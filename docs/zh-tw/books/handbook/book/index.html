<!doctype html><html class=theme-light lang=zh-tw><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/zh-tw/books/handbook/book/><title>FreeBSD 使用手冊 | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="FreeBSD 使用手冊"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="zh-tw"><meta property="og:url" content="http://172.16.201.134:1313/zh-tw/books/handbook/book/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/zh-tw\/books\/handbook\/book\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/zh-tw>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books>Books</a></li><li><a href=http://172.16.201.134:1313/zh-tw/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/zh-tw/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=zh-tw>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>FreeBSD 使用手冊</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2020 The FreeBSD Documentation Project</div><div class=legalnotice><a id=trademarks></a><details><summary>註冊商標</summary><p>FreeBSD 是 FreeBSD 基金會的註冊商標。</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390 以及 ThinkPad 是 International Business Machines Corporation 在美國和其他國家的商標。</p><p>IEEE, POSIX 以及 802 是 Institute of Electrical and Electronics Engineers, Inc. 在美國的註冊商標。</p><p>Red Hat, RPM, 是 Red Hat, Inc. 在美國和其他國家的註冊商標。</p><p>3Com 和 HomeConnect 是 3Com Corporation 的註冊商標。</p><p>Adobe, Acrobat, Acrobat Reader, Flash 以及 PostScript 是 Adobe Systems Incorporated 在美國和/或其他國家的商標或註冊商標。</p><p>Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime 以及 TrueType 是 Apple Inc. 在美國以及其他國家的註冊商標。</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium 以及 Xeon 是 Intel Corporation 及其分支機構在美國和其他國家的商標或註冊商標。</p><p>Linux 是 Linus Torvalds 的註冊商標。</p><p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media 以及 Windows NT 是 Microsoft Corporation 在美國和/或其他國家的商標或註冊商標。</p><p>Motif, OSF/1, 和 UNIX 是 The Open Group 在美國和其他國家的註冊商標； IT DialTone 和 The Open Group 是其商標。</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS 以及 VirtualBox 是 Sun Microsystems, Inc. 在美國和其他國家的商標或註冊商標。</p><p>RealNetworks, RealPlayer, 和 RealAudio 是 RealNetworks, Inc. 的註冊商標。</p><p>Oracle 是 Oracle Corporation 的註冊商標。</p><p>3ware 是 3ware Inc 的註冊商標。</p><p>ARM 是 ARM Limited. 的註冊商標。</p><p>Adaptec 是 Adaptec, Inc. 的註冊商標。</p><p>Android is a trademark of Google Inc.</p><p>Heidelberg, Helvetica, Palatino 以及 Times Roman 是 Heidelberger Druckmaschinen AG 在美國以及其他國家的商標或註冊商標。</p><p>Intuit 和 Quicken 是 Intuit Inc., 或其子公司在美國和其他國家的商標或註冊商標。</p><p>LSI Logic, AcceleRAID, eXtremeRAID, MegaRAID 和 Mylex 是 LSI Logic Corp 的商標或註冊商標。</p><p>MATLAB 是 The MathWorks, Inc. 的註冊商標。</p><p>SpeedTouch 是 Thomson 的商標。</p><p>VMware 是 VMware, Inc. 的商標。</p><p>Mathematica 是 Wolfram Research, Inc 的註冊商標。</p><p>Ogg Vorbis 和 Xiph.Org 是 Xiph.Org 的商標。</p><p>XFree86 是 The XFree86 Project, Inc 的商標。.</p><p>許多製造商和經銷商使用一些稱為商標的圖案或文字設計來區別自己的產品。 本文件中出現的眾多商標，以及 FreeBSD Project 本身廣所人知的商標，後面將以 “™” 或 “®” 符號來標示。</p></details></div><div class=toc-mobile><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#book-preface>序</a><ul><li><a href=#preface-audience>給讀者的話</a></li><li><a href=#preface-changes-from3>自第三版後的主要修訂</a></li><li><a href=#preface-changes-from2>自第二版後的主要修訂 (2004)</a></li><li><a href=#preface-changes>自第一版後的主要修訂 (2001)</a></li><li><a href=#preface-overview>本書架構</a></li><li><a href=#preface-conv>本書的編排體裁</a></li><li><a href=#preface-acknowledgements>銘謝</a></li></ul></li><li><a href=#getting-started>Part I: 入門</a><ul><li><a href=#introduction>Chapter 1. 簡介</a></li><li><a href=#bsdinstall>Chapter 2. 安裝 FreeBSD</a></li><li><a href=#basics>Chapter 3. FreeBSD 基礎</a></li><li><a href=#ports>Chapter 4. 安裝應用程式：套件與 Port</a></li><li><a href=#x11>Chapter 5. X Window 系統</a></li></ul></li><li><a href=#common-tasks>Part II: 一般作業</a><ul><li><a href=#desktop>Chapter 6. 桌面應用程式</a></li><li><a href=#multimedia>Chapter 7. 多媒體</a></li><li><a href=#kernelconfig>Chapter 8. 設定 FreeBSD 核心</a></li><li><a href=#printing>Chapter 9. 列印</a></li><li><a href=#linuxemu>Chapter 10. Linux® Binary 相容性</a></li></ul></li><li><a href=#system-administration>Part III: 系統管理</a><ul><li><a href=#config-tuning>Chapter 11. 設定與調校</a></li><li><a href=#boot>Chapter 12. FreeBSD 開機程序</a></li><li><a href=#security>Chapter 13. 安全性</a></li><li><a href=#jails>Chapter 14. Jail</a></li><li><a href=#mac>Chapter 15. 強制存取控制 (MAC)</a></li><li><a href=#audit>Chapter 16. 安全事件稽查</a></li><li><a href=#disks>Chapter 17. 儲存設備</a></li><li><a href=#geom>Chapter 18. GEOM: 模組化磁碟轉換框架</a></li><li><a href=#zfs>Chapter 19. Z 檔案系統 (ZFS)</a></li><li><a href=#filesystems>Chapter 20. 其他檔案系統</a></li><li><a href=#virtualization>Chapter 21. 虛擬化</a></li><li><a href=#l10n>Chapter 22. 在地化 - i18n/L10n 使用與安裝</a></li><li><a href=#updating-upgrading>Chapter 23. 更新與升級 FreeBSD</a></li><li><a href=#dtrace>Chapter 24. DTrace</a></li><li><a href=#usb-device-mode>Chapter 25. USB Device Mode / USB OTG</a></li></ul></li><li><a href=#network-communication>Part IV: 網路通訊</a><ul><li><a href=#serialcomms>Chapter 26. 序列通訊</a></li><li><a href=#ppp-and-slip>Chapter 27. PPP</a></li><li><a href=#mail>Chapter 28. 電子郵件</a></li><li><a href=#network-servers>Chapter 29. 網路伺服器</a></li><li><a href=#firewalls>Chapter 30. 防火牆</a></li><li><a href=#advanced-networking>Chapter 31. 進階網路設定</a></li></ul></li><li><a href=#appendices>Part V: 附錄</a><ul><li><a href=#mirrors>附錄 A: 取得 FreeBSD</a></li><li><a href=#bibliography>附錄 B: 參考書目</a></li><li><a href=#eresources>附錄 C: 網路資源</a></li><li><a href=#pgpkeys>附錄 D: OpenPGP 金鑰</a></li></ul></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class="quoteblock abstract abstract-title"><blockquote>摘要</blockquote></div><div class=paragraph><p>歡迎使用 FreeBSD！ 本使用手冊涵蓋範圍包括了 <em>FreeBSD 14.0-RELEASE, 13.2-RELEASE</em> 與 <em>FreeBSD 12.4-RELEASE</em> 的安裝與平日操作的說明。 這份使用手冊是很多人的集體創作，而且仍然『持續不斷』的進行中，因此部份章節可能尚未仍未完成，如果您有興趣協助本計畫的話，請寄電子郵件至 <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD documentation project 郵遞論壇</a>[FreeBSD 文件專案郵遞論壇]。</p></div><div class=paragraph><p>在 <a href=https://www.FreeBSD.org/>FreeBSD 網站</a> 可以找到本手冊的最新版本，舊版文件可從 <a href=https://docs.FreeBSD.org/doc/>https://docs.FreeBSD.org/doc/</a> 取得。本文件也提供各種格式與不同壓縮方式的版本可自 <a href=https://download.freebsd.org/doc/>FreeBSD 下載伺服器</a> 或是其中一個 <a href=./mirrors#mirrors>鏡像網站</a> 下載。 此外，您可在 <a href=https://www.FreeBSD.org/search/>搜尋頁面</a> 中搜尋本文件或其他文件的資料。</p></div><hr></div></div><div class=sect1><h2 id=book-preface>序<a class=anchor href=#book-preface></a></h2><div class=sectionbody><div class=sect2><h3 id=preface-audience>給讀者的話<a class=anchor href=#preface-audience></a></h3><div class=paragraph><p>若您是第一次接觸 FreeBSD 的新手，可以在本書第一部分找到 FreeBSD 的安裝程序，同時會逐步介紹 UNIX™ 的基礎概念與一些常用、共通的東西。而閱讀這部分並不難，只需要您有探索的精神和接受新概念。</p></div><div class=paragraph><p>讀完這些之後，手冊中的第二部分花很長篇幅介紹的各種廣泛主題，相當值得系統管理者去注意。 在閱讀這些章節的內容時所需要的背景知識，都註釋在該章的大綱裡面，若不熟的話，可在閱讀前先預習一番。</p></div><div class=paragraph><p>延伸閱讀方面，可參閱 <a href=./#bibliography>參考書目</a>。</p></div></div><div class=sect2><h3 id=preface-changes-from3>自第三版後的主要修訂<a class=anchor href=#preface-changes-from3></a></h3><div class=paragraph><p>您目前看到的這本手冊代表著上百位貢獻者歷時 10 年所累積的心血之作。以下為自 2014 年發佈的兩冊第三版後所做的主要修訂：</p></div><div class=ulist><ul><li><p><a href=./#dtrace>DTrace</a> 增加說明有關強大的 DTrace 效能分析工具的資訊。</p></li><li><p><a href=./#filesystems>其他檔案系統</a> 增加有關 FreeBSD 非原生檔案系統的資訊，如：來自 Sun™ 的 ZSF。</p></li><li><p><a href=./#audit>安全事件稽查</a> 增加的內容涵蓋 FreeBSD 的新稽查功能及其使用說明。</p></li><li><p><a href=./#virtualization>虛擬化</a> 增加有關在虛擬化軟體安裝 FreeBSD 的資訊。</p></li><li><p><a href=./#bsdinstall>安裝 FreeBSD</a> 增加的內容涵蓋使用新安裝工具 bsdinstall 來安裝 FreeBSD。</p></li></ul></div></div><div class=sect2><h3 id=preface-changes-from2>自第二版後的主要修訂 (2004)<a class=anchor href=#preface-changes-from2></a></h3><div class=paragraph><p>您目前看到的這本手冊第三版是 FreeBSD 文件計劃的成員歷時兩年完成的心血之作。因文件內容成長到一定大小，印刷版需要分成兩冊發佈。新版的主要修訂部分如下：</p></div><div class=ulist><ul><li><p><a href=./#config-tuning>設定與調校</a> 已針對新內容作更新，如：ACPI 電源管理、<code>cron</code> 以及其他更多的核心調校選項說明內容。</p></li><li><p><a href=./#security>安全性</a> 增加了虛擬私人網路 (VPN)、檔案系統的存取控制 (ACL)，以及安全報告。</p></li><li><p><a href=./#mac>強制存取控制 (MAC)</a> 是此版本新增的章節。該章介紹：什麼是 MAC 機制？以及如何運用它來使您的 FreeBSD 系統更安全。</p></li><li><p><a href=./#disks>儲存設備</a> 新增了像是：USB 隨身碟、檔案系統快照 (Snapshot)、檔案系統配額 (Quota) 、檔案與網路為基礎的檔案系統、以及如何對硬碟分割區作加密等詳解。</p></li><li><p><a href=./#ppp-and-slip>PPP</a> 增加了疑難排解的章節。</p></li><li><p><a href=./#mail>電子郵件</a> 新增有關如何使用其它的傳輸代理程式、SMTP 認證、UUCP、fetchmail、procmail 的運用以及其它進階主題。</p></li><li><p><a href=./#network-servers>網路伺服器</a> 是該版中全新的一章。這一章介紹了如何架設 Apache HTTP 伺服器、ftpd 以及用於支援 Microsoft™Windows™ 客戶端的 Samba。其中有些段落來自原先的 <a href=./#advanced-networking>進階網路設定</a> 。</p></li><li><p><a href=./#advanced-networking>進階網路設定</a> 新增有關在 FreeBSD 中使用藍牙™裝置、設定無線網路以及使用非同步傳輸模式 (Asynchronous Transfer Mode, ATM) 網路的介紹。</p></li><li><p>增加詞彙表，用以說明全書中出現的術語。</p></li><li><p>重新美編書中所列的圖表。</p></li></ul></div></div><div class=sect2><h3 id=preface-changes>自第一版後的主要修訂 (2001)<a class=anchor href=#preface-changes></a></h3><div class=paragraph><p>本手冊的第二版是 FreeBSD 文件計劃的成員歷時兩年完成的心血之作。第二版包的主要變動如下：</p></div><div class=ulist><ul><li><p>增加完整的目錄索引。</p></li><li><p>所有的 ASCII 圖表均改成圖檔格式的圖表。</p></li><li><p>每個章節均加入概述，以便快速的瀏覽該章節內容摘要、讀者所欲了解的部分。</p></li><li><p>內容架構重新組織成三大部分："入門"、"系統管理" 以及 "附錄"。</p></li><li><p><a href=./#basics>FreeBSD 基礎</a> 新增了程序、Daemon 以及信號 (Signal) 的介紹。</p></li><li><p><a href=./#ports>安裝應用程式：套件與 Port</a> 新增了介紹如何管理 Binary 套件的資訊。</p></li><li><p><a href=./#x11>X Window 系統</a> 經過全面改寫，著重於在 XFree86™ 4.X 上的現代桌面技術，如： KDE 和 GNOME。</p></li><li><p><a href=./#boot>FreeBSD 開機程序</a> 更新相關內容。</p></li><li><p><a href=./#disks>儲存設備</a> 分別以兩個章節 "磁碟" 與 "備份" 來撰寫。我們認為這樣子會比單一章節來得容易瞭解。還有關於 RAID (包含硬體、軟體 RAID) 的段落也新增上去了。</p></li><li><p><a href=./#serialcomms>序列通訊</a> 架構重新改寫，並更新至 FreeBSD 4.X/5.X 的內容。</p></li><li><p><a href=./#ppp-and-slip>PPP</a> 有相當程度的更新。</p></li><li><p><a href=./#advanced-networking>進階網路設定</a> 加入許多新內容。</p></li><li><p><a href=./#mail>電子郵件</a> 大量新增了設定 sendmail 的介紹。</p></li><li><p><a href=./#linuxemu>Linux® Binary 相容性</a> 增加許多有關安裝 Oracle™ 以及 SAP™ R/3™ 的介紹。</p></li><li><p>此外，第二版還新加章節，以介紹下列新主題：</p><div class=ulist><ul><li><p><a href=./#config-tuning>設定與調校</a>。</p></li><li><p><a href=./#multimedia>多媒體</a>。</p></li></ul></div></li></ul></div></div><div class=sect2><h3 id=preface-overview>本書架構<a class=anchor href=#preface-overview></a></h3><div class=paragraph><p>本書主要分為五大部分，第一部份<em>入門</em>：介紹 FreeBSD 的安裝、基本操作。 讀者可根據自己的程度，循序或者跳過一些熟悉的主題來閱讀； 第二部分<em>一般作業</em>：介紹 FreeBSD 常用功能，這部分可以不按順序來讀。 每章前面都會有概述，概述會描述本章節涵蓋的內容和讀者應該已知的， 這主要是讓讀者可以挑喜歡的章節閱讀； 第三部分<em>系統管理</em>：介紹 FreeBSD 老手所感興趣的各種主題部分； 第四部分<em>網路通訊</em>：則包括網路和各式伺服器主題；而第五部分則為附錄包含各種有關 FreeBSD 的資源。</p></div><div class=dlist><dl><dt class=hdlist1><em><a href=./#introduction>簡介</a></em></dt><dd><p>向新手介紹 FreeBSD。該篇說明了 FreeBSD 計劃的歷史、目標和開發模式。</p></dd><dt class=hdlist1><em><a href=./#bsdinstall>安裝 FreeBSD</a></em></dt><dd><p>帶領使用者走一次使用 bsdinstall 在 FreeBSD 9.<em>x</em> 及之後版本的完整安裝流程。</p></dd><dt class=hdlist1><em><a href=./#basics>FreeBSD 基礎</a></em></dt><dd><p>涵蓋 FreeBSD 作業系統的基礎指令及功能。若您熟悉 Linux™ 或其他類 UNIX® 系統，您則可跳過此章。</p></dd><dt class=hdlist1><em><a href=./#ports>安裝應用程式：套件與 Port</a></em></dt><dd><p>涵蓋如何使用 FreeBSD 獨創的 "Port 套件集" 與標準 Binary 套件安裝第三方軟體。</p></dd><dt class=hdlist1><em><a href=./#x11>X Window 系統</a></em></dt><dd><p>介紹 X Windows 系統概要及在 FreeBSD 上使用 X11，同時也會介紹常用的桌面環境如 KDE 與 GNOME。</p></dd><dt class=hdlist1><em><a href=./#desktop>桌面應用程式</a></em></dt><dd><p>列出一些常用的桌面應用程式，例如：網頁瀏覽器、辦工工具並介紹如何安裝這些應用程式到 FreeBSD。</p></dd><dt class=hdlist1><em><a href=./#multimedia>多媒體</a></em></dt><dd><p>示範如何在您的系統設定音效及影像播放支援，同時會介紹幾個代表性的音訊及視訊應用程式。</p></dd><dt class=hdlist1><em><a href=./#kernelconfig>設定 FreeBSD 核心</a></em></dt><dd><p>說明為何需要設定新的核心並會提供設定、編譯與安裝的詳細操作說明。</p></dd><dt class=hdlist1><em><a href=./#printing>列印</a></em></dt><dd><p>介紹如何在 FreeBSD 管理印表機，包含橫幅頁面、列印帳務以及初始設定等資訊。</p></dd><dt class=hdlist1><em><a href=./#linuxemu>Linux® Binary 相容性</a></em></dt><dd><p>介紹 FreeBSD 的 Linux™ 相容性功能，同時提供許多熱門的 Linux™ 應用程式詳細的安裝操作說明，例如 Oracle™ 及 Mathematica™。</p></dd><dt class=hdlist1><em><a href=./#config-tuning>設定與調校</a></em></dt><dd><p>介紹可供系統管理者用來調校 FreeBSD 系統的可用參數來最佳化效率，同時也介紹 FreeBSD 用到的各種設定檔以及到何處尋找這些設定檔。</p></dd><dt class=hdlist1><em><a href=./#boot>FreeBSD 開機程序</a></em></dt><dd><p>介紹 FreeBSD 開機流程並說明如何使用設定選項控制開機流程。</p></dd><dt class=hdlist1><em><a href=./#security>安全性</a></em></dt><dd><p>介紹許多可讓您的 FreeBSD 系統更安全的各種工具，包含 Kerberos, IPsec 及 OpenSSH。</p></dd><dt class=hdlist1><em><a href=./#jails>Jail</a></em></dt><dd><p>介紹 Jail Framework，以及 Jail 改進那些 FreeBSD 傳統 chroot 不足的地方。</p></dd><dt class=hdlist1><em><a href=./#mac>強制存取控制 (MAC)</a></em></dt><dd><p>說明什麼是強制存取控制 (Mandatory Access Control, MAC) 及這個機制如何用來確保 FreeBSD 系統的安全。</p></dd><dt class=hdlist1><em><a href=./#audit>安全事件稽查</a></em></dt><dd><p>介紹什麼事 FreeBSD 事件稽查，如何安裝與設定，以及如何檢查與監控稽查線索。</p></dd><dt class=hdlist1><em><a href=./#disks>儲存設備</a></em></dt><dd><p>介紹如何在 FreeBSD 管理儲存媒體及檔案系統，這包含了實體磁碟、RAID 陣列、光碟與磁帶媒體、記憶體為基礎的磁碟以及網路檔案系統。</p></dd><dt class=hdlist1><em><a href=./#geom>GEOM. 模組化磁碟轉換框架</a></em></dt><dd><p>介紹在 FreeBSD 中的 GEOM Framework 是什麼，以及如何設定各種支援的 RAID 階層。</p></dd><dt class=hdlist1><em><a href=./#filesystems>其他檔案系統</a></em></dt><dd><p>查看 FreeBSD 還支援那些非原生檔案系統，如 Sun™ 的 Z 檔案系統。</p></dd><dt class=hdlist1><em><a href=./#virtualization>虛擬化</a></em></dt><dd><p>介紹虛擬化系統提供了那些功能，以及如何在 FreeBSD 上使用。</p></dd><dt class=hdlist1><em><a href=./#l10n>在地化 - i18n/L10n 使用與安裝</a></em></dt><dd><p>介紹如何在 FreeBSD 使用非英文的語言，這涵蓋了系統及應用層的在地化。</p></dd><dt class=hdlist1><em><a href=./#updating-upgrading>更新與升級 FreeBSD</a></em></dt><dd><p>說明 FreeBSD-STABLE、FreeBSD-CURRENT 以及 FreeBSD 發佈版之間的差異，並介紹那些使用者適何追蹤開發系統以及程序的概述，這涵蓋了使用者更新系統到最新安全性發佈版本的方法。</p></dd><dt class=hdlist1><em><a href=./#dtrace>DTrace</a></em></dt><dd><p>介紹如何在 FreeBSD 設定及使用 Sun™ 的 DTrace 工具，動態追蹤可以透過執行真實時間系統分析來協助定位效能問題。</p></dd><dt class=hdlist1><em><a href=./#serialcomms>序列通訊</a></em></dt><dd><p>介紹如何使用撥入及撥出連線到您的 FreeBSD 系統的終端機與數據機。</p></dd><dt class=hdlist1><em><a href=./#ppp-and-slip>PPP</a></em></dt><dd><p>介紹如何在 FreeBSD 使用 PPP 來連線遠端的系統。</p></dd><dt class=hdlist1><em><a href=./#mail>電子郵件</a></em></dt><dd><p>說明組成電子郵件伺服器的各種元件，並深入說明如何設定最熱門的郵件伺服器軟體：sendmail。</p></dd><dt class=hdlist1><em><a href=./#network-servers>網路伺服器</a></em></dt><dd><p>提供詳細的操作說明與範例設定檔，讓您可安裝您的 FreeBSD 機器為網路檔案伺服器、網域名稱伺服器、網路資訊系統伺服器或時間同步伺服器。</p></dd><dt class=hdlist1><em><a href=./#firewalls>防火牆</a></em></dt><dd><p>說明軟體為基礎的防火牆背後的理念，並提供可用於 FreeBSD 中不同的防火牆設定的詳細資訊。</p></dd><dt class=hdlist1><em><a href=./#advanced-networking>進階網路設定</a></em></dt><dd><p>介紹許多網路主題，包含在您的區域網路 (LAN) 分享網際網路連線給其他電腦、進階路由主題、無線網路、Bluetooth™、ATM、IPv6 以及更多相關主題。</p></dd><dt class=hdlist1><em><a href=./#mirrors>取得 FreeBSD</a></em></dt><dd><p>列出取得 FreeBSD CDROM 或 DVD 媒體的各種來源，以及在網際網路上的各種網站，讓您可以下載並安裝 FreeBSD。</p></dd><dt class=hdlist1><em><a href=./#bibliography>參考書目</a></em></dt><dd><p>本書觸及許多不同主題，可能會讓您想更深入的了解，參考書目列出了在文中引用的許多優秀書籍。</p></dd><dt class=hdlist1><em><a href=./#eresources>網路資源</a></em></dt><dd><p>介紹了可讓 FreeBSD 使用者提出問題以及參與有關 FreeBSD 技術會談的許多論壇。</p></dd><dt class=hdlist1><em><a href=./#pgpkeys>OpenPGP 金鑰</a></em></dt><dd><p>列出了數個 FreeBSD 開發人員的 PGP 指紋。</p></dd></dl></div></div><div class=sect2><h3 id=preface-conv>本書的編排體裁<a class=anchor href=#preface-conv></a></h3><div class=paragraph><p>為了提供有一致性且易於閱讀的內容，以下是一些本書所遵循的編排體裁。</p></div><div class=sect3><h4 id=preface-conv-typographic>文字編排體裁<a class=anchor href=#preface-conv-typographic></a></h4><div class=dlist><dl><dt class=hdlist1><em>斜體字</em></dt><dd><p><em>斜體字</em>用於：檔名、目錄、網址 (URL)、 強調語氣、以及第一次提及的技術詞彙。</p></dd><dt class=hdlist1><code>等寬字</code></dt><dd><p><code>等寬字</code>用於： 錯誤訊息、指令、環境變數、Port 名稱、主機名稱、帳號、群組、裝置名稱、變數、程式碼等。</p></dd><dt class=hdlist1>粗體字</dt><dd><p>以<kbd>粗體字</kbd>表示：應用程式、指令、按鍵。</p></dd></dl></div></div><div class=sect3><h4 id=preface-conv-commands>使用者輸入<a class=anchor href=#preface-conv-commands></a></h4><div class=paragraph><p>鍵盤輸入以<strong>粗體字</strong>表示，以便與一般文字做區隔。 組合鍵是指同時按下一些按鍵，我們以 <code>+</code> 來表示連接，像是：</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></span></p></div><div class=paragraph><p>是說，一起按 <kbd>Ctrl</kbd>、 <kbd>Alt</kbd> 以及 <kbd>Del</kbd> 鍵。</p></div><div class=paragraph><p>若要逐一按鍵，那麼會以逗號 (,) 來表示，像是：</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>, <span class=keyseq><kbd>Ctrl</kbd>+<kbd>S</kbd></span></p></div><div class=paragraph><p>是說：先同時按下 <kbd>Ctrl</kbd> 與 <kbd>X</kbd> 鍵， 然後放開後再同時按 <kbd>Ctrl</kbd> 與 <kbd>S</kbd> 鍵。</p></div></div><div class=sect3><h4 id=preface-conv-examples>範例<a class=anchor href=#preface-conv-examples></a></h4><div class=paragraph><p>範例以 <span class=filename>C:\></span> 為開頭代表 MS-DOS™ 的指令。 若沒有特殊情況的話，這些指令應該是在 Microsoft™ Windows™ 環境的 "指令提示字元 (Command Prompt)" 視窗內執行。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>E:<span class=se>\&gt;</span> tools<span class=se>\f</span>dimage floppies<span class=se>\k</span>ern.flp A:</code></pre></div></div><div class=paragraph><p>範例以 <code>#</code> 為開頭代表在 FreeBSD 中以超級使用者權限來執行的指令。 你可以先以 <code>root</code> 登入系統並下指令，或是以你自己的帳號登入再使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 來取得超級使用者權限。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=kern.flp of=/dev/fd0</span></code></pre></div></div><div class=paragraph><p>範例以 <code>%</code> 為開頭代表在 FreeBSD 中以一般使用者帳號執行的指令。 除非有提到其他用法，否則都是預設為 C-shell 語法，用來設定環境變數以及下其他指令的意思。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top</code></pre></div></div></div></div><div class=sect2><h3 id=preface-acknowledgements>銘謝<a class=anchor href=#preface-acknowledgements></a></h3><div class=paragraph><p>您所看到的這本書是經過數百個分散在世界各地的人所努力而來的結果。 無論他們只是糾正一些錯誤或提交完整的章節，所有的點滴貢獻都是非常寶貴有用的。</p></div><div class=paragraph><p>也有一些公司透過提供資金讓作者專注於撰稿、提供出版資金等模式來支持文件的寫作。 其中，BSDi (之後併入 <a href=http://www.windriver.com>Wind River Systems</a>) 資助 FreeBSD 文件計劃成員來專職改善這本書直到 2000 年 3 月第一版的出版。(ISBN 1-57176-241-8) Wind River Systems 同時資助其他作者來對輸出架構做很多改進，以及給文章增加一些附加章節。這項工作結束於 2001 年 11 月第二版。(ISBN 1-57176-303-1) 在 2003-2004 兩年中，<a href=http://www.freebsdmall.com>FreeBSD Mall, Inc</a> 把報酬支付給改進這本手冊以使第三版印刷版本能夠出版的志工。</p></div><div class=paragraph><p>這部份是提供給初次使用 FreeBSD 的使用者和系統管理者。 這些章節包括：</p></div><div class=ulist><ul><li><p>介紹 FreeBSD 給您。</p></li><li><p>在安裝過程給您指引。</p></li><li><p>教您 UNIX™ 的基礎及原理。</p></li><li><p>展示給您看如何安裝豐富的 FreeBSD 的應用軟體。</p></li><li><p>向您介紹 X，UNIX™ 的視窗系統以及詳細的桌面環境設定，讓您更有生產力。</p></li></ul></div><div class=paragraph><p>我們試著儘可能的讓這段文字的參考連結數目降到最低，讓您在讀使用手冊的這部份時可以不太需要常常前後翻頁。</p></div></div></div></div><h1 id=getting-started class=sect0>Part I: 入門<a class=anchor href=#getting-started></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>這部份是提供給初次使用 FreeBSD 的使用者和系統管理者。 這些章節包括：</p></div><div class=ulist><ul><li><p>介紹 FreeBSD 給您。</p></li><li><p>在安裝過程給您指引。</p></li><li><p>教您 UNIX® 的基礎及原理。</p></li><li><p>展示給您看如何安裝豐富的 FreeBSD 的應用軟體。</p></li><li><p>向您介紹 X，UNIX® 的視窗系統以及詳細的桌面環境設定，讓您更有生產力。</p></li></ul></div><div class=paragraph><p>我們試著儘可能的讓這段文字的參考連結數目降到最低，讓您在讀使用手冊的這部份時可以不太需要常常前後翻頁。</p></div></div></div><div class=sect1><h2 id=introduction>Chapter 1. 簡介<a class=anchor href=#introduction></a></h2><div class=sectionbody><div class=sect2><h3 id=introduction-synopsis>1.1. 概述<a class=anchor href=#introduction-synopsis></a></h3><div class=paragraph><p>非常感謝您對 FreeBSD 感興趣！以下章節涵蓋 FreeBSD 計劃的各方面：比如它的歷史、目標、開發模式等等。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>FreeBSD 與其他作業系統之間的關係。</p></li><li><p>FreeBSD 計劃的歷史。</p></li><li><p>FreeBSD 計劃的目標。</p></li><li><p>FreeBSD 開源開發模式的基礎概念。</p></li><li><p>當然囉，還有 "FreeBSD" 這名字的由來。</p></li></ul></div></div><div class=sect2><h3 id=nutshell>1.2. 歡迎使用 FreeBSD！<a class=anchor href=#nutshell></a></h3><div class=paragraph><p>FreeBSD 是一套開源、符合標準的類 Unix 的作業系統，適用於 x86 (32 與 64 位元), ARM™, AArch64, RISC-V™, MIPS™, POWER™, PowerPC™ 以及 Sun UltraSPARC™ 的電腦。它提供了現代作業系統所應具備的所有功能，例如：先佔式多工、記憶體保護、虛擬記憶體、多使用者架構、對稱多工處理 (SMP)、各種針對不同語言和框架的開源開發工具以及以 X Window 系統、KDE 及 GNOME 為主的桌面功能，而它有以下優勢：</p></div><div class=ulist><ul><li><p><em>自由的開放原始碼授權</em>，授予您自由修改和擴充其原始碼並將其合併到開放原始碼專案或封閉的產品中的權力，不會對 Copyleft 授權施加典型的限制，也避免了授權不相容的潛在問題。</p></li><li><p><em>強大的 TCP/IP 網路</em> - FreeBSD 以工業標準實作通訊協定並不斷改善效能與擴展性，這使得 FreeBSD 非常適合應用在伺服器、路由器/防火牆的角色 - 這也是許多公司和供應商使用它的原因。</p></li><li><p><em>完全整合 OpenZFS</em>，包含 root-on-ZFS、ZFS 開機環境、故障管理、委託管理、對 Jail 的支援、FreeBSD 專屬的文件以及系統安裝程式的支援。</p></li><li><p><em>鉅細靡遺的安全性功能</em>，從強制存取控制 (Mandatory Access Control, MAC) 框架到 Capsicum 功能以及沙盒機制。</p></li><li><p><em>超過 3 萬個預編的套件</em>供所有支援的架構以及可簡單編譯依您的需求所客製的 Port 套件集。</p></li><li><p><em>說明文件</em> - 除了操作手冊及由許多作者著作從系統管理到核心內部主題的書籍外，也有不僅只針對 Userspace Daemon、工具及設定檔，同樣也有針對核心驅動程式 APIs (第 9 節) 及各別驅動程式 (第 4 節) 的操作說明頁 (<a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> page)。</p></li><li><p><em>簡單且具一致性的檔案庫架構與編譯系統</em> - FreeBSD 對所有的元件、核心與 Userspace 使用單一的檔案庫，加上統一、易於客製的編譯系統以及嚴謹的開發流程，讓 FreeBSD 的編譯基礎架構更容易與您產品的整合。</p></li><li><p><em>忠於 Unix 哲學</em>，偏好可組合而非具寫死的 "多合一" 單一 Daemon。</p></li><li><p><em>Linux 執行檔 (Binary) 相容性</em>，無需虛擬化即可執行許多 Linux 執行檔。</p></li></ul></div><div class=paragraph><p>FreeBSD 系統是基於美國加州大學柏克萊分校的電腦系統研究組 (Computer Systems Research Group 也就是 CSRG) 所發行的 4.4BSD-Lite，繼承了 BSD 系統開發的優良傳統。 除了由 CSRG 所提供的高品質的成果外，FreeBSD 計劃也投入了上千人時在擴充及微調，來讓系統在真實情境下能達到最大的效能與可靠性。 FreeBSD 提供了其他開源與商業產品的效能及穩定性，並結合其他產品所沒有的尖端功能。</p></div><div class=sect3><h4 id=os-overview>1.2.1. FreeBSD 能做什麼？<a class=anchor href=#os-overview></a></h4><div class=paragraph><p>FreeBSD 能應用的情境完全限制在你的想像力上。 從軟體開發到工廠自動化，庫存管控到遠程衛星天線的方位角校正；若您的需求可以用商用的 UNIX™ 產品來達成，那麼極有可能使用 FreeBSD 也能辦到！ FreeBSD 也受益於來自於全球各研究中心及大學所開發的數千個高品質的軟體 ，這些通常只需要花費很少的費用或根本就是免費的。</p></div><div class=paragraph><p>由於每個人都可以取得 FreeBSD 的原始程式碼， 這個系統可以被量身訂做成能執行任何原本完全無法想像的功能或計劃， 而對於從各廠商取得的作業系統通常沒有辦法這樣地被修改。 以下提供一些人們使用 FreeBSD 的例子：</p></div><div class=ulist><ul><li><p><em>網際網路服務：</em> FreeBSD 內建強勁的網路功能使它成為網路服務 (如下例) 的理想平台：</p><div class=ulist><ul><li><p>網頁伺服器</p></li><li><p>IPv4 及 IPv6 路由</p></li><li><p>防火牆以及 NAT ("IP 偽裝") 通訊閘</p></li><li><p>檔案傳輸協定伺服器</p></li><li><p>電子郵件伺服器</p></li><li><p>還有更多…​</p></li></ul></div></li><li><p><em>教育：</em>您是電腦科學相關領域的學生嗎？再也沒有比使用 FreeBSD 能學到更多作業系統、計算機結構、及網路的方法了。其中許多免費提供的 CAD，數學和圖形設計套件對於那些需要在電腦完成 <em>其他</em> 工作的人也非常有用！</p></li><li><p><em>研究：</em>有了完整的原始程式碼，FreeBSD 是研究作業系統及電腦科學的極佳環境。 具有免費且自由取得特性的 FreeBSD 也使得一個分置兩地的合作計劃，不必擔心版權及系統開放性的問題， 而能自在的交流。</p></li><li><p><em>網路：</em> 你如果需要 路由器、名稱伺服器 (DNS) 或安全的防火牆， FreeBSD 可以輕易的將你沒有用到的 386 或 486 PC 變身成為絕佳的伺服器，甚至具有過濾封包的功能。</p></li><li><p><em>嵌入式：</em> FreeBSD 是一套可用來建立嵌入式系統的傑出平台。 支援 ARM™, MIPS™ 以及 PowerPC™ 平台，再加上健全的網路環境、尖端的功能以及自由的 <a href=https://docs.freebsd.org/en/books/faq/#bsd-license-restrictions>BSD 授權條款</a>，FreeBSD 成為用來建置嵌入式路由器、防火牆及其他裝置的絕佳基礎。</p></li><li><p><em>桌面:</em> FreeBSD 同時也是低成本桌面解決方案中不錯的選擇，使用了免費的 X11 伺服器。FreeBSD 提供許多開源桌面環境可選擇，包含了標準 GNOME 及 KDE 圖型化使用者介面。FreeBSD 甚至可以透過中央伺服器做 "無磁碟" 開機，讓個人工作站變的更便宜、更易於管理。</p></li><li><p><em>軟體開發：</em> 基本安裝的 FreeBSD 就包含了完整的程式開發工具，如 C/C++ 編譯器及除錯器。 透過 Port 與套件管理系統也可支援需多其他語言。</p></li></ul></div><div class=paragraph><p>你可以經由燒錄 CD-ROM、DVD 或是從 FTP 站上抓回 FreeBSD。 詳情請參閱 <a href=./#mirrors>取得 FreeBSD</a> 取得 FreeBSD。</p></div></div><div class=sect3><h4 id=introduction-nutshell-users>1.2.2. 誰在用 FreeBSD？<a class=anchor href=#introduction-nutshell-users></a></h4><div class=paragraph><p>FreeBSD 以其網頁 (Web) 服務功能而聞名 - 在 FreeBSD 上運作的網站包括 <a href=https://news.ycombinator.com/>Hacker News</a>, <a href=http://www.netcraft.com/>Netcraft</a>, <a href=http://www.163.com/>NetEase</a>, <a href=https://signup.netflix.com/openconnect>Netflix</a>, <a href=http://www.sina.com/>Sina</a>, <a href=http://www.sony.co.jp/>Sony Japan</a>, <a href=http://www.rambler.ru/>Rambler</a>, <a href=http://www.yahoo.com/>Yahoo!</a> 及 <a href=http://www.yandex.ru/>Yandex</a>。</p></div><div class=paragraph><p>FreeBSD 先進的功能、成熟的安全性、可預測的發佈週期以及自由的授權條款，讓 FreeBSD 已經被用來做為建立許多商業、開源應用、裝置以及產品的平台，有許多世界上最大的資訊公司使用 FreeBSD：</p></div><div class=ulist><ul><li><p><a href=http://www.apache.org/>Apache</a> - Apache 軟體基金會中大部分面對大眾的基礎設施，包括可能是世界上最大的 SVN 檔案庫 (擁有超過 140 萬次提交) 都是在 FreeBSD 上運作。</p></li><li><p><a href=http://www.apple.com/>Apple</a> - OS X 大量借鑒 FreeBSD 的網路 Stack、虛擬檔案系統以及許多使用者空間的元件。Apple iOS 中含有從 FreeBSD 借鑒來的元素。</p></li><li><p><a href=http://www.cisco.com/>Cisco</a> - IronPort 網路安全及反垃圾郵件設備是採用改良後 FreeBSD 核心來運作。</p></li><li><p><a href=http://www.citrix.com/>Citrix</a> - 安全設備的 NetScaler 產品線提供的第 4-7 層的負載均衡、內容快取、應用層防火牆、安全的 VPN 以及行動雲端網路存取，皆運用了 FreeBSD Shell 強大的功能。</p></li><li><p><a href=https://www.emc.com/isilon>Dell EMC Isilon</a> - Isilon 的企業存儲設備是以 FreeBSD 為基礎。非常自由的 FreeBSD 授權條款讓 Isilon 整合了它們的智慧財產到整個核心，並專注打造自己的產品，而不是一個作業系統。</p></li><li><p><a href=http://www.quest.com/KACE>Quest KACE</a> - KACE 系統管理設備中運作了 FreeBSD，是因為 FreeBSD 的可靠性、可擴展性以及支持其持續發展的社群。</p></li><li><p><a href=http://www.ixsystems.com/>iXsystems</a> - 統合存儲 (Unified Storage) 設備的 TrueNAS 產品線是以 FreeBSD 為基礎。除了該公司自己的商業產品外，iXsystems 也管理著 TrueOS 和 FreeNAS 兩個開源計劃的開發。</p></li><li><p><a href=http://www.juniper.net/>Juniper</a> - JunOS 作業系統驅動了所有的 Juniper 網絡設備 (包括路由器，交換器，安全與網絡設備) 便是以 FreeBSD 為基礎。Juniper 在眾多廠商之中，展現了計劃與商業產品供應商之間的共生關係。由 Juniper 所開發的改進內容會回饋給 FreeBSD 來降低未來新功能從 FreeBSD 整合回 JunOS 的複雜性。</p></li><li><p><a href=http://www.mcafee.com/>McAfee</a> - SecurOS 是 McAfee 企業防火牆產品的基礎，其中包含了 Sidewinder ，也是以 FreeBSD 為基礎。</p></li><li><p><a href=http://www.netapp.com/>NetApp</a> - 存儲設備中的 Data ONTAP GX 產品線是以 FreeBSD 為基礎。除此之外，NetApp 還貢獻了回 FreeBSD 許多功能，包括新 BSD 條款授權的 hypervisor, bhyve。</p></li><li><p><a href=http://www.netflix.com/>Netflix</a> - Netflix 用來以串流傳送電影到客戶的 OpenConnect 設備是以 FreeBSD 為基礎。 Netflix 也做了大量貢獻到程式碼庫，並致力於維持與主線 FreeBSD 的零修正關係。Netflix 的 OpenConnect 設備負責了北美所有的網路流量 32％ 以上。</p></li><li><p><a href=http://www.sandvine.com/>Sandvine</a> - Sandvine 使用 FreeBSD 作為它的高性能即時網路處理平台的基礎來建立它們的智慧網路策略控制產品。</p></li><li><p><a href=http://www.sony.com/>Sony</a> - PlayStation 4 遊戲主機使用了修改過的 FreeBSD 版本來運作。</p></li><li><p><a href=http://www.sophos.com/>Sophos</a> - Sophos 電子郵件設備產品是以加強防護 (Hardened) 的 FreeBSD 為基礎，可掃描入站郵件中的垃圾郵件和病毒，同時也可監控出站郵件中的惡意軟體及敏感資訊。</p></li><li><p><a href=http://www.spectralogic.com/>Spectra Logic</a> - 儲藏級儲存設備的 nTier 產品線以 FreeBSD 和 OpenZFS 來運作。</p></li><li><p><a href=https://www.stormshield.eu>Stormshield</a> - Stormshield 網路安全設備使用了硬體化版本的 FreeBSD 做為基礎，BSD 授權條款讓他們可將其智慧財產與系統整合並同時回饋大量有趣的發展給社群。</p></li><li><p><a href=http://www.weather.com/>The Weather Channel</a> - 被安裝在各地有線電視營運商前端，負責加入當地天氣預報到有線電視網路節目的 IntelliStar 設備便是使用 FreeBSD。</p></li><li><p><a href=http://www.verisign.com/>Verisign</a> - VeriSign 主要經營 .com 與 .net 根網域名稱註冊業務以及隨附的 DNS 基礎設施運作。這些基礎設施的運作仰賴各種不同的網路作業系統包括 FreeBSD 來確保不會有單點故障的問題。</p></li><li><p><a href=http://www.voxer.com/>Voxer</a> - Voxer 使用了 FreeBSD 的 ZFS 來驅動行動語音通訊平台，讓 Voxer 從 Solaris 改使用 FreeBSD 的原因是 FreeBSD 擁有詳盡的文件、更大型且活躍的社群、較便利的開發人員環境。除了提供關鍵的 ZFS 和 DTrace 功能之外 FreeBSD 的 ZFS 也支援了 TRIM。</p></li><li><p><a href=http://www.whatsapp.com/>WhatsApp</a> - 當 WhatsApp 面臨需要一個每台伺服器能夠同時處理超過 100 萬個 TCP 連線的平台時，它們選擇了 FreeBSD。它們接著擴大規模到每台伺服器處理超過 250 萬的連線。</p></li><li><p><a href=http://wheelsystems.com/>Wheel Systems</a> - FUDO 安全性設備讓企業可以監控、控制、記錄以及稽查在其系統中作業的承包商與管理員。這些功能皆是以 FreeBSD 最佳的安全性功能為基礎，包括 ZFS, GELI, Capsicum, HAST 及 auditdistd。</p></li></ul></div><div class=paragraph><p>FreeBSD 也催生了數個相關的開源計劃：</p></div><div class=ulist><ul><li><p><a href=http://bsdrp.net/>BSD Router</a> - 以 FreeBSD 為基礎的大型企業路由器替代方案，專門設計為可在標準 PC 硬體上運作。</p></li><li><p><a href=http://www.freenas.org/>FreeNAS</a> - 專為網路檔案伺服器設備使用所設計的 FreeBSD。提供了以 Python 為基礎的網頁介面來簡化 UFS 與 ZFS 檔案系統的管理，支援了 NFS、SMB/ CIFS、AFP、FTP 與 iSCSI，還有以 FreeBSD Jail 為基礎的套件系統。</p></li><li><p><a href=http://www.ghostbsd.org/>GhostBSD</a> - 採用 Gnome 桌面環境的 FreeBSD 發行版。</p></li><li><p><a href=http://mfsbsd.vx.sk/>mfsBSD</a> - 用來建置可完全從記憶體執行 FreeBSD 系統映像檔工具。</p></li><li><p><a href=http://www.nas4free.org/>NAS4Free</a> - 以 FreeBSD 及 PHP 驅動網頁介面為基礎的檔案伺服器。</p></li><li><p><a href=http://www.opnsense.org/>OPNSense</a> - OPNsense 是一個以 FreeBSD 為基礎的開源、易於使用及易於建置的防火牆和路由平台。OPNsense 有大多數在昂貴的商業防火牆上才有的功能。它帶來了商業產品的豐富功能集，同時擁有開放和安全的來源。</p></li><li><p><a href=https://www.trueos.org>TrueOS</a> - 訂製版本的 FreeBSD，裝備了給桌面使用者使用的圖型化工具來展示 FreeBSD 強大的功能給所有使用者，專門設計來緩解使用者在 Windows 與 OS X 間的過渡。</p></li><li><p><a href=http://www.pfsense.org/>pfSense</a> - 以 FreeBSD 為基礎的防火牆發行版，支援巨型陣列及大規模 IPv6。</p></li><li><p><a href=http://zrouter.org/>ZRouter</a> - 嵌入式裝置韌體的開源替代方案，以 FreeBSD 為基礎，專門設計來取代現成路由器上的專用韌體。</p></li></ul></div><div class=paragraph><p>在 FreeBSD 基金會網站上可以找到<a href=https://www.freebsdfoundation.org/about/testimonials/>以 FreeBSD 為基礎的產品與服務的公司的推薦</a> 清單。 Wikipedia 也維護了一份<a href=https://en.wikipedia.org/wiki/List_of_products_based_on_FreeBSD>以 FreeBSD 為基礎的產品清單</a>。</p></div></div></div><div class=sect2><h3 id=history>1.3. 關於 FreeBSD 計劃<a class=anchor href=#history></a></h3><div class=paragraph><p>接下來講的是 FreeBSD 計劃的背景，包含歷史、計劃目標以及開發模式。</p></div><div class=sect3><h4 id=intro-history>1.3.1. FreeBSD 歷史簡介<a class=anchor href=#intro-history></a></h4><div class=paragraph><p>FreeBSD 計畫起源於 1993 年初， 那是源自於維護一組『非官方 386BSD 修正工具』計劃的最後三個協調人 Nate Williams，Rod Grimes 和 Jordan Hubbard。</p></div><div class=paragraph><p>最初的目標是做出一份 386BSD 的中間版本的快照 (Snapshot) 來修正使用修正工具 (Patchkit) 機制無法解決的數個問題，也因此早期的計劃名稱叫做 386BSD 0.5 或 386BSD Interim 便是這個原因。</p></div><div class=paragraph><p>386BSD 是 Bill Jolitz 的作業系統，在當時就已經忍受了將近一年的忽視，隨著修正工具日漸龐大的令人不舒服，他們決定提供一份過渡性的 "簡潔" 快照來幫助 Bill。 然而，由於 Bill Jolitz 忽然決定取消其對該計劃的認可，且沒有明確指出未來的打算，所以該計劃便突然面臨中止。</p></div><div class=paragraph><p>這三人認為這個目標即始沒有 Bill 的支持仍有保留的價值，最後他們採用 David Greenman 丟銅板決定的名字，也就是 "FreeBSD"。在詢問了當時的一些使用者意見之後決定了最初的目標，隨著目標越來越明確便開始著手進行。Jordan 找了 Walnut Creek CD-ROM 商討，著眼於如何改進 FreeBSD 的發行通路，讓那些不便上網的人可簡單的取得。 Walnut Creek CD-ROM 不只贊成以 CD 來發行 FreeBSD 的想法，同時提供了一台機器以及快速的網路。 若不是 Walnut Creek CD-ROM 在那個時間上史無前例的信任，這個默默無名的計劃很可能不會成為現在的 FreeBSD 快速的成長到今日這樣的規模。</p></div><div class=paragraph><p>第一張以 CD-ROM (及網路) 發行的版本為 FreeBSD 1.0，是在 1993 年十二月發佈。 該版本採用了 U.C. Berkeley 以磁帶方式發行的 4.3BSD-Lite ("Net/2") 及許多來自於 386BSD 和自由軟體基金會的元件為基礎。對於第一次發行而言還算成功，我們又接著於 1994 年 5 月發行了相當成功的 FreeBSD 1.1。</p></div><div class=paragraph><p>然而此後不久，另一個意外的風暴在 Novell 與 U.C. Berkeley 關於 Berkeley Net/2 磁帶之法律地位的訴訟確定之後形成。 U.C. Berkeley 承認大部份的 Net/2 的程式碼都是"侵佔來的"且是屬於 Novell 的財產 — 事實上是當時不久前從 AT&amp;T 取得的。 Berkeley 得到的是 Novell 對於 4.4BSD-Lite 的"祝福"，最後當 4.4BSD-Lite 終於發行之後，便不再是侵佔行為。 而所有現有 Net/2 使用者都被強烈建議更換新版本，這包括了 FreeBSD。 於是，我們被要求於 1994 年 6 月底前停止散佈以 Net/2 為基礎的產品。在此前提之下，本計劃被允許在期限以前作最後一次發行，也就是 FreeBSD 1.1.5.1。</p></div><div class=paragraph><p>FreeBSD 便開始了這宛如『重新發明輪子』的艱鉅工作 — 從全新的且不完整的 4.4BSD-Lite 重新整合。 這個 "Lite" 版本是不完整的，因為 Berkeley 的 CSRG 已經刪除了大量在建立一個可以開機執行的系統所需要的程式碼 (基於若干法律上的要求)，且該版本在 Intel 平台的移植是非常不完整的。 直到 1994 年 11 月本計劃才完成了這個轉移， 同時在該年 12 月底以 CD-ROM 以及網路的形式發行了 FreeBSD 2.0。 雖然該份版本在當時有點匆促粗糙，但仍是富有意義的成功。 隨之於 1995 年 6 月又發行了更容易安裝，更好的 FreeBSD 2.0.5。</p></div><div class=paragraph><p>自那時以來，FreeBSD 在每一次對先前版本改進穩定性、速度及功能時便會發佈一個新的發佈版本。</p></div><div class=paragraph><p>目前，長期的開發計畫繼續在 10.X-CURRENT (trunk) 分支中進行，而 10.X 的快照 (Snapshot) 版本可以在 <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/snapshots/>快照伺服器</a> 取得。</p></div></div><div class=sect3><h4 id=goals>1.3.2. FreeBSD 計劃目標<a class=anchor href=#goals></a></h4><div class=paragraph><p>FreeBSD 計劃的目標在於提供可作任意用途的軟體而不附帶任何限制條文。 我們之中許多人對程式碼 (以及計畫本身) 都有非常大的投入， 因此，當然不介意偶爾有一些資金上的補償，但我們並沒打算堅決地要求得到這類資助。 我們認為我們的首要"使命"是為任何人提供程式碼， 不管他們打算用這些程式碼做什麼， 因為這樣程式碼將能夠被更廣泛地使用，從而發揮其價值。 我認為這是自由軟體最基本的，同時也是我們所倡導的一個目標。</p></div><div class=paragraph><p>我們程式碼樹中，有若干是以 GNU 通用公共授權條款 (GPL) 或者 GNU 較寬鬆通用公共授權條款 (LGPL) 發佈的那些程式碼帶有少許的附加限制，還好只是強制性的要求開放程式碼而不是別的。 由於使用 GPL 的軟體在商業用途上會增加若干複雜性，因此，如果可以選擇的話， 我們會比較喜歡使用限制相對更寬鬆的 BSD 版權來發佈軟體。</p></div></div><div class=sect3><h4 id=development>1.3.3. FreeBSD 開發模式<a class=anchor href=#development></a></h4><div class=paragraph><p>FreeBSD 的開發是一個非常開放且具彈性的過程，就像從 <a href=https://docs.freebsd.org/en/articles/contributors/>貢獻者名單</a> 所看到的，是由全世界成千上萬的貢獻者發展起來的。 FreeBSD 的開發基礎架構允許數以百計的開發者透過網際網路協同工作。 我們也經常關注著那些對我們的計畫感興趣的新開發者和新的創意， 那些有興趣更進一步參與計劃的人只需要在 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers>FreeBSD 技術討論郵遞論壇</a> 連繫我們。 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce>FreeBSD 公告郵遞論壇</a> 對那些希望了解我們進度的人也是相當有用的。</p></div><div class=paragraph><p>無論是單獨開發者或者封閉式的團隊合作，多瞭解 FreeBSD 計劃和它的開發過程會是不錯的：</p></div><div class=dlist><dl><dt class=hdlist1>SVN 檔案庫<a id=development-cvs-repository></a></dt><dd><p>過去數年來 FreeBSD 的中央原始碼樹 (Source tree) 一直是以 <a href=http://www.nongnu.org/cvs/>CVS</a> (Concurrent Versions System) 來維護的， 它是一套免費的原始碼控管工具。 從 2008 年 6 月起， FreeBSD 計劃開始改用 <a href=http://subversion.tigris.org>SVN</a> (Subversion)。 這是一個必要的更換動作，因為隨著原始碼樹及歷史版本儲存的數量不斷快速擴張，CVS 先天的技術限制越來越明顯。 文件計劃與 Port 套件集檔案庫也同樣於 2012 年 5 月及 2012 年 7 月由 CVS 改為 SVN。請參考 <a href=./#synching>同步您的原始碼樹</a> 一節來取得有關如何取得 FreeBSD <code>src/</code> 檔案庫的更多資訊，以及 <a href=./#ports-using>使用 Port 套件集</a> 了解如何取得 FreeBSD Port 套件集。</p></dd><dt class=hdlist1>提交者名單<a id=development-committers></a></dt><dd><p>所謂的 <em>提交者 (Committer)</em> 指的是對 Subversion 原始碼樹有 <em>寫入</em> 權限的人， 並且被授予修改 FreeBSD 原始碼的權限。 ("committer" 一詞源自版本管理系統中的 <code>commit</code> 指令，該指令是用來把新的修改提交給檔案庫)。 任何人都可以回報問題到 <a href=https://bugs.FreeBSD.org/submit/>Bug Database</a>，在回報問題之前，可以使用 FreeBSD 郵遞清單、IRC 頻道或論壇來確認問題真的是一個錯誤 (Bug)。</p></dd><dt class=hdlist1>FreeBSD 核心團隊<a id=development-core></a></dt><dd><p>如果把 FreeBSD 看成是一家公司的話， <em>FreeBSD 核心團隊 (FreeBSD core team)</em> 就相當於公司的董事會。 核心團隊的主要職責在於確保此計劃的整體有良好的架構，以朝著正確的方向發展。 此外，邀請敬業且負責的開發者加入提交者的行列也是核心團隊的職責之一，隨著其他新成員的加入也招募新的核心團隊成員。 目前的核心團隊是在 2018 年 7 月從提交者候選人之中選出來的，這個選舉每兩年會舉辦一次。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>如同多數的開發者，核心團隊大部分成員加入 FreeBSD 開發都是志工性質而已， 並未從本計劃中獲得任何薪酬，所以這只是一個 "承諾" 不應該被誤解為 "保證支援" 才對。 前面用 "董事會" 來舉例可能不是很恰當，或許我們應該說： 他們是一群自願放棄原本的優渥生活、個人其他領域成就， 而選擇投入 FreeBSD 開發的熱血有為者才對！</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>非官方貢獻者</dt><dd><p>最後一點，但這點絕非最不重要的， 最大的開發者團隊就是持續為我們提供回饋以及錯誤修正的使用者自己。 與 FreeBSD 非核心開發者互動的主要方式，便是透過訂閱 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers>FreeBSD 技術討論郵遞論壇</a> 來進行溝通，這方面可參考，請參閱 <a href=#eresources>網路資源</a> 以瞭解各式不同的 FreeBSD 郵遞論壇。</p><div class=paragraph><p><a href=https://www.FreeBSD.org/doc/zh_TW.UTF-8/articles/contributors/article.html>FreeBSD 貢獻者名單</a> 相當長且不斷成長中， 只要有貢獻就會被列入其中， 要不要立即考慮貢獻 FreeBSD 一些回饋呢？</p></div><div class=paragraph><p>提供原始碼並非為這個計劃做貢獻的唯一方式； 需要大家投入的完整工作清單請參閱 <a href=https://www.FreeBSD.org/>FreeBSD 計畫網站</a>。</p></div></dd></dl></div><div class=paragraph><p>總而言之，我們的開發模式像是由鬆散的同心圓所組織。這個集中模式的設計為的是讓 FreeBSD 的<em>使用者</em>更便利，可以很容易的追蹤同一個中央的程式庫，避免把潛在的貢獻者排除在外！而我們的目標是提供一個穩定的作業系統，並有大量相關的 <a href=./#ports>應用程式</a>，讓使用者能夠輕鬆的安裝與使用 — 而這個開發模式對我們要完成這個目標來說運作的非常好。</p></div><div class=paragraph><p>我們對於那些想要加入 FreeBSD 開發者的期待是： 請保持如同前人一樣的投入，以確保繼續成功！</p></div></div><div class=sect3><h4 id=third-party-programs>1.3.4. 第三方程式<a class=anchor href=#third-party-programs></a></h4><div class=paragraph><p>除了基礎發行版之外，FreeBSD 提供了擁有上千個常用的程式的移植軟體的套件集，在撰寫本文的同時，已有超過 24,000 個 Port！Port 的範圍從 HTTP 伺服器到遊戲、語系、編輯器，幾乎所有東西都在裡面。完整的 Port 套件集需要將近 500 MB。要編譯一個 Port 您只需要切換目錄到您想安裝的程式目錄，然後輸入 <code>make install</code>，接著系統便會處理剩下的動作。您編譯的每個 Port 完整原始發行版內容是動態下載的，所以您只需要有足夠的磁碟空間來編譯您想要的 Port。幾乎所有 Port 都提供已經預先編譯好的"套件"，您可以透過簡單的指令來安裝 (<code>pkg install</code>)，提供那些不想要自行從原始碼編譯的人使用。更多有關套件與 Port 的資訊可於 <a href=./#ports>安裝應用程式：套件與 Port</a> 取得。</p></div></div><div class=sect3><h4 id=_其他文件>1.3.5. 其他文件<a class=anchor href=#_其他文件></a></h4><div class=paragraph><p>所有支援的 FreeBSD 版本都會在安裝程式中提供一個選項，讓您可以在初始化系統安裝的階段安裝額外的說明文件到 <span class=filename>/usr/local/shared/doc/freebsd</span>。說明文件也可在往後隨時使用套件安裝，詳細說明於 <a href=./#doc-ports-install-package>自 Port 更新說明文件</a>。您也可以使用任何支援 HTML 的瀏覽器進入下列 URL 檢視已安裝在本機的手冊：</p></div><div class=dlist><dl><dt class=hdlist1>FreeBSD 使用手冊</dt><dd><p><a href=file://localhost/usr/local/shared/doc/freebsd/handbook/index.html>/usr/local/shared/doc/freebsd/handbook/index.html</a></p></dd><dt class=hdlist1>FreeBSD 常見問答集</dt><dd><p><a href=file://localhost/usr/local/shared/doc/freebsd/faq/index.html>/usr/local/shared/doc/freebsd/faq/index.html</a></p></dd></dl></div><div class=paragraph><p>此外，可在下列網址找到最新版 (也是更新最頻繁的版本)：<a href=https://www.FreeBSD.org/>https://www.FreeBSD.org/</a>。</p></div></div></div></div></div><div class=sect1><h2 id=bsdinstall>Chapter 2. 安裝 FreeBSD<a class=anchor href=#bsdinstall></a></h2><div class=sectionbody><div class=sect2><h3 id=bsdinstall-synopsis>2.1. 概述<a class=anchor href=#bsdinstall-synopsis></a></h3><div class=paragraph><p>有多種不同的方法可以執行 FreeBSD，根據所在環境，包含：</p></div><div class=ulist><ul><li><p>一般虛擬機映像檔，可下載並匯入到您所選擇的虛擬環境。映像檔可從 <a href=https://www.freebsd.org/where/>Download FreeBSD</a> 頁面下載，KVM ("qcow2"), VMWare ("vmdk"), Hyper-V ("vhd") 及原始裝置的映像檔都支援。這些並非安裝程式的映像檔，而是已經預先設定好 ("已安裝好") 的實例，可直接使用並執行安裝後的作業。</p></li><li><p>託管服務虛擬機映像檔，可在 Amazon 的 <a href=https://aws.amazon.com/mp/solutions/freebsd/>AWS Marketplace</a>, <a href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps?search=freebsd&amp;page=1">Microsoft Azure Marketplace</a> 和 <a href=https://console.cloud.google.com/launcher/details/freebsd-cloud/freebsd-11>Google Cloud Platform</a> 等託管服務上運行的虛擬機映像檔。有關如何在 Azure 上部署 FreeBSD 的資訊可查詢 <a href=https://docs.microsoft.com/en-us/azure/virtual-machines/linux/freebsd-intro-on-azure>Azure 說明文件</a>中的相關章節。</p></li><li><p>SD 卡映像檔，供嵌入式系統，如 Raspberry Pi 或 BeagleBone Black 使用的映像檔，可從 <a href=https://www.freebsd.org/where/>Download FreeBSD</a> 頁面下載，這些檔案必須先解壓縮後以原始映像檔的格式寫入 SD 卡以讓這些開發電路板能夠啟動。</p></li><li><p>安裝程式映像檔，用來安裝 FreeBSD 到硬碟，供一般的桌機、筆電或伺服器系統使用。</p></li></ul></div><div class=paragraph><p>此章接下來的部份會介紹第四個案例，說明如何使用文字介面為基礎的安裝程式 bsdinstall 安裝 FreeBSD。</p></div><div class=paragraph><p>一般來說，本章所寫的安裝說明是針對 i386™ 和 AMD64 架構。如果可以用於其他平台，將會列表說明。 安裝程式和本章所敘述的內容可能會有些微差異，所以請將本章視為通用的指引，而不是完全照著來做。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>喜歡用圖形化安裝程式安裝 FreeBSD 的使用者， 可能會對 pc-sysinstall 有興趣，這是 TrueOS 計畫所使用的。 他可以用來安裝圖形化桌面 (TrueOS) 或是指令列版本的 FreeBSD。 細節請參考 TrueOS 使用者 Handbook (<a href=https://www.trueos.org/handbook/trueos.html>https://www.trueos.org/handbook/trueos.html</a>)。</p></div></td></tr></tbody></table></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>最低的硬體需求和 FreeBSD 支援的架構。</p></li><li><p>如何建立 FreeBSD 的安裝媒體。</p></li><li><p>如何開始執行 bsdinstall。</p></li><li><p>bsdinstall 會詢問的問題，問題代表的意思，以及如何回答。</p></li><li><p>安裝失敗時如何做故障排除。</p></li><li><p>如何在正式安裝前使用 live 版本的 FreeBSD。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>閱讀即將安裝的 FreeBSD 版本所附帶的硬體支援清單，並核對系統的硬體是否有支援。</p></li></ul></div></div><div class=sect2><h3 id=bsdinstall-hardware>2.2. 最低硬體需求<a class=anchor href=#bsdinstall-hardware></a></h3><div class=paragraph><p>安裝 FreeBSD 的硬體需求隨 FreeBSD 的版本和硬體架構而不同。 FreeBSD 發行版支援的硬體架構和裝置會列在 <a href=https://www.FreeBSD.org/releases/>FreeBSD 發佈資訊</a> 頁面。<a href=https://www.FreeBSD.org/where/>FreeBSD 下載頁面</a> 也有建議如何正確的選擇在不同架構使用的映像檔。</p></div><div class=paragraph><p>FreeBSD 安裝程序需要至少 96 MB 的 RAM 以及 1.5 GB 的硬碟空間。然而，如此少的記憶體及磁碟空間只適合在客製的應用上，如嵌入式設備。一般用途的桌面系統會需要更多的資源，2-4 GB RAM 與至少 8 GB 的硬碟空間是不錯的起點。</p></div><div class=paragraph><p>每一種架構的處理器需求概述如下：</p></div><div class=dlist><dl><dt class=hdlist1>amd64</dt><dd><p>桌面電腦與筆記型電腦最常見的處理器類型，運用在近代的系統。Intel™ 稱該類型為 Intel64，其他製造商則稱該類型為 x86-64。</p><div class=paragraph><p>與 amd64 相容的處理器範例包含：AMD Athlon™64, AMD Opteron™, 多核心 Intel™ Xeon™ 以及 Intel™ Core™ 2 與之後的處理器。</p></div></dd><dt class=hdlist1>i386</dt><dd><p>舊型的桌面電腦與筆記型電腦常使用此 32-bit, x86 架構。</p><div class=paragraph><p>幾乎所有含浮點運算單元的 i386 相容處理器都有支援。所有 Intel™ 486 或是更高階的處理器也有支援。</p></div><div class=paragraph><p>FreeBSD 可在有支援實體位址延伸 (Physical Address Extensions, PAE) 功能的 CPU 上運用該功能所帶來的優點。有開啟 PAE 支援的核心會偵測超過 4 GB 的記憶體，並讓這些超過的記憶體能夠被系統使用。 但使用 PAE 會限制裝置驅動程式及 FreeBSD 的其他功能，詳情請見 <a href="https://man.freebsd.org/cgi/man.cgi?query=pae&amp;sektion=4&amp;format=html">pae(4)</a>。</p></div></dd><dt class=hdlist1>ia64</dt><dd><p>目前支援的處理器是 Itanium™ 和 Itanium™ 2。支援的晶片組包括 HP zx1， Intel™ 460GX 和 Intel™ E8870。 單處理器 (Uniprocessor, UP) 和對稱多處理器 (Symmetric Multi-processor, SMP) 的設定都有支援。</p></dd><dt class=hdlist1>powerpc</dt><dd><p>所有內建 USB 的 New World ROMApple™Mac™ 系統都有支援。 SMP 在多 CPU 的機器都有支援。</p><div class=paragraph><p>32 位元的核心只能使用前 2 GB 的 RAM。</p></div></dd><dt class=hdlist1>sparc64</dt><dd><p>FreeBSD/sparc64 支援的系統列在 <a href=https://www.FreeBSD.org/platforms/sparc/>FreeBSD/sparc64 計劃</a>。</p><div class=paragraph><p>所有超過一個處理器的系統都有支援 SMP。需要專用的磁碟系統，因為此時無法和其他作業系統共用磁碟。</p></div></dd></dl></div></div><div class=sect2><h3 id=bsdinstall-pre>2.3. 安裝前準備工作<a class=anchor href=#bsdinstall-pre></a></h3><div class=paragraph><p>一旦確定系統符合安裝 FreeBSD 的最低硬體需求，就可以下載安裝檔案並準備安裝的媒體。 做這些之前，先檢查以下核對清單的項目是否準備好了：</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>備份重要資料</p><div class=paragraph><p>安裝任何作業系統前， <em>總是</em> 要先備份所有重要資料。 不要儲存備份在即將安裝的系統上，而是將資料儲存在可移除磁碟，像是 USB 隨身碟、網路上的另一個系統或是線上備份服務上。 開始安裝程序前要檢查備份，確定備份含有所有需要的檔案，一旦安裝程式格式化系統的磁碟，所有儲存在上面的資料都會遺失。</p></div></li><li><p>決定 FreeBSD 安裝在哪裡</p><div class=paragraph><p>如果 FreeBSD 是唯一一套要安裝到電腦的作業系統，這個步驟可以略過。 但是假如 FreeBSD 要和其他作業系統共用磁碟空間的話，就要決定 FreeBSD 要安裝在哪個磁碟或是哪個分割區 (Partition)。</p></div><div class=paragraph><p>在 i386 和 amd64 架構，可將磁碟分割成多個分割區，可以選擇下列兩種分割表格式 (Partitioning scheme) 的其中一種達成。 傳統的<em>主開機紀錄 (Master Boot Record, MBR)</em> 的一個分割區表定義最多可有四個<em>主分割區</em> (Primary partition)，因一些歷史淵源，FreeBSD 稱這些主分割區為 <em>slice</em>，其中一個主分割區可作為<em>延伸分割區</em> (Extended partition)，延伸分割區又可分割成多個<em>邏輯分割區</em> (Logical partition)。 <em>GUID 分割區表</em> (GUID Partition Table, GPT) 是較新和較簡單的分割磁碟的方法，一般 GPT 實作允許每個磁碟多達 128 個分割區，不再需要使用邏輯分割區。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>一些比較舊的作業系統，像是 Windows™ XP 並不相容 GPT 分割表格式。 如果 FreeBSD 將和這類作業系統共用一個磁碟，則需要用 MBR 分割表格式。</p></div></td></tr></tbody></table></div><div class=paragraph><p>FreeBSD 開機啟動程式需要主分割區或是 GPT 分割區。如果所有的主分割區或 GPT 分割區都已使用，必須釋放其中一個分割區讓 FreeBSD 使用。如果要建立一個分割區而不刪除原有的資料，可以使用磁碟重設大小的工具來縮小現有的分割區，並使用釋放出來的空間建立新分割區。</p></div><div class=paragraph><p>各種免費和付費的磁碟重設大小工具列於 <a href=http://en.wikipedia.org/wiki/List_of_disk_partitioning_software>http://en.wikipedia.org/wiki/List_of_disk_partitioning_software</a>。GParted Live (<a href=http://gparted.sourceforge.net/livecd.php>http://gparted.sourceforge.net/livecd.php</a>) 是內含分割區編輯程式 GParted 的免費 Live CD。 GParted 同時也被許多 Linux Live CD 發行版所收錄。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>在正確使用的情況下，磁碟重設大小的工具可以安全的建立讓新的分割區使用的空間。 但因仍有可能會誤選已經存在的分割區，所以在修改磁碟分割區前， 一定要備份重要資料，並確認備份的完整性。</p></div></td></tr></tbody></table></div><div class=paragraph><p>在磁碟分割區中儲存不同的作業系統讓一台電腦可以安裝多個作業系統，另一種作法是使用虛擬化技術 (<a href=./#virtualization>虛擬化</a>) ，可讓多個作業系統同時間執行而不需要改變任何磁碟分割區。</p></div></li><li><p>收集網路資訊</p><div class=paragraph><p>部份 FreeBSD 安裝方式需要網路連線來下載安裝檔，因此之後的安裝程序，安裝程式進入設定系統網路的介面。</p></div><div class=paragraph><p>如果網路中有 DHCP 伺服器，則可透過該伺服器自動設定網路，若無法使用 DHCP，則需要從區域網路管理者或是網際網路服務供應商 (Internet Service Provider, ISP) 取得以的網路資訊供系統使用：</p></div><div id=bsdinstall-collect-network-information class="olist loweralpha"><ol class=loweralpha type=a><li><p>IP 位址</p></li><li><p>子網路遮罩</p></li><li><p>預設通訊閘 IP 位址</p></li><li><p>網路的網域名稱</p></li><li><p>網路 DNS 伺服器 IP 位址</p></li></ol></div></li><li><p>檢查 FreeBSD 勘誤表</p><div class=paragraph><p>儘管 FreeBSD 計劃努力確保每個 FreeBSD 發行版能夠儘可能地穩定，但臭蟲偶爾還是會悄悄出現，並有極小的可能會發生影響安裝流程的錯誤，當這些問題被發現並修正後，會被紀錄在 FreeBSD 網站的 FreeBSD 勘誤表 (<a href=https://www.FreeBSD.org/releases/12.0r/errata/>https://www.freebsd.org/releases/12.0r/errata/</a>)。 安裝前先檢查勘誤表，以確保沒有會影響到安裝的問題。</p></div><div class=paragraph><p>所有發行版的資訊和勘誤表可以在 FreeBSD 網站的發行資訊找到 (<a href=https://www.FreeBSD.org/releases/>https://www.freebsd.org/releases/</a>)。</p></div></li></ol></div></div></div><div class=sect3><h4 id=bsdinstall-installation-media>2.3.1. 準備安裝的媒體<a class=anchor href=#bsdinstall-installation-media></a></h4><div class=paragraph><p>FreeBSD 安裝程式並不是一個可以在其他作業系統上執行的應用程式，反而您需要下載 FreeBSD 安裝檔，燒錄安裝檔到符合其檔案類型與大小的媒體 (CD, DVD 或 USB)，然後開機從插入的媒體來安裝。</p></div><div class=paragraph><p>FreeBSD 的安裝檔可於 <a href="https://www.FreeBSD.org/where/<mark>download">www.freebsd.org/where/#download</a> 取得。安裝檔的名稱由 FreeBSD 發佈版本、架構、以及檔案類型所組成，舉例，要從 DVD 安裝 FreeBSD 10.2 到 amd64 的系統，需下載 [.filename]#FreeBSD-10.2-RELEASE-amd64-dvd1.iso，並燒錄這個檔案到 DVD，然後使用插入 DVD 來開機。</p></div><div class=paragraph><p>安裝檔有許多種可用的格式，格式會依據電腦架構及媒體類型的不同而異。</p></div><div id=bsdinstall-installation-media-uefi class=paragraph><p>還有另一種安裝檔是給使用 UEFI (Unified Extensible Firmware Interface) 開機的電腦使用，這些安裝檔的名稱會含有 <span class=filename>uefi</span>。</p></div><div class=paragraph><p>檔案類型：</p></div><div class=ulist><ul><li><p><code>-bootonly.iso</code>：這是最精簡的安裝檔，檔案中只含安裝程式。 安裝時需要網際網路連線來下載所需的檔案以完成 FreeBSD 安裝。這個檔案應使用 CD 燒錄應用程式燒錄到 CD 使用。</p></li><li><p><code>-disc1.iso</code>：這個檔案含有所有安裝 FreeBSD 所需的檔案，包含原始碼及 Port 套件集。這個檔案應使用 CD 燒錄應用程式燒錄到 CD 使用。</p></li><li><p><code>-dvd1.iso</code>：這個檔案含有所有安裝 FreeBSD 所需的檔案，包含原始碼及 Port 套件集，也內含熱門的 Binary 套件可安裝視窗管理程式以及一些應用程式，如此便可從媒體安裝完整的系統，無須連線到網際網路。這個檔案應使用 DVD 燒錄應用程式燒錄到 DVD 使用。</p></li><li><p><code>-memstick.img</code>：這個檔案含有所有安裝 FreeBSD 所需的檔案，包含原始碼及 Port 套件集。這個檔案應依據以下操作指示寫入到 USB 隨身碟使用。</p></li><li><p><code>-mini-memstick.img</code>：類似 <code>-bootonly.iso</code>，但不含安裝檔 (可依所要下載)，安裝時需要網際網路連線，可依 <a href=#bsdinstall-usb>寫入映象檔到 USB</a> 的說明將此檔案寫入至 USB 隨身碟。</p></li></ul></div><div class=paragraph><p>映像檔下載完成之後，下載同一個目錄之中的 <span class=filename>CHECKSUM.SHA256</span>。FreeBSD 提供 <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a> 可用來計算映像檔的 <em>校驗碼 (Checksum)</em>，使用方式為 <code>sha256 <em>imagefilename</em></code>，其他作業系統也會有類似的程式。</p></div><div class=paragraph><p>比對計算後的校驗碼與 <span class=filename>CHECKSUM.SHA256</span> 檔案中的值，校驗碼應該要完全相符，若校驗碼不相符，則代表該映像檔是損壞的，必須再下載一次。</p></div><div class=sect4><h5 id=bsdinstall-usb>2.3.1.1. 寫入映象檔到 USB<a class=anchor href=#bsdinstall-usb></a></h5><div class=paragraph><p><span class=filename>*.img</span> 檔案是隨身碟的完整內容的<em>映像檔 (image)</em>，該檔案<em>不能</em>直接用檔案的方式複製到目標裝置。有許多應用程式可用來寫入 <span class=filename>*.img</span> 到 USB 隨身碟，本節會介紹其中兩種。</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>在繼續之前，請先備份 USB 上的重要資料，這個程序會清除在隨身碟上既有的資料。</p></div></td></tr></tbody></table></div><div id=bsdinstall-usb-dd class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: 使用 <code>dd</code> 來寫入映像檔</strong></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>本範例使用 <span class=filename>/dev/da0</span> 做為目標裝置，是映像檔將會寫入的位置。 務必<em>十分小心</em>確認要使用的裝置正確，因為這個指示會摧毀所有在指定目標裝置上已存在的資料。</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> 指令列工具在 BSD, Linux™ 以及Mac OS™ 系統皆可使用。要使用 <code>dd</code> 燒錄映像檔需先插入 USB 隨身碟，然後確認隨身碟的裝置名稱。然後指定已下載的安裝檔名稱以及 USB 隨身碟的裝置名稱。本例示範在已有的 FreeBSD 系統燒錄 amd64 安裝映像檔到第一個 USB 裝置。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=FreeBSD-10.2-RELEASE-amd64-memstick.img of=/dev/da0 bs=1M conv=sync</span></code></pre></div></div><div class=paragraph><p>若這個指示執行失敗，請確認 USB 隨身碟是否還未掛載，以及該裝置名稱是否指向這個隨身碟，而不是一個分割區。有些作業系統可能需要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a> 來執行這個指令。且 <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> 的指令語法在不同的作業系統上有些不同，例如在 Mac OS™ 需要使用小寫的 <code>bs=1m</code>，而在 Linux™ 這類的系統可能會暫存寫入動作，要強制完成所有寫入動作，需使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sync&amp;sektion=8&amp;format=html">sync(8)</a>。</p></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: 使用 Windows™ 來寫入映象檔</strong></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>務必確認指定的磁碟機代號正確，因在指定磁碟機上的既有資料將會被覆蓋與摧毀。</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p>取得 Image Writer Windows™ 版</p><div class=paragraph><p>Image Writer Windows™ 版 是一個免費的應用程式，可以正確地將映像檔寫入隨身碟。可從 <a href=https://sourceforge.net/projects/win32diskimager/>https://sourceforge.net/projects/win32diskimager/</a> 下載，並解壓縮到一個資料夾。</p></div></li><li><p>用 Image Writer 寫入映象檔</p><div class=paragraph><p>雙擊 Win32DiskImager 圖示啟動程式。 確認 <code>Device</code> 顯示的磁碟機代號是隨身碟的磁碟機代號。 按下資料夾圖示選擇要寫入隨身碟的映像檔。 按下 <b class=button>Save</b> 按鈕確定映像檔名。 確認所有東西都正確，隨身碟的資料夾並沒有在其他視窗開啟。 所有東西準備好後，按下 <b class=button>Write</b> 將映像檔寫入隨身碟。</p></div></li></ol></div></div></div><div class=paragraph><p>您現在可以開始安裝 FreeBSD 。</p></div></div></div></div><div class=sect2><h3 id=bsdinstall-start>2.4. 開始安裝<a class=anchor href=#bsdinstall-start></a></h3><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>預設安裝程序在下列訊息顯示之前不會對磁碟做任何更動：</p></div><div class="literalblock programlisting"><div class=content><pre>Your changes will now be written to disk.  If you
have chosen to overwrite existing data, it will
be PERMANENTLY ERASED. Are you sure you want to
commit your changes?</pre></div></div><div class=paragraph><p>在這個警告訊息之前可以隨時中止安裝，若有任何設定錯誤的疑慮，只需在此時關閉電腦，將不會對系統磁碟做任何更改。</p></div></td></tr></tbody></table></div><div class=paragraph><p>本節將介紹如何使用根據 <a href=#bsdinstall-installation-media>準備安裝的媒體</a> 指示所準備的安裝媒體來開機。要使用可開機的 USB，請在開啟電腦前插入 USB 隨身碟。要使用 CD 或 DVD，則可開啟電腦後在第一時間插入媒體。如何設定系統使用插入的媒體開機依不同的系統架構會有所不同。</p></div><div class=sect3><h4 id=bsdinstall-starting-i386>2.4.1. 在 i386™ 及 amd64 開機<a class=anchor href=#bsdinstall-starting-i386></a></h4><div class=paragraph><p>這兩種架構提供了 BIOS 選單可選擇開機的裝置，依據要使用的安裝媒體類型，選擇 CD/DVD 或 USB 裝置做為第一個開機裝置。大多數的系統也會提供快速鍵可在啟動時選擇開機裝置，而不需要進入BIOS，通常這個按鍵可能是 <kbd>F10</kbd>, <kbd>F11</kbd>, <kbd>F12</kbd> 或 <kbd>Escape</kbd> 其中之一。</p></div><div class=paragraph><p>若電腦仍載入了現有的作業系統，而不是 FreeBSD 安裝程式，原因可能為：</p></div><div class="olist arabic"><ol class=arabic><li><p>執行開機程序時安裝媒體插入主機的時間不夠早，請讓安裝媒體留在電腦中並重新啟動電腦。</p></li><li><p>未正確修改 BIOS 或未儲檔，請再三檢查第一個開機裝置選擇了正確的裝置。</p></li><li><p>系統太舊，無法支援使用選擇的開機媒體開機，發生這個情況可以使用 Plop Boot Manager (<a href=http://www.plop.at/en/bootmanagers.html class=bare>http://www.plop.at/en/bootmanagers.html</a>) 來從選擇的開機媒體開機。</p></li></ol></div></div><div class=sect3><h4 id=_在_powerpc_開機>2.4.2. 在 PowerPC™ 開機<a class=anchor href=#_在_powerpc_開機></a></h4><div class=paragraph><p>在大部份機型，可於開機時按住鍵盤上的 <kbd>C</kbd>，便可從 CD 開機。若在非 Apple™ 的鍵盤則可按住 <span class=keyseq><kbd>Command</kbd>+<kbd>Option</kbd>+<kbd>O</kbd>+<kbd>F</kbd></span> 或 <span class=keyseq><kbd>Windows</kbd>+<kbd>Alt</kbd>+<kbd>O</kbd>+<kbd>F</kbd></span>，出現 <code>0 ></code> 提示時，輸入</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>boot <span class=nb>cd</span>:,<span class=se>\p</span>pc<span class=se>\l</span>oader <span class=nb>cd</span>:0</code></pre></div></div></div><div class=sect3><h4 id=_在_sparc64_開機>2.4.3. 在 SPARC64™ 開機<a class=anchor href=#_在_sparc64_開機></a></h4><div class=paragraph><p>大多數 SPARC64™ 系統會自動從磁碟開機，要從 CD 安裝 FreeBSD 需要進入 PROM。</p></div><div class=paragraph><p>要進入 PROM，需重新開機系統然後等候開機訊息出現。訊息會依機型而有所不同，但大致結果會如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Sun Blade 100 <span class=o>(</span>UltraSPARC-IIe<span class=o>)</span>, Keyboard Present
Copyright 1998-2001 Sun Microsystems, Inc.  All rights reserved.
OpenBoot 4.2, 128 MB memory installed, Serial <span class=c>#51090132.</span>
Ethernet address 0:3:ba:b:92:d4, Host ID: 830b92d4.</code></pre></div></div><div class=paragraph><p>若系統繼續從磁碟開機，此時按下鍵盤上的 <span class=keyseq><kbd>L1</kbd>+<kbd>A</kbd></span> 或 <span class=keyseq><kbd>Stop</kbd>+<kbd>A</kbd></span> 或透過序列 Console 送出 <code>BREAK</code>。當使用 tip 或 cu, <code>~#</code> 發出一個 BREAK 後，PROM 的提示會在單 CPU 的系統出現 <code>ok</code>，SMP 的系統出現 <code>ok {0}</code>，其中的數字代表啟動的 CPU 數。</p></div><div class=paragraph><p>此時，放入 CD 到磁碟機然後在 PROM 提示畫面輸入 <code>boot cdrom</code>。</p></div></div><div class=sect3><h4 id=bsdinstall-view-probe>2.4.4. FreeBSD 開機選單<a class=anchor href=#bsdinstall-view-probe></a></h4><div class=paragraph><p>從安裝媒體開機之後，會顯示如下的選單：</p></div><div id=bsdinstall-newboot-loader-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-newboot-loader-menu.png alt="bsdinstall newboot loader menu"></div><div class=title>图 1. FreeBSD 開機載入程式選單</div></div><div class=paragraph><p>預設在開機進入 FreeBSD 安裝程式前選單會等候使用者輸入 10 秒鐘，若已經安裝 FreeBSD，則會在開機進入 FreeBSD 前等候。要暫停開機計時器來仔細查看選項，請按 <kbd>Space</kbd> 鍵。要選擇選項，按下明顯標示的數字、字元或按鍵。選單有以下選項可選。</p></div><div class=ulist><ul><li><p>啟動多使用者模式 (<code>Boot Multi User</code>)：這個選項會繼續 FreeBSD 開機程序，若開機計時器已經暫停，可按 <kbd>1</kbd>、大寫或小寫 <kbd>B</kbd> 或 <kbd>Enter</kbd> 鍵。</p></li><li><p>啟動單使用者模式 (<code>Boot Single User</code>)：這個模式用來修正已安裝的 FreeBSD，如 <a href=./#boot-singleuser>單使用者模式</a> 所述。可按 <kbd>2</kbd>、大寫或小寫 <kbd>S</kbd> 進入這個模式。</p></li><li><p>離開到載入程式提示 (<code>Escape to loader prompt</code>)：這個選項會開機進入修復提示，這個模式含有有限數量的低階指令，這個模式詳細說明於 <a href=./#boot-loader>階段三</a>。可按 <kbd>3</kbd> 或 <kbd>Esc</kbd> 進入這個提示。</p></li><li><p>重新開機 (<code>Reboot</code>)：重新開啟系統。</p></li><li><p>設定開機選項 (<code>Configure Boot Options</code>)：開啟內部選單，詳細說明於 <a href=#bsdinstall-boot-options-menu>FreeBSD 開機選項選單</a>。</p></li></ul></div><div id=bsdinstall-boot-options-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-boot-options-menu.png alt="bsdinstall boot options menu"></div><div class=title>图 2. FreeBSD 開機選項選單</div></div><div class=paragraph><p>開機選項選單分成兩個部份。第一個部份用來返回主開機選單或重設任何已切換的選項回預設值。</p></div><div class=paragraph><p>第二個部份用來切換可用的選項為開 (<code>On</code>) 或關 (<code>Off</code>)，透過按下選項明顯標示的編號或字元。系統將會一直使用這些選項開機，直到選項被修改。有數個選項可以在這個選單做切換：</p></div><div class=ulist><ul><li><p>ACPI 支援 (<code>ACPI Support</code>)：若系統在開機時卡住，可嘗試切換這個選項為關 (<code>Off</code>)。</p></li><li><p>安全模式 (<code>Safe Mode</code>)：若系統在 ACPI 支援 (<code>ACPI Support</code>) 設為關 (<code>Off</code>) 時開機時仍然會卡住，可嘗試將此選項設為開 (<code>On</code>)。</p></li><li><p>單使用者 (<code>Single User</code>)：切換這個選項為開 (<code>On</code>) 來修正已存在的 FreeBSD 如 <a href=./#boot-singleuser>單使用者模式</a> 所述，問題修正後，將其設回關 (<code>Off</code>)。</p></li><li><p>詳細資訊 (<code>Verbose</code>)：切換這個選項為開 (<code>On</code>) 來查看開機程序中更詳細的訊息，這在診斷硬體問題時非常有用。</p></li></ul></div><div class=paragraph><p>在做完所需的選擇後，按下 <kbd>1</kbd> 或 <kbd>Backspace</kbd> 返回主開機選單，然後按下 <kbd>Enter</kbd> 繼續開機進入 FreeBSD。FreeBSD 執行裝置偵測及載入安裝程式時會顯示一系列的開機訊息，開機完成之後，會顯示歡迎選單如 <a href=#bsdinstall-choose-mode>歡迎選單</a>。</p></div><div id=bsdinstall-choose-mode class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-choose-mode.png alt="bsdinstall choose mode"></div><div class=title>图 3. 歡迎選單</div></div><div class=paragraph><p>按下 <kbd>Enter</kbd> 選擇預設的 <b class=button>Install</b> 進入安裝程式，接下來本章將介紹如何使用這個安裝程式。 若要選擇其他項目，可使用右或左方向鍵或顏色標示的字母選擇想要的選單項目。<b class=button>Shell</b> 可用來進入 FreeBSD 的 Shell 使用指令列工具在安裝之前準備磁碟。<b class=button>Live CD</b> 選項可用來在安裝之前試用 FreeBSD，Live 版本的詳細說明於 <a href=#using-live-cd>使用 Live CD</a>。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>要重新檢視開機訊息，包含硬體裝置偵測，請按大寫或小寫 <kbd>S</kbd> 然後再按 <kbd>Enter</kbd> 進入 Shell。在 Shell 提示之後輸入 <code>more /var/run/dmesg.boot</code> 然後使用空白鍵來捲動訊息。當查看完畢後輸入 <code>exit</code> 返回歡迎選單。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=using-bsdinstall>2.5. 使用 bsdinstall<a class=anchor href=#using-bsdinstall></a></h3><div class=paragraph><p>本節將告訴您在系統安裝之前 bsdinstall 選單的順序以及會詢問的資訊類型，可使用方向鍵來選擇選單的選項，然後按下 <kbd>Space</kbd> 選擇或取消選擇選單項目。當完成之後，按下 <kbd>Enter</kbd> 儲存選項然後進入下一個畫面。</p></div><div class=sect3><h4 id=bsdinstall-keymap>2.5.1. 選擇鍵盤對應表選單<a class=anchor href=#bsdinstall-keymap></a></h4><div class=paragraph><p>依據使用的系統 Console，bsdinstall 可能一開始顯示的選單會如 <a href=#bsdinstall-keymap-select-default>鍵盤對應表選擇</a>。</p></div><div id=bsdinstall-keymap-select-default class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-select-default.png alt="bsdinstall keymap select default"></div><div class=title>图 4. 鍵盤對應表選擇</div></div><div class=paragraph><p>要設定鍵盤配置，請選擇 <b class=button>YES</b> 按下 <kbd>Enter</kbd>，接著會顯示選單如 <a href=#bsdinstall-config-keymap>選擇鍵盤選單</a>。若要使用預設的配置，則可使用方向鍵選擇 <b class=button>NO</b> 然後按下 <kbd>Enter</kbd> 跳過這個選單畫面。</p></div><div id=bsdinstall-config-keymap class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-keymap.png alt="bsdinstall config keymap"></div><div class=title>图 5. 選擇鍵盤選單</div></div><div class=paragraph><p>設定鍵盤配置時，可使用上與下方向鍵來選擇最接近已連接到系統的鍵盤的鍵盤對應表 (Keymap)，然後按下 <kbd>Enter</kbd> 儲存選項。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>按 <kbd>Esc</kbd> 會離開這個選單然後使用預設的鍵盤對應表，若不清楚要使用那種鍵盤對應表，<span class=guimenuitem>United States of America ISO-8859-1</span> 是也是保險的選項。</p></div></td></tr></tbody></table></div><div class=paragraph><p>在 FreeBSD 10.0-RELEASE 以及之後的版本，已經加強了這個選單，會顯示完整的鍵盤對應表選項，並預先選擇預設值。另外，當選擇其他鍵盤對應用時，在繼續之前會顯示對話框讓使用者測試鍵盤對應表來確認。</p></div><div id=bsdinstall-keymap-10 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-10.png alt="bsdinstall keymap 10"></div><div class=title>图 6. 改進後的鍵盤對應表選單</div></div></div><div class=sect3><h4 id=bsdinstall-hostname>2.5.2. 設定主機名稱<a class=anchor href=#bsdinstall-hostname></a></h4><div class=paragraph><p>下一個 bsdinstall 選單用來為新安裝的系統設定主機名稱。</p></div><div id=bsdinstall-config-hostname class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-hostname.png alt="bsdinstall config hostname"></div><div class=title>图 7. 設定主機名稱</div></div><div class=paragraph><p>輸入在網路上獨一無二的主機名稱，主機名稱要是完整的主機名稱，如 <code>machine3.example.com</code>。</p></div></div><div class=sect3><h4 id=bsdinstall-components>2.5.3. 選擇要安裝的元件<a class=anchor href=#bsdinstall-components></a></h4><div class=paragraph><p>接下來 bsdinstall 會提示選擇要安裝的選用元件。</p></div><div id=bsdinstall-config-components class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-components.png alt="bsdinstall config components"></div><div class=title>图 8. 選擇要安裝的元件</div></div><div class=paragraph><p>決定要安裝的元件主要會根據系統的用途以及可用的磁碟空間容量。FreeBSD 核心 (Kernel) 及 Userland 統稱為 <em>基礎系統 (Base system)</em>，是必須安裝的部份。依據系統的架構，部份元件可能不會顯示：</p></div><div class=ulist><ul><li><p><code>doc</code> - 額外的說明文件，大部份是經年累月的產物，會安裝到 <span class=filename>/usr/shared/doc</span>。由 FreeBSD 文件計劃所提供的說明文件可在之後安裝，依照 <a href=./#updating-upgrading-documentation>更新文件集</a> 中的指示操作。</p></li><li><p><code>games</code> - 數個傳統 BSD 遊戲，包含 fortune, rot13 以及其他。</p></li><li><p><code>lib32</code> - 在 64-bit 版本的 FreeBSD 供執行 32-bit 應用程式使用的相容性程式庫。</p></li><li><p><code>ports</code> - FreeBSD Port 套件集是一套可自動下載、編譯安裝第三方軟體套件的集合，<a href=./#ports>安裝應用程式：套件與 Port</a> 中會討論到如何使用 Port 套件集。</p><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>安裝程式並不會檢查是否有充足的磁碟空間，FreeBSD Port 套件集會使用約 500 MB 的磁碟空間，只有在有足夠的磁碟空間時才選擇這個選項。</p></div></td></tr></tbody></table></div></li><li><p><code>src</code> - 完整的 FreeBSD 原始碼，包含核心 (Kernel) 與 Userland。雖然大多數的應用程式並不需要，但它可以編譯裝置驅動程式、核心模組或部份來自 Port 套件集的應用程式，它同時也用來做為開發 FreeBSD 本身所使用。完整的原始碼樹需要 1 GB 的磁碟空間，重新編譯整個 FreeBSD 系統需要額外再 5 GB 的空間。</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-netinstall>2.5.4. 從網路安裝<a class=anchor href=#bsdinstall-netinstall></a></h4><div class=paragraph><p>於 <a href=#bsdinstall-netinstall-notify>從網路安裝</a> 所示的選單只會在使用 <span class=filename>-bootonly.iso</span>CD 安裝時顯示，因這個安裝媒體中並未含安裝檔的複本。由於安裝檔必須透過網路下載，此選單會告知要先設定網路介面。</p></div><div id=bsdinstall-netinstall-notify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-files.png alt="bsdinstall netinstall files"></div><div class=title>图 9. 從網路安裝</div></div><div class=paragraph><p>要設定網路連線，按下 <kbd>Enter</kbd> 然後依照 <a href=#bsdinstall-config-network-dev>設定網路介面卡</a> 中的指示操作，完成網路介面的設定之後，選擇與要安裝 FreeBSD 的電腦相同所在地區的鏡像站，當鏡像站越接近目標電腦，檔案下載的速度會比較快，這會減少安裝的時間。</p></div><div id=bsdinstall-netinstall-mirror class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-mirrorselect.png alt="bsdinstall netinstall mirrorselect"></div><div class=title>图 10. 選擇鏡像站</div></div><div class=paragraph><p>若在本機的安裝媒體中找到安裝檔案，安裝程序便會繼續。</p></div></div></div><div class=sect2><h3 id=bsdinstall-partitioning>2.6. 配置磁碟空間<a class=anchor href=#bsdinstall-partitioning></a></h3><div class=paragraph><p>接下來的選單用來決定配置磁碟空間的方式。</p></div><div id=bsdinstall-zfs-partmenu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-partmenu.png alt="bsdinstall zfs partmenu"></div><div class=title>图 11. FreeBSD 10.x 或更新版本的磁碟分割選項</div></div><div class=paragraph><p>引導式 (<code>Guided</code>) 磁碟分割會自動設定磁碟的分割區 (Partition)，手動 (<code>Manual</code>) 磁碟分割可讓進階的使用者使用選單項目建立自訂的分割區，而 <code>Shell</code> 會開啟 Shell 提示讓進階的使用者可以使用指示列工具如 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> 來建立自訂的分割區。<code>ZFS</code> 磁碟分割只在 FreeBSD 10 及之後的版本可以使用，可建立選擇性加密的 root-on-ZFS 系統並支援 <em>開機環境 (Boot environment)</em>。</p></div><div class=paragraph><p>本節會介紹在配置磁碟分割時需要考量那些事情，並且會示範各種磁碟分割的方式。</p></div><div class=sect3><h4 id=configtuning-initial>2.6.1. 規劃分割區配置<a class=anchor href=#configtuning-initial></a></h4><div class=paragraph><p>配置檔案系統時要記得硬碟的資料傳輸的速度外軌較內軌快，因此較小且大量存取的檔案系統應要較接近磁碟的外軌，而較大的分割區如 <span class=filename>/usr</span> 應放置在磁碟較內部，建議建立分割區的順序如下：<span class=filename>/</span>, swap, <span class=filename>/var</span> 然後 <span class=filename>/usr</span>。</p></div><div class=paragraph><p>機器預期的用途會反映到 <span class=filename>/var</span> 分割區的大小，這個分割區用來保存郵件 (Mailbox)、日誌檔 (Log file) 及印表機緩衝 (Spool)。依使用者數及保存的期間，郵件及日誌檔可能成長到無法預期的大小，一般來說大部份的使用很少會在 <span class=filename>/var</span> 需要超過 1 GB 的可用磁碟空間。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>有時在 <span class=filename>/var/tmp</span> 會需要較多的空間，當新軟體安裝，套件工具會從套件中取出暫存的複本置於 <span class=filename>/var/tmp</span>。若在 <span class=filename>/var/tmp</span> 沒有足夠的空間，要安裝大型軟體套件，例如 Firefox, Apache OpenOffice 或 LibreOffice 會很困難。</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>/usr</span> 分割區保存了許多支持系統運作的檔案，包含 FreeBSD Port 套件集以及系統原始碼，這個分割區建議至少要有 2 GB 的空間。</p></div><div class=paragraph><p>在規劃分割區大小時，請牢記空間需求，當因某個分割區空間不足時要改使用其他分割區時會很麻煩。</p></div><div class=paragraph><p>根據經驗，交換分割區應為是實體記憶體 (RAM) 的兩倍。使用最低需求的 RAM 來運作的系統會需要更多的交換空間來取得更好的表現。配置太小的交換交間可能導致 VM 分頁掃描碼效率不佳，且往後增加更多記憶體時可能會產生問題。</p></div><div class=paragraph><p>在有數個 SCSI 磁碟或數個 IDE 磁碟在不同控制器的大型系統建議在每個磁碟機上都設定交換空間，最多可至四個磁碟機。每個交換分割區的大小應接近相同。核心雖可以處以任意大小的交換空間，但內部資料結構擴充到 4 倍的最大交換分割區大小時，讓交換分割區擁有相同的大小可以讓核心可以最佳的方式串連各個磁碟的交換空間。規劃較大交換空間是可以的，即使沒有使用到多少交換空間，這也會讓要從失控的程式恢復運作更容易，而不需強制重新啟動系統。</p></div><div class=paragraph><p>正確的做磁碟分割，可以區隔頻繁寫入所產生的資料碎片與經常讀取的分割區，將寫入頻繁的分割區放在磁碟的邊緣可以增加 I/O 效率。雖然較大的分割區可能也需要增加 I/O 效率，但將這些分割區往磁碟邊緣移動所增加的效率並不會比將 <span class=filename>/var</span> 移到磁碟邊緣所增加的效率來的顯著。</p></div></div><div class=sect3><h4 id=bsdinstall-part-guided>2.6.2. 引導式磁碟分割<a class=anchor href=#bsdinstall-part-guided></a></h4><div class=paragraph><p>當選擇這個方法，選單上會顯示可用的磁碟，若電腦有安裝多個磁碟，則需選擇其中一個來安裝 FreeBSD。</p></div><div id=bsdinstall-part-guided-disk class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-guided-disk.png alt="bsdinstall part guided disk"></div><div class=title>图 12. 自多個磁碟選擇</div></div><div class=paragraph><p>選擇磁碟之後，接下來選單會提示是否要安裝到整個磁碟或是使用剩餘的空間建立新的分割區。若選擇 <b class=button>Entire Disk</b>，會自動建立通用的分割區配置來填滿整個磁碟。選擇 <b class=button>Partition</b> 則會使用磁碟上未使用的空間來建立分割區配置。</p></div><div id=bsdinstall-part-entire-part class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-entire-part.png alt="bsdinstall part entire part"></div><div class=title>图 13. 選擇完整磁碟或分割區</div></div><div class=paragraph><p>分割區配置建立完成之後，再檢查一次確定是否符合安裝的需求。選擇 <b class=button>Revert</b> 會重設分割區回復為原來的設定值，選擇 <b class=button>Auto</b> 會重新建立自動配置的 FreeBSD 分割區。分割區也可以手動建立、修改或刪除。當確認磁碟分割正確之後，選擇 <b class=button>Finish</b> 繼續安裝。</p></div><div id=bsdinstall-part-review class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-review.png alt="bsdinstall part review"></div><div class=title>图 14. 確認已建立的分割區</div></div></div><div class=sect3><h4 id=bsdinstall-part-manual>2.6.3. 手動磁碟分割<a class=anchor href=#bsdinstall-part-manual></a></h4><div class=paragraph><p>選擇這個方法會開啟分割區編輯程式：</p></div><div id=bsdinstall-part-manual-create class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-create.png alt="bsdinstall part manual create"></div><div class=title>图 15. 手動建立分割區</div></div><div class=paragraph><p>選擇要安裝的磁碟機 (在這個例子為 <span class=filename>ada0</span>) 然後選擇 <b class=button>Create</b> 會以選單顯示可用的分割表格式 (Partition scheme)：</p></div><div id=bsdinstall-part-manual-partscheme class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png alt="bsdinstall part manual partscheme"></div><div class=title>图 16. 手動建立分割區</div></div><div class=paragraph><p>amd64 電腦最適合的選擇通常是 GPT，無法相容 GPT 的舊電腦則應使用 MBR。而其他分割表格式一般會用在那些較罕見或較舊的電腦上。</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>表 1. 磁碟分割表格式</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">縮寫</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>APM</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Apple Partition Map，用於 PowerPC™。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>BSD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>無 MBR 的 BSD 標籤，因非 BSD 的磁碟工具可能無法辨識該標籤，有時被稱做 <em>危險專用模式 (Dangerously dedicated mode)</em>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GPT</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GUID 分割區表 (<a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>http://en.wikipedia.org/wiki/GUID_Partition_Table</a>)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>MBR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>主開機記錄 (<a href=http://en.wikipedia.org/wiki/Master_boot_record>http://en.wikipedia.org/wiki/Master_boot_record</a>)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>PC98</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>使用 MBR 改編，用於 NEC PC-98 電腦 (<a href=http://en.wikipedia.org/wiki/Pc9801>http://en.wikipedia.org/wiki/Pc9801</a>)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>VTOC8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Volume Table Of Contents，用於 Sun SPARC64 及 UltraSPARC 電腦。</p></td></tr></tbody></table><div class=paragraph><p>選擇完分割區表格式並建立之後，再選擇 <b class=button>Create</b> 一次來建立分割區。<kbd>Tab</kbd> 鍵可用來在欄位間移動游標。</p></div><div id=bsdinstall-part-manual-addpart class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-addpart.png alt="bsdinstall part manual addpart"></div><div class=title>图 17. 手動建立分割區</div></div><div class=paragraph><p>標準的 FreeBSD GPT 安裝會使用至少三種分割區：</p></div><div class=ulist><ul><li><p><code>freebsd-boot</code> - 儲存 FreeBSD 開機程式 (Boot code)。</p></li><li><p><code>freebsd-ufs</code> - FreeBSD 的 UFS 檔案系統。</p></li><li><p><code>freebsd-swap</code> - FreeBSD 交換空間。</p></li></ul></div><div class=paragraph><p>另一個值得注意的分割區類型是 <code>freebsd-zfs</code>，這個分割區用來放置 FreeBSD ZFS 檔案系統 (<a href=./#zfs>Z 檔案系統 (ZFS)</a>)。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 取得可用的 GPT 分割區類型說明。</p></div><div class=paragraph><p>檔案系統分割區可建立多個，且有部份人會偏好使用傳統的配置方式將 <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span> 以及 <span class=filename>/usr</span> 分開存放在不同的分割區。請參考 <a href=#bsdinstall-part-manual-splitfs>建立傳統分割的檔案系統分割區</a> 的範例。</p></div><div class=paragraph><p>大小 (<code>Size</code>) 欄位可以使用常用的縮寫來輸入：<em>K</em> 代表 KB, <em>M</em> 代表 MB, <em>G</em> 代表 GB。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>適當的對齊磁碟扇區 (Sector) 會提供最佳的效能，而且讓分割區大小為 4 KB 的偶數倍數可協助確保對齊在磁碟機上的 512-byte 或 4K-byte 扇區。一般來說，使用分割區大小為 1M 或 1G 的偶數倍數是最簡單的方式確保每個分割區以 4K 的偶數倍數做為開始。唯一一個例外是：<em>freebsd-boot</em> 分割區因目前開機程式 (Boot code) 的限制，不可大於 512K。</p></div></td></tr></tbody></table></div><div class=paragraph><p>若分割區內含檔案系統便會需要一個掛載點 (<code>Mountpoint</code>)，若只要建立一個 UFS 分割區，那麼掛載點應設為 <span class=filename>/</span>。</p></div><div class=paragraph><p>標籤 (<code>Label</code>) 是分割區的名稱，磁碟機名稱或編號可能因為磁碟機連接到不同的控制器或連結埠而有所不同，但分割區標籤並不會改變。因此在檔案如 <span class=filename>/etc/fstab</span> 中參照時，使用標籤來替代磁碟機名稱與分割區編號會讓系統對硬體變更有更多的容錯空間。GPT 標籤會於磁碟連結之後出現在 <span class=filename>/dev/gpt/</span>。其他分割表格式的標籤格有不同功能，且標籤會在 <span class=filename>/dev/</span> 中有各自的目錄。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>每個分割區請使用獨一無二的標籤來避免相同名稱的衝突，標籤可以加入與電腦名稱、用途、地點有關的文字。例如，使用 <code>labroot</code> 或 <code>rootfslab</code> 來做為電腦名稱為 <code>lab</code> 的 UFS 根目錄分割區。</p></div></td></tr></tbody></table></div><div id=bsdinstall-part-manual-splitfs class=exampleblock><div class=title>例 1. 建立傳統分割的檔案系統分割區</div><div class=content><div class=paragraph><p>傳統的分割區配置會將 <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span> 以及 <span class=filename>/usr</span> 分別使用不同的檔案系統與分割區。先建立 GPT 分割表格式，然後依照下表所示建立分割區。下表是針對 20G 目標磁碟的分割區大小，若在目標磁碟有更多可用的空間，則可增加交換空間 (Swap) 或 <span class=filename>/var</span> 會比較有用。以下所示的標籤皆以 <code>ex</code> 為字首，代表 "example"，讀者應照前面的說明使用其他獨一無二的標籤。</p></div><div class=paragraph><p>預設 FreeBSD 的 <span class=filename>gptboot</span> 會預期第一個 UFS 分割區為 <span class=filename>/</span> 分割區。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">分割區類型</th><th class="tableblock halign-left valign-top">大小</th><th class="tableblock halign-left valign-top">掛載點</th><th class="tableblock halign-left valign-top">標籤</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-boot</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>512K</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exrootfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-swap</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>4G</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exswap</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exvarfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>1G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>extmpfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>接受預設值 (依磁碟提示)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exusrfs</code></p></td></tr></tbody></table></div></div><div class=paragraph><p>自訂的分割區建立完後，選擇 <b class=button>Finish</b> 繼續安裝。</p></div></div><div class=sect3><h4 id=bsdinstall-part-zfs>2.6.4. Root-on-ZFS 自動磁碟分割<a class=anchor href=#bsdinstall-part-zfs></a></h4><div class=paragraph><p>在 FreeBSD 10.0-RELEASE 之後支援了自動建立 root-on-ZFS 的安裝程序。這種磁碟分割模式只能使用整個磁碟，並會清除整個磁碟內的內容。安裝程式會自動建立對齊 4k 邊界的分割區然後強制 ZFS 使用 4k 扇區 (Sector)。即使在 512 位元扇區的磁碟使用也很安全，並增加了確保在 512 位元的磁碟上建立儲存池 (Pool) 也可在未來加入 4k 扇區磁碟的好處，無論是作為額外的存儲空間或作為故障磁碟的替代品。安裝程式也可選擇性採用 GELI 磁碟加密，如 <a href=./#disks-encrypting-geli>使用 geli 做磁碟加密</a> 所介紹，若開啟磁碟加密，會建立一個內含 <span class=filename>/boot</span> 目錄的 2 GB 未加密的開機儲存池，這個儲存池中會儲存核心及其他開機必要的檔案。然後剩餘的空用會給 ZFS 儲存池使用。</p></div><div class=paragraph><p>主要 ZFS 設定選單提供了數個設定選項來控制儲存池的建立。</p></div><div id=bsdinstall-zfs-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-menu.png alt="bsdinstall zfs menu"></div><div class=title>图 18. ZFS 磁碟分割選單</div></div><div class=paragraph><p>選擇 <kbd>T</kbd> 來設定儲存池類型 (<code>Pool Type</code>) 以及要組成儲存池的磁碟。自動 ZFS 安裝程式目前僅支援建立單一頂層 vdev，除了在串連 (Stripe) 模式。要建立更複雜的儲存池，需使用 <a href=#bsdinstall-part-shell>Shell 模式磁碟分割</a> 的操作來建立儲存池。安裝程式支援建立各種儲存池類型，包含串連 Stripe (不建議，沒有備援功能)、鏡像 Mirror (效能較佳，但可用空間較少) 以及 RAID-Z 1, 2, 與 3 (分別有能力承受同時 1, 2 與 3 個磁碟的損壞)。在選擇儲存池類型時會在螢幕的下方提示所需的磁碟數量，以及在使用 RAID-Z 時，每種配置最佳的磁碟數。</p></div><div id=bsdinstall-zfs-vdev_type class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_type.png alt="bsdinstall zfs vdev type"></div><div class=title>图 19. ZFS 儲存池類型</div></div><div class=paragraph><p>選擇儲存池 (<code>Pool Type</code>) 之後，會顯示可用的磁碟清單，然後會提示使用者選擇一個或多個磁碟來建立儲存池。接著會檢驗設定來確定選擇的磁碟足夠，若不足，選擇更改選項 (<b class=button>&lt;Change Selection></b>) 來返回磁碟清單或取消 (<b class=button>&lt;Cancel></b>) 來更改儲存池類型。</p></div><div id=bsdinstall-zfs-disk_select class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_select.png alt="bsdinstall zfs disk select"></div><div class=title>图 20. 磁碟選擇</div></div><div id=bsdinstall-zfs-vdev_invalid class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_invalid.png alt="bsdinstall zfs vdev invalid"></div><div class=title>图 21. 無效的選擇</div></div><div class=paragraph><p>若有一個或多磁碟未出現在清單上，或在安裝程式啟動後才連接的磁碟，可選擇重新掃描裝置 (<b class=button>- Rescan Devices</b>) 來更新可用磁碟的清單。要避免清除掉錯的磁碟，可用磁碟資訊 (<b class=button>- Disk Info</b>) 來檢查每個磁碟，包含磁碟中的分割表以及各種其他資訊如裝置型號與序號 (若有的話)。</p></div><div id=bsdinstall-zfs-disk_info class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_info.png alt="bsdinstall zfs disk info"></div><div class=title>图 22. 分析磁碟</div></div><div class=paragraph><p>主 ZFS 設定選單也允許使用者輸入儲存池名稱、關閉強制 4k 扇區對齊、開啟或關閉加密、切換 GPT (建議) 與 MBR 分割表類型以及選擇交換空間容量。設定所有選項為想要的值之後，請選擇選單上方的安裝 (<b class=button>>>> Install</b>) 選項。</p></div><div class=paragraph><p>若開啟了 GELI 磁碟加密，安裝程式會提示輸入兩次用來加密磁碟的密碼。</p></div><div id=bsdinstall-zfs-geli_password class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-geli_password.png alt="bsdinstall zfs geli password"></div><div class=title>图 23. 磁碟加密密碼</div></div><div class=paragraph><p>安裝程式接著會提供最後一次修改的機會可取消先前所選擇摧毀用來建立 ZFS 儲存池的磁碟機。</p></div><div id=bsdinstall-zfs-warning class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-warning.png alt="bsdinstall zfs warning"></div><div class=title>图 24. 最後修改</div></div><div class=paragraph><p>然後安裝程序會正常繼續。</p></div></div><div class=sect3><h4 id=bsdinstall-part-shell>2.6.5. Shell 模式磁碟分割<a class=anchor href=#bsdinstall-part-shell></a></h4><div class=paragraph><p>當要做進階的安裝時，bsdinstall 的磁碟分割選單可能無法提供需要的彈性。進階的使用者可以在磁碟分割選單選擇 <b class=button>Shell</b> 選項來手動分割磁碟機、建立檔案系統、填寫 <span class=filename>/tmp/bsdinstall_etc/fstab</span> 以及掛載檔案系統到 <span class=filename>/mnt</span> 下。這些動作完成之後，輸入 <code>exit</code> 可返回 bsdinstall 繼續安裝程序。</p></div></div></div><div class=sect2><h3 id=bsdinstall-final-warning>2.7. 確認安裝<a class=anchor href=#bsdinstall-final-warning></a></h3><div class=paragraph><p>磁碟設定完之後，接下來的選單會讓您在格式化所選的硬碟之前有最後一次機會做變更，若需要做變更，可選 <b class=button>Back</b> 返回到主磁碟分割選單。<b class=button>Revert & Exit</b> 則會離開安裝程式，不會對硬碟做任何變更。</p></div><div id=bsdinstall-final-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-confirmation.png alt="bsdinstall final confirmation"></div><div class=title>图 25. 最後確認</div></div><div class=paragraph><p>要開始實際的安裝，請選擇 <b class=button>Commit</b> 然後按下 <kbd>Enter</kbd>。</p></div><div class=paragraph><p>安裝時間會依據選擇的發行版、安裝媒體、電腦的速度而有所不同，接下來會有一系列訊息會告知目前的進度。</p></div><div class=paragraph><p>首先，安裝程式會格式化選擇的磁碟，然後初始化分割區。然後，若使用僅可開機 (Boot only) 的媒體則會開始下載選擇的元件：</p></div><div id=bsdinstall-distfile-fetching class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-fetching.png alt="bsdinstall distfile fetching"></div><div class=title>图 26. 取得發行版檔案</div></div><div class=paragraph><p>接著，會檢驗發行版的檔案完整性來確保沒有因下載過程中或安裝媒體的讀取過程中讀取錯誤造成的損壞：</p></div><div id=bsdinstall-distfile-verify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-verifying.png alt="bsdinstall distfile verifying"></div><div class=title>图 27. 檢驗發行版檔案</div></div><div class=paragraph><p>最後，檢驗過的發行版檔案會被取出儲存至磁碟：</p></div><div id=bsdinstall-distfile-extract class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-extracting.png alt="bsdinstall distfile extracting"></div><div class=title>图 28. 解開發行版檔案</div></div><div class=paragraph><p>所有選擇的發行版檔案取出後，bsdinstall 會顯示第一次安裝後設定畫面，可用的安裝後設定選項會在下一節說明。</p></div></div><div class=sect2><h3 id=bsdinstall-post>2.8. 安裝後注意事項<a class=anchor href=#bsdinstall-post></a></h3><div class=paragraph><p>FreeBSD 安裝完之後，bsdinstall 會在開機進入新安裝的系統之前提示設定數個選項，本節將介紹這些設定選項。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>系統開機之後，<code>bsdconfig</code> 提供了一個選單導向的方式可用來設定系統使用這些以及其他的選項。</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=bsdinstall-post-root>2.8.1. 設定 <code>root</code> 密碼<a class=anchor href=#bsdinstall-post-root></a></h4><div class=paragraph><p>首先，必需設定 <code>root</code> 的密碼，輸入密碼時，並不會直接在畫面上顯示輸入的字元。輸入完密碼之後，必須再輸入一次來確認沒有輸入錯誤。</p></div><div id=bsdinstall-post-set-root-passwd class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-post-root-passwd.png alt="bsdinstall post root passwd"></div><div class=title>图 29. 設定 <code>root</code> 密碼</div></div></div><div class=sect3><h4 id=bsdinstall-config-network-dev>2.8.2. 設定網路介面卡<a class=anchor href=#bsdinstall-config-network-dev></a></h4><div class=paragraph><p>接著，會顯示在電腦上找到的網路介面卡清單。請選擇要設定的介面卡。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若使用 <em>bootonly</em> 的方式安裝在先前已有設定過網路，將會跳過網路設定選單。</p></div></td></tr></tbody></table></div><div id=bsdinstall-configure-net-interface class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface.png alt="bsdinstall configure network interface"></div><div class=title>图 30. 選擇網路介面卡</div></div><div class=paragraph><p>若選擇的是乙太網路介面卡，安裝程式會跳過這部份直接到 <a href=#bsdinstall-configure-net-ipv4>選擇 IPv4 網路</a>，若選擇的是無線網路介面卡，系統則會開始掃描無線存取點 (Wireless Access Point)：</p></div><div id=bsdinstall-wireless-scan class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-scan.png alt="bsdinstall configure wireless scan"></div><div class=title>图 31. 掃描無線網路存取點</div></div><div class=paragraph><p>網線網路會使用 Service Set Identifier (SSID) 來辦識，SSID 是一段簡短、獨一無二的名稱，用來命名每個網路。 掃描時找到的 SSID 會列到清單，並會說明該網路可用的加密類型。 若想要連線的 SSID 並未出現在清單上，可選擇 <b class=button>Rescan</b> 再掃描一次，若想要連線的網路仍然沒有出現，請檢查天線的連線是否有問題，或者嘗試將電腦移至更靠近存取點的位置，然後再掃描一次。</p></div><div id=bsdinstall-wireless-accesspoints class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-accesspoints.png alt="bsdinstall configure wireless accesspoints"></div><div class=title>图 32. 選擇無線網路</div></div><div class=paragraph><p>然後，輸入加密資訊來連線到選擇的無線網路。強列建議使用 WPA2 加密，因較舊的加密類型，如 WEP 僅提供微弱的安全性。若網路使用 WPA2 則需輸入密碼，也稱作 Pre-Shared Key (PSK)。考量安全性，輸入到輸入框的字元會以星號顯示。</p></div><div id=bsdinstall-wireless-wpa2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-wpa2setup.png alt="bsdinstall configure wireless wpa2setup"></div><div class=title>图 33. WPA2 設定</div></div><div class=paragraph><p>接下來，選擇是否要設定乙太網路或無線網路介面卡的 IPv4 位址：</p></div><div id=bsdinstall-configure-net-ipv4 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4.png alt="bsdinstall configure network interface ipv4"></div><div class=title>图 34. 選擇 IPv4 網路</div></div><div class=paragraph><p>有兩種方式可以設定 IPv4。 DHCP 會自動設定網路介面卡且該網路上需有 DHCP 伺服器才可使用。否則，必須手動輸入位址的資訊來做靜態設定。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>請不要隨便輸入網路資訊，因為這不管用。如果沒有可用的 DHCP 伺服器，可向網路管理者或網路服務供應商 (Internet Service Provider, ISP) 索取列於 <a href=#bsdinstall-collect-network-information>需要的網路資訊</a> 的資訊。</p></div></td></tr></tbody></table></div><div class=paragraph><p>若有可用的 DHCP 伺服器，請在接下來的選單中選擇 <b class=button>Yes</b> 則會自動設定網路介面卡。當找到 DHCP 伺服器並且取得系統的位址資訊時，安裝程式會出現一分鐘左右的停頓。</p></div><div id=bsdinstall-net-ipv4-dhcp class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-dhcp.png alt="bsdinstall configure network interface ipv4 dhcp"></div><div class=title>图 35. 選擇 IPv4DHCP 設定</div></div><div class=paragraph><p>若沒有可用的 DHCP 伺服器，則選擇 <b class=button>No</b> 然後在這個選單中輸入以下位址資訊：</p></div><div id=bsdinstall-net-ipv4-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-static.png alt="bsdinstall configure network interface ipv4 static"></div><div class=title>图 36. IPv4 靜態位置設定</div></div><div class=ulist><ul><li><p>IP 位址 (<code>IP Address</code>) - 要分配給這台電腦的 IPv4 位址。位址必須獨一無二且不可已被其他在區域網路上的設備使用。</p></li><li><p>子網路遮罩 (<code>Subnet Mask</code>) - 網路的子網路遮罩。</p></li><li><p>預設路由器 (<code>Default Router</code>) - IP 位址所在網段的預設通訊閘。</p></li></ul></div><div class=paragraph><p>接下來的畫面會詢問是否要設定介面卡的 IPv6 位址，若可以且想要使用 IPv6，請選擇 <b class=button>Yes</b>。</p></div><div id=bsdinstall-net-ipv6 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6.png alt="bsdinstall configure network interface ipv6"></div><div class=title>图 37. 選擇 IPv6 網路</div></div><div class=paragraph><p>同樣有兩種方式可以設定 IPv6。StateLess Address AutoConfiguration (SLAAC) 會自動向區域路由器請求取得正確的設定資訊，請參考 <a href=http://tools.ietf.org/html/rfc4862>http://tools.ietf.org/html/rfc4862</a> 取得進一步資訊。靜態設定則需要手動輸入網路資訊。</p></div><div class=paragraph><p>若有可用的 IPv6 路由器，請在接下來的選單選擇 <b class=button>Yes</b> 來自動設定網路介面卡。當找到路由器並且取得系統的位址資訊時，安裝程式會出現一分鐘左右的停頓。</p></div><div id=bsdinstall-net-ipv6-slaac class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-slaac.png alt="bsdinstall configure network interface slaac"></div><div class=title>图 38. 選擇 IPv6 SLAAC 設定</div></div><div class=paragraph><p>若沒有可用的 IPv6 路由器，請選擇 <b class=button>No</b> 然後在這個選單中輸入以下位址資訊：</p></div><div id=bsdinstall-net-ipv6-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6-static.png alt="bsdinstall configure network interface ipv6 static"></div><div class=title>图 39. IPv6 靜態位置設定</div></div><div class=ulist><ul><li><p>IPv6 位址 (<code>IPv6 Address</code>) - 要分配給這台電腦的 IPv6 位址。位址必須獨一無二且不可已被其他在區域網路上的設備使用。</p></li><li><p>預設路由器 (<code>Default Router</code>) - IPv6 位址所在網段的預設通訊閘。</p></li></ul></div><div class=paragraph><p>最後的網路設定選單是用來設定網域名稱系統 (Domain Name System, DNS) 的解析器，解析器會轉換主機名稱為網路位址。若已使用 DHCP 或 SLAAC 來自動設定網路介面卡，解析器設定 (<code>Resolver Configuration</code>) 的值可能會事先已填入，否則需輸入區域網路的網域名稱到搜尋 (<code>Search</code>) 欄位。 <code>DNS #1</code> 與 <code>DNS #2</code> 要填寫 DNS 伺服器的 IPv4 及/或 IPv6 位址，至少需填寫一個 DNS 伺服器。</p></div><div id=bsdinstall-net-dns-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-ipv4-dns.png alt="bsdinstall configure network ipv4 dns"></div><div class=title>图 40. DNS 設定</div></div></div><div class=sect3><h4 id=bsdinstall-timezone>2.8.3. 設定時區<a class=anchor href=#bsdinstall-timezone></a></h4><div class=paragraph><p>接下來的選單會詢問系統時鐘要使用 UTC 或者當地時間。 若有疑問時可選擇 <b class=button>No</b>使用更常用的當地時間。</p></div><div id=bsdinstall-local-utc class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-set-clock-local-utc.png alt="bsdinstall set clock local utc"></div><div class=title>图 41. 選擇本地或 UTC 時鐘</div></div><div class=paragraph><p>接下來一系列的選單會透過選擇地理區域、城市及時區來判斷正確的當地時間。設定時區可讓系統自動更正區域時間的更改，如日光節約時間以及正確執行其他時區相關的功能。</p></div><div class=paragraph><p>此處以位於美國東部時區的機器為例，選擇會依據地理位置不同改變。</p></div><div id=bsdinstall-timezone-region class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-region.png alt="bsdinstall timezone region"></div><div class=title>图 42. 選擇區域</div></div><div class=paragraph><p>使用方向鍵選擇適當的區域然後按下 <kbd>Enter</kbd>。</p></div><div id=bsdinstall-timezone-country class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-country.png alt="bsdinstall timezone country"></div><div class=title>图 43. 選擇城市</div></div><div class=paragraph><p>使用方向鍵選擇適當的城市然後按下 <kbd>Enter</kbd>。</p></div><div id=bsdinstall-timezone-zone class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-zone.png alt="bsdinstall timezone zone"></div><div class=title>图 44. 選擇時區</div></div><div class=paragraph><p>使用方向鍵選擇適當的時區然後按下 <kbd>Enter</kbd>。</p></div><div id=bsdinstall-timezone-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-confirm.png alt="bsdinstall timezone confirm"></div><div class=title>图 45. 確認時區</div></div><div class=paragraph><p>確認時區的縮寫是否正確，若正確，按下 <kbd>Enter</kbd> 繼續安裝後設定。</p></div></div><div class=sect3><h4 id=bsdinstall-sysconf>2.8.4. 開啟服務<a class=anchor href=#bsdinstall-sysconf></a></h4><div class=paragraph><p>接下來的選單用來設定有那些系統服務要在系統啟動時執行。所有的服務為選用，只需開啟系統運作真正需要的服務。</p></div><div id=bsdinstall-config-serv class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-services.png alt="bsdinstall config services"></div><div class=title>图 46. 選擇要開啟的其他服務</div></div><div class=paragraph><p>這是可以在這個選單開啟的服務摘要：</p></div><div class=ulist><ul><li><p><code>sshd</code> - Secure Shell (SSH) Daemon 可從遠端透過加密的連線存取系統，只有在系統允許遠端登入時開啟這個服務。</p></li><li><p><code>moused</code> - 若在指令列系統 Console 會使用到滑鼠時，可開啟此服務。</p></li><li><p><code>ntpd</code> - 網路時間通訊協定 (Network Time Protoco, NTP) Daemon 用來自動同步時間。若在網路上有使用 Windows™, Kerberos 或 LDAP 伺服器時，可開啟此服務。</p></li><li><p><code>powerd</code> - 系統電源控制工具用來做電源控制與節能。</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-crashdump>2.8.5. 開啟當機資訊 (Crash Dump)<a class=anchor href=#bsdinstall-crashdump></a></h4><div class=paragraph><p>接下來的選單用來設定是否開啟當機資訊 (Crash dump)，開啟當機資訊對系統除錯非常有用，因此建議使用者開啟當機資訊。</p></div><div id=bsdinstall-config-crashdump class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-crashdump.png alt="bsdinstall config crashdump"></div><div class=title>图 47. 開啟當機資訊 (Crash Dump)</div></div></div><div class=sect3><h4 id=bsdinstall-addusers>2.8.6. 新增使用者<a class=anchor href=#bsdinstall-addusers></a></h4><div class=paragraph><p>下個選單會提示建立至少一個使用者帳號。建議使用 <code>root</code> 以外的使用者帳號登入系統，當使用 <code>root</code> 登入時，基本上沒有任何的限制或保護。 使用一般使用者登入較保險且安全。</p></div><div class=paragraph><p>選擇 <b class=button>Yes</b> 來新增新使用者。</p></div><div id=bsdinstall-add-user1 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser1.png alt="bsdinstall adduser1"></div><div class=title>图 48. 新增使用者帳號</div></div><div class=paragraph><p>請依照提示輸入請求的使用者帳號資訊，<a href=#bsdinstall-add-user2>輸入使用者資訊</a> 的範例示範建立 <code>asample</code> 使用者帳號。</p></div><div id=bsdinstall-add-user2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser2.png alt="bsdinstall adduser2"></div><div class=title>图 49. 輸入使用者資訊</div></div><div class=paragraph><p>這裡是要輸入的資訊摘要：</p></div><div class=ulist><ul><li><p>使用者名稱 (<code>Username</code>) - 登入時使用者要輸入的名稱，常見的慣例是用姓的前一個字母與名結合，只要每個使用者名稱在系統唯一的皆可。使用者名稱區分大小寫且不應含有任何空白字元。</p></li><li><p>全名 (<code>Full name</code>) - 使用者的全名，這個欄位可使用空白並且會用來描述該使用者帳號。</p></li><li><p><code>Uid</code> - 使用者 ID，通常這個欄位會留空，系統會自動分配一個值。</p></li><li><p>登入群組 (<code>Login group</code>) - 使用者的群組，通常這個欄位會留空來使用預設值。</p></li><li><p>邀請使用者進入其他群組? (<code>Invite <em>user</em> into other groups?</code>) - 使用者要加入成為其成員的其他群組，若該使用者需要管理權限，則在此輸入 <code>wheel</code>。</p></li><li><p>登入類別 (<code>Login class</code>) - 通常會留空來使用預設值。</p></li><li><p><code>Shell</code> - 輸入清單中的其中一項來設定使用者所互動的 Shell，請參考 <a href=./#shells>Shell</a> 取得更多有關 Shell 的資訊。</p></li><li><p>家目錄 (<code>Home directory</code>) - 使用者的家目錄，預設值通常是沒有問題的。</p></li><li><p>家目錄權限 (<code>Home directory permissions</code>) - 使用者家目錄的權限，預設值通常是沒有問題的。</p></li><li><p>使用密碼為基礎的認証方式? (<code>Use password-based authentication?</code>) - 通常為是 (<code>yes</code>)，使用者才可於登入時輸入密碼。</p></li><li><p>使用空白密碼? (<code>Use an empty password?</code>) - 通常為否 (<code>no</code>)，因為使用空白密碼並不安全。</p></li><li><p>使用隨機密碼? (<code>Use a random password?</code>) - 通常為否 (<code>no</code>)，這樣使用者接下來才可設定自己的密碼。</p></li><li><p>輸入密碼 (<code>Enter password</code>) - 這個使用者的密碼，輸入的字元不會顯示在畫面上。</p></li><li><p>再輸入密碼一次 (<code>Enter password again</code>) - 再輸入一次密碼來確認無誤。</p></li><li><p>建立後鎖定使用者帳號? (<code>Lock out the account after creation?</code>) - 通常為否 (<code>no</code>)，這樣使用者才可以登入。</p></li></ul></div><div class=paragraph><p>在輸入完全部的資料後，會顯示摘要供檢查，若發現錯誤，可輸入否 (<code>no</code>) 然後再輸入一次，若輸入的所有資訊皆正確，輸入是 (<code>yes</code>) 以後便會建立新使用者。</p></div><div id=bsdinstall-add-user3 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser3.png alt="bsdinstall adduser3"></div><div class=title>图 50. 離開使用者與群組管理</div></div><div class=paragraph><p>若還有其他要新增的使用者，則在詢問新增其他使用者? (<code>Add another user?</code>) 時回答是 (<code>yes</code>)。輸入否 (<code>no</code>) 來完成加入使用者然後繼續安裝。</p></div><div class=paragraph><p>要取得新增使用者與使用者管理的更多資訊，請參考 <a href=./#users-synopsis>使用者與基礎帳號管理</a>。</p></div></div><div class=sect3><h4 id=bsdinstall-final-conf>2.8.7. 最後設定<a class=anchor href=#bsdinstall-final-conf></a></h4><div class=paragraph><p>在所有東西安裝並設定完之後，會提供最後一次修改設定的機會。</p></div><div id=bsdinstall-final-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-finalconfiguration.png alt="bsdinstall finalconfiguration"></div><div class=title>图 51. 最後設定</div></div><div class=paragraph><p>使用這個選單在完成安裝前做任何更改或做任何額外的設定。</p></div><div class=ulist><ul><li><p>新增使用者 (<code>Add User</code>) - 詳述於 <a href=#bsdinstall-addusers>新增使用者</a>。</p></li><li><p>Root 密碼 (<code>Root Password</code>) - 詳述於 <a href=#bsdinstall-post-root>設定 <code>root</code> 密碼</a>。</p></li><li><p>主機名稱 (<code>Hostname</code>) - 詳述於 <a href=#bsdinstall-hostname>設定主機名稱</a>。</p></li><li><p>網路 (<code>Network</code>) - 詳述於 <a href=#bsdinstall-config-network-dev>設定網路介面卡</a>。</p></li><li><p>服務 (<code>Services</code>) - 詳述於 <a href=#bsdinstall-sysconf>開啟服務</a>。</p></li><li><p>時區 (<code>Time Zone</code>) - 詳述於 <a href=#bsdinstall-timezone>設定時區</a>。</p></li><li><p>使用手冊 (<code>Handbook</code>) - 下載並安裝 FreeBSD 使用手冊。</p></li></ul></div><div class=paragraph><p>完成最後的設定之後，選擇 <b class=button>Exit</b>。</p></div><div id=bsdinstall-final-modification-shell class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-modification-shell.png alt="bsdinstall final modification shell"></div><div class=title>图 52. 手動設定</div></div><div class=paragraph><p>bsdinstall 會提示是否有任何額外的設定需要在重新開機進入新系統之前完成。選擇 <b class=button>Yes</b> 會離開進入到新系統的 Shell 或 <b class=button>No</b> 繼續最後的安裝步驟。</p></div><div id=bsdinstall-final-main class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-mainexit.png alt="bsdinstall mainexit"></div><div class=title>图 53. 完成安裝</div></div><div class=paragraph><p>若有需要做進一步或特殊的設定，選擇 <b class=button>Live CD</b> 會開機進入安裝媒體的 Live CD 模式。</p></div><div class=paragraph><p>若安裝已完成，選擇 <b class=button>Reboot</b> 重新開啟電腦然後啟動新的 FreeBSD 電腦。不要忘了移除 FreeBSD 安裝媒體，否則電腦會再次開機進入安裝程式。</p></div><div class=paragraph><p>FreeBSD 開機的過程會顯示許多可以參考的訊息，系統開機完成後，會顯示登入提示，在 <code>login:</code> 提示，輸入安裝時新增的使用者名稱。登入時避免直接使用 <code>root</code>，請參考 <a href=./#users-superuser>超級使用者帳號</a> 來取得當需要管理權限時如何成為超級使用者的說明。</p></div><div class=paragraph><p>要查看開機過程顯示的訊息可按 <kbd>Scroll-Lock</kbd> 鍵來開啟卷軸暫存，然後可使用 <kbd>PgUp</kbd>, <kbd>PgDn</kbd> 以及方向鍵來捲動訊息。查看完成之後再按 <kbd>Scroll-Lock</kbd> 鍵一次來解除畫面鎖定並返回 Console。系統開機一段時間之後要查看這些訊息可在指令提示後輸入 <code>less /var/run/dmesg.boot</code>，查看後按下 <kbd>q</kbd> 鍵便可返回指令列。</p></div><div class=paragraph><p>若在 <a href=#bsdinstall-config-serv>選擇要開啟的其他服務</a> 有開啟 sshd，因系統會產生 RSA 及 DSA 金鑰第一次開機可能會有點慢，之後的開機便會恢復正常速度。接著會顯示金鑰的指紋 (Fingerprint)，如這個範例：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Generating public/private rsa1 key pair.
Your identification has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.
Your public key has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.pub.
The key fingerprint is:
10:a0:f5:af:93:ae:a3:1a:b2:bb:3c:35:d9:5a:b3:f3 root@machine3.example.com
The key<span class=s1>&#39;s randomart image is:
+--[RSA1 1024]----+
|    o..          |
|   o . .         |
|  .   o          |
|       o         |
|    o   S        |
|   + + o         |
|o . + *          |
|o+ ..+ .         |
|==o..o+E         |
+-----------------+
Generating public/private dsa key pair.
Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
The key fingerprint is:
7e:1c:ce:dc:8a:3a:18:13:5b:34:b5:cf:d9:d1:47:b2 root@machine3.example.com
The key&#39;</span>s randomart image is:
+--[ DSA 1024]----+
|       ..     <span class=nb>.</span> .|
|      o  <span class=nb>.</span>   <span class=nb>.</span> + |
|     <span class=nb>.</span> ..   <span class=nb>.</span> E .|
|    <span class=nb>.</span> <span class=nb>.</span>  o o <span class=nb>.</span> <span class=nb>.</span> |
|     +  S <span class=o>=</span> <span class=nb>.</span>    |
|    +  <span class=nb>.</span> <span class=o>=</span> o     |
|     +  <span class=nb>.</span> <span class=k>*</span> <span class=nb>.</span>    |
|    <span class=nb>.</span> <span class=nb>.</span>  o <span class=nb>.</span>     |
|      .o. <span class=nb>.</span>      |
+-----------------+
Starting sshd.</code></pre></div></div><div class=paragraph><p>請參考 <a href=./#openssh>OpenSSH</a> 來取得更多有關指紋與 SSH 的資訊。</p></div><div class=paragraph><p>FreeBSD 預設並不會安裝圖型化介面，請參考 <a href=./#x11>X Window 系統</a> 取得有關安裝與設定圖型化視窗管理程式的資訊。</p></div><div class=paragraph><p>正確的將 FreeBSD 電腦關機對保護資料及避免硬體損壞有幫助。<em>在系統尚未正常關機之前請不要關閉電源！</em> 若使用者為 <code>wheel</code> 群組的成員之一，可在指令列輸入 <code>su</code> 然後輸入 <code>root</code> 密碼來成為超級使用者。接著輸入 <code>shutdown -p now</code> 系統便會關機，若硬體支援的話，電腦會自行關閉電源。</p></div></div></div><div class=sect2><h3 id=bsdinstall-install-trouble>2.9. 疑難排解<a class=anchor href=#bsdinstall-install-trouble></a></h3><div class=paragraph><p>本節涵蓋基礎的安裝疑難排解，例如一些已有人回報的常見問題。</p></div><div class=paragraph><p>查看該 FreeBSD 版本的 Hardware Notes (<a href=https://www.FreeBSD.org/releases/>https://www.freebsd.org/releases/</a>) 文件來確認是否支援該硬體。若確定有支援該硬體但仍然卡住或發生其他問題，請依照 <a href=./#kernelconfig>設定 FreeBSD 核心</a> 的指示編譯自訂核心來加入未在 <span class=filename>GENERIC</span> 核心的裝置。預設的核心會假設大部份的硬體裝置會使用原廠預設的 IRQs, I/O 位址，及 DMA 通道，若硬體已經被重新設定過，自訂的核心設定檔可以告訴 FreeBSD 到那找到這些裝置。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>部份安裝問題可以透過更各種硬體元件的韌體來避免或緩解，特別是主機板。主機板的韌體通常稱為 BIOS，大部份主機板與電腦製造商會有網站可以取得升級程式與升級資訊。</p></div><div class=paragraph><p>製造商通常會建議若沒有特殊原因盡量避免升級主機板 BIOS，例如：重大更新，升級的程多<em>可能會</em>出錯，導致未更新完成的 BIOS 並讓電腦無法運作。</p></div></td></tr></tbody></table></div><div class=paragraph><p>若系統在開機偵測硬體時卡住或安裝時運作異常，可能主因為 ACPI，FreeBSD 在 i386, amd64 及 ia64 平台廣泛的使用了系統 ACPI 服務來協助設定系統組態，若在開機時有偵測到該功能。不幸的是，ACPI 驅動程式與系統主機板及 BIOS 韌體之間仍存在部份問題。可於開機載入程式的第三階段設定 <code>hint.acpi.0.disabled</code> Hint 來關閉 ACPI：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nb>set </span>hint.acpi.0.disabled<span class=o>=</span><span class=s2>&#34;1&#34;</span></code></pre></div></div><div class=paragraph><p>每一次系統重開之後便會重設，因此需要在 <span class=filename>/boot/loader.conf</span> 檔案加入 <code>hint.acpi.0.disabled="1"</code>。更多有關開機載入程式的資訊可於 <a href=./#boot-synopsis>概述</a> 取得。</p></div></div><div class=sect2><h3 id=using-live-cd>2.10. 使用 Live CD<a class=anchor href=#using-live-cd></a></h3><div class=paragraph><p>如 <a href=#bsdinstall-choose-mode>歡迎選單</a> 所示 bsdinstall 的歡迎選單提供了 <b class=button>Live CD</b> 選項，這對那些對 FreeBSD 是否為正確的作業系統尚存疑慮的人非常有幫助，這可讓這些人在安裝前測試一部份功能。</p></div><div class=paragraph><p>在使用 <b class=button>Live CD</b> 之前必須注意以下幾點事項：</p></div><div class=ulist><ul><li><p>若要增加存取權限，必須透過認証。使用者名稱為 <code>root</code> 而密碼則是空白。</p></li><li><p>系統是直接從安裝媒體上執行，比起安裝到硬碟的系統，效能可能較差。</p></li><li><p>這個選項只提供指令提示，不會有圖型化介面。</p></li></ul></div></div></div></div><div class=sect1><h2 id=basics>Chapter 3. FreeBSD 基礎<a class=anchor href=#basics></a></h2><div class=sectionbody><div class=sect2><h3 id=basics-synopsis>3.1. 概述<a class=anchor href=#basics-synopsis></a></h3><div class=paragraph><p>接下來的這一章將涵蓋 FreeBSD 作業系統的基本指令及功能。 大部份的內容在 UNIX™-like 作業系統中都是相通的。 如果您對這些內容熟悉的話，可以放心的跳過。 如果您剛接觸 FreeBSD，那您一定要仔細的讀完這章。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>如何使用 FreeBSD 的虛擬 Console。</p></li><li><p>如何在 FreeBSD 建立與管理使用者與群組。</p></li><li><p>UNIX™ 檔案權限以及 FreeBSD 檔案標記的運作方式。</p></li><li><p>預設的 FreeBSD 檔案系統配置。</p></li><li><p>FreeBSD 的磁碟組織。</p></li><li><p>如何掛載 (Mount)、卸載 (Umount) 檔案系統。</p></li><li><p>什麼是程序、Daemon 以及信號 (Signal)。</p></li><li><p>什麼是 Shell，以及如何變更您預設的登入環境。</p></li><li><p>如何使用基本的文字編輯器。</p></li><li><p>什麼是裝置 (Device) 和裝置節點 (Device node)。</p></li><li><p>如何閱讀操作手冊以獲得更多的資訊。</p></li></ul></div></div><div class=sect2><h3 id=consoles>3.2. 虛擬 Console 與終端機<a class=anchor href=#consoles></a></h3><div class=paragraph><p>如果您沒有將 FreeBSD 設定成開機時自動進入圖形化模式，系統會進入指令登入提示像是這樣的東西：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>FreeBSD/amd64 <span class=o>(</span>pc3.example.org<span class=o>)</span> <span class=o>(</span>ttyv0<span class=o>)</span>

login:</code></pre></div></div><div class=paragraph><p>第一行包含了剛開機完系統的資訊，<code>amd64</code> 代表此範例所使用的系統是執行 64-位元版本的 FreeBSD，這台主機的名稱是 <code>pc3.example.org</code>，<span class=filename>ttyv0</span> 代表這是個 "系統 Console"。第二行則是登人的提示訊息。</p></div><div class=paragraph><p>FreeBSD 是一個多使用者的系統，需要一套可以分辨不同使用者的方法。因此所有的使用者在執行程式之前必須先"<code>登入</code>"系統以取得系統內程式的存取權限。每個使用者都有一組獨一無二的使用者名稱 ("username") 及個人密碼 ("password")。</p></div><div class=paragraph><p>要登入系統 Console 需輸入在系統安裝時設定的使用者名稱，請參考 <a href=./#bsdinstall-addusers>新增使用者</a>，並按下 <kbd>Enter</kbd>。 接著輸入該使用者名稱的密碼按下 <kbd>Enter</kbd>。 輸入的密碼為了安全起見<em>不會顯示</em>在畫面上。</p></div><div class=paragraph><p>如果您輸入了正確的密碼，您應該會看到今日訊息 (Message of the day, MOTD)，後面接著顯示指令提示字元，依使用者建立時所選擇的 Shell 會有不同的提示字元可能為 <code>#</code>, <code>$</code> 或者 <code>%</code>。 看到指令提示代表使用者現在已經登入 FreeBSD 系統 Console 且已經準備好可以下指令。</p></div><div class=sect3><h4 id=consoles-virtual>3.2.1. 虛擬 Console<a class=anchor href=#consoles-virtual></a></h4><div class=paragraph><p>雖然系統 Console 已經可以用來與系統互動，但使用鍵盤來下指令使用 FreeBSD 系統的使用者通常會使用虛擬 Console 登入。 因為系統訊息預設會顯示在系統 Console，這些訊些會在使用者作業的過程中不斷出現，讓使用者難以專心作業。</p></div><div class=paragraph><p>FreeBSD 預設提供多個虛擬 Console 可輸入指令，每個虛擬 Console 都有自己的登入提示及 Shell 並且可以輕易的在虛擬 Console 間切換。 這實際上讓指令輸入有了類似於圖型化環境中可以同時開啟多個視窗的功能。</p></div><div class=paragraph><p>組合鍵 <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span> 至 <span class=keyseq><kbd>Alt</kbd>+<kbd>F8</kbd></span> 被 FreeBSD 保留用來切換虛擬 Console，使用 <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span> 可切換至系統 Console (<span class=filename>ttyv0</span>)，<span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span> 可存取第一個虛擬 Console (<span class=filename>ttyv1</span>)，<span class=keyseq><kbd>Alt</kbd>+<kbd>F3</kbd></span> 可存取第二個虛擬 Console (<span class=filename>ttyv2</span>)，以此類推。當使用 Xorg 作為圖型化 Console 時，組合鍵則改使用 <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd></span> 來切換回文字介面的虛擬 Console。</p></div><div class=paragraph><p>當您從一個 Console 切換到下一個的時候，FreeBSD 會切換畫面顯示的內容， 這就好像有很多虛擬的螢幕和鍵盤可以讓您輸入指令到 FreeBSD 執行。 在某一個虛擬 Console 上執行的程式並不會因為使用者切到別的 Console 而停止執行。</p></div><div class=paragraph><p>請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdcontrol&amp;sektion=1&amp;format=html">kbdcontrol(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=atkbd:&amp;sektion=4&amp;format=html">atkbd:(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> 來取得更多有關 FreeBSD Console 及鍵盤驅動程式的技術說明。</p></div><div class=paragraph><p>FreeBSD 中虛擬 Console 的數量設定在 <span class=filename>/etc/ttys</span> 檔案中的下列章節：</p></div><div class="literalblock programlisting"><div class=content><pre># name    getty                         type  status comments
#
ttyv0   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
# Virtual terminals
ttyv1   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv2   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv3   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv4   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv5   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv6   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv7   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv8   &#34;/usr/X11R6/bin/xdm -nodaemon&#34;  xterm   off secure</pre></div></div><div class=paragraph><p>要關閉虛擬 Console 只要在指定的虛擬 Console 該行設定的一開始加上註解符號 (<code><mark></mark></code>)。 例如要將虛擬 Console 的數量由 8 個改為 4 個，則可將 <code></code> 加在代表虛擬 Console 的 <span class=filename>ttyv5</span> 到 <span class=filename>ttyv8</span> 的最後四行一開始。 <em>請勿</em>將系統 Console <span class=filename>ttyv0</span> 加上註解符號。 注意，若有依照 <a href=./#x11>X Window 系統</a> 安裝並設定 Xorg 時，會用到最後一個虛擬 Console (<span class=filename>ttyv8</span>)。</p></div><div class=paragraph><p>有關各欄位的設定以及其他選項，請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> 說明。</p></div></div><div class=sect3><h4 id=consoles-singleuser>3.2.2. 單使用者模式<a class=anchor href=#consoles-singleuser></a></h4><div class=paragraph><p>FreeBSD 開機選單會提供一個選項為 "Boot Single User"，若選擇該項目，系統將會進入所謂 "單使用者模式" 的特殊模式。 此模式通常用在修復系統無法開機或重設已忘掉的 <code>root</code> 密碼。 在當使用者模式中無法使用網路及其他虛擬 Console，但有完整 <code>root</code> 對系統的存取權限，而且預設是不須要輸入 <code>root</code> 密碼。 也因此，要能透過實體鍵盤操作才能進入此模式，在考量 FreeBSD 系統安全時須要限制可操作實體鍵盤的人員。</p></div><div class=paragraph><p>有關單使用者模式的設定可在 <span class=filename>/etc/ttys</span> 中的以下章節中找到：</p></div><div class="literalblock programlisting"><div class=content><pre># name  getty                           type  status  comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure</pre></div></div><div class=paragraph><p>預設狀態為安全 (<code>secure</code>)，這代表誰能夠操作實體鍵盤不是不重要就是已受到實體安全規範管制。 若設定更該為不安全 (<code>insecure</code>) 則代表主機所在的環境不安全，因為任何人皆可接觸鍵盤。 當此行設定更改為不安全 (<code>insecure</code>) 時，當使用擇選擇單使用者模式時，FreeBSD 將會要求輸入 <code>root</code> 的密碼。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>請審慎考慮是否要改為</em> <code><em>insecure</em></code>！ 因為萬一忘記 <code>root</code> 密碼的話，雖然還是有其他辦法可以登入單使用者模式，只是對不熟 FreeBSD 開機程序的人可就麻煩了。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=consoles-vidcontrol>3.2.3. 更改 Console 影像模式<a class=anchor href=#consoles-vidcontrol></a></h4><div class=paragraph><p>FreeBSD Console 預設顯示大小可以調整為 1024x768、1280x1024 或其他顯示卡與螢幕有支援的解析度大小。 要使用不同的影像模式需載入 <code>VESA</code> 模組：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vesa</span></code></pre></div></div><div class=paragraph><p>要偵測硬體支援的影像模式，可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a>。 要取得支援的影像模式清單可輸入以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol -i mode</span></code></pre></div></div><div class=paragraph><p>該指令會顯示硬體所支援的影像模式清單，要採用新的影像模式需以 <code>root</code> 使用者執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> 指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol MODE_279</span></code></pre></div></div><div class=paragraph><p>若可接受新的影像模式，可以在 <span class=filename>/etc/rc.conf</span> 加入設定，讓每次重開機後會自動生效：</p></div><div class="literalblock programlisting"><div class=content><pre>allscreens_flags=&#34;MODE_279&#34;</pre></div></div></div></div><div class=sect2><h3 id=users-synopsis>3.3. 使用者與基礎帳號管理<a class=anchor href=#users-synopsis></a></h3><div class=paragraph><p>FreeBSD 允許多使用者同時使用電腦，在一次只能有一位使用者坐在電腦螢幕前使用鍵盤操作的同時，可讓任何數量的使用者透過網路登入到系統。每一位要使用該系統的使用者應有自己的帳號。</p></div><div class=paragraph><p>本章介紹：</p></div><div class=ulist><ul><li><p>FreeBSD 系統中各種類型的使用者帳號。</p></li><li><p>如何加入、移除與修改使用者帳號。</p></li><li><p>如何設定用來控制使用者與群組允許存取的資源的限制。</p></li><li><p>如何建立群組與加入使用者作為群組成員。</p></li></ul></div><div class=sect3><h4 id=users-introduction>3.3.1. 帳號類型<a class=anchor href=#users-introduction></a></h4><div class=paragraph><p>由於所有對 FreeBSD 系統的存取是透過使用者帳號來達成，且所有的程序需要經由使用者來執行，因此使用者帳號管理非常重要。</p></div><div class=paragraph><p>有三種主要類型的帳號：系統帳號、使用者帳號以及超級使用者帳號。</p></div><div class=sect4><h5 id=users-system>3.3.1.1. 系統帳號<a class=anchor href=#users-system></a></h5><div class=paragraph><p>系統帳號用來執行服務，例如 DNS、郵件及網頁伺服器，要這麼作是因為安全性考量，若所有的服務均以超級使用者來執行，那麼這些服務的運作將不會受到限制。</p></div><div class=paragraph><p>系統帳號的例子有 <code>daemon</code>, <code>operator</code>, <code>bind</code>, <code>news</code>, and <code>www</code>。</p></div><div class=paragraph><p><code>nobody</code> 是通用的無權限系統帳號。雖然如此，只有要越多的服務使用 <code>nobody</code>，就會有更多的檔案與程式與該使用者相關聯，會讓該使用者擁有更多的權限。</p></div></div><div class=sect4><h5 id=users-user>3.3.1.2. 使用者帳號<a class=anchor href=#users-user></a></h5><div class=paragraph><p>使用者帳號會分配給實際人員，用來登入及使用系統。每位要存取系統的人員需要擁有一組唯一的使用者帳號，這可讓管理者辨識誰在做什麼以及避免使用者覆蓋其他使用者的設定。</p></div><div class=paragraph><p>每位使用者可以設定自己的環境來配合自己使用系統的習慣，透過設定預設的 Shell、編輯器、組合鍵 (Key Binding) 及語言設定。</p></div><div class=paragraph><p>每個在 FreeBSD 系統的使用者帳號都會有一些相關的資訊：</p></div><div class=dlist><dl><dt class=hdlist1>使用者名稱 (User name)</dt><dd><p>在 <code>login:</code> 提示出現時便要輸入使用者名稱，每位使用者必須要有一個唯一的使用者名稱。要建立有效的使用者名稱要遵守數條規則，在 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=5&amp;format=html">passwd(5)</a> 中有說明。建議使用者名稱由 8 個或更少的字母組成，全部採用小寫字元以向下相容應用程式。</p></dd><dt class=hdlist1>密碼 (Password)</dt><dd><p>每個帳號都會有密碼。</p></dd><dt class=hdlist1>使用者 ID (UID)</dt><dd><p>使用者 ID (User ID, UID) 是一組數字用來獨一無二的辨識 FreeBSD 系統的使用者，用到使用者名稱的指令會先將使用者名稱轉換為 UID。建議使用小於 65535 的 UID，超過這個值可能會造成部份軟體的相容性問題。</p></dd><dt class=hdlist1>群組 ID (GID)</dt><dd><p>群組 ID (Group ID, GID) 是一組數字用來獨一無二的辨識使用者所屬的主要群組。群組是一個除了使用 UID 之外根據使用者的 GID 來控制資源存取權的機制。這可以顯著的降低某些設定檔的大小且可讓使用者成為一個以上群組的成員。建議使用 65535 或以下的 GID，因超過此值的 GID 可能會讓部份軟體無法運作。</p></dd><dt class=hdlist1>登入類別 (Login class)</dt><dd><p>登入類別 (Login class) 擴充了群組機制，當在對不同使用者客製化系統時可提供額外的彈性。在 <a href=./#users-limiting>設定登入類別</a> 有對登入類別更進一步的討論。</p></dd><dt class=hdlist1>密碼更改時間 (Password change time)</dt><dd><p>預設情況下密碼並不會過期，雖然如此，密碼期限可在各別使用者上開啟，可強制部份或所有使用者在某段期間過後更改他們的密碼。</p></dd><dt class=hdlist1>帳號到期時間 (Account expiration time)</dt><dd><p>預設情況下 FreeBSD 的帳號不會有期限。當建立需要有限壽命的帳號時，例如，學校的學生帳號，可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 指定帳號的到期日期。到期日期過後，便無法使用該帳號登入到系統，儘管該帳號的目錄及檔案仍存在。</p></dd><dt class=hdlist1>使用者的全名 (User’s full name)</dt><dd><p>使用者名稱用來獨一無二的辦識 FreeBSD 的帳號，但並不一定反映了使用者的真實姓名。類似註解，這個資訊可以含有空白、大寫字元並可超過 8 個字母的長度。</p></dd><dt class=hdlist1>家目錄 (Home directory)</dt><dd><p>家目錄是系統中某個目錄的完整路徑，這個目錄是使用者登入後的起點目錄。習慣上會將所有使用者目錄放置在 <span class=filename>/home/username</span> 或 <span class=filename>/usr/home/username</span>。每位使用者可以儲存他們的個人檔案及子目錄於他們自己的家目錄。</p></dd><dt class=hdlist1>使用者 Shell (User shell)</dt><dd><p>Shell 提供了使用者預設的環境來與系統互動。有數種不同類型的 Shell，有經驗的使用者會有自己偏好的選擇，可儲存在自己的帳號設定。</p></dd></dl></div></div><div class=sect4><h5 id=users-superuser>3.3.1.3. 超級使用者帳號<a class=anchor href=#users-superuser></a></h5><div class=paragraph><p>超級使用者帳號，通常稱作 <code>root</code>，用來管理系統，沒有權限的限制，也因這個原因，該帳號不應該用來做每日的例行作業，如：寄信與收信、系統的一般探索或程式設計。</p></div><div class=paragraph><p>超級使用者並不像其他使用者帳號，可以沒有限制的操作，不正確的使用超級使用者帳號可能會造成可觀的災害。一般使用者帳號不會因為失誤而法摧毀作業系統，所以建議登入一般使用者帳號，只有在指令需要額外權限時切換為超級使用者。</p></div><div class=paragraph><p>使用超級使用者下指令時永遠要再三檢查，由於一個多餘的空白或缺少的字元可能意味著無法挽回的資料遺失。</p></div><div class=paragraph><p>有數種方法可以提升為超級使用者權限，雖然可以直接登入為 <code>root</code>，但強烈不建議這樣做。</p></div><div class=paragraph><p>改使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 切換為超級使用者。執行此指令時若指定 <code>-</code> 參數，該使用者會繼承 root 的使用者環境。執行此指令的使用者必須在 <code>wheel</code> 群組中，否則指令會失敗。使用者也必須要知道 <code>root</code> 使用者帳號的密碼。</p></div><div class=paragraph><p>在此例當中，該使用者只在要執行 <code>make install</code> 時切換為超級使用者，因為這個步驟需要超級使用者權限。指令完成之後，該使用者輸入 <code>exit</code> 離開超級使用者帳號並返回他的使用者帳號權限。</p></div><div class=exampleblock><div class=title>例 2. 以超級使用者的身份安裝程式</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% configure
% make
% su -
Password:
<span class=c># make install</span>
<span class=c># exit</span>
%</code></pre></div></div></div></div><div class=paragraph><p>內建的 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 框架在單人系統或只有一位系統管理者的小型網路可以運作的很好。另一種方式是安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> 套件或 Port。此軟體提供了活動記錄且允許管理者設定那個使用者可以用超級使用者執行那個指令。</p></div></div></div><div class=sect3><h4 id=users-modifying>3.3.2. 管理帳號<a class=anchor href=#users-modifying></a></h4><div class=paragraph><p>FreeBSD 提供了各種不同指令來管理使用者帳號，最常用的指令已摘要於 <a href=#users-modifying-utilities>管理使用者帳號的工具</a>，接著有一些用法的範例。請參考每個工具的操作手冊來取得更多詳細的資訊與用法範例。</p></div><table id=users-modifying-utilities class="tableblock frame-none grid-all stretch"><caption class=title>表 2. 管理使用者帳號的工具</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">指令</th><th class="tableblock halign-left valign-top">摘要</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>建議用來新增新使用者的指令列應用程式。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>建議用來移除使用者的指令列應用程式。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>用來更改使用者資料庫資訊的工具。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>用來更改使用者密碼的指令列工具。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>用來修改使用者帳號各方面資訊強大且靈活的工具。</p></td></tr></tbody></table><div class=sect4><h5 id=users-adduser>3.3.2.1. <code>adduser</code><a class=anchor href=#users-adduser></a></h5><div class=paragraph><p>建議用來新增新使用者的程式為 <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a>。當新使用者新增之後，此程式會自動更新 <span class=filename>/etc/passwd</span> 以及 <span class=filename>/etc/group</span>，這同時也會建立新使用者的家目錄 (複製 <span class=filename>/usr/shared/skel</span> 中的預設設定檔)，並且可以選擇是否要寄送歡迎訊息通知新使用者。這個工具必須使用超級使用者執行。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> 工具採用互動的方式，只需幾個步驟便可建立新使用者帳號。如 <a href=#users-modifying-adduser>在 FreeBSD 新增使用者</a> 所示，可輸入必填的資訊或按 <kbd>Return</kbd> 鍵採用方括中的預設值。在此例當中，使用者被邀請加入 <code>wheel</code> 群組，這讓使用者可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 變成超級使用者。完成之後，此工具會詢問是否要建立其他的使用者或離開。</p></div><div id=users-modifying-adduser class=exampleblock><div class=title>例 3. 在 FreeBSD 新增使用者</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser</span>
Username: jru
Full name: J. Random User
Uid <span class=o>(</span>Leave empty <span class=k>for </span>default<span class=o>)</span>:
Login group <span class=o>[</span>jru]:
Login group is jru. Invite jru into other <span class=nb>groups</span>? <span class=o>[]</span>: wheel
Login class <span class=o>[</span>default]:
Shell <span class=o>(</span>sh csh tcsh zsh nologin<span class=o>)</span> <span class=o>[</span>sh]: zsh
Home directory <span class=o>[</span>/home/jru]:
Home directory permissions <span class=o>(</span>Leave empty <span class=k>for </span>default<span class=o>)</span>:
Use password-based authentication? <span class=o>[</span><span class=nb>yes</span><span class=o>]</span>:
Use an empty password? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span> <span class=o>[</span>no]:
Use a random password? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span> <span class=o>[</span>no]:
Enter password:
Enter password again:
Lock out the account after creation? <span class=o>[</span>no]:
Username   : jru
Password   : <span class=k>****</span>
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>: <span class=nb>yes
</span>adduser: INFO: Successfully added <span class=o>(</span>jru<span class=o>)</span> to the user database.
Add another user? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>: no
Goodbye!
<span class=c>#</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>由於密碼在輸入時並不會顯示，在建立使用者帳號時要小心密碼不要輸入錯誤。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-rmuser>3.3.2.2. <code>rmuser</code><a class=anchor href=#users-rmuser></a></h5><div class=paragraph><p>要自系統完全移除一個使用者可使用超級使用者執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a>。這個指令會執行以下步驟：</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>移除使用者的 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> 項目，若項目存在。</p></li><li><p>移除任何屬於該使用者的 <a href="https://man.freebsd.org/cgi/man.cgi?query=at&amp;sektion=1&amp;format=html">at(1)</a> 工作。</p></li><li><p>中止所有該使用者擁有的程序。</p></li><li><p>自系統本地密碼檔移除該使用者。</p></li><li><p>選擇性移除該使用者的家目錄，若使用者擁有該目錄。</p></li><li><p>自 <span class=filename>/var/mail</span> 移除屬於該使用者的收件郵件檔。</p></li><li><p>自暫存檔儲存區域 (如 <span class=filename>/tmp</span>) 移除所有使用者擁有的檔案。</p></li><li><p>最後，自 <span class=filename>/etc/group</span> 中該使用者所屬的所有群組移除該使用者。若群組無任何成員且群組名稱與該使用者名稱相同，則該群組也會一併移除。這是為了輔助</p></li></ol></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> 替每位使用者建立獨一無二的群組。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> 無法用來移除超級使用者帳號，因為這幾乎代表著大規模破壞。</p></div><div class=paragraph><p>預設會使用互動式模式，如下範例所示。</p></div><div class=exampleblock><div class=title>例 4. <code>rmuser</code> 互動式帳號移除</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rmuser jru</span>
Matching password entry:
jru:<span class=k>*</span>:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user<span class=s1>&#39;s home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
#</span></code></pre></div></div></div></div></div><div class=sect4><h5 id=users-chpass>3.3.2.3. <code>chpass</code><a class=anchor href=#users-chpass></a></h5><div class=paragraph><p>任何使用者都可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> 來變更自己的預設 Shell 以及與自己的使用者帳號關聯的個人資訊。超級使用者可以使用這個工具更改任何使用者的其他帳號資訊。</p></div><div class=paragraph><p>除了選填的使用者名稱外，未傳入任何選項時，<a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> 會開啟含有使用者資訊的編輯器。當使用者自編輯器離開，便會更新新的資訊到使用者資料庫。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>離開編輯器時，此工具會提示使用者輸入密碼，除非使用超級使用者執行此工具。</p></div></td></tr></tbody></table></div><div class=paragraph><p>在 <a href=#users-modifying-chpass-su>以超級使用者的身份使用 <code>chpass</code></a> 中，超級使用者輸入了 <code>chpass jru</code> 並正在檢視這個使用者可以更改的欄位。若改以 <code>jru</code> 執行這個指令，只會顯示最後六個欄位供編輯，如 <a href=#users-modifying-chpass-ru>以一般使用者的身份使用 <code>chpass</code></a> 所示。</p></div><div id=users-modifying-chpass-su class=exampleblock><div class=title>例 5. 以超級使用者的身份使用 <code>chpass</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Login: jru
Password: <span class=k>*</span>
Uid <span class=o>[</span><span class=c>#]: 1001</span>
Gid <span class=o>[</span><span class=c># or name]: 1001</span>
Change <span class=o>[</span>month day year]:
Expire <span class=o>[</span>month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div id=users-modifying-chpass-ru class=exampleblock><div class=title>例 6. 以一般使用者的身份使用 <code>chpass</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>指令 <a href="https://man.freebsd.org/cgi/man.cgi?query=chfn&amp;sektion=1&amp;format=html">chfn(1)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a> 皆連結至 <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a>，就如同 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchpass&amp;sektion=1&amp;format=html">ypchpass(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchfn&amp;sektion=1&amp;format=html">ypchfn(1)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchsh&amp;sektion=1&amp;format=html">ypchsh(1)</a> 的關係。自從 NIS 支援自動化以後，便不再需要特別加上 <code>yp</code>，如何設定 NIS 在<a href=./#network-servers>網路伺服器</a> 中有說明。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-passwd>3.3.2.4. <code>passwd</code><a class=anchor href=#users-passwd></a></h5><div class=paragraph><p>任何使用者皆可簡單的使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 更改自己的密碼。要避免意外或未授權的變更，這個指令在設定新密碼之前會提示使用者輸入原來的密碼：</p></div><div class=exampleblock><div class=title>例 7. 更改您的密碼</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class=paragraph><p>超級使用者可以更改任何使用者的密碼透過在執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 時指定使用者名稱。當此工具以超級使用者執行時，將不會提示輸入使用者目前的密碼，這可在使用者忘記原來的密碼時更改密碼。</p></div><div class=exampleblock><div class=title>例 8. 以超級使用者的身份更改其他使用者的密碼</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># passwd jru</span>
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>如同 <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a>，<a href="https://man.freebsd.org/cgi/man.cgi?query=yppasswd&amp;sektion=1&amp;format=html">yppasswd(1)</a> 連結到 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a>，因此 NIS 在兩個指令上皆可運作。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-pw>3.3.2.5. <code>pw</code><a class=anchor href=#users-pw></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 工具可以建立、移除、修改以及顯示使用者與群組，它的功能是做為系統使用者與群組檔的前端。<a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 有非常強大的的指令列選項集，這讓該指令非常適合用於 Shell scripts，但新的使用者可能會發現它比其他在本節的指令要複雜許多。</p></div></div></div><div class=sect3><h4 id=users-groups>3.3.3. 管理群組<a class=anchor href=#users-groups></a></h4><div class=paragraph><p>群組代表一群使用者，群組可以由其群組名稱及 GID 來辨識。在 FreeBSD，核心會使用程序的 UID 以及其所屬的群組清單來決定程序可以做那些事。大多數情況使用者或程序的 GID 通常指的是清單中的第一個群組。</p></div><div class=paragraph><p>群組名稱與 GID 的對應表列在 <span class=filename>/etc/group</span>。這個純文字檔案使用了四個以冒號分隔的欄位，第一個欄位為群組名稱，第二個欄位為加密後的密碼，第二個欄位為 GID 以及第四個欄位為以逗號分隔的成員清單。要取得更完整的語法說明，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a>。</p></div><div class=paragraph><p>超級使用者可以使用文字編輯器修改 <span class=filename>/etc/group</span>，或者可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 加入與編輯群組。例如，要加入一個叫做 <code>teamtwo</code> 的群組然後確認該群組已新增：</p></div><div class=exampleblock><div class=title>例 9. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 新增群組</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd teamtwo</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:</code></pre></div></div></div></div><div class=paragraph><p>在本例中，<code>1100</code> 是 <code>teamtwo</code> 的 GID。目前 <code>teamtwo</code> 沒有任何成員，這個指令會加入 <code>jru</code> 作為 <code>teamtwo</code> 的成員。</p></div><div class=exampleblock><div class=title>例 10. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 加入使用者帳號到新的群組</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod teamtwo -M jru</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:jru</code></pre></div></div></div></div><div class=paragraph><p>給 <code>-M</code> 的參數是以逗號分隔的使用者清單，用來加入成員到新的 (空的) 群組或取代既有群組中的成員。對使用者來說這裡的群組成員與使用者列於密碼檔的主要群組不同 (額外的)，這代表在 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 使用 <code>groupshow</code> 時不會顯示做為使用者主要群組的成員，但會顯示在使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> 或同類工具所查詢的資訊當中。當使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 來加入使用者到某個群組，該指令只會處理 <span class=filename>/etc/group</span> 且不會嘗試自 <span class=filename>/etc/passwd</span> 讀取其他的資料。</p></div><div class=exampleblock><div class=title>例 11. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 加入新成員到群組</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod teamtwo -m db</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:jru,db</code></pre></div></div></div></div><div class=paragraph><p>在本例當中，給 <code>-m</code> 的參數是以逗號分隔的使用者清單，用來加入使用者到群組。不像前面的例子，這些使用者會加入到群組，而非取代既有群組中的使用者。</p></div><div class=exampleblock><div class=title>例 12. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> 來查看所屬群組</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>id </span>jru
<span class=nv>uid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nb>groups</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span>, 1100<span class=o>(</span>teamtwo<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>在本例中，<code>jru</code> 是群組 <code>jru</code> 以及 <code>teamtwo</code> 的成員。</p></div><div class=paragraph><p>要取得更多有關此指令的資訊及 <span class=filename>/etc/group</span> 的格式，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a>。</p></div></div></div><div class=sect2><h3 id=permissions>3.4. 權限<a class=anchor href=#permissions></a></h3><div class=paragraph><p>在 FreeBSD 中，每個檔案與目都有相關聯的數個權限，且有許多工具可以檢視與修改這些權限。了解權限如何運作是必須的，這可確保使用者能夠存存取它們所需的檔案以及無法不正確的存取供作業系統或其他使用者擁有的檔案。</p></div><div class=paragraph><p>本節會探討在 FreeBSD 中所用到的傳統 UNIX™ 權限。要做檔案系統存取控制的微調，請參考 <a href=./#fs-acl>存取控制清單</a>。</p></div><div class=paragraph><p>在 UNIX™，基礎權限透過三種類型的存取來分配：讀取、寫入與執行。這些存取類型用來決定檔案擁有者、群組以及其他人 (其他任何人) 的檔案存取權。讀取、寫入及執行權限可使用 <code>r</code>, <code>w</code>, and <code>x</code> 字母來表示。這些權限也可以使用二進位數字來表示每種權限的開或關 (<code>0</code>)。當以二進位數字來表示時，閱讀的順序為 <code>rwx</code>，其中 <code>r</code> 開啟的值為 <code>4</code>，<code>w</code> 開啟的值為 <code>2</code> 以及 <code>x</code> 開啟的值為 <code>1</code>。</p></div><div class=paragraph><p>表格 4.1 摘要了可用的數字及可用的字母。當閱讀 "目錄清單標示" 欄位時，<code>-</code> 用來代表該權限設為關閉。</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>表 3. UNIX™ 權限</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">數值</th><th class="tableblock halign-left valign-top">權限</th><th class="tableblock halign-left valign-top">目錄清單標示</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>不可讀取, 不可寫入, 不可執行</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>---</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>不可讀取, 不可寫入, 可執行</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>--x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>不可讀取, 可寫入, 不可執行</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-w-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>不可讀取, 可寫入, 可執行</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-wx</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>可讀取, 不可寫入, 不可執行</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r--</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>可讀取, 不可寫入, 可執行</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r-x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>可讀取, 可寫入, 不可執行</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rw-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>可讀取, 可寫入, 可執行</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rwx</code></p></td></tr></tbody></table><div class=paragraph><p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> 指令時，可以加上 <code>-l</code> 參數， 來檢視詳細的目錄清單。 清單中欄位的資訊包含檔案對所有者、群組及其他人的權限。 在任一個目錄底下執行 <code>ls -l</code>，會顯示如下的結果：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=nt>-l</span>
total 530
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 myfile
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 otherfile
<span class=nt>-rw-r--r--</span>  1 root  wheel    7680 Sep  5 12:31 email.txt</code></pre></div></div><div class=paragraph><p>第一個 (最左邊) 的字元用來表示這個檔案的類型為何，除標準檔案以外，尚有目錄、特殊字元裝置、Socket 及其他特殊虛擬檔案裝置， 在此例當中，<code>-</code> 表示該檔案為一個標準的檔案。 範例中接下來的三個字元中，<code>rw-</code> 代表所有者對檔案擁有的權限。 再接下來的三個字元， <code>r--</code> 則代表群組對檔案擁有的權限， 最後三個字元，<code>r--</code> 則代表其他人對檔案擁有的權限。 破折號 (-) 表示沒有權限，範例中的這個檔案的權限， 只允許所有者讀取、寫入檔案，群組以及其他人僅能讀取檔案。 根據以上的表格，此種權限的檔案可以使用 <code>644</code> 來表示， 每組數字分別代表檔案的三種權限。</p></div><div class=paragraph><p>那系統如何控制裝置的權限？ 實際上 FreeBSD 對大多的硬碟裝置就如同檔案，程式可以開啟、讀取以及寫入資料如一般檔案。 這些特殊裝置檔案都儲存於 <span class=filename>/dev/</span> 目錄中。</p></div><div class=paragraph><p>目錄也同如檔案，擁有讀取、寫入及執行的權限， 但在執行權限上與檔案有明顯的差異。 當目錄被標示為可執行時，代表可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cd&amp;sektion=1&amp;format=html">cd(1)</a> 指令切換進入該目錄。 也代表能夠存取在此目錄之中的已知檔名的檔案，但仍會受限於檔案本身所設定的權限。</p></div><div class=paragraph><p>要能夠列出目錄內容，必須擁有目錄的讀取權限。 要刪除已知檔名的檔案，必須擁有檔案所在目錄的寫入 <em>以及</em> 執行的權限。</p></div><div class=paragraph><p>還有一些權限位元，但這些權限主要在特殊情況使用，如 setuid 執行檔及 sticky 目錄。 如果您還想知道更多檔案權限的資訊及使用方法，請務必參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>。</p></div><div class=sect3><h4 id=_權限符號>3.4.1. 權限符號<a class=anchor href=#_權限符號></a></h4><div class=paragraph><p>權限符號可稱做符號表示，使用字元的方式來取代使用數值來設定檔案或目錄的權限。 符號表示的格式依序為 (某人)(動作)(權限)，可使用的符號如下：</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">項目</th><th class="tableblock halign-left valign-top">字母</th><th class="tableblock halign-left valign-top">代表意義</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(某人)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>u</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>使用者</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(某人)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>g</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>群組所有者</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(某人)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>o</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>其他</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(某人)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>全部 ("world")</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(動作)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>增加權限</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(動作)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>移除權限</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(動作)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>=</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>指定權限</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(權限)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>r</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>讀取</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(權限)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>w</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>寫入</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(權限)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>x</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>執行</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(權限)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>t</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sticky 位元</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(權限)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>s</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>設定 UID 或 GID</p></td></tr></tbody></table><div class=paragraph><p>如先前同樣使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> 指令來設定，但使用的參數為這些字元。 例如，您可以使用下列指令禁止其他使用者存取檔案 <em>FILE</em>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span><span class=nv>go</span><span class=o>=</span> FILE</code></pre></div></div><div class=paragraph><p>若有兩個以上的權限更改可以使用逗號 (,) 區隔。 例如，下列指令將會移除群組及全部人 ("world") 對檔案 <em>FILE</em> 的寫入權限， 並使全部人對該檔有執行權限：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>go-w,a+x FILE</code></pre></div></div></div><div class=sect3><h4 id=_freebsd_檔案旗標>3.4.2. FreeBSD 檔案旗標<a class=anchor href=#_freebsd_檔案旗標></a></h4><div class=paragraph><p>除了前面提到的檔案權限外，FreeBSD 支援使用 "檔案旗標"。 這些旗標增加了檔案的安全性及管理性，但不包含目錄。有了檔案旗標可確保在某些時候 <code>root</code> 不會意外將檔案修改或移除。</p></div><div class=paragraph><p>修改的檔案 flag 僅需要使用擁有簡易的介面的 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> 工具。 例如，標示系統禁止刪除的旗標於檔案 <span class=filename>file1</span>，使用下列指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags sunlink file1</span></code></pre></div></div><div class=paragraph><p>若要移除系統禁止刪除的旗標，只需要簡單在 <code>sunlink</code> 前加上 "no"，例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags nosunlink file1</span></code></pre></div></div><div class=paragraph><p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> 及參數 <code>-lo</code> 可檢視檔案目前的旗標：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -lo file1</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</pre></div></div><div class=paragraph><p>多數的旗標僅能由 <code>root</code> 使用者來標示或移除，而部份旗標可由檔案所有者設定。 我們建議系統管理者可閱讀 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> 及 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=2&amp;format=html">chflags(2)</a> 說明以瞭解相關細節。</p></div></div><div class=sect3><h4 id=_setuid_setgid_與_sticky_權限>3.4.3. <code>setuid</code> 、<code>setgid</code> 與 <code>sticky</code> 權限<a class=anchor href=#_setuid_setgid_與_sticky_權限></a></h4><div class=paragraph><p>除了已經探討過的權限外，這裡尚有另外三種特別的設定所有管理者都應該知道，這些設定為 <code>setuid</code>, <code>setgid</code> 以及 <code>sticky</code> 權限。</p></div><div class=paragraph><p>這些設定對某些一般不會授權給一般使用者的 UNIX™ 操作非常重要，它讓這些功能可運作。要了解這些權限，就必須說明真實使用者 ID (Real user ID) 與有效使用者 ID (Effective user ID) 的差異。</p></div><div class=paragraph><p>真實使用者 ID 即是擁有者或啟動程序者的 UID，而有效 UID 是執行程序所使用的使用者 ID。例如，<a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 在使用者更改自己的密碼時會以真實使用者 ID 執行，然而，為了要更新密碼資料庫，該指令必須以 <code>root</code> 使用者做為有效 ID 來執行，這讓使用者可以更改自己的密碼而不會遇到權限不足 (<code>Permission Denied</code>) 的錯誤。</p></div><div class=paragraph><p>setuid 權限可以透過在權限集前加上數字 (4) 來設定，如下範例所示：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 4755 suidexample.sh</span></code></pre></div></div><div class=paragraph><p>現在 <span class=filename>suidexample.sh</span> 的權限會如下所示：</p></div><div class="literalblock programlisting"><div class=content><pre>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</pre></div></div><div class=paragraph><p>注意，<code>s</code> 現在取代了原來的執行位元成為指定檔案擁有者權限集的一部份，這會允許須要提升權限的工具，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 可正常使用。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 的 <code>nosuid</code> 選項會造成這類 Binary 執行失敗，但不會警告使用者。由於 <code>nosuid</code> Wrapper 可能可繞過該選項，因此該選項並非完全可靠。</p></div></td></tr></tbody></table></div><div class=paragraph><p>實際來看這個範例，先開啟兩個終端機，其中一個用一般使用者輸入 <code>passwd</code>。在等待輸入新密碼的同時，檢查程序表並查看 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 程序的使用者資訊：</p></div><div class=paragraph><p>於終端機 A：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Changing <span class=nb>local </span>password <span class=k>for </span>trhodes
Old Password:</code></pre></div></div><div class=paragraph><p>於終端機 B：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps aux | grep passwd</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 <span class=nb>grep </span>passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</code></pre></div></div><div class=paragraph><p>雖然使用一般使用者來執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a>，但該程序使用了 <code>root</code> 的有效 UID。</p></div><div class=paragraph><p><code>setgid</code> 權限的功能與 <code>setuid</code> 相似，當應用程式或工具使用此設定執行時，將會以擁有該檔案的群組來執行，而非執行行該程序的使用者。</p></div><div class=paragraph><p>要在檔案設定 <code>setgid</code> 權限，需在 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> 的參數前加上 (2)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 2755 sgidexample.sh</span></code></pre></div></div><div class=paragraph><p>注意以下清單中，<code>s</code> 現在位於指定群組權限設定的欄位：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-rwxr-sr-x</span>   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>在以上這些範例中，雖然在例子中的 Shell script 是可執行的檔案，但並不會以其他的 EUID 或有效使用者 ID 執行，這是因為 Shell script 並不會存取 <a href="https://man.freebsd.org/cgi/man.cgi?query=setuid&amp;sektion=2&amp;format=html">setuid(2)</a> 系統呼叫 (System call)。</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>setuid</code> 及 <code>setgid</code> 權限位元可能會因允許提升權限而降低系統的安全性，因此有了第三個特殊的權限：<code>sticky bit</code>，可以加強系統的安全性。</p></div><div class=paragraph><p>當在目錄上設定 <code>sticky bit</code>，將只允許由檔案擁有者刪除檔案。這對避免公開目錄，如 <span class=filename>/tmp</span> 中的檔案被不擁有該檔案的人刪除非常有用。要使用這個權限，可在權限集前加上 (1)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 1777 /tmp</span></code></pre></div></div><div class=paragraph><p><code>sticky bit</code> 權限會以 <code>t</code> 顯示於權限集的最後：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -al / | grep tmp</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</code></pre></div></div></div></div><div class=sect2><h3 id=dirstructure>3.5. 目錄結構<a class=anchor href=#dirstructure></a></h3><div class=paragraph><p>認識 FreeBSD 的目錄架構，就可對系統有概略的基礎理解。 最重要的莫過於整個目錄的根目錄，就是 "/" 目錄， 該目錄會在開機時最先掛載 (mount)，裡面會有開機所會用到必備檔案。 此外，根目錄還有紀錄其他檔案系統的掛載點相關設定。</p></div><div class=paragraph><p>「掛載點」就是讓新增的檔案系統，能接到上層的檔案系統 (通常就是「根目錄」檔案系統) 的目錄。 在 <a href=#disk-organization>磁碟組織</a> 這邊對此有更詳細介紹。 標準的掛載點包括了 <span class=filename>/usr/</span>, <span class=filename>/var/</span>, <span class=filename>/tmp/</span>, <span class=filename>/mnt/</span> 以及 <span class=filename>/cdrom/</span>。 這些目錄通常會記錄在 <span class=filename>/etc/fstab</span> 設定檔內。 <span class=filename>/etc/fstab</span> 是記錄各檔案系統及相關掛載點的表格。 大部分在 <span class=filename>/etc/fstab</span> 有記錄的檔案系統，會在開機時由 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> Script 來自動掛載，除非它們有設定 <code>noauto</code> 選項。 其中細節說明可參閱 <a href=#disks-fstab><span class=filename>fstab</span> 檔</a>。</p></div><div class=paragraph><p>有關檔案系統架構的完整說明可參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a>。 現在呢，讓我們大致先一窺常見的目錄有哪些吧。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">目錄</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>檔案系統的根目錄。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>單使用者 (Single-user)、多使用者 (Multi-user) 兩種模式皆可使用的基本工具 。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>作業系統開機過程會用到的程式、設定檔。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>預設的開機啟動設定檔，詳情請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>裝置節點 (Device node)，詳情請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=intro&amp;sektion=4&amp;format=html">intro(4)</a>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>系統設定檔及一些 Script 檔。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>預設的系統設定檔，詳情請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>郵件傳輸代理程式，像是 <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> 的相關設定檔。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/periodic/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>每日、每週、每月透過 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>，執行的定期排程 Script，詳情請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 設定檔。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/mnt/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>系統管理者慣用充當臨時掛載點的空目錄。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/proc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>程序 (Process) 檔案系統，詳情請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a> 及 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_procfs&amp;sektion=8&amp;format=html">mount_procfs(8)</a>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/rescue/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>緊急救援用途的一些靜態連結 (Statically linked) 的程式，詳情請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=rescue&amp;sektion=8&amp;format=html">rescue(8)</a>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/root/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>root</code> 帳號的家目錄。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>供單使用者 (Single-user) 及多使用者 (Multi-user) 環境使用的系統程式及管理工具 。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>臨時檔案。 一般而言，重開機之後 /tmp 內的東西會被<em>清除</em>掉。 而通常會將以記憶體為基礎 (Memory-based) 的檔案系統掛載在 <span class=filename>/tmp</span> 上。 這些瑣事可透過 tmpmfs 相關的 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 環境變數來自動完成 。(或是在 <span class=filename>/etc/fstab</span> 內做設定， 詳情請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>主要是使用者所安裝的工具程式、應用程式存放處。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>常用工具、開發工具、應用軟體。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/include/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>標準 C include 檔案。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/lib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>程式庫存放處。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libdata/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>其他各式工具的資料檔。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libexec/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>系統 Daemon 及系統工具程式 (透過其他程式來執行)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>存放一些自行安裝的執行檔、程式庫等等。 同時，也是 FreeBSD Port 架構的預設安裝目錄。 <span class=filename>/usr/local</span> 內的目錄架構大致與 <span class=filename>/usr</span> 相同，詳情請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a> 說明。 但 man 目錄例外，它們是直接放在 <span class=filename>/usr/local</span> 底下，而非 <span class=filename>/usr/local/share</span>，而 Port 所安裝的說明文件則在 <span class=filename>share/doc/port</span>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/obj/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>在編譯 <span class=filename>/usr/src</span> 目錄時所產生的相關架構目地檔。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD Port 套件集 (選用)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>由使用者執行的系統 Daemon 及系統工具。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/shared/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>各架構皆共通的檔案。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BSD 原始碼 (或自行新增的)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>存放各種用途的日誌 (Log) 檔、臨時或暫時存放、列印或郵件的緩衝 (Spool) 檔案。有時候，以記憶體為基礎 (Memory-based) 的檔案系統也會掛載在 <span class=filename>/var</span>。 這些瑣事可透過 varmfs 相關的 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 環境變數來自動完成。(或是在 <span class=filename>/etc/fstab</span> 內做設定，相關細節請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/log/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>各項系統記錄的日誌 (Log) 檔。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>各使用者的郵件 (Mailbox) 檔案。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/spool/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>各種印表機、郵件系統的緩衝 (Spool) 目錄。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>臨時檔案。 這些檔案在重開機後通常仍會保留，除非 <span class=filename>/var</span> 是屬於以記憶體為基礎 (Memory-based) 的檔案系統。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/yp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS 對應表。</p></td></tr></tbody></table></div><div class=sect2><h3 id=disk-organization>3.6. 磁碟組織<a class=anchor href=#disk-organization></a></h3><div class=paragraph><p>FreeBSD 用來尋找檔案的最小單位就是檔案的名稱了。 檔案的名稱有大小寫之分，所以說 <span class=filename>readme.txt</span> 和 <span class=filename>README.TXT</span> 是兩個不同的檔案。 FreeBSD 並不使用副檔名 (.txt) 來判別這是一個程式檔、文件檔或是其他類型的檔案。</p></div><div class=paragraph><p>檔案存在目錄裡面。 一個目錄中可能沒有任何檔案，也可能有好幾百個檔案。 目錄之中也可以包含其他的目錄； 您可以建立階層式的目錄以便資料的管理。</p></div><div class=paragraph><p>檔案或目錄的對應是藉由給定的檔案或目錄名稱，然後加上正斜線符號 (<code>/</code>)；之後再視需要加上其他的目錄名稱。 如果您有一個目錄 <span class=filename>foo</span> ，裡面有一個目錄叫作 <span class=filename>bar</span>，這個目錄中又包含了一個叫 <span class=filename>readme.txt</span> 的檔案，那麼這個檔案的全名，或者說檔案的<em>路徑 (Path)</em>就是 <span class=filename>foo/bar/readme.txt</span>。注意這與 Windows™ 用來分隔檔案與目錄名稱所使用的 <code>\</code> 不同，且 FreeBSD 在路徑上並不使用磁碟機代號或其他磁碟機名稱，意思是，在 FreeBSD 上不會有人輸入 <span class=filename>c:\foo\bar\readme.txt</span> 這種路徑。</p></div><div class=paragraph><p>目錄及檔案儲存在檔案系統 (File system) 之中。 每個檔案系統都有唯一一個最上層的目錄，叫做<em>根目錄 (Root directory)</em>。 然後在這個根目錄下面才能有其他的目錄。其中一個檔案系統會被指定成為<em>根檔案系統 (Root file system)</em> 或 <code>/</code>，其他的檔案系統均會<em>掛載 (Mount)</em> 在該根檔案系統之下，不論在 FreeBSD 有多少個磁碟，所有目錄都會成為該磁碟的一部份。</p></div><div class=paragraph><p>假設您有三個檔案系統，分別叫作 <code>A</code>, <code>B</code> 及 <code>C</code>。 每個檔案系統都包含兩個目錄，叫做 <code>A1</code>, <code>A2</code> (以此類推得 <code>B1</code>, <code>B2</code> 及 <code>C1</code>, <code>C2</code>)。</p></div><div class=paragraph><p>稱 <code>A</code> 為主要的檔案系統；如果您用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> 指令查看此目錄的內容，您會看到兩個子目錄： <code>A1</code> 及 <code>A2</code>，如下所示：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir1.png alt="example dir1"></div></div><div class=paragraph><p>一個檔案系統必須以目錄形式掛載於另一個檔案系統上。 因此，假設您將 <code>B</code> 掛載於 <code>A1</code> 之上，則 <code>B</code> 的根目錄就變成了 <code>A1</code>，而在 <code>B</code> 之下的任何目錄的路徑也隨之改變：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir2.png alt="example dir2"></div></div><div class=paragraph><p>在 <code>B1</code> 或 <code>B2</code> 目錄中的任何檔案必須經由路徑 <span class=filename>/A1/B1</span> 或 <span class=filename>/A1/B2</span> 才能達到。 所有原來在 <span class=filename>/A1</span> 中的檔案會暫時被隱藏起來，直到 <code>B</code> 被<em>卸載 (Unmount)</em> 後才會再顯現出來。</p></div><div class=paragraph><p>如果 <code>B</code> 掛載在 <code>A2</code> 之上，則會變成：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir3.png alt="example dir3"></div></div><div class=paragraph><p>上面的路徑分別為 <span class=filename>/A2/B1</span> 及 <span class=filename>/A2/B2</span>。</p></div><div class=paragraph><p>檔案系統可以掛在其他檔案系統的目錄之上。 延續之前的例子，<code>C</code> 檔案系統可以掛在檔案系統 <code>B</code> 的 <code>B1</code> 目錄之上，如圖所示：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir4.png alt="example dir4"></div></div><div class=paragraph><p>或者 <code>C</code> 直接掛載於 <code>A</code> 的 <code>A1</code> 目錄之上：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir5.png alt="example dir5"></div></div><div class=paragraph><p>您可以使用單一的一個大的根檔案系統而不建立其他的檔案系統。 這樣有好處也有有壞處。</p></div><div class=ulist><div class=title>使用多個檔案系統的好處</div><ul><li><p>不同的檔案系統在掛上的時候可以有不同的 <em>掛載參數 (Mount option)</em>。 舉例來說，為求謹慎您可以將根檔案系統設成唯讀， 以避免不小心刪除或修改掉重要的檔案。 將使用者可寫入的檔案系統 (例如 <span class=filename>/home</span>) 獨立出來也可以讓他們用 <em>nosuid</em> 的參數掛載，此選項可以讓在這個檔案系統中執行檔的 <em>suid</em>/<em>guid</em> 位元失效，可讓系統更安全。</p></li><li><p>FreeBSD 會自動根據您檔案系統的使用方式來做最佳的檔案配置方式。 因此，一個有很多小檔案、 常常寫入的檔案系統跟只有幾個較大的檔案的檔案系統配置是不一樣的。 如果您只有單一個大的檔案系統，這部分就沒用了。</p></li><li><p>FreeBSD 的檔案系統在停電的時候很穩固。 然而，在某些重要的時候停電仍然會對檔案系統結構造成損害。 分割成許多個檔案系統的話在系統在停電後比較能夠正常啟動， 以便您在需要的時候將備份資料回存回來。</p></li></ul></div><div class=ulist><div class=title>使用單一檔案系統的好處</div><ul><li><p>檔案系統的大小是固定的。 若您在當初安裝 FreeBSD 的時指定了一個大小，可是後來您想把空間加大，在沒有備份的情況下很難達成，您必須將檔案系統重新建立為您需要的大小，然後將備份回存回來。</p><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>FreeBSD 的 <a href="https://man.freebsd.org/cgi/man.cgi?query=growfs&amp;sektion=8&amp;format=html">growfs(8)</a> 指令可以突破此限制直接變更檔案系統的大小。</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>檔案系統放在分區 (Partition) 中。 因為 FreeBSD 承襲 UNIX™ 架構，這邊講的分區和一般提到的分割區 (例如 MS-DOS™ 分割區) 不同。每一個分區由一個代號 (字母) 表示，從 <code>a</code> 到 <code>h</code>。 每個分區只能含有一個檔案系統，因此在表示檔案系統時，除了用該檔案系統的常用的掛載點表示外，也可以使用該檔案系統所在的分區來表示。</p></div><div class=paragraph><p>FreeBSD 也會使用磁碟空間作為<em>交換空間 (Swap space)</em> 來提供<em>虛擬記憶體 (Virtual memory)</em>。 這讓您的電腦好像擁有比實際更多的記憶體。 當 FreeBSD 的記憶體用完的時候，它會把一些目前沒用到的資料移到交換空間，然後在用到的時候移回去 (同時移出部份沒用到的)。</p></div><div class=paragraph><p>有些分割區有特定的使用慣例。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">分區</th><th class="tableblock halign-left valign-top">慣例</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>通常含有根檔案系統。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>b</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>通常含有交換空間。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>c</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>通常用來代表整個切割區 (Slice)，因此大小會與其所在的切割區一樣。這可讓需要對整個切割區處理的工具 (例如硬碟壞軌檢查工具) 可在 <code>c</code> 分區上執行。一般來說不會把檔案系統建立在這個分區。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>分區 <code>d</code> 曾經有代表特殊意義，但是已經不再使用。所以現在 <code>d</code> 和一般的分區相同。</p></td></tr></tbody></table><div class=paragraph><p>在 FreeBSD 的磁碟會分割成數個切割區 (Slice)，如同 Windows™ 中由編號 1 到 4 表示的分割區。這些切割區會再分成數個分區，每個分區內含檔案系統，且會使用字母來標示。</p></div><div class=paragraph><p>切割區的編號在裝置名稱後面，會先以 <code>s</code> 為字首，然後從 1 開始編號。 因此 "da0<em>s1</em>" 是指第一個 SCSI 硬碟的第一個切割區。 一個磁碟上只能有四個實體切割區，但是在實體切割區中放進適當類型的邏輯切割區。這些延伸的切割區編號會從 5 開始，所以 "ada0<em>s5</em>" 是第一個 SATA 硬碟上的第一個延伸切割區。因此可以預期這些由檔案系統使用的裝置 (Device) 上均會各別佔據一個切割區。</p></div><div class=paragraph><p>切割區、"危險專用 (Dangerously dedicated)" 的實體磁碟機以及其他內含<em>分割區 (Partition)</em> 的磁碟都是以字母 <code>a</code> 到 <code>h</code> 來表示。 字母會接在裝置名稱的後面，因此 "da0<em>a</em>" 是第一顆 "dangerously dedicated" 磁碟機 <code>da</code> 上的 <code>a</code> 分割區。 而 "ada1s3<em>e</em>" 則是第二顆 SATA 硬碟上第三個切割區的第五個分區。</p></div><div class=paragraph><p>終於，我們可以辨識系統上的每個磁碟了，一個磁碟的名稱會有一個代碼來表示這個磁碟的類型，接著是一個表示這是那一個磁碟的編號。不像切割區，磁碟的編號從 0 開始。常見的代碼可以參考 <a href=#disks-naming>磁碟裝置名稱</a>。</p></div><div class=paragraph><p>當要參照一個分區的時候，需包含磁碟機名稱、<code>s</code>、切割區編號以及分區字母。範例可以參考 <a href=#basics-disk-slice-part>磁碟、切割區及分區命名範例</a>。</p></div><div class=paragraph><p><a href=#basics-concept-disk-model>磁碟的概念模型</a> 示範了一個基本的磁碟配置，相信對您有些幫助。</p></div><div class=paragraph><p>要安裝 FreeBSD，您必須先建置磁碟的切割區，接著於切割區中建立要給 FreeBSD 用的分區。 最後在這些分區中建立檔案系統 (或交換空間) 並決定要將這些檔案系統掛載於哪裡。</p></div><table id=disks-naming class="tableblock frame-none grid-all stretch"><caption class=title>表 4. 磁碟裝置名稱</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">磁碟機類型</th><th class="tableblock halign-left valign-top">磁碟機裝置稱</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SATA 及 IDE 硬碟</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ada</code> 或 <code>ad</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI 硬碟與 USB 儲存裝置</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>da</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SATA 與 IDECD-ROM 光碟機</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code> 或 <code>acd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSICD-ROM 光碟機</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>軟碟機</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>各種非標準 CD-ROM 光碟機</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>mcd</code> 代表 Mitsumi CD-ROM 以及 <code>scd</code> 代表 Sony CD-ROM 光碟機</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI 磁帶機</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>sa</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>IDE 磁帶機</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ast</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RAID 磁碟機</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>範例包含 <code>aacd</code> 代表 Adaptec™ AdvancedRAID，<code>mlxd</code> 及 <code>mlyd</code> 代表 Mylex™，<code>amrd</code> 代表 AMI MegaRAID™，<code>idad</code> 代表 Compaq Smart RAID，<code>twed</code> 代表 3ware™ RAID.</p></td></tr></tbody></table><div id=basics-disk-slice-part class=exampleblock><div class=title>例 13. 磁碟、切割區及分區命名範例</div><div class=content><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">名稱</th><th class="tableblock halign-left valign-top">意義</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ada0s1a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>第一個 SATA 硬碟 (<code>ada0</code>) 上第一個切割區 (<code>s1</code>)的第一個分區(<code>a</code>) 。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>da1s2e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>第二個 SCSI 硬碟 (<code>da1</code>) 上第二個切割區 (<code>s2</code>) 的第五個分區 (<code>e</code>) 。</p></td></tr></tbody></table></div></div><div id=basics-concept-disk-model class=exampleblock><div class=title>例 14. 磁碟的概念模型</div><div class=content><div class=paragraph><p>此圖顯示 FreeBSD 中連接到系統的第一個 SATA 磁碟機內部配置圖。 假設這個磁碟的容量是 250 GB，並且包含了一個 80 GB 的切割區及一個 170 GB 的切割區 (MS-DOS™ 的分割區)。 第一個切割區是 Windows™NTFS 檔案系統的 <span class=filename>C:</span> 磁碟機，第二個則安裝了 FreeBSD。 本範例中安裝的 FreeBSD 有四個資料分區及一個交換分區。</p></div><div class=paragraph><p>這四個分區中各有一個檔案系統。 分區 <code>a</code> 是根檔案系統、分區 <code>d</code> 是 <span class=filename>/var/</span>、分區 <code>e</code> 是 <span class=filename>/tmp/</span>，而分區 <code>f</code> 是 <span class=filename>/usr/</span>。分區字母 <code>c</code> 用來代表整個切割區，因此並不作為一般分區使用。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/disk-layout.png alt="disk layout"></div></div></div></div></div><div class=sect2><h3 id=mount-unmount>3.7. 掛載與卸載檔案系統<a class=anchor href=#mount-unmount></a></h3><div class=paragraph><p>檔案系統就像一顆樹。<span class=filename>/</span> 就像是樹根，而 <span class=filename>/dev</span>，<span class=filename>/usr</span> 以及其他在根目錄下的目錄就像是樹枝，而這些樹枝上面又還有分支，像是 <span class=filename>/usr/local</span> 等。</p></div><div class=paragraph><p>因為某些原因，我們會將一些目錄分別放在不同的檔案系統上。 如 <span class=filename>/var</span> 包含了可能會滿出來的 <span class=filename>log/</span>，<span class=filename>spool/</span> 等目錄以及各式各樣的暫存檔。 把根檔案系統塞到滿出來顯然不是個好主意，所以我們往往會比較傾向把 <span class=filename>/var</span> 從 <span class=filename>/</span> 中拉出來。</p></div><div class=paragraph><p>另一個常見到把某些目錄放在不同檔案系統上的理由是： 這些檔案在不同的實體或虛擬磁碟機上。 像是網路檔案系統 (Network File System) 詳情可參考 <a href=./#network-nfs>網路檔案系統 (NFS)</a> 或是光碟機。</p></div><div class=sect3><h4 id=disks-fstab>3.7.1. <span class=filename>fstab</span> 檔<a class=anchor href=#disks-fstab></a></h4><div class=paragraph><p>在 <span class=filename>/etc/fstab</span> 裡面有設定的檔案系統會在開機 (<a href=./#boot>FreeBSD 開機程序</a>) 的過程中自動地被掛載 (除非該檔案系統有被加上 <code>noauto</code> 參數)。檔案內容的格式如下：</p></div><div class="literalblock programlisting"><div class=content><pre>device       /mount-point fstype     options      dumpfreq     passno</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>device</code></dt><dd><p>已存在的裝置名稱，詳情請參閱 <a href=#disks-naming>磁碟裝置名稱</a>。</p></dd><dt class=hdlist1><code>mount-point</code></dt><dd><p>檔案系統要掛載到的目錄 (該目錄必須存在)。</p></dd><dt class=hdlist1><code>fstype</code></dt><dd><p>檔案系統類型，這是要傳給 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 的參數。 FreeBSD 預設的檔案系統是 <code>ufs</code>。</p></dd><dt class=hdlist1><code>options</code></dt><dd><p>可讀可寫 (Read-Write) 的檔案系統用 <code>rw</code>，而唯讀 (Read-Only) 的檔案系統則是用 <code>ro</code>，後面視需要還可以加其他選項。 常見的選項如 <code>noauto</code> 是用在不要於開機過程中自動的掛載的檔案系統。 其他選項可參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 說明。</p></dd><dt class=hdlist1><code>dumpfreq</code></dt><dd><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> 由此項目決定那些檔案系統需要傾印。 如果這格空白則以零為預設值。</p></dd><dt class=hdlist1><code>passno</code></dt><dd><p>這個項目決定檔案系統檢查的順序。 對於要跳過檢查的檔案系統，它們的 <code>passno</code> 值要設為零。 根檔案系統的 <code>passno</code> 值應設為一 (因為需要比所有其他的還要先檢查)，而其他的檔案系統的 <code>passno</code> 值應該要設得比一大。 若有多個檔案系統具有相同的 <code>passno</code> 值，則 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 會試著平行地 (如果可能的話) 檢查這些檔案系統。</p></dd></dl></div><div class=paragraph><p>更多關於 <span class=filename>/etc/fstab</span> 檔案格式及選項的資訊請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> 說明文件。</p></div></div><div class=sect3><h4 id=disks-mount>3.7.2. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a><a class=anchor href=#disks-mount></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 指令是拿來掛載檔案系統用的。基本的操作指令格式如下：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount device mountpoint</span></code></pre></div></div><div class=paragraph><p>在 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 裡面有提到一大堆的選項，不過最常用的就是這些：</p></div><div class=dlist><div class=title>掛載選項</div><dl><dt class=hdlist1><code>-a</code></dt><dd><p>把 /etc/fstab 裡面所有還沒有被掛載、沒有被標記成 <span class=filename>/etc/fstab</span> 而且沒有用 <code>-t</code> 排除的檔案系統掛載起來。</p></dd><dt class=hdlist1><code>-d</code></dt><dd><p>執行所有的動作，但是不真的去呼叫掛載的系統呼叫 (System call)。 這個選項和 <code>-v</code> 搭配拿來推測 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 將要做什麼動作時很好用。</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>強迫掛載不乾淨的檔案系統 (危險)，或是用來強制取消寫入權限 (把檔案系統的掛載狀態從可存取變成唯讀)。</p></dd><dt class=hdlist1><code>-r</code></dt><dd><p>用唯讀的方式掛載檔案系統。 這個選項和在 -o 選項中指定 ro 參數是一樣的。</p></dd><dt class=hdlist1><code>-t</code> <em>fstype</em></dt><dd><p>用指定的檔案系統型態來掛載指定的檔案系統，或是在有 <code>-a</code> 選項時只掛載指定型態的檔案系統。預設的檔案系統類型為 "ufs"。</p></dd><dt class=hdlist1><code>-u</code></dt><dd><p>更新檔案系統的掛載選項。</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>顯示詳細資訊。</p></dd><dt class=hdlist1><code>-w</code></dt><dd><p>以可讀寫的模式掛載檔案系統。</p></dd></dl></div><div class=paragraph><p><code>-o</code> 選項後面會接著以逗號分隔的參數：</p></div><div class=dlist><dl><dt class=hdlist1>nosuid</dt><dd><p>不解析檔案系統上的 setuid 或 setgid 旗標， 這也是一個蠻有用的安全選項。</p></dd></dl></div></div><div class=sect3><h4 id=disks-umount>3.7.3. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a><a class=anchor href=#disks-umount></a></h4><div class=paragraph><p>要卸載檔案系統可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> 指令。該指令需要一個參數可以是掛載點 (mountpoint)，裝置名稱，以及 <code>-a</code> 或是 <code>-A</code> 等選項。</p></div><div class=paragraph><p>加上 <code>-f</code> 可以強制卸載，加上 <code>-v</code> 則是會顯示詳細資訊。 要注意的是一般來說用 <code>-f</code> 並不是個好主意，強制卸載檔案系統有可能會造成電腦當機， 或者損壞檔案系統內的資料。</p></div><div class=paragraph><p><code>-a</code> 和 <code>-A</code> 是用來卸載所有已掛載的檔案系統，另外還可以用 <code>-t</code> 來指定要卸載的是哪些種類的檔案系統。 要注意的是 <code>-A</code> 並不會試圖卸載根檔案系統。</p></div></div></div><div class=sect2><h3 id=basics-processes>3.8. 程序與 Daemon<a class=anchor href=#basics-processes></a></h3><div class=paragraph><p>FreeBSD 是一個多工的作業系統，也就是說在同一時間內可以跑超過一個程式。 每一個正在花時間跑的程式就叫做<em>程序 (Process)</em>。 您下的每個指令都至少會開啟一個新的程序， 而有些系統程序是一直在跑以維持系統正常運作的。</p></div><div class=paragraph><p>每一個程序都有一個獨一無二的數字叫做 <em>程序代號 (Process ID, PID)</em>，而且就像檔案一樣，每一個程序也有擁有者及群組。 擁有者及群組的資訊是用來決定什麼檔案或裝置是這個程序可以開啟的 (前面有提到過檔案權限)。 大部份的程序都有父程序。 父程序是開啟這個程序的程序，例如：您對 Shell 輸入指令，Shell 本身就是一個程序，而您執行的指令也是程序。 每一個您用這種方式跑的程序的父程序都是 Shell。 有一個特別的程序叫做 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> 是個例外，在 FreeBSD 開機的時候 init 會自動地被開啟，init 永遠是第一個程序，所以他的 PID 一直都會是 <code>1</code>。</p></div><div class=paragraph><p>有些程式並不是設計成一直在接收使用者的輸入的， 而是在開始執行的時候就從中斷與終端機的連線。 例如說， 網頁伺服器整天都在回應網頁方面的要求，它通常不需要您輸入任何東西。 另外，像是把信從一個站傳送到另一個站的程式，也是這種類型的應用程式。我們把這種程式稱作 <em>Daemon</em>。 Daemon 一詞是來自是希臘神話中的角色：祂們既不屬於善良陣營或邪惡陣營，祂們在背地裡做一些有用的事情。這也就是為何 BSD 的吉祥物，是一隻穿著帆布鞋拿著三叉耙的快樂小惡魔的原因。</p></div><div class=paragraph><p>通常來說做為 Deamon 執行的程式名字後面都會加一個字母 "d"。 BIND 是 Berkeley Internet Name Domain 的縮寫，但實際上執行的程式名稱是 <code>named</code>、Apache 網頁伺服器的程式名稱是 <code>httpd</code>、行列式印表機緩衝服務 (Line Printer Spooling) Daemon 是 <code>lpd</code>，依此類推。 但這是習慣用法，並沒有硬性規定，例如 Sendmail 主要的寄信 Daemon 是叫做 <code>sendmail</code> 而不是 <code>maild</code>。</p></div><div class=sect3><h4 id=_檢視程序>3.8.1. 檢視程序<a class=anchor href=#_檢視程序></a></h4><div class=paragraph><p>要看系統執行中的程序，有兩個相當有用的指令可用： <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>。<a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 指令是用來列出正在執行之程序，而且可以顯示它們的 PID、用了多少記憶體、執行的指令名稱及其後之參數是什麼等等。 <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> 指令則是顯示所有正在執行的程序， 並且數秒鐘更新一次。因此您可以互動式的觀看您的電腦正在做什麼。</p></div><div class=paragraph><p>在預設的情況下，<a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 指令只會顯示使用者所擁有的的程序。 例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps</code></pre></div></div><div class=paragraph><p>在這個範例裡可以看到 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 的輸出分成好幾個欄位。 <code>PID</code> 就是前面有提到的程序代號。 <code>PID</code> 的分配是從 1 開始一直到 99999，如果用完的話又會繞回來重頭開始分配 (若該 PID 已經在用了，則 PID 不會重新分配)。 <code>TT</code> 欄位是指這個程式在哪個 Console (tty) 上執行，在這裡可以先忽略不管。<code>STAT</code> 是程式的狀態，也可以先不要管。<code>TIME</code> 是這個程式在 CPU 上執行的時間—​這通常不是程式總共花的時間， 因為當您開始執行程式後，大部份的程式在 CPU 上執行前會先花上不少時間等待 。 最後，<code>COMMAND</code> 是執行這個程式的指令。</p></div><div class=paragraph><p>有幾個不同的選項組合可以用來變更顯示出來的資訊，其中一個最有用的組合是 <code>auxww</code>。 <code>a</code> 可以顯示所有正在跑的程序的指令，不只是您自已的。 <code>u</code> 則是顯示程序的擁有者名稱以及記憶體使用情況。 <code>x</code> 可以把 daemon 程序顯示出來， 而 <code>ww</code> 可讓 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 顯示出每個程序完整的內容， 而不致因過長而被螢幕截掉了。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> 也有類似的輸出。 一般的情況看像是這樣：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top
last pid:  9609<span class=p>;</span>  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% <span class=nb>nice</span>,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 <span class=nt>-21</span>  r31   136M 42296K <span class=k>select  </span>0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K <span class=k>select  </span>3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K <span class=k>select  </span>0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M <span class=k>select  </span>0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M <span class=k>select  </span>2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K <span class=k>select  </span>3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K <span class=k>select  </span>1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K <span class=k>select  </span>1   0:05  0.00% kdeinit4</code></pre></div></div><div class=paragraph><p>輸出的資訊分成兩個部份。開頭 (前五行或六行) 顯示出最近一個程序的 PID、系統平均負載 (系統忙磁程度評估方式)、系統的開機時間 (自上次重新開機) 以及現在的時間等。 在開頭裡面的其他數字分別是在講有多少程序正在執行、有多少記憶體及交換空間被占用了，還有就是系統分別花了多少時間在不同的 CPU 狀態上。若有載入 ZFS 檔案系統模組，會有一行 <code>ARC</code> 標示有多少資料從磁碟改由記憶體快取中取得。</p></div><div class=paragraph><p>接下來的部份是由好幾個欄位所構成，和 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 輸出的資訊類似。 就如同前例，您可以看到 PID、使用者名稱、CPU 花費的時間以及正在執行的指令。 <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> 在預設的情況下還會告訴您程序用掉了多少的記憶體空間。 在這邊會分成兩欄，一個是總用量 (Total size)，另一個是實際用量 (Resident size)----總用量是指這個應用程式需要的記憶體空間，而實際用量則是指目前實際上該程式的記憶體使用量。</p></div><div class=paragraph><p>top(1) 每隔 2 秒鐘會自動更新顯示內容，可用 <code>-s</code> 選項來改變間隔的時間。</p></div></div><div class=sect3><h4 id=basics-daemons>3.8.2. 終止程序<a class=anchor href=#basics-daemons></a></h4><div class=paragraph><p>要與執行中的程序或 Daemon 溝通唯一的方法是透過 <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> 指令傳送<em>信號 (Signal)</em>。 信號有很多種，有些有特定的意義，有些則是會由應用程式來解讀，應用程式的說明文件會告訴您該程式是如何解讀信號。 使用者只能送信號給自己所擁有的程序，送信號給其他人的程序會出現權限不足的錯誤。 唯一的例外是 <code>root</code>使用者，他可以送信號給任何人的程序。</p></div><div class=paragraph><p>作業系統在某些情況也會送信號給應用程式。 假設有個應用程式寫得不好，企圖要存取它不該碰的記憶體的時候，FreeBSD 會送一個 "Segmentation Violation" 信號 (<code>SIGSEGV</code>) 給這個程序。 如果有一個應用程式用了 <a href="https://man.freebsd.org/cgi/man.cgi?query=alarm&amp;sektion=3&amp;format=html">alarm(3)</a> 的系統呼叫 (System call) 要求系統在過一段時間之後發出通知，時間到了的時候系統就會發出"通知"信號 (<code>SIGALRM</code>) 給該程式。</p></div><div class=paragraph><p><code>SIGTERM</code> 與 <code>SIGKILL</code> 這兩個信號可以拿來終止程序。 用 <code>SIGTERM</code> 結束程序是比較有禮貌的方式，該程序收到信號後可以把自已所使用的日誌檔關閉及其他要在結束前要做的事完成， 然後在關掉程序之前結束掉手邊的工作。 在某些情況下程序有可能會忽略 <code>SIGTERM</code>，如它正在做一些不能中斷的工作的話。</p></div><div class=paragraph><p><code>SIGKILL</code> 就沒有辦法被程序忽略。 傳送 <code>SIGKILL</code> 信號給程序通常會將程序直接中止。</p></div><div class=paragraph><p>其他常用的信號有：<code>SIGHUP</code>, <code>SIGUSR1</code> 及 <code>SIGUSR2</code>。 這些是通用的信號，對不同的應用程式會有不同的反應。</p></div><div class=paragraph><p>舉例來說，當您更動了網頁伺服器的設定檔，您想要叫網頁伺服器去重新讀取設定。 重新啟動 <code>httpd</code> 會造成網頁伺服器暫停服務一段時間，我們可以傳送 <code>SIGHUP</code> 信號來取代關掉重開。 不同的 Daemon 會有不同的行為，所以使用前請先參考 Deamon 的說明文件查看是否可以達到想要的結果。</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: 送信號給程序</strong></p></div><div class=paragraph><p>這個範例將會示範如何送一個信號給 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>。<a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 的設定檔是 <span class=filename>/etc/inetd.conf</span>，而 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 會在收到 <code>SIGHUP</code> 的時候重新讀取這個設定檔。</p></div><div class="olist arabic"><ol class=arabic><li><p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pgrep&amp;sektion=1&amp;format=html">pgrep(1)</a> 來查詢要傳送信號的目標程序。 在這個例子中 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 的 PID 為 198：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pgrep <span class=nt>-l</span> inetd
198  inetd <span class=nt>-wW</span></code></pre></div></div></li><li><p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> 來發送信號。因為 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 是 <code>root</code> 所有，因此必須先用 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 切換成 <code>root</code> 先。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:
<span class=c># /bin/kill -s HUP 198</span></code></pre></div></div><div class=paragraph><p>對大多數 UNIX™ 指令來講，<a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> 執行成功時並不會輸出任何訊息。 假設您送一個信號給某個不是使用者所擁有的程序， 那麼就會顯示這個錯誤訊息： <code>kill: <em>PID</em>: Operation not permitted</code>。 若打錯 PID 的話，那就會把信號送給錯誤的程序，並把該程序關閉，或者是把信號送給一個非使用中的 PID，那您就會看到錯誤：<code>kill: <em>PID</em>: No such process</code>。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>為何要使用 <code>/bin/kill</code>？</div><div class=paragraph><p>多數 Shell 都有提供內建的 <code>kill</code> 指令。 也就是說這種 shell 會直接發送信號，而不是執行 <span class=filename>/bin/kill</span>。 但要小心不同的 shell 會有不同的語法來指定信號的名稱等。 與其嘗試去把它們通通學會，不如就單純的直接用 <code>/bin/kill</code>。</p></div></td></tr></tbody></table></div></li></ol></div></div></div><div class=paragraph><p>要送其他的信號的話也是非常類似，就視需要把指令中的 <code>TERM</code> 或 <code>KILL</code> 替換成其他信號的名稱即可。</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>隨便抓一個系統中的程序然後把他砍掉並不是個好主意。 特別是 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>， PID 1 是一個非常特別的程序。 執行 <code>/bin/kill -s KILL 1</code> 的結果就是系統立刻關機。 因此在您按下 <kbd>Return</kbd> 要執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> 之前， 請<em>一定要</em>記得再次確認您下的參數。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=shells>3.9. Shell<a class=anchor href=#shells></a></h3><div class=paragraph><p><em>Shell</em> 提供了指令列介面可用來與作業系統互動，Shell 負責從輸入的頻道接收指令並執行它們。 多數 Shell 也內建一些有助於日常工作的功能，像是檔案管理、檔案搜尋、指令列編輯、指令巨集以及環境變數等。 FreeBSD 有內附了幾個 Shell，包含 Bourne Shell (<a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>)，與改良版的 C-shell (<a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>)。 還有許多其他的 Shell 可以從 FreeBSD Port 套件集中取得，像是 <code>zsh</code> 以及 <code>bash</code> 等。</p></div><div class=paragraph><p>要用哪個 Shell 牽涉到每個人的喜好。 如果您是一個 C 程式設計師，那對於使用像是 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> 這種 C-like 的 shell 可能會感到較容易上手。 如果是 Linux™ 的使用者，那您也許會想要用 <code>bash</code>。 每一個 Shell 都有自已獨特之處，至於這些特點能不能符合使用者的喜好，就是您選擇 shell 的重點了。</p></div><div class=paragraph><p>常見的 Shell 功能之一就是檔名自動補齊。 首先輸入指令或檔案的前幾個字母，然後按下 <kbd>Tab</kbd> 鍵，Shell 就會自動把指令或是檔案名稱剩餘的部份補齊。 假設您有兩個檔案分別叫作 <span class=filename>foobar</span> 及 <span class=filename>football</span>。 要刪掉 <span class=filename>foobar</span>，那麼可以輸入 <code>rm foo</code> 然後按下 <kbd>Tab</kbd> 來補齊檔名。</p></div><div class=paragraph><p>但 Shell 只顯示了 <code>rm foo</code>，這代表它沒有辦法完全自動補齊檔名，因為有不只一個檔名符合條件。 <span class=filename>foobar</span> 和 <span class=filename>football</span> 都是 <code>foo</code> 開頭的檔名。 有一些 Shell 會有嗶的音效或者顯示所有符符條件的檔名。 使用者只需要多打幾個字元來分辦想要的檔名。 輸入 <code>t</code> 然後再按 <kbd>Tab</kbd> 一次，那 Shell 就能夠替您把剩下的檔名填滿了。</p></div><div class=paragraph><p>Shell 的另一項特點是使用了環境變數。 環境變數是以變數與鍵值 (Variable/Key) 的對應關係儲存於 Shell 的環境，任何由該 Shell 所產生的程序都可以讀取此環境變數， 因此環境變數儲存了許多程序的設定。 <a href=#shell-env-vars>常用環境變數</a> 提供了常見的環境變數與其涵義的清單。 請注意環境變數的名稱永遠以大寫表示。</p></div><table id=shell-env-vars class="tableblock frame-none grid-all stretch"><caption class=title>表 5. 常用環境變數</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">變數</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>USER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>目前登入的使用者名稱。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>以冒號 (:) 隔開的目錄列表，用以搜尋執行檔的路徑。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>DISPLAY</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>若存在這個環境變數，則代表 Xorg 顯示器的網路名稱。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>SHELL</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>目前使用的 Shell。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERM</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>使用者終端機類型的名稱，用來判斷終端機有那些功能。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERMCAP</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>用來執行各種終端機功能的終端機跳脫碼 (Terminal escape code) 的資料庫項目。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>OSTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>作業系統的類型。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MACHTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>系統的 CPU 架構。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>EDITOR</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>使用者偏好的文字編輯器。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PAGER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>使用者偏好的文字分頁檢視工具。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MANPATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>以冒號 (:) 隔開的目錄列表，用以搜尋使用手冊的路徑。</p></td></tr></tbody></table><div class=paragraph><p>在不同的 Shell 底下設定環境變數的方式也有所不同。 在 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>，使用 <code>setenv</code> 來設定環境變數。 在 <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> 和 <code>bash</code> 則使用 <code>export</code> 來設定目前環境的變數。 以下範例將 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> Shell 下的 <code>EDITOR</code> 環境變數從預設值更改為 <span class=filename>/usr/local/bin/emacs</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv EDITOR /usr/local/bin/emacs</code></pre></div></div><div class=paragraph><p>相同功能的指令在 <code>bash</code> 下則是：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>export </span><span class=nv>EDITOR</span><span class=o>=</span><span class=s2>&#34;/usr/local/bin/emacs&#34;</span></code></pre></div></div><div class=paragraph><p>要展開以顯示目前環境變數中的值，只要在指令列輸入環境變數之前加上 <code>$</code> 字元。 舉例來說，<code>echo $TERM</code> 會顯示出目前 <code>$TERM</code> 的設定值。</p></div><div class=paragraph><p>Shell 中有特殊字元用來表示特殊資料，我們將其稱作 Meta-character。 其中最常見的 Meta-character 是 <code>*</code> 字元，它代表了檔名中的任意字元。 Meta-character 可以用在搜尋檔名，舉例來說，輸入 <code>echo *</code> 會和輸入 <code>ls</code> 得到幾乎相同的結果，這是因為 shell 會將所有符合 <code>*</code> 字元的檔案由 <code>echo</code> 顯示出來。</p></div><div class=paragraph><p>為了避免 Shell 轉譯這些特殊字元，我們可以在這些特殊字元前放一個反斜線 (<code>\</code>) 字元使他們跳脫 (Escape) Shell 的轉譯。舉例來說，<code>echo $TERM</code> 會印出你目前終端機的設定， <code>echo \$TERM</code> 則會直接印出 <code>$TERM</code> 這幾個字。</p></div><div class=sect3><h4 id=changing-shells>3.9.1. 變更 Shell<a class=anchor href=#changing-shells></a></h4><div class=paragraph><p>永久變更 Shell 最簡單的方法就是透過 <code>chsh</code> 指令。 執行 <code>chsh</code> 將會使用環境變數中 <code>EDITOR</code> 指定的文字編輯器，如果沒有設定，則預設是 <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>。 請修改 <code>Shell:</code> 為新的 Shell 的完整路徑。</p></div><div class=paragraph><p>或者，使用 <code>chsh -s</code>， 來直接設定 Shell 而不開啟文字編輯器。 例如， 假設想把 Shell 更改為 <code>bash</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% chsh <span class=nt>-s</span> /usr/local/bin/bash</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>新的 Shell <em>必須</em>已列於 <span class=filename>/etc/shells</span> 裡頭。 若是依 <a href=./#ports>安裝應用程式：套件與 Port</a> 說明由 Port 套件集來裝的 Shell， 那就會自動列入至該檔案裡。 若仍缺少，請使用以下指令加入檔案 (請將路徑替換為新的 Shell 的路徑)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/local/bin/bash &gt;&gt; /etc/shells</span></code></pre></div></div><div class=paragraph><p>然後重新執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a>。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_進階_shell_技巧>3.9.2. 進階 Shell 技巧<a class=anchor href=#_進階_shell_技巧></a></h4><div class=paragraph><p>UNIX™ Shell 不只是指令的直譯器，它是一個強大的工具可讓使用者執行指令、重新導向指令的輸出、重新導向指令的輸入並將指令串連在一起來改進最終指令的輸出結果。當這個功能與內建的指令混合使用時，可提供一個可以最佳化效率的環境給使用者。</p></div><div class=paragraph><p>Shell 重新導向是將一個指令的輸出或輸入傳送給另一個指令或檔案。例如，要擷取 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> 指令的輸出到一個檔案，可以重新導向輸出：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=o>&gt;</span> directory_listing.txt</code></pre></div></div><div class=paragraph><p>目錄的內容現在會列到 <span class=filename>directory_listing.txt</span> 中，部份指令可以讀取輸入，例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=sort&amp;sektion=1&amp;format=html">sort(1)</a>。要排序這個清單，可重新導向輸入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sort</span> &lt; directory_listing.txt</code></pre></div></div><div class=paragraph><p>輸入的內容會被排序後呈現在畫面上，要重新導向該輸入到另一個檔案，可以重新導向 <a href="https://man.freebsd.org/cgi/man.cgi?query=sort&amp;sektion=1&amp;format=html">sort(1)</a> 的出輸：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sort</span> &lt; directory_listing.txt <span class=o>&gt;</span> sorted.txt</code></pre></div></div><div class=paragraph><p>於上述所有的範例中，指令會透過檔案描述符 (File descriptor) 來執行重新導向。每個 UNIX™ 系統都有檔案描述符，其中包含了標準輸入 (stdin)、標準輸出 (stdout) 以及標準錯誤 (stderr)。每一種檔案描述符都有特定的用途，輸入可能來自鍵盤或滑鼠、任何可能提供輸入的來源，輸出則可能是螢幕或印表機中的紙張，而錯誤則為任何可能用來診斷的資訊或錯誤訊息。這三種皆被認為是以 I/O 為基礎的檔案描述符，有些也會被當做串流。</p></div><div class=paragraph><p>透過使用這些檔案描述符，Shell 能夠讓輸出與輸入在各種指令間傳遞與重新導向到或自檔案。另一種重新導向的方式是使用管線運算子 (Pipe operator)。</p></div><div class=paragraph><p>UNIX™ 的管線運算子，即 "|"，可允許指令的輸出可直接傳遞或導向到另一個程式。基本上，管線運算子允許指令的標準輸出以標準輸入傳遞給另一個指令，例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>directory_listing.txt | <span class=nb>sort</span> | less</code></pre></div></div><div class=paragraph><p>在這個例子中，<span class=filename>directory_listing.txt</span> 的內容會被排序然後輸出傳遞給 <a href="https://man.freebsd.org/cgi/man.cgi?query=less&amp;sektion=1&amp;format=html">less(1)</a>，這可讓使用者依自己的閱讀步調捲動輸出的結果，避免結果直接捲動出畫面。</p></div></div></div><div class=sect2><h3 id=editors>3.10. 文字編輯器<a class=anchor href=#editors></a></h3><div class=paragraph><p>在 FreeBSD 中有許多設定必須透過編輯文字檔完成。 因此，若能熟悉文字編輯器是再好不過的。 FreeBSD 本身就內建幾種文字編輯器， 您也可以透過 Port 套件集來安裝其他的文字編輯器。</p></div><div class=paragraph><p>最簡單易學的文字編輯器叫做 <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a>，意為簡易的編輯器 (Easy Editor)。 要開始使用這個編輯器， 只需輸入 <code>ee <em>filename</em></code>，其中 <em>filename</em> 代表你想要編輯的檔案名稱。 在編輯器中， 所有編輯器的功能與操作都顯示在螢幕的上方。 其中的插入符號 (<code>^</code>) 代表鍵盤上的 <kbd>Ctrl</kbd> 鍵，所以 <code>^e</code> 代表的是 <span class=keyseq><kbd>Ctrl</kbd>+<kbd>e</kbd></span>。 若要結束 <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a>，請按下 <kbd>Esc</kbd> 鍵，接著選擇 "leave editor" 即可。 此時如果該檔案有修改過，編輯器會提醒你是否要存檔。</p></div><div class=paragraph><p>FreeBSD 同時也內建功能強大的文字編輯器，像是<a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>。 其他編輯器如 <a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> 及 <a class=package href=https://cgit.freebsd.org/ports/tree/editors/vim/>editors/vim</a> 則由 FreeBSD Port 套件集提供。 這些編輯器提供更強的功能，但是也比較難學習。 長期來看學習 vim 或 Emacs 會在日後為您省下更多的時間。</p></div><div class=paragraph><p>有許多應用程式在修改檔案或需要輸入時會自動開啟文字編輯器，要更改預設的編輯器可設定 <code>EDITOR</code> 環境變數如 <a href=#shells>Shell</a> 所說明。</p></div></div><div class=sect2><h3 id=basics-devices>3.11. 裝置及裝置節點<a class=anchor href=#basics-devices></a></h3><div class=paragraph><p>裝置 (Device) 一詞大多是跟硬體比較有關的術語，包括磁碟、印表機、顯示卡和鍵盤。 FreeBSD 開機過程當中，開機訊息 (Boot Message) 中主要是會列出偵測到的硬體裝置，開機訊息的複本也會存放在 <span class=filename>/var/run/dmesg.boot</span>。</p></div><div class=paragraph><p>每一個裝置都有一個裝置名稱及編號，舉例來說 <span class=filename>ada0</span> 是第一台 SATA 硬碟，而 <span class=filename>kbd0</span> 則代表鍵盤。</p></div><div class=paragraph><p>在 FreeBSD 中大多數的裝置必須透過裝置節點 (Device Node) 的特殊檔案來存取，這些檔案會放置在 <span class=filename>/dev</span>。</p></div></div><div class=sect2><h3 id=basics-more-information>3.12. 操作手冊<a class=anchor href=#basics-more-information></a></h3><div class=paragraph><p>在 FreeBSD 中，最詳細的文件莫過於操作手冊。 幾乎在系統上所有程式都會有簡短的操作手冊來介紹該程式的基本操作以及可用的參數。 這些操作手冊可以使用 <code>man</code> 指令來檢視：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>command</span></code></pre></div></div><div class=paragraph><p>其中 <em>command</em> 想要瞭解指令的名稱。 舉例，要知道 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> 的詳細用法，就可以打：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>ls</span></code></pre></div></div><div class=paragraph><p>操作手冊被分成很多個章節，每個章節有不同的主題。 在 FreeBSD 中操作手冊有以下章節：</p></div><div class="olist arabic"><ol class=arabic><li><p>使用者指令。</p></li><li><p>系統呼叫 (System call) 與錯誤編號。</p></li><li><p>C 程式庫函數。</p></li><li><p>裝置驅動程式。</p></li><li><p>檔案格式。</p></li><li><p>遊戲及其他程式。</p></li><li><p>其他資訊。</p></li><li><p>系統維護與操作指令。</p></li><li><p>系統核心介面。</p></li></ol></div><div class=paragraph><p>有些情況會有同樣主題會同時出現在不同章節。 舉個例子，系統內會有 <code>chmod</code> 使用者指令，但同時也有 <code>chmod()</code> 系統呼叫。 在這種情況，要告訴 <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> 要查詢的章節編號：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man 1 <span class=nb>chmod</span></code></pre></div></div><div class=paragraph><p>如此一來就會查詢使用者指令 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>。 通常在寫文件時會把有參考到特定章節的號碼寫在括號內。 所以 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> 就是指使用者指令，而 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=2&amp;format=html">chmod(2)</a> 則是指系統呼叫。</p></div><div class=paragraph><p>若不曉得操作手冊的名稱，可以使用 <code>man -k</code> 來以關鍵字查詢所有操作手冊的描述：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nt>-k</span> mail</code></pre></div></div><div class=paragraph><p>這個指令會顯示所有描述中有使用到關鍵字 "mail" 的指令。 這等同使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=apropos&amp;sektion=1&amp;format=html">apropos(1)</a>。</p></div><div class=paragraph><p>想要閱讀所有在 <span class=filename>/usr/bin</span> 底下的指令說明則可輸入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% man <span class=nt>-f</span> <span class=k>*</span> | more</code></pre></div></div><div class=paragraph><p>或</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% whatis <span class=k>*</span> |more</code></pre></div></div><div class=sect3><h4 id=basics-info>3.12.1. GNU Info 檔<a class=anchor href=#basics-info></a></h4><div class=paragraph><p>FreeBSD 有許多應用程式與工具來自自由軟體基金會 (Free Software Foundation, FSF)。 除了操作手冊之外，這些程式提供了另外一種更具有彈性的超文字文件叫做 <code>info</code> 檔。 這些檔案可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a> 指令來閱讀，或者若有裝 <a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> 亦可透過 emacs 的 info 模式閱讀。</p></div><div class=paragraph><p>要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a> 指令，只需輸入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% info</code></pre></div></div><div class=paragraph><p>要查詢簡單說明請按 <code>h</code> 鍵，若要查訊快速指令參考請按 <code>?</code> 鍵。</p></div></div></div></div></div><div class=sect1><h2 id=ports>Chapter 4. 安裝應用程式：套件與 Port<a class=anchor href=#ports></a></h2><div class=sectionbody><div class=sect2><h3 id=ports-synopsis>4.1. 概述<a class=anchor href=#ports-synopsis></a></h3><div class=paragraph><p>FreeBSD 內建豐富的系統工具集，此外 FreeBSD 提供了兩種安裝第三方軟體的套件管理技術︰由原始碼安裝的 FreeBSD Port 套件集，以及由預先編譯好的 Binary 安裝的 Binary 套件集。兩種方法都可使用本地的媒體或網路來安裝軟體。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>Binary 套件集與 Port 的差別。</p></li><li><p>如何找到已移植到 FreeBSD 的第三方軟體。</p></li><li><p>如何使用 pkg 管理 Binary 套件。</p></li><li><p>如何編譯來自 Port 套件集的第三方軟體原始碼。</p></li><li><p>如何找到應用程式已安裝的檔案來完成安裝後的設定。</p></li><li><p>若軟體安裝失敗要如何處理。</p></li></ul></div></div><div class=sect2><h3 id=ports-overview>4.2. 安裝軟體的概要<a class=anchor href=#ports-overview></a></h3><div class=paragraph><p>通常要在 UNIX™ 系統上安裝第三方軟體時，有幾個步驟要作：</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>找到並且下載軟體，該軟體有可能以原始碼或 Binary 格式發佈。</p></li><li><p>自發佈的格式解壓縮軟體。 發佈的格式通常為 tarball 並以程式壓縮，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=compress&amp;sektion=1&amp;format=html">compress(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=bzip2&amp;sektion=1&amp;format=html">bzip2(1)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=xz&amp;sektion=1&amp;format=html">xz(1)</a>。</p></li><li><p>找到位於 <span class=filename>INSTALL</span>, <span class=filename>README</span> 或者 <span class=filename>doc/</span> 子目錄底下的檔案閱讀如何安裝該軟體。</p></li><li><p>若軟體是以原始碼的格式發佈則需要編譯該軟體。 這可能會需要修改 <span class=filename>Makefile</span> 或執行 <code>configure</code> Script。</p></li><li><p>測試並安裝該軟體。</p></li></ol></div></div></div><div class=paragraph><p>FreeBSD <em>Port</em> 是指設計用來自動化從原始碼編譯應用程式整個程序的一系列檔案，組成 Port 的檔案包含了自動下載、解壓縮、修補、編譯與安裝應用程式的必要資訊。</p></div><div class=paragraph><p>若軟體尚未被 FreeBSD 採用並測試，可能會需要經過一些修正才能正常安裝並執行。</p></div><div class=paragraph><p>雖然如此，目前已有超過 <a href=https://www.FreeBSD.org/ports/>24,000</a> 個第三方應用程式已經被移植到 FreeBSD。當可行時，這些應用程式也會做成預先編譯好的 <em>套件 (Package)</em> 供下載。</p></div><div class=paragraph><p>這些 Binary 套件可使用 FreeBSD 套件管理指令來管理。</p></div><div class=paragraph><p>不論是 Binary 套件或者 Port 都有相依性，若用 Binary 套件或 Port 來安裝應用程式，且該應用程式若有相依的程式庫尚未被安裝，則會自動先安裝該程式庫。</p></div><div class=paragraph><p>FreeBSD Binary 套件中含有一個應用程式中所有預先編譯好的指令、設定檔以及文件，Binary 套件可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 指令來管理，如 <code>pkg install</code>。</p></div><div class=paragraph><p>雖然兩種技術非常相似，但 Binary 套件及 Port 有各自的優點。 要視您要安裝的應用程式需求來選擇。</p></div><div class=ulist><div class=title>Binary 套件優點</div><ul><li><p>應用程式壓縮 Binary 套件的 tarball 會比壓縮原始碼的 tarball 還要小。</p></li><li><p>安裝 Binary 套件不需要編譯的時間，對於較慢的電腦要安裝大型的應用程式如 Mozilla, KDE 或 GNOME 這點顯的相當重要。</p></li><li><p>Binary 套件不需要了解在 FreeBSD 上編譯軟體的流程。</p></li></ul></div><div class=ulist><div class=title>Port 套件優點</div><ul><li><p>由於 Binary 套件必須盡可能在大多數系統上執行，通常會採用較通用的編譯選項來編譯，由 Port 來編輯可更改編譯選項。</p></li><li><p>部份應用程式編譯期選項會與要安裝的功能有關，舉例來說 Apache 便有大量不同的內建選項可以設定。</p><div class=paragraph><p>在某些情況，同樣的應用程式會存在多個不同的 Binary 套件，如 Ghostscript 有 <span class=filename>ghostscript</span> 及 <span class=filename>ghostscript-nox11</span> 兩種 Binary 套件，用來區別是否有安裝 Xorg。 若應用程式有一個以上的編譯期選項便無法用這個方式來區別 Binary 套件。</p></div></li><li><p>部份軟體的授權條款中禁止以 Binary 格式發佈。 這種軟體必須以原始碼發佈並由終端使用者編譯。</p></li><li><p>部份人並不相信 Binary 發佈版本，寧願閱讀原始碼來查看是否潛藏的問題。</p></li><li><p>原始碼可套用自訂的修補。</p></li></ul></div><div class=paragraph><p>要持續追蹤 Port 的更新可以訂閱 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports>FreeBSD Port 郵遞論壇</a> 與 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-bugs>FreeBSD Port 問題郵遞論壇</a>。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>在安裝任何應用程式之前，請先查看 <a href=https://vuxml.freebsd.org/ class=bare>https://vuxml.freebsd.org/</a> 是否有與該應用程式相關的安全性問題或輸入 <code>pkg audit -F</code> 來檢查所有已安裝的應用程式是否有已知的漏洞。</p></div></td></tr></tbody></table></div><div class=paragraph><p>本章接下來的部份將說明如何在 FreeBSD 使用 Binary 套件及 Port 套件安裝與管理第三方軟體。</p></div></div><div class=sect2><h3 id=ports-finding-applications>4.3. 搜尋軟體<a class=anchor href=#ports-finding-applications></a></h3><div class=paragraph><p>FreeBSD 上可安裝的軟體清單不斷在增加， 有幾種方式可以來找你想安裝的軟體：</p></div><div class=ulist><ul><li><p>FreeBSD 網站有維護一份可搜尋的最新應用程式清單，在 <a href=https://www.FreeBSD.org/ports/>https://www.FreeBSD.org/ports/</a>。 可以依應用程式名稱或軟體分類來搜尋 Port。
*</p><div class=paragraph><p>由 Dan Langille 維護的 <a href=http://www.FreshPorts.org/>FreshPorts.org</a>，提供完整的搜尋工具並且可追蹤在 Port 套件集中的應用程式變更。註冊的使用者可以建立自訂的監視清單會自動寄發電子郵件通知 Port 的更新資訊。
*</p></div><div class=paragraph><p>若找不到指定的應用程式，可以先到網站 <a href=http://www.sourceforge.net/>SourceForge.net</a> 或 <a href=http://www.github.com/>GitHub.com</a> 搜尋，後然再回到 <a href=https://www.FreeBSD.org/ports/>FreeBSD 網站</a> 檢查該應用程式是否已被移植。
*</p></div><div class=paragraph><p>要搜尋 Binary 套件檔案庫中的應用程式可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg search subversion</span>
git-subversion-1.9.2
java-subversion-1.8.8_2
p5-subversion-1.8.8_2
py27-hgsubversion-1.6
py27-subversion-1.8.8_2
ruby-subversion-1.8.8_2
subversion-1.8.8_2
subversion-book-4515
subversion-static-1.8.8_2
subversion16-1.6.23_4
subversion17-1.7.16_2</code></pre></div></div><div class=paragraph><p>套件名稱包含版本編號，且若 Port 使用 Python 為基礎，也會包含用來編譯該套件的 Python 版本。有些 Port 會有多個版本可使用，如 Subversion ，因編譯選項不同，有多個版本可用，這個例子中即指靜態連結版本的 Subversion。在指定要安裝的套件時，最好使用 Port 來源來指定該應用程式，Port 來源是指應用程式在 Port 樹中的路徑。再輸入一次 <code>pkg search</code> 並加上 <code>-o</code> 來列出每個套件來源：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg search -o subversion</span>
devel/git-subversion
java/java-subversion
devel/p5-subversion
devel/py-hgsubversion
devel/py-subversion
devel/ruby-subversion
devel/subversion16
devel/subversion17
devel/subversion
devel/subversion-book
devel/subversion-static</code></pre></div></div><div class=paragraph><p><code>pkg search</code> 支援使用 Shell 萬手字元 (globs)、正規表示法、描述或檔案庫中的其他其他內容。在安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg/>ports-mgmt/pkg</a> 或 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg-devel/>ports-mgmt/pkg-devel</a> 之後，可參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-search&amp;sektion=8&amp;format=html">pkg-search(8)</a> 以取得更多詳細資訊。</p></div></li><li><p>若 Port 套件集已安裝，有數個方法可以查詢 Port 樹中的本地版本。要找到 Port 所在的分類，可輸入 <code>whereis <em>file</em></code>，其中 <em>file</em> 是要安裝的程式：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># whereis lsof</span>
lsof: /usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>或者，也可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=echo&amp;sektion=1&amp;format=html">echo(1)</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/ports/*/*lsof*</span>
/usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>請注意，這也會顯示已下載至 <span class=filename>/usr/ports/distfiles</span> 目錄中任何已符合條件的檔案。</p></div></li><li><p>另一個方法是使用 Port 套件集內建的搜尋機制來找軟體。要使用搜尋的功能需先 cd 到 <span class=filename>/usr/ports</span> 然後執行 <code>make search name=program-name</code>，其中 <em>program-name</em> 代表軟體的名稱。舉例搜尋 <code>lsof</code>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make search name=lsof</span>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span>
Maint:  ler@lerctr.org
Index:  sysutils
B-deps:
R-deps:</code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>內建的搜尋機制會使用索引檔內的資訊。若出現訊息指出需要 <span class=filename>INDEX</span> 檔，可執行 <code>make fetchindex</code> 來下載最新的索引檔。當 <span class=filename>INDEX</span> 檔存在時，<code>make search</code> 方可執行請求的搜尋動作。</p></div></td></tr></tbody></table></div><div class=paragraph><p>"Path:" 此行代表 Port 的所在位置。</p></div><div class=paragraph><p>若不要接受這麼多資訊，可使用 <code>quicksearch</code> 功能：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make quicksearch name=lsof</span>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span></code></pre></div></div><div class=paragraph><p>若要進行更有深度的搜尋，使用 <code>make search key=<em>string</em></code> 或 <code>make quicksearch key=<em>string</em></code> 其中 <em>string</em> 是要搜尋的文字。該文字可以是一部份的註解、描述或相依套件，當不清楚程式的名稱時可以找到與特定主題相關的 Port。</p></div><div class=paragraph><p>當使用 <code>search</code> 或 <code>quicksearch</code> 時，搜尋的字串不分大小寫。 搜尋 "LSOF" 會與搜尋 "lsof" 產生相同的結果。</p></div></li></ul></div></div><div class=sect2><h3 id=pkgng-intro>4.4. 使用 pkg 管理 Binary 套件<a class=anchor href=#pkgng-intro></a></h3><div class=paragraph><p>pkg 是新一代套件管理工具用來取代舊版工具，提供許多功能讓處理 Binary 套件更快更簡單。</p></div><div class=paragraph><p>對於只想要使用在 FreeBSD 鏡像站上預先編譯 Binary 套件的站台，使用 pkg 管理套件便已足夠。</p></div><div class=paragraph><p>但是，對於那些想要從原始碼或使用自己的檔案庫編譯的站台，則會需要 <a href=#ports-upgrading-tools>Port 管理工具</a>。</p></div><div class=paragraph><p>因為 pkg 僅能管理 Binary 套件，所以不能當做為替代 Port 管理工具，這些工具可用來安裝來自 Binary 與 Port 套件集的軟體，而 pkg 僅能安裝 Binary 套件。</p></div><div class=sect3><h4 id=pkgng-initial-setup>4.4.1. 開始使用 pkg<a class=anchor href=#pkgng-initial-setup></a></h4><div class=paragraph><p>FreeBSD 內建啟動 (Bootstrap) 工具可用來下載並安裝 pkg 及其操作手冊。這個工具是設計在 FreeBSD 版本 10.<em>X</em> 之後使用。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>不是所有 FreeBSD 版本及架構支援此啟動程序，目前支援的清單列於 <a href=https://pkg.freebsd.org/ class=bare>https://pkg.freebsd.org/</a>，對不支援的版本，必須改透過 Port 套件集或者 Binary 套件來安裝 pkg。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要啟動 (Bootstrap) 系統請執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/pkg</span></code></pre></div></div><div class=paragraph><p>您必須有可用的網際網路連線供啟動程式使用方可成功。</p></div><div class=paragraph><p>否則，要安裝 Port 套件，則須執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/pkg</span>
<span class=c># make</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>當升級原使用舊版 pkg_* 工具的既有系統時，必須將資料庫轉換成新的格式，如此新的工具才會知道有那些已安裝過的套件。pkg 安裝完後，必須執行以下指令將套件資料庫從舊版格式轉換到新版格式：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg2ng</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>新安裝的版本因尚未安裝任何第三方軟體因此不須做這個步驟。</p></div></td></tr></tbody></table></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>這個步驟無法還原。一旦套件資料庫轉為成 pkg 的格式，舊版 <code>pkg_*</code> 工具就不該再繼續使用。</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>套件資料庫轉換的過程可能會因內容轉換為新版本產生錯誤。通常，這些錯誤皆可安全忽略，即使如此，仍然有在執行 <code>pkg2ng</code> 後無法成功轉換的軟體清單，這些應用程式則必須手動重新安裝。</p></div></td></tr></tbody></table></div><div class=paragraph><p>為了確保 FreeBSD Port 套件集會將新軟體的資訊註冊到 pkg 而非舊版套件資料庫，FreeBSD 版本 10.<em>X</em> 之前需要在 <span class=filename>/etc/make.conf</span> 加入此行：</p></div><div class="literalblock programlisting"><div class=content><pre>WITH_PKGNG=	yes</pre></div></div><div class=paragraph><p>預設 pkg 會使用 FreeBSD 套件鏡像站 (<em>Repository</em>) 的 Binary 套件。若要取得有關編譯自訂套件檔案庫的資訊，請參考 <a href=#ports-poudriere>使用 Poudriere 編譯套件</a>。</p></div><div class=paragraph><p>其他 pkg 設定選項說明請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a>。</p></div><div class=paragraph><p>pkg 的用法資訊可在 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 操作手冊或不加任何參數執行 <code>pkg</code> 來取得。</p></div><div class=paragraph><p>每個 pkg 指令參數皆記庫在指令操件手冊。要閱讀 <code>pkg install</code> 的操作手冊，可執行以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg help install</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># man pkg-install</span></code></pre></div></div><div class=paragraph><p>本章節剩餘的部份將會示範使用 pkg 執行常用的 Binary 套件管理工作。每個示範的指令皆會提供多個參數可使用，請參考指令的說明或操作手冊以取得詳細資訊或更多範例。</p></div></div><div class=sect3><h4 id=pkgng-pkg-info>4.4.2. 取得有關已安裝套件的資訊<a class=anchor href=#pkgng-pkg-info></a></h4><div class=paragraph><p>有關已安裝在系統的套件資訊可透過執行 <code>pkg info</code> 來檢視，若執行時未指定任何參數，將會列出所有已安裝或指定的套件版本。</p></div><div class=paragraph><p>例如，要查看已安裝的 pkg 版本可執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg info pkg</span>
pkg-1.1.4_1</code></pre></div></div></div><div class=sect3><h4 id=pkgng-installing-deinstalling>4.4.3. 安裝與移除套件<a class=anchor href=#pkgng-installing-deinstalling></a></h4><div class=paragraph><p>要安裝 Binary 套件可使用以下指令，其中 <em>packagename</em> 為要安裝的套件名稱：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install packagename</span></code></pre></div></div><div class=paragraph><p>這個指令會使用檔案庫的資料來決定要安裝的軟體版本以及是否有任何未安裝的相依。例如，要安裝 curl：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install curl</span>
Updating repository catalogue
/usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

/usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

Updating repository catalogue
The following 2 packages will be installed:

        Installing ca_root_nss: 3.15.1_1
        Installing curl: 7.31.0_1

The installation will require 3 MB more space

0 B to be downloaded

Proceed with installing packages <span class=o>[</span>y/N]: y
Checking integrity... <span class=k>done</span>
<span class=o>[</span>1/2] Installing ca_root_nss-3.15.1_1... <span class=k>done</span>
<span class=o>[</span>2/2] Installing curl-7.31.0_1... <span class=k>done
</span>Cleaning up cache files...Done</code></pre></div></div><div class=paragraph><p>新的套件以及任何做為相依安裝的額外套件可在已安裝的套件清單中看到：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg info</span>
ca_root_nss-3.15.1_1	The root certificate bundle from the Mozilla Project
curl-7.31.0_1	Non-interactive tool to get files from FTP, GOPHER, HTTP<span class=o>(</span>S<span class=o>)</span> servers
pkg-1.1.4_6	New generation package manager</code></pre></div></div><div class=paragraph><p>不再需要的套件可以使用 <code>pkg delete</code> 來移除，例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg delete curl</span>
The following packages will be deleted:

	curl-7.31.0_1

The deletion will free 3 MB

Proceed with deleting packages <span class=o>[</span>y/N]: y
<span class=o>[</span>1/1] Deleting curl-7.31.0_1... <span class=k>done</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-upgrading>4.4.4. 升級已安裝套件<a class=anchor href=#pkgng-upgrading></a></h4><div class=paragraph><p>執行以下指令，可將已安裝的套件升級到最新版本：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg upgrade</span></code></pre></div></div><div class=paragraph><p>這個指令將會比對已安裝的版本與在檔案庫分類中的版本，並從檔案庫升級這些套件。</p></div></div><div class=sect3><h4 id=pkgng-auditing>4.4.5. 稽查已安裝套件<a class=anchor href=#pkgng-auditing></a></h4><div class=paragraph><p>在第三方的應用程式中偶爾可能會發現軟體漏洞，要找出這些程式，可使用 pkg 內建的稽查機制。要查詢已安裝在系統上的軟體是否有任何已知的漏洞可執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg audit -F</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-autoremove>4.4.6. 自動移除未使用的套件<a class=anchor href=#pkgng-autoremove></a></h4><div class=paragraph><p>移除一個套件可能會留下不再需要使用的相依套件。不再需要的相依套件是當初隨著其套件所安裝的套件 (枝葉套件)，可以使用以下指令自動偵測並移除：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg autoremove</span>
Packages to be autoremoved:
	ca_root_nss-3.15.1_1

The autoremoval will free 723 kB

Proceed with autoremoval of packages <span class=o>[</span>y/N]: y
Deinstalling ca_root_nss-3.15.1_1... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>因為相依所安裝的套件稱作 <em>自動 (Automatic)</em> 套件，而非自動套件即套件被安裝的原因不是因為其他套件所相依，可以使用以下方式查詢：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg prime-list</span>
nginx
openvpn
<span class=nb>sudo</span></code></pre></div></div><div class=paragraph><p><code>pkg prime-list</code> 是一個別名指令，定義在 <span class=filename>/usr/local/etc/pkg.conf</span>，尚還有許多其他相關指令可以用來查詢系統的套件資料庫，例如，指令 <code>pkg prime-origins</code> 可用來取得上述清單的來源 Port 目錄：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg prime-origins</span>
www/nginx
security/openvpn
security/sudo</code></pre></div></div><div class=paragraph><p>這份清單可以用來重新編譯所有安裝在系統中的套件，使用 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a> 或 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/synth/>ports-mgmt/synth</a> 這類的編譯工具。</p></div><div class=paragraph><p>要將一個安裝好的套件註記成為 "自動" 可以用：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -A 1 devel/cmake</span></code></pre></div></div><div class=paragraph><p>當套件為末端套件 (Leaf Package) 且被註記為 "自動"，則會被 <code>pkg autoremove</code> 挑選出來。</p></div><div class=paragraph><p>要註記一個安裝好的套件為 "<em>非</em>自動" 可以用：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -A 0 devel/cmake</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-backup>4.4.7. 還原套件資料庫<a class=anchor href=#pkgng-backup></a></h4><div class=paragraph><p>不如傳統的套件管理系統，pkg 有自己的套件資料庫備份機制，此功能預設是開啟的。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>要停止週期的 Script 備份套件資料庫可在 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic.conf&amp;sektion=5&amp;format=html">periodic.conf(5)</a> 設定 <code>daily_backup_pkgdb_enable="NO"</code>。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要還原先前套件資料庫的備份，可執行以下指令並將 <em>/path/to/pkg.sql</em> 替換為備份的位置：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg backup -r /path/to/pkg.sql</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若要還原有週期 Script 所產生的備份必須在還原前先解壓縮。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要手動備份 pkg 資料庫，可執行以下指令，並替換 <em>/path/to/pkg.sql</em> 為適當的檔案名稱與位置：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg backup -d /path/to/pkg.sql</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-clean>4.4.8. 移除過時的套件<a class=anchor href=#pkgng-clean></a></h4><div class=paragraph><p>預設 pkg 會儲存 Binary 套件在快取目錄定義在 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a> 中的 <code>PKG_CACHEDIR</code>，只會保留最後安裝的套件複本。較舊版的 pkg 會保留所有先前的套件，若要移除這些過時的 Binary 套件，可執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg clean</span></code></pre></div></div><div class=paragraph><p>使用以下指令可清空全部的快取：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg clean -a</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-set>4.4.9. 修改套件 Metadata<a class=anchor href=#pkgng-set></a></h4><div class=paragraph><p>在 FreeBSD Port 套件集中的軟體可能會經歷主要版號的修改，要解決這個問題可使用 pkg 內建的指令來更新套件來源。這非常有用，例如 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a> 重新命名為 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php53/>lang/php53</a> 因此 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a> 從此之後代表版本 <code>5.4</code>。</p></div><div class=paragraph><p>要更改上述例子中的套件來源，可執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o lang/php5:lang/php53</span></code></pre></div></div><div class=paragraph><p>再一個例子，要更新 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/ruby18/>lang/ruby18</a> 為 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/ruby19/>lang/ruby19</a>，可執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o lang/ruby18:lang/ruby19</span></code></pre></div></div><div class=paragraph><p>最後一個例子，要更改 <span class=filename>libglut</span> 共用程式庫的來源從 <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/libglut/>graphics/libglut</a> 改成 <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/freeglut/>graphics/freeglut</a> 可執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o graphics/libglut:graphics/freeglut</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>在更改套件來源之後，很重要的一件事是要重新安裝套件，來讓相依的套件也同時使用修改後的來源。要強制重新安裝相依套件，可執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install -Rf graphics/freeglut</span></code></pre></div></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=ports-using>4.5. 使用 Port 套件集<a class=anchor href=#ports-using></a></h3><div class=paragraph><p>Port 套件集是指一數個 <span class=filename>Makefiles</span>、修補及描述檔案，每一組這些檔案可用來編譯與安裝在 FreeBSD 上的一個應用程式，即稱為一個 <em>Port</em>。</p></div><div class=paragraph><p>預設，Port 套件集儲存在 <span class=filename>/usr/ports</span> 的子目錄下。</p></div><div class=paragraph><p>在應用程式可以使用 Port 編譯之前，必須先安裝 Port 套件集。若在安裝 FreeBSD 時沒有安裝，可以使用以下其中一種方式安裝：</p></div><div id=ports-using-portsnap-method class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Portsnap 方法</strong></p></div><div class=paragraph><p>FreeBSD 的基礎系統內含 Portsnap，這是一個可用來取得 Port 套件集簡單又快速的工具，較建議多數使用者使用這個方式。此工具會連線到 FreeBSD 的網站，驗証密鑰，然後下載 Port 套件集的新複本。該金鑰是要用來檢驗所有已下載檔案的完整性。</p></div><div class="olist arabic"><ol class=arabic><li><p>要下載壓縮後的 Port 套件集快照 (Snapshot) 到 <span class=filename>/var/db/portsnap</span>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span></code></pre></div></div></li><li><p>當第一次執行 Portsnap 時，要先解壓縮快照到 <span class=filename>/usr/ports</span>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap extract</span></code></pre></div></div></li><li><p>在完成上述第一次使用 Portsnap 的動作之後，往後可隨需要執行以下指令來更新 <span class=filename>/usr/ports</span> ：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span>
<span class=c># portsnap update</span></code></pre></div></div><div class=paragraph><p>當使用 <code>fetch</code> 時也可同時執行 <code>extract</code> 或 <code>update</code> 如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch update</span></code></pre></div></div></li></ol></div></div></div><div id=ports-using-subversion-method class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Subversion 方法</strong></p></div><div class=paragraph><p>若要取得更多對 Port 樹的控制，或若有本地的變更需要維護，可以使用 Subversion 來取得 Port 套件集。請參考 <a href=https://docs.freebsd.org/en/articles/committers-guide/#subversion-primer>Subversion Primer</a> 來取得 Subversion 的詳細說明。</p></div><div class="olist arabic"><ol class=arabic><li><p>必須安裝 Subversion 才可用來取出 (Check out) Port 樹。若已存在 Port 樹的複本，可使用此方式安裝 Subversion：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/devel/subversion</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>若尚無法使用 Port 樹，或已經使用 pkg 來管理套件，可使用套件來安裝 Subversion：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install subversion</span></code></pre></div></div></li><li><p>取出 Port 樹的複本：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/ports/head /usr/ports</span></code></pre></div></div></li><li><p>若需要，在第一次 Subversion 取出後可使用以下指令更新 <span class=filename>/usr/ports</span>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update /usr/ports</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Port 套件集中含有代表不同軟體分類的目錄，每個分類底下的子目錄代表每個應用程式，每個內含數個用來告訴 FreeBSD 如何編譯與安裝該程式檔案的應用程式子目錄即稱作 <em>Port Skeleton</em>，每個 Port Skeleton 會含有以下檔案及目錄：</p></div><div class=ulist><ul><li><p><span class=filename>Makefile</span>：內含用來說明應用程式要如何編譯、要安裝該程式到那的敘述句。</p></li><li><p><span class=filename>distinfo</span>：內含編譯 Port 必須下載的檔案名稱以及校驗碼 (Checksum)。</p></li><li><p><span class=filename>files/</span>：此目錄含有編譯與安裝程式到 FreeBSD 時所需的修補檔。此目錄也可能含有其他用來編譯 Port 的檔案。</p></li><li><p><span class=filename>pkg-descr</span>：提供程式更詳細的說明。</p></li><li><p><span class=filename>pkg-plist</span>：Port 安裝的所有檔案清單，也同時會告訴 Port 系統解除安裝時要移除那一些檔案。</p></li></ul></div><div class=paragraph><p>部份 Port 含有 <span class=filename>pkg-message</span> 或其他檔案用來處理特殊情況。要取得有關這些檔案的詳細資訊，以及 Port 的概要可參考 <a href=https://docs.freebsd.org/en/books/porters-handbook/>FreeBSD Porter’s Handbook</a>。</p></div><div class=paragraph><p>Port 中並不含實際的原始碼，即為 <span class=filename>distfile</span>，在編譯 Port 解壓縮時會自動下載的原始碼到 <span class=filename>/usr/ports/distfiles</span>。</p></div><div class=sect3><h4 id=ports-skeleton>4.5.1. 安裝 Port<a class=anchor href=#ports-skeleton></a></h4><div class=paragraph><p>下面我們會介紹如何使用 Port 套件集來安裝、移除軟體的基本用法。 <code>make</code> 可用的目標及環境變數詳細說明可參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a>。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>在編譯任何 Port 套件前，請先確認已經如前章節所敘述之方法更新 Port 套件集。安裝任何第三方軟體皆可能會導致安全性漏洞，建議在安裝前先閱讀 <a href=https://vuxml.freebsd.org/ class=bare>https://vuxml.freebsd.org/</a> 了解 Port 已知的安全性問題。或者在每次安裝新 Port 前執行 <code>pkg audit -F</code>。此指令可以設定在每日系統安全性檢查時自動完成安全性稽查以及更新漏洞資料庫。要取得更多資訊，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-audit&amp;sektion=8&amp;format=html">pkg-audit(8)</a> 及 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>。</p></div></td></tr></tbody></table></div><div class=paragraph><p>使用 Port 套件集會假設您擁有可正常連線的網路，同時也會需要超級使用者的權限。</p></div><div class=paragraph><p>要編譯並安裝 Port，需切換目錄到要安裝的 Port 底下，然後輸入 <code>make install</code>，訊息中會顯示安裝的進度：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span>
<span class=c># make install</span>
<span class=o>&gt;&gt;</span> lsof_4.88D.freebsd.tar.gz doesn<span class=s1>&#39;t seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.88
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.88D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.88.d,8
===&gt;  Applying FreeBSD patches for lsof-4.88.d,8
===&gt;  Configuring for lsof-4.88.d,8
...
[configure output snipped]
...
===&gt;  Building for lsof-4.88.d,8
...
[compilation output snipped]
...

===&gt;  Installing for lsof-4.88.d,8
...
[installation output snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.88.d,8
===&gt;   Registering installation for lsof-4.88.d,8
===&gt;  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
#</span></code></pre></div></div><div class=paragraph><p><code>lsof</code> 是需要進階權限才有辦法執行的程式，因此當該程式安裝完成時會顯示安全性警告。一旦安裝完成便會顯示指令提示。</p></div><div class=paragraph><p>有些 Shell 會將 <code>PATH</code> 環境變數中所列目錄中可用的指令做快取，來增加在執行指這些指令時的查詢速度。<code>tcsh</code> Shell 的使用者應輸入 <code>rehash</code> 來讓新安裝的指令不須指定完整路徑便可使用。若在 <code>sh</code> Shell 則使用 <code>hash -r</code>。請參考 Shell 的說明文件以取得更多資訊。</p></div><div class=paragraph><p>安裝過程中會建立工作用的子目錄用來儲存編譯時暫存的檔案。可移除此目錄來節省磁碟空間並漸少往後升級新版 Port 時造成問題：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make clean</span>
<span class=o>===&gt;</span>  Cleaning <span class=k>for </span>lsof-88.d,8
<span class=c>#</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若想要少做這個額外的步驟，可以編譯 Port 時使用 <code>make install clean</code>。</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_自訂_port_安裝>4.5.1.1. 自訂 Port 安裝<a class=anchor href=#_自訂_port_安裝></a></h5><div class=paragraph><p>部份 Port 提供編譯選項，可用來開啟或關閉應用程式中的元件、安全選項、或其他允許自訂的項目。這類的應用程式例子包括 <a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/security/gpgme/>security/gpgme</a> 以及 <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a>。若 Port 相依的其他 Port 有可設定的選項時，預設的模式會提示使用者選擇選單中的選項，這可能會讓安裝的過程暫停讓使用者操作數次。要避免這個情況，可一次設定所有選項，只要在 Port skeleton 中執行 <code>make config-recursive</code>，然後再執行 <code>make install [clean]</code> 編譯與安裝該 Port。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>使用 <code>config-recursive</code> 時，會使用 <code>all-depends-list</code> Target 來收集所有要設定 Port 清單。建議執行 <code>make config-recursive</code> 直到所有相依的 Port 選項都已定義，直到 Port 的選項畫面不會再出現，來確定所有相依的選項都已經設定。</p></div></td></tr></tbody></table></div><div class=paragraph><p>有許多方式可以重新進入 Port 的編譯選項清單，以便在編譯 Port 之後加入、移除或更改這些選項。方法之一是 <code>cd</code> 進入含有 Port 的目錄並輸入 <code>make config</code>。還有另一個方法是使用 <code>make showconfig</code>。最後一個方法是執行 <code>make rmconfig</code> 來移除所有曾選擇過的選項，讓您能夠重新設定。這些方法在 <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a> 中都有詳細的說明。</p></div><div class=paragraph><p>Port 系統使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> 來下載檔案，它支援許多的環境變數可設定。若 FreeBSD 系統在防火牆或 FTP/HTTP 代理伺服器後面，可以設定 <code>FTP_PASSIVE_MODE</code>, <code>FTP_PROXY</code> 以及 <code>FTP_PASSWORD</code> 變數。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> 取得完整支援的變數清單。</p></div><div class=paragraph><p>對於那些無法一直連線到網際網路的使用者，可在 <span class=filename>/usr/ports</span> 下執行 <code>make fetch</code> 來下載所有的 distfiles，或是可在某個分類的目錄中，例如 <span class=filename>/usr/ports/net</span>，或指定的 Port Skeleton 中執行。要注意的是，若 Port 有任何的相依，在分類或 Port Skeleton 中執行此指令並 <em>不會</em> 下載相依在其他分類的 Port distfiles。可使用 <code>make fetch-recursive</code> 來下載所有相依 Port 的 distfiles。</p></div><div class=paragraph><p>在部份少數情況，例如當公司或組織有自己的本地 distfiles 檔案庫，可使用 <code>MASTER_SITES</code> 變數來覆蓋在 <span class=filename>Makefile</span> 中指定的下載位址。當要指定替代的位址時可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/directory</span>
<span class=c># make MASTER_SITE_OVERRIDE= \</span>
ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/ fetch</code></pre></div></div><div class=paragraph><p>也可使用 <code>WRKDIRPREFIX</code> 及 <code>PREFIX</code> 變數來覆蓋預設的工作及目標目錄。例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=/usr/home/example/ports install</span></code></pre></div></div><div class=paragraph><p>會編譯在 <span class=filename>/usr/home/example/ports</span> 的 Port 並安裝所有東西到 <span class=filename>/usr/local</span> 下。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make PREFIX=/usr/home/example/local install</span></code></pre></div></div><div class=paragraph><p>會編譯在 <span class=filename>/usr/ports</span> Port 並安裝到 <span class=filename>/usr/home/example/local</span>。然後：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=../ports PREFIX=../local install</span></code></pre></div></div><div class=paragraph><p>來同時設定工作及目標目錄。</p></div><div class=paragraph><p>這些變數也可做為環境變數設定，請參考您使用的 Shell 操作手冊來取得如何設定環境變數的說明。</p></div></div></div><div class=sect3><h4 id=ports-removing>4.5.2. 移除已安裝的 Port<a class=anchor href=#ports-removing></a></h4><div class=paragraph><p>安裝的 Port 可以使用 <code>pkg delete</code> 解除安裝。 使用這個指令的範例可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-delete&amp;sektion=8&amp;format=html">pkg-delete(8)</a> 操作手冊找到。</p></div><div class=paragraph><p>或者，可在 Port 的目錄下執行 <code>make deinstall</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span>
make deinstall
<span class=o>===&gt;</span>  Deinstalling <span class=k>for </span>sysutils/lsof
<span class=o>===&gt;</span>   Deinstalling
Deinstallation has been requested <span class=k>for </span>the following 1 packages:

	lsof-4.88.d,8

The deinstallation will free 229 kB
<span class=o>[</span>1/1] Deleting lsof-4.88.d,8... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>建議閱讀 Port 解除安裝後的訊息，若有任何相依該 Port 的應用程式，這些資訊會被顯示出來，但解除安裝的程序仍會繼續。在這種情況下最好重新安裝應用程式來避免破壞相依性。</p></div></div><div class=sect3><h4 id=ports-upgrading>4.5.3. 升級 Port<a class=anchor href=#ports-upgrading></a></h4><div class=paragraph><p>隨著時間推移，Port 套件集中會有新版的軟體可用。本節將說明如何檢查是否有可以升級的軟體及如何升級。</p></div><div class=paragraph><p>要檢查已安裝 Port 是否有新版可用，請先確定已安裝最新版本的 Port 樹，使用 <a href=#ports-using-portsnap-method>Procedure: Portsnap 方法</a> 或 <a href=#ports-using-subversion-method>Procedure: Subversion 方法</a> 中說明的指令來更新。在 FreeBSD 10 與更新的版本，或若套件系統已轉換為 pkg，可以使用下列指令列出已經安裝的 Port 中有那些已過時：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg version -l &#34;&lt;&#34;</span></code></pre></div></div><div class=paragraph><p>在 FreeBSD 9.<em>X</em> 與較舊的版本，可以使用下列指令列出已經安裝的 Port 中有那些已過時：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_version -l &#34;&lt;&#34;</span></code></pre></div></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>在嘗試升級之前，請先從檔首閱讀 <span class=filename>/usr/ports/UPDATING</span> 來取得最近有那些 Port 已升級或系統已安裝。這個檔案中會說明各種問題及在升級 Port 時可能會需要使用者執行的額外步驟，例如檔案格式更改、設定檔位置更改、或任何與先前版本不相容的問題。留意那些與您要升級 Port 相關的指示，並依照這些指示執行升級。</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=ports-upgrading-tools>4.5.3.1. 升級與管理 Port 的工具<a class=anchor href=#ports-upgrading-tools></a></h5><div class=paragraph><p>Port 套件集含有數個工具可以進行升級，每一種工具都有其優點及缺點。</p></div><div class=paragraph><p>以往大多 Port 安裝會使用 Portmaster 或 Portupgrade，現在有較新的 Synth 可使用。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>那一種工具對特定系統是最佳的選擇取決於系統管理員。建議在使用任何這些工具之前先備份資料。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=portmaster>4.5.3.2. 使用 Portmaster 升級 Port<a class=anchor href=#portmaster></a></h5><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> 是可用來升級已安裝 Port 的小巧工具，它只使用了隨 FreeBSD 基礎系統安裝的工具，不需要相依其他 Port 或資料庫便可在 FreeBSD 使用，要使用 Port 安裝此工具可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portmaster</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Portmaster 將 Port 定義成四種類型：</p></div><div class=ulist><ul><li><p>根 Port：沒有相依且也不被任何其他 Port 相依。</p></li><li><p>主幹 Port：沒有相依，但被其他 Port 相依。</p></li><li><p>分支 Port：有相依，且其被其他 Port 相依。</p></li><li><p>枝 Port：有相依，但沒有被其他 Port 相依。</p></li></ul></div><div class=paragraph><p>要列出這幾個分類並搜尋是否有新版：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -L</span>
<span class=o>===&gt;&gt;&gt;</span> Root ports <span class=o>(</span>No dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> ispell-3.2.06_18
<span class=o>===&gt;&gt;&gt;</span> screen-4.0.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: screen-4.0.3_1
<span class=o>===&gt;&gt;&gt;</span> tcpflow-0.21_1
<span class=o>===&gt;&gt;&gt;</span> 7 root ports
...
<span class=o>===&gt;&gt;&gt;</span> Branch ports <span class=o>(</span>Have dependencies, are depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> apache22-2.2.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: apache22-2.2.8
...
<span class=o>===&gt;&gt;&gt;</span> Leaf ports <span class=o>(</span>Have dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> automake-1.9.6_2
<span class=o>===&gt;&gt;&gt;</span> bash-3.1.17
        <span class=o>===&gt;&gt;&gt;</span> New version available: bash-3.2.33
...
<span class=o>===&gt;&gt;&gt;</span> 32 leaf ports

<span class=o>===&gt;&gt;&gt;</span> 137 total installed ports
        <span class=o>===&gt;&gt;&gt;</span> 83 have new versions available</code></pre></div></div><div class=paragraph><p>此指令用來升級所有過時的 Port：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -a</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>預設 Portmaster 會在刪除已存在的 Port 前備份套件，若成功安裝新版 Portmaster 會刪除該備份。使用 <code>-b</code> 來讓 Portmaster 不會自動刪除備份。加入 <code>-i</code> 可啟動 Portmaster 的互動模式，會在升級每個 Port 前提示訊息。尚有許多可用的其他選項，請閱讀 <a href="https://man.freebsd.org/cgi/man.cgi?query=portmaster&amp;sektion=8&amp;format=html">portmaster(8)</a> 的操作手冊來取得詳細的用法。</p></div></td></tr></tbody></table></div><div class=paragraph><p>若升級的過程發生錯誤，可加入 <code>-f</code> 來升級並重新編譯所有 Port：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>Portmaster 也可用來安裝新的 Port 到系統，在編譯及安裝新 Port 前升級所有相依模組。要使用這個功能，要指定 Port 位於 Port 套件集中的位置：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster shells/bash</span></code></pre></div></div><div class=paragraph><p>更多有關 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> 的資訊可至其 <span class=filename>pkg-descr</span> 取得。</p></div></div><div class=sect4><h5 id=portupgrade>4.5.3.3. 使用 Portupgrade 升級 Port<a class=anchor href=#portupgrade></a></h5><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> 是另一個可以用來升級 Port 的工具，此工具會安裝一套可以用來管理 Port 的應用程式，它需要相依 Ruby。要安裝該 Port：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portupgrade</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>在執行升級之前使用此工具，建議使用 <code>pkgdb -F</code> 掃描已安裝的 Port 並修正該指令回報的所有資訊不一致的套件。</p></div><div class=paragraph><p>要升級所有安裝在系統上過時的 Port，可使用 <code>portupgrade -a</code>，或者加上 <code>-i</code> 會在每個套件升級時詢問確認：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -ai</span></code></pre></div></div><div class=paragraph><p>要升級指定的應用程式而非所有可用 Port 可使用 <code>portupgrade <em>pkgname</em></code>，非常重要的是，要加上 <code>-R</code> 來先升級指定應用程式所有相依的 Port：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -R firefox</span></code></pre></div></div><div class=paragraph><p>若使用 <code>-P</code>，Portupgrade 會先在 <code>PKG_PATH</code> 清單中的本地目錄中搜尋可用的套件。若本地沒有可用的套件，則會從遠端下載。若套件無法在本地或遠端找到，Portupgrade 則會使用 Port 來安裝。要避免完全使用 Port 安裝，可使用 <code>-PP</code>，這個選項會告訴 Portupgrade 若沒有套件可用時放棄安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -PP gnome3</span></code></pre></div></div><div class=paragraph><p>若只想要下載 Port distfiles 或套件，使用 <code>-P</code> 參數。若不要編譯或安裝任何東西，使用 <code>-F</code>。請參考 <code>portupgrade</code> 的操作手冊來取得所有可用選項的更多資訊。</p></div><div class=paragraph><p>更多有關 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> 的資訊可至其 <span class=filename>pkg-descr</span> 取得。</p></div></div></div><div class=sect3><h4 id=ports-disk-space>4.5.4. Port 與磁碟空間<a class=anchor href=#ports-disk-space></a></h4><div class=paragraph><p>使用 Port 套件集會隨著時間消耗磁碟空間。在編譯與安裝 Port 完之後，在 Port Skeleton 中執行 <code>make clean</code> 可清除暫存的 <span class=filename>work</span> 目錄。若使用 Portmaster 來安裝 Port，則會自動移除該目錄，除非使用 <code>-K</code>。若有安裝 Portupgrade，此指令將會移除所有在 Port 套件集的本地複本中找到的 <span class=filename>work</span> 目錄：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -C</span></code></pre></div></div><div class=paragraph><p>除此之外，許多過時的原始碼發行檔案會儲存在 <span class=filename>/usr/ports/distfiles</span>。使用 Portupgrade 刪除所有不再被任何 Port 所引用的 distfiles：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -D</span></code></pre></div></div><div class=paragraph><p>Portupgrade 可以移除所有未被任何安裝在系統上的 Port 所引用的 distfiles：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -DD</span></code></pre></div></div><div class=paragraph><p>若有安裝 Portmaster，則可使用：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster --clean-distfiles</span></code></pre></div></div><div class=paragraph><p>預設，若 distfile 應要被刪除，這個指令會以互動的方式向使用者確認。</p></div><div class=paragraph><p>除了以上指令外，<a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg_cutleaves/>ports-mgmt/pkg_cutleaves</a> 可自動移除不再需要使用的 Port。</p></div></div></div><div class=sect2><h3 id=ports-poudriere>4.6. 使用 Poudriere 編譯套件<a class=anchor href=#ports-poudriere></a></h3><div class=paragraph><p>Poudriere 是一個使用 BSD 授權條款用來建立與測試 FreeBSD 套件的工具。它使用 FreeBSD Jail 來建置獨立的編譯環境，這些 Jail 可以用來編譯與目前所在系統不同 FreeBSD 版本的套件，也同樣可以在主機為 amd64 的系統上編譯供 i386 使用的套件。套件編譯完成後的目錄配置會與官方鏡像站完全相同。這些套件可由 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 及其他套件管理工具使用。</p></div><div class=paragraph><p>Poudriere 可使用 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a> 套件或 Port 安裝。安裝完成後會有一個範例的設定檔 <span class=filename>/usr/local/etc/poudriere.conf.sample</span>。複製此檔案到 <span class=filename>/usr/local/etc/poudriere.conf</span>，編輯複製的檔案來配合本地的設定。</p></div><div class=paragraph><p>雖然在系統上執行 poudriere 並不一定要使用 ZFS，但使用了是有幫助的。當使用了 ZFS，則必須在 <span class=filename>/usr/local/etc/poudriere.conf</span> 指定 <code>ZPOOL</code> 以及 <code>FREEBSD_HOST</code> 應設定到一個最近的鏡像站。定義 <code>CCACHE_DIR</code> 可開啟使用 <a class=package href=https://cgit.freebsd.org/ports/tree/devel/ccache/>devel/ccache</a> 快取的功能來快取編譯結果並減少那些需時常編譯的程式碼的編譯次數。將 poudriere 資料集放到一個獨立的目錄並掛載到 <span class=filename>/poudriere</span> 可能會比較方便，其他設定項目採用預設值便足夠。</p></div><div class=paragraph><p>偵測到的處理器數量可用來定義要同時執行多少個編譯。並給予足夠的虛擬記憶體，不論是 RAM 或交換空間，若虛擬記憶體不足，編譯 Jail 的動作將會停止並被清除，會造成奇怪的錯誤訊息。</p></div><div class=sect3><h4 id=poudriere-initialization>4.6.1. 初始化 Jail 與 Port 樹<a class=anchor href=#poudriere-initialization></a></h4><div class=paragraph><p>在設定之後，初始化 poudriere 來安裝 Jail 及其所需的 FreeBSD 樹與 Port 樹。使用 <code>-j</code> 來指定 Jail 的名稱以及 <code>-v</code> 來指定 FreeBSD 的版本。在執行 FreeBSD/amd64 的系統上可使用 <code>-a</code> 來設定要使用的架構為 <code>i386</code> 或 <code>amd64</code>，預設會採用使用 <code>uname</code> 所顯示的架構。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere jail -c -j 10amd64 -v 10.0-RELEASE</span>
<span class=o>====&gt;&gt;</span> Creating 10amd64 fs... <span class=k>done</span>
<span class=o>====&gt;&gt;</span> Fetching base.txz <span class=k>for </span>FreeBSD 10.0-RELEASE amd64
/poudriere/jails/10amd64/fromftp/base.txz      100% of   59 MB 1470 kBps 00m42s
<span class=o>====&gt;&gt;</span> Extracting base.txz... <span class=k>done</span>
<span class=o>====&gt;&gt;</span> Fetching src.txz <span class=k>for </span>FreeBSD 10.0-RELEASE amd64
/poudriere/jails/10amd64/fromftp/src.txz       100% of  107 MB 1476 kBps 01m14s
<span class=o>====&gt;&gt;</span> Extracting src.txz... <span class=k>done</span>
<span class=o>====&gt;&gt;</span> Fetching games.txz <span class=k>for </span>FreeBSD 10.0-RELEASE amd64
/poudriere/jails/10amd64/fromftp/games.txz     100% of  865 kB  734 kBps 00m01s
<span class=o>====&gt;&gt;</span> Extracting games.txz... <span class=k>done</span>
<span class=o>====&gt;&gt;</span> Fetching lib32.txz <span class=k>for </span>FreeBSD 10.0-RELEASE amd64
/poudriere/jails/10amd64/fromftp/lib32.txz     100% of   14 MB 1316 kBps 00m12s
<span class=o>====&gt;&gt;</span> Extracting lib32.txz... <span class=k>done</span>
<span class=o>====&gt;&gt;</span> Cleaning up... <span class=k>done</span>
<span class=o>====&gt;&gt;</span> Jail 10amd64 10.0-RELEASE amd64 is ready to be used</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere ports -c -p local</span>
<span class=o>====&gt;&gt;</span> Creating <span class=nb>local </span>fs... <span class=k>done</span>
<span class=o>====&gt;&gt;</span> Extracting portstree <span class=s2>&#34;local&#34;</span>...
Looking up portsnap.FreeBSD.org mirrors... 7 mirrors found.
Fetching public key from ec2-eu-west-1.portsnap.freebsd.org... <span class=k>done</span><span class=nb>.</span>
Fetching snapshot tag from ec2-eu-west-1.portsnap.freebsd.org... <span class=k>done</span><span class=nb>.</span>
Fetching snapshot metadata... <span class=k>done</span><span class=nb>.</span>
Fetching snapshot generated at Tue Feb 11 01:07:15 CET 2014:
94a3431f0ce567f6452ffde4fd3d7d3c6e1da143efec76100% of   69 MB 1246 kBps 00m57s
Extracting snapshot... <span class=k>done</span><span class=nb>.</span>
Verifying snapshot integrity... <span class=k>done</span><span class=nb>.</span>
Fetching snapshot tag from ec2-eu-west-1.portsnap.freebsd.org... <span class=k>done</span><span class=nb>.</span>
Fetching snapshot metadata... <span class=k>done</span><span class=nb>.</span>
Updating from Tue Feb 11 01:07:15 CET 2014 to Tue Feb 11 16:05:20 CET 2014.
Fetching 4 metadata patches... <span class=k>done</span><span class=nb>.</span>
Applying metadata patches... <span class=k>done</span><span class=nb>.</span>
Fetching 0 metadata files... <span class=k>done</span><span class=nb>.</span>
Fetching 48 patches.
<span class=o>(</span>48/48<span class=o>)</span> 100.00%  <span class=k>done</span><span class=nb>.</span>
<span class=k>done</span><span class=nb>.</span>
Applying patches...
<span class=k>done</span><span class=nb>.</span>
Fetching 1 new ports or files... <span class=k>done</span><span class=nb>.</span>
/poudriere/ports/tester/CHANGES
/poudriere/ports/tester/COPYRIGHT

<span class=o>[</span>...]

Building new INDEX files... <span class=k>done</span>.</code></pre></div></div><div class=paragraph><p>在一台電腦，poudriere 可使用多組設定在多個 Jail 編譯來自不同 Port 樹的 Port。用來定義這些組合的自訂設定稱作 <em>sets</em>，可在安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a> 或 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere-devel/>ports-mgmt/poudriere-devel</a> 後參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=poudriere&amp;sektion=8&amp;format=html">poudriere(8)</a> 中的 CUSTOMIZATION 章節來取得詳細的資訊。</p></div><div class=paragraph><p>在此處示範的基本設定放了單一個 jail-, port- 以及 set- 特定的 <span class=filename>make.conf</span> 在 <span class=filename>/usr/local/etc/poudriere.d</span>。在此範例使用的檔案名稱由 Jail 名稱、Port 名稱以及 set 名稱所組成：<span class=filename>10amd64-local-workstation-make.conf</span>。系統 <span class=filename>make.conf</span> 與這個新的檔案在編譯時期會被合併為編譯 Jail 要使用的 <span class=filename>make.conf</span>。</p></div><div class=paragraph><p>要編譯的套件會輸入到 <span class=filename>10amd64-local-workstation-pkglist</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>editors/emacs
devel/git
ports-mgmt/pkg
...</pre></div></div><div class=paragraph><p>可使用以下方式設定選項及相依：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere options -j 10amd64 -p local -z workstation -f 10amd64-local-workstation-pkglist</span></code></pre></div></div><div class=paragraph><p>最後，編譯套件並建立套件檔案庫：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere bulk -j 10amd64 -p local -z workstation -f 10amd64-local-workstation-pkglist</span></code></pre></div></div><div class=paragraph><p>在執行時，按下 <span class=keyseq><kbd>Ctrl</kbd>+<kbd>t</kbd></span> 可以顯示目前編譯的狀態，Poudriere 也會編譯在 <span class=filename>/poudriere/logs/bulk/jailname</span> 中的檔案，可用在網頁伺服器來顯示編譯資訊。</p></div><div class=paragraph><p>完成之後，新套件現在可以從 poudriere 檔案庫來安裝。</p></div><div class=paragraph><p>要取得更多使用 poudriere 的資訊，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=poudriere&amp;sektion=8&amp;format=html">poudriere(8)</a> 及主網站 <a href=https://github.com/freebsd/poudriere/wiki class=bare>https://github.com/freebsd/poudriere/wiki</a>。</p></div></div><div class=sect3><h4 id=_設定_pkg_客戶端使用_poudriere_檔案庫>4.6.2. 設定 pkg 客戶端使用 Poudriere 檔案庫<a class=anchor href=#_設定_pkg_客戶端使用_poudriere_檔案庫></a></h4><div class=paragraph><p>雖然可以同時使用自訂的檔案庫與官方檔案庫，但有時關閉官方檔案庫會有幫助。這可以透過建立一個設定檔覆蓋並關閉官方的設定檔來完成。建立 <span class=filename>/usr/local/etc/pkg/repos/FreeBSD.conf</span> 包含以下內容：</p></div><div class="literalblock programlisting"><div class=content><pre>FreeBSD: {
	enabled: no
}</pre></div></div><div class=paragraph><p>通常最簡單要提供 poudriere 檔案庫給客戶端的方式是透過 HTTP。安裝一個網頁伺服器來提供套件目錄，通常會像：<span class=filename>/usr/local/poudriere/data/packages/10amd64</span>，其中 <span class=filename>10amd64</span> 是編譯的名稱。</p></div><div class=paragraph><p>若要連往套件檔案庫的 URL 是：<code><a href=http://pkg.example.com/10amd64 class=bare>http://pkg.example.com/10amd64</a></code>，則在 <span class=filename>/usr/local/etc/pkg/repos/custom.conf</span> 的檔案庫設定檔為：</p></div><div class="literalblock programlisting"><div class=content><pre>custom: {
	url: &#34;http://pkg.example.com/10amd64&#34;,
	enabled: yes,
}</pre></div></div></div></div><div class=sect2><h3 id=ports-nextsteps>4.7. 安裝後的注意事項<a class=anchor href=#ports-nextsteps></a></h3><div class=paragraph><p>不論軟體是從套件或 Port 安裝，大部份的第三方應用程式安裝完後需要做某種程度的設定，下列指令與位置可以用來協助找到應用程式安裝了什麼。</p></div><div class=ulist><ul><li><p>大部份應用程式安裝會在 <span class=filename>/usr/local/etc</span> 安裝至少一個預設的設定檔，若應用程式有大量設定檔的時則會建立一個子目錄來存放這些設定檔。範例的設定檔案名稱通常使用 <span class=filename>.sample</span> 結尾，設定檔應要仔細查看並可能要做一些編輯讓設定檔符合系統的需求，要編輯設定檔範本前需先複製該檔案並去除 <span class=filename>.sample</span> 副檔名。</p></li><li><p>應用程式提供的文件會安裝到 <span class=filename>/usr/local/shared/doc</span>，且許多應用程式也同時會安裝操作手冊，在繼續使用應用程式前應先查看這些文件。</p></li><li><p>部份應用程式會以服務的方式執行，在啟動應用程式前前需要加入設定到 <span class=filename>/etc/rc.conf</span>。這些應用程式通常會安裝啟動 Script 到 <span class=filename>/usr/local/etc/rc.d</span>，請參考 <a href=./#configtuning-starting-services>啟動服務</a> 來取得更多資訊。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>依設計，應用程式不會在安裝時執行其啟動 Script，也不會在解除安裝或升級時執行其中止 Script，這留給各系統的管理者去做決定。</p></div></td></tr></tbody></table></div></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> 的使用者應要執行 <code>rehash</code> 來更新已知 Binary 清單到 Shell 的 <code>PATH</code>。</p></li><li><p>使用 <code>pkg info</code> 來了解應用程式安裝了那些檔案、操作手冊以及 Binary。</p></li></ul></div></div><div class=sect2><h3 id=ports-broken>4.8. 處理損壞的 Port<a class=anchor href=#ports-broken></a></h3><div class=paragraph><p>當發現某個 Port 無法順利編譯或安裝，可以嘗試以下幾種方法解決：</p></div><div class="olist arabic"><ol class=arabic><li><p>搜尋 <a href=https://www.FreeBSD.org/support/>問題回報資料庫</a> 看該 Port 有沒有待審核的修正，若有的話可以使用該修正來修正問題。</p></li><li><p>尋求維護人員的協助，在 Port Skeleton 目錄中輸入 <code>make maintainer</code> 或閱讀 Port 的 <span class=filename>Makefile</span> 來取得維護人員的電子郵件位址。寄給維護人員的郵件內容請記得要包含 Port 的 <span class=filename>Makefile</span> 中的 <code>$FreeBSD:</code> 一整行及輸出的錯誤訊息。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>有一些 Port 並非由個人維護，而是由 <a href=https://docs.freebsd.org/zh-tw/articles/mailing-list-faq/>郵遞論壇</a> 維護，有許多，但並非全部，只要郵件地址長的像 <a href=mailto:freebsd-listname@FreeBSD.org>freebsd-listname@FreeBSD.org</a> 都是，寄信時記得代入實際的論壇名稱。</p></div><div class=paragraph><p>尤其是由 <a href=mailto:ports@FreeBSD.org>ports@FreeBSD.org</a> 所維護的 Port 都不是由特定個人維護，而該 Port 的修正與支援都是來自訂閱該郵遞論壇的一般社群所提供，我們隨時歡迎志工參與!</p></div></td></tr></tbody></table></div><div class=paragraph><p>若寄信後沒有取得任何回應，可以依照 <a href=https://docs.freebsd.org/zh-tw/articles/problem-reports/>撰寫 FreeBSD 問題回報</a> 的說明使用 Bugzilla 提出問題回報。</p></div></li><li><p>自行修正看看！<a href=https://docs.freebsd.org/en/books/porters-handbook/>Porter’s Handbook</a> 中含有 Port 基礎架構的詳細資訊，可提供資訊讓您可修正偶然損壞的 Port 或甚至您可以提交之自己的 Port！</p></li><li><p>依照 <a href=#pkgng-intro>使用 pkg 管理 Binary 套件</a> 中的說明安裝 Binary 套件，替代使用 Port 安裝。</p></li></ol></div></div></div></div><div class=sect1><h2 id=x11>Chapter 5. X Window 系統<a class=anchor href=#x11></a></h2><div class=sectionbody><div class=sect2><h3 id=x11-synopsis>5.1. 概述<a class=anchor href=#x11-synopsis></a></h3><div class=paragraph><p>使用 bsdinstall 安裝 FreeBSD 並不會自動安裝圖型化使用者介面。本章將說明如何安裝並設定 Xorg，該應用程式提供開放源碼的 X Window 系統來提供圖型化環境。接著會說明如何找到並安裝桌面環境或視窗管理程式。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>偏好安裝時會自動設定 Xorg 並且在安裝過程提供視窗管理程式選項的使用者請參考 <a href=http://www.trueos.org/ class=bare>http://www.trueos.org/</a> 網站。</p></div></td></tr></tbody></table></div><div class=paragraph><p>更多有關 Xorg 支援影像硬體資訊，請參考 <a href=http://www.x.org/>x.org</a> 網站。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>組成 X Window 系統的各種元件以及它們是如何相互運作。</p></li><li><p>如何安裝並設定 Xorg。</p></li><li><p>如何安裝並設定各種視窗管理程式與桌面環境。</p></li><li><p>如何在 Xorg 上使用 TrueType™ 字型。</p></li><li><p>如何設定系統以使用圖形化登入 (XDM)。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解如何依照 <a href=./#ports>安裝應用程式：套件與 Port</a> 說明安裝其他第三方軟體。</p></li></ul></div></div><div class=sect2><h3 id=x-understanding>5.2. 術語<a class=anchor href=#x-understanding></a></h3><div class=paragraph><p>雖然 X 各元件的所有細節及運作方式，並不是必須要知道的。 但對它們有些基本概念會更容易上手。</p></div><div class=dlist><dl><dt class=hdlist1>X 伺服器 (X Server)</dt><dd><p>X 最初設計是以網路為中心，採用 "client-server" 架構。在此架構下 "X 伺服器" 在有鍵盤、螢幕、滑鼠的電腦上運作。該伺服器負責的工作包含管理顯示、處理來自鍵盤、滑鼠的輸入及來自其他設備 (如平板或或影像投影機) 的輸入或輸出。這點可能會讓人感到困惑，因為 X 使用的術語與一般的認知剛好相反。 一般認知會以為 "X 伺服器" 是要在最強悍的主機上執行，而 "X 客戶端" 才是在桌機上面執行，實際上卻是相反。</p></dd><dt class=hdlist1>X 客戶端 (X Client)</dt><dd><p>每個 X 應用程式，如 XTerm、Firefox 都是 "客戶端"。 客戶端會傳訊息到伺服器，例如："請在這些座標畫一個視窗"，接著伺服器會傳回訊息，如："使用者剛點選了確定按鈕"。</p><div class=paragraph><p>在家庭或小型辦公室環境，通常 X 伺服器跟 X 客戶端都是在同一台電腦上執行。也可以在比較慢的電腦上執行 X 伺服器， 並在比較強、比較貴的系統上執行 X 應用程式。 在這種情景，X 客戶端與伺服器之間的溝通就需透過網路來進行。</p></div></dd><dt class=hdlist1>視窗管理程式 (Window Manager)</dt><dd><p>X 並不規定螢幕上的視窗該長什麼樣、要如何移動滑鼠指標、 要用什麼鍵來在視窗切換、每個視窗的標題列長相，及是否該有關閉按鈕，等等。事實上，X 把這部分交給所謂的視窗管理程式來管理。可用的<a href=http://www.xwinman.org/>視窗管理程式有很多種</a>，每一種視窗管理程式都提供不同的使用介面風格：有些支援虛擬桌面，有些允許自訂組合鍵來管理桌面，有些有 "開始" 鈕，有些則是可更換佈景主題，可自行安裝新的佈景主題以更換外觀。 視窗管理程式可在 Port 套件集的 <span class=filename>x11-wm</span> 分類找到。</p><div class=paragraph><p>每個視窗管理程式也各有其不同的設定機制，有些需要手動修改設定檔， 而有的則可透過圖型化工具來完成大部分的設定工作。</p></div></dd><dt class=hdlist1>桌面環境 (Desktop Environment)</dt><dd><p>KDE 與 GNOME 會被稱作桌面環境是因為包含了完整常用桌面作業的應用程式，這些應用程式可能包含文書軟體、網頁瀏覽器及遊戲。</p></dd><dt class=hdlist1>聚焦政策 (Focus Policy)</dt><dd><p>視窗管理程式負責滑鼠指標的聚焦政策。 聚焦政策指的是如何決定使用中及接收鍵盤輸入的視窗。</p><div class=paragraph><p>通常較為人熟悉的聚焦政策叫做 "click-to-focus"，這個模式中，滑鼠點選到的視窗便會處於作用中 (Active) 的狀態。在 "focus-follows-mouse" 模式滑鼠指標所在的視窗便是作用中的視窗，只要把滑鼠移到其他視窗就可以改變作用中的視窗，若滑鼠移到根視窗 (Root Window)，則會聚焦在根視窗。在 "sloppy-focus" 模式，既使滑鼠移到根視窗，仍然會聚焦在最後聚焦的視窗上，此模式只有當滑鼠進入新的視窗時才會聚焦於該視窗，而非離開目前視窗時。"click-to-focus" 模式用滑鼠點擊來決定作用中的視窗，且該視窗會被置頂到所有其他視窗之前，即使滑鼠移到其他視窗，所有的鍵盤輸入仍會由該視窗所接收。</p></div><div class=paragraph><p>不同的視窗管理程式支援不同的聚焦模式，全部都支援 click-to-focus 且其中大部份支援其他模式，請查看視窗管理程式的說明文件來了解可用的聚焦模式。</p></div></dd><dt class=hdlist1>視窗元件 (Widget)</dt><dd><p>視窗元件指的是在所有在使用者介面上可被點選或操作的項目，這包括按鈕、核選方塊、單選按鈕、圖示及清單。 視窗元件工具包 (Widget toolkit) 是指用來建立圖型化應用程式的一系列的視窗元件。目前有數個有名的視窗元件工具包，包含 KDE 所使用的 Qt、GNOME 所使用的 GTK+。 因此應用程式會依其開發時所選用的視窗元件工具包而有不同的外觀。</p></dd></dl></div></div><div class=sect2><h3 id=x-install>5.3. 安裝 Xorg<a class=anchor href=#x-install></a></h3><div class=paragraph><p>在 FreeBSD，Xorg 可透過套件或 Port 來安裝。</p></div><div class=paragraph><p>使用 Binary 套件的安裝速度較快，但可用的自訂選項較少：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xorg</span></code></pre></div></div><div class=paragraph><p>要從 Port 套件集編譯與安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/xorg</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>兩種安裝方式皆可完整安裝 Xorg 系統，對大多數使用者較建議使用 Binary 套件安裝。</p></div><div class=paragraph><p>較精簡版本的 X 系統適合給有經驗的使用者使用，可至 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg-minimal/>x11/xorg-minimal</a> 取得。這個版本就不會安裝大多數的文件、函數庫以及應用程式，而部份應用程式會需要這些額外的元件才能運作。</p></div></div><div class=sect2><h3 id=x-config>5.4. Xorg 設定<a class=anchor href=#x-config></a></h3><div class=sect3><h4 id=x-config-quick-start>5.4.1. 快速開始<a class=anchor href=#x-config-quick-start></a></h4><div class=paragraph><p>Xorg 支援大多數常見的顯示卡、鍵盤以及指標裝置。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>顯示卡、顯示器以及輸入裝置會自動偵測，無須任何手動設置。除非自動設置失敗，否則請勿建立 <span class=filename>xorg.conf</span> 或執行 <code>-configure</code> 步驟。</p></div></td></tr></tbody></table></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>若 Xorg 曾經在電腦使用過，可先將現有的設定檔重新命名或移除：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /etc/X11/xorg.conf ~/xorg.conf.etc</span>
<span class=c># mv /usr/local/etc/X11/xorg.conf ~/xorg.conf.localetc</span></code></pre></div></div></li><li><p>加入要執行 Xorg 的使用者到 <code>video</code> 或 <code>wheel</code> 群組，以便在可用時能開啟 3D 加速。要加入使用者 <em>jru</em> 到任一個可用的群組：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod video -m jru || pw groupmod wheel -m jru</span></code></pre></div></div></li><li><p>預設內含 TWM 視窗管理程式，啟動 Xorg 時便會啟動該視窗管理程式：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% startx</code></pre></div></div></li><li><p>在部份較舊版的 FreeBSD，在切換回文字 Console 前系統 Console 必須設為 <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> 才可正常運作，請參考 <a href=#x-config-kms>核心模式設定 (Kernel Mode Setting, KMS)</a>。</p></li></ol></div></div></div></div><div class=sect3><h4 id=x-config-user-group>5.4.2. 可加速影像處理的使用者群組<a class=anchor href=#x-config-user-group></a></h4><div class=paragraph><p>要存取 <span class=filename>/dev/dri</span> 需要允許顯示卡的 3D 加速功能，這通常只需要將要執行 X 的使用者加入 <code>video</code> 或 <code>wheel</code> 群組。此處使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 來將使用者 <em>slurms</em> 加入 <code>video</code> 群組，若沒有 <code>video</code> 則會加入 <code>wheel</code> 群組：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod video -m slurms || pw groupmod wheel -m slurms</span></code></pre></div></div></div><div class=sect3><h4 id=x-config-kms>5.4.3. 核心模式設定 (Kernel Mode Setting, KMS)<a class=anchor href=#x-config-kms></a></h4><div class=paragraph><p>當電腦顯示從 Console 切換到高螢幕解析度供 X 使用時，必須設定影像輸出<em>模式</em>。最近版本的 Xorg 使用了核心內部的系統來讓切換模式更有效率。較舊版的 FreeBSD 使用的 <a href="https://man.freebsd.org/cgi/man.cgi?query=sc&amp;sektion=4&amp;format=html">sc(4)</a> 並不知到 KMS 系統的存在，這會導致關閉 X 之後即始仍在運作但系統 Console 卻呈現空白。較新版的 <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> Console 可避免這個問題。</p></div><div class=paragraph><p>加入此行到 <span class=filename>/boot/loader.conf</span> 來開啟 <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a>：</p></div><div class="literalblock programlisting"><div class=content><pre>kern.vty=vt</pre></div></div></div><div class=sect3><h4 id=x-config-files>5.4.4. 設定檔<a class=anchor href=#x-config-files></a></h4><div class=paragraph><p>通常不需要做手動設置，除非自動設置無法運作，否則請不要手動建立設定檔。</p></div><div class=sect4><h5 id=x-config-files-directory>5.4.4.1. 目錄<a class=anchor href=#x-config-files-directory></a></h5><div class=paragraph><p>Xorg 會查看數個目錄來尋找設定檔，在 FreeBSD 較建議使用 <span class=filename>/usr/local/etc/X11/</span> 來存放這些設定檔，使用這個目錄可以幫助將應用程式檔案與作業系統檔案分離。</p></div><div class=paragraph><p>儲存設定檔在傳統的 <span class=filename>/etc/X11/</span> 仍可運作，但並不建議將應用程式檔案與基礎 FreeBSD 檔案混合在一起存放。</p></div></div><div class=sect4><h5 id=x-config-files-single-or-multi>5.4.4.2. 單檔或多檔<a class=anchor href=#x-config-files-single-or-multi></a></h5><div class=paragraph><p>使用多檔，每一個檔案只設定一個指定項目會較傳統使用單一 <span class=filename>xorg.conf</span> 設定來的簡單。這些檔案會存放在主設定檔目錄下的 <span class=filename>xorg.conf.d/</span> 子目錄，完整路徑通常為 <span class=filename>/usr/local/etc/X11/xorg.conf.d/</span>。</p></div><div class=paragraph><p>於本節稍後會有這些檔案的範例。</p></div><div class=paragraph><p>傳統單一 <span class=filename>xorg.conf</span> 的方式仍可運作，但比起在 <span class=filename>xorg.conf.d/</span> 子目錄中的多檔設定方式較不明瞭且沒有彈性。</p></div></div></div><div class=sect3><h4 id=x-config-video-cards>5.4.5. 顯示卡<a class=anchor href=#x-config-video-cards></a></h4><div class=paragraph><p>由於最近 FreeBSD 版本所做的變更，現在可以使用由 Port 或套件所提供的繪圖驅動程式，所以使用者可以使用下列來自 <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/drm-kmod/>graphics/drm-kmod</a> 的驅動程式。</p></div><div id=x-config-video-cards-ports class=dlist><dl><dt class=hdlist1>Intel KMS 驅動程式</dt><dd><p>大多數使用 Intel KMS 驅動程式的 Intel 顯示卡支援 2D 與 3D 加速。</p><div class=paragraph><p>驅動程式名稱：<code>i915kms</code></p></div><div class=paragraph><p>大多數使用 Radeon KMS 驅動程式的舊 AMD 顯示卡支援 2D 與 3D 加速。</p></div><div class=paragraph><p>驅動程式名稱：<code>radeonkms</code></p></div><div class=paragraph><p>大多數使用 AMD KMS 驅動程式的新 AMD 顯示卡支援 2D 與 3D 加速。</p></div><div class=paragraph><p>驅動程式名稱：<code>amdgpu</code></p></div><div class=paragraph><p>參考文獻請至 <a href=https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units</a> 或至 <a href=https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units</a> 取得支援的 GPU 清單。</p></div></dd></dl></div><div id=x-config-video-cards-intel class=dlist><dl><dt class=hdlist1>Intel™</dt><dd><p>3D 加速在大多數 Intel™ 顯示晶片都有支援，最新到 Ivy Bridge (HD Graphics 2500, 4000, 及 P4000) 包含 Iron Lake (HD Graphics) 與 Sandy Bridge (HD Graphics 2000)。</p><div class=paragraph><p>驅動程式名稱：<code>intel</code></p></div><div class=paragraph><p>參考文獻請至 <a href=https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units</a>。</p></div></dd></dl></div><div id=x-config-video-cards-radeon class=dlist><dl><dt class=hdlist1>AMD™ Radeon</dt><dd><p>Radeon 顯示卡支援 2D 及 3D 加速，最新到 HD6000 系列。</p><div class=paragraph><p>驅動程式名稱：<code>radeon</code></p></div><div class=paragraph><p>參考文獻請至 <a href=https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units</a>。</p></div></dd></dl></div><div id=x-config-video-cards-nvidia class=dlist><dl><dt class=hdlist1>NVIDIA</dt><dd><p>有數個 NVIDIA 驅動程式可於 Port 套件集中的 <span class=filename>x11</span> 分類取得，請安裝其中與顯示卡相符的驅動程式。</p><div class=paragraph><p>參考文獻請至 <a href=https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units</a>。</p></div></dd></dl></div><div id=x-config-video-cards-hybrid class=dlist><dl><dt class=hdlist1>混合組合繪圖晶片</dt><dd><p>部份筆記型電腦加入了額外繪圖處理單元到那些內建晶片組或處理。<em>Optimus</em> 結合了 Intel™ 及 NVIDIA 的硬體，<em>Switchable Graphics</em> 或 <em>Hybrid Graphics</em> 則是結合了 Intel™ 或 AMD™ 處理器與 AMD™ Radeon GPU。</p><div class=paragraph><p>這些混合繪圖系統的實作方式均不同，FreeBSD 的 Xorg 尚無法驅動所有的混合繪圖系統版本。</p></div><div class=paragraph><p>部份電腦提供了 BIOS 的選項可以關閉其中一個繪圖介面卡或選擇 <em>discrete</em> 模式，可用使用其中一種標準顯示卡驅動程式來驅動。例如，有時關閉 Optimus 系統中的 NVIDIA GPU 是可能讓 Intel™ 顯示晶片可用 Intel™ 驅動程式驅動。</p></div><div class=paragraph><p>BIOS 設定會依電腦的型號有所不同，在某些情況下，可以同時開啟兩個 GPU，而在建立的設定檔中的 <code>Device</code> 節只使用主要的 GPU 便能讓系統運作。</p></div></dd></dl></div><div id=x-config-video-cards-other class=dlist><dl><dt class=hdlist1>其他顯示卡</dt><dd><p>較不常見的顯示卡驅動程式可在 Port 套件集的 <span class=filename>x11-drivers</span> 目錄找到。</p><div class=paragraph><p>若沒有特定的驅動程式可以支援顯示卡，仍可能可用 <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-vesa/>x11-drivers/xf86-video-vesa</a> 驅動程式來驅動。該驅動程式可使用 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg/>x11/xorg</a> 安裝，也可使用 <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-vesa/>x11-drivers/xf86-video-vesa</a> 手動安裝。當沒有指定驅動程式時 Xorg 會嘗試使用這個驅動程式來驅動顯示卡。</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-scfb/>x11-drivers/xf86-video-scfb</a> 也是不特定顯示卡的驅動程式，可在許多 UEFI 及 ARM™ 的電腦上運作。</p></div></dd></dl></div><div id=x-config-video-cards-file class=dlist><dl><dt class=hdlist1>在檔案中設定影像驅動程式</dt><dd><p>要在設定檔設定使用 Intel™ 驅動程式：</p><div id=x-config-video-cards-file-intel class=exampleblock><div class=title>例 15. 在單檔中選擇 Intel™ 影像驅動程式</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-intel.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;intel&#34;
	# BusID    &#34;PCI:1:0:0&#34;
EndSection</pre></div></div><div class=paragraph><p>若有多張顯示卡，可取消註解 <code>BusID</code> identifier 然後設定為想要的顯示卡，顯示卡的 Bus ID 清單可以使用 <code>pciconf -lv | grep -B3 display</code> 取得。</p></div></div></div><div class=paragraph><p>要在設定檔設定使用 Radeon 驅動程式：</p></div><div id=x-config-video-cards-file-radeon class=exampleblock><div class=title>例 16. 在單檔中選擇 Radeon 影像驅動程式</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-radeon.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;radeon&#34;
EndSection</pre></div></div></div></div><div class=paragraph><p>要在設定檔設定使用 VESA 驅動程式：</p></div><div id=x-config-video-cards-file-vesa class=exampleblock><div class=title>例 17. 在單檔中選擇 VESA 影像驅動程式</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-vesa.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;vesa&#34;
EndSection</pre></div></div></div></div><div class=paragraph><p>要設定 UEFI 或 ARM™ 電腦使用 <code>scfb</code> 驅動程式：</p></div><div id=x-config-video-cards-file-scfb class=exampleblock><div class=title>例 18. 在單檔中選擇 <code>scfb</code> 影像驅動程式</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-scfb.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;scfb&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect3><h4 id=x-config-monitors>5.4.6. 顯示器<a class=anchor href=#x-config-monitors></a></h4><div class=paragraph><p>幾乎所有顯示器都支援延伸顯示辨識資料標準 (Extended Display Identification Data, EDID)，Xorg 會使用 EDID 與顯示器通訊並偵測支援的解析度與更新頻率，然後選擇最適合的設定組合使用該顯示器。</p></div><div class=paragraph><p>其他顯示器支援的解析度可透過在設定檔中設定想要的解析度來選擇，或者在 X 伺服器啟動之後使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a>。</p></div><div id=x-config-monitors-xrandr class=dlist><dl><dt class=hdlist1>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a></dt><dd><p>執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> 不加任何參數可檢查影像輸出及已偵測到的顯示器模式清單：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr
Screen 0: minimum 320 x 200, current 3000 x 1920, maximum 8192 x 8192
DVI-0 connected primary 1920x1200+1080+0 <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span> 495mm x 310mm
   1920x1200     59.95<span class=k>*</span>+
   1600x1200     60.00
   1280x1024     85.02    75.02    60.02
   1280x960      60.00
   1152x864      75.00
   1024x768      85.00    75.08    70.07    60.00
   832x624       74.55
   800x600       75.00    60.32
   640x480       75.00    60.00
   720x400       70.08
DisplayPort-0 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
HDMI-0 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span></code></pre></div></div><div class=paragraph><p>這個結果顯示 <code>DVI-0</code> 輸出被用來顯示解析度為 1920x1200 像素於更新頻率約 60 Hz 的畫面，未有顯示器連接到 <code>DisplayPort-0</code> 與 <code>HDMI-0</code> 接頭。</p></div><div class=paragraph><p>可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> 來選擇任何其他的顯示模式。例如要切換為 1280x1024 於 60 Hz：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr <span class=nt>--mode</span> 1280x1024 <span class=nt>--rate</span> 60</code></pre></div></div><div class=paragraph><p>在筆記型電腦使用外部顯示輸出到投影機是常見的作業。</p></div><div class=paragraph><p>不同裝置間輸出接頭的類型與數量也不同，給每個輸出的名稱在不同驅動程式間也不同。在某些驅動程式稱為 <code>HDMI-1</code> 的輸出在其他驅動程式則可能稱為 <code>HDMI1</code>。因此第一個步驟是執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> 列出所有可用的輸出：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr
Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192
LVDS1 connected 1366x768+0+0 <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span> 344mm x 193mm
   1366x768      60.04<span class=k>*</span>+
   1024x768      60.00
   800x600       60.32    56.25
   640x480       59.94
VGA1 connected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
   1280x1024     60.02 +  75.02
   1280x960      60.00
   1152x864      75.00
   1024x768      75.08    70.07    60.00
   832x624       74.55
   800x600       72.19    75.00    60.32    56.25
   640x480       75.00    72.81    66.67    60.00
   720x400       70.08
HDMI1 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
DP1 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span></code></pre></div></div><div class=paragraph><p>已找到四個輸出：內建面板的 <code>LVDS1</code>，外接的 <code>VGA1</code>, <code>HDMI1</code> 以及 <code>DP1</code> 接頭。</p></div><div class=paragraph><p>投影機已連接至 <code>VGA1</code> 輸出，現在使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> 來設定該輸出到投影機 (原始解析度) 並加入額外的空間到桌面的右側：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr <span class=nt>--output</span> VGA1 <span class=nt>--auto</span> <span class=nt>--right-of</span> LVDS1</code></pre></div></div><div class=paragraph><p><code>--auto</code> 會選擇使用 EDID 偵測到的解析度與更新頻率。若未正確偵測解析度，可替換 <code>--auto</code> 為 <code>--mode</code> 然後給予固定值。例如大部份的投影機可使用 1024x768 解析度為，則可設定 <code>--mode 1024x768</code>。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> 通常會在 <span class=filename>.xinitrc</span> 執行以在 X 啟動時設定適合的模式。</p></div></dd></dl></div><div id=x-config-monitors-files class=dlist><dl><dt class=hdlist1>在檔案中設定螢幕解析度</dt><dd><p>在設定檔設定螢幕解析度為 1024x768：</p><div class=exampleblock><div class=title>例 19. 在單檔中設定螢幕解析度</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/screen-resolution.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
	Identifier &#34;Screen0&#34;
	Device     &#34;Card0&#34;
	SubSection &#34;Display&#34;
	Modes      &#34;1024x768&#34;
	EndSubSection
EndSection</pre></div></div></div></div><div class=paragraph><p>少數顯示器沒有 EDID，可設定 <code>HorizSync</code> 及 <code>VertRefresh</code> 為顯示器支援的頻率範圍。</p></div><div class=exampleblock><div class=title>例 20. 手動設定顯示器頻率</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/monitor0-freq.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
	Identifier   &#34;Monitor0&#34;
	HorizSync    30-83   # kHz
	VertRefresh  50-76   # Hz
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect3><h4 id=x-config-input>5.4.7. 輸入裝置<a class=anchor href=#x-config-input></a></h4><div class=sect4><h5 id=x-config-input-keyboard>5.4.7.1. 鍵盤<a class=anchor href=#x-config-input-keyboard></a></h5><div id=x-config-input-keyboard-layout class=dlist><dl><dt class=hdlist1>鍵盤配置</dt><dd><p>鍵盤上標準按鍵的位置稱做 <em>配置 (Layout)</em>。配置與其他可調整的參數列於 <a href="https://man.freebsd.org/cgi/man.cgi?query=xkeyboard-config&amp;sektion=7&amp;format=html">xkeyboard-config(7)</a>。</p><div class=paragraph><p>預設為 United States 配置，要選擇其他的配置可在 <code>InputClass</code> 設定 <code>XkbLayout</code> 與 <code>XkbVariant</code> 選項。這會套用所有符合該類別的輸入裝置。</p></div><div class=paragraph><p>這個例子選擇 French 鍵盤配置使用 <code>oss</code> 變體。</p></div><div class=exampleblock><div class=title>例 21. 設定鍵盤配置</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/keyboard-fr-oss.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;KeyboardDefaults&#34;
	Driver		&#34;keyboard&#34;
	MatchIsKeyboard	&#34;on&#34;
	Option		&#34;XkbLayout&#34; &#34;fr&#34;
	Option		&#34;XkbVariant&#34; &#34;oss&#34;
EndSection</pre></div></div></div></div><div class=exampleblock><div class=title>例 22. 設定多個鍵盤配置</div><div class=content><div class=paragraph><p>設定 United States, Spanish 與 Ukrainian 鍵盤配置，並可按 <span class=keyseq><kbd>Alt</kbd>+<kbd>Shift</kbd></span> 來切換這些配置。可使用 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xxkb/>x11/xxkb</a> 或 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/sbxkb/>x11/sbxkb</a> 來加強配置切換控制與目前配置的指示。</p></div><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/kbd-layout-multi.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;All Keyboards&#34;
	MatchIsKeyboard	&#34;yes&#34;
	Option		&#34;XkbLayout&#34; &#34;us, es, ua&#34;
EndSection</pre></div></div></div></div></dd><dt class=hdlist1>從鍵盤關閉 Xorg</dt><dd><p>X 可以使用組合鍵來關閉，預設並未設定組合鍵，因為該組合鍵與部份應用程式的鍵盤指令衝突。要開啟這個選項需要更改鍵盤 <code>InputDevice</code> 節：</p><div class=exampleblock><div class=title>例 23. 開啟鍵盤離開 X 功能</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/keyboard-zap.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;KeyboardDefaults&#34;
	Driver		&#34;keyboard&#34;
	MatchIsKeyboard	&#34;on&#34;
	Option		&#34;XkbOptions&#34; &#34;terminate:ctrl_alt_bksp&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect4><h5 id=x11-input-mice>5.4.7.2. 滑鼠與指標裝置<a class=anchor href=#x11-input-mice></a></h5><div class=paragraph><p>有許多滑鼠參數可使用設定選項來調整，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=mousedrv&amp;sektion=4&amp;format=html">mousedrv(4)</a> 來取得完整清單。</p></div><div id=x11-input-mice-buttons class=dlist><dl><dt class=hdlist1>滑鼠按鍵</dt><dd><p>滑鼠的按鍵數可在 <span class=filename>xorg.conf</span> 的滑鼠 <code>InputDevice</code> 節設定，例如要設定按鍵數為 7：</p><div class=exampleblock><div class=title>例 24. 設定滑鼠按鍵數</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/mouse0-buttons.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
	Identifier  &#34;Mouse0&#34;
	Option      &#34;Buttons&#34; &#34;7&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div></div><div class=sect3><h4 id=x-config-manual-configuration>5.4.8. 手動設定<a class=anchor href=#x-config-manual-configuration></a></h4><div class=paragraph><p>在某些情況 Xorg 的自動設定無法在特定硬體上運作，或需要使用不同的設定。針對這些情況會建立自訂的設定檔。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>非必要請勿手動建立設定檔，非必要的手動設置會造成運作不正常。</p></div></td></tr></tbody></table></div><div class=paragraph><p>設定檔可由 Xorg 根據偵測到的硬體產生，這個檔案對一開始自訂設定很有幫助。</p></div><div class=paragraph><p>產生 <span class=filename>xorg.conf</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -configure</span></code></pre></div></div><div class=paragraph><p>設定檔會儲存至 <span class=filename>/root/xorg.conf.new</span>，做任何需要的更改，然後使用以下指令測試該檔案：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -config /root/xorg.conf.new</span></code></pre></div></div><div class=paragraph><p>在新設定檔調整與測試過後，便可分開成較小的檔案放置到正常的位置 <span class=filename>/usr/local/etc/X11/xorg.conf.d/</span>。</p></div></div></div><div class=sect2><h3 id=x-fonts>5.5. 在 Xorg 使用字型<a class=anchor href=#x-fonts></a></h3><div class=sect3><h4 id=type1>5.5.1. Type1 字型<a class=anchor href=#type1></a></h4><div class=paragraph><p>由於 Xorg 內建的預設字型用在典型的桌面出版應用程式並不是很理想，大字型會呈現鋸齒狀邊緣，看起來很不專業，小字型幾乎完全看不清楚。不過，這裡有幾個免費高品質的 Type1 (PostScript™) 字型可用，且能容易的在 Xorg 使用。例如，URW 字型集 (Times Roman™, Helvetica™, Palatino™ 及其他)。 Freefont 字型集 (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/freefonts/>x11-fonts/freefonts</a>) 包含了更多的字型，但其中大部分是給圖形軟體如 GIMP 所使用的字型，並不能完全作為螢幕字型使用。此外，Xorg 可以簡單的設定使用 TrueType™ 字型。更多有關本主題的詳細資訊，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=X&amp;sektion=7&amp;format=html">X(7)</a> 操作手冊或 <a href=#truetype>TrueType™ 字型</a>。</p></div><div class=paragraph><p>要由 Binary 套件安裝上述的 Type1 字型集可執行以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install urwfonts</span></code></pre></div></div><div class=paragraph><p>或由 Port 套件集編譯，可執行以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-fonts/urwfonts</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>同樣的安裝方式也適用 Freefont 或其他字型集。要讓 X 伺服器偵測到這些新安裝的字型，可加入適當的設定到 X 伺服器設定檔 (<span class=filename>/etc/X11/xorg.conf</span>)，內容為：</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath &#34;/usr/local/shared/fonts/urwfonts/&#34;</pre></div></div><div class=paragraph><p>或者在 X session 的指令列執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/shared/fonts/urwfonts
% xset fp rehash</code></pre></div></div><div class=paragraph><p>這樣便可，但在 X session 關閉時將會失效，除非將該設定加入啟動檔 (一般的 <code>startx</code> session 可在 <span class=filename>~/.xinitrc</span> 設定，若透過圖型化登入管理程式如 XDM 登入時則在 <span class=filename>~/.xsession</span> 設定)。第三種方式是使用新 <span class=filename>/usr/local/etc/fonts/local.conf</span>，如 <a href=#antialias>反鋸齒字型</a> 的示範。</p></div></div><div class=sect3><h4 id=truetype>5.5.2. TrueType™ 字型<a class=anchor href=#truetype></a></h4><div class=paragraph><p>Xorg 內建支援繪製 TrueType™ 字型，目前有兩個模組可以支援這項功能。在本例中使用 freetype 模組，由於此模組與其他字型繪製後端較為一致。要開啟 freetype 模組只需要將下行加入到 <span class=filename>/etc/X11/xorg.conf</span> 中的 <code>"Module"</code> section。</p></div><div class="literalblock programlisting"><div class=content><pre>Load  &#34;freetype&#34;</pre></div></div><div class=paragraph><p>現在要建立一個儲存 TrueType™ 字型的目錄 (例如，<span class=filename>/usr/local/shared/fonts/TrueType</span>) 然後複製所有 TrueType™ 字型到這個目錄。要注意 TrueType™ 字型並無法直接取自 Apple™Mac™，Xorg 使用的字型必須為 UNIX™/MS-DOS™/Windows™ 的格式。檔案複製到讓目錄之後，使用 mkfontscale 來建立 <span class=filename>fonts.dir</span> 來讓 X 字型繪製程式知道安裝了新的檔案。<code>mkfontscale</code> 可用套件的方式安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mkfontscale</span></code></pre></div></div><div class=paragraph><p>然後在目錄中建立 X 字型檔的索引：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/shared/fonts/TrueType</span>
<span class=c># mkfontscale</span></code></pre></div></div><div class=paragraph><p>接著加入 TrueType™ 目錄到字型路徑。這個動作與 <a href=#type1>Type1 字型</a> 中所介紹的方式相同：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/shared/fonts/TrueType
% xset fp rehash</code></pre></div></div><div class=paragraph><p>或直接加入 <code>FontPath</code> 一行到 <span class=filename>xorg.conf</span>。</p></div><div class=paragraph><p>現在 Gimp, Apache OpenOffice 以及其他 X 應用程式應可以辨識到已安裝的 TrueType™ 字型。極小的字型 (以高解析度在網頁中顯示的文字) 與極大的字型 (在 StarOffice™ 中) 現在會看起來比較像樣了。</p></div></div><div class=sect3><h4 id=antialias>5.5.3. 反鋸齒字型<a class=anchor href=#antialias></a></h4><div class=paragraph><p>所有可在 <span class=filename>/usr/local/shared/fonts/</span> 及 <span class=filename>~/.fonts/</span> 找到的 Xorg 字型均可在 Xft-aware 的應用程式使用反鋸齒的效果。大多最近的應用程式均為 Xft-aware 的，包括 KDE, GNOME 以及 Firefox。</p></div><div class=paragraph><p>要控制那一些字型要做反鋸齒或設定反鋸齒的屬性，需建立 <span class=filename>/usr/local/etc/fonts/local.conf</span> 檔案 (若檔案存在則編輯)。在這個檔案中可以調整 Xft 字型系統的數項進階功能，本章節僅介紹部份簡單的項目，要取得進一步資訊，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=fonts-conf&amp;sektion=5&amp;format=html">fonts-conf(5)</a>。</p></div><div class=paragraph><p>這個檔案必須使用 XML 格式，小心文字大小寫，且要確定所有標籤均有正常結尾。檔案的開頭使用常見的 XML 檔首，接著為 DOCTYPE 定義，然後是 <code>&lt;fontconfig></code> 標籤：</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34;?&gt;
      &lt;!DOCTYPE fontconfig SYSTEM &#34;fonts.dtd&#34;&gt;
      &lt;fontconfig&gt;</pre></div></div><div class=paragraph><p>如同前面所提到的，所有在 <span class=filename>/usr/local/shared/fonts/</span> 與 <span class=filename>~/.fonts/</span> 的字型均可在 Xft-aware 的應用程式做反鋸齒效果，若您想要加入除了上兩者以外的目錄，可加入如下行設定到 <span class=filename>/usr/local/etc/fonts/local.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;dir&gt;/path/to/my/fonts&lt;/dir&gt;</pre></div></div><div class=paragraph><p>加入新字型及額外的新字型目錄之後，需重新建立字型快取：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fc-cache -f</span></code></pre></div></div><div class=paragraph><p>反鋸齒效果會讓文字的邊緣變模糊，這會讓非常小的文字更能閱讀且去除大型文字的 "鋸齒"，但套用在一般的文字可能會造成眼睛的疲勞。要排除小於 14 點的字型大小使用反鋸齒效果，可加入這些行：</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;match target=&#34;font&#34;&gt;
	    &lt;test name=&#34;size&#34; compare=&#34;less&#34;&gt;
		&lt;double&gt;14&lt;/double&gt;
	    &lt;/test&gt;
	    &lt;edit name=&#34;antialias&#34; mode=&#34;assign&#34;&gt;
		&lt;bool&gt;false&lt;/bool&gt;
	    &lt;/edit&gt;
	&lt;/match&gt;
	&lt;match target=&#34;font&#34;&gt;
	    &lt;test name=&#34;pixelsize&#34; compare=&#34;less&#34; qual=&#34;any&#34;&gt;
		&lt;double&gt;14&lt;/double&gt;
	    &lt;/test&gt;
	    &lt;edit mode=&#34;assign&#34; name=&#34;antialias&#34;&gt;
		&lt;bool&gt;false&lt;/bool&gt;
	    &lt;/edit&gt;
	&lt;/match&gt;</pre></div></div><div class=paragraph><p>反鋸齒所產生的間距對於部份等寬字型並不合適，尤其是在使用 KDE 時會成為一個問題。可能的修正方式是強制這類字型的間距為 100，可加入以下行：</p></div><div class="literalblock programlisting"><div class=content><pre>	&lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	   &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
	       &lt;string&gt;fixed&lt;/string&gt;
	   &lt;/test&gt;
	   &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
	       &lt;string&gt;mono&lt;/string&gt;
	   &lt;/edit&gt;
	&lt;/match&gt;
	&lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	    &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
		&lt;string&gt;console&lt;/string&gt;
	    &lt;/test&gt;
	    &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
		&lt;string&gt;mono&lt;/string&gt;
	    &lt;/edit&gt;
	&lt;/match&gt;</pre></div></div><div class=paragraph><p>(這會設定等寬字型的其他常用名稱為 <code>"mono"</code>)，然後加入：</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	     &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
		 &lt;string&gt;mono&lt;/string&gt;
	     &lt;/test&gt;
	     &lt;edit name=&#34;spacing&#34; mode=&#34;assign&#34;&gt;
		 &lt;int&gt;100&lt;/int&gt;
	     &lt;/edit&gt;
	 &lt;/match&gt;</pre></div></div><div class=paragraph><p>部份字型，如 Helvetica，在使用反鋸齒時可能會發生問題，通常會呈現像垂直切成兩半的字型，最差還可能會導致應用程式當掉。要避免這個問題，可考慮加入以下設定到 <span class=filename>local.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	     &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
		 &lt;string&gt;Helvetica&lt;/string&gt;
	     &lt;/test&gt;
	     &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
		 &lt;string&gt;sans-serif&lt;/string&gt;
	     &lt;/edit&gt;
	 &lt;/match&gt;</pre></div></div><div class=paragraph><p>編輯 <span class=filename>local.conf</span> 完之後，請確認有使用 <code>&lt;/fontconfig></code> 標籤結尾，若沒有使用會讓所做的更改被忽略。</p></div><div class=paragraph><p>使用者可透過建立自己的 <span class=filename>~/.config/fontconfig/fonts.conf</span> 來加入個人化的設定，此檔案使用與上述說明相同的 XML 格式。</p></div><div class=paragraph><p>最後一點：若有使用 LCD 螢幕，可能會想要使用子像素取樣 (Sub-pixel sampling)，這基本上會分開處理 (水平分隔) 紅、綠、藍色彩組成來提高垂直解析度，結果可能是無法預料的。要開啟這個功能，加入下行到 <span class=filename>local.conf</span> 的任一處：</p></div><div class="literalblock programlisting"><div class=content><pre>	 &lt;match target=&#34;font&#34;&gt;
	     &lt;test qual=&#34;all&#34; name=&#34;rgba&#34;&gt;
		 &lt;const&gt;unknown&lt;/const&gt;
	     &lt;/test&gt;
	     &lt;edit name=&#34;rgba&#34; mode=&#34;assign&#34;&gt;
		 &lt;const&gt;rgb&lt;/const&gt;
	     &lt;/edit&gt;
	 &lt;/match&gt;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>依據不同的顯示器類型可能會需要將 <code>rgb</code> 更改為 <code>bgr</code>, <code>vrgb</code> 或 <code>vbgr</code>：可實驗看看然後看那一個效果最好。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x-xdm>5.6. X 顯示管理程式<a class=anchor href=#x-xdm></a></h3><div class=paragraph><p>Xorg 提供了 X 顯示管理程式 (X Display Manager, XDM)，可用來做登入階段的管理。XDM 提供了一個圖型化的介面來選擇要連結的顯示伺服器以及輸入認証資訊 (登入與密碼)。</p></div><div class=paragraph><p>本節將示範如何設定 FreeBSD 的 X 顯示管理程式。部份桌面環境會提供自己的圖型化登入管理程式，請參考 <a href=#x11-wm-gnome>GNOME</a> 取得如何設定 GNOME 顯示管理程式 (GNOME Display Manager) 的操作方式以及 <a href=#x11-wm-kde>KDE</a> 取得如何設定 KDE 顯示管理程式 (KDE Display Manager) 的操作方式。</p></div><div class=sect3><h4 id=_設定_xdm>5.6.1. 設定 XDM<a class=anchor href=#_設定_xdm></a></h4><div class=paragraph><p>要安裝 XDM 可使用 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xdm/>x11/xdm</a> 套件或 Port。安裝完成之後，可設定 XDM 在開機時執行，只需編輯 <span class=filename>/etc/ttys</span> 中的此項目：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ttyv8   <span class=s2>&#34;/usr/local/bin/xdm -nodaemon&#34;</span>  xterm   off secure</code></pre></div></div><div class=paragraph><p>更改關 (<code>off</code>) 為開 (<code>on</code>) 然後儲存編輯。在此項目中的 <code>ttyv8</code> 代表 XDM 會在第 9 個虛擬終端機執行。</p></div><div class=paragraph><p>XDM 的設定目錄位於 <span class=filename>/usr/local/etc/X11/xdm</span>。此目錄中包含數個可用來更改 XDM 行為與外觀的檔案以及在 XDM 執行時用來設定桌面的一些 Script 及程式，<a href=#xdm-config-files>XDM 設定檔</a> 摘要了每個檔案的功能。這些檔案正確的語法與用法在 <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> 有說明。</p></div><table id=xdm-config-files class="tableblock frame-none grid-all stretch"><caption class=title>表 6. XDM 設定檔</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">檔案</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xaccess</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>連線到 XDM 所需的通訊協定稱做 X 顯示管理程式連線通訊協定 (X Display Manager Connection Protocol, XDMCP)，此檔案為客戶端認証規則，用來控制來自遠端機器的 XDMCP 連線。預設此檔案並不允許任何遠端的客戶端連線。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xresources</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>此檔案控制 XDM 顯示選擇器及登入畫面的外觀。預設的設定簡單的矩形登入視窗，上方用較大的字型顯示機器的主機名稱，並在下方顯示 "Login:" 與 "Password:" 提示。此檔案的格式與 Xorg 說明文件中說明的 app-defaults 檔相同。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xservers</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>登入選擇時在選擇器上要提供的本地及遠端顯示清單。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsession</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>預設的登入階段 Script，使用者登入之後由 XDM 執行。這會指向使用者自訂的登入階段 Script 於 <span class=filename>~/.xsession</span>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsetup_</span>*</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>用來在顯示選擇器與登入介面之前自動執行應用程式的 Script。每一個顯示各有一個 Script，名稱為 <span class=filename>Xsetup_*</span>，其中 <code>*</code> 為本地顯示編號。正常情況這些 Script 會在背景執行一兩個程式，例如 <code>xconsole</code>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-config</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>用來設定所有在此機器上執行的顯示的全域設定檔。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-errors</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>內含由伺服器程式產生的錯誤訊息，若 XDM 嘗試啟動的顯示沒有回應，可查看此檔案來取得錯誤訊息。以登入階段為基礎，這些訊息也同樣會寫入至使用者的 <span class=filename>~/.xsession-errors</span>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-pid</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>XDM 的執行程序 ID。</p></td></tr></tbody></table></div><div class=sect3><h4 id=_設定遠端存取>5.6.2. 設定遠端存取<a class=anchor href=#_設定遠端存取></a></h4><div class=paragraph><p>預設只有同系統的使用者可以使用 XDM 登入。要開啟讓其他系統的使用者可連線到顯示伺服器，需編輯存取控制規則及開啟連線傾聽程式。</p></div><div class=paragraph><p>要設定 XDM 傾聽任何遠端的連線，在 <span class=filename>/usr/local/etc/X11/xdm/xdm-config</span> 中的 <code>DisplayManager.requestPort</code> 行前加上 <code>!</code> 來註解該行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>!</span> SECURITY: <span class=k>do </span>not listen <span class=k>for </span>XDMCP or Chooser requests
<span class=o>!</span> Comment out this line <span class=k>if </span>you want to manage X terminals with xdm
DisplayManager.requestPort:     0</code></pre></div></div><div class=paragraph><p>儲存編輯並重新啟動 XDM，要限制遠端存取，請看 <span class=filename>/usr/local/etc/X11/xdm/Xaccess</span> 中的範例項目，並參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> 取得進一步資訊。</p></div></div></div><div class=sect2><h3 id=x11-wm>5.7. 桌面環境<a class=anchor href=#x11-wm></a></h3><div class=paragraph><p>本節將介紹如何在 FreeBSD 系統安裝三種熱門的桌面環境。一套桌面環境的範圍可從簡單的視窗管理程式到完整的桌面應用程式集。有上百套的桌面環境可在 Port 套件集的 <span class=filename>x11-wm</span> 分類取得。</p></div><div class=sect3><h4 id=x11-wm-gnome>5.7.1. GNOME<a class=anchor href=#x11-wm-gnome></a></h4><div class=paragraph><p>GNOME 是一個擁有友善使用者介面的的桌面環境，它包括用於啟動應用程式和顯示狀態的面板、一系列工具與應用程序及一套可讓應用程式更容易進行合作、相互一致的協定。更多有關 FreeBSD GNOME 的訊息可在 <a href=https://www.FreeBSD.org/gnome>https://www.FreeBSD.org/gnome</a> 取得，該網站包含了有關在 FreeBSD 安裝、設定和管理 GNOME 的額外文件。</p></div><div class=paragraph><p>這套桌面環境可以從套件安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnome3</span></code></pre></div></div><div class=paragraph><p>也可使用以下指令從 Port 編譯 GNOME，GNOME 是一套大型的應用程式，即使在速度較快的電腦上，也會需要花費一些時間編譯。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/gnome3</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>GNOME 需要掛載 <span class=filename>/proc</span>。加入下行到 <span class=filename>/etc/fstab</span> 讓系統啟動時會自動掛載這個檔案系統：</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>GNOME 使用了 D-Bus 以及 HAL 的 Message bus 與 Hardware abstraction。這兩個應用程式會隨著 GNOME 的相依一併自動安裝，但需要在 <span class=filename>/etc/rc.conf</span> 開啟，這樣在系統開機時才會啟動：</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;
hald_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>安裝完之後，需設定讓 Xorg 啟動 GNOME。最簡單的方法是開啟 GNOME Display Manager, GDM，該程式已做為 GNOME 套件或 Port 的一部份安裝了，可加入下行到 <span class=filename>/etc/rc.conf</span> 來開啟：</p></div><div class="literalblock programlisting"><div class=content><pre>gdm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>通常也會需要啟動所有的 GNOME 服務，可加入下行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>gnome_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>GDM 則會在系統開機時自動啟動。</p></div><div class=paragraph><p>第二種啟動 GNOME 的方法是在設定完 <span class=filename>~/.xinitrc</span> 後在指令列輸入 <code>startx</code>。若這個檔案已經存在，替換啟動目前視窗管理程式的那一行，改為啟動 <span class=filename>/usr/local/bin/gnome-session</span>。若檔案不存在，則使用以下指令建立一個：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>第三種方法是使用 XDM 做為顯示管理程式，在這個方法需要建立一個可執行的 <span class=filename>~/.xsession</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div></div><div class=sect3><h4 id=x11-wm-kde>5.7.2. KDE<a class=anchor href=#x11-wm-kde></a></h4><div class=paragraph><p>KDE 是另一套易於使用的桌面環境。這個桌面環境提供了一致外觀的應用程式、標準化的選單和工具列、組合鍵、配色方案、國際化與集中、對話框導向的桌面設定。更多有關 KDE 可在 <a href=http://www.kde.org/>http://www.kde.org/</a> 取得。要取得 FreeBSD 特定的資訊，則可參考 <a href=http://freebsd.kde.org/>http://freebsd.kde.org</a>。</p></div><div class=paragraph><p>要安裝 KDE 套件，請輸入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/kde5</span></code></pre></div></div><div class=paragraph><p>或者要使用 KDE Port 編譯，可使用以下指令，採用 Port 方式安裝會有選單可以選擇要安裝的元件。KDE 是一個大型的應用程式，即使在較快的電腦上仍需要花費一段時間來編譯。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/kde5</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>KDE 需要掛載 <span class=filename>/proc</span>。加入下行到 <span class=filename>/etc/fstab</span> 讓系統啟動時會自動掛載這個檔案系統：</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>KDE 使用了 D-Bus 以及 HAL 的 Message bus 與 Hardware abstraction。這兩個應用程式會隨著 KDE 的相依一併自動安裝，但需要在 <span class=filename>/etc/rc.conf</span> 開啟，這樣在系統開機時才會啟動：</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;
hald_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>自 KDE Plasma 5 開始，KDE Display Manager, KDM 便停止開發，可能的替代方案為 SDDM，要安裝該套件可輸入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/sddm</span></code></pre></div></div><div class=paragraph><p>加入下行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>sddm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>第二種執行 KDE 的方法是在在指令列輸入 <code>startx</code>。要採用這個方式，需要加入下行到 <span class=filename>~/.xinitrc</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>exec ck-launch-session startkde</pre></div></div><div class=paragraph><p>第三種啟動 KDE 的方式是透過 XDM，要使用這個方法需要建立一個可執行的 <span class=filename>~/.xsession</span> 如下：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec ck-launch-session startkde&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div><div class=paragraph><p>啟動 KDE 之後，請參考內建的說明系統來取得更多有關如何使用各種選單及應用程式的資訊。</p></div></div><div class=sect3><h4 id=x11-wm-xfce>5.7.3. Xfce<a class=anchor href=#x11-wm-xfce></a></h4><div class=paragraph><p>Xfce 是以 GNOME 使用的 GTK +工具包做為基礎所開發的桌面環境，但是它更輕巧且提供了一種簡單、高效、易於使用的桌面。它可完全自訂設定、附有選單、Applet 及應用程式啟動器的主面板、提供檔案管理程式和音效管理程式並且可設定主題。由於它是快速、輕巧、高效的桌面環境，因此它非常適合有記憶體限制的較舊或較慢機器。更多有關 Xfce 的資訊可至 <a href=http://www.xfce.org/>http://www.xfce.org</a> 取得。</p></div><div class=paragraph><p>要安裝 Xfce 套件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xfce</span></code></pre></div></div><div class=paragraph><p>或者使用 Port 編譯：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-wm/xfce4</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Xfce 使用了 D-Bus 作為 Message bus，由於是 Xfce 的相依，因此會自動安裝，但仍要在 <span class=filename>/etc/rc.conf</span> 中開啟該程式才會在系統開機時啟動：</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>不像 GNOME 或 KDE，Xfce 並沒有自己的登入管理程式，要能用 <code>startx</code> 指令列啟動 Xfce 之前需先加入其項目到 <span class=filename>~/.xinitrc</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;. /usr/local/etc/xdg/xfce4/xinitrc&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>另一種方式是使用 XDM，要設定這個方式需建立一個可執行的 <span class=filename>~/.xsession</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;. /usr/local/etc/xdg/xfce4/xinitrc&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div></div></div><div class=sect2><h3 id=x-compiz-fusion>5.8. 安裝 Compiz Fusion<a class=anchor href=#x-compiz-fusion></a></h3><div class=paragraph><p>要令使用桌面電腦更令人愉快的方法是用炫麗的 3D 效果。</p></div><div class=paragraph><p>安裝 Compiz Fusion 套件非常簡單，但設定該套件需要一些未在 Port 說明文件中說明的步驟。</p></div><div class=sect3><h4 id=x-compiz-video-card>5.8.1. 設定 FreeBSD nVidia 驅動程式<a class=anchor href=#x-compiz-video-card></a></h4><div class=paragraph><p>桌面特效需要使用相當程度的顯示卡，對於以 nVidia 為基礎的顯示卡，需要使用專用的驅動程序來取得較佳的性能。其他顯示卡的使用可以跳過這一節，並繼續 <span class=filename>xorg.conf</span> 設定。</p></div><div class=paragraph><p>要知道需要那一種 nVidia 驅動程式可以查看 <a href=https://docs.freebsd.org/en/books/faq/#idp59950544>FAQ 中與此主題相關的問題</a>。</p></div><div class=paragraph><p>知道您的顯示卡要使用那種驅動程式才是正確的之後，接下來的安裝程序跟安裝其他套件一樣簡單。</p></div><div class=paragraph><p>例如，要安裝最新的驅動程式：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/nvidia-driver</span></code></pre></div></div><div class=paragraph><p>驅動程式會建立一個需要在系統啟動時載入的核心模組，加入下行到 <span class=filename>/boot/loader.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>nvidia_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>要立即載入核心模組到執行中的核心可以下 <code>kldload nvidia</code> 指令，但是需要注意，若不是在開機時載入，某些 Xorg 版本會無法正常運作。因此編輯完 <span class=filename>/boot/loader.conf</span> 之後建議要重新開機。</p></div></td></tr></tbody></table></div><div class=paragraph><p>核心模組載入之後，您只需要更改 <span class=filename>xorg.conf</span> 的其中一行來開啟專用的驅動程式：</p></div><div class=paragraph><p>找到 <span class=filename>/etc/X11/xorg.conf</span> 中的下行：</p></div><div class="literalblock programlisting"><div class=content><pre>Driver      &#34;nv&#34;</pre></div></div><div class=paragraph><p>然後更改該行為：</p></div><div class="literalblock programlisting"><div class=content><pre>Driver      &#34;nvidia&#34;</pre></div></div><div class=paragraph><p>如往常般啟動 GUI，您應該會看到 nVidia 的啟動畫面，其他東西應如往常般運作。</p></div></div><div class=sect3><h4 id=xorg-configuration>5.8.2. 設定 xorg.conf 來啟動桌面特效<a class=anchor href=#xorg-configuration></a></h4><div class=paragraph><p>要開啟 Compiz Fusion 需要修改 <span class=filename>/etc/X11/xorg.conf</span>：</p></div><div class=paragraph><p>加入以下 Section 來開啟合成特效：</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Extensions&#34;
    Option         &#34;Composite&#34; &#34;Enable&#34;
EndSection</pre></div></div><div class=paragraph><p>找到 "Screen" section，長的應該如下所示：</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
    Identifier     &#34;Screen0&#34;
    Device         &#34;Card0&#34;
    Monitor        &#34;Monitor0&#34;
    ...</pre></div></div><div class=paragraph><p>然後加入以下兩行 (在"Monitor" 之後)：</p></div><div class="literalblock programlisting"><div class=content><pre>DefaultDepth    24
Option         &#34;AddARGBGLXVisuals&#34; &#34;True&#34;</pre></div></div><div class=paragraph><p>找到您欲使用的螢幕解析度所在的 "Subsection"，例如，您想要使用 1280x1024，則找到如下所示的 Section。若想要使用的解析度不在任何 Subsection 之中，您可以手動加入對應的項目：</p></div><div class="literalblock programlisting"><div class=content><pre>SubSection     &#34;Display&#34;
    Viewport    0 0
    Modes      &#34;1280x1024&#34;
EndSubSection</pre></div></div><div class=paragraph><p>桌面合成需要 24 bit 的色彩深度，更改上述 Subsection 為：</p></div><div class="literalblock programlisting"><div class=content><pre>SubSection     &#34;Display&#34;
    Viewport    0 0
    Depth       24
    Modes      &#34;1280x1024&#34;
EndSubSection</pre></div></div><div class=paragraph><p>最後確認在 "Module" section 中已經載入 "glx" 與 "extmod" 模組：</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Module&#34;
    Load           &#34;extmod&#34;
    Load           &#34;glx&#34;
    ...</pre></div></div><div class=paragraph><p>前面所述的動作可以執行 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-xconfig/>x11/nvidia-xconfig</a> 來自動完成 (使用 root)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nvidia-xconfig --add-argb-glx-visuals</span>
<span class=c># nvidia-xconfig --composite</span>
<span class=c># nvidia-xconfig --depth=24</span></code></pre></div></div></div><div class=sect3><h4 id=compiz-fusion>5.8.3. 安裝與設定 Compiz Fusion<a class=anchor href=#compiz-fusion></a></h4><div class=paragraph><p>安裝 Compiz Fusion 如同安裝其他套件一樣簡單：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11-wm/compiz-fusion</span></code></pre></div></div><div class=paragraph><p>安裝完成之後，開啟您的圖型化桌面，然後在終端機的畫面輸入以下指令 (使用一般使用者)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% compiz <span class=nt>--replace</span> <span class=nt>--sm-disable</span> <span class=nt>--ignore-desktop-hints</span> ccp &amp;
% emerald <span class=nt>--replace</span> &amp;</code></pre></div></div><div class=paragraph><p>由於您的視窗管理程式 (例如：Metacity，若您使用 GNOME) 會被替換成 Compiz Fusion，您的螢幕會閃爍幾秒。而 Emerald 會處理視窗的裝飾 (例如：關閉、最小化、最大化按鈕、標題列及其他相關)。</p></div><div class=paragraph><p>您或許可以將這些指令改寫成較小的 Script 然後在啟動時自動執行 (加到 GNOME 桌面的 "Sessions" 中)：</p></div><div class="literalblock programlisting"><div class=content><pre>#! /bin/sh
compiz --replace --sm-disable --ignore-desktop-hints ccp &amp;
emerald --replace &amp;</pre></div></div><div class=paragraph><p>儲存這個 Script 到您的家目錄所在位置，例如 <span class=filename>start-compiz</span>，然後讓該檔案可以執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod</span> +x ~/start-compiz</code></pre></div></div><div class=paragraph><p>接著使用 GUI 將該檔案加入啟動程式 <span class=guimenuitem>Startup Programs</span> (位於 GNOME 桌面的系統 <span class=guimenuitem>System</span>, 偏好設定 <span class=guimenuitem>Preferences</span>, 工作階段 <span class=guimenuitem>Sessions</span>)。</p></div><div class=paragraph><p>要選擇所想使用的特效與相關設定，可執行 (一樣使用一般使用者) Compiz Config 設定管理程式 Compiz Config Settings Manager：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ccsm</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>在 GNOME 中，也可在系統 <span class=guimenuitem>System</span>, 偏好設定 <span class=guimenuitem>Preferences</span> 選單中找到。</p></div></td></tr></tbody></table></div><div class=paragraph><p>若您在編譯時選擇了 "gconf support"，您便可使用 <code>gconf-editor</code> 在 <code>apps/compiz</code> 下查看設定。</p></div></div></div><div class=sect2><h3 id=x11-understanding>5.9. 疑難排解<a class=anchor href=#x11-understanding></a></h3><div class=paragraph><p>若滑鼠無法使用，您將需要做第一次設定方可繼續。在最近的 Xorg 版本，使用自動偵測裝置會忽略在 <span class=filename>xorg.conf</span> 中的 <code>InputDevice</code> section。要採用舊的方式，需在此檔案加入下行到 <code>ServerLayout</code> 或 <code>ServerFlags</code> section：</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;AutoAddDevices&#34; &#34;false&#34;</pre></div></div><div class=paragraph><p>輸入裝置便可如先前版本一樣設定，連同其他所需的選項 (如：切換鍵盤配置)。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>如同前面有說明過，hald Daemon 預設會自動偵測您的鍵盤，因此您的鍵盤配置或型號可能不正確，桌面環境如 GNOME, KDE 或 Xfce 會提供設定鍵盤的工具。即使如此，還是有可能透過 <a href="https://man.freebsd.org/cgi/man.cgi?query=setxkbmap&amp;sektion=1&amp;format=html">setxkbmap(1)</a> 工具或 hald 的設定規則的協助來直接設定鍵盤屬性。</p></div><div class=paragraph><p>舉例來說，若有人想要使用 PC 102 鍵的鍵盤，採用法語 (French) 配置，我們便需要建立一個給 hald 的鍵盤設定檔，名稱為 <span class=filename>x11-input.fdi</span>，然後儲存到 <span class=filename>/usr/local/etc/hal/fdi/policy</span> 目錄。這個檔案中應要有以下幾行：</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;deviceinfo version=&#34;0.2&#34;&gt;
  &lt;device&gt;
    &lt;match key=&#34;info.capabilities&#34; contains=&#34;input.keyboard&#34;&gt;
	  &lt;merge key=&#34;input.x11_options.XkbModel&#34; type=&#34;string&#34;&gt;pc102&lt;/merge&gt;
	  &lt;merge key=&#34;input.x11_options.XkbLayout&#34; type=&#34;string&#34;&gt;fr&lt;/merge&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;</pre></div></div><div class=paragraph><p>若這個檔案已經存在，只需要複製並貼上您的檔案中有關鍵盤設定的那幾行。</p></div><div class=paragraph><p>您會需要重新啟動您的機器來讓 hald 讀取這個檔案。</p></div><div class=paragraph><p>也是可以從 X 終端機或 Script 下指令來做同樣的設定：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setxkbmap <span class=nt>-model</span> pc102 <span class=nt>-layout</span> fr</code></pre></div></div><div class=paragraph><p><span class=filename>/usr/local/shared/X11/xkb/rules/base.lst</span> 中列出了各種可用的鍵盤、配置與設定。</p></div></td></tr></tbody></table></div><div class=paragraph><p>現在可以開始調整 <span class=filename>xorg.conf.new</span> 設定檔，在文字編輯器如 <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a> 開啟該設定檔。若顯示器是不支援自動偵測同步頻率 (Sync frequency) 的舊或特殊的型號，同步頻率的設定可以手動加到 <span class=filename>xorg.conf.new</span> 的 <code>"Monitor"</code> section：</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
	Identifier   &#34;Monitor0&#34;
	VendorName   &#34;Monitor Vendor&#34;
	ModelName    &#34;Monitor Model&#34;
	HorizSync    30-107
	VertRefresh  48-120
EndSection</pre></div></div><div class=paragraph><p>多數顯示器都支援自動偵測同步頻率，並不需要手動設定這些數值。對於那些不支援自動偵測的顯示器，請輸入由製造商提供的數值來避免損壞顯示器。</p></div><div class=paragraph><p>X 允許在支援的顯示器使用 DPMS (Energy Star) 功能，<a href="https://man.freebsd.org/cgi/man.cgi?query=xset&amp;sektion=1&amp;format=html">xset(1)</a> 程式可以控制逾時並可強制待機 (Standby)、暫停 (Suspend) 或關閉 (Off) 模式。若您想要為您的顯示器開啟 DPMS 功能，您需要加入下行到顯示器 (Monitor) 的 Section：</p></div><div class="literalblock programlisting"><div class=content><pre>Option       &#34;DPMS&#34;</pre></div></div><div class=paragraph><p>在編輯器還未關閉 <span class=filename>xorg.conf.new</span> 設定檔前，選擇想要使用的預設解析度及色彩深度。這些項目可在 <code>"Screen"</code> section 定義：</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
	Identifier &#34;Screen0&#34;
	Device     &#34;Card0&#34;
	Monitor    &#34;Monitor0&#34;
	DefaultDepth 24
	SubSection &#34;Display&#34;
		Viewport  0 0
		Depth     24
		Modes     &#34;1024x768&#34;
	EndSubSection
EndSection</pre></div></div><div class=paragraph><p><code>DefaultDepth</code> 關鍵字代表預設執行要使用的色彩深度，這個設定可以被 <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a> 的指令列參數 <code>-depth</code> 覆蓋。<code>Modes</code> 關鍵字代表執行要使用的解析度，注意，只有 VESA 標準模式才支援目標系統的繪圖硬體來定義解析度。在上述的例子中，預設使用的色彩深度為每像素 24 bit，這個色彩深度可用的解析度為 1024 x 768 像素。</p></div><div class=paragraph><p>最後，儲存設定檔並使用測試模式來測試上述的設定。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>有一個工具可以協助您診斷問題，那就是 Xorg 日誌檔。該日誌檔中記錄了 Xorg 連接的每個裝置的資訊。Xorg 記錄檔名稱的格式為 <span class=filename>/var/log/Xorg.0.log</span>，確切的記錄檔名會可能從 <span class=filename>Xorg.0.log</span> 到 <span class=filename>Xorg.8.log</span> 以此類推。</p></div></td></tr></tbody></table></div><div class=paragraph><p>若一且運作正常，設定檔需要安裝到 <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a> 會尋找的常用設定檔位置，通常是 <span class=filename>/etc/X11/xorg.conf</span> 或 <span class=filename>/usr/local/etc/X11/xorg.conf</span>。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp xorg.conf.new /etc/X11/xorg.conf</span></code></pre></div></div><div class=paragraph><p>現在已經完成了 Xorg 的設定程序。Xorg 現在可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a> 工具啟動。Xorg 伺服器也可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> 來啟動。</p></div><div class=sect3><h4 id=_設定_inteli810_繪圖晶片組>5.9.1. 設定 Intel™<code>i810</code> 繪圖晶片組<a class=anchor href=#_設定_inteli810_繪圖晶片組></a></h4><div class=paragraph><p>要設定 Intel™ i810 整合晶片組需要使用 <span class=filename>agpgart</span> AGP 程式介面來控制 Xorg 驅動該顯示卡。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> 驅動程式操作手冊來取得更多詳細資訊。</p></div><div class=paragraph><p>這也可讓您可以設定任何其他繪圖卡的硬體。注意，在未編譯 <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> 到核心的系統，並無法使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> 來載入該模組，因此驅動程式必須在開機時便在核心啟動，所以需要透過編譯或使用 <span class=filename>/boot/loader.conf</span> 來載入。</p></div></div><div class=sect3><h4 id=_加入寬螢幕平板顯示器到設定檔>5.9.2. 加入寬螢幕平板顯示器到設定檔<a class=anchor href=#_加入寬螢幕平板顯示器到設定檔></a></h4><div class=paragraph><p>此章節會需要有一些進階的設定知識，若嘗試使用上述的標準設定工具仍無法產生可運作的設定，在日誌檔中應有足夠的資訊可運用來讓顯示卡運作。在此會需要使用文字編輯器。</p></div><div class=paragraph><p>目前使用寬螢幕 (WSXGA, WSXGA+, WUXGA, WXGA, WXGA+, et.al.) 格式支援的 16:10 及 10:9 格式或其他的寬高比可會有問題。例如一些 16:10 寬高比常見的螢幕解析度：</p></div><div class=ulist><ul><li><p>2560x1600</p></li><li><p>1920x1200</p></li><li><p>1680x1050</p></li><li><p>1440x900</p></li><li><p>1280x800</p></li></ul></div><div class=paragraph><p>在某些時候，可以簡單的將這些要使用的解析度以 <code>Mode</code> 加入到 Section "Screen"：</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
Identifier &#34;Screen0&#34;
Device     &#34;Card0&#34;
Monitor    &#34;Monitor0&#34;
DefaultDepth 24
SubSection &#34;Display&#34;
	Viewport  0 0
	Depth     24
	Modes     &#34;1680x1050&#34;
EndSubSection
EndSection</pre></div></div><div class=paragraph><p>Xorg 能夠從寬螢幕設定取得解析度資訊 (透過 I2C/DDC)，因此能夠知道螢幕能處理的頻率及解析度。</p></div><div class=paragraph><p>若驅動程式中不存在那些螢幕能處理的 <code>ModeLines</code>，則需要給 Xorg 一點提示。透過 <span class=filename>/var/log/Xorg.0.log</span> 可以取得足夠的資訊來手動建立可運作的 <code>ModeLine</code>。只需要在日誌檔中找到類似以下的訊息：</p></div><div class="literalblock programlisting"><div class=content><pre>(II) MGA(0): Supported additional Video Mode:
(II) MGA(0): clock: 146.2 MHz   Image Size:  433 x 271 mm
(II) MGA(0): h_active: 1680  h_sync: 1784  h_sync_end 1960 h_blank_end 2240 h_border: 0
(II) MGA(0): v_active: 1050  v_sync: 1053  v_sync_end 1059 v_blanking: 1089 v_border: 0
(II) MGA(0): Ranges: V min: 48  V max: 85 Hz, H min: 30  H max: 94 kHz, PixClock max 170 MHz</pre></div></div><div class=paragraph><p>這些資訊稱作 EDID 資訊，使用 EDIT 資訊建立 <code>ModeLine</code> 只需要將數據使用正確的順序放入：</p></div><div class="literalblock programlisting"><div class=content><pre>ModeLine &lt;name&gt; &lt;clock&gt; &lt;4 horiz. timings&gt; &lt;4 vert. timings&gt;</pre></div></div><div class=paragraph><p>將資訊放入之後，本例中 <code>Section "Monitor"</code> 中的 <code>ModeLine</code> 會看起來像這樣：</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
Identifier      &#34;Monitor1&#34;
VendorName      &#34;Bigname&#34;
ModelName       &#34;BestModel&#34;
ModeLine        &#34;1680x1050&#34; 146.2 1680 1784 1960 2240 1050 1053 1059 1089
Option          &#34;DPMS&#34;
EndSection</pre></div></div><div class=paragraph><p>便完成編輯的步驟，接著需要在您的寬螢幕顯示器啟動 X。</p></div></div><div class=sect3><h4 id=compiz-troubleshooting>5.9.3. Compiz Fusion 疑難排解<a class=anchor href=#compiz-troubleshooting></a></h4><div class=sect4><h5 id=_我已經安裝了_compizfusion但在執行了您所提到的指令後我的視窗的標題列與按鈕便消失了是那裡有問題>5.9.3.1. 我已經安裝了 Compiz Fusion，但在執行了您所提到的指令後，我的視窗的標題列與按鈕便消失了。是那裡有問題?<a class=anchor href=#_我已經安裝了_compizfusion但在執行了您所提到的指令後我的視窗的標題列與按鈕便消失了是那裡有問題></a></h5><div class=paragraph><p>您可能忘記在 <span class=filename>/etc/X11/xorg.conf</span> 中的設定。請重新檢查這個檔案，特別是 <code>DefaultDepth</code> 及 <code>AddARGBGLXVisuals</code> 指令項。</p></div></div><div class=sect4><h5 id=_當我執行指令來啟動_compizfusionx_伺服器便當掉了然後我又返回_console是那裡有問題>5.9.3.2. 當我執行指令來啟動 Compiz Fusion，X 伺服器便當掉了，然後我又返回 Console。是那裡有問題?<a class=anchor href=#_當我執行指令來啟動_compizfusionx_伺服器便當掉了然後我又返回_console是那裡有問題></a></h5><div class=paragraph><p>若您檢查 <span class=filename>/var/log/Xorg.0.log</span>，您可能可以找到當 X 啟動時所發生的錯誤訊息。最常發生的錯誤會是：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     Failed to initialize the GLX module<span class=p>;</span> please check <span class=k>in </span>your X
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     log file that the GLX module has been loaded <span class=k>in </span>your X
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     server, and that the module is the NVIDIA GLX module.  If
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     you <span class=k>continue </span>to encounter problems, Please try
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     reinstalling the NVIDIA driver.</code></pre></div></div><div class=paragraph><p>會發生這個情形通常是因為您升級了 Xorg，您需要重新安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-driver/>x11/nvidia-driver</a> 套件來重新編譯 glx。</p></div></div></div></div></div></div><h1 id=common-tasks class=sect0>Part II: 一般作業<a class=anchor href=#common-tasks></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>既然基礎的部分已經提過了，接下來的這個部分將會討論一些常會用到的 FreeBSD 的特色，這些章節包括：</p></div><div class=ulist><ul><li><p>介紹給您常見且實用的桌面應用軟體：瀏覽器、辦工工具、文件閱覽程式等。</p></li><li><p>介紹給您眾多 FreeBSD 上可用的多媒體工具。</p></li><li><p>解釋如何編譯量身訂做的 FreeBSD 核心以增加額外系統功能的流程。</p></li><li><p>詳細描述列印系統，包含桌上型印表機及網路印表機的設定。</p></li><li><p>展示給您看如何在您的 FreeBSD 系統中執行 Linux 應用軟體。</p></li></ul></div><div class=paragraph><p>這些章節中有些需要您預先閱讀些相關文件，在各章節開頭的概要內會提及。</p></div></div></div><div class=sect1><h2 id=desktop>Chapter 6. 桌面應用程式<a class=anchor href=#desktop></a></h2><div class=sectionbody><div class=sect2><h3 id=desktop-synopsis>6.1. 概述<a class=anchor href=#desktop-synopsis></a></h3><div class=paragraph><p>隨著 FreeBSD 優越的效能及穩定性越來越熱門，它同時適合作為每日使用的桌面系統。FreeBSD 套件或 Port 有超過 24,000 個可用的應用程式，可以簡單的建立一個自訂的桌面環境來執行各種不同的桌面應用程式。本章將示範如何安裝數個桌面應用程式，包含網頁瀏覽器、辦工軟體、文件閱覽程式以及財務軟體。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>比起重頭設定與編譯，較偏好使用 FreeBSD 桌面環境已預先編譯好版本的使用者可參考 <a href=http://www.trueos.org/>trueos.org 網站</a>。</p></div></td></tr></tbody></table></div><div class=paragraph><p>在閱讀這章之前，你必須了解如何：</p></div><div class=ulist><ul><li><p>使用套件或 Port 安裝其他軟體如 <a href=./#ports>安裝應用程式：套件與 Port</a> 所敘述。</p></li><li><p>安狀 X 與視窗管理程式如 <a href=./#x11>X Window 系統</a> 所敘述。</p></li></ul></div><div class=paragraph><p>要取得有關如何設定多媒體環境的資訊，請參考 <a href=./#multimedia>多媒體</a>。</p></div></div><div class=sect2><h3 id=desktop-browsers>6.2. 瀏覽器<a class=anchor href=#desktop-browsers></a></h3><div class=paragraph><p>在 FreeBSD 中並未預先安裝好網頁瀏覽器。 但在 Port 套件集中的 <a href=https://www.FreeBSD.org/ports/>www</a> 分類中有許多瀏覽器可以採 Binary 套件安裝或自 Port 套件集編譯的方式安裝。</p></div><div class=paragraph><p>KDE 和 GNOME 桌面環境都有提供自有的 HTML 瀏覽器。請參考 <a href=./#x11-wm>桌面環境</a> 來了解更多有關如何設定完整桌面環境的資訊。</p></div><div class=paragraph><p>有一些輕量化的瀏覽器可使用，包含 <a class=package href=https://cgit.freebsd.org/ports/tree/www/dillo2/>www/dillo2</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/www/links/>www/links</a> 以及 <a class=package href=https://cgit.freebsd.org/ports/tree/www/w3m/>www/w3m</a>。</p></div><div class=paragraph><p>本章節將示範如何安裝下列常見的網頁瀏覽器並說明該應用程式是否需要用到大量資源、花費大量時間自 Port 編譯或何主要的相依套件。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">應用程式名稱</th><th class="tableblock halign-left valign-top">所需資源</th><th class="tableblock halign-left valign-top">自 Port 安裝時間</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>中</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>有 FreeBSD 、 Linux™ 及在地化版本</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Opera</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>有 FreeBSD 、 Linux™ 版本</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Konqueror</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>中</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>需要 KDE 程式庫</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chromium</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>中</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>需要 Gtk+ 程式庫</p></td></tr></tbody></table><div class=sect3><h4 id=_firefox>6.2.1. Firefox<a class=anchor href=#_firefox></a></h4><div class=paragraph><p>Firefox 是一套開放源始碼的瀏覽器，它具備符合 HTML 標準的顯示引擎、頁籤瀏覽、彈出視窗封鎖、擴充套件、強化安全性及其他更多功能。Firefox 的基礎使用了 Mozilla 的程式庫。</p></div><div class=paragraph><p>要安裝最新釋出版本的 Firefox 套件可輸入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install firefox</span></code></pre></div></div><div class=paragraph><p>要安裝延長支援發佈 (Extended Support Release, ESR) 版本的 Firefox，可使用：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install firefox-esr</span></code></pre></div></div><div class=paragraph><p>在地化的版本可在 <a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox-i18n/>www/firefox-i18n</a> 及 <a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox-esr-i18n/>www/firefox-esr-i18n</a> 取得。</p></div><div class=paragraph><p>使用 Port 套件地可以用原始碼編譯成您想要的 Firefox 版本。此範例編譯 <a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a>，其中 <code>firefox</code> 可替換為 ESR 或在地化版本來安裝。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/firefox</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_opera>6.2.2. Opera<a class=anchor href=#_opera></a></h4><div class=paragraph><p>Opera 是個具備完整功能、符合標準且輕量、執行速度快的瀏覽器。 它同時也具備了內建的郵件、新聞閱讀器、IRC 客戶端、RSS/Atom 來源閱讀器等。 可用的版本有兩種原生的 FreeBSD 版本及 Linux™ 模擬模式下執行的版本。</p></div><div class=paragraph><p>以下指令可安裝 FreeBSD Binary 套件版本的 Opera，替換 <code>opera</code> 為 <code>linux-opera</code> 則可改安裝 Linux™ 版本。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install opera</span></code></pre></div></div><div class=paragraph><p>或者，可安裝 Port 套件集中的版本，以下範例會編譯原生的版本：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/opera</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>要安裝 Linux™ 則替換 <code>opera</code> 為 <code>linux-opera</code>。</p></div><div class=paragraph><p>要安裝 Adobe™Flash™ 附加元件，需先編譯 <a class=package href=https://cgit.freebsd.org/ports/tree/www/linux-flashplayer/>www/linux-flashplayer</a> Port，因受到授權條款限制無法事先編譯為 Binary 套件。然後再安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/www/opera-linuxplugins/>www/opera-linuxplugins</a>。以下範例示範如何編譯 Port 中的這兩個應用程式：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/linux-flashplayer</span>
<span class=c># make install clean</span>
<span class=c># cd /usr/ports/www/opera-linuxplugins</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>安裝完成後，開啟瀏覽器檢查附加元件是否存在，在網址列輸入 <code>opera:plugins</code> 並按下 <kbd>Enter</kbd> 鍵，便會有清單顯示目前可用的附加元件。</p></div><div class=paragraph><p>若要安裝 Java™ 附加元件請接著安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/java/icedtea-web/>java/icedtea-web</a>。</p></div></div><div class=sect3><h4 id=_konqueror>6.2.3. Konqueror<a class=anchor href=#_konqueror></a></h4><div class=paragraph><p>Konqueror 不只是個網頁瀏覽器， 它同時也是檔案管理器和多媒體瀏覽器。它包含在 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/kde4-baseapps/>x11/kde4-baseapps</a> 套件或 Port 中。</p></div><div class=paragraph><p>Konqueror 使用支援 WebKit 以及它自有的 KTHML。WebKit 是一套被許多現代瀏覽器所使用的繪圖引擎，包含 Chromium。要在 FreeBSD 的 Konqueror 使用 WebKit 需安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/www/kwebkitpart/>www/kwebkitpart</a> 套件或 Port。此範例示範使用 Binary 套件安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install kwebkitpart</span></code></pre></div></div><div class=paragraph><p>從 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/kwebkitpart</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>要啟動 Konqueror 中的 WebKit 點選 "Settings"、"Configure Konqueror"。在 "General" 設定頁面內點選 "Default web browser engine" 旁的下拉示選單並變更 "KHTML" 為 "WebKit"。</p></div><div class=paragraph><p>Konqueror 也支援 Flash™，"如何"在 Konqueror 上安裝 Flash™ 的說明可參考 <a href=http://freebsd.kde.org/howtos/konqueror-flash.php>http://freebsd.kde.org/howtos/konqueror-flash.php</a>。</p></div></div><div class=sect3><h4 id=_chromium>6.2.4. Chromium<a class=anchor href=#_chromium></a></h4><div class=paragraph><p>Chromium 是一個開放源始碼的瀏覽器計劃，該計劃的目標是要建立一個安全、快速且更穩定的網頁瀏覽體驗。Chromium 的功能有頁籤式瀏覽、彈出視窗封鎖、擴充套件等等。</p></div><div class=paragraph><p>Chromium 可以使用套件來安裝，只要輸入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install chromium</span></code></pre></div></div><div class=paragraph><p>或者可從 Port 套件集的原始碼編譯 Chromium：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/chromium</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Chromium 的執行檔為 <span class=filename>/usr/local/bin/chrome</span>，並非 <span class=filename>/usr/local/bin/chromium</span>。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=desktop-productivity>6.3. 辦工工具<a class=anchor href=#desktop-productivity></a></h3><div class=paragraph><p>當開始進行辦公，使用者通常會找好用的辦公軟體或是好上手的文書處理程式。 雖然有些 <a href=./#x11-wm>桌面環境</a> 像是 KDE 已經提供了辦公軟體，但並沒有預設的辦公軟體，FreeBSD 提供多套辦公軟體以及圖型化文書處理程式，不論您用那種的視窗管理程式都能使用。</p></div><div class=paragraph><p>本章節元範如何安裝以下熱門的辦公軟體以及說明該應用程式所需的資源、自 Port 編譯的時間或者是否有其他主要相依套件。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">應用程式名稱</th><th class="tableblock halign-left valign-top">所需資源</th><th class="tableblock halign-left valign-top">自 Port 安裝時間</th><th class="tableblock halign-left valign-top">主要相依套件</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Calligra</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AbiWord</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ 或 GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>The Gimp</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Apache OpenOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>非常多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>JDK™ 及 Mozilla</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>LibreOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>有點多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>非常多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ 或 KDE/ GNOME 或 JDK™</p></td></tr></tbody></table><div class=sect3><h4 id=_calligra>6.3.1. Calligra<a class=anchor href=#_calligra></a></h4><div class=paragraph><p>KDE 桌面環境中內含辦公軟體可以與 KDE 分開安裝。Calligra 中也有可在其他辦公軟體中找到的標準元件，如 Words 是文件處理程式、Sheets 是試算表程式、Stage 可管理投影片以及 Karbon 用來繪製圖型文件。</p></div><div class=paragraph><p>在 FreeBSD 中 <a class=package href=https://cgit.freebsd.org/ports/tree/editors/calligra/>editors/calligra</a> 可以使用套件或 Port 的方式安裝，要使用套件安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install calligra</span></code></pre></div></div><div class=paragraph><p>若沒有可用的套件，可改使用 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/calligra</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_abiword>6.3.2. AbiWord<a class=anchor href=#_abiword></a></h4><div class=paragraph><p>AbiWord 是一個免費的文件處理軟體，外觀和感覺都近似於 Microsoft™ Word。 它非常快速，包含了許多功能而且非常容易上手。</p></div><div class=paragraph><p>AbiWord 可以輸入或輸出許多檔案格式， 包括一些有專用的格式，例如 Microsoft™ <span class=filename>.rtf</span> 格式。</p></div><div class=paragraph><p>要安裝 AbiWord Binary 套件，可使用下列指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install abiword</span></code></pre></div></div><div class=paragraph><p>若沒有 Binary 套件版本，也可以從 Port 套件集中編譯安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/abiword</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_the_gimp>6.3.3. The GIMP<a class=anchor href=#_the_gimp></a></h4><div class=paragraph><p>對於影像的編輯及修改來說，The GIMP 是非常精緻的影像處理軟體。 它可以當作簡單的繪圖軟體或是高品質的相片處理軟體。 它支援為數眾多的外掛程式及指令稿 (script-fu) 介面。 The GIMP 可以讀寫許多檔案格式。 它也支援掃描器和手寫板。</p></div><div class=paragraph><p>要安裝套件可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gimp</span></code></pre></div></div><div class=paragraph><p>或使用 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/gimp</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>在 Port 套件集的 graphics 分類 (<a href=https://www.FreeBSD.org/ports/>freebsd.org/ports/</a>) 下也包含了許多 GIMP 相關的附加元件，說明檔及使用手冊。</p></div></div><div class=sect3><h4 id=_apache_openoffice>6.3.4. Apache OpenOffice<a class=anchor href=#_apache_openoffice></a></h4><div class=paragraph><p>Apache OpenOffice 是開放原始碼的辦工室軟體，由 Apache Software Foundation’s Incubator 底下的團隊所開發。 它包含了所有完整的辦公軟體組合： 文字處理器、試算表、簡報軟體還有繪圖軟體。 除了它的使用者介面非常類似其他的辦公軟體， 他還能夠輸入和輸出許多熱門的檔案格式。 它也包含了不同語言的使用者介面、拼字檢查和字典。</p></div><div class=paragraph><p>Apache OpenOffice 的文字處理器使用原生的 XML 檔案格式來增加移植性及彈性。 試算表程式支援巨集 (Macro) 功能而且能夠使用外來的資料庫介面。 Apache OpenOffice 已經十分穩定， 並且能夠在 Windows™, Solaris™, Linux™, FreeBSD 及 Mac OS™ X 等作業系統上面執行。 想知道更多關於 Apache OpenOffice 的資訊可以在 <a href=http://openoffice.org/>openoffice.org</a> 網頁上查詢。在 FreeBSD 特定的資訊可參考 <a href=http://porting.openoffice.org/freebsd/>porting.openoffice.org/freebsd/</a>。</p></div><div class=paragraph><p>要安裝 Apache OpenOffice 套件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install apache-openoffice</span></code></pre></div></div><div class=paragraph><p>當套件安裝完成之後，只要輸入下面的指令就能執行 Apache OpenOffice：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% openoffice-X.Y.Z</code></pre></div></div><div class=paragraph><p>其中 <em>X.Y.Z</em> 是已安裝的 Apache OpenOffice 的版本編號。第一次執行 Apache OpenOffice 會詢問一些問題且會在使用者的家目錄建立一個 <span class=filename>.openoffice.org</span> 資料夾。</p></div><div class=paragraph><p>若無法由套件取得想要的 Apache OpenOffice，仍可選擇從 Port 編譯。 不過必須注意：編譯的過程會需要大量的磁碟空間與時間：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/openoffice-4</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>如果想要編譯在地化的版本，將前面的指令替換成為：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make LOCALIZED_LANG=your_language install clean</span></code></pre></div></div><div class=paragraph><p>替換 <em>your_language</em> 為正確的語言 ISO 編碼。支援的語言編碼清單在 <span class=filename>files/Makefile.localized</span>，位於該 Port 的目錄。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_libreoffice>6.3.5. LibreOffice<a class=anchor href=#_libreoffice></a></h4><div class=paragraph><p>LibreOffice 是一套自由的辦公軟體由 <a href=http://www.documentfoundation.org/>documentfoundation.org</a> 所開發。它可相容其他主流的辦公軟體以及可在各種平台上使用。它是 Apache OpenOffice 品牌重塑後的分支，含有可在完整辦公生產力軟體中找到的應用程式：文件處理程式、試算表、簡報管理程式、繪圖程式、資料庫管理程式以及建立與編輯數學公式的工具。它也支援數種語言與國際化一直延伸到介面、拼字檢查程式與字典。</p></div><div class=paragraph><p>LibreOffice 的文件處理程式使用了原生的 XML 檔案格式來增加可攜性與彈性，試算表程式支援可與外部資料庫連接的巨集語言。LibreOffice 非常穩定且可直接在 Windows™, Linux™, FreeBSD 以及 Mac OS™ X 上執行。更多有關 LibreOffice 的資訊可在 <a href=http://www.libreoffice.org/>libreoffice.org</a> 找到。</p></div><div class=paragraph><p>要安裝英文版本的 LibreOffice 套件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install libreoffice</span></code></pre></div></div><div class=paragraph><p>Port 套件集的編輯器分類 (<a href=https://www.FreeBSD.org/ports/>freebsd.org/ports/</a>) 中含有數個 LibreOffice 的語系。安裝在地化套件時，請替換 <code>libreoffice</code> 為在地化套件的名稱。</p></div><div class=paragraph><p>套件安裝之後，輸入以下指令來執行 LibreOffice：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% libreoffice</code></pre></div></div><div class=paragraph><p>第一次啟動的過程中會詢問一些問題並在使用者的家目錄建立 <span class=filename>.libreoffice</span> 資料夾。</p></div><div class=paragraph><p>若找不到想使用的 LibreOffice 套件，也可從 Port 編譯，但這會要大量的磁碟空間及漫長的時間編譯。以下例子示範編譯英文版本：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/libreoffice</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>要編譯在地化版本，則需 <code>cd</code> 進入想要的語言 Port 目錄。支援的語言可在 Port 套件集的編輯器分類 (<a href=https://www.FreeBSD.org/ports/>freebsd.org/ports/</a>) 中找到。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=desktop-viewers>6.4. 文件閱覽程式<a class=anchor href=#desktop-viewers></a></h3><div class=paragraph><p>UNIX™ 出現之後，有一些新的文件格式才越來越熱門，這些文件所需的檢視程式可能並不在基礎系統中。本節將示範如何安裝以下文件檢視程式：</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">應用程式名稱</th><th class="tableblock halign-left valign-top">所需資源</th><th class="tableblock halign-left valign-top">自 Port 安裝時間</th><th class="tableblock halign-left valign-top">主要相依套件</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Xpdf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeType</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Xaw3d</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Geeqie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ 或 GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ePDFView</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Okular</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect3><h4 id=_xpdf>6.4.1. Xpdf<a class=anchor href=#_xpdf></a></h4><div class=paragraph><p>如果你想要一個小型的 FreeBSD PDF 閱覽軟體， Xpdf 是個輕量級而且有效率的閱覽器。 它只需要非常少的資源而且十分穩定。 它只使用標準的 X 字型且不需要額外的工具包(Toolkit)。</p></div><div class=paragraph><p>安裝 Xpdf 套件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xpdf</span></code></pre></div></div><div class=paragraph><p>若沒有可用的套件版本，可使用 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/xpdf</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>完成安裝後，執行 <code>xpdf</code> 並使用滑鼠右鍵開啟選單。</p></div></div><div class=sect3><h4 id=_gv>6.4.2. gv<a class=anchor href=#_gv></a></h4><div class=paragraph><p>gv 是 PostScript™ 和 PDF 的閱覽器。 它建構於 ghostview 的基礎上，不過因為使用 Xaw3d 視窗元件工具包，所以外觀看起來比較漂亮。 gv 有許多可設定的功能，比如說紙張方向、紙張大小、縮放比例、和反鋸齒(Anti-aliasing)等。 而且幾乎所有的使用都可以從鍵盤或滑鼠來完成。</p></div><div class=paragraph><p>安裝 gv 套件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gv</span></code></pre></div></div><div class=paragraph><p>若沒有可用的套件版本，可使用 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/print/gv</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_geeqie>6.4.3. Geeqie<a class=anchor href=#_geeqie></a></h4><div class=paragraph><p>Geeqie 是由已經停止維護的 GQView 專案所衍伸出來的分支，並致力開發新功能並整合已有的修補。Geeqie 是一套影像管理軟體，支援單鍵閱覽檔案、啟動外部編輯器、縮圖預覽等功能。 它也有幻燈片模式及一些基本的檔案操作的功能，能輕鬆的管理大量影像並找出重複的檔案。 Geeqie 也支援使用全螢幕閱覽以及國際化。</p></div><div class=paragraph><p>安裝 Geeqie 套件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install geeqie</span></code></pre></div></div><div class=paragraph><p>若沒有可用的套件版本，可使用 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/geeqie</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_epdfview>6.4.4. ePDFView<a class=anchor href=#_epdfview></a></h4><div class=paragraph><p>ePDFView 是一套小巧的 PDF 文件檢視程式，只使用了 Gtk+ 與 Poppler 程式庫。它目前還在開發當中，但已經可以開啟大部份 PDF 檔案 (甚至是加密過的)、儲存文件複本以及支援使用 CUPS 來列印。</p></div><div class=paragraph><p>要以套件安裝 ePDFView：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install epdfview</span></code></pre></div></div><div class=paragraph><p>若沒有可用的套件版本，可使用 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/epdfview</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_okular>6.4.5. Okular<a class=anchor href=#_okular></a></h4><div class=paragraph><p>Okular 是一套通用的文件檢視程式，以 KDE 的 KPDF 為基礎。它可以開啟許多種文件格式，包含了 PDF, PostScript™, DjVu, CHM, XPS 以及 ePub。</p></div><div class=paragraph><p>要以套件安裝 Okular：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install okular</span></code></pre></div></div><div class=paragraph><p>若沒有可用的套件版本，可使用 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/okular</span>
<span class=c># make install clean</span></code></pre></div></div></div></div><div class=sect2><h3 id=desktop-finance>6.5. 財務<a class=anchor href=#desktop-finance></a></h3><div class=paragraph><p>如果有任何理由你想要在你的 FreeBSD 桌面環境上管理你的個人財務， 這裡有一些功能強大、使用簡單的應用程式可供安裝。 這些財務管理軟體之中有些是相容於流行的 Quicken 或 Excel 文件。</p></div><div class=paragraph><p>這節涵蓋了下面這些軟體：</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">應用程式名稱</th><th class="tableblock halign-left valign-top">所需資源</th><th class="tableblock halign-left valign-top">自 Port 安裝時間</th><th class="tableblock halign-left valign-top">主要相依套件</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GnuCash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnumeric</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KMyMoney</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect3><h4 id=_gnucash>6.5.1. GnuCash<a class=anchor href=#_gnucash></a></h4><div class=paragraph><p>GnuCash 是 GNOME 團隊努力成果中的一部分， GNOME 團隊主要提供親切而強大的桌面應用程式給終端使用者。使用 GnuCash 可以持續追蹤收入與花費、銀行帳戶以及股票證券等。 它的特性是介面直覺但功能仍非常專業。</p></div><div class=paragraph><p>GnuCash 提供了智慧的計數器、多階層帳戶系統以及快速鍵及自動完成功能。 它也能分開單一的報表至數個詳細的部份。 GnuCash 也能夠匯入及合併 Quicken QIF 檔案。 它也能處理大部分國際的日期及通用貨幣之格式。</p></div><div class=paragraph><p>安裝 GnuCash 套件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnucash</span></code></pre></div></div><div class=paragraph><p>若沒有可用的套件版本，可使用 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/gnucash</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_gnumeric>6.5.2. Gnumeric<a class=anchor href=#_gnumeric></a></h4><div class=paragraph><p>Gnumeric 是 GNOME 社群所開發的試算表程式。 它的特點是擁有能夠根據儲存格格式 「猜出」使用者的輸入來自動補齊的系統。 它也能夠匯入許多熱門的檔案格式，像是 Excel, Lotus 1-2-3 以及 Quattro Pro。 它有大量內建的函數而且能夠使用常用的儲存格格式，像是：數字、貨幣、日期、時間及其他格式等。</p></div><div class=paragraph><p>安裝 Gnumeric 套件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnumeric</span></code></pre></div></div><div class=paragraph><p>若沒有可用的套件版本，可使用 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/math/gnumeric</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_kmymoney>6.5.3. KMyMoney<a class=anchor href=#_kmymoney></a></h4><div class=paragraph><p>KMyMoney 是一套個人財務應用程式，由 KDE 社群所開發。KMyMoney 的目標是提供可在商業個人財務管理應用程式中找到的重要功能，它也強調簡單易用及其功能間採用合適的複式記帳。KMyMoney 可從標準 Quicken QIF 檔案匯入資料、追蹤投資、處理多種貨幣並提供財務報表。</p></div><div class=paragraph><p>要以套件安裝 KMyMoney：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install kmymoney-kde4</span></code></pre></div></div><div class=paragraph><p>若沒有可用的套件版本，可使用 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/kmymoney-kde4</span>
<span class=c># make install clean</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=multimedia>Chapter 7. 多媒體<a class=anchor href=#multimedia></a></h2><div class=sectionbody><div class=sect2><h3 id=multimedia-synopsis>7.1. 概述<a class=anchor href=#multimedia-synopsis></a></h3><div class=paragraph><p>FreeBSD 廣泛地支援各種音效卡， 讓使用者可以享受來自電腦上的高傳真音質(Hi-Fi)， 此外還包括了錄製和播放 MPEG Audio Layer 3 (MP3)、 Waveform Audio File (WAV)、Ogg Vorbis 以及其他許多種格式聲音的能力。同時 FreeBSD Port 套件集也包含了許多可讓您可以錄音、編修音效以及控制 MIDI 配備的應用程式。</p></div><div class=paragraph><p>FreeBSD 也能播放一般的視訊檔和 DVD。 FreeBSD Port 套件集中含有可編碼、轉換以及播放格種影像媒體的應用程式。</p></div><div class=paragraph><p>本章會說明如何設定 FreeBSD 上的音效卡、影像播放器、電視卡及掃描器。同時會說明有那些應用程式可以使用這些裝置。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>設定 FreeBSD 上的音效卡。</p></li><li><p>音效設定疑難排解。</p></li><li><p>播放、錄製 MP3 及其他聲音檔案格式。</p></li><li><p>FreeBSD 系統播放影像的準備工具。</p></li><li><p>播放 DVD 的 <span class=filename>.mpg</span> 及 <span class=filename>.avi</span> 檔。</p></li><li><p>擷取(Rip) CD 和 DVD的內容至檔案。</p></li><li><p>設定電視卡。</p></li><li><p>在 FreeBSD 安裝 MythTV</p></li><li><p>設定影像掃描機。</p></li><li><p>設定藍芽耳機。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>知道如何安裝應用程式如 <a href=./#ports>安裝應用程式：套件與 Port</a> 所敘述。</p></li></ul></div></div><div class=sect2><h3 id=sound-setup>7.2. 設定音效卡<a class=anchor href=#sound-setup></a></h3><div class=paragraph><p>開始設定之前，必須先知道你的音效卡型號、晶片為何。 FreeBSD 支援許多種音效卡，請檢查支援的音效硬體表 <a href=https://www.FreeBSD.org/releases/12.0r/hardware/>Hardware Notes</a>，以確認你的音效卡是否支援以及如何在 FreeBSD 上驅動。</p></div><div class=paragraph><p>要使用音效裝置，必須要載入正確的驅動程式才行。最簡單方式就是以 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> 來載入核心模組。以下範例示範載入 Intel 規格內建的音效晶片驅動程式：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_hda</span></code></pre></div></div><div class=paragraph><p>要開機時自動載入驅動程式，需將驅動程式加到 <span class=filename>/boot/loader.conf</span> 檔，以此驅動程式為例：</p></div><div class="literalblock programlisting"><div class=content><pre>snd_hda_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>其他可用的音效卡模組清單列於 <span class=filename>/boot/defaults/loader.conf</span>。當不確認要使用何種驅動程式時，可載入 <span class=filename>snd_driver</span> 模組：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_driver</span></code></pre></div></div><div class=paragraph><p>它是 metadriver 會載入所有最通用的音效驅動程式並且用來加速尋找正確的驅動程式。也可以把 metadriver 加入 <span class=filename>/boot/loader.conf</span> 檔來載入所有音效驅動程式。</p></div><div class=paragraph><p>要知道載入 <span class=filename>snd_driver</span> metadriver 後使用了那個音效卡驅動程式，請輸入 <code>cat /dev/sndstat</code>。</p></div><div class=sect3><h4 id=_設定自訂核心支援音效>7.2.1. 設定自訂核心支援音效<a class=anchor href=#_設定自訂核心支援音效></a></h4><div class=paragraph><p>This section is for users who prefer to statically compile in support for the sound card in a custom kernel. For more information about recompiling a kernel, refer to <a href=./#kernelconfig>設定 FreeBSD 核心</a>.</p></div><div class=paragraph><p>When using a custom kernel to provide sound support, make sure that the audio framework driver exists in the custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device sound</pre></div></div><div class=paragraph><p>Next, add support for the sound card. To continue the example of the built-in audio chipset based on the Intel specification from the previous section, use the following line in the custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_hda</pre></div></div><div class=paragraph><p>Be sure to read the manual page of the driver for the device name to use for the driver.</p></div><div class=paragraph><p>Non-PnP ISA sound cards may require the IRQ and I/O port settings of the card to be added to <span class=filename>/boot/device.hints</span>. During the boot process, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> reads this file and passes the settings to the kernel. For example, an old Creative SoundBlaster™ 16 ISA non-PnP card will use the <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> driver in conjunction with <code>snd_sb16</code>. For this card, the following lines must be added to the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_sbc
device snd_sb16</pre></div></div><div class=paragraph><p>If the card uses the <code>0x220</code> I/O port and IRQ <code>5</code>, these lines must also be added to <span class=filename>/boot/device.hints</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.sbc.0.at=&#34;isa&#34;
hint.sbc.0.port=&#34;0x220&#34;
hint.sbc.0.irq=&#34;5&#34;
hint.sbc.0.drq=&#34;1&#34;
hint.sbc.0.flags=&#34;0x15&#34;</pre></div></div><div class=paragraph><p>The syntax used in <span class=filename>/boot/device.hints</span> is described in <a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a> and the manual page for the driver of the sound card.</p></div><div class=paragraph><p>The settings shown above are the defaults. In some cases, the IRQ or other settings may need to be changed to match the card. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> for more information about this card.</p></div></div><div class=sect3><h4 id=sound-testing>7.2.2. 測試音效<a class=anchor href=#sound-testing></a></h4><div class=paragraph><p>After loading the required module or rebooting into the custom kernel, the sound card should be detected. To confirm, run <code>dmesg | grep pcm</code>. This example is from a system with a built-in Conexant CX20590 chipset:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pcm0: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> at nid 5 on hdaa0
pcm1: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> at nid 6 on hdaa0
pcm2: &lt;Conexant CX20590 <span class=o>(</span>Analog 2.0+HP/2.0<span class=o>)&gt;</span> at nid 31,25 and 35,27 on hdaa1</code></pre></div></div><div class=paragraph><p>The status of the sound card may also be checked using this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /dev/sndstat</span>
FreeBSD Audio Driver <span class=o>(</span>newpcm: 64bit 2009061500/amd64<span class=o>)</span>
Installed devices:
pcm0: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> <span class=o>(</span>play<span class=o>)</span>
pcm1: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> <span class=o>(</span>play<span class=o>)</span>
pcm2: &lt;Conexant CX20590 <span class=o>(</span>Analog 2.0+HP/2.0<span class=o>)&gt;</span> <span class=o>(</span>play/rec<span class=o>)</span> default</code></pre></div></div><div class=paragraph><p>The output will vary depending upon the sound card. If no <span class=filename>pcm</span> devices are listed, double-check that the correct device driver was loaded or compiled into the kernel. The next section lists some common problems and their solutions.</p></div><div class=paragraph><p>If all goes well, the sound card should now work in FreeBSD. If the CD or DVD drive is properly connected to the sound card, one can insert an audio CD in the drive and play it with <a href="https://man.freebsd.org/cgi/man.cgi?query=cdcontrol&amp;sektion=1&amp;format=html">cdcontrol(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdcontrol <span class=nt>-f</span> /dev/acd0 play 1</code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Audio CDs have specialized encodings which means that they should not be mounted using <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Various applications, such as <a class=package href=https://cgit.freebsd.org/ports/tree/audio/workman/>audio/workman</a>, provide a friendlier interface. The <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> port can be installed to listen to MP3 audio files.</p></div><div class=paragraph><p>Another quick way to test the card is to send data to <span class=filename>/dev/dsp</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>filename <span class=o>&gt;</span> /dev/dsp</code></pre></div></div><div class=paragraph><p>where <span class=filename>filename</span> can be any type of file. This command should produce some noise, confirming that the sound card is working.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <span class=filename>/dev/dsp*</span> device nodes will be created automatically as needed. When not in use, they do not exist and will not appear in the output of <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=bluetooth-headset>7.2.3. 設定藍芽音效裝置<a class=anchor href=#bluetooth-headset></a></h4><div class=paragraph><p>Connecting to a Bluetooth device is out of scope for this chapter. Refer to <a href=./#network-bluetooth>藍牙</a> for more information.</p></div><div class=paragraph><p>To get Bluetooth sound sink working with FreeBSD’s sound system, users have to install <a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a> first:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install virtual_oss</span></code></pre></div></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a> requires <code>cuse</code> to be loaded into the kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload cuse</span></code></pre></div></div><div class=paragraph><p>To load <code>cuse</code> during system startup, run this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf cuse_load=yes</span></code></pre></div></div><div class=paragraph><p>To use headphones as a sound sink with <a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a>, users need to create a virtual device after connecting to a Bluetooth audio device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># virtual_oss -C 2 -c 2 -r 48000 -b 16 -s 768 -R /dev/null -P /dev/bluetooth/headphones -d dsp</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>headphones</em> in this example is a hostname from <span class=filename>/etc/bluetooth/hosts</span>. <code>BT_ADDR</code> could be used instead.</p></div></td></tr></tbody></table></div><div class=paragraph><p>請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=virtual_oss&amp;sektion=8&amp;format=html">virtual_oss(8)</a> 取得更多資訊。</p></div></div><div class=sect3><h4 id=troubleshooting>7.2.4. 疑難排解音效<a class=anchor href=#troubleshooting></a></h4><div class=paragraph><p><a href=#multimedia-sound-common-error-messages>常見錯誤訊息</a> lists some common error messages and their solutions:</p></div><table id=multimedia-sound-common-error-messages class="tableblock frame-none grid-all stretch"><caption class=title>表 7. 常見錯誤訊息</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">錯誤</th><th class="tableblock halign-left valign-top">解決方式</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb_dspwr(XX) timed out</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The I/O port is not set correctly.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bad irq XX</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The IRQ is set incorrectly. Make sure that the set IRQ and the sound IRQ are the same.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: gus pcm not attached, out of memory</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>There is not enough available memory to use the device.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: can’t open /dev/dsp!</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Type <code>fstat | grep dsp</code> to check if another application is holding the device open. Noteworthy troublemakers are esound and KDE’s sound support.</p></td></tr></tbody></table><div class=paragraph><p>Modern graphics cards often come with their own sound driver for use with HDMI. This sound device is sometimes enumerated before the sound card meaning that the sound card will not be used as the default playback device. To check if this is the case, run dmesg and look for <code>pcm</code>. The output looks something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 0 nid 1 on hdac0
pcm1: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 1 nid 1 on hdac0
pcm2: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 2 nid 1 on hdac0
pcm3: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: &lt;HDA Realtek ALC889 PCM #0 Analog&gt; at cad 2 nid 1 on hdac1
pcm5: &lt;HDA Realtek ALC889 PCM #1 Analog&gt; at cad 2 nid 1 on hdac1
pcm6: &lt;HDA Realtek ALC889 PCM #2 Digital&gt; at cad 2 nid 1 on hdac1
pcm7: &lt;HDA Realtek ALC889 PCM #3 Digital&gt; at cad 2 nid 1 on hdac1
...</pre></div></div><div class=paragraph><p>In this example, the graphics card (<code>NVidia</code>) has been enumerated before the sound card (<code>Realtek ALC889</code>). To use the sound card as the default playback device, change <code>hw.snd.default_unit</code> to the unit that should be used for playback:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.snd.default_unit=n</span></code></pre></div></div><div class=paragraph><p>where <code>n</code> is the number of the sound device to use. In this example, it should be <code>4</code>. Make this change permanent by adding the following line to <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.snd.default_unit=4</pre></div></div></div><div class=sect3><h4 id=sound-multiple-sources>7.2.5. 使用多個音效來源<a class=anchor href=#sound-multiple-sources></a></h4><div class=paragraph><p>It is often desirable to have multiple sources of sound that are able to play simultaneously. FreeBSD uses "Virtual Sound Channels" to multiplex the sound card’s playback by mixing sound in the kernel.</p></div><div class=paragraph><p>Three <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> knobs are available for configuring virtual channels:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl dev.pcm.0.play.vchans=4</span>
<span class=c># sysctl dev.pcm.0.rec.vchans=4</span>
<span class=c># sysctl hw.snd.maxautovchans=4</span></code></pre></div></div><div class=paragraph><p>This example allocates four virtual channels, which is a practical number for everyday use. Both <code>dev.pcm.0.play.vchans=4</code> and <code>dev.pcm.0.rec.vchans=4</code> are configurable after a device has been attached and represent the number of virtual channels <span class=filename>pcm0</span> has for playback and recording. Since the <span class=filename>pcm</span> module can be loaded independently of the hardware drivers, <code>hw.snd.maxautovchans</code> indicates how many virtual channels will be given to an audio device when it is attached. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> for more information.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The number of virtual channels for a device cannot be changed while it is in use. First, close any programs using the device, such as music players or sound daemons.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The correct <span class=filename>pcm</span> device will automatically be allocated transparently to a program that requests <span class=filename>/dev/dsp0</span>.</p></div></div><div class=sect3><h4 id=_設定混音器頻道的預設值>7.2.6. 設定混音器頻道的預設值<a class=anchor href=#_設定混音器頻道的預設值></a></h4><div class=paragraph><p>The default values for the different mixer channels are hardcoded in the source code of the <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> driver. While sound card mixer levels can be changed using <a href="https://man.freebsd.org/cgi/man.cgi?query=mixer&amp;sektion=8&amp;format=html">mixer(8)</a> or third-party applications and daemons, this is not a permanent solution. To instead set default mixer values at the driver level, define the appropriate values in <span class=filename>/boot/device.hints</span>, as seen in this example:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.pcm.0.vol=&#34;50&#34;</pre></div></div><div class=paragraph><p>This will set the volume channel to a default value of <code>50</code> when the <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> module is loaded.</p></div></div></div><div class=sect2><h3 id=sound-mp3>7.3. MP3 音樂<a class=anchor href=#sound-mp3></a></h3><div class=paragraph><p>This section describes some MP3 players available for FreeBSD, how to rip audio CD tracks, and how to encode and decode MP3s.</p></div><div class=sect3><h4 id=mp3-players>7.3.1. MP3 播放器<a class=anchor href=#mp3-players></a></h4><div class=paragraph><p>A popular graphical MP3 player is Audacious. It supports Winamp skins and additional plugins. The interface is intuitive, with a playlist, graphic equalizer, and more. Those familiar with Winamp will find Audacious simple to use. On FreeBSD, Audacious can be installed from the <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/audacious/>multimedia/audacious</a> port or package. Audacious is a descendant of XMMS.</p></div><div class=paragraph><p>The <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> package or port provides an alternative, command-line MP3 player. Once installed, specify the MP3 file to play on the command line. If the system has multiple audio devices, the sound device can also be specified:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3</span>
High Performance MPEG 1.0/2.0/2.5 Audio Player <span class=k>for </span>Layers 1, 2 and 3
        version 1.18.1<span class=p>;</span> written and copyright by Michael Hipp and others
        free software <span class=o>(</span>LGPL<span class=o>)</span> without any warranty but with best wishes

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo</code></pre></div></div><div class=paragraph><p>Additional MP3 players are available in the FreeBSD Ports Collection.</p></div></div><div class=sect3><h4 id=rip-cd>7.3.2. 擷取 CD 音軌<a class=anchor href=#rip-cd></a></h4><div class=paragraph><p>Before encoding a CD or CD track to MP3, the audio data on the CD must be ripped to the hard drive. This is done by copying the raw CD Digital Audio (CDDA) data to WAV files.</p></div><div class=paragraph><p>The <code>cdda2wav</code> tool, which is installed with the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> suite, can be used to rip audio information from CDs.</p></div><div class=paragraph><p>With the audio CD in the drive, the following command can be issued as <code>root</code> to rip an entire CD into individual, per track, WAV files:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -B</span></code></pre></div></div><div class=paragraph><p>In this example, the <code>-D <em>0,1,0</em></code> indicates the SCSI device <span class=filename>0,1,0</span> containing the CD to rip. Use <code>cdrecord -scanbus</code> to determine the correct device parameters for the system.</p></div><div class=paragraph><p>To rip individual tracks, use <code>-t</code> to specify the track:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 7</span></code></pre></div></div><div class=paragraph><p>To rip a range of tracks, such as track one to seven, specify a range:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 1+7</span></code></pre></div></div><div class=paragraph><p>To rip from an ATAPI (IDE) CDROM drive, specify the device name in place of the SCSI unit numbers. For example, to rip track 7 from an IDE drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D /dev/acd0 -t 7</span></code></pre></div></div><div class=paragraph><p>Alternately, <code>dd</code> can be used to extract audio tracks on ATAPI drives, as described in <a href=./#duplicating-audiocds>複製音樂 CD</a>.</p></div></div><div class=sect3><h4 id=mp3-encoding>7.3.3. MP3 編碼與解碼<a class=anchor href=#mp3-encoding></a></h4><div class=paragraph><p>Lame is a popular MP3 encoder which can be installed from the <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a> port. Due to patent issues, a package is not available.</p></div><div class=paragraph><p>The following command will convert the ripped WAV file <span class=filename>audio01.wav</span> to <span class=filename>audio01.mp3</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lame -h -b 128 --tt &#34;Foo Song Title&#34; --ta &#34;FooBar Artist&#34; --tl &#34;FooBar Album&#34; \</span>
<span class=nt>--ty</span> <span class=s2>&#34;2014&#34;</span> <span class=nt>--tc</span> <span class=s2>&#34;Ripped and encoded by Foo&#34;</span> <span class=nt>--tg</span> <span class=s2>&#34;Genre&#34;</span> audio01.wav audio01.mp3</code></pre></div></div><div class=paragraph><p>The specified 128 kbits is a standard MP3 bitrate while the 160 and 192 bitrates provide higher quality. The higher the bitrate, the larger the size of the resulting MP3. The <code>-h</code> turns on the "higher quality but a little slower" mode. The options beginning with <code>--t</code> indicate ID3 tags, which usually contain song information, to be embedded within the MP3 file. Additional encoding options can be found in the lame manual page.</p></div><div class=paragraph><p>In order to burn an audio CD from MP3s, they must first be converted to a non-compressed file format. XMMS can be used to convert to the WAV format, while mpg123 can be used to convert to the raw Pulse-Code Modulation (PCM) audio data format.</p></div><div class=paragraph><p>To convert <span class=filename>audio01.mp3</span> using mpg123, specify the name of the PCM file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -s audio01.mp3 &gt; audio01.pcm</span></code></pre></div></div><div class=paragraph><p>To use XMMS to convert a MP3 to WAV format, use these steps:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Converting to WAV Format in XMMS</strong>
. Launch XMMS.
. Right-click the window to bring up the XMMS menu.
. Select <code>Preferences</code> under <code>Options</code>.
. Change the Output Plugin to "Disk Writer Plugin".
. Press <code>Configure</code>.
. Enter or browse to a directory to write the uncompressed files to.
. Load the MP3 file into XMMS as usual, with volume at 100% and EQ settings turned off.
. Press <code>Play</code>. The XMMS will appear as if it is playing the MP3, but no music will be heard. It is actually playing the MP3 to a file.
. When finished, be sure to set the default Output Plugin back to what it was before in order to listen to MP3s again.</p></div></div></div><div class=paragraph><p>Both the WAV and PCM formats can be used with cdrecord. When using WAV files, there will be a small tick sound at the beginning of each track. This sound is the header of the WAV file. The <a class=package href=https://cgit.freebsd.org/ports/tree/audio/sox/>audio/sox</a> port or package can be used to remove the header:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sox <span class=nt>-t</span> wav <span class=nt>-r</span> 44100 <span class=nt>-s</span> <span class=nt>-w</span> <span class=nt>-c</span> 2 track.wav track.raw</code></pre></div></div><div class=paragraph><p>Refer to <a href=./#creating-cds>建立與使用 CD 媒體</a> for more information on using a CD burner in FreeBSD.</p></div></div></div><div class=sect2><h3 id=video-playback>7.4. 影片播放<a class=anchor href=#video-playback></a></h3><div class=paragraph><p>Before configuring video playback, determine the model and chipset of the video card. While Xorg supports a wide variety of video cards, not all provide good playback performance. To obtain a list of extensions supported by the Xorg server using the card, run <code>xdpyinfo</code> while Xorg is running.</p></div><div class=paragraph><p>It is a good idea to have a short MPEG test file for evaluating various players and options. Since some DVD applications look for DVD media in <span class=filename>/dev/dvd</span> by default, or have this device name hardcoded in them, it might be useful to make a symbolic link to the proper device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -sf /dev/cd0 /dev/dvd</span></code></pre></div></div><div class=paragraph><p>Due to the nature of <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a>, manually created links will not persist after a system reboot. In order to recreate the symbolic link automatically when the system boots, add the following line to <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>link cd0 dvd</pre></div></div><div class=paragraph><p>DVD decryption invokes certain functions that require write permission to the DVD device.</p></div><div class=paragraph><p>To enhance the shared memory Xorg interface, it is recommended to increase the values of these <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variables:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</pre></div></div><div class=sect3><h4 id=video-interface>7.4.1. 偵測影像處理能力<a class=anchor href=#video-interface></a></h4><div class=paragraph><p>There are several possible ways to display video under Xorg and what works is largely hardware dependent. Each method described below will have varying quality across different hardware.</p></div><div class=paragraph><p>Common video interfaces include:</p></div><div class="olist arabic"><ol class=arabic><li><p>Xorg: normal output using shared memory.</p></li><li><p>XVideo: an extension to the Xorg interface which allows video to be directly displayed in drawable objects through a special acceleration. This extension provides good quality playback even on low-end machines. The next section describes how to determine if this extension is running.</p></li><li><p>SDL: the Simple Directmedia Layer is a porting layer for many operating systems, allowing cross-platform applications to be developed which make efficient use of sound and graphics. SDL provides a low-level abstraction to the hardware which can sometimes be more efficient than the Xorg interface. On FreeBSD, SDL can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/devel/sdl20/>devel/sdl20</a> package or port.</p></li><li><p>DGA: the Direct Graphics Access is an Xorg extension which allows a program to bypass the Xorg server and directly alter the framebuffer. Because it relies on a low level memory mapping, programs using it must be run as <code>root</code>. The DGA extension can be tested and benchmarked using <a href="https://man.freebsd.org/cgi/man.cgi?query=dga&amp;sektion=1&amp;format=html">dga(1)</a>. When <code>dga</code> is running, it changes the colors of the display whenever a key is pressed. To quit, press <kbd>q</kbd>.</p></li><li><p>SVGAlib: a low level console graphics layer.</p></li></ol></div><div class=sect4><h5 id=video-interface-xvideo>7.4.1.1. XVideo<a class=anchor href=#video-interface-xvideo></a></h5><div class=paragraph><p>To check whether this extension is running, use <code>xvinfo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xvinfo</code></pre></div></div><div class=paragraph><p>XVideo is supported for the card if the result is similar to:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
  screen <span class=c>#0</span>
  Adaptor <span class=c>#0: &#34;Savage Streams Engine&#34;</span>
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      <span class=s2>&#34;XV_COLORKEY&#34;</span> <span class=o>(</span>range 0 to 16777215<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 2110<span class=o>)</span>
      <span class=s2>&#34;XV_BRIGHTNESS&#34;</span> <span class=o>(</span>range <span class=nt>-128</span> to 127<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
      <span class=s2>&#34;XV_CONTRAST&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_SATURATION&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_HUE&#34;</span> <span class=o>(</span>range <span class=nt>-180</span> to 180<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      <span class=nb>id</span>: 0x32595559 <span class=o>(</span>YUY2<span class=o>)</span>
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x32315659 <span class=o>(</span>YV12<span class=o>)</span>
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x30323449 <span class=o>(</span>I420<span class=o>)</span>
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x36315652 <span class=o>(</span>RV16<span class=o>)</span>
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      <span class=nb>id</span>: 0x35315652 <span class=o>(</span>RV15<span class=o>)</span>
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      <span class=nb>id</span>: 0x31313259 <span class=o>(</span>Y211<span class=o>)</span>
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</code></pre></div></div><div class=paragraph><p>The formats listed, such as YUV2 and YUV12, are not present with every implementation of XVideo and their absence may hinder some players.</p></div><div class=paragraph><p>If the result instead looks like:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen <span class=c>#0</span>
no adaptors present</code></pre></div></div><div class=paragraph><p>XVideo is probably not supported for the card. This means that it will be more difficult for the display to meet the computational demands of rendering video, depending on the video card and processor.</p></div></div></div><div class=sect3><h4 id=video-ports>7.4.2. 可處理影像的 Port 與套件<a class=anchor href=#video-ports></a></h4><div class=paragraph><p>This section introduces some of the software available from the FreeBSD Ports Collection which can be used for video playback.</p></div><div class=sect4><h5 id=video-mplayer>7.4.2.1. MPlayer 與 MEncoder<a class=anchor href=#video-mplayer></a></h5><div class=paragraph><p>MPlayer is a command-line video player with an optional graphical interface which aims to provide speed and flexibility. Other graphical front-ends to MPlayer are available from the FreeBSD Ports Collection.</p></div><div class=paragraph><p>MPlayer can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mplayer/>multimedia/mplayer</a> package or port. Several compile options are available and a variety of hardware checks occur during the build process. For these reasons, some users prefer to build the port rather than install the package.</p></div><div class=paragraph><p>When compiling the port, the menu options should be reviewed to determine the type of support to compile into the port. If an option is not selected, MPlayer will not be able to display that type of video format. Use the arrow keys and spacebar to select the required formats. When finished, press <kbd>Enter</kbd> to continue the port compile and installation.</p></div><div class=paragraph><p>By default, the package or port will build the <code>mplayer</code> command line utility and the <code>gmplayer</code> graphical utility. To encode videos, compile the <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mencoder/>multimedia/mencoder</a> port. Due to licensing restrictions, a package is not available for MEncoder.</p></div><div class=paragraph><p>The first time MPlayer is run, it will create <span class=filename>~/.mplayer</span> in the user’s home directory. This subdirectory contains default versions of the user-specific configuration files.</p></div><div class=paragraph><p>This section describes only a few common uses. Refer to mplayer(1) for a complete description of its numerous options.</p></div><div class=paragraph><p>To play the file <span class=filename>testfile.avi</span>, specify the video interfaces with <code>-vo</code>, as seen in the following examples:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> xv testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> sdl testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> x11 testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo dga testfile.avi</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo &#39;sdl:dga&#39; testfile.avi</span></code></pre></div></div><div class=paragraph><p>It is worth trying all of these options, as their relative performance depends on many factors and will vary significantly with hardware.</p></div><div class=paragraph><p>To play a DVD, replace <span class=filename>testfile.avi</span> with <code>dvd://<em>N</em> -dvd-device <em>DEVICE</em></code>, where <em>N</em> is the title number to play and <em>DEVICE</em> is the device node for the DVD. For example, to play title 3 from <span class=filename>/dev/dvd</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo xv dvd://3 -dvd-device /dev/dvd</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The default DVD device can be defined during the build of the MPlayer port by including the <code>WITH_DVD_DEVICE=/path/to/desired/device</code> option. By default, the device is <span class=filename>/dev/cd0</span>. More details can be found in the port’s <span class=filename>Makefile.options</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To stop, pause, advance, and so on, use a keybinding. To see the list of keybindings, run <code>mplayer -h</code> or read mplayer(1).</p></div><div class=paragraph><p>Additional playback options include <code>-fs -zoom</code>, which engages fullscreen mode, and <code>-framedrop</code>, which helps performance.</p></div><div class=paragraph><p>Each user can add commonly used options to their <span class=filename>~/.mplayer/config</span> like so:</p></div><div class="literalblock programlisting"><div class=content><pre>vo=xv
fs=yes
zoom=yes</pre></div></div><div class=paragraph><p><code>mplayer</code> can be used to rip a DVD title to a <span class=filename>.vob</span>. To dump the second title from a DVD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd</span></code></pre></div></div><div class=paragraph><p>The output file, <span class=filename>out.vob</span>, will be in MPEG format.</p></div><div class=paragraph><p>Anyone wishing to obtain a high level of expertise with UNIX™ video should consult <a href=http://www.mplayerhq.hu/DOCS/>mplayerhq.hu/DOCS</a> as it is technically informative. This documentation should be considered as required reading before submitting any bug reports.</p></div><div class=paragraph><p>Before using <code>mencoder</code>, it is a good idea to become familiar with the options described at <a href=http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html>mplayerhq.hu/DOCS/HTML/en/mencoder.html</a>. There are innumerable ways to improve quality, lower bitrate, and change formats, and some of these options may make the difference between good or bad performance. Improper combinations of command line options can yield output files that are unplayable even by <code>mplayer</code>.</p></div><div class=paragraph><p>Here is an example of a simple copy:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> copy <span class=nt>-ovc</span> copy <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>To rip to a file, use <code>-dumpfile</code> with <code>mplayer</code>.</p></div><div class=paragraph><p>To convert <span class=filename>input.avi</span> to the MPEG4 codec with MPEG3 audio encoding, first install the <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a> port. Due to licensing restrictions, a package is not available. Once installed, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> mp3lame <span class=nt>-lameopts</span> <span class=nv>br</span><span class=o>=</span>192 <span class=se>\</span>
	 <span class=nt>-ovc</span> lavc <span class=nt>-lavcopts</span> <span class=nv>vcodec</span><span class=o>=</span>mpeg4:vhq <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>This will produce output playable by applications such as <code>mplayer</code> and <code>xine</code>.</p></div><div class=paragraph><p><span class=filename>input.avi</span> can be replaced with <code>dvd://1 -dvd-device /dev/dvd</code> and run as <code>root</code> to re-encode a DVD title directly. Since it may take a few tries to get the desired result, it is recommended to instead dump the title to a file and to work on the file.</p></div></div><div class=sect4><h5 id=video-xine>7.4.2.2. xine 影像播放器<a class=anchor href=#video-xine></a></h5><div class=paragraph><p>xine is a video player with a reusable base library and a modular executable which can be extended with plugins. It can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xine/>multimedia/xine</a> package or port.</p></div><div class=paragraph><p>In practice, xine requires either a fast CPU with a fast video card, or support for the XVideo extension. The xine video player performs best on XVideo interfaces.</p></div><div class=paragraph><p>By default, the xine player starts a graphical user interface. The menus can then be used to open a specific file.</p></div><div class=paragraph><p>Alternatively, xine may be invoked from the command line by specifying the name of the file to play:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xine <span class=nt>-g</span> <span class=nt>-p</span> mymovie.avi</code></pre></div></div><div class=paragraph><p>Refer to <a href=http://www.xine-project.org/faq>xine-project.org/faq</a> for more information and troubleshooting tips.</p></div></div><div class=sect4><h5 id=video-ports-transcode>7.4.2.3. Transcode 工具<a class=anchor href=#video-ports-transcode></a></h5><div class=paragraph><p>Transcode provides a suite of tools for re-encoding video and audio files. Transcode can be used to merge video files or repair broken files using command line tools with stdin/stdout stream interfaces.</p></div><div class=paragraph><p>In FreeBSD, Transcode can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/transcode/>multimedia/transcode</a> package or port. Many users prefer to compile the port as it provides a menu of compile options for specifying the support and codecs to compile in. If an option is not selected, Transcode will not be able to encode that format. Use the arrow keys and spacebar to select the required formats. When finished, press <kbd>Enter</kbd> to continue the port compile and installation.</p></div><div class=paragraph><p>This example demonstrates how to convert a DivX file into a PAL MPEG-1 file (PAL VCD):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% transcode <span class=nt>-i</span> input.avi <span class=nt>-V</span> <span class=nt>--export_prof</span> vcd-pal <span class=nt>-o</span> output_vcd
% mplex <span class=nt>-f</span> 1 <span class=nt>-o</span> output_vcd.mpg output_vcd.m1v output_vcd.mpa</code></pre></div></div><div class=paragraph><p>The resulting MPEG file, <span class=filename>output_vcd.mpg</span>, is ready to be played with MPlayer. The file can be burned on a CD media to create a video CD using a utility such as <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/vcdimager/>multimedia/vcdimager</a> or <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a>.</p></div><div class=paragraph><p>In addition to the manual page for <code>transcode</code>, refer to <a href=http://www.transcoding.org/cgi-bin/transcode>transcoding.org/cgi-bin/transcode</a> for further information and examples.</p></div></div></div></div><div class=sect2><h3 id=tvcard>7.5. 電視卡<a class=anchor href=#tvcard></a></h3><div class=paragraph><p>電視卡 (TV card) 可以讓您用電腦來看無線、有線電視節目。許多卡都是透過 RCA 或 S-video 輸入端子來接收視訊，而且有些卡還可接收 FM 廣播的功能。</p></div><div class=paragraph><p>FreeBSD 可透過 <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> 驅動程式，來支援 PCI 介面的電視卡，只要這些卡使用的是 Brooktree Bt848/849/878/879 或 Conexant CN-878/Fusion 878a 視訊擷取晶片。此外，要再確認哪些卡上所附的選台功能是否有支援，可以參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> 說明，以查看所支援的硬體清單。</p></div><div class=sect3><h4 id=_載入驅動程式>7.5.1. 載入驅動程式<a class=anchor href=#_載入驅動程式></a></h4><div class=paragraph><p>要用電視卡的話，就要載入 <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> 驅動程式，這個可以透過在 <span class=filename>/boot/loader.conf</span> 檔加上下面這一行就可以了：</p></div><div class="literalblock programlisting"><div class=content><pre>bktr_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>或者可以將電視卡支援靜態編譯到自訂的核心當中，若要這麼做則可在自訂核心設定檔加入以下行：</p></div><div class="literalblock programlisting"><div class=content><pre>device	 bktr
device	iicbus
device	iicbb
device	smbus</pre></div></div><div class=paragraph><p>之所以要加上這些額外的驅動程式，是因為卡的各組成部分都是透過 I2C 匯流排而相互連接的。接下來，請編譯、安裝新的核心 。</p></div><div class=paragraph><p>要測試調諧器 (Tuner) 是否被正確的偵測，請先重新啟動系統。電視卡應該會出現在開機訊息檔中，如同此範例：</p></div><div class="literalblock programlisting"><div class=content><pre>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</pre></div></div><div class=paragraph><p>該訊息會依硬體不同而有所不同。若必要，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 系統偵測的參數或者自訂核心設定選項。例如要強制使用 Philips SECAM 調諧器則可加入下列行至自訂核心設定檔：</p></div><div class="literalblock programlisting"><div class=content><pre>options OVERRIDE_TUNER=6</pre></div></div><div class=paragraph><p>或使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.bt848.tuner=6</span></code></pre></div></div><div class=paragraph><p>請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> 查看 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 可用的參數說明及核心選項。</p></div></div><div class=sect3><h4 id=_好用的應用程式>7.5.2. 好用的應用程式<a class=anchor href=#_好用的應用程式></a></h4><div class=paragraph><p>To use the TV card, install one of the following applications:</p></div><div class=ulist><ul><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/fxtv/>multimedia/fxtv</a> provides TV-in-a-window and image/audio/video capture capabilities.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xawtv/>multimedia/xawtv</a> is another TV application with similar features.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/xmradio/>audio/xmradio</a> provides an application for using the FM radio tuner of a TV card.</p></li></ul></div><div class=paragraph><p>More applications are available in the FreeBSD Ports Collection.</p></div></div><div class=sect3><h4 id=_疑難排解>7.5.3. 疑難排解<a class=anchor href=#_疑難排解></a></h4><div class=paragraph><p>If any problems are encountered with the TV card, check that the video capture chip and the tuner are supported by <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> and that the right configuration options were used. For more support or to ask questions about supported TV cards, refer to the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-multimedia>freebsd-multimedia</a> mailing list.</p></div></div></div><div class=sect2><h3 id=mythtv>7.6. MythTV<a class=anchor href=#mythtv></a></h3><div class=paragraph><p>MythTV is a popular, open source Personal Video Recorder (PVR) application. This section demonstrates how to install and setup MythTV on FreeBSD. Refer to <a href=http://www.mythtv.org/wiki/>mythtv.org/wiki</a> for more information on how to use MythTV.</p></div><div class=paragraph><p>MythTV requires a frontend and a backend. These components can either be installed on the same system or on different machines.</p></div><div class=paragraph><p>The frontend can be installed on FreeBSD using the <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv-frontend/>multimedia/mythtv-frontend</a> package or port. Xorg must also be installed and configured as described in <a href=./#x11>X Window 系統</a>. Ideally, this system has a video card that supports X-Video Motion Compensation (XvMC) and, optionally, a Linux Infrared Remote Control (LIRC)-compatible remote.</p></div><div class=paragraph><p>To install both the backend and the frontend on FreeBSD, use the <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv/>multimedia/mythtv</a> package or port. A MySQL™ database server is also required and should automatically be installed as a dependency. Optionally, this system should have a tuner card and sufficient storage to hold recorded data.</p></div><div class=sect3><h4 id=_硬體>7.6.1. 硬體<a class=anchor href=#_硬體></a></h4><div class=paragraph><p>MythTV uses Video for Linux (V4L) to access video input devices such as encoders and tuners. In FreeBSD, MythTV works best with USB DVB-S/C/T cards as they are well supported by the <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/webcamd/>multimedia/webcamd</a> package or port which provides a V4L userland application. Any Digital Video Broadcasting (DVB) card supported by webcamd should work with MythTV. A list of known working cards can be found at <a href=https://wiki.freebsd.org/WebcamCompat>wiki.freebsd.org/WebcamCompat</a>. Drivers are also available for Hauppauge cards in the <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/pvr250/>multimedia/pvr250</a> and <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/pvrxxx/>multimedia/pvrxxx</a> ports, but they provide a non-standard driver interface that does not work with versions of MythTV greater than 0.23. Due to licensing restrictions, no packages are available and these two ports must be compiled.</p></div><div class=paragraph><p>The <a href=https://wiki.freebsd.org/HTPC>wiki.freebsd.org/HTPC</a> page contains a list of all available DVB drivers.</p></div></div><div class=sect3><h4 id=_設定_mythtv_後端>7.6.2. 設定 MythTV 後端<a class=anchor href=#_設定_mythtv_後端></a></h4><div class=paragraph><p>要使用 Binary 套件安裝 MythTV 可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mythtv</span></code></pre></div></div><div class=paragraph><p>或從 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/multimedia/mythtv</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>Once installed, set up the MythTV database:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mysql -uroot -p &lt; /usr/local/shared/mythtv/database/mc.sql</span></code></pre></div></div><div class=paragraph><p>Then, configure the backend:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mythtv-setup</span></code></pre></div></div><div class=paragraph><p>Finally, start the backend:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc mythbackend_enable=yes</span>
<span class=c># service mythbackend start</span></code></pre></div></div></div></div><div class=sect2><h3 id=scanners>7.7. 影像掃描器<a class=anchor href=#scanners></a></h3><div class=paragraph><p>In FreeBSD, access to image scanners is provided by SANE (Scanner Access Now Easy), which is available in the FreeBSD Ports Collection. SANE will also use some FreeBSD device drivers to provide access to the scanner hardware.</p></div><div class=paragraph><p>FreeBSD supports both SCSI and USB scanners. Depending upon the scanner interface, different device drivers are required. Be sure the scanner is supported by SANE prior to performing any configuration. Refer to <a href=http://www.sane-project.org/sane-supported-devices.html>http://www.sane-project.org/sane-supported-devices.html</a> for more information about supported scanners.</p></div><div class=paragraph><p>This chapter describes how to determine if the scanner has been detected by FreeBSD. It then provides an overview of how to configure and use SANE on a FreeBSD system.</p></div><div class=sect3><h4 id=scanners-kernel-usb>7.7.1. 檢查掃描器<a class=anchor href=#scanners-kernel-usb></a></h4><div class=paragraph><p>The <span class=filename>GENERIC</span> kernel includes the device drivers needed to support USB scanners. Users with a custom kernel should ensure that the following lines are present in the custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device usb
device uhci
device ohci
device ehci</pre></div></div><div class=paragraph><p>To determine if the USB scanner is detected, plug it in and use <code>dmesg</code> to determine whether the scanner appears in the system message buffer. If it does, it should display a message similar to this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ugen0.2: &lt;EPSON&gt; at usbus0</code></pre></div></div><div class=paragraph><p>In this example, an EPSON Perfection™ 1650 USB scanner was detected on <span class=filename>/dev/ugen0.2</span>.</p></div><div class=paragraph><p>If the scanner uses a SCSI interface, it is important to know which SCSI controller board it will use. Depending upon the SCSI chipset, a custom kernel configuration file may be needed. The <span class=filename>GENERIC</span> kernel supports the most common SCSI controllers. Refer to <span class=filename>/usr/src/sys/conf/NOTES</span> to determine the correct line to add to a custom kernel configuration file. In addition to the SCSI adapter driver, the following lines are needed in a custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus
device pass</pre></div></div><div class=paragraph><p>Verify that the device is displayed in the system message buffer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</code></pre></div></div><div class=paragraph><p>If the scanner was not powered-on at system boot, it is still possible to manually force detection by performing a SCSI bus scan with <code>camcontrol</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol rescan all</span>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</code></pre></div></div><div class=paragraph><p>The scanner should now appear in the SCSI devices list:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 <span class=o>(</span>pass0,da0<span class=o>)</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 <span class=o>(</span>pass1,da1<span class=o>)</span>
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 <span class=o>(</span>pass3<span class=o>)</span>
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 <span class=o>(</span>pass2,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=scsi&amp;sektion=4&amp;format=html">scsi(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a> for more details about SCSI devices on FreeBSD.</p></div></div><div class=sect3><h4 id=_sane_設定>7.7.2. SANE 設定<a class=anchor href=#_sane_設定></a></h4><div class=paragraph><p>The SANE system is split in two parts: the backends (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a>) and the frontends (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-frontends/>graphics/sane-frontends</a> or <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xsane/>graphics/xsane</a>). The backends provide access to the scanner. Refer to <a href=http://www.sane-project.org/sane-supported-devices.html>http://www.sane-project.org/sane-supported-devices.html</a> to determine which backend supports the scanner. The frontends provide the graphical scanning interface. <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-frontends/>graphics/sane-frontends</a> installs xscanimage while <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xsane/>graphics/xsane</a> installs xsane.</p></div><div class=paragraph><p>要由 Binary 套件安裝這兩個部份可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xsane sane-frontends</span></code></pre></div></div><div class=paragraph><p>或由 Port 套件集安裝</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/sane-frontends</span>
<span class=c># make install clean</span>
<span class=c># cd /usr/ports/graphics/xsane</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>After installing the <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a> port or package, use <code>sane-find-scanner</code> to check the scanner detection by the SANE system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sane-find-scanner -q</span>
found SCSI scanner <span class=s2>&#34;AGFA SNAPSCAN 600 1.10&#34;</span> at /dev/pass3</code></pre></div></div><div class=paragraph><p>The output should show the interface type of the scanner and the device node used to attach the scanner to the system. The vendor and the product model may or may not appear.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Some USB scanners require firmware to be loaded. Refer to sane-find-scanner(1) and sane(7) for details.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Next, check if the scanner will be identified by a scanning frontend. The SANE backends include <code>scanimage</code> which can be used to list the devices and perform an image acquisition. Use <code>-L</code> to list the scanner devices. The first example is for a SCSI scanner and the second is for a USB scanner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=sb>`</span>snapscan:/dev/pass3<span class=s1>&#39; is a AGFA SNAPSCAN 600 flatbed scanner
# scanimage -L
device &#39;</span>epson2:libusb:/dev/usb:/dev/ugen0.2<span class=s1>&#39; is a Epson GT-8200 flatbed scanner</span></code></pre></div></div><div class=paragraph><p>In this second example, <code>'epson2:libusb:/dev/usb:/dev/ugen0.2'</code> is the backend name (<code>epson2</code>) and <code>/dev/ugen0.2</code> is the device node used by the scanner.</p></div><div class=paragraph><p>If <code>scanimage</code> is unable to identify the scanner, this message will appear:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged <span class=k>in</span>, turned on and detected by the
sane-find-scanner tool <span class=o>(</span><span class=k>if </span>appropriate<span class=o>)</span><span class=nb>.</span> Please <span class=nb>read </span>the documentation
which came with this software <span class=o>(</span>README, FAQ, manpages<span class=o>)</span>.</code></pre></div></div><div class=paragraph><p>If this happens, edit the backend configuration file in <span class=filename>/usr/local/etc/sane.d/</span> and define the scanner device used. For example, if the undetected scanner model is an EPSON Perfection™ 1650 and it uses the <code>epson2</code> backend, edit <span class=filename>/usr/local/etc/sane.d/epson2.conf</span>. When editing, add a line specifying the interface and the device node used. In this case, add the following line:</p></div><div class="literalblock programlisting"><div class=content><pre>usb /dev/ugen0.2</pre></div></div><div class=paragraph><p>Save the edits and verify that the scanner is identified with the right backend name and the device node:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=s1>&#39;epson2:libusb:/dev/usb:/dev/ugen0.2&#39;</span> is a Epson GT-8200 flatbed scanner</code></pre></div></div><div class=paragraph><p>Once <code>scanimage -L</code> sees the scanner, the configuration is complete and the scanner is now ready to use.</p></div><div class=paragraph><p>While <code>scanimage</code> can be used to perform an image acquisition from the command line, it is often preferable to use a graphical interface to perform image scanning. The <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-frontends/>graphics/sane-frontends</a> package or port installs a simple but efficient graphical interface, xscanimage.</p></div><div class=paragraph><p>Alternately, xsane, which is installed with the <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xsane/>graphics/xsane</a> package or port, is another popular graphical scanning frontend. It offers advanced features such as various scanning modes, color correction, and batch scans. Both of these applications are usable as a GIMP plugin.</p></div></div><div class=sect3><h4 id=_掃描器權限>7.7.3. 掃描器權限<a class=anchor href=#_掃描器權限></a></h4><div class=paragraph><p>In order to have access to the scanner, a user needs read and write permissions to the device node used by the scanner. In the previous example, the USB scanner uses the device node <span class=filename>/dev/ugen0.2</span> which is really a symlink to the real device node <span class=filename>/dev/usb/0.2.0</span>. The symlink and the device node are owned, respectively, by the <code>wheel</code> and <code>operator</code> groups. While adding the user to these groups will allow access to the scanner, it is considered insecure to add a user to <code>wheel</code>. A better solution is to create a group and make the scanner device accessible to members of this group.</p></div><div class=paragraph><p>This example creates a group called <code><em>usb</em></code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd usb</span></code></pre></div></div><div class=paragraph><p>Then, make the <span class=filename>/dev/ugen0.2</span> symlink and the <span class=filename>/dev/usb/0.2.0</span> device node accessible to the <code>usb</code> group with write permissions of <code>0660</code> or <code>0664</code> by adding the following lines to <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb</pre></div></div><div class=paragraph><p>Finally, add the users to <code><em>usb</em></code> in order to allow access to the scanner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod usb -m joe</span></code></pre></div></div><div class=paragraph><p>For more details refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=kernelconfig>Chapter 8. 設定 FreeBSD 核心<a class=anchor href=#kernelconfig></a></h2><div class=sectionbody><div class=sect2><h3 id=kernelconfig-synopsis>8.1. 概述<a class=anchor href=#kernelconfig-synopsis></a></h3><div class=paragraph><p>核心 (Kernel) 是 FreeBSD 作業系統最重要的部份之一。它負責記憶體管理、安全控管、網路、硬碟存取等等。 儘管目前 FreeBSD 大多可以用動態設定， 但有時仍需要設定並編譯自訂的核心。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>何時需要編譯自訂核心。</p></li><li><p>如何取得硬體資訊。</p></li><li><p>如何量身訂做核心設定檔。</p></li><li><p>如何使用核心設定檔來建立並編譯新的核心。</p></li><li><p>如何安裝新的核心。</p></li><li><p>發生錯誤時如何排除問題。</p></li></ul></div><div class=paragraph><p>所有在本章所列出的指令均應以 <code>root</code> 來執行。</p></div></div><div class=sect2><h3 id=kernelconfig-custom-kernel>8.2. 為何要編譯自訂的核心?<a class=anchor href=#kernelconfig-custom-kernel></a></h3><div class=paragraph><p>早期的 FreeBSD 的核心 (Kernel) 被戲稱為 “巨石”。因為當時的核心是一個非常大的程式，且只支援固定的硬體裝置，如果您想改變核心的設定，就必須編譯一個新核心並重新開機，才能使用。</p></div><div class=paragraph><p>現今，大多數在 FreeBSD 核心的功能已採用模組 (Module) 的方式包裝，並可依需求動態從核心載入或卸載。 這使得執行中的核心能夠快速適應新硬體環境並在核心開啟新的功能，這就是所謂模組化核心 (Modular Kernel)。</p></div><div class=paragraph><p>儘管如此，還是有一些功能因使用到靜態的核心設定須要編譯，因為這些功能與核心緊密結合，無法將做成可動態載入的模組。且部份強調安全性的環境會盡量避免載入與卸載核心模組，且只要將需要的功能靜態的編譯到核心當中。</p></div><div class=paragraph><p>編譯自訂的核心幾乎是每位進階的 BSD 使用者所必須經歷的過程。儘管這項工作可能比較耗時，但在 FreeBSD 的使用上會有許多好處。 跟必須支援大多數各式硬體的 <span class=filename>GENERIC</span> 核心相比的話， 自訂的核心可以更『體貼』，只支援『自己硬體』的部分就好。 自訂核心有許多項優點，如：</p></div><div class=ulist><ul><li><p>加速開機，因為自訂的核心只需要偵測您系統上存在的硬體，所以讓啟動所花的過程更流暢快速。</p></li><li><p>減少記憶體使用，自訂的核心通常會比 <span class=filename>GENERIC</span> 核心使用更少的記憶體，這很重要，因為核心必須一直存放在實體記憶體內，會讓其他應用程式無法使用。因此，自訂核心對於記憶體較小的系統來說，發揮很大的作用。</p></li><li><p>支援額外的硬體，自訂的核心可以增加一些 <span class=filename>GENERIC</span> 核心沒有提供的硬體支援。</p></li></ul></div><div class=paragraph><p>在編譯自訂核心之前，請思考要這麼做的原因，若是因為需要特定硬體的支援，很可能已有既有的模組可以使用。</p></div><div class=paragraph><p>核心模組會放在 <span class=filename>/boot/kernel</span> 並且可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> 動態載入到執行中的核心。大部份的核心驅動程式都有可載入的模組與操作手冊。例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> 無線乙太網路驅動程式在其操作手冊有以下資訊：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Alternatively, to load the driver as a module at boot <span class=nb>time</span>, place the
following line <span class=k>in </span>loader.conf<span class=o>(</span>5<span class=o>)</span>:

    <span class=nv>if_ath_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>加入 <code>if_ath_load="YES"</code> 到 <span class=filename>/boot/loader.conf</span> 會於開機期間自動載入這個模組。</p></div><div class=paragraph><p>部份情況在 <span class=filename>/boot/kernel</span> 會沒有相關的模組，這對於某些子系統大多是真的。</p></div></div><div class=sect2><h3 id=kernelconfig-devices>8.3. 偵測系統硬體<a class=anchor href=#kernelconfig-devices></a></h3><div class=paragraph><p>在編輯核心設定檔之前，建議先調查清楚機器各項硬體資訊。在雙作業系統的環境，也可透過其他作業系統來了解目前機器上的硬體資訊。 舉例來說，Microsoft™ 的 裝置管理員 (Device Manager) 內會有目前已安裝的硬體資訊。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>某些版本的 Microsoft™ Windows™ 會有系統 (System) 圖示可用來進入 裝置管理員。</p></div></td></tr></tbody></table></div><div class=paragraph><p>若 FreeBSD 是唯一安裝的作業系統，則可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> 來查看開時時系統偵測到的硬體資訊 。FreeBSD 上大多硬體驅動程式都有操作手冊會列出支援的硬體。例如，以下幾行是說 <a href="https://man.freebsd.org/cgi/man.cgi?query=psm&amp;sektion=4&amp;format=html">psm(4)</a> 驅動程式偵測到了一隻滑鼠：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: <span class=o>[</span>GIANT-LOCKED]
psm0: <span class=o>[</span>ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</code></pre></div></div><div class=paragraph><p>因為該硬體存在，此驅動程式便不應該從自訂核心設定檔中移除。</p></div><div class=paragraph><p>若 <code>dmesg</code> 輸出的結果未顯示開機偵測硬體的部份，則可改閱讀 <span class=filename>/var/run/dmesg.boot</span> 檔案的內容。</p></div><div class=paragraph><p>另外，也可以透過 <a href="https://man.freebsd.org/cgi/man.cgi?query=pciconf&amp;sektion=8&amp;format=html">pciconf(8)</a> 工具可用來查詢硬體資訊，該工具會列出更詳細的硬體資訊如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pciconf <span class=nt>-lv</span>
ath0@pci0:3:0:0:        <span class=nv>class</span><span class=o>=</span>0x020000 <span class=nv>card</span><span class=o>=</span>0x058a1014 <span class=nv>chip</span><span class=o>=</span>0x1014168c <span class=nv>rev</span><span class=o>=</span>0x01 <span class=nv>hdr</span><span class=o>=</span>0x00
    vendor     <span class=o>=</span> <span class=s1>&#39;Atheros Communications Inc.&#39;</span>
    device     <span class=o>=</span> <span class=s1>&#39;AR5212 Atheros AR5212 802.11abg wireless&#39;</span>
    class      <span class=o>=</span> network
    subclass   <span class=o>=</span> ethernet</code></pre></div></div><div class=paragraph><p>以上輸出資訊說明 <span class=filename>ath</span> 驅動程式已經找到一個無線乙太網路裝置。</p></div><div class=paragraph><p>在 <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> 指令加上 <code>-k</code> 旗標可提供有用的資訊，例如，這可列出有包含指定裝置品牌或名稱的手冊頁面清單：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># man -k Atheros</span>
ath<span class=o>(</span>4<span class=o>)</span>                   - Atheros IEEE 802.11 wireless network driver
ath_hal<span class=o>(</span>4<span class=o>)</span>               - Atheros Hardware Access Layer <span class=o>(</span>HAL<span class=o>)</span></code></pre></div></div><div class=paragraph><p>準備好硬體清單之後，參考該清單來確認已安裝的硬體驅動程式在編輯自訂核心設定時沒有被移除。</p></div></div><div class=sect2><h3 id=kernelconfig-config>8.4. 設定檔<a class=anchor href=#kernelconfig-config></a></h3><div class=paragraph><p>為了要建立自訂核心設定檔並編譯自訂核心，必須先安裝完整的 FreeBSD 原始碼樹。</p></div><div class=paragraph><p>若 <span class=filename>/usr/src/</span> 目錄不存在或者是空的，代表尚未安裝。原始碼可以使用 Subversion 並依據 <a href=./#svn>使用 Subversion</a> 中的操作說明來安裝。</p></div><div class=paragraph><p>完成原始碼安裝完成後，需檢查 <span class=filename>/usr/src/sys</span> 內的檔案。該目錄內包含數個子目錄，這些子目錄代表著支援的硬體架構 (Architecture) 如下：<span class=filename>amd64</span>, <span class=filename>i386</span>, <span class=filename>ia64</span>, <span class=filename>powerpc</span> 以及 <span class=filename>sparc64</span>。在指定架構目錄中的內容只對該架構有效，其餘部份的程式碼與硬體架構無關，可通用所有平台。每個支援的硬體架構中會有 <span class=filename>conf</span> 子目錄，裡面含有供該架構使用的 <span class=filename>GENERIC</span> 核心設定檔。</p></div><div class=paragraph><p>請不要直接對 <span class=filename>GENERIC</span> 檔案做編輯。複製該檔案為另一個名稱，並對複製出來的檔案做編輯，習慣上檔名會全部使用大寫字元。當維護多台安裝不同的硬體的 FreeBSD 機器時，將檔名後方加上機器的主機名稱 (Host name) 是個不錯的方法。以下範例使用 <code>amd64</code> 架構的 <span class=filename>GENERIC</span> 設定檔建立了一個複本名稱為 <span class=filename>MYKERNEL</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># cp GENERIC MYKERNEL</span></code></pre></div></div><div class=paragraph><p>現在可以使用任何 ASCII 文字編輯器來自訂 <span class=filename>MYKERNEL</span>。預設的編輯器為 vi，在 FreeBSD 也內建一個易於初學者使用的編輯器叫做 ee。</p></div><div class=paragraph><p>核心設定檔的格式很簡單，每一行會含有代表裝置 (Device) 或子系統 (Subsystem) 的關鍵字、參數以及簡短的說明。任何在 <code><mark></mark></code> 符號之後的文字會被當做註解並且略過。要移除核心對某個裝置或子系統的支援，僅需要在代表該裝置或子系統的行前加上 <code></code> 符號。請不要在您還不了解用途的行前加上或移除 <code>#</code> 符號。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>移除對裝置或選項的支援很容易會造成核心損壞。例如，若從核心設定檔 <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a> 驅動程式，那麼使用 ATA 磁碟驅動程式的系統便會無法開機。因此當您不確定時，請在核心保留該項目的支援。</p></div></td></tr></tbody></table></div><div class=paragraph><p>除了在設定檔中提供的簡短說明之外，尚有其他的說明在 <span class=filename>NOTES</span> 檔案中，可在與該架構 <span class=filename>GENERIC</span> 相同的目錄底下找到。要查看所有架構通用的選項，請參考 <span class=filename>/usr/src/sys/conf/NOTES</span>。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>當完成自訂的核心設定檔，請備份到 <span class=filename>/usr/src</span> 位置之外。</p></div><div class=paragraph><p>或者，將核心設定檔放在其他地方，然後建立一個符號連結 (Symbolic link) 至該檔案：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># mkdir /root/kernels</span>
<span class=c># cp GENERIC /root/kernels/MYKERNEL</span>
<span class=c># ln -s /root/kernels/MYKERNEL</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>設定檔中可以使用 <code>include</code> 指令 (Directive)。該指令可以引用其他設定檔到目前的設定檔，這讓只需根據現有檔案設定做些微調整時更簡單。若只有少量的額外選項或驅動程式需要設定，該指令可引用 <span class=filename>GENERIC</span> 並設定額外增加的選項，如範例所示：</p></div><div class="literalblock programlisting"><div class=content><pre>include GENERIC
ident MYKERNEL

options         IPFIREWALL
options         DUMMYNET
options         IPFIREWALL_DEFAULT_TO_ACCEPT
options         IPDIVERT</pre></div></div><div class=paragraph><p>使用此方法，設定檔只含有與 <span class=filename>GENERIC</span> 核心不同的部份。當升級有新功能加入 <span class=filename>GENERIC</span> 時，也可一併引用，除非特別使用 <code>nooptions</code> 或 <code>nodevice</code> 選項來排除設定。更詳細的設定檔指令及其說明可在 <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a> 找到。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>要產生含有所有可用選項的設定檔，可以 <code>root</code> 執行以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/arch/conf &amp;&amp; make LINT</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kernelconfig-building>8.5. 編譯與安裝自訂核心<a class=anchor href=#kernelconfig-building></a></h3><div class=paragraph><p>完成自訂設定檔的編輯並儲存之後，便可依據以下步驟編譯核心的原始碼：</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: 編譯核心</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>切換至此目錄：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div></li><li><p>指定自訂核心設定檔的名稱來編譯新的核心：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=MYKERNEL</span></code></pre></div></div></li><li><p>安裝使用指定核心設定檔所編譯的新核心。此指令將會複製新核心到 <span class=filename>/boot/kernel/kernel</span> 並將舊核心備份到 <span class=filename>/boot/kernel.old/kernel</span>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make installkernel KERNCONF=MYKERNEL</span></code></pre></div></div></li><li><p>關機並重新開機載入新的核心，若發生錯誤請參考 <a href=./#kernelconfig-noboot>無法使用核心開機</a>。</p></li></ol></div></div></div><div class=paragraph><p>預設在自訂核心編譯完成後，所有核心模組也同被重新編譯。要快速更新核心或只編譯自訂的模組，需在開始編譯之前先編輯 <span class=filename>/etc/make.conf</span>。</p></div><div class=paragraph><p>例如，使用以下變數可指定要編譯的模組清單來替代預設編譯所有模組的設定：</p></div><div class="literalblock programlisting"><div class=content><pre>MODULES_OVERRIDE = linux acpi</pre></div></div><div class=paragraph><p>或者，可使用以下變數來從編譯程序中排除要編譯的模組：</p></div><div class="literalblock programlisting"><div class=content><pre>WITHOUT_MODULES = linux acpi sound</pre></div></div><div class=paragraph><p>尚有其他可用的變數，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a> 取得詳細資訊。</p></div></div><div class=sect2><h3 id=kernelconfig-trouble>8.6. 如果發生錯誤<a class=anchor href=#kernelconfig-trouble></a></h3><div class=paragraph><p>當編譯自訂核心時可能發生以下四種類型的問題：</p></div><div class=dlist><dl><dt class=hdlist1><code>config</code> 失敗</dt><dd><p>若 <code>config</code> 失敗，會列出不正確的行號。使用以下訊息為例子，需要與 <span class=filename>GENERIC</span> 或 <span class=filename>NOTES</span> 比對來確認第 17 行輸入的內容正確：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>config: line 17: syntax error</code></pre></div></div></dd><dt class=hdlist1><code>make</code> 失敗</dt><dd><p>若 <code>make</code> 失敗，通常是因為核心設定檔未提供足夠的資訊讓 <code>config</code> 找到問題。請仔細檢查設定檔，若仍不清楚問題，請寄發電子郵件給 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>FreeBSD general questions mailing list</a> 並附上核心設定檔。</p></dd></dl></div><div id=kernelconfig-noboot class=dlist><dl><dt class=hdlist1>無法使用核心開機</dt><dd><p>若新核心無法開機或無法辨識裝置並不要恐慌！幸好，FreeBSD 有良好的機制可以從不相容的核心復原。只需要在 FreeBSD 開機載入程式 (Boot loader) 選擇要用來開機的核心便可，當系統開機選單出現時選擇 "Escape to a loader prompt" 選項，並在指令提示後輸入 <code>boot <em>kernel.old</em></code> 或替換為任何其他已經知道可以正常開機的核心名稱。</p><div class=paragraph><p>使用好的核心開機之後，檢查設定檔並嘗試再編譯一次。<span class=filename>/var/log/messages</span> 是有用的資源，它在每次成功開機時會記錄核心訊息。同樣的，<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> 也會印出自本次開機後的核心訊息。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>在排除核心問題時，請確定留有 <span class=filename>GENERIC</span> 的複本，或者其他已知可以運作的核心，並使用不同的名稱來確保下次編譯時不會被刪除，這很重要，因此每當新的核心被安裝之後，<span class=filename>kernel.old</span> 都會被最後安裝的核心覆寫，有可能會無法開機。盡快，透過重新命名將可運作的核心目錄移動到目前運作的核心目錄：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /boot/kernel /boot/kernel.bad</span>
<span class=c># mv /boot/kernel.good /boot/kernel</span></code></pre></div></div></td></tr></tbody></table></div></dd><dt class=hdlist1>核心可運作，但 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 無法運作</dt><dd><p>若核心版本與系統工具所編譯的版本不同，例如，有一個核心使用 -CURRENT 的原始碼編譯並安裝在 -RELEASE 的系統上，許多系統狀態指令如 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 及 <a href="https://man.freebsd.org/cgi/man.cgi?query=vmstat&amp;sektion=8&amp;format=html">vmstat(8)</a> 將會無法運作。要修正此問題，請使用與核心相同版本的原始碼樹 (Source tree) <a href=./#makeworld>重新編譯並安裝 World</a>。使用與作業系統其他部份版本不同的核心永遠不會是個好主意。</p></dd></dl></div></div></div></div><div class=sect1><h2 id=printing>Chapter 9. 列印<a class=anchor href=#printing></a></h2><div class=sectionbody><div class=paragraph><p>儘管很多人試圖淘汰列印功能，但列印資訊到紙上仍是一個重要的功能。列印由兩個基本元件組成，包含了資料傳送到印表機的方式以及印表機可以理解的資料形式。</p></div><div class=sect2><h3 id=printing-quick-start>9.1. 快速開始<a class=anchor href=#printing-quick-start></a></h3><div class=paragraph><p>基本的列印功能可以快速設定完成，列印機必須能夠列印純 ASCII 文字。若要列印其他類型的檔案，請參考 <a href=#printing-lpd-filters>過濾器</a>。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>建立一個目錄來儲存要被列印的檔案：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /var/spool/lpd/lp</span>
<span class=c># chown daemon:daemon /var/spool/lpd/lp</span>
<span class=c># chmod 770 /var/spool/lpd/lp</span></code></pre></div></div></li><li><p>以 <code>root</code> 建立 <span class=filename>/etc/printcap</span> 內容如下：</p><div class="literalblock programlisting"><div class=content><pre>lp:\
	:lp=/dev/unlpt0:\  <i class=conum data-value=1></i><b>(1)</b>
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/lp:\
	:lf=/var/log/lpd-errs:</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>此行是針對連接到 USB 埠的印表機。連接到並列或 "印表器 (Printer)" 埠的印表機要使用：直接連接到網路的印表機要使用：替換 <em>network-printer-name</em> 為網路印表機的 DNS 主機名稱。</td></tr></tbody></table></div></li><li><p>編輯 <span class=filename>/etc/rc.conf</span> 加入下行來開啟 <code>lpd</code>：</p><div class="literalblock programlisting"><div class=content><pre>lpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>啟動服務：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service lpd start</span>
Starting lpd.</code></pre></div></div></li><li><p>測試列印：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># printf &#34;1. This printer can print.\n2. This is the second line.\n&#34; | lpr</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>若列印的兩行未從左邊界開始，而是呈現 "階梯狀 (Stairstep)"，請參考 <a href=#printing-lpd-filters-stairstep>避免在純文字印表機階梯狀列印</a>。</p></div></td></tr></tbody></table></div><div class=paragraph><p>現在可以使用 <code>lpr</code> 來列印文字檔，只要在指令列給序檔案名稱，或者將輸出使用管線符號 (Pipe) 傳送給 <code>lpr</code>。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr textfile.txt
% <span class=nb>ls</span> <span class=nt>-lh</span> | lpr</code></pre></div></div></li></ol></div></div></div></div><div class=sect2><h3 id=printing-connections>9.2. 印表機連線<a class=anchor href=#printing-connections></a></h3><div class=paragraph><p>印表機有許多方式可以連接到電腦，小型的桌面印表機會直接連接到電腦的 USB 埠，舊式的印表機會連接到並列 (Parallel) 或 "印表機 (Printer)" 埠，而有一部份印表機則是直接連接網路，讓印表機能夠給多台電腦共享使用，還有少部分印表機則是連接到較罕見的序列 (Serial) 埠。</p></div><div class=paragraph><p>FreeBSD 可以與這些類型的印表機溝通。</p></div><div id=printing-connections-usb class=dlist><dl><dt class=hdlist1>USB</dt><dd><p>USB 印表機可以連接到電腦上任何可用的 USB 埠。</p><div class=paragraph><p>當 FreeBSD 偵測到 USB 印表機，會建立兩個裝置項目：<span class=filename>/dev/ulpt0</span> 以及 <span class=filename>/dev/unlpt0</span>，傳送到兩者任一裝置的資料都會被轉發到印表機。在每個列印工作完成後 <span class=filename>ulpt0</span> 便會重設 USB 埠，重設 USB 埠可能會在部份印表機造成問題，因此通常可以改使用 <span class=filename>unlpt0</span> 裝置。<span class=filename>unlpt0</span> 不會重設 USB 埠。</p></div></dd></dl></div><div id=printing-connections-parallel class=dlist><dl><dt class=hdlist1>並列 (IEEE-1284)</dt><dd><p>並列埠裝置使用 <span class=filename>/dev/lpt0</span>，此裝置不論印表機是否連接上都會存在，它並不會自動偵測。</p><div class=paragraph><p>供應商已不再採用這種 "舊式" 連接埠，且有許多電腦甚至已沒有這種連接埠。可以用轉接器來連接並列印表機到 USB 埠，有了轉接器，並列印表機可以被當作 USB 印表機使用。有另一種稱作 <em>列印伺服器 (Print server)</em> 的裝置也可用來連接並列印表機到網路。</p></div></dd></dl></div><div id=printing-connections-serial class=dlist><dl><dt class=hdlist1>序列 (RS-232)</dt><dd><p>序列埠也是另一種舊式連接埠，已很少用在印表機上，除了某些特殊的應用外，纜線、接頭與需要的佈線方式依需求變化性很大。</p><div class=paragraph><p>內建在主機板的序列埠的序列裝置名稱為 <span class=filename>/dev/cuau0</span> 或 <span class=filename>/dev/cuau1</span>。也有序列 USB 轉接器可使用，而裝置的的名稱則會是 <span class=filename>/dev/cuaU0</span>。</p></div><div class=paragraph><p>要與序列印表機通訊必須知道數個通訊參數，其中最重要的是 <em>傳輸速率 (Baud rate)</em> 或 BPS (Bits Per Second) 以及 <em>同位檢查 (Parity)</em>。數值有數種，但一般序列印表機會使用 的傳輸速率是 9600 且無同位檢查。</p></div></dd></dl></div><div id=printing-connections-network class=dlist><dl><dt class=hdlist1>網路</dt><dd><p>網路印表機可直接連接到區域網路。</p><div class=paragraph><p>若印表機透過 DHCP 分配動態位址，則必須要知道 DNS 主機名稱，DNS 應動態更新來讓主機名稱能夠對應到正確的 IP 位址。指定網路印表機一個靜態的 IP 位址可避免這個問題。</p></div><div class=paragraph><p>大多數網路印表機可以認得使用 LPD 通訊協定所送出的列印工作，列印佇列 (Print queue) 的名稱也會在這時指定。部份印表機會依據使用的佇列來決定處理資料的方式，例如 <code>raw</code> 佇列會列印原始資料，而 <code>text</code> 佇列則會在純文字上增加換行符號 (Carriage return)。</p></div><div class=paragraph><p>大部份網路印表機也可列印直接傳送到埠號 9100 的資料。</p></div></dd></dl></div><div class=sect3><h4 id=printing-connections-summary>9.2.1. 摘要<a class=anchor href=#printing-connections-summary></a></h4><div class=paragraph><p>有線網路連線通常是安裝最簡單的方式，且可以提供快速的列印。若要直接連接到電腦，較建議使用 USB，由於較快速、簡單。並列連線仍然可以使用，但有纜線長度與速度上的限制。而序列連線則比較難設定，不同型號的纜線佈線方式不同，且通訊參數如傳輸速率及同位檢查增加了複雜性，所幸序列印表機並不多。</p></div></div></div><div class=sect2><h3 id=printing-pdls>9.3. 常見的頁面描述語言<a class=anchor href=#printing-pdls></a></h3><div class=paragraph><p>傳送給印表機的資料必須使用印表機能夠理解的語言，這些語言稱為頁面描述語言 (Page Description Languages) 或 PDL。</p></div><div id=print-pdls-ascii class=dlist><dl><dt class=hdlist1>ASCII</dt><dd><p>純 ASCII 文字是傳送資料到印表機最簡單的方式，一個字元對應一個要列印的文字：資料中的 <code>A</code> 會列印一個 <code>A</code> 在頁面。可以使用的格式非常少，沒有辦法選擇字型或者比例間距。強迫使用簡單的純 ASCII 為的是讓文字可以直接從電腦列印只需一點或甚至不需要編碼或轉譯，列印的結果可直接對應傳送的內容。</p><div class=paragraph><p>部份便宜印表機無法列印純 ASCII 文字，這讓這些印表機較難設定。</p></div></dd></dl></div><div id=print-pdls-postscript class=dlist><dl><dt class=hdlist1>PostScript™</dt><dd><p>PostScript™ 與 ASCII 幾乎相反，與簡單的文字不同，PostScript™ 程式語言有一套指令可以繪出最終所要的文件，可以使用不同的字型與圖形，但是，這樣強大的功能是有代價的，繪製頁面需要搛寫程式語言，通常這個程式語言會由應用程式產生，所以使用者是看不到的。</p><div class=paragraph><p>便宜的印表機有時會移除 PostScript™ 的相容性來節省成本。</p></div></dd></dl></div><div id=print-pdls-pcl class=dlist><dl><dt class=hdlist1>PCL (Printer Command Language)</dt><dd><p>PCL 由 ASCII 延伸而來，加入了跳脫序列 (Escape sequence) 來標示格式、選擇字型以及列印圖型。大部份印表機都支援 PCL5，少數支援較新的 PCL6 或 PCLXL，這些後來的版本是 PCL5 的超集合 (Superset)，並可以提供更快的列印速度。</p></dd></dl></div><div id=print-pdls-host-based class=dlist><dl><dt class=hdlist1>以主機為基礎 (Host-Based)</dt><dd><p>製造商可能會使用簡單的處理器和較小的記憶體來降低印表機的成本，這些印表機無法列印純文字，相反的，文字與圖形會先在機器上的驅動程式畫完後傳送到印表機。這些稱為<em>以主機為基礎 (Host-based)</em> 的印表機。</p><div class=paragraph><p>驅動程式與以主機為基礎的印表機通訊通常會透過專用或無文件的通訊協定，這讓這些印表機只能在最常用的作業系統上運作。</p></div></dd></dl></div><div class=sect3><h4 id=print-pdls-table>9.3.1. 轉換 PostScript™ 至其他 PDL<a class=anchor href=#print-pdls-table></a></h4><div class=paragraph><p>Port 套件集與 FreeBSD 工具集有許多可以處理 PostScript™ 輸出的應用程式，此表整理出了可轉換 PostScript™ 成其他常用 PDL 的工具：</p></div><table id=print-pdls-ps-to-other-tbl class="tableblock frame-none grid-all stretch"><caption class=title>表 8. 輸出 PDL 格式</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">輸出 PDL</th><th class="tableblock halign-left valign-top">產生由</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>PCL 或 PCL5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>單色使用 <code>-sDEVICE=ljet4</code>、彩色使用 <code>-sDEVICE=cljet5</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>PCLXL 或 PCL6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>單色使用 <code>-sDEVICE=pxlmono</code>、彩色使用 <code>-sDEVICE=pxlcolor</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ESC/P2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-sDEVICE=uniprint</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>XQX</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/foo2zjs/>print/foo2zjs</a></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table></div><div class=sect3><h4 id=print-pdls-summary>9.3.2. 摘要<a class=anchor href=#print-pdls-summary></a></h4><div class=paragraph><p>要可以列印最簡單的方式就是選擇支援 PostScript™ 的印表機，再來是支援 PCL 的印表機，有了 <a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a> 這些印表機也可像原生支援 PostScript™ 的印表機一般使用。有直接支援 PostScript™ 或 PCL 的印表機通常也會直接支援純 ASCII 文字檔案。</p></div><div class=paragraph><p>行列式印表機如同典型的噴墨式印表機通常不支援 PostScript™ 或 PCL，這種印表機通常可以列印純 ASCII 文字檔案。<a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a> 支援部份這種印表機使用的 PDL，不過要在這種印表機上列印完全以圖型為基礎的頁面通常會非常緩慢，由於需要傳送大量的資料並列印。</p></div><div class=paragraph><p>以主機為基礎的印表機通常較難設定，有些會因為用了專用的 PDL 而無法使用，盡可能避免使用這類的印表機。</p></div><div class=paragraph><p>有關各種 PDL 的介紹可至 <a href=http://www.undocprint.org/formats/page_description_languages class=bare>http://www.undocprint.org/formats/page_description_languages</a>。各種型號印表機所使用的特定 PDL 可至 <a href=http://www.openprinting.org/printers class=bare>http://www.openprinting.org/printers</a> 查詢。</p></div></div></div><div class=sect2><h3 id=printing-direct>9.4. 直接列印<a class=anchor href=#printing-direct></a></h3><div class=paragraph><p>對於偶爾列印，檔案可以直接傳送到印表機裝置，無需做任何設定。例如，要傳送一個名稱為 <span class=filename>sample.txt</span> 的檔案到 USB 印表機：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp sample.txt /dev/unlpt0</span></code></pre></div></div><div class=paragraph><p>要直接使用網路印表機列印需看該印表機支援的功能，但大多數會接受埠號 9100 的列印作業，可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=nc&amp;sektion=1&amp;format=html">nc(1)</a> 來完成。要使用 DNS 主機名稱為 <em>netlaser</em> 的印表機列印與上述相同的檔案可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nc netlaser 9100 &lt; sample.txt</span></code></pre></div></div></div><div class=sect2><h3 id=printing-lpd>9.5. LPD (行列式印表機 Daemon)<a class=anchor href=#printing-lpd></a></h3><div class=paragraph><p>在背景列印一個檔案稱作 <em>Spooling</em>，緩衝程式 (Spooler) 讓使用者能夠繼續執行電腦的其他程式而不需要等候印表機緩慢的完成列印工作。</p></div><div class=paragraph><p>FreeBSD 內含的緩衝程式 (Spooler) 稱作 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>，而列印工作會使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> 來提交。</p></div><div class=sect3><h4 id=printing-lpd-setup>9.5.1. 初始設定<a class=anchor href=#printing-lpd-setup></a></h4><div class=paragraph><p>建立要用來儲存列印工作的目錄、設定擁有關係以及權限來避免其他使用者可以檢視這些檔案的內容：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /var/spool/lpd/lp</span>
<span class=c># chown daemon:daemon /var/spool/lpd/lp</span>
<span class=c># chmod 770 /var/spool/lpd/lp</span></code></pre></div></div><div class=paragraph><p>印表機會定義在 <span class=filename>/etc/printcap</span>，每台印表機項目所包含的詳細資料有名稱、連接的接頭以及各種其他設定。建立 <span class=filename>/etc/printcap</span> 使用以下內容：</p></div><div class="literalblock programlisting"><div class=content><pre>lp:\				<i class=conum data-value=1></i><b>(1)</b>
	:lp=/dev/unlpt0:\	<i class=conum data-value=2></i><b>(2)</b>
	:sh:\			<i class=conum data-value=3></i><b>(3)</b>
	:mx#0:\			<i class=conum data-value=4></i><b>(4)</b>
	:sd=/var/spool/lpd/lp:\	<i class=conum data-value=5></i><b>(5)</b>
	:lf=/var/log/lpd-errs:	<i class=conum data-value=6></i><b>(6)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>印表機的名稱。 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> 會傳送列印工作到 <code>lp</code> 印表機，除非有使用 <code>-P</code> 來指定其他印表機，所以預的印表機名稱應使用 <code>lp</code>。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>印表機所連接到裝置。替換此行為正確的連線類型，如此處所示。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>在列印工作開始時不列印首頁。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>不限制列印工作的最大尺寸。</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>此印表機的緩衝 (Spooling) 目錄路徑，每台印表機會自己使用一個獨立的緩衝 (Spooling) 目錄。</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>回報此印表機的錯誤的日誌檔。</td></tr></tbody></table></div><div class=paragraph><p>在建立 <span class=filename>/etc/printcap</span> 之後，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chkprintcap&amp;sektion=8&amp;format=html">chkprintcap(8)</a> 測試印表機是否有錯誤：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chkprintcap</span></code></pre></div></div><div class=paragraph><p>在繼續之前修正任何回報的問題。</p></div><div class=paragraph><p>開啟 <span class=filename>/etc/rc.conf</span> 中的 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>：</p></div><div class="literalblock programlisting"><div class=content><pre>lpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>啟動服務：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service lpd start</span></code></pre></div></div></div><div class=sect3><h4 id=printing-lpd-lpr>9.5.2. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> 列印<a class=anchor href=#printing-lpd-lpr></a></h4><div class=paragraph><p>Documents are sent to the printer with <code>lpr</code>. A file to be printed can be named on the command line or piped into <code>lpr</code>. These two commands are equivalent, sending the contents of <span class=filename>doc.txt</span> to the default printer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr doc.txt
% <span class=nb>cat </span>doc.txt | lpr</code></pre></div></div><div class=paragraph><p>Printers can be selected with <code>-P</code>. To print to a printer called <em>laser</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-Plaser</span> doc.txt</code></pre></div></div></div><div class=sect3><h4 id=printing-lpd-filters>9.5.3. 過濾器<a class=anchor href=#printing-lpd-filters></a></h4><div class=paragraph><p>The examples shown so far have sent the contents of a text file directly to the printer. As long as the printer understands the content of those files, output will be printed correctly.</p></div><div class=paragraph><p>Some printers are not capable of printing plain text, and the input file might not even be plain text.</p></div><div class=paragraph><p><em>Filters</em> allow files to be translated or processed. The typical use is to translate one type of input, like plain text, into a form that the printer can understand, like PostScript™ or PCL. Filters can also be used to provide additional features, like adding page numbers or highlighting source code to make it easier to read.</p></div><div class=paragraph><p>The filters discussed here are <em>input filters</em> or <em>text filters</em>. These filters convert the incoming file into different forms. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> to become <code>root</code> before creating the files.</p></div><div class=paragraph><p>Filters are specified in <span class=filename>/etc/printcap</span> with the <code>if=</code> identifier. To use <span class=filename>/usr/local/libexec/lf2crlf</span> as a filter, modify <span class=filename>/etc/printcap</span> like this:</p></div><div class="literalblock programlisting"><div class=content><pre>lp:\
	:lp=/dev/unlpt0:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/lp:\
	:if=/usr/local/libexec/lf2crlf:\   <i class=conum data-value=1></i><b>(1)</b>
	:lf=/var/log/lpd-errs:</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>if=</code> identifies the <em>input filter</em> that will be used on incoming text.</td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>The backslash <em>line continuation</em> characters at the end of the lines in <span class=filename>printcap</span> entries reveal that an entry for a printer is really just one long line with entries delimited by colon characters. An earlier example can be rewritten as a single less-readable line:</p></div><div class="literalblock programlisting"><div class=content><pre>lp:lp=/dev/unlpt0:sh:mx#0:sd=/var/spool/lpd/lp:if=/usr/local/libexec/lf2crlf:lf=/var/log/lpd-errs:</pre></div></div></td></tr></tbody></table></div><div class=sect4><h5 id=printing-lpd-filters-stairstep>9.5.3.1. 避免在純文字印表機階梯狀列印<a class=anchor href=#printing-lpd-filters-stairstep></a></h5><div class=paragraph><p>Typical FreeBSD text files contain only a single line feed character at the end of each line. These lines will "stairstep" on a standard printer:</p></div><div class="literalblock programlisting"><div class=content><pre>A printed file looks
                    like the steps of a staircase
                                                 scattered by the wind</pre></div></div><div class=paragraph><p>A filter can convert the newline characters into carriage returns and newlines. The carriage returns make the printer return to the left after each line. Create <span class=filename>/usr/local/libexec/lf2crlf</span> with these contents:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
CR=$&#39;\r&#39;
/usr/bin/sed -e &#34;s/$/${CR}/g&#34;</pre></div></div><div class=paragraph><p>Set the permissions and make it executable:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/lf2crlf</span></code></pre></div></div><div class=paragraph><p>Modify <span class=filename>/etc/printcap</span> to use the new filter:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/lf2crlf:\</pre></div></div><div class=paragraph><p>Test the filter by printing the same plain text file. The carriage returns will cause each line to start at the left side of the page.</p></div></div><div class=sect4><h5 id=printing-lpd-filters-enscript>9.5.3.2. 使用 <a class=package href=https://cgit.freebsd.org/ports/tree/print/enscript/>print/enscript</a> 在 PostScript™ 印表機美化純文字內容<a class=anchor href=#printing-lpd-filters-enscript></a></h5><div class=paragraph><p>GNUEnscript converts plain text files into nicely-formatted PostScript™ for printing on PostScript™ printers. It adds page numbers, wraps long lines, and provides numerous other features to make printed text files easier to read. Depending on the local paper size, install either <a class=package href=https://cgit.freebsd.org/ports/tree/print/enscript-letter/>print/enscript-letter</a> or <a class=package href=https://cgit.freebsd.org/ports/tree/print/enscript-a4/>print/enscript-a4</a> from the Ports Collection.</p></div><div class=paragraph><p>Create <span class=filename>/usr/local/libexec/enscript</span> with these contents:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
/usr/local/bin/enscript -o -</pre></div></div><div class=paragraph><p>Set the permissions and make it executable:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/enscript</span></code></pre></div></div><div class=paragraph><p>Modify <span class=filename>/etc/printcap</span> to use the new filter:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/enscript:\</pre></div></div><div class=paragraph><p>Test the filter by printing a plain text file.</p></div></div><div class=sect4><h5 id=printing-lpd-filters-ps2pcl>9.5.3.3. 列印 PostScript™ 到 PCL 印表機<a class=anchor href=#printing-lpd-filters-ps2pcl></a></h5><div class=paragraph><p>Many programs produce PostScript™ documents. However, inexpensive printers often only understand plain text or PCL. This filter converts PostScript™ files to PCL before sending them to the printer.</p></div><div class=paragraph><p>由 Port 套件集安裝 Ghostscript PostScript™ 直譯器，<a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a>。</p></div><div class=paragraph><p>Create <span class=filename>/usr/local/libexec/ps2pcl</span> with these contents:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
/usr/local/bin/gs -dSAFER -dNOPAUSE -dBATCH -q -sDEVICE=ljet4 -sOutputFile=- -</pre></div></div><div class=paragraph><p>Set the permissions and make it executable:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/ps2pcl</span></code></pre></div></div><div class=paragraph><p>PostScript™ input sent to this script will be rendered and converted to PCL before being sent on to the printer.</p></div><div class=paragraph><p>Modify <span class=filename>/etc/printcap</span> to use this new input filter:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/ps2pcl:\</pre></div></div><div class=paragraph><p>Test the filter by sending a small PostScript™ program to it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>printf</span> <span class=s2>&#34;%%</span><span class=se>\!</span><span class=s2>PS </span><span class=se>\n</span><span class=s2> /Helvetica findfont 18 scalefont setfont </span><span class=se>\</span><span class=s2>
72 432 moveto (PostScript printing successful.) show showpage </span><span class=se>\0</span><span class=s2>04&#34;</span> | lpr</code></pre></div></div></div><div class=sect4><h5 id=printing-lpd-filters-smart>9.5.3.4. 智慧過濾器<a class=anchor href=#printing-lpd-filters-smart></a></h5><div class=paragraph><p>A filter that detects the type of input and automatically converts it to the correct format for the printer can be very convenient. The first two characters of a PostScript™ file are usually <code>%!</code>. A filter can detect those two characters. PostScript™ files can be sent on to a PostScript™ printer unchanged. Text files can be converted to PostScript™ with Enscript as shown earlier. Create <span class=filename>/usr/local/libexec/psif</span> with these contents:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psif - Print PostScript or plain text on a PostScript printer
#
IFS=&#34;&#34; read -r first_line
first_two_chars=`expr &#34;$first_line&#34; : &#39;\(..\)&#39;`

case &#34;$first_two_chars&#34; in
%!)
    # %! : PostScript job, print it.
    echo &#34;$first_line&#34; &amp;&amp; cat &amp;&amp; exit 0
    exit 2
    ;;
*)
    # otherwise, format with enscript
    ( echo &#34;$first_line&#34;; cat ) | /usr/local/bin/enscript -o - &amp;&amp; exit 0
    exit 2
    ;;
esac</pre></div></div><div class=paragraph><p>Set the permissions and make it executable:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/psif</span></code></pre></div></div><div class=paragraph><p>Modify <span class=filename>/etc/printcap</span> to use this new input filter:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/psif:\</pre></div></div><div class=paragraph><p>Test the filter by printing PostScript™ and plain text files.</p></div></div></div><div class=sect3><h4 id=printing-lpd-queues>9.5.4. 多序列<a class=anchor href=#printing-lpd-queues></a></h4><div class=paragraph><p>The entries in <span class=filename>/etc/printcap</span> are really definitions of <em>queues</em>. There can be more than one queue for a single printer. When combined with filters, multiple queues provide users more control over how their jobs are printed.</p></div><div class=paragraph><p>As an example, consider a networked PostScript™ laser printer in an office. Most users want to print plain text, but a few advanced users want to be able to print PostScript™ files directly. Two entries can be created for the same printer in <span class=filename>/etc/printcap</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>textprinter:\
	:lp=9100@officelaser:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/textprinter:\
	:if=/usr/local/libexec/enscript:\
	:lf=/var/log/lpd-errs:

psprinter:\
	:lp=9100@officelaser:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/psprinter:\
	:lf=/var/log/lpd-errs:</pre></div></div><div class=paragraph><p>Documents sent to <code>textprinter</code> will be formatted by the <span class=filename>/usr/local/libexec/enscript</span> filter shown in an earlier example. Advanced users can print PostScript™ files on <code>psprinter</code>, where no filtering is done.</p></div><div class=paragraph><p>This multiple queue technique can be used to provide direct access to all kinds of printer features. A printer with a duplexer could use two queues, one for ordinary single-sided printing, and one with a filter that sends the command sequence to enable double-sided printing and then sends the incoming file.</p></div></div><div class=sect3><h4 id=printing-lpd-monitor>9.5.5. 監視與控制列印<a class=anchor href=#printing-lpd-monitor></a></h4><div class=paragraph><p>Several utilities are available to monitor print jobs and check and control printer operation.</p></div><div class=sect4><h5 id=printing-lpd-monitor-lpq>9.5.5.1. <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a><a class=anchor href=#printing-lpd-monitor-lpq></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> shows the status of a user’s print jobs. Print jobs from other users are not shown.</p></div><div class=paragraph><p>Show the current user’s pending jobs on a single printer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq <span class=nt>-Plp</span>
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     0    <span class=o>(</span>standard input<span class=o>)</span>                      12792 bytes</code></pre></div></div><div class=paragraph><p>Show the current user’s pending jobs on all printers:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq <span class=nt>-a</span>
lp:
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     1    <span class=o>(</span>standard input<span class=o>)</span>                      27320 bytes

laser:
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     287  <span class=o>(</span>standard input<span class=o>)</span>                      22443 bytes</code></pre></div></div></div><div class=sect4><h5 id=printing-lpd-monitor-lprm>9.5.5.2. <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a><a class=anchor href=#printing-lpd-monitor-lprm></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> is used to remove print jobs. Normal users are only allowed to remove their own jobs. <code>root</code> can remove any or all jobs.</p></div><div class=paragraph><p>Remove all pending jobs from a printer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lprm -Plp -</span>
dfA002smithy dequeued
cfA002smithy dequeued
dfA003smithy dequeued
cfA003smithy dequeued
dfA004smithy dequeued
cfA004smithy dequeued</code></pre></div></div><div class=paragraph><p>Remove a single job from a printer. <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> is used to find the job number.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     5    <span class=o>(</span>standard input<span class=o>)</span>                      12188 bytes
% lprm <span class=nt>-Plp</span> 5
dfA005smithy dequeued
cfA005smithy dequeued</code></pre></div></div></div><div class=sect4><h5 id=printing-lpd-monitor-lpc>9.5.5.3. <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a><a class=anchor href=#printing-lpd-monitor-lpc></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> is used to check and modify printer status. <code>lpc</code> is followed by a command and an optional printer name. <code>all</code> can be used instead of a specific printer name, and the command will be applied to all printers. Normal users can view status with <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>. Only <code>root</code> can use commands which modify printer status.</p></div><div class=paragraph><p>Show the status of all printers:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpc status all
lp:
	queuing is enabled
	printing is enabled
	1 entry <span class=k>in </span>spool area
	printer idle
laser:
	queuing is enabled
	printing is enabled
	1 entry <span class=k>in </span>spool area
	waiting <span class=k>for </span>laser to come up</code></pre></div></div><div class=paragraph><p>Prevent a printer from accepting new jobs, then begin accepting new jobs again:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc disable lp</span>
lp:
	queuing disabled
<span class=c># lpc enable lp</span>
lp:
	queuing enabled</code></pre></div></div><div class=paragraph><p>Stop printing, but continue to accept new jobs. Then begin printing again:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc stop lp</span>
lp:
	printing disabled
<span class=c># lpc start lp</span>
lp:
	printing enabled
	daemon started</code></pre></div></div><div class=paragraph><p>Restart a printer after some error condition:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc restart lp</span>
lp:
	no daemon to abort
	printing enabled
	daemon restarted</code></pre></div></div><div class=paragraph><p>Turn the print queue off and disable printing, with a message to explain the problem to users:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc down lp Repair parts will arrive on Monday</span>
lp:
	printer and queuing disabled
	status message is now: Repair parts will arrive on Monday</code></pre></div></div><div class=paragraph><p>Re-enable a printer that is down:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc up lp</span>
lp:
	printing enabled
	daemon started</code></pre></div></div><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> for more commands and options.</p></div></div></div><div class=sect3><h4 id=printing-lpd-shared>9.5.6. 分享印表機<a class=anchor href=#printing-lpd-shared></a></h4><div class=paragraph><p>Printers are often shared by multiple users in businesses and schools. Additional features are provided to make sharing printers more convenient.</p></div><div class=sect4><h5 id=printing-shared-aliases>9.5.6.1. 別名<a class=anchor href=#printing-shared-aliases></a></h5><div class=paragraph><p>The printer name is set in the first line of the entry in <span class=filename>/etc/printcap</span>. Additional names, or <em>aliases</em>, can be added after that name. Aliases are separated from the name and each other by vertical bars:</p></div><div class="literalblock programlisting"><div class=content><pre>lp|repairsprinter|salesprinter:\</pre></div></div><div class=paragraph><p>Aliases can be used in place of the printer name. For example, users in the Sales department print to their printer with</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-Psalesprinter</span> sales-report.txt</code></pre></div></div><div class=paragraph><p>Users in the Repairs department print to <em>their</em> printer with</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-Prepairsprinter</span> repairs-report.txt</code></pre></div></div><div class=paragraph><p>All of the documents print on that single printer. When the Sales department grows enough to need their own printer, the alias can be removed from the shared printer entry and used as the name of a new printer. Users in both departments continue to use the same commands, but the Sales documents are sent to the new printer.</p></div></div><div class=sect4><h5 id=printing-shared-headers>9.5.6.2. 頁首<a class=anchor href=#printing-shared-headers></a></h5><div class=paragraph><p>It can be difficult for users to locate their documents in the stack of pages produced by a busy shared printer. <em>Header pages</em> were created to solve this problem. A header page with the user name and document name is printed before each print job. These pages are also sometimes called <em>banner</em> or <em>separator</em> pages.</p></div><div class=paragraph><p>Enabling header pages differs depending on whether the printer is connected directly to the computer with a USB, parallel, or serial cable, or is connected remotely over a network.</p></div><div class=paragraph><p>Header pages on directly-connected printers are enabled by removing the <code>:sh:\</code> (Suppress Header) line from the entry in <span class=filename>/etc/printcap</span>. These header pages only use line feed characters for new lines. Some printers will need the <span class=filename>/usr/shared/examples/printing/hpif</span> filter to prevent stairstepped text. The filter configures PCL printers to print both carriage returns and line feeds when a line feed is received.</p></div><div class=paragraph><p>Header pages for network printers must be configured on the printer itself. Header page entries in <span class=filename>/etc/printcap</span> are ignored. Settings are usually available from the printer front panel or a configuration web page accessible with a web browser.</p></div></div></div><div class=sect3><h4 id=printing-lpd-references>9.5.7. 參考文獻<a class=anchor href=#printing-lpd-references></a></h4><div class=paragraph><p>Example files: <span class=filename>/usr/shared/examples/printing/</span>.</p></div><div class=paragraph><p>The <em>4.3BSD Line Printer Spooler Manual</em>, <span class=filename>/usr/shared/doc/smm/07.lpd/paper.ascii.gz</span>.</p></div><div class=paragraph><p>Manual pages: <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a>.</p></div></div></div><div class=sect2><h3 id=printing-other>9.6. 其他列印系統<a class=anchor href=#printing-other></a></h3><div class=paragraph><p>Several other printing systems are available in addition to the built-in <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>. These systems offer support for other protocols or additional features.</p></div><div class=sect3><h4 id=printing-other-cups>9.6.1. CUPS (Common UNIX™ Printing System)<a class=anchor href=#printing-other-cups></a></h4><div class=paragraph><p>CUPS is a popular printing system available on many operating systems. Using CUPS on FreeBSD is documented in a separate article: <a href=https://docs.freebsd.org/en/articles/cups/>CUPS</a></p></div></div><div class=sect3><h4 id=printing-other-hplip>9.6.2. HPLIP<a class=anchor href=#printing-other-hplip></a></h4><div class=paragraph><p>Hewlett Packard provides a printing system that supports many of their inkjet and laser printers. The port is <a class=package href=https://cgit.freebsd.org/ports/tree/print/hplip/>print/hplip</a>. The main web page is at <a href=http://hplipopensource.com/hplip-web/index.html class=bare>http://hplipopensource.com/hplip-web/index.html</a>. The port handles all the installation details on FreeBSD. Configuration information is shown at <a href=http://hplipopensource.com/hplip-web/install/manual/hp_setup.html class=bare>http://hplipopensource.com/hplip-web/install/manual/hp_setup.html</a>.</p></div></div><div class=sect3><h4 id=printing-other-lprng>9.6.3. LPRng<a class=anchor href=#printing-other-lprng></a></h4><div class=paragraph><p>LPRng was developed as an enhanced alternative to <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>. The port is <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/LPRng/>sysutils/LPRng</a>. For details and documentation, see <a href=https://lprng.sourceforge.net/ class=bare>https://lprng.sourceforge.net/</a>.</p></div></div></div></div></div><div class=sect1><h2 id=linuxemu>Chapter 10. Linux® Binary 相容性<a class=anchor href=#linuxemu></a></h2><div class=sectionbody><div class=sect2><h3 id=linuxemu-synopsis>10.1. 概述<a class=anchor href=#linuxemu-synopsis></a></h3><div class=paragraph><p>FreeBSD 提供 Linux™ Binary 的相容性，允許使用者在 FreeBSD 系統上不需要修改就可以安裝和執行大部份的 Linux™ Binary。 曾經有報告指出，在某些情況下，Linux™ Binary 在 FreeBSD 的表現比在 Linux™ 好。</p></div><div class=paragraph><p>然而，部份特定在 Linux™ 作業系統上的功能在 FreeBSD 並沒有支援。例如，若 Linux™ Binary 過度的使用 i386™ 特定的呼叫，如啟動虛擬 8086 模式，會無法在 FreeBSD 執行。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 10.3 後支援 64 位元的 Linux™ Binary 相容性。</p></div></td></tr></tbody></table></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>如何在 FreeBSD 系統啟用 Linux™ Binary 相容模式。</p></li><li><p>如何安裝其他的 Linux™ 共用程式庫。</p></li><li><p>如何在 FreeBSD 系統安裝 Linux™ 應用程式。</p></li><li><p>在 FreeBSD 中 Linux™ 相容性的實作細節。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>知道如何安裝 <a href=./#ports>其他的第三方軟體</a>。</p></li></ul></div></div><div class=sect2><h3 id=linuxemu-lbc-install>10.2. 設定 Linux™ Binary 相容性<a class=anchor href=#linuxemu-lbc-install></a></h3><div class=paragraph><p>Linux™ 程式庫預設並不會安裝，且並不會開啟 Linux™ Binary 相容性。 Linux™ 程式庫可以手動安裝或是從 FreeBSD Port 套件集安裝。</p></div><div class=paragraph><p>在嘗試編譯 Port 前，要載入 Linux™ 核心模組，否則編譯會失敗：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload linux</span></code></pre></div></div><div class=paragraph><p>對 64-位元的相容性：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload linux64</span></code></pre></div></div><div class=paragraph><p>確認模組已載入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kldstat
      Id Refs Address    Size     Name
      1    2 0xc0100000 16bdb8   kernel
      7    1 0xc24db000 d000     linux.ko</code></pre></div></div><div class=paragraph><p>在 FreeBSD 安裝基本的 Linux™ 程式庫和 Binary 最簡單的方式是安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base-c6/>emulators/linux_base-c6</a> 套件或是 Port 。要安裝 Port：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install emulators/linux_base-c6</span></code></pre></div></div><div class=paragraph><p>要在開機時開啟 Linux™ 相容性，可以加入這行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>linux_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>在 64-位元的機器上，<span class=filename>/etc/rc.d/abi</span> 會自動載入用來做 64-位元模擬的模組。</p></div><div class=paragraph><p>Since the Linux™ binary compatibility layer has gained support for running both 32- and 64-bit Linux™ binaries (on 64-bit x86 hosts), it is no longer possible to link the emulation functionality statically into a custom kernel.</p></div><div class=sect3><h4 id=linuxemu-libs-manually>10.2.1. 手動安裝其他程式庫<a class=anchor href=#linuxemu-libs-manually></a></h4><div class=paragraph><p>若有 Linux™ 應用程式在設定 Linux™ Binary 相容性後出現缺少共用程式庫的情況，確認這個 Linux™ Binary 需要哪個共用程式庫並手動安裝。</p></div><div class=paragraph><p>在 Linux™ 系統，可使用 <code>ldd</code> 來找出應用程式需要哪個共用程式庫。 例如，檢查 <code>linuxdoom</code> 需要哪個共用程式庫，在有安裝 Doom 的 Linux™ 系統執行這個指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ldd linuxdoom
libXt.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libX11.so.3.1.0
libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> <span class=o>=&gt;</span> /lib/libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>然後，複製所有 Linux™ 系統輸出結果中最後一欄的檔案到 FreeBSD 系統的 <span class=filename>/compat/linux</span>。 複製完後，建立符號連結 (Symbolic link) 至輸出結果第一欄的名稱。以這個例子會在 FreeBSD 系統產生以下檔案：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>若 Linux™ 共用程式庫已經存在，並符合 <code>ldd</code> 輸出結果第一欄的主要修訂版號，則不需要複製該行最後一欄的檔案，使用既有的程式庫應可運作。若有較新的版本建議仍要複製共用程式庫，只要符號連結指向新版的程式庫，舊版便可移除。</p></div><div class=paragraph><p>例如，以下程式庫已存在 FreeBSD 系統：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</code></pre></div></div><div class=paragraph><p>且 <code>ldd</code> 顯示 Binary 需要使用較新的版本：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>雖然既有的程式庫只有在最後一碼過時一或兩個版本，程式應該仍可使用稍微舊的版本執行，雖然如此，保險起見還替換既有的 <span class=filename>libc.so</span> 為較新的版本：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>一般來說，只有在安裝 Linux™ 程式到 FreeBSD 完的前幾次會需要查看 Linux™ Binary 相依的共用程式庫。之後系統便有足夠的 Linux™ 共用程式庫能夠執行新安裝的 Linux™ Binary，便不再需要額外的動作。</p></div></div><div class=sect3><h4 id=_安裝_linuxelf_binary>10.2.2. 安裝 Linux™ELF Binary<a class=anchor href=#_安裝_linuxelf_binary></a></h4><div class=paragraph><p>ELF Binary 有時候需要額外的步驟。當執行無商標 (Unbranded) 的 ELF Binary，會產生錯誤訊息：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./my-linux-elf-binary
ELF binary <span class=nb>type </span>not known
Abort</code></pre></div></div><div class=paragraph><p>要協助 FreeBSD 核心區別是 FreeBSD ELF Binary 還是 Linux™ Binary，可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% brandelf <span class=nt>-t</span> Linux my-linux-elf-binary</code></pre></div></div><div class=paragraph><p>由於 GNU 工具鏈會自動放置適當的商標資訊到 ELF Binary，通常不需要這個步驟。</p></div></div><div class=sect3><h4 id=_安裝以_linuxrpm_為基礎的應用程式>10.2.3. 安裝以 Linux™RPM 為基礎的應用程式<a class=anchor href=#_安裝以_linuxrpm_為基礎的應用程式></a></h4><div class=paragraph><p>要安裝 Linux™RPM 為基礎的應用程式，需先安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/archivers/rpm4/>archivers/rpm4</a> 套件或 Port。安裝完成之後，<code>root</code> 可以使用這個指令安裝 <span class=filename>.rpm</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /compat/linux</span>
<span class=c># rpm2cpio &lt; /path/to/linux.archive.rpm | cpio -id</span></code></pre></div></div><div class=paragraph><p>如果需要， <code>brandelf</code> 已安裝的 ELF Binary。注意，這將會無法乾淨地解除安裝。</p></div></div><div class=sect3><h4 id=_設定主機名稱解析器>10.2.4. 設定主機名稱解析器<a class=anchor href=#_設定主機名稱解析器></a></h4><div class=paragraph><p>如果 DNS 無法運作或出現這個錯誤：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>resolv+: <span class=s2>&#34;bind&#34;</span> is an invalid keyword resolv+:
<span class=s2>&#34;hosts&#34;</span> is an invalid keyword</code></pre></div></div><div class=paragraph><p>將 <span class=filename>/compat/linux/etc/host.conf</span> 設定如下：</p></div><div class="literalblock programlisting"><div class=content><pre>order hosts, bind
multi on</pre></div></div><div class=paragraph><p>這指定先搜尋 <span class=filename>/etc/hosts</span>，其次為 DNS。 當 <span class=filename>/compat/linux/etc/host.conf</span> 不存在， Linux™ 應用程式會使用 <span class=filename>/etc/host.conf</span> 並會警告不相容的 FreeBSD 語法。如果名稱伺服器未設定使用 <span class=filename>/etc/resolv.conf</span> 的話，則可移除 <code>bind</code>。</p></div></div></div><div class=sect2><h3 id=linuxemu-advanced>10.3. 進階主題<a class=anchor href=#linuxemu-advanced></a></h3><div class=paragraph><p>This section describes how Linux™ binary compatibility works and is based on an email written to <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chat>FreeBSD chat mailing list</a> by Terry Lambert <a href=mailto:tlambert@primenet.com>tlambert@primenet.com</a> (Message ID: <code>&lt;<a href=mailto:199906020108.SAA07001@usr09.primenet.com>199906020108.SAA07001@usr09.primenet.com</a>></code>).</p></div><div class=paragraph><p>FreeBSD has an abstraction called an "execution class loader". This is a wedge into the <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> system call.</p></div><div class=paragraph><p>Historically, the UNIX™ loader examined the magic number (generally the first 4 or 8 bytes of the file) to see if it was a binary known to the system, and if so, invoked the binary loader.</p></div><div class=paragraph><p>If it was not the binary type for the system, the <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> call returned a failure, and the shell attempted to start executing it as shell commands. The assumption was a default of "whatever the current shell is".</p></div><div class=paragraph><p>Later, a hack was made for <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> to examine the first two characters, and if they were <code>:\n</code>, it invoked the <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> shell instead.</p></div><div class=paragraph><p>FreeBSD has a list of loaders, instead of a single loader, with a fallback to the <code>#!</code> loader for running shell interpreters or shell scripts.</p></div><div class=paragraph><p>For the Linux™ABI support, FreeBSD sees the magic number as an ELF binary. The ELF loader looks for a specialized <em>brand</em>, which is a comment section in the ELF image, and which is not present on SVR4/Solaris™ ELF binaries.</p></div><div class=paragraph><p>For Linux™ binaries to function, they must be <em>branded</em> as type <code>Linux</code> using <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># brandelf -t Linux file</span></code></pre></div></div><div class=paragraph><p>When the ELF loader sees the <code>Linux</code> brand, the loader replaces a pointer in the <code>proc</code> structure. All system calls are indexed through this pointer. In addition, the process is flagged for special handling of the trap vector for the signal trampoline code, and several other (minor) fix-ups that are handled by the Linux™ kernel module.</p></div><div class=paragraph><p>The Linux™ system call vector contains, among other things, a list of <code>sysent[]</code> entries whose addresses reside in the kernel module.</p></div><div class=paragraph><p>When a system call is called by the Linux™ binary, the trap code dereferences the system call function pointer off the <code>proc</code> structure, and gets the Linux™, not the FreeBSD, system call entry points.</p></div><div class=paragraph><p>Linux™ mode dynamically <em>reroots</em> lookups. This is, in effect, equivalent to <code>union</code> to file system mounts. First, an attempt is made to lookup the file in <span class=filename>/compat/linux/original-path</span>. If that fails, the lookup is done in <span class=filename>/original-path</span>. This makes sure that binaries that require other binaries can run. For example, the Linux™ toolchain can all run under Linux™ABI support. It also means that the Linux™ binaries can load and execute FreeBSD binaries, if there are no corresponding Linux™ binaries present, and that a <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> command can be placed in the <span class=filename>/compat/linux</span> directory tree to ensure that the Linux™ binaries cannot tell they are not running on Linux™.</p></div><div class=paragraph><p>In effect, there is a Linux™ kernel in the FreeBSD kernel. The various underlying functions that implement all of the services provided by the kernel are identical to both the FreeBSD system call table entries, and the Linux™ system call table entries: file system operations, virtual memory operations, signal delivery, and System V IPC. The only difference is that FreeBSD binaries get the FreeBSD <em>glue</em> functions, and Linux™ binaries get the Linux™<em>glue</em> functions. The FreeBSD <em>glue</em> functions are statically linked into the kernel, and the Linux™<em>glue</em> functions can be statically linked, or they can be accessed via a kernel module.</p></div><div class=paragraph><p>Technically, this is not really emulation, it is an ABI implementation. It is sometimes called "Linux™ emulation" because the implementation was done at a time when there was no other word to describe what was going on. Saying that FreeBSD ran Linux™ binaries was not true, since the code was not compiled in.</p></div></div></div></div><h1 id=system-administration class=sect0>Part III: 系統管理<a class=anchor href=#system-administration></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>FreeBSD 使用手冊剩下的這些章節涵蓋了全方位的 FreeBSD 系統管理。 每個章節的開頭會先描述在該您讀完該章節後您會學到什麼，也會詳述在您在看這些資料時應該要有的一些背景知識。</p></div><div class=paragraph><p>這些章節是讓您在需要查資料的時候翻閱用的。 您不需要依照特定的順序來讀，也不需要將這些章節全部過讀之後才開始用 FreeBSD。</p></div></div></div><div class=sect1><h2 id=config-tuning>Chapter 11. 設定與調校<a class=anchor href=#config-tuning></a></h2><div class=sectionbody><div class=sect2><h3 id=config-synopsis>11.1. 概述<a class=anchor href=#config-synopsis></a></h3><div class=paragraph><p>在 FreeBSD 使用過程中，相當重要的環節之一就是如何正確設定系統。 本章著重於介紹 FreeBSD 的設定流程，包括一些可以調整 FreeBSD 效能的參數設定。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p><span class=filename>rc.conf</span> 設定的基礎概念及 <span class=filename>/usr/local/etc/rc.d</span> 啟動 Script。</p></li><li><p>如何設定並測試網路卡。</p></li><li><p>如何在網路裝置上設定虛擬主機。</p></li><li><p>如何使用在 <span class=filename>/etc</span> 中的各種設定檔。</p></li><li><p>如何使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 變數調校 FreeBSD。</p></li><li><p>如何調校磁碟效能及修改核心限制。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解 UNIX™ 及 FreeBSD 基礎 (<a href=./#basics>FreeBSD 基礎</a>)。</p></li><li><p>熟悉核心設定與編譯的基礎 (<a href=./#kernelconfig>設定 FreeBSD 核心</a>)。</p></li></ul></div></div><div class=sect2><h3 id=configtuning-starting-services>11.2. 啟動服務<a class=anchor href=#configtuning-starting-services></a></h3><div class=paragraph><p>許多使用者會使用 Port 套件集安裝第三方軟體到 FreeBSD 且需要安裝服務在系統初始化時可啟動該軟體。服務，例如 <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> 或 <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> 僅只是在眾多需要在系統初始化時啟動的軟體之中的兩個。本章節將說明可用來啟動第三方軟體的程序。</p></div><div class=paragraph><p>在 FreeBSD 大多數內建的服務，例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 也是透過系統啟動 Script 來執行。</p></div><div class=sect3><h4 id=_延伸應用程式設定>11.2.1. 延伸應用程式設定<a class=anchor href=#_延伸應用程式設定></a></h4><div class=paragraph><p>現在 FreeBSD 會引用 <span class=filename>rc.d</span>，設定應用程式啟動變的更簡單且提供更多的功能。使用於 <a href=#configtuning-rcd>管理 FreeBSD 中的服務</a> 所提到的關鍵字，可以設定應用程式在其他特定服務之後啟動且可以透過 <span class=filename>/etc/rc.conf</span> 來傳遞額外的旗標來取代寫死在啟動 Script 中的旗標。一個基本的 Script 可能會如下例所示：</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>這個 Script 會確保要執行的 <code>utility</code> 會在虛構的服務 <code>DAEMON</code> 之後啟動，也同時提供設定與追蹤程序 ID (Process ID, PID) 的方法。</p></div><div class=paragraph><p>接著此應用程式便可將下行放到 <span class=filename>/etc/rc.conf</span> 中：</p></div><div class="literalblock programlisting"><div class=content><pre>utility_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>使用這種方式可以簡單的處理指令列參數、引用 <span class=filename>/etc/rc.subr</span> 所提供的預設函數、與 <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> 相容並可在 <span class=filename>rc.conf</span> 簡單的設定。</p></div></div><div class=sect3><h4 id=_使用服務來啟動其他服務>11.2.2. 使用服務來啟動其他服務<a class=anchor href=#_使用服務來啟動其他服務></a></h4><div class=paragraph><p>其他的服務可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 來啟動，在 <a href=./#network-inetd>inetd 超級伺服器</a> 有如何使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 以及其設定的深入說明。</p></div><div class=paragraph><p>在某些情況更適合使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 來啟動系統服務，由於 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 會使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> 的擁有者來執行這些程序，所以這個方法有不少優點，這讓一般的使用者也可以啟動與維護自己的應用程式。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 的 <code>@reboot</code> 功能，可用來替代指定詳細的時間，而該工作會在系統初始化時執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 後執行。</p></div></div></div><div class=sect2><h3 id=configtuning-cron>11.3. 設定 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a><a class=anchor href=#configtuning-cron></a></h3><div class=paragraph><p>在 FreeBSD 其中最有用的其中一項工具便是 cron，這個工具會在背景執行並且定期檢查 <span class=filename>/etc/crontab</span> 是否有要執行的工作然後搜尋 <span class=filename>/var/cron/tabs</span> 是否有自訂的 crontab 檔案，這些檔案用來安排要讓 cron 在指定的時間執行的工作，crontab 中的每一個項目定義了一個要執行的工作，又稱作 <em>cron job</em>。</p></div><div class=paragraph><p>這裡使用了兩種類型的設定檔：其一是系統 crontab，系統 crontab 不應該被修改，其二為使用者 crontab，使用者 crontab 可以依需要建立與編輯。這兩種檔案的格式在 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> 有說明。系統 crontab <span class=filename>/etc/crontab</span> 的格式含有在使用者 crontab 所沒有的 <code>who</code> 欄位，在系統 crontab，cron 會依據該欄位所指定的使用者來執行指令，而在使用者 crontab，會以建立 crontab 的使用者來執行指令。</p></div><div class=paragraph><p>使用者 crontab 讓個別使用者可以安排自己的工作，<code>root</code> 使用者也可有自己的使用者 <span class=filename>crontab</span> 來安排不在系統 <span class=filename>crontab</span> 中的工作。</p></div><div class=paragraph><p>以下為系統 crontab <span class=filename>/etc/crontab</span> 的範例項目：</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/crontab - root&#39;s crontab for FreeBSD
#
# $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $
#<i class=conum data-value=1></i><b>(1)</b>
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <i class=conum data-value=2></i><b>(2)</b>
#
#minute	hour	mday	month	wday	who	command <i class=conum data-value=3></i><b>(3)</b>
#
*/5	*	*	*	*	root	/usr/libexec/atrun <i class=conum data-value=4></i><b>(4)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>以 <code>#</code> 字元為首的行代表註解。可在檔案中放置註解提醒要執行什麼動作及為何要執行。註解不可與指令同行，否則會被當做指令的一部份，註解必須在新的一行，空白行則會被忽略掉。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>等號 (<code>=</code>) 字元用來定義任何環境設定。在這個例子當中，使用了等號來定義 <code>SHELL</code> 及 <code>PATH</code>。若 <code>SHELL</code> 被省略，cron 則會使用預設的 Bourne shell。若 <code>PATH</code> 被省略，則必須指定指令或 Script 的完整路徑才能執行。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>此行定義了在系統 crontab 會使用到的七個欄位：<code>minute</code>, <code>hour</code>, <code>mday</code>, <code>month</code>, <code>wday</code>, <code>who</code> 以及 <code>command</code>。<code>minute</code> 欄位是指定指令要執行的時間中的分，<code>hour</code> 指定指令要執行的時，<code>mday</code> 是月裡面的日，<code>month</code> 是月，以及 <code>wday</code> 是週裡面的日。這些欄位必須數值代表 24 小時制的時間或 <code>\*</code> 來代表所有可能的值。<code>who</code> 這個欄位只有系統 crontab 才有，用來指定要用那一個使用者來執行指令。最後一個欄位則是要執行的指令。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>這個項目定義了該工作所使用的數值，<code>*/5</code> 後接著數個 <code>*</code> 字元指的是每個月的每一週的每一日的每個小時的每 5 分鐘會使用 <code>root</code> 執行 <code>/usr/libexec/atrun</code>。指令可含任何數量的參數，但若指令要使用多行則需以反斜線 "\" 連線字元換行。</td></tr></tbody></table></div><div class=sect3><h4 id=configtuning-installcrontab>11.3.1. 建立使用者的 Crontab<a class=anchor href=#configtuning-installcrontab></a></h4><div class=paragraph><p>要建立一個使用者 crontab 可使用編輯模式執行 <code>crontab</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-e</span></code></pre></div></div><div class=paragraph><p>這樣會使用預設的文字編輯器來開啟使用者的 crontab，使用者第一次執行這個指令會開啟一個空的檔案，使用者建立 crontab 之後這個指令則會開啟已建立的 crontab 供編輯。</p></div><div class=paragraph><p>加入這些行到 crontab 檔的最上方來設定環境變數以及備忘在 crontab 中欄位的意思非常有用：</p></div><div class="literalblock programlisting"><div class=content><pre>SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin
# Order of crontab fields
# minute	hour	mday	month	wday	command</pre></div></div><div class=paragraph><p>然後每一個要執行的指令或 Script 加入一行，指定要執行指令的時間。這個例子會每天在下午 2 點執行指定的自訂 Bourne shell script，由於沒有在 <code>PATH</code> 指定 Script 的路徑，所以必須給予完整的 Script 路徑：</p></div><div class="literalblock programlisting"><div class=content><pre>0	14	*	*	*	/usr/home/dru/bin/mycustomscript.sh</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>在使用自訂的 Script 之前，請先確定該 Script 可以執行並且使用 cron 在有限的環境變數下測試。要複製一個用來執行上述 cron 項目的環境可以使用：</p></div><div class="literalblock programlisting"><div class=content><pre>env -i SHELL=/bin/sh PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin HOME=/home/dru LOGNAME=dru /usr/home/dru/bin/mycustomscript.sh</pre></div></div><div class=paragraph><p>在 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> 有討論 cron 使用的環境變數，若 Script 中含有任何會使用萬用字元刪除檔案的指令，那麼檢查 Script 可正常在 cron 的環境運作非常重要。</p></div></td></tr></tbody></table></div><div class=paragraph><p>編輯完成 crontab 之後儲存檔案，編輯完的 crontab 會被自動安裝且 cron 會讀取該 crontab 並在其指定的時指執行其 cron job。要列出 crontab 中有那一些 cron job 可以使用此指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-l</span>
0	14	<span class=k>*</span>	<span class=k>*</span>	<span class=k>*</span>	/usr/home/dru/bin/mycustomscript.sh</code></pre></div></div><div class=paragraph><p>要移除使用在使用者 crontab 中的 cron job 可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-r</span>
remove crontab <span class=k>for </span>dru? y</code></pre></div></div></div></div><div class=sect2><h3 id=configtuning-rcd>11.4. 管理 FreeBSD 中的服務<a class=anchor href=#configtuning-rcd></a></h3><div class=paragraph><p>FreeBSD 在系統初始化時使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 系統的啟動 Script。列於 <span class=filename>/etc/rc.d</span> 的 Script 提供了基本的服務可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> 加上 <code>start</code>, <code>stop</code> 以及 <code>restart</code> 選項來控制。例如，使用以下指令可以重新啟動 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd restart</span></code></pre></div></div><div class=paragraph><p>這個程序可以用來在執行中的系統上啟動服務，而在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 中有指定的服務則會在開機時自動啟動。例如，要在系統啟動時開啟 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>，可入下行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>若 <code>natd_enable="NO"</code> 行已存在，則將 <code>NO</code> 更改為 <code>YES</code>，在下次開機時 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> script 便會自動載入任何相依的服務，詳細如下所述。</p></div><div class=paragraph><p>由於 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 系統主要用於在系統開機與關機時啟動與停止服務，只有當有服務的變數設定在 <span class=filename>/etc/rc.conf</span> 時 <code>start</code>, <code>stop</code> 以及 <code>restart</code> 才會有作用。例如 <code>sshd restart</code> 只會在 <span class=filename>/etc/rc.conf</span> 中的 <code>sshd_enable</code> 設為 <code>YES</code> 時才會運作，若要不透過 <span class=filename>/etc/rc.conf</span> 的設定來 <code>start</code>, <code>stop</code> 或 <code>restart</code> 一個服務則需要在指令前加上 "one"，例如要不透過目前在 <span class=filename>/etc/rc.conf</span> 的設定重新啟動 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 可執行以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd onerestart</span></code></pre></div></div><div class=paragraph><p>要檢查一個服務是否有在 <span class=filename>/etc/rc.conf</span> 開啟，可執行服務的 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> Script 加上 <code>rcvar</code>。這個例子會檢查 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 是否在 <span class=filename>/etc/rc.conf</span> 已經開啟：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd rcvar</span>
<span class=c># sshd</span>
<span class=c>#</span>
<span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=c>#   (default: &#34;&#34;)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>行 <code># sshd</code> 的輸出來自上述指令，而非 <code>root</code> console。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要判斷是一個服務是否正在執行，可使用 <code>status</code>，例如要確認 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 是否正常在執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd status</span>
sshd is running as pid 433.</code></pre></div></div><div class=paragraph><p>在某些情況，也可以 <code>reload</code> 一個服務。這個動作會嘗試發送一個信號給指定的服務，強制服務重新載入其設定檔，在大多數的情況下，發送給服務的信號是 <code>SIGHUP</code>。並不是每個服務都有支援此功能。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 系統會用在網路服務及也應用在大多數的系統初化 。例如執行 <span class=filename>/etc/rc.d/bgfsck</span> Script 會列印出以下訊息：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Starting background file system checks <span class=k>in </span>60 seconds.</code></pre></div></div><div class=paragraph><p>這個 Script 用來在背景做檔案系統檢查，只有在系統初始化時要執行。</p></div><div class=paragraph><p>許多系統服務會相依其他服務來運作，例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=yp&amp;sektion=8&amp;format=html">yp(8)</a> 及其他以 RPC 為基礎的服務在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rpcbind&amp;sektion=8&amp;format=html">rpcbind(8)</a> 服務啟動前可能會啟動失敗。要解決這種問題，就必須在啟動 Script 上方的註解中加入相依及其他 meta-data。在系統初始化時會用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> 程式分析這些註解來決定要以什麼順序來執行系統服務以滿足相依。</p></div><div class=paragraph><p>因 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> 的需要，以下的關鍵字必須加入到所有的啟動 Script 方可 "enable" 啟動 Script：</p></div><div class=ulist><ul><li><p><code>PROVIDE</code>: 設定此檔案所提供的服務。</p></li></ul></div><div class=paragraph><p>以下關鍵字可能會在每個啟動 Script 的上方引用，雖然非必要，但是對於 <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> 是非常有用的提示：</p></div><div class=ulist><ul><li><p><code>REQUIRE</code>: 列出此服務需要引用的服務。有使用此關鍵字的 Script 會在指定服務啟動 <em>之後</em> 才執行。</p></li><li><p><code>BEFORE</code>: 列出相依此服務的服務。有使用此關鍵字的 Script 會在指定的服務啟動 <em>之前</em> 執行。</p></li></ul></div><div class=paragraph><p>透過仔細的設定每個啟動 Script 的這些關鍵字，管理者便可對 Script 的啟動順序進行微調，而不需使用到其他 UNIX™ 作業系統所使用的 "runlevels"。</p></div><div class=paragraph><p>額外的資訊可在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> 中找到。請參考 <a href=https://docs.freebsd.org/en/articles/rc-scripting/>此文章</a> 來取得如何建立自訂 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> Script 的操作說明。</p></div><div class=sect3><h4 id=configtuning-core-configuration>11.4.1. 管理系統特定的設定<a class=anchor href=#configtuning-core-configuration></a></h4><div class=paragraph><p>系統設定資訊的主要位於 <span class=filename>/etc/rc.conf</span>，這個檔案的設定資訊範圍非常廣且會在系統啟動時讀取來設定系統，它也提供設定資訊給 <span class=filename>rc*</span> 檔案使用。</p></div><div class=paragraph><p>在 <span class=filename>/etc/rc.conf</span> 中的設定項目會覆蓋在 <span class=filename>/etc/defaults/rc.conf</span> 的預設設定，不應直接編輯該檔案中的預設設定，所有系統特定的設定應到 <span class=filename>/etc/rc.conf</span> 所修改。</p></div><div class=paragraph><p>在叢集應用時要將系統特定的設定與各站特定的設定分開，藉此減少管理成本有好幾種方法，建議的方法是將系統特定的設定放置在 <span class=filename>/etc/rc.conf.local</span>，例如以下將要套用到所有系統的設定項目放在 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;
keyrate=&#34;fast&#34;
defaultrouter=&#34;10.1.1.254&#34;</pre></div></div><div class=paragraph><p>而只套用到此系統的設定放在 <span class=filename>/etc/rc.conf.local</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;node1.example.org&#34;
ifconfig_fxp0=&#34;inet 10.1.1.1/8&#34;</pre></div></div><div class=paragraph><p>使用應用程式如 rsync 或 puppet 將 <span class=filename>/etc/rc.conf</span> 散布到每個系統，而在各系統保留自己的 <span class=filename>/etc/rc.conf.local</span>。</p></div><div class=paragraph><p>升級系統並不會覆寫 <span class=filename>/etc/rc.conf</span>，所以系統設定資訊不會因此遺失。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/rc.conf</span> 以及 <span class=filename>/etc/rc.conf.local</span> 兩個檔案都會使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> 解析，這讓系統操作者能夠建立較複雜的設定方案。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 來取得更多有關此主題的資訊。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=config-network-setup>11.5. 設定網路介面卡<a class=anchor href=#config-network-setup></a></h3><div class=paragraph><p>對 FreeBSD 管理者來說加入與設定網路介面卡 (Network Interface Card, NIC) 會是一件常見的工作。</p></div><div class=sect3><h4 id=_找到正確的驅動程式>11.5.1. 找到正確的驅動程式<a class=anchor href=#_找到正確的驅動程式></a></h4><div class=paragraph><p>首先，要先確定 NIC 的型號及其使用的晶片。FreeBSD 支援各種 NIC，可檢查該 FreeBSD 發佈版本的硬體相容性清單來查看是否有支援該 NIC。</p></div><div class=paragraph><p>若有支援該 NIC，接著要確定該 NIC 所要需要的 FreeBSD 驅動程式名稱。請參考 <span class=filename>/usr/src/sys/conf/NOTES</span> 及 <span class=filename>/usr/src/sys/arch/conf/NOTES</span> 來取得 NIC 驅動程式清單及其支援的晶片組相關資訊。當有疑問是，請閱讀該驅動程式的操作手冊，會有提供更多有關支援硬體及該驅動程式已知問題的資訊。</p></div><div class=paragraph><p><span class=filename>GENERIC</span> 核心已有內含常見 NIC 的驅動程式 ，意思是在開機時應該會偵測到 NIC。可以輸入 <code>more /var/run/dmesg.boot</code> 來檢視系統的開機訊息並使用空白鍵捲動文字。在此例中，兩個乙太網路 NIC 使用系統已有的 <a href="https://man.freebsd.org/cgi/man.cgi?query=dc&amp;sektion=4&amp;format=html">dc(4)</a> 驅動程式：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: <span class=o>[</span>ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: <span class=o>[</span>ITHREAD]</code></pre></div></div><div class=paragraph><p>若在 <span class=filename>GENERIC</span> 中沒有該 NIC 的驅動程式，但有可用的驅動程式，那麼在設定及使用 NIC 前要先載入該驅動程式，有兩種方式可以完成這件事：</p></div><div class=ulist><ul><li><p>最簡單的方式是使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> 載入 NIC 要使用的核心模組。要在開機時自動載入，可加入適當的設定到 <span class=filename>/boot/loader.conf</span>。不是所有 NIC 驅動程式皆可當做模組使用。</p></li><li><p>或者，靜態編譯對 NIC 的支援到自訂核心，請參考 <span class=filename>/usr/src/sys/conf/NOTES</span>, <span class=filename>/usr/src/sys/arch/conf/NOTES</span> 及驅動程式的操作手冊來了解要在自訂核心設定檔中要加入那些設定。要取得更多有關重新編譯核心的資訊可參考 <a href=./#kernelconfig>設定 FreeBSD 核心</a>。若在開機時有偵測到 NIC，就不需要再重新編譯核心。</p></li></ul></div><div class=sect4><h5 id=config-network-ndis>11.5.1.1. 使用 Windows™NDIS 驅動程式<a class=anchor href=#config-network-ndis></a></h5><div class=paragraph><p>很不幸的，仍有很多供應商並沒有提供它們驅動程式的技術文件給開源社群，因為這些文件有涉及商業機密。因此，FreeBSD 及其他作業系統的開發人員只剩下兩種方案可以選擇：透過長期與艱苦的過程做逆向工程來開發驅動程式或是使用現有供 Microsoft™ Windows™ 平台用的驅動程式 Binary。</p></div><div class=paragraph><p>FreeBSD 對 Network Driver Interface Specification (NDIS) 有提供 "原生" 的支援，這包含了 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> 可用來轉換 Windows™ XP 驅動程式成可在 FreeBSD 上使用的格式。由於 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> 驅動程式使用的是 Windows™ XP binary，所以只能在 i386™ 及 amd64 系統上執行。PCI, CardBus, PCMCIA 以及 USB 裝置也都有支援。</p></div><div class=paragraph><p>要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> 需要三樣東西：</p></div><div class="olist arabic"><ol class=arabic><li><p>FreeBSD 核心原始碼。</p></li><li><p>一個 <span class=filename>.SYS</span> 附檔名的 Windows™ XP 驅動程式 Binary。</p></li><li><p>一個 <span class=filename>.INF</span> 附檔名的 Windows™ XP 驅動程式設定檔。</p></li></ol></div><div class=paragraph><p>下載供指定 NIC 使用的 <span class=filename>.SYS</span> 及 <span class=filename>.INF</span> 檔。通常這些檔案可以在驅動程式 CD 或者供應商的網站上找到。以下範例會使用 <span class=filename>W32DRIVER.SYS</span> 及 <span class=filename>W32DRIVER.INF</span>。</p></div><div class=paragraph><p>驅動程式的位元寬度必須與 FreeBSD 的版本相符。例如 FreeBSD/i386 需要使用 Windows™ 32-bit 驅動程式，而 FreeBSD/amd64 則需要使用 Windows™ 64-bit 驅動程式。</p></div><div class=paragraph><p>下個步驟是編譯驅動程式 Binary 成可載入的核心模組。以 <code>root</code> 身份使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</span></code></pre></div></div><div class=paragraph><p>這個指令是互動式的，會提示輸入任何所需的額外資訊，新的核心模組會被產生在目前的目錄，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> 來載入新的模組：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ./W32DRIVER_SYS.ko</span></code></pre></div></div><div class=paragraph><p>除了產生的核心模組之外，<span class=filename>ndis.ko</span> 以及 <span class=filename>if_ndis.ko</span> 也必須載入，會在任何有相依 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> 的模組被載入時一併自動載入。若沒有自動載入，則需使用以下指令手動載入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>第一個指令會載入 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> miniport 驅動程式包裝程式，而第二個指令會載入產生的 NIC 驅動程式。</p></div><div class=paragraph><p>檢查 <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> 查看是否有任何載入錯誤，若一切正常，輸出結果應會如下所示：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>到此之後 <span class=filename>ndis0</span> 可以像任何其他 NIC 設定使用。</p></div><div class=paragraph><p>要設定系統於開機時載入 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> 模組，可複製產生的模組 <span class=filename>W32DRIVER_SYS.ko</span> 到 <span class=filename>/boot/modules</span>。然後加入下行到 <span class=filename>/boot/loader.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>W32DRIVER_SYS_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect3><h4 id=_設定網路卡>11.5.2. 設定網路卡<a class=anchor href=#_設定網路卡></a></h4><div class=paragraph><p>載入正確的 NIC 驅動程式之後，接著需要設定介面卡，這個動作可能在安裝時已經使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a> 設定過了。</p></div><div class=paragraph><p>要查看 NIC 設定可輸入以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig
dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active
dc1: <span class=nv>flags</span><span class=o>=</span>8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        <span class=nv>options</span><span class=o>=</span>3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 <span class=nv>options</span><span class=o>=</span>3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</code></pre></div></div><div class=paragraph><p>在這個例子中列出了以下裝置：</p></div><div class=ulist><ul><li><p><span class=filename>dc0</span>: 第一個乙太網路介面。</p></li><li><p><span class=filename>dc1</span>: 第二個乙太網路介面。</p></li><li><p><span class=filename>lo0</span>: Loopback 裝置。</p></li></ul></div><div class=paragraph><p>FreeBSD 會使用驅動程式名稱接著開機時所偵測到的介面卡順序來命名 NIC。例如 <span class=filename>sis2</span> 是指在系統上使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sis&amp;sektion=4&amp;format=html">sis(4)</a> 驅動程式的第三個 NIC。</p></div><div class=paragraph><p>在此例中，<span class=filename>dc0</span> 已經上線並且執行中。主要的依據有：</p></div><div class="olist arabic"><ol class=arabic><li><p><code>UP</code> 代表介面卡已設定好並且準備就緒。</p></li><li><p>介面卡有網際網路 (<code>inet</code>) 位址，<code>192.168.1.3</code>。</p></li><li><p>介面卡有一個有效的子網路遮罩 (<code>netmask</code>)，其中 <code>0xffffff00</code> 等同於 <code>255.255.255.0</code>。</p></li><li><p>介面卡有一個有效的廣播位址，<code>192.168.1.255</code>。</p></li><li><p>介面卡 (<code>ether</code>) 的 MAC 位址是 <code>00:a0:cc:da:da:da</code>。</p></li><li><p>實體媒介選擇為自動選擇模式 (<code>media: Ethernet autoselect (100baseTX &lt;full-duplex>)</code>)。在本例中 <span class=filename>dc1</span> 被設定使用 <code>10baseT/UTP</code> 媒介。要取得更多有關可用的驅動程式媒介類型請參考操作手冊。</p></li><li><p>連結的狀態 (<code>status</code>) 為使用中 (<code>active</code>)，代表有偵測到載波信號 (Carrier Signal)。若 <span class=filename>dc1</span> 所代表的介面卡未插入乙太網路線則狀態為 <code>status: no carrier</code> 是正常的。</p></li></ol></div><div class=paragraph><p>若 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 的輸出結果如下：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	<span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
	ether 00:a0:cc:da:da:da
	media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
	status: active</code></pre></div></div><div class=paragraph><p>則代表尚未設定介面卡。</p></div><div class=paragraph><p>介面卡必須以 <code>root</code> 來設定。NIC 的設定可在指令列執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 來完成，但重新開機之後變會消失，除非將設定也加到 <span class=filename>/etc/rc.conf</span>。若在 LAN 中有 DHCP 伺服器，則只需加入此行：</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>替換 <em>dc0</em> 為該系統的正確值。</p></div><div class=paragraph><p>加入這行之後，接著依據 <a href=#config-network-testing>測試與疑難排解</a> 指示操作。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若網路在安裝時已設定，可能會已經有 NIC 的設定項目。在加入任何設定前請再次檢查 <span class=filename>/etc/rc.conf</span>。</p></div></td></tr></tbody></table></div><div class=paragraph><p>在這個例中，沒有 DHCP 伺服器，必須手動設定 NIC。提每一個在系統上的 NIC 加入一行設定，如此例：</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_dc1=&#34;inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP&#34;</pre></div></div><div class=paragraph><p>替換 <span class=filename>dc0</span> 及 <span class=filename>dc1</span> 以及 IP 位址資訊為系統的正確值。請參考驅動程式的操作手冊、<a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 取得更多有關可用的選項及 <span class=filename>/etc/rc.conf</span> 的語法。</p></div><div class=paragraph><p>若網路沒有使用 DNS，則編輯 <span class=filename>/etc/hosts</span> 加入 LAN 上主機的名稱與 IP 位址。要取得更多資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> 及 <span class=filename>/usr/shared/examples/etc/hosts</span>。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若沒有 DHCP 伺服器且需要存取網際網路，那麼需要手動設定預設閘道及名稱伺服器：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;defaultrouter=&#34;your_default_router&#34;&#39; &gt;&gt; /etc/rc.conf</span>
<span class=c># echo &#39;nameserver your_DNS_server&#39; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=config-network-testing>11.5.3. 測試與疑難排解<a class=anchor href=#config-network-testing></a></h4><div class=paragraph><p>必要的變更儲存到 <span class=filename>/etc/rc.conf</span> 之後，需要重新啟動系統來測試網路設定並檢查系統重新啟動是否沒有任何設定錯誤。或者使用這個指令將設定套用到網路系統：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若預設的通訊閘已設定於 <span class=filename>/etc/rc.conf</span> 也同樣要下這個指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service routing restart</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>網路系統重新啟動後，便可接著測試 NIC。</p></div><div class=sect4><h5 id=_測試乙太網路卡>11.5.3.1. 測試乙太網路卡<a class=anchor href=#_測試乙太網路卡></a></h5><div class=paragraph><p>要檢查乙太網路卡是否已正確設定可 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> 介面卡自己，然後 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> 其他於 LAN 上的主機：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.3
PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.082 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.074 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.108 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms

<span class=nt>---</span> 192.168.1.3 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.074/0.083/0.108/0.013 ms</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.2
PING 192.168.1.2 <span class=o>(</span>192.168.1.2<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.726 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.766 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.700 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.747 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.704 ms

<span class=nt>---</span> 192.168.1.2 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.700/0.729/0.766/0.025 ms</code></pre></div></div><div class=paragraph><p>要測試網路解析，可使用主機名稱來替代 IP 位址。若在網路上沒有 DNS 伺服器則必須先設定 <span class=filename>/etc/hosts</span>，若主機尚未設定到 <span class=filename>/etc/hosts</span> 中，則需編輯 <span class=filename>/etc/hosts</span> 加入 LAN 上主機的名稱及 IP 位址，要取得更多資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> 及 <span class=filename>/usr/shared/examples/etc/hosts</span>。</p></div></div><div class=sect4><h5 id=_疑難排解_2>11.5.3.2. 疑難排解<a class=anchor href=#_疑難排解_2></a></h5><div class=paragraph><p>在排除硬體及軟體設定問題時，要先檢查幾件簡單的事。網路線插上了沒？網路的服務都正確設定了嗎？防火牆設定是否正確？FreeBSD 是否支援該 NIC？在回報問題之前，永遠要先檢查 Hardware Notes、更新 FreeBSD 到最新的 STABLE 版本、檢查郵遞論壇封存記錄以及上網查詢。</p></div><div class=paragraph><p>若介面卡可以運作，但是效能很差，請閱讀 <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>，同時也要檢查網路設定，因為不正確的網路設定會造成連線速度緩慢。</p></div><div class=paragraph><p>部份使用者會遇到一次或兩次 <code>device timeout</code> 的訊息，在對某些介面卡是正常的。若訊息持續發生或很煩的，請確認是否有與其他的裝置衝突，再次檢查網路線，或考慮使用其他介面卡。</p></div><div class=paragraph><p>要解決 <code>watchdog timeout</code> 錯誤，先檢查網路線。許多介面卡需要使用支援 Bus Mastering 的 PCI 插槽，在一些舊型的主機板，只會有一個 PCI 插槽支援，通常是插槽 0。檢查 NIC 以及主機板說明文件來確定是否為此問題。</p></div><div class=paragraph><p>若系統無法路由傳送封包到目標主機則會出現 <code>No route to host</code> 訊息，這可能是因為沒有指定預設的路由或未插上網路線。請檢查 <code>netstat -rn</code> 的輸出並確認有一個有效的路由可連線至主機，若沒有，請閱讀 <a href=./#network-routing>通訊閘與路由</a>。</p></div><div class=paragraph><p>造成 <code>ping: sendto: Permission denied</code> 錯誤訊息的原因通常是防火牆設定錯誤。若在 FreeBSD 上有開啟防火牆，但卻未定義任何的規則，預設的原則是拒絕所有傳輸，即使是用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>。請參考 <a href=./#firewalls>防火牆</a> 取得更多資訊。</p></div><div class=paragraph><p>有時介面卡的效能很差或低於平均值，在這種情況可嘗試設定媒介選擇模式由 <code>autoselect</code> 更改為正確的媒介選項，雖然這在大部份硬體可運作，但可能無法解決問題，同樣的，檢查所有網路設定並參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>。</p></div></div></div></div><div class=sect2><h3 id=configtuning-virtual-hosts>11.6. 虛擬主機<a class=anchor href=#configtuning-virtual-hosts></a></h3><div class=paragraph><p>FreeBSD 最常見的用途之一就是虛擬網站代管，即以一台伺服器在網路上扮演多台伺服器，這可以透過指定多個網路位置到一個網路介面來做到。</p></div><div class=paragraph><p>一個網路介面會有一個 "真實 (Real)" 位址且可以有許多個 "別名 (Alias)" 位址。一般會在 <span class=filename>/etc/rc.conf</span> 中放置別名項目來增加別名，如下例：</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>別名項目必須以 <code>alias<em>0</em></code> 開頭，使用連續數字例如 <code>alias0</code>, <code>alias1</code> 以此類推，設定程序會在第一個遇到缺號的地方中止。</p></div><div class=paragraph><p>要注意別名網路遮罩 (Netmask) 的計算，使用的介面必須至少有一個正確的填寫網路遮罩的位址，而其他所有在此網路中的位址則必須使用全部 <code>1</code> 的網路遮罩，可用 <code>255.255.255.255</code> 或 <code>0xffffffff</code> 來表示。</p></div><div class=paragraph><p>舉例來說，有一個 <span class=filename>fxp0</span> 介面連結到兩個網路：<code>10.1.1.0</code> 使用網路遮罩 <code>255.255.255.0</code> 以及 <code>202.0.75.16</code> 使用網路遮罩 <code>255.255.255.240</code>。而系統將要設定使用範圍 <code>10.1.1.1</code> 到 <code>10.1.1.5</code> 以及 <code>202.0.75.17</code> 到 <code>202.0.75.20</code>。在指定的網路範圍中只有第一個位址應使用真實的網路遮罩，其餘 (<code>10.1.1.2</code> 到 <code>10.1.1.5</code> 及 <code>202.0.75.18</code> 到 <code>202.0.75.20</code>) 則必須設定使用 <code>255.255.255.255</code> 的遮罩。</p></div><div class=paragraph><p>在此情境下正確設定網路介面的方式如下 <span class=filename>/etc/rc.conf</span> 中的項目：</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div><div class=paragraph><p>有一種更簡單的方式可以表達這些設定，便是使用以空白分隔的 IP 位址清單。只有第一個位址會使用指定的子網路遮罩，其他的位址則會使用 <code>255.255.255.255</code> 的子網路遮罩。</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_aliases=&#34;inet 10.1.1.1-5/24 inet 202.0.75.17-20/28&#34;</pre></div></div></div><div class=sect2><h3 id=configtuning-syslog>11.7. 設定系統日誌<a class=anchor href=#configtuning-syslog></a></h3><div class=paragraph><p>產生與讀取系統日誌對系統管理來說是一件非常重要的事，在系統日誌中的資訊可以用來偵測硬體與軟體的問題，同樣也可以偵測應用程式與系統設定的錯誤。這些資訊在安全性稽查與事件回應也同樣扮演了重要的角色，大多數系統 Daemon 與應用程式都會產生日誌項目。</p></div><div class=paragraph><p>FreeBSD 提供了一個系統日誌程式 syslogd 用來管理日誌。預設 syslogd 會與系統開機時啟動。這可使用在 <span class=filename>/etc/rc.conf</span> 中的變數 <code>syslogd_enable</code> 來控制。而且有數個應用程式參數可在 <span class=filename>/etc/rc.conf</span> 使用 <code>syslogd_flags</code> 來設定。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> 來取得更多可用參數的資訊。</p></div><div class=paragraph><p>此章節會介紹如何設定 FreeBSD 系統日誌程式來做本地與遠端日誌並且介紹如何執行日誌翻轉 (Log rotation) 與日誌管理。</p></div><div class=sect3><h4 id=_設定本地日誌>11.7.1. 設定本地日誌<a class=anchor href=#_設定本地日誌></a></h4><div class=paragraph><p>設定檔 <span class=filename>/etc/syslog.conf</span> 控制 syslogd 收到日誌項目時要做的事情，有數個參數可以用來控制接收到事件時的處理方式。<em>設施 (facility)</em> 用來描述記錄產生訊息的子系統 (subsystem)，如核心或者 Daemon，而 <em>層級 (level)</em> 用來描述所發生的事件嚴重性。也可以依據應用程式所發出的訊息及產生日誌事件機器的主機名稱來決定後續處置的動作。</p></div><div class=paragraph><p>此設定檔中一行代表一個動作，每一行的格式皆為一個選擇器欄位 (Selector field) 接著一個動作欄位 (Action field)。選擇器欄位的格式為 <em>facility.level</em> 可以用來比對來自 <em>facility</em> 於層級 <em>level</em> 或更高層的日誌訊息，也可以在層級前加入選擇性的比對旗標來更確切的指定記錄的內容。同樣一個動作可以使用多個選擇器欄位並使用分號 (<code>;</code>) 來分隔。用 <code>*</code> 可以比對任何東西。動作欄位可用來指定傳送日誌訊息的目標，如一個檔案或遠端日誌主機。範例為以下為 FreeBSD 預設的 <span class=filename>syslog.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit                /dev/console
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
security.*                                      /var/log/security
auth.info;authpriv.info                         /var/log/auth.log
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
ftp.info                                        /var/log/xferlog
cron.*                                          /var/log/cron
!-devd
*.=debug                                        /var/log/debug.log
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
# Uncomment this if you wish to see messages produced by devd
# !devd
# *.&gt;=info
!ppp
*.*                                             /var/log/ppp.log
!*</pre></div></div><div class=paragraph><p>在這個範例中：</p></div><div class=ulist><ul><li><p>第 8 行會找出所有符合 <code>err</code> 或以上層級的訊息，還有 <code>kern.warning</code>, <code>auth.notice</code> 與 <code>mail.crit</code> 的訊息，然後將這些日誌訊息傳送到 Console (<span class=filename>/dev/console</span>)。</p></li><li><p>第 12 行會找出所有符合 <code>mail</code> 設施中於 <code>info</code> 或以上層級的訊息，並記錄訊息至 <span class=filename>/var/log/maillog</span>。</p></li><li><p>第 17 行使用了比較旗標 (<code>=</code>) 來只找出符合 <code>debug</code> 層級的訊息，並將訊息記錄至 <span class=filename>/var/log/debug.log</span>。</p></li><li><p>第 33 行是指定程式的範例用法。這可以讓在該行以下的規則只對指定的程式生效。在此例中，只有由 ppp 產生的訊息會被記錄到 <span class=filename>/var/log/ppp.log</span>。</p></li></ul></div><div class=paragraph><p>所以可用層級從最嚴重到最不嚴重的順序為 <code>emerg</code>, <code>alert</code>, <code>crit</code>, <code>err</code>, <code>warning</code>, <code>notice</code>, <code>info</code> 以及 <code>debug</code>。</p></div><div class=paragraph><p>設施 (facility) 則無特定順序，可用的有 <code>auth</code>, <code>authpriv</code>, <code>console</code>, <code>cron</code>, <code>daemon</code>, <code>ftp</code>, <code>kern</code>, <code>lpr</code>, <code>mail</code>, <code>mark</code>, <code>news</code>, <code>security</code>, <code>syslog</code>, <code>user</code>, <code>uucp</code> 及 <code>local0</code> 到 <code>local7</code>。要注意在其他作業系統的設施可能會不同。</p></div><div class=paragraph><p>要記錄所有所有 <code>notice</code> 與以上層級的訊息到 <span class=filename>/var/log/daemon.log</span> 可加入以下項目：</p></div><div class="literalblock programlisting"><div class=content><pre>daemon.notice                                        /var/log/daemon.log</pre></div></div><div class=paragraph><p>要取得更多有關不同的層級與設施的資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> 及 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>。要取得更多有關 <span class=filename>/etc/syslog.conf</span>、語法以及更多進階用法範例的資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>。</p></div></div><div class=sect3><h4 id=_日誌管理與翻轉>11.7.2. 日誌管理與翻轉<a class=anchor href=#_日誌管理與翻轉></a></h4><div class=paragraph><p>日誌檔案會成長的非常快速，這會消耗磁碟空間並且會更難在日誌中找到有用的資訊，日誌管理便是為了嘗試減緩這種問題。在 FreeBSD 可以使用 newsyslog 來管理日誌檔案，這個內建的程式會定期翻轉 (Rotate) 與壓縮日誌檔案，並且可選擇性的建立遺失的日誌檔案並在日誌檔案被移動位置時通知程式。日誌檔案可能會由 syslogd 產生或由其他任何會產生日誌檔案的程式。newsyslog 正常會由 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 來執行，它並非一個系統 Daemon，預設會每個小時執行一次。</p></div><div class=paragraph><p>newsyslog 會讀取其設定檔 <span class=filename>/etc/newsyslog.conf</span> 來決定其要採取的動作，每個要由 newsyslog 所管理的日誌檔案會在此設定檔中設定一行，每一行要說明檔案的擁有者、權限、何時要翻轉該檔案、選用的日誌翻轉旗標，如：壓縮，以及日誌翻轉時要通知的程式。以下為 FreeBSD 的預設設定：</p></div><div class="literalblock programlisting"><div class=content><pre># configuration file for newsyslog
# $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $
#
# Entries which do not specify the &#39;/pid_file&#39; field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the &#39;N&#39; flag.
#
# The &#39;flags&#39; field is one or more of the letters: BCDGJNUXZ or a &#39;-&#39;.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/amd.log                        644  7     100  *     J
/var/log/auth.log                       600  7     100  @0101T JC
/var/log/console.log                    600  5     100  *     J
/var/log/cron                           600  3     100  *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     100  *     JC
/var/log/kerberos.log                   600  7     100  *     J
/var/log/lpd-errs                       644  7     100  *     JC
/var/log/maillog                        640  7     *    @T00  JC
/var/log/messages                       644  5     100  @0101T JC
/var/log/monthly.log                    640  12    *    $M1D0 JN
/var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log        root:network    640  3     100  *     JC
/var/log/devd.log                       644  3     100  *     JC
/var/log/security                       600  10    100  *     JC
/var/log/sendmail.st                    640  10    *    168   B
/var/log/utx.log                        644  3     *    @01T05 B
/var/log/weekly.log                     640  5     1    $W6D0 JN
/var/log/xferlog                        600  7     100  *     JC</pre></div></div><div class=paragraph><p>每一行的開始為要翻轉的日誌名稱、接著是供翻轉與新建檔案使用的擁有者及群組 (選填)。<code>mode</code> 欄位可設定日誌檔案的權限，<code>count</code> 代表要保留多少個翻轉過的日誌檔案，而 <code>size</code> 與 <code>when</code> 欄位會告訴 newsyslog 何時要翻轉該檔案。日誌檔案會在當其檔案超過 <code>size</code> 欄位的大小或已超過 <code>when</code> 欄位指定的時間時翻轉，可使用星號 (<code>*</code>) 忽略該欄位。<em>flags</em> 欄位可以給予進階的參數，例如：如何壓縮翻轉後檔案或建立遺失的日誌檔案。最後兩個欄位皆為選填，可指定程序的程序 ID (PID) 檔名稱以及檔案翻轉後要傳送給該程序的信號 (Signal) 編號。</p></div><div class=paragraph><p>要取的更多有關所有欄位、可用的旗標及如何指定翻轉時間，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a>。由於 newsyslog 是由 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 執行，因此無法比其在 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 中所排定的時間間距內更頻繁的執行翻轉檔案。</p></div></div><div class=sect3><h4 id=network-syslogd>11.7.3. 設定遠端日誌<a class=anchor href=#network-syslogd></a></h4><div class=paragraph><p>Monitoring the log files of multiple hosts can become unwieldy as the number of systems increases. Configuring centralized logging can reduce some of the administrative burden of log file administration.</p></div><div class=paragraph><p>In FreeBSD, centralized log file aggregation, merging, and rotation can be configured using syslogd and newsyslog. This section demonstrates an example configuration, where host <code>A</code>, named <code>logserv.example.com</code>, will collect logging information for the local network. Host <code>B</code>, named <code>logclient.example.com</code>, will be configured to pass logging information to the logging server.</p></div><div class=sect4><h5 id=_日誌伺服器設定>11.7.3.1. 日誌伺服器設定<a class=anchor href=#_日誌伺服器設定></a></h5><div class=paragraph><p>A log server is a system that has been configured to accept logging information from other hosts. Before configuring a log server, check the following:</p></div><div class=ulist><ul><li><p>If there is a firewall between the logging server and any logging clients, ensure that the firewall ruleset allows UDP port 514 for both the clients and the server.</p></li><li><p>The logging server and all client machines must have forward and reverse entries in the local DNS. If the network does not have a DNS server, create entries in each system’s <span class=filename>/etc/hosts</span>. Proper name resolution is required so that log entries are not rejected by the logging server.</p></li></ul></div><div class=paragraph><p>On the log server, edit <span class=filename>/etc/syslog.conf</span> to specify the name of the client to receive log entries from, the logging facility to be used, and the name of the log to store the host’s log entries. This example adds the hostname of <code>B</code>, logs all facilities, and stores the log entries in <span class=filename>/var/log/logclient.log</span>.</p></div><div class=exampleblock><div class=title>例 25. 日誌伺服器設定範例</div><div class=content><div class="literalblock programlisting"><div class=content><pre>+logclient.example.com
*.*     /var/log/logclient.log</pre></div></div></div></div><div class=paragraph><p>When adding multiple log clients, add a similar two-line entry for each client. More information about the available facilities may be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>.</p></div><div class=paragraph><p>Next, configure <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-a logclient.example.com -v -v&#34;</pre></div></div><div class=paragraph><p>The first entry starts syslogd at system boot. The second entry allows log entries from the specified client. The <code>-v -v</code> increases the verbosity of logged messages. This is useful for tweaking facilities as administrators are able to see what type of messages are being logged under each facility.</p></div><div class=paragraph><p>Multiple <code>-a</code> options may be specified to allow logging from multiple clients. IP addresses and whole netblocks may also be specified. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> for a full list of possible options.</p></div><div class=paragraph><p>Finally, create the log file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/logclient.log</span></code></pre></div></div><div class=paragraph><p>At this point, syslogd should be restarted and verified:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
<span class=c># pgrep syslog</span></code></pre></div></div><div class=paragraph><p>If a PID is returned, the server restarted successfully, and client configuration can begin. If the server did not restart, consult <span class=filename>/var/log/messages</span> for the error.</p></div></div><div class=sect4><h5 id=_日誌客戶端設定>11.7.3.2. 日誌客戶端設定<a class=anchor href=#_日誌客戶端設定></a></h5><div class=paragraph><p>A logging client sends log entries to a logging server on the network. The client also keeps a local copy of its own logs.</p></div><div class=paragraph><p>Once a logging server has been configured, edit <span class=filename>/etc/rc.conf</span> on the logging client:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-s -v -v&#34;</pre></div></div><div class=paragraph><p>The first entry enables syslogd on boot up. The second entry prevents logs from being accepted by this client from other hosts (<code>-s</code>) and increases the verbosity of logged messages.</p></div><div class=paragraph><p>Next, define the logging server in the client’s <span class=filename>/etc/syslog.conf</span>. In this example, all logged facilities are sent to a remote system, denoted by the <code>@</code> symbol, with the specified hostname:</p></div><div class="literalblock programlisting"><div class=content><pre>*.*		@logserv.example.com</pre></div></div><div class=paragraph><p>After saving the edit, restart syslogd for the changes to take effect:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>To test that log messages are being sent across the network, use <a href="https://man.freebsd.org/cgi/man.cgi?query=logger&amp;sektion=1&amp;format=html">logger(1)</a> on the client to send a message to syslogd:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># logger &#34;Test message from logclient&#34;</span></code></pre></div></div><div class=paragraph><p>This message should now exist both in <span class=filename>/var/log/messages</span> on the client and <span class=filename>/var/log/logclient.log</span> on the log server.</p></div></div><div class=sect4><h5 id=_日誌伺服器除錯>11.7.3.3. 日誌伺服器除錯<a class=anchor href=#_日誌伺服器除錯></a></h5><div class=paragraph><p>If no messages are being received on the log server, the cause is most likely a network connectivity issue, a hostname resolution issue, or a typo in a configuration file. To isolate the cause, ensure that both the logging server and the logging client are able to <code>ping</code> each other using the hostname specified in their <span class=filename>/etc/rc.conf</span>. If this fails, check the network cabling, the firewall ruleset, and the hostname entries in the DNS server or <span class=filename>/etc/hosts</span> on both the logging server and clients. Repeat until the <code>ping</code> is successful from both hosts.</p></div><div class=paragraph><p>If the <code>ping</code> succeeds on both hosts but log messages are still not being received, temporarily increase logging verbosity to narrow down the configuration issue. In the following example, <span class=filename>/var/log/logclient.log</span> on the logging server is empty and <span class=filename>/var/log/messages</span> on the logging client does not indicate a reason for the failure. To increase debugging output, edit the <code>syslogd_flags</code> entry on the logging server and issue a restart:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_flags=&#34;-d -a logclient.example.com -v -v&#34;</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>Debugging data similar to the following will flash on the console immediately after the restart:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
Logging to FILE /var/log/messages
syslogd: kernel boot file is /boot/kernel/kernel
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
rejected <span class=k>in </span>rule 0 due to name mismatch.</code></pre></div></div><div class=paragraph><p>In this example, the log messages are being rejected due to a typo which results in a hostname mismatch. The client’s hostname should be <code>logclient</code>, not <code>logclien</code>. Fix the typo, issue a restart, and verify the results:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel
logmsg: pri 166, flags 17, from logserv.example.com,
msg Dec 10 20:55:02 &lt;syslog.err&gt; logserv.example.com syslogd: exiting on signal 2
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
accepted <span class=k>in </span>rule 0.
logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
Logging to FILE /var/log/logclient.log
Logging to FILE /var/log/messages</code></pre></div></div><div class=paragraph><p>At this point, the messages are being properly received and placed in the correct file.</p></div></div><div class=sect4><h5 id=_安全注意事項>11.7.3.4. 安全注意事項<a class=anchor href=#_安全注意事項></a></h5><div class=paragraph><p>As with any network service, security requirements should be considered before implementing a logging server. Log files may contain sensitive data about services enabled on the local host, user accounts, and configuration data. Network data sent from the client to the server will not be encrypted or password protected. If a need for encryption exists, consider using <a class=package href=https://cgit.freebsd.org/ports/tree/security/stunnel/>security/stunnel</a>, which will transmit the logging data over an encrypted tunnel.</p></div><div class=paragraph><p>Local security is also an issue. Log files are not encrypted during use or after log rotation. Local users may access log files to gain additional insight into system configuration. Setting proper permissions on log files is critical. The built-in log rotator, newsyslog, supports setting permissions on newly created and rotated log files. Setting log files to mode <code>600</code> should prevent unwanted access by local users. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> for additional information.</p></div></div></div></div><div class=sect2><h3 id=configtuning-configfiles>11.8. 設定檔<a class=anchor href=#configtuning-configfiles></a></h3><div class=sect3><h4 id=_etc_配置>11.8.1. <span class=filename>/etc</span> 配置<a class=anchor href=#_etc_配置></a></h4><div class=paragraph><p>有數個目錄中儲存著設定資訊，這些目錄有：</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>通用系統特定的設定資訊。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>系統設定檔的預設版本。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> 額外的設定以及其他 MTA 設定檔。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>user- 及 kernel-ppp 程式的設定。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>已安裝應用程式的設定檔，可能會有以應用程式區分的子目錄。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>已安裝應用程式的 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> Script。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>自動產生的系統特定資料庫檔案，例如套件資料庫以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=locate&amp;sektion=1&amp;format=html">locate(1)</a> 資料庫。</p></td></tr></tbody></table></div><div class=sect3><h4 id=_主機名稱>11.8.2. 主機名稱<a class=anchor href=#_主機名稱></a></h4><div class=sect4><h5 id=_etcresolv_conf>11.8.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h5><div class=paragraph><p>FreeBSD 要如何存取網際網路網域名稱系統 (Internet Domain Name System, DNS) 是由 <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> 來控制。</p></div><div class=paragraph><p><span class=filename>/etc/resolv.conf</span> 中最常用的項目為：</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>解析程式 (Resolver) 要查詢的名稱伺服器 IP 位置，這些伺服器會依所列的順序來查詢，最多可以有三個。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>主機名稱查詢使用的搜尋清單。這通常會使用本機主機名稱所在的網域。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>本地網域名稱。</p></td></tr></tbody></table><div class=paragraph><p>典型的 <span class=filename>/etc/resolv.conf</span> 會如下：</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>search</code> 與 <code>domain</code> 選項應擇一使用。</p></div></td></tr></tbody></table></div><div class=paragraph><p>當使用 DHCP 時，<a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 通常會使用從 DHCP 伺服器所接收到的資訊覆寫 <span class=filename>/etc/resolv.conf</span>。</p></div></div><div class=sect4><h5 id=_etchosts>11.8.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h5><div class=paragraph><p><span class=filename>/etc/hosts</span> 是簡單的文字資料庫，會與 DNS 及 NIS 一併使用來提供主機名稱與 IP 位址的對應。可將透過 LAN 所連結的在地電腦項目加入到這個檔案做最簡單的命名，來替代設定一個 <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> 伺服器。除此之外 <span class=filename>/etc/hosts</span> 可以用來提供本地的網際網路名稱記錄，來減少常用名稱向外部 DNS 伺服器查詢的需求。</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace &#39;my.domain&#39; below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#	10.0.0.0	-   10.255.255.255
#	172.16.0.0	-   172.31.255.255
#	192.168.0.0	-   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</pre></div></div><div class=paragraph><p><span class=filename>/etc/hosts</span> 的格式如下：</p></div><div class="literalblock programlisting"><div class=content><pre>[Internet address] [official hostname] [alias1] [alias2] ...</pre></div></div><div class=paragraph><p>例如：</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> 取得更多資訊。</p></div></div></div></div><div class=sect2><h3 id=configtuning-sysctl>11.9. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 調校<a class=anchor href=#configtuning-sysctl></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 可用來更改執行中的 FreeBSD 系統，這包含許多 TCP/IP 堆疊及虛擬記憶體系統的進階選項，讓有經驗的系統管理者能夠簡單的提升效能。有超過五百個系統變數可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 來讀取與設定。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 主要提供兩個功能：讀取與修改系統設定。</p></div><div class=paragraph><p>檢視所有可讀取的變數：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>要讀取特定變數只要指定其名稱：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>要設定特定變數可使用 <em>variable</em>=<em>value</em> 語法：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>sysctl 的設定值通常為字串、數字或布林值，其中布林值的 <code>1</code> 代表是，<code>0</code> 代表否。</p></div><div class=paragraph><p>要在每次機器開機時自動設定一些變數可將其加入到 <span class=filename>/etc/sysctl.conf</span>。要取得更多的資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> 及 <a href=#configtuning-sysctlconf><span class=filename>sysctl.conf</span></a>。</p></div><div class=sect3><h4 id=configtuning-sysctlconf>11.9.1. <span class=filename>sysctl.conf</span><a class=anchor href=#configtuning-sysctlconf></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 的設定檔於 <span class=filename>/etc/sysctl.conf</span>，內容很像 <span class=filename>/etc/rc.conf</span>，設定數值使用 <code>variable=value</code> 格式。指定的數值會在系統進入多使用者模式時設定，但並非所有變數皆可在此模式設定。</p></div><div class=paragraph><p>例如，要關閉嚴重信號 (Fatal signal) 中止的記錄並避免使用者看到其他使用者所執行的程序，可加入以下設定到 <span class=filename>/etc/sysctl.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre># Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre></div></div></div><div class=sect3><h4 id=sysctl-readonly>11.9.2. 唯讀 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><a class=anchor href=#sysctl-readonly></a></h4><div class=paragraph><p>在有些情況可能會需要修改唯讀的 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 數值，而這會需要重新啟動系統。</p></div><div class=paragraph><p>例如，某些筆電型號的 <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> 裝置無法偵測到記憶體範圍而且會失效並有類似以下的錯誤：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</code></pre></div></div><div class=paragraph><p>這個修正需要修改唯讀的 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 設定。加入 <code>hw.pci.allow_unsupported_io_range=1</code> 到 <span class=filename>/boot/loader.conf</span> 然後重新啟動。現在 <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> 應可正常運作。</p></div></div></div><div class=sect2><h3 id=configtuning-disk>11.10. 調校磁碟<a class=anchor href=#configtuning-disk></a></h3><div class=paragraph><p>接下來的章節會討論在磁碟裝置上各種可調校的機制與選項。在大多數案例中，有使用機械元件的硬碟，如 SCSI 磁碟機，會成為導致整體系統效能低下的瓶頸。雖然已經有不使用機械元件的磁碟機解決方案，如，固態硬碟，但使用機械元件的磁碟機短期內並不會消失。在調校磁碟時，建議可以利用 <a href="https://man.freebsd.org/cgi/man.cgi?query=iostat&amp;sektion=8&amp;format=html">iostat(8)</a> 指令的功能來測試各種對系統的變更，這個指令可讓使用者取得系統 IO 相關的有用資訊。</p></div><div class=sect3><h4 id=_sysctl_變數>11.10.1. Sysctl 變數<a class=anchor href=#_sysctl_變數></a></h4><div class=sect4><h5 id=_vfs_vmiodirenable>11.10.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h5><div class=paragraph><p>The <code>vfs.vmiodirenable</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable may be set to either <code>0</code> (off) or <code>1</code> (on). It is set to <code>1</code> by default. This variable controls how directories are cached by the system. Most directories are small, using just a single fragment (typically 1 K) in the file system and typically 512 bytes in the buffer cache. With this variable turned off, the buffer cache will only cache a fixed number of directories, even if the system has a huge amount of memory. When turned on, this <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> allows the buffer cache to use the VM page cache to cache the directories, making all the memory available for caching directories. However, the minimum in-core memory used to cache a directory is the physical page size (typically 4 K) rather than 512 bytes. Keeping this option enabled is recommended if the system is running any services which manipulate large numbers of files. Such services can include web caches, large mail systems, and news systems. Keeping this option on will generally not reduce performance, even with the wasted memory, but one should experiment to find out.</p></div></div><div class=sect4><h5 id=_vfs_write_behind>11.10.1.2. <code>vfs.write_behind</code><a class=anchor href=#_vfs_write_behind></a></h5><div class=paragraph><p>The <code>vfs.write_behind</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable defaults to <code>1</code> (on). This tells the file system to issue media writes as full clusters are collected, which typically occurs when writing large sequential files. This avoids saturating the buffer cache with dirty buffers when it would not benefit I/O performance. However, this may stall processes and under certain circumstances should be turned off.</p></div></div><div class=sect4><h5 id=_vfs_hirunningspace>11.10.1.3. <code>vfs.hirunningspace</code><a class=anchor href=#_vfs_hirunningspace></a></h5><div class=paragraph><p>The <code>vfs.hirunningspace</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable determines how much outstanding write I/O may be queued to disk controllers system-wide at any given instance. The default is usually sufficient, but on machines with many disks, try bumping it up to four or five <em>megabytes</em>. Setting too high a value which exceeds the buffer cache’s write threshold can lead to bad clustering performance. Do not set this value arbitrarily high as higher write values may add latency to reads occurring at the same time.</p></div><div class=paragraph><p>There are various other buffer cache and VM page cache related <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> values. Modifying these values is not recommended as the VM system does a good job of automatically tuning itself.</p></div></div><div class=sect4><h5 id=_vm_swap_idle_enabled>11.10.1.4. <code>vm.swap_idle_enabled</code><a class=anchor href=#_vm_swap_idle_enabled></a></h5><div class=paragraph><p>The <code>vm.swap_idle_enabled</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable is useful in large multi-user systems with many active login users and lots of idle processes. Such systems tend to generate continuous pressure on free memory reserves. Turning this feature on and tweaking the swapout hysteresis (in idle seconds) via <code>vm.swap_idle_threshold1</code> and <code>vm.swap_idle_threshold2</code> depresses the priority of memory pages associated with idle processes more quickly then the normal pageout algorithm. This gives a helping hand to the pageout daemon. Only turn this option on if needed, because the tradeoff is essentially pre-page memory sooner rather than later which eats more swap and disk bandwidth. In a small system this option will have a determinable effect, but in a large system that is already doing moderate paging, this option allows the VM system to stage whole processes into and out of memory easily.</p></div></div><div class=sect4><h5 id=_hw_ata_wc>11.10.1.5. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h5><div class=paragraph><p>Turning off IDE write caching reduces write bandwidth to IDE disks, but may sometimes be necessary due to data consistency issues introduced by hard drive vendors. The problem is that some IDE drives lie about when a write completes. With IDE write caching turned on, IDE hard drives write data to disk out of order and will sometimes delay writing some blocks indefinitely when under heavy disk load. A crash or power failure may cause serious file system corruption. Check the default on the system by observing the <code>hw.ata.wc</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable. If IDE write caching is turned off, one can set this read-only variable to <code>1</code> in <span class=filename>/boot/loader.conf</span> in order to enable it at boot time.</p></div><div class=paragraph><p>For more information, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a>.</p></div></div><div class=sect4><h5 id=_scsi_delay_kern_cam_scsi_delay>11.10.1.6. <code>SCSI_DELAY</code> (<code>kern.cam.scsi_delay</code>)<a class=anchor href=#_scsi_delay_kern_cam_scsi_delay></a></h5><div class=paragraph><p>The <code>SCSI_DELAY</code> kernel configuration option may be used to reduce system boot times. The defaults are fairly high and can be responsible for <code>15</code> seconds of delay in the boot process. Reducing it to <code>5</code> seconds usually works with modern drives. The <code>kern.cam.scsi_delay</code> boot time tunable should be used. The tunable and kernel configuration option accept values in terms of <em>milliseconds</em> and <em>not seconds</em>.</p></div></div></div><div class=sect3><h4 id=soft-updates>11.10.2. 軟更新<a class=anchor href=#soft-updates></a></h4><div class=paragraph><p>To fine-tune a file system, use <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>. This program has many different options. To toggle Soft Updates on and off, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>A file system cannot be modified with <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> while it is mounted. A good time to enable Soft Updates is before any partitions have been mounted, in single-user mode.</p></div><div class=paragraph><p>Soft Updates is recommended for UFS file systems as it drastically improves meta-data performance, mainly file creation and deletion, through the use of a memory cache. There are two downsides to Soft Updates to be aware of. First, Soft Updates guarantee file system consistency in the case of a crash, but could easily be several seconds or even a minute behind updating the physical disk. If the system crashes, unwritten data may be lost. Secondly, Soft Updates delay the freeing of file system blocks. If the root file system is almost full, performing a major update, such as <code>make installworld</code>, can cause the file system to run out of space and the update to fail.</p></div><div class=sect4><h5 id=_有關軟更新的更多詳細資訊>11.10.2.1. 有關軟更新的更多詳細資訊<a class=anchor href=#_有關軟更新的更多詳細資訊></a></h5><div class=paragraph><p>Meta-data updates are updates to non-content data like inodes or directories. There are two traditional approaches to writing a file system’s meta-data back to disk.</p></div><div class=paragraph><p>Historically, the default behavior was to write out meta-data updates synchronously. If a directory changed, the system waited until the change was actually written to disk. The file data buffers (file contents) were passed through the buffer cache and backed up to disk later on asynchronously. The advantage of this implementation is that it operates safely. If there is a failure during an update, meta-data is always in a consistent state. A file is either created completely or not at all. If the data blocks of a file did not find their way out of the buffer cache onto the disk by the time of the crash, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> recognizes this and repairs the file system by setting the file length to <code>0</code>. Additionally, the implementation is clear and simple. The disadvantage is that meta-data changes are slow. For example, <code>rm -r</code> touches all the files in a directory sequentially, but each directory change will be written synchronously to the disk. This includes updates to the directory itself, to the inode table, and possibly to indirect blocks allocated by the file. Similar considerations apply for unrolling large hierarchies using <code>tar -x</code>.</p></div><div class=paragraph><p>The second approach is to use asynchronous meta-data updates. This is the default for a UFS file system mounted with <code>mount -o async</code>. Since all meta-data updates are also passed through the buffer cache, they will be intermixed with the updates of the file content data. The advantage of this implementation is there is no need to wait until each meta-data update has been written to disk, so all operations which cause huge amounts of meta-data updates work much faster than in the synchronous case. This implementation is still clear and simple, so there is a low risk for bugs creeping into the code. The disadvantage is that there is no guarantee for a consistent state of the file system. If there is a failure during an operation that updated large amounts of meta-data, like a power failure or someone pressing the reset button, the file system will be left in an unpredictable state. There is no opportunity to examine the state of the file system when the system comes up again as the data blocks of a file could already have been written to the disk while the updates of the inode table or the associated directory were not. It is impossible to implement a <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> which is able to clean up the resulting chaos because the necessary information is not available on the disk. If the file system has been damaged beyond repair, the only choice is to reformat it and restore from backup.</p></div><div class=paragraph><p>The usual solution for this problem is to implement <em>dirty region logging</em>, which is also referred to as <em>journaling</em>. Meta-data updates are still written synchronously, but only into a small region of the disk. Later on, they are moved to their proper location. Because the logging area is a small, contiguous region on the disk, there are no long distances for the disk heads to move, even during heavy operations, so these operations are quicker than synchronous updates. Additionally, the complexity of the implementation is limited, so the risk of bugs being present is low. A disadvantage is that all meta-data is written twice, once into the logging region and once to the proper location, so performance "pessimization" might result. On the other hand, in case of a crash, all pending meta-data operations can be either quickly rolled back or completed from the logging area after the system comes up again, resulting in a fast file system startup.</p></div><div class=paragraph><p>Kirk McKusick, the developer of Berkeley FFS, solved this problem with Soft Updates. All pending meta-data updates are kept in memory and written out to disk in a sorted sequence ("ordered meta-data updates"). This has the effect that, in case of heavy meta-data operations, later updates to an item "catch" the earlier ones which are still in memory and have not already been written to disk. All operations are generally performed in memory before the update is written to disk and the data blocks are sorted according to their position so that they will not be on the disk ahead of their meta-data. If the system crashes, an implicit "log rewind" causes all operations which were not written to the disk appear as if they never happened. A consistent file system state is maintained that appears to be the one of 30 to 60 seconds earlier. The algorithm used guarantees that all resources in use are marked as such in their blocks and inodes. After a crash, the only resource allocation error that occurs is that resources are marked as "used" which are actually "free". <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> recognizes this situation, and frees the resources that are no longer used. It is safe to ignore the dirty state of the file system after a crash by forcibly mounting it with <code>mount -f</code>. In order to free resources that may be unused, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> needs to be run at a later time. This is the idea behind the <em>background <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a></em>: at system startup time, only a <em>snapshot</em> of the file system is recorded and <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> is run afterwards. All file systems can then be mounted "dirty", so the system startup proceeds in multi-user mode. Then, background <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> is scheduled for all file systems where this is required, to free resources that may be unused. File systems that do not use Soft Updates still need the usual foreground <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>.</p></div><div class=paragraph><p>The advantage is that meta-data operations are nearly as fast as asynchronous updates and are faster than <em>logging</em>, which has to write the meta-data twice. The disadvantages are the complexity of the code, a higher memory consumption, and some idiosyncrasies. After a crash, the state of the file system appears to be somewhat "older". In situations where the standard synchronous approach would have caused some zero-length files to remain after the <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, these files do not exist at all with Soft Updates because neither the meta-data nor the file contents have been written to disk. Disk space is not released until the updates have been written to disk, which may take place some time after running <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a>. This may cause problems when installing large amounts of data on a file system that does not have enough free space to hold all the files twice.</p></div></div></div></div><div class=sect2><h3 id=configtuning-kernel-limits>11.11. 調校核心限制<a class=anchor href=#configtuning-kernel-limits></a></h3><div class=sect3><h4 id=file-process-limits>11.11.1. 檔案/程序限制<a class=anchor href=#file-process-limits></a></h4><div class=sect4><h5 id=kern-maxfiles>11.11.1.1. <code>kern.maxfiles</code><a class=anchor href=#kern-maxfiles></a></h5><div class=paragraph><p>The <code>kern.maxfiles</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable can be raised or lowered based upon system requirements. This variable indicates the maximum number of file descriptors on the system. When the file descriptor table is full, <code>file: table is full</code> will show up repeatedly in the system message buffer, which can be viewed using <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>.</p></div><div class=paragraph><p>Each open file, socket, or fifo uses one file descriptor. A large-scale production server may easily require many thousands of file descriptors, depending on the kind and number of services running concurrently.</p></div><div class=paragraph><p>In older FreeBSD releases, the default value of <code>kern.maxfiles</code> is derived from <code>maxusers</code> in the kernel configuration file. <code>kern.maxfiles</code> grows proportionally to the value of <code>maxusers</code>. When compiling a custom kernel, consider setting this kernel configuration option according to the use of the system. From this number, the kernel is given most of its pre-defined limits. Even though a production machine may not have 256 concurrent users, the resources needed may be similar to a high-scale web server.</p></div><div class=paragraph><p>The read-only <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable <code>kern.maxusers</code> is automatically sized at boot based on the amount of memory available in the system, and may be determined at run-time by inspecting the value of <code>kern.maxusers</code>. Some systems require larger or smaller values of <code>kern.maxusers</code> and values of <code>64</code>, <code>128</code>, and <code>256</code> are not uncommon. Going above <code>256</code> is not recommended unless a huge number of file descriptors is needed. Many of the tunable values set to their defaults by <code>kern.maxusers</code> may be individually overridden at boot-time or run-time in <span class=filename>/boot/loader.conf</span>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> and <span class=filename>/boot/defaults/loader.conf</span> for more details and some hints.</p></div><div class=paragraph><p>In older releases, the system will auto-tune <code>maxusers</code> if it is set to <code>0</code>. . When setting this option, set <code>maxusers</code> to at least <code>4</code>, especially if the system runs Xorg or is used to compile software. The most important table set by <code>maxusers</code> is the maximum number of processes, which is set to <code>20 + 16 * maxusers</code>. If <code>maxusers</code> is set to <code>1</code>, there can only be <code>36</code> simultaneous processes, including the <code>18</code> or so that the system starts up at boot time and the <code>15</code> or so used by Xorg. Even a simple task like reading a manual page will start up nine processes to filter, decompress, and view it. Setting <code>maxusers</code> to <code>64</code> allows up to <code>1044</code> simultaneous processes, which should be enough for nearly all uses. If, however, the error is displayed when trying to start another program, or a server is running with a large number of simultaneous users, increase the number and rebuild.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>maxusers</code> does <em>not</em> limit the number of users which can log into the machine. It instead sets various table sizes to reasonable values considering the maximum number of users on the system and how many processes each user will be running.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_kern_ipc_soacceptqueue>11.11.1.2. <code>kern.ipc.soacceptqueue</code><a class=anchor href=#_kern_ipc_soacceptqueue></a></h5><div class=paragraph><p>The <code>kern.ipc.soacceptqueue</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable limits the size of the listen queue for accepting new <code>TCP</code> connections. The default value of <code>128</code> is typically too low for robust handling of new connections on a heavily loaded web server. For such environments, it is recommended to increase this value to <code>1024</code> or higher. A service such as <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, or Apache may itself limit the listen queue size, but will often have a directive in its configuration file to adjust the queue size. Large listen queues do a better job of avoiding Denial of Service (DoS) attacks.</p></div></div></div><div class=sect3><h4 id=nmbclusters>11.11.2. 網路限制<a class=anchor href=#nmbclusters></a></h4><div class=paragraph><p>The <code>NMBCLUSTERS</code> kernel configuration option dictates the amount of network Mbufs available to the system. A heavily-trafficked server with a low number of Mbufs will hinder performance. Each cluster represents approximately 2 K of memory, so a value of <code>1024</code> represents <code>2</code> megabytes of kernel memory reserved for network buffers. A simple calculation can be done to figure out how many are needed. A web server which maxes out at <code>1000</code> simultaneous connections where each connection uses a 6 K receive and 16 K send buffer, requires approximately 32 MB worth of network buffers to cover the web server. A good rule of thumb is to multiply by <code>2</code>, so 2x32 MB / 2 KB = 64 MB / 2 kB = <code>32768</code>. Values between <code>4096</code> and <code>32768</code> are recommended for machines with greater amounts of memory. Never specify an arbitrarily high value for this parameter as it could lead to a boot time crash. To observe network cluster usage, use <code>-m</code> with <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>.</p></div><div class=paragraph><p>The <code>kern.ipc.nmbclusters</code> loader tunable should be used to tune this at boot time. Only older versions of FreeBSD will require the use of the <code>NMBCLUSTERS</code> kernel <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> option.</p></div><div class=paragraph><p>For busy servers that make extensive use of the <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> system call, it may be necessary to increase the number of <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> buffers via the <code>NSFBUFS</code> kernel configuration option or by setting its value in <span class=filename>/boot/loader.conf</span> (see <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> for details). A common indicator that this parameter needs to be adjusted is when processes are seen in the <code>sfbufa</code> state. The <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable <code>kern.ipc.nsfbufs</code> is read-only. This parameter nominally scales with <code>kern.maxusers</code>, however it may be necessary to tune accordingly.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Even though a socket has been marked as non-blocking, calling <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> on the non-blocking socket may result in the <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> call blocking until enough <code>struct sf_buf</code>'s are made available.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_net_inet_ip_portrange>11.11.2.1. <code>net.inet.ip.portrange.*</code><a class=anchor href=#_net_inet_ip_portrange></a></h5><div class=paragraph><p>The <code>net.inet.ip.portrange.*</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variables control the port number ranges automatically bound to <code>TCP</code> and <code>UDP</code> sockets. There are three ranges: a low range, a default range, and a high range. Most network programs use the default range which is controlled by <code>net.inet.ip.portrange.first</code> and <code>net.inet.ip.portrange.last</code>, which default to <code>1024</code> and <code>5000</code>, respectively. Bound port ranges are used for outgoing connections and it is possible to run the system out of ports under certain circumstances. This most commonly occurs when running a heavily loaded web proxy. The port range is not an issue when running a server which handles mainly incoming connections, such as a web server, or has a limited number of outgoing connections, such as a mail relay. For situations where there is a shortage of ports, it is recommended to increase <code>net.inet.ip.portrange.last</code> modestly. A value of <code>10000</code>, <code>20000</code> or <code>30000</code> may be reasonable. Consider firewall effects when changing the port range. Some firewalls may block large ranges of ports, usually low-numbered ports, and expect systems to use higher ranges of ports for outgoing connections. For this reason, it is not recommended that the value of <code>net.inet.ip.portrange.first</code> be lowered.</p></div></div><div class=sect4><h5 id=_tcp_頻寬延遲乘積>11.11.2.2. <code>TCP</code> 頻寬延遲乘積<a class=anchor href=#_tcp_頻寬延遲乘積></a></h5><div class=paragraph><p><code>TCP</code> bandwidth delay product limiting can be enabled by setting the <code>net.inet.tcp.inflight.enable</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable to <code>1</code>. This instructs the system to attempt to calculate the bandwidth delay product for each connection and limit the amount of data queued to the network to just the amount required to maintain optimum throughput.</p></div><div class=paragraph><p>This feature is useful when serving data over modems, Gigabit Ethernet, high speed <code>WAN</code> links, or any other link with a high bandwidth delay product, especially when also using window scaling or when a large send window has been configured. When enabling this option, also set <code>net.inet.tcp.inflight.debug</code> to <code>0</code> to disable debugging. For production use, setting <code>net.inet.tcp.inflight.min</code> to at least <code>6144</code> may be beneficial. Setting high minimums may effectively disable bandwidth limiting, depending on the link. The limiting feature reduces the amount of data built up in intermediate route and switch packet queues and reduces the amount of data built up in the local host’s interface queue. With fewer queued packets, interactive connections, especially over slow modems, will operate with lower <em>Round Trip Times</em>. This feature only effects server side data transmission such as uploading. It has no effect on data reception or downloading.</p></div><div class=paragraph><p>Adjusting <code>net.inet.tcp.inflight.stab</code> is <em>not</em> recommended. This parameter defaults to <code>20</code>, representing 2 maximal packets added to the bandwidth delay product window calculation. The additional window is required to stabilize the algorithm and improve responsiveness to changing conditions, but it can also result in higher <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> times over slow links, though still much lower than without the inflight algorithm. In such cases, try reducing this parameter to <code>15</code>, <code>10</code>, or <code>5</code> and reducing <code>net.inet.tcp.inflight.min</code> to a value such as <code>3500</code> to get the desired effect. Reducing these parameters should be done as a last resort only.</p></div></div></div><div class=sect3><h4 id=_虛擬記憶體>11.11.3. 虛擬記憶體<a class=anchor href=#_虛擬記憶體></a></h4><div class=sect4><h5 id=_kern_maxvnodes>11.11.3.1. <code>kern.maxvnodes</code><a class=anchor href=#_kern_maxvnodes></a></h5><div class=paragraph><p>A vnode is the internal representation of a file or directory. Increasing the number of vnodes available to the operating system reduces disk I/O. Normally, this is handled by the operating system and does not need to be changed. In some cases where disk I/O is a bottleneck and the system is running out of vnodes, this setting needs to be increased. The amount of inactive and free RAM will need to be taken into account.</p></div><div class=paragraph><p>To see the current number of vnodes in use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.numvnodes</span>
vfs.numvnodes: 91349</code></pre></div></div><div class=paragraph><p>To see the maximum vnodes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxvnodes</span>
kern.maxvnodes: 100000</code></pre></div></div><div class=paragraph><p>If the current vnode usage is near the maximum, try increasing <code>kern.maxvnodes</code> by a value of <code>1000</code>. Keep an eye on the number of <code>vfs.numvnodes</code>. If it climbs up to the maximum again, <code>kern.maxvnodes</code> will need to be increased further. Otherwise, a shift in memory usage as reported by <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> should be visible and more memory should be active.</p></div></div></div></div><div class=sect2><h3 id=adding-swap-space>11.12. 增加交換空間<a class=anchor href=#adding-swap-space></a></h3><div class=paragraph><p>有時系統會需要更多的交換 (Swap) 空間，本章節會介紹兩種增加交換空間的方式：一種是在既有的分割區或新的硬碟增加交換空間，另一種則是在既有的分割區中建立一個交換檔。</p></div><div class=paragraph><p>要取得更多有關如何加密交換空間的資訊、有那些可用的選項以及為何要做加密，可參考 <a href=./#swap-encrypting>交換空間加密</a>。</p></div><div class=sect3><h4 id=new-drive-swap>11.12.1. 使用新硬碟或既有分割區增加交換空間<a class=anchor href=#new-drive-swap></a></h4><div class=paragraph><p>在新的磁碟上增加交換空間比起使用既有硬碟上的分割區會有較佳的效率。設定分割區與硬碟在 <a href=./#disks-adding>加入磁碟</a> 中有說明，另外 <a href=./#configtuning-initial>規劃分割區配置</a> 會討論到分割區的配置與交換分割區大小需考量的事項。</p></div><div class=paragraph><p>使用 <code>swapon</code> 來增加交換分割區到系統，例：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon /dev/ada1s1b</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>可以使用任何尚未掛載過、甚至已經有內含資料的分割區做為交換空間，但在含有資料的分割區上使用 <code>swapon</code> 會覆寫並清除該分割區上所有的資料，請在執行 <code>swapon</code> 之前確認真的要使用該分割區增加交換空間。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要在開機時自動加入此交換分割區，可加入以下項目到 <span class=filename>/etc/fstab</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1s1b	none	swap	sw	0	0</pre></div></div><div class=paragraph><p>請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> 來取得在 <span class=filename>/etc/fstab</span> 中項目的說明。更多有關 <code>swapon</code> 的資訊 可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a> 找到。</p></div></div><div class=sect3><h4 id=create-swapfile>11.12.2. 建立交換檔<a class=anchor href=#create-swapfile></a></h4><div class=paragraph><p>以下例子會建立一個 64M 的交換檔於 <span class=filename>/usr/swap0</span> 來替代使用分割區建立交換空間。</p></div><div class=paragraph><p>使用交換檔開啟交換空間前需要在核心編譯或載入 <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> 所需的模組，請參考 <a href=./#kernelconfig>設定 FreeBSD 核心</a> 了解有關編譯自訂核心的資訊。</p></div><div id=swapfile-10-and-later class=exampleblock><div class=title>例 26. 建立交換檔於 FreeBSD 10.<em>X</em> 及以後版本</div><div class=content><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>建立交換檔：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1m count=64</span></code></pre></div></div></li><li><p>在新檔案設定適當的權限：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>加入行到 <span class=filename>/etc/fstab</span> 以讓系統知道交換檔的資訊：</p><div class="literalblock programlisting"><div class=content><pre>md99	none	swap	sw,file=/usr/swap0,late	0	0</pre></div></div><div class=paragraph><p>已使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> 裝置的 <span class=filename>md99</span>，保留較低的裝置編號供互動操作時使用。</p></div></li><li><p>交換空間會於系統啟動時增加。若要立即增加交換空間，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon -aL</span></code></pre></div></div></li></ol></div></div></div></div></div><div id=swapfile-9-and-earlier class=exampleblock><div class=title>例 27. 建立交換檔於 FreeBSD 9.<em>X</em> 及先前版本</div><div class=content><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>建立交換檔 <span class=filename>/usr/swap0</span>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1m count=64</span></code></pre></div></div></li><li><p>設定適當的權限於 <span class=filename>/usr/swap0</span>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>在 <span class=filename>/etc/rc.conf</span> 開啟交換檔：</p><div class="literalblock programlisting"><div class=content><pre>swapfile=&#34;/usr/swap0&#34;   # Set to name of swap file</pre></div></div></li><li><p>交換空間會於系統啟動時增加。若要立即增加交換空間，可指定一個未使用的記憶體裝置。請參考 <a href=./#disks-virtual>記憶體磁碟</a> 取得更多有關記憶體裝置的資訊。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /usr/swap0 -u 0 &amp;&amp; swapon /dev/md0</span></code></pre></div></div></li></ol></div></div></div></div></div></div></div><div class=sect2><h3 id=acpi-overview>11.13. 電源與資源管理<a class=anchor href=#acpi-overview></a></h3><div class=paragraph><p>以有效率的方式運用硬體資源是很重要的，電源與資源管理讓作業系統可以監控系統的限制，並且在系統溫度意外升高時能夠發出警報。早期提供電源管理的規範是進階電源管理 (Advanced Power Management, APM)，APM 可根據系統的使用狀況來來控制電源用量。然而，使用 APM 要作業系統來管理系統的電源用量和溫度屬性是困難且沒有彈性的，因為硬體是由 BIOS 所管理，使用者對電源管理設定只有有限的設定性與可見性，且 APMBIOS 是由供應商提供且特定於某些硬體平台，而作業系統中必透過 APM 驅動程式做為中介存取 APM 軟體介面才能夠管理電源等級。</p></div><div class=paragraph><p>在 APM 有四個主要的問題。第一，電源管理是由供應商特定的 BIOS 來完成，與作業系統是分開的。例如，使用者可在 APMBIOS 設定硬碟的閒置時間值，在超過時間時 BIOS 可在未徵得作業系統的同意下降低硬碟的轉速。第二，APM 的邏輯是內嵌在 BIOS 當中的，並且在作業系統範圍之外運作，這代表使用者只能夠透過燒錄新的韌體到 ROM 來修正 APMBIOS 中的問題，而這樣的程序是危險的，若失敗，可能會讓系統進入無法復原的狀態。第三，APM 是供應商特定的技術，這代表有許多重複的工作，在一個供應商的 BIOS 找到的問題在其他的供應商卻沒有解決。最後一點，APMBIOS 並沒有足夠的空間來實作複雜的電源管理政策或可良好適應主機用途的程式。</p></div><div class=paragraph><p>Plug and Play BIOS (PNPBIOS) 在很多情況下並不可靠，PNPBIOS 是 16 位元的技術，所以作業系統必須模擬 16 位元才能存取 PNPBIOS。FreeBSD 提供了一個 APM 驅動程式來做 APM，應可用在 2000 年之前所製造的系統，該驅動程式的說明於 <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a>。</p></div><div class=paragraph><p>APM 的後繼者是進階設置與電源介面 (Advanced Configuration and Power Interface, ACPI)。ACPI 是一套由供應商聯盟所搛寫出的標準，提供了硬體資源與電源管理的介面，它是 <em>作業系統直接設置與電源管理 (Operating System-directed configuration and Power Management)</em> 關鍵的要素，提供了作業系統更多的控制方式與彈性。</p></div><div class=paragraph><p>本章節將示範如何在 FreeBSD 設定 ACPI，然後提供一些如何對 ACPI 除錯的提示以及如何提交包含除錯資訊的問題回報，讓開發人員能夠診斷並修正 ACPI 的問題。</p></div><div class=sect3><h4 id=acpi-config>11.13.1. 設定 ACPI<a class=anchor href=#acpi-config></a></h4><div class=paragraph><p>在 FreeBSD <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> 驅動程式預設會在系統開始時載入，且<em>不</em>應被編譯到核心當中。這個驅動程式在開機之後無法被卸載，因為系統匯流排會使用它做各種硬體互動。雖然如此，若系統遇到問題，ACPI 還是可以被關閉，在 <span class=filename>/boot/loader.conf</span> 中設定 <code>hint.acpi.0.disabled="1"</code> 之後重新開機或在載入程式提示時設定這個變數，如 <a href=./#boot-loader>階段三</a> 中的說明。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ACPI 與 APM 不能同時存在且應分開使用，若有偵測到有另一個正在執行，要載入的後者將會中斷。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ACPI 可以用來讓系統進入睡眠模式，使用 <code>acpiconf</code> 與 <code>-s</code> 旗標再加上由 <code>1</code> 到 <code>5</code> 的數字。大多數使用者只需使用 <code>1</code> (快速待命到 RAM) 或 <code>3</code> (待命到 RAM)，選項 <code>5</code> 會執行軟關機 (Soft-off)，如同執行 <code>halt -p</code> 一樣。</p></div><div class=paragraph><p>其他的選項可使用 <code>sysctl</code> 來設定，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a> 以取得更多資訊。</p></div></div><div class=sect3><h4 id=ACPI-comprob>11.13.2. 常見問題<a class=anchor href=#ACPI-comprob></a></h4><div class=paragraph><p>ACPI is present in all modern computers that conform to the ia32 (x86), ia64 (Itanium), and amd64 (AMD) architectures. The full standard has many features including CPU performance management, power planes control, thermal zones, various battery systems, embedded controllers, and bus enumeration. Most systems implement less than the full standard. For instance, a desktop system usually only implements bus enumeration while a laptop might have cooling and battery management support as well. Laptops also have suspend and resume, with their own associated complexity.</p></div><div class=paragraph><p>An ACPI-compliant system has various components. The BIOS and chipset vendors provide various fixed tables, such as FADT, in memory that specify things like the APIC map (used for SMP), config registers, and simple configuration values. Additionally, a bytecode table, the Differentiated System Description Table DSDT, specifies a tree-like name space of devices and methods.</p></div><div class=paragraph><p>The ACPI driver must parse the fixed tables, implement an interpreter for the bytecode, and modify device drivers and the kernel to accept information from the ACPI subsystem. For FreeBSD, Intel™ has provided an interpreter (ACPI-CA) that is shared with Linux™ and NetBSD. The path to the ACPI-CA source code is <span class=filename>src/sys/contrib/dev/acpica</span>. The glue code that allows ACPI-CA to work on FreeBSD is in <span class=filename>src/sys/dev/acpica/Osd</span>. Finally, drivers that implement various ACPI devices are found in <span class=filename>src/sys/dev/acpica</span>.</p></div><div class=paragraph><p>For ACPI to work correctly, all the parts have to work correctly. Here are some common problems, in order of frequency of appearance, and some possible workarounds or fixes. If a fix does not resolve the issue, refer to <a href=#ACPI-submitdebug>取得與回報除錯資訊</a> for instructions on how to submit a bug report.</p></div><div class=sect4><h5 id=_滑鼠問題>11.13.2.1. 滑鼠問題<a class=anchor href=#_滑鼠問題></a></h5><div class=paragraph><p>In some cases, resuming from a suspend operation will cause the mouse to fail. A known work around is to add <code>hint.psm.0.flags="0x3000"</code> to <span class=filename>/boot/loader.conf</span>.</p></div></div><div class=sect4><h5 id=_待機喚醒>11.13.2.2. 待機/喚醒<a class=anchor href=#_待機喚醒></a></h5><div class=paragraph><p>ACPI has three suspend to RAM (STR) states, <code>S1</code>-<code>S3</code>, and one suspend to disk state (STD), called <code>S4</code>. STD can be implemented in two separate ways. The <code>S4</code>BIOS is a BIOS-assisted suspend to disk and <code>S4</code>OS is implemented entirely by the operating system. The normal state the system is in when plugged in but not powered up is "soft off" (<code>S5</code>).</p></div><div class=paragraph><p>Use <code>sysctl hw.acpi</code> to check for the suspend-related items. These example results are from a Thinkpad:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</code></pre></div></div><div class=paragraph><p>Use <code>acpiconf -s</code> to test <code>S3</code>, <code>S4</code>, and <code>S5</code>. An <code>s4bios</code> of one (<code>1</code>) indicates <code>S4</code>BIOS support instead of <code>S4</code> operating system support.</p></div><div class=paragraph><p>When testing suspend/resume, start with <code>S1</code>, if supported. This state is most likely to work since it does not require much driver support. No one has implemented <code>S2</code>, which is similar to <code>S1</code>. Next, try <code>S3</code>. This is the deepest STR state and requires a lot of driver support to properly reinitialize the hardware.</p></div><div class=paragraph><p>A common problem with suspend/resume is that many device drivers do not save, restore, or reinitialize their firmware, registers, or device memory properly. As a first attempt at debugging the problem, try:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.bootverbose=1</span>
<span class=c># sysctl debug.acpi.suspend_bounce=1</span>
<span class=c># acpiconf -s 3</span></code></pre></div></div><div class=paragraph><p>This test emulates the suspend/resume cycle of all device drivers without actually going into <code>S3</code> state. In some cases, problems such as losing firmware state, device watchdog time out, and retrying forever, can be captured with this method. Note that the system will not really enter <code>S3</code> state, which means devices may not lose power, and many will work fine even if suspend/resume methods are totally missing, unlike real <code>S3</code> state.</p></div><div class=paragraph><p>Harder cases require additional hardware, such as a serial port and cable for debugging through a serial console, a Firewire port and cable for using <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a>, and kernel debugging skills.</p></div><div class=paragraph><p>To help isolate the problem, unload as many drivers as possible. If it works, narrow down which driver is the problem by loading drivers until it fails again. Typically, binary drivers like <span class=filename>nvidia.ko</span>, display drivers, and USB will have the most problems while Ethernet interfaces usually work fine. If drivers can be properly loaded and unloaded, automate this by putting the appropriate commands in <span class=filename>/etc/rc.suspend</span> and <span class=filename>/etc/rc.resume</span>. Try setting <code>hw.acpi.reset_video</code> to <code>1</code> if the display is messed up after resume. Try setting longer or shorter values for <code>hw.acpi.sleep_delay</code> to see if that helps.</p></div><div class=paragraph><p>Try loading a recent Linux™ distribution to see if suspend/resume works on the same hardware. If it works on Linux™, it is likely a FreeBSD driver problem. Narrowing down which driver causes the problem will assist developers in fixing the problem. Since the ACPI maintainers rarely maintain other drivers, such as sound or ATA, any driver problems should also be posted to the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>freebsd-current</a> list and mailed to the driver maintainer. Advanced users can include debugging <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a>s in a problematic driver to track down where in its resume function it hangs.</p></div><div class=paragraph><p>Finally, try disabling ACPI and enabling APM instead. If suspend/resume works with APM, stick with APM, especially on older hardware (pre-2000). It took vendors a while to get ACPI support correct and older hardware is more likely to have BIOS problems with ACPI.</p></div></div><div class=sect4><h5 id=_系統無回應>11.13.2.3. 系統無回應<a class=anchor href=#_系統無回應></a></h5><div class=paragraph><p>Most system hangs are a result of lost interrupts or an interrupt storm. Chipsets may have problems based on boot, how the BIOS configures interrupts before correctness of the APIC (MADT) table, and routing of the System Control Interrupt (SCI).</p></div><div class=paragraph><p>Interrupt storms can be distinguished from lost interrupts by checking the output of <code>vmstat -i</code> and looking at the line that has <code>acpi0</code>. If the counter is increasing at more than a couple per second, there is an interrupt storm. If the system appears hung, try breaking to DDB (<span class=keyseq><kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>ESC</kbd></span> on console) and type <code>show interrupts</code>.</p></div><div class=paragraph><p>When dealing with interrupt problems, try disabling APIC support with <code>hint.apic.0.disabled="1"</code> in <span class=filename>/boot/loader.conf</span>.</p></div></div><div class=sect4><h5 id=_當機>11.13.2.4. 當機<a class=anchor href=#_當機></a></h5><div class=paragraph><p>Panics are relatively rare for ACPI and are the top priority to be fixed. The first step is to isolate the steps to reproduce the panic, if possible, and get a backtrace. Follow the advice for enabling <code>options DDB</code> and setting up a serial console in <a href=./#serialconsole-ddb>從序列線路 (Serial Line) 進入 DDB 除錯程式</a> or setting up a dump partition. To get a backtrace in DDB, use <code>tr</code>. When handwriting the backtrace, get at least the last five and the top five lines in the trace.</p></div><div class=paragraph><p>Then, try to isolate the problem by booting with ACPI disabled. If that works, isolate the ACPI subsystem by using various values of <code>debug.acpi.disable</code>. See <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> for some examples.</p></div></div><div class=sect4><h5 id=_系統在待機或關機後仍開機>11.13.2.5. 系統在待機或關機後仍開機<a class=anchor href=#_系統在待機或關機後仍開機></a></h5><div class=paragraph><p>First, try setting <code>hw.acpi.disable_on_poweroff="0"</code> in <span class=filename>/boot/loader.conf</span>. This keeps ACPI from disabling various events during the shutdown process. Some systems need this value set to <code>1</code> (the default) for the same reason. This usually fixes the problem of a system powering up spontaneously after a suspend or poweroff.</p></div></div><div class=sect4><h5 id=ACPI-aslanddump>11.13.2.6. BIOS 含有有問題的 Bytecode<a class=anchor href=#ACPI-aslanddump></a></h5><div class=paragraph><p>Some BIOS vendors provide incorrect or buggy bytecode. This is usually manifested by kernel console messages like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ACPI-1287: <span class=k>***</span> Error: Method execution failed <span class=o>[</span><span class=se>\\</span>_SB_.PCI0.LPC0.FIGD._STA] <span class=se>\\</span>
<span class=o>(</span>Node 0xc3f6d160<span class=o>)</span>, AE_NOT_FOUND</code></pre></div></div><div class=paragraph><p>Often, these problems may be resolved by updating the BIOS to the latest revision. Most console messages are harmless, but if there are other problems, like the battery status is not working, these messages are a good place to start looking for problems.</p></div></div></div><div class=sect3><h4 id=_覆蓋預設的_aml>11.13.3. 覆蓋預設的 AML<a class=anchor href=#_覆蓋預設的_aml></a></h4><div class=paragraph><p>The BIOS bytecode, known as ACPI Machine Language (AML), is compiled from a source language called ACPI Source Language (ASL). The AML is found in the table known as the Differentiated System Description Table (DSDT).</p></div><div class=paragraph><p>The goal of FreeBSD is for everyone to have working ACPI without any user intervention. Workarounds are still being developed for common mistakes made by BIOS vendors. The Microsoft™ interpreter (<span class=filename>acpi.sys</span> and <span class=filename>acpiec.sys</span>) does not strictly check for adherence to the standard, and thus many BIOS vendors who only test ACPI under Windows™ never fix their ASL. FreeBSD developers continue to identify and document which non-standard behavior is allowed by Microsoft™'s interpreter and replicate it so that FreeBSD can work without forcing users to fix the ASL.</p></div><div class=paragraph><p>To help identify buggy behavior and possibly fix it manually, a copy can be made of the system’s ASL. To copy the system’s ASL to a specified file name, use <code>acpidump</code> with <code>-t</code>, to show the contents of the fixed tables, and <code>-d</code>, to disassemble the AML:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -td &gt; my.asl</span></code></pre></div></div><div class=paragraph><p>Some AML versions assume the user is running Windows™. To override this, set <code>hw.acpi.osname=<em>"Windows 2009"</em></code> in <span class=filename>/boot/loader.conf</span>, using the most recent Windows™ version listed in the ASL.</p></div><div class=paragraph><p>Other workarounds may require <span class=filename>my.asl</span> to be customized. If this file is edited, compile the new ASL using the following command. Warnings can usually be ignored, but errors are bugs that will usually prevent ACPI from working correctly.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl -f my.asl</span></code></pre></div></div><div class=paragraph><p>Including <code>-f</code> forces creation of the AML, even if there are errors during compilation. Some errors, such as missing return statements, are automatically worked around by the FreeBSD interpreter.</p></div><div class=paragraph><p>The default output filename for <code>iasl</code> is <span class=filename>DSDT.aml</span>. Load this file instead of the BIOS’s buggy copy, which is still present in flash memory, by editing <span class=filename>/boot/loader.conf</span> as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>acpi_dsdt_load=&#34;YES&#34;
acpi_dsdt_name=&#34;/boot/DSDT.aml&#34;</pre></div></div><div class=paragraph><p>Be sure to copy <span class=filename>DSDT.aml</span> to <span class=filename>/boot</span>, then reboot the system. If this fixes the problem, send a <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> of the old and new ASL to <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> so that developers can work around the buggy behavior in <span class=filename>acpica</span>.</p></div></div><div class=sect3><h4 id=ACPI-submitdebug>11.13.4. 取得與回報除錯資訊<a class=anchor href=#ACPI-submitdebug></a></h4><div class=paragraph><p>The ACPI driver has a flexible debugging facility. A set of subsystems and the level of verbosity can be specified. The subsystems to debug are specified as layers and are broken down into components (<code>ACPI_ALL_COMPONENTS</code>) and ACPI hardware support (<code>ACPI_ALL_DRIVERS</code>). The verbosity of debugging output is specified as the level and ranges from just report errors (<code>ACPI_LV_ERROR</code>) to everything (<code>ACPI_LV_VERBOSE</code>). The level is a bitmask so multiple options can be set at once, separated by spaces. In practice, a serial console should be used to log the output so it is not lost as the console message buffer flushes. A full list of the individual layers and levels is found in <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>.</p></div><div class=paragraph><p>Debugging output is not enabled by default. To enable it, add <code>options ACPI_DEBUG</code> to the custom kernel configuration file if ACPI is compiled into the kernel. Add <code>ACPI_DEBUG=1</code> to <span class=filename>/etc/make.conf</span> to enable it globally. If a module is used instead of a custom kernel, recompile just the <span class=filename>acpi.ko</span> module as follows:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/modules/acpi/acpi &amp;&amp; make clean &amp;&amp; make ACPI_DEBUG=1</span></code></pre></div></div><div class=paragraph><p>Copy the compiled <span class=filename>acpi.ko</span> to <span class=filename>/boot/kernel</span> and add the desired level and layer to <span class=filename>/boot/loader.conf</span>. The entries in this example enable debug messages for all ACPI components and hardware drivers and output error messages at the least verbose level:</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.layer=&#34;ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS&#34;
debug.acpi.level=&#34;ACPI_LV_ERROR&#34;</pre></div></div><div class=paragraph><p>If the required information is triggered by a specific event, such as a suspend and then resume, do not modify <span class=filename>/boot/loader.conf</span>. Instead, use <code>sysctl</code> to specify the layer and level after booting and preparing the system for the specific event. The variables which can be set using <code>sysctl</code> are named the same as the tunables in <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Once the debugging information is gathered, it can be sent to <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> so that it can be used by the FreeBSD ACPI maintainers to identify the root cause of the problem and to develop a solution.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Before submitting debugging information to this mailing list, ensure the latest BIOS version is installed and, if available, the embedded controller firmware version.</p></div></td></tr></tbody></table></div><div class=paragraph><p>When submitting a problem report, include the following information:</p></div><div class=ulist><ul><li><p>Description of the buggy behavior, including system type, model, and anything that causes the bug to appear. Note as accurately as possible when the bug began occurring if it is new.</p></li><li><p>The output of <code>dmesg</code> after running <code>boot -v</code>, including any error messages generated by the bug.</p></li><li><p>The <code>dmesg</code> output from <code>boot -v</code> with ACPI disabled, if disabling ACPI helps to fix the problem.</p></li><li><p>Output from <code>sysctl hw.acpi</code>. This lists which features the system offers.</p></li><li><p>The URL to a pasted version of the system’s ASL. Do <em>not</em> send the ASL directly to the list as it can be very large. Generate a copy of the ASL by running this command:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -dt &gt; name-system.asl</span></code></pre></div></div><div class=paragraph><p>Substitute the login name for <em>name</em> and manufacturer/model for <em>system</em>. For example, use <span class=filename>njl-FooCo6000.asl</span>.</p></div></li></ul></div><div class=paragraph><p>Most FreeBSD developers watch the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>FreeBSD-CURRENT mailing list</a>, but one should submit problems to <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> to be sure it is seen. Be patient when waiting for a response. If the bug is not immediately apparent, submit a bug report. When entering a PR, include the same information as requested above. This helps developers to track the problem and resolve it. Do not send a PR without emailing <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> first as it is likely that the problem has been reported before.</p></div></div><div class=sect3><h4 id=ACPI-References>11.13.5. 參考文獻<a class=anchor href=#ACPI-References></a></h4><div class=paragraph><p>More information about ACPI may be found in the following locations:</p></div><div class=ulist><ul><li><p>The FreeBSD ACPI Mailing List Archives (<a href=https://lists.freebsd.org/pipermail/freebsd-acpi/>https://lists.freebsd.org/pipermail/freebsd-acpi/</a>)</p></li><li><p>The <a href=https://uefi.org/specifications#ACPI>ACPI Specification</a></p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_thermal&amp;sektion=4&amp;format=html">acpi_thermal(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=iasl&amp;sektion=8&amp;format=html">iasl(8)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidb&amp;sektion=8&amp;format=html">acpidb(8)</a></p></li></ul></div></div></div></div></div><div class=sect1><h2 id=boot>Chapter 12. FreeBSD 開機程序<a class=anchor href=#boot></a></h2><div class=sectionbody><div class=sect2><h3 id=boot-synopsis>12.1. 概述<a class=anchor href=#boot-synopsis></a></h3><div class=paragraph><p>從開啟電腦到載入作業系統的這段流程稱為 "開機程序" (Bootstrap process) 或 "開機" (Booting)。FreeBSD 的開機程序提供大量的客製化彈性，包含可選擇安裝在同電腦的其他的作業系統、不同版本的作業系統或不同核心的作業系統的功能。</p></div><div class=paragraph><p>本章會詳細說明可以設定的選項。示範如何自訂 FreeBSD 開機流程，包含其中所有會發生的事，直到啟動 FreeBSD 核心、偵測裝置及啟動 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>。這些事會發生在開機訊息的文字顏色會從亮白變成灰色之間。</p></div><div class=paragraph><p>在閱讀本章之後，您會了解：</p></div><div class=ulist><ul><li><p>FreeBSD 開機系統的元件以及它們如何互動。</p></li><li><p>FreeBSD 開機程式中各元件可使用的選項，用來控制開機程序。</p></li><li><p>如何設定自訂的開機啟動畫面 (Splash screen)。</p></li><li><p>設定 Device Hints 的基礎。</p></li><li><p>如何開機進入單人及多人模式以及如何正確關閉 FreeBSD 系統。</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>本章僅說明 FreeBSD 在 x86 及 amd64 系統上執行的開機流程。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=boot-introduction>12.2. FreeBSD 開機程序<a class=anchor href=#boot-introduction></a></h3><div class=paragraph><p>打開電腦並啟動作業系統的這個動作呈現了一個有趣的困境。照道理，電腦在啟動作業系統之前並不知道要如何做任何事情，這些事情之中包括從磁碟執行程式。如果電腦無法在沒有作業系統的情況下執行程式，而作業系統的程式本身又在磁碟上，那麼作業系統要如何啟動呢?</p></div><div class=paragraph><p>這個問題如同 The Adventures of Baron Munchausen 一書中的一個角色掉進了洞裡，他抓住了靴子上的拔靴帶 (Bootstrap) 才把自己拉了出來，因此在早期電腦領域用 <em>bootstrap</em> 一詞來指載入作業系統的機制，後來被縮短為 "booting"。</p></div><div class=paragraph><p>在 x86 硬體上，基本輸入/輸出系統 (Basic Input/Output System, BIOS) 負責載入作業系統。 BIOS 會找到硬碟上的主開機記錄區 (Master Boot Record, MBR)，該記錄區必須位於磁碟上的特定位置。BIOS 有足夠的知識可以載入並執行這個 MBR，並且假設這個 MBR 在 BIOS 的協助下可以完成接下來載入作業系統的工作。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 在較舊的 MBR 標準與較新的 GUID 分割區表 (GUID Partition Table, GPT) 上都能夠開機 (Booting)。GPT 磁碟分割通常會在有支援統一可延伸韌體介面 (Unified Extensible Firmware Interface, UEFI) 的電腦上找到。不論如何，FreeBSD 即使在只有傳統 BIOS 的機器上，也可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gptboot&amp;sektion=8&amp;format=html">gptboot(8)</a> 由 GPT 分割區開機。直接使用 UEFI 開機的開發工作正在進行中。</p></div></td></tr></tbody></table></div><div class=paragraph><p>在 MBR 中的程式通常會稱作開機管理程式 (<em>Boot manager</em>)，特別是那些會與使用者互動的程式。開機管理程式通常會另一部份的程式會存放於磁碟的第一個磁軌或檔案系統。開機管理程式的例子有標準 FreeBSD 開機管理程式 boot0 又稱 Boot Easy 以及 Grub 常用於各種 Linux™ 發行版。</p></div><div class=paragraph><p>若只有安裝一個作業系統，MBR 會搜尋磁碟上第一個可開機的 (使用中) 切割區 (Slice)，然後執行在該切割區上的程式來載入剩下的作業系統。當有多個作業系統存在時，可以安裝可顯示作業系統清單的開機管理程式，以讓使用者可以選擇要啟動的作業系統。</p></div><div class=paragraph><p>剩餘的 FreeBSD 開機系統分成三個階段，第一個階段只知道如何讓電腦進入特定狀態並執行第二階段，第二個階段在執行第三階段之前會做的事比較多一點，第三個階段會完成載入作業系統的工作。把工作分成三個階段的原因是 MBR 有限制在階段一與階段二能夠執行程式的大小。將這些工作連結在一起讓 FreeBSD 能夠提供更有彈性的載入程式。</p></div><div class=paragraph><p>核心會接著開始偵測裝置並初始化這些裝置供使用。核心開機程序完成之後，核心便會傳送控制權給使用者程序 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>，這個程序會確保磁碟在可以使用的狀態，然後啟動使用者層級的資源設置來掛載檔案系統、設定網路卡以能夠連線網路、啟動那些被設定在開機時要啟動的程序。</p></div><div class=paragraph><p>本章節將更詳細介紹這些階段並示範如何與 FreeBSD 開機程序互動。</p></div><div class=sect3><h4 id=boot-boot0>12.2.1. 開機管理程式<a class=anchor href=#boot-boot0></a></h4><div class=paragraph><p>有時會稱在 MBR 中的開機管理程式為開機程序的 <em>第零階段 (Stage zero)</em>，FreeBSD 預設會使用 boot0 開機管理程式。</p></div><div class=paragraph><p>由 FreeBSD 安裝程式所安裝的 MBR 便是以 <span class=filename>/boot/boot0</span> 為基礎。boot0 的大小與容量被限制在 446 個位元組是由於切割表與 <code>0x55AA</code> 識別碼位於 MBR 的最末端。若安裝多個作業系統使用 boot0 ，則會在開機時顯示如下範例的訊息：</p></div><div id=boot-boot0-example class=exampleblock><div class=title>例 28. <span class=filename>boot0</span> 螢幕截圖</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>F1 Win
F2 FreeBSD

Default: F2</code></pre></div></div></div></div><div class=paragraph><p>其作他作業統若在 FreeBSD 之後才安裝則會覆蓋現有的 MBR，若這件事發生了，或者要使用 FreeBSD MBR 取代現有的 MBR 可使用以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdisk -B -b /boot/boot0 device</span></code></pre></div></div><div class=paragraph><p>其中 <em>device</em> 開機磁碟，例如第一個 IDE 磁碟為 <span class=filename>ad0</span>，第二個 IDE 控制器的第一個 IDE磁碟為 <span class=filename>ad2</span>，第一個 SCSI 磁碟為 <span class=filename>da0</span>。要建立自訂的 MBR 設定請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a>。</p></div></div><div class=sect3><h4 id=boot-boot1>12.2.2. 階段一與階段二<a class=anchor href=#boot-boot1></a></h4><div class=paragraph><p>概念上，第一與第二個階段均為磁碟上同一個區域上同一個程式的一部份，由於空間上的限制，它們被分成兩部份，但是會一併安裝。它們會由 FreeBSD 安裝程式或 <code>bsdlabel</code> 從 <span class=filename>/boot/boot</span> 複製而來。</p></div><div class=paragraph><p>這兩個階段均位於檔案系統之外，在開機切割區的第一個磁軌，從第一個磁碟扇區 (Sector) 開始，這個位置便是 boot0 或其他開機管理程式所會儲存的地方，並會尋找可以執行的程式以繼續開機程序。</p></div><div class=paragraph><p>第一個階段的 <span class=filename>boot1</span> 非常的簡單，因為它只能有 512 位元組的大小。它只能認得儲存切割區資訊的 FreeBSD <em>bsdlabel</em> 以及尋找並執行 <span class=filename>boot2</span>。</p></div><div class=paragraph><p>階段二 <span class=filename>boot2</span> 稍微複雜一點，能夠理解 FreeBSD 檔案系統來搜尋檔案。它可以提供一個簡單的介面來選擇要執行的核心或載入程式。它所執行的載入程式 (loader) 更複雜並能讀取開機設定檔。若開機程序在階段二中斷，則會顯示以下的互動畫面：</p></div><div id=boot-boot2-example class=exampleblock><div class=title>例 29. <span class=filename>boot2</span> 螢幕截圖</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div></div></div><div class=paragraph><p>要更換已安裝的 <span class=filename>boot1</span> 與 <span class=filename>boot2</span> 可使用 <code>bsdlabel</code>，其中 <em>diskslice</em> 是要開機的磁碟與切割區，例如 <span class=filename>ad0s1</span> 代表第一個 IDE 磁碟的第一個切割區：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -B diskslice</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>若只使用磁碟名稱，如 <span class=filename>ad0</span>，<code>bsdlabel</code> 便會以 "危險專用的模式" 來建立磁碟，而不會建立任何分割區。這個可能與預期的動作不同，所以在按下 <kbd>Return</kbd> 鍵之前請再次確認 <em>diskslice</em>。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-loader>12.2.3. 階段三<a class=anchor href=#boot-loader></a></h4><div class=paragraph><p>loader 是三階段開機程多的最後一個階段，載入程式位於檔案系統之中，通常在 <span class=filename>/boot/loader</span>。</p></div><div class=paragraph><p>loader 主要目地是利用擁有更複雜指令集的強大直譯器做為基礎的內建指令集提供一個互動的方式來做設定。</p></div><div class=paragraph><p>在初始化的過程中，loader 會偵測 Console 與磁碟，並找出可以用來開機的磁碟。在由 Script 或互動輸入使用者指令的地方會設定相對的變數並啟動直譯器。</p></div><div class=paragraph><p>loader 接著會讀取 <span class=filename>/boot/loader.rc</span>，這個程式預設又會讀取 <span class=filename>/boot/defaults/loader.conf</span> 來設定合理的變數預設值以及讀取 <span class=filename>/boot/loader.conf</span> 來對這些變數做本地的更改。<span class=filename>loader.rc</span> 接著會依這些變數來運作，讀取選擇模組與核心。</p></div><div class=paragraph><p>最後，預設情況下 loader 會待候鍵盤輸入 10 秒鐘，若沒有被中斷的話會接著啟動核心。若被使用者中斷，則會向使用者顯示提示字元，此時使用可以使用指令集來調整變數、卸載所有模組、載入模組，然後最後開機或重新開機。<a href=#boot-loader-commands>載入程式內建指令</a> 中列出了最常使用的 loader 指令。要完整了解所有可用的指令，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>。</p></div><table id=boot-loader-commands class="tableblock frame-none grid-all stretch"><caption class=title>表 9. 載入程式內建指令</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">變數</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>autoboot <em>seconds</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>若在指定時間 (秒) 內沒有中斷，會繼續啟動核心。此指令會顯示倒數，預設的時間為 10 秒鐘。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>boot <code>[<em>-options</em>] [<em>kernelname]</em></code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>使用任何指定的選項或核心名稱立即啟動核心，要由指令列指定核心名稱必須先執行 <code>unload</code>，否則會使用先前載入過的核心。若 <em>kernelname</em> 不是完整的路徑則會搜尋 <em>/boot/kernel</em> 及 <em>/boot/modules</em> 底下。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>boot-conf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>依據指定的變數及最常用的 <code>kernel</code> 再做一次相同的自動模組設置。這只有在執行 <code>unload</code> 之後，尚未變更變數之前方可使用。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>help <code>[<em>topic</em>]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>顯示自 <span class=filename>/boot/loader.help</span> 取得的說明訊息。若指定的主題為 <code>index</code> 則會顯示所有可用的主題。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>include <em>filename</em> …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>讀取指定的檔案並直譯每一行。若有錯誤則會立即中止 <code>include</code>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>load <code>[-t <em>type</em>]</code> <em>filename</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>由指定的檔案名稱載入核心、核心模組或指定類型的檔案。任何於 <em>filename</em> 之後的參數都會被傳遞到該檔案。若 <em>filename</em> 不是絕對位置則會搜尋 <em>/boot/kernel</em> 及 <em>/boot/modules</em> 底下。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ls [-l] <code>[<em>path</em>]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>顯示指定路徑中的檔案，若未指定路徑則會顯示根目錄中的檔案。若有指定 <code>-l</code>，則會連檔案大小一同顯示。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lsdev [-v]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>列出所有的裝置，這些裝置可能可以用來載入模組。若有指定 <code>-v</code> 則會顯示更詳細的資訊。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lsmod [-v]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>顯示已載入的模組。若有指定 <code>-v</code> 則會顯示更詳細的資訊。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>more <em>filename</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>顯示指定的檔案，並於每 <code>LINES</code> 行顯示後會暫停。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>reboot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>立即重新啟動系統。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>set <em>variable</em>, set <em>variable</em>=<em>value</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>設定指定的環境變數。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>unload</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>移除所有已載入的模組。</p></td></tr></tbody></table><div class=paragraph><p>這裡有一些 loader 用法的實務範例。要使用一般的核心開機進入單使用者模式 (Single-user mode) 可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nt>-s</span></code></pre></div></div><div class=paragraph><p>要卸載一般的核心與模組，然後載入先前或另一個指定的核心可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> unload
 load kernel.old</code></pre></div></div><div class=paragraph><p>使用 <span class=filename>kernel.GENERIC</span> 來代表安裝程式使用的預設核心，或 <span class=filename>kernel.old</span> 來代表在系統升級之前或設定自訂核心前安裝的核心。</p></div><div class=paragraph><p>使用以下指令來使用另一個核心載入一般的模組：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> unload
 <span class=nb>set </span><span class=nv>kernel</span><span class=o>=</span><span class=s2>&#34;kernel.old&#34;</span>
 boot-conf</code></pre></div></div><div class=paragraph><p>要載入一個已自動化的核心設置 Script 可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> load <span class=nt>-t</span> userconfig_script /boot/kernel.conf</code></pre></div></div></div><div class=sect3><h4 id=boot-init>12.2.4. 最終階段<a class=anchor href=#boot-init></a></h4><div class=paragraph><p>由 loader 或由會繞開 loader 的 boot2 載入核心之後，載入程式便會檢查是不有使用任何開機旗標，並根據需要調整開機的方式。<a href=#boot-kernel>開機時核心互動參數</a> 列出了常用的開機旗標，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> 取得更多其他開機旗標的資訊。</p></div><table id=boot-kernel class="tableblock frame-none grid-all stretch"><caption class=title>表 10. 開機時核心互動參數</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">項目</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>核心初始化時，會詢問要掛載為根檔案系統的裝置。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-C</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>由 CDROM 做為根檔案系統開機。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-s</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>開機進入單使用者模式。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-v</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>核心啟動時提供更多詳細資訊。</p></td></tr></tbody></table><div class=paragraph><p>一旦核心完成開機程序後，便會傳送控制權給使用者程序 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>，該程序位於 <span class=filename>/sbin/init</span> 或在 <code>loader</code> 中的 <code>init_path</code> 變數所指的程式路徑。這是開機程序的最後一個階段。</p></div><div class=paragraph><p>開機程序會確保系統上的檔案系統的一致性 (Consistency)，若 UFS 檔案系統不一致且 <code>fsck</code> 無法修時，init 會讓系統進入單使用者模式，以讓系統管理者能夠直接解決問題，否則系統會開機進入多使用者模式。</p></div><div class=sect4><h5 id=boot-singleuser>12.2.4.1. 單使用者模式<a class=anchor href=#boot-singleuser></a></h5><div class=paragraph><p>使用者可以在開機時指定 <code>-s</code> 或在 loader 設定 <code>boot_single</code> 變數進入這個模式。也可以透過在多使用者模式執行 <code>shutdown now</code> 進入此模式。進入單使用者模式時會出現此訊息：</p></div><div class="literalblock programlisting"><div class=content><pre>Enter full pathname of shell or RETURN for /bin/sh:</pre></div></div><div class=paragraph><p>若使用者按下 <kbd>Enter</kbd>，系統便會進入預設的 Bourne shell。要指定使用其他的 Shell 則輸入該 Shell 的完整路徑。</p></div><div class=paragraph><p>單使用者模式通常用來修復因檔案系統不一致或開機設定檔發生錯誤造成的無法開機，也可以用來重設遺忘的 <code>root</code> 的密碼，因為在單使用者模式會給予對本地系統及設定檔完整的存取權。在這個模式下沒有網路功能。</p></div><div class=paragraph><p>雖然單使用者模式對修復系統很有幫助，但若系統放在不安全的場所便會有安全上的風險。預設，開機進入單使用者模式後，任何能夠存取實體主機的使用者便擁有系統的完整控制權。</p></div><div class=paragraph><p>若在 <span class=filename>/etc/ttys</span> 系統 <code>console</code> 更改為 <code>insecure</code>，系統便會在初始化單使用者模式前先詢問 <code>root</code> 的密碼。這可增加一定程度的安全性，但便無法在忘記 <code>root</code> 密碼時重設密碼。</p></div><div id=boot-insecure-console class=exampleblock><div class=title>例 30. 在 <span class=filename>/etc/ttys</span> 設定不安全的 Console</div><div class=content><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</pre></div></div></div></div><div class=paragraph><p>不安全 (<code>insecure</code>) console 代表對 Console 的實體安全性評估為不安全 (insecure)，所以只有知道 <code>root</code> 密碼的人可以使用單使用者模式。</p></div></div><div class=sect4><h5 id=boot-multiuser>12.2.4.2. 多使用者模式<a class=anchor href=#boot-multiuser></a></h5><div class=paragraph><p>若 init 正常找到檔案系統或在單使用者模式的使用者完成了操作並輸入 <code>exit</code> 離開單使用者模式，系統便會進入多使用者模式，在這個模式便會開始系統的資源設置。</p></div><div class=paragraph><p>資源設置系統 (Resource configuration system) 會從 <span class=filename>/etc/defaults/rc.conf</span> 讀取設定預設值以及從 <span class=filename>/etc/rc.conf</span> 讀取系統特定的設定，接著會繼續掛載系統列於 <span class=filename>/etc/fstab</span> 的檔案系統，也會啟動網路服務、其他的系統 Daemon，然後執行本地已安裝套件的啟動 Script。</p></div><div class=paragraph><p>要了解更多有關資源設置系統，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 以及查看位於 <span class=filename>/etc/rc.d</span> 的 Script。</p></div></div></div></div><div class=sect2><h3 id=boot-splash>12.3. 設定開機啟動畫面<a class=anchor href=#boot-splash></a></h3><div class=paragraph><p>正常 FreeBSD 系統開機會在 Console 顯示以一系列訊息來表示開機進度。開機啟動畫面 (Boot splash screen) 是另一種可以把所有開機偵測與服務啟動訊息隱藏的開機畫面，但即使開啟了啟動畫面，仍有有少數的開機載入程式的訊息，如：開機選項選單以及倒數時間的提示，仍會在開機時顯示。在開機程序時可以按下鍵盤上的按鍵來關閉顯示中的啟動畫面。</p></div><div class=paragraph><p>FreeBSD 有兩種基本的環境可以使用，一種是預設的傳統虛擬 Console 指令列環境，在系統完成開機之後，便會顯示 Console 登入提示。另一種環境則是設定好的圖型化環境，請參考 <a href=./#x11>X Window 系統</a> 以取得更多有關如何安裝與設定圖型化顯示管理程式與圖型化登入管理程式的資訊。</p></div><div class=paragraph><p>系統開機之後，啟動畫面預設會作為螢幕保護程式，一段時間未使用便會顯示啟動畫面，並且會循環更改影像的亮度，從明亮到非常暗，然後再繼續循環。啟動螢幕保護程式的設定可在 <span class=filename>/etc/rc.conf</span> 增加一行 <code>saver=</code> 來更改。有許多內建的螢幕保護程式可用，在 <a href="https://man.freebsd.org/cgi/man.cgi?query=splash&amp;sektion=4&amp;format=html">splash(4)</a> 中有說明。<code>saver=</code> 的選項只會套用至虛擬 Console，對圖型化顯示管理程式並不會有任何影響。</p></div><div class=paragraph><p>透過安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bsd-splash-changer/>sysutils/bsd-splash-changer</a> 套件或 Port，可在開機時顯示隨機挑選的啟動畫面。啟動畫面功能支援 256 色的點陣圖 (<span class=filename>.bmp</span>)、ZSoft PCX (<span class=filename>.pcx</span>) 或 TheDraw (<span class=filename>.bin</span>) 格式。<span class=filename>.bmp</span>, <span class=filename>.pcx</span> 或 <span class=filename>.bin</span> 圖片必須放在根分割區，例如於 <span class=filename>/boot</span>。啟動圖片檔必須使用 320x200 像素或更低的解析度以能夠在標準 VGA 介面卡上運作，要在預設 256 色、320x200 像素或更低的解析度設定開機啟動圖片，可加入下行到 <span class=filename>/boot/loader.conf</span>，並替換 <em>splash.bmp</em> 為實際要使用的點陣圖檔：</p></div><div class="literalblock programlisting"><div class=content><pre>splash_bmp_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.bmp&#34;</pre></div></div><div class=paragraph><p>要使用 PCX 檔則可替換點陣圖檔：</p></div><div class="literalblock programlisting"><div class=content><pre>splash_pcx_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.pcx&#34;</pre></div></div><div class=paragraph><p>若要改使用 <a href=https://en.wikipedia.org/wiki/TheDraw>https://en.wikipedia.org/wiki/TheDraw</a> 格式的 ASCII 圖可：</p></div><div class="literalblock programlisting"><div class=content><pre>splash_txt=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.bin&#34;</pre></div></div><div class=paragraph><p>要使用較大的圖片來填滿整個顯示畫面支援的解析度最大可至 1024x768 像素，VESA 模組也必須在系統開機時載入。若使用自訂的核心，請確定自訂核心設定檔中有含有 <code>VESA</code> 核心設定選項。要載入 VESA 模組來顯示啟動畫面可在 <span class=filename>/boot/loader.conf</span> 上述例子中提到的三行之前加入下行：</p></div><div class="literalblock programlisting"><div class=content><pre>vesa_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>其他有用的 <span class=filename>loader.conf</span> 選項還有：</p></div><div class=dlist><dl><dt class=hdlist1><code>beastie_disable="YES"</code></dt><dd><p>這個會關閉開機選項選單的顯示，但倒數計時提示仍會在。即使關閉了開機選項選單，在倒數計時提示時輸入選擇的選項還是會啟動對應的開機選項。</p></dd><dt class=hdlist1><code>loader_logo="beastie"</code></dt><dd><p>這個選項會替換預設與上色的小惡魔圖示一起顯示於開機選項選單右側的 "FreeBSD" 文字。</p></dd></dl></div><div class=paragraph><p>要取得更多資訊，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=splash&amp;sektion=4&amp;format=html">splash(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=vga&amp;sektion=4&amp;format=html">vga(4)</a>。</p></div></div><div class=sect2><h3 id=device-hints>12.4. 裝置提示<a class=anchor href=#device-hints></a></h3><div class=paragraph><p>在一開始系統啟動時，開機 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> 會讀取 <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>，這個檔中儲存了核心開機資訊，即變數，有時我們又會稱其為 "裝置提示 (Device hints)"。這些 "裝置提示 (Device hints)" 會傳送給裝置驅動程式做裝置的設置使用。</p></div><div class=paragraph><p>裝置提示也可在階段 3 開機載入程式提示時指定，如 <a href=#boot-loader>階段三</a> 中的示範，其變數也可以使用 <code>set</code> 增加、使用 <code>unset</code> 移除、使用 <code>show</code> 檢視，也可覆蓋設定在 <span class=filename>/boot/device.hints</span> 的變數，但在開機載入程式輸入的裝置提示並不是永久有效的，在下一次重新開機久後便會失效。</p></div><div class=paragraph><p>一旦系統開機後，便可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a> 來列出所有的變數。</p></div><div class=paragraph><p><span class=filename>/boot/device.hints</span> 的語法為一個變數一行，使用井字號 "#" 做為註解符號，每一行的結構如下：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> hint.driver.unit.keyword<span class=o>=</span><span class=s2>&#34;value&#34;</span></code></pre></div></div><div class=paragraph><p>在階段 3 開機載入程式的語法則為：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set </span>hint.driver.unit.keyword<span class=o>=</span>value</code></pre></div></div><div class=paragraph><p>其中 <code>driver</code> 為裝置驅動程式名稱、<code>unit</code> 為裝置驅動程式單位編號及 <code>keyword</code> 為提示關鍵字，關鍵字由以下選項所組成：</p></div><div class=ulist><ul><li><p><code>at</code>: 指定裝置所連結的匯流排 (Bus)。</p></li><li><p><code>port</code>: 指定要使用的 I/O 開始位置。</p></li><li><p><code>irq</code>: 指定要使用的中斷請求編號。</p></li><li><p><code>drq</code>: 指定 DMA 頻道編號。</p></li><li><p><code>maddr</code>: 指定裝置所使用的實體記憶體位置。</p></li><li><p><code>flags</code>: 設定提供給裝置的各種旗標位元。</p></li><li><p><code>disabled</code>: 若設為 <code>1</code> 則可關閉該裝置。</p></li></ul></div><div class=paragraph><p>由於裝置驅動程式可能會接受或請求更多未列於此處的提示，建議先閱讀驅動程式的操作手冊。要取得更多資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>。</p></div></div><div class=sect2><h3 id=boot-shutdown>12.5. 關機程序<a class=anchor href=#boot-shutdown></a></h3><div class=paragraph><p>在使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> 控制關閉時，<a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> 會嘗試執行 <span class=filename>/etc/rc.shutdown</span> Script 接著傳送 <code>TERM</code> 信號給所有的程序，然後傳送 <code>KILL</code> 信號給未在時間內中止的程序。</p></div><div class=paragraph><p>要在支援電源管理的架構與系統關閉 FreeBSD 主機電源，可使用 <code>shutdown -p now</code> 來立即關閉電源，要重新啟動 FreeBSD 系統可使用 <code>shutdown -r now</code>。操作人必須為 <code>root</code> 或為 <code>operator</code> 的成員才可執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a>，擁有這些身份的人也可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=halt&amp;sektion=8&amp;format=html">halt(8)</a> 與 <a href="https://man.freebsd.org/cgi/man.cgi?query=reboot&amp;sektion=8&amp;format=html">reboot(8)</a>，參考這些指令與 <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> 的操作手冊來取得更多資訊。</p></div><div class=paragraph><p>要修改群組成員可參考 <a href=./#users-synopsis>使用者與基礎帳號管理</a>。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>電源管理需要以載入 <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> 模組或將其靜態編譯至自訂核心中。</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=security>Chapter 13. 安全性<a class=anchor href=#security></a></h2><div class=sectionbody><div class=sect2><h3 id=security-synopsis>13.1. 概述<a class=anchor href=#security-synopsis></a></h3><div class=paragraph><p>不論實體或虛擬，安全性這個主題大到有整個產業圍繞著它，上百個標準案例已經被用來搛寫如何確保系統與網路的安全性。身為 FreeBSD 必須了解如何避免攻擊與入侵。</p></div><div class=paragraph><p>在此章會討論幾個基本原理及技術。FreeBSD 系統的安全性有許多層面，且有許多第三方工具可以用來增加安全性。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>基礎 FreeBSD 系統安全概念。</p></li><li><p>FreeBSD 中的幾種加密 (Crypt) 機制。</p></li><li><p>如何設定一次性密碼認證。</p></li><li><p>如何設定 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 中的 TCP Wrapper。</p></li><li><p>如何在 FreeBSD 設定 Kerberos。</p></li><li><p>如何設定 IPsec 並且建立 VPN。</p></li><li><p>如何在 FreeBSD 設定並使用 OpenSSH。</p></li><li><p>如何使用檔案系統 ACL。</p></li><li><p>如何使用 pkg 來稽查從 Port 套件集安裝的第三方軟體套件。</p></li><li><p>如何利用 FreeBSD 安全報告。</p></li><li><p>什麼是程序追蹤 (Process Accounting) 以及如何在 FreeBSD 開啟。</p></li><li><p>如何使用登入類別或資源限制資料庫控制使用者資源。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解 FreeBSD 基礎及網路概念。</p></li></ul></div><div class=paragraph><p>其他的安全性議題會在本操作手冊的其他處說明。例如 強制存取控制 (Mandatory Access Control, MAC) 會在 <a href=./#mac>強制存取控制 (MAC)</a> 討論及網路防火牆會在 <a href=./#firewalls>防火牆</a> 討論。</p></div></div><div class=sect2><h3 id=security-intro>13.2. 簡介<a class=anchor href=#security-intro></a></h3><div class=paragraph><p>保安是每個人的責任，任何系統中的弱點都可讓入侵者取得對關鍵資訊的存取權並導致整個網路的浩劫。資訊安全的其中一個核心原則便是 CIA 三字訣，代表著資訊系統的機密性 (Confidentiality)、完整性 (Integrity) 以及可用性 (Availability)。</p></div><div class=paragraph><p>CIA 三字訣是電腦安全的基石，就如同客戶與使用者期望他們的資料得到保護一樣重要。例如，一個客戶會期望他們的信用卡資訊被安全的保存 (機密性)、他們的訂單不會在私底下被竄改 (完整性) 以及他們隨時可以存取他們的訂單資訊 (可用性)。</p></div><div class=paragraph><p>要提供 CIA，安全專家會應用防禦深度的策略。防禦深度的概念是增加數個保全階層來避免單一階層失效便導致整個安全系統瓦解。例如，系統管理者不能直接打開防火牆與評估網路或系統的安全性，還要同時稽查帳號、檢查 Binary 的完整性與確保未被安裝惡意工具。要執行有效的保安策略，必須了解威脅以及如何抵禦威脅。</p></div><div class=paragraph><p>什麼威脅影響到電腦安全性? 威脅並不僅限於在遠端嘗試未經授權存取系統的遠端攻擊者，威脅也包含員工、惡意軟體、未經許可的網路裝置、天然災害、安全性漏洞甚至是公司競爭對手。</p></div><div class=paragraph><p>系統與網路可以被未經授權存取，有時是因為意外，或是因遠端攻擊者，或在某些案例中，是因商業間諜或者前員工。做為使用者，重要的是做好防範準備以及當有失誤造成安全漏洞能夠承認並回報可能的問題給安全團隊。做為管理者，重要的是了解威脅並準備在發生時能夠減緩威脅。</p></div><div class=paragraph><p>當要應用保安到系統上時，建議由基本帳號以及系統設定開始保全，接著確保網路層，使其遵守系統政策以及組織的安全程序。許多組織已經有涵蓋科技裝置設置的安全性政策，該政策應包含工作站、桌上型電腦、行動裝置、手機、上線伺服器、開發伺服器的安全設置。在大多數案例中，也都已經有標準操作程序 (SOP)，當有疑慮時，請向安全團隊諮詢。</p></div><div class=paragraph><p>簡介接下來的部份將說明如何在 FreeBSD 系統上執行這些基礎的安全設置。本章接下來的部份將介紹在 FreeBSD 系統執行安全性政策時會用到的特定工具。</p></div><div class=sect3><h4 id=security-accounts>13.2.1. 防止登入<a class=anchor href=#security-accounts></a></h4><div class=paragraph><p>要確保一個系統的安全最好的起點便是做好帳號的稽查，確保 <code>root</code> 使用了一個強而有力的密碼，並這個密碼未在其他地方使用過，然後關閉任何無須登入存取權的帳號。</p></div><div class=paragraph><p>要防止登入存取帳號有兩種方法，第一種是鎖定帳號，以下範例會鎖定 <code>toor</code> 帳號：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw lock toor</span></code></pre></div></div><div class=paragraph><p>第二種防止登入存取的方式是狀 Shell 更改為 <span class=filename>/usr/sbin/nologin</span>，只有超級使用者可以更改其他使用者的 Shell：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chsh -s /usr/sbin/nologin toor</span></code></pre></div></div><div class=paragraph><p><span class=filename>/usr/sbin/nologin</span> shell 可以避免系統分配 Shell 給嘗試登入的使用者。</p></div></div><div class=sect3><h4 id=security-accountmgmt>13.2.2. 帳號升級授權<a class=anchor href=#security-accountmgmt></a></h4><div class=paragraph><p>在有一些案例，需要與其他使用者共用系統管理權限，FreeBSD 有兩種方式可以處理這種情況。第一種，也是較不建議的方式，是與 <code>wheel</code> 群組的成員共用 root 的密碼，這種方式使用者可以在需要超級使用者的存取權時輸入 <code>su</code> 然後輸入 <code>wheel</code> 的密碼，在完成需要管理存取權的指令之後，使用應輸入 <code>exit</code> 離開。要加入使用者到這個群組，可編輯 <span class=filename>/etc/group</span> 然後加入該使用者到 <code>wheel</code> 項目的最後，使用者必須以逗號字元分隔並不可有空白。</p></div><div class=paragraph><p>第二種方式，也是較建議的方式，安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> 套件或 Port 來提升權限。這個軟體提供了額外的稽查、更細微的使用者控制，然後可以設定鎖定使用者只能執行特定需權限的指令。</p></div><div class=paragraph><p>在安裝之後，使用 <code>visudo</code> 來編輯 <span class=filename>/usr/local/etc/sudoers</span>。這個範例會建立新 <code>webadmin</code> 群組，並加入 <code>trhodes</code> 帳號到該群組，然後設定該群組可重新啟動 <a class=package href=https://cgit.freebsd.org/ports/tree/apache24/>apache24</a> 的存取權：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd webadmin -M trhodes -g 6000</span>
<span class=c># visudo</span>
%webadmin <span class=nv>ALL</span><span class=o>=(</span>ALL<span class=o>)</span> /usr/sbin/service apache24 <span class=k>*</span></code></pre></div></div></div><div class=sect3><h4 id=security-passwords>13.2.3. 密碼編碼方式<a class=anchor href=#security-passwords></a></h4><div class=paragraph><p>密碼是資訊科技的必要之惡，當必須使用密碼時，應要有複雜且強大的雜湊機制來加密儲存在密碼資料庫中的密碼。FreeBSD 支援 DES, MD5, SHA256, SHA512 以及 Blowfish 雜湊演算法於其 <code>crypt()</code> 程式庫。預設使用 SHA512，不建議改成更不安全的雜湊演算法，但可改成更安全的 Blowfish 演算法。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Blowfish 不是 AES 的一部份且不符合任何聯邦資訊處理標準 (Federal Information Processing Standards, FIPS)，在某些環境可能不會允許使用這種加密方式。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要知道目前用何種雜湊演算法來加密某位使用者密碼，超級使用者可以檢視在 FreeBSD 密碼資料庫中該使用者的雜湊，每個雜湊的一開始便會以符號標示其用來加密密碼所使用的雜湊機制。若使用 DES 則開始不會有任何符號，而 MD5 的符號則是 <code>$</code>，SHA256 及 SHA512 的符號是 <code>$6$</code>，Blowfish 的符號是 <code>$2a$</code>。在以下例子中 <code>dru</code> 的密碼使以預設的 SHA512 演算法加密，因為其雜湊的開始為 <code>$6$</code>。注意，該加密過的雜湊，不是原來的密碼，會儲存於密碼資料庫中：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep dru /etc/master.passwd</span>
dru:<span class=nv>$6$pzIjSvCAn</span>.PBYQBA<span class=nv>$PXpSeWPx3g5kscj3IMiM7tUEUSPmGexxta</span>.8Lt9TGSi2lNQqYGKszsBPuGME0:1001:1001::0:0:dru:/usr/home/dru:/bin/csh</code></pre></div></div><div class=paragraph><p>雜湊機制是設定在該使用者的登入類別 (Login class)，以此為例，該使用者屬於 <code>default</code> 登入類別，且雜湊演算法是以下行設定在 <span class=filename>/etc/login.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>        :passwd_format=sha512:\</pre></div></div><div class=paragraph><p>要更改演算法為 Blowfish，可修改該行如下：</p></div><div class="literalblock programlisting"><div class=content><pre>        :passwd_format=blf:\</pre></div></div><div class=paragraph><p>然後依 <a href=#users-limiting>設定登入類別</a> 中所描述的方式執行 <code>cap_mkdb /etc/login.conf</code>。注意，這個動作不會影響任何已存在的密碼雜湊，但這代表必須要求所有使用者執行 <code>passwd</code> 來更改其密碼才有辦法重新加密所有密碼。</p></div><div class=paragraph><p>針對遠端登入，應使用雙重認證 (Two-factor authentication)，舉例來說您同時要 "有某樣東西"，如：鑰匙，以及 "知道某個資訊"，如：密碼。自從 OpenSSH 是 FreeBSD 基礎系統的一部份，所有來算網路的登入應透過加密過的連線且使用以金鑰為基礎的認証來替代密碼。要了解更多資訊請參考 <a href=#openssh>OpenSSH</a>。Kerberos 的使用者可能會需要多做一些額外的更改才能在其網路上使用 OpenSSH，這些更改在 <a href=#kerberos5>Kerberos</a> 中會有說明。</p></div></div><div class=sect3><h4 id=security-pwpolicy>13.2.4. 強制密碼政策<a class=anchor href=#security-pwpolicy></a></h4><div class=paragraph><p>強制在本地帳號使用高強度密碼的政策是系統安全的基礎之一。在 FreeBSD 密碼長度、密碼強度以及密碼複雜性可使用內建的可插拔認証模組 (Pluggable Authentication Modules, PAM) 來執行。</p></div><div class=paragraph><p>本節將示範如何設定密碼長度下限與上限以及使用 <span class=filename>pam_passwdqc.so</span> 來強制使用混合字元的密碼，此模組可在使用者更改其密碼時強制要求。</p></div><div class=paragraph><p>要設定此模組，需要先成為超級使用者，然後取消註解在 <span class=filename>/etc/pam.d/passwd</span> 中含有 <code>pam_passwdqc.so</code> 的行。然後編輯該行來配合密碼政策：</p></div><div class="literalblock programlisting"><div class=content><pre>password        requisite       pam_passwdqc.so         min=disabled,disabled,disabled,12,10 similar=deny retry=3 enforce=users</pre></div></div><div class=paragraph><p>這個例子會設定新密碼所需符合的需求。<code>min</code> 設定可以控制密碼長度下限，它有五個值因為這個模組根據密碼的複雜度定義了五種類型。而複雜度是由必須在密碼中存在的字元類型來定義，例如：文字、數字、符號以及大小寫，這些密碼類型在 <a href="https://man.freebsd.org/cgi/man.cgi?query=pam_passwdqc&amp;sektion=8&amp;format=html">pam_passwdqc(8)</a> 有詳細的說明。在這個例子，密碼類型的前三項為關閉的，代表不會接受只滿足這些複雜度的密碼，不論長度為何。<code>12</code> 設定密碼政策可接受滿足三種字元類型複雜度且至少 12 個字元的密碼，<code>10</code> 設定密碼政策接受滿足四種字元類型複雜度且至少 10 個字元的密碼。</p></div><div class=paragraph><p><code>similar</code> 設定則會拒絕以使用者前一次類似的密碼。<code>retry</code> 設定會提供使用者三次輸入新密碼的機會。</p></div><div class=paragraph><p>一這個檔案儲存之後，更改密碼的使用者將會看到如下的訊息：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
Changing <span class=nb>local </span>password <span class=k>for </span>trhodes
Old Password:

You can now choose the new password.
A valid password should be a mix of upper and lower <span class=k>case</span> letters,
digits and other characters.  You can use a 12 character long
password with characters from at least 3 of these 4 classes, or
a 10 character long password containing characters from all the
classes.  Characters that form a common pattern are discarded by
the check.
Alternatively, <span class=k>if </span>no one <span class=k>else </span>can see your terminal now, you can
pick this as your password: <span class=s2>&#34;trait-useful&amp;knob&#34;</span><span class=nb>.</span>
Enter new password:</code></pre></div></div><div class=paragraph><p>若輸入了一個不符何密碼政策的密碼，則會被拒絕並顯示警告，然後使用者會有機會再重試，直到超過設定的允許重試次數。</p></div><div class=paragraph><p>大多數密碼政策會讓密碼在多日過後過期。要在 FreeBSD 設定密碼年齡日期，可在 <span class=filename>/etc/login.conf</span> 中該使用者的登入類別設定 <code>passwordtime</code>。在 <code>default</code> 登入類別已有設定範例：</p></div><div class="literalblock programlisting"><div class=content><pre>#       :passwordtime=90d:\</pre></div></div><div class=paragraph><p>因此，要設定此登入類別的密碼在 90 天之後過期只需要移除註解符號 (<code>#</code>)，然後儲存編輯結果並執行 <code>cap_mkdb /etc/login.conf</code>。</p></div><div class=paragraph><p>要在個別使用者設定期限，可將有效日期或到期的天數與使用者名稱傳給 <code>pw</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod -p 30-apr-2015 -n trhodes</span></code></pre></div></div><div class=paragraph><p>如這個例子，有效日期的格式為天、月以及年。要取得更多資訊可參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>。</p></div></div><div class=sect3><h4 id=security-rkhunter>13.2.5. 偵測 Root 工具 (Rootkit)<a class=anchor href=#security-rkhunter></a></h4><div class=paragraph><p><em>rootkit</em> 指的是嘗試未經授權取得系統 <code>root</code> 存取權的軟體。一旦安裝之後，這個惡意軟體將可以光明正大的開啟給另一個給攻擊者進入的大門。現實上，一但系統已被 rootkit 滲透且執行了搜索動作之後，該系統就應該從頭重新安裝，因為即使非常謹真的資安或系統工程式也可能會遺漏攻擊者留下的動西。</p></div><div class=paragraph><p>rootkit 對管理者而言唯一有幫助的是：一但偵測到，便代表某處已經被滲透，但這類型的應用程式躲藏的非常好，本節將會示範一個可以用來偵測 rootkit 的工具，<a class=package href=https://cgit.freebsd.org/ports/tree/security/rkhunter/>security/rkhunter</a>。</p></div><div class=paragraph><p>安裝此套件或 Port 之後，系統便可使用以下指令檢查。該指令提供許多資訊且會需要手動按下 <kbd>ENTER</kbd> 確認：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rkhunter -c</span></code></pre></div></div><div class=paragraph><p>該程序完成之後，目前狀態的訊息便會顯示在畫面上。這個訊息包含了已檢查過多少檔案、可疑的檔案、可能的 rootkit 以及其他更多資訊。在檢查的過程中，可能會產生一些有關隱藏檔案、OpenSSH 通訊協定選擇及已安裝軟體已知漏洞版本的通用的安全性警告、這些問題可以立即處理或在更詳細的分析之後再處理。</p></div><div class=paragraph><p>每位管理者應了解在系統上執行了那些程式以及這些程式的用途。第三方工具如 rkhunter 與 <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/lsof/>sysutils/lsof</a> 以及原生指令如 <code>netstat</code> 與 <code>ps</code> 可以系統上大量的資訊，記錄下那一些是正常的，當有不適當的程式出現時提出疑問，然後找出答案。雖然理想要避免滲透，但也必須偵測是否已被滲透了。</p></div></div><div class=sect3><h4 id=security-ids>13.2.6. Binary 檢驗<a class=anchor href=#security-ids></a></h4><div class=paragraph><p>檢驗系統檔案與 Binary 是很重要的，因為它可以提供系統管理者與資安團隊有關系統變更的資訊，能夠監視系統變更的軟體應用程式稱為入侵偵測系統 (Intrusion Detection System, IDS)。</p></div><div class=paragraph><p>FreeBSD 原生提供了基礎的 IDS 系統，雖然每天晚上會有安全性的信件會通知管理者相關的變更，但這些資訊是儲存在本地的，這讓惡意的使用者有機會能夠修改這些資訊來隱藏其對系統的變更。也因此，會建議建立一個獨立的 Binary 簽名並將這些簽名儲存在唯度、root 擁有的目錄或在可移除的 USB 磁碟或遠端 rsync 伺服器更好。</p></div><div class=paragraph><p>內建 <code>mtree</code> 工具可以對一個目錄中的內容產生一個規格檔，產生規格檔會用到一個種子碼 (Seed) 或常數，然後在檢查規格是否有更改過時會也會需要使用這個種子碼或常數。這讓檢查一個檔案或 Binary 是否被修改變成可能的一件事。由於攻擊者並不知道種子碼，要仿冒或檢查檔案的校驗碼 (Checksum) 數值是幾乎不可能的。以下例子會產生一組 SHA256 雜湊，每一個在 <span class=filename>/bin</span> 的系統 Binary 都會有一個，並姐會將這些值以隱藏黨儲存在 <code>root</code> 的家目錄，<span class=filename>/root/.bin_chksum_mtree</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mtree -s 3483151339707503 -c -K cksum,sha256digest -p /bin &gt; /root/.bin_chksum_mtree</span>
<span class=c># mtree: /bin checksum: 3427012225</span></code></pre></div></div><div class=paragraph><p><em>3483151339707503</em> 代表種子碼，這個值應要記錄下來且不可給其它人看。</p></div><div class=paragraph><p>檢視 <span class=filename>/root/.bin_cksum_mtree</span> 應會產生類似以下的輸出結果：</p></div><div class="literalblock programlisting"><div class=content><pre>#          user: root
#       machine: dreadnaught
#          tree: /bin
#          date: Mon Feb  3 10:19:53 2014

# .
/set type=file uid=0 gid=0 mode=0555 nlink=1 flags=none
.               type=dir mode=0755 nlink=2 size=1024 \
                time=1380277977.000000000
    \133        nlink=2 size=11704 time=1380277977.000000000 \
                cksum=484492447 \
                sha256digest=6207490fbdb5ed1904441fbfa941279055c3e24d3a4049aeb45094596400662a
    cat         size=12096 time=1380277975.000000000 cksum=3909216944 \
                sha256digest=65ea347b9418760b247ab10244f47a7ca2a569c9836d77f074e7a306900c1e69
    chflags     size=8168 time=1380277975.000000000 cksum=3949425175 \
                sha256digest=c99eb6fc1c92cac335c08be004a0a5b4c24a0c0ef3712017b12c89a978b2dac3
    chio        size=18520 time=1380277975.000000000 cksum=2208263309 \
                sha256digest=ddf7c8cb92a58750a675328345560d8cc7fe14fb3ccd3690c34954cbe69fc964
    chmod       size=8640 time=1380277975.000000000 cksum=2214429708 \
                sha256digest=a435972263bf814ad8df082c0752aa2a7bdd8b74ff01431ccbd52ed1e490bbe7</pre></div></div><div class=paragraph><p>機器的主機名稱、建立規格檔的日期與時間、以及建立此規格檔的使用者名稱皆會記錄在此報告當中，報告當中還會有在目錄中每個 Binary 的校驗碼、大小、時間以及 SHA256 編碼。</p></div><div class=paragraph><p>要檢驗 Binary 簽名是否有被變更過，可使用先前產生的規格檔比對目前目錄的內容，然後儲存結果到檔案。這個指令需要當初產生原規格檔所使用的種子碼：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mtree -s 3483151339707503 -p /bin &lt; /root/.bin_chksum_mtree &gt;&gt; /root/.bin_chksum_output</span>
<span class=c># mtree: /bin checksum: 3427012225</span></code></pre></div></div><div class=paragraph><p>這個動作應會產生與上次建立 <span class=filename>/bin</span> 規格檔時產生的校驗碼相同，若在此目錄的 Binary 沒有被變更過，那麼 <span class=filename>/root/.bin_chksum_output</span> 這個輸出檔將會是空的。要模擬變更，可以使用 <code>touch</code> 更改 <span class=filename>/root/.bin_chksum_output</span> 的日期然後再執行檢驗指令一次：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /bin/cat</span>
<span class=c># mtree -s 3483151339707503 -p /bin &lt; /root/.bin_chksum_mtree &gt;&gt; /root/.bin_chksum_output</span>
<span class=c># more /root/.bin_chksum_output</span>
<span class=nb>cat </span>changed
	modification <span class=nb>time </span>expected Fri Sep 27 06:32:55 2013 found Mon Feb  3 10:28:43 2014</code></pre></div></div><div class=paragraph><p>建議對含有 Binary 以及設定檔的目錄建立規格檔，對含有敏感資料的目錄也是。通常會為 <span class=filename>/bin</span>, <span class=filename>/sbin</span>, <span class=filename>/usr/bin</span>, <span class=filename>/usr/sbin</span>, <span class=filename>/usr/local/bin</span>, <span class=filename>/etc</span> 及 <span class=filename>/usr/local/etc</span> 建立規格檔。</p></div><div class=paragraph><p>也有更進階的 IDS 系統，例如 <a class=package href=https://cgit.freebsd.org/ports/tree/security/aide/>security/aide</a>。大多數情況 <code>mtree</code> 已可提供管理者所需的功能。將種子碼與校驗碼結果保存在惡意使用者無法存取的地方是非常重要的一件事。更多有關 <code>mtree</code> 的資訊可在 <a href="https://man.freebsd.org/cgi/man.cgi?query=mtree&amp;sektion=8&amp;format=html">mtree(8)</a> 找到。</p></div></div><div class=sect3><h4 id=security-tuning>13.2.7. 系統安全性調校<a class=anchor href=#security-tuning></a></h4><div class=paragraph><p>在 FreeBSD，有許多系統功能可以使用 <code>sysctl</code> 調校，本節會涵蓋少數可以調校來避免阻斷服務 (Denial of Service, DoS) 攻擊的安全性功能。更多有關使用 <code>sysctl</code> 的資訊包含：如何暫時更改數值及如何在測試之後做永久更改可在 <a href=./#configtuning-sysctl>使用 sysctl(8) 調校</a> 找到。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>任何時間使用 <a href=./#configtuning-sysctl>使用 sysctl(8) 調校</a> 做的設定變更都會讓造成不想要的傷害的可能性上升，影響到系統的可用性。因此應要對所有的變更做監視，若可能的話，先在測試系統上實驗，再到上線的系統上使用。</p></div></td></tr></tbody></table></div><div class=paragraph><p>預設 FreeBSD 核心會使用安全性層級 <code>-1</code> 來開機，這又稱作"不安全模式"，因為不可變 (Immutable) 檔案旗標可以被關閉且可以讀取或寫入所有的裝置。除非有使用 <code>sysctl</code> 或在啟動 Script 設定修改該值，否則安全性層級將會在 <code>-1</code>。安全性層級可以在系統啟動時透過在 <span class=filename>/etc/rc.conf</span> 設定 <code>kern_securelevel_enable</code> 為 <code>YES</code> 以及 設定 <code>kern_securelevel</code> 的值為想要的安全層級來提升。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=security&amp;sektion=7&amp;format=html">security(7)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> 以取得更多與這些設定及可用的安全性層級相關的資訊。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>提高 <code>securelevel</code> 會導致 Xorg 無法執行以及造成其他問題，請做好除錯的準備。</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>net.inet.tcp.blackhole</code> 以及 <code>net.inet.udp.blackhole</code> 設定可以用來丟棄在已關閉連接埠 (Port) 收到的 SYN 封包且不會回傳 RST 回應，預設的動作是會回傳 RST 來表示該連接埠已被關閉，更改預設的動作可對連接埠掃描 (用在查看在系統上執行的應用程式) 提供一定程度的保護，要這麼做可設定 <code>net.inet.tcp.blackhole</code> 為 <code>2</code> 及 <code>net.inet.udp.blackhole</code> 為 <code>1</code>。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=blackhole&amp;sektion=4&amp;format=html">blackhole(4)</a> 以取得更多有關這些設定的資訊。</p></div><div class=paragraph><p><code>net.inet.icmp.drop_redirect</code> 以及 <code>net.inet.ip.redirect</code> 設定可以幫助避免 <em>重新導向攻擊 (Redirect attacks)</em>，重新導向攻擊是 DoS 的一種，會傳送大量 ICMP 類型 5 的封包，由於這些封包並不是必要的，設定 <code>net.inet.icmp.drop_redirect</code> 為 <code>1</code> 以及設定 <code>net.inet.ip.redirect</code> 為 <code>0</code> 可丟棄這些封包。</p></div><div class=paragraph><p>來源路由 (Source routing) 是一種偵測與存取在內部網路中不可路由位址的方法，由於不可路由位址通常是固故讓它不可路由的，因此可以關閉這個功能。要關閉這個功能可設定 <code>net.inet.ip.sourceroute</code> 以及 <code>net.inet.ip.accept_sourceroute</code> 為 <code>0</code>。</p></div><div class=paragraph><p>當一台在網路上的機器需要傳送訊息給所有在子網路上的主機時，會發送 ICMP 回應請求訊息到廣播位址。然而，外部的主機是沒有理由可以執行這個動作的。要拒絕所有來自外部的廣播請求可設定 <code>net.inet.icmp.bmcastecho</code> 為 <code>0</code>。</p></div><div class=paragraph><p>還有一些額外的設定在 <a href="https://man.freebsd.org/cgi/man.cgi?query=security&amp;sektion=7&amp;format=html">security(7)</a> 有說明。</p></div></div></div><div class=sect2><h3 id=one-time-passwords>13.3. 一次性密碼<a class=anchor href=#one-time-passwords></a></h3><div class=paragraph><p>預設 FreeBSD 已內建一次性密碼 (One-time Passwords In Everything, OPIE)。OPIE 設計用來避免重送攻擊 (Replay attack)，重送攻擊指的是攻擊者發現了某位使用者的密碼，然後使用該密碼來存取系統。由於在 OPIE 的環境下，一組密碼只能被使用一次，被發現的密碼對攻擊者而言便沒有什麼作用。OPIE 使用了安全的加密方式與詰問/回應系統 (Challenge/response system) 來管理密碼。FreeBSD 在實作上預設採用 MD5 加密。</p></div><div class=paragraph><p>OPIE 使用了三種不同類型的密碼，第一種是一般的 UNIX™ 或 Kerberos 密碼，第二種是由 <code>opiekey</code> 所產生的一次性密碼，第三種是用來生一次性密碼的 "秘密密碼 (Secret password)"，秘密密碼與 UNIX™ 密碼無關且不應相同。</p></div><div class=paragraph><p>對 OPIE 來說還有另外兩個部份的資料很重要。其中一個是"種子碼 (Seed)" 或稱"金鑰 (Key)"，由兩個字母與五個數字組成。另一個則是"疊代次數 (Iteration count)"，是一個介於 1 到 100 間的數字。OPIE 會將種子碼與秘密密碼串連後，套用 MD5 加密數次後 (根據疊代次數)，再將結果轉換成六個簡短的英文單字來產生一次性密碼。認証系統會持續追蹤最後使用的一次性密碼，若使用者提供的密碼加密後與前一次的密碼相同則可通過認証。由於採用了單向的加密方式，若使用過的密碼被成功擷取也無法拿來產生之後的一次性密碼。疊代次數會在每一次登入成功之後減少，來保持使用者與登入程式間的同步。當疊代次數減少至 <code>1</code> 時，OPIE 便要重新初始化。</p></div><div class=paragraph><p>這個整個程序會牽涉到幾個程式。傳送疊代次數、種子碼與秘密密碼來產生一組一次性密碼或數個一次性密碼的 <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a>。除了初始化 OPIE 之外，用來更改密碼、疊代次數或種子碼的 <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a>。會讀取放在 <span class=filename>/etc/opiekeys</span> 的相關憑証檔來列出使用者目前的疊代次數與種子碼的 <a href="https://man.freebsd.org/cgi/man.cgi?query=opieinfo&amp;sektion=1&amp;format=html">opieinfo(1)</a>。</p></div><div class=paragraph><p>本章節將介紹四種不同的操作，第一是如何在安全連線下做第一次的一次性密碼設定，第二是如何使用在不安全的連線下使用 <code>opiepasswd</code>，第三是如何在不安全的連線下登入系統，第四是如何產生數個可以被記錄或列印下來在不安全的場所使的金鑰。</p></div><div class=sect3><h4 id=_初始化_opie>13.3.1. 初始化 OPIE<a class=anchor href=#_初始化_opie></a></h4><div class=paragraph><p>第一次要初始化 OPIE，要在安全的場所執行以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd <span class=nt>-c</span>
Adding unfurl:
Only use this method from the console<span class=p>;</span> NEVER from remote. If you are using
telnet, xterm, or a dial-in, <span class=nb>type</span> ^C now or <span class=nb>exit </span>with no password.
Then run opiepasswd without the <span class=nt>-c</span> parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:

ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</code></pre></div></div><div class=paragraph><p><code>-c</code> 會設定採用假設指令在安全場所執行的 Console 模式，如在使用者掌控之中的電腦或者透過 SSH 連線到一台在使用者掌控之中的電腦。</p></div><div class=paragraph><p>提示出現後，輸入用來產生一次性登入金鑰的秘密密碼，應使用一個不容易被猜出來的密碼，且應與使用者登入帳號所使用的密碼不同，密碼必須介於 10 到 127 個字元長度之間，然後請記住這個密碼。</p></div><div class=paragraph><p><code>ID</code> 行會列出登入名稱 (<code>unfurl</code>)、預設的疊代次數 (<code>499</code>) 以及預設的種子碼 (<code>to4268</code>)。在進行登入時，系統會記住這些參數並且顯示出來，這也代表不需要另外記錄這些資訊。最後一行會列出根據這些參數與秘密密碼所產生出來的一次性密碼，在下一次登入時便要使用這個一次性密碼。</p></div></div><div class=sect3><h4 id=_在不安全連線下做初始化>13.3.2. 在不安全連線下做初始化<a class=anchor href=#_在不安全連線下做初始化></a></h4><div class=paragraph><p>要在不安全的系統上初始化或更改秘密密碼會需要某個可使用安全的連線的地方執行 <code>opiekey</code>，這可能是在某一台信任的主機上的 Shell。初始化需要設定疊代次數，100 可能是不錯的數字，種子碼可以自行指定或隨機產生，在不安全連線下要被初始化主機須使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
	otp-md5 498 to4268 ext
	Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
	otp-md5 499 to4269
	Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</code></pre></div></div><div class=paragraph><p>要採用預設的種子碼，可直接按下 <kbd>Return</kbd> 做初始化。接著在輸入回應之前移到安全的連線然後給予相同的加密參數產生密碼：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</code></pre></div></div><div class=paragraph><p>切換回不安全的連線，然後複製產生的一次性密碼貼上。</p></div></div><div class=sect3><h4 id=_產生單組一次性密碼>13.3.3. 產生單組一次性密碼<a class=anchor href=#_產生單組一次性密碼></a></h4><div class=paragraph><p>在初始化 OPIE 之後進行登入會顯示如下的提示訊息：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>example.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;username&gt;
otp-md5 498 gr4269 ext
Password:</code></pre></div></div><div class=paragraph><p>OPIE 的提示提供了一個很有用的功能，若在密碼提示時按下 <kbd>Return</kbd>，便會開啟回應功能並顯示輸入的內容，這個功能在嘗試手工輸入列印出來的密碼時很有用。</p></div><div class=paragraph><p>此時，要產生一次性密碼來回應登入時的提示，這必須在受信任且可安全執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> 的系統上完成。這個指令有提供 Windows™, Mac OS™ 與 FreeBSD 版本，使用時需要疊代次數與種子碼做為在指令列的參數，剪下在要登入主機在登入時所提示的訊息。</p></div><div class=paragraph><p>在信任的系統上執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</code></pre></div></div><div class=paragraph><p>在產生一次性密碼後，回到登入畫面繼續登入。</p></div></div><div class=sect3><h4 id=_產生多組一次性密碼>13.3.4. 產生多組一次性密碼<a class=anchor href=#_產生多組一次性密碼></a></h4><div class=paragraph><p>有時會無法存取信任的主機或沒有安全的連線，在這種情況下，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> 來預先產生多個一次性密碼，例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey <span class=nt>-n</span> 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: &lt;secret password&gt;
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</code></pre></div></div><div class=paragraph><p><code>-n 5</code> 會請求產生連續五個金鑰，而 <code>30</code> 則是指定最後一個疊代的編號。注意這些列印出的結果的順序與使用的順序<em>相反</em>。十足的偏執狂可能會想要用手寫下結果，否則就列印出清單。每一行會同時顯示疊代次數及一次性密碼，在密碼使用過後便可劃掉。</p></div></div><div class=sect3><h4 id=_限制使用_unix_密碼>13.3.5. 限制使用 UNIX™ 密碼<a class=anchor href=#_限制使用_unix_密碼></a></h4><div class=paragraph><p>OPIE 可以根據登入階段的 IP 位置限制使用 UNIX™ 密碼，相關的檔案為 <span class=filename>/etc/opieaccess</span>，這個檔案預設便存在。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=opieaccess&amp;sektion=5&amp;format=html">opieaccess(5)</a> 來取得更多有關此檔案的資訊以及當使用時要考量的安全性問題。</p></div><div class=paragraph><p>這裡有一個範本 <span class=filename>opieaccess</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>permit 192.168.0.0 255.255.0.0</pre></div></div><div class=paragraph><p>這一行允許來源 IP 位址 (容易受到詐騙的位址) 符合指定值與遮罩的使用者在任何時間可使用 UNIX™ 密碼登入。</p></div><div class=paragraph><p>若在 <span class=filename>opieaccess</span> 中沒有符合的規則，預設會拒絕非 OPIE 的登入。</p></div></div></div><div class=sect2><h3 id=tcpwrappers>13.4. TCP Wrapper<a class=anchor href=#tcpwrappers></a></h3><div class=paragraph><p>TCP Wrapper is a host-based access control system which extends the abilities of <a href=./#network-inetd>inetd 超級伺服器</a>. It can be configured to provide logging support, return messages, and connection restrictions for the server daemons under the control of inetd. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpd&amp;sektion=8&amp;format=html">tcpd(8)</a> for more information about TCP Wrapper and its features.</p></div><div class=paragraph><p>TCP Wrapper should not be considered a replacement for a properly configured firewall. Instead, TCP Wrapper should be used in conjunction with a firewall and other security enhancements in order to provide another layer of protection in the implementation of a security policy.</p></div><div class=sect3><h4 id=_初始設定>13.4.1. 初始設定<a class=anchor href=#_初始設定></a></h4><div class=paragraph><p>To enable TCP Wrapper in FreeBSD, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;
inetd_flags=&#34;-Ww&#34;</pre></div></div><div class=paragraph><p>Then, properly configure <span class=filename>/etc/hosts.allow</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Unlike other implementations of TCP Wrapper, the use of <span class=filename>hosts.deny</span> is deprecated in FreeBSD. All configuration options should be placed in <span class=filename>/etc/hosts.allow</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In the simplest configuration, daemon connection policies are set to either permit or block, depending on the options in <span class=filename>/etc/hosts.allow</span>. The default configuration in FreeBSD is to allow all connections to the daemons started with inetd.</p></div><div class=paragraph><p>Basic configuration usually takes the form of <code>daemon : address : action</code>, where <code>daemon</code> is the daemon which inetd started, <code>address</code> is a valid hostname, IP address, or an IPv6 address enclosed in brackets ([ ]), and <code>action</code> is either <code>allow</code> or <code>deny</code>. TCP Wrapper uses a first rule match semantic, meaning that the configuration file is scanned from the beginning for a matching rule. When a match is found, the rule is applied and the search process stops.</p></div><div class=paragraph><p>For example, to allow POP3 connections via the <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a> daemon, the following lines should be appended to <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre></div></div><div class=paragraph><p>Whenever this file is edited, restart inetd:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd restart</span></code></pre></div></div></div><div class=sect3><h4 id=_進階設定>13.4.2. 進階設定<a class=anchor href=#_進階設定></a></h4><div class=paragraph><p>TCP Wrapper provides advanced options to allow more control over the way connections are handled. In some cases, it may be appropriate to return a comment to certain hosts or daemon connections. In other cases, a log entry should be recorded or an email sent to the administrator. Other situations may require the use of a service for local connections only. This is all possible through the use of configuration options known as wildcards, expansion characters, and external command execution.</p></div><div class=paragraph><p>Suppose that a situation occurs where a connection should be denied yet a reason should be sent to the host who attempted to establish that connection. That action is possible with <code>twist</code>. When a connection attempt is made, <code>twist</code> executes a shell command or script. An example exists in <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># The rest of the daemons are protected.
ALL : ALL \
	: severity auth.info \
	: twist /bin/echo &#34;You are not welcome to use %d from %h.&#34;</pre></div></div><div class=paragraph><p>In this example, the message "You are not allowed to use <em>daemon name</em> from <em>hostname</em>." will be returned for any daemon not configured in <span class=filename>hosts.allow</span>. This is useful for sending a reply back to the connection initiator right after the established connection is dropped. Any message returned <em>must</em> be wrapped in quote (<code>"</code>) characters.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>It may be possible to launch a denial of service attack on the server if an attacker floods these daemons with connection requests.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Another possibility is to use <code>spawn</code>. Like <code>twist</code>, <code>spawn</code> implicitly denies the connection and may be used to run external shell commands or scripts. Unlike <code>twist</code>, <code>spawn</code> will not send a reply back to the host who established the connection. For example, consider the following configuration:</p></div><div class="literalblock programlisting"><div class=content><pre># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</pre></div></div><div class=paragraph><p>This will deny all connection attempts from <code>*.example.com</code> and log the hostname, IP address, and the daemon to which access was attempted to <span class=filename>/var/log/connections.log</span>. This example uses the substitution characters <code>%a</code> and <code>%h</code>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> for the complete list.</p></div><div class=paragraph><p>To match every instance of a daemon, domain, or IP address, use <code>ALL</code>. Another wildcard is <code>PARANOID</code> which may be used to match any host which provides an IP address that may be forged because the IP address differs from its resolved hostname. In this example, all connection requests to Sendmail which have an IP address that varies from its hostname will be denied:</p></div><div class="literalblock programlisting"><div class=content><pre># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</pre></div></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Using the <code>PARANOID</code> wildcard will result in denied connections if the client or server has a broken DNS setup.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To learn more about wildcards and their associated functionality, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When adding new configuration lines, make sure that any unneeded entries for that daemon are commented out in <span class=filename>hosts.allow</span>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=kerberos5>13.5. Kerberos<a class=anchor href=#kerberos5></a></h3><div class=paragraph><p>Kerberos is a network authentication protocol which was originally created by the Massachusetts Institute of Technology (MIT) as a way to securely provide authentication across a potentially hostile network. The Kerberos protocol uses strong cryptography so that both a client and server can prove their identity without sending any unencrypted secrets over the network. Kerberos can be described as an identity-verifying proxy system and as a trusted third-party authentication system. After a user authenticates with Kerberos, their communications can be encrypted to assure privacy and data integrity.</p></div><div class=paragraph><p>The only function of Kerberos is to provide the secure authentication of users and servers on the network. It does not provide authorization or auditing functions. It is recommended that Kerberos be used with other security methods which provide authorization and audit services.</p></div><div class=paragraph><p>The current version of the protocol is version 5, described in RFC 4120. Several free implementations of this protocol are available, covering a wide range of operating systems. MIT continues to develop their Kerberos package. It is commonly used in the US as a cryptography product, and has historically been subject to US export regulations. In FreeBSD, MITKerberos is available as the <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a> package or port. The Heimdal Kerberos implementation was explicitly developed outside of the US to avoid export regulations. The Heimdal Kerberos distribution is included in the base FreeBSD installation, and another distribution with more configurable options is available as <a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a> in the Ports Collection.</p></div><div class=paragraph><p>In Kerberos users and services are identified as "principals" which are contained within an administrative grouping, called a "realm". A typical user principal would be of the form <code><em>user</em>@<em>REALM</em></code> (realms are traditionally uppercase).</p></div><div class=paragraph><p>This section provides a guide on how to set up Kerberos using the Heimdal distribution included in FreeBSD.</p></div><div class=paragraph><p>For purposes of demonstrating a Kerberos installation, the name spaces will be as follows:</p></div><div class=ulist><ul><li><p>The DNS domain (zone) will be <code>example.org</code>.</p></li><li><p>The Kerberos realm will be <code>EXAMPLE.ORG</code>.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Use real domain names when setting up Kerberos, even if it will run internally. This avoids DNS problems and assures inter-operation with other Kerberos realms.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_設定_heimdal_kdc>13.5.1. 設定 Heimdal KDC<a class=anchor href=#_設定_heimdal_kdc></a></h4><div class=paragraph><p>The Key Distribution Center (KDC) is the centralized authentication service that Kerberos provides, the "trusted third party" of the system. It is the computer that issues Kerberos tickets, which are used for clients to authenticate to servers. Because the KDC is considered trusted by all other computers in the Kerberos realm, it has heightened security concerns. Direct access to the KDC should be limited.</p></div><div class=paragraph><p>While running a KDC requires few computing resources, a dedicated machine acting only as a KDC is recommended for security reasons.</p></div><div class=paragraph><p>To begin setting up a KDC, add these lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kdc_enable=&#34;YES&#34;
kadmind_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Next, edit <span class=filename>/etc/krb5.conf</span> as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
	kdc = kerberos.example.org
	admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>In this example, the KDC will use the fully-qualified hostname <code>kerberos.example.org</code>. The hostname of the KDC must be resolvable in the DNS.</p></div><div class=paragraph><p>Kerberos can also use the DNS to locate KDCs, instead of a <code>[realms]</code> section in <span class=filename>/etc/krb5.conf</span>. For large organizations that have their own DNS servers, the above example could be trimmed to:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
      default_realm = EXAMPLE.ORG
[domain_realm]
    .example.org = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>With the following lines being included in the <code>example.org</code> zone file:</p></div><div class="literalblock programlisting"><div class=content><pre>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In order for clients to be able to find the Kerberos services, they <em>must</em> have either a fully configured <span class=filename>/etc/krb5.conf</span> or a minimally configured <span class=filename>/etc/krb5.conf</span><em>and</em> a properly configured DNS server.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Next, create the Kerberos database which contains the keys of all principals (users and hosts) encrypted with a master password. It is not required to remember this password as it will be stored in <span class=filename>/var/heimdal/m-key</span>; it would be reasonable to use a 45-character random password for this purpose. To create the master key, run <code>kstash</code> and enter a password:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>
Master key: xxxxxxxxxxxxxxxxxxxxxxx
Verifying password - Master key: xxxxxxxxxxxxxxxxxxxxxxx</code></pre></div></div><div class=paragraph><p>Once the master key has been created, the database should be initialized. The Kerberos administrative tool <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> can be used on the KDC in a mode that operates directly on the database, without using the <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmind&amp;sektion=8&amp;format=html">kadmind(8)</a> network service, as <code>kadmin -l</code>. This resolves the chicken-and-egg problem of trying to connect to the database before it is created. At the <code>kadmin</code> prompt, use <code>init</code> to create the realm’s initial database:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin -l</span>
kadmin&gt; init EXAMPLE.ORG
Realm max ticket life <span class=o>[</span>unlimited]:</code></pre></div></div><div class=paragraph><p>Lastly, while still in <code>kadmin</code>, create the first principal using <code>add</code>. Stick to the default options for the principal for now, as these can be changed later with <code>modify</code>. Type <code>?</code> at the prompt to see the available options.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>kadmin&gt; add tillman
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx</code></pre></div></div><div class=paragraph><p>Next, start the KDC services by running <code>service kdc start</code> and <code>service kadmind start</code>. While there will not be any kerberized daemons running at this point, it is possible to confirm that the KDC is functioning by obtaining a ticket for the principal that was just created:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit tillman
tillman@EXAMPLE.ORG<span class=s1>&#39;s Password:</span></code></pre></div></div><div class=paragraph><p>Confirm that a ticket was successfully obtained using <code>klist</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% klist
Credentials cache: FILE:/tmp/krb5cc_1001
	Principal: tillman@EXAMPLE.ORG

  Issued                Expires               Principal
Aug 27 15:37:58 2013  Aug 28 01:37:58 2013  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</code></pre></div></div><div class=paragraph><p>The temporary ticket can be destroyed when the test is finished:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kdestroy</code></pre></div></div></div><div class=sect3><h4 id=_設定伺服器使用_kerberos>13.5.2. 設定伺服器使用 Kerberos<a class=anchor href=#_設定伺服器使用_kerberos></a></h4><div class=paragraph><p>The first step in configuring a server to use Kerberos authentication is to ensure that it has the correct configuration in <span class=filename>/etc/krb5.conf</span>. The version from the KDC can be used as-is, or it can be regenerated on the new system.</p></div><div class=paragraph><p>Next, create <span class=filename>/etc/krb5.keytab</span> on the server. This is the main part of "Kerberizing" a service — it corresponds to generating a secret shared between the service and the KDC. The secret is a cryptographic key, stored in a "keytab". The keytab contains the server’s host key, which allows it and the KDC to verify each others' identity. It must be transmitted to the server in a secure fashion, as the security of the server can be broken if the key is made public. Typically, the <span class=filename>keytab</span> is generated on an administrator’s trusted machine using <code>kadmin</code>, then securely transferred to the server, e.g., with <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>; it can also be created directly on the server if that is consistent with the desired security policy. It is very important that the keytab is transmitted to the server in a secure fashion: if the key is known by some other party, that party can impersonate any user to the server! Using <code>kadmin</code> on the server directly is convenient, because the entry for the host principal in the KDC database is also created using <code>kadmin</code>.</p></div><div class=paragraph><p>Of course, <code>kadmin</code> is a kerberized service; a Kerberos ticket is needed to authenticate to the network service, but to ensure that the user running <code>kadmin</code> is actually present (and their session has not been hijacked), <code>kadmin</code> will prompt for the password to get a fresh ticket. The principal authenticating to the kadmin service must be permitted to use the <code>kadmin</code> interface, as specified in <span class=filename>kadmind.acl</span>. See the section titled "Remote administration" in <code>info heimdal</code> for details on designing access control lists. Instead of enabling remote <code>kadmin</code> access, the administrator could securely connect to the KDC via the local console or <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, and perform administration locally using <code>kadmin -l</code>.</p></div><div class=paragraph><p>After installing <span class=filename>/etc/krb5.conf</span>, use <code>add --random-key</code> in <code>kadmin</code>. This adds the server’s host principal to the database, but does not extract a copy of the host principal key to a keytab. To generate the keytab, use <code>ext</code> to extract the server’s host principal key to its own keytab:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; add <span class=nt>--random-key</span> host/myserver.example.org
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Principal expiration <span class=nb>time</span> <span class=o>[</span>never]:
Password expiration <span class=nb>time</span> <span class=o>[</span>never]:
Attributes <span class=o>[]</span>:
kadmin&gt; ext_keytab host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Note that <code>ext_keytab</code> stores the extracted key in <span class=filename>/etc/krb5.keytab</span> by default. This is good when being run on the server being kerberized, but the <code>--keytab <em>path/to/file</em></code> argument should be used when the keytab is being extracted elsewhere:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; ext_keytab <span class=nt>--keytab</span><span class=o>=</span>/tmp/example.keytab host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>The keytab can then be securely copied to the server using <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> or a removable media. Be sure to specify a non-default keytab name to avoid inserting unneeded keys into the system’s keytab.</p></div><div class=paragraph><p>At this point, the server can read encrypted messages from the KDC using its shared key, stored in <span class=filename>krb5.keytab</span>. It is now ready for the Kerberos-using services to be enabled. One of the most common such services is <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>, which supports Kerberos via the GSS-API. In <span class=filename>/etc/ssh/sshd_config</span>, add the line:</p></div><div class="literalblock programlisting"><div class=content><pre>GSSAPIAuthentication yes</pre></div></div><div class=paragraph><p>做完了這個變更之後，必須重新啟動 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 來使新的設定值生效：<code>service sshd restart</code>。</p></div></div><div class=sect3><h4 id=_設定客戶端使用_kerberos>13.5.3. 設定客戶端使用 Kerberos<a class=anchor href=#_設定客戶端使用_kerberos></a></h4><div class=paragraph><p>As it was for the server, the client requires configuration in <span class=filename>/etc/krb5.conf</span>. Copy the file in place (securely) or re-enter it as needed.</p></div><div class=paragraph><p>Test the client by using <code>kinit</code>, <code>klist</code>, and <code>kdestroy</code> from the client to obtain, show, and then delete a ticket for an existing principal. Kerberos applications should also be able to connect to Kerberos enabled servers. If that does not work but obtaining a ticket does, the problem is likely with the server and not with the client or the KDC. In the case of kerberized <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, GSS-API is disabled by default, so test using <code>ssh -o GSSAPIAuthentication=yes <em>hostname</em></code>.</p></div><div class=paragraph><p>When testing a Kerberized application, try using a packet sniffer such as <code>tcpdump</code> to confirm that no sensitive information is sent in the clear.</p></div><div class=paragraph><p>Various Kerberos client applications are available. With the advent of a bridge so that applications using SASL for authentication can use GSS-API mechanisms as well, large classes of client applications can use Kerberos for authentication, from Jabber clients to IMAP clients.</p></div><div class=paragraph><p>Users within a realm typically have their Kerberos principal mapped to a local user account. Occasionally, one needs to grant access to a local user account to someone who does not have a matching Kerberos principal. For example, <code>tillman@EXAMPLE.ORG</code> may need access to the local user account <code>webdevelopers</code>. Other principals may also need access to that local account.</p></div><div class=paragraph><p>The <span class=filename>.k5login</span> and <span class=filename>.k5users</span> files, placed in a user’s home directory, can be used to solve this problem. For example, if the following <span class=filename>.k5login</span> is placed in the home directory of <code>webdevelopers</code>, both principals listed will have access to that account without requiring a shared password:</p></div><div class="literalblock programlisting"><div class=content><pre>tillman@example.org
jdoe@example.org</pre></div></div><div class=paragraph><p>Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> for more information about <span class=filename>.k5users</span>.</p></div></div><div class=sect3><h4 id=_與_mit_的差異>13.5.4. 與 MIT 的差異<a class=anchor href=#_與_mit_的差異></a></h4><div class=paragraph><p>The major difference between the MIT and Heimdal implementations is that <code>kadmin</code> has a different, but equivalent, set of commands and uses a different protocol. If the KDC is MIT, the Heimdal version of <code>kadmin</code> cannot be used to administer the KDC remotely, and vice versa.</p></div><div class=paragraph><p>Client applications may also use slightly different command line options to accomplish the same tasks. Following the instructions at <a href=http://web.mit.edu/Kerberos/www/>http://web.mit.edu/Kerberos/www/</a> is recommended. Be careful of path issues: the MIT port installs into <span class=filename>/usr/local/</span> by default, and the FreeBSD system applications run instead of the MIT versions if <code>PATH</code> lists the system directories first.</p></div><div class=paragraph><p>When using MIT Kerberos as a KDC on FreeBSD, the following edits should also be made to <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kerberos5_server=&#34;/usr/local/sbin/krb5kdc&#34;
kadmind5_server=&#34;/usr/local/sbin/kadmind&#34;
kerberos5_server_flags=&#34;&#34;
kerberos5_server_enable=&#34;YES&#34;
kadmind5_server_enable=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=_kerberos_提示技巧與疑難排解>13.5.5. Kerberos 提示、技巧與疑難排解<a class=anchor href=#_kerberos_提示技巧與疑難排解></a></h4><div class=paragraph><p>When configuring and troubleshooting Kerberos, keep the following points in mind:</p></div><div class=ulist><ul><li><p>When using either Heimdal or MITKerberos from ports, ensure that the <code>PATH</code> lists the port’s versions of the client applications before the system versions.</p></li><li><p>If all the computers in the realm do not have synchronized time settings, authentication may fail. <a href=./#network-ntp>NTP 時間校對</a> describes how to synchronize clocks using NTP.</p></li><li><p>If the hostname is changed, the <code>host/</code> principal must be changed and the keytab updated. This also applies to special keytab entries like the <code>HTTP/</code> principal used for Apache’s <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_auth_kerb/>www/mod_auth_kerb</a>.</p></li><li><p>All hosts in the realm must be both forward and reverse resolvable in DNS or, at a minimum, exist in <span class=filename>/etc/hosts</span>. CNAMEs will work, but the A and PTR records must be correct and in place. The error message for unresolvable hosts is not intuitive: <code>Kerberos5 refuses authentication because Read req failed: Key table entry not found</code>.</p></li><li><p>Some operating systems that act as clients to the KDC do not set the permissions for <code>ksu</code> to be setuid <code>root</code>. This means that <code>ksu</code> does not work. This is a permissions problem, not a KDC error.</p></li><li><p>With MITKerberos, to allow a principal to have a ticket life longer than the default lifetime of ten hours, use <code>modify_principal</code> at the <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> prompt to change the <code>maxlife</code> of both the principal in question and the <code>krbtgt</code> principal. The principal can then use <code>kinit -l</code> to request a ticket with a longer lifetime.</p></li><li><p>When running a packet sniffer on the KDC to aid in troubleshooting while running <code>kinit</code> from a workstation, the Ticket Granting Ticket (TGT) is sent immediately, even before the password is typed. This is because the Kerberos server freely transmits a TGT to any unauthorized request. However, every TGT is encrypted in a key derived from the user’s password. When a user types their password, it is not sent to the KDC, it is instead used to decrypt the TGT that <code>kinit</code> already obtained. If the decryption process results in a valid ticket with a valid time stamp, the user has valid Kerberos credentials. These credentials include a session key for establishing secure communications with the Kerberos server in the future, as well as the actual TGT, which is encrypted with the Kerberos server’s own key. This second layer of encryption allows the Kerberos server to verify the authenticity of each TGT.</p></li><li><p>Host principals can have a longer ticket lifetime. If the user principal has a lifetime of a week but the host being connected to has a lifetime of nine hours, the user cache will have an expired host principal and the ticket cache will not work as expected.</p></li><li><p>When setting up <span class=filename>krb5.dict</span> to prevent specific bad passwords from being used as described in <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmind&amp;sektion=8&amp;format=html">kadmind(8)</a>, remember that it only applies to principals that have a password policy assigned to them. The format used in <span class=filename>krb5.dict</span> is one string per line. Creating a symbolic link to <span class=filename>/usr/shared/dict/words</span> might be useful.</p></li></ul></div></div><div class=sect3><h4 id=_減輕_kerberos_的限制>13.5.6. 減輕 Kerberos 的限制<a class=anchor href=#_減輕_kerberos_的限制></a></h4><div class=paragraph><p>Since Kerberos is an all or nothing approach, every service enabled on the network must either be modified to work with Kerberos or be otherwise secured against network attacks. This is to prevent user credentials from being stolen and re-used. An example is when Kerberos is enabled on all remote shells but the non-Kerberized POP3 mail server sends passwords in plain text.</p></div><div class=paragraph><p>The KDC is a single point of failure. By design, the KDC must be as secure as its master password database. The KDC should have absolutely no other services running on it and should be physically secure. The danger is high because Kerberos stores all passwords encrypted with the same master key which is stored as a file on the KDC.</p></div><div class=paragraph><p>A compromised master key is not quite as bad as one might fear. The master key is only used to encrypt the Kerberos database and as a seed for the random number generator. As long as access to the KDC is secure, an attacker cannot do much with the master key.</p></div><div class=paragraph><p>If the KDC is unavailable, network services are unusable as authentication cannot be performed. This can be alleviated with a single master KDC and one or more slaves, and with careful implementation of secondary or fall-back authentication using PAM.</p></div><div class=paragraph><p>Kerberos allows users, hosts and services to authenticate between themselves. It does not have a mechanism to authenticate the KDC to the users, hosts, or services. This means that a trojanned <code>kinit</code> could record all user names and passwords. File system integrity checking tools like <a class=package href=https://cgit.freebsd.org/ports/tree/security/tripwire/>security/tripwire</a> can alleviate this.</p></div></div><div class=sect3><h4 id=_相關資源與延伸資訊>13.5.7. 相關資源與延伸資訊<a class=anchor href=#_相關資源與延伸資訊></a></h4><div class=ulist><ul><li><p><a href=http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html>The Kerberos FAQ</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/dialogue.html>Designing an Authentication System: a Dialog in Four Scenes</a></p></li><li><p><a href=https://www.ietf.org/rfc/rfc4120.txt>RFC 4120, The Kerberos Network Authentication Service (V5)</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/>MIT Kerberos home page</a></p></li><li><p><a href=https://www.h5l.org/>Heimdal Kerberos home page</a></p></li></ul></div></div></div><div class=sect2><h3 id=openssl>13.6. OpenSSL<a class=anchor href=#openssl></a></h3><div class=paragraph><p>OpenSSL is an open source implementation of the SSL and TLS protocols. It provides an encryption transport layer on top of the normal communications layer, allowing it to be intertwined with many network applications and services.</p></div><div class=paragraph><p>The version of OpenSSL included in FreeBSD supports the Secure Sockets Layer 3.0 (SSLv3) and Transport Layer Security 1.0/1.1/1.2 (TLSv1/TLSv1.1/TLSv1.2) network security protocols and can be used as a general cryptographic library. In FreeBSD 12.0-RELEASE and above, OpenSSL also supports Transport Layer Security 1.3 (TLSv1.3).</p></div><div class=paragraph><p>OpenSSL is often used to encrypt authentication of mail clients and to secure web based transactions such as credit card payments. Some ports, such as <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache24/>www/apache24</a> and <a class=package href=https://cgit.freebsd.org/ports/tree/databases/postgresql11-server/>databases/postgresql11-server</a>, include a compile option for building with OpenSSL. If selected, the port will add support using OpenSSL from the base system. To instead have the port compile against OpenSSL from the <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssl/>security/openssl</a> port, add the following to <span class=filename>/etc/make.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>DEFAULT_VERSIONS+= ssl=openssl</pre></div></div><div class=paragraph><p>Another common use of OpenSSL is to provide certificates for use with software applications. Certificates can be used to verify the credentials of a company or individual. If a certificate has not been signed by an external <em>Certificate Authority</em> (CA), such as <a href=http://www.verisign.com>http://www.verisign.com</a>, the application that uses the certificate will produce a warning. There is a cost associated with obtaining a signed certificate and using a signed certificate is not mandatory as certificates can be self-signed. However, using an external authority will prevent warnings and can put users at ease.</p></div><div class=paragraph><p>This section demonstrates how to create and use certificates on a FreeBSD system. Refer to <a href=./#ldap-config>設定 LDAP 伺服器</a> for an example of how to create a CA for signing one’s own certificates.</p></div><div class=paragraph><p>For more information about SSL, read the free <a href=https://www.feistyduck.com/books/openssl-cookbook/>OpenSSL Cookbook</a>.</p></div><div class=sect3><h4 id=_產生憑証>13.6.1. 產生憑証<a class=anchor href=#_產生憑証></a></h4><div class=paragraph><p>To generate a certificate that will be signed by an external CA, issue the following command and input the information requested at the prompts. This input information will be written to the certificate. At the <code>Common Name</code> prompt, input the fully qualified name for the system that will use the certificate. If this name does not match the server, the application verifying the certificate will issue a warning to the user, rendering the verification provided by the certificate as useless.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -nodes -out req.pem -keyout cert.key -sha256 -newkey rsa:2048</span>
Generating a 2048 bit RSA private key
..................+++
.............................................................+++
writing new private key to <span class=s1>&#39;cert.key&#39;</span>
<span class=nt>-----</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>eg, YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org

Please enter the following <span class=s1>&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class=o>[]</span>:
An optional company name <span class=o>[]</span>:Another Name</code></pre></div></div><div class=paragraph><p>Other options, such as the expire time and alternate encryption algorithms, are available when creating a certificate. A complete list of options is described in <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a>.</p></div><div class=paragraph><p>This command will create two files in the current directory. The certificate request, <span class=filename>req.pem</span>, can be sent to a CA who will validate the entered credentials, sign the request, and return the signed certificate. The second file, <span class=filename>cert.key</span>, is the private key for the certificate and should be stored in a secure location. If this falls in the hands of others, it can be used to impersonate the user or the server.</p></div><div class=paragraph><p>Alternately, if a signature from a CA is not required, a self-signed certificate can be created. First, generate the RSA key:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl genrsa -rand -genkey -out cert.key 2048</span>
0 semi-random bytes loaded
Generating RSA private key, 2048 bit long modulus
.............................................+++
.................................................................................................................+++
e is 65537 <span class=o>(</span>0x10001<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Use this key to create a self-signed certificate. Follow the usual prompts for creating a certificate:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -x509 -days 365 -key cert.key -out cert.crt -sha256</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>e.g. server FQDN or YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org</code></pre></div></div><div class=paragraph><p>This will create two new files in the current directory: a private key file <span class=filename>cert.key</span>, and the certificate itself, <span class=filename>cert.crt</span>. These should be placed in a directory, preferably under <span class=filename>/etc/ssl/</span>, which is readable only by <code>root</code>. Permissions of <code>0700</code> are appropriate for these files and can be set using <code>chmod</code>.</p></div></div><div class=sect3><h4 id=_使用憑證>13.6.2. 使用憑證<a class=anchor href=#_使用憑證></a></h4><div class=paragraph><p>One use for a certificate is to encrypt connections to the Sendmail mail server in order to prevent the use of clear text authentication.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Some mail clients will display an error if the user has not installed a local copy of the certificate. Refer to the documentation included with the software for more information on certificate installation.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In FreeBSD 10.0-RELEASE and above, it is possible to create a self-signed certificate for Sendmail automatically. To enable this, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;YES&#34;
sendmail_cert_create=&#34;YES&#34;
sendmail_cert_cn=&#34;localhost.example.org&#34;</pre></div></div><div class=paragraph><p>This will automatically create a self-signed certificate, <span class=filename>/etc/mail/certs/host.cert</span>, a signing key, <span class=filename>/etc/mail/certs/host.key</span>, and a CA certificate, <span class=filename>/etc/mail/certs/cacert.pem</span>. The certificate will use the <code>Common Name</code> specified in <code>sendmail_cert_cn</code>. After saving the edits, restart Sendmail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sendmail restart</span></code></pre></div></div><div class=paragraph><p>If all went well, there will be no error messages in <span class=filename>/var/log/maillog</span>. For a simple test, connect to the mail server’s listening port using <code>telnet</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># telnet example.com 25</span>
Trying 192.0.34.166...
Connected to example.com.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
220 example.com ESMTP Sendmail 8.14.7/8.14.7<span class=p>;</span> Fri, 18 Apr 2014 11:50:32 <span class=nt>-0400</span> <span class=o>(</span>EDT<span class=o>)</span>
ehlo example.com
250-example.com Hello example.com <span class=o>[</span>192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 example.com closing connection
Connection closed by foreign host.</code></pre></div></div><div class=paragraph><p>If the <code>STARTTLS</code> line appears in the output, everything is working correctly.</p></div></div></div><div class=sect2><h3 id=ipsec>13.7. VPN over IPsec<a class=anchor href=#ipsec></a></h3><div class=paragraph><p>Internet Protocol Security (IPsec) is a set of protocols which sit on top of the Internet Protocol (IP) layer. It allows two or more hosts to communicate in a secure manner by authenticating and encrypting each IP packet of a communication session. The FreeBSD IPsec network stack is based on the <a href=http://www.kame.net/>http://www.kame.net/</a> implementation and supports both IPv4 and IPv6 sessions.</p></div><div class=paragraph><p>IPsec is comprised of the following sub-protocols:</p></div><div class=ulist><ul><li><p><em>Encapsulated Security Payload (ESP)</em>: this protocol protects the IP packet data from third party interference by encrypting the contents using symmetric cryptography algorithms such as Blowfish and 3DES.</p></li><li><p><em>Authentication Header (AH)</em>: this protocol protects the IP packet header from third party interference and spoofing by computing a cryptographic checksum and hashing the IP packet header fields with a secure hashing function. This is then followed by an additional header that contains the hash, to allow the information in the packet to be authenticated.</p></li><li><p><em>IP Payload Compression Protocol (IPComp</em>): this protocol tries to increase communication performance by compressing the IP payload in order to reduce the amount of data sent.</p></li></ul></div><div class=paragraph><p>These protocols can either be used together or separately, depending on the environment.</p></div><div class=paragraph><p>IPsec supports two modes of operation. The first mode, <em>Transport Mode</em>, protects communications between two hosts. The second mode, <em>Tunnel Mode</em>, is used to build virtual tunnels, commonly known as Virtual Private Networks (VPNs). Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> for detailed information on the IPsec subsystem in FreeBSD.</p></div><div class=paragraph><p>在 FreeBSD 11 與之後的版本預設會開啟 IPsec 功能，先前版本的 FreeBSD 可在自訂核心設定檔中加入以下選項然後依 <a href=./#kernelconfig>設定 FreeBSD 核心</a> 的指示來重新編譯核心：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC        <span class=c>#IP security</span>
device    crypto</code></pre></div></div><div class=paragraph><p>If IPsec debugging support is desired, the following kernel option should also be added:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_DEBUG  debug <span class=k>for </span>IP security</code></pre></div></div><div class=paragraph><p>This rest of this chapter demonstrates the process of setting up an IPsecVPN between a home network and a corporate network. In the example scenario:</p></div><div class=ulist><ul><li><p>Both sites are connected to the Internet through a gateway that is running FreeBSD.</p></li><li><p>The gateway on each network has at least one external IP address. In this example, the corporate LAN’s external IP address is <code>172.16.5.4</code> and the home LAN’s external IP address is <code>192.168.1.12</code>.</p></li><li><p>The internal addresses of the two networks can be either public or private IP addresses. However, the address space must not collide. For example, both networks cannot use <code>192.168.1.x</code>. In this example, the corporate LAN’s internal IP address is <code>10.246.38.1</code> and the home LAN’s internal IP address is <code>10.0.0.5</code>.</p></li></ul></div><div class=sect3><h4 id=_在_freebsd_上設定_vpn>13.7.1. 在 FreeBSD 上設定 VPN<a class=anchor href=#_在_freebsd_上設定_vpn></a></h4><div class=paragraph><p>To begin, <a class=package href=https://cgit.freebsd.org/ports/tree/security/ipsec-tools/>security/ipsec-tools</a> must be installed from the Ports Collection. This software provides a number of applications which support the configuration.</p></div><div class=paragraph><p>The next requirement is to create two <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> pseudo-devices which will be used to tunnel packets and allow both networks to communicate properly. As <code>root</code>, run the following commands, replacing <em>internal</em> and <em>external</em> with the real IP addresses of the internal and external interfaces of the two gateways:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0 internal1 internal2</span>
<span class=c># ifconfig gif0 tunnel external1 external2</span></code></pre></div></div><div class=paragraph><p>Verify the setup on each gateway, using <code>ifconfig</code>. Here is the output from Gateway 1:</p></div><div class="literalblock programlisting"><div class=content><pre>gif0: flags=8051 mtu 1280
tunnel inet 172.16.5.4 --&gt; 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
inet 10.246.38.1 --&gt; 10.0.0.5 netmask 0xffffff00</pre></div></div><div class=paragraph><p>Here is the output from Gateway 2:</p></div><div class="literalblock programlisting"><div class=content><pre>gif0: flags=8051 mtu 1280
tunnel inet 192.168.1.12 --&gt; 172.16.5.4
inet 10.0.0.5 --&gt; 10.246.38.1 netmask 0xffffff00
inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4</pre></div></div><div class=paragraph><p>Once complete, both internal IP addresses should be reachable using <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>priv-net# ping 10.0.0.5
PING 10.0.0.5 (10.0.0.5): 56 data bytes
64 bytes from 10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms
64 bytes from 10.0.0.5: icmp_seq=1 ttl=64 time=19.255 ms
64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms
--- 10.0.0.5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms

corp-net# ping 10.246.38.1
PING 10.246.38.1 (10.246.38.1): 56 data bytes
64 bytes from 10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms
64 bytes from 10.246.38.1: icmp_seq=1 ttl=64 time=42.917 ms
64 bytes from 10.246.38.1: icmp_seq=2 ttl=64 time=127.525 ms
64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms
64 bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms
--- 10.246.38.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms</pre></div></div><div class=paragraph><p>As expected, both sides have the ability to send and receive ICMP packets from the privately configured addresses. Next, both gateways must be told how to route packets in order to correctly send traffic from either network. The following commands will achieve this goal:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>corp-net# route add 10.0.0.0 10.0.0.5 255.255.255.0
corp-net# route add net 10.0.0.0: gateway 10.0.0.5
priv-net# route add 10.246.38.0 10.246.38.1 255.255.255.0
priv-net# route add host 10.246.38.0: gateway 10.246.38.1</code></pre></div></div><div class=paragraph><p>At this point, internal machines should be reachable from each gateway as well as from machines behind the gateways. Again, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> to confirm:</p></div><div class="literalblock programlisting"><div class=content><pre>corp-net# ping 10.0.0.8
PING 10.0.0.8 (10.0.0.8): 56 data bytes
64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
--- 10.0.0.8 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

priv-net# ping 10.246.38.107
PING 10.246.38.1 (10.246.38.107): 56 data bytes
64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
--- 10.246.38.107 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms</pre></div></div><div class=paragraph><p>Setting up the tunnels is the easy part. Configuring a secure link is a more in depth process. The following configuration uses pre-shared (PSK) RSA keys. Other than the IP addresses, the <span class=filename>/usr/local/etc/racoon/racoon.conf</span> on both gateways will be identical and look similar to:</p></div><div class="literalblock programlisting"><div class=content><pre>path    pre_shared_key  &#34;/usr/local/etc/racoon/psk.txt&#34;; #location of pre-shared key file
log     debug;	#log verbosity setting: set to &#39;notify&#39; when testing and debugging is complete

padding	# options are not to be changed
{
        maximum_length  20;
        randomize       off;
        strict_check    off;
        exclusive_tail  off;
}

timer	# timing options. change as needed
{
        counter         5;
        interval        20 sec;
        persend         1;
#       natt_keepalive  15 sec;
        phase1          30 sec;
        phase2          15 sec;
}

listen	# address [port] that racoon will listen on
{
        isakmp          172.16.5.4 [500];
        isakmp_natt     172.16.5.4 [4500];
}

remote  192.168.1.12 [500]
{
        exchange_mode   main,aggressive;
        doi             ipsec_doi;
        situation       identity_only;
        my_identifier   address 172.16.5.4;
        peers_identifier        address 192.168.1.12;
        lifetime        time 8 hour;
        passive         off;
        proposal_check  obey;
#       nat_traversal   off;
        generate_policy off;

                        proposal {
                                encryption_algorithm    blowfish;
                                hash_algorithm          md5;
                                authentication_method   pre_shared_key;
                                lifetime time           30 sec;
                                dh_group                1;
                        }
}

sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)	# address $network/$netmask $type address $network/$netmask $type ( $type being any or esp)
{								# $network must be the two internal networks you are joining.
        pfs_group       1;
        lifetime        time    36000 sec;
        encryption_algorithm    blowfish,3des;
        authentication_algorithm        hmac_md5,hmac_sha1;
        compression_algorithm   deflate;
}</pre></div></div><div class=paragraph><p>For descriptions of each available option, refer to the manual page for <span class=filename>racoon.conf</span>.</p></div><div class=paragraph><p>The Security Policy Database (SPD) needs to be configured so that FreeBSD and racoon are able to encrypt and decrypt network traffic between the hosts.</p></div><div class=paragraph><p>This can be achieved with a shell script, similar to the following, on the corporate gateway. This file will be used during system initialization and should be saved as <span class=filename>/usr/local/etc/racoon/setkey.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>flush;
spdflush;
# To the home network
spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
spdadd 10.0.0.0/24 10.246.38.0/24 any -P in ipsec esp/tunnel/192.168.1.12-172.16.5.4/use;</pre></div></div><div class=paragraph><p>Once in place, racoon may be started on both gateways using the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log</span></code></pre></div></div><div class=paragraph><p>The output should be similar to the following:</p></div><div class="literalblock programlisting"><div class=content><pre>corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
Foreground mode.
2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=28496098(0x1b2d0e2)
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=47784998(0x2d92426)
2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=124397467(0x76a279b)
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=175852902(0xa7b4d66)</pre></div></div><div class=paragraph><p>To ensure the tunnel is working properly, switch to another console and use <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> to view network traffic using the following command. Replace <code>em0</code> with the network interface card as required:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tcpdump -i em0 host 172.16.5.4 and dst 192.168.1.12</span></code></pre></div></div><div class=paragraph><p>Data similar to the following should appear on the console. If not, there is an issue and debugging the returned data will be required.</p></div><div class="literalblock programlisting"><div class=content><pre>01:47:32.021683 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
01:47:33.022442 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
01:47:34.024218 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)</pre></div></div><div class=paragraph><p>At this point, both networks should be available and seem to be part of the same network. Most likely both networks are protected by a firewall. To allow traffic to flow between them, rules need to be added to pass packets. For the <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> firewall, add the following lines to the firewall configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 00201 allow log esp from any to any
ipfw add 00202 allow log ah from any to any
ipfw add 00203 allow log ipencap from any to any
ipfw add 00204 allow log udp from any 500 to any</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The rule numbers may need to be altered depending on the current host configuration.</p></div></td></tr></tbody></table></div><div class=paragraph><p>For users of <a href="https://man.freebsd.org/cgi/man.cgi?query=pf&amp;sektion=4&amp;format=html">pf(4)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a>, the following rules should do the trick:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in quick proto esp from any to any
pass in quick proto ah from any to any
pass in quick proto ipencap from any to any
pass in quick proto udp from any port = 500 to any port = 500
pass in quick on gif0 from any to any
pass out quick proto esp from any to any
pass out quick proto ah from any to any
pass out quick proto ipencap from any to any
pass out quick proto udp from any port = 500 to any port = 500
pass out quick on gif0 from any to any</pre></div></div><div class=paragraph><p>Finally, to allow the machine to start support for the VPN during system initialization, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipsec_enable=&#34;YES&#34;
ipsec_program=&#34;/usr/local/sbin/setkey&#34;
ipsec_file=&#34;/usr/local/etc/racoon/setkey.conf&#34; # allows setting up spd policies on boot
racoon_enable=&#34;yes&#34;</pre></div></div></div></div><div class=sect2><h3 id=openssh>13.8. OpenSSH<a class=anchor href=#openssh></a></h3><div class=paragraph><p>OpenSSH 是一套網路連線工具，可安全的存取遠端的主機，此外，透過 SSH 連線可以建立 TCP/IP 連線通道或安全的轉送 TCP/IP 的封包。OpenSSH 會對所有傳輸的資料做加密，可有效的避免竊聽 (Eavesdropping)、或連線劫持 (Connection hijacking) 與其他網路層的攻擊。</p></div><div class=paragraph><p>OpenSSH 由 OpenBSD 專案所維護且在 FreeBSD 預設會安裝，它可同時相容 SSH 版本 1 與 2 通訊協定。</p></div><div class=paragraph><p>當以未加密的方式在網路上傳送資料時，任何在客戶端與伺服器之間的網路竊聽程式 (Network sniffer) 皆可竊取使用者/密碼資訊或者在連線階段傳送的資料，OpenSSH 提供了數種認証與加密方式來避免這種事情發生。更多有關 OpenSSH 的資訊可於 <a href=http://www.openssh.com/>http://www.openssh.com/</a> 取得。</p></div><div class=paragraph><p>本節會簡單介紹如何使用內建的客戶端工具安全的存取其他系統及安全的傳輸檔案到 FreeBSD 系統，然後會說明如何設定在 FreeBSD 系統上的 SSH 伺服器。更多的資訊可於本章節所提及的操作手冊 (Man page) 取得。</p></div><div class=sect3><h4 id=_使用_ssh_客戶端工具>13.8.1. 使用 SSH 客戶端工具<a class=anchor href=#_使用_ssh_客戶端工具></a></h4><div class=paragraph><p>要登入一台 SSH 伺服器，可使用 <code>ssh</code> 然後指定在伺服器上存在的使用者名稱與 IP 位址或伺服器的主機名稱。若這是第一次連線到指定的伺服器，會提示該使用者伺服器的指紋做第一次檢驗：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ssh user@example.com</span>
The authenticity of host <span class=s1>&#39;example.com (10.0.0.1)&#39;</span> can<span class=s1>&#39;t be established.
ECDSA key fingerprint is 25:cc:73:b5:b3:96:75:3d:56:19:49:d2:5c:1f:91:3b.
Are you sure you want to continue connecting (yes/no)? yes
Permanently added &#39;</span>example.com<span class=s1>&#39; (ECDSA) to the list of known hosts.
Password for user@example.com: user_password</span></code></pre></div></div><div class=paragraph><p>SSH 會在客戶端連線時利用金鑰指紋 (Key fingerprint) 系統來驗證伺服器的真偽，當使用者在第一次連線時輸入 <code>yes</code> 接受了這個金鑰指紋，便會將該金鑰的複本儲存到使用者家目錄的 <span class=filename>.ssh/known_hosts</span>，未來嘗試登入時便會以這個存好的金鑰來驗證，若伺服器的金鑰與儲存的金鑰不同將會顯示警告訊息。若出現這個警告時，使用者應在繼續連線之前檢查金鑰變動的原因。</p></div><div class=paragraph><p>最近版本的 OpenSSH 預設只會接受 SSHv2 的連線。客戶端預設會盡可能使用版本 2 的通訊協定，若伺服器不支援版本 2 的通訊協定便會向下相容版本 1 的協定。要強制 <code>ssh</code> 只能使用指定的通訊協定，可使用 <code>-1</code> 或 <code>-2</code>，其他的選項在 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> 中有說明。</p></div><div class=paragraph><p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> 可從遠端主機安全的複製一個檔案，以下範例會複製在遠端主機的 <span class=filename>COPYRIGHT</span> 到本地主機的目前目錄：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scp user@example.com:/COPYRIGHT COPYRIGHT</span>
Password <span class=k>for </span>user@example.com: <span class=k>*******</span>
COPYRIGHT            100% |<span class=k>*****************************</span>|  4735
00:00
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>由於這個主機的指紋已驗證過，在提示用者輸入密碼之前伺服器的金鑰已自動檢查。</p></div><div class=paragraph><p>傳給 <code>scp</code> 的參數與傳給 <code>cp</code> 的參數相似。第一個參數是要複製的檔案，第二個參數是目地，由於檔案是透過網路取得，檔案參數需要使用 <code>user@host:&lt;path_to_remote_file></code> 格式。注意，在 <code>scp</code> 要遞迴複製目錄是使用 <code>-r</code>，如同 <code>cp</code> 使用 <code>-R</code>。</p></div><div class=paragraph><p>要開啟可互動的連線來複製檔案可使用 <code>sftp</code>，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> 來取得在 <code>sftp</code> 連線時可用的指令清單。</p></div><div class=sect4><h5 id=security-ssh-keygen>13.8.1.1. 以金鑰為基礎的認證<a class=anchor href=#security-ssh-keygen></a></h5><div class=paragraph><p>除了使用密碼之外，客戶端可以設定成使用金鑰來連線到遠端的主機。要產生 RSA 認証金鑰可使用 <code>ssh-keygen</code>。要產生成對的公鑰與私鑰，可指定金鑰的類型並依提示操作。建議使用容易記住但較難猜出的密碼來保護這個金鑰。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-keygen <span class=nt>-t</span> rsa
Generating public/private rsa key pair.
Enter file <span class=k>in </span>which to save the key <span class=o>(</span>/home/user/.ssh/id_rsa<span class=o>)</span>:
Enter passphrase <span class=o>(</span>empty <span class=k>for </span>no passphrase<span class=o>)</span>:  <i class=conum data-value=1></i><b>(1)</b>
Enter same passphrase again:                 <i class=conum data-value=2></i><b>(2)</b>
Your identification has been saved <span class=k>in</span> /home/user/.ssh/id_rsa.
Your public key has been saved <span class=k>in</span> /home/user/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:54Xm9Uvtv6H4NOo6yjP/YCfODryvUU7yWHzMqeXwhq8 user@host.example.com
The key<span class=s1>&#39;s randomart image is:
+---[RSA 2048]----+
|                 |
|                 |
|                 |
|        . o..    |
|       .S*+*o    |
|      . O=Oo . . |
|       = Oo= oo..|
|      .oB.* +.oo.|
|       =OE**.o..=|
+----[SHA256]-----+</span></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>在此輸入密碼，密碼不可含有空白或符號。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>再輸入一次密碼驗證。</td></tr></tbody></table></div><div class=paragraph><p>私鑰會儲存於 <span class=filename>~/.ssh/id_rsa</span> 而公鑰會儲存於 <span class=filename>~/.ssh/id_rsa.pub</span>。<em>公鑰</em>必須複製到遠端主機的<span class=filename>~/.ssh/authorized_keys</span> 來讓以金鑰為基礎的認証可以運作。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>許多使用者認為金鑰的設計是安全的並在產生金鑰時未使用密碼，這樣的行為其實很<em>危險</em>。管理者可以手動查看私鑰來檢查金鑰對是否受密碼保護，如果私鑰檔案中包含 <code>ENCRYPTED</code> 字詞，則代表金鑰的擁有者有使用密碼。此外，要更進一步保護最終使用者的安全，可在公鑰檔案中放入 <code>from</code>，例如，在 <code>ssh-rsa</code> 前加上 <code>from="192.168.10.5"</code> 將只允許指定的使用者由該 IP 位址登入。</p></div></td></tr></tbody></table></div><div class=paragraph><p>不同版本 OpenSSH 的選項與檔案會不同，要避免發生問題請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>。</p></div><div class=paragraph><p>若使用了密碼，在每次連線到伺服器時都會提示使用者輸入密碼。要將 SSH 金鑰載入到記憶體並讓每次連線時不必再輸入密碼，可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> 與 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a>。</p></div><div class=paragraph><p>認証可用 <code>ssh-agent</code> 來管理，只要將私鑰載入，<code>ssh-agent</code> 可用在執行其他應用程式，如 Shell 或視窗管理程式。</p></div><div class=paragraph><p>要在 Shell 使用 <code>ssh-agent</code>，使用 Shell 做為參數來啟動 <code>ssh-agent</code>。執行 <code>ssh-add</code> 來加入識別碼，然後輸入私鑰的密碼。使用者將可使用 <code>ssh</code> 連線到任何有安裝對應公鑰的主機，例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-agent csh
% ssh-add
Enter passphrase <span class=k>for </span>key <span class=s1>&#39;/usr/home/user/.ssh/id_rsa&#39;</span>:  <i class=conum data-value=1></i><b>(1)</b>
Identity added: /usr/home/user/.ssh/id_rsa <span class=o>(</span>/usr/home/user/.ssh/id_rsa<span class=o>)</span>
%</code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>輸入金鑰的密碼。</td></tr></tbody></table></div><div class=paragraph><p>要在 Xorg 使用 <code>ssh-agent</code> 可在 <span class=filename>~/.xinitrc</span> 加入一個設定項目，這可讓 <code>ssh-agent</code> 對所有在 Xorg 中執行的程式提供服務。<span class=filename>~/.xinitrc</span> 範例如下：</p></div><div class="literalblock programlisting"><div class=content><pre>exec ssh-agent startxfce4</pre></div></div><div class=paragraph><p>這會在每次啟動 Xorg 時，反過來先執行 <code>ssh-agent</code> 再由執行 XFCE，一但 Xorg 被重新啟動，要讓所有變更生效需執行 <code>ssh-add</code> 來載入所有的 SSH 金鑰。</p></div></div><div class=sect4><h5 id=security-ssh-tunneling>13.8.1.2. SSH 通道<a class=anchor href=#security-ssh-tunneling></a></h5><div class=paragraph><p>OpenSSH 可以建立一個通道 (Tunnel) 來封裝其他通訊協定到一個加密的連線。</p></div><div class=paragraph><p>以下指令會告訴 <code>ssh</code> 建立一個供 telnet 使用的通道：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5023:localhost:23 user@foo.example.com
%</code></pre></div></div><div class=paragraph><p>這個例子使用了以下選項：</p></div><div class=dlist><dl><dt class=hdlist1><code>-2</code></dt><dd><p>強制 <code>ssh</code> 使用版本 2 的通訊協定連線到伺服器。</p></dd><dt class=hdlist1><code>-N</code></dt><dd><p>代表不需下指令、只建立通道。若省略這個選項 <code>ssh</code> 會初始化一個正常的連線。</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>強制 <code>ssh</code> 在背景執行。</p></dd><dt class=hdlist1><code>-L</code></dt><dd><p>代表這是一個本地通道，使用 <em>localport:remotehost:remoteport</em> 格式。</p></dd><dt class=hdlist1><code>user@foo.example.com</code></dt><dd><p>在指定的遠端 SSH 伺服器要使用的登入名稱。</p></dd></dl></div><div class=paragraph><p>SSH 通道會建立一個傾聽 <code>localhost</code> 指定 <code>localport</code> 的 Socket ，然後會透過 SSH 連線轉送任何在 <code>localport</code> 接收的連線。以這個例子來說在客戶端的 Port <code>5023</code> 會被轉送到遠端主機的 Port <code>23</code>，由於 Port 23 是由 telnet 使用，所以這會透過 SSH 通道建立一個加密的 telnet 連線。</p></div><div class=paragraph><p>這個方法可用來包裝許多不安全的 TCP 通訊協定，例如 SMTP, POP3 以及 FTP，如下例所示。</p></div><div class=exampleblock><div class=title>例 31. 建立供 SMTP 使用的安全通道</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com<span class=s1>&#39;s password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;</span>^]<span class=s1>&#39;.
220 mailserver.example.com ESMTP</span></code></pre></div></div><div class=paragraph><p>這可配合 <code>ssh-keygen</code> 與另一個使用者帳號與來建立一個更無縫的 SSH 通道環境，可使用金鑰來代替手動輸入密碼，然後該通道便可以另一個使用者執行。</p></div></div></div><div class=exampleblock><div class=title>例 32. 安全存取 POP3 伺服器</div><div class=content><div class=paragraph><p>在這個例子中有一個 SSH 伺服器會接受來自外部的連線，在同個網段下有一個郵件伺服器執行 POP3 伺服器。要使用較安全的方式檢查有沒有新郵件可建立一個 SSH 連線到 SSH 伺服器然後透過通道連線到郵件伺服器：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com<span class=s1>&#39;s password: ******</span></code></pre></div></div><div class=paragraph><p>一但通道啟動並執行後，指定郵件客戶端將 POP3 請求傳送到 <code>localhost</code> 的 Port 2110，這個連線將會被安全的透過通道轉送到 <code>mail.example.com</code>。</p></div></div></div><div class=exampleblock><div class=title>例 33. 跳過防火牆</div><div class=content><div class=paragraph><p>有些防火牆會同時過濾傳入與傳出的連線。例如，防火牆很可能會限制來自遠端主機只能存取 Port 22 與 80 來只讓 SSH 與網頁瀏覽器連線，這會使得 Port 使用 22 或 80 以外的服務無法存取。</p></div><div class=paragraph><p>這問題的解決方法是建立一個 SSH 連線到在防火牆防護之外主機然後使用該連線的通道連到想要使用的服務：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 8888:music.example.com:8000 user@unfirewalled-system.example.org
user@unfirewalled-system.example.org<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>在這個例子中，串流 Ogg Vorbis 客戶端現在可以指向 <code>localhost</code> Port 8888，連線將會被轉送到 <code>music.example.com</code> 於 Port 8000，成功的跳過防火牆。</p></div></div></div></div></div><div class=sect3><h4 id=_開啟_ssh_伺服器>13.8.2. 開啟 SSH 伺服器<a class=anchor href=#_開啟_ssh_伺服器></a></h4><div class=paragraph><p>除了提供內建的 SSH 客戶端工具外，還可以設定 FreeBSD 系統為一個 SSH 伺服器，以接受來自其他 SSH 客戶端的連線。</p></div><div class=paragraph><p>要查看 sshd 是否正在運作，可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> 指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd status</span></code></pre></div></div><div class=paragraph><p>若服務未執行，請加入下行到 <span class=filename>/etc/rc.conf</span>。</p></div><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>這會讓下次系統開機時啟動 OpenSSH 的 Daemon 程式 sshd。若要立即啟動：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd start</span></code></pre></div></div><div class=paragraph><p>在 FreeBSD 系統第一次啟動 sshd 時便會自動產生系統的主機金鑰且會顯示指紋在 Console 上，這個指紋可供使用者在第一次連線到伺服器時驗證用。</p></div><div class=paragraph><p>請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 可取得在啟動 sshd 時可用選項的清單以及更多完整有關認証、登入程序與各種設定檔的資訊。</p></div><div class=paragraph><p>現在，sshd 應可供所有在系統上有使用者名稱及密碼的使用者使用。</p></div></div><div class=sect3><h4 id=_ssh_伺服器安全性>13.8.3. SSH 伺服器安全性<a class=anchor href=#_ssh_伺服器安全性></a></h4><div class=paragraph><p>在 FreeBSD 廣泛使用 sshd 做為遠端管理基礎設施的同時，所有暴露在公有網路上的系統也會時常受到暴力攻擊 (Brute force attack) 與路過攻擊 (Drive by attack)。在本節會介紹一些可用來避免這些攻擊的參數。</p></div><div class=paragraph><p>使用在 OpenSSH 伺服器設定檔的 <code>AllowUsers</code> 關鍵字限制可以登入到 SSH 伺服器的使用者及來源是一個不錯的方式。例如要只允許來自 <code>192.168.1.32</code> 的 <code>root</code> 登入，可加入下行到 <span class=filename>/etc/ssh/sshd_config</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32</pre></div></div><div class=paragraph><p>要允許來自任何地方的 <code>admin</code> 登入，可只列出使用者名稱，不指定 IP 位址：</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers admin</pre></div></div><div class=paragraph><p>有多位使用者也應列在同一行，例如：</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32 admin</pre></div></div><div class=paragraph><p>在對 <span class=filename>/etc/ssh/sshd_config</span> 做完變更後，執行以下指令告訴 sshd 重新載入設定檔：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd reload</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>在使用了這個關鍵字時，列出每一位需要登入此主機的使用者很重要，任何未被在該行指定的使用者將無法登入。同時，在 OpenSSH 伺服器設定檔使用的關鍵字是區分大小寫的，若關鍵字未正確的拼寫 (含其大小寫)，則將會被忽略，永遠要記得測試對這個檔案所做的更改來確保伺服器有如預期的方式運作。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a> 來檢查拼寫以及可用的關鍵字。</p></div></td></tr></tbody></table></div><div class=paragraph><p>此外，使用者可能被強制要透過公鑰與私鑰使用雙重認證 (Two factor authentication)。當需要時，使用者可以透過使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> 產生一堆金鑰然後將公鑰傳送給管理者，這個金鑰檔會如以上在客戶端章節所述的被放在 <span class=filename>authorized_keys</span>。要強制使用者只能使用這個金鑰，可能需要設定以下選項：</p></div><div class="literalblock programlisting"><div class=content><pre>AuthenticationMethods publickey</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>請不要將 <span class=filename>/etc/ssh/sshd_config</span> 以及 <span class=filename>/etc/ssh/ssh_config</span> 搞混 (注意在第一節檔名有多出個 <code>d</code>)，第一個檔案用來設定伺服器，而第二個檔案用來設定客戶端。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh_config&amp;sektion=5&amp;format=html">ssh_config(5)</a> 來取得可用的客戶端設定清單。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=fs-acl>13.9. 存取控制清單<a class=anchor href=#fs-acl></a></h3><div class=paragraph><p>Access Control Lists (ACLs) extend the standard UNIX™ permission model in a POSIX™.1e compatible way. This permits an administrator to take advantage of a more fine-grained permissions model.</p></div><div class=paragraph><p>The FreeBSD <span class=filename>GENERIC</span> kernel provides ACL support for UFS file systems. Users who prefer to compile a custom kernel must include the following option in their custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options UFS_ACL</pre></div></div><div class=paragraph><p>If this option is not compiled in, a warning message will be displayed when attempting to mount a file system with ACL support. ACLs rely on extended attributes which are natively supported in UFS2.</p></div><div class=paragraph><p>This chapter describes how to enable ACL support and provides some usage examples.</p></div><div class=sect3><h4 id=_開啟_acl_支援>13.9.1. 開啟 ACL 支援<a class=anchor href=#_開啟_acl_支援></a></h4><div class=paragraph><p>ACLs are enabled by the mount-time administrative flag, <code>acls</code>, which may be added to <span class=filename>/etc/fstab</span>. The mount-time flag can also be automatically set in a persistent manner using <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> to modify a superblock ACLs flag in the file system header. In general, it is preferred to use the superblock flag for several reasons:</p></div><div class=ulist><ul><li><p>The superblock flag cannot be changed by a remount using <code>mount -u</code> as it requires a complete <code>umount</code> and fresh <code>mount</code>. This means that ACLs cannot be enabled on the root file system after boot. It also means that ACL support on a file system cannot be changed while the system is in use.</p></li><li><p>Setting the superblock flag causes the file system to always be mounted with ACLs enabled, even if there is not an <span class=filename>fstab</span> entry or if the devices re-order. This prevents accidental mounting of the file system without ACL support.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is desirable to discourage accidental mounting without ACLs enabled because nasty things can happen if ACLs are enabled, then disabled, then re-enabled without flushing the extended attributes. In general, once ACLs are enabled on a file system, they should not be disabled, as the resulting file protections may not be compatible with those intended by the users of the system, and re-enabling ACLs may re-attach the previous ACLs to files that have since had their permissions changed, resulting in unpredictable behavior.</p></div></td></tr></tbody></table></div><div class=paragraph><p>File systems with ACLs enabled will show a plus (<code>+</code>) sign in their permission settings:</p></div><div class="literalblock programlisting"><div class=content><pre>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</pre></div></div><div class=paragraph><p>In this example, <span class=filename>directory1</span>, <span class=filename>directory2</span>, and <span class=filename>directory3</span> are all taking advantage of ACLs, whereas <span class=filename>public_html</span> is not.</p></div></div><div class=sect3><h4 id=_使用_acl>13.9.2. 使用 ACL<a class=anchor href=#_使用_acl></a></h4><div class=paragraph><p>File system ACLs can be viewed using <code>getfacl</code>. For instance, to view the ACL settings on <span class=filename>test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% getfacl <span class=nb>test</span>
	<span class=c>#file:test</span>
	<span class=c>#owner:1001</span>
	<span class=c>#group:1001</span>
	user::rw-
	group::r--
	other::r--</code></pre></div></div><div class=paragraph><p>To change the ACL settings on this file, use <code>setfacl</code>. To remove all of the currently defined ACLs from a file or file system, include <code>-k</code>. However, the preferred method is to use <code>-b</code> as it leaves the basic fields required for ACLs to work.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-k</span> <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>To modify the default ACL entries, use <code>-m</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-m</span> u:trhodes:rwx,group:web:r--,o::--- <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>In this example, there were no pre-defined entries, as they were removed by the previous command. This command restores the default options and assigns the options listed. If a user or group is added which does not exist on the system, an <code>Invalid argument</code> error will be displayed.</p></div><div class=paragraph><p>Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a> for more information about the options available for these commands.</p></div></div></div><div class=sect2><h3 id=security-pkg>13.10. 監視第三方安全性問題<a class=anchor href=#security-pkg></a></h3><div class=paragraph><p>In recent years, the security world has made many improvements to how vulnerability assessment is handled. The threat of system intrusion increases as third party utilities are installed and configured for virtually any operating system available today.</p></div><div class=paragraph><p>Vulnerability assessment is a key factor in security. While FreeBSD releases advisories for the base system, doing so for every third party utility is beyond the FreeBSD Project’s capability. There is a way to mitigate third party vulnerabilities and warn administrators of known security issues. A FreeBSD add on utility known as pkg includes options explicitly for this purpose.</p></div><div class=paragraph><p>pkg polls a database for security issues. The database is updated and maintained by the FreeBSD Security Team and ports developers.</p></div><div class=paragraph><p>Please refer to <a href=./#pkgng-intro>instructions</a> for installing pkg.</p></div><div class=paragraph><p>Installation provides <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> configuration files for maintaining the pkg audit database, and provides a programmatic method of keeping it updated. This functionality is enabled if <code>daily_status_security_pkgaudit_enable</code> is set to <code>YES</code> in <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic.conf&amp;sektion=5&amp;format=html">periodic.conf(5)</a>. Ensure that daily security run emails, which are sent to <code>root</code>'s email account, are being read.</p></div><div class=paragraph><p>After installation, and to audit third party utilities as part of the Ports Collection at any time, an administrator may choose to update the database and view known vulnerabilities of installed packages by invoking:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg audit -F</span></code></pre></div></div><div class=paragraph><p>pkg displays messages any published vulnerabilities in installed packages:</p></div><div class="literalblock programlisting"><div class=content><pre>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;https://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</pre></div></div><div class=paragraph><p>By pointing a web browser to the displayed URL, an administrator may obtain more information about the vulnerability. This will include the versions affected, by FreeBSD port version, along with other web sites which may contain security advisories.</p></div><div class=paragraph><p>pkg is a powerful utility and is extremely useful when coupled with <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a>.</p></div></div><div class=sect2><h3 id=security-advisories>13.11. FreeBSD 安全報告<a class=anchor href=#security-advisories></a></h3><div class=paragraph><p>Like many producers of quality operating systems, the FreeBSD Project has a security team which is responsible for determining the End-of-Life (EoL) date for each FreeBSD release and to provide security updates for supported releases which have not yet reached their EoL. More information about the FreeBSD security team and the supported releases is available on the <a href=https://www.FreeBSD.org/security>FreeBSD security page</a>.</p></div><div class=paragraph><p>One task of the security team is to respond to reported security vulnerabilities in the FreeBSD operating system. Once a vulnerability is confirmed, the security team verifies the steps necessary to fix the vulnerability and updates the source code with the fix. It then publishes the details as a "Security Advisory". Security advisories are published on the <a href=https://www.FreeBSD.org/security/advisories/>FreeBSD website</a> and mailed to the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security-notifications>freebsd-security-notifications</a>, <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security>freebsd-security</a>, and <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce>freebsd-announce</a> mailing lists.</p></div><div class=paragraph><p>This section describes the format of a FreeBSD security advisory.</p></div><div class=sect3><h4 id=_安全報告的格式>13.11.1. 安全報告的格式<a class=anchor href=#_安全報告的格式></a></h4><div class=paragraph><p>Here is an example of a FreeBSD security advisory:</p></div><div class="literalblock programlisting"><div class=content><pre>=============================================================================
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

=============================================================================
FreeBSD-SA-14:04.bind                                       Security Advisory
                                                          The FreeBSD Project

Topic:          BIND remote denial of service vulnerability

Category:       contrib
Module:         bind
Announced:      2014-01-14
Credits:        ISC
Affects:        FreeBSD 8.x and FreeBSD 9.x
Corrected:      2014-01-14 19:38:37 UTC (stable/9, 9.2-STABLE)
                2014-01-14 19:42:28 UTC (releng/9.2, 9.2-RELEASE-p3)
                2014-01-14 19:42:28 UTC (releng/9.1, 9.1-RELEASE-p10)
                2014-01-14 19:38:37 UTC (stable/8, 8.4-STABLE)
                2014-01-14 19:42:28 UTC (releng/8.4, 8.4-RELEASE-p7)
                2014-01-14 19:42:28 UTC (releng/8.3, 8.3-RELEASE-p14)
CVE Name:       CVE-2014-0591

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit &lt;URL:http://security.FreeBSD.org/&gt;.

I.   Background

BIND 9 is an implementation of the Domain Name System (DNS) protocols.
The named(8) daemon is an Internet Domain Name Server.

II.  Problem Description

Because of a defect in handling queries for NSEC3-signed zones, BIND can
crash with an &#34;INSIST&#34; failure in name.c when processing queries possessing
certain properties.  This issue only affects authoritative nameservers with
at least one NSEC3-signed zone.  Recursive-only servers are not at risk.

III. Impact

An attacker who can send a specially crafted query could cause named(8)
to crash, resulting in a denial of service.

IV.  Workaround

No workaround is available, but systems not running authoritative DNS service
with at least one NSEC3-signed zone using named(8) are not vulnerable.

V.   Solution

Perform one of the following:

1) Upgrade your vulnerable system to a supported FreeBSD stable or
release / security branch (releng) dated after the correction date.

2) To update your vulnerable system via a source code patch:

The following patches have been verified to apply to the applicable
FreeBSD release branches.

a) Download the relevant patch from the location below, and verify the
detached PGP signature using your PGP utility.

[FreeBSD 8.3, 8.4, 9.1, 9.2-RELEASE and 8.4-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch.asc
# gpg --verify bind-release.patch.asc

[FreeBSD 9.2-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch.asc
# gpg --verify bind-stable-9.patch.asc

b) Execute the following commands as root:

# cd /usr/src
# patch &lt; /path/to/patch

Recompile the operating system using buildworld and installworld as
described in &lt;URL:https://www.FreeBSD.org/handbook/makeworld.html&gt;.

Restart the applicable daemons, or reboot the system.

3) To update your vulnerable system via a binary patch:

Systems running a RELEASE version of FreeBSD on the i386 or amd64
platforms can be updated via the freebsd-update(8) utility:

# freebsd-update fetch
# freebsd-update install

VI.  Correction details

The following list contains the correction revision numbers for each
affected branch.

Branch/path                                                      Revision
- -------------------------------------------------------------------------
stable/8/                                                         r260646
releng/8.3/                                                       r260647
releng/8.4/                                                       r260647
stable/9/                                                         r260646
releng/9.1/                                                       r260647
releng/9.2/                                                       r260647
- -------------------------------------------------------------------------

To see which files were modified by a particular revision, run the
following command, replacing NNNNNN with the revision number, on a
machine with Subversion installed:

# svn diff -cNNNNNN --summarize svn://svn.freebsd.org/base

Or visit the following URL, replacing NNNNNN with the revision number:

&lt;URL:https://svnweb.freebsd.org/base?view=revision&amp;revision=NNNNNN&gt;

VII. References

&lt;URL:https://kb.isc.org/article/AA-01078&gt;

&lt;URL:http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0591&gt;

The latest revision of this advisory is available at
&lt;URL:http://security.FreeBSD.org/advisories/FreeBSD-SA-14:04.bind.asc&gt;
-----BEGIN PGP SIGNATURE-----

iQIcBAEBCgAGBQJS1ZTYAAoJEO1n7NZdz2rnOvQP/2/68/s9Cu35PmqNtSZVVxVG
ZSQP5EGWx/lramNf9566iKxOrLRMq/h3XWcC4goVd+gZFrvITJSVOWSa7ntDQ7TO
XcinfRZ/iyiJbs/Rg2wLHc/t5oVSyeouyccqODYFbOwOlk35JjOTMUG1YcX+Zasg
ax8RV+7Zt1QSBkMlOz/myBLXUjlTZ3Xg2FXVsfFQW5/g2CjuHpRSFx1bVNX6ysoG
9DT58EQcYxIS8WfkHRbbXKh9I1nSfZ7/Hky/kTafRdRMrjAgbqFgHkYTYsBZeav5
fYWKGQRJulYfeZQ90yMTvlpF42DjCC3uJYamJnwDIu8OhS1WRBI8fQfr9DRzmRua
OK3BK9hUiScDZOJB6OqeVzUTfe7MAA4/UwrDtTYQ+PqAenv1PK8DZqwXyxA9ThHb
zKO3OwuKOVHJnKvpOcr+eNwo7jbnHlis0oBksj/mrq2P9m2ueF9gzCiq5Ri5Syag
Wssb1HUoMGwqU0roS8+pRpNC8YgsWpsttvUWSZ8u6Vj/FLeHpiV3mYXPVMaKRhVm
067BA2uj4Th1JKtGleox+Em0R7OFbCc/9aWC67wiqI6KRyit9pYiF3npph+7D5Eq
7zPsUdDd+qc+UTiLp3liCRp5w6484wWdhZO6wRtmUgxGjNkxFoNnX8CitzF8AaqO
UWWemqWuz3lAZuORQ9KX
=OQzQ
-----END PGP SIGNATURE-----</pre></div></div><div class=paragraph><p>Every security advisory uses the following format:</p></div><div class=ulist><ul><li><p>Each security advisory is signed by the PGP key of the Security Officer. The public key for the Security Officer can be verified at <a href=./#pgpkeys>OpenPGP 金鑰</a>.</p></li><li><p>The name of the security advisory always begins with <code>FreeBSD-SA-</code> (for FreeBSD Security Advisory), followed by the year in two digit format (<code>14:</code>), followed by the advisory number for that year (<code>04.</code>), followed by the name of the affected application or subsystem (<code>bind</code>). The advisory shown here is the fourth advisory for 2014 and it affects BIND.</p></li><li><p>The <code>Topic</code> field summarizes the vulnerability.</p></li><li><p>The <code>Category</code> refers to the affected part of the system which may be one of <code>core</code>, <code>contrib</code>, or <code>ports</code>. The <code>core</code> category means that the vulnerability affects a core component of the FreeBSD operating system. The <code>contrib</code> category means that the vulnerability affects software included with FreeBSD, such as BIND. The <code>ports</code> category indicates that the vulnerability affects software available through the Ports Collection.</p></li><li><p>The <code>Module</code> field refers to the component location. In this example, the <code>bind</code> module is affected; therefore, this vulnerability affects an application installed with the operating system.</p></li><li><p>The <code>Announced</code> field reflects the date the security advisory was published. This means that the security team has verified that the problem exists and that a patch has been committed to the FreeBSD source code repository.</p></li><li><p>The <code>Credits</code> field gives credit to the individual or organization who noticed the vulnerability and reported it.</p></li><li><p>The <code>Affects</code> field explains which releases of FreeBSD are affected by this vulnerability.</p></li><li><p>The <code>Corrected</code> field indicates the date, time, time offset, and releases that were corrected. The section in parentheses shows each branch for which the fix has been merged, and the version number of the corresponding release from that branch. The release identifier itself includes the version number and, if appropriate, the patch level. The patch level is the letter <code>p</code> followed by a number, indicating the sequence number of the patch, allowing users to track which patches have already been applied to the system.</p></li><li><p>The <code>CVE Name</code> field lists the advisory number, if one exists, in the public <a href=http://cve.mitre.org>cve.mitre.org</a> security vulnerabilities database.</p></li><li><p>The <code>Background</code> field provides a description of the affected module.</p></li><li><p>The <code>Problem Description</code> field explains the vulnerability. This can include information about the flawed code and how the utility could be maliciously used.</p></li><li><p>The <code>Impact</code> field describes what type of impact the problem could have on a system.</p></li><li><p>The <code>Workaround</code> field indicates if a workaround is available to system administrators who cannot immediately patch the system .</p></li><li><p>The <code>Solution</code> field provides the instructions for patching the affected system. This is a step by step tested and verified method for getting a system patched and working securely.</p></li><li><p>The <code>Correction Details</code> field displays each affected Subversion branch with the revision number that contains the corrected code.</p></li><li><p>The <code>References</code> field offers sources of additional information regarding the vulnerability.</p></li></ul></div></div></div><div class=sect2><h3 id=security-accounting>13.12. 程序追蹤<a class=anchor href=#security-accounting></a></h3><div class=paragraph><p>Process accounting is a security method in which an administrator may keep track of system resources used and their allocation among users, provide for system monitoring, and minimally track a user’s commands.</p></div><div class=paragraph><p>Process accounting has both positive and negative points. One of the positives is that an intrusion may be narrowed down to the point of entry. A negative is the amount of logs generated by process accounting, and the disk space they may require. This section walks an administrator through the basics of process accounting.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If more fine-grained accounting is needed, refer to <a href=./#audit>安全事件稽查</a>.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_開啟並使用程序追蹤>13.12.1. 開啟並使用程序追蹤<a class=anchor href=#_開啟並使用程序追蹤></a></h4><div class=paragraph><p>Before using process accounting, it must be enabled using the following commands:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc accounting_enable=yes</span>
<span class=c># service accounting start</span></code></pre></div></div><div class=paragraph><p>The accounting information is stored in files located in <span class=filename>/var/account</span>, which is automatically created, if necessary, the first time the accounting service starts. These files contain sensitive information, including all the commands issued by all users. Write access to the files is limited to <code>root</code>, and read access is limited to <code>root</code> and members of the <code>wheel</code> group. To also prevent members of <code>wheel</code> from reading the files, change the mode of the <span class=filename>/var/account</span> directory to allow access only by <code>root</code>.</p></div><div class=paragraph><p>Once enabled, accounting will begin to track information such as CPU statistics and executed commands. All accounting logs are in a non-human readable format which can be viewed using <code>sa</code>. If issued without any options, <code>sa</code> prints information relating to the number of per-user calls, the total elapsed time in minutes, total CPU and user time in minutes, and the average number of I/O operations. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> for the list of available options which control the output.</p></div><div class=paragraph><p>To display the commands issued by users, use <code>lastcomm</code>. For example, this command prints out all usage of <code>ls</code> by <code>trhodes</code> on the <code>ttyp1</code> terminal:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lastcomm ls trhodes ttyp1</span></code></pre></div></div><div class=paragraph><p>Many other useful options exist and are explained in <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>.</p></div></div></div><div class=sect2><h3 id=security-resourcelimits>13.13. 限制資源<a class=anchor href=#security-resourcelimits></a></h3><div class=paragraph><p>FreeBSD provides several methods for an administrator to limit the amount of system resources an individual may use. Disk quotas limit the amount of disk space available to users. Quotas are discussed in <a href=./#quotas>磁碟配額</a>.</p></div><div class=paragraph><p>Limits to other resources, such as CPU and memory, can be set using either a flat file or a command to configure a resource limits database. The traditional method defines login classes by editing <span class=filename>/etc/login.conf</span>. While this method is still supported, any changes require a multi-step process of editing this file, rebuilding the resource database, making necessary changes to <span class=filename>/etc/master.passwd</span>, and rebuilding the password database. This can become time consuming, depending upon the number of users to configure.</p></div><div class=paragraph><p><code>rctl</code> can be used to provide a more fine-grained method for controlling resource limits. This command supports more than user limits as it can also be used to set resource constraints on processes and jails.</p></div><div class=paragraph><p>This section demonstrates both methods for controlling resources, beginning with the traditional method.</p></div><div class=sect3><h4 id=users-limiting>13.13.1. 設定登入類別<a class=anchor href=#users-limiting></a></h4><div class=paragraph><p>In the traditional method, login classes and the resource limits to apply to a login class are defined in <span class=filename>/etc/login.conf</span>. Each user account can be assigned to a login class, where <code>default</code> is the default login class. Each login class has a set of login capabilities associated with it. A login capability is a <code><em>name</em>=<em>value</em></code> pair, where <em>name</em> is a well-known identifier and <em>value</em> is an arbitrary string which is processed accordingly depending on the <em>name</em>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Whenever <span class=filename>/etc/login.conf</span> is edited, the <span class=filename>/etc/login.conf.db</span> must be updated by executing the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Resource limits differ from the default login capabilities in two ways. First, for every limit, there is a <em>soft</em> and <em>hard</em> limit. A soft limit may be adjusted by the user or application, but may not be set higher than the hard limit. The hard limit may be lowered by the user, but can only be raised by the superuser. Second, most resource limits apply per process to a specific user.</p></div><div class=paragraph><p><a href=#resource-limits>登入類別限制資源類型</a> lists the most commonly used resource limits. All of the available resource limits and capabilities are described in detail in <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.</p></div><table id=resource-limits class="tableblock frame-none grid-all stretch"><caption class=title>表 11. 登入類別限制資源類型</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">限制資源</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>coredumpsize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The limit on the size of a core file generated by a program is subordinate to other limits on disk usage, such as <code>filesize</code> or disk quotas. This limit is often used as a less severe method of controlling disk space consumption. Since users do not generate core files and often do not delete them, this setting may save them from running out of disk space should a large program crash.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cputime</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The maximum amount of CPU time a user’s process may consume. Offending processes will be killed by the kernel. This is a limit on CPU <em>time</em> consumed, not the percentage of the CPU as displayed in some of the fields generated by <code>top</code> and <code>ps</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>filesize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The maximum size of a file the user may own. Unlike disk quotas (<a href=./#quotas>磁碟配額</a>), this limit is enforced on individual files, not the set of all files a user owns.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>maxproc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The maximum number of foreground and background processes a user can run. This limit may not be larger than the system limit specified by <code>kern.maxproc</code>. Setting this limit too small may hinder a user’s productivity as some tasks, such as compiling a large program, start lots of processes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>memorylocked</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The maximum amount of memory a process may request to be locked into main memory using <a href="https://man.freebsd.org/cgi/man.cgi?query=mlock&amp;sektion=2&amp;format=html">mlock(2)</a>. Some system-critical programs, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a>, lock into main memory so that if the system begins to swap, they do not contribute to disk thrashing.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>memoryuse</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The maximum amount of memory a process may consume at any given time. It includes both core memory and swap usage. This is not a catch-all limit for restricting memory consumption, but is a good start.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>openfiles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The maximum number of files a process may have open. In FreeBSD, files are used to represent sockets and IPC channels, so be careful not to set this too low. The system-wide limit for this is defined by <code>kern.maxfiles</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>sbsize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The limit on the amount of network memory a user may consume. This can be generally used to limit network communications.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>stacksize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The maximum size of a process stack. This alone is not sufficient to limit the amount of memory a program may use, so it should be used in conjunction with other limits.</p></td></tr></tbody></table><div class=paragraph><p>There are a few other things to remember when setting resource limits:</p></div><div class=ulist><ul><li><p>Processes started at system startup by <span class=filename>/etc/rc</span> are assigned to the <code>daemon</code> login class.</p></li><li><p>Although the default <span class=filename>/etc/login.conf</span> is a good source of reasonable values for most limits, they may not be appropriate for every system. Setting a limit too high may open the system up to abuse, while setting it too low may put a strain on productivity.</p></li><li><p>Xorg takes a lot of resources and encourages users to run more programs simultaneously.</p></li><li><p>Many limits apply to individual processes, not the user as a whole. For example, setting <code>openfiles</code> to <code>50</code> means that each process the user runs may open up to <code>50</code> files. The total amount of files a user may open is the value of <code>openfiles</code> multiplied by the value of <code>maxproc</code>. This also applies to memory consumption.</p></li></ul></div><div class=paragraph><p>For further information on resource limits and login classes and capabilities in general, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=cap_mkdb&amp;sektion=1&amp;format=html">cap_mkdb(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getrlimit&amp;sektion=2&amp;format=html">getrlimit(2)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.</p></div></div><div class=sect3><h4 id=_開啟並設定資源限制>13.13.2. 開啟並設定資源限制<a class=anchor href=#_開啟並設定資源限制></a></h4><div class=paragraph><p>The <code>kern.racct.enable</code> tunable must be set to a non-zero value. Custom kernels require specific configuration:</p></div><div class="literalblock programlisting"><div class=content><pre>options         RACCT
options         RCTL</pre></div></div><div class=paragraph><p>Once the system has rebooted into the new kernel, <code>rctl</code> may be used to set rules for the system.</p></div><div class=paragraph><p>Rule syntax is controlled through the use of a subject, subject-id, resource, and action, as seen in this example rule:</p></div><div class="literalblock programlisting"><div class=content><pre>user:trhodes:maxproc:deny=10/user</pre></div></div><div class=paragraph><p>In this rule, the subject is <code>user</code>, the subject-id is <code>trhodes</code>, the resource, <code>maxproc</code>, is the maximum number of processes, and the action is <code>deny</code>, which blocks any new processes from being created. This means that the user, <code>trhodes</code>, will be constrained to no greater than <code>10</code> processes. Other possible actions include logging to the console, passing a notification to <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>, or sending a sigterm to the process.</p></div><div class=paragraph><p>Some care must be taken when adding rules. Since this user is constrained to <code>10</code> processes, this example will prevent the user from performing other tasks after logging in and executing a <code>screen</code> session. Once a resource limit has been hit, an error will be printed, as in this example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>test</span>
    /usr/bin/man: Cannot fork: Resource temporarily unavailable
<span class=nb>eval</span>: Cannot fork: Resource temporarily unavailable</code></pre></div></div><div class=paragraph><p>As another example, a jail can be prevented from exceeding a memory limit. This rule could be written as:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -a jail:httpd:memoryuse:deny=2G/jail</span></code></pre></div></div><div class=paragraph><p>Rules will persist across reboots if they have been added to <span class=filename>/etc/rctl.conf</span>. The format is a rule, without the preceding command. For example, the previous rule could be added as:</p></div><div class="literalblock programlisting"><div class=content><pre># Block jail from using more than 2G memory:
jail:httpd:memoryuse:deny=2G/jail</pre></div></div><div class=paragraph><p>To remove a rule, use <code>rctl</code> to remove it from the list:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -r user:trhodes:maxproc:deny=10/user</span></code></pre></div></div><div class=paragraph><p>A method for removing all rules is documented in <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a>. However, if removing all rules for a single user is required, this command may be issued:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -r user:trhodes</span></code></pre></div></div><div class=paragraph><p>Many other resources exist which can be used to exert additional control over various <code>subjects</code>. See <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> to learn about them.</p></div></div></div><div class=sect2><h3 id=security-sudo>13.14. 使用 Sudo 分享管理權限<a class=anchor href=#security-sudo></a></h3><div class=paragraph><p>系統管理者通常會要能夠授予額外的權限給其他使用者，以讓這些使用者可以執行需權限的工作。要讓團隊成員可以存取 FreeBSD 系統來完成其特定的工作對所有管理者都會帶來挑戰，這些團隊成員通常只需要比一般使用者多出一些存取權限便可作業，但他們總是會告訴管理者若沒有超級使用者的存取權便無法完成其工作。幸好，有工具可以管理這類的需求，這樣便不需提供這麼大的權限給一般使用者。</p></div><div class=paragraph><p>到目前為止，安全性章節已說明了如何允許已授權的使用者存取以及嘗試防止未經授權的存取，而現在有另一個問題，是由已授權的使用者擁有權限存取系統資源造成的。在很多的情況，使用者會需要存取應用程式啟動 Script 的權限或是管理者團隊需要維護系統，以往會使用標準的使用者與群組、檔案權限、甚至是 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 指令來管理存取權，但當應用程式需要更多存取權，更多使用者需要使用系統資源時，便需要更好的解決方案，目前最常用來解決此問題的應用程式便是 Sudo。</p></div><div class=paragraph><p>Sudo 讓管理者可以對系統指令的存取設下更嚴格的限制並提供進階的記錄功能。如同其他工具，它可自 Port 套件集取得，於其中的 <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a>，或使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 工具取得，若要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 工具可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install sudo</span></code></pre></div></div><div class=paragraph><p>安裝完成之後，可用安裝的 <code>visudo</code> 以文字編輯器開啟設定檔，強烈建議使用 <code>visudo</code> 來編輯設定檔，由於它有內建的語法檢查程式可在檔案儲存之前檢驗是否有誤。</p></div><div class=paragraph><p>設定檔由個小節所組成，透過這些小節可做常廣泛的設定，在以下的範例中，網站應用程式維護人員 user1 需要啟動、停止與重新啟動名稱為 <em>webservice</em> 的網站應用程式 。要授權此使用者執行這些工作的權限，可加入此行到 <span class=filename>/usr/local/etc/sudoers</span> 的最後：</p></div><div class="literalblock programlisting"><div class=content><pre>user1   ALL=(ALL)       /usr/sbin/service webservice *</pre></div></div><div class=paragraph><p>現在使用者可使用此指令來啟動 <em>webservice</em>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sudo</span> /usr/sbin/service webservice start</code></pre></div></div><div class=paragraph><p>雖然這項設定可以讓一位使用者存取 webservice 服務，但在大部份組織中會有一整個網站小組負責管理該服務，因此也可以一行來授予整個群組存取權，以下步驟會建立一個網站群組、加入使用者到這個群組，然後讓該群組中的所有成員能夠管理服務：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd -g 6001 -n webteam</span></code></pre></div></div><div class=paragraph><p>同樣使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 指令來加入該使用到 webteam 群組：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod -m user1 -n webteam</span></code></pre></div></div><div class=paragraph><p>最後，在 <span class=filename>/usr/local/etc/sudoers</span> 中的這行設定可以讓 webteam 群組的所有成員可以管理 <em>webservice</em>：</p></div><div class="literalblock programlisting"><div class=content><pre>%webteam   ALL=(ALL)       /usr/sbin/service webservice *</pre></div></div><div class=paragraph><p>與 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 不同的是 Sudo 只需要一般使用者的密碼，這有一個使用者不需要共用密碼的優點，在大多數安全稽查都會發現共用密碼的問題且這種情況只有壞處可言。</p></div><div class=paragraph><p>使用 Sudo 允許使用者執行應用程式只需要輸入使用者自己的密碼，這更安全且提供比 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 更佳的控制權，因為 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 只要輸入 <code>root</code> 密碼之後該使用者便可取得所有的 <code>root</code> 權限。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>大多數組織已正在導入或已導入雙重認証 (Two factor authentication)，在這個情境下使用者可以不用輸入密碼，Sudo 提供了 <code>NOPASSWD</code> 變數來供這個情境使用，可將該設定加入到上述的設定將可允許所有 <em>webteam</em> 群組的成員不需要輸入密碼便可管理該服務：</p></div><div class="literalblock programlisting"><div class=content><pre>%webteam   ALL=(ALL)       NOPASSWD: /usr/sbin/service webservice *</pre></div></div></td></tr></tbody></table></div><div class=sect3><h4 id=security-sudo-loggin>13.14.1. 記錄輸出<a class=anchor href=#security-sudo-loggin></a></h4><div class=paragraph><p>採用 Sudo 的另一個優點是能夠開啟連線階段的記錄。使用內建立記錄機制與內含的 sudoreplay 指令，所有透過 Sudo 初始化的指令會被記錄下來供往後檢驗用。要開啟這個功能要加入預設記錄目錄的項目，在以下範例中使用了使用者變數來做目錄名稱，也還有許多其他記錄檔名稱慣例，可參考 sudoreplay 的操作手冊來取得進一步資訊。</p></div><div class="literalblock programlisting"><div class=content><pre>Defaults iolog_dir=/var/log/sudo-io/%{user}</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>這個目錄會在記錄功能設定之後自動建立，最好讓系統以預設的權限來建立目錄比較保險，除此之外，這個設定項目也會記錄使用 sudoreplay 指令的管理者，要更改設定請閱讀並取消在 <span class=filename>sudoers</span> 中記錄選項的註解。</p></div></td></tr></tbody></table></div><div class=paragraph><p>一旦這個設定加入至 <span class=filename>sudoers</span> 檔案之後，所有的使用者設定項目便可加上記錄存取動作的項目，在 <em>webteam</em> 項目加入額外設定之後的範例如下：</p></div><div class="literalblock programlisting"><div class=content><pre>%webteam ALL=(ALL) NOPASSWD: LOG_INPUT: LOG_OUTPUT: /usr/sbin/service webservice *</pre></div></div><div class=paragraph><p>從此之後，所有 <em>webteam</em> 修改 <em>webservice</em> 應用程式狀態的成員將會被記錄下來。要列出先前與目前連線階段的記錄可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sudoreplay -l</span></code></pre></div></div><div class=paragraph><p>在輸出結果中要重播指定連線階段的記錄可搜尋 <code>TSID=</code> 項目，然後傳送給 sudoreplay 且不加其他選項便可以一般速度重播連線階段，例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sudoreplay user1/00/00/02</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>雖然所有連線階段都會被記錄，但任何管理者都可以移除連線階段，使得沒人知道它們做了什麼事，所以非常值得在入侵偵測系統 (IDS) 或類似的軟體加入每日檢查，以便在有人為修改時通知其他管理人員。</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>sudoreplay</code> 的擴充空間非常大，請參考說明文件來取得更多資訊。</p></div></div></div></div></div><div class=sect1><h2 id=jails>Chapter 14. Jail<a class=anchor href=#jails></a></h2><div class=sectionbody><div class=sect2><h3 id=jails-synopsis>14.1. 概述<a class=anchor href=#jails-synopsis></a></h3><div class=paragraph><p>由於系統管理是一項困難的工作，許多工具開發來讓系統管理者能夠更輕鬆。這些工具通常可以強化系統安裝、設定以及維護的方式。這些工具之可以用來強化 FreeBSD 系統的安全性之一的就是 <em>Jail</em>。Jail 早在 FreeBSD 4.X 便可使用並持續強化它的功能、效率、穩定性以及安全性。</p></div><div class=paragraph><p>Jail 建立在 <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> 概念之上，會更改一系列程序的根目錄。這可以創造一個安全的環境，將程序與系統的其他部份分隔。在 chroot 的環境所建立的程序不能存取該環境以外的檔案或資源。也因此，滲透一個在 chroot 的環境執行的服務並不會讓整個系統被攻擊者滲透。但 chroot 有許多限制，只適合用在簡單的工作，不需要許多彈性或複雜性、進階功能的工作。隨著時間推移，許多可以逃離 chroot 的環境的方法已經被找到，讓這個方法不再是確保服務安全的理想方案。</p></div><div class=paragraph><p>Jail 用許多方式改進了傳統 chroot 環境的概念。在傳統 chroot 環境，程序僅限制在一部份檔案系統可存取的地方。其餘的系統資源、系統使用者、執行的程序以及網路子系統被 chroot 的程序及主機系統的程序所共享。Jail 透過虛擬化存取檔案系統、使用者及網路子系統來擴展這個模型，可使用更多細微的控制參數來調校 Jail 的環境存取方式，Jail 可算是一種作業系統層級的虛擬化。</p></div><div class=paragraph><p>Jail 的四個要素：</p></div><div class=ulist><ul><li><p>一個子樹狀目錄：進入 Jail 的起點目錄，一但在 Jail 中，程序便沒有權限離開此目錄之外。</p></li><li><p>一個主機名稱：將會由 Jail 所使用。</p></li><li><p>一個 IP 位址：用來分配給 Jail。Jail 的 IP 位址通常是現有網路介面的別名位址。</p></li><li><p>一個指令：要在 Jail 中可執行的執行檔路徑名稱。該路徑是 Jail 環境根目錄的相對路徑。</p></li></ul></div><div class=paragraph><p>Jail 有自己使用者及自己的 <code>root</code> 帳號，皆受到 Jail 環境的限制。Jail 中的 <code>root</code> 帳號不允許對指定 Jail 環境之外的系統執行操作。</p></div><div class=paragraph><p>本章將提供 FreeBSD Jail 術語及管理指令的概述，Jail 對系統管理者及進階的使用者來二者來說皆是強大的工具。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>Jail 是什麼及它在 FreeBSD 中提供的目的。</p></li><li><p>如何建立、啟動及停止 Jail。</p></li><li><p>Jail 管理基礎，不論從內部或外部。</p></li></ul></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Jail 是強大的工具，但它不是安全性問題的萬靈丹。雖然 Jail 的程序不可能自己獨自打破規則，但有許多方法可以讓在 Jail 之外無權限的使用者與在 Jail 之內有權限的使用者串通來取得主機環境的更高權限。</p></div><div class=paragraph><p>大多數這類型的攻擊者可以由確保 Jail 根目錄不會被無權限使用者存取來減少。基本上，不受信任的使用者有 Jail 的存取權限並不會讓其可存取主機環境。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=jails-terms>14.2. Jail 相關術語<a class=anchor href=#jails-terms></a></h3><div class=paragraph><p>為協助更容易理解 FreeBSD 系統有關 Jail 部份， 以及它們與 FreeBSD 其他部分的相互作用關係， 以下列出本章將使用的術語：</p></div><div class=dlist><dl><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> (指令)</dt><dd><p>工具，用來使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> FreeBSD 系統呼叫 (System call) 來更改程予及其衍伸程序的根目錄。</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> (環境)</dt><dd><p>指程序在 "chroot" 中執行的環境。包含的資源如：一部份可見的檔案系統、可用的使用者及群組 ID、網路介面及其他 IPC 機制等。</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> (指令)</dt><dd><p>允許在 Jail 環境下執行程序的系統管理工具。</p></dd><dt class=hdlist1>主機 (系統、程序、使用者等)</dt><dd><p>Jail 環境的控制系統。 主機系統可以存取所有可用的硬體資源，並能控制 Jail 環境內外的程序。主機系統與 Jail 最大的差別在於：在主機系統中的超級使用者程序並不像在 Jail 環境那樣受到限制。</p></dd><dt class=hdlist1>託管 (主機、程序、使用者等)</dt><dd><p>存取資源受到 FreeBSD Jail 限制的託管程序、使用者或其他實體。</p></dd></dl></div></div><div class=sect2><h3 id=jails-build>14.3. 建立和控制 Jail<a class=anchor href=#jails-build></a></h3><div class=paragraph><p>部份管理者將 Jail 分成兩種類型："完整的" Jail，它像一個真正的 FreeBSD 系統以及 "服務的" Jail，專門用於某個應用程式或服務，可能使用管理權限執行。但這些只是概念上的區分，建立 Jail 的程序並不受這個概念的影響。當要建立一個 "完整的" Jail，Userland 有兩個來源選項：使用預先編譯的 Binary (如安裝媒體上提供的 Binary) 或從原始碼編譯。</p></div><div class=paragraph><p>要從安裝媒體安裝 Userland，需要先建立根目錄供 Jail 使用。這個動作可以透過設定 <code>DESTDIR</code> 來到適當的位置來完成。</p></div><div class=paragraph><p>啟動 Shell 並定義 <code>DESTDIR</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh</span>
<span class=c># export DESTDIR=/here/is/the/jail</span></code></pre></div></div><div class=paragraph><p>當使用安裝 ISO 時，可依 <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> 中的說明掛載安裝媒體：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/`mdconfig -f cdimage.iso` /mnt</span>
<span class=c># cd /mnt/usr/freebsd-dist/</span></code></pre></div></div><div class=paragraph><p>或者自鏡像站下載 Tarball 壓縮檔：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh</span>
<span class=c># export DESTRELEASE=12.0-RELEASE</span>
<span class=c># export DESTARCH=`uname -m`</span>
<span class=c># export SOURCEURL=http://ftp.freebsd.org/pub/FreeBSD/releases/$DESTARCH/$DESTRELEASE/</span>
<span class=c># for set in base ports; do fetch $SOURCEURL/$set.txz ; done</span></code></pre></div></div><div class=paragraph><p>從安裝媒體上的 Tarball 中取出 Binary 並放到宣告的位置，至少需要取出 Base set 的部份，若需要也可完整安裝。</p></div><div class=paragraph><p>只安裝基礎系統 (Base system)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar -xf base.txz -C $DESTDIR</span></code></pre></div></div><div class=paragraph><p>安裝全部不含核心：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for set in base ports; do tar -xf $set.txz -C $DESTDIR ; done</span></code></pre></div></div><div class=paragraph><p>依 <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 操作手冊說明的程序建置 Jail：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setenv D /here/is/the/jail</span>
<span class=c># mkdir -p $D      </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># cd /usr/src</span>
<span class=c># make buildworld  </span><i class=conum data-value=2></i><b>(2)</b>
<span class=c># make installworld DESTDIR=$D  </span><i class=conum data-value=3></i><b>(3)</b>
<span class=c># make distribution DESTDIR=$D  </span><i class=conum data-value=4></i><b>(4)</b>
<span class=c># mount -t devfs devfs $D/dev   </span><i class=conum data-value=5></i><b>(5)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>選擇 Jail 的位置是建置 Jail 最好的起點，這是在 Jail 主機上儲存 Jail 的實體位置。較好的選擇是 <span class=filename>/usr/jail/jailname</span>，其中 <em>jailname</em> 是用來辦識 Jail 的主機名稱。通常在 <span class=filename>/usr/</span> 會有足夠的空間供 Jail 檔案系統使用，對 "完整的" Jail 來說，便是複製 FreeBSD 基礎系統預設安裝的每一個檔案。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>若您已經使用 <code>make world</code> 或 <code>make buildworld</code> 重新編譯您的 Userland，您可以跳過這個步驟並安裝您已存在的 Userland 到新的 Jail。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>這個指令將會在檔案系統中 Jail 所在的實體位置產生樹狀目錄及必要的 Binary、程式庫、操作手冊與相關檔案。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>make 的 <code>distribution</code> 目標會安裝所有需要的設定檔。簡單來說，它會安裝所有 <span class=filename>/usr/src/etc/</span> 中可安裝的檔案到 Jail 環境的 <span class=filename>/etc</span>目錄：<span class=filename>$D/etc/</span>。</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>在 Jail 中掛載 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> 檔案系統並非必要的動作。從另一個角度來說，任何或大部份的應用程式會依該程式的目的會需要存取至少一個裝置，在 Jail 中控制存取的裝置非常重要，不恰當的設定可能會讓攻擊者可以在 Jail 中做不軌的事。對 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> 的控制是透過 Ruleset，在 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> 及 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.conf&amp;sektion=5&amp;format=html">devfs.conf(5)</a> 操作手冊中有詳細說明。</td></tr></tbody></table></div><div class=paragraph><p>Jail 安裝完成之後，便可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 工具來啟動。<a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 工具需要四個必要參數，在 <a href=#jails-synopsis>概述</a> 有說明。其他參數也可能需要指定，例如要使用特定使用者的身份來執行要 Jail 的程序。<code><em>command</em></code> 參數依 Jail 的類型所需而定，對一個 <em>虛擬系統</em> 來說，<span class=filename>/etc/rc</span> 是不錯的選擇，因為該檔案可以模仿真實 FreeBSD 的啟動順序。對於 <em>服務型</em> 的 Jail 來說，則看在 Jail 中要執行的服務或應用程式來決定。</p></div><div class=paragraph><p>Jail 通常會需要隨著開機執行，使用 FreeBSD <span class=filename>rc</span> 機制可讓以簡單的達成這件事。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>在 <span class=filename>jail.conf</span> 中設定 jail 參數：</p><div class="literalblock programlisting"><div class=content><pre>www {
    host.hostname = www.example.org;           # Hostname
    ip4.addr = 192.168.0.10;                   # IP address of the jail
    path =&#34;/usr/jail/www&#34;;                     # Path to the jail
    devfs_ruleset = &#34;www_ruleset&#34;;             # devfs ruleset
    mount.devfs;                               # Mount devfs inside the jail
    exec.start = &#34;/bin/sh /etc/rc&#34;;            # Start command
    exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;    # Stop command
}</pre></div></div><div class=paragraph><p>在 <span class=filename>rc.conf</span> 中設定開機時啟動 Jail：</p></div><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;   # Set to NO to disable starting of any jails</pre></div></div><div class=paragraph><p>預設要啟動的 Jail 可在 <a href="https://man.freebsd.org/cgi/man.cgi?query=jail.conf&amp;sektion=5&amp;format=html">jail.conf(5)</a> 設定，會把 Jail 當作是一個完全虛擬的系統，然後執行 Jail 中的 <span class=filename>/etc/rc</span> Script。針對服務型的 Jail 則需透過設定 <code>exec.start</code> 選項來適當更改 Jail 的預設啟動指令。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>要取得完整可用選項的清單，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=jail.conf&amp;sektion=5&amp;format=html">jail.conf(5)</a>操作手冊。</p></div></td></tr></tbody></table></div></li></ol></div></div></div><div class=paragraph><p>若 Jail 項目已經在 <span class=filename>jail.conf</span> 中設定好，可以手動用 <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> 來啟動或停止某個 Jail 項目：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service jail start www</span>
<span class=c># service jail stop www</span></code></pre></div></div><div class=paragraph><p>Jail 可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> 來關機。先使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> 來辦識 Jail 的 <code>JID</code>，然後使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> 在該 Jail 中執行關機 Script。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jls</span>
   JID  IP Address      Hostname                      Path
     3  192.168.0.10    www                           /usr/jail/www
<span class=c># jexec 3 /etc/rc.shutdown</span></code></pre></div></div><div class=paragraph><p>更多有關 Jail 的資訊可在 <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 操作手冊取得。</p></div></div><div class=sect2><h3 id=jails-tuning>14.4. 調校與管理<a class=anchor href=#jails-tuning></a></h3><div class=paragraph><p>還有許多選項可以對所有 Jail 做設定，以及各種可讓 Jail 與主機 FreeBSD 系統結合的方法來提供更高層級的應用程式使用。 本節將介紹：</p></div><div class=ulist><ul><li><p>Some of the options available for tuning the behavior and security restrictions implemented by a jail installation.</p></li><li><p>Some of the high-level applications for jail management, which are available through the FreeBSD Ports Collection, and can be used to implement overall jail-based solutions.</p></li></ul></div><div class=sect3><h4 id=jails-tuning-utilities>14.4.1. 在 FreeBSD 中調校 Jail 的系統工具<a class=anchor href=#jails-tuning-utilities></a></h4><div class=paragraph><p>Fine tuning of a jail’s configuration is mostly done by setting <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variables. A special subtree of sysctl exists as a basis for organizing all the relevant options: the <code>security.jail.*</code> hierarchy of FreeBSD kernel options. Here is a list of the main jail-related sysctls, complete with their default value. Names should be self-explanatory, but for more information about them, please refer to the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> manual pages.</p></div><div class=ulist><ul><li><p><code>security.jail.set_hostname_allowed: 1</code></p></li><li><p><code>security.jail.socket_unixiproute_only: 1</code></p></li><li><p><code>security.jail.sysvipc_allowed: 0</code></p></li><li><p><code>security.jail.enforce_statfs: 2</code></p></li><li><p><code>security.jail.allow_raw_sockets: 0</code></p></li><li><p><code>security.jail.chflags_allowed: 0</code></p></li><li><p><code>security.jail.jailed: 0</code></p></li></ul></div><div class=paragraph><p>These variables can be used by the system administrator of the <em>host system</em> to add or remove some of the limitations imposed by default on the <code>root</code> user. Note that there are some limitations which cannot be removed. The <code>root</code> user is not allowed to mount or unmount file systems from within a <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. The <code>root</code> inside a jail may not load or unload <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> rulesets, set firewall rules, or do many other administrative tasks which require modifications of in-kernel data, such as setting the <code>securelevel</code> of the kernel.</p></div><div class=paragraph><p>The base system of FreeBSD contains a basic set of tools for viewing information about the active jails, and attaching to a jail to run administrative commands. The <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> commands are part of the base FreeBSD system, and can be used to perform the following simple tasks:</p></div><div class=ulist><ul><li><p>Print a list of active jails and their corresponding jail identifier (JID), IP address, hostname and path.</p></li><li><p>Attach to a running jail, from its host system, and run a command inside the jail or perform administrative tasks inside the jail itself. This is especially useful when the <code>root</code> user wants to cleanly shut down a jail. The <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> utility can also be used to start a shell in a jail to do administration in it; for example:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 1 tcsh</span></code></pre></div></div></li></ul></div></div><div class=sect3><h4 id=jails-tuning-admintools>14.4.2. 在 FreeBSD Port 套件集中的高層級管理工具<a class=anchor href=#jails-tuning-admintools></a></h4><div class=paragraph><p>Among the many third-party utilities for jail administration, one of the most complete and useful is <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/ezjail/>sysutils/ezjail</a>. It is a set of scripts that contribute to <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> management. Please refer to <a href=https://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/jails-ezjail.html>the handbook section on ezjail</a> for more information.</p></div></div><div class=sect3><h4 id=jails-updating>14.4.3. 持續 Jail 的修補與更新<a class=anchor href=#jails-updating></a></h4><div class=paragraph><p>Jails should be kept up to date from the host operating system as attempting to patch userland from within the jail may likely fail as the default behavior in FreeBSD is to disallow the use of <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> in a jail which prevents the replacement of some files. It is possible to change this behavior but it is recommended to use <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> to maintain jails instead. Use <code>-b</code> to specify the path of the jail to be updated.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -b /here/is/the/jail fetch</span>
<span class=c># freebsd-update -b /here/is/the/jail install</span></code></pre></div></div></div></div><div class=sect2><h3 id=jails-application>14.5. 更新多個 Jail<a class=anchor href=#jails-application></a></h3><div class=paragraph><p>The management of multiple jails can become problematic because every jail has to be rebuilt from scratch whenever it is upgraded. This can be time consuming and tedious if a lot of jails are created and manually updated.</p></div><div class=paragraph><p>This section demonstrates one method to resolve this issue by safely sharing as much as is possible between jails using read-only <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nullfs&amp;sektion=8&amp;format=html">mount_nullfs(8)</a> mounts, so that updating is simpler. This makes it more attractive to put single services, such as HTTP, DNS, and SMTP, into individual jails. Additionally, it provides a simple way to add, remove, and upgrade jails.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Simpler solutions exist, such as ezjail, which provides an easier method of administering FreeBSD jails but is less versatile than this setup. ezjail is covered in more detail in <a href=#jails-ezjail>使用 ezjail 管理 Jail</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The goals of the setup described in this section are:</p></div><div class=ulist><ul><li><p>Create a simple and easy to understand jail structure that does not require running a full installworld on each and every jail.</p></li><li><p>Make it easy to add new jails or remove existing ones.</p></li><li><p>Make it easy to update or upgrade existing jails.</p></li><li><p>Make it possible to run a customized FreeBSD branch.</p></li><li><p>Be paranoid about security, reducing as much as possible the possibility of compromise.</p></li><li><p>Save space and inodes, as much as possible.</p></li></ul></div><div class=paragraph><p>This design relies on a single, read-only master template which is mounted into each jail and one read-write device per jail. A device can be a separate physical disc, a partition, or a vnode backed memory device. This example uses read-write nullfs mounts.</p></div><div class=paragraph><p>The file system layout is as follows:</p></div><div class=ulist><ul><li><p>The jails are based under the <span class=filename>/home</span> partition.</p></li><li><p>Each jail will be mounted under the <span class=filename>/home/j</span> directory.</p></li><li><p>The template for each jail and the read-only partition for all of the jails is <span class=filename>/home/j/mroot</span>.</p></li><li><p>A blank directory will be created for each jail under the <span class=filename>/home/j</span> directory.</p></li><li><p>Each jail will have a <span class=filename>/s</span> directory that will be linked to the read-write portion of the system.</p></li><li><p>Each jail will have its own read-write system that is based upon <span class=filename>/home/j/skel</span>.</p></li><li><p>The read-write portion of each jail will be created in <span class=filename>/home/js</span>.</p></li></ul></div><div class=sect3><h4 id=jails-service-jails-template>14.5.1. 建立範本<a class=anchor href=#jails-service-jails-template></a></h4><div class=paragraph><p>This section describes the steps needed to create the master template.</p></div><div class=paragraph><p>It is recommended to first update the host FreeBSD system to the latest -RELEASE branch using the instructions in <a href=./#makeworld>從原始碼更新 FreeBSD</a>. Additionally, this template uses the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cpdup/>sysutils/cpdup</a> package or port and portsnap will be used to download the FreeBSD Ports Collection.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>First, create a directory structure for the read-only file system which will contain the FreeBSD binaries for the jails. Then, change directory to the FreeBSD source tree and install the read-only file system to the jail template:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j /home/j/mroot</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld DESTDIR=/home/j/mroot</span></code></pre></div></div></li><li><p>Next, prepare a FreeBSD Ports Collection for the jails as well as a FreeBSD source tree, which is required for mergemaster:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j/mroot</span>
<span class=c># mkdir usr/ports</span>
<span class=c># portsnap -p /home/j/mroot/usr/ports fetch extract</span>
<span class=c># cpdup /usr/src /home/j/mroot/usr/src</span></code></pre></div></div></li><li><p>Create a skeleton for the read-write portion of the system:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/skel /home/j/skel/home /home/j/skel/usr-X11R6 /home/j/skel/distfiles</span>
<span class=c># mv etc /home/j/skel</span>
<span class=c># mv usr/local /home/j/skel/usr-local</span>
<span class=c># mv tmp /home/j/skel</span>
<span class=c># mv var /home/j/skel</span>
<span class=c># mv root /home/j/skel</span></code></pre></div></div></li><li><p>Use mergemaster to install missing configuration files. Then, remove the extra directories that mergemaster creates:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -t /home/j/skel/var/tmp/temproot -D /home/j/skel -i</span>
<span class=c># cd /home/j/skel</span>
<span class=c># rm -R bin boot lib libexec mnt proc rescue sbin sys usr dev</span></code></pre></div></div></li><li><p>Now, symlink the read-write file system to the read-only file system. Ensure that the symlinks are created in the correct <span class=filename>s/</span> locations as the creation of directories in the wrong locations will cause the installation to fail.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j/mroot</span>
<span class=c># mkdir s</span>
<span class=c># ln -s s/etc etc</span>
<span class=c># ln -s s/home home</span>
<span class=c># ln -s s/root root</span>
<span class=c># ln -s ../s/usr-local usr/local</span>
<span class=c># ln -s ../s/usr-X11R6 usr/X11R6</span>
<span class=c># ln -s ../../s/distfiles usr/ports/distfiles</span>
<span class=c># ln -s s/tmp tmp</span>
<span class=c># ln -s s/var var</span></code></pre></div></div></li><li><p>As a last step, create a generic <span class=filename>/home/j/skel/etc/make.conf</span> containing this line:</p><div class="literalblock programlisting"><div class=content><pre>WRKDIRPREFIX?=  /s/portbuild</pre></div></div><div class=paragraph><p>This makes it possible to compile FreeBSD ports inside each jail. Remember that the ports directory is part of the read-only system. The custom path for <code>WRKDIRPREFIX</code> allows builds to be done in the read-write portion of every jail.</p></div></li></ol></div></div></div></div><div class=sect3><h4 id=jails-service-jails-creating>14.5.2. 建立 Jail<a class=anchor href=#jails-service-jails-creating></a></h4><div class=paragraph><p>The jail template can now be used to setup and configure the jails in <span class=filename>/etc/rc.conf</span>. This example demonstrates the creation of 3 jails: <code>NS</code>, <code>MAIL</code> and <code>WWW</code>.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Add the following lines to <span class=filename>/etc/fstab</span>, so that the read-only template for the jails and the read-write space will be available in the respective jails:</p><div class="literalblock programlisting"><div class=content><pre>/home/j/mroot   /home/j/ns     nullfs  ro  0   0
/home/j/mroot   /home/j/mail   nullfs  ro  0   0
/home/j/mroot   /home/j/www    nullfs  ro  0   0
/home/js/ns     /home/j/ns/s   nullfs  rw  0   0
/home/js/mail   /home/j/mail/s nullfs  rw  0   0
/home/js/www    /home/j/www/s  nullfs  rw  0   0</pre></div></div><div class=paragraph><p>To prevent fsck from checking nullfs mounts during boot and dump from backing up the read-only nullfs mounts of the jails, the last two columns are both set to <code>0</code>.</p></div></li><li><p>Configure the jails in <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;
jail_set_hostname_allow=&#34;NO&#34;
jail_list=&#34;ns mail www&#34;
jail_ns_hostname=&#34;ns.example.org&#34;
jail_ns_ip=&#34;192.168.3.17&#34;
jail_ns_rootdir=&#34;/usr/home/j/ns&#34;
jail_ns_devfs_enable=&#34;YES&#34;
jail_mail_hostname=&#34;mail.example.org&#34;
jail_mail_ip=&#34;192.168.3.18&#34;
jail_mail_rootdir=&#34;/usr/home/j/mail&#34;
jail_mail_devfs_enable=&#34;YES&#34;
jail_www_hostname=&#34;www.example.org&#34;
jail_www_ip=&#34;62.123.43.14&#34;
jail_www_rootdir=&#34;/usr/home/j/www&#34;
jail_www_devfs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The <code>jail<em>name</em>rootdir</code> variable is set to <span class=filename>/usr/home</span> instead of <span class=filename>/home</span> because the physical path of <span class=filename>/home</span> on a default FreeBSD installation is <span class=filename>/usr/home</span>. The <code>jail<em>name</em>rootdir</code> variable must <em>not</em> be set to a path which includes a symbolic link, otherwise the jails will refuse to start.</p></div></li><li><p>Create the required mount points for the read-only file system of each jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/ns /home/j/mail /home/j/www</span></code></pre></div></div></li><li><p>Install the read-write template into each jail using <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cpdup/>sysutils/cpdup</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/js</span>
<span class=c># cpdup /home/j/skel /home/js/ns</span>
<span class=c># cpdup /home/j/skel /home/js/mail</span>
<span class=c># cpdup /home/j/skel /home/js/www</span></code></pre></div></div></li><li><p>In this phase, the jails are built and prepared to run. First, mount the required file systems for each jail, and then start them:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a</span>
<span class=c># service jail start</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>The jails should be running now. To check if they have started correctly, use <code>jls</code>. Its output should be similar to the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jls</span>
   JID  IP Address      Hostname                      Path
     3  192.168.3.17    ns.example.org                /home/j/ns
     2  192.168.3.18    mail.example.org              /home/j/mail
     1  62.123.43.14    www.example.org               /home/j/www</code></pre></div></div><div class=paragraph><p>At this point, it should be possible to log onto each jail, add new users, or configure daemons. The <code>JID</code> column indicates the jail identification number of each running jail. Use the following command to perform administrative tasks in the jail whose JID is <code>3</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 3 tcsh</span></code></pre></div></div></div><div class=sect3><h4 id=jails-service-jails-upgrading>14.5.3. 升級<a class=anchor href=#jails-service-jails-upgrading></a></h4><div class=paragraph><p>The design of this setup provides an easy way to upgrade existing jails while minimizing their downtime. Also, it provides a way to roll back to the older version should a problem occur.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>The first step is to upgrade the host system. Then, create a new temporary read-only template in <span class=filename>/home/j/mroot2</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/mroot2</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld DESTDIR=/home/j/mroot2</span>
<span class=c># cd /home/j/mroot2</span>
<span class=c># cpdup /usr/src usr/src</span>
<span class=c># mkdir s</span></code></pre></div></div><div class=paragraph><p>The <code>installworld</code> creates a few unnecessary directories, which should be removed:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags -R 0 var</span>
<span class=c># rm -R etc var root usr/local tmp</span></code></pre></div></div></li><li><p>Recreate the read-write symlinks for the master file system:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s s/etc etc</span>
<span class=c># ln -s s/root root</span>
<span class=c># ln -s s/home home</span>
<span class=c># ln -s ../s/usr-local usr/local</span>
<span class=c># ln -s ../s/usr-X11R6 usr/X11R6</span>
<span class=c># ln -s s/tmp tmp</span>
<span class=c># ln -s s/var var</span></code></pre></div></div></li><li><p>Next, stop the jails:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service jail stop</span></code></pre></div></div></li><li><p>Unmount the original file systems as the read-write systems are attached to the read-only system (<span class=filename>/s</span>):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /home/j/ns/s</span>
<span class=c># umount /home/j/ns</span>
<span class=c># umount /home/j/mail/s</span>
<span class=c># umount /home/j/mail</span>
<span class=c># umount /home/j/www/s</span>
<span class=c># umount /home/j/www</span></code></pre></div></div></li><li><p>Move the old read-only file system and replace it with the new one. This will serve as a backup and archive of the old read-only file system should something go wrong. The naming convention used here corresponds to when a new read-only file system has been created. Move the original FreeBSD Ports Collection over to the new file system to save some space and inodes:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j</span>
<span class=c># mv mroot mroot.20060601</span>
<span class=c># mv mroot2 mroot</span>
<span class=c># mv mroot.20060601/usr/ports mroot/usr</span></code></pre></div></div></li><li><p>At this point the new read-only template is ready, so the only remaining task is to remount the file systems and start the jails:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a</span>
<span class=c># service jail start</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Use <code>jls</code> to check if the jails started correctly. Run <code>mergemaster</code> in each jail to update the configuration files.</p></div></div></div><div class=sect2><h3 id=jails-ezjail>14.6. 使用 ezjail 管理 Jail<a class=anchor href=#jails-ezjail></a></h3><div class=paragraph><p>Creating and managing multiple jails can quickly become tedious and error-prone. Dirk Engling’s ezjail automates and greatly simplifies many jail tasks. A <em>basejail</em> is created as a template. Additional jails use <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nullfs&amp;sektion=8&amp;format=html">mount_nullfs(8)</a> to share many of the basejail directories without using additional disk space. Each additional jail takes only a few megabytes of disk space before applications are installed. Upgrading the copy of the userland in the basejail automatically upgrades all of the other jails.</p></div><div class=paragraph><p>Additional benefits and features are described in detail on the ezjail web site, <a href=https://erdgeist.org/arts/software/ezjail/ class=bare>https://erdgeist.org/arts/software/ezjail/</a>.</p></div><div class=sect3><h4 id=jails-ezjail-install>14.6.1. 安裝 ezjail<a class=anchor href=#jails-ezjail-install></a></h4><div class=paragraph><p>Installing ezjail consists of adding a loopback interface for use in jails, installing the port or package, and enabling the service.</p></div><div id=jails-ezjail-install-procedure class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>To keep jail loopback traffic off the host’s loopback network interface <code>lo0</code>, a second loopback interface is created by adding an entry to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;lo1&#34;</pre></div></div><div class=paragraph><p>The second loopback interface <code>lo1</code> will be created when the system starts. It can also be created manually without a restart:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif cloneup</span>
Created clone interfaces: lo1.</code></pre></div></div><div class=paragraph><p>Jails can be allowed to use aliases of this secondary loopback interface without interfering with the host.</p></div><div class=paragraph><p>Inside a jail, access to the loopback address <code>127.0.0.1</code> is redirected to the first IP address assigned to the jail. To make the jail loopback correspond with the new <code>lo1</code> interface, that interface must be specified first in the list of interfaces and IP addresses given when creating a new jail.</p></div><div class=paragraph><p>Give each jail a unique loopback address in the <code>127.0.0.0/8</code> netblock.</p></div></li><li><p>Install <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/ezjail/>sysutils/ezjail</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/ezjail</span>
<span class=c># make install clean</span></code></pre></div></div></li><li><p>Enable ezjail by adding this line to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>ezjail_enable=&#34;YES&#34;</pre></div></div></li><li><p>The service will automatically start on system boot. It can be started immediately for the current session:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ezjail start</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=jails-ezjail-initialsetup>14.6.2. 初始設定<a class=anchor href=#jails-ezjail-initialsetup></a></h4><div class=paragraph><p>With ezjail installed, the basejail directory structure can be created and populated. This step is only needed once on the jail host computer.</p></div><div class=paragraph><p>In both of these examples, <code>-p</code> causes the ports tree to be retrieved with <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> into the basejail. That single copy of the ports directory will be shared by all the jails. Using a separate copy of the ports directory for jails isolates them from the host. The ezjailFAQ explains in more detail: <a href=http://erdgeist.org/arts/software/ezjail/#FAQ class=bare>http://erdgeist.org/arts/software/ezjail/#FAQ</a>.</p></div><div id=jails-ezjail-initialsetup-procedure class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>To Populate the Jail with FreeBSD-RELEASE</p><div class=paragraph><p>For a basejail based on the FreeBSD RELEASE matching that of the host computer, use <code>install</code>. For example, on a host computer running FreeBSD 10-STABLE, the latest RELEASE version of FreeBSD -10 will be installed in the jail):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin install -p</span></code></pre></div></div></li><li><p>To Populate the Jail with <code>installworld</code></p><div class=paragraph><p>The basejail can be installed from binaries created by <code>buildworld</code> on the host with <code>ezjail-admin update</code>.</p></div><div class=paragraph><p>In this example, FreeBSD 10-STABLE has been built from source. The jail directories are created. Then <code>installworld</code> is executed, installing the host’s <span class=filename>/usr/obj</span> into the basejail.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -i -p</span></code></pre></div></div><div class=paragraph><p>The host’s <span class=filename>/usr/src</span> is used by default. A different source directory on the host can be specified with <code>-s</code> and a path, or set with <code>ezjail_sourcetree</code> in <span class=filename>/usr/local/etc/ezjail.conf</span>.</p></div></li></ol></div></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>The basejail’s ports tree is shared by other jails. However, downloaded distfiles are stored in the jail that downloaded them. By default, these files are stored in <span class=filename>/var/ports/distfiles</span> within each jail. <span class=filename>/var/ports</span> inside each jail is also used as a work directory when building ports.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>The FTP protocol is used by default to download packages for the installation of the basejail. Firewall or proxy configurations can prevent or interfere with FTP transfers. The HTTP protocol works differently and avoids these problems. It can be chosen by specifying a full URL for a particular download mirror in <span class=filename>/usr/local/etc/ezjail.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ezjail_ftphost=http://ftp.FreeBSD.org</pre></div></div><div class=paragraph><p>See <a href=./#mirrors-ftp>FTP 站</a> for a list of sites.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=jails-ezjail-create>14.6.3. 建立並啟動新的 Jail<a class=anchor href=#jails-ezjail-create></a></h4><div class=paragraph><p>New jails are created with <code>ezjail-admin create</code>. In these examples, the <code>lo1</code> loopback interface is used as described above.</p></div><div id=jails-ezjail-create-steps class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Create and Start a New Jail</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Create the jail, specifying a name and the loopback and network interfaces to use, along with their IP addresses. In this example, the jail is named <code>dnsjail</code>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin create dnsjail &#39;lo1|127.0.1.1,em0|192.168.1.50&#39;</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Most network services run in jails without problems. A few network services, most notably <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>, use <em>raw network sockets</em>. In jails, raw network sockets are disabled by default for security. Services that require them will not work.</p></div><div class=paragraph><p>Occasionally, a jail genuinely needs raw sockets. For example, network monitoring applications often use <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> to check the availability of other computers. When raw network sockets are actually needed in a jail, they can be enabled by editing the ezjail configuration file for the individual jail, <span class=filename>/usr/local/etc/ezjail/jailname</span>. Modify the <code>parameters</code> entry:</p></div><div class="literalblock programlisting"><div class=content><pre>export jail_jailname_parameters=&#34;allow.raw_sockets=1&#34;</pre></div></div><div class=paragraph><p>Do not enable raw network sockets unless services in the jail actually require them.</p></div></td></tr></tbody></table></div></li><li><p>Start the jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin start dnsjail</span></code></pre></div></div></li><li><p>Use a console on the jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin console dnsjail</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>The jail is operating and additional configuration can be completed. Typical settings added at this point include:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Set the <code>root</code> Password</p><div class=paragraph><p>Connect to the jail and set the <code>root</code> user’s password:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin console dnsjail</span>
<span class=c># passwd</span>
Changing <span class=nb>local </span>password <span class=k>for </span>root
New Password:
Retype New Password:</code></pre></div></div></li><li><p>Time Zone Configuration</p><div class=paragraph><p>The jail’s time zone can be set with <a href="https://man.freebsd.org/cgi/man.cgi?query=tzsetup&amp;sektion=8&amp;format=html">tzsetup(8)</a>. To avoid spurious error messages, the <a href="https://man.freebsd.org/cgi/man.cgi?query=adjkerntz&amp;sektion=8&amp;format=html">adjkerntz(8)</a> entry in <span class=filename>/etc/crontab</span> can be commented or removed. This job attempts to update the computer’s hardware clock with time zone changes, but jails are not allowed to access that hardware.</p></div></li><li><p>DNS Servers</p><div class=paragraph><p>Enter domain name server lines in <span class=filename>/etc/resolv.conf</span> so DNS works in the jail.</p></div></li><li><p>Edit <span class=filename>/etc/hosts</span></p><div class=paragraph><p>Change the address and add the jail name to the <code>localhost</code> entries in <span class=filename>/etc/hosts</span>.</p></div></li><li><p>Configure <span class=filename>/etc/rc.conf</span></p><div class=paragraph><p>Enter configuration settings in <span class=filename>/etc/rc.conf</span>. This is much like configuring a full computer. The host name and IP address are not set here. Those values are already provided by the jail configuration.</p></div></li></ol></div></div></div><div class=paragraph><p>With the jail configured, the applications for which the jail was created can be installed.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Some ports must be built with special options to be used in a jail. For example, both of the network monitoring plugin packages <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/nagios-plugins/>net-mgmt/nagios-plugins</a> and <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/monitoring-plugins/>net-mgmt/monitoring-plugins</a> have a <code>JAIL</code> option which must be enabled for them to work correctly inside a jail.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=jails-ezjail-update>14.6.4. 更新 Jail<a class=anchor href=#jails-ezjail-update></a></h4><div class=sect4><h5 id=jails-ezjail-update-os>14.6.4.1. 更新作業系統<a class=anchor href=#jails-ezjail-update-os></a></h5><div class=paragraph><p>Because the basejail’s copy of the userland is shared by the other jails, updating the basejail automatically updates all of the other jails. Either source or binary updates can be used.</p></div><div class=paragraph><p>To build the world from source on the host, then install it in the basejail, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -b</span></code></pre></div></div><div class=paragraph><p>If the world has already been compiled on the host, install it in the basejail with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -i</span></code></pre></div></div><div class=paragraph><p>Binary updates use <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a>. These updates have the same limitations as if <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> were being run directly. The most important one is that only -RELEASE versions of FreeBSD are available with this method.</p></div><div class=paragraph><p>Update the basejail to the latest patched release of the version of FreeBSD on the host. For example, updating from RELEASE-p1 to RELEASE-p2.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -u</span></code></pre></div></div><div class=paragraph><p>To upgrade the basejail to a new version, first upgrade the host system as described in <a href=./#freebsdupdate-upgrade>執行主要及次要版號升級</a>. Once the host has been upgraded and rebooted, the basejail can then be upgraded. <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> has no way of determining which version is currently installed in the basejail, so the original version must be specified. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=file&amp;sektion=1&amp;format=html">file(1)</a> to determine the original version in the basejail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># file /usr/jails/basejail/bin/sh</span>
/usr/jails/basejail/bin/sh: ELF 64-bit LSB executable, x86-64, version 1 <span class=o>(</span>FreeBSD<span class=o>)</span>, dynamically linked <span class=o>(</span>uses shared libs<span class=o>)</span>, <span class=k>for </span>FreeBSD 9.3, stripped</code></pre></div></div><div class=paragraph><p>Now use this information to perform the upgrade from <code>9.3-RELEASE</code> to the current version of the host system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -U -s 9.3-RELEASE</span></code></pre></div></div><div class=paragraph><p>After updating the basejail, <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> must be run to update each jail’s configuration files.</p></div><div class=paragraph><p>How to use <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> depends on the purpose and trustworthiness of a jail. If a jail’s services or users are not trusted, then <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> should only be run from within that jail:</p></div><div id=jails-ezjail-update-mergemaster-untrusted class=exampleblock><div class=title>例 34. 在不信任的 Jail 做 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a></div><div class=content><div class=paragraph><p>Delete the link from the jail’s <span class=filename>/usr/src</span> into the basejail and create a new <span class=filename>/usr/src</span> in the jail as a mountpoint. Mount the host computer’s <span class=filename>/usr/src</span> read-only on the jail’s new <span class=filename>/usr/src</span> mountpoint:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm /usr/jails/jailname/usr/src</span>
<span class=c># mkdir /usr/jails/jailname/usr/src</span>
<span class=c># mount -t nullfs -o ro /usr/src /usr/jails/jailname/usr/src</span></code></pre></div></div><div class=paragraph><p>Get a console in the jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin console jailname</span></code></pre></div></div><div class=paragraph><p>Inside the jail, run <code>mergemaster</code>. Then exit the jail console:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># mergemaster -U</span>
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>Finally, unmount the jail’s <span class=filename>/usr/src</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /usr/jails/jailname/usr/src</span></code></pre></div></div></div></div><div id=jails-ezjail-update-mergemaster-trusted class=exampleblock><div class=title>例 35. 在信任的 Jail 做 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a></div><div class=content><div class=paragraph><p>If the users and services in a jail are trusted, <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> can be run from the host:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -U -D /usr/jails/jailname</span></code></pre></div></div></div></div></div><div class=sect4><h5 id=jails-ezjail-update-ports>14.6.4.2. 更新 Port<a class=anchor href=#jails-ezjail-update-ports></a></h5><div class=paragraph><p>The ports tree in the basejail is shared by the other jails. Updating that copy of the ports tree gives the other jails the updated version also.</p></div><div class=paragraph><p>The basejail ports tree is updated with <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -P</span></code></pre></div></div></div></div><div class=sect3><h4 id=jails-ezjail-control>14.6.5. 控制 Jail<a class=anchor href=#jails-ezjail-control></a></h4><div class=sect4><h5 id=jails-ezjail-control-stop-start>14.6.5.1. 停止與啟動 Jail<a class=anchor href=#jails-ezjail-control-stop-start></a></h5><div class=paragraph><p>ezjail automatically starts jails when the computer is started. Jails can be manually stopped and restarted with <code>stop</code> and <code>start</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin stop sambajail</span>
Stopping jails: sambajail.</code></pre></div></div><div class=paragraph><p>By default, jails are started automatically when the host computer starts. Autostarting can be disabled with <code>config</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin config -r norun seldomjail</span></code></pre></div></div><div class=paragraph><p>This takes effect the next time the host computer is started. A jail that is already running will not be stopped.</p></div><div class=paragraph><p>Enabling autostart is very similar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin config -r run oftenjail</span></code></pre></div></div></div><div class=sect4><h5 id=jails-ezjail-control-backup>14.6.5.2. 封存與還原 Jail<a class=anchor href=#jails-ezjail-control-backup></a></h5><div class=paragraph><p>Use <code>archive</code> to create a <span class=filename>.tar.gz</span> archive of a jail. The file name is composed from the name of the jail and the current date. Archive files are written to the archive directory, <span class=filename>/usr/jails/ezjail_archives</span>. A different archive directory can be chosen by setting <code>ezjail_archivedir</code> in the configuration file.</p></div><div class=paragraph><p>The archive file can be copied elsewhere as a backup, or an existing jail can be restored from it with <code>restore</code>. A new jail can be created from the archive, providing a convenient way to clone existing jails.</p></div><div class=paragraph><p>Stop and archive a jail named <code>wwwserver</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin stop wwwserver</span>
Stopping jails: wwwserver.
<span class=c># ezjail-admin archive wwwserver</span>
<span class=c># ls /usr/jails/ezjail-archives/</span>
wwwserver-201407271153.13.tar.gz</code></pre></div></div><div class=paragraph><p>Create a new jail named <code>wwwserver-clone</code> from the archive created in the previous step. Use the <span class=filename>em1</span> interface and assign a new IP address to avoid conflict with the original:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin create -a /usr/jails/ezjail_archives/wwwserver-201407271153.13.tar.gz wwwserver-clone &#39;lo1|127.0.3.1,em1|192.168.1.51&#39;</span></code></pre></div></div></div></div><div class=sect3><h4 id=jails-ezjail-example-bind>14.6.6. 完整範例：在 Jail 中安裝 BIND<a class=anchor href=#jails-ezjail-example-bind></a></h4><div class=paragraph><p>Putting the BINDDNS server in a jail improves security by isolating it. This example creates a simple caching-only name server.</p></div><div class=ulist><ul><li><p>The jail will be called <code>dns1</code>.</p></li><li><p>The jail will use IP address <code>192.168.1.240</code> on the host’s <code>re0</code> interface.</p></li><li><p>The upstream ISP’s DNS servers are at <code>10.0.0.62</code> and <code>10.0.0.61</code>.</p></li><li><p>The basejail has already been created and a ports tree installed as shown in <a href=#jails-ezjail-initialsetup>初始設定</a>.</p></li></ul></div><div id=jails-ezjail-example-bind-steps class=exampleblock><div class=title>例 36. 在 Jail 中執行 BIND</div><div class=content><div class=paragraph><p>Create a cloned loopback interface by adding a line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;lo1&#34;</pre></div></div><div class=paragraph><p>Immediately create the new loopback interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif cloneup</span>
Created clone interfaces: lo1.</code></pre></div></div><div class=paragraph><p>Create the jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin create dns1 &#39;lo1|127.0.2.1,re0|192.168.1.240&#39;</span></code></pre></div></div><div class=paragraph><p>Start the jail, connect to a console running on it, and perform some basic configuration:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin start dns1</span>
<span class=c># ezjail-admin console dns1</span>
<span class=c># passwd</span>
Changing <span class=nb>local </span>password <span class=k>for </span>root
New Password:
Retype New Password:
<span class=c># tzsetup</span>
<span class=c># sed -i .bak -e &#39;/adjkerntz/ s/^/#/&#39; /etc/crontab</span>
<span class=c># sed -i .bak -e &#39;s/127.0.0.1/127.0.2.1/g; s/localhost.my.domain/dns1.my.domain dns1/&#39; /etc/hosts</span></code></pre></div></div><div class=paragraph><p>Temporarily set the upstream DNS servers in <span class=filename>/etc/resolv.conf</span> so ports can be downloaded:</p></div><div class="literalblock programlisting"><div class=content><pre>nameserver 10.0.0.62
nameserver 10.0.0.61</pre></div></div><div class=paragraph><p>Still using the jail console, install <a class=package href=https://cgit.freebsd.org/ports/tree/dns/bind99/>dns/bind99</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -C /usr/ports/dns/bind99 install clean</span></code></pre></div></div><div class=paragraph><p>Configure the name server by editing <span class=filename>/usr/local/etc/namedb/named.conf</span>.</p></div><div class=paragraph><p>Create an Access Control List (ACL) of addresses and networks that are permitted to send DNS queries to this name server. This section is added just before the <code>options</code> section already in the file:</p></div><div class="literalblock programlisting"><div class=content><pre>...
// or cause huge amounts of useless Internet traffic.

acl &#34;trusted&#34; {
	192.168.1.0/24;
	localhost;
	localnets;
};

options {
...</pre></div></div><div class=paragraph><p>Use the jail IP address in the <code>listen-on</code> setting to accept DNS queries from other computers on the network:</p></div><div class="literalblock programlisting"><div class=content><pre>	listen-on	{ 192.168.1.240; };</pre></div></div><div class=paragraph><p>A simple caching-only DNS name server is created by changing the <code>forwarders</code> section. The original file contains:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
	forwarders {
		127.0.0.1;
	};
*/</pre></div></div><div class=paragraph><p>Uncomment the section by removing the <code>/<strong></strong></code><strong> and <code></code></strong><code>/</code> lines. Enter the IP addresses of the upstream DNS servers. Immediately after the <code>forwarders</code> section, add references to the <code>trusted</code> ACL defined earlier:</p></div><div class="literalblock programlisting"><div class=content><pre>	forwarders {
		10.0.0.62;
		10.0.0.61;
	};

	allow-query       { any; };
	allow-recursion   { trusted; };
	allow-query-cache { trusted; };</pre></div></div><div class=paragraph><p>Enable the service in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>named_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Start and test the name server:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service named start</span>
wrote key file <span class=s2>&#34;/usr/local/etc/namedb/rndc.key&#34;</span>
Starting named.
<span class=c># /usr/local/bin/dig @192.168.1.240 freebsd.org</span></code></pre></div></div><div class=paragraph><p>A response that includes</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=p>;;</span> Got answer<span class=p>;</span></code></pre></div></div><div class=paragraph><p>shows that the new DNS server is working. A long delay followed by a response including</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=p>;;</span> connection timed out<span class=p>;</span> no servers could be reached</code></pre></div></div><div class=paragraph><p>shows a problem. Check the configuration settings and make sure any local firewalls allow the new DNS access to the upstream DNS servers.</p></div><div class=paragraph><p>The new DNS server can use itself for local name resolution, just like other local computers. Set the address of the DNS server in the client computer’s <span class=filename>/etc/resolv.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nameserver 192.168.1.240</pre></div></div><div class=paragraph><p>A local DHCP server can be configured to provide this address for a local DNS server, providing automatic configuration on DHCP clients.</p></div></div></div></div></div></div></div><div class=sect1><h2 id=mac>Chapter 15. 強制存取控制 (MAC)<a class=anchor href=#mac></a></h2><div class=sectionbody><div class=sect2><h3 id=mac-synopsis>15.1. 概述<a class=anchor href=#mac-synopsis></a></h3><div class=paragraph><p>FreeBSD supports security extensions based on the POSIX™.1e draft. These security mechanisms include file system Access Control Lists (<a href=./#fs-acl>存取控制清單</a>) and Mandatory Access Control (MAC). MAC allows access control modules to be loaded in order to implement security policies. Some modules provide protections for a narrow subset of the system, hardening a particular service. Others provide comprehensive labeled security across all subjects and objects. The mandatory part of the definition indicates that enforcement of controls is performed by administrators and the operating system. This is in contrast to the default security mechanism of Discretionary Access Control (DAC) where enforcement is left to the discretion of users.</p></div><div class=paragraph><p>This chapter focuses on the MAC framework and the set of pluggable security policy modules FreeBSD provides for enabling various security mechanisms.</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>The terminology associated with the MAC framework.</p></li><li><p>The capabilities of MAC security policy modules as well as the difference between a labeled and non-labeled policy.</p></li><li><p>The considerations to take into account before configuring a system to use the MAC framework.</p></li><li><p>Which MAC security policy modules are included in FreeBSD and how to configure them.</p></li><li><p>How to implement a more secure environment using the MAC framework.</p></li><li><p>How to test the MAC configuration to ensure the framework has been properly implemented.</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解 UNIX™ 及 FreeBSD 基礎 (<a href=./#basics>FreeBSD 基礎</a>)。</p></li><li><p>Have some familiarity with security and how it pertains to FreeBSD (<a href=./#security>安全性</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Improper MAC configuration may cause loss of system access, aggravation of users, or inability to access the features provided by Xorg. More importantly, MAC should not be relied upon to completely secure a system. The MAC framework only augments an existing security policy. Without sound security practices and regular security checks, the system will never be completely secure.</p></div><div class=paragraph><p>The examples contained within this chapter are for demonstration purposes and the example settings should <em>not</em> be implemented on a production system. Implementing any security policy takes a good deal of understanding, proper design, and thorough testing.</p></div></td></tr></tbody></table></div><div class=paragraph><p>While this chapter covers a broad range of security issues relating to the MAC framework, the development of new MAC security policy modules will not be covered. A number of security policy modules included with the MAC framework have specific characteristics which are provided for both testing and new module development. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_test&amp;sektion=4&amp;format=html">mac_test(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_stub&amp;sektion=4&amp;format=html">mac_stub(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_none&amp;sektion=4&amp;format=html">mac_none(4)</a> for more information on these security policy modules and the various mechanisms they provide.</p></div></div><div class=sect2><h3 id=mac-inline-glossary>15.2. 關鍵詞<a class=anchor href=#mac-inline-glossary></a></h3><div class=paragraph><p>The following key terms are used when referring to the MAC framework:</p></div><div class=ulist><ul><li><p><em>compartment</em>: a set of programs and data to be partitioned or separated, where users are given explicit access to specific component of a system. A compartment represents a grouping, such as a work group, department, project, or topic. Compartments make it possible to implement a need-to-know-basis security policy.</p></li><li><p><em>integrity</em>: the level of trust which can be placed on data. As the integrity of the data is elevated, so does the ability to trust that data.</p></li><li><p><em>level</em>: the increased or decreased setting of a security attribute. As the level increases, its security is considered to elevate as well.</p></li><li><p><em>label</em>: a security attribute which can be applied to files, directories, or other items in the system. It could be considered a confidentiality stamp. When a label is placed on a file, it describes the security properties of that file and will only permit access by files, users, and resources with a similar security setting. The meaning and interpretation of label values depends on the policy configuration. Some policies treat a label as representing the integrity or secrecy of an object while other policies might use labels to hold rules for access.</p></li><li><p><em>multilabel</em>: this property is a file system option which can be set in single-user mode using <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>, during boot using <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a>, or during the creation of a new file system. This option permits an administrator to apply different MAC labels on different objects. This option only applies to security policy modules which support labeling.</p></li><li><p><em>single label</em>: a policy where the entire file system uses one label to enforce access control over the flow of data. Whenever <code>multilabel</code> is not set, all files will conform to the same label setting.</p></li><li><p><em>object</em>: an entity through which information flows under the direction of a <em>subject</em>. This includes directories, files, fields, screens, keyboards, memory, magnetic storage, printers or any other data storage or moving device. An object is a data container or a system resource. Access to an object effectively means access to its data.</p></li><li><p><em>subject</em>: any active entity that causes information to flow between <em>objects</em> such as a user, user process, or system process. On FreeBSD, this is almost always a thread acting in a process on behalf of a user.</p></li><li><p><em>policy</em>: a collection of rules which defines how objectives are to be achieved. A policy usually documents how certain items are to be handled. This chapter considers a policy to be a collection of rules which controls the flow of data and information and defines who has access to that data and information.</p></li><li><p><em>high-watermark</em>: this type of policy permits the raising of security levels for the purpose of accessing higher level information. In most cases, the original level is restored after the process is complete. Currently, the FreeBSD MAC framework does not include this type of policy.</p></li><li><p><em>low-watermark</em>: this type of policy permits lowering security levels for the purpose of accessing information which is less secure. In most cases, the original security level of the user is restored after the process is complete. The only security policy module in FreeBSD to use this is <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a>.</p></li><li><p><em>sensitivity</em>: usually used when discussing Multilevel Security (MLS). A sensitivity level describes how important or secret the data should be. As the sensitivity level increases, so does the importance of the secrecy, or confidentiality, of the data.</p></li></ul></div></div><div class=sect2><h3 id=mac-understandlabel>15.3. 了解 MAC 標籤<a class=anchor href=#mac-understandlabel></a></h3><div class=paragraph><p>A MAC label is a security attribute which may be applied to subjects and objects throughout the system. When setting a label, the administrator must understand its implications in order to prevent unexpected or undesired behavior of the system. The attributes available on an object depend on the loaded policy module, as policy modules interpret their attributes in different ways.</p></div><div class=paragraph><p>The security label on an object is used as a part of a security access control decision by a policy. With some policies, the label contains all of the information necessary to make a decision. In other policies, the labels may be processed as part of a larger rule set.</p></div><div class=paragraph><p>There are two types of label policies: single label and multi label. By default, the system will use single label. The administrator should be aware of the pros and cons of each in order to implement policies which meet the requirements of the system’s security model.</p></div><div class=paragraph><p>A single label security policy only permits one label to be used for every subject or object. Since a single label policy enforces one set of access permissions across the entire system, it provides lower administration overhead, but decreases the flexibility of policies which support labeling. However, in many environments, a single label policy may be all that is required.</p></div><div class=paragraph><p>A single label policy is somewhat similar to DAC as <code>root</code> configures the policies so that users are placed in the appropriate categories and access levels. A notable difference is that many policy modules can also restrict <code>root</code>. Basic control over objects will then be released to the group, but <code>root</code> may revoke or modify the settings at any time.</p></div><div class=paragraph><p>When appropriate, a multi label policy can be set on a UFS file system by passing <code>multilabel</code> to <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>. A multi label policy permits each subject or object to have its own independent MAC label. The decision to use a multi label or single label policy is only required for policies which implement the labeling feature, such as <code>biba</code>, <code>lomac</code>, and <code>mls</code>. Some policies, such as <code>seeotheruids</code>, <code>portacl</code> and <code>partition</code>, do not use labels at all.</p></div><div class=paragraph><p>Using a multi label policy on a partition and establishing a multi label security model can increase administrative overhead as everything in that file system has a label. This includes directories, files, and even device nodes.</p></div><div class=paragraph><p>The following command will set <code>multilabel</code> on the specified UFS file system. This may only be done in single-user mode and is not a requirement for the swap file system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -l enable /</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Some users have experienced problems with setting the <code>multilabel</code> flag on the root partition. If this is the case, please review <a href=#mac-troubleshoot>MAC 架構疑難排解</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Since the multi label policy is set on a per-file system basis, a multi label policy may not be needed if the file system layout is well designed. Consider an example security MAC model for a FreeBSD web server. This machine uses the single label, <code>biba/high</code>, for everything in the default file systems. If the web server needs to run at <code>biba/low</code> to prevent write up capabilities, it could be installed to a separate UFS <span class=filename>/usr/local</span> file system set at <code>biba/low</code>.</p></div><div class=sect3><h4 id=_標籤設定>15.3.1. 標籤設定<a class=anchor href=#_標籤設定></a></h4><div class=paragraph><p>Virtually all aspects of label policy module configuration will be performed using the base system utilities. These commands provide a simple interface for object or subject configuration or the manipulation and verification of the configuration.</p></div><div class=paragraph><p>All configuration may be done using <code>setfmac</code>, which is used to set MAC labels on system objects, and <code>setpmac</code>, which is used to set the labels on system subjects. For example, to set the <code>biba</code> MAC label to <code>high</code> on <span class=filename>test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/high test</span></code></pre></div></div><div class=paragraph><p>If the configuration is successful, the prompt will be returned without error. A common error is <code>Permission denied</code> which usually occurs when the label is being set or modified on a restricted object. Other conditions may produce different failures. For instance, the file may not be owned by the user attempting to relabel the object, the object may not exist, or the object may be read-only. A mandatory policy will not allow the process to relabel the file, maybe because of a property of the file, a property of the process, or a property of the proposed new label value. For example, if a user running at low integrity tries to change the label of a high integrity file, or a user running at low integrity tries to change the label of a low integrity file to a high integrity label, these operations will fail.</p></div><div class=paragraph><p>The system administrator may use <code>setpmac</code> to override the policy module’s settings by assigning a different label to the invoked process:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/high test</span>
Permission denied
<span class=c># setpmac biba/low setfmac biba/high test</span>
<span class=c># getfmac test</span>
<span class=nb>test</span>: biba/high</code></pre></div></div><div class=paragraph><p>For currently running processes, such as sendmail, <code>getpmac</code> is usually used instead. This command takes a process ID (PID) in place of a command name. If users attempt to manipulate a file not in their access, subject to the rules of the loaded policy modules, the <code>Operation not permitted</code> error will be displayed.</p></div></div><div class=sect3><h4 id=_預先定義的標籤>15.3.2. 預先定義的標籤<a class=anchor href=#_預先定義的標籤></a></h4><div class=paragraph><p>A few FreeBSD policy modules which support the labeling feature offer three predefined labels: <code>low</code>, <code>equal</code>, and <code>high</code>, where:</p></div><div class=ulist><ul><li><p><code>low</code> is considered the lowest label setting an object or subject may have. Setting this on objects or subjects blocks their access to objects or subjects marked high.</p></li><li><p><code>equal</code> sets the subject or object to be disabled or unaffected and should only be placed on objects considered to be exempt from the policy.</p></li><li><p><code>high</code> grants an object or subject the highest setting available in the Biba and MLS policy modules.</p></li></ul></div><div class=paragraph><p>Such policy modules include <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a>. Each of the predefined labels establishes a different information flow directive. Refer to the manual page of the module to determine the traits of the generic label configurations.</p></div></div><div class=sect3><h4 id=_數值標籤>15.3.3. 數值標籤<a class=anchor href=#_數值標籤></a></h4><div class=paragraph><p>The Biba and MLS policy modules support a numeric label which may be set to indicate the precise level of hierarchical control. This numeric level is used to partition or sort information into different groups of classification, only permitting access to that group or a higher group level. For example:</p></div><div class="literalblock programlisting"><div class=content><pre>biba/10:2+3+6(5:2+3-20:2+3+4+5+6)</pre></div></div><div class=paragraph><p>may be interpreted as "Biba Policy Label/Grade 10:Compartments 2, 3 and 6: (grade 5 …​")</p></div><div class=paragraph><p>In this example, the first grade would be considered the effective grade with effective compartments, the second grade is the low grade, and the last one is the high grade. In most configurations, such fine-grained settings are not needed as they are considered to be advanced configurations.</p></div><div class=paragraph><p>System objects only have a current grade and compartment. System subjects reflect the range of available rights in the system, and network interfaces, where they are used for access control.</p></div><div class=paragraph><p>The grade and compartments in a subject and object pair are used to construct a relationship known as <em>dominance</em>, in which a subject dominates an object, the object dominates the subject, neither dominates the other, or both dominate each other. The "both dominate" case occurs when the two labels are equal. Due to the information flow nature of Biba, a user has rights to a set of compartments that might correspond to projects, but objects also have a set of compartments. Users may have to subset their rights using <code>su</code> or <code>setpmac</code> in order to access objects in a compartment from which they are not restricted.</p></div></div><div class=sect3><h4 id=_使用者標籤>15.3.4. 使用者標籤<a class=anchor href=#_使用者標籤></a></h4><div class=paragraph><p>Users are required to have labels so that their files and processes properly interact with the security policy defined on the system. This is configured in <span class=filename>/etc/login.conf</span> using login classes. Every policy module that uses labels will implement the user class setting.</p></div><div class=paragraph><p>To set the user class default label which will be enforced by MAC, add a <code>label</code> entry. An example <code>label</code> entry containing every policy module is displayed below. Note that in a real configuration, the administrator would never enable every policy module. It is recommended that the rest of this chapter be reviewed before any configuration is implemented.</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
	:copyright=/etc/COPYRIGHT:\
	:welcome=/etc/motd:\
	:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
	:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
	:manpath=/usr/shared/man /usr/local/man:\
	:nologin=/usr/sbin/nologin:\
	:cputime=1h30m:\
	:datasize=8M:\
	:vmemoryuse=100M:\
	:stacksize=2M:\
	:memorylocked=4M:\
	:memoryuse=8M:\
	:filesize=8M:\
	:coredumpsize=8M:\
	:openfiles=24:\
	:maxproc=32:\
	:priority=0:\
	:requirehome:\
	:passwordtime=91d:\
	:umask=022:\
	:ignoretime@:\
	:label=partition/13,mls/5,biba/10(5-15),lomac/10[2]:</pre></div></div><div class=paragraph><p>While users can not modify the default value, they may change their label after they login, subject to the constraints of the policy. The example above tells the Biba policy that a process’s minimum integrity is <code>5</code>, its maximum is <code>15</code>, and the default effective label is <code>10</code>. The process will run at <code>10</code> until it chooses to change label, perhaps due to the user using <code>setpmac</code>, which will be constrained by Biba to the configured range.</p></div><div class=paragraph><p>After any change to <span class=filename>login.conf</span>, the login class capability database must be rebuilt using <code>cap_mkdb</code>.</p></div><div class=paragraph><p>Many sites have a large number of users requiring several different user classes. In depth planning is required as this can become difficult to manage.</p></div></div><div class=sect3><h4 id=_網路介面標籤>15.3.5. 網路介面標籤<a class=anchor href=#_網路介面標籤></a></h4><div class=paragraph><p>Labels may be set on network interfaces to help control the flow of data across the network. Policies using network interface labels function in the same way that policies function with respect to objects. Users at high settings in Biba, for example, will not be permitted to access network interfaces with a label of <code>low</code>.</p></div><div class=paragraph><p>When setting the MAC label on network interfaces, <code>maclabel</code> may be passed to <code>ifconfig</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bge0 maclabel biba/equal</span></code></pre></div></div><div class=paragraph><p>This example will set the MAC label of <code>biba/equal</code> on the <code>bge0</code> interface. When using a setting similar to <code>biba/high(low-high)</code>, the entire label should be quoted to prevent an error from being returned.</p></div><div class=paragraph><p>Each policy module which supports labeling has a tunable which may be used to disable the MAC label on network interfaces. Setting the label to <code>equal</code> will have a similar effect. Review the output of <code>sysctl</code>, the policy manual pages, and the information in the rest of this chapter for more information on those tunables.</p></div></div></div><div class=sect2><h3 id=mac-planning>15.4. 規劃安全架構<a class=anchor href=#mac-planning></a></h3><div class=paragraph><p>Before implementing any MAC policies, a planning phase is recommended. During the planning stages, an administrator should consider the implementation requirements and goals, such as:</p></div><div class=ulist><ul><li><p>How to classify information and resources available on the target systems.</p></li><li><p>Which information or resources to restrict access to along with the type of restrictions that should be applied.</p></li><li><p>Which MAC modules will be required to achieve this goal.</p></li></ul></div><div class=paragraph><p>A trial run of the trusted system and its configuration should occur <em>before</em> a MAC implementation is used on production systems. Since different environments have different needs and requirements, establishing a complete security profile will decrease the need of changes once the system goes live.</p></div><div class=paragraph><p>Consider how the MAC framework augments the security of the system as a whole. The various security policy modules provided by the MAC framework could be used to protect the network and file systems or to block users from accessing certain ports and sockets. Perhaps the best use of the policy modules is to load several security policy modules at a time in order to provide a MLS environment. This approach differs from a hardening policy, which typically hardens elements of a system which are used only for specific purposes. The downside to MLS is increased administrative overhead.</p></div><div class=paragraph><p>The overhead is minimal when compared to the lasting effect of a framework which provides the ability to pick and choose which policies are required for a specific configuration and which keeps performance overhead down. The reduction of support for unneeded policies can increase the overall performance of the system as well as offer flexibility of choice. A good implementation would consider the overall security requirements and effectively implement the various security policy modules offered by the framework.</p></div><div class=paragraph><p>A system utilizing MAC guarantees that a user will not be permitted to change security attributes at will. All user utilities, programs, and scripts must work within the constraints of the access rules provided by the selected security policy modules and control of the MAC access rules is in the hands of the system administrator.</p></div><div class=paragraph><p>It is the duty of the system administrator to carefully select the correct security policy modules. For an environment that needs to limit access control over the network, the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> policy modules make good starting points. For an environment where strict confidentiality of file system objects is required, consider the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> policy modules.</p></div><div class=paragraph><p>Policy decisions could be made based on network configuration. If only certain users should be permitted access to <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> policy module is a good choice. In the case of file systems, access to objects might be considered confidential to some users, but not to others. As an example, a large development team might be broken off into smaller projects where developers in project A might not be permitted to access objects written by developers in project B. Yet both projects might need to access objects created by developers in project C. Using the different security policy modules provided by the MAC framework, users could be divided into these groups and then given access to the appropriate objects.</p></div><div class=paragraph><p>Each security policy module has a unique way of dealing with the overall security of a system. Module selection should be based on a well thought out security policy which may require revision and reimplementation. Understanding the different security policy modules offered by the MAC framework will help administrators choose the best policies for their situations.</p></div><div class=paragraph><p>The rest of this chapter covers the available modules, describes their use and configuration, and in some cases, provides insight on applicable situations.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Implementing MAC is much like implementing a firewall since care must be taken to prevent being completely locked out of the system. The ability to revert back to a previous configuration should be considered and the implementation of MAC over a remote connection should be done with extreme caution.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mac-policies>15.5. 可用的 MAC 管理政策<a class=anchor href=#mac-policies></a></h3><div class=paragraph><p>The default FreeBSD kernel includes <code>options MAC</code>. This means that every module included with the MAC framework can be loaded with <code>kldload</code> as a run-time kernel module. After testing the module, add the module name to <span class=filename>/boot/loader.conf</span> so that it will load during boot. Each module also provides a kernel option for those administrators who choose to compile their own custom kernel.</p></div><div class=paragraph><p>FreeBSD includes a group of policies that will cover most security requirements. Each policy is summarized below. The last three policies support integer settings in place of the three default labels.</p></div><div class=sect3><h4 id=mac-seeotheruids>15.5.1. MAC See Other UIDs 政策<a class=anchor href=#mac-seeotheruids></a></h4><div class=paragraph><p>Module name: <span class=filename>mac_seeotheruids.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_SEEOTHERUIDS</code></p></div><div class=paragraph><p>Boot option: <code>mac_seeotheruids_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> module extends the <code>security.bsd.see_other_uids</code> and <code>security.bsd.see_other_gids sysctl</code> tunables. This option does not require any labels to be set before configuration and can operate transparently with other modules.</p></div><div class=paragraph><p>After loading the module, the following <code>sysctl</code> tunables may be used to control its features:</p></div><div class=ulist><ul><li><p><code>security.mac.seeotheruids.enabled</code> enables the module and implements the default settings which deny users the ability to view processes and sockets owned by other users.</p></li><li><p><code>security.mac.seeotheruids.specificgid_enabled</code> allows specified groups to be exempt from this policy. To exempt specific groups, use the <code>security.mac.seeotheruids.specificgid=<em>XXX</em> sysctl</code> tunable, replacing <em>XXX</em> with the numeric group ID to be exempted.</p></li><li><p><code>security.mac.seeotheruids.primarygroup_enabled</code> is used to exempt specific primary groups from this policy. When using this tunable, <code>security.mac.seeotheruids.specificgid_enabled</code> may not be set.</p></li></ul></div></div><div class=sect3><h4 id=mac-bsdextended>15.5.2. MAC BSD Extended 政策<a class=anchor href=#mac-bsdextended></a></h4><div class=paragraph><p>Module name: <span class=filename>mac_bsdextended.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_BSDEXTENDED</code></p></div><div class=paragraph><p>Boot option: <code>mac_bsdextended_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> module enforces a file system firewall. It provides an extension to the standard file system permissions model, permitting an administrator to create a firewall-like ruleset to protect files, utilities, and directories in the file system hierarchy. When access to a file system object is attempted, the list of rules is iterated until either a matching rule is located or the end is reached. This behavior may be changed using <code>security.mac.bsdextended.firstmatch_enabled</code>. Similar to other firewall modules in FreeBSD, a file containing the access control rules can be created and read by the system at boot time using an <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> variable.</p></div><div class=paragraph><p>The rule list may be entered using <a href="https://man.freebsd.org/cgi/man.cgi?query=ugidfw&amp;sektion=8&amp;format=html">ugidfw(8)</a> which has a syntax similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. More tools can be written by using the functions in the <a href="https://man.freebsd.org/cgi/man.cgi?query=libugidfw&amp;sektion=3&amp;format=html">libugidfw(3)</a> library.</p></div><div class=paragraph><p>After the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> module has been loaded, the following command may be used to list the current rule configuration:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw list</span>
0 slots, 0 rules</code></pre></div></div><div class=paragraph><p>By default, no rules are defined and everything is completely accessible. To create a rule which blocks all access by users but leaves <code>root</code> unaffected:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw add subject not uid root new object not uid root mode n</span></code></pre></div></div><div class=paragraph><p>While this rule is simple to implement, it is a very bad idea as it blocks all users from issuing any commands. A more realistic example blocks <code>user1</code> all access, including directory listings, to <code><em>user2</em></code>'s home directory:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw set 2 subject uid user1 object uid user2 mode n</span>
<span class=c># ugidfw set 3 subject uid user1 object gid user2 mode n</span></code></pre></div></div><div class=paragraph><p>Instead of <code>user1</code>, <code>not uid <em>user2</em></code> could be used in order to enforce the same access restrictions for all users. However, the <code>root</code> user is unaffected by these rules.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Extreme caution should be taken when working with this module as incorrect use could block access to certain parts of the file system.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mac-ifoff>15.5.3. MAC Interface Silencing 政策<a class=anchor href=#mac-ifoff></a></h4><div class=paragraph><p>Module name: <span class=filename>mac_ifoff.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_IFOFF</code></p></div><div class=paragraph><p>Boot option: <code>mac_ifoff_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> module is used to disable network interfaces on the fly and to keep network interfaces from being brought up during system boot. It does not use labels and does not depend on any other MAC modules.</p></div><div class=paragraph><p>Most of this module’s control is performed through these <code>sysctl</code> tunables:</p></div><div class=ulist><ul><li><p><code>security.mac.ifoff.lo_enabled</code> enables or disables all traffic on the loopback, <a href="https://man.freebsd.org/cgi/man.cgi?query=lo&amp;sektion=4&amp;format=html">lo(4)</a>, interface.</p></li><li><p><code>security.mac.ifoff.bpfrecv_enabled</code> enables or disables all traffic on the Berkeley Packet Filter interface, <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>.</p></li><li><p><code>security.mac.ifoff.other_enabled</code> enables or disables traffic on all other interfaces.</p></li></ul></div><div class=paragraph><p>One of the most common uses of <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> is network monitoring in an environment where network traffic should not be permitted during the boot sequence. Another use would be to write a script which uses an application such as <a class=package href=https://cgit.freebsd.org/ports/tree/security/aide/>security/aide</a> to automatically block network traffic if it finds new or altered files in protected directories.</p></div></div><div class=sect3><h4 id=mac-portacl>15.5.4. MAC Port Access Control 政策<a class=anchor href=#mac-portacl></a></h4><div class=paragraph><p>Module name: <span class=filename>mac_portacl.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>MAC_PORTACL</code></p></div><div class=paragraph><p>Boot option: <code>mac_portacl_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> module is used to limit binding to local TCP and UDP ports, making it possible to allow non-<code>root</code> users to bind to specified privileged ports below 1024.</p></div><div class=paragraph><p>Once loaded, this module enables the MAC policy on all sockets. The following tunables are available:</p></div><div class=ulist><ul><li><p><code>security.mac.portacl.enabled</code> enables or disables the policy completely.</p></li><li><p><code>security.mac.portacl.port_high</code> sets the highest port number that <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> protects.</p></li><li><p><code>security.mac.portacl.suser_exempt</code>, when set to a non-zero value, exempts the <code>root</code> user from this policy.</p></li><li><p><code>security.mac.portacl.rules</code> specifies the policy as a text string of the form <code>rule[,rule,…​]</code>, with as many rules as needed, and where each rule is of the form <code>idtype:id:protocol:port</code>. The <span class=parameter>idtype</span> is either <code>uid</code> or <code>gid</code>. The <span class=parameter>protocol</span> parameter can be <code>tcp</code> or <code>udp</code>. The <span class=parameter>port</span> parameter is the port number to allow the specified user or group to bind to. Only numeric values can be used for the user ID, group ID, and port parameters.</p></li></ul></div><div class=paragraph><p>By default, ports below 1024 can only be used by privileged processes which run as <code>root</code>. For <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> to allow non-privileged processes to bind to ports below 1024, set the following tunables as follows:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.port_high=1023</span>
<span class=c># sysctl net.inet.ip.portrange.reservedlow=0</span>
<span class=c># sysctl net.inet.ip.portrange.reservedhigh=0</span></code></pre></div></div><div class=paragraph><p>To prevent the <code>root</code> user from being affected by this policy, set <code>security.mac.portacl.suser_exempt</code> to a non-zero value.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.suser_exempt=1</span></code></pre></div></div><div class=paragraph><p>To allow the <code>www</code> user with UID 80 to bind to port 80 without ever needing <code>root</code> privilege:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.rules=uid:80:tcp:80</span></code></pre></div></div><div class=paragraph><p>This next example permits the user with the UID of 1001 to bind to TCP ports 110 (POP3) and 995 (POP3s):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995</span></code></pre></div></div></div><div class=sect3><h4 id=mac-partition>15.5.5. MAC Partition 政策<a class=anchor href=#mac-partition></a></h4><div class=paragraph><p>Module name: <span class=filename>mac_partition.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_PARTITION</code></p></div><div class=paragraph><p>Boot option: <code>mac_partition_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_partition&amp;sektion=4&amp;format=html">mac_partition(4)</a> policy drops processes into specific "partitions" based on their MAC label. Most configuration for this policy is done using <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a>. One <code>sysctl</code> tunable is available for this policy:</p></div><div class=ulist><ul><li><p><code>security.mac.partition.enabled</code> enables the enforcement of MAC process partitions.</p></li></ul></div><div class=paragraph><p>When this policy is enabled, users will only be permitted to see their processes, and any others within their partition, but will not be permitted to work with utilities outside the scope of this partition. For instance, a user in the <code>insecure</code> class will not be permitted to access <code>top</code> as well as many other commands that must spawn a process.</p></div><div class=paragraph><p>This example adds <code>top</code> to the label set on users in the <code>insecure</code> class. All processes spawned by users in the <code>insecure</code> class will stay in the <code>partition/13</code> label.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setpmac partition/13 top</span></code></pre></div></div><div class=paragraph><p>This command displays the partition label and the process list:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps Zax</span></code></pre></div></div><div class=paragraph><p>This command displays another user’s process partition label and that user’s currently running processes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps -ZU trhodes</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Users can see processes in <code>root</code>'s label unless the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> policy is loaded.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mac-mls>15.5.6. MAC Multi-Level Security 模組<a class=anchor href=#mac-mls></a></h4><div class=paragraph><p>Module name: <span class=filename>mac_mls.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_MLS</code></p></div><div class=paragraph><p>Boot option: <code>mac_mls_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> policy controls access between subjects and objects in the system by enforcing a strict information flow policy.</p></div><div class=paragraph><p>In MLS environments, a "clearance" level is set in the label of each subject or object, along with compartments. Since these clearance levels can reach numbers greater than several thousand, it would be a daunting task to thoroughly configure every subject or object. To ease this administrative overhead, three labels are included in this policy: <code>mls/low</code>, <code>mls/equal</code>, and <code>mls/high</code>, where:</p></div><div class=ulist><ul><li><p>Anything labeled with <code>mls/low</code> will have a low clearance level and not be permitted to access information of a higher level. This label also prevents objects of a higher clearance level from writing or passing information to a lower level.</p></li><li><p><code>mls/equal</code> should be placed on objects which should be exempt from the policy.</p></li><li><p><code>mls/high</code> is the highest level of clearance possible. Objects assigned this label will hold dominance over all other objects in the system; however, they will not permit the leaking of information to objects of a lower class.</p></li></ul></div><div class=paragraph><p>MLS provides:</p></div><div class=ulist><ul><li><p>A hierarchical security level with a set of non-hierarchical categories.</p></li><li><p>Fixed rules of <code>no read up, no write down</code>. This means that a subject can have read access to objects on its own level or below, but not above. Similarly, a subject can have write access to objects on its own level or above, but not beneath.</p></li><li><p>Secrecy, or the prevention of inappropriate disclosure of data.</p></li><li><p>A basis for the design of systems that concurrently handle data at multiple sensitivity levels without leaking information between secret and confidential.</p></li></ul></div><div class=paragraph><p>The following <code>sysctl</code> tunables are available:</p></div><div class=ulist><ul><li><p><code>security.mac.mls.enabled</code> is used to enable or disable the MLS policy.</p></li><li><p><code>security.mac.mls.ptys_equal</code> labels all <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a> devices as <code>mls/equal</code> during creation.</p></li><li><p><code>security.mac.mls.revocation_enabled</code> revokes access to objects after their label changes to a label of a lower grade.</p></li><li><p><code>security.mac.mls.max_compartments</code> sets the maximum number of compartment levels allowed on a system.</p></li></ul></div><div class=paragraph><p>To manipulate MLS labels, use <a href="https://man.freebsd.org/cgi/man.cgi?query=setfmac&amp;sektion=8&amp;format=html">setfmac(8)</a>. To assign a label to an object:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac mls/5 test</span></code></pre></div></div><div class=paragraph><p>To get the MLS label for the file <span class=filename>test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># getfmac test</span></code></pre></div></div><div class=paragraph><p>Another approach is to create a master policy file in <span class=filename>/etc/</span> which specifies the MLS policy information and to feed that file to <code>setfmac</code>.</p></div><div class=paragraph><p>When using the MLS policy module, an administrator plans to control the flow of sensitive information. The default <code>block read up block write down</code> sets everything to a low state. Everything is accessible and an administrator slowly augments the confidentiality of the information.</p></div><div class=paragraph><p>Beyond the three basic label options, an administrator may group users and groups as required to block the information flow between them. It might be easier to look at the information in clearance levels using descriptive words, such as classifications of <code>Confidential</code>, <code>Secret</code>, and <code>Top Secret</code>. Some administrators instead create different groups based on project levels. Regardless of the classification method, a well thought out plan must exist before implementing a restrictive policy.</p></div><div class=paragraph><p>Some example situations for the MLS policy module include an e-commerce web server, a file server holding critical company information, and financial institution environments.</p></div></div><div class=sect3><h4 id=mac-biba>15.5.7. MAC Biba 模組<a class=anchor href=#mac-biba></a></h4><div class=paragraph><p>Module name: <span class=filename>mac_biba.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_BIBA</code></p></div><div class=paragraph><p>Boot option: <code>mac_biba_load="YES"</code></p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> module loads the MAC Biba policy. This policy is similar to the MLS policy with the exception that the rules for information flow are slightly reversed. This is to prevent the downward flow of sensitive information whereas the MLS policy prevents the upward flow of sensitive information.</p></div><div class=paragraph><p>In Biba environments, an "integrity" label is set on each subject or object. These labels are made up of hierarchical grades and non-hierarchical components. As a grade ascends, so does its integrity.</p></div><div class=paragraph><p>Supported labels are <code>biba/low</code>, <code>biba/equal</code>, and <code>biba/high</code>, where:</p></div><div class=ulist><ul><li><p><code>biba/low</code> is considered the lowest integrity an object or subject may have. Setting this on objects or subjects blocks their write access to objects or subjects marked as <code>biba/high</code>, but will not prevent read access.</p></li><li><p><code>biba/equal</code> should only be placed on objects considered to be exempt from the policy.</p></li><li><p><code>biba/high</code> permits writing to objects set at a lower label, but does not permit reading that object. It is recommended that this label be placed on objects that affect the integrity of the entire system.</p></li></ul></div><div class=paragraph><p>Biba provides:</p></div><div class=ulist><ul><li><p>Hierarchical integrity levels with a set of non-hierarchical integrity categories.</p></li><li><p>Fixed rules are <code>no write up, no read down</code>, the opposite of MLS. A subject can have write access to objects on its own level or below, but not above. Similarly, a subject can have read access to objects on its own level or above, but not below.</p></li><li><p>Integrity by preventing inappropriate modification of data.</p></li><li><p>Integrity levels instead of MLS sensitivity levels.</p></li></ul></div><div class=paragraph><p>The following tunables can be used to manipulate the Biba policy:</p></div><div class=ulist><ul><li><p><code>security.mac.biba.enabled</code> is used to enable or disable enforcement of the Biba policy on the target machine.</p></li><li><p><code>security.mac.biba.ptys_equal</code> is used to disable the Biba policy on <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a> devices.</p></li><li><p><code>security.mac.biba.revocation_enabled</code> forces the revocation of access to objects if the label is changed to dominate the subject.</p></li></ul></div><div class=paragraph><p>To access the Biba policy setting on system objects, use <code>setfmac</code> and <code>getfmac</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/low test</span>
<span class=c># getfmac test</span>
<span class=nb>test</span>: biba/low</code></pre></div></div><div class=paragraph><p>Integrity, which is different from sensitivity, is used to guarantee that information is not manipulated by untrusted parties. This includes information passed between subjects and objects. It ensures that users will only be able to modify or access information they have been given explicit access to. The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> security policy module permits an administrator to configure which files and programs a user may see and invoke while assuring that the programs and files are trusted by the system for that user.</p></div><div class=paragraph><p>During the initial planning phase, an administrator must be prepared to partition users into grades, levels, and areas. The system will default to a high label once this policy module is enabled, and it is up to the administrator to configure the different grades and levels for users. Instead of using clearance levels, a good planning method could include topics. For instance, only allow developers modification access to the source code repository, source code compiler, and other development utilities. Other users would be grouped into other categories such as testers, designers, or end users and would only be permitted read access.</p></div><div class=paragraph><p>A lower integrity subject is unable to write to a higher integrity subject and a higher integrity subject cannot list or read a lower integrity object. Setting a label at the lowest possible grade could make it inaccessible to subjects. Some prospective environments for this security policy module would include a constrained web server, a development and test machine, and a source code repository. A less useful implementation would be a personal workstation, a machine used as a router, or a network firewall.</p></div></div><div class=sect3><h4 id=mac-lomac>15.5.8. MAC Low-watermark 模組<a class=anchor href=#mac-lomac></a></h4><div class=paragraph><p>Module name: <span class=filename>mac_lomac.ko</span></p></div><div class=paragraph><p>Kernel configuration line: <code>options MAC_LOMAC</code></p></div><div class=paragraph><p>Boot option: <code>mac_lomac_load="YES"</code></p></div><div class=paragraph><p>Unlike the MAC Biba policy, the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a> policy permits access to lower integrity objects only after decreasing the integrity level to not disrupt any integrity rules.</p></div><div class=paragraph><p>The Low-watermark integrity policy works almost identically to Biba, with the exception of using floating labels to support subject demotion via an auxiliary grade compartment. This secondary compartment takes the form <code>[auxgrade]</code>. When assigning a policy with an auxiliary grade, use the syntax <code>lomac/10[2]</code>, where <code>2</code> is the auxiliary grade.</p></div><div class=paragraph><p>This policy relies on the ubiquitous labeling of all system objects with integrity labels, permitting subjects to read from low integrity objects and then downgrading the label on the subject to prevent future writes to high integrity objects using <code>[auxgrade]</code>. The policy may provide greater compatibility and require less initial configuration than Biba.</p></div><div class=paragraph><p>Like the Biba and MLS policies, <code>setfmac</code> and <code>setpmac</code> are used to place labels on system objects:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac /usr/home/trhodes lomac/high[low]</span>
<span class=c># getfmac /usr/home/trhodes lomac/high[low]</span></code></pre></div></div><div class=paragraph><p>The auxiliary grade <code>low</code> is a feature provided only by the MACLOMAC policy.</p></div></div></div><div class=sect2><h3 id=mac-userlocked>15.6. User Lock Down<a class=anchor href=#mac-userlocked></a></h3><div class=paragraph><p>This example considers a relatively small storage system with fewer than fifty users. Users will have login capabilities and are permitted to store data and access resources.</p></div><div class=paragraph><p>For this scenario, the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> policy modules could co-exist and block access to system objects while hiding user processes.</p></div><div class=paragraph><p>Begin by adding the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>mac_seeotheruids_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> security policy module may be activated by adding this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ugidfw_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Default rules stored in <span class=filename>/etc/rc.bsdextended</span> will be loaded at system initialization. However, the default entries may need modification. Since this machine is expected only to service users, everything may be left commented out except the last two lines in order to force the loading of user owned system objects by default.</p></div><div class=paragraph><p>Add the required users to this machine and reboot. For testing purposes, try logging in as a different user across two consoles. Run <code>ps aux</code> to see if processes of other users are visible. Verify that running <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> on another user’s home directory fails.</p></div><div class=paragraph><p>Do not try to test with the <code>root</code> user unless the specific <code>sysctl</code>`s have been modified to block super user access.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When a new user is added, their <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> rule will not be in the ruleset list. To update the ruleset quickly, unload the security policy module and reload it again using <a href="https://man.freebsd.org/cgi/man.cgi?query=kldunload&amp;sektion=8&amp;format=html">kldunload(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mac-implementing>15.7. 在 MAC Jail 中使用 Nagios<a class=anchor href=#mac-implementing></a></h3><div class=paragraph><p>This section demonstrates the steps that are needed to implement the Nagios network monitoring system in a MAC environment. This is meant as an example which still requires the administrator to test that the implemented policy meets the security requirements of the network before using in a production environment.</p></div><div class=paragraph><p>This example requires <code>multilabel</code> to be set on each file system. It also assumes that <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/nagios-plugins/>net-mgmt/nagios-plugins</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/nagios/>net-mgmt/nagios</a>, and <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> are all installed, configured, and working correctly before attempting the integration into the MAC framework.</p></div><div class=sect3><h4 id=_建立不安全的使用者類別>15.7.1. 建立不安全的使用者類別<a class=anchor href=#_建立不安全的使用者類別></a></h4><div class=paragraph><p>Begin the procedure by adding the following user class to <span class=filename>/etc/login.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>insecure:\
:copyright=/etc/COPYRIGHT:\
:welcome=/etc/motd:\
:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
:manpath=/usr/shared/man /usr/local/man:\
:nologin=/usr/sbin/nologin:\
:cputime=1h30m:\
:datasize=8M:\
:vmemoryuse=100M:\
:stacksize=2M:\
:memorylocked=4M:\
:memoryuse=8M:\
:filesize=8M:\
:coredumpsize=8M:\
:openfiles=24:\
:maxproc=32:\
:priority=0:\
:requirehome:\
:passwordtime=91d:\
:umask=022:\
:ignoretime@:\
:label=biba/10(10-10):</pre></div></div><div class=paragraph><p>Then, add the following line to the default user class section:</p></div><div class="literalblock programlisting"><div class=content><pre>:label=biba/high:</pre></div></div><div class=paragraph><p>Save the edits and issue the following command to rebuild the database:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div></div><div class=sect3><h4 id=_設定使用者>15.7.2. 設定使用者<a class=anchor href=#_設定使用者></a></h4><div class=paragraph><p>Set the <code>root</code> user to the default class using:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod root -L default</span></code></pre></div></div><div class=paragraph><p>All user accounts that are not <code>root</code> will now require a login class. The login class is required, otherwise users will be refused access to common commands. The following <code>sh</code> script should do the trick:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for x in `awk -F: &#39;($3 &gt;= 1001) &amp;&amp; ($3 != 65534) { print $1 }&#39; \</span>
	/etc/passwd<span class=sb>`</span><span class=p>;</span> <span class=k>do </span>pw usermod <span class=nv>$x</span> <span class=nt>-L</span> default<span class=p>;</span> <span class=k>done</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Next, drop the <code>nagios</code> and <code>www</code> accounts into the insecure class:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod nagios -L insecure</span>
<span class=c># pw usermod www -L insecure</span></code></pre></div></div></div><div class=sect3><h4 id=_建立關聯檔_context_file>15.7.3. 建立關聯檔 (Context File)<a class=anchor href=#_建立關聯檔_context_file></a></h4><div class=paragraph><p>A contexts file should now be created as <span class=filename>/etc/policy.contexts</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># This is the default BIBA policy for this system.

# System:
/var/run(/.*)?			biba/equal

/dev/(/.*)?			biba/equal

/var				biba/equal
/var/spool(/.*)?		biba/equal

/var/log(/.*)?			biba/equal

/tmp(/.*)?			biba/equal
/var/tmp(/.*)?			biba/equal

/var/spool/mqueue		biba/equal
/var/spool/clientmqueue		biba/equal

# For Nagios:
/usr/local/etc/nagios(/.*)?	biba/10

/var/spool/nagios(/.*)?		biba/10

# For apache
/usr/local/etc/apache(/.*)?	biba/10</pre></div></div><div class=paragraph><p>This policy enforces security by setting restrictions on the flow of information. In this specific configuration, users, including <code>root</code>, should never be allowed to access Nagios. Configuration files and processes that are a part of Nagios will be completely self contained or jailed.</p></div><div class=paragraph><p>This file will be read after running <code>setfsmac</code> on every file system. This example sets the policy on the root file system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfsmac -ef /etc/policy.contexts /</span></code></pre></div></div><div class=paragraph><p>Next, add these edits to the main section of <span class=filename>/etc/mac.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>default_labels file ?biba
default_labels ifnet ?biba
default_labels process ?biba
default_labels socket ?biba</pre></div></div></div><div class=sect3><h4 id=_載入程式設定>15.7.4. 載入程式設定<a class=anchor href=#_載入程式設定></a></h4><div class=paragraph><p>To finish the configuration, add the following lines to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>mac_biba_load=&#34;YES&#34;
mac_seeotheruids_load=&#34;YES&#34;
security.mac.biba.trust_all_interfaces=1</pre></div></div><div class=paragraph><p>And the following line to the network card configuration stored in <span class=filename>/etc/rc.conf</span>. If the primary network configuration is done via DHCP, this may need to be configured manually after every system boot:</p></div><div class="literalblock programlisting"><div class=content><pre>maclabel biba/equal</pre></div></div></div><div class=sect3><h4 id=_測試設定>15.7.5. 測試設定<a class=anchor href=#_測試設定></a></h4><div class=paragraph><p>First, ensure that the web server and Nagios will not be started on system initialization and reboot. Ensure that <code>root</code> cannot access any of the files in the Nagios configuration directory. If <code>root</code> can list the contents of <span class=filename>/var/spool/nagios</span>, something is wrong. Instead, a "permission denied" error should be returned.</p></div><div class=paragraph><p>If all seems well, Nagios, Apache, and Sendmail can now be started:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/mail &amp;&amp; make stop &amp;&amp; \</span>
setpmac biba/equal make start <span class=o>&amp;&amp;</span> setpmac biba/10<span class=se>\(</span>10-10<span class=se>\)</span> apachectl start <span class=o>&amp;&amp;</span> <span class=se>\</span>
setpmac biba/10<span class=se>\(</span>10-10<span class=se>\)</span> /usr/local/etc/rc.d/nagios.sh forcestart</code></pre></div></div><div class=paragraph><p>Double check to ensure that everything is working properly. If not, check the log files for error messages. If needed, use <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> to disable the <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> security policy module and try starting everything again as usual.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <code>root</code> user can still change the security enforcement and edit its configuration files. The following command will permit the degradation of the security policy to a lower grade for a newly spawned shell:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setpmac biba/10 csh</span></code></pre></div></div><div class=paragraph><p>To block this from happening, force the user into a range using <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>. If <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a> attempts to run a command outside of the compartment’s range, an error will be returned and the command will not be executed. In this case, set root to <code>biba/high(high-high)</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=mac-troubleshoot>15.8. MAC 架構疑難排解<a class=anchor href=#mac-troubleshoot></a></h3><div class=paragraph><p>This section discusses common configuration errors and how to resolve them.</p></div><div class=dlist><dl><dt class=hdlist1>The <code>multilabel</code> flag does not stay enabled on the root (<span class=filename>/</span>) partition</dt><dd><p>The following steps may resolve this transient error:</p></dd></dl></div><div class="exampleblock procedure"><div class=content><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Edit <span class=filename>/etc/fstab</span> and set the root partition to <code>ro</code> for read-only.</p></li><li><p>Reboot into single user mode.</p></li><li><p>Run <code>tunefs -l enable</code> on <span class=filename>/</span>.</p></li><li><p>Reboot the system.</p></li><li><p>Run <code>mount -urw</code><span class=filename>/</span> and change the <code>ro</code> back to <code>rw</code> in <span class=filename>/etc/fstab</span> and reboot the system again.</p></li><li><p>Double-check the output from <code>mount</code> to ensure that <code>multilabel</code> has been properly set on the root file system.</p></li></ol></div></div></div><div class=dlist><dl><dt class=hdlist1>After establishing a secure environment with MAC, Xorg no longer starts</dt><dd><p>This could be caused by the MAC <code>partition</code> policy or by a mislabeling in one of the MAC labeling policies. To debug, try the following:</p></dd></dl></div><div class="exampleblock procedure"><div class=content><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Check the error message. If the user is in the <code>insecure</code> class, the <code>partition</code> policy may be the culprit. Try setting the user’s class back to the <code>default</code> class and rebuild the database with <code>cap_mkdb</code>. If this does not alleviate the problem, go to step two.</p></li><li><p>Double-check that the label policies are set correctly for the user, Xorg, and the <span class=filename>/dev</span> entries.</p></li><li><p>If neither of these resolve the problem, send the error message and a description of the environment to the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>FreeBSD general questions mailing list</a>.</p></li></ol></div></div></div><div class=dlist><dl><dt class=hdlist1>The <code>_secure_path: unable to stat .login_conf</code> error appears</dt><dd><p>This error can appear when a user attempts to switch from the <code>root</code> user to another user in the system. This message usually occurs when the user has a higher label setting than that of the user they are attempting to become. For instance, if <code>joe</code> has a default label of <code>biba/low</code> and <code>root</code> has a label of <code>biba/high</code>, <code>root</code> cannot view <code>joe</code>'s home directory. This will happen whether or not <code>root</code> has used <code>su</code> to become <code>joe</code> as the Biba integrity model will not permit <code>root</code> to view objects set at a lower integrity level.</p></dd><dt class=hdlist1>The system no longer recognizes <code>root</code></dt><dd><p>When this occurs, <code>whoami</code> returns <code>0</code> and <code>su</code> returns <code>who are you?</code>.</p><div class=paragraph><p>This can happen if a labeling policy has been disabled by <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> or the policy module was unloaded. If the policy is disabled, the login capabilities database needs to be reconfigured. Double check <span class=filename>/etc/login.conf</span> to ensure that all <code>label</code> options have been removed and rebuild the database with <code>cap_mkdb</code>.</p></div><div class=paragraph><p>This may also happen if a policy restricts access to <span class=filename>master.passwd</span>. This is usually caused by an administrator altering the file under a label which conflicts with the general policy being used by the system. In these cases, the user information would be read by the system and access would be blocked as the file has inherited the new label. Disable the policy using <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> and everything should return to normal.</p></div></dd></dl></div></div></div></div><div class=sect1><h2 id=audit>Chapter 16. 安全事件稽查<a class=anchor href=#audit></a></h2><div class=sectionbody><div class=sect2><h3 id=audit-synopsis>16.1. 概述<a class=anchor href=#audit-synopsis></a></h3><div class=paragraph><p>The FreeBSD operating system includes support for security event auditing. Event auditing supports reliable, fine-grained, and configurable logging of a variety of security-relevant system events, including logins, configuration changes, and file and network access. These log records can be invaluable for live system monitoring, intrusion detection, and postmortem analysis. FreeBSD implements Sun™'s published Basic Security Module (BSM) Application Programming Interface (API) and file format, and is interoperable with the Solaris™ and Mac OS™ X audit implementations.</p></div><div class=paragraph><p>This chapter focuses on the installation and configuration of event auditing. It explains audit policies and provides an example audit configuration.</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>What event auditing is and how it works.</p></li><li><p>How to configure event auditing on FreeBSD for users and processes.</p></li><li><p>How to review the audit trail using the audit reduction and review tools.</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解 UNIX™ 及 FreeBSD 基礎 (<a href=./#basics>FreeBSD 基礎</a>)。</p></li><li><p>Be familiar with the basics of kernel configuration/compilation (<a href=./#kernelconfig>設定 FreeBSD 核心</a>).</p></li><li><p>Have some familiarity with security and how it pertains to FreeBSD (<a href=./#security>安全性</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>The audit facility has some known limitations. Not all security-relevant system events are auditable and some login mechanisms, such as Xorg-based display managers and third-party daemons, do not properly configure auditing for user login sessions.</p></div><div class=paragraph><p>The security event auditing facility is able to generate very detailed logs of system activity. On a busy system, trail file data can be very large when configured for high detail, exceeding gigabytes a week in some configurations. Administrators should take into account the disk space requirements associated with high volume audit configurations. For example, it may be desirable to dedicate a file system to <span class=filename>/var/audit</span> so that other file systems are not affected if the audit file system becomes full.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=audit-inline-glossary>16.2. 關鍵詞<a class=anchor href=#audit-inline-glossary></a></h3><div class=paragraph><p>The following terms are related to security event auditing:</p></div><div class=ulist><ul><li><p><em>event</em>: an auditable event is any event that can be logged using the audit subsystem. Examples of security-relevant events include the creation of a file, the building of a network connection, or a user logging in. Events are either "attributable", meaning that they can be traced to an authenticated user, or "non-attributable". Examples of non-attributable events are any events that occur before authentication in the login process, such as bad password attempts.</p></li><li><p><em>class</em>: a named set of related events which are used in selection expressions. Commonly used classes of events include "file creation" (fc), "exec" (ex), and "login_logout" (lo).</p></li><li><p><em>record</em>: an audit log entry describing a security event. Records contain a record event type, information on the subject (user) performing the action, date and time information, information on any objects or arguments, and a success or failure condition.</p></li><li><p><em>trail</em>: a log file consisting of a series of audit records describing security events. Trails are in roughly chronological order with respect to the time events completed. Only authorized processes are allowed to commit records to the audit trail.</p></li><li><p><em>selection expression</em>: a string containing a list of prefixes and audit event class names used to match events.</p></li><li><p><em>preselection</em>: the process by which the system identifies which events are of interest to the administrator. The preselection configuration uses a series of selection expressions to identify which classes of events to audit for which users, as well as global settings that apply to both authenticated and unauthenticated processes.</p></li><li><p><em>reduction</em>: the process by which records from existing audit trails are selected for preservation, printing, or analysis. Likewise, the process by which undesired audit records are removed from the audit trail. Using reduction, administrators can implement policies for the preservation of audit data. For example, detailed audit trails might be kept for one month, but after that, trails might be reduced in order to preserve only login information for archival purposes.</p></li></ul></div></div><div class=sect2><h3 id=audit-config>16.3. 稽查設定<a class=anchor href=#audit-config></a></h3><div class=paragraph><p>User space support for event auditing is installed as part of the base FreeBSD operating system. Kernel support is available in the <span class=filename>GENERIC</span> kernel by default, and <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> can be enabled by adding the following line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>auditd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then, start the audit daemon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service auditd start</span></code></pre></div></div><div class=paragraph><p>Users who prefer to compile a custom kernel must include the following line in their custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options	AUDIT</pre></div></div><div class=sect3><h4 id=_事件選擇表示法>16.3.1. 事件選擇表示法<a class=anchor href=#_事件選擇表示法></a></h4><div class=paragraph><p>Selection expressions are used in a number of places in the audit configuration to determine which events should be audited. Expressions contain a list of event classes to match. Selection expressions are evaluated from left to right, and two expressions are combined by appending one onto the other.</p></div><div class=paragraph><p><a href=#event-selection>預設稽查事件類別</a> summarizes the default audit event classes:</p></div><table id=event-selection class="tableblock frame-none grid-all stretch"><caption class=title>表 12. 預設稽查事件類別</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">類別名稱</th><th class="tableblock halign-left valign-top">說明</th><th class="tableblock halign-left valign-top">動作</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>all</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>all</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Match all event classes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>aa</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>authentication and authorization</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ad</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>administrative</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Administrative actions performed on the system as a whole.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ap</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>application</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Application defined action.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cl</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file close</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit calls to the <code>close</code> system call.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ex</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>exec</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit program execution. Auditing of command line arguments and environmental variables is controlled via <a href="https://man.freebsd.org/cgi/man.cgi?query=audit_control&amp;sektion=5&amp;format=html">audit_control(5)</a> using the <code>argv</code> and <code>envv</code> parameters to the <code>policy</code> setting.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fa</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file attribute access</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit the access of object attributes such as <a href="https://man.freebsd.org/cgi/man.cgi?query=stat&amp;sektion=1&amp;format=html">stat(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=pathconf&amp;sektion=2&amp;format=html">pathconf(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file create</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit events where a file is created as a result.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file delete</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit events where file deletion occurs.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file attribute modify</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit events where file attribute modification occurs, such as by <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=flock&amp;sektion=2&amp;format=html">flock(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fr</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file read</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit events in which data is read or files are opened for reading.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fw</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file write</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit events in which data is written or files are written or modified.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>io</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ioctl</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit use of the <code>ioctl</code> system call.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ip</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ipc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit various forms of Inter-Process Communication, including POSIX pipes and System V IPC operations.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lo</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>login_logout</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=logout&amp;sektion=1&amp;format=html">logout(1)</a> events.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>na</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>non attributable</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit non-attributable events.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>no</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>invalid class</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Match no audit events.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nt</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>network</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit events related to network actions such as <a href="https://man.freebsd.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;format=html">connect(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;format=html">accept(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>other</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit miscellaneous events.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>pc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>process</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit process operations such as <a href="https://man.freebsd.org/cgi/man.cgi?query=exec&amp;sektion=3&amp;format=html">exec(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=3&amp;format=html">exit(3)</a>.</p></td></tr></tbody></table><div class=paragraph><p>These audit event classes may be customized by modifying the <span class=filename>audit_class</span> and <span class=filename>audit_event</span> configuration files.</p></div><div class=paragraph><p>Each audit event class may be combined with a prefix indicating whether successful/failed operations are matched, and whether the entry is adding or removing matching for the class and type. <a href=#event-prefixes>稽查事件類別字首</a> summarizes the available prefixes:</p></div><table id=event-prefixes class="tableblock frame-none grid-all stretch"><caption class=title>表 13. 稽查事件類別字首</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">字首</th><th class="tableblock halign-left valign-top">動作</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit successful events in this class.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit failed events in this class.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit neither successful nor failed events in this class.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Do not audit successful events in this class.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Do not audit failed events in this class.</p></td></tr></tbody></table><div class=paragraph><p>If no prefix is present, both successful and failed instances of the event will be audited.</p></div><div class=paragraph><p>The following example selection string selects both successful and failed login/logout events, but only successful execution events:</p></div><div class="literalblock programlisting"><div class=content><pre>lo,+ex</pre></div></div></div><div class=sect3><h4 id=_設定檔>16.3.2. 設定檔<a class=anchor href=#_設定檔></a></h4><div class=paragraph><p>The following configuration files for security event auditing are found in <span class=filename>/etc/security</span>:</p></div><div class=ulist><ul><li><p><span class=filename>audit_class</span>: contains the definitions of the audit classes.</p></li><li><p><span class=filename>audit_control</span>: controls aspects of the audit subsystem, such as default audit classes, minimum disk space to leave on the audit log volume, and maximum audit trail size.</p></li><li><p><span class=filename>audit_event</span>: textual names and descriptions of system audit events and a list of which classes each event is in.</p></li><li><p><span class=filename>audit_user</span>: user-specific audit requirements to be combined with the global defaults at login.</p></li><li><p><span class=filename>audit_warn</span>: a customizable shell script used by <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> to generate warning messages in exceptional situations, such as when space for audit records is running low or when the audit trail file has been rotated.</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Audit configuration files should be edited and maintained carefully, as errors in configuration may result in improper logging of events.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In most cases, administrators will only need to modify <span class=filename>audit_control</span> and <span class=filename>audit_user</span>. The first file controls system-wide audit properties and policies and the second file may be used to fine-tune auditing by user.</p></div><div class=sect4><h5 id=audit-auditcontrol>16.3.2.1. The <span class=filename>audit_control</span> File<a class=anchor href=#audit-auditcontrol></a></h5><div class=paragraph><p>A number of defaults for the audit subsystem are specified in <span class=filename>audit_control</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dir:/var/audit
dist:off
flags:lo,aa
minfree:5
naflags:lo,aa
policy:cnt,argv
filesz:2M
expire-after:10M</pre></div></div><div class=paragraph><p>The <code>dir</code> entry is used to set one or more directories where audit logs will be stored. If more than one directory entry appears, they will be used in order as they fill. It is common to configure audit so that audit logs are stored on a dedicated file system, in order to prevent interference between the audit subsystem and other subsystems if the file system fills.</p></div><div class=paragraph><p>If the <code>dist</code> field is set to <code>on</code> or <code>yes</code>, hard links will be created to all trail files in <span class=filename>/var/audit/dist</span>.</p></div><div class=paragraph><p>The <code>flags</code> field sets the system-wide default preselection mask for attributable events. In the example above, successful and failed login/logout events as well as authentication and authorization are audited for all users.</p></div><div class=paragraph><p>The <code>minfree</code> entry defines the minimum percentage of free space for the file system where the audit trail is stored.</p></div><div class=paragraph><p>The <code>naflags</code> entry specifies audit classes to be audited for non-attributed events, such as the login/logout process and authentication and authorization.</p></div><div class=paragraph><p>The <code>policy</code> entry specifies a comma-separated list of policy flags controlling various aspects of audit behavior. The <code>cnt</code> indicates that the system should continue running despite an auditing failure (this flag is highly recommended). The other flag, <code>argv</code>, causes command line arguments to the <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> system call to be audited as part of command execution.</p></div><div class=paragraph><p>The <code>filesz</code> entry specifies the maximum size for an audit trail before automatically terminating and rotating the trail file. A value of <code>0</code> disables automatic log rotation. If the requested file size is below the minimum of 512k, it will be ignored and a log message will be generated.</p></div><div class=paragraph><p>The <code>expire-after</code> field specifies when audit log files will expire and be removed.</p></div></div><div class=sect4><h5 id=audit-audituser>16.3.2.2. The <span class=filename>audit_user</span> File<a class=anchor href=#audit-audituser></a></h5><div class=paragraph><p>The administrator can specify further audit requirements for specific users in <span class=filename>audit_user</span>. Each line configures auditing for a user via two fields: the <code>alwaysaudit</code> field specifies a set of events that should always be audited for the user, and the <code>neveraudit</code> field specifies a set of events that should never be audited for the user.</p></div><div class=paragraph><p>The following example entries audit login/logout events and successful command execution for <code>root</code> and file creation and successful command execution for <code>www</code>. If used with the default <span class=filename>audit_control</span>, the <code>lo</code> entry for <code>root</code> is redundant, and login/logout events will also be audited for <code>www</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>root:lo,+ex:no
www:fc,+ex:no</pre></div></div></div></div></div><div class=sect2><h3 id=audit-administration>16.4. 查看稽查線索<a class=anchor href=#audit-administration></a></h3><div class=paragraph><p>Since audit trails are stored in the BSM binary format, several built-in tools are available to modify or convert these trails to text. To convert trail files to a simple text format, use <code>praudit</code>. To reduce the audit trail file for analysis, archiving, or printing purposes, use <code>auditreduce</code>. This utility supports a variety of selection parameters, including event type, event class, user, date or time of the event, and the file path or object acted on.</p></div><div class=paragraph><p>For example, to dump the entire contents of a specified audit log in plain text:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># praudit /var/audit/AUDITFILE</span></code></pre></div></div><div class=paragraph><p>Where <em>AUDITFILE</em> is the audit log to dump.</p></div><div class=paragraph><p>Audit trails consist of a series of audit records made up of tokens, which <code>praudit</code> prints sequentially, one per line. Each token is of a specific type, such as <code>header</code> (an audit record header) or <code>path</code> (a file path from a name lookup). The following is an example of an <code>execve</code> event:</p></div><div class="literalblock programlisting"><div class=content><pre>header,133,10,execve(2),0,Mon Sep 25 15:58:03 2006, + 384 msec
exec arg,finger,doug
path,/usr/bin/finger
attribute,555,root,wheel,90,24918,104944
subject,robert,root,wheel,root,wheel,38439,38032,42086,128.232.9.100
return,success,0
trailer,133</pre></div></div><div class=paragraph><p>This audit represents a successful <code>execve</code> call, in which the command <code>finger doug</code> has been run. The <code>exec arg</code> token contains the processed command line presented by the shell to the kernel. The <code>path</code> token holds the path to the executable as looked up by the kernel. The <code>attribute</code> token describes the binary and includes the file mode. The <code>subject</code> token stores the audit user ID, effective user ID and group ID, real user ID and group ID, process ID, session ID, port ID, and login address. Notice that the audit user ID and real user ID differ as the user <code>robert</code> switched to the <code>root</code> account before running this command, but it is audited using the original authenticated user. The <code>return</code> token indicates the successful execution and the <code>trailer</code> concludes the record.</p></div><div class=paragraph><p>XML output format is also supported and can be selected by including <code>-x</code>.</p></div><div class=paragraph><p>Since audit logs may be very large, a subset of records can be selected using <code>auditreduce</code>. This example selects all audit records produced for the user <code>trhodes</code> stored in <span class=filename>AUDITFILE</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># auditreduce -u trhodes /var/audit/AUDITFILE | praudit</span></code></pre></div></div><div class=paragraph><p>Members of the <code>audit</code> group have permission to read audit trails in <span class=filename>/var/audit</span>. By default, this group is empty, so only the <code>root</code> user can read audit trails. Users may be added to the <code>audit</code> group in order to delegate audit review rights. As the ability to track audit log contents provides significant insight into the behavior of users and processes, it is recommended that the delegation of audit review rights be performed with caution.</p></div><div class=sect3><h4 id=_使用_audit_pipes_即時監視>16.4.1. 使用 Audit Pipes 即時監視<a class=anchor href=#_使用_audit_pipes_即時監視></a></h4><div class=paragraph><p>Audit pipes are cloning pseudo-devices which allow applications to tap the live audit record stream. This is primarily of interest to authors of intrusion detection and system monitoring applications. However, the audit pipe device is a convenient way for the administrator to allow live monitoring without running into problems with audit trail file ownership or log rotation interrupting the event stream. To track the live audit event stream:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># praudit /dev/auditpipe</span></code></pre></div></div><div class=paragraph><p>By default, audit pipe device nodes are accessible only to the <code>root</code> user. To make them accessible to the members of the <code>audit</code> group, add a <code>devfs</code> rule to <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;auditpipe*&#39; mode 0440 group audit</pre></div></div><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> for more information on configuring the devfs file system.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>It is easy to produce audit event feedback cycles, in which the viewing of each audit event results in the generation of more audit events. For example, if all network I/O is audited, and <code>praudit</code> is run from an SSH session, a continuous stream of audit events will be generated at a high rate, as each event being printed will generate another event. For this reason, it is advisable to run <code>praudit</code> on an audit pipe device from sessions without fine-grained I/O auditing.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_翻轉與壓縮_audit_trail_檔>16.4.2. 翻轉與壓縮 Audit Trail 檔<a class=anchor href=#_翻轉與壓縮_audit_trail_檔></a></h4><div class=paragraph><p>Audit trails are written to by the kernel and managed by the audit daemon, <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a>. Administrators should not attempt to use <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> or other tools to directly rotate audit logs. Instead, <code>audit</code> should be used to shut down auditing, reconfigure the audit system, and perform log rotation. The following command causes the audit daemon to create a new audit log and signal the kernel to switch to using the new log. The old log will be terminated and renamed, at which point it may then be manipulated by the administrator:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># audit -n</span></code></pre></div></div><div class=paragraph><p>If <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> is not currently running, this command will fail and an error message will be produced.</p></div><div class=paragraph><p>Adding the following line to <span class=filename>/etc/crontab</span> will schedule this rotation every twelve hours:</p></div><div class="literalblock programlisting"><div class=content><pre>0     */12       *       *       *       root    /usr/sbin/audit -n</pre></div></div><div class=paragraph><p>The change will take effect once <span class=filename>/etc/crontab</span> is saved.</p></div><div class=paragraph><p>Automatic rotation of the audit trail file based on file size is possible using <code>filesz</code> in <span class=filename>audit_control</span> as described in <a href=#audit-auditcontrol>The <span class=filename>audit_control</span> File</a>.</p></div><div class=paragraph><p>As audit trail files can become very large, it is often desirable to compress or otherwise archive trails once they have been closed by the audit daemon. The <span class=filename>audit_warn</span> script can be used to perform customized operations for a variety of audit-related events, including the clean termination of audit trails when they are rotated. For example, the following may be added to <span class=filename>/etc/security/audit_warn</span> to compress audit trails on close:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Compress audit trail files on close.
#
if [ &#34;$1&#34; = closefile ]; then
        gzip -9 $2
fi</pre></div></div><div class=paragraph><p>Other archiving activities might include copying trail files to a centralized server, deleting old trail files, or reducing the audit trail to remove unneeded records. This script will be run only when audit trail files are cleanly terminated, so will not be run on trails left unterminated following an improper shutdown.</p></div></div></div></div></div><div class=sect1><h2 id=disks>Chapter 17. 儲存設備<a class=anchor href=#disks></a></h2><div class=sectionbody><div class=sect2><h3 id=disks-synopsis>17.1. 概述<a class=anchor href=#disks-synopsis></a></h3><div class=paragraph><p>本章涵蓋如何在 FreeBSD 下使用磁碟及儲存媒體，這包含 SCSI 及 IDE 磁碟、CD 及 DVD 媒體、記憶體磁碟及 USB 儲存裝置。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>如何在 FreeBSD 系統加入額外的硬碟。</p></li><li><p>如何在 FreeBSD 擴增磁碟分割區的大小。</p></li><li><p>如何設定 FreeBSD 使用 USB 儲存裝置。</p></li><li><p>如何在 FreeBSD 系統使用 CD 及 DVD 媒體。</p></li><li><p>如何使用在 FreeBSD 下可用的備份程式。</p></li><li><p>如何設定記憶體磁碟。</p></li><li><p>什麼是檔案系統快照 (Snapshot) 以及如何有效使用。</p></li><li><p>如何使用配額 (Quota) 來限制磁碟空間使用量。</p></li><li><p>如何加密磁碟及交換空間來防範攻擊者。</p></li><li><p>如何設定高可用性 (Highly available) 的儲存網路。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解如何 <a href=./#kernelconfig>設定並安裝新的 FreeBSD 核心</a>。</p></li></ul></div></div><div class=sect2><h3 id=disks-adding>17.2. 加入磁碟<a class=anchor href=#disks-adding></a></h3><div class=paragraph><p>本節將說明如何加入新的 SATA 磁碟到目前只有一個磁碟的機器上。 首先要關閉電腦並依照電腦、控制器及磁碟製造商的操作指南將磁碟安裝到電腦。重新啟動系統並登入 <code>root</code>。</p></div><div class=paragraph><p>查看 <span class=filename>/var/run/dmesg.boot</span> 來確認已經找到新的磁碟。在本例中，會以 <span class=filename>ada1</span> 代表新加入的 SATA 磁碟。</p></div><div class=paragraph><p>在本例中，會在新的磁碟上建立單一大型分割區，使用 <a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>GPT</a> 分割表格式而非較舊與通用性較差的 MBR 結構。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若新加入的磁碟不是空白的，可以使用 <code>gpart delete</code> 來移除舊的分割區資訊。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 取得詳細資訊。</p></div></td></tr></tbody></table></div><div class=paragraph><p>建立完分割表格式後接著加入一個分割區，要在新的磁碟增進效能可使用較大的硬體區塊大小 (Block size)，此分割區會對齊 1 MB 的邊界：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT ada1</span>
<span class=c># gpart add -t freebsd-ufs -a 1M ada1</span></code></pre></div></div><div class=paragraph><p>依據使用情況，也可以使用較小的分割區。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 來取得建立較小分割區的選項。</p></div><div class=paragraph><p>磁碟分割區資訊可以使用 <code>gpart show</code> 檢視：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gpart show ada1
<span class=o>=&gt;</span>        34  1465146988  ada1  GPT  <span class=o>(</span>699G<span class=o>)</span>
          34        2014        - free -  <span class=o>(</span>1.0M<span class=o>)</span>
        2048  1465143296     1  freebsd-ufs  <span class=o>(</span>699G<span class=o>)</span>
  1465145344        1678        - free -  <span class=o>(</span>839K<span class=o>)</span></code></pre></div></div><div class=paragraph><p>在新磁碟的新分割區上建立檔案系統：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/ada1p1</span></code></pre></div></div><div class=paragraph><p>建立一個空的目錄做來做為<em>掛載點 (mountpoint)</em>，一個在原有磁碟的檔案系統上可用來掛載新磁碟的位置：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /newdisk</span></code></pre></div></div><div class=paragraph><p>最後，將磁碟項目加入到 <span class=filename>/etc/fstab</span>，讓啟動時會自動掛載新的磁碟：</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1p1	/newdisk	ufs	rw	2	2</pre></div></div><div class=paragraph><p>新的磁碟也可手動掛載，無須重新啟動系統：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /newdisk</span></code></pre></div></div></div><div class=sect2><h3 id=disks-growing>17.3. 重設大小與擴增磁碟<a class=anchor href=#disks-growing></a></h3><div class=paragraph><p>磁碟的容量可以增加且不需要更動任何已存在的資料。這時常會用在虛擬機器，當虛擬磁碟太小且需要增加時。有時磁碟映像檔會被寫入到 USB 隨身碟，但卻沒有使用全部的容量。此節我們將說明如合重設大小或 <em>擴增</em> 磁碟內容來使用增加的容量。</p></div><div class=paragraph><p>要取得要重設大小的磁碟的代號可以查看 <span class=filename>/var/run/dmesg.boot</span>。在本例中，在系統上只有一個 SATA 磁碟，該磁碟會以 <span class=filename>ada0</span> 表示。</p></div><div class=paragraph><p>列出在磁碟上的分割區來查看目前的設定：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>      34  83886013  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span> <span class=o>[</span>CORRUPT]
        34       128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
       162  79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
  79691810   4194236     3  freebsd-swap  <span class=o>(</span>2G<span class=o>)</span>
  83886046         1        - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若磁碟已使用 <a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>GPT</a> 分割表格式做格式化，可能會顯示為 "已損壞 (corrupted)" 因為 GPT 備份分割區已不存在於磁碟結尾。 使用 <code>gpart</code> 來修正備份分割區：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart recover ada0</span>
ada0 recovered</code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>現在在磁碟上的額外空間已經可以被新的分割區使用，或者可以拿來擴充既有的分割區：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
   79691810    4194236     3  freebsd-swap  <span class=o>(</span>2G<span class=o>)</span>
   83886046   18513921        - free -  <span class=o>(</span>8.8G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>分割區只能在連續的未使用空間上重設大小。在這個例子中，磁碟上最後的分割區為交換 (Swap) 分割區，而第二個分割區才是需要重設大小的分割區。由於交換分割區中只會有暫存的資料，所以此時可以安全的卸載、刪除，然後在重設第二個分割區大小之後再重建最後一個分割區。</p></div><div class=paragraph><p>停用交換分割區：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapoff /dev/ada0p3</span></code></pre></div></div><div class=paragraph><p>刪除 <em>ada0</em> 磁碟上的第三個分割區，可使用 <code>-i</code> 參數來指定分割區。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart delete -i 3 ada0</span>
ada0p3 deleted
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
   79691810   22708157        - free -  <span class=o>(</span>10G<span class=o>)</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>在掛載的檔案系統上修改分割區表可能會造成資料遺失。最好的方式是在未掛載檔案系統的情況下 (使用 Live CD-ROM 或 USB 裝置) 執行以下步驟。雖然如此，若仍要這樣做的話，在關閉 GEOM 安全性功能之後可以在掛載的檔案系統上修改分割區表：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.debugflags=16</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>重設分割區大小並保留要用來重建交換分割區的空間，要重設大小的分割區可以用 <code>-i</code> 來指定，而要重設的大小可用 <code>-s</code> 來指定，若要對齊分割區可以使用 <code>-a</code>。這個動作只會修改分割區大小，分割區中的檔案系統需在另一個步驟擴增。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart resize -i 2 -s 47G -a 4k ada0</span>
ada0p2 resized
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   98566144     2  freebsd-ufs  <span class=o>(</span>47G<span class=o>)</span>
   98566306    3833661        - free -  <span class=o>(</span>1.8G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>重建交換分割區並且啟動，若不使用 <code>-s</code> 指定大小則會使用所有剩餘的空間：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart add -t freebsd-swap -a 4k ada0</span>
ada0p3 added
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   98566144     2  freebsd-ufs  <span class=o>(</span>47G<span class=o>)</span>
   98566306    3833661     3  freebsd-swap  <span class=o>(</span>1.8G<span class=o>)</span>
<span class=c># swapon /dev/ada0p3</span></code></pre></div></div><div class=paragraph><p>擴增 UFS 檔案系統來使用重設分割區大小之後的新容量：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growfs /dev/ada0p2</span>
Device is mounted read-write<span class=p>;</span> resizing will result <span class=k>in </span>temporary write suspension <span class=k>for</span> /.
It<span class=s1>&#39;s strongly recommended to make a backup before growing the file system.
OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes
super-block backups (for fsck -b #) at:
 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432</span></code></pre></div></div><div class=paragraph><p>若檔案系統使用 ZFS，重設大小需執行 <code>online</code> 子指令並使用 <code>-e</code> 來觸發動作：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool online -e zroot /dev/ada0p2</span></code></pre></div></div><div class=paragraph><p>現在分割區與檔案系統已透過重設大小來使用新增加的磁碟空間。</p></div></div><div class=sect2><h3 id=usb-disks>17.4. USB 儲存裝置<a class=anchor href=#usb-disks></a></h3><div class=paragraph><p>許多外部儲存裝置的解決方案，例如硬碟、USB 隨身碟及 CD 與 DVD 燒錄機皆使用通用序列匯流排 (Universal Serial Bus, USB)，FreeBSD 提供了對 USB 1.x, 2.0 及 3.0 裝置的支援。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>部份硬體尚不相容 USB 3.0，包含 Haswell (Lynx point) 晶片組，若 FreeBSD 開機出現 <code>failed with error 19</code> 訊息，請在系統 BIOS 關閉 xHCI/USB3。</p></div></td></tr></tbody></table></div><div class=paragraph><p>對 USB 儲存裝置的支援已內建於 <span class=filename>GENERIC</span> 核心，若為自訂的核心，請確定在核心設定檔中有下列幾行設定：</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da
device cd	# needed for CD and DVD burners</pre></div></div><div class=paragraph><p>FreeBSD 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a> 驅動程式透過 SCSI 子系統來存取 USB 儲存裝置，因此任何在系統的 USB 裝置都會以 SCSI 裝置呈現，若 USB 裝置是 CD 或 DVD 燒錄機，請<em>不要</em>在自訂核心設定檔中引用 <code>device atapicam</code>。</p></div><div class=paragraph><p>本節後續的部份將示範如何檢查 FreeBSD 能夠辦識 USB 儲存裝置以及如何設定該裝置。</p></div><div class=sect3><h4 id=_裝置設定>17.4.1. 裝置設定<a class=anchor href=#_裝置設定></a></h4><div class=paragraph><p>要測試 USB 設定，請先插入 USB 裝置，然後使用 <code>dmesg</code> 來確認系統訊息緩衝區中有出現該磁碟機，該訊息如下：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: &lt;STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3&gt; on usbus0
umass0:  SCSI over Bulk-Only<span class=p>;</span> quirks <span class=o>=</span> 0x0100
umass0:4:0:-1: Attached to scbus4
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; Fixed Direct Access SCSI-4 device
da0: Serial Number WD-WXE508CAN263
da0: 40.000MB/s transfers
da0: 152627MB <span class=o>(</span>312581808 512 byte sectors: 255H 63S/T 19457C<span class=o>)</span>
da0: <span class=nv>quirks</span><span class=o>=</span>0x2&lt;NO_6_BYTE&gt;</code></pre></div></div><div class=paragraph><p>不同的裝置會有不同的廠牌、裝置節點 (<span class=filename>da0</span>)、速度與大小。</p></div><div class=paragraph><p>當 USB 裝置可以做為 SCSI 檢視時，便可使用 <code>camcontrol</code> 來列出連接到系統的 USB 儲存裝置：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;STECH Simple Drive 1.04&gt;          at scbus4 target 0 lun 0 <span class=o>(</span>pass3,da0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>或者，可以使用 <code>usbconfig</code> 來列出裝置，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a> 來取得更多有關此指令的資訊。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># usbconfig</span>
ugen0.3: &lt;Simple Drive STECH&gt; at usbus0, <span class=nv>cfg</span><span class=o>=</span>0 <span class=nv>md</span><span class=o>=</span>HOST <span class=nv>spd</span><span class=o>=</span>HIGH <span class=o>(</span>480Mbps<span class=o>)</span> <span class=nv>pwr</span><span class=o>=</span>ON <span class=o>(</span>2mA<span class=o>)</span></code></pre></div></div><div class=paragraph><p>若該裝置尚未被格式化，請參考 <a href=#disks-adding>加入磁碟</a> 中有關如何在 USB 磁碟格式化與建立分割區的說明。若磁碟中有檔案系統，可由 <code>root</code> 依據 <a href=./#mount-unmount>掛載與卸載檔案系統</a> 中的說明掛載磁碟。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>要允許未被信任的使用者掛載任意媒體，可開啟 <code>vfs.usermount</code>，詳細說明如下。從安全性的角度來看這並不是安全的，大多的檔案系統並不會防範惡意裝置。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要讓裝置可讓一般使用者掛載，其中一個解決方案便是使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 讓所有裝置的使用者成為 <code>operator</code> 群組的成員。接著，將下列幾行加入 <span class=filename>/etc/devfs.rules</span> 來確保 <code>operator</code> 能夠讀取與寫入裝置：</p></div><div class="literalblock programlisting"><div class=content><pre>[localrules=5]
add path &#39;da*&#39; mode 0660 group operator</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若系統也同時安裝了內建 SCSI 磁碟，請更改第二行如下：</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;da[3-9]*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>這會從 <code>operator</code> 群組中排除前三個 SCSI 磁碟 (<span class=filename>da0</span> 到 <span class=filename>da2</span>)，接著取代 <em>3</em> 為內部 SCSI 磁碟的編號。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> 來取得更多有關此檔案的資訊。</p></div></td></tr></tbody></table></div><div class=paragraph><p>接著，在 <span class=filename>/etc/rc.conf</span> 開啟規則：</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;localrules&#34;</pre></div></div><div class=paragraph><p>然後，加入以下行到 <span class=filename>/etc/sysctl.conf</span> 指示系統允許正常使用者掛載檔案系統：</p></div><div class="literalblock programlisting"><div class=content><pre>vfs.usermount=1</pre></div></div><div class=paragraph><p>這樣只會在下次重新開機時生效，可使用 <code>sysctl</code> 來立即設定這個變數：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1</code></pre></div></div><div class=paragraph><p>最後一個步驟是建立要掛載檔案系統要的目錄，要掛載檔案系統的使用者需要擁有這個目錄。其中一個辦法是讓 <code>root</code> 建立由該使用者擁有的子目錄 <span class=filename>/mnt/username</span>。在下面的例子，將 <em>username</em> 替換為該使用者的登入名稱並將 <em>usergroup</em> 替換為該使用者的主要群組：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /mnt/username</span>
<span class=c># chown username:usergroup /mnt/username</span></code></pre></div></div><div class=paragraph><p>假如已經插入 USB 隨身碟，且已出現 <span class=filename>/dev/da0s1</span> 裝置。若裝置使用 FAT 格式的檔案系統，則使用者可使用以下指令掛載該檔案系統：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mount <span class=nt>-t</span> msdosfs <span class=nt>-o</span> <span class=nt>-m</span><span class=o>=</span>644,-M<span class=o>=</span>755 /dev/da0s1 /mnt/username</code></pre></div></div><div class=paragraph><p>在裝置可以被拔除前，<em>必須</em>先卸載：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% umount /mnt/username</code></pre></div></div><div class=paragraph><p>裝置移除之後，系統訊息緩衝區會顯示如下的訊息：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: at uhub3, port 2, addr 3 <span class=o>(</span>disconnected<span class=o>)</span>
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; s/n WD-WXE508CAN263          detached
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: Periph destroyed</code></pre></div></div></div><div class=sect3><h4 id=_自動掛載可移除的媒體>17.4.2. 自動掛載可移除的媒體<a class=anchor href=#_自動掛載可移除的媒體></a></h4><div class=paragraph><p>可以取消註解在 <span class=filename>/etc/auto_master</span> 中的下行來自動掛載 USB 裝置：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/media		<span class=nt>-media</span>		<span class=nt>-nosuid</span></code></pre></div></div><div class=paragraph><p>然後加入這些行到 <span class=filename>/etc/devd.conf</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>notify 100 <span class=o>{</span>
	match <span class=s2>&#34;system&#34;</span> <span class=s2>&#34;GEOM&#34;</span><span class=p>;</span>
	match <span class=s2>&#34;subsystem&#34;</span> <span class=s2>&#34;DEV&#34;</span><span class=p>;</span>
	action <span class=s2>&#34;/usr/sbin/automount -c&#34;</span><span class=p>;</span>
<span class=o>}</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>若 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> 已經正在執行，則需重新載入設定：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount restart</span>
<span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p>要設定讓 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 在開機時啟動可以加入此行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>autofs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 需要開啟 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>，預設已經開啟。</p></div><div class=paragraph><p>立即啟動服務：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount start</span>
<span class=c># service automountd start</span>
<span class=c># service autounmountd start</span>
<span class=c># service devd start</span></code></pre></div></div><div class=paragraph><p>可以被自動掛載的檔案系統會在 <span class=filename>/media/</span> 中以目錄呈現，會以檔案系統的標籤來命名目錄，若標籤遺失，則會以裝置節點命名。</p></div><div class=paragraph><p>檔案系統會在第一次存取時自動掛載，並在一段時間未使用後自動卸載。自動掛載的磁碟也可手動卸載：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># automount -fu</span></code></pre></div></div><div class=paragraph><p>這個機制一般會用在記憶卡與 USB 隨身碟，也可用在任何 Block 裝置，包含光碟機或 iSCSILUN。</p></div></div></div><div class=sect2><h3 id=creating-cds>17.5. 建立與使用 CD 媒體<a class=anchor href=#creating-cds></a></h3><div class=paragraph><p>Compact Disc (CD) media provide a number of features that differentiate them from conventional disks. They are designed so that they can be read continuously without delays to move the head between tracks. While CD media do have tracks, these refer to a section of data to be read continuously, and not a physical property of the disk. The ISO 9660 file system was designed to deal with these differences.</p></div><div class=paragraph><p>The FreeBSD Ports Collection provides several utilities for burning and duplicating audio and data CDs. This chapter demonstrates the use of several command line utilities. For CD burning software with a graphical utility, consider installing the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xcdroast/>sysutils/xcdroast</a> or <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a> packages or ports.</p></div><div class=sect3><h4 id=atapicam>17.5.1. 支援的裝置<a class=anchor href=#atapicam></a></h4><div class=paragraph><p>The <span class=filename>GENERIC</span> kernel provides support for SCSI, USB, and ATAPICD readers and burners. If a custom kernel is used, the options that need to be present in the kernel configuration file vary by the type of device.</p></div><div class=paragraph><p>For a SCSI burner, make sure these options are present:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners</pre></div></div><div class=paragraph><p>For a USB burner, make sure these options are present:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da</pre></div></div><div class=paragraph><p>For an ATAPI burner, make sure these options are present:</p></div><div class="literalblock programlisting"><div class=content><pre>device ata	# Legacy ATA/SATA controllers
device scbus	# SCSI bus (required for ATA/SCSI)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>On FreeBSD versions prior to 10.x, this line is also needed in the kernel configuration file if the burner is an ATAPI device:</p></div><div class="literalblock programlisting"><div class=content><pre>device atapicam</pre></div></div><div class=paragraph><p>Alternately, this driver can be loaded at boot time by adding the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>atapicam_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>This will require a reboot of the system as this driver can only be loaded at boot time.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To verify that FreeBSD recognizes the device, run <code>dmesg</code> and look for an entry for the device. On systems prior to 10.x, the device name in the first line of the output will be <span class=filename>acd0</span> instead of <span class=filename>cd0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% dmesg | <span class=nb>grep cd
</span>cd0 at ahcich1 bus 0 scbus1 target 0 lun 0
cd0: &lt;HL-DT-ST DVDRAM GU70N LT20&gt; Removable CD-ROM SCSI-0 device
cd0: Serial Number M3OD3S34152
cd0: 150.000MB/s transfers <span class=o>(</span>SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes<span class=o>)</span>
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</code></pre></div></div></div><div class=sect3><h4 id=cdrecord>17.5.2. 燒錄 CD<a class=anchor href=#cdrecord></a></h4><div class=paragraph><p>In FreeBSD, <code>cdrecord</code> can be used to burn CDs. This command is installed with the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> package or port.</p></div><div class=paragraph><p>While <code>cdrecord</code> has many options, basic usage is simple. Specify the name of the ISO file to burn and, if the system has multiple burner devices, specify the name of the device to use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord dev=device imagefile.iso</span></code></pre></div></div><div class=paragraph><p>To determine the device name of the burner, use <code>-scanbus</code> which might produce results like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord -scanbus</span>
ProDVD-ProBD-Clone 3.00 <span class=o>(</span>amd64-unknown-freebsd10.0<span class=o>)</span> Copyright <span class=o>(</span>C<span class=o>)</span> 1995-2010 Jörg Schilling
Using libscg version <span class=s1>&#39;schily-0.9&#39;</span>
scsibus0:
        0,0,0     0<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39236LW       &#39;</span> <span class=s1>&#39;0004&#39;</span> Disk
        0,1,0     1<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39173W        &#39;</span> <span class=s1>&#39;5958&#39;</span> Disk
        0,2,0     2<span class=o>)</span> <span class=k>*</span>
        0,3,0     3<span class=o>)</span> <span class=s1>&#39;iomega  &#39;</span> <span class=s1>&#39;jaz 1GB         &#39;</span> <span class=s1>&#39;J.86&#39;</span> Removable Disk
        0,4,0     4<span class=o>)</span> <span class=s1>&#39;NEC     &#39;</span> <span class=s1>&#39;CD-ROM DRIVE:466&#39;</span> <span class=s1>&#39;1.26&#39;</span> Removable CD-ROM
        0,5,0     5<span class=o>)</span> <span class=k>*</span>
        0,6,0     6<span class=o>)</span> <span class=k>*</span>
        0,7,0     7<span class=o>)</span> <span class=k>*</span>
scsibus1:
        1,0,0   100<span class=o>)</span> <span class=k>*</span>
        1,1,0   101<span class=o>)</span> <span class=k>*</span>
        1,2,0   102<span class=o>)</span> <span class=k>*</span>
        1,3,0   103<span class=o>)</span> <span class=k>*</span>
        1,4,0   104<span class=o>)</span> <span class=k>*</span>
        1,5,0   105<span class=o>)</span> <span class=s1>&#39;YAMAHA  &#39;</span> <span class=s1>&#39;CRW4260         &#39;</span> <span class=s1>&#39;1.0q&#39;</span> Removable CD-ROM
        1,6,0   106<span class=o>)</span> <span class=s1>&#39;ARTEC   &#39;</span> <span class=s1>&#39;AM12S           &#39;</span> <span class=s1>&#39;1.06&#39;</span> Scanner
        1,7,0   107<span class=o>)</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>Locate the entry for the CD burner and use the three numbers separated by commas as the value for <code>dev</code>. In this case, the Yamaha burner device is <code>1,5,0</code>, so the appropriate input to specify that device is <code>dev=1,5,0</code>. Refer to the manual page for <code>cdrecord</code> for other ways to specify this value and for information on writing audio tracks and controlling the write speed.</p></div><div class=paragraph><p>Alternately, run the following command to get the device address of the burner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 <span class=o>(</span>cd0,pass0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Use the numeric values for <code>scbus</code>, <code>target</code>, and <code>lun</code>. For this example, <code>1,0,0</code> is the device name to use.</p></div></div><div class=sect3><h4 id=mkisofs>17.5.3. 寫入資料到一個 ISO 檔案系統<a class=anchor href=#mkisofs></a></h4><div class=paragraph><p>In order to produce a data CD, the data files that are going to make up the tracks on the CD must be prepared before they can be burned to the CD. In FreeBSD, <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> installs <code>mkisofs</code>, which can be used to produce an ISO 9660 file system that is an image of a directory tree within a UNIX™ file system. The simplest usage is to specify the name of the ISO file to create and the path to the files to place into the ISO 9660 file system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -o imagefile.iso /path/to/tree</span></code></pre></div></div><div class=paragraph><p>This command maps the file names in the specified path to names that fit the limitations of the standard ISO 9660 file system, and will exclude files that do not meet the standard for ISO file systems.</p></div><div class=paragraph><p>A number of options are available to overcome the restrictions imposed by the standard. In particular, <code>-R</code> enables the Rock Ridge extensions common to UNIX™ systems and <code>-J</code> enables Joliet extensions used by Microsoft™ systems.</p></div><div class=paragraph><p>For CDs that are going to be used only on FreeBSD systems, <code>-U</code> can be used to disable all filename restrictions. When used with <code>-R</code>, it produces a file system image that is identical to the specified FreeBSD tree, even if it violates the ISO 9660 standard.</p></div><div class=paragraph><p>The last option of general use is <code>-b</code>. This is used to specify the location of a boot image for use in producing an "El Torito" bootable CD. This option takes an argument which is the path to a boot image from the top of the tree being written to the CD. By default, <code>mkisofs</code> creates an ISO image in "floppy disk emulation" mode, and thus expects the boot image to be exactly 1200, 1440 or 2880 KB in size. Some boot loaders, like the one used by the FreeBSD distribution media, do not use emulation mode. In this case, <code>-no-emul-boot</code> should be used. So, if <span class=filename>/tmp/myboot</span> holds a bootable FreeBSD system with the boot image in <span class=filename>/tmp/myboot/boot/cdboot</span>, this command would produce <span class=filename>/tmp/bootable.iso</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</span></code></pre></div></div><div class=paragraph><p>The resulting ISO image can be mounted as a memory disk with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>One can then verify that <span class=filename>/mnt</span> and <span class=filename>/tmp/myboot</span> are identical.</p></div><div class=paragraph><p>There are many other options available for <code>mkisofs</code> to fine-tune its behavior. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> for details.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is possible to copy a data CD to an image file that is functionally equivalent to the image file created with <code>mkisofs</code>. To do so, use <span class=filename>dd</span> with the device name as the input file and the name of the ISO to create as the output file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/cd0 of=file.iso bs=2048</span></code></pre></div></div><div class=paragraph><p>The resulting image file can be burned to CD as described in <a href=#cdrecord>燒錄 CD</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mounting-cd>17.5.4. 使用資料 CD<a class=anchor href=#mounting-cd></a></h4><div class=paragraph><p>Once an ISO has been burned to a CD, it can be mounted by specifying the file system type, the name of the device containing the CD, and an existing mount point:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Since <code>mount</code> assumes that a file system is of type <code>ufs</code>, a <code>Incorrect super block</code> error will occur if <code>-t cd9660</code> is not included when mounting a data CD.</p></div><div class=paragraph><p>While any data CD can be mounted this way, disks with certain ISO 9660 extensions might behave oddly. For example, Joliet disks store all filenames in two-byte Unicode characters. If some non-English characters show up as question marks, specify the local charset with <code>-C</code>. For more information, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In order to do this character conversion with the help of <code>-C</code>, the kernel requires the <span class=filename>cd9660_iconv.ko</span> module to be loaded. This can be done either by adding this line to <span class=filename>loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cd9660_iconv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>and then rebooting the machine, or by directly loading the module with <code>kldload</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Occasionally, <code>Device not configured</code> will be displayed when trying to mount a data CD. This usually means that the CD drive has not detected a disk in the tray, or that the drive is not visible on the bus. It can take a couple of seconds for a CD drive to detect media, so be patient.</p></div><div class=paragraph><p>Sometimes, a SCSICD drive may be missed because it did not have enough time to answer the bus reset. To resolve this, a custom kernel can be created which increases the default SCSI delay. Add the following option to the custom kernel configuration file and rebuild the kernel using the instructions in <a href=./#kernelconfig-building>編譯與安裝自訂核心</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options SCSI_DELAY=15000</pre></div></div><div class=paragraph><p>This tells the SCSI bus to pause 15 seconds during boot, to give the CD drive every possible chance to answer the bus reset.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is possible to burn a file directly to CD, without creating an ISO 9660 file system. This is known as burning a raw data CD and some people do this for backup purposes.</p></div><div class=paragraph><p>This type of disk can not be mounted as a normal data CD. In order to retrieve the data burned to such a CD, the data must be read from the raw device node. For example, this command will extract a compressed tar file located on the second CD device into the current working directory:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /dev/cd1</span></code></pre></div></div><div class=paragraph><p>In order to mount a data CD, the data must be written using <code>mkisofs</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=duplicating-audiocds>17.5.5. 複製音樂 CD<a class=anchor href=#duplicating-audiocds></a></h4><div class=paragraph><p>To duplicate an audio CD, extract the audio data from the CD to a series of files, then write these files to a blank CD.</p></div><div class=paragraph><p><a href=#using-cdrecord>Duplicating an Audio CD</a> describes how to duplicate and burn an audio CD. If the FreeBSD version is less than 10.0 and the device is ATAPI, the <code>atapicam</code> module must be first loaded using the instructions in <a href=#atapicam>支援的裝置</a>.</p></div><div id=using-cdrecord class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Duplicating an Audio CD</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>The <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> package or port installs <code>cdda2wav</code>. This command can be used to extract all of the audio tracks, with each track written to a separate WAV file in the current working directory:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdda2wav <span class=nt>-vall</span> <span class=nt>-B</span> <span class=nt>-Owav</span></code></pre></div></div><div class=paragraph><p>A device name does not need to be specified if there is only one CD device on the system. Refer to the <code>cdda2wav</code> manual page for instructions on how to specify a device and to learn more about the other options available for this command.</p></div></li><li><p>Use <code>cdrecord</code> to write the <span class=filename>.wav</span> files:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdrecord <span class=nt>-v</span> <span class=nv>dev</span><span class=o>=</span>2,0 <span class=nt>-dao</span> <span class=nt>-useinfo</span>  <span class=k>*</span>.wav</code></pre></div></div><div class=paragraph><p>Make sure that <em>2,0</em> is set appropriately, as described in <a href=#cdrecord>燒錄 CD</a>.</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=creating-dvds>17.6. 建立與使用 DVD 媒體<a class=anchor href=#creating-dvds></a></h3><div class=paragraph><p>Compared to the CD, the DVD is the next generation of optical media storage technology. The DVD can hold more data than any CD and is the standard for video publishing.</p></div><div class=paragraph><p>Five physical recordable formats can be defined for a recordable DVD:</p></div><div class=ulist><ul><li><p>DVD-R: This was the first DVD recordable format available. The DVD-R standard is defined by the <a href=http://www.dvdforum.org/forum.shtml>DVD Forum</a>. This format is write once.</p></li><li><p>DVD-RW: This is the rewritable version of the DVD-R standard. A DVD-RW can be rewritten about 1000 times.</p></li><li><p>DVD-RAM: This is a rewritable format which can be seen as a removable hard drive. However, this media is not compatible with most DVD-ROM drives and DVD-Video players as only a few DVD writers support the DVD-RAM format. Refer to <a href=#creating-dvd-ram>使用 DVD-RAM</a> for more information on DVD-RAM use.</p></li><li><p>DVD+RW: This is a rewritable format defined by the <a href=https://en.wikipedia.org/wiki/DVD%2BRW_Alliance>DVD+RW Alliance</a>. A DVD+RW can be rewritten about 1000 times.</p></li><li><p>DVD+R: This format is the write once variation of the DVD+RW format.</p></li></ul></div><div class=paragraph><p>A single layer recordable DVD can hold up to 4,700,000,000 bytes which is actually 4.38 GB or 4485 MB as 1 kilobyte is 1024 bytes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A distinction must be made between the physical media and the application. For example, a DVD-Video is a specific file layout that can be written on any recordable DVD physical media such as DVD-R, DVD+R, or DVD-RW. Before choosing the type of media, ensure that both the burner and the DVD-Video player are compatible with the media under consideration.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_設定>17.6.1. 設定<a class=anchor href=#_設定></a></h4><div class=paragraph><p>To perform DVD recording, use <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. This command is part of the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dvd+rw-tools/>sysutils/dvd+rw-tools</a> utilities which support all DVD media types.</p></div><div class=paragraph><p>These tools use the SCSI subsystem to access the devices, therefore <a href=#atapicam>ATAPI/CAM support</a> must be loaded or statically compiled into the kernel. This support is not needed if the burner uses the USB interface. Refer to <a href=#usb-disks>USB 儲存裝置</a> for more details on USB device configuration.</p></div><div class=paragraph><p>DMA access must also be enabled for ATAPI devices, by adding the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Before attempting to use dvd+rw-tools, consult the <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html>Hardware Compatibility Notes</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For a graphical user interface, consider using <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a> which provides a user friendly interface to <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> and many other burning tools.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_燒錄資料_dvd>17.6.2. 燒錄資料 DVD<a class=anchor href=#_燒錄資料_dvd></a></h4><div class=paragraph><p>Since <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> is a front-end to <a href=#mkisofs>mkisofs</a>, it will invoke <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> to create the file system layout and perform the write on the DVD. This means that an image of the data does not need to be created before the burning process.</p></div><div class=paragraph><p>To burn to a DVD+R or a DVD-R the data in <span class=filename>/path/to/data</span>, use the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>In this example, <code>-J -R</code> is passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> to create an ISO 9660 file system with Joliet and Rock Ridge extensions. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> for more details.</p></div><div class=paragraph><p>For the initial session recording, <code>-Z</code> is used for both single and multiple sessions. Replace <em>/dev/cd0</em>, with the name of the DVD device. Using <code>-dvd-compat</code> indicates that the disk will be closed and that the recording will be unappendable. This should also provide better media compatibility with DVD-ROM drives.</p></div><div class=paragraph><p>To burn a pre-mastered image, such as <em>imagefile.iso</em>, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>The write speed should be detected and automatically set according to the media and the drive being used. To force the write speed, use <code>-speed=</code>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> for example usage.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In order to support working files larger than 4.38GB, an UDF/ISO-9660 hybrid file system must be created by passing <code>-udf -iso-level 3</code> to <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> and all related programs, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. This is required only when creating an ISO image file or when writing files directly to a disk. Since a disk created this way must be mounted as an UDF file system with <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_udf&amp;sektion=8&amp;format=html">mount_udf(8)</a>, it will be usable only on an UDF aware operating system. Otherwise it will look as if it contains corrupted files.</p></div><div class=paragraph><p>To create this type of ISO file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mkisofs <span class=nt>-R</span> <span class=nt>-J</span> <span class=nt>-udf</span> <span class=nt>-iso-level</span> 3 <span class=nt>-o</span> imagefile.iso /path/to/data</code></pre></div></div><div class=paragraph><p>To burn files directly to a disk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>When an ISO image already contains large files, no additional options are required for <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> to burn that image on a disk.</p></div><div class=paragraph><p>Be sure to use an up-to-date version of <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>, which contains <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, as an older version may not contain large files support. If the latest version does not work, install <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools-devel/>sysutils/cdrtools-devel</a> and read its <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_燒錄_dvd_video>17.6.3. 燒錄 DVD-Video<a class=anchor href=#_燒錄_dvd_video></a></h4><div class=paragraph><p>A DVD-Video is a specific file layout based on the ISO 9660 and micro-UDF (M-UDF) specifications. Since DVD-Video presents a specific data structure hierarchy, a particular program such as <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a> is needed to author the DVD.</p></div><div class=paragraph><p>If an image of the DVD-Video file system already exists, it can be burned in the same way as any other image. If <code>dvdauthor</code> was used to make the DVD and the result is in <span class=filename>/path/to/video</span>, the following command should be used to burn the DVD-Video:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -dvd-video /path/to/video</span></code></pre></div></div><div class=paragraph><p><code>-dvd-video</code> is passed to <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> to instruct it to create a DVD-Video file system layout. This option implies the <code>-dvd-compat</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> option.</p></div></div><div class=sect3><h4 id=_使用_dvdrw>17.6.4. 使用 DVD+RW<a class=anchor href=#_使用_dvdrw></a></h4><div class=paragraph><p>Unlike CD-RW, a virgin DVD+RW needs to be formatted before first use. It is <em>recommended</em> to let <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> take care of this automatically whenever appropriate. However, it is possible to use <code>dvd+rw-format</code> to format the DVD+RW:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Only perform this operation once and keep in mind that only virgin DVD+RW medias need to be formatted. Once formatted, the DVD+RW can be burned as usual.</p></div><div class=paragraph><p>To burn a totally new file system and not just append some data onto a DVD+RW, the media does not need to be blanked first. Instead, write over the previous recording like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/newdata</span></code></pre></div></div><div class=paragraph><p>The DVD+RW format supports appending data to a previous recording. This operation consists of merging a new session to the existing one as it is not considered to be multi-session writing. <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> will <em>grow</em> the ISO 9660 file system present on the media.</p></div><div class=paragraph><p>For example, to append data to a DVD+RW, use the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>The same <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> options used to burn the initial session should be used during next writes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Use <code>-dvd-compat</code> for better media compatibility with DVD-ROM drives. When using DVD+RW, this option will not prevent the addition of data.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To blank the media, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0=/dev/zero</span></code></pre></div></div></div><div class=sect3><h4 id=_使用_dvd_rw>17.6.5. 使用 DVD-RW<a class=anchor href=#_使用_dvd_rw></a></h4><div class=paragraph><p>A DVD-RW accepts two disc formats: incremental sequential and restricted overwrite. By default, DVD-RW discs are in sequential format.</p></div><div class=paragraph><p>A virgin DVD-RW can be directly written without being formatted. However, a non-virgin DVD-RW in sequential format needs to be blanked before writing a new initial session.</p></div><div class=paragraph><p>To blank a DVD-RW in sequential mode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A full blanking using <code>-blank=full</code> will take about one hour on a 1x media. A fast blanking can be performed using <code>-blank</code>, if the DVD-RW will be recorded in Disk-At-Once (DAO) mode. To burn the DVD-RW in DAO mode, use the command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Since <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> automatically attempts to detect fast blanked media and engage DAO write, <code>-use-the-force-luke=dao</code> should not be required.</p></div><div class=paragraph><p>One should instead use restricted overwrite mode with any DVD-RW as this format is more flexible than the default of incremental sequential.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To write data on a sequential DVD-RW, use the same instructions as for the other DVD formats:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>To append some data to a previous recording, use <code>-M</code> with <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. However, if data is appended on a DVD-RW in incremental sequential mode, a new session will be created on the disc and the result will be a multi-session disc.</p></div><div class=paragraph><p>A DVD-RW in restricted overwrite format does not need to be blanked before a new initial session. Instead, overwrite the disc with <code>-Z</code>. It is also possible to grow an existing ISO 9660 file system written on the disc with <code>-M</code>. The result will be a one-session DVD.</p></div><div class=paragraph><p>To put a DVD-RW in restricted overwrite format, the following command must be used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>To change back to sequential format, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div></div><div class=sect3><h4 id=_多階段燒錄_multi_session>17.6.6. 多階段燒錄 (Multi-Session)<a class=anchor href=#_多階段燒錄_multi_session></a></h4><div class=paragraph><p>Few DVD-ROM drives support multi-session DVDs and most of the time only read the first session. DVD+R, DVD-R and DVD-RW in sequential format can accept multiple sessions. The notion of multiple sessions does not exist for the DVD+RW and the DVD-RW restricted overwrite formats.</p></div><div class=paragraph><p>Using the following command after an initial non-closed session on a DVD+R, DVD-R, or DVD-RW in sequential format, will add a new session to the disc:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>Using this command with a DVD+RW or a DVD-RW in restricted overwrite mode will append data while merging the new session to the existing one. The result will be a single-session disc. Use this method to add data after an initial write on these types of media.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Since some space on the media is used between each session to mark the end and start of sessions, one should add sessions with a large amount of data to optimize media space. The number of sessions is limited to 154 for a DVD+R, about 2000 for a DVD-R, and 127 for a DVD+R Double Layer.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_取得更多資訊>17.6.7. 取得更多資訊<a class=anchor href=#_取得更多資訊></a></h4><div class=paragraph><p>To obtain more information about a DVD, use <code>dvd+rw-mediainfo <em>/dev/cd0</em></code> while the disc in the specified drive.</p></div><div class=paragraph><p>More information about dvd+rw-tools can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>, on the <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/>dvd+rw-tools web site</a>, and in the <a href=http://lists.debian.org/cdwrite/>cdwrite mailing list</a> archives.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When creating a problem report related to the use of dvd+rw-tools, always include the output of <code>dvd+rw-mediainfo</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=creating-dvd-ram>17.6.8. 使用 DVD-RAM<a class=anchor href=#creating-dvd-ram></a></h4><div class=paragraph><p>DVD-RAM writers can use either a SCSI or ATAPI interface. For ATAPI devices, DMA access has to be enabled by adding the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>A DVD-RAM can be seen as a removable hard drive. Like any other hard drive, the DVD-RAM must be formatted before it can be used. In this example, the whole disk space will be formatted with a standard UFS2 file system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/acd0 bs=2k count=1</span>
<span class=c># bsdlabel -Bw acd0</span>
<span class=c># newfs /dev/acd0</span></code></pre></div></div><div class=paragraph><p>The DVD device, <span class=filename>acd0</span>, must be changed according to the configuration.</p></div><div class=paragraph><p>Once the DVD-RAM has been formatted, it can be mounted as a normal hard drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/acd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Once mounted, the DVD-RAM will be both readable and writeable.</p></div></div></div><div class=sect2><h3 id=floppies>17.7. 建立與使用軟碟<a class=anchor href=#floppies></a></h3><div class=paragraph><p>This section explains how to format a 3.5 inch floppy disk in FreeBSD.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Steps to Format a Floppy</strong></p></div><div class=paragraph><p>A floppy disk needs to be low-level formatted before it can be used. This is usually done by the vendor, but formatting is a good way to check media integrity. To low-level format the floppy disk on FreeBSD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a>. When using this utility, make note of any error messages, as these can help determine if the disk is good or bad.</p></div><div class="olist arabic"><ol class=arabic><li><p>To format the floppy, insert a new 3.5 inch floppy disk into the first floppy drive and issue:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat -f 1440 /dev/fd0</span></code></pre></div></div></li><li><p>After low-level formatting the disk, create a disk label as it is needed by the system to determine the size of the disk and its geometry. The supported geometry values are listed in <span class=filename>/etc/disktab</span>.</p><div class=paragraph><p>To write the disk label, use <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/bsdlabel -B -w /dev/fd0 fd1440</span></code></pre></div></div></li><li><p>The floppy is now ready to be high-level formatted with a file system. The floppy’s file system can be either UFS or FAT, where FAT is generally a better choice for floppies.</p><div class=paragraph><p>To format the floppy with FAT, issue:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/newfs_msdos /dev/fd0</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>The disk is now ready for use. To use the floppy, mount it with <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a>. One can also install and use <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> from the Ports Collection.</p></div></div><div class=sect2><h3 id=backup-basics>17.8. 備份基礎概念<a class=anchor href=#backup-basics></a></h3><div class=paragraph><p>為了要能夠從磁碟故障、意外刪除文件、隨機文件損壞或完全機器毀壞，包含本地備份毀壞進行恢復，執行備份計劃是必要的。</p></div><div class=paragraph><p>備份的類型與排程會依情況有所不同，取決於資料的重要性、檔案還原所需的程度以及可接受的停機時間。一些可用來備份的技術有：</p></div><div class=ulist><ul><li><p>封存整個檔案系統，備份至永久、異地媒體。這可在以上所列的所有問題發生時提供保護，但要還原會較慢且不方便，特別是對於沒有權限的使用者。</p></li><li><p>檔案系統快照 (Snapshot)，對於還原已刪除的檔案或先前版本的檔案非常有用。</p></li><li><p>整個檔案系統或磁碟的複本，使用排程的 <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> 來與網路上的另一個系統同步。</p></li><li><p>硬體或軟體 RAID，來最小化或避免當磁碟故障時的停機時間。</p></li></ul></div><div class=paragraph><p>通常會混合使用各種備份技術，例如，建立一個排程每週自動做儲存於異地的完整系統備份，並使用每小時的 ZFS 快照來輔助備份。此外，在對檔案做編輯或刪除前手動備份各別目錄或檔案。</p></div><div class=paragraph><p>本章節會介紹一些可以用來在 FreeBSD 上建立與管理系統備份的工具。</p></div><div class=sect3><h4 id=_檔案系統備份>17.8.1. 檔案系統備份<a class=anchor href=#_檔案系統備份></a></h4><div class=paragraph><p>要備份一個檔案系統，會用到 <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> 這個傳統 UNIX™ 程式來建立備份，並可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> 來還原備份。這兩個工具可在磁碟區塊的層級運作，這個層級比由檔案系統建立檔案、連結與目錄的抽象層級還要低，因此不像其他的備份軟體，<code>dump</code> 必須一次備份整個檔案系統，且無法只備份部份檔案系統或跨多個檔案系統的目錄樹，<code>dump</code> 會備份構成檔案與目錄的原始資料區塊，而非直接備份檔案與目錄。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>在根目錄使用 <code>dump</code>，會無法備份 <span class=filename>/home</span>, <span class=filename>/usr</span> 或其他許多的目錄，由於這些目錄通常是其他檔案系統的掛載點或連結到其他檔案系統的符號連結。</p></div></td></tr></tbody></table></div><div class=paragraph><p>還原資料時，<code>restore</code> 預設會儲存暫存檔案於 <span class=filename>/tmp/</span>，當使用一個 <span class=filename>/tmp</span> 較小的復原磁碟時，請設定 <code>TMPDIR</code> 到一個擁有較多可用空間的目錄以讓還原可以順利執行。</p></div><div class=paragraph><p>當使用 <code>dump</code> 時，請小心最早自 AT&amp;T UNIX™,circa 1975 的版本 6 仍有一些問題存在，預設的參數會假設備份到一個 9 軌的磁帶，這並非其他類型的媒體或現今可用的高密度磁帶，必須另外在指令列修改這個預設值。</p></div><div class=paragraph><p>雖然可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rdump&amp;sektion=8&amp;format=html">rdump(8)</a> 與 <a href="https://man.freebsd.org/cgi/man.cgi?query=rrestore&amp;sektion=8&amp;format=html">rrestore(8)</a> 工具可以跨網路備份一個檔案系統到另一個系統或備份到連結另一台電腦的磁帶機，但這使用兩個工具備份的安全性並不足夠。</p></div><div class=paragraph><p>可改以在較安全的 SSH 連線上使用 <code>dump</code> 與 <code>restore</code>。以下例子會建立一個完整、壓縮的 <span class=filename>/usr</span> 備份並透過 SSH 連線傳送備份檔案到指定的主機。</p></div><div class=exampleblock><div class=title>例 37. 在 ssh 使用 <code>dump</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \</span>
          targetuser@targetmachine.example.com <span class=nb>dd </span><span class=nv>of</span><span class=o>=</span>/mybigfiles/dump-usr-l0.gz</code></pre></div></div></div></div><div class=paragraph><p>這個例子會設定 <code>RSH</code>，以便透過 SSH 連線寫入備份到遠端系統的磁帶機：</p></div><div class=exampleblock><div class=title>例 38. 在 ssh 使用 <code>dump</code> 透過 <code>RSH</code> 設定</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_目錄備份>17.8.2. 目錄備份<a class=anchor href=#_目錄備份></a></h4><div class=paragraph><p>系統已有內建數個工具可在需要時用來備份與還原指定的檔案與目錄。</p></div><div class=paragraph><p>要備份一個目錄中的所有檔案最好的選擇是 <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>，這個工具最早可以追朔自 AT&amp;T UNIX™ 版本 6 時，因此預設會做一個遞迴備份到一個磁帶機，可以使用參數來改指定備份檔案的名稱。</p></div><div class=paragraph><p>這個例子會建立目前目錄的壓縮備份並儲存至 <span class=filename>/tmp/mybackup.tgz</span>，在建立備份檔案時，要確認備份檔案不要儲存到與目前備份目錄相同的目錄。</p></div><div class=exampleblock><div class=title>例 39. 使用 <code>tar</code> 備份目前目錄</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar czvf /tmp/mybackup.tgz .</span></code></pre></div></div></div></div><div class=paragraph><p>要還原整個備份，先 <code>cd</code> 進入要放置還原檔的目錄並指定備份的名稱。注意，這個動作會覆寫任何在該還原目錄中任何較新版的檔案，當不確定時，可先還原到一個暫時的目錄或指定備份檔中的檔案做還原。</p></div><div class=exampleblock><div class=title>例 40. 使用 <code>tar</code> 還原目前目錄</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /tmp/mybackup.tgz</span></code></pre></div></div></div></div><div class=paragraph><p>除此之外還有許多可用的參數在 <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> 中會有說明。本工具也支援使用排除模式 (Exclude pattern) 來指定那些檔案應該在備份指定目錄或自備份還原檔案時排除。</p></div><div class=paragraph><p>要使用指定的檔案與目錄清單做備份使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> 是不錯的選擇。它並不像 <code>tar</code>，<code>cpio</code> 並不知道如何走訪目錄樹，所以必須提供檔案的清單才能做備份。</p></div><div class=paragraph><p>例如，檔案的清單可以使用 <code>ls</code> 或 <code>find</code> 來產生。以下例子會建立一個目前目錄的遞迴清單然後轉送 (Piped) 給 <code>cpio</code> 來建立名稱為 <span class=filename>/tmp/mybackup.cpio</span> 的備份檔。</p></div><div class=exampleblock><div class=title>例 41. 使用 <code>ls</code> 與 <code>cpio</code> 來製作目前目錄的遞迴備份</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -R | cpio -ovF /tmp/mybackup.cpio</span></code></pre></div></div></div></div><div class=paragraph><p>有一個備份工具嘗試整合 <code>tar</code> 與 <code>cpio</code> 所提供的功能，便是 <a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a>。經歷數年，各種版本的 <code>tar</code> 與 <code>cpio</code> 變的有一些無法相容。POSIX™ 開發出 <code>pax</code>，嘗試讀取與寫入各種版本的 <code>cpio</code> and <code>tar</code> 格式並加入自己的新格式。</p></div><div class=paragraph><p>以先前的例子改使用 <code>pax</code> 會是：</p></div><div class=exampleblock><div class=title>例 42. 使用 <code>pax</code> 備份目前目錄</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pax -wf /tmp/mybackup.pax .</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=backups-tapebackups>17.8.3. 使用資料磁帶備份<a class=anchor href=#backups-tapebackups></a></h4><div class=paragraph><p>隨著磁帶的技術持續發展，當今的備份系統將異地備份與本地可移除媒體做了結合。FreeBSD 支援任何使用 SCSI 的磁帶機，如 LTO 或 DAT，並有限制的支援 SATA 與 USB 磁帶機。</p></div><div class=paragraph><p>SCSI 磁帶機在 FreeBSD 會使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=4&amp;format=html">sa(4)</a> 驅動程式以及 <span class=filename>/dev/sa0</span>, <span class=filename>/dev/nsa0</span> 與 <span class=filename>/dev/esa0</span> 裝置，實體裝置名稱為 <span class=filename>/dev/sa0</span>，當使用 <span class=filename>/dev/nsa0</span> 時，備份程式在寫入檔案之後不會倒帶，這可允許寫入超過一個檔案到磁帶，而使用 <span class=filename>/dev/esa0</span> 時，當關閉裝置後便會退出磁帶。</p></div><div class=paragraph><p>在 FreeBSD 中會使用 <code>mt</code> 來做磁帶機的控制操作，例如在磁帶中搜尋檔案或寫入磁帶控制記號到磁帶。例如，要保留磁帶上的前三個檔案，可以在寫入新檔案前跳過這些檔案：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mt -f /dev/nsa0 fsf 3</span></code></pre></div></div><div class=paragraph><p>這個工具尚支援許多操作，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=mt&amp;sektion=1&amp;format=html">mt(1)</a> 了解詳情。</p></div><div class=paragraph><p>要使用 <code>tar</code> 寫入單一檔案到磁帶，可指定磁帶裝置的名稱以及要備份的檔案：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar cvf /dev/sa0 file</span></code></pre></div></div><div class=paragraph><p>要從磁帶上的 <code>tar</code> 封存檔還原檔案到目前的目錄可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xvf /dev/sa0</span></code></pre></div></div><div class=paragraph><p>要備份一個 UFS 檔案系統可使用 <code>dump</code>。以下例子會備份 <span class=filename>/usr</span> 並在完成時不做倒帶：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dump -0aL -b64 -f /dev/nsa0 /usr</span></code></pre></div></div><div class=paragraph><p>要以互動的方式從磁帶上的 <code>dump</code> 檔案還原到目前目錄：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># restore -i -f /dev/nsa0</span></code></pre></div></div></div><div class=sect3><h4 id=backups-programs-amanda>17.8.4. 第三方備份工具<a class=anchor href=#backups-programs-amanda></a></h4><div class=paragraph><p>FreeBSD Port 套件集提供了許多第三方工具可用於排程建立備份，簡化磁帶備份並讓備份更簡單方便。許多這類的應用程式是以客戶端/伺服器為基礎，可用來自動化單一系統或網路上所有電腦的備份。</p></div><div class=paragraph><p>較熱門的工具包含 Amanda, Bacula, rsync 以及 duplicity。</p></div></div><div class=sect3><h4 id=_緊急還原>17.8.5. 緊急還原<a class=anchor href=#_緊急還原></a></h4><div class=paragraph><p>除了正常的備份外，建議將下以步驟做為緊急準備計劃的一部份。</p></div><div class=paragraph><p>替以下指令的輸出建立一份可列印的複本：</p></div><div class=ulist><ul><li><p><code>gpart show</code></p></li><li><p><code>more /etc/fstab</code></p></li><li><p><code>dmesg</code></p></li></ul></div><div class=paragraph><p>在安全的地方保存這份列印結果與安裝媒體的複本，在緊急還原時可能會需要，接著開機進入安裝媒體並選擇 <code>Live CD</code> 以存取救援 Shell (Rescue shell)，這個救援模式可以用來檢視目前系統的狀態，若有需要，可重新格式化磁碟然後自備份還原資料。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD/i386 11.2-RELEASE 的安裝媒體未內含救援 Shell，針對該版本，可改自 <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso</a> 下載 Livefs CD 映像檔並燒錄。</p></div></td></tr></tbody></table></div><div class=paragraph><p>然後，測試救援 Shell 下的備份。記錄下整個程序，將這份記錄隨媒體、列印結果、備份檔一併保存，這份記錄可以避免在緊張壓力下做緊急還原時因不慎造成備份的毀壞。</p></div><div class=paragraph><p>要再安全性一點，則可將最新的備份儲存在與實體電腦與磁碟機有一段明顯距離的遠端位置。</p></div></div></div><div class=sect2><h3 id=disks-virtual>17.9. 記憶體磁碟<a class=anchor href=#disks-virtual></a></h3><div class=paragraph><p>In addition to physical disks, FreeBSD also supports the creation and use of memory disks. One possible use for a memory disk is to access the contents of an ISO file system without the overhead of first burning it to a CD or DVD, then mounting the CD/DVD media.</p></div><div class=paragraph><p>In FreeBSD, the <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> driver is used to provide support for memory disks. The <span class=filename>GENERIC</span> kernel includes this driver. When using a custom kernel configuration file, ensure it includes this line:</p></div><div class="literalblock programlisting"><div class=content><pre>device md</pre></div></div><div class=sect3><h4 id=disks-mdconfig>17.9.1. 連接與解除連接既有的映象檔<a class=anchor href=#disks-mdconfig></a></h4><div class=paragraph><p>To mount an existing file system image, use <code>mdconfig</code> to specify the name of the ISO file and a free unit number. Then, refer to that unit number to mount it on an existing mount point. Once mounted, the files in the ISO will appear in the mount point. This example attaches <em>diskimage.iso</em> to the memory device <span class=filename>/dev/md0</span> then mounts that memory device on <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -f diskimage.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Notice that <code>-t cd9660</code> was used to mount an ISO format. If a unit number is not specified with <code>-u</code>, <code>mdconfig</code> will automatically allocate an unused memory device and output the name of the allocated unit, such as <span class=filename>md4</span>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> for more details about this command and its options.</p></div><div class=paragraph><p>When a memory disk is no longer in use, its resources should be released back to the system. First, unmount the file system, then use <code>mdconfig</code> to detach the disk from the system and release its resources. To continue this example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 0</span></code></pre></div></div><div class=paragraph><p>To determine if any memory disks are still attached to the system, type <code>mdconfig -l</code>.</p></div></div><div class=sect3><h4 id=disks-md-freebsd5>17.9.2. 建立以檔案或記憶體為基底的磁碟<a class=anchor href=#disks-md-freebsd5></a></h4><div class=paragraph><p>FreeBSD also supports memory disks where the storage to use is allocated from either a hard disk or an area of memory. The first method is commonly referred to as a file-backed file system and the second method as a memory-backed file system. Both types can be created using <code>mdconfig</code>.</p></div><div class=paragraph><p>To create a new memory-backed file system, specify a type of <code>swap</code> and the size of the memory disk to create. Then, format the memory disk with a file system and mount as usual. This example creates a 5M memory disk on unit <code>1</code>. That memory disk is then formatted with the UFS file system before it is mounted:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t swap -s 5m -u 1</span>
<span class=c># newfs -U md1</span>
/dev/md1: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2752, 5344, 7936
<span class=c># mount /dev/md1 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</code></pre></div></div><div class=paragraph><p>To create a new file-backed memory disk, first allocate an area of disk to use. This example creates an empty 5MB file named <span class=filename>newimage</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out</code></pre></div></div><div class=paragraph><p>Next, attach that file to a memory disk, label the memory disk and format it with the UFS file system, mount the memory disk, and verify the size of the file-backed disk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -f newimage -u 0</span>
<span class=c># bsdlabel -w md0 auto</span>
<span class=c># newfs -U md0a</span>
/dev/md0a: 5.0MB <span class=o>(</span>10224 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.25MB, 80 blks, 192 inodes.
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2720, 5280, 7840
<span class=c># mount /dev/md0a /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</code></pre></div></div><div class=paragraph><p>It takes several commands to create a file- or memory-backed file system using <code>mdconfig</code>. FreeBSD also comes with <code>mdmfs</code> which automatically configures a memory disk, formats it with the UFS file system, and mounts it. For example, after creating <em>newimage</em> with <code>dd</code>, this one command is equivalent to running the <code>bsdlabel</code>, <code>newfs</code>, and <code>mount</code> commands shown above:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -F newimage -s 5m md0 /mnt</span></code></pre></div></div><div class=paragraph><p>To instead create a new memory-based memory disk with <code>mdmfs</code>, use this one command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -s 5m md1 /mnt</span></code></pre></div></div><div class=paragraph><p>If the unit number is not specified, <code>mdmfs</code> will automatically select an unused memory device. For more details about <code>mdmfs</code>, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>.</p></div></div></div><div class=sect2><h3 id=snapshots>17.10. 檔案系統快照<a class=anchor href=#snapshots></a></h3><div class=paragraph><p>FreeBSD offers a feature in conjunction with <a href=./#soft-updates>Soft Updates</a>: file system snapshots.</p></div><div class=paragraph><p>UFS snapshots allow a user to create images of specified file systems, and treat them as a file. Snapshot files must be created in the file system that the action is performed on, and a user may create no more than 20 snapshots per file system. Active snapshots are recorded in the superblock so they are persistent across unmount and remount operations along with system reboots. When a snapshot is no longer required, it can be removed using <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a>. While snapshots may be removed in any order, all the used space may not be acquired because another snapshot will possibly claim some of the released blocks.</p></div><div class=paragraph><p>The un-alterable <code>snapshot</code> file flag is set by <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> after initial creation of a snapshot file. <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=1&amp;format=html">unlink(1)</a> makes an exception for snapshot files since it allows them to be removed.</p></div><div class=paragraph><p>Snapshots are created using <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. To place a snapshot of <span class=filename>/var</span> in the file <span class=filename>/var/snapshot/snap</span>, use the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o snapshot /var/snapshot/snap /var</span></code></pre></div></div><div class=paragraph><p>Alternatively, use <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> to create the snapshot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mksnap_ffs /var /var/snapshot/snap</span></code></pre></div></div><div class=paragraph><p>One can find snapshot files on a file system, such as <span class=filename>/var</span>, using <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># find /var -flags snapshot</span></code></pre></div></div><div class=paragraph><p>Once a snapshot has been created, it has several uses:</p></div><div class=ulist><ul><li><p>Some administrators will use a snapshot file for backup purposes, because the snapshot can be transferred to CDs or tape.</p></li><li><p>The file system integrity checker, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, may be run on the snapshot. Assuming that the file system was clean when it was mounted, this should always provide a clean and unchanging result.</p></li><li><p>Running <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> on the snapshot will produce a dump file that is consistent with the file system and the timestamp of the snapshot. <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> can also take a snapshot, create a dump image, and then remove the snapshot in one command by using <code>-L</code>.</p></li><li><p>The snapshot can be mounted as a frozen image of the file system. To <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> the snapshot <span class=filename>/var/snapshot/snap</span> run:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4</span>
<span class=c># mount -r /dev/md4 /mnt</span></code></pre></div></div></li></ul></div><div class=paragraph><p>The frozen <span class=filename>/var</span> is now available through <span class=filename>/mnt</span>. Everything will initially be in the same state it was during the snapshot creation time. The only exception is that any earlier snapshots will appear as zero length files. To unmount the snapshot, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>For more information about <code>softupdates</code> and file system snapshots, including technical papers, visit Marshall Kirk McKusick’s website at <a href=http://www.mckusick.com/>http://www.mckusick.com/</a>.</p></div></div><div class=sect2><h3 id=quotas>17.11. 磁碟配額<a class=anchor href=#quotas></a></h3><div class=paragraph><p>磁碟配額可以用來限制使用者或群組成員能夠在各別檔案系統上使用的磁碟空間量或檔案數量。這個可避免一個使用者或群組成員耗盡所有磁碟的可用空間。</p></div><div class=paragraph><p>本節將說明如何設定 UFS 檔案系統的磁碟配額。要在 ZFS 檔案系統上設定配額，請參考 <a href=./#zfs-zfs-quota>資料集、使用者以及群組配額</a></p></div><div class=sect3><h4 id=_開啟磁碟配額>17.11.1. 開啟磁碟配額<a class=anchor href=#_開啟磁碟配額></a></h4><div class=paragraph><p>查看 FreeBSD 核心是否支援磁碟配額：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.features.ufs_quota
kern.features.ufs_quota: 1</code></pre></div></div><div class=paragraph><p>在本例中，數值 <code>1</code> 代表支援磁碟配額，若為 <code>0</code>，則需加入下列設定到自訂核心設定檔然後依照 <a href=./#kernelconfig>設定 FreeBSD 核心</a> 的指示重新編譯核心：</p></div><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>接著，在 <span class=filename>/etc/rc.conf</span> 開啟磁碟配額：</p></div><div class="literalblock programlisting"><div class=content><pre>quota_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>正常在開機時，會使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a> 檢查每個檔案系統的配額完整性，這個程式會確保在配額資料庫中的資料正確的反映了檔案系統上的資料。這是一個耗費時間的程序，會明顯的影響系統開機的時間，要跳過這個步驟可以加入此變數到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>check_quotas=&#34;NO&#34;</pre></div></div><div class=paragraph><p>最後，編輯 <span class=filename>/etc/fstab</span> 來開啟在各個檔案系統上的磁碟配額。要開啟在檔案系統上對每個使用者的配額要加入 <code>userquota</code> 選項到 <span class=filename>/etc/fstab</span> 要開啟配額的檔案系統的項目中。例如：</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g   /home    ufs rw,userquota 1 2</pre></div></div><div class=paragraph><p>要開啟群組配額，則使用 <code>groupquota</code>。要同時開啟使用者及群組配額，可使用逗號隔開選項：</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</pre></div></div><div class=paragraph><p>預設配額檔案會儲存在檔案系統的根目錄的 <span class=filename>quota.user</span> 及 <span class=filename>quota.group</span>，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> 來取得更多資訊，較不建議指定其他位置來儲存配額檔案。</p></div><div class=paragraph><p>設定完成之後，重新啟動系統，<span class=filename>/etc/rc</span> 會自動執行適當的指令對所有在 <span class=filename>/etc/fstab</span> 中開啟配磁的檔案系統建立初始的配額檔。</p></div><div class=paragraph><p>在一般的操作中，並不需要手動執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaon&amp;sektion=8&amp;format=html">quotaon(8)</a> 或是 <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaoff&amp;sektion=8&amp;format=html">quotaoff(8)</a>，雖然如此，仍應閱讀這些指令的操作手冊來熟悉這些指令的操作。</p></div></div><div class=sect3><h4 id=_設定配額限制>17.11.2. 設定配額限制<a class=anchor href=#_設定配額限制></a></h4><div class=paragraph><p>要確認配額已經開啟，可執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># quota -v</span></code></pre></div></div><div class=paragraph><p>每個有開啟配額的檔案系統應該會有一行磁碟用量及目前配額限制的摘要。</p></div><div class=paragraph><p>現在系統已準備好可以使用 <code>edquota</code> 分配配額限制。</p></div><div class=paragraph><p>有數個選項可以強制限制使用者或群組對磁碟空間的使用量以及可以建立多少檔案。可以用磁碟空間 (block 配額)，檔案數量 (inode 配額) 或同時使用來分配。每種限制又可進一步細分為兩個類型：硬性 (Hard) 及軟性 (Soft) 限制。</p></div><div class=paragraph><p>硬性限制無法被超額使用。一旦使用者超出了硬性限制，該使用者在該檔案系統將無法再使用任何空間。舉例來說，若一個使用者在一個檔案系統上有 500 KB 的硬性限制，且目前已經使用了 490 KB，該使用者只能再使用 10 KB 的空間，若嘗試使用 11 KB 的空間將會失敗。</p></div><div class=paragraph><p>軟性限制在有限的時間內可以被超額使用，即為寬限期 (Grace period)，預設為一週。若一個使用者超出限制並超過寬限期，則軟性限制將轉為硬性限制並且將不允許再使用空間。當使用者使用的空間回到低於軟性限制內，寬限期就會被重置。</p></div><div class=paragraph><p>在下面的例子中，會編輯 <code>test</code> 的配額。當執行 <code>edquota</code> 時，將會使用 <code>EDITOR</code> 指定的編輯器來編輯配額限制。預設的編輯器為 vi。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -u test</span>
Quotas <span class=k>for </span>user <span class=nb>test</span>:
/usr: kbytes <span class=k>in </span>use: 65, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 75<span class=o>)</span>
        inodes <span class=k>in </span>use: 7, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 60<span class=o>)</span>
/usr/var: kbytes <span class=k>in </span>use: 0, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 75<span class=o>)</span>
        inodes <span class=k>in </span>use: 0, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 60<span class=o>)</span></code></pre></div></div><div class=paragraph><p>正常每個開啟配額的檔案系統會有兩行需要設定，一行代表區塊限制 (Block limit) 而另一行代表節點限制 (inode limit)，更改行內的值來修改配額限制。舉例來說，要在 <span class=filename>/usr</span> 提高區塊的軟性限制到 <code>500</code> 以及硬性限制到 <code>600</code>，可更改行內的值如下：</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</pre></div></div><div class=paragraph><p>新的配額限制將在離開編輯器後生效。</p></div><div class=paragraph><p>有時會想要針對一群使用者設定配額限，這時可以透過指定想要的配額給第一個使用者，若然後使用 <code>-p</code> 來複製配額到指定範圍的使用者 ID (UID)。以下指定將複製配額限制給 UID <code>10,000</code> 到 <code>19,999</code> 的使用者：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -p test 10000-19999</span></code></pre></div></div><div class=paragraph><p>要取得更多資訊，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>。</p></div></div><div class=sect3><h4 id=_檢查配額限制與磁碟使用狀況>17.11.3. 檢查配額限制與磁碟使用狀況<a class=anchor href=#_檢查配額限制與磁碟使用狀況></a></h4><div class=paragraph><p>要檢查各別使用者或群組的配額與磁碟用量可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a>。使用者僅可查看自己的配額以及所屬群組的配額，只有使超級使用者可以檢視所有使用者及群組的配額。要取得某個有開啟配額的檔案系統的所有配額及磁碟用量摘要，可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a>。</p></div><div class=paragraph><p>正常情況，使用者未使用任何磁碟空間的檔案系統並不會顯示在 <code>quota</code> 的輸出結果中，即使該使用者有在該檔案系統設定配額限制，使用 <code>-v</code> 可以顯示這些檔案系統。以下是使用使用 <code>quota -v</code> 查詢某個使用者在兩個檔案系統上的配額限制的範例輸出。</p></div><div class="literalblock programlisting"><div class=content><pre>Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</pre></div></div><div class=paragraph><p>在這個例子當中，使用者在 <span class=filename>/usr</span> 的軟性限制 50 KB 已經超出了 15 KB 並已經過了 5 天寬限期。星號 <code>*</code> 代表該使用者目前已超出配額限制。</p></div></div><div class=sect3><h4 id=_nfs_上的配額>17.11.4. NFS 上的配額<a class=anchor href=#_nfs_上的配額></a></h4><div class=paragraph><p>在 NFS 伺服器上，配額會由配額子系統強制執行，<a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.rquotad&amp;sektion=8&amp;format=html">rpc.rquotad(8)</a> Daemon 會提供配額資訊給 NFS 客戶端的 <code>quota</code>，讓在那些主機的使用者可以查看它們的配額統計資訊。</p></div><div class=paragraph><p>在 NFS 伺服器上將 <span class=filename>/etc/inetd.conf</span> 中 <code>rpc.rquotad</code> 行前的 <code>#</code> 移除來開啟：</p></div><div class="literalblock programlisting"><div class=content><pre>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</pre></div></div><div class=paragraph><p>然後重新啟動 <code>inetd</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd restart</span></code></pre></div></div></div></div><div class=sect2><h3 id=disks-encrypting>17.12. 磁碟分割區加密<a class=anchor href=#disks-encrypting></a></h3><div class=paragraph><p>FreeBSD offers excellent online protections against unauthorized data access. File permissions and <a href=./#mac>Mandatory Access Control</a> (MAC) help prevent unauthorized users from accessing data while the operating system is active and the computer is powered up. However, the permissions enforced by the operating system are irrelevant if an attacker has physical access to a computer and can move the computer’s hard drive to another system to copy and analyze the data.</p></div><div class=paragraph><p>Regardless of how an attacker may have come into possession of a hard drive or powered-down computer, the GEOM-based cryptographic subsystems built into FreeBSD are able to protect the data on the computer’s file systems against even highly-motivated attackers with significant resources. Unlike encryption methods that encrypt individual files, the built-in <code>gbde</code> and <code>geli</code> utilities can be used to transparently encrypt entire file systems. No cleartext ever touches the hard drive’s platter.</p></div><div class=paragraph><p>This chapter demonstrates how to create an encrypted file system on FreeBSD. It first demonstrates the process using <code>gbde</code> and then demonstrates the same example using <code>geli</code>.</p></div><div class=sect3><h4 id=_使用_gbde_做磁碟加密>17.12.1. 使用 gbde 做磁碟加密<a class=anchor href=#_使用_gbde_做磁碟加密></a></h4><div class=paragraph><p>The objective of the <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> facility is to provide a formidable challenge for an attacker to gain access to the contents of a <em>cold</em> storage device. However, if the computer is compromised while up and running and the storage device is actively attached, or the attacker has access to a valid passphrase, it offers no protection to the contents of the storage device. Thus, it is important to provide physical security while the system is running and to protect the passphrase used by the encryption mechanism.</p></div><div class=paragraph><p>This facility provides several barriers to protect the data stored in each disk sector. It encrypts the contents of a disk sector using 128-bit AES in CBC mode. Each sector on the disk is encrypted with a different AES key. For more information on the cryptographic design, including how the sector keys are derived from the user-supplied passphrase, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a>.</p></div><div class=paragraph><p>FreeBSD provides a kernel module for gbde which can be loaded with this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_bde</span></code></pre></div></div><div class=paragraph><p>If using a custom kernel configuration file, ensure it contains this line:</p></div><div class=paragraph><p><code>options GEOM_BDE</code></p></div><div class=paragraph><p>The following example demonstrates adding a new hard drive to a system that will hold a single encrypted partition that will be mounted as <span class=filename>/private</span>.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Encrypting a Partition with gbde</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Add the New Hard Drive</p><div class=paragraph><p>Install the new drive to the system as explained in <a href=#disks-adding>加入磁碟</a>. For the purposes of this example, a new hard drive partition has been added as <span class=filename>/dev/ad4s1c</span> and <span class=filename>/dev/ad0s1*</span> represents the existing standard FreeBSD partitions.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</code></pre></div></div></li><li><p>Create a Directory to Hold <code>gbde</code> Lock Files</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /etc/gbde</span></code></pre></div></div><div class=paragraph><p>The gbde lock file contains information that gbde requires to access encrypted partitions. Without access to the lock file, gbde will not be able to decrypt the data contained in the encrypted partition without significant manual intervention which is not supported by the software. Each encrypted partition uses a separate lock file.</p></div></li><li><p>Initialize the <code>gbde</code> Partition</p><div class=paragraph><p>A gbde partition must be initialized before it can be used. This initialization needs to be performed only once. This command will open the default editor, in order to set various configuration options in a template. For use with the UFS file system, set the sector_size to 2048:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</span>
<span class=c># $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $</span></code></pre></div></div><div class=paragraph><p>Once the edit is saved, the user will be asked twice to type the passphrase used to secure the data. The passphrase must be the same both times. The ability of gbde to protect data depends entirely on the quality of the passphrase. For tips on how to select a secure passphrase that is easy to remember, see <a href=http://world.std.com/~reinhold/diceware.html>http://world.std.com/~reinhold/diceware.htm</a>.</p></div><div class=paragraph><p>This initialization creates a lock file for the gbde partition. In this example, it is stored as <span class=filename>/etc/gbde/ad4s1c.lock</span>. Lock files must end in ".lock" in order to be correctly detected by the <span class=filename>/etc/rc.d/gbde</span> start up script.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Lock files <em>must</em> be backed up together with the contents of any encrypted partitions. Without the lock file, the legitimate owner will be unable to access the data on the encrypted partition.</p></div></td></tr></tbody></table></div></li><li><p>Attach the Encrypted Partition to the Kernel</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</span></code></pre></div></div><div class=paragraph><p>This command will prompt to input the passphrase that was selected during the initialization of the encrypted partition. The new encrypted device will appear in <span class=filename>/dev</span> as <span class=filename>/dev/device_name.bde</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</code></pre></div></div></li><li><p>Create a File System on the Encrypted Device</p><div class=paragraph><p>Once the encrypted device has been attached to the kernel, a file system can be created on the device. This example creates a UFS file system with soft updates enabled. Be sure to specify the partition which has a <span class=filename>*.bde</span> extension:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/ad4s1c.bde</span></code></pre></div></div></li><li><p>Mount the Encrypted Partition</p><div class=paragraph><p>Create a mount point and mount the encrypted file system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /private</span>
<span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div></li><li><p>Verify That the Encrypted File System is Available</p><div class=paragraph><p>The encrypted file system should now be visible and available for use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>df</span> <span class=nt>-H</span>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>After each boot, any encrypted file systems must be manually re-attached to the kernel, checked for errors, and mounted, before the file systems can be used. To configure these steps, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gbde_autoattach_all=&#34;YES&#34;
gbde_devices=&#34;ad4s1c&#34;
gbde_lockdir=&#34;/etc/gbde&#34;</pre></div></div><div class=paragraph><p>This requires that the passphrase be entered at the console at boot time. After typing the correct passphrase, the encrypted partition will be mounted automatically. Additional gbde boot options are available and listed in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>sysinstall is incompatible with gbde-encrypted devices. All <span class=filename>*.bde</span> devices must be detached from the kernel before starting sysinstall or it will crash during its initial probing for devices. To detach the encrypted device used in the example, use the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde detach /dev/ad4s1c</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=disks-encrypting-geli>17.12.2. 使用 <code>geli</code> 做磁碟加密<a class=anchor href=#disks-encrypting-geli></a></h4><div class=paragraph><p>An alternative cryptographic GEOM class is available using <code>geli</code>. This control utility adds some features and uses a different scheme for doing cryptographic work. It provides the following features:</p></div><div class=ulist><ul><li><p>Utilizes the <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=9&amp;format=html">crypto(9)</a> framework and automatically uses cryptographic hardware when it is available.</p></li><li><p>Supports multiple cryptographic algorithms such as AES, Blowfish, and 3DES.</p></li><li><p>Allows the root partition to be encrypted. The passphrase used to access the encrypted root partition will be requested during system boot.</p></li><li><p>Allows the use of two independent keys.</p></li><li><p>It is fast as it performs simple sector-to-sector encryption.</p></li><li><p>Allows backup and restore of master keys. If a user destroys their keys, it is still possible to get access to the data by restoring keys from the backup.</p></li><li><p>Allows a disk to attach with a random, one-time key which is useful for swap partitions and temporary file systems.</p></li></ul></div><div class=paragraph><p>More features and usage examples can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></div><div class=paragraph><p>The following example describes how to generate a key file which will be used as part of the master key for the encrypted provider mounted under <span class=filename>/private</span>. The key file will provide some random data used to encrypt the master key. The master key will also be protected by a passphrase. The provider’s sector size will be 4kB. The example describes how to attach to the <code>geli</code> provider, create a file system on it, mount it, work with it, and finally, how to detach it.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Encrypting a Partition with <code>geli</code></strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Load <code>geli</code> Support</p><div class=paragraph><p>Support for <code>geli</code> is available as a loadable kernel module. To configure the system to automatically load the module at boot time, add the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_eli_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To load the kernel module now:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_eli</span></code></pre></div></div><div class=paragraph><p>For a custom kernel, ensure the kernel configuration file contains these lines:</p></div><div class="literalblock programlisting"><div class=content><pre>options GEOM_ELI
device crypto</pre></div></div></li><li><p>Generate the Master Key</p><div class=paragraph><p>The following commands generate a master key (<span class=filename>/root/da2.key</span>) that is protected with a passphrase. The data source for the key file is <span class=filename>/dev/random</span> and the sector size of the provider (<span class=filename>/dev/da2.eli</span>) is 4kB as a bigger sector size provides better performance:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/root/da2.key bs=64 count=1</span>
<span class=c># geli init -s 4096 -K /root/da2.key /dev/da2</span>
Enter new passphrase:
Reenter new passphrase:</code></pre></div></div><div class=paragraph><p>It is not mandatory to use both a passphrase and a key file as either method of securing the master key can be used in isolation.</p></div><div class=paragraph><p>If the key file is given as "-", standard input will be used. For example, this command generates three key files:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</span></code></pre></div></div></li><li><p>Attach the Provider with the Generated Key</p><div class=paragraph><p>To attach the provider, specify the key file, the name of the disk, and the passphrase:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geli attach -k /root/da2.key /dev/da2</span>
Enter passphrase:</code></pre></div></div><div class=paragraph><p>This creates a new device with an <span class=filename>.eli</span> extension:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/da2*</span>
/dev/da2  /dev/da2.eli</code></pre></div></div></li><li><p>Create the New File System</p><div class=paragraph><p>Next, format the device with the UFS file system and mount it on an existing mount point:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/da2.eli bs=1m</span>
<span class=c># newfs /dev/da2.eli</span>
<span class=c># mount /dev/da2.eli /private</span></code></pre></div></div><div class=paragraph><p>The encrypted file system should now be available for use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df -H</span>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Once the work on the encrypted partition is done, and the <span class=filename>/private</span> partition is no longer needed, it is prudent to put the device into cold storage by unmounting and detaching the <code>geli</code> encrypted partition from the kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /private</span>
<span class=c># geli detach da2.eli</span></code></pre></div></div><div class=paragraph><p>A <span class=filename>rc.d</span> script is provided to simplify the mounting of <code>geli</code>-encrypted devices at boot time. For this example, add these lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geli_devices=&#34;da2&#34;
geli_da2_flags=&#34;-k /root/da2.key&#34;</pre></div></div><div class=paragraph><p>This configures <span class=filename>/dev/da2</span> as a <code>geli</code> provider with a master key of <span class=filename>/root/da2.key</span>. The system will automatically detach the provider from the kernel before the system shuts down. During the startup process, the script will prompt for the passphrase before attaching the provider. Other kernel messages might be shown before and after the password prompt. If the boot process seems to stall, look carefully for the password prompt among the other messages. Once the correct passphrase is entered, the provider is attached. The file system is then mounted, typically by an entry in <span class=filename>/etc/fstab</span>. Refer to <a href=./#mount-unmount>掛載與卸載檔案系統</a> for instructions on how to configure a file system to mount at boot time.</p></div></div></div><div class=sect2><h3 id=swap-encrypting>17.13. 交換空間加密<a class=anchor href=#swap-encrypting></a></h3><div class=paragraph><p>Like the encryption of disk partitions, encryption of swap space is used to protect sensitive information. Consider an application that deals with passwords. As long as these passwords stay in physical memory, they are not written to disk and will be cleared after a reboot. However, if FreeBSD starts swapping out memory pages to free space, the passwords may be written to the disk unencrypted. Encrypting swap space can be a solution for this scenario.</p></div><div class=paragraph><p>This section demonstrates how to configure an encrypted swap partition using <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> encryption. It assumes that <span class=filename>/dev/ada0s1b</span> is the swap partition.</p></div><div class=sect3><h4 id=_設定已加密的交換空間>17.13.1. 設定已加密的交換空間<a class=anchor href=#_設定已加密的交換空間></a></h4><div class=paragraph><p>Swap partitions are not encrypted by default and should be cleared of any sensitive data before continuing. To overwrite the current swap partition with random garbage, execute the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/ada0s1b bs=1m</span></code></pre></div></div><div class=paragraph><p>To encrypt the swap partition using <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a>, add the <code>.bde</code> suffix to the swap line in <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ada0s1b.bde	none		swap	sw		0	0</pre></div></div><div class=paragraph><p>To instead encrypt the swap partition using <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>, use the <code>.eli</code> suffix:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw		0	0</pre></div></div><div class=paragraph><p>By default, <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> uses the AES algorithm with a key length of 128 bits. Normally the default settings will suffice. If desired, these defaults can be altered in the options field in <span class=filename>/etc/fstab</span>. The possible flags are:</p></div><div class=dlist><dl><dt class=hdlist1>aalgo</dt><dd><p>Data integrity verification algorithm used to ensure that the encrypted data has not been tampered with. See <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> for a list of supported algorithms.</p></dd><dt class=hdlist1>ealgo</dt><dd><p>Encryption algorithm used to protect the data. See <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> for a list of supported algorithms.</p></dd><dt class=hdlist1>keylen</dt><dd><p>The length of the key used for the encryption algorithm. See <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> for the key lengths that are supported by each encryption algorithm.</p></dd><dt class=hdlist1>sectorsize</dt><dd><p>The size of the blocks data is broken into before it is encrypted. Larger sector sizes increase performance at the cost of higher storage overhead. The recommended size is 4096 bytes.</p></dd></dl></div><div class=paragraph><p>This example configures an encrypted swap partition using the Blowfish algorithm with a key length of 128 bits and a sectorsize of 4 kilobytes:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options				Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw,ealgo=blowfish,keylen=128,sectorsize=4096	0	0</pre></div></div></div><div class=sect3><h4 id=_加密的交換空間檢驗>17.13.2. 加密的交換空間檢驗<a class=anchor href=#_加密的交換空間檢驗></a></h4><div class=paragraph><p>Once the system has rebooted, proper operation of the encrypted swap can be verified using <code>swapinfo</code>.</p></div><div class=paragraph><p>If <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> is being used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.bde   542720        0   542720     0%</code></pre></div></div><div class=paragraph><p>If <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> is being used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.eli   542720        0   542720     0%</code></pre></div></div></div></div><div class=sect2><h3 id=disks-hast>17.14. 高可用存儲空間 (HAST)<a class=anchor href=#disks-hast></a></h3><div class=paragraph><p>High availability is one of the main requirements in serious business applications and highly-available storage is a key component in such environments. In FreeBSD, the Highly Available STorage (HAST) framework allows transparent storage of the same data across several physically separated machines connected by a TCP/IP network. HAST can be understood as a network-based RAID1 (mirror), and is similar to the DRBD® storage system used in the GNU/Linux™ platform. In combination with other high-availability features of FreeBSD like CARP, HAST makes it possible to build a highly-available storage cluster that is resistant to hardware failures.</p></div><div class=paragraph><p>The following are the main features of HAST:</p></div><div class=ulist><ul><li><p>Can be used to mask I/O errors on local hard drives.</p></li><li><p>File system agnostic as it works with any file system supported by FreeBSD.</p></li><li><p>Efficient and quick resynchronization as only the blocks that were modified during the downtime of a node are synchronized.</p></li><li><p>Can be used in an already deployed environment to add additional redundancy.</p></li><li><p>Together with CARP, Heartbeat, or other tools, it can be used to build a robust and durable storage system.</p></li></ul></div><div class=paragraph><p>After reading this section, you will know:</p></div><div class=ulist><ul><li><p>What HAST is, how it works, and which features it provides.</p></li><li><p>How to set up and use HAST on FreeBSD.</p></li><li><p>How to integrate CARP and <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> to build a robust storage system.</p></li></ul></div><div class=paragraph><p>Before reading this section, you should:</p></div><div class=ulist><ul><li><p>了解 UNIX™ 及 FreeBSD 基礎 (<a href=./#basics>FreeBSD 基礎</a>)。</p></li><li><p>Know how to configure network interfaces and other core FreeBSD subsystems (<a href=./#config-tuning>設定與調校</a>).</p></li><li><p>Have a good understanding of FreeBSD networking (<a href=./#network-communication>網路通訊</a>).</p></li></ul></div><div class=paragraph><p>The HAST project was sponsored by The FreeBSD Foundation with support from <a href=http://www.omc.net/>http://www.omc.net/</a> and <a href=http://www.transip.nl/>http://www.transip.nl/</a>.</p></div><div class=sect3><h4 id=_hast_運作模式>17.14.1. HAST 運作模式<a class=anchor href=#_hast_運作模式></a></h4><div class=paragraph><p>HAST provides synchronous block-level replication between two physical machines: the <em>primary</em>, also known as the <em>master</em> node, and the <em>secondary</em>, or <em>slave</em> node. These two machines together are referred to as a cluster.</p></div><div class=paragraph><p>Since HAST works in a primary-secondary configuration, it allows only one of the cluster nodes to be active at any given time. The primary node, also called <em>active</em>, is the one which will handle all the I/O requests to HAST-managed devices. The secondary node is automatically synchronized from the primary node.</p></div><div class=paragraph><p>The physical components of the HAST system are the local disk on primary node, and the disk on the remote, secondary node.</p></div><div class=paragraph><p>HAST operates synchronously on a block level, making it transparent to file systems and applications. HAST provides regular GEOM providers in <span class=filename>/dev/hast/</span> for use by other tools or applications. There is no difference between using HAST-provided devices and raw disks or partitions.</p></div><div class=paragraph><p>Each write, delete, or flush operation is sent to both the local disk and to the remote disk over TCP/IP. Each read operation is served from the local disk, unless the local disk is not up-to-date or an I/O error occurs. In such cases, the read operation is sent to the secondary node.</p></div><div class=paragraph><p>HAST tries to provide fast failure recovery. For this reason, it is important to reduce synchronization time after a node’s outage. To provide fast synchronization, HAST manages an on-disk bitmap of dirty extents and only synchronizes those during a regular synchronization, with an exception of the initial sync.</p></div><div class=paragraph><p>There are many ways to handle synchronization. HAST implements several replication modes to handle different synchronization methods:</p></div><div class=ulist><ul><li><p><em>memsync</em>: This mode reports a write operation as completed when the local write operation is finished and when the remote node acknowledges data arrival, but before actually storing the data. The data on the remote node will be stored directly after sending the acknowledgement. This mode is intended to reduce latency, but still provides good reliability. This mode is the default.</p></li><li><p><em>fullsync</em>: This mode reports a write operation as completed when both the local write and the remote write complete. This is the safest and the slowest replication mode.</p></li><li><p><em>async</em>: This mode reports a write operation as completed when the local write completes. This is the fastest and the most dangerous replication mode. It should only be used when replicating to a distant node where latency is too high for other modes.</p></li></ul></div></div><div class=sect3><h4 id=_hast_設定>17.14.2. HAST 設定<a class=anchor href=#_hast_設定></a></h4><div class=paragraph><p>The HAST framework consists of several components:</p></div><div class=ulist><ul><li><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> daemon which provides data synchronization. When this daemon is started, it will automatically load <code>geom_gate.ko</code>.</p></li><li><p>The userland management utility, <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a>.</p></li><li><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a> configuration file. This file must exist before starting hastd.</p></li></ul></div><div class=paragraph><p>Users who prefer to statically build <code>GEOM_GATE</code> support into the kernel should add this line to the custom kernel configuration file, then rebuild the kernel using the instructions in <a href=./#kernelconfig>設定 FreeBSD 核心</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_GATE</pre></div></div><div class=paragraph><p>The following example describes how to configure two nodes in master-slave/primary-secondary operation using HAST to replicate the data between the two. The nodes will be called <code>hasta</code>, with an IP address of <code>172.16.0.1</code>, and <code>hastb</code>, with an IP address of <code>172.16.0.2</code>. Both nodes will have a dedicated hard drive <span class=filename>/dev/ad6</span> of the same size for HAST operation. The HAST pool, sometimes referred to as a resource or the GEOM provider in <span class=filename>/dev/hast/</span>, will be called <code>test</code>.</p></div><div class=paragraph><p>Configuration of HAST is done using <span class=filename>/etc/hast.conf</span>. This file should be identical on both nodes. The simplest configuration is:</p></div><div class="literalblock programlisting"><div class=content><pre>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</pre></div></div><div class=paragraph><p>For more advanced configuration, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>It is also possible to use host names in the <code>remote</code> statements if the hosts are resolvable and defined either in <span class=filename>/etc/hosts</span> or in the local DNS.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Once the configuration exists on both nodes, the HAST pool can be created. Run these commands on both nodes to place the initial metadata onto the local disk and to start <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl create test</span>
<span class=c># service hastd onestart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is <em>not</em> possible to use GEOM providers with an existing file system or to convert an existing storage to a HAST-managed pool. This procedure needs to store some metadata on the provider and there will not be enough required space available on an existing provider.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A HAST node’s <code>primary</code> or <code>secondary</code> role is selected by an administrator, or software like Heartbeat, using <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a>. On the primary node, <code>hasta</code>, issue this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role primary test</span></code></pre></div></div><div class=paragraph><p>Run this command on the secondary node, <code>hastb</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role secondary test</span></code></pre></div></div><div class=paragraph><p>Verify the result by running <code>hastctl</code> on each node:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl status test</span></code></pre></div></div><div class=paragraph><p>Check the <code>status</code> line in the output. If it says <code>degraded</code>, something is wrong with the configuration file. It should say <code>complete</code> on each node, meaning that the synchronization between the nodes has started. The synchronization completes when <code>hastctl status</code> reports 0 bytes of <code>dirty</code> extents.</p></div><div class=paragraph><p>The next step is to create a file system on the GEOM provider and mount it. This must be done on the <code>primary</code> node. Creating the file system can take a few minutes, depending on the size of the hard drive. This example creates a UFS file system on <span class=filename>/dev/hast/test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/hast/test</span>
<span class=c># mkdir /hast/test</span>
<span class=c># mount /dev/hast/test /hast/test</span></code></pre></div></div><div class=paragraph><p>Once the HAST framework is configured properly, the final step is to make sure that HAST is started automatically during system boot. Add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hastd_enable=&#34;YES&#34;</pre></div></div><div class=sect4><h5 id=_容錯移轉設定>17.14.2.1. 容錯移轉設定<a class=anchor href=#_容錯移轉設定></a></h5><div class=paragraph><p>The goal of this example is to build a robust storage system which is resistant to the failure of any given node. If the primary node fails, the secondary node is there to take over seamlessly, check and mount the file system, and continue to work without missing a single bit of data.</p></div><div class=paragraph><p>To accomplish this task, the Common Address Redundancy Protocol (CARP) is used to provide for automatic failover at the IP layer. CARP allows multiple hosts on the same network segment to share an IP address. Set up CARP on both nodes of the cluster according to the documentation available in <a href=./#carp>共用位址備援協定 (CARP)</a>. In this example, each node will have its own management IP address and a shared IP address of <em>172.16.0.254</em>. The primary HAST node of the cluster must be the master CARP node.</p></div><div class=paragraph><p>The HAST pool created in the previous section is now ready to be exported to the other hosts on the network. This can be accomplished by exporting it through NFS or Samba, using the shared IP address <em>172.16.0.254</em>. The only problem which remains unresolved is an automatic failover should the primary node fail.</p></div><div class=paragraph><p>In the event of CARP interfaces going up or down, the FreeBSD operating system generates a <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> event, making it possible to watch for state changes on the CARP interfaces. A state change on the CARP interface is an indication that one of the nodes failed or came back online. These state change events make it possible to run a script which will automatically handle the HAST failover.</p></div><div class=paragraph><p>To catch state changes on the CARP interfaces, add this configuration to <span class=filename>/etc/devd.conf</span> on each node:</p></div><div class="literalblock programlisting"><div class=content><pre>notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_UP&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch master&#34;;
};

notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_DOWN&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch slave&#34;;
};</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If the systems are running FreeBSD 10 or higher, replace <span class=filename>carp0</span> with the name of the CARP-configured interface.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Restart <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> on both nodes to put the new configuration into effect:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p>When the specified interface state changes by going up or down , the system generates a notification, allowing the <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> subsystem to run the specified automatic failover script, <span class=filename>/usr/local/sbin/carp-hast-switch</span>. For further clarification about this configuration, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=devd.conf&amp;sektion=5&amp;format=html">devd.conf(5)</a>.</p></div><div class=paragraph><p>Here is an example of an automated failover script:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources=&#34;test&#34;

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log=&#34;local0.debug&#34;
name=&#34;carp-hast&#34;

# end of user configurable stuff

case &#34;$1&#34; in
	master)
		logger -p $log -t $name &#34;Switching to primary provider for ${resources}.&#34;
		sleep ${delay}

		# Wait for any &#34;hastd secondary&#34; processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf &#34;hastd: ${disk} \(secondary\)&#34; &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to change role to primary for resource ${disk}.&#34;
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c &#34;/dev/hast/${disk}&#34; ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c &#34;/dev/hast/${disk}&#34; ]; then
				logger -p $log -t $name &#34;GEOM provider /dev/hast/${disk} did not appear.&#34;
				exit 1
			fi
		done

		logger -p $log -t $name &#34;Role for HAST resources ${resources} switched to primary.&#34;

		logger -p $log -t $name &#34;Mounting disks.&#34;
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name &#34;Switching to secondary provider for ${resources}.&#34;

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q &#34;^/dev/hast/${disk} on &#34;
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to switch role to secondary for resource ${disk}.&#34;
				exit 1
			fi
			logger -p $log -t $name &#34;Role switched to secondary for resource ${disk}.&#34;
		done
	;;
esac</pre></div></div><div class=paragraph><p>In a nutshell, the script takes these actions when a node becomes master:</p></div><div class=ulist><ul><li><p>Promotes the HAST pool to primary on the other node.</p></li><li><p>Checks the file system under the HAST pool.</p></li><li><p>Mounts the pool.</p></li></ul></div><div class=paragraph><p>When a node becomes secondary:</p></div><div class=ulist><ul><li><p>Unmounts the HAST pool.</p></li><li><p>Degrades the HAST pool to secondary.</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>This is just an example script which serves as a proof of concept. It does not handle all the possible scenarios and can be extended or altered in any way, for example, to start or stop required services.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>For this example, a standard UFS file system was used. To reduce the time needed for recovery, a journal-enabled UFS or ZFS file system can be used instead.</p></div></td></tr></tbody></table></div><div class=paragraph><p>More detailed information with additional examples can be found at <a href=http://wiki.FreeBSD.org/HAST>http://wiki.FreeBSD.org/HAST</a>.</p></div></div></div><div class=sect3><h4 id=_疑難排解_3>17.14.3. 疑難排解<a class=anchor href=#_疑難排解_3></a></h4><div class=paragraph><p>HAST should generally work without issues. However, as with any other software product, there may be times when it does not work as supposed. The sources of the problems may be different, but the rule of thumb is to ensure that the time is synchronized between the nodes of the cluster.</p></div><div class=paragraph><p>When troubleshooting HAST, the debugging level of <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> should be increased by starting <code>hastd</code> with <code>-d</code>. This argument may be specified multiple times to further increase the debugging level. Consider also using <code>-F</code>, which starts <code>hastd</code> in the foreground.</p></div><div class=sect4><h5 id=disks-hast-sb>17.14.3.1. 自 Split-brain 情況復原<a class=anchor href=#disks-hast-sb></a></h5><div class=paragraph><p><em>Split-brain</em> occurs when the nodes of the cluster are unable to communicate with each other, and both are configured as primary. This is a dangerous condition because it allows both nodes to make incompatible changes to the data. This problem must be corrected manually by the system administrator.</p></div><div class=paragraph><p>The administrator must either decide which node has more important changes, or perform the merge manually. Then, let HAST perform full synchronization of the node which has the broken data. To do this, issue these commands on the node which needs to be resynchronized:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role init test</span>
<span class=c># hastctl create test</span>
<span class=c># hastctl role secondary test</span></code></pre></div></div></div></div></div></div></div><div class=sect1><h2 id=geom>Chapter 18. GEOM: 模組化磁碟轉換框架<a class=anchor href=#geom></a></h2><div class=sectionbody><div class=sect2><h3 id=geom-synopsis>18.1. 概述<a class=anchor href=#geom-synopsis></a></h3><div class=paragraph><p>在 FreeBSD 中，GEOM 可允許對類別做存取與控制，例如：主開機記錄 (Master Boot Record) 與 BSD 標籤，透過利用提供者，或在 <span class=filename>/dev</span> 中的磁碟裝置。透過支援各種 RAID 的配置，GEOM 透明的提供了對作業系統與作業系統工具的存取。</p></div><div class=paragraph><p>This chapter covers the use of disks under the GEOM framework in FreeBSD. This includes the major RAID control utilities which use the framework for configuration. This chapter is not a definitive guide to RAID configurations and only GEOM-supported RAID classifications are discussed.</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>What type of RAID support is available through GEOM.</p></li><li><p>How to use the base utilities to configure, maintain, and manipulate the various RAID levels.</p></li><li><p>How to mirror, stripe, encrypt, and remotely connect disk devices through GEOM.</p></li><li><p>How to troubleshoot disks attached to the GEOM framework.</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>Understand how FreeBSD treats disk devices (<a href=./#disks>儲存設備</a>).</p></li><li><p>了解如何設定並安裝新的核心 (<a href=./#kernelconfig>設定 FreeBSD 核心</a>)。</p></li></ul></div></div><div class=sect2><h3 id=geom-striping>18.2. RAID0 - 串連 (Striping)<a class=anchor href=#geom-striping></a></h3><div class=paragraph><p>串連會合併數個磁碟成單一個磁碟區 (Volume)，可以透過使用硬體 RAID 控制器來做到串連。GEOM 磁碟子系統提供了軟體支援的磁碟串連，也就是所謂的 RAID0，而不需要 RAID 磁碟控制器。</p></div><div class=paragraph><p>在 RAID0 中，資料會被切割成數個資料區塊 (Block) 寫入到磁碟陣列中的每一個磁碟機。如下圖所示，取代以往等候系統寫入 256k 到一個磁碟的時間， RAID0 可以同時寫入 64k 到磁碟陣列中四個磁碟的每個磁碟，這可提供優異的 I/O 效能，若使用多個磁碟控制器可增加更多的效能。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/geom/striping.png alt="Disk Striping Illustration"></div></div><div class=paragraph><p>在 RAID0 串連中的每個磁碟必須要相同大小，因為 I/O 的請求是平行交錯讀取或寫入到多個磁碟的。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>RAID0 並<em>不</em>提供任何備援 (Redundancy) 功能。這意謂著若磁碟陣列中的其中一個磁碟故障，所有在該磁碟上的資料便會遺失。若資料很重要，請規畫備份策略，定期儲存備份到遠端系統或裝置。</p></div></td></tr></tbody></table></div><div class=paragraph><p>The process for creating a software, GEOM-based RAID0 on a FreeBSD system using commodity disks is as follows. Once the stripe is created, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=gstripe&amp;sektion=8&amp;format=html">gstripe(8)</a> for more information on how to control an existing stripe.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Creating a Stripe of Unformatted ATA Disks</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Load the <span class=filename>geom_stripe.ko</span> module:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_stripe</span></code></pre></div></div></li><li><p>Ensure that a suitable mount point exists. If this volume will become a root partition, then temporarily use another mount point such as <span class=filename>/mnt</span>.</p></li><li><p>Determine the device names for the disks which will be striped, and create the new stripe device. For example, to stripe two unused and unpartitioned ATA disks with device names of <span class=filename>/dev/ad2</span> and <span class=filename>/dev/ad3</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gstripe label -v st0 /dev/ad2 /dev/ad3</span>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</code></pre></div></div></li><li><p>Write a standard label, also known as a partition table, on the new volume and install the default bootstrap code:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/stripe/st0</span></code></pre></div></div></li><li><p>This process should create two other devices in <span class=filename>/dev/stripe</span> in addition to <span class=filename>st0</span>. Those include <span class=filename>st0a</span> and <span class=filename>st0c</span>. At this point, a UFS file system can be created on <span class=filename>st0a</span> using <code>newfs</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/stripe/st0a</span></code></pre></div></div><div class=paragraph><p>Many numbers will glide across the screen, and after a few seconds, the process will be complete. The volume has been created and is ready to be mounted.</p></div></li><li><p>To manually mount the created disk stripe:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/stripe/st0a /mnt</span></code></pre></div></div></li><li><p>To mount this striped file system automatically during the boot process, place the volume information in <span class=filename>/etc/fstab</span>. In this example, a permanent mount point, named <span class=filename>stripe</span>, is created:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /stripe</span>
<span class=c># echo &#34;/dev/stripe/st0a /stripe ufs rw 2 2&#34; \</span>
<span class=o>&gt;&gt;</span> /etc/fstab</code></pre></div></div></li><li><p>The <span class=filename>geom_stripe.ko</span> module must also be automatically loaded during system initialization, by adding a line to <span class=filename>/boot/loader.conf</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf geom_stripe_load=YES</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect2><h3 id=geom-mirror>18.3. RAID1 - 鏡像 (Mirroring)<a class=anchor href=#geom-mirror></a></h3><div class=paragraph><p>RAID1 或<em>鏡像</em>是一項寫入相同資料到超過一個磁碟機的技術。鏡像通常用來保護資料因磁碟機故障導致的損失，每個在鏡像中的磁碟機會擁有完全相同的資料，當各別磁碟機故障時，鏡像會繼續運作，由還可運作的磁碟機提供資料。電腦會繼續執行，等到管理者有時間更換故障的硬碟，而不會被使用者中斷運作。</p></div><div class=paragraph><p>Two common situations are illustrated in these examples. The first creates a mirror out of two new drives and uses it as a replacement for an existing single drive. The second example creates a mirror on a single new drive, copies the old drive’s data to it, then inserts the old drive into the mirror. While this procedure is slightly more complicated, it only requires one new drive.</p></div><div class=paragraph><p>Traditionally, the two drives in a mirror are identical in model and capacity, but <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> does not require that. Mirrors created with dissimilar drives will have a capacity equal to that of the smallest drive in the mirror. Extra space on larger drives will be unused. Drives inserted into the mirror later must have at least as much capacity as the smallest drive already in the mirror.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>The mirroring procedures shown here are non-destructive, but as with any major disk operation, make a full backup first.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>While <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> is used in these procedures to copy file systems, it does not work on file systems with soft updates journaling. See <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> for information on detecting and disabling soft updates journaling.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=geom-mirror-metadata>18.3.1. Metadata 問題<a class=anchor href=#geom-mirror-metadata></a></h4><div class=paragraph><p>Many disk systems store metadata at the end of each disk. Old metadata should be erased before reusing the disk for a mirror. Most problems are caused by two particular types of leftover metadata: GPT partition tables and old metadata from a previous mirror.</p></div><div class=paragraph><p>GPT metadata can be erased with <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>. This example erases both primary and backup GPT partition tables from disk <span class=filename>ada8</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart destroy -F ada8</span></code></pre></div></div><div class=paragraph><p>A disk can be removed from an active mirror and the metadata erased in one step using <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a>. Here, the example disk <span class=filename>ada8</span> is removed from the active mirror <span class=filename>gm4</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror remove gm4 ada8</span></code></pre></div></div><div class=paragraph><p>If the mirror is not running, but old mirror metadata is still on the disk, use <code>gmirror clear</code> to remove it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror clear ada8</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> stores one block of metadata at the end of the disk. Because GPT partition schemes also store metadata at the end of the disk, mirroring entire GPT disks with <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> is not recommended. MBR partitioning is used here because it only stores a partition table at the start of the disk and does not conflict with the mirror metadata.</p></div></div><div class=sect3><h4 id=geom-mirror-two-new-disks>18.3.2. 使用兩個新磁碟建立鏡像<a class=anchor href=#geom-mirror-two-new-disks></a></h4><div class=paragraph><p>In this example, FreeBSD has already been installed on a single disk, <span class=filename>ada0</span>. Two new disks, <span class=filename>ada1</span> and <span class=filename>ada2</span>, have been connected to the system. A new mirror will be created on these two disks and used to replace the old single disk.</p></div><div class=paragraph><p>The <span class=filename>geom_mirror.ko</span> kernel module must either be built into the kernel or loaded at boot- or run-time. Manually load the kernel module now:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Create the mirror with the two new drives:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror label -v gm0 /dev/ada1 /dev/ada2</span></code></pre></div></div><div class=paragraph><p><span class=filename>gm0</span> is a user-chosen device name assigned to the new mirror. After the mirror has been started, this device name appears in <span class=filename>/dev/mirror/</span>.</p></div><div class=paragraph><p>MBR and bsdlabel partition tables can now be created on the mirror with <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>. This example uses a traditional file system layout, with partitions for <span class=filename>/</span>, swap, <span class=filename>/var</span>, <span class=filename>/tmp</span>, and <span class=filename>/usr</span>. A single <span class=filename>/</span> and a swap partition will also work.</p></div><div class=paragraph><p>Partitions on the mirror do not have to be the same size as those on the existing disk, but they must be large enough to hold all the data already present on <span class=filename>ada0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s MBR mirror/gm0</span>
<span class=c># gpart add -t freebsd -a 4k mirror/gm0</span>
<span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>       63  156301423  mirror/gm0  MBR  <span class=o>(</span>74G<span class=o>)</span>
         63         63                    - free -  <span class=o>(</span>31k<span class=o>)</span>
        126  156301299                 1  freebsd  <span class=o>(</span>74G<span class=o>)</span>
  156301425         61                    - free -  <span class=o>(</span>30k<span class=o>)</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s BSD mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k       mirror/gm0s1</span>
<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>        0  156301299  mirror/gm0s1  BSD  <span class=o>(</span>74G<span class=o>)</span>
          0          2                      - free -  <span class=o>(</span>1.0k<span class=o>)</span>
          2    4194304                   1  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
    4194306    8388608                   2  freebsd-swap  <span class=o>(</span>4.0G<span class=o>)</span>
   12582914    4194304                   4  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
   16777218    2097152                   5  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
   18874370  137426928                   6  freebsd-ufs  <span class=o>(</span>65G<span class=o>)</span>
  156301298          1                      - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Make the mirror bootable by installing bootcode in the MBR and bsdlabel and setting the active slice:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Format the file systems on the new mirror, enabling soft-updates.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span></code></pre></div></div><div class=paragraph><p>File systems from the original <span class=filename>ada0</span> disk can now be copied onto the mirror with <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/tmp</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/usr</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Edit <span class=filename>/mnt/etc/fstab</span> to point to the new mirror file systems:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/tmp		ufs	rw	2	2
/dev/mirror/gm0s1f	/usr		ufs	rw	2	2</pre></div></div><div class=paragraph><p>If the <span class=filename>geom_mirror.ko</span> kernel module has not been built into the kernel, <span class=filename>/mnt/boot/loader.conf</span> is edited to load the module at boot:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Reboot the system to test the new mirror and verify that all data has been copied. The BIOS will see the mirror as two individual drives rather than a mirror. Because the drives are identical, it does not matter which is selected to boot.</p></div><div class=paragraph><p>See <a href=#gmirror-troubleshooting>疑難排解</a> if there are problems booting. Powering down and disconnecting the original <span class=filename>ada0</span> disk will allow it to be kept as an offline backup.</p></div><div class=paragraph><p>In use, the mirror will behave just like the original single drive.</p></div></div><div class=sect3><h4 id=geom-mirror-existing-drive>18.3.3. 使用既有磁碟建立鏡像<a class=anchor href=#geom-mirror-existing-drive></a></h4><div class=paragraph><p>In this example, FreeBSD has already been installed on a single disk, <span class=filename>ada0</span>. A new disk, <span class=filename>ada1</span>, has been connected to the system. A one-disk mirror will be created on the new disk, the existing system copied onto it, and then the old disk will be inserted into the mirror. This slightly complex procedure is required because <code>gmirror</code> needs to put a 512-byte block of metadata at the end of each disk, and the existing <span class=filename>ada0</span> has usually had all of its space already allocated.</p></div><div class=paragraph><p>Load the <span class=filename>geom_mirror.ko</span> kernel module:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Check the media size of the original disk with <code>diskinfo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># diskinfo -v ada0 | head -n3</span>
/dev/ada0
	512             <span class=c># sectorsize</span>
	1000204821504   <span class=c># mediasize in bytes (931G)</span></code></pre></div></div><div class=paragraph><p>Create a mirror on the new disk. To make certain that the mirror capacity is not any larger than the original <span class=filename>ada0</span> drive, <a href="https://man.freebsd.org/cgi/man.cgi?query=gnop&amp;sektion=8&amp;format=html">gnop(8)</a> is used to create a fake drive of the exact same size. This drive does not store any data, but is used only to limit the size of the mirror. When <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> creates the mirror, it will restrict the capacity to the size of <span class=filename>gzero.nop</span>, even if the new <span class=filename>ada1</span> drive has more space. Note that the <em>1000204821504</em> in the second line is equal to <span class=filename>ada0</span>'s media size as shown by <code>diskinfo</code> above.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geom zero load</span>
<span class=c># gnop create -s 1000204821504 gzero</span>
<span class=c># gmirror label -v gm0 gzero.nop ada1</span>
<span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Since <span class=filename>gzero.nop</span> does not store any data, the mirror does not see it as connected. The mirror is told to "forget" unconnected components, removing references to <span class=filename>gzero.nop</span>. The result is a mirror device containing only a single disk, <span class=filename>ada1</span>.</p></div><div class=paragraph><p>After creating <span class=filename>gm0</span>, view the partition table on <span class=filename>ada0</span>. This output is from a 1 TB drive. If there is some unallocated space at the end of the drive, the contents may be copied directly from <span class=filename>ada0</span> to the new mirror.</p></div><div class=paragraph><p>However, if the output shows that all of the space on the disk is allocated, as in the following listing, there is no space available for the 512-byte mirror metadata at the end of the disk.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>        63  1953525105        ada0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525105           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>In this case, the partition table must be edited to reduce the capacity by one sector on <span class=filename>mirror/gm0</span>. The procedure will be explained later.</p></div><div class=paragraph><p>In either case, partition tables on the primary disk should be first copied using <code>gpart backup</code> and <code>gpart restore</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart backup ada0 &gt; table.ada0</span>
<span class=c># gpart backup ada0s1 &gt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>These commands create two files, <span class=filename>table.ada0</span> and <span class=filename>table.ada0s1</span>. This example is from a 1 TB drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525105   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640881</code></pre></div></div><div class=paragraph><p>If no free space is shown at the end of the disk, the size of both the slice and the last partition must be reduced by one sector. Edit the two files, reducing the size of both the slice and last partition by one. These are the last numbers in each listing.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525104   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640880</code></pre></div></div><div class=paragraph><p>If at least one sector was unallocated at the end of the disk, these two files can be used without modification.</p></div><div class=paragraph><p>Now restore the partition table into <span class=filename>mirror/gm0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart restore mirror/gm0 &lt; table.ada0</span>
<span class=c># gpart restore mirror/gm0s1 &lt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>Check the partition table with <code>gpart show</code>. This example has <span class=filename>gm0s1a</span> for <span class=filename>/</span>, <span class=filename>gm0s1d</span> for <span class=filename>/var</span>, <span class=filename>gm0s1e</span> for <span class=filename>/usr</span>, <span class=filename>gm0s1f</span> for <span class=filename>/data1</span>, and <span class=filename>gm0s1g</span> for <span class=filename>/data2</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>        63  1953525104  mirror/gm0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525042           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span>
  1953525105          62              - free -  <span class=o>(</span>31k<span class=o>)</span>

<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>         0  1953525042  mirror/gm0s1  BSD  <span class=o>(</span>931G<span class=o>)</span>
           0     2097152             1  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
     2097152    16777216             2  freebsd-swap  <span class=o>(</span>8.0G<span class=o>)</span>
    18874368    41943040             4  freebsd-ufs  <span class=o>(</span>20G<span class=o>)</span>
    60817408    20971520             5  freebsd-ufs  <span class=o>(</span>10G<span class=o>)</span>
    81788928   629145600             6  freebsd-ufs  <span class=o>(</span>300G<span class=o>)</span>
   710934528  1242590514             7  freebsd-ufs  <span class=o>(</span>592G<span class=o>)</span>
  1953525042          63                - free -  <span class=o>(</span>31k<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Both the slice and the last partition must have at least one free block at the end of the disk.</p></div><div class=paragraph><p>Create file systems on these new partitions. The number of partitions will vary to match the original disk, <span class=filename>ada0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span>
<span class=c># newfs -U /dev/mirror/gm0s1g</span></code></pre></div></div><div class=paragraph><p>Make the mirror bootable by installing bootcode in the MBR and bsdlabel and setting the active slice:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Adjust <span class=filename>/etc/fstab</span> to use the new partitions on the mirror. Back up this file first by copying it to <span class=filename>/etc/fstab.orig</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/fstab /etc/fstab.orig</span></code></pre></div></div><div class=paragraph><p>Edit <span class=filename>/etc/fstab</span>, replacing <span class=filename>/dev/ada0</span> with <span class=filename>mirror/gm0</span>.</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/usr		ufs	rw	2	2
/dev/mirror/gm0s1f	/data1		ufs	rw	2	2
/dev/mirror/gm0s1g	/data2		ufs	rw	2	2</pre></div></div><div class=paragraph><p>If the <span class=filename>geom_mirror.ko</span> kernel module has not been built into the kernel, edit <span class=filename>/boot/loader.conf</span> to load it at boot:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>File systems from the original disk can now be copied onto the mirror with <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>. Each file system dumped with <code>dump -L</code> will create a snapshot first, which can take some time.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - /    | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/usr</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/data1</span>
<span class=c># mount /dev/mirror/gm0s1g /mnt/data2</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Restart the system, booting from <span class=filename>ada1</span>. If everything is working, the system will boot from <span class=filename>mirror/gm0</span>, which now contains the same data as <span class=filename>ada0</span> had previously. See <a href=#gmirror-troubleshooting>疑難排解</a> if there are problems booting.</p></div><div class=paragraph><p>At this point, the mirror still consists of only the single <span class=filename>ada1</span> disk.</p></div><div class=paragraph><p>After booting from <span class=filename>mirror/gm0</span> successfully, the final step is inserting <span class=filename>ada0</span> into the mirror.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>When <span class=filename>ada0</span> is inserted into the mirror, its former contents will be overwritten by data from the mirror. Make certain that <span class=filename>mirror/gm0</span> has the same contents as <span class=filename>ada0</span> before adding <span class=filename>ada0</span> to the mirror. If the contents previously copied by <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> are not identical to what was on <span class=filename>ada0</span>, revert <span class=filename>/etc/fstab</span> to mount the file systems on <span class=filename>ada0</span>, reboot, and start the whole procedure again.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 ada0</span>
GEOM_MIRROR: Device gm0: rebuilding provider ada0</code></pre></div></div><div class=paragraph><p>Synchronization between the two disks will start immediately. Use <code>gmirror status</code> to view the progress.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror status</span>
      Name    Status  Components
mirror/gm0  DEGRADED  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>SYNCHRONIZING, 64%<span class=o>)</span></code></pre></div></div><div class=paragraph><p>After a while, synchronization will finish.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
<span class=c># gmirror status</span>
      Name    Status  Components
mirror/gm0  COMPLETE  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>ACTIVE<span class=o>)</span></code></pre></div></div><div class=paragraph><p><span class=filename>mirror/gm0</span> now consists of the two disks <span class=filename>ada0</span> and <span class=filename>ada1</span>, and the contents are automatically synchronized with each other. In use, <span class=filename>mirror/gm0</span> will behave just like the original single drive.</p></div></div><div class=sect3><h4 id=gmirror-troubleshooting>18.3.4. 疑難排解<a class=anchor href=#gmirror-troubleshooting></a></h4><div class=paragraph><p>If the system no longer boots, BIOS settings may have to be changed to boot from one of the new mirrored drives. Either mirror drive can be used for booting, as they contain identical data.</p></div><div class=paragraph><p>If the boot stops with this message, something is wrong with the mirror device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

Loader variables:
  vfs.root.mountfrom<span class=o>=</span>ufs:/dev/mirror/gm0s1a
  vfs.root.mountfrom.options<span class=o>=</span>rw

Manual root filesystem specification:
  &lt;fstype&gt;:&lt;device&gt; <span class=o>[</span>options]
      Mount &lt;device&gt; using filesystem &lt;fstype&gt;
      and with the specified <span class=o>(</span>optional<span class=o>)</span> option list.

    eg. ufs:/dev/da0s1a
        zfs:tank
        cd9660:/dev/acd0 ro
          <span class=o>(</span>which is equivalent to: mount <span class=nt>-t</span> cd9660 <span class=nt>-o</span> ro /dev/acd0 /<span class=o>)</span>

  ?               List valid disk boot devices
  <span class=nb>.</span>               Yield 1 second <span class=o>(</span><span class=k>for </span>background tasks<span class=o>)</span>
  &lt;empty line&gt;    Abort manual input

mountroot&gt;</code></pre></div></div><div class=paragraph><p>Forgetting to load the <span class=filename>geom_mirror.ko</span> module in <span class=filename>/boot/loader.conf</span> can cause this problem. To fix it, boot from a FreeBSD installation media and choose <code>Shell</code> at the first prompt. Then load the mirror module and mount the mirror device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span>
<span class=c># mount /dev/mirror/gm0s1a /mnt</span></code></pre></div></div><div class=paragraph><p>Edit <span class=filename>/mnt/boot/loader.conf</span>, adding a line to load the mirror module:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Save the file and reboot.</p></div><div class=paragraph><p>Other problems that cause <code>error 19</code> require more effort to fix. Although the system should boot from <span class=filename>ada0</span>, another prompt to select a shell will appear if <span class=filename>/etc/fstab</span> is incorrect. Enter <code>ufs:/dev/ada0s1a</code> at the boot loader prompt and press <kbd>Enter</kbd>. Undo the edits in <span class=filename>/etc/fstab</span> then mount the file systems from the original disk (<span class=filename>ada0</span>) instead of the mirror. Reboot the system and try the procedure again.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter full pathname of shell or RETURN <span class=k>for</span> /bin/sh:
<span class=c># cp /etc/fstab.orig /etc/fstab</span>
<span class=c># reboot</span></code></pre></div></div></div><div class=sect3><h4 id=_自磁碟故障復原>18.3.5. 自磁碟故障復原<a class=anchor href=#_自磁碟故障復原></a></h4><div class=paragraph><p>The benefit of disk mirroring is that an individual disk can fail without causing the mirror to lose any data. In the above example, if <span class=filename>ada0</span> fails, the mirror will continue to work, providing data from the remaining working drive, <span class=filename>ada1</span>.</p></div><div class=paragraph><p>To replace the failed drive, shut down the system and physically replace the failed drive with a new drive of equal or greater capacity. Manufacturers use somewhat arbitrary values when rating drives in gigabytes, and the only way to really be sure is to compare the total count of sectors shown by <code>diskinfo -v</code>. A drive with larger capacity than the mirror will work, although the extra space on the new drive will not be used.</p></div><div class=paragraph><p>After the computer is powered back up, the mirror will be running in a "degraded" mode with only one drive. The mirror is told to forget drives that are not currently connected:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Any old metadata should be cleared from the replacement disk using the instructions in <a href=#geom-mirror-metadata>Metadata 問題</a>. Then the replacement disk, <span class=filename>ada4</span> for this example, is inserted into the mirror:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 /dev/ada4</span></code></pre></div></div><div class=paragraph><p>Resynchronization begins when the new drive is inserted into the mirror. This process of copying mirror data to a new drive can take a while. Performance of the mirror will be greatly reduced during the copy, so inserting new drives is best done when there is low demand on the computer.</p></div><div class=paragraph><p>Progress can be monitored with <code>gmirror status</code>, which shows drives that are being synchronized and the percentage of completion. During resynchronization, the status will be <code>DEGRADED</code>, changing to <code>COMPLETE</code> when the process is finished.</p></div></div></div><div class=sect2><h3 id=geom-raid3>18.4. RAID3 - 位元級串連與獨立奇偶校驗<a class=anchor href=#geom-raid3></a></h3><div class=paragraph><p>RAID3 is a method used to combine several disk drives into a single volume with a dedicated parity disk. In a RAID3 system, data is split up into a number of bytes that are written across all the drives in the array except for one disk which acts as a dedicated parity disk. This means that disk reads from a RAID3 implementation access all disks in the array. Performance can be enhanced by using multiple disk controllers. The RAID3 array provides a fault tolerance of 1 drive, while providing a capacity of 1 - 1/n times the total capacity of all drives in the array, where n is the number of hard drives in the array. Such a configuration is mostly suitable for storing data of larger sizes such as multimedia files.</p></div><div class=paragraph><p>At least 3 physical hard drives are required to build a RAID3 array. Each disk must be of the same size, since I/O requests are interleaved to read or write to multiple disks in parallel. Also, due to the nature of RAID3, the number of drives must be equal to 3, 5, 9, 17, and so on, or 2^n + 1.</p></div><div class=paragraph><p>This section demonstrates how to create a software RAID3 on a FreeBSD system.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>While it is theoretically possible to boot from a RAID3 array on FreeBSD, that configuration is uncommon and is not advised.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_建立_dedicated_raid3_陣列>18.4.1. 建立 Dedicated RAID3 陣列<a class=anchor href=#_建立_dedicated_raid3_陣列></a></h4><div class=paragraph><p>In FreeBSD, support for RAID3 is implemented by the <a href="https://man.freebsd.org/cgi/man.cgi?query=graid3&amp;sektion=8&amp;format=html">graid3(8)</a>GEOM class. Creating a dedicated RAID3 array on FreeBSD requires the following steps.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>First, load the <span class=filename>geom_raid3.ko</span> kernel module by issuing one of the following commands:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 load</span></code></pre></div></div><div class=paragraph><p>or:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_raid3</span></code></pre></div></div></li><li><p>Ensure that a suitable mount point exists. This command creates a new directory to use as the mount point:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /multimedia</span></code></pre></div></div></li><li><p>Determine the device names for the disks which will be added to the array, and create the new RAID3 device. The final device listed will act as the dedicated parity disk. This example uses three unpartitioned ATA drives: <span class=filename>ada1</span> and <span class=filename>ada2</span> for data, and <span class=filename>ada3</span> for parity.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</span>
Metadata value stored on /dev/ada1.
Metadata value stored on /dev/ada2.
Metadata value stored on /dev/ada3.
Done.</code></pre></div></div></li><li><p>Partition the newly created <span class=filename>gr0</span> device and put a UFS file system on it:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT /dev/raid3/gr0</span>
<span class=c># gpart add -t freebsd-ufs /dev/raid3/gr0</span>
<span class=c># newfs -j /dev/raid3/gr0p1</span></code></pre></div></div><div class=paragraph><p>Many numbers will glide across the screen, and after a bit of time, the process will be complete. The volume has been created and is ready to be mounted:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/raid3/gr0p1 /multimedia/</span></code></pre></div></div><div class=paragraph><p>The RAID3 array is now ready to use.</p></div></li></ol></div></div></div><div class=paragraph><p>Additional configuration is needed to retain this setup across system reboots.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>The <span class=filename>geom_raid3.ko</span> module must be loaded before the array can be mounted. To automatically load the kernel module during system initialization, add the following line to <span class=filename>/boot/loader.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>geom_raid3_load=&#34;YES&#34;</pre></div></div></li><li><p>The following volume information must be added to <span class=filename>/etc/fstab</span> in order to automatically mount the array’s file system during the system boot process:</p><div class="literalblock programlisting"><div class=content><pre>/dev/raid3/gr0p1	/multimedia	ufs	rw	2	2</pre></div></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=geom-graid>18.5. 軟體 RAID 裝置<a class=anchor href=#geom-graid></a></h3><div class=paragraph><p>Some motherboards and expansion cards add some simple hardware, usually just a ROM, that allows the computer to boot from a RAID array. After booting, access to the RAID array is handled by software running on the computer’s main processor. This "hardware-assisted software RAID" gives RAID arrays that are not dependent on any particular operating system, and which are functional even before an operating system is loaded.</p></div><div class=paragraph><p>Several levels of RAID are supported, depending on the hardware in use. See <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> for a complete list.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> requires the <span class=filename>geom_raid.ko</span> kernel module, which is included in the <span class=filename>GENERIC</span> kernel starting with FreeBSD 9.1. If needed, it can be loaded manually with <code>graid load</code>.</p></div><div class=sect3><h4 id=geom-graid-creating>18.5.1. 建立陣列<a class=anchor href=#geom-graid-creating></a></h4><div class=paragraph><p>Software RAID devices often have a menu that can be entered by pressing special keys when the computer is booting. The menu can be used to create and delete RAID arrays. <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> can also create arrays directly from the command line.</p></div><div class=paragraph><p><code>graid label</code> is used to create a new array. The motherboard used for this example has an Intel software RAID chipset, so the Intel metadata format is specified. The new array is given a label of <span class=filename>gm0</span>, it is a mirror (RAID1), and uses drives <span class=filename>ada0</span> and <span class=filename>ada1</span>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Some space on the drives will be overwritten when they are made into a new array. Back up existing data first!</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 ada1</span>
GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.
GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Array started.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.
Intel-a29ea104 created
GEOM_RAID: Intel-a29ea104: Provider raid/r0 <span class=k>for </span>volume gm0 created.</code></pre></div></div><div class=paragraph><p>A status check shows the new mirror is ready for use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>The array device appears in <span class=filename>/dev/raid/</span>. The first array is called <span class=filename>r0</span>. Additional arrays, if present, will be <span class=filename>r1</span>, <span class=filename>r2</span>, and so on.</p></div><div class=paragraph><p>The BIOS menu on some of these devices can create arrays with special characters in their names. To avoid problems with those special characters, arrays are given simple numbered names like <span class=filename>r0</span>. To show the actual labels, like <span class=filename>gm0</span> in the example above, use <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.raid.name_format=1</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-volumes>18.5.2. 多磁碟區<a class=anchor href=#geom-graid-volumes></a></h4><div class=paragraph><p>Some software RAID devices support more than one <em>volume</em> on an array. Volumes work like partitions, allowing space on the physical drives to be split and used in different ways. For example, Intel software RAID devices support two volumes. This example creates a 40 G mirror for safely storing the operating system, followed by a 20 G RAID0 (stripe) volume for fast temporary storage:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label -S 40G Intel gm0 RAID1 ada0 ada1</span>
<span class=c># graid add -S 20G gm0 RAID0</span></code></pre></div></div><div class=paragraph><p>Volumes appear as additional <span class=filename>rX</span> entries in <span class=filename>/dev/raid/</span>. An array with two volumes will show <span class=filename>r0</span> and <span class=filename>r1</span>.</p></div><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> for the number of volumes supported by different software RAID devices.</p></div></div><div class=sect3><h4 id=geom-graid-converting>18.5.3. 轉換單一磁碟為鏡像<a class=anchor href=#geom-graid-converting></a></h4><div class=paragraph><p>Under certain specific conditions, it is possible to convert an existing single drive to a <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> array without reformatting. To avoid data loss during the conversion, the existing drive must meet these minimum requirements:</p></div><div class=ulist><ul><li><p>The drive must be partitioned with the MBR partitioning scheme. GPT or other partitioning schemes with metadata at the end of the drive will be overwritten and corrupted by the <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> metadata.</p></li><li><p>There must be enough unpartitioned and unused space at the end of the drive to hold the <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> metadata. This metadata varies in size, but the largest occupies 64 M, so at least that much free space is recommended.</p></li></ul></div><div class=paragraph><p>If the drive meets these requirements, start by making a full backup. Then create a single-drive mirror with that drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 NONE</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> metadata was written to the end of the drive in the unused space. A second drive can now be inserted into the mirror:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span></code></pre></div></div><div class=paragraph><p>Data from the original drive will immediately begin to be copied to the second drive. The mirror will operate in degraded status until the copy is complete.</p></div></div><div class=sect3><h4 id=geom-graid-inserting>18.5.4. 插入新磁碟到陣列<a class=anchor href=#geom-graid-inserting></a></h4><div class=paragraph><p>Drives can be inserted into an array as replacements for drives that have failed or are missing. If there are no failed or missing drives, the new drive becomes a spare. For example, inserting a new drive into a working two-drive mirror results in a two-drive mirror with one spare drive, not a three-drive mirror.</p></div><div class=paragraph><p>In the example mirror array, data immediately begins to be copied to the newly-inserted drive. Any existing information on the new drive will be overwritten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.</code></pre></div></div></div><div class=sect3><h4 id=geom-graid-removing>18.5.5. 從陣列移除磁碟<a class=anchor href=#geom-graid-removing></a></h4><div class=paragraph><p>Individual drives can be permanently removed from a from an array and their metadata erased:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid remove raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.</code></pre></div></div></div><div class=sect3><h4 id=geom-graid-stopping>18.5.6. 停止陣列<a class=anchor href=#geom-graid-stopping></a></h4><div class=paragraph><p>An array can be stopped without removing metadata from the drives. The array will be restarted when the system is booted.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid stop raid/r0</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-status>18.5.7. 檢查陣列狀態<a class=anchor href=#geom-graid-status></a></h4><div class=paragraph><p>Array status can be checked at any time. After a drive was added to the mirror in the example above, data is being copied from the original drive to the new drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name    Status  Components
raid/r0  DEGRADED  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                   ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>REBUILD 28%<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Some types of arrays, like <code>RAID0</code> or <code>CONCAT</code>, may not be shown in the status report if disks have failed. To see these partially-failed arrays, add <code>-ga</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status -ga</span>
          Name  Status  Components
Intel-e2d07d9a  BROKEN  ada6 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-deleting>18.5.8. 刪除陣列<a class=anchor href=#geom-graid-deleting></a></h4><div class=paragraph><p>Arrays are destroyed by deleting all of the volumes from them. When the last volume present is deleted, the array is stopped and metadata is removed from the drives:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-unexpected>18.5.9. 刪除預期之外的陣列<a class=anchor href=#geom-graid-unexpected></a></h4><div class=paragraph><p>Drives may unexpectedly contain <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> metadata, either from previous use or manufacturer testing. <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> will detect these drives and create an array, interfering with access to the individual drive. To remove the unwanted metadata:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Boot the system. At the boot menu, select <code>2</code> for the loader prompt. Enter:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>OK <span class=nb>set </span>kern.geom.raid.enable<span class=o>=</span>0
OK boot</code></pre></div></div><div class=paragraph><p>The system will boot with <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> disabled.</p></div></li><li><p>Back up all data on the affected drive.</p></li><li><p>As a workaround, <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> array detection can be disabled by adding</p><div class="literalblock programlisting"><div class=content><pre>kern.geom.raid.enable=0</pre></div></div><div class=paragraph><p>to <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>To permanently remove the <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> metadata from the affected drive, boot a FreeBSD installation CD-ROM or memory stick, and select <code>Shell</code>. Use <code>status</code> to find the name of the array, typically <code>raid/r0</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Delete the volume by name:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div><div class=paragraph><p>If there is more than one volume shown, repeat the process for each volume. After the last array has been deleted, the volume will be destroyed.</p></div><div class=paragraph><p>Reboot and verify data, restoring from backup if necessary. After the metadata has been removed, the <code>kern.geom.raid.enable=0</code> entry in <span class=filename>/boot/loader.conf</span> can also be removed.</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=geom-ggate>18.6. GEOM Gate Network<a class=anchor href=#geom-ggate></a></h3><div class=paragraph><p>GEOM provides a simple mechanism for providing remote access to devices such as disks, CDs, and file systems through the use of the GEOM Gate network daemon, ggated. The system with the device runs the server daemon which handles requests made by clients using ggatec. The devices should not contain any sensitive data as the connection between the client and the server is not encrypted.</p></div><div class=paragraph><p>Similar to NFS, which is discussed in <a href=./#network-nfs>網路檔案系統 (NFS)</a>, ggated is configured using an exports file. This file specifies which systems are permitted to access the exported resources and what level of access they are offered. For example, to give the client <code>192.168.1.5</code> read and write access to the fourth slice on the first SCSI disk, create <span class=filename>/etc/gg.exports</span> with this line:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.1.5 RW /dev/da0s4d</pre></div></div><div class=paragraph><p>Before exporting the device, ensure it is not currently mounted. Then, start ggated:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggated</span></code></pre></div></div><div class=paragraph><p>Several options are available for specifying an alternate listening port or changing the default location of the exports file. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ggated&amp;sektion=8&amp;format=html">ggated(8)</a> for details.</p></div><div class=paragraph><p>To access the exported device on the client machine, first use <code>ggatec</code> to specify the IP address of the server and the device name of the exported device. If successful, this command will display a <code>ggate</code> device name to mount. Mount that specified device name on a free mount point. This example connects to the <span class=filename>/dev/da0s4d</span> partition on <code>192.168.1.1</code>, then mounts <span class=filename>/dev/ggate0</span> on <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggatec create -o rw 192.168.1.1 /dev/da0s4d</span>
ggate0
<span class=c># mount /dev/ggate0 /mnt</span></code></pre></div></div><div class=paragraph><p>The device on the server may now be accessed through <span class=filename>/mnt</span> on the client. For more details about <code>ggatec</code> and a few usage examples, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ggatec&amp;sektion=8&amp;format=html">ggatec(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The mount will fail if the device is currently mounted on either the server or any other client on the network. If simultaneous access is needed to network resources, use NFS instead.</p></div></td></tr></tbody></table></div><div class=paragraph><p>When the device is no longer needed, unmount it with <code>umount</code> so that the resource is available to other clients.</p></div></div><div class=sect2><h3 id=geom-glabel>18.7. 磁碟裝置標籤<a class=anchor href=#geom-glabel></a></h3><div class=paragraph><p>During system initialization, the FreeBSD kernel creates device nodes as devices are found. This method of probing for devices raises some issues. For instance, what if a new disk device is added via USB? It is likely that a flash device may be handed the device name of <span class=filename>da0</span> and the original <span class=filename>da0</span> shifted to <span class=filename>da1</span>. This will cause issues mounting file systems if they are listed in <span class=filename>/etc/fstab</span> which may also prevent the system from booting.</p></div><div class=paragraph><p>One solution is to chain SCSI devices in order so a new device added to the SCSI card will be issued unused device numbers. But what about USB devices which may replace the primary SCSI disk? This happens because USB devices are usually probed before the SCSI card. One solution is to only insert these devices after the system has been booted. Another method is to use only a single ATA drive and never list the SCSI devices in <span class=filename>/etc/fstab</span>.</p></div><div class=paragraph><p>A better solution is to use <code>glabel</code> to label the disk devices and use the labels in <span class=filename>/etc/fstab</span>. Because <code>glabel</code> stores the label in the last sector of a given provider, the label will remain persistent across reboots. By using this label as a device, the file system may always be mounted regardless of what device node it is accessed through.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>glabel</code> can create both transient and permanent labels. Only permanent labels are consistent across reboots. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> for more information on the differences between labels.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_標籤類型與範例>18.7.1. 標籤類型與範例<a class=anchor href=#_標籤類型與範例></a></h4><div class=paragraph><p>Permanent labels can be a generic or a file system label. Permanent file system labels can be created with <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>. These types of labels are created in a sub-directory of <span class=filename>/dev</span>, and will be named according to the file system type. For example, UFS2 file system labels will be created in <span class=filename>/dev/ufs</span>. Generic permanent labels can be created with <code>glabel label</code>. These are not file system specific and will be created in <span class=filename>/dev/label</span>.</p></div><div class=paragraph><p>Temporary labels are destroyed at the next reboot. These labels are created in <span class=filename>/dev/label</span> and are suited to experimentation. A temporary label can be created using <code>glabel create</code>.</p></div><div class=paragraph><p>To create a permanent label for a UFS2 file system without destroying any data, issue the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -L home /dev/da3</span></code></pre></div></div><div class=paragraph><p>A label should now exist in <span class=filename>/dev/ufs</span> which may be added to <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufs/home		/home            ufs     rw              2      2</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The file system must not be mounted while attempting to run <code>tunefs</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Now the file system may be mounted:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /home</span></code></pre></div></div><div class=paragraph><p>From this point on, so long as the <span class=filename>geom_label.ko</span> kernel module is loaded at boot with <span class=filename>/boot/loader.conf</span> or the <code>GEOM_LABEL</code> kernel option is present, the device node may change without any ill effect on the system.</p></div><div class=paragraph><p>File systems may also be created with a default label by using the <code>-L</code> flag with <code>newfs</code>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> for more information.</p></div><div class=paragraph><p>The following command can be used to destroy the label:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel destroy home</span></code></pre></div></div><div class=paragraph><p>The following example shows how to label the partitions of a boot disk.</p></div><div class=exampleblock><div class=title>例 43. 在開機磁碟標記分割區標籤</div><div class=content><div class=paragraph><p>By permanently labeling the partitions on the boot disk, the system should be able to continue to boot normally, even if the disk is moved to another controller or transferred to a different system. For this example, it is assumed that a single ATA disk is used, which is currently recognized by the system as <span class=filename>ad0</span>. It is also assumed that the standard FreeBSD partition scheme is used, with <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/usr</span> and <span class=filename>/tmp</span>, as well as a swap partition.</p></div><div class=paragraph><p>Reboot the system, and at the <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> prompt, press <kbd>4</kbd> to boot into single user mode. Then enter the following commands:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel label rootfs /dev/ad0s1a</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1a is label/rootfs
<span class=c># glabel label var /dev/ad0s1d</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1d is label/var
<span class=c># glabel label usr /dev/ad0s1f</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1f is label/usr
<span class=c># glabel label tmp /dev/ad0s1e</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1e is label/tmp
<span class=c># glabel label swap /dev/ad0s1b</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1b is label/swap
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>The system will continue with multi-user boot. After the boot completes, edit <span class=filename>/etc/fstab</span> and replace the conventional device names, with their respective labels. The final <span class=filename>/etc/fstab</span> will look like this:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2</pre></div></div><div class=paragraph><p>The system can now be rebooted. If everything went well, it will come up normally and <code>mount</code> will show:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/label/rootfs on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/label/tmp on /tmp <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/usr on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/var on /var <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> class supports a label type for UFS file systems, based on the unique file system id, <code>ufsid</code>. These labels may be found in <span class=filename>/dev/ufsid</span> and are created automatically during system startup. It is possible to use <code>ufsid</code> labels to mount partitions using <span class=filename>/etc/fstab</span>. Use <code>glabel status</code> to receive a list of file systems and their corresponding <code>ufsid</code> labels:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% glabel status
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</code></pre></div></div><div class=paragraph><p>In the above example, <span class=filename>ad4s1d</span> represents <span class=filename>/var</span>, while <span class=filename>ad4s1f</span> represents <span class=filename>/usr</span>. Using the <code>ufsid</code> values shown, these partitions may now be mounted with the following entries in <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2</pre></div></div><div class=paragraph><p>Any partitions with <code>ufsid</code> labels can be mounted in this way, eliminating the need to manually create permanent labels, while still enjoying the benefits of device name independent mounting.</p></div></div></div><div class=sect2><h3 id=geom-gjournal>18.8. UFS Journaling 透過 GEOM<a class=anchor href=#geom-gjournal></a></h3><div class=paragraph><p>Support for journals on UFS file systems is available on FreeBSD. The implementation is provided through the GEOM subsystem and is configured using <code>gjournal</code>. Unlike other file system journaling implementations, the <code>gjournal</code> method is block based and not implemented as part of the file system. It is a GEOM extension.</p></div><div class=paragraph><p>Journaling stores a log of file system transactions, such as changes that make up a complete disk write operation, before meta-data and file writes are committed to the disk. This transaction log can later be replayed to redo file system transactions, preventing file system inconsistencies.</p></div><div class=paragraph><p>This method provides another mechanism to protect against data loss and inconsistencies of the file system. Unlike Soft Updates, which tracks and enforces meta-data updates, and snapshots, which create an image of the file system, a log is stored in disk space specifically for this task. For better performance, the journal may be stored on another disk. In this configuration, the journal provider or storage device should be listed after the device to enable journaling on.</p></div><div class=paragraph><p>The <span class=filename>GENERIC</span> kernel provides support for <code>gjournal</code>. To automatically load the <span class=filename>geom_journal.ko</span> kernel module at boot time, add the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_journal_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>If a custom kernel is used, ensure the following line is in the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_JOURNAL</pre></div></div><div class=paragraph><p>Once the module is loaded, a journal can be created on a new file system using the following steps. In this example, <span class=filename>da4</span> is a new SCSI disk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gjournal load</span>
<span class=c># gjournal label /dev/da4</span></code></pre></div></div><div class=paragraph><p>This will load the module and create a <span class=filename>/dev/da4.journal</span> device node on <span class=filename>/dev/da4</span>.</p></div><div class=paragraph><p>A UFS file system may now be created on the journaled device, then mounted on an existing mount point:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -O 2 -J /dev/da4.journal</span>
<span class=c># mount /dev/da4.journal /mnt</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In the case of several slices, a journal will be created for each individual slice. For instance, if <span class=filename>ad4s1</span> and <span class=filename>ad4s2</span> are both slices, then <code>gjournal</code> will create <span class=filename>ad4s1.journal</span> and <span class=filename>ad4s2.journal</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Journaling may also be enabled on current file systems by using <code>tunefs</code>. However, <em>always</em> make a backup before attempting to alter an existing file system. In most cases, <code>gjournal</code> will fail if it is unable to create the journal, but this does not protect against data loss incurred as a result of misusing <code>tunefs</code>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=gjournal&amp;sektion=8&amp;format=html">gjournal(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> for more information about these commands.</p></div><div class=paragraph><p>It is possible to journal the boot disk of a FreeBSD system. Refer to the article <a href=https://docs.freebsd.org/en/articles/gjournal-desktop/>Implementing UFS Journaling on a Desktop PC</a> for detailed instructions.</p></div></div></div></div><div class=sect1><h2 id=zfs>Chapter 19. Z 檔案系統 (ZFS)<a class=anchor href=#zfs></a></h2><div class=sectionbody><div class=paragraph><p><em>Z 檔案系統</em> 或 ZFS 是設計來克服許多在以往設計中發現的主要問題的一個先進的檔案系統。</p></div><div class=paragraph><p>最初由 Sun™ 所開發，後來的開放源始碼 ZFS 開發已移到 <a href=http://open-zfs.org>OpenZFS 計劃</a>。</p></div><div class=paragraph><p>ZFS 的設計目標主要有三個：</p></div><div class=ulist><ul><li><p>資料完整性：所有資料都會有一個資料的校驗碼 (<a href=#zfs-term-checksum>checksum</a>)，資料寫入時會計算校驗碼然後一併寫入，往後讀取資料時會再計算一次校驗碼，若校驗碼與當初寫入時不相符，便可偵測到資料錯誤，此時若有可用的資料備援 (Data redundancy)，ZFS 會嘗試自動修正錯誤。</p></li><li><p>儲存池：實體的儲存裝置都會先被加入到一個儲存池 (Pool)，這個共用的儲存池可用來配置儲存空間，儲存池的空間可被所有的檔案系統使用且透過加入新的儲存裝置來增加空間。</p></li><li><p>效能：提供多個快取機制來增加效能。先進、以記憶體為基礎的讀取快取可使用 <a href=#zfs-term-arc>ARC</a>。第二層以磁碟為基礎的讀取快取可使用 <a href=#zfs-term-l2arc>L2ARC</a>，以磁碟為基礎的同步寫入快取則可使用 <a href=#zfs-term-zil>ZIL</a>。</p></li></ul></div><div class=paragraph><p>完整的功能清單與術語在 <a href=#zfs-term>ZFS 特色與術語</a> 中有詳述。</p></div><div class=sect2><h3 id=zfs-differences>19.1. 什麼使 ZFS 與眾不同<a class=anchor href=#zfs-differences></a></h3><div class=paragraph><p>ZFS 與以往任何的檔案系統有顯著的不同，因為它不只是一個檔案系統，ZFS 的獨特優點來自結合了以往被分開的磁碟區管理程式 (Volume Manager) 及檔案系統兩個角色，讓檔案系統也能夠察覺磁碟底層結構的變動。傳統在一個磁碟上只能建立一個檔案系統，若有兩個磁碟則會需要建立兩個分開的檔案系統，在傳統要解決這個問題要使用硬體 RAID 來製作一個空間實際上由數顆實體磁碟所組成的單一的邏輯磁碟給作業系統，作業系統便可在這個邏輯磁碟上放置檔案系統，即使是在那些使用 GEOM 提供的軟體 RAID 解決方案也是一樣，把 UFS 檔案系統放在 RAID Transform 上面當做是一個單一的裝置。ZFS 結合了磁碟區管理程式 (Volume Manager) 與檔案系統來解決這個問題並讓建立多個檔案系統可以共用一個儲存池 (Pool)。ZFS 最大的優點是可以察覺實體磁碟配置的變動，當有額外的磁碟加入到儲存池時可以自動擴增現有的檔案系統，所有的檔案系統便可使用這個新的空間。ZFS 也有數個不同的屬性可以套用到各別檔案系統上，比起單一檔案系統，對建立數個不同檔案系統與資料集 (Dataset) 時有許多的好處。</p></div></div><div class=sect2><h3 id=zfs-quickstart>19.2. 快速入門指南<a class=anchor href=#zfs-quickstart></a></h3><div class=paragraph><p>這裡有一個啟動機制，可讓 FreeBSD 在系統初始化時掛載 ZFS 儲存池。要開啟這個功能，可加入此行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>zfs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>然後啟動服務：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service zfs start</span></code></pre></div></div><div class=paragraph><p>本節的例子會假設有三個 SCSI 磁碟，名稱分別為 <span class=filename>da0</span>, <span class=filename>da1</span> 及 <span class=filename>da2</span>。SATA 硬體的使用者裝置名稱改為 <span class=filename>ada</span> 。</p></div><div class=sect3><h4 id=zfs-quickstart-single-disk-pool>19.2.1. 單磁碟儲存池<a class=anchor href=#zfs-quickstart-single-disk-pool></a></h4><div class=paragraph><p>要使用一個磁碟裝置建立一個簡單、無備援的儲存池可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create example /dev/da0</span></code></pre></div></div><div class=paragraph><p>要檢視這個新的儲存池，可查看 <code>df</code> 的輸出結果：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example</code></pre></div></div><div class=paragraph><p>這個輸出結果說明 <code>example</code> 儲存池已建立且被掛載，現在已經可以作為檔案系統存取，可以在上面建立檔案且使用者可以瀏覽：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /example</span>
<span class=c># ls</span>
<span class=c># touch testfile</span>
<span class=c># ls -al</span>
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 <span class=nb>.</span>
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
<span class=nt>-rw-r--r--</span>   1 root  wheel    0 Aug 29 23:15 testfile</code></pre></div></div><div class=paragraph><p>但是，這個儲存池並未運用到任何 ZFS 功能，若要在這個儲存池上建立一個有開啟壓縮功能的資料集：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create example/compressed</span>
<span class=c># zfs set compression=gzip example/compressed</span></code></pre></div></div><div class=paragraph><p><code>example/compressed</code> 資料集現在是一個 ZFS 壓縮的檔案系統，可以試著複製較大的檔案到 <span class=filename>/example/compressed</span>。</p></div><div class=paragraph><p>壓縮功能也可以使用以下指令關閉：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set compression=off example/compressed</span></code></pre></div></div><div class=paragraph><p>要卸載檔案系統，使用 <code>zfs umount</code> 然後再使用 <code>df</code> 確認：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs umount example/compressed</span>
<span class=c># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example</code></pre></div></div><div class=paragraph><p>要重新掛載檔案系統以便再次使用，使用 <code>zfs mount</code> 然後以 <code>df</code> 檢查：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs mount example/compressed</span>
<span class=c># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed</code></pre></div></div><div class=paragraph><p>儲存池與檔案系統也可以從 <code>mount</code> 的結果查詢到：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/ad0s1a on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/ad0s1d on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
example on /example <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
example/compressed on /example/compressed <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span></code></pre></div></div><div class=paragraph><p>在建立之後，ZFS 的資料集可如同其他檔案系統一般使用，且有許多額外功能可在每個資料集上設定。例如，建立一個預計存放重要的資料的新檔案系統 <code>data</code>，要設定每個資料區塊 (Data block) 要保留兩份備份：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create example/data</span>
<span class=c># zfs set copies=2 example/data</span></code></pre></div></div><div class=paragraph><p>現在，可以使用 <code>df</code> 指令來查看資料與空間的使用率：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data</code></pre></div></div><div class=paragraph><p>注意，從這個可以發現每個在儲存池上的檔案系統都擁有相同的可用空間，這是為什麼要在這些範例使用 <code>df</code> 的原因，為了要顯示檔案系統只會用它們所需要使用到的空間，且均取自同一個儲存池。ZFS 淘汰了磁碟區 (Volume) 與分割區 (Partition) 的概念，且允許多個檔案系統共用相同的儲存池。</p></div><div class=paragraph><p>不需要使用時可摧毀檔案系統後再摧毀儲存池：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs destroy example/compressed</span>
<span class=c># zfs destroy example/data</span>
<span class=c># zpool destroy example</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-quickstart-raid-z>19.2.2. RAID-Z<a class=anchor href=#zfs-quickstart-raid-z></a></h4><div class=paragraph><p>磁碟損壞時，要避免資料因磁碟故障造成遺失便是使用 RAID。ZFS 在它的儲存池設計中支援了這項功能。RAID-Z 儲存池需要使用三個或更多的磁碟，但可以提供比鏡像 (Mirror) 儲存池更多的可用空間。</p></div><div class=paragraph><p>這個例子會建立一個 RAID-Z 儲存池，並指定要加入這個儲存池的磁碟：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create storage raidz da0 da1 da2</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sun™ 建議用在 RAID-Z 設定的裝置數在三到九個之間。若需要由 10 個或更多磁碟組成單一儲存池的環境，可考慮分成較小的 RAID-Z 群組。若只有兩個可用的磁碟且需要做備援 (Redundancy)，可考慮使用 ZFS 鏡像 (Mirror)。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a> 取得更多詳細資訊。</p></div></td></tr></tbody></table></div><div class=paragraph><p>先前的例子已經建立了 <code>storage</code> 儲存池 (zpool)，現在這個例子會在該儲存池中建立一個新的檔案系統，名稱為 <code>home</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create storage/home</span></code></pre></div></div><div class=paragraph><p>可以設定開啟壓縮及保留目錄及檔案額外備份的功能：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set copies=2 storage/home</span>
<span class=c># zfs set compression=gzip storage/home</span></code></pre></div></div><div class=paragraph><p>要讓這個空間作為使用者的新家目錄位置，需複製使用者資料到這個目錄並建立適合的符號連結 (Symbolic link)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp -rp /home/* /storage/home</span>
<span class=c># rm -rf /home /usr/home</span>
<span class=c># ln -s /storage/home /home</span>
<span class=c># ln -s /storage/home /usr/home</span></code></pre></div></div><div class=paragraph><p>現在使用者的資料會儲存在新建立的 <span class=filename>/storage/home</span>，可以加入新使用者並登入該使用者來測試。</p></div><div class=paragraph><p>試著建立檔案系統快照 (Snapshot)，稍後可用來還原 (Rollback)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>快照只可以使用整個檔案系統製作，無法使用各別目錄或檔案。</p></div><div class=paragraph><p><code>@</code> 字元用來區隔檔案系統名稱 (File system) 或磁碟區 (Volume) 名稱，若有重要的目錄意外被刪除，檔案系統可以備份然後還原到先前目錄還存在時的快照 (Snapshot)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs rollback storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>要列出所有可用的快照，可在檔案系統的 <span class=filename>.zfs/snapshot</span> 目錄執行 <code>ls</code>，舉例來說，要查看先前已做的快照：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /storage/home/.zfs/snapshot</span></code></pre></div></div><div class=paragraph><p>也可以寫一個 Script 來對使用者資料做例行性的快照，但隨著時間快照可能消耗大量的磁碟空間。先前的快照可以使用指令移除：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs destroy storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>在測試之後，便可讓 <span class=filename>/storage/home</span> 成為真正的 <span class=filename>/home</span> 使用此指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set mountpoint=/home storage/home</span></code></pre></div></div><div class=paragraph><p>執行 <code>df</code> 興 <code>mount</code> 來確認系統現在是否以把檔案系統做為真正的 <span class=filename>/home</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/ad0s1a on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/ad0s1d on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
storage on /storage <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
storage/home on /home <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
<span class=c># df</span>
Filesystem   1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a    2026030  235240  1628708    13%    /
devfs                1       1        0   100%    /dev
/dev/ad0s1d   54098308 1032826 48737618     2%    /usr
storage       26320512       0 26320512     0%    /storage
storage/home  26320512       0 26320512     0%    /home</code></pre></div></div><div class=paragraph><p>這個動作完成 RAID-Z 最後的設定，有關已建立的檔案系統每日狀態更新可以做為 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 的一部份在每天晚上執行。加入此行到 <span class=filename>/etc/periodic.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>daily_status_zfs_enable=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=zfs-quickstart-recovering-raid-z>19.2.3. 復原 RAID-Z<a class=anchor href=#zfs-quickstart-recovering-raid-z></a></h4><div class=paragraph><p>每個軟體 RAID 都有監控其狀態 (<code>state</code>) 的方式，而 RAID-Z 裝置的狀態可以使用這個指令來查看：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status -x</span></code></pre></div></div><div class=paragraph><p>如果所有儲存池為上線 (<a href=#zfs-term-online>Online</a>) 且正常，則訊息會顯示：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>all pools are healthy</code></pre></div></div><div class=paragraph><p>如果有發生問題，可能磁碟會呈現離線 (<a href=#zfs-term-offline>Offline</a>) 的狀態，此時儲存池的狀態會是：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  pool: storage
 state: DEGRADED
status: One or more devices has been taken offline by the administrator.
	Sufficient replicas exist <span class=k>for </span>the pool to <span class=k>continue </span>functioning <span class=k>in </span>a
	degraded state.
action: Online the device using <span class=s1>&#39;zpool online&#39;</span> or replace the device with
	<span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
 scrub: none requested
config:

	NAME        STATE     READ WRITE CKSUM
	storage     DEGRADED     0     0     0
	  raidz1    DEGRADED     0     0     0
	    da0     ONLINE       0     0     0
	    da1     OFFLINE      0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>這代表著裝置在之前被管理者使用此指令拿下線：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool offline storage da1</span></code></pre></div></div><div class=paragraph><p>現在系統可以關機然後更換 <span class=filename>da1</span>，當系統恢復上線，則可以替換掉儲存池中故障的磁碟：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool replace storage da1</span></code></pre></div></div><div class=paragraph><p>到這裡，可以再檢查狀態一次，這時不需使用 <code>-x</code> 參數來顯示所有的儲存池：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>在這個例子中，所有的磁碟均已正常運作。</p></div></div><div class=sect3><h4 id=zfs-quickstart-data-verification>19.2.4. 資料檢驗<a class=anchor href=#zfs-quickstart-data-verification></a></h4><div class=paragraph><p>ZFS 使用校驗碼 (Checksum) 來檢驗資料的完整性 (Integrity)，會在建立檔案系統時便自動開啟。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>校驗碼 (Checksum) 可以關閉，但並<em>不</em>建議！校驗碼只會使用非常少的儲存空間來確保資料的完整性。若關閉校驗碼會使許多 ZFS 功能無法正常運作，且關閉校驗碼對並不會明顯的改善效能。</p></div></td></tr></tbody></table></div><div class=paragraph><p>檢驗校驗碼這個動作即所謂的<em>清潔 (Scrub)</em>，可以使用以下指令來檢驗 <code>storage</code> 儲存池的資料完整性：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool scrub storage</span></code></pre></div></div><div class=paragraph><p>清潔所需要的時間依儲存的資料量而定，較大的資料量相對會需要花費較長的時間來檢驗。清潔會對 I/O 有非常密集的操作且一次只能進行一個清潔動作。在清潔完成之後，可以使用 <code>status</code> 來查看狀態：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: scrub completed with 0 errors on Sat Jan 26 19:57:37 2013
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>查詢結果會顯示上次完成清潔的時間來協助追蹤是否要再做清潔。定期清潔可以協助保護資料不會默默損壞且確保儲存池的完整性。</p></div><div class=paragraph><p>請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=8&amp;format=html">zfs(8)</a> 及 <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a> 來取得其他 ZFS 選項。</p></div></div></div><div class=sect2><h3 id=zfs-zpool>19.3. <code>zpool</code> 管理<a class=anchor href=#zfs-zpool></a></h3><div class=paragraph><p>ZFS 管理分成兩個主要的工具。<code>zpool</code> 工具用來控制儲存池的運作並可處理磁碟的新增、移除、更換與管理。<a href=#zfs-zfs><code>zfs</code></a> 工具用來建立、摧毀與管理檔案系統 (<a href=#zfs-term-filesystem>File system</a>) 與磁碟區 (<a href=#zfs-term-volume>Volume</a>) 的資料集。</p></div><div class=sect3><h4 id=zfs-zpool-create>19.3.1. 建立與摧毀儲存池<a class=anchor href=#zfs-zpool-create></a></h4><div class=paragraph><p>建立 ZFS 儲存池 (<em>zpool</em>) 要做幾個涉及長遠規劃的決定，因為建立儲存池之後便無法再更改儲存池的結構。最重要的決定是要使用那一種型態的 vdev 來將實體磁碟設為同一群組。請參考 <a href=#zfs-term-vdev>vdev 型態</a> 的清單來取得有關可用選項的詳細資訊。大部份的 vdev 型態不允許在建立儲存池之後再加入額外的磁碟，鏡像 (Mirror) 是可以允許加入額外的磁碟到 vdev 的其中一個例外，另一個則是串連 (Stripe)，可以加入額外的磁碟到 vdev 來升級為鏡像。雖然可以加入額外的 vdev 來擴充儲存池，但儲存池的配置在建立之後便無法更改，若要要更改，則必須先備份資料，把儲存池摧毀後再重新建立。</p></div><div class=paragraph><p>建立一個簡單的鏡像儲存池：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create mypool mirror /dev/ada1 /dev/ada2</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>可以一次建立數個 vdev，磁碟群組間使用 vdev 型態關鍵字來區隔，在這個例子使用 <code>mirror</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create mypool mirror /dev/ada1 /dev/ada2 mirror /dev/ada3 /dev/ada4</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada3    ONLINE       0     0     0
            ada4    ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>儲存池也可以不使用整個磁碟而改使用分割區 (Partition) 來建立。把 ZFS 放到不同的分割區可讓同一個磁碟有其他的分割區可做其他用途，尤其是有 Bootcode 與檔案系統要用來開機的分割區，這讓磁碟可以用來開機也同樣可以做為儲存池的一部份。在 FreeBSD 用分割區來替代整個磁碟並不會對效能有影響。使用分割區也讓管理者可以對磁碟容量做 <em>少算的預備</em>，使用比完整容量少的容量，未來若要替換的磁碟號稱與原磁碟相同，但實際上卻比較小時，也可符合這個較小的分割區容量，以使用替換的磁碟。</p></div><div class=paragraph><p>使用分割區建立一個 <a href=#zfs-term-vdev-raidz>RAID-Z2</a> 儲存池：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create mypool raidz2 /dev/ada0p3 /dev/ada1p3 /dev/ada2p3 /dev/ada3p3 /dev/ada4p3 /dev/ada5p3</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>不需使用的儲存池可以摧毀，來讓磁碟可以再次使用。摧毀一個儲存池要先卸載所有該儲存池的資料集。若資料集在使用中，卸載的操作會失敗且儲存池不會被摧毀。儲存池的摧毀可以使用 <code>-f</code> 來強制執行，但這可能造成那些有開啟這些資料集之中檔案的應用程式無法辨識的行為。</p></div></div><div class=sect3><h4 id=zfs-zpool-attach>19.3.2. 加入與移除裝置<a class=anchor href=#zfs-zpool-attach></a></h4><div class=paragraph><p>加入磁碟到儲存池 (zpool) 會有兩種情形：使用 <code>zpool attach</code> 加入一個磁碟到既有的 vdev，或使用 <code>zpool add</code> 加入 vdev 到儲存池。只有部份 <a href=#zfs-term-vdev>vdev 型態</a> 允許在 vdev 建立之後加入磁碟。</p></div><div class=paragraph><p>由單一磁碟所建立的儲存池缺乏備援 (Redundancy) 功能，可以偵測到資料的損壞但無法修復，因為資料沒有其他備份可用。備份數 (<a href=#zfs-term-copies>Copies</a>) 屬性可以讓您從較小的故障中復原，如磁碟壞軌 (Bad sector)，但無法提供與鏡像或 RAID-Z 同樣層級的保護。由單一磁碟所建立的儲存池可以使用 <code>zpool attach</code> 來加入額外的磁碟到 vdev，來建立鏡像。<code>zpool attach</code> 也可用來加入額外的磁碟到鏡像群組，來增加備援與讀取效率。若使用的磁碟已有分割區，可以複製該磁碟的分割區配置到另一個，使用 <code>gpart backup</code> 與 <code>gpart restore</code> 可讓這件事變的很簡單。</p></div><div class=paragraph><p>加入 <em>ada1p3</em> 來升級單一磁碟串連 (stripe) vdev <em>ada0p3</em> 採用鏡像型態 (mirror)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          ada0p3    ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool attach mypool ada0p3 ada1p3</span>
Make sure to <span class=nb>wait </span><span class=k>until </span>resilver is <span class=k>done </span>before rebooting.

If you boot from pool <span class=s1>&#39;mypool&#39;</span>, you may need to update
boot code on newly attached disk <span class=s1>&#39;ada1p3&#39;</span><span class=nb>.</span>

Assuming you use GPT partitioning and <span class=s1>&#39;da0&#39;</span> is your new boot disk
you may use the following <span class=nb>command</span>:

        gpart bootcode <span class=nt>-b</span> /boot/pmbr <span class=nt>-p</span> /boot/gptzfsboot <span class=nt>-i</span> 1 da0
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1</span>
bootcode written to ada1
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        <span class=k>continue </span>to <span class=k>function</span>, possibly <span class=k>in </span>a degraded state.
action: Wait <span class=k>for </span>the resilver to complete.
  scan: resilver <span class=k>in </span>progress since Fri May 30 08:19:19 2014
        527M scanned out of 781M at 47.9M/s, 0h0m to go
        527M resilvered, 67.53% <span class=k>done
</span>config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0  <span class=o>(</span>resilvering<span class=o>)</span>

errors: No known data errors
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:15:58 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>若不想選擇加入磁碟到既有的 vdev ，對 RAID-Z 來說，可選擇另一種方式，便是加入另一個 vdev 到儲存池。額外的 vdev 可以提供更高的效能，分散寫入資料到 vdev 之間，每個 vdev 會負責自己的備援。也可以混合使用不同的 vdev 型態，但並不建議，例如混合使用 <code>mirror</code> 與 <code>RAID-Z</code>，加入一個無備援的 vdev 到一個含有 mirror 或 RAID-Z vdev 的儲存池會讓資料損壞的風險擴大整個儲存池，由於會分散寫入資料，若在無備援的磁碟上發生故障的結果便是遺失大半寫到儲存池的資料區塊。</p></div><div class=paragraph><p>在每個 vdev 間的資料是串連的，例如，有兩個 mirror vdev，便跟 RAID 10 一樣在兩個 mirror 間分散寫入資料，且會做空間的分配，因此 vdev 會在同時達到全滿 100% 的用量。若 vdev 間的可用空間量不同則會影響到效能，因為資料量會不成比例的寫入到使用量較少的 vdev。</p></div><div class=paragraph><p>當連接額外的裝置到一個可以開機的儲存池，要記得更新 Bootcode。</p></div><div class=paragraph><p>連接第二個 mirror 群組 (<span class=filename>ada2p3</span> 及 <span class=filename>ada3p3</span>) 到既有的 mirror：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:19:35 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool add mypool mirror ada2p3 ada3p3</span>
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2</span>
bootcode written to ada2
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada3</span>
bootcode written to ada3
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>現在已無法從儲存池上移除 vdev，且磁碟只能夠在有足夠備援空間的情況下從 mirror 移除，若在 mirror 群組中只剩下一個磁碟，便會取消 mirror 然後還原為 stripe，若剩下的那個磁碟故障，便會影響到整個儲存池。</p></div><div class=paragraph><p>從一個三方 mirror 群組移除一個磁碟：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool detach mypool ada2p3</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-status>19.3.3. 檢查儲存池狀態<a class=anchor href=#zfs-zpool-status></a></h4><div class=paragraph><p>儲存池的狀態很重要，若有磁碟機離線或偵測到讀取、寫入或校驗碼 (Checksum) 錯誤，對應的錯誤計數便會增加。<code>status</code> 會顯示儲存池中每一個磁碟機的設定與狀態及整個儲存池的狀態。需要處置的方式與有關最近清潔 (<a href=#zfs-zpool-scrub><code>Scrub</code></a>) 的詳細資訊也會一併顯示。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>2h25m with 0 errors on Sat Sep 14 04:25:50 2013
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-clear>19.3.4. 清除錯誤<a class=anchor href=#zfs-zpool-clear></a></h4><div class=paragraph><p>當偵測到錯誤發生，讀取、寫入或校驗碼 (Checksum) 的計數便會增加。使用 <code>zpool clear <em>mypool</em></code> 可以清除錯誤訊息及重置計數。清空錯誤狀態對當儲存池發生錯誤要使用自動化 Script 通知的管理者來說會很重要，因在舊的錯誤尚未清除前不會回報後續的錯誤。</p></div></div><div class=sect3><h4 id=zfs-zpool-replace>19.3.5. 更換運作中的裝置<a class=anchor href=#zfs-zpool-replace></a></h4><div class=paragraph><p>可能有一些情況會需要更換磁碟為另一個磁碟，當要更換運作中的磁碟，此程序會維持舊有的磁碟在更換的過程為上線的狀態，儲存池不會進入降級 (<a href=#zfs-term-degraded>Degraded</a>) 的狀態，來減少資料遺失的風險。<code>zpool replace</code> 會複製所有舊磁碟的資料到新磁碟，操作完成之後舊磁碟便會與 vdev 中斷連線。若新磁碟容量較舊磁碟大，也可以會增加儲存池來使用新的空間，請參考 <a href=#zfs-zpool-online>擴增儲存池</a>。</p></div><div class=paragraph><p>更換儲存池中正在運作的狀置：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool replace mypool ada1p3 ada2p3</span>
Make sure to <span class=nb>wait </span><span class=k>until </span>resilver is <span class=k>done </span>before rebooting.

If you boot from pool <span class=s1>&#39;zroot&#39;</span>, you may need to update
boot code on newly attached disk <span class=s1>&#39;ada2p3&#39;</span><span class=nb>.</span>

Assuming you use GPT partitioning and <span class=s1>&#39;da0&#39;</span> is your new boot disk
you may use the following <span class=nb>command</span>:

        gpart bootcode <span class=nt>-b</span> /boot/pmbr <span class=nt>-p</span> /boot/gptzfsboot <span class=nt>-i</span> 1 da0
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        <span class=k>continue </span>to <span class=k>function</span>, possibly <span class=k>in </span>a degraded state.
action: Wait <span class=k>for </span>the resilver to complete.
  scan: resilver <span class=k>in </span>progress since Mon Jun  2 14:21:35 2014
        604M scanned out of 781M at 46.5M/s, 0h0m to go
        604M resilvered, 77.39% <span class=k>done
</span>config:

        NAME             STATE     READ WRITE CKSUM
        mypool           ONLINE       0     0     0
          mirror-0       ONLINE       0     0     0
            ada0p3       ONLINE       0     0     0
            replacing-1  ONLINE       0     0     0
              ada1p3     ONLINE       0     0     0
              ada2p3     ONLINE       0     0     0  <span class=o>(</span>resilvering<span class=o>)</span>

errors: No known data errors
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Mon Jun  2 14:21:52 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-resilver>19.3.6. 處理故障裝置<a class=anchor href=#zfs-zpool-resilver></a></h4><div class=paragraph><p>當儲存池中的磁碟故障，該故障硬碟所屬的 vdev 便會進入降級 (<a href=#zfs-term-degraded>Degraded</a>) 狀態，所有的資料仍可使用，但效能可能會降低，因為遺失的資料必須從可用的備援資料計算才能取得。要將 vdev 恢復完整運作的狀態必須更換故障的實體裝置。然後 ZFS 便會開始修復 (<a href=#zfs-term-resilver>Resilver</a>，古代鏡子的修復稱 Resilver) 作業，會從可用的備援資料計算出故障磁碟中的資料並寫入到替換的裝置上。完成後 vdev 便會重新返回上線 (<a href=#zfs-term-online>Online</a>) 的狀態。</p></div><div class=paragraph><p>若 vdev 沒有任何備援資料或有多個裝置故障，沒有足夠的備援資料可以補償，儲存池便會進入故障 (<a href=#zfs-term-faulted>Faulted</a>) 的狀態。</p></div><div class=paragraph><p>更換故障的磁碟時，故障磁碟的名稱會更換為裝置的 GUID，若替換裝置要使用相同的裝置名稱，則在 <code>zpool replace</code> 不須加上新裝置名稱參數。</p></div><div class=paragraph><p>使用 <code>zpool replace</code> 更換故障的磁碟：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: DEGRADED
status: One or more devices could not be opened.  Sufficient replicas exist <span class=k>for
        </span>the pool to <span class=k>continue </span>functioning <span class=k>in </span>a degraded state.
action: Attach the missing device and online it using <span class=s1>&#39;zpool online&#39;</span><span class=nb>.</span>
   see: http://illumos.org/msg/ZFS-8000-2Q
  scan: none requested
config:

        NAME                    STATE     READ WRITE CKSUM
        mypool                  DEGRADED     0     0     0
          mirror-0              DEGRADED     0     0     0
            ada0p3              ONLINE       0     0     0
            316502962686821739  UNAVAIL      0     0     0  was /dev/ada1p3

errors: No known data errors
<span class=c># zpool replace mypool 316502962686821739 ada2p3</span>
<span class=c># zpool status</span>
  pool: mypool
 state: DEGRADED
status: One or more devices is currently being resilvered.  The pool will
        <span class=k>continue </span>to <span class=k>function</span>, possibly <span class=k>in </span>a degraded state.
action: Wait <span class=k>for </span>the resilver to complete.
  scan: resilver <span class=k>in </span>progress since Mon Jun  2 14:52:21 2014
        641M scanned out of 781M at 49.3M/s, 0h0m to go
        640M resilvered, 82.04% <span class=k>done
</span>config:

        NAME                        STATE     READ WRITE CKSUM
        mypool                      DEGRADED     0     0     0
          mirror-0                  DEGRADED     0     0     0
            ada0p3                  ONLINE       0     0     0
            replacing-1             UNAVAIL      0     0     0
              15732067398082357289  UNAVAIL      0     0     0  was /dev/ada1p3/old
              ada2p3                ONLINE       0     0     0  <span class=o>(</span>resilvering<span class=o>)</span>

errors: No known data errors
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Mon Jun  2 14:52:38 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-scrub>19.3.7. 清潔儲存池<a class=anchor href=#zfs-zpool-scrub></a></h4><div class=paragraph><p>建議儲存池要定期清潔 (<a href=#zfs-term-scrub>Scrub</a>)，最好是每一個月清潔一次。 <code>scrub</code> 作業對磁碟操作非常的密集，在執行時會降低磁碟的效能。在排程 <code>scrub</code> 時避免在使用高峰的時期，或使用 <a href=#zfs-advanced-tuning-scrub_delay><code>vfs.zfs.scrub_delay</code></a> 來調整 <code>scrub</code> 的相對優先權來避免影響其他的工作。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool scrub mypool</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub <span class=k>in </span>progress since Wed Feb 19 20:52:54 2014
        116G scanned out of 8.60T at 649M/s, 3h48m to go
        0 repaired, 1.32% <span class=k>done
</span>config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>若發生需要取消清潔作業的事，可以下 <code>zpool scrub -s <em>mypool</em></code>。</p></div></div><div class=sect3><h4 id=zfs-zpool-selfheal>19.3.8. 自我修復<a class=anchor href=#zfs-zpool-selfheal></a></h4><div class=paragraph><p>校驗碼 (Checksum) 會隨資料區塊一併儲存，這使得檔案系統可以做到<em>自我修復</em>。這個功能可以在校驗碼與儲存池中的另一個裝置不同時自動修復資料。舉例來說，有兩個磁碟做鏡像 (Mirror)，其中一個磁碟機開始失常並無法正常儲存資料，甚至是資料放在長期封存的儲存裝置上，已經很久沒有被存取。傳統的檔案系統需要執行演算法來檢查並修復資料如 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>，這些指令耗費時間，且在嚴重時需要管理者手動決定要做那一種修復操作。當 ZFS 偵測到資料區塊的校驗碼不對時，它除了把資料交給需要的應用程式外，也會修正在磁碟上錯誤的資料。這件事不需要與系統管理者作任何互動便會在一般的儲存池操作時完成。</p></div><div class=paragraph><p>接下來的例子會示範自我修復會如何運作。建立一個使用磁碟 <span class=filename>/dev/ada0</span> 及 <span class=filename>/dev/ada1</span> 做鏡像的儲存池。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create healer mirror /dev/ada0 /dev/ada1</span>
<span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
  scan: none requested
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool list</span>
NAME     SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
healer   960M  92.5K   960M         -         -     0%    0%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>將部份需要使用自我修復功能來保護的重要資料複製到該儲存池，建立一個儲存池的校驗碼供稍後做比較時使用。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /some/important/data /healer</span>
<span class=c># zfs list</span>
NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT
healer   960M  67.7M   892M     7%  1.00x  ONLINE  -
<span class=c># sha1 /healer &gt; checksum.txt</span>
<span class=c># cat checksum.txt</span>
SHA1 <span class=o>(</span>/healer<span class=o>)</span> <span class=o>=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f</code></pre></div></div><div class=paragraph><p>寫入隨機的資料到鏡像的第一個磁碟來模擬資料損毀的情況。要避免 ZFS 偵測到錯誤時馬上做修復，接著要將儲存池匯出，待模擬資料損毀之後再匯入。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>這是一個危險的操作，會破壞重要的資料。在這裡使用僅為了示範用，不應在儲存池正常運作時嘗試使用，也不應將這個故意損壞資料的例子用在任何其他的檔案系統上，所以請勿使用任何不屬於該儲存池的其他磁碟裝置名稱並確定在執行指令前已對儲存池做正確的備份！</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool export healer</span>
<span class=c># dd if=/dev/random of=/dev/ada1 bs=1m count=200</span>
200+0 records <span class=k>in
</span>200+0 records out
209715200 bytes transferred <span class=k>in </span>62.992162 secs <span class=o>(</span>3329227 bytes/sec<span class=o>)</span>
<span class=c># zpool import healer</span></code></pre></div></div><div class=paragraph><p>儲存池的狀態顯示有一個裝置發生了錯誤。注意，應用程式從儲存池讀取的資料中並沒有任何的錯誤資料，ZFS 會自 <span class=filename>ada0</span> 裝置提供有正確校驗碼的資料。結果裡面 <code>CKSUM</code> 欄位含有非零值便是有錯誤校驗碼的裝置。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status healer</span>
    pool: healer
   state: ONLINE
  status: One or more devices has experienced an unrecoverable error.  An
          attempt was made to correct the error.  Applications are unaffected.
  action: Determine <span class=k>if </span>the device needs to be replaced, and clear the errors
          using <span class=s1>&#39;zpool clear&#39;</span> or replace the device with <span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
     see: http://illumos.org/msg/ZFS-8000-4J
    scan: none requested
  config:

      NAME        STATE     READ WRITE CKSUM
      healer      ONLINE       0     0     0
        mirror-0  ONLINE       0     0     0
         ada0     ONLINE       0     0     0
         ada1     ONLINE       0     0     1

errors: No known data errors</code></pre></div></div><div class=paragraph><p>錯誤已經被偵測到並且由未被影響的 <span class=filename>ada0</span> 鏡像磁碟上的備援提供資料。可與原來的校驗碼做比較來看儲存池是否已修復為一致。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sha1 /healer &gt;&gt; checksum.txt</span>
<span class=c># cat checksum.txt</span>
SHA1 <span class=o>(</span>/healer<span class=o>)</span> <span class=o>=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f
SHA1 <span class=o>(</span>/healer<span class=o>)</span> <span class=o>=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f</code></pre></div></div><div class=paragraph><p>儲存池在故意竄改資料前與後的兩個校驗碼仍相符顯示了 ZFS 在校驗碼不同時偵測與自動修正錯誤的能力。注意，這只在當儲存池中有足夠的備援時才可做到，由單一裝置組成的儲存池並沒有自我修復的能力。這也是為什麼在 ZFS 中校驗碼如此重要，任何原因都不該關閉。不需要 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 或類似的檔案系統一致性檢查程式便能夠偵測與修正問題，且儲存儲存池在發生問題時仍可正常運作。接著需要做清潔作業來覆蓋在 <span class=filename>ada1</span> 上的錯誤資料。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool scrub healer</span>
<span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
            attempt was made to correct the error.  Applications are unaffected.
action: Determine <span class=k>if </span>the device needs to be replaced, and clear the errors
            using <span class=s1>&#39;zpool clear&#39;</span> or replace the device with <span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub <span class=k>in </span>progress since Mon Dec 10 12:23:30 2012
        10.4M scanned out of 67.0M at 267K/s, 0h3m to go
        9.63M repaired, 15.56% <span class=k>done
</span>config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0   627  <span class=o>(</span>repairing<span class=o>)</span>

errors: No known data errors</code></pre></div></div><div class=paragraph><p>清潔作業會從 <span class=filename>ada0</span> 讀取資料並重新寫入任何在 <span class=filename>ada1</span> 上有錯誤校驗碼的資料。這個操作可以由 <code>zpool status</code> 的輸出中呈現修復中 <code>(repairing)</code> 的項目來辨識。這個作業完成後，儲存池的狀態會更改為：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
        attempt was made to correct the error.  Applications are unaffected.
action: Determine <span class=k>if </span>the device needs to be replaced, and clear the errors
             using <span class=s1>&#39;zpool clear&#39;</span> or replace the device with <span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub repaired 66.5M <span class=k>in </span>0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0 2.72K

errors: No known data errors</code></pre></div></div><div class=paragraph><p>清潔操作完成便同步了 <span class=filename>ada0</span> 到 <span class=filename>ada1</span> 間的所有資料。執行 <code>zpool clear</code> 可以清除 (<a href=#zfs-zpool-clear>Clear</a>) 儲存池狀態的錯誤訊息。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool clear healer</span>
<span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
  scan: scrub repaired 66.5M <span class=k>in </span>0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>儲存池現在恢復完整運作的狀態且清除所有的錯誤了。</p></div></div><div class=sect3><h4 id=zfs-zpool-online>19.3.9. 擴增儲存池<a class=anchor href=#zfs-zpool-online></a></h4><div class=paragraph><p>可用的備援儲存池大小會受到每個 vdev 中容量最小的裝置限制。最小的裝置可以替換成較大的裝置，在更換 (<a href=#zfs-zpool-replace>Replace</a>) 或修復 (<a href=#zfs-term-resilver>Resilver</a>) 作業後，儲存池可以成長到該新裝置的可用容量。例如，要做一個 1 TB 磁碟機與一個 2 TB 磁碟機的鏡像，可用的空間會是 1 TB，當 1 TB 磁碟機備更換成另一個 2 TB 的磁碟機時，修復程序會複製既有的資料到新的磁碟機，由於現在兩個裝置都有 2 TB 的容量，所以鏡像的可用空間便會成長到 2 TB。</p></div><div class=paragraph><p>可以在每個裝置用 <code>zpool online -e</code> 來觸發擴充的動作，在擴充完所有裝置後，儲存池便可使用額外的空間。</p></div></div><div class=sect3><h4 id=zfs-zpool-import>19.3.10. 匯入與匯出儲存池<a class=anchor href=#zfs-zpool-import></a></h4><div class=paragraph><p>儲存池在移動到其他系統之前需要做匯出 (<em>Export</em>)，會卸載所有的資料集，然後標記每個裝置為已匯出，為了避免被其他磁碟子系統存取，因此仍會鎖定這些裝置。這個動作讓儲存池可以在支援 ZFS 的其他機器、其他作業系統做匯入 (<em>Import</em>)，甚至是不同的硬體架構 (有一些注意事項，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a>)。當資料集有被開啟的檔案，可使用 <code>zpool export -f</code> 來強制匯出儲存池，使用這個指令需要小心，資料集是被強制卸載的，因此有可能造成在該資料集開啟檔案的應用程式發生無法預期的結果。</p></div><div class=paragraph><p>匯出未使用的儲存池：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool export mypool</span></code></pre></div></div><div class=paragraph><p>匯入儲存池會自動掛載資料集，若不想自動掛載，可以使用 <code>zpool import -N</code>。<code>zpool import -o</code> 可以設定在匯入時暫時使用的屬性。<code>zpool import altroot=</code> 允許匯入時指定基礎掛載點 (Base mount point) 來替換檔案系統根目錄。若儲存池先前用在不同的系統且不正常匯出，可能會需要使用 <code>zpool import -f</code> 來強制匯入。<code>zpool import -a</code> 會匯入所有沒有被其他系統使用的儲存池。</p></div><div class=paragraph><p>列出所有可以匯入的儲存池：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool import</span>
   pool: mypool
     <span class=nb>id</span>: 9930174748043525076
  state: ONLINE
 action: The pool can be imported using its name or numeric identifier.
 config:

        mypool      ONLINE
          ada2p3    ONLINE</code></pre></div></div><div class=paragraph><p>使用替代的根目錄匯入儲存池：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool import -o altroot=/mnt mypool</span>
<span class=c># zfs list</span>
zfs list
NAME                 USED  AVAIL  REFER  MOUNTPOINT
mypool               110K  47.0G    31K  /mnt/mypool</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-upgrade>19.3.11. 升級儲存儲存池<a class=anchor href=#zfs-zpool-upgrade></a></h4><div class=paragraph><p>在升級 FreeBSD 之後或儲存池是由其他使用舊版 ZFS 的系統匯入，儲存池可以手動升級到最新版本的 ZFS 來支援新的功能。在升級前請評估儲存池是否還要在舊的系統做匯入，由於升級是一個單向的程序，舊的儲存池可以升級，但有新功能的儲存池無法降級。</p></div><div class=paragraph><p>升級一個 v28 的儲存以支援功能旗標 (<code>Feature Flags</code>)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: The pool is formatted using a legacy on-disk format.  The pool can
        still be used, but some features are unavailable.
action: Upgrade the pool using <span class=s1>&#39;zpool upgrade&#39;</span><span class=nb>.</span>  Once this is <span class=k>done</span>, the
        pool will no longer be accessible on software that does not support feat
        flags.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool upgrade</span>
This system supports ZFS pool feature flags.

The following pools are formatted with legacy version numbers and can
be upgraded to use feature flags.  After being upgraded, these pools
will no longer be accessible by software that does not support feature
flags.

VER  POOL
<span class=nt>---</span>  <span class=nt>------------</span>
28   mypool

Use <span class=s1>&#39;zpool upgrade -v&#39;</span> <span class=k>for </span>a list of available legacy versions.
Every feature flags pool has all supported features enabled.
<span class=c># zpool upgrade mypool</span>
This system supports ZFS pool feature flags.

Successfully upgraded <span class=s1>&#39;mypool&#39;</span> from version 28 to feature flags.
Enabled the following features on <span class=s1>&#39;mypool&#39;</span>:
  async_destroy
  empty_bpobj
  lz4_compress
  multi_vdev_crash_dump</code></pre></div></div><div class=paragraph><p>ZFS 的新功能在 <code>zpool upgrade</code> 尚未完成之前無法使用。可以用 <code>zpool upgrade -v</code> 來查看升級後有那些新功能，也同時會列出已經支援那些功能。</p></div><div class=paragraph><p>升級儲存池支援新版的功能旗標 (Feature flags)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: Some supported features are not enabled on the pool. The pool can
        still be used, but some features are unavailable.
action: Enable all features using <span class=s1>&#39;zpool upgrade&#39;</span><span class=nb>.</span> Once this is <span class=k>done</span>,
        the pool may no longer be accessible by software that does not support
        the features. See zpool-features<span class=o>(</span>7<span class=o>)</span> <span class=k>for </span>details.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool upgrade</span>
This system supports ZFS pool feature flags.

All pools are formatted using feature flags.

Some supported features are not enabled on the following pools. Once a
feature is enabled the pool may become incompatible with software
that does not support the feature. See zpool-features<span class=o>(</span>7<span class=o>)</span> <span class=k>for </span>details.

POOL  FEATURE
<span class=nt>---------------</span>
zstore
      multi_vdev_crash_dump
      spacemap_histogram
      enabled_txg
      hole_birth
      extensible_dataset
      bookmarks
      filesystem_limits
<span class=c># zpool upgrade mypool</span>
This system supports ZFS pool feature flags.

Enabled the following features on <span class=s1>&#39;mypool&#39;</span>:
  spacemap_histogram
  enabled_txg
  hole_birth
  extensible_dataset
  bookmarks
  filesystem_limits</code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>在使用儲存池來開機的系統上的 Boot code 也必須一併更新來支援新的儲存池版本，可在含有 Boot code 的分割區使用 <code>gpart bootcode</code> 來更新。目前有兩種 Boot code 可使用，需視系統開機的方式使用：GPT (最常用的選項) 以及 EFI (較新的系統)。</p></div><div class=paragraph><p>針對傳統使用 GPT 開機的系統，可以使用以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1</span></code></pre></div></div><div class=paragraph><p>針對使用 EFI 開機的系統可以執行以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -p /boot/boot1.efifat -i 1 ada1</span></code></pre></div></div><div class=paragraph><p>套用 Boot code 到所有儲存池中可開機的磁碟。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 以取得更多資訊。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=zfs-zpool-history>19.3.12. 顯示已記錄的儲存池歷史日誌<a class=anchor href=#zfs-zpool-history></a></h4><div class=paragraph><p>修改儲存池的指令會被記錄下來，會記錄的動作包含資料集的建立，屬性更改或更換磁碟。這個歷史記錄用來查看儲存池是如何建立、由誰執行、什麼動作及何時。歷史記錄並非儲存在日誌檔 (Log file)，而是儲存在儲存池。查看這個歷史記錄的指令名稱為 <code>zpool history</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool history</span>
History <span class=k>for</span> <span class=s1>&#39;tank&#39;</span>:
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1
2013-02-27.18:50:58 zfs <span class=nb>set </span><span class=nv>atime</span><span class=o>=</span>off tank
2013-02-27.18:51:09 zfs <span class=nb>set </span><span class=nv>checksum</span><span class=o>=</span>fletcher4 tank
2013-02-27.18:51:18 zfs create tank/backup</code></pre></div></div><div class=paragraph><p>輸出結果顯示曾在該儲存池上執行的 <code>zpool</code> 與 <code>zfs</code> 指令以及時間戳記。只有會修改儲存池或類似的指令會被記錄下來，像是 <code>zfs list</code> 這種指令並不會被記錄。當不指定儲存池名稱時，會列出所有儲存池的歷史記錄。</p></div><div class=paragraph><p>在提供選項 <code>-i</code> 或 <code>-l</code> 時 <code>zpool history</code> 可以顯更多詳細資訊。<code>-i</code> 會顯示使用者觸發的事件外，也會顯示內部記錄的 ZFS 事件。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool history -i</span>
History <span class=k>for</span> <span class=s1>&#39;tank&#39;</span>:
2013-02-26.23:02:35 <span class=o>[</span>internal pool create txg:5] pool spa 28<span class=p>;</span> zfs spa 28<span class=p>;</span> zpl 5<span class=p>;</span>uts  9.1-RELEASE 901000 amd64
2013-02-27.18:50:53 <span class=o>[</span>internal property <span class=nb>set </span>txg:50] <span class=nv>atime</span><span class=o>=</span>0 dataset <span class=o>=</span> 21
2013-02-27.18:50:58 zfs <span class=nb>set </span><span class=nv>atime</span><span class=o>=</span>off tank
2013-02-27.18:51:04 <span class=o>[</span>internal property <span class=nb>set </span>txg:53] <span class=nv>checksum</span><span class=o>=</span>7 dataset <span class=o>=</span> 21
2013-02-27.18:51:09 zfs <span class=nb>set </span><span class=nv>checksum</span><span class=o>=</span>fletcher4 tank
2013-02-27.18:51:13 <span class=o>[</span>internal create txg:55] dataset <span class=o>=</span> 39
2013-02-27.18:51:18 zfs create tank/backup</code></pre></div></div><div class=paragraph><p>更多詳細的資訊可加上 <code>-l</code> 來取得，歷史記錄會以較長的格式顯示，包含的資訊有執行指令的使用者名稱、主機名稱以及更改的項目。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool history -l</span>
History <span class=k>for</span> <span class=s1>&#39;tank&#39;</span>:
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1 <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on :global]
2013-02-27.18:50:58 zfs <span class=nb>set </span><span class=nv>atime</span><span class=o>=</span>off tank <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on myzfsbox:global]
2013-02-27.18:51:09 zfs <span class=nb>set </span><span class=nv>checksum</span><span class=o>=</span>fletcher4 tank <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on myzfsbox:global]
2013-02-27.18:51:18 zfs create tank/backup <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on myzfsbox:global]</code></pre></div></div><div class=paragraph><p>輸出結果顯示 <code>root</code> 使用者使用 <span class=filename>/dev/ada0</span> 及 <span class=filename>/dev/ada1</span> 建立鏡像的儲存池。主機名稱 <code>myzfsbox</code> 在建立完儲存池後也同樣會顯示。由於儲存池可以從一個系統匯出再匯入到另一個系統，因此主機名稱也很重要，這樣一來可以清楚的辦識在其他系統上執行的每一個指令的主機名稱。</p></div><div class=paragraph><p>兩個 <code>zpool history</code> 選項可以合併使用來取得最完整的儲存池詳細資訊。儲存池歷史記錄在追蹤執行什麼動作或要取得除錯所需的輸出結果提供了非常有用的資訊。</p></div></div><div class=sect3><h4 id=zfs-zpool-iostat>19.3.13. 監視效能<a class=anchor href=#zfs-zpool-iostat></a></h4><div class=paragraph><p>內建的監視系統可以即時顯示儲存池的 I/O 統計資訊。它會顯示儲存池剩餘的空間與使用的空間，每秒執行了多少讀取與寫入的操作，有多少 I/O 頻寬被使用。預設會監視所有在系統中的儲存池都並顯示出來，可以提供儲存池名稱來只顯示該儲存池的監視資訊。舉一個簡單的例子：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool iostat</span>
               capacity     operations    bandwidth
pool        alloc   free   <span class=nb>read  </span>write   <span class=nb>read  </span>write
<span class=nt>----------</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>
data         288G  1.53T      2     11  11.3K  57.1K</code></pre></div></div><div class=paragraph><p>要持續監視 I/O 的活動可以在最後的參數指定一個數字，這個數字代表每次更新資訊所間隔的秒數。在每次經過間隔的時間後會列出新一行的統計資訊，按下 <span class=keyseq><kbd>Ctrl</kbd>+<kbd>C</kbd></span> 可以中止監視。或者在指令列的間隔時間之後再指定一個數字，代表總共要顯示的統計資訊筆數。</p></div><div class=paragraph><p>使用 <code>-v</code> 可以顯示更詳細的 I/O 統計資訊。每個在儲存池中的裝置會以一行統計資訊顯示。這可以幫助了解每一個裝置做了多少讀取與寫入的操作，並可協助確認是否有各別裝置拖慢了整個儲存池的速度。以下範例會顯示有兩個裝置的鏡像儲存池：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool iostat -v</span>
                            capacity     operations    bandwidth
pool                     alloc   free   <span class=nb>read  </span>write   <span class=nb>read  </span>write
<span class=nt>-----------------------</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>
data                      288G  1.53T      2     12  9.23K  61.5K
  mirror                  288G  1.53T      2     12  9.23K  61.5K
    ada1                     -      -      0      4  5.61K  61.7K
    ada2                     -      -      1      4  5.04K  61.7K
<span class=nt>-----------------------</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-split>19.3.14. 分割儲存儲存池<a class=anchor href=#zfs-zpool-split></a></h4><div class=paragraph><p>由一個或多個鏡像 vdev 所組成的儲存池可以切分開成兩個儲存池。除非有另外指定，否則每個鏡像的最後一個成員會被分離來然用來建立一個含有相同資料的新儲存池。在做這個操作的第一次應先使用 <code>-n</code>，會顯示預計會做的操作而不會真的執行，這可以協助確認操作是否與使用者所要的相同。</p></div></div></div><div class=sect2><h3 id=zfs-zfs>19.4. <code>zfs</code> 管理<a class=anchor href=#zfs-zfs></a></h3><div class=paragraph><p><code>zfs</code> 工具負責建立、摧毀與管理在一個儲存池中所有的 ZFS 資料集。儲存池使用 <a href=#zfs-zpool><code>zpool</code></a> 來管理。</p></div><div class=sect3><h4 id=zfs-zfs-create>19.4.1. 建立與摧毀資料集<a class=anchor href=#zfs-zfs-create></a></h4><div class=paragraph><p>不同於傳統的磁碟與磁碟區管理程式 (Volume manager) ，在 ZFS 中的空間並<em>不</em>會預先分配。傳統的檔案系統在分割與分配空間完後，若沒有增加新的磁碟便無法再增加額外的檔案系統。在 ZFS，可以隨時建立新的檔案系統，每個資料集 (<a href=#zfs-term-dataset><em>Dataset</em></a>) 都有自己的屬性，包含壓縮 (Compression)、去重複 (Deduplication)、快取 (Caching) 與配額 (Quota) 功能以及其他有用的屬性如唯讀 (Readonly)、區分大小寫 (Case sensitivity)、網路檔案分享 (Network file sharing) 以及掛載點 (Mount point)。資料集可以存在於其他資料集中，且子資料集會繼承其父資料集的屬性。每個資料集都可以作為一個單位來管理、委託 (<a href=#zfs-zfs-allow>Delegate</a>)、備份 (<a href=#zfs-zfs-send>Replicate</a>)、快照 (<a href=#zfs-zfs-snapshot>Snapshot</a>)、監禁 (<a href=#zfs-zfs-jail>Jail</a>) 與摧毀 (Destroy)，替每種不同類型或集合的檔案建立各別的資料集還有許多的好處。唯一的缺點是在當有非常大數量的資料集時，部份指令例如 <code>zfs list</code> 會變的較緩慢，且掛載上百個或其至上千個資料集可能會使 FreeBSD 的開機程序變慢。</p></div><div class=paragraph><p>建立一個新資料集並開啟 <a href=#zfs-term-compression-lz4>LZ4 壓縮</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.20M  93.2G   608K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp
<span class=c># zfs create -o compress=lz4 mypool/usr/mydataset</span>
<span class=c># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 781M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.20M  93.2G   610K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp</code></pre></div></div><div class=paragraph><p>摧毀資料集會比刪除所有在資料集上所殘留的檔案來的快，由於摧毀資料集並不會掃描所有檔案並更新所有相關的 Metadata。</p></div><div class=paragraph><p>摧毀先前建立的資料集：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 880M  93.1G   144K  none
mypool/ROOT            777M  93.1G   144K  none
mypool/ROOT/default    777M  93.1G   777M  /
mypool/tmp             176K  93.1G   176K  /tmp
mypool/usr             101M  93.1G   144K  /usr
mypool/usr/home        184K  93.1G   184K  /usr/home
mypool/usr/mydataset   100M  93.1G   100M  /usr/mydataset
mypool/usr/ports       144K  93.1G   144K  /usr/ports
mypool/usr/src         144K  93.1G   144K  /usr/src
mypool/var            1.20M  93.1G   610K  /var
mypool/var/crash       148K  93.1G   148K  /var/crash
mypool/var/log         178K  93.1G   178K  /var/log
mypool/var/mail        144K  93.1G   144K  /var/mail
mypool/var/tmp         152K  93.1G   152K  /var/tmp
<span class=c># zfs destroy mypool/usr/mydataset</span>
<span class=c># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.21M  93.2G   612K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp</code></pre></div></div><div class=paragraph><p>在最近版本的 ZFS，<code>zfs destroy</code> 是非同步的，且釋放出的空間會許要花費數分鐘才會出現在儲存池上，可使用 <code>zpool get freeing <em>poolname</em></code> 來查看 <code>freeing</code> 屬性，這個屬性會指出資料集在背景已經釋放多少資料區塊了。若有子資料集，如快照 (<a href=#zfs-term-snapshot>Snapshot</a>) 或其他資料集存在的話，則會無法摧毀父資料集。要摧毀一個資料集及其所有子資料集，可使用 <code>-r</code> 來做遞迴摧毀資料集及其所有子資料集，可用 <code>-n -v</code> 來列出會被這個操作所摧毀的資料集及快照，而不會真的摧毀，因摧毀快照所釋放出的空間也會同時顯示。</p></div></div><div class=sect3><h4 id=zfs-zfs-volume>19.4.2. 建立與摧毀磁碟區<a class=anchor href=#zfs-zfs-volume></a></h4><div class=paragraph><p>磁碟區 (Volume) 是特殊類型的資料集，不會被掛載成一個檔案系統，而是會被當做儲存區塊裝置出現在 <span class=filename>/dev/zvol/poolname/dataset</span> 下。這讓磁碟區可供其他檔案系統使用、拿來備份虛擬機器的磁碟或是使用 iSCSI 或 HAST 通訊協定匯出。</p></div><div class=paragraph><p>磁碟區可以被格式化成任何檔案系統，或不使用檔案系統來儲存原始資料。對一般使用者，磁碟區就像是一般的磁碟，可以放置一般的檔案系統在這些 <em>zvols</em> 上，並提供一般磁碟或檔案系統一般所沒有的功能。例如，使用壓縮屬性在一個 250 MB 的磁碟區可建立一個壓縮的 FAT 檔案系統。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V 250m -o compression=on tank/fat32</span>
<span class=c># zfs list tank</span>
NAME USED AVAIL REFER MOUNTPOINT
tank 258M  670M   31K /tank
<span class=c># newfs_msdos -F32 /dev/zvol/tank/fat32</span>
<span class=c># mount -t msdosfs /dev/zvol/tank/fat32 /mnt</span>
<span class=c># df -h /mnt | grep fat32</span>
Filesystem           Size Used Avail Capacity Mounted on
/dev/zvol/tank/fat32 249M  24k  249M     0%   /mnt
<span class=c># mount | grep fat32</span>
/dev/zvol/tank/fat32 on /mnt <span class=o>(</span>msdosfs, <span class=nb>local</span><span class=o>)</span></code></pre></div></div><div class=paragraph><p>摧毀一個磁碟區與摧毀一個一般的檔案系統資料集差不多。操作上幾乎是即時的，但在背景會需要花費數分鐘來讓釋放空間再次可用。</p></div></div><div class=sect3><h4 id=zfs-zfs-rename>19.4.3. 重新命名資料集<a class=anchor href=#zfs-zfs-rename></a></h4><div class=paragraph><p>資料集的名稱可以使用 <code>zfs rename</code> 更改。父資料集也同樣可以使用這個指令來更改名稱。重新命名一個資料集到另一個父資料集也會更改自父資料集繼承的屬性值。重新命名資料集後，會被卸載然後重新掛載到新的位置 (依繼承的新父資料集而定)，可使用 <code>-u</code> 來避免重新掛載。</p></div><div class=paragraph><p>重新命名一個資料集並移動該資料集到另一個父資料集：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 780M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.21M  93.2G   614K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp
<span class=c># zfs rename mypool/usr/mydataset mypool/var/newname</span>
<span class=c># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                780M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.29M  93.2G   614K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/newname   87.5K  93.2G  87.5K  /var/newname
mypool/var/tmp        152K  93.2G   152K  /var/tmp</code></pre></div></div><div class=paragraph><p>快照也可以像這樣重新命名，由於快照的本質使其無法被重新命名到另一個父資料集。要遞迴重新命名快照可指定 <code>-r</code>，然後在子資料集中所有同名的快照也會一併被重新命名。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -t snapshot</span>
NAME                                USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@first_snapshot      0      -  87.5K  -
<span class=c># zfs rename mypool/var/newname@first_snapshot new_snapshot_name</span>
<span class=c># zfs list -t snapshot</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@new_snapshot_name      0      -  87.5K  -</code></pre></div></div></div><div class=sect3><h4 id=zfs-zfs-set>19.4.4. 設定資料集屬性<a class=anchor href=#zfs-zfs-set></a></h4><div class=paragraph><p>每個 ZFS 資料集有數個屬性可以用來控制其行為。大部份的屬性會自動繼承自其父資料集，但可以被自己覆蓋。設定資料集上的屬性可使用 <code>zfs set <em>property=value dataset</em></code>。大部份屬性有限制可用的值，<code>zfs get</code> 會顯示每個可以使用的屬性及其可用的值。大部份可以使用 <code>zfs inherit</code> 還原成其繼承的值。</p></div><div class=paragraph><p>也可設定使用者自訂的屬性。這些屬性也會成為資料集設定的一部份，且可以被用來提供資料集或其內容的額外資訊。要別分自訂屬性與 ZFS 提供的屬性，會使用冒號 (<code>:</code>) 建立一個自訂命名空間供自訂屬性使用。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set custom:costcenter=1234 tank</span>
<span class=c># zfs get custom:costcenter tank</span>
NAME PROPERTY           VALUE SOURCE
tank custom:costcenter  1234  <span class=nb>local</span></code></pre></div></div><div class=paragraph><p>要移除自訂屬性，可用 <code>zfs inherit</code> 加上 <code>-r</code>。若父資料集未定義任何自訂屬性，將會將該屬性完全移除 (更改動作仍會記錄於儲存池的歷史記錄)。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs inherit -r custom:costcenter tank</span>
<span class=c># zfs get custom:costcenter tank</span>
NAME    PROPERTY           VALUE              SOURCE
tank    custom:costcenter  -                  -
<span class=c># zfs get all tank | grep custom:costcenter</span>
<span class=c>#</span></code></pre></div></div><div class=sect4><h5 id=zfs-zfs-set-share>19.4.4.1. 取得與設定共享屬性<a class=anchor href=#zfs-zfs-set-share></a></h5><div class=paragraph><p>Two commonly used and useful dataset properties are the NFS and SMB share options. Setting these define if and how ZFS datasets may be shared on the network. At present, only setting sharing via NFS is supported on FreeBSD. To get the current status of a share, enter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get sharenfs mypool/usr/home</span>
NAME             PROPERTY  VALUE    SOURCE
mypool/usr/home  sharenfs  on       <span class=nb>local</span>
<span class=c># zfs get sharesmb mypool/usr/home</span>
NAME             PROPERTY  VALUE    SOURCE
mypool/usr/home  sharesmb  off      <span class=nb>local</span></code></pre></div></div><div class=paragraph><p>To enable sharing of a dataset, enter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  zfs set sharenfs=on mypool/usr/home</span></code></pre></div></div><div class=paragraph><p>It is also possible to set additional options for sharing datasets through NFS, such as <code>-alldirs</code>, <code>-maproot</code> and <code>-network</code>. To set additional options to a dataset shared through NFS, enter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  zfs set sharenfs=&#34;-alldirs,-maproot=root,-network=192.168.1.0/24&#34; mypool/usr/home</span></code></pre></div></div></div></div><div class=sect3><h4 id=zfs-zfs-snapshot>19.4.5. 管理快照 (Snapshot)<a class=anchor href=#zfs-zfs-snapshot></a></h4><div class=paragraph><p>快照 (<a href=#zfs-term-snapshot>Snapshot</a>) 是 ZFS 最強大的功能之一。快照提供了資料集唯讀、單一時間點 (Point-in-Time) 的複製功能，使用了寫入時複製 (Copy-On-Write, COW) 的技術，可以透過保存在磁碟上的舊版資料快速的建立快照。若沒有快照存在，在資料被覆蓋或刪除時，便回收空間供未來使用。由於只記錄前一個版本與目前資料集的差異，因此快照可節省磁碟空間。快照只允許在整個資料集上使用，無法在各別檔案或目錄。當建立了一個資料集的快照時，便備份了所有內含的資料，這包含了檔案系統屬性、檔案、目錄、權限等等。第一次建立快照時只會使用到更改參照到資料區塊的空間，不會用到其他額外的空間。使用 <code>-r</code> 可以對使用同名的資料集及其所有子資料集的建立一個遞迴快照，提供一致且即時 (Moment-in-time) 的完整檔案系統快照功能，這對於那些彼此有相關或相依檔案存放在不同資料集的應用程式非常重要。不使用快照所備份的資料其實是分散不同時間點的。</p></div><div class=paragraph><p>ZFS 中的快照提供了多種功能，即使是在其他缺乏快照功能的檔案系統上。一個使用快照的典型例子是在安裝軟體或執行系統升級這種有風險的動作時，能有一個快速的方式可以備份檔案系統目前的狀態，若動作失敗，可以使用快照還原 (Roll back) 到與快照建立時相同的系統狀態，若升級成功，便可刪除快照來釋放空間。若沒有快照功能，升級失敗通常會需要使用備份來恢復 (Restore) 系統，而這個動作非常繁瑣、耗時且可能會需要停機一段時間系統無法使用。使用快照可以快速的還原，即使系統正在執行一般的運作，只而要短暫或甚至不需停機。能夠節省大量在有數 TB 的儲存系統上從備份複製所需資料的時間。快照並非要用來取代儲存池的完整備份，但可以用在快速且簡單的保存某個特定時間點的資料集。</p></div><div class=sect4><h5 id=zfs-zfs-snapshot-creation>19.4.5.1. 建立快照<a class=anchor href=#zfs-zfs-snapshot-creation></a></h5><div class=paragraph><p>快照可以使用 <code>zfs snapshot <em>dataset</em>@<em>snapshotname</em></code> 來建立。加入 <code>-r</code> 可以遞迴對所有同名的子資料集建立快照。</p></div><div class=paragraph><p>建立一個整個儲存池的遞迴快照：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -t all</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool                                 780M  93.2G   144K  none
mypool/ROOT                            777M  93.2G   144K  none
mypool/ROOT/default                    777M  93.2G   777M  /
mypool/tmp                             176K  93.2G   176K  /tmp
mypool/usr                             616K  93.2G   144K  /usr
mypool/usr/home                        184K  93.2G   184K  /usr/home
mypool/usr/ports                       144K  93.2G   144K  /usr/ports
mypool/usr/src                         144K  93.2G   144K  /usr/src
mypool/var                            1.29M  93.2G   616K  /var
mypool/var/crash                       148K  93.2G   148K  /var/crash
mypool/var/log                         178K  93.2G   178K  /var/log
mypool/var/mail                        144K  93.2G   144K  /var/mail
mypool/var/newname                    87.5K  93.2G  87.5K  /var/newname
mypool/var/newname@new_snapshot_name      0      -  87.5K  -
mypool/var/tmp                         152K  93.2G   152K  /var/tmp
<span class=c># zfs snapshot -r mypool@my_recursive_snapshot</span>
<span class=c># zfs list -t snapshot</span>
NAME                                        USED  AVAIL  REFER  MOUNTPOINT
mypool@my_recursive_snapshot                   0      -   144K  -
mypool/ROOT@my_recursive_snapshot              0      -   144K  -
mypool/ROOT/default@my_recursive_snapshot      0      -   777M  -
mypool/tmp@my_recursive_snapshot               0      -   176K  -
mypool/usr@my_recursive_snapshot               0      -   144K  -
mypool/usr/home@my_recursive_snapshot          0      -   184K  -
mypool/usr/ports@my_recursive_snapshot         0      -   144K  -
mypool/usr/src@my_recursive_snapshot           0      -   144K  -
mypool/var@my_recursive_snapshot               0      -   616K  -
mypool/var/crash@my_recursive_snapshot         0      -   148K  -
mypool/var/log@my_recursive_snapshot           0      -   178K  -
mypool/var/mail@my_recursive_snapshot          0      -   144K  -
mypool/var/newname@new_snapshot_name           0      -  87.5K  -
mypool/var/newname@my_recursive_snapshot       0      -  87.5K  -
mypool/var/tmp@my_recursive_snapshot           0      -   152K  -</code></pre></div></div><div class=paragraph><p>建立的快照不會顯示在一般的 <code>zfs list</code> 操作結果，要列出快照需在 <code>zfs list</code> 後加上 <code>-t snapshot</code>，使用 <code>-t all</code> 可以同時列出檔案系統的內容及快照。</p></div><div class=paragraph><p>快照並不會直接掛載，因此 <code>MOUNTPOINT</code> 欄位的路徑如此顯示。在 <code>AVAIL</code> 欄位不會有可用的磁碟空間，因為快照建立之後便無法再寫入。比較快照與其原來建立時的資料集：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all mypool/usr/home</span>
NAME                                    USED  AVAIL  REFER  MOUNTPOINT
mypool/usr/home                         184K  93.2G   184K  /usr/home
mypool/usr/home@my_recursive_snapshot      0      -   184K  -</code></pre></div></div><div class=paragraph><p>同時顯示資料集與快照可以了解快照如何使用 <a href=#zfs-term-cow>COW</a> 技術來運作。快照只會保存有更動 (<em>差異</em>) 的資料，並非整個檔案系統的內容，這個意思是說，快照只會在有做更動時使用一小部份的空間，複製一個檔案到該資料集，可以讓空間使用量變的更明顯，然後再做第二個快照：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/passwd /var/tmp</span>
<span class=c># zfs snapshot mypool/var/tmp@after_cp</span>
<span class=c># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -</code></pre></div></div><div class=paragraph><p>第二快照只會包含了資料集做了複製動作後的更動，這樣的機制可以節省大量的空間。注意在複製之後快照 <em>mypool/var/tmp@my_recursive_snapshot</em> 於 <code>USED</code> 欄位中的大小也更改了，這說明了這個更動在前次快照與之後快照間的關係。</p></div></div><div class=sect4><h5 id=zfs-zfs-snapshot-diff>19.4.5.2. 比對快照<a class=anchor href=#zfs-zfs-snapshot-diff></a></h5><div class=paragraph><p>ZFS 提供了內建指令可以用來比對兩個快照 (Snapshot) 之間的差異，在使用者想要查看一段時間之間檔案系統所的變更時非常有用。例如 <code>zfs diff</code> 可以讓使用者在最後一次快照中找到意外刪除的檔案。對前面一節所做的兩個快照使用這個指令會產生以下結果：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -
<span class=c># zfs diff mypool/var/tmp@my_recursive_snapshot</span>
M       /var/tmp/
+       /var/tmp/passwd</code></pre></div></div><div class=paragraph><p>指令會列出指定快照 (在這個例子中為 <code><em>mypool/var/tmp@my_recursive_snapshot</em></code>) 與目前檔案系統間的更改。第一個欄位是更改的類型：</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>加入了該路徑或檔案。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>刪除了該路徑或檔案。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>M</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>修改了該路徑或檔案。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>R</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重新命名了該路徑或檔案。</p></td></tr></tbody></table><div class=paragraph><p>對照這個表格來看輸出的結果，可以明顯的看到 <span class=filename>passwd</span> 是在快照 <code><em>mypool/var/tmp@my_recursive_snapshot</em></code> 建立之後才加入的，結果也同樣看的到掛載到 <code><em>/var/tmp</em></code> 的父目錄已經做過修改。</p></div><div class=paragraph><p>在使用 ZFS 備份功能來傳輸一個資料集到另一個主機備份時比對兩個快照也同樣很有用。</p></div><div class=paragraph><p>比對兩個快照需要提供兩個資料集的完整資料集名稱與快照名稱：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /var/tmp/passwd /var/tmp/passwd.copy</span>
<span class=c># zfs snapshot mypool/var/tmp@diff_snapshot</span>
<span class=c># zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@diff_snapshot</span>
M       /var/tmp/
+       /var/tmp/passwd
+       /var/tmp/passwd.copy
<span class=c># zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@after_cp</span>
M       /var/tmp/
+       /var/tmp/passwd</code></pre></div></div><div class=paragraph><p>備份管理者可以比對兩個自傳送主機所接收到的兩個快照並查看實際在資料集中的變更。請參考 <a href=#zfs-zfs-send>備份</a> 一節來取得更多資訊。</p></div></div><div class=sect4><h5 id=zfs-zfs-snapshot-rollback>19.4.5.3. 使用快照還原<a class=anchor href=#zfs-zfs-snapshot-rollback></a></h5><div class=paragraph><p>只要至少有一個可用的快照便可以隨時還原。大多數在已不需要目前資料集，想要改用較舊版的資料的情況，例如，本地開發的測試發生錯誤、不良的系統更新破壞了系統的整體功能或需要還原意外刪除檔案或目錄 …​ 等，都是非常常見的情形。幸運的，要還原到某個快照只需要簡單輸入 <code>zfs rollback <em>snapshotname</em></code>。會依快照所做的變更數量來決定處理的時間，還原的操作會在一段時間後完成。在這段時間中，資料集會一直保持一致的狀態，類似一個符合 ACID 原則的資料庫在做還原。還原可在資料集處於上線及可存取的情況下完成，不需要停機。還原到快照之後，資料集便回到當初執行快照時相同的狀態，所有沒有在快照中的其他資料便會被丟棄，因此往後若還有可能需要部份資料時，建議在還原到前一個快照之前先對目前的資料集做快照，這樣一來，使用者便可以在快照之間來回快換，而不會遺失重要的資料。</p></div><div class=paragraph><p>在第一個範例中，因為 <code>rm</code> 操作不小心移除了預期外的資料，要還原到快照。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         262K  93.2G   120K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<span class=c># ls /var/tmp</span>
passwd          passwd.copy     vi.recover
<span class=c># rm /var/tmp/passwd*</span>
<span class=c># ls /var/tmp</span>
vi.recover</code></pre></div></div><div class=paragraph><p>在此時，使用者發現到刪除了太多檔案並希望能夠還原。ZFS 提供了簡單的方可以取回檔案，便是使用還原 (Rollback)，但這只在有定期對重要的資料使用快照時可用。要拿回檔案並從最後一次快照重新開始，可執行以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs rollback mypool/var/tmp@diff_snapshot</span>
<span class=c># ls /var/tmp</span>
passwd          passwd.copy     vi.recover</code></pre></div></div><div class=paragraph><p>還原操作會將資料集還原為最後一次快照的狀態。這也可以還原到更早之前，有其他在其之後建立的快照。要這麼做時，ZFS 會發出這個警告：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt snapshot mypool/var/tmp</span>
AME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<span class=c># zfs rollback mypool/var/tmp@my_recursive_snapshot</span>
cannot rollback to <span class=s1>&#39;mypool/var/tmp@my_recursive_snapshot&#39;</span>: more recent snapshots exist
use <span class=s1>&#39;-r&#39;</span> to force deletion of the following snapshots:
mypool/var/tmp@after_cp
mypool/var/tmp@diff_snapshot</code></pre></div></div><div class=paragraph><p>這個警告是因在該快照與資料集的目前狀態之間有其他快照存在，然而使用者想要還原到該快照。要完成這樣的還原動作，必須刪除在這之間的快照，因為 ZFS 無法追蹤不同資料集狀態間的變更。在使用者未指定 <code>-r</code> 來確認這個動作前，ZFS 不會刪除受影響的快照。若確定要這麼做，那麼必須要知道會遺失所有在這之間的快照，然後可執行以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs rollback -r mypool/var/tmp@my_recursive_snapshot</span>
<span class=c># zfs list -rt snapshot mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot     8K      -   152K  -
<span class=c># ls /var/tmp</span>
vi.recover</code></pre></div></div><div class=paragraph><p>可從 <code>zfs list -t snapshot</code> 的結果來確認 <code>zfs rollback -r</code> 會移除的快照。</p></div></div><div class=sect4><h5 id=zfs-zfs-snapshot-snapdir>19.4.5.4. 從快照還原個別檔案<a class=anchor href=#zfs-zfs-snapshot-snapdir></a></h5><div class=paragraph><p>快照會掛載在父資料集下的隱藏目錄：<span class=filename>.zfs/snapshots/snapshotname</span>。預設不會顯示這些目錄，即使是用 <code>ls -a</code> 指令。雖然該目錄不會顯示，但該目錄實際存在，而且可以像一般的目錄一樣存取。一個名稱為 <code>snapdir</code> 的屬性可以控制是否在目錄清單中顯示這些隱藏目錄，設定該屬性為可見 (<code>visible</code>) 可以讓這些目錄出現在 <code>ls</code> 以及其他處理目錄內容的指令中。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get snapdir mypool/var/tmp</span>
NAME            PROPERTY  VALUE    SOURCE
mypool/var/tmp  snapdir   hidden   default
<span class=c># ls -a /var/tmp</span>
<span class=nb>.</span>               ..              passwd          vi.recover
<span class=c># zfs set snapdir=visible mypool/var/tmp</span>
<span class=c># ls -a /var/tmp</span>
<span class=nb>.</span>               ..              .zfs            passwd          vi.recover</code></pre></div></div><div class=paragraph><p>要還原個別檔案到先前的狀態非常簡單，只要從快照中複製檔案到父資料集。在 <span class=filename>.zfs/snapshot</span> 目錄結構下有一個與先前所做的快照名稱相同的目錄，可以很容易的找到。在下個範例中，我們會示範從隱藏的 <span class=filename>.zfs</span> 目錄還原一個檔案，透過從含有該檔案的最新版快照複製：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm /var/tmp/passwd</span>
<span class=c># ls -a /var/tmp</span>
<span class=nb>.</span>               ..              .zfs            vi.recover
<span class=c># ls /var/tmp/.zfs/snapshot</span>
after_cp                my_recursive_snapshot
<span class=c># ls /var/tmp/.zfs/snapshot/after_cp</span>
passwd          vi.recover
<span class=c># cp /var/tmp/.zfs/snapshot/after_cp/passwd /var/tmp</span></code></pre></div></div><div class=paragraph><p>執行 <code>ls .zfs/snapshot</code> 時，雖然 <code>snapdir</code> 可能已經設為隱藏，但仍可能可以顯示該目錄中的內容，這取決於管理者是否要顯示這些目錄，可以只顯示特定的資料集，而其他的則不顯示。從這個隱藏的 <span class=filename>.zfs/snapshot</span> 複製檔案或目錄非常簡單，除此之外，嘗試其他的動作則會出現以下錯誤：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/rc.conf /var/tmp/.zfs/snapshot/after_cp/</span>
<span class=nb>cp</span>: /var/tmp/.zfs/snapshot/after_cp/rc.conf: Read-only file system</code></pre></div></div><div class=paragraph><p>這個錯誤用來提醒使用者快照是唯讀的，在建立之後不能更改。無法複製檔案進去或從該快照目錄中移除，因為這會變更該資料集所代表的狀態。</p></div><div class=paragraph><p>快照所消耗的空間是依據自快照之後父檔案系統做了多少變更來決定，快照的 <code>written</code> 屬性可以用來追蹤有多少空間被快照所使用。</p></div><div class=paragraph><p>使用 <code>zfs destroy <em>dataset</em>@<em>snapshot</em></code> 可以摧毀快照並回收空間。加上 <code>-r</code> 可以遞迴移除所有在父資料集下使用同名的快照。加入 <code>-n -v</code> 來顯示將要移除的快照清單以及估計回收的空間，而不會實際執行摧毀的操作。</p></div></div></div><div class=sect3><h4 id=zfs-zfs-clones>19.4.6. 管理複本 (Clone)<a class=anchor href=#zfs-zfs-clones></a></h4><div class=paragraph><p>複本 (Clone) 是快照的複製，但更像是一般的資料集，與快照不同的是，複本是非唯讀的 (可寫)，且可掛載，可以有自己的屬性。使用 <code>zfs clone</code> 建立複本之後，便無法再摧毀用來建立複本的快照。複本與快照的父/子關係可以使用 <code>zfs promote</code> 來對換。提升複本之後 ，快照便會成為複本的子資料集，而不是原來的父資料集，這個動作會改變空間計算的方式，但並不會實際改變空間的使用量。複本可以被掛載到 ZFS 檔案系統階層中的任何一點，並非只能位於原來快照的位置底下。</p></div><div class=paragraph><p>要示範複本功能會用到這個範例資料集：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all camino/home/joe</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
camino/home/joe         108K   1.3G    87K  /usr/home/joe
camino/home/joe@plans    21K      -  85.5K  -
camino/home/joe@backup    0K      -    87K  -</code></pre></div></div><div class=paragraph><p>會使用到複本一般是要在可以保留快照以便出錯時可還原的情況下使用指定的資料集做實驗，由於快照並無法做更改，所以會建立一個可以讀/寫的快照複本。當在複本中做完想要執行的動作後，便可以提升複本成資料集，然後移除舊的檔案系統。嚴格來說這並非必要，因為複本與資料集可同時存在，不會有任何問題。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs clone camino/home/joe@backup camino/home/joenew</span>
<span class=c># ls /usr/home/joe*</span>
/usr/home/joe:
backup.txz     plans.txt

/usr/home/joenew:
backup.txz     plans.txt
<span class=c># df -h /usr/home</span>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G     31k    1.3G     0%    /usr/home/joe
usr/home/joenew     1.3G     31k    1.3G     0%    /usr/home/joenew</code></pre></div></div><div class=paragraph><p>建立完的複本便有與建立快照時狀態相同的資料集，現在複本可以獨立於原來的資料集來做更改。剩下唯一與資料集之間的關係便是快照，ZFS 會在屬性 <code>origin</code> 記錄這個關係，一旦在快照與複本之間的相依關係因為使用 <code>zfs promote</code> 提升而移除時，複本的 <code>origin</code> 也會因為成為一個完全獨立的資料集而移除。以下範例會示範這個動作：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get origin camino/home/joenew</span>
NAME                  PROPERTY  VALUE                     SOURCE
camino/home/joenew    origin    camino/home/joe@backup    -
<span class=c># zfs promote camino/home/joenew</span>
<span class=c># zfs get origin camino/home/joenew</span>
NAME                  PROPERTY  VALUE   SOURCE
camino/home/joenew    origin    -       -</code></pre></div></div><div class=paragraph><p>做為部份更改之後，例如複製 <span class=filename>loader.conf</span> 到提升後的複本，這個例子中的舊目錄便無須保留，取而代之的是提升後的複本，這個動作可以用兩個連續的指令來完成：在舊資料集上執行 <code>zfs destroy</code> 並在與舊資料相似名稱 (也可能用完全不同的名稱) 的複本上執行 <code>zfs rename</code>。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /boot/defaults/loader.conf /usr/home/joenew</span>
<span class=c># zfs destroy -f camino/home/joe</span>
<span class=c># zfs rename camino/home/joenew camino/home/joe</span>
<span class=c># ls /usr/home/joe</span>
backup.txz     loader.conf     plans.txt
<span class=c># df -h /usr/home</span>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G    128k    1.3G     0%    /usr/home/joe</code></pre></div></div><div class=paragraph><p>快照的複本現在可以如同一般資料集一樣使用，它的內容包含了所有來自原始快照的資料以及後來加入的檔案，例如 <span class=filename>loader.conf</span>。複本可以在許多不同的情境下使用提供 ZFS 的使用者有用的功能，例如，Jail 可以透過含有已安裝了各種應用程式集的快照來提供，使用者可以複製這些快照然後加入自己想要嘗試的應用程式，一但更改可以滿足需求，便可提升複本為完整的資料集然後提供給終端使用者，讓終端使用者可以如同實際擁有資料集一般的使用，這個以節省提供這些 Jail 的時間與管理成本。</p></div></div><div class=sect3><h4 id=zfs-zfs-send>19.4.7. 備份 (Replication)<a class=anchor href=#zfs-zfs-send></a></h4><div class=paragraph><p>將資料保存在單一地點的單一儲存池上會讓資料暴露在盜竊、自然或人為的風險之下，定期備份整個儲存池非常重要，ZFS 提供了內建的序列化 (Serialization) 功能可以將資料以串流傳送到標準輸出。使用這項技術，不僅可以將資料儲存到另一個已連結到本地系統的儲存池，也可以透過網路將資料傳送到另一個系統，這種備份方式以快照為基礎 (請參考章節 <a href=#zfs-zfs-snapshot>ZFS 快照(Snapshot)</a>)。用來備份資料的指令為 <code>zfs send</code> 及 <code>zfs receive</code>。</p></div><div class=paragraph><p>以下例子將示範使用兩個儲存池來做 ZFS 備份：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M    77K   896M         -         -     0%    0%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%    4%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>名為 <em>mypool</em> 的儲存池為主要的儲存池，資料會定期寫入與讀取的位置。第二個儲存池 <em>backup</em> 用來待命 (Standby)，萬一主要儲存池無法使用時可替換。注意，ZFS 並不會自動做容錯移轉 (Fail-over)，必須要由系統管理者在需要的時候手動完成。快照會用來提供一個與檔系統一致的版本來做備份，<em>mypool</em> 的快照建立之後，便可以複製到 <em>backup</em> 儲存池，只有快照可以做備份，最近一次快照之後所做的變更不會含在內容裡面。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot mypool@backup1</span>
<span class=c># zfs list -t snapshot</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@backup1             0      -  43.6M  -</code></pre></div></div><div class=paragraph><p>快照存在以後，便可以使用 <code>zfs send</code> 來建立一個代表快照內容的串流，這個串流可以儲存成檔案或由其他儲存池接收。串流會寫入到標準輸出，但是必須要重新導向到一個檔案或轉接到其他地方，否則會錯誤：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs send mypool@backup1</span>
Error: Stream can not be written to a terminal.
You must redirect standard output.</code></pre></div></div><div class=paragraph><p>要使用 <code>zfs send</code> 備份一個資料集，可重新導向到一個位於在已掛載到備份儲存池上的檔案。確定該儲存池有足夠的空間容納要傳送的快照，這裡指的是該快照中內含的所有資料，並非只有上次快照到該快照間的變更。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs send mypool@backup1 &gt; /backup/backup1</span>
<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p><code>zfs send</code> 會傳輸在快照 <em>backup1</em> 中所有的資料到儲存池 <em>backup</em>。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 排程來自動完成建立與傳送快照的動作。</p></div><div class=paragraph><p>若不想將備份以封存檔案儲存，ZFS 可用實際的檔案系統來接收資料，讓備份的資料可以直接被存取。要取得實際包含在串流中的資料可以用 <code>zfs receive</code> 將串流轉換回檔案與目錄。以下例子會以管線符號連接 <code>zfs send</code> 及 <code>zfs receive</code>，將資料從一個儲存池複製到另一個，傳輸完成後可以直接使用接收儲存池上的資料。一個資料集只可以被複製到另一個空的資料集。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot mypool@replica1</span>
<span class=c># zfs send -v mypool@replica1 | zfs receive backup/mypool</span>
send from @ to mypool@replica1 estimated size is 50.1M
total estimated size is 50.1M
TIME        SENT   SNAPSHOT

<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</code></pre></div></div><div class=sect4><h5 id=zfs-send-incremental>19.4.7.1. 漸進式備份<a class=anchor href=#zfs-send-incremental></a></h5><div class=paragraph><p><code>zfs send</code> 也可以比較兩個快照之間的差異，並且只傳送兩者之間的差異，這麼做可以節省磁碟空間及傳輸時間。例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot mypool@replica2</span>
<span class=c># zfs list -t snapshot</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@replica1         5.72M      -  43.6M  -
mypool@replica2             0      -  44.1M  -
<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M  61.7M   898M         -         -     0%    6%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%    5%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>會建立一個名為 <em>replica2</em> 的第二個快照，這個快照只中只會含有目前與前次快照 <em>replica1</em> 之間檔案系統所做的變更。使用 <code>zfs send -i</code> 並指定要用來產生漸進備份串流的快照，串流中只會含有做過更改的資料。這個動作只在接收端已經有初始快照時才可用。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs send -v -i mypool@replica1 mypool@replica2 | zfs receive /backup/mypool</span>
send from @replica1 to mypool@replica2 estimated size is 5.02M
total estimated size is 5.02M
TIME        SENT   SNAPSHOT

<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG  CAP  DEDUP  HEALTH  ALTROOT
backup  960M  80.8M   879M         -         -     0%   8%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%   5%  1.00x  ONLINE  -

<span class=c># zfs list</span>
NAME                         USED  AVAIL  REFER  MOUNTPOINT
backup                      55.4M   240G   152K  /backup
backup/mypool               55.3M   240G  55.2M  /backup/mypool
mypool                      55.6M  11.6G  55.0M  /mypool

<span class=c># zfs list -t snapshot</span>
NAME                                         USED  AVAIL  REFER  MOUNTPOINT
backup/mypool@replica1                       104K      -  50.2M  -
backup/mypool@replica2                          0      -  55.2M  -
mypool@replica1                             29.9K      -  50.0M  -
mypool@replica2                                 0      -  55.0M  -</code></pre></div></div><div class=paragraph><p>如此一來，便成功傳輸漸進式的串流，只有做過更改的資料會被備份，不會傳送完整的 <em>replica1</em>。由於不會備份完整的儲存池，只傳送差異的部份，所以可以減少傳輸的時間並節省磁碟空間，特別是在網路緩慢或需要考量每位元傳輸成本時非常有用。</p></div><div class=paragraph><p>從儲存池 <em>mypool</em> 複製所有檔案與資料的新檔案系統 <em>backup/mypool</em> 便可以使用。若指定 <code>-P</code>，會一併複製資料集的屬性，這包含壓縮 (Compression) 設定，配額 (Quota) 及掛載點 (Mount point)。若指定 <code>-R</code>，會複製所有指定資料集的子資料集，及這些子資料集的所有屬性。可將傳送與接收自動化來定期使用第二個儲存池做備份。</p></div></div><div class=sect4><h5 id=zfs-send-ssh>19.4.7.2. 透過 SSH 傳送加密的備份<a class=anchor href=#zfs-send-ssh></a></h5><div class=paragraph><p>透過網路來傳送串流是一個做遠端備份不錯的方式，但是也有一些缺點，透過網路連線傳送的資料沒有加密，這會讓任何人都可以在未告知傳送方的情況下攔截並轉換串流回資料，這是我們所不想見到的情況，特別是在使用網際網路傳送串流到遠端的主機時。SSH 可用來加密要透過網路連線傳送的資料，在 ZFS 只需要將串流重新導向到標準輸出，如此一來便可簡單的轉接到 SSH。若要讓檔案系統內容在傳送或在遠端系統中也維持在加密的狀態可考慮使用 <a href=https://wiki.freebsd.org/PEFS>PEFS</a>。</p></div><div class=paragraph><p>有一些設定以及安全性注意事項必須先完成，只有對 <code>zfs send</code> 操作必要的步驟才會在此說明，要取得更多有關 SSH 的資訊請參考 <a href=./#openssh>OpenSSH</a>。</p></div><div class=paragraph><p>必要的環境設定：</p></div><div class=ulist><ul><li><p>使用 SSH 金鑰設定傳送端與接收端間無密碼的 SSH 存取</p></li><li><p>正常會需要 <code>root</code> 的權限來傳送與接收串流，這需要可以 <code>root</code> 登入到接收端系統。但是，預設因安全性考慮會關閉以 <code>root</code> 登入。ZFS 委託 (<a href=#zfs-zfs-allow>ZFS Delegation</a>) 系統可以用來允許一個非 <code>root</code> 使用者在每個系統上執行各自的發送與接收操作。</p></li><li><p>在傳送端系統上：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs allow -u someuser send,snapshot mypool</span></code></pre></div></div></li><li><p>要掛載儲存池，無權限的使用者必須擁有該目錄且必須允許一般的使用者掛載檔案系統。在接收端系統上：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1
<span class=c># sysrc -f /etc/sysctl.conf vfs.usermount=1</span>
<span class=c># zfs create recvpool/backup</span>
<span class=c># zfs allow -u someuser create,mount,receive recvpool/backup</span>
<span class=c># chown someuser /recvpool/backup</span></code></pre></div></div></li></ul></div><div class=paragraph><p>無權限的使用者現在有能力可以接收並掛載資料集，且 <em>home</em> 資料集可以被複製到遠端系統：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% zfs snapshot <span class=nt>-r</span> mypool/home@monday
% zfs send <span class=nt>-R</span> mypool/home@monday | ssh someuser@backuphost zfs recv <span class=nt>-dvu</span> recvpool/backup</code></pre></div></div><div class=paragraph><p>替儲存在儲存池 <em>mypool</em> 上的檔案系統資料集 <em>home</em> 製作一個遞迴快照 <em>monday</em>，然後使用 <code>zfs send -R</code> 來傳送包含該資料集及其所有子資料集、快照、複製與設定的串流。輸出會被導向到 SSH 連線的遠端主機 <em>backuphost</em> 上等候輸入的 <code>zfs receive</code>，在此建議使用完整網域名稱或 IP 位置。接收端的機器會寫入資料到 <em>recvpool</em> 儲存池上的 <em>backup</em> 資料集，在 <code>zfs recv</code> 加上 <code>-d</code> 可覆寫在接收端使用相同名稱的快照，加上 <code>-u</code> 可讓檔案系統在接收端不會被掛載，當使用 <code>-v</code>，會顯示更多有關傳輸的詳細資訊，包含已花費的時間及已傳輸的資料量。</p></div></div></div><div class=sect3><h4 id=zfs-zfs-quota>19.4.8. 資料集、使用者以及群組配額<a class=anchor href=#zfs-zfs-quota></a></h4><div class=paragraph><p>資料集配額 (<a href=#zfs-term-quota>Dataset quota</a>) 可用來限制特定資料集可以使用的的空間量。參考配額 (<a href=#zfs-term-refquota>Reference Quota</a>) 的功能也非常相似，差在參考配額只會計算資料集自己使用的空間，不含快照與子資料集。類似的，使用者 (<a href=#zfs-term-userquota>User</a>) 與群組 (<a href=#zfs-term-groupquota>Group</a>) 配額可以用來避免使用者或群組用掉儲存池或資料集的所有空間。</p></div><div class=paragraph><p>要設定 <span class=filename>storage/home/bob</span> 的資料集配額為 10 GB：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set quota=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>要設定 <span class=filename>storage/home/bob</span> 的參考配額為 10 GB：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set refquota=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>要移除 <span class=filename>storage/home/bob</span> 的 10 GB 配額：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set quota=none storage/home/bob</span></code></pre></div></div><div class=paragraph><p>設定使用者配額的一般格式為 <code>userquota@<em>user</em>=<em>size</em></code> 使用者的名稱必須使用以下格式：</p></div><div class=ulist><ul><li><p>POSIX 相容的名稱，如 <em>joe</em>。</p></li><li><p>POSIX 數字 ID，如 <em>789</em>。</p></li><li><p>SID 名稱，如 <em>joe.bloggs@example.com</em>。</p></li><li><p>SID 數字 ID，如 <em>S-1-123-456-789</em>。</p></li></ul></div><div class=paragraph><p>例如，要設定使用者名為 <em>joe</em> 的使用者配額為 50 GB：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set userquota@joe=50G</span></code></pre></div></div><div class=paragraph><p>要移除所有配額：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set userquota@joe=none</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>使用者配額的屬性不會顯示在 <code>zfs get all</code>。非 <code>root</code> 的使用者只可以看到自己的配額，除非它們有被授予 <code>userquota</code> 權限，擁有這個權限的使用者可以檢視與設定任何人的配額。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要設定群組配額的一般格式為：<code>groupquota@<em>group</em>=<em>size</em></code>。</p></div><div class=paragraph><p>要設定群組 <em>firstgroup</em> 的配額為 50 GB 可使用：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set groupquota@firstgroup=50G</span></code></pre></div></div><div class=paragraph><p>要移除群組 <em>firstgroup</em> 的配額，或確保該群組未設定配額可使用：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set groupquota@firstgroup=none</span></code></pre></div></div><div class=paragraph><p>如同使用者配額屬性，非 <code>root</code> 使用者只可以查看自己所屬群組的配額。而 <code>root</code> 或擁有 <code>groupquota</code> 權限的使用者，可以檢視並設定所有群組的任何配額。</p></div><div class=paragraph><p>要顯示在檔案系統或快照上每位使用者所使用的空間量及配額可使用 <code>zfs userspace</code>，要取得群組的資訊則可使用 <code>zfs groupspace</code>，要取得有關支援的選項資訊或如何只顯示特定選項的資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=1&amp;format=html">zfs(1)</a>。</p></div><div class=paragraph><p>有足夠權限的使用者及 <code>root</code> 可以使用以下指令列出 <span class=filename>storage/home/bob</span> 的配額：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get quota storage/home/bob</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-zfs-reservation>19.4.9. 保留空間<a class=anchor href=#zfs-zfs-reservation></a></h4><div class=paragraph><p>保留空間 (<a href=#zfs-term-reservation>Reservation</a>) 可以確保資料集最少可用的空間量，其他任何資料集無法使用保留的空間，這個功能在要確保有足夠的可用空間來存放重要的資料集或日誌檔時特別有用。</p></div><div class=paragraph><p><code>reservation</code> 屬性的一般格式為 <code>reservation=<em>size</em></code>，所以要在 <span class=filename>storage/home/bob</span> 設定保留 10 GB 的空間可以用：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set reservation=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>要清除任何保留空間：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set reservation=none storage/home/bob</span></code></pre></div></div><div class=paragraph><p>同樣的原則可以應用在 <code>refreservation</code> 屬性來設定參考保留空間 (<a href=#zfs-term-refreservation>Reference Reservation</a>)，參考保留空間的一般格式為 <code>refreservation=<em>size</em></code>。</p></div><div class=paragraph><p>這個指令會顯示任何已設定於 <span class=filename>storage/home/bob</span> 的 reservation 或 refreservation：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get reservation storage/home/bob</span>
<span class=c># zfs get refreservation storage/home/bob</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-zfs-compression>19.4.10. 壓縮 (Compression)<a class=anchor href=#zfs-zfs-compression></a></h4><div class=paragraph><p>ZFS 提供直接的壓縮功能，在資料區塊層級壓縮資料不僅可以節省空間，也可以增加磁碟的效能。若資料壓縮了 25%，但壓縮的資料會使用了與未壓縮版本相同的速率寫入到磁碟，所以實際的寫入速度會是原來的 125%。壓縮功能也可來替代去重複 (<a href=#zfs-zfs-deduplication>Deduplication</a>) 功能，因為壓縮並不需要使用額外的記憶體。</p></div><div class=paragraph><p>ZFS 提了多種不同的壓縮演算法，每一種都有不同的優缺點，隨著 ZFS v5000 引進了 LZ4 壓縮技術，可對整個儲存池開啟壓縮，而不像其他演算法需要消耗大量的效能來達成，最大的優點是 LZ4 擁有 <em>提早放棄</em> 的功能，若 LZ4 無法在資料一開始的部份達成至少 12.5% 的壓縮率，便會以不壓縮的方式來寫入資料區塊來避免 CPU 在那些已經壓縮過或無法壓縮的資料上浪費運算能力。要取得更多有關 ZFS 中可用的壓縮演算法詳細資訊，可參考術語章節中的壓縮 (<a href=#zfs-term-compression>Compression</a>) 項目。</p></div><div class=paragraph><p>管理者可以使用資料集的屬性來監視壓縮的效果。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get used,compressratio,compression,logicalused mypool/compressed_dataset</span>
NAME        PROPERTY          VALUE     SOURCE
mypool/compressed_dataset  used              449G      -
mypool/compressed_dataset  compressratio     1.11x     -
mypool/compressed_dataset  compression       lz4       <span class=nb>local
</span>mypool/compressed_dataset  logicalused       496G      -</code></pre></div></div><div class=paragraph><p>資料集目前使用了 449 GB 的空間 (在 used 屬性)。在尚未壓縮前，該資料集應該會使用 496 GB 的空間 (於 <code>logicalused</code> 屬性)，這個結果顯示目前的壓縮比為 1.11:1。</p></div><div class=paragraph><p>壓縮功能在與使用者配額 (<a href=#zfs-term-userquota>User Quota</a>) 一併使用時可能會產生無法預期的副作用。使用者配額會限制一個使用者在一個資料集上可以使用多少空間，但衡量的依據是以 <em>壓縮後</em> 所使用的空間，因此，若一個使用者有 10 GB 的配額，寫入了 10 GB 可壓縮的資料，使用者將還會有空間儲存額外的資料。若使用者在之後更新了一個檔案，例如一個資料庫，可能有更多或較少的可壓縮資料，那麼剩餘可用的空間量也會因此而改變，這可能會造成奇怪的現象便是，一個使用者雖然沒有增加實際的資料量 (於 <code>logicalused</code> 屬性)，但因為更改影響了壓縮率，導致使用者達到配額的上限。</p></div><div class=paragraph><p>壓縮功能在與備份功能一起使用時也可能會有類似的問題，通常會使用配額功能來限制能夠儲存的資料量來確保有足夠的備份空間可用。但是由於配額功能並不會考量壓縮狀況，可能會有比未壓縮版本備份更多的資料量會被寫入到資料集。</p></div></div><div class=sect3><h4 id=zfs-zfs-deduplication>19.4.11. 去重複 (Deduplication)<a class=anchor href=#zfs-zfs-deduplication></a></h4><div class=paragraph><p>當開啟，去重複 (<a href=#zfs-term-deduplication>Deduplication</a>) 功能會使用每個資料區塊的校驗碼 (Checksum) 來偵測重複的資料區塊，當新的資料區塊與現有的資料區塊重複，ZFS 便會寫入連接到現有資料的參考來替代寫入重複的資料區塊，這在資料中有大量重複的檔案或資訊時可以節省大量的空間，要注意的是：去重複功能需要使用大量的記憶體且大部份可節省的空間可改開啟壓縮功能來達成，而壓縮功能不需要使用額外的記憶體。</p></div><div class=paragraph><p>要開啟去重複功能，需在目標儲存池設定 <code>dedup</code> 屬性：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set dedup=on pool</span></code></pre></div></div><div class=paragraph><p>只有要被寫入到儲存池的新資料才會做去重複的動作，先前已被寫入到儲存池的資料不會因此啟動了這個選項而做去重複。查看已開啟去重複屬性的儲存池會如下：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool list</span>
NAME  SIZE ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG   CAP   DEDUP   HEALTH   ALTROOT
pool 2.84G 2.19M 2.83G         -         -     0%    0%   1.00x   ONLINE   -</code></pre></div></div><div class=paragraph><p><code>DEDUP</code> 欄位會顯示儲存池的實際去重複率，數值為 <code>1.00x</code> 代表資料尚未被去重複。在下一個例子會在前面所建立的去重複儲存池中複製三份 Port 樹到不同的目錄中。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for d in dir1 dir2 dir3; do</span>
<span class=o>&gt;</span> <span class=nb>mkdir</span> <span class=nv>$d</span> <span class=o>&amp;&amp;</span> <span class=nb>cp</span> <span class=nt>-R</span> /usr/ports <span class=nv>$d</span> &amp;
<span class=o>&gt;</span> <span class=k>done</span></code></pre></div></div><div class=paragraph><p>已經偵測到重複的資料並做去重複：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool list</span>
NAME SIZE  ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG  CAP   DEDUP   HEALTH   ALTROOT
pool 2.84G 20.9M 2.82G         -         -     0%   0%   3.00x   ONLINE   -</code></pre></div></div><div class=paragraph><p><code>DEDUP</code> 欄位顯示有 <code>3.00x</code> 的去重複率，這代表已偵測到多份複製的 Port 樹資料並做了去重複的動作，且只會使用第三份資料所佔的空間。去重複能節省空間的潛力可以非常巨大，但會需要消耗大量的記憶體來持續追蹤去重複的資料區塊。</p></div><div class=paragraph><p>去重複並非總是有效益的，特別是當儲存池中的資料本身並沒有重複時。ZFS 可以透過在現有儲存池上模擬開啟去重複功能來顯示可能節省的空間：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zdb -S pool</span>
Simulated DDT histogram:

bucket              allocated                       referenced
______   ______________________________   ______________________________
refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE
<span class=nt>------</span>   <span class=nt>------</span>   <span class=nt>-----</span>   <span class=nt>-----</span>   <span class=nt>-----</span>   <span class=nt>------</span>   <span class=nt>-----</span>   <span class=nt>-----</span>   <span class=nt>-----</span>
     1    2.58M    289G    264G    264G    2.58M    289G    264G    264G
     2     206K   12.6G   10.4G   10.4G     430K   26.4G   21.6G   21.6G
     4    37.6K    692M    276M    276M     170K   3.04G   1.26G   1.26G
     8    2.18K   45.2M   19.4M   19.4M    20.0K    425M    176M    176M
    16      174   2.83M   1.20M   1.20M    3.33K   48.4M   20.4M   20.4M
    32       40   2.17M    222K    222K    1.70K   97.2M   9.91M   9.91M
    64        9     56K   10.5K   10.5K      865   4.96M    948K    948K
   128        2   9.50K      2K      2K      419   2.11M    438K    438K
   256        5   61.5K     12K     12K    1.90K   23.0M   4.47M   4.47M
    1K        2      1K      1K      1K    2.98K   1.49M   1.49M   1.49M
 Total    2.82M    303G    275G    275G    3.20M    319G    287G    287G

dedup <span class=o>=</span> 1.05, compress <span class=o>=</span> 1.11, copies <span class=o>=</span> 1.00, dedup <span class=k>*</span> compress / copies <span class=o>=</span> 1.16</code></pre></div></div><div class=paragraph><p>在 <code>zdb -S</code> 分析完儲存池後會顯示在啟動去重複後可達到的空間減少比例。在本例中，<code>1.16</code> 是非常差的空間節省比例，因為這個比例使用壓縮功能便能達成。若在此儲存池上啟動去重複並不能明顯的節省空間使用量，那麼就不值得耗費大量的記憶體來開啟去重複功能。透過公式 <em>ratio = dedup * compress / copies</em>，系統管理者可以規劃儲存空間的配置，來判斷要處理的資料是否有足夠的重複資料區塊來平衡所需的記憶體。若資料是可壓縮的，那麼空間節少的效果可能會非常好，建議先開啟壓縮功能，且壓縮功能也可以大大提高效能。去重複功能只有在可以節省可觀的空間且有足夠的記憶體做 <a href=#zfs-term-deduplication>DDT</a> 時才開啟。</p></div></div><div class=sect3><h4 id=zfs-zfs-jail>19.4.12. ZFS 與 Jail<a class=anchor href=#zfs-zfs-jail></a></h4><div class=paragraph><p><code>zfs jail</code> 以及相關的 <code>jailed</code> 屬性可以用來將一個 ZFS 資料集委託給一個 <a href=./#jails>Jail</a> 管理。<code>zfs jail <em>jailid</em></code> 可以將一個資料集連結到一個指定的 Jail，而 <code>zfs unjail</code> 則可解除連結。資料集要可以在 Jail 中控制需設定 <code>jailed</code> 屬性，一旦資料集被隔離便無法再掛載到主機，因為有掛載點可能會破壞主機的安全性。</p></div></div></div><div class=sect2><h3 id=zfs-zfs-allow>19.5. 委託管理<a class=anchor href=#zfs-zfs-allow></a></h3><div class=paragraph><p>一個全面性的權限委託系統可能無權限的使用者執行 ZFS 的管理功能。例如，若每個使用者的家目錄均為一個資料集，便可以給予使用者權限建立與摧毀它們家目錄中的快照。可以給予備份使用者使用備份功能的權限。一個使用量統計的 Script 可以允許其在執行時能存取所有使用者的空間利用率資料。甚至可以將委託權限委託給其他人，每個子指令與大多數屬性都可使用權限委託。</p></div><div class=sect3><h4 id=zfs-zfs-allow-create>19.5.1. 委託資料集建立<a class=anchor href=#zfs-zfs-allow-create></a></h4><div class=paragraph><p><code>zfs allow <em>someuser</em> create <em>mydataset</em></code> 可以給予指定的使用者在指定的父資料集下建立子資料集的權限。這裡需要注意：建立新資料集會牽涉到掛載，因此需要設定 FreeBSD 的 <code>vfs.usermount</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 為 <code>1</code> 來允許非 root 的使用者掛載一個檔案系統。這裡還有另一項限制可以避免濫用：非 <code>root</code> 使用者必須擁有掛載點在檔案系統中所在位置的權限才可掛載。</p></div></div><div class=sect3><h4 id=zfs-zfs-allow-allow>19.5.2. 委託權限委託<a class=anchor href=#zfs-zfs-allow-allow></a></h4><div class=paragraph><p><code>zfs allow <em>someuser</em> allow <em>mydataset</em></code> 可以給予指定的使用者有權限指派它們在目標資料集或其子資料集上擁有的任何權限給其他人。若該使用者擁有 <code>snapshot</code> 權限及 <code>allow</code> 權限，則該使用者可以授權 <code>snapshot</code> 權限給其他使用者。</p></div></div></div><div class=sect2><h3 id=zfs-advanced>19.6. 進階主題<a class=anchor href=#zfs-advanced></a></h3><div class=sect3><h4 id=zfs-advanced-tuning>19.6.1. 調校<a class=anchor href=#zfs-advanced-tuning></a></h4><div class=paragraph><p>這裡有數個可調校的項目可以調整，來讓 ZFS 在面對各種工作都能以最佳狀況運作。</p></div><div class=ulist><ul><li><p><a id=zfs-advanced-tuning-arc_max></a><code><em>vfs.zfs.arc_max</em></code> - Maximum size of the <a href=#zfs-term-arc>ARC</a>. The default is all RAM but 1 GB, or 5/8 of all RAM, whichever is more. However, a lower value should be used if the system will be running any other daemons or processes that may require memory. This value can be adjusted at runtime with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> and can be set in <span class=filename>/boot/loader.conf</span> or <span class=filename>/etc/sysctl.conf</span>.</p></li><li><p><a id=zfs-advanced-tuning-arc_meta_limit></a><code><em>vfs.zfs.arc_meta_limit</em></code> - Limit the portion of the <a href=#zfs-term-arc>ARC</a> that can be used to store metadata. The default is one fourth of <code>vfs.zfs.arc_max</code>. Increasing this value will improve performance if the workload involves operations on a large number of files and directories, or frequent metadata operations, at the cost of less file data fitting in the <a href=#zfs-term-arc>ARC</a>. This value can be adjusted at runtime with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> and can be set in <span class=filename>/boot/loader.conf</span> or <span class=filename>/etc/sysctl.conf</span>.</p></li><li><p><a id=zfs-advanced-tuning-arc_min></a><code><em>vfs.zfs.arc_min</em></code> - Minimum size of the <a href=#zfs-term-arc>ARC</a>. The default is one half of <code>vfs.zfs.arc_meta_limit</code>. Adjust this value to prevent other applications from pressuring out the entire <a href=#zfs-term-arc>ARC</a>. This value can be adjusted at runtime with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> and can be set in <span class=filename>/boot/loader.conf</span> or <span class=filename>/etc/sysctl.conf</span>.</p></li><li><p><a id=zfs-advanced-tuning-vdev-cache-size></a><code><em>vfs.zfs.vdev.cache.size</em></code> - A preallocated amount of memory reserved as a cache for each device in the pool. The total amount of memory used will be this value multiplied by the number of devices. This value can only be adjusted at boot time, and is set in <span class=filename>/boot/loader.conf</span>.</p></li><li><p><a id=zfs-advanced-tuning-min-auto-ashift></a><code><em>vfs.zfs.min_auto_ashift</em></code> - Minimum <code>ashift</code> (sector size) that will be used automatically at pool creation time. The value is a power of two. The default value of <code>9</code> represents <code>2^9 = 512</code>, a sector size of 512 bytes. To avoid <em>write amplification</em> and get the best performance, set this value to the largest sector size used by a device in the pool.</p><div class=paragraph><p>Many drives have 4 KB sectors. Using the default <code>ashift</code> of <code>9</code> with these drives results in write amplification on these devices. Data that could be contained in a single 4 KB write must instead be written in eight 512-byte writes. ZFS tries to read the native sector size from all devices when creating a pool, but many drives with 4 KB sectors report that their sectors are 512 bytes for compatibility. Setting <code>vfs.zfs.min_auto_ashift</code> to <code>12</code> (<code>2^12 = 4096</code>) before creating a pool forces ZFS to use 4 KB blocks for best performance on these drives.</p></div><div class=paragraph><p>Forcing 4 KB blocks is also useful on pools where disk upgrades are planned. Future disks are likely to use 4 KB sectors, and <code>ashift</code> values cannot be changed after a pool is created.</p></div><div class=paragraph><p>In some specific cases, the smaller 512-byte block size might be preferable. When used with 512-byte disks for databases, or as storage for virtual machines, less data is transferred during small random reads. This can provide better performance, especially when using a smaller ZFS record size.</p></div></li><li><p><a id=zfs-advanced-tuning-prefetch_disable></a><code><em>vfs.zfs.prefetch_disable</em></code> - Disable prefetch. A value of <code>0</code> is enabled and <code>1</code> is disabled. The default is <code>0</code>, unless the system has less than 4 GB of RAM. Prefetch works by reading larger blocks than were requested into the <a href=#zfs-term-arc>ARC</a> in hopes that the data will be needed soon. If the workload has a large number of random reads, disabling prefetch may actually improve performance by reducing unnecessary reads. This value can be adjusted at any time with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-vdev-trim_on_init></a><code><em>vfs.zfs.vdev.trim_on_init</em></code> - Control whether new devices added to the pool have the <code>TRIM</code> command run on them. This ensures the best performance and longevity for SSDs, but takes extra time. If the device has already been secure erased, disabling this setting will make the addition of the new device faster. This value can be adjusted at any time with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-vdev-max_pending></a><code><em>vfs.zfs.vdev.max_pending</em></code> - Limit the number of pending I/O requests per device. A higher value will keep the device command queue full and may give higher throughput. A lower value will reduce latency. This value can be adjusted at any time with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-top_maxinflight></a><code><em>vfs.zfs.top_maxinflight</em></code> - Maxmimum number of outstanding I/Os per top-level <a href=#zfs-term-vdev>vdev</a>. Limits the depth of the command queue to prevent high latency. The limit is per top-level vdev, meaning the limit applies to each <a href=#zfs-term-vdev-mirror>mirror</a>, <a href=#zfs-term-vdev-raidz>RAID-Z</a>, or other vdev independently. This value can be adjusted at any time with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-l2arc_write_max></a><code><em>vfs.zfs.l2arc_write_max</em></code> - Limit the amount of data written to the <a href=#zfs-term-l2arc>L2ARC</a> per second. This tunable is designed to extend the longevity of SSDs by limiting the amount of data written to the device. This value can be adjusted at any time with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-l2arc_write_boost></a><code><em>vfs.zfs.l2arc_write_boost</em></code> - The value of this tunable is added to <a href=#zfs-advanced-tuning-l2arc_write_max><code>vfs.zfs.l2arc_write_max</code></a> and increases the write speed to the SSD until the first block is evicted from the <a href=#zfs-term-l2arc>L2ARC</a>. This "Turbo Warmup Phase" is designed to reduce the performance loss from an empty <a href=#zfs-term-l2arc>L2ARC</a> after a reboot. This value can be adjusted at any time with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-scrub_delay></a><code><em>vfs.zfs.scrub_delay</em></code> - Number of ticks to delay between each I/O during a <a href=#zfs-term-scrub><code>scrub</code></a>. To ensure that a <code>scrub</code> does not interfere with the normal operation of the pool, if any other I/O is happening the <code>scrub</code> will delay between each command. This value controls the limit on the total IOPS (I/Os Per Second) generated by the <code>scrub</code>. The granularity of the setting is determined by the value of <code>kern.hz</code> which defaults to 1000 ticks per second. This setting may be changed, resulting in a different effective IOPS limit. The default value is <code>4</code>, resulting in a limit of: 1000 ticks/sec / 4 = 250 IOPS. Using a value of <em>20</em> would give a limit of: 1000 ticks/sec / 20 = 50 IOPS. The speed of <code>scrub</code> is only limited when there has been recent activity on the pool, as determined by <a href=#zfs-advanced-tuning-scan_idle><code>vfs.zfs.scan_idle</code></a>. This value can be adjusted at any time with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-resilver_delay></a><code><em>vfs.zfs.resilver_delay</em></code> - Number of milliseconds of delay inserted between each I/O during a <a href=#zfs-term-resilver>resilver</a>. To ensure that a resilver does not interfere with the normal operation of the pool, if any other I/O is happening the resilver will delay between each command. This value controls the limit of total IOPS (I/Os Per Second) generated by the resilver. The granularity of the setting is determined by the value of <code>kern.hz</code> which defaults to 1000 ticks per second. This setting may be changed, resulting in a different effective IOPS limit. The default value is 2, resulting in a limit of: 1000 ticks/sec / 2 = 500 IOPS. Returning the pool to an <a href=#zfs-term-online>Online</a> state may be more important if another device failing could <a href=#zfs-term-faulted>Fault</a> the pool, causing data loss. A value of 0 will give the resilver operation the same priority as other operations, speeding the healing process. The speed of resilver is only limited when there has been other recent activity on the pool, as determined by <a href=#zfs-advanced-tuning-scan_idle><code>vfs.zfs.scan_idle</code></a>. This value can be adjusted at any time with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-scan_idle></a><code><em>vfs.zfs.scan_idle</em></code> - Number of milliseconds since the last operation before the pool is considered idle. When the pool is idle the rate limiting for <a href=#zfs-term-scrub><code>scrub</code></a> and <a href=#zfs-term-resilver>resilver</a> are disabled. This value can be adjusted at any time with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-txg-timeout></a><code><em>vfs.zfs.txg.timeout</em></code> - Maximum number of seconds between <a href=#zfs-term-txg>transaction group</a>s. The current transaction group will be written to the pool and a fresh transaction group started if this amount of time has elapsed since the previous transaction group. A transaction group my be triggered earlier if enough data is written. The default value is 5 seconds. A larger value may improve read performance by delaying asynchronous writes, but this may cause uneven performance when the transaction group is written. This value can be adjusted at any time with <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li></ul></div></div><div class=sect3><h4 id=zfs-advanced-i386>19.6.2. i386 上的 ZFS<a class=anchor href=#zfs-advanced-i386></a></h4><div class=paragraph><p>ZFS 所提供的部份功能需要使用大量記憶體，且可能需要對有限 RAM 的系統調校來取得最佳的效率。</p></div><div class=sect4><h5 id=_記憶體>19.6.2.1. 記憶體<a class=anchor href=#_記憶體></a></h5><div class=paragraph><p>最低需求，總系統記憶體應至少有 1 GB，建議的 RAM 量需視儲存池的大小以及使用的 ZFS 功能而定。一般的經驗法則是每 1 TB 的儲存空間需要 1 GB 的 RAM，若有開啟去重複的功能，一般的經驗法則是每 1 TB 的要做去重複的儲存空間需要 5 GB 的 RAM。雖然有部份使用者成功使用較少的 RAM 來運作 ZFS，但系統在負載較重時有可能會因為記憶用耗而導致當機，對於要使用低於建議 RAM 需求量來運作的系統可能會需要更進一步的調校。</p></div></div><div class=sect4><h5 id=_核心設定>19.6.2.2. 核心設定<a class=anchor href=#_核心設定></a></h5><div class=paragraph><p>由於在 i386™ 平台上位址空間的限制，在 i386™ 架構上的 ZFS 使用者必須加入這個選項到自訂核心設定檔，重新編譯核心並重新開啟：</p></div><div class="literalblock programlisting"><div class=content><pre>options        KVA_PAGES=512</pre></div></div><div class=paragraph><p>這個選項會增加核心位址空間，允許調整 <code>vm.kvm_size</code> 超出目前的 1 GB 限制或在 PAE 的 2 GB 限制。要找到這個選項最合適的數值，可以將想要的位址空間換算成 MB 然後除以 4，在本例中，以 2 GB 計算後即為 <code>512</code>。</p></div></div><div class=sect4><h5 id=_載入程式可調參數>19.6.2.3. 載入程式可調參數<a class=anchor href=#_載入程式可調參數></a></h5><div class=paragraph><p>在所有的 FreeBSD 架構上均可增加 <span class=filename>kmem</span> 位址空間，經測試在一個 1 GB 實體記憶體的測試系統上，加入以下選項到 <span class=filename>/boot/loader.conf</span>，重新開啟系統，可成功設定：</p></div><div class="literalblock programlisting"><div class=content><pre>vm.kmem_size=&#34;330M&#34;
vm.kmem_size_max=&#34;330M&#34;
vfs.zfs.arc_max=&#34;40M&#34;
vfs.zfs.vdev.cache.size=&#34;5M&#34;</pre></div></div><div class=paragraph><p>要取得更多詳細的 ZFS 相關調校的建議清單，請參考 <a href=https://wiki.freebsd.org/ZFSTuningGuide class=bare>https://wiki.freebsd.org/ZFSTuningGuide</a>。</p></div></div></div></div><div class=sect2><h3 id=zfs-links>19.7. 其他資源<a class=anchor href=#zfs-links></a></h3><div class=ulist><ul><li><p><a href=https://wiki.freebsd.org/ZFS>FreeBSD Wiki - ZFS</a></p></li><li><p><a href=https://wiki.freebsd.org/ZFSTuningGuide>FreeBSD Wiki - ZFS Tuning</a></p></li><li><p><a href=http://wiki.illumos.org/display/illumos/ZFS>Illumos Wiki - ZFS</a></p></li><li><p><a href=http://docs.oracle.com/cd/E19253-01/819-5461/index.html>Oracle Solaris ZFS Administration Guide</a></p></li><li><p><a href=https://calomel.org/zfs_raid_speed_capacity.html>Calomel Blog - ZFS Raidz Performance, Capacity and Integrity</a></p></li></ul></div></div><div class=sect2><h3 id=zfs-term>19.8. ZFS 特色與術語<a class=anchor href=#zfs-term></a></h3><div class=paragraph><p>ZFS 是一個從本質上與眾不同的檔案系統，由於它並非只是一個檔案系統，ZFS 結合了檔案系統及磁碟區管理程式，讓額外的儲存裝置可以即時的加入到系統並可讓既有的檔案系統立即使用這些在儲存池中空間。透過結合傳統區分為二的兩個角色，ZFS 能夠克服以往 RAID 磁碟群組無法擴充的限制。每個在儲存池頂層的裝置稱作 <em>vdev</em>，其可以是一個簡單的磁碟或是一個 RAID 如鏡像或 RAID-Z 陣列。ZFS 的檔案系統 (稱作 <em>資料集 (Dataset)</em>) 每一個資料集均可存取整個存池所共通的可用空間，隨著使用儲存池來配置空間區塊，儲存池能給每個檔案系統使用的可用空間就會減少，這個方法可以避免擴大分割區會使的可用空間分散分割區之間的常見問題。</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>儲存池 (Pool)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><em>儲存池 (Pool)</em> 是建構 ZFS 最基礎的單位。一個儲存池可由一個或多個 vdev 所組成，是用來儲存資料的底層裝置。儲存池會被拿來建立一個或多個檔案系統 (資料集 Dataset) 或區塊裝置 (磁碟區 Volume)，這些資料集與磁碟區會共用儲存池的剩餘可用空間。每一個儲存池可由名稱與 GUID 來辨識。可用的功能會依儲存池上的 ZFS 版本而有不同。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>vdev 型態 (vdev Types)</p></td><td class="tableblock halign-left valign-top"><div class=content><div class=paragraph><p>儲存池是由一個或多個 vdev 所組成，vdev 可以是一個磁碟或是 RAID Transform 的磁碟群組。當使用多個 vdev，ZFS 可以分散資料到各個 vdev 來增加效能與最大的可用空間。</p></div><div class=ulist><ul><li><p><em>磁碟 (Disk)</em> - 最基本的 vdev 型態便是一個標準的資料區塊裝置，這可以是一整個磁碟 (例如 <span class=filename>/dev/ada0</span> 或 <span class=filename>/dev/da0</span>) 或一個分割區 (<span class=filename>/dev/ada0p3</span>)。在 FreeBSD 上，使用分割區來替代整個磁碟不會影響效能，這可能與 Solaris 說明文件所建議的有所不同。</p></li><li><p><em>檔案 (File)</em> - 除了磁碟外，ZFS 儲存池可以使用一般檔案為基礎，這在測試與實驗時特別有用。在 <code>zpool create</code> 時使用檔案的完整路徑作為裝置路徑。所有 vdev 必須至少有 128 MB 的大小。</p></li><li><p><em>鏡像 (Mirror)</em> - 要建立鏡像，需使用 <code>mirror</code> 關鍵字，後面接著要做為該鏡像成員裝置的清單。一個鏡像需要由兩個或多個裝置來組成，所有的資料都會被寫入到所有的成員裝置。鏡像 vdev 可以對抗所有成員故障只剩其中一個而不損失任何資料。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>正常單一磁碟的 vdev 可以使用 <code>zpool <a href=#zfs-zpool-attach>attach</a></code> 隨時升級成為鏡像 vdev。</p></div></td></tr></tbody></table></div></li><li><p><em>RAID-Z</em> - ZFS 實作了 RAID-Z，以標準的 RAID-5 修改而來，可提供奇偶校驗 (Parity) 更佳的分散性並去除了 "RAID-5 write hole" 導致在預期之外的重啟後資料與奇偶校驗資訊不一致的問題。ZFS 支援三個層級的 RAID-Z，可提供不同程度的備援來換取減少不同程度的可用空間，類型的名稱以陣列中奇偶校驗裝置的數量與儲存池可以容許磁碟故障的數量來命名，從 RAID-Z1 到 RAID-Z3 。</p><div class=paragraph><p>在 RAID-Z1 配置 4 個磁碟，每個磁碟 1 TB，可用的儲存空間則為 3 TB，且若其中一個磁碟故障仍可以降級 (Degraded) 的模式運作，若在故障磁碟尚未更換並修復 (Resilver) 之前又有磁碟故障，所有在儲存池中的資料便會遺失。</p></div><div class=paragraph><p>在 RAID-Z3 配置 8 個 1 TB 的磁碟，磁碟區將會可以提供 5 TB 的可用空間且在 3 個磁碟故障的情況下仍可運作。Sun™ 建議單一個 vdev 不要使用超過 9 個磁碟。若配置需要使用更多磁碟，建議分成兩個 vdev，這樣儲存池的資料便會分散到這兩個 vdev。</p></div><div class=paragraph><p>使用兩個 RAID-Z2 各由 8 個磁碟組成的 vdev 的配置可以建立一個類似 RAID-60 的陣列。RAID-Z 群組的儲存空量會接近其中最小的磁碟乘上非奇偶校驗磁碟的數量。4 個 1 TB 磁碟在 RAID-Z1 會有接近 3 TB 的實際大小，且一個由 8 個 1 TB 磁碟組成的 RAID-Z3 陣列會有 5 TB 的可用空間。</p></div></li><li><p><em>備援 (Spare)</em> - ZFS 有特殊的虛擬 vdev 型態可用來持續追蹤可用的熱備援裝置 (Hot spare)。注意，安裝的熱備援裝置並不會自動佈署，熱備援裝置需要手動使用 <code>zfs replace</code> 設定替換故障的裝置。</p></li><li><p><em>日誌 (Log)</em> - ZFS 記錄裝置，也被稱作 ZFS 意圖日誌 (ZFS Intent Log, <a href=#zfs-term-zil>ZIL</a>) 會從正常的儲存池裝置移動意圖日誌到獨立的裝置上，通常是一個 SSD。有了獨立的日誌裝置，可以明顯的增進有大量同步寫入應用程式的效能，特別是資料庫。日誌裝置可以做成鏡像，但不支援 RAID-Z，若使用多個日誌裝置，寫入動作會被負載平衡分散到這些裝置。</p></li><li><p><em>快取 (Cache)</em> - 加入快取 vdev 到儲存池可以增加儲存空間的 <a href=#zfs-term-l2arc>L2ARC</a> 快取。快取裝置無法做鏡像，因快取裝置只會儲存額外的現有資料的複本，並沒有資料遺失的風險。</p></li></ul></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>交易群組 (Transaction Group, TXG)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>交易群組是一種將更動的資料區塊包裝成一組的方式，最後再一次寫入到儲存池。交易群組是 ZFS 用來檢驗一致性的基本單位。每個交易群組會被分配一個獨一無二的 64-bit 連續代號。最多一次可以有三個活動中的交易群組，這三個交易群組的每一個都有這三種狀態：</p><p class=tableblock>* <em>開放 (Open)</em> - 新的交易群組建立之後便處於開放的狀態，可以接受新的寫入動作。永遠會有開放狀態的交易群組，即始交易群組可能會因到達上限而拒絕新的寫入動作。一但開放的交易群組到達上限或到達 <a href=#zfs-advanced-tuning-txg-timeout><code>vfs.zfs.txg.timeout</code></a>，交易群組便會繼續進入下一個狀態。
* <em>靜置中 (Quiescing)</em> - 一個短暫的狀態，會等候任何未完成的操作完成，不會阻擋新開放的交易群組建立。一旦所有在群組中的交易完成，交易群組便會進入到最終狀態。
* <em>同步中 (Syncing)</em> - 所有在交易群組中的資料會被寫任到穩定的儲存空間，這個程序會依序修改其他也需同樣寫入到穩定儲存空間的資料，如 Metadata 與空間對應表。同步的程多會牽涉多個循環，首先是同步所有更改的資料區塊，也是最大的部份，接著是 Metadata，這可能會需要多個循環來完成。由於要配置空間供資料區塊使用會產生新的 Metadata，同步中狀態在到達循環完成而不再需要分配任何額外空間的狀態前無法結束。同步中狀態也是完成 <em>synctask</em> 的地方，Synctask 是指管理操作，如：建立或摧毀快照與資料集，會修改 uberblock，也會在此時完成。同步狀態完成後，其他處於狀態中狀態的交易群組便會進入同步中狀態。
所有管理功能如快照 (<a href=#zfs-term-snapshot><code>Snapshot</code></a>) 會作為交易群組的一部份寫入。當 synctask 建立之後，便會加入到目前開放的交易群組中，然後該群組會盡快的進入同步中狀態來減少管理指令的延遲。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Adaptive Replacement Cache (ARC)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ZFS 使用了自適應替換快取 (Adaptive Replacement Cache, ARC)，而不是傳統的最近最少使用 (Least Recently Used, LRU) 快取，LRU 快取在快取中是一個簡單的項目清單，會依每個物件最近使用的時間來排序，新項會加入到清單的最上方，當快取額滿了便會去除清單最下方的項目來空出空間給較常使用的物件。ARC 結合了四種快取清單，最近最常使用 (Most Recently Used, MRU) 及最常使用 (Most Frequently Used, MFU) 物件加上兩個清單各自的幽靈清單 (Ghost list)，這些幽靈清單會追蹤最近被去除的物件來避免又被加回到快取，避免過去只有偶爾被使用的物件加入清單可以增加快取的命中率。同時使用 MRU 及 MFU 的另外一個優點是掃描一個完整檔案系統可以去除在 MRU 或 LRU 快取中的所有資料，有利於這些才剛存取的內容。使用 ZFS 也有 MFU 可只追蹤最常使用的物件並保留最常被存取的資料區塊快取。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L2ARC</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L2ARC 是 ZFS 快取系統的第二層，主要的 ARC 會儲存在 RAM 當中，但因為 RAM 可用的空間量通常有限，因此 ZFS 也可以使用 <a href=#zfs-term-vdev-cache>快取 vdev (Cache vdev)</a>。固態磁碟 (Solid State Disk, SSD) 常被拿來此處作為快取裝置，因為比起傳統旋轉碟片的磁碟，固態磁碟有較快的速度與較低的延遲。L2ARC 是選用的，但使用可以明顯增進那些已使用 SSD 快取的檔案讀取速度，無須從一般磁碟讀取。L2ARC 也同樣可以加速去重複 (<a href=#zfs-term-deduplication>Deduplication</a>)，因為 DDT 並不適合放在 RAM，但適合放在 L2ARC，比起要從磁碟讀取，可以加快不少速度。為了避免 SSD 因寫入次速過多而過早耗損，加入到快取裝置的資料速率會被限制，直到快取用盡 (去除第一個資料區塊來騰出空間) 之前，寫入到 L2ARC 的資料速率會限制在寫入限制 (Write limit) 與加速限制 (Boost limit) 的總合，之後則會限制為寫入限制，可以控制這兩個速度限制的 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 數值分別為 <a href=#zfs-advanced-tuning-l2arc_write_max><code>vfs.zfs.l2arc_write_max</code></a> 控制每秒有多少數位元組可寫入到快取，而 <a href=#zfs-advanced-tuning-l2arc_write_boost><code>vfs.zfs.l2arc_write_boost</code></a> 可在 "渦輪預熱階段" (即寫入加速) 時增加寫入限制。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ZIL</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ZIL 會使用比主要儲存池還更快的儲存裝置來加速同步寫入動作 (Synchronous transaction)，如 SSD。當應用程式請求做一個同步的寫入時 (保証資料會安全的儲存到磁碟，而不是先快取稍後再寫入)，資料會先寫入到速度較快的 ZIL 儲存空間，之後再一併寫入到一般的磁碟。這可大量的減少延遲並增進效能。ZIL 只會有利於使用像資料庫這類的同步工作，一般非同步的寫入像複製檔案，則完全不會用到 ZIL。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>寫入時複製 (Copy-On-Write)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>不像傳統的檔案系統，在 ZFS，當資料要被覆寫時，不會直接覆寫舊資料所在的位置，而是將新資料會寫入到另一個資料區塊，只在資料寫入完成後才會更新 Metadata 指向新的位置。因此，在發生寫入中斷 (在寫入檔案的過程中系統當機或電源中斷) 時，原來檔案的完整內容並不會遺失，只會放棄未寫入完成的新資料，這也意謂著 ZFS 在發生預期之外的關機後不需要做 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>資料集 (Dataset)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><em>資料集 (Dataset)</em> 是 ZFS 檔案系統、磁碟區、快照或複本的通用術語。每個資料集都有獨一無二的名稱使用 <em>poolname/path@snapshot</em> 格式。儲存池的根部技術上來說也算一個資料集，子資料集會採用像目錄一樣的層級來命名，例如 <em>mypool/home</em>，home 資料集是 <em>mypool</em> 的子資料集並且會繼承其屬性。這可以在往後繼續擴展成 <em>mypool/home/user</em>，這個孫資料集會繼承其父及祖父的屬性。在子資料集的屬性可以覆蓋預設繼承自父及祖父的屬性。資料集及其子資料級的管理權限可以委託 (<a href=#zfs-zfs-allow>Delegate</a>) 給他人。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>檔案系統 (File system)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ZFS 資料集最常被當做檔案系統使用。如同大多數其他的檔案系統，ZFS 檔案系統會被掛載在系統目錄層級的某一處且內含各自擁有權限、旗標及 Metadata 的檔案與目錄。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>磁碟區 (Volume)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>除了一般的檔案系統資料集之外，ZFS 也可以建立磁碟區 (Volume)，磁碟區是資料區塊裝置。磁碟區有許多與資料集相似的功能，包含複製時寫入、快照、複本以及資料校驗。要在 ZFS 的頂層執行其他檔案系統格式時使用磁碟區非常有用，例如 UFS 虛擬化或匯出 iSCSI 延伸磁區 (Extent)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>快照 (Snapshot)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ZFS 的寫入時複製 (<a href=#zfs-term-cow>Copy-On-Write</a>, COW) 設計可以使用任意的名稱做到幾乎即時、一致的快照。在製做資料集的快照或父資料集遞迴快照 (會包含其所有子資料集) 之後，新的資料會寫入到資的資料區塊，但不會回收舊的資料區塊為可用空間，快照中會使用原版本的檔案系統，而快照之後所做的變更則會儲存在目前的檔案系統，因此不會重複使用額外的空間。當新的資料寫入到目前的檔案系統，便會配置新的資料區塊來儲存這些資料。快照表面大小 (Apparent size) 會隨著在目前檔案系統停止使用的資料區塊而成長，但僅限於快照。可以用唯讀的方式掛載這些快照來復原先前版本的檔案，也可以還原 (<a href=#zfs-zfs-snapshot>Rollback</a>) 目前的檔案系統到指定的快照，來還原任何在快照之後所做的變更。每個在儲存池中的資料區塊都會有一個參考記數器，可以用來持續追蹤有多少快照、複本、資料集或是磁碟區使用這個資料區塊，當刪除檔案與快照參照的計數變會滅少，直到沒有任何東西參考這個資料區塊才會被回收為可用空間。快照也可使用 <a href=#zfs-zfs-snapshot>hold</a> 來標記，檔標記為 hold 時，任何嘗試要刪除該快照的動作便會回傳 <code>EBUSY</code> 的錯誤，每個快照可以標記多個不同唯一名稱的 hold，而 <a href=#zfs-zfs-snapshot>release</a> 指令則可以移除 hold，這樣才可刪除快照。在磁碟區上快可以製作快照，但只能用來複製或還原，無法獨立掛載。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>複本 (Clone)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>快照也可以做複本，複本是可寫入版本的快照，讓檔案系統可分支成為新的資料集。如同快照，複本一開始不會消耗任何額外空間，隨著新資料寫入到複本會配置新的資料區塊，複本的表面大小 (Apparent size) 才會成長，當在複本檔案系統或磁碟區的資料區塊被覆寫時，在先前資料區塊的參考計數則會減少。建立複本所使用的快照無法被刪除，因為複本會相依該快照，快照為父，複本為子。複本可以被提升 (<em>promoted</em>)、反轉相依關係，來讓複本成為父，之前的父變為子，這個操作不需要額外的空間。由於反轉了父與子使用的空間量，所以可能會影響既有的配額 (Quota) 與保留空間 (Reservation)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>校驗碼 (Checksum)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>配置每個資料區塊快的同時也會做資料校驗，資料校驗用的演算法是依資料集屬性而有所不同的，請參考 <a href=#zfs-zfs-set><code>set</code></a>。每個資料區塊會在讀取的過成便完成校驗，讓 ZFS 可以偵測到隱藏的損壞，若資料不符合預期的校驗碼，ZFS 會嘗試從任何可用的備援來還原資料，例如鏡像 (Mirror) 或 RAID-Z。要檢驗所有資料的校驗碼可以使用清潔 (<a href=#zfs-term-scrub><code>Scrub</code></a>)，資料校驗的演算法有：</p><p class=tableblock>* <code>fletcher2</code>
* <code>fletcher4</code>
* <code>sha256</code>
<code>fletcher</code> 演算法最快，而 <code>sha256</code> 雖較消耗效能，但其有強大的密碼雜湊與較低的衝突率。也可關閉資料校驗，但並不建議。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>壓縮 (Compression)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>每個資料集都有壓縮 (Compression) 屬性，預設是關閉的，這個屬性可以設定使用以下幾個壓縮演算法的其中一個來壓縮寫入到資料集的新資料。壓縮除了減少空間使用量外，常也會增加讀取與寫入的吞吐量，因為會減少讀取與寫入的資料區塊。</p><p class=tableblock><a id=zfs-term-compression-lz4></a>* <em>LZ4</em> - ZFS 儲存池版本 5000 (功能旗標) 後所增加，LZ4 現在是建議的壓縮演算法，在處理可壓縮的資料時 LZ4 壓縮比 LZJB 快將近 50%，在處理不可壓縮的資料時快將近三倍，LZ4 解壓縮也比 LZJB 將近 80%。在現代的 CPU 上，LZ4 經常平均可用 500 MB/s 的速度壓縮，而解壓縮可到達 1.5 GB/s (每個 CPU 核心)。</p><p class=tableblock><a id=zfs-term-compression-lzjb></a>* <em>LZJB</em> - 預設的壓縮演算法。由 Jeff Bonwick 所開發 (ZFS 的創始人之一)。LZJB 與 GZIP 相比，可以較低的 CPU 提供較佳的壓縮功能。在未來預設的壓縮演算法將會更換為 LZ4。</p><p class=tableblock><a id=zfs-term-compression-gzip></a>* <em>GZIP</em> - 在 ZFS 可用的熱門串流壓縮演算法。使用 GZIP 主要的優點之一便是可設定壓縮層級。當設定 <code>compress</code> 屬性，管理者可以選擇壓縮層級範圍從最低的壓縮層級 <code>gzip1</code> 到最高的壓縮層級 <code>gzip9</code>。這讓管理者可以控制要使用多少 CPU 來節省磁碟空間。</p><p class=tableblock><a id=zfs-term-compression-zle></a>* <em>ZLE</em> - 零長度編號是一個特殊的壓縮演算法，它只會壓縮連續的零。這種壓縮演算法只在資料集中含有大量為零的資料區塊時有用。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>備份數 (Copies)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>當設定大於 1 的數值時，<code>copies</code> 屬性會指示 ZFS 備份每個在檔案系統 (<a href=#zfs-term-filesystem>File System</a>) 或磁碟區 (<a href=#zfs-term-volume>Volume</a>) 的資料區塊數份。在重要的資料集上設定這個屬性可以做額外的備援以在資料校驗碼不相符時可做復原。在沒有做備援的儲存池上，備份功能提供只是一種資料的備援方式，備份功能可以復原單一壞軌或其他情況的次要損壞，但無法復原儲存池中整個磁碟損壞所損失的資料。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>去重複 (Deduplication)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>校驗碼讓在寫入時可以偵測重複資料區塊，使用去重複，可以增加既有、完全相同的資料區塊參考數來節省儲存空間。要偵測重複的資料區塊需要在記憶體中儲存去重複資料表 (Deduplication table, DDT)，這個資料表中會有唯一的校驗碼清單、這些資料區塊的所在位置以及參考數。當寫入新資料時，便會計算校驗碼然後比對清單中是否有符合的既有資料區塊已在清單。去重複使用了 SHA256 校驗碼演算法來提供一個安全的加密雜湊，去重複功能是可以調校的，若 <code>dedup</code> 設為 <code>on</code> 只要符合校驗碼便會認為資料完全相同，若 <code>dedup</code> 設為 <code>verify</code> 則會一個一個位元檢查兩個資料區塊的資料來確保資料真的完全相同，若資料不同便會註記與雜湊衝突並會分別儲存兩個資料區塊。由於 DDT 須要儲存每個唯一資料區塊的雜湊，所以會消耗大量的記憶體，一般的經驗法則是每 1 TB 的去重複資料需要使用 5-6 GB 的記憶體。由於要有足夠的 RAM 來儲存整個 DDT 在實務上並不實際，導致在每個新資料區塊寫入前需要從磁碟來讀取 DDT 會對效能有很大的影響，去重複功能可以使用 L2ARC 儲存 DDT 以在快速的系統記憶體及較慢的磁碟之間取得一個平衡點。也可以考慮使用壓縮功能來取代此功能，因為壓縮也能節省相近的空間使用量而不需要大量額外的記憶體。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>清潔 (Scrub)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ZFS 有 <code>scrub</code> 來替代 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 來做一致性的檢查。<code>scrub</code> 會讀取所有儲存在儲存池中的資料區塊並且根據儲存在 Metadata 中已知良好的校驗碼來檢驗這些資料區塊的校驗碼，定期檢查儲存池中儲存的所有資料可以確保實際使用這些資料前已將所有損壞的資料區塊復原。在不正常的關閉之後並不需要做清潔動作，但建議每三個月至少執行一次。在正常使用讀取時便會檢查每個資料區塊的校驗碼，但清潔動作可以確保那些不常用的資料也會被檢查以避免隱藏的損壞，如此便能增進資料的安全性，特別是對用來保存資料的儲存裝置。<code>scrub</code> 可以使用 <a href=#zfs-advanced-tuning-scrub_delay><code>vfs.zfs.scrub_delay</code></a> 調整相對優先權來避免清潔動作降低儲存池上其他工作的效率。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>資料集配額 (Dataset Quota)</p></td><td class="tableblock halign-left valign-top"><div class=content><div class=paragraph><p>除了配額及空間保留外，ZFS 提供非常快速且準確的資料集、使用者及群組空間的計算功能，這可讓管理者調整空間配置的方式且可為重要的檔案系統保留空間。</p></div><div class=paragraph><p>ZFS supports different types of quotas: the dataset quota, the <a href=#zfs-term-refquota>reference quota (refquota)</a>, the <a href=#zfs-term-userquota>user quota</a>, and the <a href=#zfs-term-groupquota>group quota</a>.</p></div><div class=paragraph><p>配額會限制資料集及後裔包含資料集的快照、子資料集及子資料集的快照能使用的空間量。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>磁碟區上無法設定配額，因為 <code>volsize</code> 屬性已經被用來做內定的配額。</p></div></td></tr></tbody></table></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>參考配額 (Reference Quota)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>參考配額可以設定一個硬性限制 (Hard limit) 來限制資料集能使用的空間量，而這個硬性限制只包含了資料集參考的空間，並不含其後裔所使用的空間，如：檔案系統或快照。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>使用者配額 (User Quota)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>使用者配額在用來限制特定使用者能使用的空間量時非常有用。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>群組配額 (Group Quota)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>群組配額可以限制特定群組能使用的空間量。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>資料集保留空間 (Dataset Reservation)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>reservation</code> 屬性可以確保對特定資料集及其後裔最小可用的空間量，若在 <span class=filename>storage/home/bob</span> 設定 10 GB 的保留空間且其他資料集嘗試使用所有剩餘的空間時，會保留至少 10 GB 的空間供這個資料集使用。若要製作 <span class=filename>storage/home/bob</span> 的快照，該快照所使用的空間也會被列入保留空間計算。 <a href=#zfs-term-refreservation><code>refreservation</code></a> 屬性也以類似的方式運作，但是他 <em>不包含</em> 後裔，例如：快照。</p><p class=tableblock>不管那一種保留空間在許多情境皆很有用，例如：要規劃與測試磁碟空間配置在新系統上的適應性，或是確保有足夠的空間供稽查日誌或系統還原程序及檔案使用。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>參考保留空間 (Reference Reservation)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>refreservation</code> 屬性可以確保對特定資料集 <em>不包含</em> 其後裔最小可用的空間，這代表若在 <span class=filename>storage/home/bob</span> 設定 10 GB 的保留空間且其他資料集嘗試使用所有剩餘的空間時，會保留至少 10 GB 的空間供這個資料集使用。於正常 <a href=#zfs-term-reservation>reservation</a> 不同的是，由快照及後裔資料集所使用的空間並不會列入保留空間計算。例如，若要製作一個 <span class=filename>storage/home/bob</span> 的快照，在 <code>refreservation</code> 空間之外必須要有足夠的空間才能成功完成這項操作，主資料集的後裔並不會列入 <code>refreservation</code> 空間額計算，所以也不會佔用保留空間。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>修復 (Resilver)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>當有磁碟故障且被更換後，新的磁碟必須回存先前所遺失的資料，會使用分散在其他磁碟上的奇偶校驗資訊來計算並寫入遺失的資料到新的磁碟機的這個程序稱作 <em>修復 (Resilvering)</em>。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>上線 (Online)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>一個儲存池或 vdev 處於線上 (<code>Online</code>) 狀態時代表所有該裝置的成員均已連結且正常運作。個別裝置處於線上 (<code>Online</code>) 狀態時代表功能正常。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>離線 (Offline)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>若有足夠的備援可避免儲存池或 vdev 進入故障 (<a href=#zfs-term-faulted>Faulted</a>) 狀態，個別裝置若可由管理者設為離線 (<code>Offline</code>) 狀態，管理者可以選擇要設定那一個磁碟為離線來準備更換或是讓其更容易辨識。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>降級 (Degraded)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>一個儲存池或 vdev 處於降級 (<code>Degraded</code>) 狀態代表其有一個或多個磁碟已斷線或故障，此時儲存池仍可以使用，但只要再有其他的裝置故障，儲存池會無法復原。重新連線缺少的裝置或更換故障的磁碟，並在新裝置完成修復 (<a href=#zfs-term-resilver>Resilver</a>) 程序可讓儲存池返回線上 (<a href=#zfs-term-online>Online</a>) 狀態。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>故障 (Faulted)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>一個儲存池或 vdev 處於故障 (<code>Faulted</code>) 狀態代表無法運作，會無法存取在該裝置上的資料。當在 vdev 中缺少或故障的裝置數超過備援的層級，儲存池或 vdev 會進入故障 (<code>Faulted</code>) 狀態。若缺少的裝置可以重新連結上，儲存池便會返回線上 (<a href=#zfs-term-online>Online</a>) 狀態。若沒有足夠的備援可補償故障的磁碟數量便會遺失儲存池中的內容且只能從備份還原。</p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=filesystems>Chapter 20. 其他檔案系統<a class=anchor href=#filesystems></a></h2><div class=sectionbody><div class=sect2><h3 id=filesystems-synopsis>20.1. 概述<a class=anchor href=#filesystems-synopsis></a></h3><div class=paragraph><p>File systems are an integral part of any operating system. They allow users to upload and store files, provide access to data, and make hard drives useful. Different operating systems differ in their native file system. Traditionally, the native FreeBSD file system has been the Unix File System UFS which has been modernized as UFS2. Since FreeBSD 7.0, the Z File System (ZFS) is also available as a native file system. See <a href=./#zfs>Z 檔案系統 (ZFS)</a> for more information.</p></div><div class=paragraph><p>In addition to its native file systems, FreeBSD supports a multitude of other file systems so that data from other operating systems can be accessed locally, such as data stored on locally attached USB storage devices, flash drives, and hard disks. This includes support for the Linux™ Extended File System (EXT).</p></div><div class=paragraph><p>There are different levels of FreeBSD support for the various file systems. Some require a kernel module to be loaded and others may require a toolset to be installed. Some non-native file system support is full read-write while others are read-only.</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>The difference between native and supported file systems.</p></li><li><p>Which file systems are supported by FreeBSD.</p></li><li><p>How to enable, configure, access, and make use of non-native file systems.</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>Understand UNIX™ and <a href=./#basics>FreeBSD basics</a>.</p></li><li><p>Be familiar with the basics of <a href=./#kernelconfig>kernel configuration and compilation</a>.</p></li><li><p>Feel comfortable <a href=./#ports>installing software</a> in FreeBSD.</p></li><li><p>Have some familiarity with <a href=./#disks>disks</a>, storage, and device names in FreeBSD.</p></li></ul></div></div><div class=sect2><h3 id=filesystems-linux>20.2. Linux™ 檔案系統<a class=anchor href=#filesystems-linux></a></h3><div class=paragraph><p>FreeBSD provides built-in support for several Linux™ file systems. This section demonstrates how to load support for and how to mount the supported Linux™ file systems.</p></div><div class=sect3><h4 id=_ext2>20.2.1. ext2<a class=anchor href=#_ext2></a></h4><div class=paragraph><p>Kernel support for ext2 file systems has been available since FreeBSD 2.2. In FreeBSD 8.x and earlier, the code is licensed under the GPL. Since FreeBSD 9.0, the code has been rewritten and is now BSD licensed.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> driver allows the FreeBSD kernel to both read and write to ext2 file systems.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This driver can also be used to access ext3 and ext4 file systems. The <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> filesystem has full read and write support for ext4 as of FreeBSD 12.0-RELEASE. Additionally, extended attributes and ACLs are also supported, while journalling and encryption are not. Starting with FreeBSD 12.1-RELEASE, a DTrace provider will be available as well. Prior versions of FreeBSD can access ext4 in read and write mode using <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/fusefs-ext2/>sysutils/fusefs-ext2</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To access an ext file system, first load the kernel loadable module:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ext2fs</span></code></pre></div></div><div class=paragraph><p>Then, mount the ext volume by specifying its FreeBSD partition name and an existing mount point. This example mounts <span class=filename>/dev/ad1s1</span> on <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t ext2fs /dev/ad1s1 /mnt</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=virtualization>Chapter 21. 虛擬化<a class=anchor href=#virtualization></a></h2><div class=sectionbody><div class=sect2><h3 id=virtualization-synopsis>21.1. 概述<a class=anchor href=#virtualization-synopsis></a></h3><div class=paragraph><p>虛擬化軟體可以讓同一台機器得以同時執行多種作業系統。在 PC 上的這類軟體系統通常涉及的角色有執行虛擬化軟體的主端 (Host) 作業系統以及數個安裝在其中的客端 (Guest) 作業系統。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>主端作業系統及客端作業系統的差別。</p></li><li><p>如何在 Intel™-based Apple™Mac™ 電腦安裝 FreeBSD 。</p></li><li><p>如何在 Microsoft™ Windows™ 使用 Virtual PC 安裝 FreeBSD。</p></li><li><p>如何以 FreeBSD 作為客端安裝在 bhyve。</p></li><li><p>如何調校 FreeBSD 系統來取得虛擬化的最佳效能。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解<a href=./#basics>UNIX™ 與 FreeBSD 的基礎</a>。</p></li><li><p>知道如何<a href=./#bsdinstall>安裝 FreeBSD</a>。</p></li><li><p>知道如何<a href=./#advanced-networking>設定網路連線</a>。</p></li><li><p>知道如何<a href=./#ports>安裝其他第三方軟體</a>。</p></li></ul></div></div><div class=sect2><h3 id=virtualization-guest-parallels>21.2. 在 Mac OS™ X 的 Parallels 安裝 FreeBSD 為客端<a class=anchor href=#virtualization-guest-parallels></a></h3><div class=paragraph><p>Mac™ 的 Parallels Desktop 是一套商業軟體可在 Intel™ 為基礎的 Apple™Mac™ 的 Mac OS™ 10.4.6 或更新版本上執行。 該軟體完全支援使用 FreeBSD 作為客端作業系統。 在 Mac OS™ X 裝好 Parallels 後，使用者必先完成虛擬機器的設定後才可安裝想使用的客端作業系統。</p></div><div class=sect3><h4 id=virtualization-guest-parallels-install>21.2.1. 在 Parallels/Mac OS™ X 安裝 FreeBSD<a class=anchor href=#virtualization-guest-parallels-install></a></h4><div class=paragraph><p>在 Parallels 上安裝 FreeBSD 的第一步是建立供安裝 FreeBSD 使用的新虛擬機器。提示出現後請選擇 <b class=menuref>Guest OS Type</b> 為 <span class=guimenuitem>FreeBSD</span>：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd1.png alt="parallels freebsd1"></div></div><div class=paragraph><p>根據您對此虛擬 FreeBSD 作業系統的規畫選擇合理的磁碟及記憶體空間，對大多數在 Parallels 下的 FreeBSD 使用來講 4GB 的磁碟空間與 512MB 的 RAM 便足夠：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd2.png alt="parallels freebsd2"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd3.png alt="parallels freebsd3"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd4.png alt="parallels freebsd4"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd5.png alt="parallels freebsd5"></div></div><div class=paragraph><p>選擇網路類型以及網路介面：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd6.png alt="parallels freebsd6"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd7.png alt="parallels freebsd7"></div></div><div class=paragraph><p>儲存並完成設定：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd8.png alt="parallels freebsd8"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd9.png alt="parallels freebsd9"></div></div><div class=paragraph><p>在 FreeBSD 虛擬機器新增後，就可以繼續以其安裝 FreeBSD。 安裝方面，比較好的作法是使用官方的 FreeBSD CD/DVD 或者是自官方 FTP 站下載的 ISO 映像檔。 複製適合的 ISO 映像檔到 Mac™ 檔案系統本地端或放入 CD/DVD 到 Mac™ 的 CD-ROM 磁碟機。在 FreeBSD Parallels 視窗的右下角點選磁碟圖示後會出現一個視窗，可用來建立虛擬機器內的 CD-ROM 磁碟機與磁碟上 ISO 檔案或實際 CD-ROM 磁碟機的關聯。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd11.png alt="parallels freebsd11"></div></div><div class=paragraph><p>建立與 CD-ROM 來源的關聯後，點選重新開機圖示重新開啟 FreeBSD 虛擬機器。Parallels 會重新開機進入一個特殊的 BIOS 畫面並檢查是否有 CD-ROM。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd10.png alt="parallels freebsd10"></div></div><div class=paragraph><p>在此處會找到 FreeBSD 安裝媒體並開始正常的 FreeBSD 安裝程序。完成安裝，但不要在此時嘗試設定 Xorg。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd12.png alt="parallels freebsd12"></div></div><div class=paragraph><p>當安裝完成後，重新開機將會進入新安裝的 FreeBSD 虛擬機器。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd13.png alt="parallels freebsd13"></div></div></div><div class=sect3><h4 id=virtualization-guest-parallels-configure>21.2.2. 在 Parallels 設定 FreeBSD<a class=anchor href=#virtualization-guest-parallels-configure></a></h4><div class=paragraph><p>在成功將 FreeBSD 安裝到 Mac OS™ X 的 Parallels 後，有數個設定步驟要完成來最佳化系統在虛擬機器上的運作。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>設定 Boot Loader 變數</p><div class=paragraph><p>最重要的一個步驟是減少 <code>kern.hz</code> 參數來減少 FreeBSD 在 Parallels 環境下對 CPU 的使用率。加入以下行到 <span class=filename>/boot/loader.conf</span> 來完成這個動作：</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>若沒有完成此設定，閒置的 FreeBSD Parallels 客端將會消耗掉單一處理器的 iMac™ 將近 15% 的 CPU。完成此更改後使用率會減至接近 5%。</p></div></li><li><p>建立新核心設定檔</p><div class=paragraph><p>所有的 SCSI, FireWire 及 USB 裝置可以從自訂的核心設定檔中移除。Parallels 提供的虛擬網路卡使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> 驅動程式，所以除了 <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> 外的所有網路裝置可以自核心中移除。</p></div></li><li><p>設定網路</p><div class=paragraph><p>最基本的網路設定是使用 DHCP 來讓虛擬機器連線到與主端 Mac™ 相同的區域網路，這可以透過加入 <code>ifconfig_ed0="DHCP"</code> 到 <span class=filename>/etc/rc.conf</span> 來完成。更進階的網路設定在 <a href=./#advanced-networking>進階網路設定</a> 中描述。</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=virtualization-guest-virtualpc>21.3. 在 Windows™ 的 Virtual PC 安裝 FreeBSD 為客端<a class=anchor href=#virtualization-guest-virtualpc></a></h3><div class=paragraph><p>給 Windows™ 使用的 Virtual PC 是一套可免費下載的 Microsoft™ 軟體產品，請參考此網站取得<a href=http://www.microsoft.com/windows/downloads/virtualpc/sysreq.mspx>系統需求</a>。Virtual PC 在 Microsoft™ Windows™ 上安裝完成之後，使用者可以設定一台虛擬機器然後安裝想要的客端作業系統。</p></div><div class=sect3><h4 id=virtualization-guest-virtualpc-install>21.3.1. 在 Virtual PC 安裝 FreeBSD<a class=anchor href=#virtualization-guest-virtualpc-install></a></h4><div class=paragraph><p>安裝 FreeBSD 到 Virtual PC 的第一個步驟是建立新的虛擬機器來安裝 FreeBSD。當提示畫面出現時，請選擇 <span class=guimenuitem>Create a virtual machine</span>：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd1.png alt="virtualpc freebsd1"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd2.png alt="virtualpc freebsd2"></div></div><div class=paragraph><p>當提示畫面出現時，選擇 <span class=guimenuitem>Operating system</span> 為 <span class=guimenuitem>Other</span>：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd3.png alt="virtualpc freebsd3"></div></div><div class=paragraph><p>然後，根據您對此虛擬 FreeBSD 作業系統的規畫選擇合理的磁碟及記憶體空間，對大多數在 Virtual PC 下的 FreeBSD 使用來講 4GB 的磁碟空間與 512MB 的 RAM 便足夠：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd4.png alt="virtualpc freebsd4"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd5.png alt="virtualpc freebsd5"></div></div><div class=paragraph><p>儲存並完成設定：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd6.png alt="virtualpc freebsd6"></div></div><div class=paragraph><p>選擇 FreeBSD 虛擬機器然後點選 <b class=menuref>Settings</b>，接著設定網路類型及網路介面卡：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd7.png alt="virtualpc freebsd7"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd8.png alt="virtualpc freebsd8"></div></div><div class=paragraph><p>FreeBSD 虛擬機器建立完成之後，便可安裝 FreeBSD 到該虛擬機器。安裝最好使用官方 FreeBSD CD/DVD 或使用自官方 FTP 站下載的 ISO 映像檔。複製適當的 ISO 映像檔到本地 Windows™ 檔案系統或插入 CD/DVD 到 CD 磁碟機，然後雙擊點選 FreeBSD 虛擬機器來開機。接著，點選 <b class=menuref>CD</b> 並在 Virtual PC 視窗選擇 <b class=menuref>Capture ISO Image…​</b>，這將會顯示一個視窗可以建立虛擬機器中的 CD-ROM 與 ISO 檔或磁碟或實體 CD-ROM 磁碟機之間的關聯。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd9.png alt="virtualpc freebsd9"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd10.png alt="virtualpc freebsd10"></div></div><div class=paragraph><p>建立與 CD-ROM 來源的關聯後，點選 <b class=menuref>Action</b> 及 <b class=menuref>Reset</b> 重新開機 FreeBSD 虛擬機器。Virtual PC 會重新開始並進入特殊的 BIOS 來做 CD-ROM 的第一次檢查。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd11.png alt="virtualpc freebsd11"></div></div><div class=paragraph><p>在這個情況下會找到 FreeBSD 安裝媒體然後開始正常的 FreeBSD 安裝。接著繼續安裝，但此時請不要嘗試設定 Xorg。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd12.png alt="virtualpc freebsd12"></div></div><div class=paragraph><p>當安裝完成之後，記得退出 CD/DVD 或釋放 ISO 映像檔。最後，重新開機進入新安裝的 FreeBSD 虛擬機器。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd13.png alt="virtualpc freebsd13"></div></div></div><div class=sect3><h4 id=virtualization-guest-virtualpc-configure>21.3.2. 在 Virtual PC 設定 FreeBSD<a class=anchor href=#virtualization-guest-virtualpc-configure></a></h4><div class=paragraph><p>在成功將 FreeBSD 安裝到 Microsoft™ Windows™ 的 Virtual PC 後，有數個設定步驟要完成來最佳化系統在虛擬機器上的運作。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>設定 Boot Loader 變數</p><div class=paragraph><p>最重要的一個步驟是減少 <code>kern.hz</code>，來減少 FreeBSD 在 Virtual PC 環境下 CPU 的使用量。這可以透過加入下列幾行到 <span class=filename>/boot/loader.conf</span> 來完成：</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>若沒有完成此設定，閒置的 FreeBSD Virtual PC 客端 OS 會消耗掉單一處理器的電腦 40% 的 CPU。完成此更改後使用率會減至接近 3%。</p></div></li><li><p>建立新核心設定檔</p><div class=paragraph><p>所有的 SCSI, FireWire 及 USB 裝置可以從自訂的核心設定檔中移除。Virtual PC 提供的虛擬網路卡使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=de&amp;sektion=4&amp;format=html">de(4)</a> 驅動程式，所以除了 <a href="https://man.freebsd.org/cgi/man.cgi?query=de&amp;sektion=4&amp;format=html">de(4)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> 外的所有網路裝置可以自核心中移除。</p></div></li><li><p>設定網路</p><div class=paragraph><p>最基本的網路設定是使用 DHCP 來讓虛擬機器連線到與主端 Microsoft™ Windows™ 相同的區域網路，這可以透過加入 <code>ifconfig_de0="DHCP"</code> 到 <span class=filename>/etc/rc.conf</span> 來完成。更進階的網路設定在 <a href=./#advanced-networking>進階網路設定</a> 中描述。</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=virtualization-guest-vmware>21.4. 在 Mac OS™ 的 VMware Fusion 安裝 FreeBSD 為客端<a class=anchor href=#virtualization-guest-vmware></a></h3><div class=paragraph><p>VMware Fusion 是一套商業軟體可在 Intel™ 為基礎的 Apple™Mac™ 的 Mac OS™ 10.4.9 或更新版本上執行。 該軟體完全支援使用 FreeBSD 作為客端作業系統。 在 Mac OS™ X 裝好 VMware Fusion 後，使用者必先完成虛擬機器的設定後才可安裝想使用的客端作業系統。</p></div><div class=sect3><h4 id=virtualization-guest-vmware-install>21.4.1. 在 VMware Fusion 安裝 FreeBSD<a class=anchor href=#virtualization-guest-vmware-install></a></h4><div class=paragraph><p>第一個步驟是啟動 VMware Fusion 載入 Virtual Machine Library，點選 <span class=guimenuitem>New</span> 建立虛擬機器：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd01.png alt="vmware freebsd01"></div></div><div class=paragraph><p>這個動做會載入 New Virtual Machine Assistant，點選 <span class=guimenuitem>Continue</span> 繼續：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd02.png alt="vmware freebsd02"></div></div><div class=paragraph><p>選擇 <span class=guimenuitem>Operating System</span> 為 <span class=guimenuitem>Other</span> 以及在 <b class=menuref>Version</b> 提示出現時選擇 <span class=guimenuitem>FreeBSD</span> 或 <span class=guimenuitem>FreeBSD 64-bit</span>：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd03.png alt="vmware freebsd03"></div></div><div class=paragraph><p>選擇虛擬機器要使用的名稱以及要儲存目錄位置：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd04.png alt="vmware freebsd04"></div></div><div class=paragraph><p>選擇虛擬機器的 Virtual Hard Disk 大小：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd05.png alt="vmware freebsd05"></div></div><div class=paragraph><p>選擇安裝虛擬機器的方式，可從 ISO 映像檔或從 CD/DVD：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd06.png alt="vmware freebsd06"></div></div><div class=paragraph><p>點選 <span class=guimenuitem>Finish</span> 接著虛擬機器會開機：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd07.png alt="vmware freebsd07"></div></div><div class=paragraph><p>照往常方式安裝 FreeBSD：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd08.png alt="vmware freebsd08"></div></div><div class=paragraph><p>安裝完成後，可以修改虛擬機器的設定，例如記憶體使用量：</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>虛擬機器的 System Hardware 設定無法在虛擬機器執行時修改。</p></div></td></tr></tbody></table></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd09.png alt="vmware freebsd09"></div></div><div class=paragraph><p>虛擬機器要使用的 CPU 數量：</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd10.png alt="vmware freebsd10"></div></div><div class=paragraph><p>CD-ROM 裝置的狀態，正常情況 CD/DVD/ISO 在不需要時會中斷與虛擬機器的連線。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd11.png alt="vmware freebsd11"></div></div><div class=paragraph><p>最後一件事是更改虛擬機器連線到網路的方式，要允許除了主端以外的機器連線到虛擬機器，請選擇 <span class=guimenuitem>Connect directly to the physical network (Bridged)</span>。否則會偏好使用 <span class=guimenuitem>Share the host’s internet connection (NAT)</span> 來讓虛擬機器可以存取網際網路，但外部網路無法連線到虛擬機器。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd12.png alt="vmware freebsd12"></div></div><div class=paragraph><p>在修改設定之後，開機進入新安裝的 FreeBSD 虛擬機器。</p></div></div><div class=sect3><h4 id=virtualization-guest-vmware-configure>21.4.2. 在 VMware Fusion 設定 FreeBSD<a class=anchor href=#virtualization-guest-vmware-configure></a></h4><div class=paragraph><p>在成功將 FreeBSD 安裝到 Mac OS™ X 的 VMware Fusion 後，有數個設定步驟要完成來最佳化系統在虛擬機器上的運作。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>設定 Boot Loader 變數</p><div class=paragraph><p>最重要的一個步驟是減少 <code>kern.hz</code>，來減少 FreeBSD 在 VMware Fusion 環境下 CPU 的使用量。這可以透過加入下列幾行到 <span class=filename>/boot/loader.conf</span> 來完成：</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>若沒有完成此設定，閒置的 FreeBSD VMware Fusion 客端將會消耗掉單一處理器的 iMac™ 將近 15% 的 CPU。完成此更改後使用率會減至接近 5%。</p></div></li><li><p>建立新核心設定檔</p><div class=paragraph><p>所有的 SCSI, FireWire 及 USB 裝置可以從自訂的核心設定檔中移除。VMware Fusion 提供的虛擬網路卡使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a> 驅動程式，所以除了 <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a> 外的所有網路裝置可以自核心中移除。</p></div></li><li><p>設定網路</p><div class=paragraph><p>最基本的網路設定是使用 DHCP 來讓虛擬機器連線到與主端 Mac™ 相同的區域網路，這可以透過加入 <code>ifconfig_em0="DHCP"</code> 到 <span class=filename>/etc/rc.conf</span> 來完成。更進階的網路設定在 <a href=./#advanced-networking>進階網路設定</a> 中描述。</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=virtualization-guest-virtualbox>21.5. 在 VirtualBox™ 安裝 FreeBSD 作為客端<a class=anchor href=#virtualization-guest-virtualbox></a></h3><div class=paragraph><p>在 VirtualBox™ 中使用 FreeBSD 做為客端系統也可運作的很好，虛擬化軟體可支援最常見的幾個作業系統，這當然也包含 FreeBSD。</p></div><div class=paragraph><p>VirtualBox™ guest additions 支援以下功能：</p></div><div class=ulist><ul><li><p>剪貼簿共享。</p></li><li><p>滑鼠指標整合。</p></li><li><p>主機時間同步。</p></li><li><p>視窗縮放。</p></li><li><p>無痕模式。</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>以下指令均是在 FreeBSD 客端中執行。</p></div></td></tr></tbody></table></div><div class=paragraph><p>首先，在 FreeBSD 客端安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose-additions/>emulators/virtualbox-ose-additions</a> 套件或 Port，以下指令會安裝 Port：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/virtualbox-ose-additions &amp;&amp; make install clean</span></code></pre></div></div><div class=paragraph><p>加入下行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>vboxguest_enable=&#34;YES&#34;
vboxservice_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>若有使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a>，便可關閉主機時間同步功能：</p></div><div class="literalblock programlisting"><div class=content><pre>vboxservice_flags=&#34;--disable-timesync&#34;</pre></div></div><div class=paragraph><p>Xorg 會自動辨識 <code>vboxvideo</code> 驅動程式，也可手動在 <span class=filename>/etc/X11/xorg.conf</span> 中輸入：</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver &#34;vboxvideo&#34;
	VendorName &#34;InnoTek Systemberatung GmbH&#34;
	BoardName &#34;VirtualBox Graphics Adapter&#34;
EndSection</pre></div></div><div class=paragraph><p>要使用 <code>vboxmouse</code> 驅動程式，可調整在 <span class=filename>/etc/X11/xorg.conf</span> 中與滑鼠相關的一節：</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
	Identifier &#34;Mouse0&#34;
	Driver &#34;vboxmouse&#34;
EndSection</pre></div></div><div class=paragraph><p>HAL 的使用者應建立以下 <span class=filename>/usr/local/etc/hal/fdi/policy/90-vboxguest.fdi</span> 或複製自 <span class=filename>/usr/local/shared/hal/fdi/policy/10osvendor/90-vboxguest.fdi</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;!--
# Sun VirtualBox
# Hal driver description for the vboxmouse driver
# $Id: chapter.xml,v 1.33 2012-03-17 04:53:52 eadler Exp $

	Copyright (C) 2008-2009 Sun Microsystems, Inc.

	This file is part of VirtualBox Open Source Edition (OSE, as
	available from http://www.virtualbox.org. This file is free software;
	you can redistribute it and/or modify it under the terms of the GNU
	General Public License (GPL) as published by the Free Software
	Foundation, in version 2 as it comes in the &#34;COPYING&#34; file of the
	VirtualBox OSE distribution. VirtualBox OSE is distributed in the
	hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.

	Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
	Clara, CA 95054 USA or visit http://www.sun.com if you need
	additional information or have any questions.
--&gt;
&lt;deviceinfo version=&#34;0.2&#34;&gt;
  &lt;device&gt;
    &lt;match key=&#34;info.subsystem&#34; string=&#34;pci&#34;&gt;
      &lt;match key=&#34;info.product&#34; string=&#34;VirtualBox guest Service&#34;&gt;
        &lt;append key=&#34;info.capabilities&#34; type=&#34;strlist&#34;&gt;input&lt;/append&gt;
	&lt;append key=&#34;info.capabilities&#34; type=&#34;strlist&#34;&gt;input.mouse&lt;/append&gt;
        &lt;merge key=&#34;input.x11_driver&#34; type=&#34;string&#34;&gt;vboxmouse&lt;/merge&gt;
	&lt;merge key=&#34;input.device&#34; type=&#34;string&#34;&gt;/dev/vboxguest&lt;/merge&gt;
      &lt;/match&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;</pre></div></div><div class=paragraph><p>Shared folders for file transfers between host and VM are accessible by mounting them using <code>mount_vboxvfs</code>. A shared folder can be created on the host using the VirtualBox GUI or via <code>vboxmanage</code>. For example, to create a shared folder called <em>myshare</em> under <span class=filename>/mnt/bsdboxshare</span> for the VM named <em>BSDBox</em>, run:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vboxmanage sharedfolder add &#39;BSDBox&#39; --name myshare --hostpath /mnt/bsdboxshare</span></code></pre></div></div><div class=paragraph><p>Note that the shared folder name must not contain spaces. Mount the shared folder from within the guest system like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_vboxvfs -w myshare /mnt</span></code></pre></div></div></div><div class=sect2><h3 id=virtualization-host-virtualbox>21.6. 以 FreeBSD 作為主端使用 VirtualBox™<a class=anchor href=#virtualization-host-virtualbox></a></h3><div class=paragraph><p>VirtualBox™ 是一套積極開發、完整的虛擬化套件，適用大多數作業系統，包含 Windows™, Mac OS™, Linux™ 與 FreeBSD，它同樣能夠執行類 Windows™ 或 UNIX™ 的客端系統。它是以開源軟體的方式發佈，但閉源元件可獨立在擴充包中使用，這些元件包含對 USB 2.0 裝置的支援。更多資訊可在 <a href=http://www.virtualbox.org/wiki/Downloads>VirtualBox wiki 的 Downloads 頁面</a>。目前，這些擴充套件並不支援 FreeBSD。</p></div><div class=sect3><h4 id=virtualization-virtualbox-install>21.6.1. 安裝 VirtualBox™<a class=anchor href=#virtualization-virtualbox-install></a></h4><div class=paragraph><p>VirtualBox™ 可於 <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose/>emulators/virtualbox-ose</a> 以 FreeBSD 套件或 Port 的方式取得。要安裝 Port 可使用以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/virtualbox-ose</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>在 Port 的設定選單中 <code>GuestAdditions</code> 相關程式是最有用的選項之一，這些程式可在客端作業系統提供數個有用的功能，如滑鼠指標整合 (允許滑鼠在主端與客端之間移動，不需要按特殊快速鍵來切換) 與較快的影像繪圖速度，特別是在 Windows™ 的客端系統。Guest additions 可在客端系統安裝完之後的 <b class=menuref>Devices</b> 選單找到。</p></div><div class=paragraph><p>還有一些設定需要在 VirtualBox™ 第一次啟動端做修改，Port 會安裝一個核心模組在 <span class=filename>/boot/modules</span>，該模組必須在核心中載入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vboxdrv</span></code></pre></div></div><div class=paragraph><p>要確保該模組在重新開機後會載入，可加入下行到 <span class=filename>/boot/loader.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>vboxdrv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>要使用可支援橋接或僅限主端 (Host-only) 的網路，可加入下行到 <span class=filename>/etc/rc.conf</span>，然後重新啟動電腦：</p></div><div class="literalblock programlisting"><div class=content><pre>vboxnet_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>在安裝 VirtualBox™ 的過程中會建立 <code>vboxusers</code> 群組，所有需要存取 VirtualBox™ 的使用者均需要加入成為此群組的成員，<code>pw</code> 可用來加入新的成員：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod vboxusers -m yourusername</span></code></pre></div></div><div class=paragraph><p><span class=filename>/dev/vboxnetctl</span> 的預設權限是受限的，需要更改後才可使用橋接網路：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:vboxusers /dev/vboxnetctl</span>
<span class=c># chmod 0660 /dev/vboxnetctl</span></code></pre></div></div><div class=paragraph><p>要永久變更權限，可加入下列幾行到 <span class=filename>/etc/devfs.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>own     vboxnetctl root:vboxusers
perm    vboxnetctl 0660</pre></div></div><div class=paragraph><p>要執行 VirtualBox™，可在 Xorg 工作階段輸入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% VirtualBox</code></pre></div></div><div class=paragraph><p>要取得更多有關設定與使用 VirtualBox™ 的資訊，請參考 <a href=http://www.virtualbox.org>官方網站</a>。供 FreeBSD 特定的資訊與疑難排解操作指示，可參考 <a href=http://wiki.FreeBSD.org/VirtualBox>FreeBSD wiki 中相關的頁面</a>。</p></div></div><div class=sect3><h4 id=virtualization-virtualbox-usb-support>21.6.2. VirtualBox™ USB 支援<a class=anchor href=#virtualization-virtualbox-usb-support></a></h4><div class=paragraph><p>VirtualBox™ can be configured to pass USB devices through to the guest operating system. The host controller of the OSE version is limited to emulating USB 1.1 devices until the extension pack supporting USB 2.0 and 3.0 devices becomes available on FreeBSD.</p></div><div class=paragraph><p>For VirtualBox™ to be aware of USB devices attached to the machine, the user needs to be a member of the <code>operator</code> group.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod operator -m yourusername</span></code></pre></div></div><div class=paragraph><p>Then, add the following to <span class=filename>/etc/devfs.rules</span>, or create this file if it does not exist yet:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=10]
add path &#39;usb/*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>若服務未執行，請加入下行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;system&#34;</pre></div></div><div class=paragraph><p>然後重新啟動 devfs：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div><div class=paragraph><p>重新啟動登作階段與 VirtualBox™ 來讓這些變更生效，且建立必要的 USB 的過濾器。</p></div></div><div class=sect3><h4 id=virtualization-virtualbox-host-dvd-cd-access>21.6.3. VirtualBox™ Host DVD/CD 存取<a class=anchor href=#virtualization-virtualbox-host-dvd-cd-access></a></h4><div class=paragraph><p>透過共享實體磁碟機可讓客端系統能夠存取主端系統的 DVD/CD 磁碟機。在 VirtualBox™ 中，這個功能可在虛擬機器設定中的儲存 (Storage) 視窗中設定。若需要，可先建立一個空的 IDECD/DVD 裝置，然後在跳出的選單中選擇要做為虛擬 CD/DVD 磁碟機的主端磁碟機，此時會出現一個標籤為 <code>Passthrough</code> 的核選方塊，勾選這個核選方塊可讓虛擬機器直接使用該硬體，例如，音樂 CD 或燒錄機只會在有勾選此選項時能夠運作。</p></div><div class=paragraph><p>VirtualBox™DVD/CD 功能要能運作需要執行 HAL，因此需在 <span class=filename>/etc/rc.conf</span> 中開啟，若該服務尚未啟動，則啟動它：</p></div><div class="literalblock programlisting"><div class=content><pre>hald_enable=&#34;YES&#34;</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hald start</span></code></pre></div></div><div class=paragraph><p>為了讓使用者能夠使用 VirtualBox™DVD/CD 功能，這些使用者需要存取 <span class=filename>/dev/xpt0</span>, <span class=filename>/dev/cdN</span> 以及 <span class=filename>/dev/passN</span>，這通常可讓這些使用者成為 <code>operator</code> 的成員來達成。對這些裝置的權限必須加入下行到 <span class=filename>/etc/devfs.conf</span> 來修正：</p></div><div class="literalblock programlisting"><div class=content><pre>perm cd* 0660
perm xpt0 0660
perm pass* 0660</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div></div></div><div class=sect2><h3 id=virtualization-host-bhyve>21.7. 以 FreeBSD 作為主端安裝 bhyve<a class=anchor href=#virtualization-host-bhyve></a></h3><div class=paragraph><p>The bhyveBSD-licensed hypervisor became part of the base system with FreeBSD 10.0-RELEASE. This hypervisor supports a number of guests, including FreeBSD, OpenBSD, and many Linux™ distributions. By default, bhyve provides access to serial console and does not emulate a graphical console. Virtualization offload features of newer CPUs are used to avoid the legacy methods of translating instructions and manually managing memory mappings.</p></div><div class=paragraph><p>The bhyve design requires a processor that supports Intel™ Extended Page Tables (EPT) or AMD™ Rapid Virtualization Indexing (RVI) or Nested Page Tables (NPT). Hosting Linux™ guests or FreeBSD guests with more than one vCPU requires VMX unrestricted mode support (UG). Most newer processors, specifically the Intel™ Core™ i3/i5/i7 and Intel™ Xeon™ E3/E5/E7, support these features. UG support was introduced with Intel’s Westmere micro-architecture. For a complete list of Intel™ processors that support EPT, refer to <a href="https://ark.intel.com/content/www/us/en/ark/search/featurefilter.html?productType=873&amp;0_ExtendedPageTables=True" class=bare>https://ark.intel.com/content/www/us/en/ark/search/featurefilter.html?productType=873&amp;0_ExtendedPageTables=True</a>. RVI is found on the third generation and later of the AMD Opteron™ (Barcelona) processors. The easiest way to tell if a processor supports bhyve is to run <code>dmesg</code> or look in <span class=filename>/var/run/dmesg.boot</span> for the <code>POPCNT</code> processor feature flag on the <code>Features2</code> line for AMD™ processors or <code>EPT</code> and <code>UG</code> on the <code>VT-x</code> line for Intel™ processors.</p></div><div class=sect3><h4 id=virtualization-bhyve-prep>21.7.1. 準備主端<a class=anchor href=#virtualization-bhyve-prep></a></h4><div class=paragraph><p>The first step to creating a virtual machine in bhyve is configuring the host system. First, load the bhyve kernel module:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vmm</span></code></pre></div></div><div class=paragraph><p>Then, create a <span class=filename>tap</span> interface for the network device in the virtual machine to attach to. In order for the network device to participate in the network, also create a bridge interface containing the <span class=filename>tap</span> interface and the physical interface as members. In this example, the physical interface is <em>igb0</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig tap0 create</span>
<span class=c># sysctl net.link.tap.up_on_open=1</span>
net.link.tap.up_on_open: 0 -&gt; 1
<span class=c># ifconfig bridge0 create</span>
<span class=c># ifconfig bridge0 addm igb0 addm tap0</span>
<span class=c># ifconfig bridge0 up</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-freebsd>21.7.2. 建立 FreeBSD 客端<a class=anchor href=#virtualization-bhyve-freebsd></a></h4><div class=paragraph><p>Create a file to use as the virtual disk for the guest machine. Specify the size and name of the virtual disk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># truncate -s 16G guest.img</span></code></pre></div></div><div class=paragraph><p>Download an installation image of FreeBSD to install:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch ftp://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/10.3/FreeBSD-10.3-RELEASE-amd64-bootonly.iso</span>
FreeBSD-10.3-RELEASE-amd64-bootonly.iso       100% of  230 MB  570 kBps 06m17s</code></pre></div></div><div class=paragraph><p>FreeBSD comes with an example script for running a virtual machine in bhyve. The script will start the virtual machine and run it in a loop, so it will automatically restart if it crashes. The script takes a number of options to control the configuration of the machine: <code>-c</code> controls the number of virtual CPUs, <code>-m</code> limits the amount of memory available to the guest, <code>-t</code> defines which <span class=filename>tap</span> device to use, <code>-d</code> indicates which disk image to use, <code>-i</code> tells bhyve to boot from the CD image instead of the disk, and <code>-I</code> defines which CD image to use. The last parameter is the name of the virtual machine, used to track the running machines. This example starts the virtual machine in installation mode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /usr/shared/examples/bhyve/vmrun.sh -c 1 -m 1024M -t tap0 -d guest.img -i -I FreeBSD-10.3-RELEASE-amd64-bootonly.iso guestname</span></code></pre></div></div><div class=paragraph><p>The virtual machine will boot and start the installer. After installing a system in the virtual machine, when the system asks about dropping in to a shell at the end of the installation, choose <b class=button>Yes</b>.</p></div><div class=paragraph><p>Reboot the virtual machine. While rebooting the virtual machine causes bhyve to exit, the <span class=filename>vmrun.sh</span> script runs <code>bhyve</code> in a loop and will automatically restart it. When this happens, choose the reboot option from the boot loader menu in order to escape the loop. Now the guest can be started from the virtual disk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /usr/shared/examples/bhyve/vmrun.sh -c 4 -m 1024M -t tap0 -d guest.img guestname</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-linux>21.7.3. 建立 Linux™ 客端<a class=anchor href=#virtualization-bhyve-linux></a></h4><div class=paragraph><p>In order to boot operating systems other than FreeBSD, the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a> port must be first installed.</p></div><div class=paragraph><p>Next, create a file to use as the virtual disk for the guest machine:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># truncate -s 16G linux.img</span></code></pre></div></div><div class=paragraph><p>Starting a virtual machine with bhyve is a two step process. First a kernel must be loaded, then the guest can be started. The Linux™ kernel is loaded with <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a>. Create a <span class=filename>device.map</span> that grub will use to map the virtual devices to the files on the host system:</p></div><div class="literalblock programlisting"><div class=content><pre>(hd0) ./linux.img
(cd0) ./somelinux.iso</pre></div></div><div class=paragraph><p>Use <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a> to load the Linux™ kernel from the ISO image:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grub-bhyve -m device.map -r cd0 -M 1024M linuxguest</span></code></pre></div></div><div class=paragraph><p>This will start grub. If the installation CD contains a <span class=filename>grub.cfg</span>, a menu will be displayed. If not, the <code>vmlinuz</code> and <code>initrd</code> files must be located and loaded manually:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>grub&gt; <span class=nb>ls</span>
<span class=o>(</span>hd0<span class=o>)</span> <span class=o>(</span>cd0<span class=o>)</span> <span class=o>(</span>cd0,msdos1<span class=o>)</span> <span class=o>(</span>host<span class=o>)</span>
grub&gt; <span class=nb>ls</span> <span class=o>(</span>cd0<span class=o>)</span>/isolinux
boot.cat boot.msg grub.conf initrd.img isolinux.bin isolinux.cfg memtest
splash.jpg TRANS.TBL vesamenu.c32 vmlinuz
grub&gt; linux <span class=o>(</span>cd0<span class=o>)</span>/isolinux/vmlinuz
grub&gt; initrd <span class=o>(</span>cd0<span class=o>)</span>/isolinux/initrd.img
grub&gt; boot</code></pre></div></div><div class=paragraph><p>Now that the Linux™ kernel is loaded, the guest can be started:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \</span>
    <span class=nt>-s</span> 4:0,ahci-cd,./somelinux.iso <span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div><div class=paragraph><p>The system will boot and start the installer. After installing a system in the virtual machine, reboot the virtual machine. This will cause bhyve to exit. The instance of the virtual machine needs to be destroyed before it can be started again:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=linuxguest</span></code></pre></div></div><div class=paragraph><p>Now the guest can be started directly from the virtual disk. Load the kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grub-bhyve -m device.map -r hd0,msdos1 -M 1024M linuxguest</span>
grub&gt; <span class=nb>ls</span>
<span class=o>(</span>hd0<span class=o>)</span> <span class=o>(</span>hd0,msdos2<span class=o>)</span> <span class=o>(</span>hd0,msdos1<span class=o>)</span> <span class=o>(</span>cd0<span class=o>)</span> <span class=o>(</span>cd0,msdos1<span class=o>)</span> <span class=o>(</span>host<span class=o>)</span>
<span class=o>(</span>lvm/VolGroup-lv_swap<span class=o>)</span> <span class=o>(</span>lvm/VolGroup-lv_root<span class=o>)</span>
grub&gt; <span class=nb>ls</span> <span class=o>(</span>hd0,msdos1<span class=o>)</span>/
lost+found/ grub/ efi/ System.map-2.6.32-431.el6.x86_64 config-2.6.32-431.el6.x
86_64 symvers-2.6.32-431.el6.x86_64.gz vmlinuz-2.6.32-431.el6.x86_64
initramfs-2.6.32-431.el6.x86_64.img
grub&gt; linux <span class=o>(</span>hd0,msdos1<span class=o>)</span>/vmlinuz-2.6.32-431.el6.x86_64 <span class=nv>root</span><span class=o>=</span>/dev/mapper/VolGroup-lv_root
grub&gt; initrd <span class=o>(</span>hd0,msdos1<span class=o>)</span>/initramfs-2.6.32-431.el6.x86_64.img
grub&gt; boot</code></pre></div></div><div class=paragraph><p>Boot the virtual machine:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 \</span>
    <span class=nt>-s</span> 3:0,virtio-blk,./linux.img <span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div><div class=paragraph><p>Linux™ will now boot in the virtual machine and eventually present you with the login prompt. Login and use the virtual machine. When you are finished, reboot the virtual machine to exit bhyve. Destroy the virtual machine instance:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=linuxguest</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-uefi>21.7.4. 使用 UEFI 韌體開機 bhyve 虛擬機器<a class=anchor href=#virtualization-bhyve-uefi></a></h4><div class=paragraph><p>In addition to bhyveload and grub-bhyve, the bhyve hypervisor can also boot virtual machines using the UEFI userspace firmware. This option may support guest operating systems that are not supported by the other loaders.</p></div><div class=paragraph><p>In order to make use of the UEFI support in bhyve, first obtain the UEFI firmware images. This can be done by installing <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/>sysutils/bhyve-firmware</a> port or package.</p></div><div class=paragraph><p>With the firmware in place, add the flags <code>-l bootrom,<em>/path/to/firmware</em></code> to your bhyve command line. The actual bhyve command may look like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
<span class=nt>-l</span> bootrom,/usr/local/shared/uefi-firmware/BHYVE_UEFI.fd <span class=se>\</span>
guest</code></pre></div></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/>sysutils/bhyve-firmware</a> also contains a CSM-enabled firmware, to boot guests with no UEFI support in legacy BIOS mode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
<span class=nt>-l</span> bootrom,/usr/local/shared/uefi-firmware/BHYVE_UEFI_CSM.fd <span class=se>\</span>
guest</code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-framebuffer>21.7.5. 供 bhyve 客端用的圖型化 UEFI Framebuffer<a class=anchor href=#virtualization-bhyve-framebuffer></a></h4><div class=paragraph><p>The UEFI firmware support is particularly useful with predominantly graphical guest operating systems such as Microsoft Windows™.</p></div><div class=paragraph><p>Support for the UEFI-GOP framebuffer may also be enabled with the <code>-s 29,fbuf,tcp=<em>0.0.0.0:5900</em></code> flags. The framebuffer resolution may be configured with <code>w=<em>800</em></code> and <code>h=<em>600</em></code>, and bhyve can be instructed to wait for a VNC connection before booting the guest by adding <code>wait</code>. The framebuffer may be accessed from the host or over the network via the VNC protocol.</p></div><div class=paragraph><p>bhyve 指令的結果會如下：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 31:0,lpc \</span>
<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
<span class=nt>-s</span> 29,fbuf,tcp<span class=o>=</span>0.0.0.0:5900,w<span class=o>=</span>800,h<span class=o>=</span>600,wait <span class=se>\</span>
<span class=nt>-l</span> bootrom,/usr/local/shared/uefi-firmware/BHYVE_UEFI.fd <span class=se>\</span>
guest</code></pre></div></div><div class=paragraph><p>Note, in BIOS emulation mode, the framebuffer will cease receiving updates once control is passed from firmware to guest operating system.</p></div></div><div class=sect3><h4 id=virtualization-bhyve-zfs>21.7.6. 在 bhyve 客端使用 ZFS<a class=anchor href=#virtualization-bhyve-zfs></a></h4><div class=paragraph><p>If ZFS is available on the host machine, using ZFS volumes instead of disk image files can provide significant performance benefits for the guest VMs. A ZFS volume can be created by:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V16G -o volmode=dev zroot/linuxdisk0</span></code></pre></div></div><div class=paragraph><p>When starting the VM, specify the ZFS volume as the disk drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s3:0,virtio-blk,/dev/zvol/zroot/linuxdisk0 \</span>
    <span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-nmdm>21.7.7. 虛擬機器 Console<a class=anchor href=#virtualization-bhyve-nmdm></a></h4><div class=paragraph><p>It is advantageous to wrap the bhyve console in a session management tool such as <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/tmux/>sysutils/tmux</a> or <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/screen/>sysutils/screen</a> in order to detach and reattach to the console. It is also possible to have the console of bhyve be a null modem device that can be accessed with <code>cu</code>. To do this, load the <span class=filename>nmdm</span> kernel module and replace <code>-l com1,stdio</code> with <code>-l com1,/dev/nmdm0A</code>. The <span class=filename>/dev/nmdm</span> devices are created automatically as needed, where each is a pair, corresponding to the two ends of the null modem cable (<span class=filename>/dev/nmdm0A</span> and <span class=filename>/dev/nmdm0B</span>). See <a href="https://man.freebsd.org/cgi/man.cgi?query=nmdm&amp;sektion=4&amp;format=html">nmdm(4)</a> for more information.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload nmdm</span>
<span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \</span>
    <span class=nt>-l</span> com1,/dev/nmdm0A <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest
<span class=c># cu -l /dev/nmdm0B</span>
Connected

Ubuntu 13.10 handbook ttyS0

handbook login:</code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-managing>21.7.8. 管理虛擬機器<a class=anchor href=#virtualization-bhyve-managing></a></h4><div class=paragraph><p>A device node is created in <span class=filename>/dev/vmm</span> for each virtual machine. This allows the administrator to easily see a list of the running virtual machines:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -al /dev/vmm</span>
total 1
dr-xr-xr-x   2 root  wheel    512 Mar 17 12:19 ./
dr-xr-xr-x  14 root  wheel    512 Mar 17 06:38 ../
crw-------   1 root  wheel  0x1a2 Mar 17 12:20 guestname
crw-------   1 root  wheel  0x19f Mar 17 12:19 linuxguest
crw-------   1 root  wheel  0x1a1 Mar 17 12:19 otherguest</code></pre></div></div><div class=paragraph><p>A specified virtual machine can be destroyed using <code>bhyvectl</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=guestname</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-onboot>21.7.9. Persistent 設定<a class=anchor href=#virtualization-bhyve-onboot></a></h4><div class=paragraph><p>In order to configure the system to start bhyve guests at boot time, the following configurations must be made in the specified files:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><span class=filename>/etc/sysctl.conf</span></p><div class="literalblock programlisting"><div class=content><pre>net.link.tap.up_on_open=1</pre></div></div></li><li><p><span class=filename>/etc/rc.conf</span></p><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0 tap0&#34;
ifconfig_bridge0=&#34;addm igb0 addm tap0&#34;
kld_list=&#34;nmdm vmm&#34;</pre></div></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=virtualization-host-xen>21.8. 以 FreeBSD 作為主端安裝 Xen™<a class=anchor href=#virtualization-host-xen></a></h3><div class=paragraph><p>Xen is a GPLv2-licensed <a href=https://en.wikipedia.org/wiki/Hypervisor#Classification>type 1 hypervisor</a> for Intel™ and ARM™ architectures. FreeBSD has included i386™ and AMD™ 64-Bit <a href=https://wiki.xenproject.org/wiki/DomU>DomU</a> and <a href=https://en.wikipedia.org/wiki/Amazon_Elastic_Compute_Cloud>Amazon EC2</a> unprivileged domain (virtual machine) support since FreeBSD 8.0 and includes Dom0 control domain (host) support in FreeBSD 11.0. Support for para-virtualized (PV) domains has been removed from FreeBSD 11 in favor of hardware virtualized (HVM) domains, which provides better performance.</p></div><div class=paragraph><p>Xen™ is a bare-metal hypervisor, which means that it is the first program loaded after the BIOS. A special privileged guest called the Domain-0 (<code>Dom0</code> for short) is then started. The Dom0 uses its special privileges to directly access the underlying physical hardware, making it a high-performance solution. It is able to access the disk controllers and network adapters directly. The Xen™ management tools to manage and control the Xen™ hypervisor are also used by the Dom0 to create, list, and destroy VMs. Dom0 provides virtual disks and networking for unprivileged domains, often called <code>DomU</code>. Xen™ Dom0 can be compared to the service console of other hypervisor solutions, while the DomU is where individual guest VMs are run.</p></div><div class=paragraph><p>Xen™ can migrate VMs between different Xen™ servers. When the two xen hosts share the same underlying storage, the migration can be done without having to shut the VM down first. Instead, the migration is performed live while the DomU is running and there is no need to restart it or plan a downtime. This is useful in maintenance scenarios or upgrade windows to ensure that the services provided by the DomU are still provided. Many more features of Xen™ are listed on the <a href=https://wiki.xenproject.org/wiki/Category:Overview>Xen Wiki Overview page</a>. Note that not all features are supported on FreeBSD yet.</p></div><div class=sect3><h4 id=virtualization-host-xen-requirements>21.8.1. Xen™ Dom0 的硬體需求<a class=anchor href=#virtualization-host-xen-requirements></a></h4><div class=paragraph><p>To run the Xen™ hypervisor on a host, certain hardware functionality is required. Hardware virtualized domains require Extended Page Table (<a href=http://en.wikipedia.org/wiki/Extended_Page_Table>EPT</a>) and Input/Output Memory Management Unit (<a href=http://en.wikipedia.org/wiki/List_of_IOMMU-supporting_hardware>IOMMU</a>) support in the host processor.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In order to run a FreeBSD Xen™ Dom0 the box must be booted using legacy boot (BIOS).</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=virtualization-host-xen-dom0-setup>21.8.2. Xen™ Dom0 控制領域安裝<a class=anchor href=#virtualization-host-xen-dom0-setup></a></h4><div class=paragraph><p>Users of FreeBSD 11 should install the <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/xen-kernel47/>emulators/xen-kernel47</a> and <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xen-tools47/>sysutils/xen-tools47</a> packages that are based on Xen version 4.7. Systems running on FreeBSD-12.0 or newer can use Xen 4.11 provided by <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/xen-kernel411/>emulators/xen-kernel411</a> and <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xen-tools411/>sysutils/xen-tools411</a>, respectively.</p></div><div class=paragraph><p>Configuration files must be edited to prepare the host for the Dom0 integration after the Xen packages are installed. An entry to <span class=filename>/etc/sysctl.conf</span> disables the limit on how many pages of memory are allowed to be wired. Otherwise, DomU VMs with higher memory requirements will not run.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;vm.max_wired=-1&#39; &gt;&gt; /etc/sysctl.conf</span></code></pre></div></div><div class=paragraph><p>Another memory-related setting involves changing <span class=filename>/etc/login.conf</span>, setting the <code>memorylocked</code> option to <code>unlimited</code>. Otherwise, creating DomU domains may fail with <code>Cannot allocate memory</code> errors. After making the change to <span class=filename>/etc/login.conf</span>, run <code>cap_mkdb</code> to update the capability database. See <a href=./#security-resourcelimits>限制資源</a> for details.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sed -i &#39;&#39; -e &#39;s/memorylocked=64K/memorylocked=unlimited/&#39; /etc/login.conf</span>
<span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class=paragraph><p>Add an entry for the Xen™ console to <span class=filename>/etc/ttys</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;xc0     &#34;/usr/libexec/getty Pc&#34;         xterm   onifconsole  secure&#39; &gt;&gt; /etc/ttys</span></code></pre></div></div><div class=paragraph><p>Selecting a Xen™ kernel in <span class=filename>/boot/loader.conf</span> activates the Dom0. Xen™ also requires resources like CPU and memory from the host machine for itself and other DomU domains. How much CPU and memory depends on the individual requirements and hardware capabilities. In this example, 8 GB of memory and 4 virtual CPUs are made available for the Dom0. The serial console is also activated and logging options are defined.</p></div><div class=paragraph><p>The following command is used for Xen 4.7 packages:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf hw.pci.mcfg=0</span>
<span class=c># sysrc -f /boot/loader.conf if_tap_load=&#34;YES&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_kernel=&#34;/boot/xen&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_cmdline=&#34;dom0_mem=8192M dom0_max_vcpus=4 dom0pvh=1 console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all&#34;</span></code></pre></div></div><div class=paragraph><p>For Xen versions 4.11 and higher, the following command should be used instead:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf if_tap_load=&#34;YES&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_kernel=&#34;/boot/xen&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_cmdline=&#34;dom0_mem=8192M dom0_max_vcpus=4 dom0=pvh console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all&#34;</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Log files that Xen™ creates for the DomU VMs are stored in <span class=filename>/var/log/xen</span>. Please be sure to check the contents of that directory if experiencing issues.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Activate the xencommons service during system startup:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc xencommons_enable=yes</span></code></pre></div></div><div class=paragraph><p>These settings are enough to start a Dom0-enabled system. However, it lacks network functionality for the DomU machines. To fix that, define a bridged interface with the main NIC of the system which the DomU VMs can use to connect to the network. Replace <em>em0</em> with the host network interface name.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc cloned_interfaces=&#34;bridge0&#34;</span>
<span class=c># sysrc ifconfig_bridge0=&#34;addm em0 SYNCDHCP&#34;</span>
<span class=c># sysrc ifconfig_em0=&#34;up&#34;</span></code></pre></div></div><div class=paragraph><p>Restart the host to load the Xen™ kernel and start the Dom0.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># reboot</span></code></pre></div></div><div class=paragraph><p>After successfully booting the Xen™ kernel and logging into the system again, the Xen™ management tool <code>xl</code> is used to show information about the domains.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl list</span>
Name                                        ID   Mem VCPUs      State   Time<span class=o>(</span>s<span class=o>)</span>
Domain-0                                     0  8192     4     r-----     962.0</code></pre></div></div><div class=paragraph><p>The output confirms that the Dom0 (called <code>Domain-0</code>) has the ID <code>0</code> and is running. It also has the memory and virtual CPUs that were defined in <span class=filename>/boot/loader.conf</span> earlier. More information can be found in the <a href=https://www.xenproject.org/help/documentation.html>Xen Documentation</a>. DomU guest VMs can now be created.</p></div></div><div class=sect3><h4 id=virtualization-host-xen-domu-setup>21.8.3. Xen™ DomU 客端 VM 設置<a class=anchor href=#virtualization-host-xen-domu-setup></a></h4><div class=paragraph><p>Unprivileged domains consist of a configuration file and virtual or physical hard disks. Virtual disk storage for the DomU can be files created by <a href="https://man.freebsd.org/cgi/man.cgi?query=truncate&amp;sektion=1&amp;format=html">truncate(1)</a> or ZFS volumes as described in <a href=./#zfs-zfs-volume>建立與摧毀磁碟區</a>. In this example, a 20 GB volume is used. A VM is created with the ZFS volume, a FreeBSD ISO image, 1 GB of RAM and two virtual CPUs. The ISO installation file is retrieved with <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> and saved locally in a file called <span class=filename>freebsd.iso</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch ftp://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/12.0/FreeBSD-12.0-RELEASE-amd64-bootonly.iso -o freebsd.iso</span></code></pre></div></div><div class=paragraph><p>A ZFS volume of 20 GB called <span class=filename>xendisk0</span> is created to serve as the disk space for the VM.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V20G -o volmode=dev zroot/xendisk0</span></code></pre></div></div><div class=paragraph><p>The new DomU guest VM is defined in a file. Some specific definitions like name, keymap, and VNC connection details are also defined. The following <span class=filename>freebsd.cfg</span> contains a minimum DomU configuration for this example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat freebsd.cfg</span>
builder <span class=o>=</span> <span class=s2>&#34;hvm&#34;</span> <i class=conum data-value=1></i><b>(1)</b>
name <span class=o>=</span> <span class=s2>&#34;freebsd&#34;</span> <i class=conum data-value=2></i><b>(2)</b>
memory <span class=o>=</span> 1024 <i class=conum data-value=3></i><b>(3)</b>
vcpus <span class=o>=</span> 2 <i class=conum data-value=4></i><b>(4)</b>
vif <span class=o>=</span> <span class=o>[</span> <span class=s1>&#39;mac=00:16:3E:74:34:32,bridge=bridge0&#39;</span> <span class=o>]</span> <i class=conum data-value=5></i><b>(5)</b>
disk <span class=o>=</span> <span class=o>[</span>
<span class=s1>&#39;/dev/zvol/tank/xendisk0,raw,hda,rw&#39;</span>, <i class=conum data-value=6></i><b>(6)</b>
<span class=s1>&#39;/root/freebsd.iso,raw,hdc:cdrom,r&#39;</span> <i class=conum data-value=7></i><b>(7)</b>
  <span class=o>]</span>
vnc <span class=o>=</span> 1 <i class=conum data-value=8></i><b>(8)</b>
vnclisten <span class=o>=</span> <span class=s2>&#34;0.0.0.0&#34;</span>
serial <span class=o>=</span> <span class=s2>&#34;pty&#34;</span>
usbdevice <span class=o>=</span> <span class=s2>&#34;tablet&#34;</span></code></pre></div></div><div class=paragraph><p>These lines are explained in more detail:</p></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This defines what kind of virtualization to use. <code>hvm</code> refers to hardware-assisted virtualization or hardware virtual machine. Guest operating systems can run unmodified on CPUs with virtualization extensions, providing nearly the same performance as running on physical hardware. <code>generic</code> is the default value and creates a PV domain.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Name of this virtual machine to distinguish it from others running on the same Dom0. Required.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Quantity of RAM in megabytes to make available to the VM. This amount is subtracted from the hypervisor’s total available memory, not the memory of the Dom0.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Number of virtual CPUs available to the guest VM. For best performance, do not create guests with more virtual CPUs than the number of physical CPUs on the host.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Virtual network adapter. This is the bridge connected to the network interface of the host. The <code>mac</code> parameter is the MAC address set on the virtual network interface. This parameter is optional, if no MAC is provided Xen™ will generate a random one.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Full path to the disk, file, or ZFS volume of the disk storage for this VM. Options and multiple disk definitions are separated by commas.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Defines the Boot medium from which the initial operating system is installed. In this example, it is the ISO imaged downloaded earlier. Consult the Xen™ documentation for other kinds of devices and options to set.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Options controlling VNC connectivity to the serial console of the DomU. In order, these are: active VNC support, define IP address on which to listen, device node for the serial console, and the input method for precise positioning of the mouse and other input methods. <code>keymap</code> defines which keymap to use, and is <code>english</code> by default.</td></tr></tbody></table></div><div class=paragraph><p>After the file has been created with all the necessary options, the DomU is created by passing it to <code>xl create</code> as a parameter.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl create freebsd.cfg</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Each time the Dom0 is restarted, the configuration file must be passed to <code>xl create</code> again to re-create the DomU. By default, only the Dom0 is created after a reboot, not the individual VMs. The VMs can continue where they left off as they stored the operating system on the virtual disk. The virtual machine configuration can change over time (for example, when adding more memory). The virtual machine configuration files must be properly backed up and kept available to be able to re-create the guest VM when needed.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The output of <code>xl list</code> confirms that the DomU has been created.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl list</span>
Name                                        ID   Mem VCPUs      State   Time<span class=o>(</span>s<span class=o>)</span>
Domain-0                                     0  8192     4     r-----  1653.4
freebsd                                      1  1024     1     <span class=nt>-b----</span>   663.9</code></pre></div></div><div class=paragraph><p>To begin the installation of the base operating system, start the VNC client, directing it to the main network address of the host or to the IP address defined on the <code>vnclisten</code> line of <span class=filename>freebsd.cfg</span>. After the operating system has been installed, shut down the DomU and disconnect the VNC viewer. Edit <span class=filename>freebsd.cfg</span>, removing the line with the <code>cdrom</code> definition or commenting it out by inserting a <code>#</code> character at the beginning of the line. To load this new configuration, it is necessary to remove the old DomU with <code>xl destroy</code>, passing either the name or the id as the parameter. Afterwards, recreate it using the modified <span class=filename>freebsd.cfg</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl destroy freebsd</span>
<span class=c># xl create freebsd.cfg</span></code></pre></div></div><div class=paragraph><p>The machine can then be accessed again using the VNC viewer. This time, it will boot from the virtual disk where the operating system has been installed and can be used as a virtual machine.</p></div></div><div class=sect3><h4 id=virtualization-host-xen-troubleshooting>21.8.4. 疑難排解<a class=anchor href=#virtualization-host-xen-troubleshooting></a></h4><div class=paragraph><p>This section contains basic information in order to help troubleshoot issues found when using FreeBSD as a Xen™ host or guest.</p></div><div class=sect4><h5 id=virtualization-host-xen-troubleshooting-host>21.8.4.1. 主端開機疑難排解<a class=anchor href=#virtualization-host-xen-troubleshooting-host></a></h5><div class=paragraph><p>Please note that the following troubleshooting tips are intended for Xen™ 4.11 or newer. If you are still using Xen™ 4.7 and having issues consider migrating to a newer version of Xen™.</p></div><div class=paragraph><p>In order to troubleshoot host boot issues you will likely need a serial cable, or a debug USB cable. Verbose Xen™ boot output can be obtained by adding options to the <code>xen_cmdline</code> option found in <span class=filename>loader.conf</span>. A couple of relevant debug options are:</p></div><div class=ulist><ul><li><p><code>iommu=debug</code>: can be used to print additional diagnostic information about the iommu.</p></li><li><p><code>dom0=verbose</code>: can be used to print additional diagnostic information about the dom0 build process.</p></li><li><p><code>sync_console</code>: flag to force synchronous console output. Useful for debugging to avoid losing messages due to rate limiting. Never use this option in production environments since it can allow malicious guests to perform DoS attacks against Xen™ using the console.</p></li></ul></div><div class=paragraph><p>FreeBSD should also be booted in verbose mode in order to identify any issues. To activate verbose booting, run this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf boot_verbose=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>If none of these options help solving the problem, please send the serial boot log to <a href=mailto:freebsd-xen@FreeBSD.org>freebsd-xen@FreeBSD.org</a> and <a href=mailto:xen-devel@lists.xenproject.org>xen-devel@lists.xenproject.org</a> for further analysis.</p></div></div><div class=sect4><h5 id=virtualization-host-xen-troubleshooting-guest>21.8.4.2. 客端建立疑難排解<a class=anchor href=#virtualization-host-xen-troubleshooting-guest></a></h5><div class=paragraph><p>Issues can also arise when creating guests, the following attempts to provide some help for those trying to diagnose guest creation issues.</p></div><div class=paragraph><p>The most common cause of guest creation failures is the <code>xl</code> command spitting some error and exiting with a return code different than 0. If the error provided is not enough to help identify the issue, more verbose output can also be obtained from <code>xl</code> by using the <code>v</code> option repeatedly.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl -vvv create freebsd.cfg</span>
Parsing config from freebsd.cfg
libxl: debug: libxl_create.c:1693:do_domain_create: Domain 0:ao 0x800d750a0: create: <span class=nv>how</span><span class=o>=</span>0x0 <span class=nv>callback</span><span class=o>=</span>0x0 <span class=nv>poller</span><span class=o>=</span>0x800d6f0f0
libxl: debug: libxl_device.c:397:libxl__device_disk_set_backend: Disk <span class=nv>vdev</span><span class=o>=</span>xvda spec.backend<span class=o>=</span>unknown
libxl: debug: libxl_device.c:432:libxl__device_disk_set_backend: Disk <span class=nv>vdev</span><span class=o>=</span>xvda, using backend phy
libxl: debug: libxl_create.c:1018:initiate_domain_create: Domain 1:running bootloader
libxl: debug: libxl_bootloader.c:328:libxl__bootloader_run: Domain 1:not a PV/PVH domain, skipping bootloader
libxl: debug: libxl_event.c:689:libxl__ev_xswatch_deregister: watch <span class=nv>w</span><span class=o>=</span>0x800d96b98: deregister unregistered
domainbuilder: detail: xc_dom_allocate: <span class=nv>cmdline</span><span class=o>=</span><span class=s2>&#34;&#34;</span>, <span class=nv>features</span><span class=o>=</span><span class=s2>&#34;&#34;</span>
domainbuilder: detail: xc_dom_kernel_file: <span class=nv>filename</span><span class=o>=</span><span class=s2>&#34;/usr/local/lib/xen/boot/hvmloader&#34;</span>
domainbuilder: detail: xc_dom_malloc_filemap    : 326 kB
libxl: debug: libxl_dom.c:988:libxl__load_hvm_firmware_module: Loading BIOS: /usr/local/shared/seabios/bios.bin
...</code></pre></div></div><div class=paragraph><p>If the verbose output does not help diagnose the issue there are also QEMU and Xen™ toolstack logs in <span class=filename>/var/log/xen</span>. Note that the name of the domain is appended to the log name, so if the domain is named <code>freebsd</code> you should find a <span class=filename>/var/log/xen/xl-freebsd.log</span> and likely a <span class=filename>/var/log/xen/qemu-dm-freebsd.log</span>. Both log files can contain useful information for debugging. If none of this helps solve the issue, please send the description of the issue you are facing and as much information as possible to <a href=mailto:freebsd-xen@FreeBSD.org>freebsd-xen@FreeBSD.org</a> and <a href=mailto:xen-devel@lists.xenproject.org>xen-devel@lists.xenproject.org</a> in order to get help.</p></div></div></div></div></div></div><div class=sect1><h2 id=l10n>Chapter 22. 在地化 - i18n/L10n 使用與安裝<a class=anchor href=#l10n></a></h2><div class=sectionbody><div class=sect2><h3 id=l10n-synopsis>22.1. 概述<a class=anchor href=#l10n-synopsis></a></h3><div class=paragraph><p>FreeBSD 計劃的使用者及貢獻者分佈在世界各地，也因此 FreeBSD 支援多語系，讓使用者可以使用非英文語言來檢視、輸入或處理資料。使用者可以選擇大多數主要語言，包含但不限於以下語言：中文、德文、日文、韓文、法文、俄文及越南文。</p></div><div class=paragraph><p><code>國際化</code> (Internationalization) 一詞可以縮寫為 i18n，即 第一個字母到最後一個字母間的字母數量。L10n 也使用同樣的命名規則，但源自 <code>在地化</code> (Localization)。 i18n/L10n 的方法、協定及應用程式讓使用者可以自己選擇使用的語言。</p></div><div class=paragraph><p>本章會討論 FreeBSD 的國際化及在地化功能。在閱讀本章之後，您會了解：</p></div><div class=ulist><ul><li><p>語系名稱如何組成。</p></li><li><p>如何設定登入 Shell 的語系。</p></li><li><p>如何設定 Console 給非英文語言的使用者。</p></li><li><p>如果設定 Xorg 使用不同語言。</p></li><li><p>如何找到支援 i18n 的應用程式。</p></li><li><p>那裡可以找到更多設定特定語言的資訊。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解如何 <a href=./#ports>安裝其他第三方應用程式</a>。</p></li></ul></div></div><div class=sect2><h3 id=using-localization>22.2. 使用語系<a class=anchor href=#using-localization></a></h3><div class=paragraph><p>語系設定值由三個元件所組成：語言代號、城市代號及編碼。語系名稱組成的方式如下：</p></div><div class="literalblock programlisting"><div class=content><pre>LanguageCode_CountryCode.Encoding</pre></div></div><div class=paragraph><p><em>LanguageCode</em> 與 <em>CountryCode</em> 用來表示城市及特定語言。<a href=#locale-lang-country>常用語言及城市代碼</a> 提供了幾個 <em>LanguageCode_CountryCode</em> 的範例：</p></div><table id=locale-lang-country class="tableblock frame-none grid-all stretch"><caption class=title>表 14. 常用語言及城市代碼</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">語言代號_城市代號</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>en_US</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>英文，美國</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ru_RU</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>俄文，俄國</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>zh_TW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>繁體中文，台灣</p></td></tr></tbody></table><div class=paragraph><p>完整可用的語系清單可用以下指令查詢：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% locale <span class=nt>-a</span> | more</code></pre></div></div><div class=paragraph><p>查詢目前使用的語系設定：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% locale</code></pre></div></div><div class=paragraph><p>語言特定的字元集如 ISO8859-1, ISO8859-15, KOI8-R 及 CP437 在 <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a> 有詳細說明。可用的字元集可在 <a href=http://www.iana.org/assignments/character-sets>IANA Registry</a> 查詢。</p></div><div class=paragraph><p>某些語言，如中文或日文，無法使用 ASCII 字元表示，會需要使用寬 (Wide) 字元或多位元組 (Multibyte) 字元來擴充的語言編碼。EUC 與 Big5 即是使用寬子元或多位元組字元的例子。舊的應用程式會誤判這些字元為控制字元，新的應用程式則通常可以辨識這些字元，依實作的需要，使用者可能需要開啟寬字元或多位元組字元支援或者使用正確的字元設定來編譯應用程式。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 使用 Xorg 相容的語系編碼。</p></div></td></tr></tbody></table></div><div class=paragraph><p>本節剩餘的部份將說明各種在 FreeBSD 系統上設定語系的方法。下一節將會探討如何尋找以及編譯使用 i18n 支援的應用程式。</p></div><div class=sect3><h4 id=setting-locale>22.2.1. 設定登入 Shell 的語系<a class=anchor href=#setting-locale></a></h4><div class=paragraph><p>語系設定可在使用者的 <span class=filename>~/.login_conf</span> 或使用者的 Shell 的啟動檔設定：<span class=filename>~/.profile</span>, <span class=filename>~/.bashrc</span> 或 <span class=filename>~/.cshrc</span>。</p></div><div class=paragraph><p>有兩個環境變數需要設定：</p></div><div class=ulist><ul><li><p><code>LANG</code> 用來設定語系</p></li><li><p><code>MM_CHARSET</code> 用來設定應用程式所使用的 MIME 字元集</p></li></ul></div><div class=paragraph><p>除了使用者的 Shell 設定外，這些變數也應針對特定應用程式設定以及 Xorg 設定。</p></div><div class=paragraph><p>兩種可以完成所需變數設定的方法有：<a href=#login-class>登入類別 (Login class)</a> 法 (較建議) 及 <a href=#startup-file>啟動檔 (Startup file) </a>法。以下兩節將示範如何使用這兩個方法。</p></div><div class=sect4><h5 id=login-class>22.2.1.1. 登入類別 (Login Class) 法<a class=anchor href=#login-class></a></h5><div class=paragraph><p>第一種方式，同時也是建議使用的方法，它可以對任何可能的 Shell 設定需要的語系及 MIME 字元集變數。此設定也可由每位使用者自行設定或者由超級管理者為所有使用者設定。</p></div><div class=paragraph><p>以下精簡範例示範在一個使用者的家目錄中的 <span class=filename>.login_conf</span> 設定 Latin-1 編碼使用的兩個環境變數：</p></div><div class="literalblock programlisting"><div class=content><pre>me:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:</pre></div></div><div class=paragraph><p>以下使用者的 <span class=filename>~/.login_conf</span> 範例設定了繁體中文於 BIG-5 編碼使用到的環境變數。有一部份應用程式無法正確處理中文、日文及韓文的語系變數，因此需要額外多做一些設定：</p></div><div class="literalblock programlisting"><div class=content><pre>#Users who do not wish to use monetary units or time formats
#of Taiwan can manually change each variable
me:\
	:lang=zh_TW.Big5:\
	:setenv=LC_ALL=zh_TW.Big5,LC_COLLATE=zh_TW.Big5,LC_CTYPE=zh_TW.Big5,LC_MESSAGES=zh_TW.Big5,LC_MONETARY=zh_TW.Big5,LC_NUMERIC=zh_TW.Big5,LC_TIME=zh_TW.Big5:\
	:charset=big5:\
	:xmodifiers=&#34;@im=gcin&#34;: #Set gcin as the XIM Input Server</pre></div></div><div class=paragraph><p>或者，超級使用者可以設定所有系統使用者的語系。以下在 <span class=filename>/etc/login.conf</span> 中的變數可用來設定語系及 MIME 字元集：</p></div><div class="literalblock programlisting"><div class=content><pre>language_name|Account Type Description:\
	:charset=MIME_charset:\
	:lang=locale_name:\
	:tc=default:</pre></div></div><div class=paragraph><p>若套用之前的 Latin-1 編碼範例如下：</p></div><div class="literalblock programlisting"><div class=content><pre>german|German Users Accounts:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:\
	:tc=default:</pre></div></div><div class=paragraph><p>請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> 以取得更多有關這些變數的詳細資訊。請注意，它已經含有預先定義的 <em>russian</em> class。</p></div><div class=paragraph><p>每次編輯 <span class=filename>/etc/login.conf</span> 之後，請記得要執行以下指令來更新登入類別的能力資料庫(Capability database)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class=sect5><h6 id=_變更登入類別的工具>22.2.1.1.1. 變更登入類別的工具<a class=anchor href=#_變更登入類別的工具></a></h6><div class=paragraph><p>除了手動編輯 <span class=filename>/etc/login.conf</span> 之外，尚有需多工具可用來為新建立的使用者設定語系。</p></div><div class=paragraph><p>當使用 <code>vipw</code> 來新增使用者時，可指定 <em>language</em> 來設定語系：</p></div><div class="literalblock programlisting"><div class=content><pre>user:password:1111:11:language:0:0:User Name:/home/user:/bin/sh</pre></div></div><div class=paragraph><p>當使用 <code>adduser</code> 來新增使用者時，可對所有使用者或指定的使用者事先設定預設的語言。</p></div><div class=paragraph><p>若所有新的使用者都使用同樣的語言，可在 <span class=filename>/etc/adduser.conf</span> 設定 <code>defaultclass=<em>language</em></code>。</p></div><div class=paragraph><p>要在建立使用者時覆蓋預設的設定，可在出現此提示時輸入需要的語系：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter login class: default <span class=o>[]</span>:</code></pre></div></div><div class=paragraph><p>或執行 <code>adduser</code> 時指定語系：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser -class language</span></code></pre></div></div><div class=paragraph><p>若使用 <code>pw</code> 來新增使用者，則可指定語系如下：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd user_name -L language</span></code></pre></div></div><div class=paragraph><p>To change the login class of an existing user, <code>chpass</code> can be used. Invoke it as superuser and provide the username to edit as the argument.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chpass user_name</span></code></pre></div></div></div></div><div class=sect4><h5 id=startup-file>22.2.1.2. Shell 啟動檔 (Startup File) 法<a class=anchor href=#startup-file></a></h5><div class=paragraph><p>第二種方法，較不建議使用，因每一種使用到的 Shell 都需要手動設定，而每一種 Shell 都有不同的設定檔以及語法。例如將一位使用者的 <code>sh</code> shell 設定為德語，需要將下列行加到 <span class=filename>~/.profile</span>，若要設定給使用該 Shell 的所有使用者則必須將下列行加到 <span class=filename>/etc/profile</span> 或 <span class=filename>/usr/shared/skel/dot.profile</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG
MM_CHARSET=ISO-8859-1; export MM_CHARSET</pre></div></div><div class=paragraph><p>然而，在 <code>csh</code> shell 所使用的設定檔名稱及語法不同。同樣的設定需加入下列行至 <span class=filename>~/.csh.login</span>, <span class=filename>/etc/csh.login</span> 或 <span class=filename>/usr/shared/skel/dot.login</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1
setenv MM_CHARSET ISO-8859-1</pre></div></div><div class=paragraph><p>更複雜一點的情況，Xorg 的 <span class=filename>~/.xinitrc</span> 語系設定會依使用的 Shell 而有所不同。第一個例子是針對 <code>sh</code> shell 而第二個則是針對 <code>csh</code> shell：</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG</pre></div></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1</pre></div></div></div></div><div class=sect3><h4 id=setting-console>22.2.2. Console 設定<a class=anchor href=#setting-console></a></h4><div class=paragraph><p>已有許多語系的字型可在 Console 使用，要查看可用的字型清單，可輸入 <code>ls /usr/shared/syscons/fonts</code>。要設定 Console 的字型，可在 <span class=filename>/etc/rc.conf</span> 指定去掉 <span class=filename>.fnt</span> 字尾的字型名稱 <em>font_name</em>：</p></div><div class="literalblock programlisting"><div class=content><pre>font8x16=font_name
font8x14=font_name
font8x8=font_name</pre></div></div><div class=paragraph><p>鍵盤對應表 (Keymap) 及螢幕對應表 (Screenmap) 用可加入下行到 <span class=filename>/etc/rc.conf</span> 來設定：</p></div><div class="literalblock programlisting"><div class=content><pre>scrnmap=screenmap_name
keymap=keymap_name
keychange=&#34;fkey_number sequence&#34;</pre></div></div><div class=paragraph><p>要查看可用的螢幕對應表，可輸入 <code>ls /usr/shared/syscons/scrnmaps</code>。在設定螢幕對應表 <em>screenmap_name</em> 時請去掉 <span class=filename>.scm</span> 字尾。在 VGA Adapter 的字型字元矩陣擴充位元 8 到位元 9 時會需要使用螢幕對應表與相關的字型對應來解決，因此若螢幕字型使用位元 8 的欄位，字母會移出虛擬繪圖區 (Pseudographics area)。</p></div><div class=paragraph><p>要查看可用的鍵盤對應表，可輸入 <code>ls /usr/shared/syscons/keymaps</code>。在設定鍵盤對應表 <em>keymap_name</em> 時請去掉 <span class=filename>.kbd</span> 字尾。若要不重開機測試鍵盤對應用可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdmap&amp;sektion=1&amp;format=html">kbdmap(1)</a>。</p></div><div class=paragraph><p><code>keychange</code> 項目用在當功能鍵序列無法定義在鍵盤對應表時，可設定對應選擇終對機類型的功能鍵。</p></div><div class=paragraph><p>接下來，在 <span class=filename>/etc/ttys</span> 為所有虛擬終端機項目設定正確的 Console 終端機類型。<a href=#locale-charset>已定義供特定字元集使用的終端機類型</a> 摘要了可用的終端機類型：</p></div><table id=locale-charset class="tableblock frame-none grid-all stretch"><caption class=title>表 15. 已定義供特定字元集使用的終端機類型</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">字元集</th><th class="tableblock halign-left valign-top">終端機類型</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-1 or ISO8859-15</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l7</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-R</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25r</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25u</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CP437 (VGA 預設值)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>US-ASCII</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25w</code></p></td></tr></tbody></table><div class=paragraph><p>對於使用寬字元或多位元組字元的語言，需從 Port 套件集安裝支援該語言的 Console。 可用的 Port 摘要在 <a href=#locale-console>Port 套件集中可用的 Console</a>。安裝完成之後，請參考 Port 的 <span class=filename>pkg-message</span> 或操作手冊來取得設定及使用說明。</p></div><table id=locale-console class="tableblock frame-none grid-all stretch"><caption class=title>表 16. Port 套件集中可用的 Console</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">語言</th><th class="tableblock halign-left valign-top">Port 位置</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>繁體中文 (BIG-5)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/big5con/>chinese/big5con</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中文/日文/韓文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/cce/>chinese/cce</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中文/日文/韓文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/zhcon/>chinese/zhcon</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/kon2/>chinese/kon2</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-14dot/>japanese/kon2-14dot</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-16dot/>japanese/kon2-16dot</a></p></td></tr></tbody></table><div class=paragraph><p>若在 <span class=filename>/etc/rc.conf</span> 有開啟 moused，可能會需要額外的設定。預設 <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> 驅動程式的滑鼠游標會佔用字元集 <code>0xd0</code>-<code>0xd3</code> 的範圍，若語言有使用到此範圍，可加入以下行到 <span class=filename>/etc/rc.conf</span> 來移動游標的範圍：</p></div><div class="literalblock programlisting"><div class=content><pre>mousechar_start=3</pre></div></div></div><div class=sect3><h4 id=_xorg_設定>22.2.3. Xorg 設定<a class=anchor href=#_xorg_設定></a></h4><div class=paragraph><p><a href=./#x11>X Window 系統</a> 會說明如何安裝並設定 Xorg。當要設定 Xorg 在地化時，可從 FreeBSD Port 套件集中取得其他可用的字型及輸入法。應用程式特定的 i18n 設定像是字型與選單，可以在 <span class=filename>~/.Xresources</span> 中調校且可允許使用者在圖型化應用程式選單檢視其所選擇的語言。</p></div><div class=paragraph><p>X 輸入法 (X Input Method, XIM) 協定是 Xorg 針對輸入非英語字元的標準。<a href=#locale-xim>可用的輸入法</a> 摘要了在 FreeBSD 套件集中可用的輸入法應用程式。也可使用其他如 Fcitx 及 Uim 應用程式。</p></div><table id=locale-xim class="tableblock frame-none grid-all stretch"><caption class=title>表 17. 可用的輸入法</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">語言</th><th class="tableblock halign-left valign-top">輸入法</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/gcin/>chinese/gcin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/ibus-chewing/>chinese/ibus-chewing</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/ibus-pinyin/>chinese/ibus-pinyin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/oxim/>chinese/oxim</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-fcitx/>chinese/scim-fcitx</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-pinyin/>chinese/scim-pinyin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-tables/>chinese/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-anthy/>japanese/ibus-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-mozc/>japanese/ibus-mozc</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-skk/>japanese/ibus-skk</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/im-ja/>japanese/im-ja</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kinput2/>japanese/kinput2</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-anthy/>japanese/scim-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-canna/>japanese/scim-canna</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka/>japanese/scim-honoka</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka-plugin-romkan/>japanese/scim-honoka-plugin-romkan</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka-plugin-wnn/>japanese/scim-honoka-plugin-wnn</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-prime/>japanese/scim-prime</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-skk/>japanese/scim-skk</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-tables/>japanese/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-tomoe/>japanese/scim-tomoe</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-uim/>japanese/scim-uim</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/skkinput/>japanese/skkinput</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/skkinput3/>japanese/skkinput3</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/uim-anthy/>japanese/uim-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/ibus-hangul/>korean/ibus-hangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/imhangul/>korean/imhangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/nabi/>korean/nabi</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/scim-hangul/>korean/scim-hangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/scim-tables/>korean/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>越南文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/vietnamese/xvnkb/>vietnamese/xvnkb</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>越南文</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/vietnamese/x-unikey/>vietnamese/x-unikey</a></p></td></tr></tbody></table></div></div><div class=sect2><h3 id=l10n-compiling>22.3. 尋找 i18n 應用程式<a class=anchor href=#l10n-compiling></a></h3><div class=paragraph><p>i18n 應用程式會使用 i18n 工具包做為程式庫開發。這讓開發人員可以寫一個簡單的檔案並翻譯顯示的選單及文字至各種語言。</p></div><div class=paragraph><p><a href=https://www.FreeBSD.org/ports/>FreeBSD Port 套件集</a>中含有許多內建支援寬字元或多位元組字元的應用程式可支援各種語言。該類型的應用程式在名稱上會註明 <code>i18n</code> 以易於辨識。雖然如此，但不一定支援您所需要的語言。</p></div><div class=paragraph><p>有一部份應用程式可以使用指定的字元集來編譯。通常會在 Port 的 <span class=filename>Makefile</span> 中設定，或者傳送參數給 configure。請參考各 FreeBSD Port 原始碼中的 i18n 說明文件以取得更多有關需要的設定值資訊或 Port 的 <span class=filename>Makefile</span> 來了解在編譯時有那些可以使用的編譯選項。</p></div></div><div class=sect2><h3 id=lang-setup>22.4. 特定語言的語系設定<a class=anchor href=#lang-setup></a></h3><div class=paragraph><p>This section provides configuration examples for localizing a FreeBSD system for the Russian language. It then provides some additional resources for localizing other languages.</p></div><div class=sect3><h4 id=ru-localize>22.4.1. 俄語 (KOI8-R 編碼)<a class=anchor href=#ru-localize></a></h4><div class=paragraph><p>This section shows the specific settings needed to localize a FreeBSD system for the Russian language. Refer to <a href=#using-localization>Using Localization</a> for a more complete description of each type of setting.</p></div><div class=paragraph><p>To set this locale for the login shell, add the following lines to each user’s <span class=filename>~/.login_conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>me:My Account:\
	:charset=KOI8-R:\
	:lang=ru_RU.KOI8-R:</pre></div></div><div class=paragraph><p>To configure the console, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>keymap=&#34;ru.utf-8&#34;
scrnmap=&#34;utf-82cp866&#34;
font8x16=&#34;cp866b-8x16&#34;
font8x14=&#34;cp866-8x14&#34;
font8x8=&#34;cp866-8x8&#34;
mousechar_start=3</pre></div></div><div class=paragraph><p>For each <code>ttyv</code> entry in <span class=filename>/etc/ttys</span>, use <code>cons25r</code> as the terminal type.</p></div><div class=paragraph><p>To configure printing, a special output filter is needed to convert from KOI8-R to CP866 since most printers with Russian characters come with hardware code page CP866. FreeBSD includes a default filter for this purpose, <span class=filename>/usr/libexec/lpr/ru/koi2alt</span>. To use this filter, add this entry to <span class=filename>/etc/printcap</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>lp|Russian local line printer:\
	:sh:of=/usr/libexec/lpr/ru/koi2alt:\
	:lp=/dev/lpt0:sd=/var/spool/output/lpd:lf=/var/log/lpd-errs:</pre></div></div><div class=paragraph><p>Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> for a more detailed explanation.</p></div><div class=paragraph><p>To configure support for Russian filenames in mounted MS-DOS™ file systems, include <code>-L</code> and the locale name when adding an entry to <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ad0s2      /dos/c  msdos   rw,-Lru_RU.KOI8-R 0 0</pre></div></div><div class=paragraph><p>Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> for more details.</p></div><div class=paragraph><p>To configure Russian fonts for Xorg, install the <a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/xorg-fonts-cyrillic/>x11-fonts/xorg-fonts-cyrillic</a> package. Then, check the <code>"Files"</code> section in <span class=filename>/etc/X11/xorg.conf</span>. The following line must be added <em>before</em> any other <code>FontPath</code> entries:</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath   &#34;/usr/local/lib/X11/fonts/cyrillic&#34;</pre></div></div><div class=paragraph><p>Additional Cyrillic fonts are available in the Ports Collection.</p></div><div class=paragraph><p>To activate a Russian keyboard, add the following to the <code>"Keyboard"</code> section of <span class=filename>/etc/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbLayout&#34;   &#34;us,ru&#34;
Option &#34;XkbOptions&#34;  &#34;grp:toggle&#34;</pre></div></div><div class=paragraph><p>Make sure that <code>XkbDisable</code> is commented out in that file.</p></div><div class=paragraph><p>For <code>grp:toggle</code> use <kbd>Right Alt</kbd>, for <code>grp:ctrl_shift_toggle</code> use <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Shift</kbd></span>. For <code>grp:caps_toggle</code> use <kbd>CapsLock</kbd>. The old <kbd>CapsLock</kbd> function is still available in LAT mode only using <span class=keyseq><kbd>Shift</kbd>+<kbd>CapsLock</kbd></span>. <code>grp:caps_toggle</code> does not work in Xorg for some unknown reason.</p></div><div class=paragraph><p>If the keyboard has "Windows™" keys, and some non-alphabetical keys are mapped incorrectly, add the following line to <span class=filename>/etc/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbVariant&#34; &#34;,winkeys&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The Russian XKB keyboard may not work with non-localized applications. Minimally localized applications should call a <code>XtSetLanguageProc (NULL, NULL, NULL);</code> function early in the program.</p></div></td></tr></tbody></table></div><div class=paragraph><p>See <a href=http://koi8.pp.ru/xwin.html>http://koi8.pp.ru/xwin.html</a> for more instructions on localizing Xorg applications. For more general information about KOI8-R encoding, refer to <a href=http://koi8.pp.ru/>http://koi8.pp.ru/</a>.</p></div></div><div class=sect3><h4 id=_其他特定語言資源>22.4.2. 其他特定語言資源<a class=anchor href=#_其他特定語言資源></a></h4><div class=paragraph><p>This section lists some additional resources for configuring other locales.</p></div><div class=dlist><dl><dt class=hdlist1>Traditional Chinese for Taiwan</dt><dd><p>The FreeBSD-Taiwan Project has a Chinese HOWTO for FreeBSD at <a href=http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/>http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/</a>.</p></dd><dt class=hdlist1>Greek Language Localization</dt><dd><p>A complete article on Greek support in FreeBSD is available <a href=https://www.FreeBSD.org/doc/el/articles/greek-language-support/>here</a>, in Greek only, as part of the official FreeBSD Greek documentation.</p></dd><dt class=hdlist1>Japanese and Korean Language Localization</dt><dd><p>For Japanese, refer to <a href=http://www.jp.FreeBSD.org/>http://www.jp.FreeBSD.org/</a>, and for Korean, refer to <a href=http://www.kr.FreeBSD.org/>http://www.kr.FreeBSD.org/</a>.</p></dd><dt class=hdlist1>Non-English FreeBSD Documentation</dt><dd><p>Some FreeBSD contributors have translated parts of the FreeBSD documentation to other languages. They are available through links on the <a href=https://www.FreeBSD.org/>FreeBSD web site</a> or in <span class=filename>/usr/shared/doc</span>.</p></dd></dl></div></div></div></div></div><div class=sect1><h2 id=updating-upgrading>Chapter 23. 更新與升級 FreeBSD<a class=anchor href=#updating-upgrading></a></h2><div class=sectionbody><div class=sect2><h3 id=updating-upgrading-synopsis>23.1. 概述<a class=anchor href=#updating-upgrading-synopsis></a></h3><div class=paragraph><p>FreeBSD 在每次的發佈之間持續在開發。有些人偏好正式發佈的版本，也有另一群人喜歡使用最新的開發版本。然而，即使是正式發佈的版本也時常會有安全性與其他緊急修復的更新，因此，無論使用哪種版本，FreeBSD 都提供所有必要的工具來讓系統能維持最新的版本，且讓各種版本都能簡單的升級。本章將說明如何追蹤開發版本的系統及讓 FreeBSD 系統維持最新版本的基本工具。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>如何使用 freebsd-update, Subversion 來維持 FreeBSD 系統為最新版。</p></li><li><p>如何比對已安裝系統與已知原始複本間的狀態。</p></li><li><p>如何使用 Subversion 或說明文件 Port 來維持已安裝的文件為新版。</p></li><li><p>兩種開發分支間的差異：FreeBSD-STABLE 與 FreeBSD-CURRENT。</p></li><li><p>如何重新編譯及重新安裝整個基礎系統 (Base system)。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>正確的設定網路連線 (<a href=./#advanced-networking>進階網路設定</a>)。</p></li><li><p>了解如何安裝其他第三方軟體 (<a href=./#ports>安裝應用程式：套件與 Port</a>)。</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>本章會經常使用 <code>svnlite</code> 來取得與更新 FreeBSD 原始碼。您也可以使用 <a class=package href=https://cgit.freebsd.org/ports/tree/devel/subversion/>devel/subversion</a> Port 或套件。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=updating-upgrading-freebsdupdate>23.2. FreeBSD 更新<a class=anchor href=#updating-upgrading-freebsdupdate></a></h3><div class=paragraph><p>隨時套用安全性更新以及升級到新發佈的作業系統版本對管理一個持續運作的系統是非常重要的任務，FreeBSD 內含可以執行這兩項任務的工具程式，叫做 <code>freebsd-update</code>。</p></div><div class=paragraph><p>這個工具程式支援使用 Binary 對 FreeBSD 做安全性與和錯誤更新，不需要手動編譯和安裝修補 (Patch) 或新核心。目前由安全性團隊提供支援的 Binary 更新可用於所有的架構和發行版。支援的發行版清單及各自的支援期限列於 <a href=https://www.FreeBSD.org/security/>https://www.FreeBSD.org/security/</a>。</p></div><div class=paragraph><p>這個工具程式也支援升級作業系統到次要的發佈版以及升級到另一個發佈版分支。在升級到新的發佈版本前，需先查看該版本的發佈公告，因為發行公告中包含了該發行版本的相關重要資訊。發行公告可自 <a href=https://www.FreeBSD.org/releases/>https://www.FreeBSD.org/releases/</a> 取得。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>如果有使用 <code>crontab</code> 來執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a>，則必須在升級作業系統前先關閉。</p></div></td></tr></tbody></table></div><div class=paragraph><p>本節將說明 <code>freebsd-update</code> 使用的設定檔， 示範如何套用安全性修補及如何升級到主要或次要的作業系統發行版，並討論升級作業系統的需要考量的事項。</p></div><div class=sect3><h4 id=freebsdupdate-config-file>23.2.1. 設定檔<a class=anchor href=#freebsdupdate-config-file></a></h4><div class=paragraph><p><code>freebsd-update</code> 預設的設定檔不需變更即可運作。 部份使用者可能會想要調校位於 <span class=filename>/etc/freebsd-update.conf</span> 的預設設定檔來對程序有更好的控制。該設定檔中的註解均有說明可用的選項，但以下幾個項目可能需要進一步的說明：</p></div><div class="literalblock programlisting"><div class=content><pre># Components of the base system which should be kept updated.
Components world kernel</pre></div></div><div class=paragraph><p>這個參數控制 FreeBSD 要保持最新版本的部份。 預設是更新整個基礎系統 (Base system) 和核心。 可指定個別元件，例如：<code>src/base</code> 或 <code>src/sys</code>。 雖然如此，最好的選項是維持預設值，因為更改指定特定項目時需列出每一個需要的項目。時間一久可能會因為原始碼和 Binary 檔案沒有更新而造成慘重的後果。</p></div><div class="literalblock programlisting"><div class=content><pre># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths /boot/kernel/linker.hints</pre></div></div><div class=paragraph><p>要保持特定的目錄在更新過程不被更動，例如 <span class=filename>/bin</span> 或 <span class=filename>/sbin</span>，可以將他們的路徑加到此敘述中。 這個選項可以防止 <code>freebsd-update</code> 覆蓋本地的修改。</p></div><div class="literalblock programlisting"><div class=content><pre># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</pre></div></div><div class=paragraph><p>這個選項只會更新特定目錄中未修改的設定檔。任何使用者修改的檔案都不會自動更新。 有另一個選項 <code>KeepModifiedMetadata</code> 可讓 <code>freebsd-update</code> 在合併時儲存使用者做的變更。</p></div><div class="literalblock programlisting"><div class=content><pre># When upgrading to a new FreeBSD release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints</pre></div></div><div class=paragraph><p>列出 <code>freebsd-update</code> 應嘗試合併的設定檔目錄。 檔案合併程序是指一系列類似 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 做的 <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> 修補動作， 但是選項比較少。 合併的動作包含接受、開啟編輯器，或讓 <code>freebsd-update</code> 中止。 如果有疑慮，請先備份 <span class=filename>/etc</span>，然後再接受合併。 更多關於 <code>mergemaster</code> 的資訊， 參見 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a>。</p></div><div class="literalblock programlisting"><div class=content><pre># Directory in which to store downloaded updates and temporary
# files used by FreeBSD Update.
# WorkDir /var/db/freebsd-update</pre></div></div><div class=paragraph><p>這個目錄是所有修補檔和暫存檔的存放處。當使用者進行版本升級時，這個位置應該要有至少 1GB 的可用磁碟空間。</p></div><div class="literalblock programlisting"><div class=content><pre># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which FreeBSD Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</pre></div></div><div class=paragraph><p>當這個選項設定為 <code>yes</code> 時，<code>freebsd-update</code> 將會假設 <code>Components</code> 清單已完成，將不會對清單之外的項目做變更。 實際上 <code>freebsd-update</code> 會將嘗試更新每一個屬於 <code>Components</code> 清單中的檔案。</p></div></div><div class=sect3><h4 id=freebsdupdate-security-patches>23.2.2. 套用安全性修補<a class=anchor href=#freebsdupdate-security-patches></a></h4><div class=paragraph><p>套用 FreeBSD 安全性修補的過程已經被簡化，讓系統管理員可使用 <code>freebsd-update</code> 來保持系統更新。更多有關 FreeBSD 安全性報告的資訊可以參考 <a href=./#security-advisories>FreeBSD 安全報告</a>。</p></div><div class=paragraph><p>FreeBSD 安全性修補可以使用以下指令下載並安裝。 第一個指令會偵測是否有可用的修補，如果有，將列出若執行修補後會變更的檔案清單。第二個指令將會套用修補。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update fetch</span>
<span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>如果更新套用了任何核心修補，系統將會需要重新開機以使用修補過的核心。如果修補套用在任何執行中的 Binary，受影響的應用程式應重新啟動來使用修補過的 Binary 版本。</p></div><div class=paragraph><p>加入以下項目至 <span class=filename>/etc/crontab</span> 可設定系統每天自動檢查更新一次：</p></div><div class="literalblock programlisting"><div class=content><pre>@daily                                  root    freebsd-update cron</pre></div></div><div class=paragraph><p>如果有新的修補，該程式會會自動下載，但不會執行。<code>root</code> 使用者會收到電子郵件通知複查該修補並手動執行 <code>freebsd-update install</code> 安裝。</p></div><div class=paragraph><p>如果有發生任何錯誤，<code>freebsd-update</code> 可以使用以下指令還原最後所做的變更：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update rollback</span>
Uninstalling updates... <span class=k>done</span>.</code></pre></div></div><div class=paragraph><p>再次強調，若核心或任何核心模組有做過修改應重新啟動系統，以及任何受影響的 Binary 應重新執行。</p></div><div class=paragraph><p>只有 <span class=filename>GENERIC</span> 核心可使用 <code>freebsd-update</code> 自動更新。 如果有安裝自訂的核心，在 <code>freebsd-update</code> 完成安裝更新後，需要重新編譯和重新安裝。 預設的核心名稱為 <em>GENERIC</em>，可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> 指令來檢查安裝的核心。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>隨時在 <span class=filename>/boot/GENERIC</span> 保留一份 <span class=filename>GENERIC</span> 核心的複本將有助於診斷各種問題及執行版本升級。請參考 <a href=#freebsd-update-custom-kernel-9x>在 FreeBSD 9.X 及之後版本自訂核心</a> 來了解有關如何取得 <span class=filename>GENERIC</span> 核心的複本說明。</p></div></td></tr></tbody></table></div><div class=paragraph><p>除非在 <span class=filename>/etc/freebsd-update.conf</span> 的預設設定檔被修改，否則 <code>freebsd-update</code> 將會安裝更新後的核心原始碼和其餘的更新，可依平常的方式執行重新編譯與重新安裝核心。</p></div><div class=paragraph><p>以 <code>freebsd-update</code> 發行的更新並非總是會更新核心。若核心的原始碼沒有被 <code>freebsd-update install</code> 修改則不需要重新編譯自訂的核心。雖然如此 <code>freebsd-update</code> 總是會更新 <span class=filename>/usr/src/sys/conf/newvers.sh</span>，目前修補的版本如 <code>uname -r</code> 執行結果中的 <code>-p</code> 數字，便是由該檔取得。即使沒有做任何其他變更，重新編譯自訂核心可讓 <code>uname</code> 準確的回報系統目前的修補版本。當維護多個系統時這會特別有用，因其可讓你快速評估每個系統安裝的更新。</p></div></div><div class=sect3><h4 id=freebsdupdate-upgrade>23.2.3. 執行主要及次要版號升級<a class=anchor href=#freebsdupdate-upgrade></a></h4><div class=paragraph><p>從 FreeBSD 的次要版本升級到另一個版本，例如從 FreeBSD 9.0 到 FreeBSD 9.1, 叫作 <em>次要版本 (Minor version)</em> 更新。 <em>主要版本 (Major version)</em> 更新發生在當 FreeBSD 從一個主要版本升級到主要版本升級到另一個主要版本時，例如從 FreeBSD 9.X 到 FreeBSD 10.X。 兩種更新都可以透過提供 <code>freebsd-update</code> 目標的發佈版本來執行。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>如果系統正在執行自訂的核心，請在開始升級前，確定有保留一份 <span class=filename>GENERIC</span> 核心的複本在 <span class=filename>/boot/GENERIC</span>。 請參考 <a href=#freebsd-update-custom-kernel-9x>在 FreeBSD 9.X 及之後版本自訂核心</a> 關於如何取得 <span class=filename>GENERIC</span> 核心複本的說明。</p></div></td></tr></tbody></table></div><div class=paragraph><p>在 FreeBSD 9.0 系統執行以下指令，將會把系統升級至 FreeBSD 9.1：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -r 9.1-RELEASE upgrade</span></code></pre></div></div><div class=paragraph><p>收到這個指令後，<code>freebsd-update</code> 會開始評估設定檔和目前的系統來收集升級所需的資訊。 螢幕會顯示偵測到或沒偵測到的元件清單。例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature <span class=k>for </span>9.0-RELEASE from update1.FreeBSD.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata index... <span class=k>done</span><span class=nb>.</span>
Inspecting system... <span class=k>done</span><span class=nb>.</span>

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD <span class=k>do </span>not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable <span class=o>(</span>y/n<span class=o>)</span>? y</code></pre></div></div><div class=paragraph><p>此時，<code>freebsd-update</code> 將會嘗試下載所有升級需要的檔案。 在某些情況，會詢問使用者一些關於要安裝什麼或要如何繼續。</p></div><div class=paragraph><p>當使用自訂核心，上述的步驟將會產生如下的警告：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>WARNING: This system is running a <span class=s2>&#34;MYKERNEL&#34;</span> kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running <span class=s2>&#34;/usr/sbin/freebsd-update install&#34;</span></code></pre></div></div><div class=paragraph><p>這時的警告可以安全地忽略，升級過程將會使用更新過的 <span class=filename>GENERIC</span> 核心來進行。</p></div><div class=paragraph><p>所有的修補都下載到本地系統之後， 將會開始套用更新。這個過程可能會花點時間，取決於機器的速度和工作量。設定檔將會被合併。 合併的過程中當檔案被合併或是手動合併畫面上出現編輯器時需要使用者操作。 每一個成功合併的結果將會顯示給使用者並繼續程序，失敗或忽略合併將會使程序中斷。使用者可能想要備份 <span class=filename>/etc</span> 並稍後手動合併重要的檔案，例如：<span class=filename>master.passwd</span> 或 <span class=filename>group</span>。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>所有的修補與合併動作會在另一個目錄進行，並不會直接修改。當成功套用所有修補，所有設定檔已合併且過程順利，使用者可使用以下指令將變更安裝到磁碟：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>核心與核心模組會先修補，若系統正在執行自訂的核心，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=nextboot&amp;sektion=8&amp;format=html">nextboot(8)</a> 來設定下次開機使用更新過的 <span class=filename>/boot/GENERIC</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nextboot -k GENERIC</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>若機器在遠端進行更新，請在使用 <span class=filename>GENERIC</span> 核心重新開機前，請確定該核心含有所有系統所需的驅動程式以正常開機並連線至網路。特別是在執行的自訂核心有使用到由核心模組提供內建功能，請確定將這些模組已暫時使用 <span class=filename>/boot/loader.conf</span> 設定檔載入到 <span class=filename>GENERIC</span> 核心。建議關閉非必須的服務和磁碟與網路掛載直到升級程序完成。</p></div></td></tr></tbody></table></div><div class=paragraph><p>機器現在應使用更新過的核心重新開機：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>一旦系統重新上線，使用以下指令繼續 <code>freebsd-update</code>。 由於程序的狀態已被儲存，<code>freebsd-update</code> 不會重頭開始，但會進行下一個階段並移除所有舊的共用程式庫和目標檔。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>取決於是否有任何程式庫版本編號衝突，也可能只有兩個而不是三個安裝階段。</p></div></td></tr></tbody></table></div><div class=paragraph><p>升級程序現在完成了。如果所做的是主要的版本升級，則需依 <a href=#freebsdupdate-portsrebuild>主要版號升級後的套件升級</a> 的說明重新安裝所有的 Port 和套件。</p></div><div class=sect4><h5 id=freebsd-update-custom-kernel-9x>23.2.3.1. 在 FreeBSD 9.X 及之後版本自訂核心<a class=anchor href=#freebsd-update-custom-kernel-9x></a></h5><div class=paragraph><p>在使用 <code>freebsd-update</code> 前，請確定已有 <span class=filename>GENERIC</span> 核心的複本於 <span class=filename>/boot/GENERIC</span>。若只編譯過一次自訂核心，那麼 <span class=filename>/boot/kernel.old</span> 就是 <code>GENERIC</code> 核心，只需要將該目錄重新命名為 <span class=filename>/boot/kernel</span>。</p></div><div class=paragraph><p>若有編譯自訂核心過超過一次，或已經不曉得編譯自訂核心的次數，則需取得與目前作業系統版本相符的 <code>GENERIC</code> 核心複本。若可直接操作實體系統，則可以從安裝媒體取得 <code>GENERIC</code> 核心複本：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span>
<span class=c># cd /cdrom/usr/freebsd-dist</span>
<span class=c># tar -C/ -xvf kernel.txz boot/kernel/kernel</span></code></pre></div></div><div class=paragraph><p>或者，可以從原始碼重新編譯 <code>GENERIC</code> 核心：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</span></code></pre></div></div><div class=paragraph><p>這個核心要被 <code>freebsd-update</code> 認做 <code>GENERIC</code> 核心，<span class=filename>GENERIC</span> 設定檔必須不能做任何修改，也建議在編譯核心時不要使用其他特殊選項。</p></div><div class=paragraph><p><code>freebsd-update</code> 僅需要 <span class=filename>/boot/GENERIC</span> 存在便可，因此不須重新開機進入 <span class=filename>GENERIC</span>。</p></div></div><div class=sect4><h5 id=freebsdupdate-portsrebuild>23.2.3.2. 主要版號升級後的套件升級<a class=anchor href=#freebsdupdate-portsrebuild></a></h5><div class=paragraph><p>一般來說，已安裝的應用程式在次要版本升級仍可沒問題的正常執行。但主要版本升級會採用不同的應用程式 Binary 介面 (Application Binary Interfaces, ABIs)，會導致大部份第三方應用程式無法正常執行。 因此在主要版本升級後，需要升及所有已安裝的套件和 Port，套件可以使用 <code>pkg upgrade</code> 來升級，而 Port 則需使用 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> 工具。</p></div><div class=paragraph><p>強制升級所有已安裝的套件會使用檔案庫中新版本的套件來取得目前套件，即使該版號沒有增加。由於在升級 FreeBSD 主要版本時會變更 ABI 版本，因此這是必要動作。強制升級可以執行以下指令來完成：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg-static upgrade -f</span></code></pre></div></div><div class=paragraph><p>重新編譯所有已安裝的應用程式可以執行以下指令來完成：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>這個指令會在安裝每個應用程式有可設定選項時顯示設定畫面，並會等待使用者操作該畫面，要避免這種情況並使用預設的設定選項，可在上述指令加上 <code>-G</code> 參數。</p></div><div class=paragraph><p>完成軟體升級後，最後需執行 <code>freebsd-update</code> 來完成最後的升級動作：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>若有使用臨時 <span class=filename>GENERIC</span> 核心，便應在此時依據 <a href=./#kernelconfig>設定 FreeBSD 核心</a> 的說明編譯並安裝新的自訂核心。</p></div><div class=paragraph><p>重新開機使用新的 FreeBSD 版本後，升級程序便正式完成。</p></div></div></div><div class=sect3><h4 id=freebsdupdate-system-comparison>23.2.4. 比對系統狀態<a class=anchor href=#freebsdupdate-system-comparison></a></h4><div class=paragraph><p>已安裝的 FreeBSD 版本狀態可以使用 <code>freebsd-update IDS</code> 與另一個已知良好的複本來做比對測試。 這個指令會評估目前版本的系統工具，程式庫和設定檔，可做為內建的入侵偵測系統來使用 (Intrusion Detection System, IDS)。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>這個指令並非用來取代真正的 IDS，如 <a class=package href=https://cgit.freebsd.org/ports/tree/security/snort/>security/snort</a>。由於 <code>freebsd-update</code> 儲存在磁碟上，被竄改的可能性是顯而易見的，雖然這個可能性會因使用 <code>kern.securelevel</code> 以及將 <code>freebsd-update</code> 在不使用時以唯讀儲存而降低，最好的解決方案是能夠與安全的磁碟，如 DVD 或儲存在外部的 USB 磁碟裝置比對系統。替代的方式是使用內建工具的 IDS 功能，在 <a href=./#security-ids>Binary 檢驗</a> 有詳細說明</p></div></td></tr></tbody></table></div><div class=paragraph><p>要開始比對，需指定輸出的檔案來儲存結果：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update IDS &gt;&gt; outfile.ids</span></code></pre></div></div><div class=paragraph><p>系統將會開始檢查並且會產生相當長的檔案清單，內容包含發佈版本已知的與目前安裝版本的 SHA256 雜湊值會儲存到指定的輸出檔。</p></div><div class=paragraph><p>清單中的項目會相當的多，但輸出的格式可以很簡單的用來分析。例如，要取得與發佈版本不同的檔案清單，可使用以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat outfile.ids | awk &#39;{ print $1 }&#39; | more</span>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</code></pre></div></div><div class=paragraph><p>實際的檔案會更多，此範例的輸出已精簡。部份檔案可能本來就會被修改。例如 <span class=filename>/etc/passwd</span> 在新增使用者到系統時會被修改，核心模組也有可能因使用 <code>freebsd-update</code> 更新而有所不同。要排除特定的檔案或目錄可將這些檔案或目錄加入到 <span class=filename>/etc/freebsd-update.conf</span> 中的 <code>IDSIgnorePaths</code> 選項。</p></div></div></div><div class=sect2><h3 id=updating-upgrading-documentation>23.3. 更新文件集<a class=anchor href=#updating-upgrading-documentation></a></h3><div class=paragraph><p>說明文件是 FreeBSD 作業系統不可或缺的一部份。最新版本的 FreeBSD 文件除了可在 FreeBSD 網站 (<a href=https://www.FreeBSD.org/doc/>https://www.freebsd.org/doc/</a>) 取得，也可很簡單的取得本地的 FreeBSD 網站、使用手冊、FAQ 及文章副本。</p></div><div class=paragraph><p>本節將說明如何使用原始碼與 FreeBSD Port 套件集來取得最新版本 FreeBSD 文件本地複本。</p></div><div class=paragraph><p>有關編輯與提出修正說明文件的資訊，請參考 FreeBSD 文件計畫入門書 (<a href=https://docs.freebsd.org/zh-tw/books/fdp-primer/>FreeBSD Documentation Project Primer</a>)。</p></div><div class=sect3><h4 id=updating-installed-documentation>23.3.1. 自原始碼更新說明文件<a class=anchor href=#updating-installed-documentation></a></h4><div class=paragraph><p>從原始碼重新編譯 FreeBSD 文件需要一些不屬於 FreeBSD 基礎系統的工具。需要的工具可安裝由 FreeBSD 文件計劃所開發的 <a class=package href=https://cgit.freebsd.org/ports/tree/textproc/docproj/>textproc/docproj</a> 套件或 Port。</p></div><div class=paragraph><p>安裝完成之後，可使用 svnlite 來取得乾淨的文件原始碼複本：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite checkout https://svn.FreeBSD.org/doc/head /usr/doc</span></code></pre></div></div><div class=paragraph><p>第一次下載文件原始碼需要一些時間，請耐心等候執行完畢。</p></div><div class=paragraph><p>往後更新文件原始碼可執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite update /usr/doc</span></code></pre></div></div><div class=paragraph><p>下載最新的文件原始碼到 <span class=filename>/usr/doc</span> 之後，便完成要更新已安裝文件的準備動作。</p></div><div class=paragraph><p>完整更新所有可用的語言可以執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>若只想要更新特定語言，可對 <span class=filename>/usr/doc</span> 中特定語言的子目錄執行 <code>make</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc/en_US.ISO8859-1</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>另一個更新文件的方式是在 <span class=filename>/usr/doc</span> 或特定的語言子目錄下執行此指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make update</span></code></pre></div></div><div class=paragraph><p>要指定安裝的輸出格式可使用 <code>FORMATS</code> 來設定：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make FORMATS=&#39;html html-split&#39; install clean</span></code></pre></div></div><div class=paragraph><p>有數個選項可更新部份文件或只編譯特定翻譯來簡化更新程序。這些選項可在 <span class=filename>/etc/make.conf</span> 設為系統全域的預設選項，或是透過指令傳送給 <code>make</code>。</p></div><div class=paragraph><p>選項有：</p></div><div class=dlist><dl><dt class=hdlist1><code>DOC_LANG</code></dt><dd><p>要編譯與安裝的語言及編碼清單，例如 <code>en_US.ISO8859-1</code> 代表英語文件。</p></dd><dt class=hdlist1><code>FORMATS</code></dt><dd><p>要編譯的輸出格式清單，目前支援 <code>html</code>, <code>html-split</code>, <code>txt</code>, <code>ps</code> 以及 <code>pdf</code>。</p></dd><dt class=hdlist1><code>DOCDIR</code></dt><dd><p>要安裝文件的位置，預設為 <span class=filename>/usr/shared/doc</span>。</p></dd></dl></div><div class=paragraph><p>要取得更多可做為 FreeBSD 系統全域選項的 <code>make</code> 變數，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a>。</p></div></div><div class=sect3><h4 id=doc-ports-install-package>23.3.2. 自 Port 更新說明文件<a class=anchor href=#doc-ports-install-package></a></h4><div class=paragraph><p>前一節介紹了由原始碼更新 FreeBSD 文件的方法，本節將說明使用 Port 套件集的替代方法，可由以下方式達成：</p></div><div class=ulist><ul><li><p>安裝事先編譯好的文件套件，無須在本地編譯任何東西或安裝文件工具集。</p></li><li><p>使用 Port 框架來編譯文件原始碼，可讓取得與編譯文件的步驟更簡單。</p></li></ul></div><div class=paragraph><p>這個更新 FreeBSD 文件的方法，會使用到一系列由文件工程團隊 <a href=mailto:doceng@FreeBSD.org>doceng@FreeBSD.org</a> 每月更新的文件 Port 與套件。這些套件列於 FreeBSD Port 套件集的 docs 分類下 (<a href=http://www.freshports.org/docs/>http://www.freshports.org/docs/</a>)。</p></div><div class=paragraph><p>文件 Port 的組織方式如下：</p></div><div class=ulist><ul><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-en/>misc/freebsd-doc-en</a> 套件或 Port 會安裝所有英語的文件。</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-all/>misc/freebsd-doc-all</a> 套件或 Port 會安裝所有可用語言的文件。</p></li><li><p>每個翻譯語言都有套件與 Port，如 <a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-hu/>misc/freebsd-doc-hu</a> 為匈牙利語文件。</p></li></ul></div><div class=paragraph><p>當使用 Binary 套件時，會安裝指定語言 FreeBSD 文件的所有可用格式。例如以下指令會安裝最新的匈牙利語文件套件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install hu-freebsd-doc</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>套件使用的名稱格式與 Port 的名稱不同：<code><em>lang</em>-freebsd-doc</code>，其中 <em>lang</em> 是語言代碼的縮寫，例如 <code>hu</code> 代表匈牙利語，<code>zh_cn</code> 代表簡體中文。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要指定文件的格式，需以編譯 Port 來代替安裝套件。例如要編譯並安裝英語文件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/misc/freebsd-doc-en</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Port 提供設定選單來指定要編譯與安裝的格式，預設會選擇分頁的 HTML (類似 <a href=http://www.FreeBSD.org>http://www.FreeBSD.org</a> 使用的格式) 以及 PDF。</p></div><div class=paragraph><p>此外，編譯文件 Port 時也可指定數個 <code>make</code> 選項，包括：</p></div><div class=dlist><dl><dt class=hdlist1><code>WITH_HTML</code></dt><dd><p>編譯一份文件使用一個 HTML 檔的 HTML 格式。格式化後的文件會儲存至名稱為 <span class=filename>article.html</span> 或 <span class=filename>book.html</span> 的檔案。</p></dd><dt class=hdlist1><code>WITH_PDF</code></dt><dd><p>格式化的文件會儲存至名稱為 <span class=filename>article.pdf</span> 或 <span class=filename>book.pdf</span> 的檔案。</p></dd><dt class=hdlist1><code>DOCBASE</code></dt><dd><p>指定要安裝文件的位置，預設為 <span class=filename>/usr/local/shared/doc/freebsd</span>。</p></dd></dl></div><div class=paragraph><p>以下範例使用變數來安裝 PDF 的匈牙利語文件到特定目錄：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/misc/freebsd-doc-hu</span>
<span class=c># make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</span></code></pre></div></div><div class=paragraph><p>文件套件或 Port 可以依 <a href=./#ports>安裝應用程式：套件與 Port</a> 的說明更新。例如以下指令會使用 <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> 更新已安裝的匈牙利語文件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -PP hu-freebsd-doc</span></code></pre></div></div></div></div><div class=sect2><h3 id=current-stable>23.4. 追蹤開發分支<a class=anchor href=#current-stable></a></h3><div class=paragraph><p>FreeBSD 有兩個開發分支：FreeBSD-CURRENT 及 FreeBSD-STABLE。</p></div><div class=paragraph><p>本節將說明每個分支及其的特定使用者，也會說明如何在各別分支維持系統為最新版。</p></div><div class=sect3><h4 id=current>23.4.1. 使用 FreeBSD-CURRENT<a class=anchor href=#current></a></h4><div class=paragraph><p>FreeBSD-CURRENT 是 FreeBSD 開發的 "最前線"，FreeBSD-CURRENT 的使用者需具備較強的技術能力。技術能力較弱的使用者應改追蹤 FreeBSD-STABLE 開發分支。</p></div><div class=paragraph><p>FreeBSD-CURRENT 是 FreeBSD 最新的原始碼，其中包括正在進行的開發工作、實驗性的變更以及不一定會在下一個官方發行版出現的過渡機制。 雖然 FreeBSD 開發者每天編譯 FreeBSD-CURRENT 原始碼，但仍可能有短暫時間原始碼是無法編譯的。雖然這些問題會儘快被解決，但是無論 FreeBSD-CURRENT 帶來災難或是新功能，同步原始碼時都要考量這個問題。</p></div><div class=paragraph><p>FreeBSD-CURRENT 主要給下以三種族群：</p></div><div class="olist arabic"><ol class=arabic><li><p>致力於開發某一部份原始碼樹的 FreeBSD 社群成員。</p></li><li><p>FreeBSD 社群成員中活耀的測試人員。 他們願意花時間解決問題，對 FreeBSD 的變更及大方向提出專業建議並送交修補。</p></li><li><p>隨時關注的使用者，使用目前原始碼做為參考用途，或是偶爾提供意見或貢獻原始碼。</p></li></ol></div><div class=paragraph><p><em>不應</em>將 FreeBSD-CURRENT 當做下一個發行版前取得新功能的快速途徑，因為尚未發行的功能並未被完整測試，很可能有問題。這也不是一個快速取得問題修正的方式，因為任何已知的問題修正有可能產生新的問題。 使用 FreeBSD-CURRENT 不在 "官方支援" 的範圍內。</p></div><div class=paragraph><p>若要追蹤 FreeBSD-CURRENT：</p></div><div class="olist arabic"><ol class=arabic><li><p>加入 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>freebsd-current</a> 和 <a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-head>svn-src-head</a> 郵遞論壇。這是 <em>重要</em> 的，是為了要了解目前人們對於系統目前狀態的評論並接收有關 FreeBSD-CURRENT 目前狀態的重要公告。</p><div class=paragraph><p><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-head>svn-src-head</a> 郵遞論壇會記錄每一次修改的提交項目，以及可能產生的副作用的相關資訊。</p></div><div class=paragraph><p>要加入這兩個郵遞論壇，請前往 <a href=http://lists.FreeBSD.org/mailman/listinfo>http://lists.FreeBSD.org/mailman/listinfo</a> 點選要訂閱的郵遞論壇，並依照網頁指示的步驟操作。要追蹤整個原始碼樹，不單只有 FreeBSD-CURRENT 的變更，可訂閱 <a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-all>svn-src-all</a> 郵遞論壇。</p></div></li><li><p>同步 FreeBSD-CURRENT 原始碼。 通常會使用 <a href=./#svn>svnlite</a> 自列於 <a href=./#svn-mirrors>Subversion 鏡像站</a> 中的其中一個 Subversion 鏡像站的 <code>head</code> 分支中取出 -CURRENT 的程式碼。</p></li><li><p>考量到檔案庫的大小，部份使用者選擇只同步他們有興趣或貢獻修補的部份原始碼。然而， 計劃要從原始碼編譯整個作業系統的使用者須下載 <em>全部</em> 的 FreeBSD-CURRENT，不可只有選擇的部份。</p><div class=paragraph><p>編譯 FreeBSD-CURRENT 前，請仔細地閱讀 <span class=filename>/usr/src/Makefile</span> 並依照 <a href=#makeworld>從原始碼更新 FreeBSD</a> 的指示操作。 閱讀 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>FreeBSD-CURRENT 郵遞論壇</a> 以及 <span class=filename>/usr/src/UPDATING</span> 來了解升級的相關資訊，有時會含有升級下一個發行版的必要資訊。</p></div></li><li><p>要活躍！我們非常鼓勵 FreeBSD-CURRENT 的使用者發表他們對加強哪些功能或是修復哪些錯誤的建議。 如果您在建議時能附上相關程式碼的話，是最好的。</p></li></ol></div></div><div class=sect3><h4 id=stable>23.4.2. 使用 FreeBSD-STABLE<a class=anchor href=#stable></a></h4><div class=paragraph><p>FreeBSD-STABLE 是一個開發分支，會在主要的版本更新後產生，進入這個分支的步伐會比較緩慢，而且通常會假定已經在 FreeBSD-CURRENT 中做過測試，所以問題會比較少，但這<em>仍然</em>是一個開發分支，在任何時間點，FreeBSD-STABLE 中的原始碼不能保証能供一般使用，它只是另一個開發支線，並不是供最終使用者使用的資源，若沒有任何資源可以做測試的使用者應改使用最新版本的 FreeBSD 發佈版。</p></div><div class=paragraph><p>對於那些有興趣追蹤或為 FreeBSD 開發流程提供一些貢獻的人，特別是針對下一個主要發佈版的 FreeBSD，應該考慮追蹤 FreeBSD-STABLE。</p></div><div class=paragraph><p>雖然 FreeBSD-STABLE 分支應該已經做過編譯並執行過，但這仍然無法保証不會出任何問題。由於使用 FreeBSD-STABLE 的人比 FreeBSD-CURRENT 更多，因此不可避免的，有時仍會在 FreeBSD-STABLE 中發現未在 FreeBSD-CURRENT 中出現的問題與特殊狀況。基於這個原因，任何人都不應盲目的追蹤 FreeBSD-STABLE，特別重要的是 <em>不</em> 要將任何產線上的伺服器更新成未經開發或測試環境中測試過的 FreeBSD-STABLE。</p></div><div class=paragraph><p>若要追蹤 FreeBSD-STABLE：</p></div><div class="olist arabic"><ol class=arabic><li><p>加入 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-stable>freebsd-stable</a> 郵遞論壇來隨時了解 FreeBSD-STABLE 可能需要的編譯相依項目或任何需要特別注意的問題，當有一些有爭議的修復或更新時，開發人員也會在郵遞論壇中公告，如果有使用者對所提出的更改有任何的疑慮，可讓使用者有機會能反應問題。</p><div class=paragraph><p>加入要追蹤的分支所相關的 svn 郵遞論壇，例如，在追蹤 9-STABLE 分支的使用者會加入 <a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-9>svn-src-stable-9</a> 郵遞論壇，該郵遞論壇會記錄每次變更的提交記錄，以及有關可能出現的副作用的任何相關訊息。</p></div><div class=paragraph><p>要加入這些郵遞論壇，請前往 <a href=http://lists.FreeBSD.org/mailman/listinfo>http://lists.FreeBSD.org/mailman/listinfo</a> 點選要訂閱的郵遞論壇，並依照網頁指示的步驟操作。要追蹤整個原始碼樹的變更，可訂閱 <a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-all>svn-src-all</a> 郵遞論壇。</p></div></li><li><p>要安裝新的 FreeBSD-STABLE 系統，可安裝在 <a href=./#mirrors>FreeBSD 鏡像站</a> 中最近的 FreeBSD-STABLE 發佈版或使用每月使用 FreeBSD-STABLE 所編譯的快照 (Snapshot)，請參考 <a href=https://www.FreeBSD.org/snapshots/>www.freebsd.org/snapshots</a> 取得更多有關快照的資訊。</p><div class=paragraph><p>要編譯或升級已有的 FreeBSD 系統到 FreeBSD-STABLE 可使用 <a href=./#svn>svn</a> 來取出欲升級的分支程式碼，可用分支的名稱如：<code>stable/9</code> 會列在 <a href=https://www.FreeBSD.org/releng/>www.freebsd.org/releng</a>。</p></div></li><li><p>編譯 FreeBSD-STABLE 前，請仔細地閱讀 <span class=filename>/usr/src/Makefile</span> 並依照 <a href=#makeworld>從原始碼更新 FreeBSD</a> 的指示操作。 閱讀 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-stable>FreeBSD-STABLE 郵遞論壇</a> 以及 <span class=filename>/usr/src/UPDATING</span> 來了解升級的相關資訊，有時會含有升級下一個發行版的必要資訊。</p></li></ol></div></div></div><div class=sect2><h3 id=makeworld>23.5. 從原始碼更新 FreeBSD<a class=anchor href=#makeworld></a></h3><div class=paragraph><p>從編譯原始碼來更新 FreeBSD 比起用 Binary 更新有幾項優點，在編譯程式碼時可以自訂選項來充分運用特定硬體，部份基礎系統可以使用非預設的設定值編譯，或是在不需要或不想要的時候跳過編譯。使用編譯的程序來更新系統比起安裝 Binary 來更新會耗時許多，但能夠完整自訂一個量身定做版本的 FreeBSD。</p></div><div class=sect3><h4 id=updating-src-quick-start>23.5.1. 快速開始<a class=anchor href=#updating-src-quick-start></a></h4><div class=paragraph><p>這是從原始碼編譯來更新 FreeBSD 的標準步驟快速的參考，稍後的章節會更詳細的說明這個程序。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>更新並編譯</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite update /usr/src  </span><i class=conum data-value=1></i><b>(1)</b>
check /usr/src/UPDATING  <i class=conum data-value=2></i><b>(2)</b>
<span class=c># cd /usr/src          </span><i class=conum data-value=3></i><b>(3)</b>
<span class=c># make -j4 buildworld  </span><i class=conum data-value=4></i><b>(4)</b>
<span class=c># make -j4 kernel      </span><i class=conum data-value=5></i><b>(5)</b>
<span class=c># shutdown -r now      </span><i class=conum data-value=6></i><b>(6)</b>
<span class=c># cd /usr/src          </span><i class=conum data-value=7></i><b>(7)</b>
<span class=c># make installworld    </span><i class=conum data-value=8></i><b>(8)</b>
<span class=c># mergemaster -Ui      </span><i class=conum data-value=9></i><b>(9)</b>
<span class=c># shutdown -r now      </span><i class=conum data-value=10></i><b>(10)</b></code></pre></div></div></li></ol></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>取得最新版本的原始碼，請參考 <a href=#updating-src-obtaining-src>更新原始碼</a> 來了解更多取得與更新原始碼的資訊。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>檢查 <span class=filename>/usr/src/UPDATING</span> 看是否有任後在原始碼編譯之前或之後需要手動操作的步驟。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>前往原始碼目錄。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>編譯世界 (World)，即除了核心 (Kernel) 外的所有東西。</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>編譯並安裝核心，此動作等同於 <code>make buildkernel installkernel</code>。</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>重新啟動系統以使用新的核心。</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>前往原始碼目錄。</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>安裝世界。</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>更新與合併在 <span class=filename>/etc/</span> 中的設定檔案。</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>重新啟動系統以使用新編譯好的世界與核心。</td></tr></tbody></table></div></div></div></div><div class=sect3><h4 id=updating-src-preparing>23.5.2. 準備原始碼更新<a class=anchor href=#updating-src-preparing></a></h4><div class=paragraph><p>閱讀 <span class=filename>/usr/src/UPDATING</span>，從原始碼編譯之前與之後任何需要手動操作步驟會在此檔案中說明。</p></div></div><div class=sect3><h4 id=updating-src-obtaining-src>23.5.3. 更新原始碼<a class=anchor href=#updating-src-obtaining-src></a></h4><div class=paragraph><p>FreeBSD 的原始碼位於 <span class=filename>/usr/src/</span>，較建議透過 Subversion 版本控制系統來更新這份原始碼，要確認原始碼已在版本控制系統的管控下可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite info /usr/src</span>
Path: /usr/src
Working Copy Root Path: /usr/src
...</code></pre></div></div><div class=paragraph><p>此結果代表 <span class=filename>/usr/src/</span> 已在版本控制系統的管控下並且可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=svnlite&amp;sektion=1&amp;format=html">svnlite(1)</a> 來更新：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite update /usr/src</span></code></pre></div></div><div class=paragraph><p>若該目錄最近沒有更新過，可能會需要一些時間來完成更新動作。在更新完成之後，原始碼便為最新版本，並可開始依下一章節的說明來編譯程序。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>取得原始碼</div><div class=paragraph><p>若輸出結果顯示 <code>'/usr/src' is not a working copy</code> 代表有缺少檔案或原始碼是採用其他方式安裝，若是如此，便需重新取出 (checkout) 原始碼。</p></div><table id=updating-src-obtaining-src-repopath class="tableblock frame-all grid-all stretch"><caption class=title>表 18. FreeBSD 版本與檔案庫路徑</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">uname -r 的輸出結果</th><th class="tableblock halign-left valign-top">檔案庫路徑</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X.Y</em>-RELEASE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>base/releng/</code><em>X.Y</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>發佈版本加上關鍵的安全性與錯誤修正，較建議大多數使用者使用這個分支。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X.Y</em>-STABLE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>base/stable/</code><em>X</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>發佈版本加上所有在該分支上其他開發中的程式，<em>STABLE</em> 代表不會更改應用程式 Binary 介面 (Applications Binary Interface, ABI)，所以在先前版本所編譯的軟體仍可以正常運作，舉例來說，被編譯在 FreeBSD 10.1 可執行的軟體在編譯完 FreeBSD 10-STABLE 之後仍可以執行。</p><p class=tableblock>STABLE 分支偶爾也會有錯誤或無法相容的問題會影響使用者，雖然這些問題通常會很快的被修正。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X</em>-CURRENT</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>base/head/</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>最新未發佈的 FreeBSD 開發版本，CURRENT 分支可能會有重大錯誤或不相容的問題，只建議進階的使用者使用。</p></td></tr></tbody></table><div class=paragraph><p>查看 FreeBSD 目前使用的版本可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># uname -r</span>
10.3-RELEASE</code></pre></div></div><div class=paragraph><p>根據 <a href=#updating-src-obtaining-src-repopath>FreeBSD 版本與檔案庫路徑</a>，要更新 <code>10.3-RELEASE</code> 需使用的原始碼檔案庫路徑為 <code>base/releng/10.3</code>，在取出 (checkout) 原始碼時便要使用這個路徑：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /usr/src /usr/src.bak  </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># svnlite checkout https://svn.freebsd.org/base/releng/10.3 /usr/src  </span><i class=conum data-value=2></i><b>(2)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>將舊的目錄移到其他地方，若沒有在這個目錄做過任何本地修改，可直接刪除這個目錄。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>將從 <a href=#updating-src-obtaining-src-repopath>FreeBSD 版本與檔案庫路徑</a> 查到的路徑加到檔案庫 URL 之後。第三個參數用來存放本地系統原始碼的目標目錄。</td></tr></tbody></table></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=updating-src-building>23.5.4. 從原始碼編譯<a class=anchor href=#updating-src-building></a></h4><div class=paragraph><p>編譯世界 (<em>world</em>) 即編譯整個作業系統除了核心 (Kernel)，要先做這個動作以便提供最新的工具來編譯核心，接著便可編譯核心：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildworld</span>
<span class=c># make buildkernel</span></code></pre></div></div><div class=paragraph><p>編譯完的程式會寫入至 <span class=filename>/usr/obj</span>。</p></div><div class=paragraph><p>以上這些均為基本的步驟，用來控制編譯的其他選項在以下章節會說明。</p></div><div class=sect4><h5 id=updating-src-building-clean-build>23.5.4.1. 執行清除編譯<a class=anchor href=#updating-src-building-clean-build></a></h5><div class=paragraph><p>部份 FreeBSD 編譯系統版本會保留先前編譯的程式於暫存的物件目錄 <span class=filename>/usr/obj</span>，避免重新編譯那些尚未更動過的程式碼可加速後續的編譯動作，若要強制重新編譯所有東西可在開始編譯前使用 <code>cleanworld</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make cleanworld</span></code></pre></div></div></div><div class=sect4><h5 id=updating-src-building-jobs>23.5.4.2. 設定工作數量<a class=anchor href=#updating-src-building-jobs></a></h5><div class=paragraph><p>在多核處理器上增加編譯工作的數量可增加編譯速度，可使用 <code>sysctl hw.ncpu</code> 來查看有多少核心，不同處理器使用不同版本的 FreeBSD 編譯系統，所以唯一能了解不同工作數量對編譯速度影響的方式便是測試。在一開始可考慮選擇一個介於 1/2 到 2 倍核心數之間的數值，工作的數量可使用 <code>-j</code> 來指定。</p></div><div id=updating-src-building-jobs-example class=exampleblock><div class=title>例 44. 增加編譯工作數</div><div class=content><div class=paragraph><p>使用四個工作來編譯世界與核心：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -j4 buildworld buildkernel</span></code></pre></div></div></div></div></div><div class=sect4><h5 id=updating-src-building-only-kernel>23.5.4.3. 只編譯核心<a class=anchor href=#updating-src-building-only-kernel></a></h5><div class=paragraph><p>若原始碼有更動，便須執行 <code>buildworld</code>，完成之後，便可隨時執行 <code>buildkernel</code> 來編譯核心，若要只編譯核心可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildkernel</span></code></pre></div></div></div><div class=sect4><h5 id=updating-src-building-custom-kernel>23.5.4.4. 編譯自訂核心<a class=anchor href=#updating-src-building-custom-kernel></a></h5><div class=paragraph><p>標準的 FreeBSD 核心是以一個名為 <span class=filename>GENERIC</span> 的<em>核心設定檔 (Kernel config file)</em>為基礎，<span class=filename>GENERIC</span> 核心中內含了所有最常用的裝置驅動程式與選項，有時這個檔案對編譯自訂核心也非常有用，可根據其來加入或移除裝置驅動程式或選項來滿足特定需求。</p></div><div class=paragraph><p>例如，要開發一個 RAM 受到嚴重限制的小型嵌入式電腦，便可移除不需要的裝置驅動程式或選項來縮小核心。</p></div><div class=paragraph><p>核心設定檔位於 <span class=filename>/usr/src/sys/arch/conf/</span>，其中使用的 <em>arch</em> 即為 <code>uname -m</code> 輸出的結果，大部份的電腦為 <code>amd64</code>，那其設定檔目錄則為 <span class=filename>/usr/src/sys/amd64/conf/</span>。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><span class=filename>/usr/src</span> 可以被刪除或重建，所以較建議將自訂核心設定檔放在另一個目錄，如 <span class=filename>/root</span>，並將核心設定檔以連結放至 <span class=filename>conf</span> 目錄，若該目錄被刪除或覆寫，便可重新建立一個新的核心設定的連結。</p></div></td></tr></tbody></table></div><div class=paragraph><p>自訂設定檔可由複製 <span class=filename>GENERIC</span> 設定檔來建立，在此範例，新的自訂核心要用在儲存伺服器，所以將其命名為 <span class=filename>STORAGESERVER</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /usr/src/sys/amd64/conf/GENERIC /root/STORAGESERVER</span>
<span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># ln -s /root/STORAGESERVER .</span></code></pre></div></div><div class=paragraph><p>接著編譯 <span class=filename>/root/STORAGESERVER</span>，要加入或移除裝置或選項可見 <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a>。</p></div><div class=paragraph><p>自訂核心要在指令列設定 <code>KERNCONF</code> 為核心設定檔來編譯：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=STORAGESERVER</span></code></pre></div></div></div></div><div class=sect3><h4 id=updating-src-installing>23.5.5. 安裝編譯好的程式<a class=anchor href=#updating-src-installing></a></h4><div class=paragraph><p>在完成 <code>buildworld</code> 與 <code>buildkernel</code> 兩個步驟之後，便可安裝新的核心與世界：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make installkernel</span>
<span class=c># shutdown -r now</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld</span>
<span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>若使用自訂核心，則同樣須設定 <code>KERNCONF</code> 來使用新的自訂核心：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make installkernel KERNCONF=STORAGESERVER</span>
<span class=c># shutdown -r now</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld</span>
<span class=c># shutdown -r now</span></code></pre></div></div></div><div class=sect3><h4 id=updating-src-completing>23.5.6. 完成更新<a class=anchor href=#updating-src-completing></a></h4><div class=paragraph><p>還有最後一些的工作要做來完成更新，任何修改過的設定檔要與新版本的設定檔合併、移除找到的過時程式庫，然後重新啟動系統。</p></div><div class=sect4><h5 id=updating-src-completing-merge-mergemaster>23.5.6.1. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 合併設定檔案<a class=anchor href=#updating-src-completing-merge-mergemaster></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 可簡單的將修改過的系統設定檔與新版設定檔合併。</p></div><div class=paragraph><p>使用 <code>-Ui</code>，<a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 會自動更新那些未被使用者修改過的設定檔並安裝尚不存在的檔案：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -Ui</span></code></pre></div></div><div class=paragraph><p>若檔案需要手動合併，會有互動式介面可讓使用者選擇要保留那一邊的檔案，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 取得更多資訊。</p></div></div><div class=sect4><h5 id=updating-src-completing-check-old>23.5.6.2. 檢查過時的檔案與程式庫<a class=anchor href=#updating-src-completing-check-old></a></h5><div class=paragraph><p>部份廢棄的檔案或目錄可以在更新之後保留，可使用以下指令找出這些檔案：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make check-old</span></code></pre></div></div><div class=paragraph><p>並用以下指令刪除：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make delete-old</span></code></pre></div></div><div class=paragraph><p>部份廢棄的程式庫也可以保留下來，可使用以下指令來偵測這些程式庫：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make check-old-libs</span></code></pre></div></div><div class=paragraph><p>並使用以下指令刪除</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make delete-old-libs</span></code></pre></div></div><div class=paragraph><p>那些仍使用舊程式庫的程式將在刪除程式庫之後無法正常運作，而這些程式須要在刪除舊程式庫之後重新編譯或更換。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>當確認所有舊檔案或目錄可安全的刪除時，要避免刪除每一個檔案時均需按下 <kbd>y</kbd> 與 <kbd>Enter</kbd> 鍵可在指令設定 <code>BATCH_DELETE_OLD_FILES</code>，例如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make BATCH_DELETE_OLD_FILES=yes delete-old-libs</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=updating-src-completing-restart>23.5.6.3. 更新後重新啟動<a class=anchor href=#updating-src-completing-restart></a></h5><div class=paragraph><p>更新之後的最後一個步驟便是重新啟動電腦，來讓所有的變更生效：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=small-lan>23.6. 多部機器追蹤<a class=anchor href=#small-lan></a></h3><div class=paragraph><p>當有多部主機需要追蹤相同的原始碼樹，要在每一部主機的系統下載原始碼與重新編譯所有的東西會耗費不少磁碟空間、網路頻寬與 CPU 運算，要解決這個問題的方法是先在一部主機上做完大部份的工作，而其餘的主機透過 NFS 掛載使用編譯完的成果。本節會介紹如何做這件事。要取得更多有關使用 NFS 的資訊請參考 <a href=./#network-nfs>網路檔案系統 (NFS)</a>。</p></div><div class=paragraph><p>首先，要先確認要執行同一組 Binary 的一群主機，這群主機又稱作 <em>建置集 (Build set)</em>，其中每部主機可以有自己的自訂核心，但會執行相同的 Userland binary。建置集中需挑選一部做為<em>建置主機 (Build machine)</em>，這部主機將會拿來編譯 World 與核心 (Kernel)，理想情況下，要挑選一部速度較快、有足夠的 CPU 能夠執行 <code>make buildworld</code> 與 <code>make buildkernel</code> 的主機。</p></div><div class=paragraph><p>再挑選一部主機做為<em>測試主機 (Test machine)</em>，這部主機,要在將系統更新上正式運作的環境前做測試，這<em>必須</em>一部能夠承受服務停止一段時間的主機，它也可是同時是建置主機，但不是一定要。</p></div><div class=paragraph><p>所有在此建置集中的主機需要透過 NFS 掛載在建置主機上的 <span class=filename>/usr/obj</span> 與 <span class=filename>/usr/src</span>。在有多個建置集時，<span class=filename>/usr/src</span> 也應放在其中一部建置主機，然後由其他主機使用 NFS 掛載。</p></div><div class=paragraph><p>確保在建置集中的所有主機的 <span class=filename>/etc/make.conf</span> 及 <span class=filename>/etc/src.conf</span> 與建置主機一致，這是由於建置主機必須編譯整個基礎系統 (Base system) 給所有建置集中的主機安裝。此外，每一部建置主機應在 <span class=filename>/etc/make.conf</span> 使用 <code>KERNCONF</code> 設定其核心名稱，且建置主機應列出所有要編譯的核心名稱在 <code>KERNCONF</code>，並且把自己要用的核心放在第一個。建置主機也必須有每部主機的核心設定檔在其 <span class=filename>/usr/src/sys/arch/conf</span>。</p></div><div class=paragraph><p>在建置主機上，編譯核心與 World 如 <a href=#makeworld>從原始碼更新 FreeBSD</a> 所述，但不要在建置主機上安裝所有編譯好的東西，而是要將編譯好的核心安裝到測試主機，在測試主機透過 NFS 掛載 <span class=filename>/usr/src</span> 及 <span class=filename>/usr/obj</span>。然後執行 <code>shutdown now</code> 進入單使用者模式來安裝新的核心與 World 並如同往常執行 <code>mergemaster</code>。完成之後，重新開機回到正常的多使用者模式運作。</p></div><div class=paragraph><p>在測試主機上檢驗完所有東西皆運作正常之後，使用相同的程序將編譯好的結果安裝到在建置集中的其他主機。</p></div><div class=paragraph><p>同樣的方法也可用在 Port 樹，第一個步驟是透過 NFS 共享 <span class=filename>/usr/ports</span> 給所有在建置集中的主機。要設定 <span class=filename>/etc/make.conf</span> 使用共享的 distfiles，可設定 <code>DISTDIR</code> 為由 NFS 掛載對應到的使用者 <code>root</code> 可寫入的通用共享目錄。每一台主機應設定 <code>WRKDIRPREFIX</code> 到一個本地的編譯目錄，若 Port 要在本地編譯。或者，若建置系統要編譯並散佈套件到建置集中的主機可在建置系統上設定 <code>PACKAGES</code> 到一個類似 <code>DISTDIR</code> 的目錄。</p></div></div></div></div><div class=sect1><h2 id=dtrace>Chapter 24. DTrace<a class=anchor href=#dtrace></a></h2><div class=sectionbody><div class=sect2><h3 id=dtrace-synopsis>24.1. 概述<a class=anchor href=#dtrace-synopsis></a></h3><div class=paragraph><p>DTrace，又被稱作 Dynamic Tracing ，由 Sun™ 開發，用在生產 (production) 跟預生產 (pre-production) 系統中找出效能瓶頸的工具。
除了診斷性能問題外，DTrace 還可以用於查詢以及除錯 FreeBSD 核心和使用者層級程式的未預期行為。</p></div><div class=paragraph><p>DTrace 是一個卓越的分析工具，具有一系列令人驚豔、用於診斷系統問題的功能。
它還可以執行預先寫好的腳本，以使用其功能。
使用者可以用 DTrace D 語言編寫自己的工具，從而允許他們根據特定的需求客製化。</p></div><div class=paragraph><p>FreeBSD 實做提供對核心層級的 DTrace 全面的支援，以及對使用者層級的 DTrace 實驗性的支援。
使用者層級的 DTrace 允許使用者使用 <code>pid</code> 執行函式邊界追蹤 (function boundary tracing)，並將 static probes 插入到使用者程式以供之後追蹤。
一些 ports，像是 <a class=package href=https://cgit.freebsd.org/ports/tree/databases/postgresql12-server/>databases/postgresql12-server</a> 和 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php74/>lang/php74</a> 提供 DTrace 選項，以提供 static probes 功能。</p></div><div class=paragraph><p>DTrace 的官方指南由 Illumos 維護，在 <a href=http://dtrace.org/guide>DTrace Guide</a>。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>什麼是 DTrace 以及其提供的功能。</p></li><li><p>Solaris™ 實做的 DTrace 跟 FreeBSD 提供的 DTrace 之間的不同之處。</p></li><li><p>如何在 FreeBSD 上啟用和使用 DTrace。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解 UNIX™ 及 FreeBSD 基礎 (<a href=./#basics>FreeBSD 基礎</a>)。</p></li><li><p>了解安全性以及其跟 FreeBSD 的關係 (<a href=./#security>安全性</a>)。</p></li></ul></div></div><div class=sect2><h3 id=dtrace-implementation>24.2. 實作差異<a class=anchor href=#dtrace-implementation></a></h3><div class=paragraph><p>雖然 FreeBSD 的 DTrace 和 Solaris™ 的 DTrace 類似，但是還是有存在差異。
最重要的區別為，在 FreeBSD 中，DTrace 是作為一組核心模組 (kernel modules) 實做的，並且在載入模組之前無法使用。
要載入所有需要的模組:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload dtraceall</span></code></pre></div></div><div class=paragraph><p>從 FreeBSD 10.0-RELEASE 之後，模組會在執行 <code>dtrace</code> 時自動載入。</p></div><div class=paragraph><p>FreeBSD 使用 <code>DDB_CTF</code> 核心選項來支援從核心模組和核心本身載入 <code>CTF</code> 資料。
<code>CTF</code> 是 Solaris™ Compact C Type Format，它封裝了一種簡化形式的除錯資訊，類似於 <code>DWARF</code> 和 古老的 stabs。
<code>CTF</code> 資料通過`ctfconvert` and <code>ctfmerge</code> 建構工具，加入到二進制文件中。
<code>ctfconvert</code> 工具分析編譯器創建的 <code>DWARF<code>ELF</code> 除錯部份，而 <code>ctfmerge</code> 將目標的 <code>CTF</code>ELF</code> 部份合併到執行檔或函式庫中。</p></div><div class=paragraph><p>與 Solaris™ 相比，FreeBSD 存在一些不同的 providers。
最值得注意的是 <code>dtmalloc</code> provider 允許在 FreeBSD 核心中按照類型 (type) 追蹤 <code>malloc()</code>。
Solaris™ 中的一些 providers，例如 <code>cpc</code> 和 <code>mib</code>，在 FreeBSD 中則不存在。
這些可能會在 FreeBSD 未來的版本中出現。
此外，兩個作業系統中一些可用的 providers 是不相容的，因為他們具有不同的參數類型。
因此，在 Solaris™ 上拓寫的 <code>D</code> 腳本在未經修改的情況下可能可以或不可以在 FreeBSD 上執行，反之亦然。</p></div><div class=paragraph><p>因為安全的差異，只有 <code>root</code> 可以在 FreeBSD 上使用 DTrace。
Solaris™ 擁有一些 FreeBSD 中還不存在的低階 (low level) 安全檢查。
因此 <span class=filename>/dev/dtrace/dtrace</span> 被嚴格限制成 <code>root</code>。</p></div><div class=paragraph><p>DTrace 使用 Common Development and Distribution License (<code>CDDL</code>) 授權。
要在 FreeBSD 上查看此授權, 請參閱 <span class=filename>/usr/src/cddl/contrib/opensolaris/OPENSOLARIS.LICENSE</span> 或者在 <a href=http://opensource.org/licenses/CDDL-1.0>http://opensource.org/licenses/CDDL-1.0</a> 線上查看。
雖然具有 DTrace 支援的 FreeBSD 核心使用 <code>BSD</code> 授權，但當模組使用二進制形式或者二進制文件發布時，將使用 <code>CDDL</code> 授權。</p></div></div><div class=sect2><h3 id=dtrace-enable>24.3. 開啟 DTrace 支援<a class=anchor href=#dtrace-enable></a></h3><div class=paragraph><p>在 FreeBSD 9.2 和 10.0 中，DTrace 內建於 <span class=filename>GENERIC</span> 核心裡。
FreeBSD 早期版本的使用者或喜歡在 DTrace 支援下靜態編譯的使用者應加入下列幾行到客製化核心配置文件，並根據 <a href=./#kernelconfig>Configuring the FreeBSD Kernel</a> 中的說明重新編譯核心:</p></div><div class="literalblock programlisting"><div class=content><pre>options         KDTRACE_HOOKS
options         DDB_CTF
makeoptions	DEBUG=-g
makeoptions	WITH_CTF=1</pre></div></div><div class=paragraph><p>AMD64 架構的使用者應加入下列幾行:</p></div><div class="literalblock programlisting"><div class=content><pre>options         KDTRACE_FRAME</pre></div></div><div class=paragraph><p>此選項提供對 <code>FBT</code> 的支援，
雖然 DTrace 可以在沒有此選項的情況下運作，但對函式邊界追蹤的支援有限。</p></div><div class=paragraph><p>一旦 FreeBSD 系統使用新的核心重新啟動，或者使用 <code>kldload dtraceall</code> 載入 DTrace 核心模組後，系統需要支援 Korn shell，因為 DTrace 工具箱有幾個用 <code>ksh</code> 拓寫的工具。
確保已經安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/shells/ksh93/>shells/ksh93</a> 套件或者 port，
也可以在 <a class=package href=https://cgit.freebsd.org/ports/tree/shells/pdksh/>shells/pdksh</a> 或者 <a class=package href=https://cgit.freebsd.org/ports/tree/shells/mksh/>shells/mksh</a> 下執行這些工具。</p></div><div class=paragraph><p>最後，安裝目前的 DTrace 工具箱，這是一組用於收集系統資訊的現成腳本，
有一些腳本可以檢查打開的文件、記憶體、<code>CPU</code> 使用情況等等。
FreeBSD 10 將其中一些腳本安裝在 <span class=filename>/usr/share/dtrace</span> 中。
在其他 FreeBSD 的版本中，要安裝 DTrace 工具箱，請使用 <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dtrace-toolkit/>sysutils/dtrace-toolkit</a> 套件或者 port。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/usr/share/dtrace</span> 中的腳本已專門移植到 FreeBSD，
並非所有在 DTrace 工具箱中的所有腳本都能在 FreeBSD 上按照原樣運作，一些腳本可能需要一些修改才能在 FreeBSD 上運作。</p></div></td></tr></tbody></table></div><div class=paragraph><p>DTrace 工具箱包含許多使用 DTrace 特殊語言的腳本，
這種語言被稱為 D 語言，它與 C++ 非常類似，
對於該語言的深度討論超出了此文件的範圍，
他在 <a href=http://www.dtrace.org/guide>Illumos Dynamic Tracing Guide</a> 有廣泛的介紹。</p></div></div><div class=sect2><h3 id=dtrace-using>24.4. 使用 DTrace<a class=anchor href=#dtrace-using></a></h3><div class=paragraph><p>DTrace 腳本由一個或多個 <em>probes</em> 或檢查點 (instrumentation points) 的列表組成，其中每個 probe 都與一個行為有關，
只要能滿足 probe 的條件，就會執行相關的行為，
舉例來說，打開文件、啟動一個行程或執行一行程式。
該行為可能是紀錄一些資訊，或修改上下文變數 (context variables)，
上下文變數的讀寫允許 probes 分享資訊和共同分析不同事件的相關性。</p></div><div class=paragraph><p>想要查看所有的 probes，系統管理員可以執行以下指令:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dtrace -l | more</span></code></pre></div></div><div class=paragraph><p>每個 probe 都有一個 <code>ID</code>、一個 <code>PROVIDER</code> (dtrace 或者 fbt)、一個 <code>MODULE</code> 和一個 <code>FUNCTION NAME</code>。
有關此指令的更多資訊，請參閱 <a href="https://man.freebsd.org/cgi/man.cgi?query=dtrace&amp;sektion=1&amp;format=html">dtrace(1)</a>。</p></div><div class=paragraph><p>本節中的例子概述如何使用 DTrace 工具箱中完全支援的兩個腳本: <span class=filename>hotkernel</span> 和 <span class=filename>procsystime</span> 腳本。</p></div><div class=paragraph><p><span class=filename>hotkernel</span> 腳本設計成觀察哪個函式使用的核心時間最多，
它會產生類似於以下內容的輸出:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/share/dtrace-toolkit</span>
<span class=c># ./hotkernel</span>
Sampling... Hit Ctrl-C to end.</code></pre></div></div><div class=paragraph><p>按照說明，使用 <span class=keyseq><kbd>Ctrl</kbd>+<kbd>C</kbd></span> 組合鍵停止行程，
中止後，腳本將顯示一整列的核心函式和時間資訊，按照時間遞增排序:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>kernel<span class=sb>`</span>_thread_lock_flags                                   2   0.0%
0xc1097063                                                  2   0.0%
kernel<span class=sb>`</span>sched_userret                                        2   0.0%
kernel<span class=sb>`</span>kern_select                                          2   0.0%
kernel<span class=sb>`</span>generic_copyin                                       3   0.0%
kernel<span class=sb>`</span>_mtx_assert                                          3   0.0%
kernel<span class=sb>`</span>vm_fault                                             3   0.0%
kernel<span class=sb>`</span>sopoll_generic                                       3   0.0%
kernel<span class=sb>`</span>fixup_filename                                       4   0.0%
kernel<span class=sb>`</span>_isitmyx                                             4   0.0%
kernel<span class=sb>`</span>find_instance                                        4   0.0%
kernel<span class=sb>`</span>_mtx_unlock_flags                                    5   0.0%
kernel<span class=sb>`</span>syscall                                              5   0.0%
kernel<span class=sb>`</span>DELAY                                                5   0.0%
0xc108a253                                                  6   0.0%
kernel<span class=sb>`</span>witness_lock                                         7   0.0%
kernel<span class=sb>`</span>read_aux_data_no_wait                                7   0.0%
kernel<span class=sb>`</span>Xint0x80_syscall                                     7   0.0%
kernel<span class=sb>`</span>witness_checkorder                                   7   0.0%
kernel<span class=sb>`</span>sse2_pagezero                                        8   0.0%
kernel<span class=sb>`</span>strncmp                                              9   0.0%
kernel<span class=sb>`</span>spinlock_exit                                       10   0.0%
kernel<span class=sb>`</span>_mtx_lock_flags                                     11   0.0%
kernel<span class=sb>`</span>witness_unlock                                      15   0.0%
kernel<span class=sb>`</span>sched_idletd                                       137   0.3%
0xc10981a5                                              42139  99.3%</code></pre></div></div><div class=paragraph><p>此腳本也是用於核心模組，
要使用此功能，請使用 <code>-m</code> 執行腳本:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./hotkernel -m</span>
Sampling... Hit Ctrl-C to end.
^C
MODULE                                                  COUNT   PCNT
0xc107882e                                                  1   0.0%
0xc10e6aa4                                                  1   0.0%
0xc1076983                                                  1   0.0%
0xc109708a                                                  1   0.0%
0xc1075a5d                                                  1   0.0%
0xc1077325                                                  1   0.0%
0xc108a245                                                  1   0.0%
0xc107730d                                                  1   0.0%
0xc1097063                                                  2   0.0%
0xc108a253                                                 73   0.0%
kernel                                                    874   0.4%
0xc10981a5                                             213781  99.6%</code></pre></div></div><div class=paragraph><p><span class=filename>procsystime</span> 抓取和輸出系統調用時間，給設定行程 ID (PID) 或行程名稱的行程。
在以下的例子中，生成了 <span class=filename>/bin/csh</span> 新物件，
然後，<span class=filename>procsystime</span> 被執行並一直等待，同時在 <code>csh</code> 的另一個化身上輸入一些指令，
以下是本次測試的結果:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./procsystime -n csh</span>
Tracing... Hit Ctrl-C to end...
^C

Elapsed Times <span class=k>for </span>processes csh,

         SYSCALL          TIME <span class=o>(</span>ns<span class=o>)</span>
          getpid               6131
       sigreturn               8121
           close              19127
           fcntl              19959
             dup              26955
         setpgid              28070
            <span class=nb>stat              </span>31899
       setitimer              40938
           wait4              62717
       sigaction              67372
     sigprocmask             119091
    gettimeofday             183710
           write             263242
          execve             492547
           ioctl             770073
           vfork            3258923
      sigsuspend            6985124
            <span class=nb>read         </span>3988049784</code></pre></div></div><div class=paragraph><p>如圖所示，<code>read()</code> 系統調用使用的時間最多（以奈秒為單位），而 <code>getpid()</code> 系統調用使用的時間最少。</p></div></div></div></div><div class=sect1><h2 id=usb-device-mode>Chapter 25. USB Device Mode / USB OTG<a class=anchor href=#usb-device-mode></a></h2><div class=sectionbody><div class=sect2><h3 id=usb-device-mode-synopsis>25.1. 概述<a class=anchor href=#usb-device-mode-synopsis></a></h3><div class=paragraph><p>This chapter covers the use of USB Device Mode and USB On The Go (USB OTG) in FreeBSD. This includes virtual serial consoles, virtual network interfaces, and virtual USB drives.</p></div><div class=paragraph><p>When running on hardware that supports USB device mode or USB OTG, like that built into many embedded boards, the FreeBSD USB stack can run in <em>device mode</em>. Device mode makes it possible for the computer to present itself as different kinds of USB device classes, including serial ports, network adapters, and mass storage, or a combination thereof. A USB host like a laptop or desktop computer is able to access them just like physical USB devices. Device mode is sometimes called the "USB gadget mode".</p></div><div class=paragraph><p>There are two basic ways the hardware can provide the device mode functionality: with a separate "client port", which only supports the device mode, and with a USB OTG port, which can provide both device and host mode. For USB OTG ports, the USB stack switches between host-side and device-side automatically, depending on what is connected to the port. Connecting a USB device like a memory stick to the port causes FreeBSD to switch to host mode. Connecting a USB host like a computer causes FreeBSD to switch to device mode. Single purpose "client ports" always work in device mode.</p></div><div class=paragraph><p>What FreeBSD presents to the USB host depends on the <code>hw.usb.template</code> sysctl. Some templates provide a single device, such as a serial terminal; others provide multiple ones, which can all be used at the same time. An example is the template 10, which provides a mass storage device, a serial console, and a network interface. See <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> for the list of available values.</p></div><div class=paragraph><p>Note that in some cases, depending on the hardware and the hosts operating system, for the host to notice the configuration change, it must be either physically disconnected and reconnected, or forced to rescan the USB bus in a system-specific way. When FreeBSD is running on the host, <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a><code>reset</code> can be used. This also must be done after loading <span class=filename>usb_template.ko</span> if the USB host was already connected to the USBOTG socket.</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>How to set up USB Device Mode functionality on FreeBSD.</p></li><li><p>How to configure the virtual serial port on FreeBSD.</p></li><li><p>How to connect to the virtual serial port from various operating systems.</p></li><li><p>How to configure FreeBSD to provide a virtual USB network interface.</p></li><li><p>How to configure FreeBSD to provide a virtual USB storage device.</p></li></ul></div></div><div class=sect2><h3 id=usb-device-mode-terminals>25.2. USB 虛擬序列埠<a class=anchor href=#usb-device-mode-terminals></a></h3><div class=sect3><h4 id=_設定_usb_裝置模式序列埠>25.2.1. 設定 USB 裝置模式序列埠<a class=anchor href=#_設定_usb_裝置模式序列埠></a></h4><div class=paragraph><p>Virtual serial port support is provided by templates number 3, 8, and 10. Note that template 3 works with Microsoft Windows 10 without the need for special drivers and INF files. Other host operating systems work with all three templates. Both <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=umodem&amp;sektion=4&amp;format=html">umodem(4)</a> kernel modules must be loaded.</p></div><div class=paragraph><p>To enable USB device mode serial ports, add those lines to <span class=filename>/etc/ttys</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ttyU0	<span class=s2>&#34;/usr/libexec/getty 3wire&#34;</span>	vt100	onifconsole secure
ttyU1	<span class=s2>&#34;/usr/libexec/getty 3wire&#34;</span>	vt100	onifconsole secure</code></pre></div></div><div class=paragraph><p>然後加入這些行到 <span class=filename>/etc/devd.conf</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>notify 100 <span class=o>{</span>
	match <span class=s2>&#34;system&#34;</span>		<span class=s2>&#34;DEVFS&#34;</span><span class=p>;</span>
	match <span class=s2>&#34;subsystem&#34;</span>	<span class=s2>&#34;CDEV&#34;</span><span class=p>;</span>
	match <span class=s2>&#34;type&#34;</span>		<span class=s2>&#34;CREATE&#34;</span><span class=p>;</span>
	match <span class=s2>&#34;cdev&#34;</span>		<span class=s2>&#34;ttyU[0-9]+&#34;</span><span class=p>;</span>
	action <span class=s2>&#34;/sbin/init q&#34;</span><span class=p>;</span>
<span class=o>}</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Reload the configuration if <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> is already running:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p>Make sure the necessary modules are loaded and the correct template is set at boot by adding those lines to <span class=filename>/boot/loader.conf</span>, creating it if it does not already exist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>umodem_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
hw.usb.template<span class=o>=</span>3</code></pre></div></div><div class=paragraph><p>To load the module and set the template without rebooting use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload umodem</span>
<span class=c># sysctl hw.usb.template=3</span></code></pre></div></div></div><div class=sect3><h4 id=_自_freebsd_連線到_usb_裝置模式序列埠>25.2.2. 自 FreeBSD 連線到 USB 裝置模式序列埠<a class=anchor href=#_自_freebsd_連線到_usb_裝置模式序列埠></a></h4><div class=paragraph><p>To connect to a board configured to provide USB device mode serial ports, connect the USB host, such as a laptop, to the boards USB OTG or USB client port. Use <code>pstat -t</code> on the host to list the terminal lines. Near the end of the list you should see a USB serial port, eg "ttyU0". To open the connection, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/ttyU0</span></code></pre></div></div><div class=paragraph><p>After pressing the Enter key a few times you will see a login prompt.</p></div></div><div class=sect3><h4 id=_自_macos_連線到_usb_裝置模式序列埠>25.2.3. 自 macOS 連線到 USB 裝置模式序列埠<a class=anchor href=#_自_macos_連線到_usb_裝置模式序列埠></a></h4><div class=paragraph><p>To connect to a board configured to provide USB device mode serial ports, connect the USB host, such as a laptop, to the boards USB OTG or USB client port. To open the connection, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/cu.usbmodemFreeBSD1</span></code></pre></div></div></div><div class=sect3><h4 id=_自_linux_連線到_usb_裝置模式序列埠>25.2.4. 自 Linux 連線到 USB 裝置模式序列埠<a class=anchor href=#_自_linux_連線到_usb_裝置模式序列埠></a></h4><div class=paragraph><p>To connect to a board configured to provide USB device mode serial ports, connect the USB host, such as a laptop, to the boards USB OTG or USB client port. To open the connection, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># minicom -D /dev/ttyACM0</span></code></pre></div></div></div><div class=sect3><h4 id=_自_microsoft_windows_10_連線到_usb_裝置模式序列埠>25.2.5. 自 Microsoft Windows 10 連線到 USB 裝置模式序列埠<a class=anchor href=#_自_microsoft_windows_10_連線到_usb_裝置模式序列埠></a></h4><div class=paragraph><p>To connect to a board configured to provide USB device mode serial ports, connect the USB host, such as a laptop, to the boards USB OTG or USB client port. To open a connection you will need a serial terminal program, such as PuTTY. To check the COM port name used by Windows, run Device Manager, expand "Ports (COM & LPT)". You will see a name similar to "USB Serial Device (COM4)". Run serial terminal program of your choice, for example PuTTY. In the PuTTY dialog set "Connection type" to "Serial", type the COMx obtained from Device Manager in the "Serial line" dialog box and click Open.</p></div></div></div><div class=sect2><h3 id=usb-device-mode-network>25.3. USB 裝置模式網路介面<a class=anchor href=#usb-device-mode-network></a></h3><div class=paragraph><p>Virtual network interfaces support is provided by templates number 1, 8, and 10. Note that none of them works with Microsoft Windows. Other host operating systems work with all three templates. Both <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=if_cdce&amp;sektion=4&amp;format=html">if_cdce(4)</a> kernel modules must be loaded.</p></div><div class=paragraph><p>Make sure the necessary modules are loaded and the correct template is set at boot by adding those lines to <span class=filename>/boot/loader.conf</span>, creating it if it does not already exist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>if_cdce_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
hw.usb.template<span class=o>=</span>1</code></pre></div></div><div class=paragraph><p>To load the module and set the template without rebooting use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_cdce</span>
<span class=c># sysctl hw.usb.template=1</span></code></pre></div></div></div><div class=sect2><h3 id=usb-device-mode-storage>25.4. USB 虛擬儲存裝置<a class=anchor href=#usb-device-mode-storage></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> 驅動程式是一個在 FreeBSD 12.0 之後才可用的 USB 裝置模式驅動程式。</p></div></td></tr></tbody></table></div><div class=paragraph><p>Mass Storage target is provided by templates 0 and 10. Both <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> kernel modules must be loaded. <a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> interfaces to the CTL subsystem, the same one that is used for iSCSI or Fibre Channel targets. On the host side, USB Mass Storage initiators can only access a single LUN, LUN 0.</p></div><div class=sect3><h4 id=_使用_cfumass_啟動_script_設定_usb_大容量儲存目標>25.4.1. 使用 cfumass 啟動 Script 設定 USB 大容量儲存目標<a class=anchor href=#_使用_cfumass_啟動_script_設定_usb_大容量儲存目標></a></h4><div class=paragraph><p>The simplest way to set up a read-only USB storage target is to use the <span class=filename>cfumass</span> rc script. To configure it this way, copy the files to be presented to the USB host machine into the <code>/var/cfumass</code> directory, and add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cfumass_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To configure the target without restarting, run this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service cfumass start</span></code></pre></div></div><div class=paragraph><p>Differently from serial and network functionality, the template should not be set to 0 or 10 in <span class=filename>/boot/loader.conf</span>. This is because the LUN must be set up before setting the template. The cfumass startup script sets the correct template number automatically when started.</p></div></div><div class=sect3><h4 id=_使用其他方式設定_usb_大容量存儲目標>25.4.2. 使用其他方式設定 USB 大容量存儲目標<a class=anchor href=#_使用其他方式設定_usb_大容量存儲目標></a></h4><div class=paragraph><p>The rest of this chapter provides detailed description of setting the target without using the cfumass rc file. This is necessary if eg one wants to provide a writeable LUN.</p></div><div class=paragraph><p>USB Mass Storage does not require the <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> daemon to be running, although it can be used if desired. This is different from iSCSI. Thus, there are two ways to configure the target: <a href="https://man.freebsd.org/cgi/man.cgi?query=ctladm&amp;sektion=8&amp;format=html">ctladm(8)</a>, or <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a>. Both require the <span class=filename>cfumass.ko</span> kernel module to be loaded. The module can be loaded manually:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload cfumass</span></code></pre></div></div><div class=paragraph><p>If <span class=filename>cfumass.ko</span> has not been built into the kernel, <span class=filename>/boot/loader.conf</span> can be set to load the module at boot:</p></div><div class="literalblock programlisting"><div class=content><pre>cfumass_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>A LUN can be created without the <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> daemon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ctladm create -b block -o file=/data/target0</span></code></pre></div></div><div class=paragraph><p>This presents the contents of the image file <span class=filename>/data/target0</span> as a LUN to the USB host. The file must exist before executing the command. To configure the LUN at system startup, add the command to <span class=filename>/etc/rc.local</span>.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> can also be used to manage LUNs. Create <span class=filename>/etc/ctl.conf</span>, add a line to <span class=filename>/etc/rc.conf</span> to make sure <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> is automatically started at boot, and then start the daemon.</p></div><div class=paragraph><p>This is an example of a simple <span class=filename>/etc/ctl.conf</span> configuration file. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ctl.conf&amp;sektion=5&amp;format=html">ctl.conf(5)</a> for a more complete description of the options.</p></div><div class="literalblock programlisting"><div class=content><pre>target naa.50015178f369f092 {
	lun 0 {
		path /data/target0
		size 4G
	}
}</pre></div></div><div class=paragraph><p>The example creates a single target with a single LUN. The <code>naa.50015178f369f092</code> is a device identifier composed of 32 random hexadecimal digits. The <code>path</code> line defines the full path to a file or zvol backing the LUN. That file must exist before starting <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a>. The second line is optional and specifies the size of the LUN.</p></div><div class=paragraph><p>To make sure the <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> daemon is started at boot, add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ctld_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To start <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> now, run this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld start</span></code></pre></div></div><div class=paragraph><p>當 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> Daemon 啟動後，它會讀取 <span class=filename>/etc/ctl.conf</span>，若這個檔案在 Daemon 啟動之後才做修改，要重新載入變更的內容才能立即生效：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld reload</span></code></pre></div></div></div></div></div></div><h1 id=network-communication class=sect0>Part IV: 網路通訊<a class=anchor href=#network-communication></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>FreeBSD 是一種廣泛的被使用在高效能的網路伺服器中的作業系統，這些章節包含了：</p></div><div class=ulist><ul><li><p>序列通訊</p></li><li><p>PPP 和在乙太網路使用 PPP</p></li><li><p>電子郵件</p></li><li><p>執行網路伺服器</p></li><li><p>防火牆</p></li><li><p>其他的進階網路主題</p></li></ul></div><div class=paragraph><p>這些章節是讓您在需要查資料的時候翻閱用的。 您不需要依照特定的順序來讀，也不需要將這些章節全部讀過之後才將 FreeBSD 用在網路環境下。</p></div></div></div><div class=sect1><h2 id=serialcomms>Chapter 26. 序列通訊<a class=anchor href=#serialcomms></a></h2><div class=sectionbody><div class=sect2><h3 id=serial-synopsis>26.1. 概述<a class=anchor href=#serial-synopsis></a></h3><div class=paragraph><p>UNIX™ 從最早的第一台 UNIX™ 仰賴序列線路來讓使用者輸入與輸出以來一直都支援序列通訊，雖與每秒 10 個字元的序列印表機及鍵盤組成的終端機時代比起已改變很多。本章將說明幾種可在 FreeBSD 使用的序列通訊方式。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>如何連線終端機到 FreeBSD 系統。</p></li><li><p>如何使用數據機撥號給遠端主機。</p></li><li><p>如何允許遠端使用者透過數據機來登入 FreeBSD 系統。</p></li><li><p>如何從序列 Console 啟動 FreeBSD 系統。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解如何 <a href=./#kernelconfig>設定並安裝自訂核心</a>。</p></li><li><p>了解 <a href=./#basics>FreeBSD 的權限與程序</a>。</p></li><li><p>能夠取得要在 FreeBSD 使用的序列硬體的技術手冊。</p></li></ul></div></div><div class=sect2><h3 id=serial>26.2. 序列術語與硬體<a class=anchor href=#serial></a></h3><div class=paragraph><p>The following terms are often used in serial communications:</p></div><div class=dlist><dl><dt class=hdlist1>bps</dt><dd><p>Bits per Second (bps) is the rate at which data is transmitted.</p></dd><dt class=hdlist1>DTE</dt><dd><p>Data Terminal Equipment (DTE) is one of two endpoints in a serial communication. An example would be a computer.</p></dd><dt class=hdlist1>DCE</dt><dd><p>Data Communications Equipment (DTE) is the other endpoint in a serial communication. Typically, it is a modem or serial terminal.</p></dd><dt class=hdlist1>RS-232</dt><dd><p>The original standard which defined hardware serial communications. It has since been renamed to TIA-232.</p></dd></dl></div><div class=paragraph><p>When referring to communication data rates, this section does not use the term <em>baud</em>. Baud refers to the number of electrical state transitions made in a period of time, while bps is the correct term to use.</p></div><div class=paragraph><p>To connect a serial terminal to a FreeBSD system, a serial port on the computer and the proper cable to connect to the serial device are needed. Users who are already familiar with serial hardware and cabling can safely skip this section.</p></div><div class=sect3><h4 id=term-cables-null>26.2.1. 序列線與埠<a class=anchor href=#term-cables-null></a></h4><div class=paragraph><p>There are several different kinds of serial cables. The two most common types are null-modem cables and standard RS-232 cables. The documentation for the hardware should describe the type of cable required.</p></div><div class=paragraph><p>These two types of cables differ in how the wires are connected to the connector. Each wire represents a signal, with the defined signals summarized in <a href=#serialcomms-signal-names>RS-232C 信號名稱</a>. A standard serial cable passes all of the RS-232C signals straight through. For example, the "Transmitted Data" pin on one end of the cable goes to the "Transmitted Data" pin on the other end. This is the type of cable used to connect a modem to the FreeBSD system, and is also appropriate for some terminals.</p></div><div class=paragraph><p>A null-modem cable switches the "Transmitted Data" pin of the connector on one end with the "Received Data" pin on the other end. The connector can be either a DB-25 or a DB-9.</p></div><div class=paragraph><p>A null-modem cable can be constructed using the pin connections summarized in <a href=#nullmodem-db25>DB-25 對 DB-25 Null-Modem 線</a>, <a href=#nullmodem-db9>DB-9 對 DB-9 Null-Modem 線</a>, and <a href=#nullmodem-db9-25>DB-9 對 DB-25 Null-Modem 線</a>. While the standard calls for a straight-through pin 1 to pin 1 "Protective Ground" line, it is often omitted. Some terminals work using only pins 2, 3, and 7, while others require different configurations. When in doubt, refer to the documentation for the hardware.</p></div><table id=serialcomms-signal-names class="tableblock frame-none grid-all stretch"><caption class=title>表 19. RS-232C 信號名稱</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">縮寫</th><th class="tableblock halign-left valign-top">Names</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Received Data</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Transmitted Data</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Terminal Ready</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Set Ready</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Carrier Detect</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Signal Ground</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Request to Send</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clear to Send</p></td></tr></tbody></table><table id=nullmodem-db25 class="tableblock frame-none grid-all stretch"><caption class=title>表 20. DB-25 對 DB-25 Null-Modem 線</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">信號</th><th class="tableblock halign-left valign-top">針腳 #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">針腳 #</th><th class="tableblock halign-left valign-top">信號</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr></tbody></table><table id=nullmodem-db9 class="tableblock frame-none grid-all stretch"><caption class=title>表 21. DB-9 對 DB-9 Null-Modem 線</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">信號</th><th class="tableblock halign-left valign-top">針腳 #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">針腳 #</th><th class="tableblock halign-left valign-top">信號</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr></tbody></table><table id=nullmodem-db9-25 class="tableblock frame-none grid-all stretch"><caption class=title>表 22. DB-9 對 DB-25 Null-Modem 線</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">信號</th><th class="tableblock halign-left valign-top">針腳 #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">針腳 #</th><th class="tableblock halign-left valign-top">信號</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When one pin at one end connects to a pair of pins at the other end, it is usually implemented with one short wire between the pair of pins in their connector and a long wire to the other single pin.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Serial ports are the devices through which data is transferred between the FreeBSD host computer and the terminal. Several kinds of serial ports exist. Before purchasing or constructing a cable, make sure it will fit the ports on the terminal and on the FreeBSD system.</p></div><div class=paragraph><p>Most terminals have DB-25 ports. Personal computers may have DB-25 or DB-9 ports. A multiport serial card may have RJ-12 or RJ-45/ ports. See the documentation that accompanied the hardware for specifications on the kind of port or visually verify the type of port.</p></div><div class=paragraph><p>In FreeBSD, each serial port is accessed through an entry in <span class=filename>/dev</span>. There are two different kinds of entries:</p></div><div class=ulist><ul><li><p>Call-in ports are named <span class=filename>/dev/ttyuN</span> where <em>N</em> is the port number, starting from zero. If a terminal is connected to the first serial port (<span class=filename>COM1</span>), use <span class=filename>/dev/ttyu0</span> to refer to the terminal. If the terminal is on the second serial port (<span class=filename>COM2</span>), use <span class=filename>/dev/ttyu1</span>, and so forth. Generally, the call-in port is used for terminals. Call-in ports require that the serial line assert the "Data Carrier Detect" signal to work correctly.</p></li><li><p>Call-out ports are named <span class=filename>/dev/cuauN</span> on FreeBSD versions 8.X and higher and <span class=filename>/dev/cuadN</span> on FreeBSD versions 7.X and lower. Call-out ports are usually not used for terminals, but are used for modems. The call-out port can be used if the serial cable or the terminal does not support the "Data Carrier Detect" signal.</p></li></ul></div><div class=paragraph><p>FreeBSD also provides initialization devices (<span class=filename>/dev/ttyuN.init</span> and <span class=filename>/dev/cuauN.init</span> or <span class=filename>/dev/cuadN.init</span>) and locking devices (<span class=filename>/dev/ttyuN.lock</span> and <span class=filename>/dev/cuauN.lock</span> or <span class=filename>/dev/cuadN.lock</span>). The initialization devices are used to initialize communications port parameters each time a port is opened, such as <code>crtscts</code> for modems which use <code>RTS/CTS</code> signaling for flow control. The locking devices are used to lock flags on ports to prevent users or programs changing certain parameters. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=termios&amp;sektion=4&amp;format=html">termios(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> for information on terminal settings, locking and initializing devices, and setting terminal options, respectively.</p></div></div><div class=sect3><h4 id=serial-hw-config>26.2.2. 序列埠設定<a class=anchor href=#serial-hw-config></a></h4><div class=paragraph><p>By default, FreeBSD supports four serial ports which are commonly known as <span class=filename>COM1</span>, <span class=filename>COM2</span>, <span class=filename>COM3</span>, and <span class=filename>COM4</span>. FreeBSD also supports dumb multi-port serial interface cards, such as the BocaBoard 1008 and 2016, as well as more intelligent multi-port cards such as those made by Digiboard. However, the default kernel only looks for the standard <span class=filename>COM</span> ports.</p></div><div class=paragraph><p>To see if the system recognizes the serial ports, look for system boot messages that start with <code>uart</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep uart /var/run/dmesg.boot</span></code></pre></div></div><div class=paragraph><p>If the system does not recognize all of the needed serial ports, additional entries can be added to <span class=filename>/boot/device.hints</span>. This file already contains <code>hint.uart.0.*</code> entries for <span class=filename>COM1</span> and <code>hint.uart.1.*</code> entries for <span class=filename>COM2</span>. When adding a port entry for <span class=filename>COM3</span> use <code>0x3E8</code>, and for <span class=filename>COM4</span> use <code>0x2E8</code>. Common IRQ addresses are <code>5</code> for <span class=filename>COM3</span> and <code>9</code> for <span class=filename>COM4</span>.</p></div><div class=paragraph><p>To determine the default set of terminal I/O settings used by the port, specify its device name. This example determines the settings for the call-in port on <span class=filename>COM2</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -a -f /dev/ttyu1</span></code></pre></div></div><div class=paragraph><p>System-wide initialization of serial devices is controlled by <span class=filename>/etc/rc.d/serial</span>. This file affects the default settings of serial devices. To change the settings for a device, use <code>stty</code>. By default, the changed settings are in effect until the device is closed and when the device is reopened, it goes back to the default set. To permanently change the default set, open and adjust the settings of the initialization device. For example, to turn on <code>CLOCAL</code> mode, 8 bit communication, and <code>XON/XOFF</code> flow control for <span class=filename>ttyu5</span>, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</span></code></pre></div></div><div class=paragraph><p>To prevent certain settings from being changed by an application, make adjustments to the locking device. For example, to lock the speed of <span class=filename>ttyu5</span> to 57600 bps, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyu5.lock 57600</span></code></pre></div></div><div class=paragraph><p>Now, any application that opens <span class=filename>ttyu5</span> and tries to change the speed of the port will be stuck with 57600 bps.</p></div></div></div><div class=sect2><h3 id=term>26.3. 終端機<a class=anchor href=#term></a></h3><div class=paragraph><p>Terminals provide a convenient and low-cost way to access a FreeBSD system when not at the computer’s console or on a connected network. This section describes how to use terminals with FreeBSD.</p></div><div class=paragraph><p>The original UNIX™ systems did not have consoles. Instead, users logged in and ran programs through terminals that were connected to the computer’s serial ports.</p></div><div class=paragraph><p>The ability to establish a login session on a serial port still exists in nearly every UNIX™-like operating system today, including FreeBSD. By using a terminal attached to an unused serial port, a user can log in and run any text program that can normally be run on the console or in an <code>xterm</code> window.</p></div><div class=paragraph><p>Many terminals can be attached to a FreeBSD system. An older spare computer can be used as a terminal wired into a more powerful computer running FreeBSD. This can turn what might otherwise be a single-user computer into a powerful multiple-user system.</p></div><div class=paragraph><p>FreeBSD supports three types of terminals:</p></div><div class=dlist><dl><dt class=hdlist1>Dumb terminals</dt><dd><p>Dumb terminals are specialized hardware that connect to computers over serial lines. They are called "dumb" because they have only enough computational power to display, send, and receive text. No programs can be run on these devices. Instead, dumb terminals connect to a computer that runs the needed programs.</p><div class=paragraph><p>There are hundreds of kinds of dumb terminals made by many manufacturers, and just about any kind will work with FreeBSD. Some high-end terminals can even display graphics, but only certain software packages can take advantage of these advanced features.</p></div><div class=paragraph><p>Dumb terminals are popular in work environments where workers do not need access to graphical applications.</p></div></dd><dt class=hdlist1>Computers Acting as Terminals</dt><dd><p>Since a dumb terminal has just enough ability to display, send, and receive text, any spare computer can be a dumb terminal. All that is needed is the proper cable and some <em>terminal emulation</em> software to run on the computer.</p><div class=paragraph><p>This configuration can be useful. For example, if one user is busy working at the FreeBSD system’s console, another user can do some text-only work at the same time from a less powerful personal computer hooked up as a terminal to the FreeBSD system.</p></div><div class=paragraph><p>There are at least two utilities in the base-system of FreeBSD that can be used to work through a serial connection: <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a>.</p></div><div class=paragraph><p>For example, to connect from a client system that runs FreeBSD to the serial connection of another system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/cuauN</span></code></pre></div></div><div class=paragraph><p>Ports are numbered starting from zero. This means that <span class=filename>COM1</span> is <span class=filename>/dev/cuau0</span>.</p></div><div class=paragraph><p>Additional programs are available through the Ports Collection, such as <a class=package href=https://cgit.freebsd.org/ports/tree/comms/minicom/>comms/minicom</a>.</p></div></dd><dt class=hdlist1>X Terminals</dt><dd><p>X terminals are the most sophisticated kind of terminal available. Instead of connecting to a serial port, they usually connect to a network like Ethernet. Instead of being relegated to text-only applications, they can display any Xorg application.</p><div class=paragraph><p>This chapter does not cover the setup, configuration, or use of X terminals.</p></div></dd></dl></div><div class=sect3><h4 id=term-config>26.3.1. 終端機設定<a class=anchor href=#term-config></a></h4><div class=paragraph><p>This section describes how to configure a FreeBSD system to enable a login session on a serial terminal. It assumes that the system recognizes the serial port to which the terminal is connected and that the terminal is connected with the correct cable.</p></div><div class=paragraph><p>In FreeBSD, <code>init</code> reads <span class=filename>/etc/ttys</span> and starts a <code>getty</code> process on the available terminals. The <code>getty</code> process is responsible for reading a login name and starting the <code>login</code> program. The ports on the FreeBSD system which allow logins are listed in <span class=filename>/etc/ttys</span>. For example, the first virtual console, <span class=filename>ttyv0</span>, has an entry in this file, allowing logins on the console. This file also contains entries for the other virtual consoles, serial ports, and pseudo-ttys. For a hardwired terminal, the serial port’s <span class=filename>/dev</span> entry is listed without the <code>/dev</code> part. For example, <span class=filename>/dev/ttyv0</span> is listed as <code>ttyv0</code>.</p></div><div class=paragraph><p>The default <span class=filename>/etc/ttys</span> configures support for the first four serial ports, <span class=filename>ttyu0</span> through <span class=filename>ttyu3</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure
ttyu1   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure
ttyu2   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure
ttyu3   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure</pre></div></div><div class=paragraph><p>When attaching a terminal to one of those ports, modify the default entry to set the required speed and terminal type, to turn the device <code>on</code> and, if needed, to change the port’s <code>secure</code> setting. If the terminal is connected to another port, add an entry for the port.</p></div><div class=paragraph><p><a href=#ex-etc-ttys>設定終端機項目</a> configures two terminals in <span class=filename>/etc/ttys</span>. The first entry configures a Wyse-50 connected to <span class=filename>COM2</span>. The second entry configures an old computer running Procomm terminal software emulating a VT-100 terminal. The computer is connected to the sixth serial port on a multi-port serial card.</p></div><div id=ex-etc-ttys class=exampleblock><div class=title>例 45. 設定終端機項目</div><div class=content><div class="literalblock programlisting"><div class=content><pre>ttyu1  &#34;/usr/libexec/getty std.38400&#34;  wy50  on  insecure
ttyu5   &#34;/usr/libexec/getty std.19200&#34;  vt100  on insecure</pre></div></div><div class=ulist><ul><li><p>The first field specifies the device name of the serial terminal.</p></li><li><p>The second field tells <code>getty</code> to initialize and open the line, set the line speed, prompt for a user name, and then execute the <code>login</code> program. The optional <em>getty type</em> configures characteristics on the terminal line, like bps rate and parity. The available getty types are listed in <span class=filename>/etc/gettytab</span>. In almost all cases, the getty types that start with <code>std</code> will work for hardwired terminals as these entries ignore parity. There is a <code>std</code> entry for each bps rate from 110 to 115200. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> for more information.When setting the getty type, make sure to match the communications settings used by the terminal. For this example, the Wyse-50 uses no parity and connects at 38400 bps. The computer uses no parity and connects at 19200 bps.</p></li><li><p>The third field is the type of terminal. For dial-up ports, <code>unknown</code> or <code>dialup</code> is typically used since users may dial up with practically any type of terminal or software. Since the terminal type does not change for hardwired terminals, a real terminal type from <span class=filename>/etc/termcap</span> can be specified. For this example, the Wyse-50 uses the real terminal type while the computer running Procomm is set to emulate a VT-100.</p></li><li><p>The fourth field specifies if the port should be enabled. To enable logins on this port, this field must be set to <code>on</code>.</p></li><li><p>The final field is used to specify whether the port is secure. Marking a port as <code>secure</code> means that it is trusted enough to allow <code>root</code> to login from that port. Insecure ports do not allow <code>root</code> logins. On an insecure port, users must login from unprivileged accounts and then use <code>su</code> or a similar mechanism to gain superuser privileges, as described in <a href=./#users-superuser>超級使用者帳號</a>. For security reasons, it is recommended to change this setting to <code>insecure</code>.</p></li></ul></div></div></div><div class=paragraph><p>After making any changes to <span class=filename>/etc/ttys</span>, send a SIGHUP (hangup) signal to the <code>init</code> process to force it to re-read its configuration file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>Since <code>init</code> is always the first process run on a system, it always has a process ID of <code>1</code>.</p></div><div class=paragraph><p>If everything is set up correctly, all cables are in place, and the terminals are powered up, a <code>getty</code> process should now be running on each terminal and login prompts should be available on each terminal.</p></div></div><div class=sect3><h4 id=term-debug>26.3.2. 連線疑難排解<a class=anchor href=#term-debug></a></h4><div class=paragraph><p>Even with the most meticulous attention to detail, something could still go wrong while setting up a terminal. Here is a list of common symptoms and some suggested fixes.</p></div><div class=paragraph><p>If no login prompt appears, make sure the terminal is plugged in and powered up. If it is a personal computer acting as a terminal, make sure it is running terminal emulation software on the correct serial port.</p></div><div class=paragraph><p>Make sure the cable is connected firmly to both the terminal and the FreeBSD computer. Make sure it is the right kind of cable.</p></div><div class=paragraph><p>Make sure the terminal and FreeBSD agree on the bps rate and parity settings. For a video display terminal, make sure the contrast and brightness controls are turned up. If it is a printing terminal, make sure paper and ink are in good supply.</p></div><div class=paragraph><p>Use <code>ps</code> to make sure that a <code>getty</code> process is running and serving the terminal. For example, the following listing shows that a <code>getty</code> is running on the second serial port, <span class=filename>ttyu1</span>, and is using the <code>std.38400</code> entry in <span class=filename>/etc/gettytab</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps -axww|grep ttyu</span>
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</code></pre></div></div><div class=paragraph><p>If no <code>getty</code> process is running, make sure the port is enabled in <span class=filename>/etc/ttys</span>. Remember to run <code>kill -HUP 1</code> after modifying <span class=filename>/etc/ttys</span>.</p></div><div class=paragraph><p>If the <code>getty</code> process is running but the terminal still does not display a login prompt, or if it displays a prompt but will not accept typed input, the terminal or cable may not support hardware handshaking. Try changing the entry in <span class=filename>/etc/ttys</span> from <code>std.38400</code> to <code>3wire.38400</code>, then run <code>kill -HUP 1</code> after modifying <span class=filename>/etc/ttys</span>. The <code>3wire</code> entry is similar to <code>std</code>, but ignores hardware handshaking. The baud rate may need to be reduced or software flow control enabled when using <code>3wire</code> to prevent buffer overflows.</p></div><div class=paragraph><p>If garbage appears instead of a login prompt, make sure the terminal and FreeBSD agree on the bps rate and parity settings. Check the <code>getty</code> processes to make sure the correct <em>getty</em> type is in use. If not, edit <span class=filename>/etc/ttys</span> and run <code>kill -HUP 1</code>.</p></div><div class=paragraph><p>If characters appear doubled and the password appears when typed, switch the terminal, or the terminal emulation software, from "half duplex" or "local echo" to "full duplex."</p></div></div></div><div class=sect2><h3 id=dialup>26.4. 撥入服務<a class=anchor href=#dialup></a></h3><div class=paragraph><p>Configuring a FreeBSD system for dial-in service is similar to configuring terminals, except that modems are used instead of terminal devices. FreeBSD supports both external and internal modems.</p></div><div class=paragraph><p>External modems are more convenient because they often can be configured via parameters stored in non-volatile RAM and they usually provide lighted indicators that display the state of important RS-232 signals, indicating whether the modem is operating properly.</p></div><div class=paragraph><p>Internal modems usually lack non-volatile RAM, so their configuration may be limited to setting DIP switches. If the internal modem has any signal indicator lights, they are difficult to view when the system’s cover is in place.</p></div><div class=paragraph><p>When using an external modem, a proper cable is needed. A standard RS-232C serial cable should suffice.</p></div><div class=paragraph><p>FreeBSD needs the RTS and CTS signals for flow control at speeds above 2400 bps, the CD signal to detect when a call has been answered or the line has been hung up, and the DTR signal to reset the modem after a session is complete. Some cables are wired without all of the needed signals, so if a login session does not go away when the line hangs up, there may be a problem with the cable. Refer to <a href=#term-cables-null>序列線與埠</a> for more information about these signals.</p></div><div class=paragraph><p>Like other UNIX™-like operating systems, FreeBSD uses the hardware signals to find out when a call has been answered or a line has been hung up and to hangup and reset the modem after a call. FreeBSD avoids sending commands to the modem or watching for status reports from the modem.</p></div><div class=paragraph><p>FreeBSD supports the NS8250, NS16450, NS16550, and NS16550A-based RS-232C (CCITT V.24) communications interfaces. The 8250 and 16450 devices have single-character buffers. The 16550 device provides a 16-character buffer, which allows for better system performance. Bugs in plain 16550 devices prevent the use of the 16-character buffer, so use 16550A devices if possible. Because single-character-buffer devices require more work by the operating system than the 16-character-buffer devices, 16550A-based serial interface cards are preferred. If the system has many active serial ports or will have a heavy load, 16550A-based cards are better for low-error-rate communications.</p></div><div class=paragraph><p>The rest of this section demonstrates how to configure a modem to receive incoming connections, how to communicate with the modem, and offers some troubleshooting tips.</p></div><div class=sect3><h4 id=dialup-ttys>26.4.1. 數據機設定<a class=anchor href=#dialup-ttys></a></h4><div class=paragraph><p>As with terminals, <code>init</code> spawns a <code>getty</code> process for each configured serial port used for dial-in connections. When a user dials the modem’s line and the modems connect, the "Carrier Detect" signal is reported by the modem. The kernel notices that the carrier has been detected and instructs <code>getty</code> to open the port and display a <code>login:</code> prompt at the specified initial line speed. In a typical configuration, if garbage characters are received, usually due to the modem’s connection speed being different than the configured speed, <code>getty</code> tries adjusting the line speeds until it receives reasonable characters. After the user enters their login name, <code>getty</code> executes <code>login</code>, which completes the login process by asking for the user’s password and then starting the user’s shell.</p></div><div class=paragraph><p>There are two schools of thought regarding dial-up modems. One configuration method is to set the modems and systems so that no matter at what speed a remote user dials in, the dial-in RS-232 interface runs at a locked speed. The benefit of this configuration is that the remote user always sees a system login prompt immediately. The downside is that the system does not know what a user’s true data rate is, so full-screen programs like Emacs will not adjust their screen-painting methods to make their response better for slower connections.</p></div><div class=paragraph><p>The second method is to configure the RS-232 interface to vary its speed based on the remote user’s connection speed. Because <code>getty</code> does not understand any particular modem’s connection speed reporting, it gives a <code>login:</code> message at an initial speed and watches the characters that come back in response. If the user sees junk, they should press <kbd>Enter</kbd> until they see a recognizable prompt. If the data rates do not match, <code>getty</code> sees anything the user types as junk, tries the next speed, and gives the <code>login:</code> prompt again. This procedure normally only takes a keystroke or two before the user sees a good prompt. This login sequence does not look as clean as the locked-speed method, but a user on a low-speed connection should receive better interactive response from full-screen programs.</p></div><div class=paragraph><p>When locking a modem’s data communications rate at a particular speed, no changes to <span class=filename>/etc/gettytab</span> should be needed. However, for a matching-speed configuration, additional entries may be required in order to define the speeds to use for the modem. This example configures a 14.4 Kbps modem with a top interface speed of 19.2 Kbps using 8-bit, no parity connections. It configures <code>getty</code> to start the communications rate for a V.32bis connection at 19.2 Kbps, then cycles through 9600 bps, 2400 bps, 1200 bps, 300 bps, and back to 19.2 Kbps. Communications rate cycling is implemented with the <code>nx=</code> (next table) capability. Each line uses a <code>tc=</code> (table continuation) entry to pick up the rest of the settings for a particular data rate.</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</pre></div></div><div class=paragraph><p>For a 28.8 Kbps modem, or to take advantage of compression on a 14.4 Kbps modem, use a higher communications rate, as seen in this example:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</pre></div></div><div class=paragraph><p>For a slow CPU or a heavily loaded system without 16550A-based serial ports, this configuration may produce <code>sio</code> "silo" errors at 57.6 Kbps.</p></div><div class=paragraph><p>The configuration of <span class=filename>/etc/ttys</span> is similar to <a href=#ex-etc-ttys>設定終端機項目</a>, but a different argument is passed to <code>getty</code> and <code>dialup</code> is used for the terminal type. Replace <em>xxx</em> with the process <code>init</code> will run on the device:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty xxx&#34;   dialup on</pre></div></div><div class=paragraph><p>The <code>dialup</code> terminal type can be changed. For example, setting <code>vt102</code> as the default terminal type allows users to use VT102 emulation on their remote systems.</p></div><div class=paragraph><p>For a locked-speed configuration, specify the speed with a valid type listed in <span class=filename>/etc/gettytab</span>. This example is for a modem whose port speed is locked at 19.2 Kbps:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty std.19200&#34;   dialup on</pre></div></div><div class=paragraph><p>In a matching-speed configuration, the entry needs to reference the appropriate beginning "auto-baud" entry in <span class=filename>/etc/gettytab</span>. To continue the example for a matching-speed modem that starts at 19.2 Kbps, use this entry:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty V19200&#34;   dialup on</pre></div></div><div class=paragraph><p>After editing <span class=filename>/etc/ttys</span>, wait until the modem is properly configured and connected before signaling <code>init</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>High-speed modems, like V.32, V.32bis, and V.34 modems, use hardware (<code>RTS/CTS</code>) flow control. Use <code>stty</code> to set the hardware flow control flag for the modem port. This example sets the <code>crtscts</code> flag on <span class=filename>COM2</span>'s dial-in and dial-out initialization devices:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyu1.init crtscts</span>
<span class=c># stty -f /dev/cuau1.init crtscts</span></code></pre></div></div></div><div class=sect3><h4 id=_疑難排解_4>26.4.2. 疑難排解<a class=anchor href=#_疑難排解_4></a></h4><div class=paragraph><p>This section provides a few tips for troubleshooting a dial-up modem that will not connect to a FreeBSD system.</p></div><div class=paragraph><p>Hook up the modem to the FreeBSD system and boot the system. If the modem has status indication lights, watch to see whether the modem’s DTR indicator lights when the <code>login:</code> prompt appears on the system’s console. If it lights up, that should mean that FreeBSD has started a <code>getty</code> process on the appropriate communications port and is waiting for the modem to accept a call.</p></div><div class=paragraph><p>If the DTR indicator does not light, login to the FreeBSD system through the console and type <code>ps ax</code> to see if FreeBSD is running a <code>getty</code> process on the correct port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0</code></pre></div></div><div class=paragraph><p>If the second column contains a <code>d0</code> instead of a <code>??</code> and the modem has not accepted a call yet, this means that <code>getty</code> has completed its open on the communications port. This could indicate a problem with the cabling or a misconfigured modem because <code>getty</code> should not be able to open the communications port until the carrier detect signal has been asserted by the modem.</p></div><div class=paragraph><p>If no <code>getty</code> processes are waiting to open the port, double-check that the entry for the port is correct in <span class=filename>/etc/ttys</span>. Also, check <span class=filename>/var/log/messages</span> to see if there are any log messages from <code>init</code> or <code>getty</code>.</p></div><div class=paragraph><p>Next, try dialing into the system. Be sure to use 8 bits, no parity, and 1 stop bit on the remote system. If a prompt does not appear right away, or the prompt shows garbage, try pressing <kbd>Enter</kbd> about once per second. If there is still no <code>login:</code> prompt, try sending a <code>BREAK</code>. When using a high-speed modem, try dialing again after locking the dialing modem’s interface speed.</p></div><div class=paragraph><p>If there is still no <code>login:</code> prompt, check <span class=filename>/etc/gettytab</span> again and double-check that:</p></div><div class=ulist><ul><li><p>The initial capability name specified in the entry in <span class=filename>/etc/ttys</span> matches the name of a capability in <span class=filename>/etc/gettytab</span>.</p></li><li><p>Each <code>nx=</code> entry matches another <span class=filename>gettytab</span> capability name.</p></li><li><p>Each <code>tc=</code> entry matches another <span class=filename>gettytab</span> capability name.</p></li></ul></div><div class=paragraph><p>If the modem on the FreeBSD system will not answer, make sure that the modem is configured to answer the phone when DTR is asserted. If the modem seems to be configured correctly, verify that the DTR line is asserted by checking the modem’s indicator lights.</p></div><div class=paragraph><p>If it still does not work, try sending an email to the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>FreeBSD general questions mailing list</a> describing the modem and the problem.</p></div></div></div><div class=sect2><h3 id=dialout>26.5. 撥出服務<a class=anchor href=#dialout></a></h3><div class=paragraph><p>The following are tips for getting the host to connect over the modem to another computer. This is appropriate for establishing a terminal session with a remote host.</p></div><div class=paragraph><p>This kind of connection can be helpful to get a file on the Internet if there are problems using PPP. If PPP is not working, use the terminal session to FTP the needed file. Then use zmodem to transfer it to the machine.</p></div><div class=sect3><h4 id=hayes-unsupported>26.5.1. 使用 Stock Hayes 數據機<a class=anchor href=#hayes-unsupported></a></h4><div class=paragraph><p>A generic Hayes dialer is built into <code>tip</code>. Use <code>at=hayes</code> in <span class=filename>/etc/remote</span>.</p></div><div class=paragraph><p>The Hayes driver is not smart enough to recognize some of the advanced features of newer modems messages like <code>BUSY</code>, <code>NO DIALTONE</code>, or <code>CONNECT 115200</code>. Turn those messages off when using <code>tip</code> with <code>ATX0&amp;W</code>.</p></div><div class=paragraph><p>The dial timeout for <code>tip</code> is 60 seconds. The modem should use something less, or else <code>tip</code> will think there is a communication problem. Try <code>ATS7=45&amp;W</code>.</p></div></div><div class=sect3><h4 id=direct-at>26.5.2. 使用 <code>AT</code> 指令<a class=anchor href=#direct-at></a></h4><div class=paragraph><p>Create a "direct" entry in <span class=filename>/etc/remote</span>. For example, if the modem is hooked up to the first serial port, <span class=filename>/dev/cuau0</span>, use the following line:</p></div><div class="literalblock programlisting"><div class=content><pre>cuau0:dv=/dev/cuau0:br#19200:pa=none</pre></div></div><div class=paragraph><p>Use the highest bps rate the modem supports in the <code>br</code> capability. Then, type <code>tip cuau0</code> to connect to the modem.</p></div><div class=paragraph><p>Or, use <code>cu</code> as <code>root</code> with the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -lline -sspeed</span></code></pre></div></div><div class=paragraph><p><em>line</em> is the serial port, such as <span class=filename>/dev/cuau0</span>, and <em>speed</em> is the speed, such as <code>57600</code>. When finished entering the AT commands, type <code>~.</code> to exit.</p></div></div><div class=sect3><h4 id=gt-failure>26.5.3. <code>@</code> 符號無法運作<a class=anchor href=#gt-failure></a></h4><div class=paragraph><p>The <code>@</code> sign in the phone number capability tells <code>tip</code> to look in <span class=filename>/etc/phones</span> for a phone number. But, the <code>@</code> sign is also a special character in capability files like <span class=filename>/etc/remote</span>, so it needs to be escaped with a backslash:</p></div><div class="literalblock programlisting"><div class=content><pre>pn=\@</pre></div></div></div><div class=sect3><h4 id=dial-command-line>26.5.4. 從指令列撥號<a class=anchor href=#dial-command-line></a></h4><div class=paragraph><p>Put a "generic" entry in <span class=filename>/etc/remote</span>. For example:</p></div><div class="literalblock programlisting"><div class=content><pre>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>This should now work:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tip -115200 5551234</span></code></pre></div></div><div class=paragraph><p>Users who prefer <code>cu</code> over <code>tip</code>, can use a generic <code>cu</code> entry:</p></div><div class="literalblock programlisting"><div class=content><pre>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>and type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu 5551234 -s 115200</span></code></pre></div></div></div><div class=sect3><h4 id=set-bps>26.5.5. 設定 bps 率<a class=anchor href=#set-bps></a></h4><div class=paragraph><p>Put in an entry for <code>tip1200</code> or <code>cu1200</code>, but go ahead and use whatever bps rate is appropriate with the <code>br</code> capability. <code>tip</code> thinks a good default is 1200 bps which is why it looks for a <code>tip1200</code> entry. 1200 bps does not have to be used, though.</p></div></div><div class=sect3><h4 id=terminal-server>26.5.6. 透過終端伺服器存取多個主機<a class=anchor href=#terminal-server></a></h4><div class=paragraph><p>Rather than waiting until connected and typing <code>CONNECT <em>host</em></code> each time, use <code>tip</code>'s <code>cm</code> capability. For example, these entries in <span class=filename>/etc/remote</span> will let you type <code>tip pain</code> or <code>tip muffin</code> to connect to the hosts <code>pain</code> or <code>muffin</code>, and <code>tip deep13</code> to connect to the terminal server.</p></div><div class="literalblock programlisting"><div class=content><pre>pain|pain.deep13.com|Forrester&#39;s machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank&#39;s machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:</pre></div></div></div><div class=sect3><h4 id=tip-multiline>26.5.7. 在 <code>tip</code> 使用超過一行<a class=anchor href=#tip-multiline></a></h4><div class=paragraph><p>This is often a problem where a university has several modem lines and several thousand students trying to use them.</p></div><div class=paragraph><p>Make an entry in <span class=filename>/etc/remote</span> and use <code>@</code> for the <code>pn</code> capability:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:</pre></div></div><div class=paragraph><p>Then, list the phone numbers in <span class=filename>/etc/phones</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</pre></div></div><div class=paragraph><p><code>tip</code> will try each number in the listed order, then give up. To keep retrying, run <code>tip</code> in a <code>while</code> loop.</p></div></div><div class=sect3><h4 id=multi-controlp>26.5.8. 使用強制字元<a class=anchor href=#multi-controlp></a></h4><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> is the default "force" character, used to tell <code>tip</code> that the next character is literal data. The force character can be set to any other character with the <code>~s</code> escape, which means "set a variable."</p></div><div class=paragraph><p>Type <code>~sforce=<em>single-char</em></code> followed by a newline. <em>single-char</em> is any single character. If <em>single-char</em> is left out, then the force character is the null character, which is accessed by typing <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> or <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Space</kbd></span>. A pretty good value for <em>single-char</em> is <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span>, which is only used on some terminal servers.</p></div><div class=paragraph><p>To change the force character, specify the following in <span class=filename>~/.tiprc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>force=single-char</pre></div></div></div><div class=sect3><h4 id=uppercase>26.5.9. 大寫字元<a class=anchor href=#uppercase></a></h4><div class=paragraph><p>This happens when <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span> is pressed, which is <code>tip</code>'s "raise character", specially designed for people with broken caps-lock keys. Use <code>~s</code> to set <code>raisechar</code> to something reasonable. It can be set to be the same as the force character, if neither feature is used.</p></div><div class=paragraph><p>Here is a sample <span class=filename>~/.tiprc</span> for Emacs users who need to type <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> and <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span>:</p></div><div class="literalblock programlisting"><div class=content><pre>force=^^
raisechar=^^</pre></div></div><div class=paragraph><p>The <code>^^</code> is <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span>.</p></div></div><div class=sect3><h4 id=tip-filetransfer>26.5.10. 使用 <code>tip</code> 傳輸檔案<a class=anchor href=#tip-filetransfer></a></h4><div class=paragraph><p>When talking to another UNIX™-like operating system, files can be sent and received using <code>~p</code> (put) and <code>~t</code> (take). These commands run <code>cat</code> and <code>echo</code> on the remote system to accept and send files. The syntax is:</p></div><div class=paragraph><p><code>~p</code> local-file [ remote-file ]</p></div><div class=paragraph><p><code>~t</code> remote-file [ local-file ]</p></div><div class=paragraph><p>There is no error checking, so another protocol, like zmodem, should probably be used.</p></div></div><div class=sect3><h4 id=zmodem-tip>26.5.11. 在 zmodem 使用 <code>tip</code>?<a class=anchor href=#zmodem-tip></a></h4><div class=paragraph><p>To receive files, start the sending program on the remote end. Then, type <code>~C rz</code> to begin receiving them locally.</p></div><div class=paragraph><p>To send files, start the receiving program on the remote end. Then, type <code>~C sz <em>files</em></code> to send them to the remote system.</p></div></div></div><div class=sect2><h3 id=serialconsole-setup>26.6. 設定序列 Console<a class=anchor href=#serialconsole-setup></a></h3><div class=paragraph><p>FreeBSD has the ability to boot a system with a dumb terminal on a serial port as a console. This configuration is useful for system administrators who wish to install FreeBSD on machines that have no keyboard or monitor attached, and developers who want to debug the kernel or device drivers.</p></div><div class=paragraph><p>As described in <a href=./#boot>FreeBSD 開機程序</a>, FreeBSD employs a three stage bootstrap. The first two stages are in the boot block code which is stored at the beginning of the FreeBSD slice on the boot disk. The boot block then loads and runs the boot loader as the third stage code.</p></div><div class=paragraph><p>In order to set up booting from a serial console, the boot block code, the boot loader code, and the kernel need to be configured.</p></div><div class=sect3><h4 id=serialconsole-howto-fast>26.6.1. 快速序列 Console 設定<a class=anchor href=#serialconsole-howto-fast></a></h4><div class=paragraph><p>This section provides a fast overview of setting up the serial console. This procedure can be used when the dumb terminal is connected to <span class=filename>COM1</span>.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configuring a Serial Console on <span class=filename>COM1</span></strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Connect the serial cable to <span class=filename>COM1</span> and the controlling terminal.</p></li><li><p>To configure boot messages to display on the serial console, issue the following command as the superuser:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sysrc <span class=nt>-f</span> /boot/loader.conf <span class=nv>console</span><span class=o>=</span>comconsole</code></pre></div></div></li><li><p>Edit <span class=filename>/etc/ttys</span> and change <code>off</code> to <code>on</code> and <code>dialup</code> to <code>vt100</code> for the <span class=filename>ttyu0</span> entry. Otherwise, a password will not be required to connect via the serial console, resulting in a potential security hole.</p></li><li><p>Reboot the system to see if the changes took effect.</p></li></ol></div></div></div><div class=paragraph><p>If a different configuration is required, see the next section for a more in-depth configuration explanation.</p></div></div><div class=sect3><h4 id=serialconsole-howto>26.6.2. 深入序列 Console 設定<a class=anchor href=#serialconsole-howto></a></h4><div class=paragraph><p>This section provides a more detailed explanation of the steps needed to setup a serial console in FreeBSD.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configuring a Serial Console</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Prepare a serial cable.</p><div class=paragraph><p>Use either a null-modem cable or a standard serial cable and a null-modem adapter. See <a href=#term-cables-null>序列線與埠</a> for a discussion on serial cables.</p></div></li><li><p>Unplug the keyboard.</p><div class=paragraph><p>Many systems probe for the keyboard during the Power-On Self-Test (POST) and will generate an error if the keyboard is not detected. Some machines will refuse to boot until the keyboard is plugged in.</p></div><div class=paragraph><p>If the computer complains about the error, but boots anyway, no further configuration is needed.</p></div><div class=paragraph><p>If the computer refuses to boot without a keyboard attached, configure the BIOS so that it ignores this error. Consult the motherboard’s manual for details on how to do this.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Try setting the keyboard to "Not installed" in the BIOS. This setting tells the BIOS not to probe for a keyboard at power-on so it should not complain if the keyboard is absent. If that option is not present in the BIOS, look for an "Halt on Error" option instead. Setting this to "All but Keyboard" or to "No Errors" will have the same effect.</p></div></td></tr></tbody></table></div><div class=paragraph><p>If the system has a PS/2™ mouse, unplug it as well. PS/2™ mice share some hardware with the keyboard and leaving the mouse plugged in can fool the keyboard probe into thinking the keyboard is still there.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>While most systems will boot without a keyboard, quite a few will not boot without a graphics adapter. Some systems can be configured to boot with no graphics adapter by changing the "graphics adapter" setting in the BIOS configuration to "Not installed". Other systems do not support this option and will refuse to boot if there is no display hardware in the system. With these machines, leave some kind of graphics card plugged in, even if it is just a junky mono board. A monitor does not need to be attached.</p></div></td></tr></tbody></table></div></li><li><p>Plug a dumb terminal, an old computer with a modem program, or the serial port on another UNIX™ box into the serial port.</p></li><li><p>Add the appropriate <code>hint.sio.*</code> entries to <span class=filename>/boot/device.hints</span> for the serial port. Some multi-port cards also require kernel configuration options. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> for the required options and device hints for each supported serial port.</p></li><li><p>Create <span class=filename>boot.config</span> in the root directory of the <code>a</code> partition on the boot drive.</p><div class=paragraph><p>This file instructs the boot block code how to boot the system. In order to activate the serial console, one or more of the following options are needed. When using multiple options, include them all on the same line:</p></div><div class=dlist><dl><dt class=hdlist1><code>-h</code></dt><dd><p>Toggles between the internal and serial consoles. Use this to switch console devices. For instance, to boot from the internal (video) console, use <code>-h</code> to direct the boot loader and the kernel to use the serial port as its console device. Alternatively, to boot from the serial port, use <code>-h</code> to tell the boot loader and the kernel to use the video display as the console instead.</p></dd><dt class=hdlist1><code>-D</code></dt><dd><p>Toggles between the single and dual console configurations. In the single configuration, the console will be either the internal console (video display) or the serial port, depending on the state of <code>-h</code>. In the dual console configuration, both the video display and the serial port will become the console at the same time, regardless of the state of <code>-h</code>. However, the dual console configuration takes effect only while the boot block is running. Once the boot loader gets control, the console specified by <code>-h</code> becomes the only console.</p></dd><dt class=hdlist1><code>-P</code></dt><dd><p>Makes the boot block probe the keyboard. If no keyboard is found, the <code>-D</code> and <code>-h</code> options are automatically set.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Due to space constraints in the current version of the boot blocks, <code>-P</code> is capable of detecting extended keyboards only. Keyboards with less than 101 keys and without F11 and F12 keys may not be detected. Keyboards on some laptops may not be properly found because of this limitation. If this is the case, do not use <code>-P</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Use either <code>-P</code> to select the console automatically or <code>-h</code> to activate the serial console. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=boot.config&amp;sektion=5&amp;format=html">boot.config(5)</a> for more details.</p></div><div class=paragraph><p>The options, except for <code>-P</code>, are passed to the boot loader. The boot loader will determine whether the internal video or the serial port should become the console by examining the state of <code>-h</code>. This means that if <code>-D</code> is specified but <code>-h</code> is not specified in <span class=filename>/boot.config</span>, the serial port can be used as the console only during the boot block as the boot loader will use the internal video display as the console.</p></div></dd></dl></div></li><li><p>Boot the machine.</p><div class=paragraph><p>When FreeBSD starts, the boot blocks echo the contents of <span class=filename>/boot.config</span> to the console. For example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/boot.config: <span class=nt>-P</span>
Keyboard: no</code></pre></div></div><div class=paragraph><p>The second line appears only if <code>-P</code> is in <span class=filename>/boot.config</span> and indicates the presence or absence of the keyboard. These messages go to either the serial or internal console, or both, depending on the option in <span class=filename>/boot.config</span>:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Options</th><th class="tableblock halign-left valign-top">Message goes to</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>none</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>internal console</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serial console</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serial and internal consoles</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serial and internal consoles</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, keyboard present</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>internal console</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, keyboard absent</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serial console</p></td></tr></tbody></table><div class=paragraph><p>After the message, there will be a small pause before the boot blocks continue loading the boot loader and before any further messages are printed to the console. Under normal circumstances, there is no need to interrupt the boot blocks, but one can do so in order to make sure things are set up correctly.</p></div><div class=paragraph><p>Press any key, other than <kbd>Enter</kbd>, at the console to interrupt the boot process. The boot blocks will then prompt for further action:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div><div class=paragraph><p>Verify that the above message appears on either the serial or internal console, or both, according to the options in <span class=filename>/boot.config</span>. If the message appears in the correct console, press <kbd>Enter</kbd> to continue the boot process.</p></div><div class=paragraph><p>If there is no prompt on the serial terminal, something is wrong with the settings. Enter <code>-h</code> then <kbd>Enter</kbd> or <kbd>Return</kbd> to tell the boot block (and then the boot loader and the kernel) to choose the serial port for the console. Once the system is up, go back and check what went wrong.</p></div></li></ol></div></div></div><div class=paragraph><p>During the third stage of the boot process, one can still switch between the internal console and the serial console by setting appropriate environment variables in the boot loader. See <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> for more information.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This line in <span class=filename>/boot/loader.conf</span> or <span class=filename>/boot/loader.conf.local</span> configures the boot loader and the kernel to send their boot messages to the serial console, regardless of the options in <span class=filename>/boot.config</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>console=&#34;comconsole&#34;</pre></div></div><div class=paragraph><p>That line should be the first line of <span class=filename>/boot/loader.conf</span> so that boot messages are displayed on the serial console as early as possible.</p></div><div class=paragraph><p>If that line does not exist, or if it is set to <code>console="vidconsole"</code>, the boot loader and the kernel will use whichever console is indicated by <code>-h</code> in the boot block. See <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> for more information.</p></div><div class=paragraph><p>At the moment, the boot loader has no option equivalent to <code>-P</code> in the boot block, and there is no provision to automatically select the internal console and the serial console based on the presence of the keyboard.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>While it is not required, it is possible to provide a <code>login</code> prompt over the serial line. To configure this, edit the entry for the serial port in <span class=filename>/etc/ttys</span> using the instructions in <a href=#term-config>終端機設定</a>. If the speed of the serial port has been changed, change <code>std.9600</code> to match the new setting.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_設定使用更快的序列埠速度>26.6.3. 設定使用更快的序列埠速度<a class=anchor href=#_設定使用更快的序列埠速度></a></h4><div class=paragraph><p>By default, the serial port settings are 9600 baud, 8 bits, no parity, and 1 stop bit. To change the default console speed, use one of the following options:</p></div><div class=ulist><ul><li><p>Edit <span class=filename>/etc/make.conf</span> and set <code>BOOT_COMCONSOLE_SPEED</code> to the new console speed. Then, recompile and install the boot blocks and the boot loader:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/boot</span>
<span class=c># make clean</span>
<span class=c># make</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>If the serial console is configured in some other way than by booting with <code>-h</code>, or if the serial console used by the kernel is different from the one used by the boot blocks, add the following option, with the desired speed, to a custom kernel configuration file and compile a new kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options CONSPEED=19200</pre></div></div></li><li><p>Add the <code>-S_19200_</code> boot option to <span class=filename>/boot.config</span>, replacing <em>19200</em> with the speed to use.</p></li><li><p>Add the following options to <span class=filename>/boot/loader.conf</span>. Replace <em>115200</em> with the speed to use.</p><div class="literalblock programlisting"><div class=content><pre>boot_multicons=&#34;YES&#34;
boot_serial=&#34;YES&#34;
comconsole_speed=&#34;115200&#34;
console=&#34;comconsole,vidconsole&#34;</pre></div></div></li></ul></div></div><div class=sect3><h4 id=serialconsole-ddb>26.6.4. 從序列線路 (Serial Line) 進入 DDB 除錯程式<a class=anchor href=#serialconsole-ddb></a></h4><div class=paragraph><p>To configure the ability to drop into the kernel debugger from the serial console, add the following options to a custom kernel configuration file and compile the kernel using the instructions in <a href=./#kernelconfig>設定 FreeBSD 核心</a>. Note that while this is useful for remote diagnostics, it is also dangerous if a spurious BREAK is generated on the serial port. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=8&amp;format=html">ddb(8)</a> for more information about the kernel debugger.</p></div><div class="literalblock programlisting"><div class=content><pre>options BREAK_TO_DEBUGGER
options DDB</pre></div></div></div></div></div></div><div class=sect1><h2 id=ppp-and-slip>Chapter 27. PPP<a class=anchor href=#ppp-and-slip></a></h2><div class=sectionbody><div class=sect2><h3 id=ppp-and-slip-synopsis>27.1. 概述<a class=anchor href=#ppp-and-slip-synopsis></a></h3><div class=paragraph><p>FreeBSD 支援點對點 (Point-to-Point, PPP) 通訊協定，可透過撥號數據機用來建立網路或網際網路連線。本章將說明如何設定在 FreeBSD 中以數據機為基礎的通訊服務。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>如何設定、使用 PPP 連線及排除問題。</p></li><li><p>如何設定在乙太網路 (Ethernet) 上的 PPP (PPPoE)。</p></li><li><p>如何設定在 ATM 上的 PPP (PPPoA)。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>熟悉基本網路術語。</p></li><li><p>了解撥號連線及 PPP 的基礎及目的。</p></li></ul></div></div><div class=sect2><h3 id=userppp>27.2. 設定 PPP<a class=anchor href=#userppp></a></h3><div class=paragraph><p>FreeBSD provides built-in support for managing dial-up PPP connections using <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>. The default FreeBSD kernel provides support for <span class=filename>tun</span> which is used to interact with a modem hardware. Configuration is performed by editing at least one configuration file, and configuration files containing examples are provided. Finally, <code>ppp</code> is used to start and manage connections.</p></div><div class=paragraph><p>In order to use a PPP connection, the following items are needed:</p></div><div class=ulist><ul><li><p>A dial-up account with an Internet Service Provider (ISP).</p></li><li><p>A dial-up modem.</p></li><li><p>The dial-up number for the ISP.</p></li><li><p>The login name and password assigned by the ISP.</p></li><li><p>The IP address of one or more DNS servers. Normally, the ISP provides these addresses. If it did not, FreeBSD can be configured to use DNS negotiation.</p></li></ul></div><div class=paragraph><p>If any of the required information is missing, contact the ISP.</p></div><div class=paragraph><p>The following information may be supplied by the ISP, but is not necessary:</p></div><div class=ulist><ul><li><p>The IP address of the default gateway. If this information is unknown, the ISP will automatically provide the correct value during connection setup. When configuring PPP on FreeBSD, this address is referred to as <code>HISADDR</code>.</p></li><li><p>The subnet mask. If the ISP has not provided one, <code>255.255.255.255</code> will be used in the <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> configuration file.
*</p><div class=paragraph><p>If the ISP has assigned a static IP address and hostname, it should be input into the configuration file. Otherwise, this information will be automatically provided during connection setup.</p></div></li></ul></div><div class=paragraph><p>The rest of this section demonstrates how to configure FreeBSD for common PPP connection scenarios. The required configuration file is <span class=filename>/etc/ppp/ppp.conf</span> and additional files and examples are available in <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Throughout this section, many of the file examples display line numbers. These line numbers have been added to make it easier to follow the discussion and are not meant to be placed in the actual file.</p></div><div class=paragraph><p>When editing a configuration file, proper indentation is important. Lines that end in a <code>:</code> start in the first column (beginning of the line) while all other lines should be indented as shown using spaces or tabs.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=userppp-staticIP>27.2.1. 基礎設定<a class=anchor href=#userppp-staticIP></a></h4><div class=paragraph><p>In order to configure a PPP connection, first edit <span class=filename>/etc/ppp/ppp.conf</span> with the dial-in information for the ISP. This file is described as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>1     default:
2       set log Phase Chat LCP IPCP CCP tun command
3       ident user-ppp VERSION
4       set device /dev/cuau0
5       set speed 115200
6       set dial &#34;ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \
7                 \&#34;\&#34; AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT&#34;
8       set timeout 180
9       enable dns
10
11    provider:
12      set phone &#34;(123) 456 7890&#34;
13      set authname foo
14      set authkey bar
15      set timeout 300
16      set ifaddr x.x.x.x/0 y.y.y.y/0 255.255.255.255 0.0.0.0
17      add default HISADDR</pre></div></div><div class=dlist><dl><dt class=hdlist1>Line 1</dt><dd><p>Identifies the <code>default</code> entry. Commands in this entry (lines 2 through 9) are executed automatically when <code>ppp</code> is run.</p></dd><dt class=hdlist1>Line 2</dt><dd><p>Enables verbose logging parameters for testing the connection. Once the configuration is working satisfactorily, this line should be reduced to:</p><div class="literalblock programlisting"><div class=content><pre>set log phase tun</pre></div></div></dd><dt class=hdlist1>Line 3</dt><dd><p>Displays the version of <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> to the PPP software running on the other side of the connection.</p></dd><dt class=hdlist1>Line 4</dt><dd><p>Identifies the device to which the modem is connected, where <span class=filename>COM1</span> is <span class=filename>/dev/cuau0</span> and <span class=filename>COM2</span> is <span class=filename>/dev/cuau1</span>.</p></dd><dt class=hdlist1>Line 5</dt><dd><p>Sets the connection speed. If <code>115200</code> does not work on an older modem, try <code>38400</code> instead.</p></dd><dt class=hdlist1>Lines 6 & 7</dt><dd><p>The dial string written as an expect-send syntax. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=chat&amp;sektion=8&amp;format=html">chat(8)</a> for more information.</p><div class=paragraph><p>Note that this command continues onto the next line for readability. Any command in <span class=filename>ppp.conf</span> may do this if the last character on the line is <code>\</code>.</p></div></dd><dt class=hdlist1>Line 8</dt><dd><p>Sets the idle timeout for the link in seconds.</p></dd><dt class=hdlist1>Line 9</dt><dd><p>Instructs the peer to confirm the DNS settings. If the local network is running its own DNS server, this line should be commented out, by adding a <code>#</code> at the beginning of the line, or removed.</p></dd><dt class=hdlist1>Line 10</dt><dd><p>A blank line for readability. Blank lines are ignored by <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></dd><dt class=hdlist1>Line 11</dt><dd><p>Identifies an entry called <code>provider</code>. This could be changed to the name of the ISP so that <code>load <em>ISP</em></code> can be used to start the connection.</p></dd><dt class=hdlist1>Line 12</dt><dd><p>Use the phone number for the ISP. Multiple phone numbers may be specified using the colon (<code>:</code>) or pipe character (<code>|</code>) as a separator. To rotate through the numbers, use a colon. To always attempt to dial the first number first and only use the other numbers if the first number fails, use the pipe character. Always enclose the entire set of phone numbers between quotation marks (<code>"</code>) to prevent dialing failures.</p></dd><dt class=hdlist1>Lines 13 & 14</dt><dd><p>Use the user name and password for the ISP.</p></dd><dt class=hdlist1>Line 15</dt><dd><p>Sets the default idle timeout in seconds for the connection. In this example, the connection will be closed automatically after 300 seconds of inactivity. To prevent a timeout, set this value to zero.</p></dd><dt class=hdlist1>Line 16</dt><dd><p>Sets the interface addresses. The values used depend upon whether a static IP address has been obtained from the ISP or if it instead negotiates a dynamic IP address during connection.</p><div class=paragraph><p>If the ISP has allocated a static IP address and default gateway, replace <em>x.x.x.x</em> with the static IP address and replace <em>y.y.y.y</em> with the IP address of the default gateway. If the ISP has only provided a static IP address without a gateway address, replace <em>y.y.y.y</em> with <code>10.0.0.2/0</code>.</p></div><div class=paragraph><p>If the IP address changes whenever a connection is made, change this line to the following value. This tells <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> to use the IP Configuration Protocol (IPCP) to negotiate a dynamic IP address:</p></div><div class="literalblock programlisting"><div class=content><pre>set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0</pre></div></div></dd><dt class=hdlist1>Line 17</dt><dd><p>Keep this line as-is as it adds a default route to the gateway. The <code>HISADDR</code> will automatically be replaced with the gateway address specified on line 16. It is important that this line appears after line 16.</p></dd></dl></div><div class=paragraph><p>Depending upon whether <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> is started manually or automatically, a <span class=filename>/etc/ppp/ppp.linkup</span> may also need to be created which contains the following lines. This file is required when running <code>ppp</code> in <code>-auto</code> mode. This file is used after the connection has been established. At this point, the IP address will have been assigned and it is now be possible to add the routing table entries. When creating this file, make sure that <em>provider</em> matches the value demonstrated in line 11 of <span class=filename>ppp.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>provider:
      add default HISADDR</pre></div></div><div class=paragraph><p>This file is also needed when the default gateway address is "guessed" in a static IP address configuration. In this case, remove line 17 from <span class=filename>ppp.conf</span> and create <span class=filename>/etc/ppp/ppp.linkup</span> with the above two lines. More examples for this file can be found in <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class=paragraph><p>By default, <code>ppp</code> must be run as <code>root</code>. To change this default, add the account of the user who should run <code>ppp</code> to the <code>network</code> group in <span class=filename>/etc/group</span>.</p></div><div class=paragraph><p>Then, give the user access to one or more entries in <span class=filename>/etc/ppp/ppp.conf</span> with <code>allow</code>. For example, to give <code>fred</code> and <code>mary</code> permission to only the <code>provider:</code> entry, add this line to the <code>provider:</code> section:</p></div><div class="literalblock programlisting"><div class=content><pre>allow users fred mary</pre></div></div><div class=paragraph><p>To give the specified users access to all entries, put that line in the <code>default</code> section instead.</p></div></div><div class=sect3><h4 id=_進階設定_2>27.2.2. 進階設定<a class=anchor href=#_進階設定_2></a></h4><div class=paragraph><p>It is possible to configure PPP to supply DNS and NetBIOS nameserver addresses on demand.</p></div><div class=paragraph><p>To enable these extensions with PPP version 1.x, the following lines might be added to the relevant section of <span class=filename>/etc/ppp/ppp.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>enable msext
set ns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>And for PPP version 2 and above:</p></div><div class="literalblock programlisting"><div class=content><pre>accept dns
set dns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>This will tell the clients the primary and secondary name server addresses, and a NetBIOS nameserver host.</p></div><div class=paragraph><p>In version 2 and above, if the <code>set dns</code> line is omitted, PPP will use the values found in <span class=filename>/etc/resolv.conf</span>.</p></div><div class=sect4><h5 id=userppp-PAPnCHAP>27.2.2.1. PAP 與 CHAP 認證<a class=anchor href=#userppp-PAPnCHAP></a></h5><div class=paragraph><p>Some ISPs set their system up so that the authentication part of the connection is done using either of the PAP or CHAP authentication mechanisms. If this is the case, the ISP will not give a <code>login:</code> prompt at connection, but will start talking PPP immediately.</p></div><div class=paragraph><p>PAP is less secure than CHAP, but security is not normally an issue here as passwords, although being sent as plain text with PAP, are being transmitted down a serial line only. There is not much room for crackers to "eavesdrop".</p></div><div class=paragraph><p>The following alterations must be made:</p></div><div class="literalblock programlisting"><div class=content><pre>13      set authname MyUserName
14      set authkey MyPassword
15      set login</pre></div></div><div class=dlist><dl><dt class=hdlist1>Line 13</dt><dd><p>This line specifies the PAP/CHAP user name. Insert the correct value for <em>MyUserName</em>.</p></dd><dt class=hdlist1>Line 14</dt><dd><p>This line specifies the PAP/CHAP password. Insert the correct value for <em>MyPassword</em>. You may want to add an additional line, such as:</p><div class="literalblock programlisting"><div class=content><pre>16      accept PAP</pre></div></div><div class=paragraph><p>或</p></div><div class="literalblock programlisting"><div class=content><pre>16      accept CHAP</pre></div></div><div class=paragraph><p>to make it obvious that this is the intention, but PAP and CHAP are both accepted by default.</p></div></dd><dt class=hdlist1>Line 15</dt><dd><p>The ISP will not normally require a login to the server when using PAP or CHAP. Therefore, disable the "set login" string.</p></dd></dl></div></div><div class=sect4><h5 id=userppp-nat>27.2.2.2. 使用 PPP 網路位址轉譯功能<a class=anchor href=#userppp-nat></a></h5><div class=paragraph><p>PPP has ability to use internal NAT without kernel diverting capabilities. This functionality may be enabled by the following line in <span class=filename>/etc/ppp/ppp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nat enable yes</pre></div></div><div class=paragraph><p>Alternatively, NAT may be enabled by command-line option <code>-nat</code>. There is also <span class=filename>/etc/rc.conf</span> knob named <code>ppp_nat</code>, which is enabled by default.</p></div><div class=paragraph><p>When using this feature, it may be useful to include the following <span class=filename>/etc/ppp/ppp.conf</span> options to enable incoming connections forwarding:</p></div><div class="literalblock programlisting"><div class=content><pre>nat port tcp 10.0.0.2:ftp ftp
nat port tcp 10.0.0.2:http http</pre></div></div><div class=paragraph><p>or do not trust the outside at all</p></div><div class="literalblock programlisting"><div class=content><pre>nat deny_incoming yes</pre></div></div></div></div><div class=sect3><h4 id=userppp-final>27.2.3. 最終系統設定<a class=anchor href=#userppp-final></a></h4><div class=paragraph><p>While <code>ppp</code> is now configured, some edits still need to be made to <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Working from the top down in this file, make sure the <code>hostname=</code> line is set:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;foo.example.com&#34;</pre></div></div><div class=paragraph><p>If the ISP has supplied a static IP address and name, use this name as the host name.</p></div><div class=paragraph><p>Look for the <code>network_interfaces</code> variable. To configure the system to dial the ISP on demand, make sure the <span class=filename>tun0</span> device is added to the list, otherwise remove it.</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 tun0&#34;
ifconfig_tun0=</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <code>ifconfig_tun0</code> variable should be empty, and a file called <span class=filename>/etc/start_if.tun0</span> should be created. This file should contain the line:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp -auto mysystem</pre></div></div><div class=paragraph><p>This script is executed at network configuration time, starting the ppp daemon in automatic mode. If this machine acts as a gateway, consider including <code>-alias</code>. Refer to the manual page for further details.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Make sure that the router program is set to <code>NO</code> with the following line in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>router_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>It is important that the <code>routed</code> daemon is not started, as <code>routed</code> tends to delete the default routing table entries created by <code>ppp</code>.</p></div><div class=paragraph><p>It is probably a good idea to ensure that the <code>sendmail_flags</code> line does not include the <code>-q</code> option, otherwise <code>sendmail</code> will attempt to do a network lookup every now and then, possibly causing your machine to dial out. You may try:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_flags=&#34;-bd&#34;</pre></div></div><div class=paragraph><p>The downside is that <code>sendmail</code> is forced to re-examine the mail queue whenever the ppp link. To automate this, include <code>!bg</code> in <span class=filename>ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m</pre></div></div><div class=paragraph><p>An alternative is to set up a "dfilter" to block SMTP traffic. Refer to the sample files for further details.</p></div></div><div class=sect3><h4 id=_使用_ppp>27.2.4. 使用 <code>ppp</code><a class=anchor href=#_使用_ppp></a></h4><div class=paragraph><p>All that is left is to reboot the machine. After rebooting, either type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp</span></code></pre></div></div><div class=paragraph><p>and then <code>dial provider</code> to start the PPP session, or, to configure <code>ppp</code> to establish sessions automatically when there is outbound traffic and <span class=filename>start_if.tun0</span> does not exist, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -auto provider</span></code></pre></div></div><div class=paragraph><p>It is possible to talk to the <code>ppp</code> program while it is running in the background, but only if a suitable diagnostic port has been set up. To do this, add the following line to the configuration:</p></div><div class="literalblock programlisting"><div class=content><pre>set server /var/run/ppp-tun%d DiagnosticPassword 0177</pre></div></div><div class=paragraph><p>This will tell PPP to listen to the specified UNIX™ domain socket, asking clients for the specified password before allowing access. The <code>%d</code> in the name is replaced with the <span class=filename>tun</span> device number that is in use.</p></div><div class=paragraph><p>Once a socket has been set up, the <a href="https://man.freebsd.org/cgi/man.cgi?query=pppctl&amp;sektion=8&amp;format=html">pppctl(8)</a> program may be used in scripts that wish to manipulate the running program.</p></div></div><div class=sect3><h4 id=userppp-mgetty>27.2.5. 設定撥入服務<a class=anchor href=#userppp-mgetty></a></h4><div class=paragraph><p><a href=./#dialup>撥入服務</a> provides a good description on enabling dial-up services using <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>.</p></div><div class=paragraph><p>An alternative to <code>getty</code> is <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a> port), a smarter version of <code>getty</code> designed with dial-up lines in mind.</p></div><div class=paragraph><p>The advantages of using <code>mgetty</code> is that it actively <em>talks</em> to modems, meaning if port is turned off in <span class=filename>/etc/ttys</span> then the modem will not answer the phone.</p></div><div class=paragraph><p>Later versions of <code>mgetty</code> (from 0.99beta onwards) also support the automatic detection of PPP streams, allowing clients scriptless access to the server.</p></div><div class=paragraph><p>Refer to <a href=http://mgetty.greenie.net/doc/mgetty_toc.html>http://mgetty.greenie.net/doc/mgetty_toc.html</a> for more information on <code>mgetty</code>.</p></div><div class=paragraph><p>By default the <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a> port comes with the <code>AUTO_PPP</code> option enabled allowing <code>mgetty</code> to detect the LCP phase of PPP connections and automatically spawn off a ppp shell. However, since the default login/password sequence does not occur it is necessary to authenticate users using either PAP or CHAP.</p></div><div class=paragraph><p>This section assumes the user has successfully compiled, and installed the <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a> port on his system.</p></div><div class=paragraph><p>Ensure that <span class=filename>/usr/local/etc/mgetty+sendfax/login.config</span> has the following:</p></div><div class="literalblock programlisting"><div class=content><pre>/AutoPPP/ -     - /etc/ppp/ppp-pap-dialup</pre></div></div><div class=paragraph><p>This tells <code>mgetty</code> to run <span class=filename>ppp-pap-dialup</span> for detected PPP connections.</p></div><div class=paragraph><p>Create an executable file called <span class=filename>/etc/ppp/ppp-pap-dialup</span> containing the following:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
exec /usr/sbin/ppp -direct pap$IDENT</pre></div></div><div class=paragraph><p>For each dial-up line enabled in <span class=filename>/etc/ttys</span>, create a corresponding entry in <span class=filename>/etc/ppp/ppp.conf</span>. This will happily co-exist with the definitions we created above.</p></div><div class="literalblock programlisting"><div class=content><pre>pap:
  enable pap
  set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
  enable proxy</pre></div></div><div class=paragraph><p>Each user logging in with this method will need to have a username/password in <span class=filename>/etc/ppp/ppp.secret</span>, or alternatively add the following option to authenticate users via PAP from <span class=filename>/etc/passwd</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>enable passwdauth</pre></div></div><div class=paragraph><p>To assign some users a static IP number, specify the number as the third argument in <span class=filename>/etc/ppp/ppp.secret</span>. See <span class=filename>/usr/shared/examples/ppp/ppp.secret.sample</span> for examples.</p></div></div></div><div class=sect2><h3 id=ppp-troubleshoot>27.3. PPP 連線疑難排解<a class=anchor href=#ppp-troubleshoot></a></h3><div class=paragraph><p>This section covers a few issues which may arise when using PPP over a modem connection. Some ISPs present the <code>ssword</code> prompt while others present <code>password</code>. If the <code>ppp</code> script is not written accordingly, the login attempt will fail. The most common way to debug <code>ppp</code> connections is by connecting manually as described in this section.</p></div><div class=sect3><h4 id=_檢查裝置節點>27.3.1. 檢查裝置節點<a class=anchor href=#_檢查裝置節點></a></h4><div class=paragraph><p>When using a custom kernel, make sure to include the following line in the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device   uart</pre></div></div><div class=paragraph><p>The <span class=filename>uart</span> device is already included in the <code>GENERIC</code> kernel, so no additional steps are necessary in this case. Just check the <code>dmesg</code> output for the modem device with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | grep uart</span></code></pre></div></div><div class=paragraph><p>This should display some pertinent output about the <span class=filename>uart</span> devices. These are the COM ports we need. If the modem acts like a standard serial port, it should be listed on <span class=filename>uart1</span>, or <span class=filename>COM2</span>. If so, a kernel rebuild is not required. When matching up, if the modem is on <span class=filename>uart1</span>, the modem device would be <span class=filename>/dev/cuau1</span>.</p></div></div><div class=sect3><h4 id=_手動連線>27.3.2. 手動連線<a class=anchor href=#_手動連線></a></h4><div class=paragraph><p>Connecting to the Internet by manually controlling <code>ppp</code> is quick, easy, and a great way to debug a connection or just get information on how the ISP treats <code>ppp</code> client connections. Lets start PPP from the command line. Note that in all of our examples we will use <em>example</em> as the hostname of the machine running PPP. To start <code>ppp</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>device /dev/cuau1</code></pre></div></div><div class=paragraph><p>This second command sets the modem device to <span class=filename>cuau1</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>speed 115200</code></pre></div></div><div class=paragraph><p>This sets the connection speed to 115,200 kbps.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>enable </span>dns</code></pre></div></div><div class=paragraph><p>This tells <code>ppp</code> to configure the resolver and add the nameserver lines to <span class=filename>/etc/resolv.conf</span>. If <code>ppp</code> cannot determine the hostname, it can manually be set later.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; term</code></pre></div></div><div class=paragraph><p>This switches to "terminal" mode in order to manually control the modem.</p></div><div class="literalblock programlisting"><div class=content><pre>deflink: Entering terminal mode on /dev/cuau1
type &#39;~h&#39; for help</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>at
OK
atdt123456789</code></pre></div></div><div class=paragraph><p>Use <code>at</code> to initialize the modem, then use <code>atdt</code> and the number for the ISP to begin the dial in process.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>CONNECT</code></pre></div></div><div class=paragraph><p>Confirmation of the connection, if we are going to have any connection problems, unrelated to hardware, here is where we will attempt to resolve them.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ISP Login:myusername</code></pre></div></div><div class=paragraph><p>At this prompt, return the prompt with the username that was provided by the ISP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ISP Pass:mypassword</code></pre></div></div><div class=paragraph><p>At this prompt, reply with the password that was provided by the ISP. Just like logging into FreeBSD, the password will not echo.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Shell or PPP:ppp</code></pre></div></div><div class=paragraph><p>Depending on the ISP, this prompt might not appear. If it does, it is asking whether to use a shell on the provider or to start <code>ppp</code>. In this example, <code>ppp</code> was selected in order to establish an Internet connection.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Ppp ON example&gt;</code></pre></div></div><div class=paragraph><p>Notice that in this example the first <code>p</code> has been capitalized. This shows that we have successfully connected to the ISP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPp ON example&gt;</code></pre></div></div><div class=paragraph><p>We have successfully authenticated with our ISP and are waiting for the assigned IP address.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPP ON example&gt;</code></pre></div></div><div class=paragraph><p>We have made an agreement on an IP address and successfully completed our connection.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPP ON example&gt;add default HISADDR</code></pre></div></div><div class=paragraph><p>Here we add our default route, we need to do this before we can talk to the outside world as currently the only established connection is with the peer. If this fails due to existing routes, put a bang character <code>!</code> in front of the <code>add</code>. Alternatively, set this before making the actual connection and it will negotiate a new route accordingly.</p></div><div class=paragraph><p>If everything went good we should now have an active connection to the Internet, which could be thrown into the background using <span class=keyseq><kbd>CTRL</kbd>+<kbd>z</kbd></span> If <code>PPP</code> returns to <code>ppp</code> then the connection has bee lost. This is good to know because it shows the connection status. Capital P’s represent a connection to the ISP and lowercase p’s show that the connection has been lost.</p></div></div><div class=sect3><h4 id=_除錯>27.3.3. 除錯<a class=anchor href=#_除錯></a></h4><div class=paragraph><p>If a connection cannot be established, turn hardware flow CTS/RTS to off using <code>set ctsrts off</code>. This is mainly the case when connected to some PPP-capable terminal servers, where PPP hangs when it tries to write data to the communication link, and waits for a Clear To Send (CTS) signal which may never come. When using this option, include <code>set accmap</code> as it may be required to defeat hardware dependent on passing certain characters from end to end, most of the time XON/XOFF. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> for more information on this option and how it is used.</p></div><div class=paragraph><p>An older modem may need <code>set parity even</code>. Parity is set at none be default, but is used for error checking with a large increase in traffic, on older modems.</p></div><div class=paragraph><p>PPP may not return to the command mode, which is usually a negotiation error where the ISP is waiting for negotiating to begin. At this point, using <code>~p</code> will force ppp to start sending the configuration information.</p></div><div class=paragraph><p>If a login prompt never appears, PAP or CHAP authentication is most likely required. To use PAP or CHAP, add the following options to PPP before going into terminal mode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>authname myusername</code></pre></div></div><div class=paragraph><p>Where <em>myusername</em> should be replaced with the username that was assigned by the ISP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>authkey mypassword</code></pre></div></div><div class=paragraph><p>Where <em>mypassword</em> should be replaced with the password that was assigned by the ISP.</p></div><div class=paragraph><p>If a connection is established, but cannot seem to find any domain name, try to <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> an IP address. If there is 100 percent (100%) packet loss, it is likely that a default route was not assigned. Double check that <code>add default HISADDR</code> was set during the connection. If a connection can be made to a remote IP address, it is possible that a resolver address has not been added to <span class=filename>/etc/resolv.conf</span>. This file should look like:</p></div><div class="literalblock programlisting"><div class=content><pre>domain example.com
nameserver x.x.x.x
nameserver y.y.y.y</pre></div></div><div class=paragraph><p>Where <em>x.x.x.x</em> and <em>y.y.y.y</em> should be replaced with the IP address of the ISP’s DNS servers.</p></div><div class=paragraph><p>To configure <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> to provide logging for the PPP connection, make sure this line exists in <span class=filename>/etc/syslog.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>!ppp
*.*     /var/log/ppp.log</pre></div></div></div></div><div class=sect2><h3 id=pppoe>27.4. 在乙太網路使用 PPP (PPPoE)<a class=anchor href=#pppoe></a></h3><div class=paragraph><p>本節介紹如何設定在 乙太網路使用 PPP (PPPoE)。</p></div><div class=paragraph><p>以下有一個可用的的 <span class=filename>ppp.conf</span> 範例：</p></div><div class="literalblock programlisting"><div class=content><pre>default:
  set log Phase tun command # you can add more detailed logging if you wish
  set ifaddr 10.0.0.1/0 10.0.0.2/0

name_of_service_provider:
  set device PPPoE:xl1 # replace xl1 with your Ethernet device
  set authname YOURLOGINNAME
  set authkey YOURPASSWORD
  set dial
  set login
  add default HISADDR</pre></div></div><div class=paragraph><p>以 <code>root</code> 身份執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -ddial name_of_service_provider</span></code></pre></div></div><div class=paragraph><p>將以下參數加到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>ppp_enable=&#34;YES&#34;
ppp_mode=&#34;ddial&#34;
ppp_nat=&#34;YES&#34;	# if you want to enable nat for your local network, otherwise NO
ppp_profile=&#34;name_of_service_provider&#34;</pre></div></div><div class=sect3><h4 id=_使用_pppoe_服務標籤>27.4.1. 使用 PPPoE 服務標籤<a class=anchor href=#_使用_pppoe_服務標籤></a></h4><div class=paragraph><p>有時需要使用服務標籤 (Service Tag) 才能建立連線，服務標籤用來區別不同網路要各自連線的 PPPoE 伺服器。</p></div><div class=paragraph><p>所需的服務標籤資訊應該會在 ISP 所提供的文件中說明。</p></div><div class=paragraph><p>最後的手段是嘗試安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/net/rr-pppoe/>net/rr-pppoe</a> 套件或 Port。但是請注意，這可能會解除安裝數據機中的程式並使其無法運作，所以請三思而為。只需要安裝數據機所提供的程式，然後由該程式進入 <b class=menuref>System</b> 選單，基本資料 (Profile name) 的名稱應該會列出來，通常是 <em>ISP</em> 的名稱。</p></div><div class=paragraph><p>基本資料名稱 (Profile Name) 即服務標籤，會被用在 <span class=filename>ppp.conf</span> 中的 PPPoE 設定項目，<code>set device</code> 的提供商 (Provider) 部份。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 以取得詳細說明，結果應如下：</p></div><div class="literalblock programlisting"><div class=content><pre>set device PPPoE:xl1:ISP</pre></div></div><div class=paragraph><p>別忘記更改 <em>xl1</em> 為乙太網路卡的裝置名稱。</p></div><div class=paragraph><p>別忘記更改 <em>ISP</em> 為基本資料名稱。</p></div><div class=paragraph><p>要取得更進一步資訊，請參考 Renaud Waldura 所著的 <a href=http://renaud.waldura.com/doc/freebsd/pppoe/>Cheaper Broadband with FreeBSD on DSL</a>。</p></div></div><div class=sect3><h4 id=ppp-3com>27.4.2. 在 3Com™HomeConnect™ ADSL Modem Dual Link 使用 PPPoE<a class=anchor href=#ppp-3com></a></h4><div class=paragraph><p>這台數據機並不採用 <a href=http://www.faqs.org/rfcs/rfc2516.html>RFC 2516</a> 所定義的規格。</p></div><div class=paragraph><p>為了要讓 FreeBSD 能夠與這台裝置通訊，必須設定 sysctl，這可以透過更新 <span class=filename>/etc/sysctl.conf</span> 來讓開機時自動設定。</p></div><div class="literalblock programlisting"><div class=content><pre>net.graph.nonstandard_pppoe=1</pre></div></div><div class=paragraph><p>或可以執行以下指令立即更改：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.graph.nonstandard_pppoe=1</span></code></pre></div></div><div class=paragraph><p>不幸的是，由於這是一個全系統的設定，這可能導致一般 PPPoE 客戶端或伺服器無法與 3Com™HomeConnect™ ADSL 數據機同時使用。</p></div></div></div><div class=sect2><h3 id=pppoa>27.5. 在 ATM 使用 PPP (PPPoA)<a class=anchor href=#pppoa></a></h3><div class=paragraph><p>The following describes how to set up PPP over ATM (PPPoA). PPPoA is a popular choice among European DSL providers.</p></div><div class=sect3><h4 id=_使用_mpd>27.5.1. 使用 mpd<a class=anchor href=#_使用_mpd></a></h4><div class=paragraph><p>The mpd application can be used to connect to a variety of services, in particular PPTP services. It can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/net/mpd5/>net/mpd5</a> package or port. Many ADSL modems require that a PPTP tunnel is created between the modem and computer.</p></div><div class=paragraph><p>Once installed, configure mpd to suit the provider’s settings. The port places a set of sample configuration files which are well documented in <span class=filename>/usr/local/etc/mpd/</span>. A complete guide to configure mpd is available in HTML format in <span class=filename>/usr/ports/shared/doc/mpd/</span>. Here is a sample configuration for connecting to an ADSL service with mpd. The configuration is spread over two files, first the <span class=filename>mpd.conf</span>:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This example <span class=filename>mpd.conf</span> only works with mpd 4.x.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>default:
    load adsl

adsl:
    new -i ng0 adsl adsl
    set bundle authname username <i class=conum data-value=1></i><b>(1)</b>
    set bundle password password <i class=conum data-value=2></i><b>(2)</b>
    set bundle disable multilink

    set link no pap acfcomp protocomp
    set link disable chap
    set link accept chap
    set link keep-alive 30 10

    set ipcp no vjcomp
    set ipcp ranges 0.0.0.0/0 0.0.0.0/0

    set iface route default
    set iface disable on-demand
    set iface enable proxy-arp
    set iface idle 0

    open</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The username used to authenticate with your ISP.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The password used to authenticate with your ISP.</td></tr></tbody></table></div><div class=paragraph><p>Information about the link, or links, to establish is found in <span class=filename>mpd.links</span>. An example <span class=filename>mpd.links</span> to accompany the above example is given beneath:</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
    set link type pptp
    set pptp mode active
    set pptp enable originate outcall
    set pptp self 10.0.0.1 <i class=conum data-value=1></i><b>(1)</b>
    set pptp peer 10.0.0.138 <i class=conum data-value=2></i><b>(2)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The IP address of FreeBSD computer running mpd.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The IP address of the ADSL modem. The Alcatel SpeedTouch™ Home defaults to <code>10.0.0.138</code>.</td></tr></tbody></table></div><div class=paragraph><p>It is possible to initialize the connection easily by issuing the following command as <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpd -b adsl</span></code></pre></div></div><div class=paragraph><p>To view the status of the connection:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig ng0
ng0: <span class=nv>flags</span><span class=o>=</span>88d1&lt;UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST&gt; mtu 1500
     inet 216.136.204.117 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffffff</code></pre></div></div><div class=paragraph><p>Using mpd is the recommended way to connect to an ADSL service with FreeBSD.</p></div></div><div class=sect3><h4 id=_使用_pptpclient>27.5.2. 使用 pptpclient<a class=anchor href=#_使用_pptpclient></a></h4><div class=paragraph><p>It is also possible to use FreeBSD to connect to other PPPoA services using <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a>.</p></div><div class=paragraph><p>To use <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a> to connect to a DSL service, install the port or package, then edit <span class=filename>/etc/ppp/ppp.conf</span>. An example section of <span class=filename>ppp.conf</span> is given below. For further information on <span class=filename>ppp.conf</span> options consult <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
 set log phase chat lcp ipcp ccp tun command
 set timeout 0
 enable dns
 set authname username <i class=conum data-value=1></i><b>(1)</b>
 set authkey password <i class=conum data-value=2></i><b>(2)</b>
 set ifaddr 0 0
 add default HISADDR</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>The username for the DSL provider.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The password for your account.</td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Since the account’s password is added to <span class=filename>ppp.conf</span> in plain text form, make sure nobody can read the contents of this file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:wheel /etc/ppp/ppp.conf</span>
<span class=c># chmod 600 /etc/ppp/ppp.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>This will open a tunnel for a PPP session to the DSL router. Ethernet DSL modems have a preconfigured LAN IP address to connect to. In the case of the Alcatel SpeedTouch™ Home, this address is <code>10.0.0.138</code>. The router’s documentation should list the address the device uses. To open the tunnel and start a PPP session:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pptp address adsl</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>If an ampersand ("&") is added to the end of this command, pptp will return the prompt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A <span class=filename>tun</span> virtual tunnel device will be created for interaction between the pptp and ppp processes. Once the prompt is returned, or the pptp process has confirmed a connection, examine the tunnel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig tun0
tun0: <span class=nv>flags</span><span class=o>=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
        inet 216.136.204.21 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffff00
	Opened by PID 918</code></pre></div></div><div class=paragraph><p>If the connection fails, check the configuration of the router, which is usually accessible using a web browser. Also, examine the output of <code>pptp</code> and the contents of the log file, <span class=filename>/var/log/ppp.log</span> for clues.</p></div></div></div></div></div><div class=sect1><h2 id=mail>Chapter 28. 電子郵件<a class=anchor href=#mail></a></h2><div class=sectionbody><div class=sect2><h3 id=mail-synopsis>28.1. 概述<a class=anchor href=#mail-synopsis></a></h3><div class=paragraph><p>"電子郵件" 或稱 email，是現今使用最廣泛的溝通方式之一。本章主要介紹如何在 FreeBSD 上執行郵件伺服器，以及如何使用 FreeBSD 收發信件，若欲瞭解細節請參閱 <a href=./#bibliography>參考書目</a> 內的參考書籍。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>哪些軟體元件與收發電子郵件有關。</p></li><li><p>FreeBSD 內的 Sendmail 設定檔在哪。</p></li><li><p>遠端信箱 (Mailbox) 與本機信箱的差異。</p></li><li><p>如何阻擋垃圾郵件寄件者 (Spammer) 非法使用郵件伺服器作為中繼站。</p></li><li><p>如何安裝與設定其他的郵件傳輸代理程式 (Mail Transfer Agent) 來取代 Sendmail。</p></li><li><p>如何排除常見的郵件伺服器問題。</p></li><li><p>如何設定系統只能寄送郵件。</p></li><li><p>如何在撥號連線上使用郵件。</p></li><li><p>如何設定 SMTP 認証來增加安全性。</p></li><li><p>如何安裝並使用郵件使用者代理程式 (Mail User Agent) 如 mutt 來寄發與接收電子郵件。</p></li><li><p>如何從遠端的 POP 或 IMAP 伺服器下載郵件。</p></li><li><p>如何自動套用過濾器及規則在收到的電子郵件上。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>正確的設定網路連線 (<a href=./#advanced-networking>進階網路設定</a>)。</p></li><li><p>正確的設定郵件主機的 DNS 資訊 (<a href=./#network-servers>網路伺服器</a>)。</p></li><li><p>了解如何安裝其他第三方軟體 (<a href=./#ports>安裝應用程式：套件與 Port</a>)。</p></li></ul></div></div><div class=sect2><h3 id=mail-using>28.2. 郵件組成<a class=anchor href=#mail-using></a></h3><div class=paragraph><p>There are five major parts involved in an email exchange: the Mail User Agent (MUA), the Mail Transfer Agent (MTA), a mail host, a remote or local mailbox, and DNS. This section provides an overview of these components.</p></div><div class=dlist><dl><dt class=hdlist1>郵件使用者代理程式 (Mail User Agent, MUA)</dt><dd><p>The Mail User Agent (MUA) is an application which is used to compose, send, and receive emails. This application can be a command line program, such as the built-in <code>mail</code> utility or a third-party application from the Ports Collection, such as mutt, alpine, or elm. Dozens of graphical programs are also available in the Ports Collection, including Claws Mail, Evolution, and Thunderbird. Some organizations provide a web mail program which can be accessed through a web browser. More information about installing and using a MUA on FreeBSD can be found in <a href=#mail-agents>郵件使用者代理程式</a>.</p></dd><dt class=hdlist1>郵件傳輸代理程式 (Mail Transfer Agent, MTA)</dt><dd><p>The Mail Transfer Agent (MTA) is responsible for receiving incoming mail and delivering outgoing mail. FreeBSD ships with Sendmail as the default MTA, but it also supports numerous other mail server daemons, including Exim, Postfix, and qmail. Sendmail configuration is described in <a href=#sendmail>Sendmail 設定檔</a>. If another MTA is installed using the Ports Collection, refer to its post-installation message for FreeBSD-specific configuration details and the application’s website for more general configuration instructions.</p></dd><dt class=hdlist1>郵件主機 (Mail Host) 與郵件信箱 (Mailbox)</dt><dd><p>The mail host is a server that is responsible for delivering and receiving mail for a host or a network. The mail host collects all mail sent to the domain and stores it either in the default <span class=filename>mbox</span> or the alternative Maildir format, depending on the configuration. Once mail has been stored, it may either be read locally using a MUA or remotely accessed and collected using protocols such as POP or IMAP. If mail is read locally, a POP or IMAP server does not need to be installed.</p><div class=paragraph><p>To access mailboxes remotely, a POP or IMAP server is required as these protocols allow users to connect to their mailboxes from remote locations. IMAP offers several advantages over POP. These include the ability to store a copy of messages on a remote server after they are downloaded and concurrent updates. IMAP can be useful over low-speed links as it allows users to fetch the structure of messages without downloading them. It can also perform tasks such as searching on the server in order to minimize data transfer between clients and servers.</p></div><div class=paragraph><p>Several POP and IMAP servers are available in the Ports Collection. These include <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/imap-uw/>mail/imap-uw</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/courier-imap/>mail/courier-imap</a>, and <a class=package href=https://cgit.freebsd.org/ports/tree/mail/dovecot2/>mail/dovecot2</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>It should be noted that both POP and IMAP transmit information, including username and password credentials, in clear-text. To secure the transmission of information across these protocols, consider tunneling sessions over <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> (<a href=./#security-ssh-tunneling>SSH 通道</a>) or using SSL (<a href=./#openssl>OpenSSL</a>).</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>網域名稱系統 (DNS)</dt><dd><p>The Domain Name System (DNS) and its daemon <code>named</code> play a large role in the delivery of email. In order to deliver mail from one site to another, the MTA will look up the remote site in DNS to determine which host will receive mail for the destination. This process also occurs when mail is sent from a remote host to the MTA.</p><div class=paragraph><p>In addition to mapping hostnames to IP addresses, DNS is responsible for storing information specific to mail delivery, known as Mail eXchanger MX records. The MX record specifies which hosts will receive mail for a particular domain.</p></div><div class=paragraph><p>To view the MX records for a domain, specify the type of record. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=host&amp;sektion=1&amp;format=html">host(1)</a>, for more details about this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% host <span class=nt>-t</span> mx FreeBSD.org
FreeBSD.org mail is handled by 10 mx1.FreeBSD.org</code></pre></div></div><div class=paragraph><p>Refer to <a href=./#network-dns>網域名稱系統 (DNS)</a> for more information about DNS and its configuration.</p></div></dd></dl></div></div><div class=sect2><h3 id=sendmail>28.3. Sendmail 設定檔<a class=anchor href=#sendmail></a></h3><div class=paragraph><p>Sendmail is the default MTA installed with FreeBSD. It accepts mail from MUAs and delivers it to the appropriate mail host, as defined by its configuration. Sendmail can also accept network connections and deliver mail to local mailboxes or to another program.</p></div><div class=paragraph><p>The configuration files for Sendmail are located in <span class=filename>/etc/mail</span>. This section describes these files in more detail.</p></div><div class=dlist><dl><dt class=hdlist1><span class=filename>/etc/mail/access</span></dt><dd><p>This access database file defines which hosts or IP addresses have access to the local mail server and what kind of access they have. Hosts listed as <code>OK</code>, which is the default option, are allowed to send mail to this host as long as the mail’s final destination is the local machine. Hosts listed as <code>REJECT</code> are rejected for all mail connections. Hosts listed as <code>RELAY</code> are allowed to send mail for any destination using this mail server. Hosts listed as <code>ERROR</code> will have their mail returned with the specified mail error. If a host is listed as <code>SKIP</code>, Sendmail will abort the current search for this entry without accepting or rejecting the mail. Hosts listed as <code>QUARANTINE</code> will have their messages held and will receive the specified text as the reason for the hold.</p><div class=paragraph><p>Examples of using these options for both IPv4 and IPv6 addresses can be found in the FreeBSD sample configuration, <span class=filename>/etc/mail/access.sample</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $
#
# Mail relay access control list.  Default is to reject mail unless the
# destination is local, or listed in /etc/mail/local-host-names
#
## Examples (commented out for safety)
#From:cyberspammer.com          ERROR:&#34;550 We don&#39;t accept mail from spammers&#34;
#From:okay.cyberspammer.com     OK
#Connect:sendmail.org           RELAY
#To:sendmail.org                RELAY
#Connect:128.32                 RELAY
#Connect:128.32.2               SKIP
#Connect:IPv6:1:2:3:4:5:6:7     RELAY
#Connect:suspicious.example.com QUARANTINE:Mail from suspicious host
#Connect:[127.0.0.3]            OK
#Connect:[IPv6:1:2:3:4:5:6:7:8] OK</pre></div></div><div class=paragraph><p>To configure the access database, use the format shown in the sample to make entries in <span class=filename>/etc/mail/access</span>, but do not put a comment symbol (<code>#</code>) in front of the entries. Create an entry for each host or network whose access should be configured. Mail senders that match the left side of the table are affected by the action on the right side of the table.</p></div><div class=paragraph><p>Whenever this file is updated, update its database and restart Sendmail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># makemap hash /etc/mail/access &lt; /etc/mail/access</span>
<span class=c># service sendmail restart</span></code></pre></div></div></dd><dt class=hdlist1><span class=filename>/etc/mail/aliases</span></dt><dd><p>This database file contains a list of virtual mailboxes that are expanded to users, files, programs, or other aliases. Here are a few entries to illustrate the file format:</p><div class="literalblock programlisting"><div class=content><pre>root: localuser
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: &#34;|/usr/local/bin/procmail&#34;</pre></div></div><div class=paragraph><p>The mailbox name on the left side of the colon is expanded to the target(s) on the right. The first entry expands the <code>root</code> mailbox to the <code>localuser</code> mailbox, which is then looked up in the <span class=filename>/etc/mail/aliases</span> database. If no match is found, the message is delivered to <code>localuser</code>. The second entry shows a mail list. Mail to <code>ftp-bugs</code> is expanded to the three local mailboxes <code>joe</code>, <code>eric</code>, and <code>paul</code>. A remote mailbox could be specified as <em>user@example.com</em>. The third entry shows how to write mail to a file, in this case <span class=filename>/dev/null</span>. The last entry demonstrates how to send mail to a program, <span class=filename>/usr/local/bin/procmail</span>, through a UNIX™ pipe. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=aliases&amp;sektion=5&amp;format=html">aliases(5)</a> for more information about the format of this file.</p></div><div class=paragraph><p>Whenever this file is updated, run <code>newaliases</code> to update and initialize the aliases database.</p></div></dd><dt class=hdlist1><span class=filename>/etc/mail/sendmail.cf</span></dt><dd><p>This is the master configuration file for Sendmail. It controls the overall behavior of Sendmail, including everything from rewriting email addresses to printing rejection messages to remote mail servers. Accordingly, this configuration file is quite complex. Fortunately, this file rarely needs to be changed for standard mail servers.</p><div class=paragraph><p>The master Sendmail configuration file can be built from <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> macros that define the features and behavior of Sendmail. Refer to <span class=filename>/usr/src/contrib/sendmail/cf/README</span> for some of the details.</p></div><div class=paragraph><p>Whenever changes to this file are made, Sendmail needs to be restarted for the changes to take effect.</p></div></dd><dt class=hdlist1><span class=filename>/etc/mail/virtusertable</span></dt><dd><p>This database file maps mail addresses for virtual domains and users to real mailboxes. These mailboxes can be local, remote, aliases defined in <span class=filename>/etc/mail/aliases</span>, or files. This allows multiple virtual domains to be hosted on one machine.</p><div class=paragraph><p>FreeBSD provides a sample configuration file in <span class=filename>/etc/mail/virtusertable.sample</span> to further demonstrate its format. The following example demonstrates how to create custom entries using that format:</p></div><div class="literalblock programlisting"><div class=content><pre>root@example.com                root
postmaster@example.com          postmaster@noc.example.net
@example.com                    joe</pre></div></div><div class=paragraph><p>This file is processed in a first match order. When an email address matches the address on the left, it is mapped to the local mailbox listed on the right. The format of the first entry in this example maps a specific email address to a local mailbox, whereas the format of the second entry maps a specific email address to a remote mailbox. Finally, any email address from <code>example.com</code> which has not matched any of the previous entries will match the last mapping and be sent to the local mailbox <code>joe</code>. When creating custom entries, use this format and add them to <span class=filename>/etc/mail/virtusertable</span>. Whenever this file is edited, update its database and restart Sendmail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># makemap hash /etc/mail/virtusertable &lt; /etc/mail/virtusertable</span>
<span class=c># service sendmail restart</span></code></pre></div></div></dd><dt class=hdlist1><span class=filename>/etc/mail/relay-domains</span></dt><dd><p>In a default FreeBSD installation, Sendmail is configured to only send mail from the host it is running on. For example, if a POP server is available, users will be able to check mail from remote locations but they will not be able to send outgoing emails from outside locations. Typically, a few moments after the attempt, an email will be sent from <code>MAILER-DAEMON</code> with a <code>5.7 Relaying Denied</code> message.</p><div class=paragraph><p>The most straightforward solution is to add the ISP’s FQDN to <span class=filename>/etc/mail/relay-domains</span>. If multiple addresses are needed, add them one per line:</p></div><div class="literalblock programlisting"><div class=content><pre>your.isp.example.com
other.isp.example.net
users-isp.example.org
www.example.org</pre></div></div><div class=paragraph><p>After creating or editing this file, restart Sendmail with <code>service sendmail restart</code>.</p></div><div class=paragraph><p>Now any mail sent through the system by any host in this list, provided the user has an account on the system, will succeed. This allows users to send mail from the system remotely without opening the system up to relaying SPAM from the Internet.</p></div></dd></dl></div></div><div class=sect2><h3 id=mail-changingmta>28.4. 更改郵件傳輸代理程式<a class=anchor href=#mail-changingmta></a></h3><div class=paragraph><p>FreeBSD comes with Sendmail already installed as the MTA which is in charge of outgoing and incoming mail. However, the system administrator can change the system’s MTA. A wide choice of alternative MTAs is available from the <code>mail</code> category of the FreeBSD Ports Collection.</p></div><div class=paragraph><p>Once a new MTA is installed, configure and test the new software before replacing Sendmail. Refer to the documentation of the new MTA for information on how to configure the software.</p></div><div class=paragraph><p>Once the new MTA is working, use the instructions in this section to disable Sendmail and configure FreeBSD to use the replacement MTA.</p></div><div class=sect3><h4 id=mail-disable-sendmail>28.4.1. 關閉 Sendmail<a class=anchor href=#mail-disable-sendmail></a></h4><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>If Sendmail’s outgoing mail service is disabled, it is important that it is replaced with an alternative mail delivery system. Otherwise, system functions such as <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> will be unable to deliver their results by email. Many parts of the system expect a functional MTA. If applications continue to use Sendmail’s binaries to try to send email after they are disabled, mail could go into an inactive Sendmail queue and never be delivered.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In order to completely disable Sendmail, add or edit the following lines in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;
sendmail_submit_enable=&#34;NO&#34;
sendmail_outbound_enable=&#34;NO&#34;
sendmail_msp_queue_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>To only disable Sendmail’s incoming mail service, use only this entry in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>More information on Sendmail’s startup options is available in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.sendmail&amp;sektion=8&amp;format=html">rc.sendmail(8)</a>.</p></div></div><div class=sect3><h4 id=_替換預設的_mta>28.4.2. 替換預設的 MTA<a class=anchor href=#_替換預設的_mta></a></h4><div class=paragraph><p>When a new MTA is installed using the Ports Collection, its startup script is also installed and startup instructions are mentioned in its package message. Before starting the new MTA, stop the running Sendmail processes. This example stops all of these services, then starts the Postfix service:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sendmail stop</span>
<span class=c># service postfix start</span></code></pre></div></div><div class=paragraph><p>To start the replacement MTA at system boot, add its configuration line to <span class=filename>/etc/rc.conf</span>. This entry enables the Postfix MTA:</p></div><div class="literalblock programlisting"><div class=content><pre>postfix_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Some extra configuration is needed as Sendmail is so ubiquitous that some software assumes it is already installed and configured. Check <span class=filename>/etc/periodic.conf</span> and make sure that these values are set to <code>NO</code>. If this file does not exist, create it with these entries:</p></div><div class="literalblock programlisting"><div class=content><pre>daily_clean_hoststat_enable=&#34;NO&#34;
daily_status_mail_rejects_enable=&#34;NO&#34;
daily_status_include_submit_mailq=&#34;NO&#34;
daily_submit_queuerun=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Some alternative MTAs provide their own compatible implementations of the Sendmail command-line interface in order to facilitate using them as drop-in replacements for Sendmail. However, some MUAs may try to execute standard Sendmail binaries instead of the new MTA’s binaries. FreeBSD uses <span class=filename>/etc/mail/mailer.conf</span> to map the expected Sendmail binaries to the location of the new binaries. More information about this mapping can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=mailwrapper&amp;sektion=8&amp;format=html">mailwrapper(8)</a>.</p></div><div class=paragraph><p>The default <span class=filename>/etc/mail/mailer.conf</span> looks like this:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $
#
# Execute the &#34;real&#34; sendmail program, named /usr/libexec/sendmail/sendmail
#
sendmail        /usr/libexec/sendmail/sendmail
send-mail       /usr/libexec/sendmail/sendmail
mailq           /usr/libexec/sendmail/sendmail
newaliases      /usr/libexec/sendmail/sendmail
hoststat        /usr/libexec/sendmail/sendmail
purgestat       /usr/libexec/sendmail/sendmail</pre></div></div><div class=paragraph><p>When any of the commands listed on the left are run, the system actually executes the associated command shown on the right. This system makes it easy to change what binaries are executed when these default binaries are invoked.</p></div><div class=paragraph><p>Some MTAs, when installed using the Ports Collection, will prompt to update this file for the new binaries. For example, Postfix will update the file like this:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Execute the Postfix sendmail program, named /usr/local/sbin/sendmail
#
sendmail        /usr/local/sbin/sendmail
send-mail       /usr/local/sbin/sendmail
mailq           /usr/local/sbin/sendmail
newaliases      /usr/local/sbin/sendmail</pre></div></div><div class=paragraph><p>If the installation of the MTA does not automatically update <span class=filename>/etc/mail/mailer.conf</span>, edit this file in a text editor so that it points to the new binaries. This example points to the binaries installed by <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail        /usr/local/sbin/ssmtp
send-mail       /usr/local/sbin/ssmtp
mailq           /usr/local/sbin/ssmtp
newaliases      /usr/local/sbin/ssmtp
hoststat        /usr/bin/true
purgestat       /usr/bin/true</pre></div></div><div class=paragraph><p>Once everything is configured, it is recommended to reboot the system. Rebooting provides the opportunity to ensure that the system is correctly configured to start the new MTA automatically on boot.</p></div></div></div><div class=sect2><h3 id=mail-trouble>28.5. 疑難排解<a class=anchor href=#mail-trouble></a></h3><div class=sect3><h4 id=_why_do_i_have_to_use_the_fqdn_for_hosts_on_my_site>28.5.1. Why do I have to use the FQDN for hosts on my site?<a class=anchor href=#_why_do_i_have_to_use_the_fqdn_for_hosts_on_my_site></a></h4><div class=paragraph><p>The host may actually be in a different domain. For example, in order for a host in <code>foo.bar.edu</code> to reach a host called <code>mumble</code> in the <code>bar.edu</code> domain, refer to it by the Fully-Qualified Domain Name FQDN, <code>mumble.bar.edu</code>, instead of just <code>mumble</code>.</p></div><div class=paragraph><p>This is because the version of BIND which ships with FreeBSD no longer provides default abbreviations for non-FQDNs other than the local domain. An unqualified host such as <code>mumble</code> must either be found as <code>mumble.foo.bar.edu</code>, or it will be searched for in the root domain.</p></div><div class=paragraph><p>In older versions of BIND, the search continued across <code>mumble.bar.edu</code>, and <code>mumble.edu</code>. RFC 1535 details why this is considered bad practice or even a security hole.</p></div><div class=paragraph><p>As a good workaround, place the line:</p></div><div class="literalblock programlisting"><div class=content><pre>search foo.bar.edu bar.edu</pre></div></div><div class=paragraph><p>instead of the previous:</p></div><div class="literalblock programlisting"><div class=content><pre>domain foo.bar.edu</pre></div></div><div class=paragraph><p>into <span class=filename>/etc/resolv.conf</span>. However, make sure that the search order does not go beyond the "boundary between local and public administration", as RFC 1535 calls it.</p></div></div><div class=sect3><h4 id=_how_can_i_run_a_mail_server_on_a_dial_up_ppp_host>28.5.2. How can I run a mail server on a dial-up PPP host?<a class=anchor href=#_how_can_i_run_a_mail_server_on_a_dial_up_ppp_host></a></h4><div class=paragraph><p>Connect to a FreeBSD mail gateway on the LAN. The PPP connection is non-dedicated.</p></div><div class=paragraph><p>One way to do this is to get a full-time Internet server to provide secondary MX services for the domain. In this example, the domain is <code>example.com</code> and the ISP has configured <code>example.net</code> to provide secondary MX services to the domain:</p></div><div class="literalblock programlisting"><div class=content><pre>example.com.          MX        10      example.com.
                      MX        20      example.net.</pre></div></div><div class=paragraph><p>Only one host should be specified as the final recipient. For Sendmail, add <code>Cw example.com</code> in <span class=filename>/etc/mail/sendmail.cf</span> on <code>example.com</code>.</p></div><div class=paragraph><p>When the sending MTA attempts to deliver mail, it will try to connect to the system, <code>example.com</code>, over the PPP link. This will time out if the destination is offline. The MTA will automatically deliver it to the secondary MX site at the Internet Service Provider (ISP), <code>example.net</code>. The secondary MX site will periodically try to connect to the primary MX host, <code>example.com</code>.</p></div><div class=paragraph><p>Use something like this as a login script:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Put me in /usr/local/bin/pppmyisp
( sleep 60 ; /usr/sbin/sendmail -q ) &amp;
/usr/sbin/ppp -direct pppmyisp</pre></div></div><div class=paragraph><p>When creating a separate login script for users, instead use <code>sendmail -qRexample.com</code> in the script above. This will force all mail in the queue for <code>example.com</code> to be processed immediately.</p></div><div class=paragraph><p>A further refinement of the situation can be seen from this example from the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-isp>FreeBSD Internet service provider’s mailing list</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>&gt; we provide the secondary MX for a customer. The customer connects to
&gt; our services several times a day automatically to get the mails to
&gt; his primary MX (We do not call his site when a mail for his domains
&gt; arrived). Our sendmail sends the mailqueue every 30 minutes. At the
&gt; moment he has to stay 30 minutes online to be sure that all mail is
&gt; gone to the primary MX.
&gt;
&gt; Is there a command that would initiate sendmail to send all the mails
&gt; now? The user has not root-privileges on our machine of course.

In the privacy flags section of sendmail.cf, there is a
definition Opgoaway,restrictqrun

Remove restrictqrun to allow non-root users to start the queue processing.
You might also like to rearrange the MXs. We are the 1st MX for our
customers like this, and we have defined:

# If we are the best MX for a host, try directly instead of generating
# local config error.
OwTrue

That way a remote site will deliver straight to you, without trying
the customer connection.  You then send to your customer.  Only works for
hosts, so you need to get your customer to name their mail
machine customer.com as well as
hostname.customer.com in the DNS.  Just put an A record in
the DNS for customer.com.</pre></div></div></div></div><div class=sect2><h3 id=mail-advanced>28.6. 進階主題<a class=anchor href=#mail-advanced></a></h3><div class=paragraph><p>This section covers more involved topics such as mail configuration and setting up mail for an entire domain.</p></div><div class=sect3><h4 id=mail-config>28.6.1. 基礎設定<a class=anchor href=#mail-config></a></h4><div class=paragraph><p>Out of the box, one can send email to external hosts as long as <span class=filename>/etc/resolv.conf</span> is configured or the network has access to a configured DNS server. To have email delivered to the MTA on the FreeBSD host, do one of the following:</p></div><div class=ulist><ul><li><p>Run a DNS server for the domain.</p></li><li><p>Get mail delivered directly to the FQDN for the machine.</p></li></ul></div><div class=paragraph><p>In order to have mail delivered directly to a host, it must have a permanent static IP address, not a dynamic IP address. If the system is behind a firewall, it must be configured to allow SMTP traffic. To receive mail directly at a host, one of these two must be configured:</p></div><div class=ulist><ul><li><p>Make sure that the lowest-numbered MX record in DNS points to the host’s static IP address.</p></li><li><p>Make sure there is no MX entry in the DNS for the host.</p></li></ul></div><div class=paragraph><p>Either of the above will allow mail to be received directly at the host.</p></div><div class=paragraph><p>Try this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hostname</span>
example.FreeBSD.org
<span class=c># host example.FreeBSD.org</span>
example.FreeBSD.org has address 204.216.27.XX</code></pre></div></div><div class=paragraph><p>In this example, mail sent directly to <a href=mailto:yourlogin@example.FreeBSD.org>yourlogin@example.FreeBSD.org</a> should work without problems, assuming Sendmail is running correctly on <code>example.FreeBSD.org</code>.</p></div><div class=paragraph><p>For this example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># host example.FreeBSD.org</span>
example.FreeBSD.org has address 204.216.27.XX
example.FreeBSD.org mail is handled <span class=o>(</span><span class=nv>pri</span><span class=o>=</span>10<span class=o>)</span> by nevdull.FreeBSD.org</code></pre></div></div><div class=paragraph><p>All mail sent to <code>example.FreeBSD.org</code> will be collected on <code>hub</code> under the same username instead of being sent directly to your host.</p></div><div class=paragraph><p>The above information is handled by the DNS server. The DNS record that carries mail routing information is the MX entry. If no MX record exists, mail will be delivered directly to the host by way of its IP address.</p></div><div class=paragraph><p>The MX entry for <code>freefall.FreeBSD.org</code> at one time looked like this:</p></div><div class="literalblock programlisting"><div class=content><pre>freefall		MX	30	mail.crl.net
freefall		MX	40	agora.rdrop.com
freefall		MX	10	freefall.FreeBSD.org
freefall		MX	20	who.cdrom.com</pre></div></div><div class=paragraph><p><code>freefall</code> had many MX entries. The lowest MX number is the host that receives mail directly, if available. If it is not accessible for some reason, the next lower-numbered host will accept messages temporarily, and pass it along when a lower-numbered host becomes available.</p></div><div class=paragraph><p>Alternate MX sites should have separate Internet connections in order to be most useful. Your ISP can provide this service.</p></div></div><div class=sect3><h4 id=mail-domain>28.6.2. 網域中的郵件<a class=anchor href=#mail-domain></a></h4><div class=paragraph><p>When configuring a MTA for a network, any mail sent to hosts in its domain should be diverted to the MTA so that users can receive their mail on the master mail server.</p></div><div class=paragraph><p>To make life easiest, a user account with the same <em>username</em> should exist on both the MTA and the system with the MUA. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> to create the user accounts.</p></div><div class=paragraph><p>The MTA must be the designated mail exchanger for each workstation on the network. This is done in theDNS configuration with an MX record:</p></div><div class="literalblock programlisting"><div class=content><pre>example.FreeBSD.org	A	204.216.27.XX		; Workstation
			MX	10 nevdull.FreeBSD.org	; Mailhost</pre></div></div><div class=paragraph><p>This will redirect mail for the workstation to the MTA no matter where the A record points. The mail is sent to the MX host.</p></div><div class=paragraph><p>This must be configured on a DNS server. If the network does not run its own DNS server, talk to the ISP or DNS provider.</p></div><div class=paragraph><p>The following is an example of virtual email hosting. Consider a customer with the domain <code>customer1.org</code>, where all the mail for <code>customer1.org</code> should be sent to <code>mail.myhost.com</code>. The DNS entry should look like this:</p></div><div class="literalblock programlisting"><div class=content><pre>customer1.org		MX	10	mail.myhost.com</pre></div></div><div class=paragraph><p>An <code>A</code>> record is <em>not</em> needed for <code>customer1.org</code> in order to only handle email for that domain. However, running <code>ping</code> against <code>customer1.org</code> will not work unless an <code>A</code> record exists for it.</p></div><div class=paragraph><p>Tell the MTA which domains and/or hostnames it should accept mail for. Either of the following will work for Sendmail:</p></div><div class=ulist><ul><li><p>Add the hosts to <span class=filename>/etc/mail/local-host-names</span> when using the <code>FEATURE(use_cw_file)</code>.</p></li><li><p>Add a <code>Cwyour.host.com</code> line to <span class=filename>/etc/sendmail.cf</span>.</p></li></ul></div></div></div><div class=sect2><h3 id=outgoing-only>28.7. 寄件設定<a class=anchor href=#outgoing-only></a></h3><div class=paragraph><p>There are many instances where one may only want to send mail through a relay. Some examples are:</p></div><div class=ulist><ul><li><p>The computer is a desktop machine that needs to use programs such as <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>, using the ISP’s mail relay.</p></li><li><p>The computer is a server that does not handle mail locally, but needs to pass off all mail to a relay for processing.</p></li></ul></div><div class=paragraph><p>While any MTA is capable of filling this particular niche, it can be difficult to properly configure a full-featured MTA just to handle offloading mail. Programs such as Sendmail and Postfix are overkill for this use.</p></div><div class=paragraph><p>Additionally, a typical Internet access service agreement may forbid one from running a "mail server".</p></div><div class=paragraph><p>The easiest way to fulfill those needs is to install the <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/mail/ssmtp</span>
<span class=c># make install replace clean</span></code></pre></div></div><div class=paragraph><p>Once installed, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> can be configured with <span class=filename>/usr/local/etc/ssmtp/ssmtp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>root=yourrealemail@example.com
mailhub=mail.example.com
rewriteDomain=example.com
hostname=_HOSTNAME_</pre></div></div><div class=paragraph><p>Use the real email address for <code>root</code>. Enter the ISP’s outgoing mail relay in place of <code>mail.example.com</code>. Some ISPs call this the "outgoing mail server" or "SMTP server".</p></div><div class=paragraph><p>Make sure to disable Sendmail, including the outgoing mail service. See <a href=#mail-disable-sendmail>關閉 Sendmail</a> for details.</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> has some other options available. Refer to the examples in <span class=filename>/usr/local/etc/ssmtp</span> or the manual page of ssmtp for more information.</p></div><div class=paragraph><p>Setting up ssmtp in this manner allows any software on the computer that needs to send mail to function properly, while not violating the ISP’s usage policy or allowing the computer to be hijacked for spamming.</p></div></div><div class=sect2><h3 id=SMTP-dialup>28.8. 在撥號連線使用郵件<a class=anchor href=#SMTP-dialup></a></h3><div class=paragraph><p>When using a static IP address, one should not need to adjust the default configuration. Set the hostname to the assigned Internet name and Sendmail will do the rest.</p></div><div class=paragraph><p>When using a dynamically assigned IP address and a dialup PPP connection to the Internet, one usually has a mailbox on the ISP’s mail server. In this example, the ISP’s domain is <code>example.net</code>, the user name is <code>user</code>, the hostname is <code>bsd.home</code>, and the ISP has allowed <code>relay.example.net</code> as a mail relay.</p></div><div class=paragraph><p>In order to retrieve mail from the ISP’s mailbox, install a retrieval agent from the Ports Collection. <a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a> is a good choice as it supports many different protocols. Usually, the ISP will provide POP. When using user PPP, email can be automatically fetched when an Internet connection is established with the following entry in <span class=filename>/etc/ppp/ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>MYADDR:
!bg su user -c fetchmail</pre></div></div><div class=paragraph><p>When using Sendmail to deliver mail to non-local accounts, configure Sendmail to process the mail queue as soon as the Internet connection is established. To do this, add this line after the above <code>fetchmail</code> entry in <span class=filename>/etc/ppp/ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>  !bg su user -c &#34;sendmail -q&#34;</pre></div></div><div class=paragraph><p>In this example, there is an account for <code>user</code> on <code>bsd.home</code>. In the home directory of <code>user</code> on <code>bsd.home</code>, create a <span class=filename>.fetchmailrc</span> which contains this line:</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.net protocol pop3 fetchall pass MySecret</pre></div></div><div class=paragraph><p>This file should not be readable by anyone except <code>user</code> as it contains the password <code>MySecret</code>.</p></div><div class=paragraph><p>In order to send mail with the correct <code>from:</code> header, configure Sendmail to use <a href=mailto:user@example.net>user@example.net</a> rather than <a href=mailto:user@bsd.home>user@bsd.home</a> and to send all mail via <code>relay.example.net</code>, allowing quicker mail transmission.</p></div><div class=paragraph><p>The following <span class=filename>.mc</span> should suffice:</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`bsd.home.mc version 1.0&#39;)
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net&#39;)dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST&#39;, `relay.example.net&#39;)
Dmbsd.home
define(`confDOMAIN_NAME&#39;,`bsd.home&#39;)dnl
define(`confDELIVERY_MODE&#39;,`deferred&#39;)dnl</pre></div></div><div class=paragraph><p>Refer to the previous section for details of how to convert this file into the <span class=filename>sendmail.cf</span> format. Do not forget to restart Sendmail after updating <span class=filename>sendmail.cf</span>.</p></div></div><div class=sect2><h3 id=SMTP-Auth>28.9. SMTP 認證<a class=anchor href=#SMTP-Auth></a></h3><div class=paragraph><p>Configuring SMTP authentication on the MTA provides a number of benefits. SMTP authentication adds a layer of security to Sendmail, and provides mobile users who switch hosts the ability to use the same MTA without the need to reconfigure their mail client’s settings each time.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Install <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2/>security/cyrus-sasl2</a> from the Ports Collection. This port supports a number of compile-time options. For the SMTP authentication method demonstrated in this example, make sure that <code>LOGIN</code> is not disabled.</p></li><li><p>After installing <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2/>security/cyrus-sasl2</a>, edit <span class=filename>/usr/local/lib/sasl2/Sendmail.conf</span>, or create it if it does not exist, and add the following line:</p><div class="literalblock programlisting"><div class=content><pre>pwcheck_method: saslauthd</pre></div></div></li><li><p>Next, install <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2-saslauthd/>security/cyrus-sasl2-saslauthd</a> and add the following line to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>saslauthd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Finally, start the saslauthd daemon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service saslauthd start</span></code></pre></div></div><div class=paragraph><p>This daemon serves as a broker for Sendmail to authenticate against the FreeBSD <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=5&amp;format=html">passwd(5)</a> database. This saves the trouble of creating a new set of usernames and passwords for each user that needs to use SMTP authentication, and keeps the login and mail password the same.</p></div></li><li><p>Next, edit <span class=filename>/etc/make.conf</span> and add the following lines:</p><div class="literalblock programlisting"><div class=content><pre>SENDMAIL_CFLAGS=-I/usr/local/include/sasl -DSASL
SENDMAIL_LDFLAGS=-L/usr/local/lib
SENDMAIL_LDADD=-lsasl2</pre></div></div><div class=paragraph><p>These lines provide Sendmail the proper configuration options for linking to <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl2/>cyrus-sasl2</a> at compile time. Make sure that <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl2/>cyrus-sasl2</a> has been installed before recompiling Sendmail.</p></div></li><li><p>Recompile Sendmail by executing the following commands:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/lib/libsmutil</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make</span>
<span class=c># cd /usr/src/lib/libsm</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make</span>
<span class=c># cd /usr/src/usr.sbin/sendmail</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make &amp;&amp; make install</span></code></pre></div></div><div class=paragraph><p>This compile should not have any problems if <span class=filename>/usr/src</span> has not changed extensively and the shared libraries it needs are available.</p></div></li><li><p>After Sendmail has been compiled and reinstalled, edit <span class=filename>/etc/mail/freebsd.mc</span> or the local <span class=filename>.mc</span>. Many administrators choose to use the output from <a href="https://man.freebsd.org/cgi/man.cgi?query=hostname&amp;sektion=1&amp;format=html">hostname(1)</a> as the name of <span class=filename>.mc</span> for uniqueness. Add these lines:</p><div class="literalblock programlisting"><div class=content><pre>dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confAUTH_MECHANISMS&#39;, `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl</pre></div></div><div class=paragraph><p>These options configure the different methods available to Sendmail for authenticating users. To use a method other than pwcheck, refer to the Sendmail documentation.</p></div></li><li><p>Finally, run <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> while in <span class=filename>/etc/mail</span>. That will run the new <span class=filename>.mc</span> and create a <span class=filename>.cf</span> named either <span class=filename>freebsd.cf</span> or the name used for the local <span class=filename>.mc</span>. Then, run <code>make install restart</code>, which will copy the file to <span class=filename>sendmail.cf</span>, and properly restart Sendmail. For more information about this process, refer to <span class=filename>/etc/mail/Makefile</span>.</p></li></ol></div></div></div><div class=paragraph><p>To test the configuration, use a MUA to send a test message. For further investigation, set the <code>LogLevel</code> of Sendmail to <code>13</code> and watch <span class=filename>/var/log/maillog</span> for any errors.</p></div><div class=paragraph><p>For more information, refer to <a href=http://www.sendmail.org/~ca/email/auth.html>SMTP authentication</a>.</p></div></div><div class=sect2><h3 id=mail-agents>28.10. 郵件使用者代理程式<a class=anchor href=#mail-agents></a></h3><div class=paragraph><p>A MUA is an application that is used to send and receive email. As email "evolves" and becomes more complex, MUAs are becoming increasingly powerful and provide users increased functionality and flexibility. The <code>mail</code> category of the FreeBSD Ports Collection contains numerous MUAs. These include graphical email clients such as Evolution or Balsa and console based clients such as mutt or alpine.</p></div><div class=sect3><h4 id=mail-command>28.10.1. <code>mail</code><a class=anchor href=#mail-command></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> is the default MUA installed with FreeBSD. It is a console based MUA that offers the basic functionality required to send and receive text-based email. It provides limited attachment support and can only access local mailboxes.</p></div><div class=paragraph><p>Although <code>mail</code> does not natively support interaction with POP or IMAP servers, these mailboxes may be downloaded to a local <span class=filename>mbox</span> using an application such as fetchmail.</p></div><div class=paragraph><p>In order to send and receive email, run <code>mail</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail</code></pre></div></div><div class=paragraph><p>The contents of the user’s mailbox in <span class=filename>/var/mail</span> are automatically read by <code>mail</code>. Should the mailbox be empty, the utility exits with a message indicating that no mail could be found. If mail exists, the application interface starts, and a list of messages will be displayed. Messages are automatically numbered, as can be seen in the following example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mail version 8.1 6/6/93.  Type ? <span class=k>for </span>help.
<span class=s2>&#34;/var/mail/marcs&#34;</span>: 3 messages 3 new
<span class=o>&gt;</span>N  1 root@localhost        Mon Mar  8 14:05  14/510   <span class=s2>&#34;test&#34;</span>
 N  2 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;user account&#34;</span>
 N  3 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;sample&#34;</span></code></pre></div></div><div class=paragraph><p>Messages can now be read by typing <kbd>t</kbd> followed by the message number. This example reads the first email:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp; t 1
Message 1:
From root@localhost  Mon Mar  8 14:05:52 2004
X-Original-To: marcs@localhost
Delivered-To: marcs@localhost
To: marcs@localhost
Subject: <span class=nb>test
</span>Date: Mon,  8 Mar 2004 14:05:52 +0200 <span class=o>(</span>SAST<span class=o>)</span>
From: root@localhost <span class=o>(</span>Charlie Root<span class=o>)</span>

This is a <span class=nb>test </span>message, please reply <span class=k>if </span>you receive it.</code></pre></div></div><div class=paragraph><p>As seen in this example, the message will be displayed with full headers. To display the list of messages again, press <kbd>h</kbd>.</p></div><div class=paragraph><p>If the email requires a reply, press either <kbd>R</kbd> or <kbd>r</kbd><code>mail</code> keys. <kbd>R</kbd> instructs <code>mail</code> to reply only to the sender of the email, while <kbd>r</kbd> replies to all other recipients of the message. These commands can be suffixed with the mail number of the message to reply to. After typing the response, the end of the message should be marked by a single <kbd>.</kbd> on its own line. An example can be seen below:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp; R 1
To: root@localhost
Subject: Re: <span class=nb>test

</span>Thank you, I did get your email.
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>In order to send a new email, press <kbd>m</kbd>, followed by the recipient email address. Multiple recipients may be specified by separating each address with the <kbd>,</kbd> delimiter. The subject of the message may then be entered, followed by the message contents. The end of the message should be specified by putting a single <kbd>.</kbd> on its own line.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp; mail root@localhost
Subject: I mastered mail

Now I can send and receive email using mail ... :<span class=o>)</span>
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>While using <code>mail</code>, press <kbd>?</kbd> to display help at any time. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> for more help on how to use <code>mail</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> was not designed to handle attachments and thus deals with them poorly. Newer MUAs handle attachments in a more intelligent way. Users who prefer to use <code>mail</code> may find the <a class=package href=https://cgit.freebsd.org/ports/tree/converters/mpack/>converters/mpack</a> port to be of considerable use.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mutt-command>28.10.2. mutt<a class=anchor href=#mutt-command></a></h4><div class=paragraph><p>mutt is a powerful MUA, with many features, including:</p></div><div class=ulist><ul><li><p>The ability to thread messages.</p></li><li><p>PGP support for digital signing and encryption of email.</p></li><li><p>MIME support.</p></li><li><p>Maildir support.</p></li><li><p>Highly customizable.</p></li></ul></div><div class=paragraph><p>Refer to <a href=http://www.mutt.org>http://www.mutt.org</a> for more information on mutt.</p></div><div class=paragraph><p>mutt may be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/mail/mutt/>mail/mutt</a> port. After the port has been installed, mutt can be started by issuing the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mutt</code></pre></div></div><div class=paragraph><p>mutt will automatically read and display the contents of the user mailbox in <span class=filename>/var/mail</span>. If no mails are found, mutt will wait for commands from the user. The example below shows mutt displaying a list of messages:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt1.png alt=mutt1></div></div><div class=paragraph><p>To read an email, select it using the cursor keys and press <kbd>Enter</kbd>. An example of mutt displaying email can be seen below:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt2.png alt=mutt2></div></div><div class=paragraph><p>Similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>, mutt can be used to reply only to the sender of the message as well as to all recipients. To reply only to the sender of the email, press <kbd>r</kbd>. To send a group reply to the original sender as well as all the message recipients, press <kbd>g</kbd>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>By default, mutt uses the <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> editor for creating and replying to emails. Each user can customize this by creating or editing the <span class=filename>.muttrc</span> in their home directory and setting the <code>editor</code> variable or by setting the <code>EDITOR</code> environment variable. Refer to <a href=http://www.mutt.org/>http://www.mutt.org/</a> for more information about configuring mutt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To compose a new mail message, press <kbd>m</kbd>. After a valid subject has been given, mutt will start <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> so the email can be written. Once the contents of the email are complete, save and quit from <code>vi</code>. mutt will resume, displaying a summary screen of the mail that is to be delivered. In order to send the mail, press <kbd>y</kbd>. An example of the summary screen can be seen below:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt3.png alt=mutt3></div></div><div class=paragraph><p>mutt contains extensive help which can be accessed from most of the menus by pressing <kbd>?</kbd>. The top line also displays the keyboard shortcuts where appropriate.</p></div></div><div class=sect3><h4 id=alpine-command>28.10.3. alpine<a class=anchor href=#alpine-command></a></h4><div class=paragraph><p>alpine is aimed at a beginner user, but also includes some advanced features.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>alpine has had several remote vulnerabilities discovered in the past, which allowed remote attackers to execute arbitrary code as users on the local system, by the action of sending a specially-prepared email. While <em>known</em> problems have been fixed, alpine code is written in an insecure style and the FreeBSD Security Officer believes there are likely to be other undiscovered vulnerabilities. Users install alpine at their own risk.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The current version of alpine may be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/mail/alpine/>mail/alpine</a> port. Once the port has installed, alpine can be started by issuing the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% alpine</code></pre></div></div><div class=paragraph><p>The first time alpine runs, it displays a greeting page with a brief introduction, as well as a request from the alpine development team to send an anonymous email message allowing them to judge how many users are using their client. To send this anonymous message, press <kbd>Enter</kbd>. Alternatively, press <kbd>E</kbd> to exit the greeting without sending an anonymous message. An example of the greeting page is shown below:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine1.png alt=pine1></div></div><div class=paragraph><p>The main menu is then presented, which can be navigated using the cursor keys. This main menu provides shortcuts for the composing new mails, browsing mail directories, and administering address book entries. Below the main menu, relevant keyboard shortcuts to perform functions specific to the task at hand are shown.</p></div><div class=paragraph><p>The default directory opened by alpine is <span class=filename>inbox</span>. To view the message index, press <kbd>I</kbd>, or select the <span class=guimenuitem>MESSAGE INDEX</span> option shown below:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine2.png alt=pine2></div></div><div class=paragraph><p>The message index shows messages in the current directory and can be navigated by using the cursor keys. Highlighted messages can be read by pressing <kbd>Enter</kbd>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine3.png alt=pine3></div></div><div class=paragraph><p>In the screenshot below, a sample message is displayed by alpine. Contextual keyboard shortcuts are displayed at the bottom of the screen. An example of one of a shortcut is <kbd>r</kbd>, which tells the MUA to reply to the current message being displayed.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine4.png alt=pine4></div></div><div class=paragraph><p>Replying to an email in alpine is done using the pico editor, which is installed by default with alpine. pico makes it easy to navigate the message and is easier for novice users to use than <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>. Once the reply is complete, the message can be sent by pressing <span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>. alpine will ask for confirmation before sending the message.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine5.png alt=pine5></div></div><div class=paragraph><p>alpine can be customized using the <span class=guimenuitem>SETUP</span> option from the main menu. Consult <a href=http://www.washington.edu/alpine/>http://www.washington.edu/alpine/</a> for more information.</p></div></div></div><div class=sect2><h3 id=mail-fetchmail>28.11. 使用 fetchmail<a class=anchor href=#mail-fetchmail></a></h3><div class=paragraph><p>fetchmail is a full-featured IMAP and POP client. It allows users to automatically download mail from remote IMAP and POP servers and save it into local mailboxes where it can be accessed more easily. fetchmail can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a> port, and offers various features, including:</p></div><div class=ulist><ul><li><p>Support for the POP3, APOP, KPOP, IMAP, ETRN and ODMR protocols.</p></li><li><p>Ability to forward mail using SMTP, which allows filtering, forwarding, and aliasing to function normally.</p></li><li><p>May be run in daemon mode to check periodically for new messages.</p></li><li><p>Can retrieve multiple mailboxes and forward them, based on configuration, to different local users.</p></li></ul></div><div class=paragraph><p>This section explains some of the basic features of fetchmail. This utility requires a <span class=filename>.fetchmailrc</span> configuration in the user’s home directory in order to run correctly. This file includes server information as well as login credentials. Due to the sensitive nature of the contents of this file, it is advisable to make it readable only by the user, with the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>600 .fetchmailrc</code></pre></div></div><div class=paragraph><p>The following <span class=filename>.fetchmailrc</span> serves as an example for downloading a single user mailbox using POP. It tells fetchmail to connect to <code>example.com</code> using a username of <code>joesoap</code> and a password of <code>XXX</code>. This example assumes that the user <code>joesoap</code> exists on the local system.</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.com protocol pop3 username &#34;joesoap&#34; password &#34;XXX&#34;</pre></div></div><div class=paragraph><p>The next example connects to multiple POP and IMAP servers and redirects to different local usernames where applicable:</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.com proto pop3:
user &#34;joesoap&#34;, with password &#34;XXX&#34;, is &#34;jsoap&#34; here;
user &#34;andrea&#34;, with password &#34;XXXX&#34;;
poll example2.net proto imap:
user &#34;john&#34;, with password &#34;XXXXX&#34;, is &#34;myth&#34; here;</pre></div></div><div class=paragraph><p>fetchmail can be run in daemon mode by running it with <code>-d</code>, followed by the interval (in seconds) that fetchmail should poll servers listed in <span class=filename>.fetchmailrc</span>. The following example configures fetchmail to poll every 600 seconds:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% fetchmail <span class=nt>-d</span> 600</code></pre></div></div><div class=paragraph><p>More information on fetchmail can be found at <a href=http://www.fetchmail.info/>http://www.fetchmail.info/</a>.</p></div></div><div class=sect2><h3 id=mail-procmail>28.12. 使用 procmail<a class=anchor href=#mail-procmail></a></h3><div class=paragraph><p>procmail is a powerful application used to filter incoming mail. It allows users to define "rules" which can be matched to incoming mails to perform specific functions or to reroute mail to alternative mailboxes or email addresses. procmail can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/mail/procmail/>mail/procmail</a> port. Once installed, it can be directly integrated into most MTAs. Consult the MTA documentation for more information. Alternatively, procmail can be integrated by adding the following line to a <span class=filename>.forward</span> in the home directory of the user:</p></div><div class="literalblock programlisting"><div class=content><pre>&#34;|exec /usr/local/bin/procmail || exit 75&#34;</pre></div></div><div class=paragraph><p>The following section displays some basic procmail rules, as well as brief descriptions of what they do. Rules must be inserted into a <span class=filename>.procmailrc</span>, which must reside in the user’s home directory.</p></div><div class=paragraph><p>The majority of these rules can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=procmailex&amp;sektion=5&amp;format=html">procmailex(5)</a>.</p></div><div class=paragraph><p>To forward all mail from <a href=mailto:user@example.com>user@example.com</a> to an external address of <a href=mailto:goodmail@example2.com>goodmail@example2.com</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^From.*user@example.com
! goodmail@example2.com</pre></div></div><div class=paragraph><p>To forward all mails shorter than 1000 bytes to an external address of <a href=mailto:goodmail@example2.com>goodmail@example2.com</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* &lt; 1000
! goodmail@example2.com</pre></div></div><div class=paragraph><p>To send all mail sent to <a href=mailto:alternate@example.com>alternate@example.com</a> to a mailbox called <span class=filename>alternate</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^TOalternate@example.com
alternate</pre></div></div><div class=paragraph><p>To send all mail with a subject of "Spam" to <span class=filename>/dev/null</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
^Subject:.*Spam
/dev/null</pre></div></div><div class=paragraph><p>A useful recipe that parses incoming <code>FreeBSD.org</code> mailing lists and places each list in its own mailbox:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^Sender:.owner-freebsd-\/[^@]+@FreeBSD.ORG
{
	LISTNAME=${MATCH}
	:0
	* LISTNAME??^\/[^@]+
	FreeBSD-${MATCH}
}</pre></div></div></div></div></div><div class=sect1><h2 id=network-servers>Chapter 29. 網路伺服器<a class=anchor href=#network-servers></a></h2><div class=sectionbody><div class=sect2><h3 id=network-servers-synopsis>29.1. 概述<a class=anchor href=#network-servers-synopsis></a></h3><div class=paragraph><p>本章節涵蓋一些在 UNIX™ 系統常用的網路服務，包含安裝、設定、測試及維護各種不同類型的網路服務。本章會提供範例設定檔以供參考。</p></div><div class=paragraph><p>讀完本章，您將了解：</p></div><div class=ulist><ul><li><p>如何管理 inetd Daemon。</p></li><li><p>如何設定網路檔案系統 (Network File System, NFS)。</p></li><li><p>如何設定網路資訊伺服器 (Network Information Server, NIS) 來集中管理及共用使用者帳號。</p></li><li><p>如何設定 FreeBSD 成為 LDAP 伺服器或客戶端</p></li><li><p>如何設定使用 DHCP 自動網路設定。</p></li><li><p>如何設定網域名稱伺服器 (Domain Name Server, DNS)。</p></li><li><p>如何設定 ApacheHTTP 伺服器。</p></li><li><p>如何設定檔案傳輸協定 (File Transfer Protocol, FTP) 伺服器。</p></li><li><p>如何設定 Samba 檔案與列印伺服器供 Windows™ 客戶端使用。</p></li><li><p>如何同步時間與日期，並使用網路時間協定 (Network Time Protocol, NTP) 設定時間伺服器。</p></li><li><p>如何設定 iSCSI。</p></li></ul></div><div class=paragraph><p>本章假設您有以下基礎知識：</p></div><div class=ulist><ul><li><p><span class=filename>/etc/rc</span> Script。</p></li><li><p>網路術語。</p></li><li><p>安裝其他第三方軟體 (<a href=./#ports>安裝應用程式：套件與 Port</a>)。</p></li></ul></div></div><div class=sect2><h3 id=network-inetd>29.2. inetd 超級伺服器<a class=anchor href=#network-inetd></a></h3><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> daemon is sometimes referred to as a Super-Server because it manages connections for many services. Instead of starting multiple applications, only the inetd service needs to be started. When a connection is received for a service that is managed by inetd, it determines which program the connection is destined for, spawns a process for that program, and delegates the program a socket. Using inetd for services that are not heavily used can reduce system load, when compared to running each daemon individually in stand-alone mode.</p></div><div class=paragraph><p>Primarily, inetd is used to spawn other daemons, but several trivial protocols are handled internally, such as chargen, auth, time, echo, discard, and daytime.</p></div><div class=paragraph><p>This section covers the basics of configuring inetd.</p></div><div class=sect3><h4 id=network-inetd-conf>29.2.1. 設定檔<a class=anchor href=#network-inetd-conf></a></h4><div class=paragraph><p>Configuration of inetd is done by editing <span class=filename>/etc/inetd.conf</span>. Each line of this configuration file represents an application which can be started by inetd. By default, every line starts with a comment (<code><mark></mark></code>), meaning that inetd is not listening for any applications. To configure inetd to listen for an application’s connections, remove the <code></code> at the beginning of the line for that application.</p></div><div class=paragraph><p>After saving your edits, configure inetd to start at system boot by editing <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To start inetd now, so that it listens for the service you configured, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div><div class=paragraph><p>Once inetd is started, it needs to be notified whenever a modification is made to <span class=filename>/etc/inetd.conf</span>:</p></div><div id=network-inetd-reread class=exampleblock><div class=title>例 46. 重新庫入 inetd 設定檔</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd reload</span></code></pre></div></div></div></div><div class=paragraph><p>Typically, the default entry for an application does not need to be edited beyond removing the <code>#</code>. In some situations, it may be appropriate to edit the default entry.</p></div><div class=paragraph><p>As an example, this is the default entry for <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> over IPv4:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</pre></div></div><div class=paragraph><p>The seven columns in an entry are as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]
user[:group][/login-class]
server-program
server-program-arguments</pre></div></div><div class=paragraph><p>where:</p></div><div class=dlist><dl><dt class=hdlist1>service-name</dt><dd><p>The service name of the daemon to start. It must correspond to a service listed in <span class=filename>/etc/services</span>. This determines which port inetd listens on for incoming connections to that service. When using a custom service, it must first be added to <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>socket-type</dt><dd><p>Either <code>stream</code>, <code>dgram</code>, <code>raw</code>, or <code>seqpacket</code>. Use <code>stream</code> for TCP connections and <code>dgram</code> for UDP services.</p></dd><dt class=hdlist1>protocol</dt><dd><p>Use one of the following protocol names:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Protocol Name</th><th class="tableblock halign-left valign-top">Explanation</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp or tcp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp or udp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Both TCP IPv4 and IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Both UDP IPv4 and IPv6</p></td></tr></tbody></table></dd><dt class=hdlist1>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]</dt><dd><p>In this field, <code>wait</code> or <code>nowait</code> must be specified. <code>max-child</code>, <code>max-connections-per-ip-per-minute</code> and <code>max-child-per-ip</code> are optional.</p><div class=paragraph><p><code>wait|nowait</code> indicates whether or not the service is able to handle its own socket. <code>dgram</code> socket types must use <code>wait</code> while <code>stream</code> daemons, which are usually multi-threaded, should use <code>nowait</code>. <code>wait</code> usually hands off multiple sockets to a single daemon, while <code>nowait</code> spawns a child daemon for each new socket.</p></div><div class=paragraph><p>The maximum number of child daemons inetd may spawn is set by <code>max-child</code>. For example, to limit ten instances of the daemon, place a <code>/10</code> after <code>nowait</code>. Specifying <code>/0</code> allows an unlimited number of children.</p></div><div class=paragraph><p><code>max-connections-per-ip-per-minute</code> limits the number of connections from any particular IP address per minute. Once the limit is reached, further connections from this IP address will be dropped until the end of the minute. For example, a value of <code>/10</code> would limit any particular IP address to ten connection attempts per minute. <code>max-child-per-ip</code> limits the number of child processes that can be started on behalf on any single IP address at any moment. These options can limit excessive resource consumption and help to prevent Denial of Service attacks.</p></div><div class=paragraph><p>An example can be seen in the default settings for <a href="https://man.freebsd.org/cgi/man.cgi?query=fingerd&amp;sektion=8&amp;format=html">fingerd(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -k -s</pre></div></div></dd><dt class=hdlist1>user</dt><dd><p>The username the daemon will run as. Daemons typically run as <code>root</code>, <code>daemon</code>, or <code>nobody</code>.</p></dd><dt class=hdlist1>server-program</dt><dd><p>The full path to the daemon. If the daemon is a service provided by inetd internally, use <code>internal</code>.</p></dd><dt class=hdlist1>server-program-arguments</dt><dd><p>Used to specify any command arguments to be passed to the daemon on invocation. If the daemon is an internal service, use <code>internal</code>.</p></dd></dl></div></div><div class=sect3><h4 id=network-inetd-cmdline>29.2.2. 指令列選項<a class=anchor href=#network-inetd-cmdline></a></h4><div class=paragraph><p>Like most server daemons, inetd has a number of options that can be used to modify its behavior. By default, inetd is started with <code>-wW -C 60</code>. These options enable TCP wrappers for all services, including internal services, and prevent any IP address from requesting any service more than 60 times per minute.</p></div><div class=paragraph><p>To change the default options which are passed to inetd, add an entry for <code>inetd_flags</code> in <span class=filename>/etc/rc.conf</span>. If inetd is already running, restart it with <code>service inetd restart</code>.</p></div><div class=paragraph><p>The available rate limiting options are:</p></div><div class=dlist><dl><dt class=hdlist1>-c maximum</dt><dd><p>Specify the default maximum number of simultaneous invocations of each service, where the default is unlimited. May be overridden on a per-service basis by using <code>max-child</code> in <span class=filename>/etc/inetd.conf</span>.</p></dd><dt class=hdlist1>-C rate</dt><dd><p>Specify the default maximum number of times a service can be invoked from a single IP address per minute. May be overridden on a per-service basis by using <code>max-connections-per-ip-per-minute</code> in <span class=filename>/etc/inetd.conf</span>.</p></dd><dt class=hdlist1>-R rate</dt><dd><p>Specify the maximum number of times a service can be invoked in one minute, where the default is <code>256</code>. A rate of <code>0</code> allows an unlimited number.</p></dd><dt class=hdlist1>-s maximum</dt><dd><p>Specify the maximum number of times a service can be invoked from a single IP address at any one time, where the default is unlimited. May be overridden on a per-service basis by using <code>max-child-per-ip</code> in <span class=filename>/etc/inetd.conf</span>.</p></dd></dl></div><div class=paragraph><p>Additional options are available. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> for the full list of options.</p></div></div><div class=sect3><h4 id=network-inetd-security>29.2.3. 安全注意事項<a class=anchor href=#network-inetd-security></a></h4><div class=paragraph><p>Many of the daemons which can be managed by inetd are not security-conscious. Some daemons, such as fingerd, can provide information that may be useful to an attacker. Only enable the services which are needed and monitor the system for excessive connection attempts. <code>max-connections-per-ip-per-minute</code>, <code>max-child</code> and <code>max-child-per-ip</code> can be used to limit such attacks.</p></div><div class=paragraph><p>By default, TCP wrappers is enabled. Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> for more information on placing TCP restrictions on various inetd invoked daemons.</p></div></div></div><div class=sect2><h3 id=network-nfs>29.3. 網路檔案系統 (NFS)<a class=anchor href=#network-nfs></a></h3><div class=paragraph><p>FreeBSD supports the Network File System (NFS), which allows a server to share directories and files with clients over a network. With NFS, users and programs can access files on remote systems as if they were stored locally.</p></div><div class=paragraph><p>NFS has many practical uses. Some of the more common uses include:</p></div><div class=ulist><ul><li><p>Data that would otherwise be duplicated on each client can be kept in a single location and accessed by clients on the network.</p></li><li><p>Several clients may need access to the <span class=filename>/usr/ports/distfiles</span> directory. Sharing that directory allows for quick access to the source files without having to download them to each client.</p></li><li><p>On large networks, it is often more convenient to configure a central NFS server on which all user home directories are stored. Users can log into a client anywhere on the network and have access to their home directories.</p></li><li><p>Administration of NFS exports is simplified. For example, there is only one file system where security or backup policies must be set.</p></li><li><p>Removable media storage devices can be used by other machines on the network. This reduces the number of devices throughout the network and provides a centralized location to manage their security. It is often more convenient to install software on multiple machines from a centralized installation media.</p></li></ul></div><div class=paragraph><p>NFS consists of a server and one or more clients. The client remotely accesses the data that is stored on the server machine. In order for this to function properly, a few processes have to be configured and running.</p></div><div class=paragraph><p>These daemons must be running on the server:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Daemon</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nfsd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The NFS daemon which services requests from NFS clients.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>mountd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The NFS mount daemon which carries out requests received from nfsd.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpcbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>This daemon allows NFS clients to discover which port the NFS server is using.</p></td></tr></tbody></table><div class=paragraph><p>Running <a href="https://man.freebsd.org/cgi/man.cgi?query=nfsiod&amp;sektion=8&amp;format=html">nfsiod(8)</a> on the client can improve performance, but is not required.</p></div><div class=sect3><h4 id=network-configuring-nfs>29.3.1. 設定伺服器<a class=anchor href=#network-configuring-nfs></a></h4><div class=paragraph><p>The file systems which the NFS server will share are specified in <span class=filename>/etc/exports</span>. Each line in this file specifies a file system to be exported, which clients have access to that file system, and any access options. When adding entries to this file, each exported file system, its properties, and allowed hosts must occur on a single line. If no clients are listed in the entry, then any client on the network can mount that file system.</p></div><div class=paragraph><p>The following <span class=filename>/etc/exports</span> entries demonstrate how to export file systems. The examples can be modified to match the file systems and client names on the reader’s network. There are many options that can be used in this file, but only a few will be mentioned here. See <a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> for the full list of options.</p></div><div class=paragraph><p>This example shows how to export <span class=filename>/cdrom</span> to three hosts named <em>alpha</em>, <em>bravo</em>, and <em>charlie</em>:</p></div><div class="literalblock programlisting"><div class=content><pre>/cdrom -ro alpha bravo charlie</pre></div></div><div class=paragraph><p>The <code>-ro</code> flag makes the file system read-only, preventing clients from making any changes to the exported file system. This example assumes that the host names are either in DNS or in <span class=filename>/etc/hosts</span>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> if the network does not have a DNS server.</p></div><div class=paragraph><p>The next example exports <span class=filename>/home</span> to three clients by IP address. This can be useful for networks without DNS or <span class=filename>/etc/hosts</span> entries. The <code>-alldirs</code> flag allows subdirectories to be mount points. In other words, it will not automatically mount the subdirectories, but will permit the client to mount the directories that are required as needed.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</pre></div></div><div class=paragraph><p>This next example exports <span class=filename>/a</span> so that two clients from different domains may access that file system. The <code>-maproot=root</code> allows <code>root</code> on the remote system to write data on the exported file system as <code>root</code>. If <code>-maproot=root</code> is not specified, the client’s <code>root</code> user will be mapped to the server’s <code>nobody</code> account and will be subject to the access limitations defined for <code>nobody</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>/a  -maproot=root  host.example.com box.example.org</pre></div></div><div class=paragraph><p>A client can only be specified once per file system. For example, if <span class=filename>/usr</span> is a single file system, these entries would be invalid as both entries specify the same host:</p></div><div class="literalblock programlisting"><div class=content><pre># Invalid when /usr is one file system
/usr/src   client
/usr/ports client</pre></div></div><div class=paragraph><p>The correct format for this situation is to use one entry:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src /usr/ports  client</pre></div></div><div class=paragraph><p>The following is an example of a valid export list, where <span class=filename>/usr</span> and <span class=filename>/exports</span> are local file systems:</p></div><div class="literalblock programlisting"><div class=content><pre># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</pre></div></div><div class=paragraph><p>To enable the processes required by the NFS server at boot time, add these options to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rpcbind_enable=&#34;YES&#34;
nfs_server_enable=&#34;YES&#34;
mountd_flags=&#34;-r&#34;</pre></div></div><div class=paragraph><p>The server can be started now by running this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div><div class=paragraph><p>Whenever the NFS server is started, mountd also starts automatically. However, mountd only reads <span class=filename>/etc/exports</span> when it is started. To make subsequent <span class=filename>/etc/exports</span> edits take effect immediately, force mountd to reread it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service mountd reload</span></code></pre></div></div></div><div class=sect3><h4 id=_設定客戶端>29.3.2. 設定客戶端<a class=anchor href=#_設定客戶端></a></h4><div class=paragraph><p>To enable NFS clients, set this option in each client’s <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nfs_client_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then, run this command on each NFS client:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsclient start</span></code></pre></div></div><div class=paragraph><p>The client now has everything it needs to mount a remote file system. In these examples, the server’s name is <code>server</code> and the client’s name is <code>client</code>. To mount <span class=filename>/home</span> on <code>server</code> to the <span class=filename>/mnt</span> mount point on <code>client</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount server:/home /mnt</span></code></pre></div></div><div class=paragraph><p>The files and directories in <span class=filename>/home</span> will now be available on <code>client</code>, in the <span class=filename>/mnt</span> directory.</p></div><div class=paragraph><p>To mount a remote file system each time the client boots, add it to <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>server:/home	/mnt	nfs	rw	0	0</pre></div></div><div class=paragraph><p>Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> for a description of all available options.</p></div></div><div class=sect3><h4 id=_鎖定>29.3.3. 鎖定<a class=anchor href=#_鎖定></a></h4><div class=paragraph><p>Some applications require file locking to operate correctly. To enable locking, add these lines to <span class=filename>/etc/rc.conf</span> on both the client and server:</p></div><div class="literalblock programlisting"><div class=content><pre>rpc_lockd_enable=&#34;YES&#34;
rpc_statd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then start the applications:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service lockd start</span>
<span class=c># service statd start</span></code></pre></div></div><div class=paragraph><p>If locking is not required on the server, the NFS client can be configured to lock locally by including <code>-L</code> when running mount. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8&amp;format=html">mount_nfs(8)</a> for further details.</p></div></div><div class=sect3><h4 id=network-amd>29.3.4. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> 自動掛載<a class=anchor href=#network-amd></a></h4><div class=paragraph><p>The automatic mounter daemon, amd, automatically mounts a remote file system whenever a file or directory within that file system is accessed. File systems that are inactive for a period of time will be automatically unmounted by amd.</p></div><div class=paragraph><p>This daemon provides an alternative to modifying <span class=filename>/etc/fstab</span> to list every client. It operates by attaching itself as an NFS server to the <span class=filename>/host</span> and <span class=filename>/net</span> directories. When a file is accessed within one of these directories, amd looks up the corresponding remote mount and automatically mounts it. <span class=filename>/net</span> is used to mount an exported file system from an IP address while <span class=filename>/host</span> is used to mount an export from a remote hostname. For instance, an attempt to access a file within <span class=filename>/host/foobar/usr</span> would tell amd to mount the <span class=filename>/usr</span> export on the host <code>foobar</code>.</p></div><div class=exampleblock><div class=title>例 47. 使用 amd 掛載 Export</div><div class=content><div class=paragraph><p>In this example, <code>showmount -e</code> shows the exported file systems that can be mounted from the NFS server, <code>foobar</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% showmount <span class=nt>-e</span> foobar
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
% <span class=nb>cd</span> /host/foobar/usr</code></pre></div></div></div></div><div class=paragraph><p>The output from <code>showmount</code> shows <span class=filename>/usr</span> as an export. When changing directories to <span class=filename>/host/foobar/usr</span>, amd intercepts the request and attempts to resolve the hostname <code>foobar</code>. If successful, amd automatically mounts the desired export.</p></div><div class=paragraph><p>To enable amd at boot time, add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>amd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To start amd now:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service amd start</span></code></pre></div></div><div class=paragraph><p>Custom flags can be passed to amd from the <code>amd_flags</code> environment variable. By default, <code>amd_flags</code> is set to:</p></div><div class="literalblock programlisting"><div class=content><pre>amd_flags=&#34;-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map&#34;</pre></div></div><div class=paragraph><p>The default options with which exports are mounted are defined in <span class=filename>/etc/amd.map</span>. Some of the more advanced features of amd are defined in <span class=filename>/etc/amd.conf</span>.</p></div><div class=paragraph><p>Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=amd.conf&amp;sektion=5&amp;format=html">amd.conf(5)</a> for more information.</p></div></div><div class=sect3><h4 id=network-autofs>29.3.5. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 自動掛載<a class=anchor href=#network-autofs></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> automount facility is supported starting with FreeBSD 10.1-RELEASE. To use the automounter functionality in older versions of FreeBSD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> instead. This chapter only describes the <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> automounter.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> facility is a common name for several components that, together, allow for automatic mounting of remote and local filesystems whenever a file or directory within that file system is accessed. It consists of the kernel component, <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a>, and several userspace applications: <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a>. It serves as an alternative for <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> from previous FreeBSD releases. Amd is still provided for backward compatibility purposes, as the two use different map format; the one used by autofs is the same as with other SVR4 automounters, such as the ones in Solaris, MacOS X, and Linux.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> virtual filesystem is mounted on specified mountpoints by <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a>, usually invoked during boot.</p></div><div class=paragraph><p>Whenever a process attempts to access file within the <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> mountpoint, the kernel will notify <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> daemon and pause the triggering process. The <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> daemon will handle kernel requests by finding the proper map and mounting the filesystem according to it, then signal the kernel to release blocked process. The <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a> daemon automatically unmounts automounted filesystems after some time, unless they are still being used.</p></div><div class=paragraph><p>The primary autofs configuration file is <span class=filename>/etc/auto_master</span>. It assigns individual maps to top-level mounts. For an explanation of <span class=filename>auto_master</span> and the map syntax, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=auto_master&amp;sektion=5&amp;format=html">auto_master(5)</a>.</p></div><div class=paragraph><p>There is a special automounter map mounted on <span class=filename>/net</span>. When a file is accessed within this directory, <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> looks up the corresponding remote mount and automatically mounts it. For instance, an attempt to access a file within <span class=filename>/net/foobar/usr</span> would tell <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> to mount the <span class=filename>/usr</span> export from the host <code>foobar</code>.</p></div><div class=exampleblock><div class=title>例 48. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 掛載 Export</div><div class=content><div class=paragraph><p>In this example, <code>showmount -e</code> shows the exported file systems that can be mounted from the NFS server, <code>foobar</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% showmount <span class=nt>-e</span> foobar
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
% <span class=nb>cd</span> /net/foobar/usr</code></pre></div></div></div></div><div class=paragraph><p>The output from <code>showmount</code> shows <span class=filename>/usr</span> as an export. When changing directories to <span class=filename>/host/foobar/usr</span>, <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> intercepts the request and attempts to resolve the hostname <code>foobar</code>. If successful, <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> automatically mounts the source export.</p></div><div class=paragraph><p>To enable <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> at boot time, add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>autofs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> can be started by running:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount start</span>
<span class=c># service automountd start</span>
<span class=c># service autounmountd start</span></code></pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> map format is the same as in other operating systems. Information about this format from other sources can be useful, like the <a href=http://web.archive.org/web/20160813071113/http://images.apple.com/business/docs/Autofs.pdf>Mac OS X document</a>.</p></div><div class=paragraph><p>Consult the <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=auto_master&amp;sektion=5&amp;format=html">auto_master(5)</a> manual pages for more information.</p></div></div></div><div class=sect2><h3 id=network-nis>29.4. 網路資訊系統 (NIS)<a class=anchor href=#network-nis></a></h3><div class=paragraph><p>Network Information System (NIS) is designed to centralize administration of UNIX™-like systems such as Solaris™, HP-UX, AIX™, Linux, NetBSD, OpenBSD, and FreeBSD. NIS was originally known as Yellow Pages but the name was changed due to trademark issues. This is the reason why NIS commands begin with <code>yp</code>.</p></div><div class=paragraph><p>NIS is a Remote Procedure Call (RPC)-based client/server system that allows a group of machines within an NIS domain to share a common set of configuration files. This permits a system administrator to set up NIS client systems with only minimal configuration data and to add, remove, or modify configuration data from a single location.</p></div><div class=paragraph><p>FreeBSD uses version 2 of the NIS protocol.</p></div><div class=sect3><h4 id=_nis_術語與程序>29.4.1. NIS 術語與程序<a class=anchor href=#_nis_術語與程序></a></h4><div class=paragraph><p>Table 28.1 summarizes the terms and important processes used by NIS:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>表 23. NIS 術語</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">術語</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>NIS domain name</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS servers and clients share an NIS domain name. Typically, this name does not have anything to do with DNS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rpcbind&amp;sektion=8&amp;format=html">rpcbind(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>This service enables RPC and must be running in order to run an NIS server or act as an NIS client.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>This service binds an NIS client to its NIS server. It will take the NIS domain name and use RPC to connect to the server. It is the core of client/server communication in an NIS environment. If this service is not running on a client machine, it will not be able to access the NIS server.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>This is the process for the NIS server. If this service stops running, the server will no longer be able to respond to NIS requests so hopefully, there is a slave server to take over. Some non-FreeBSD clients will not try to reconnect using a slave server and the ypbind process may need to be restarted on these clients.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.yppasswdd&amp;sektion=8&amp;format=html">rpc.yppasswdd(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>This process only runs on NIS master servers. This daemon allows NIS clients to change their NIS passwords. If this daemon is not running, users will have to login to the NIS master server and change their passwords there.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_主機類型>29.4.2. 主機類型<a class=anchor href=#_主機類型></a></h4><div class=paragraph><p>There are three types of hosts in an NIS environment:</p></div><div class=ulist><ul><li><p>NIS master server</p><div class=paragraph><p>This server acts as a central repository for host configuration information and maintains the authoritative copy of the files used by all of the NIS clients. The <span class=filename>passwd</span>, <span class=filename>group</span>, and other various files used by NIS clients are stored on the master server. While it is possible for one machine to be an NIS master server for more than one NIS domain, this type of configuration will not be covered in this chapter as it assumes a relatively small-scale NIS environment.</p></div></li><li><p>NIS slave servers</p><div class=paragraph><p>NIS slave servers maintain copies of the NIS master’s data files in order to provide redundancy. Slave servers also help to balance the load of the master server as NIS clients always attach to the NIS server which responds first.</p></div></li><li><p>NIS clients</p><div class=paragraph><p>NIS clients authenticate against the NIS server during log on.</p></div></li></ul></div><div class=paragraph><p>Information in many files can be shared using NIS. The <span class=filename>master.passwd</span>, <span class=filename>group</span>, and <span class=filename>hosts</span> files are commonly shared via NIS. Whenever a process on a client needs information that would normally be found in these files locally, it makes a query to the NIS server that it is bound to instead.</p></div></div><div class=sect3><h4 id=_規劃注意事項>29.4.3. 規劃注意事項<a class=anchor href=#_規劃注意事項></a></h4><div class=paragraph><p>This section describes a sample NIS environment which consists of 15 FreeBSD machines with no centralized point of administration. Each machine has its own <span class=filename>/etc/passwd</span> and <span class=filename>/etc/master.passwd</span>. These files are kept in sync with each other only through manual intervention. Currently, when a user is added to the lab, the process must be repeated on all 15 machines.</p></div><div class=paragraph><p>The configuration of the lab will be as follows:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Machine name</th><th class="tableblock halign-left valign-top">IP 位址</th><th class="tableblock halign-left valign-top">Machine role</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ellington</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS master</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>coltrane</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.3</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS slave</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>basie</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.4</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Faculty workstation</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bird</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.5</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Client machine</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cli[1-11]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.[6-17]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Other client machines</p></td></tr></tbody></table><div class=paragraph><p>If this is the first time an NIS scheme is being developed, it should be thoroughly planned ahead of time. Regardless of network size, several decisions need to be made as part of the planning process.</p></div><div class=sect4><h5 id=_選擇_nis_網域名稱>29.4.3.1. 選擇 NIS 網域名稱<a class=anchor href=#_選擇_nis_網域名稱></a></h5><div class=paragraph><p>When a client broadcasts its requests for info, it includes the name of the NIS domain that it is part of. This is how multiple servers on one network can tell which server should answer which request. Think of the NIS domain name as the name for a group of hosts.</p></div><div class=paragraph><p>Some organizations choose to use their Internet domain name for their NIS domain name. This is not recommended as it can cause confusion when trying to debug network problems. The NIS domain name should be unique within the network and it is helpful if it describes the group of machines it represents. For example, the Art department at Acme Inc. might be in the "acme-art"NIS domain. This example will use the domain name <code>test-domain</code>.</p></div><div class=paragraph><p>However, some non-FreeBSD operating systems require the NIS domain name to be the same as the Internet domain name. If one or more machines on the network have this restriction, the Internet domain name <em>must</em> be used as the NIS domain name.</p></div></div><div class=sect4><h5 id=_實體伺服器需求>29.4.3.2. 實體伺服器需求<a class=anchor href=#_實體伺服器需求></a></h5><div class=paragraph><p>There are several things to keep in mind when choosing a machine to use as a NIS server. Since NIS clients depend upon the availability of the server, choose a machine that is not rebooted frequently. The NIS server should ideally be a stand alone machine whose sole purpose is to be an NIS server. If the network is not heavily used, it is acceptable to put the NIS server on a machine running other services. However, if the NIS server becomes unavailable, it will adversely affect all NIS clients.</p></div></div></div><div class=sect3><h4 id=_設定_nis_master_伺服器>29.4.4. 設定 NIS Master 伺服器<a class=anchor href=#_設定_nis_master_伺服器></a></h4><div class=paragraph><p>The canonical copies of all NIS files are stored on the master server. The databases used to store the information are called NIS maps. In FreeBSD, these maps are stored in <span class=filename>/var/yp/[domainname]</span> where <span class=filename>[domainname]</span> is the name of the NIS domain. Since multiple domains are supported, it is possible to have several directories, one for each domain. Each domain will have its own independent set of maps.</p></div><div class=paragraph><p>NIS master and slave servers handle all NIS requests through <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a>. This daemon is responsible for receiving incoming requests from NIS clients, translating the requested domain and map name to a path to the corresponding database file, and transmitting data from the database back to the client.</p></div><div class=paragraph><p>Setting up a master NIS server can be relatively straight forward, depending on environmental needs. Since FreeBSD provides built-in NIS support, it only needs to be enabled by adding the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;	<i class=conum data-value=1></i><b>(1)</b>
nis_server_enable=&#34;YES&#34;		<i class=conum data-value=2></i><b>(2)</b>
nis_yppasswdd_enable=&#34;YES&#34;	<i class=conum data-value=3></i><b>(3)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This line sets the NIS domain name to <code>test-domain</code>.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>This automates the start up of the NIS server processes when the system boots.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>This enables the <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.yppasswdd&amp;sektion=8&amp;format=html">rpc.yppasswdd(8)</a> daemon so that users can change their NIS password from a client machine.</td></tr></tbody></table></div><div class=paragraph><p>Care must be taken in a multi-server domain where the server machines are also NIS clients. It is generally a good idea to force the servers to bind to themselves rather than allowing them to broadcast bind requests and possibly become bound to each other. Strange failure modes can result if one server goes down and others are dependent upon it. Eventually, all the clients will time out and attempt to bind to other servers, but the delay involved can be considerable and the failure mode is still present since the servers might bind to each other all over again.</p></div><div class=paragraph><p>A server that is also a client can be forced to bind to a particular server by adding these additional lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nis_client_enable=&#34;YES&#34; # run client stuff as well
nis_client_flags=&#34;-S NIS domain,server&#34;</pre></div></div><div class=paragraph><p>After saving the edits, type <code>/etc/netstart</code> to restart the network and apply the values defined in <span class=filename>/etc/rc.conf</span>. Before initializing the NIS maps, start <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ypserv start</span></code></pre></div></div><div class=sect4><h5 id=_初始化_nis_對應表>29.4.4.1. 初始化 NIS 對應表<a class=anchor href=#_初始化_nis_對應表></a></h5><div class=paragraph><p>NIS maps are generated from the configuration files in <span class=filename>/etc</span> on the NIS master, with one exception: <span class=filename>/etc/master.passwd</span>. This is to prevent the propagation of passwords to all the servers in the NIS domain. Therefore, before the NIS maps are initialized, configure the primary password files:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/master.passwd /var/yp/master.passwd</span>
<span class=c># cd /var/yp</span>
<span class=c># vi master.passwd</span></code></pre></div></div><div class=paragraph><p>It is advisable to remove all entries for system accounts as well as any user accounts that do not need to be propagated to the NIS clients, such as the <code>root</code> and any other administrative accounts.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ensure that the <span class=filename>/var/yp/master.passwd</span> is neither group or world readable by setting its permissions to <code>600</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>After completing this task, initialize the NIS maps. FreeBSD includes the <a href="https://man.freebsd.org/cgi/man.cgi?query=ypinit&amp;sektion=8&amp;format=html">ypinit(8)</a> script to do this. When generating maps for the master server, include <code>-m</code> and specify the NIS domain name:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# ypinit <span class=nt>-m</span> test-domain
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n] n
Ok, please remember to go back and redo manually whatever fails.
If not, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please <span class=k>continue </span>to add any slave servers, one per line. When you are
<span class=k>done </span>with the list, <span class=nb>type </span>a &lt;control D&gt;.
master server   :  ellington
next host to add:  coltrane
next host to add:  ^D
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  <span class=o>[</span>y/n: y] y

<span class=o>[</span>..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</code></pre></div></div><div class=paragraph><p>This will create <span class=filename>/var/yp/Makefile</span> from <span class=filename>/var/yp/Makefile.dist</span>. By default, this file assumes that the environment has a single NIS server with only FreeBSD clients. Since <code>test-domain</code> has a slave server, edit this line in <span class=filename>/var/yp/Makefile</span> so that it begins with a comment (<code>#</code>):</p></div><div class="literalblock programlisting"><div class=content><pre>NOPUSH = &#34;True&#34;</pre></div></div></div><div class=sect4><h5 id=_新增使用者>29.4.4.2. 新增使用者<a class=anchor href=#_新增使用者></a></h5><div class=paragraph><p>Every time a new user is created, the user account must be added to the master NIS server and the NIS maps rebuilt. Until this occurs, the new user will not be able to login anywhere except on the NIS master. For example, to add the new user <code>jsmith</code> to the <code>test-domain</code> domain, run these commands on the master server:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd jsmith</span>
<span class=c># cd /var/yp</span>
<span class=c># make test-domain</span></code></pre></div></div><div class=paragraph><p>The user could also be added using <code>adduser jsmith</code> instead of <code>pw useradd smith</code>.</p></div></div></div><div class=sect3><h4 id=_設定_nis_slave_伺服器>29.4.5. 設定 NIS Slave 伺服器<a class=anchor href=#_設定_nis_slave_伺服器></a></h4><div class=paragraph><p>To set up an NIS slave server, log on to the slave server and edit <span class=filename>/etc/rc.conf</span> as for the master server. Do not generate any NIS maps, as these already exist on the master server. When running <code>ypinit</code> on the slave server, use <code>-s</code> (for slave) instead of <code>-m</code> (for master). This option requires the name of the NIS master in addition to the domain name, as seen in this example:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>coltrane# ypinit <span class=nt>-s</span> ellington test-domain

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If not, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Remember to update map ypservers on ellington.</code></pre></div></div><div class=paragraph><p>This will generate a directory on the slave server called <span class=filename>/var/yp/test-domain</span> which contains copies of the NIS master server’s maps. Adding these <span class=filename>/etc/crontab</span> entries on each slave server will force the slaves to sync their maps with the maps on the master server:</p></div><div class="literalblock programlisting"><div class=content><pre>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</pre></div></div><div class=paragraph><p>These entries are not mandatory because the master server automatically attempts to push any map changes to its slaves. However, since clients may depend upon the slave server to provide correct password information, it is recommended to force frequent password map updates. This is especially important on busy networks where map updates might not always complete.</p></div><div class=paragraph><p>To finish the configuration, run <code>/etc/netstart</code> on the slave server in order to start the NIS services.</p></div></div><div class=sect3><h4 id=_設定_nis_客戶端>29.4.6. 設定 NIS 客戶端<a class=anchor href=#_設定_nis_客戶端></a></h4><div class=paragraph><p>An NIS client binds to an NIS server using <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a>. This daemon broadcasts RPC requests on the local network. These requests specify the domain name configured on the client. If an NIS server in the same domain receives one of the broadcasts, it will respond to ypbind, which will record the server’s address. If there are several servers available, the client will use the address of the first server to respond and will direct all of its NIS requests to that server. The client will automatically ping the server on a regular basis to make sure it is still available. If it fails to receive a reply within a reasonable amount of time, ypbind will mark the domain as unbound and begin broadcasting again in the hopes of locating another server.</p></div><div class=paragraph><p>To configure a FreeBSD machine to be an NIS client:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Edit <span class=filename>/etc/rc.conf</span> and add the following lines in order to set the NIS domain name and start <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a> during network startup:</p><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;
nis_client_enable=&#34;YES&#34;</pre></div></div></li><li><p>To import all possible password entries from the NIS server, use <code>vipw</code> to remove all user accounts except one from <span class=filename>/etc/master.passwd</span>. When removing the accounts, keep in mind that at least one local account should remain and this account should be a member of <code>wheel</code>. If there is a problem with NIS, this local account can be used to log in remotely, become the superuser, and fix the problem. Before saving the edits, add the following line to the end of the file:</p><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class=paragraph><p>This line configures the client to provide anyone with a valid account in the NIS server’s password maps an account on the client. There are many ways to configure the NIS client by modifying this line. One method is described in <a href=#network-netgroups>使用 Netgroups</a>. For more detailed reading, refer to the book <code>Managing NFS and NIS</code>, published by O’Reilly Media.</p></div></li><li><p>To import all possible group entries from the NIS server, add this line to <span class=filename>/etc/group</span>:</p><div class="literalblock programlisting"><div class=content><pre>+:*::</pre></div></div></li></ol></div></div></div><div class=paragraph><p>To start the NIS client immediately, execute the following commands as the superuser:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/netstart</span>
<span class=c># service ypbind start</span></code></pre></div></div><div class=paragraph><p>After completing these steps, running <code>ypcat passwd</code> on the client should show the server’s <span class=filename>passwd</span> map.</p></div></div><div class=sect3><h4 id=_nis_安全性>29.4.7. NIS 安全性<a class=anchor href=#_nis_安全性></a></h4><div class=paragraph><p>Since RPC is a broadcast-based service, any system running ypbind within the same domain can retrieve the contents of the NIS maps. To prevent unauthorized transactions, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> supports a feature called "securenets" which can be used to restrict access to a given set of hosts. By default, this information is stored in <span class=filename>/var/yp/securenets</span>, unless <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> is started with <code>-p</code> and an alternate path. This file contains entries that consist of a network specification and a network mask separated by white space. Lines starting with <code>#</code> are considered to be comments. A sample <span class=filename>securenets</span> might look like this:</p></div><div class="literalblock programlisting"><div class=content><pre># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0</pre></div></div><div class=paragraph><p>If <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> receives a request from an address that matches one of these rules, it will process the request normally. If the address fails to match a rule, the request will be ignored and a warning message will be logged. If the <span class=filename>securenets</span> does not exist, <code>ypserv</code> will allow connections from any host.</p></div><div class=paragraph><p><a href=./#tcpwrappers>TCP Wrapper</a> is an alternate mechanism for providing access control instead of <span class=filename>securenets</span>. While either access control mechanism adds some security, they are both vulnerable to "IP spoofing" attacks. All NIS-related traffic should be blocked at the firewall.</p></div><div class=paragraph><p>Servers using <span class=filename>securenets</span> may fail to serve legitimate NIS clients with archaic TCP/IP implementations. Some of these implementations set all host bits to zero when doing broadcasts or fail to observe the subnet mask when calculating the broadcast address. While some of these problems can be fixed by changing the client configuration, other problems may force the retirement of these client systems or the abandonment of <span class=filename>securenets</span>.</p></div><div class=paragraph><p>The use of TCP Wrapper increases the latency of the NIS server. The additional delay may be long enough to cause timeouts in client programs, especially in busy networks with slow NIS servers. If one or more clients suffer from latency, convert those clients into NIS slave servers and force them to bind to themselves.</p></div><div class=sect4><h5 id=_阻擋部份使用者>29.4.7.1. 阻擋部份使用者<a class=anchor href=#_阻擋部份使用者></a></h5><div class=paragraph><p>In this example, the <code>basie</code> system is a faculty workstation within the NIS domain. The <span class=filename>passwd</span> map on the master NIS server contains accounts for both faculty and students. This section demonstrates how to allow faculty logins on this system while refusing student logins.</p></div><div class=paragraph><p>To prevent specified users from logging on to a system, even if they are present in the NIS database, use <code>vipw</code> to add <code>-<em>username</em></code> with the correct number of colons towards the end of <span class=filename>/etc/master.passwd</span> on the client, where <em>username</em> is the username of a user to bar from logging in. The line with the blocked user must be before the <code>+</code> line that allows NIS users. In this example, <code>bill</code> is barred from logging on to <code>basie</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>basie# <span class=nb>cat</span> /etc/master.passwd
root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:<span class=k>*</span>:1:1::0:0:Owner of many system processes:/root:/usr/sbin/nologin
operator:<span class=k>*</span>:2:5::0:0:System &amp;:/:/usr/sbin/nologin
bin:<span class=k>*</span>:3:7::0:0:Binaries Commands and Source,,,:/:/usr/sbin/nologin
<span class=nb>tty</span>:<span class=k>*</span>:4:65533::0:0:Tty Sandbox:/:/usr/sbin/nologin
kmem:<span class=k>*</span>:5:65533::0:0:KMem Sandbox:/:/usr/sbin/nologin
games:<span class=k>*</span>:7:13::0:0:Games pseudo-user:/usr/games:/usr/sbin/nologin
news:<span class=k>*</span>:8:8::0:0:News Subsystem:/:/usr/sbin/nologin
man:<span class=k>*</span>:9:9::0:0:Mister Man Pages:/usr/shared/man:/usr/sbin/nologin
<span class=nb>bind</span>:<span class=k>*</span>:53:53::0:0:Bind Sandbox:/:/usr/sbin/nologin
uucp:<span class=k>*</span>:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:<span class=k>*</span>:67:67::0:0:X-10 daemon:/usr/local/xten:/usr/sbin/nologin
pop:<span class=k>*</span>:68:6::0:0:Post Office Owner:/nonexistent:/usr/sbin/nologin
nobody:<span class=k>*</span>:65534:65534::0:0:Unprivileged user:/nonexistent:/usr/sbin/nologin
<span class=nt>-bill</span>:::::::::
+:::::::::

basie#</code></pre></div></div></div></div><div class=sect3><h4 id=network-netgroups>29.4.8. 使用 Netgroups<a class=anchor href=#network-netgroups></a></h4><div class=paragraph><p>Barring specified users from logging on to individual systems becomes unscaleable on larger networks and quickly loses the main benefit of NIS: <em>centralized</em> administration.</p></div><div class=paragraph><p>Netgroups were developed to handle large, complex networks with hundreds of users and machines. Their use is comparable to UNIX™ groups, where the main difference is the lack of a numeric ID and the ability to define a netgroup by including both user accounts and other netgroups.</p></div><div class=paragraph><p>To expand on the example used in this chapter, the NIS domain will be extended to add the users and systems shown in Tables 28.2 and 28.3:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>表 24. 其他使用者</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">使用者名稱</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>alpha</code>, <code>beta</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IT department employees</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>charlie</code>, <code>delta</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IT department apprentices</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>echo</code>, <code>foxtrott</code>, <code>golf</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>employees</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>able</code>, <code>baker</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interns</p></td></tr></tbody></table><table class="tableblock frame-none grid-all stretch"><caption class=title>表 25. 其他系統</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">機器名稱</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>war</code>, <code>death</code>, <code>famine</code>, <code>pollution</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Only IT employees are allowed to log onto these servers.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pride</code>, <code>greed</code>, <code>envy</code>, <code>wrath</code>, <code>lust</code>, <code>sloth</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All members of the IT department are allowed to login onto these servers.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>one</code>, <code>two</code>, <code>three</code>, <code>four</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ordinary workstations used by employees.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>trashcan</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A very old machine without any critical data. Even interns are allowed to use this system.</p></td></tr></tbody></table><div class=paragraph><p>When using netgroups to configure this scenario, each user is assigned to one or more netgroups and logins are then allowed or forbidden for all members of the netgroup. When adding a new machine, login restrictions must be defined for all netgroups. When a new user is added, the account must be added to one or more netgroups. If the NIS setup is planned carefully, only one central configuration file needs modification to grant or deny access to machines.</p></div><div class=paragraph><p>The first step is the initialization of the NIS <code>netgroup</code> map. In FreeBSD, this map is not created by default. On the NIS master server, use an editor to create a map named <span class=filename>/var/yp/netgroup</span>.</p></div><div class=paragraph><p>This example creates four netgroups to represent IT employees, IT apprentices, employees, and interns:</p></div><div class="literalblock programlisting"><div class=content><pre>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
        (,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</pre></div></div><div class=paragraph><p>Each entry configures a netgroup. The first column in an entry is the name of the netgroup. Each set of brackets represents either a group of one or more users or the name of another netgroup. When specifying a user, the three comma-delimited fields inside each group represent:</p></div><div class="olist arabic"><ol class=arabic><li><p>The name of the host(s) where the other fields representing the user are valid. If a hostname is not specified, the entry is valid on all hosts.</p></li><li><p>The name of the account that belongs to this netgroup.</p></li><li><p>The NIS domain for the account. Accounts may be imported from other NIS domains into a netgroup.</p></li></ol></div><div class=paragraph><p>If a group contains multiple users, separate each user with whitespace. Additionally, each field may contain wildcards. See <a href="https://man.freebsd.org/cgi/man.cgi?query=netgroup&amp;sektion=5&amp;format=html">netgroup(5)</a> for details.</p></div><div class=paragraph><p>Netgroup names longer than 8 characters should not be used. The names are case sensitive and using capital letters for netgroup names is an easy way to distinguish between user, machine and netgroup names.</p></div><div class=paragraph><p>Some non-FreeBSD NIS clients cannot handle netgroups containing more than 15 entries. This limit may be circumvented by creating several sub-netgroups with 15 users or fewer and a real netgroup consisting of the sub-netgroups, as seen in this example:</p></div><div class="literalblock programlisting"><div class=content><pre>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</pre></div></div><div class=paragraph><p>Repeat this process if more than 225 (15 times 15) users exist within a single netgroup.</p></div><div class=paragraph><p>To activate and distribute the new NIS map:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# <span class=nb>cd</span> /var/yp
ellington# make</code></pre></div></div><div class=paragraph><p>This will generate the three NIS maps <span class=filename>netgroup</span>, <span class=filename>netgroup.byhost</span> and <span class=filename>netgroup.byuser</span>. Use the map key option of <a href="https://man.freebsd.org/cgi/man.cgi?query=ypcat&amp;sektion=1&amp;format=html">ypcat(1)</a> to check if the new NIS maps are available:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington% ypcat <span class=nt>-k</span> netgroup
ellington% ypcat <span class=nt>-k</span> netgroup.byhost
ellington% ypcat <span class=nt>-k</span> netgroup.byuser</code></pre></div></div><div class=paragraph><p>The output of the first command should resemble the contents of <span class=filename>/var/yp/netgroup</span>. The second command only produces output if host-specific netgroups were created. The third command is used to get the list of netgroups for a user.</p></div><div class=paragraph><p>To configure a client, use <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> to specify the name of the netgroup. For example, on the server named <code>war</code>, replace this line:</p></div><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class=paragraph><p>with</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::</pre></div></div><div class=paragraph><p>This specifies that only the users defined in the netgroup <code>IT_EMP</code> will be imported into this system’s password database and only those users are allowed to login to this system.</p></div><div class=paragraph><p>This configuration also applies to the <code>~</code> function of the shell and all routines which convert between user names and numerical user IDs. In other words, <code>cd ~<em>user</em></code> will not work, <code>ls -l</code> will show the numerical ID instead of the username, and <code>find . -user joe -print</code> will fail with the message <code>No such user</code>. To fix this, import all user entries without allowing them to login into the servers. This can be achieved by adding an extra line:</p></div><div class="literalblock programlisting"><div class=content><pre>+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>This line configures the client to import all entries but to replace the shell in those entries with <span class=filename>/usr/sbin/nologin</span>.</p></div><div class=paragraph><p>Make sure that extra line is placed <em>after</em> <code>+@IT_EMP:::::::::</code>. Otherwise, all user accounts imported from NIS will have <span class=filename>/usr/sbin/nologin</span> as their login shell and no one will be able to login to the system.</p></div><div class=paragraph><p>To configure the less important servers, replace the old <code>+:::::::::</code> on the servers with these lines:</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>The corresponding lines for the workstations would be:</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>NIS supports the creation of netgroups from other netgroups which can be useful if the policy regarding user access changes. One possibility is the creation of role-based netgroups. For example, one might create a netgroup called <code>BIGSRV</code> to define the login restrictions for the important servers, another netgroup called <code>SMALLSRV</code> for the less important servers, and a third netgroup called <code>USERBOX</code> for the workstations. Each of these netgroups contains the netgroups that are allowed to login onto these machines. The new entries for the NIS <code>netgroup</code> map would look like this:</p></div><div class="literalblock programlisting"><div class=content><pre>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</pre></div></div><div class=paragraph><p>This method of defining login restrictions works reasonably well when it is possible to define groups of machines with identical restrictions. Unfortunately, this is the exception and not the rule. Most of the time, the ability to define login restrictions on a per-machine basis is required.</p></div><div class=paragraph><p>Machine-specific netgroup definitions are another possibility to deal with the policy changes. In this scenario, the <span class=filename>/etc/master.passwd</span> of each system contains two lines starting with "+". The first line adds a netgroup with the accounts allowed to login onto this machine and the second line adds all other accounts with <span class=filename>/usr/sbin/nologin</span> as shell. It is recommended to use the "ALL-CAPS" version of the hostname as the name of the netgroup:</p></div><div class="literalblock programlisting"><div class=content><pre>+@BOXNAME:::::::::
+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>Once this task is completed on all the machines, there is no longer a need to modify the local versions of <span class=filename>/etc/master.passwd</span> ever again. All further changes can be handled by modifying the NIS map. Here is an example of a possible <code>netgroup</code> map for this scenario:</p></div><div class="literalblock programlisting"><div class=content><pre># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION  BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]</pre></div></div><div class=paragraph><p>It may not always be advisable to use machine-based netgroups. When deploying a couple of dozen or hundreds of systems, role-based netgroups instead of machine-based netgroups may be used to keep the size of the NIS map within reasonable limits.</p></div></div><div class=sect3><h4 id=_密碼格式>29.4.9. 密碼格式<a class=anchor href=#_密碼格式></a></h4><div class=paragraph><p>NIS requires that all hosts within an NIS domain use the same format for encrypting passwords. If users have trouble authenticating on an NIS client, it may be due to a differing password format. In a heterogeneous network, the format must be supported by all operating systems, where DES is the lowest common standard.</p></div><div class=paragraph><p>To check which format a server or client is using, look at this section of <span class=filename>/etc/login.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Further entries elided]</pre></div></div><div class=paragraph><p>In this example, the system is using the DES format. Other possible values are <code>blf</code> for Blowfish and <code>md5</code> for MD5 encrypted passwords.</p></div><div class=paragraph><p>If the format on a host needs to be edited to match the one being used in the NIS domain, the login capability database must be rebuilt after saving the change:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The format of passwords for existing user accounts will not be updated until each user changes their password <em>after</em> the login capability database is rebuilt.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-ldap>29.5. 輕量級目錄存取協定 (LDAP)<a class=anchor href=#network-ldap></a></h3><div class=paragraph><p>輕量級目錄存取協定 (Lightweight Directory Access Protocol, LDAP) 是一個利用分散式目錄資訊服務來做到存取、修改與認証物件的應用層通訊協定，可以想像成是一本可以儲存數個階層、同質資訊的電話簿或記錄簿。它用在 Active Directory 及 OpenLDAP 網路，允許使用者利用一個帳號來存取數個階層的內部資訊，例如：電子郵件認証、取得員工聯絡資訊及內部網站的認証皆可使用 LDAP 伺服器資料庫中的單一使用者帳號來存取。</p></div><div class=paragraph><p>本章節將介紹在 FreeBSD 系統上如何快速的設定一個 LDAP 伺服器。本章節假設管理者已做好規劃，這包含：要儲存何種類型的資訊、這些資訊要來做什麼、那些使用者擁有存取這些資訊的權限以及如何確保這些資訊不會被未經授權存取。</p></div><div class=sect3><h4 id=_ldap_術語與結構>29.5.1. LDAP 術語與結構<a class=anchor href=#_ldap_術語與結構></a></h4><div class=paragraph><p>LDAP 使用了數個術語在開始設置之前必須先了解。所有的目錄項目由一群屬性 (<em>attributes</em>) 所組成，每個屬性集皆有一個獨特的辨識碼稱為辨識名稱 (<em>Distinguished Name</em>, DN)，這個辨識碼會由數個其他的屬性，如：常用或相對辨識名稱 (<em>Relative Distinguished Name</em>, RDN) 所組成，這就像目錄有絕對路徑與相對路徑，可以把 DN 當做絕對路徑，RDN 當做相對路徑。</p></div><div class=paragraph><p>LDAP 項目的例子如下。這個例子會搜尋指定使用者帳號 (<code>uid</code>)、組織單位 (<code>ou</code>) 及組織的項目 (<code>o</code>)：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ldapsearch <span class=nt>-xb</span> <span class=s2>&#34;uid=trhodes,ou=users,o=example.com&#34;</span>
<span class=c># extended LDIF</span>
<span class=c>#</span>
<span class=c># LDAPv3</span>
<span class=c># base &lt;uid=trhodes,ou=users,o=example.com&gt; with scope subtree</span>
<span class=c># filter: (objectclass=*)</span>
<span class=c># requesting: ALL</span>
<span class=c>#</span>

<span class=c># trhodes, users, example.com</span>
dn: <span class=nv>uid</span><span class=o>=</span>trhodes,ou<span class=o>=</span><span class=nb>users</span>,o<span class=o>=</span>example.com
mail: trhodes@example.com
cn: Tom Rhodes
uid: trhodes
telephoneNumber: <span class=o>(</span>123<span class=o>)</span> 456-7890

<span class=c># search result</span>
search: 2
result: 0 Success

<span class=c># numResponses: 2</span>
<span class=c># numEntries: 1</span></code></pre></div></div><div class=paragraph><p>這個範例項目會顯示 <code>dn</code>, <code>mail</code>, <code>cn</code>, <code>uid</code> 以及 <code>telephoneNumber</code> 屬性的數值。而 cn 屬性則是 RDN。</p></div><div class=paragraph><p>更多有關 LDAP 以及其術語的資訊可在 <a href=http://www.openldap.org/doc/admin24/intro.html>http://www.openldap.org/doc/admin24/intro.html</a> 找到。</p></div></div><div class=sect3><h4 id=ldap-config>29.5.2. 設定 LDAP 伺服器<a class=anchor href=#ldap-config></a></h4><div class=paragraph><p>FreeBSD 並未提供內建的 LDAP 伺服器，要開始設定前請先安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/net/openldap-server/>net/openldap-server</a> 套件或 Port：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install openldap-server</span></code></pre></div></div><div class=paragraph><p>在<a href=https://docs.freebsd.org/en/articles/linux-users/#software>套件</a>中已開啟了許多的預設選項，可以透過執行 <code>pkg info openldap-server</code> 來查看已開啟的選項，若有不足的地方 (例如需要開啟 SQL 的支援)，請考慮使用適當的<a href=./#ports-using>方式</a>重新編譯該 Port。</p></div><div class=paragraph><p>安裝程序會建立目錄 <span class=filename>/var/db/openldap-data</span> 來儲存資料，同時需要建立儲存憑證的目錄：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /usr/local/etc/openldap/private</span></code></pre></div></div><div class=paragraph><p>接下來是設定憑証機構 (Certificate authority)。以下指令必須在 <span class=filename>/usr/local/etc/openldap/private</span> 下執行，這很重要是由於檔案權限須要被限制且其他使用者不應有這些檔案的存取權限，更多有關憑証的詳細資訊以及相關的參數可在 <a href=./#openssl>OpenSSL</a> 中找到。要建立憑証授權，需先輸人這個指令並依提示操作：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -days 365 -nodes -new -x509 -keyout ca.key -out ../ca.crt</span></code></pre></div></div><div class=paragraph><p>提示輸入的項目<em>除了</em>通用名稱 (<code>Common Name</code>) 外其他是可以一樣的，這個項目必須使用跟系統主機名稱 <em>不同</em> 的名稱。若這是一個自行簽署的憑証 (Self signed certificate)，則在憑証機構 <code>CA</code> 的前面加上主機名稱。</p></div><div class=paragraph><p>接下來的工作是建立一個伺服器的憑証簽署請求與一個私鑰。請輸入以下指令然後依提示操作：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -days 365 -nodes -new -keyout server.key -out server.csr</span></code></pre></div></div><div class=paragraph><p>在憑証產生程序的過程中請確認 <code>Common Name</code> 屬性設定正確。憑証簽署請求 (Certificate Signing Request) 必須經過憑証機構簽署後才會成為有效的憑証：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl x509 -req -days 365 -in server.csr -out ../server.crt -CA ../ca.crt -CAkey ca.key -CAcreateserial</span></code></pre></div></div><div class=paragraph><p>在憑証產生程序的最後一步是產生並簽署客戶端憑証：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -days 365 -nodes -new -keyout client.key -out client.csr</span>
<span class=c># openssl x509 -req -days 3650 -in client.csr -out ../client.crt -CA ../ca.crt -CAkey ca.key</span></code></pre></div></div><div class=paragraph><p>記得當提示時要使用同樣的 <code>Common Name</code> 屬性。完成之後，請確認執行的指令產生了 8 個新檔案。</p></div><div class=paragraph><p>OpenLDAP 伺服器所執行的 Daemon 為 <span class=filename>slapd</span>，OpenLDAP 是透過 <span class=filename>slapd.ldif</span> 來做設定， OpenLDAP 官方已停止採用舊的 <span class=filename>slapd.conf</span> 格式。</p></div><div class=paragraph><p>這裡有些 <span class=filename>slapd.ldif</span> 的 <a href=http://www.openldap.org/doc/admin24/slapdconf2.html>設定檔範例</a> 可以使用，同時您也可以在 <span class=filename>/usr/local/etc/openldap/slapd.ldif.sample</span> 找到範例資訊。相關可用的選項在 slapd-config(5) 文件會有說明。<span class=filename>slapd.ldif</span> 的每個段落，如同其他 LDAP 屬性設定一樣會透過獨一無二 DN 來辨識，並請確保 <code>dn:</code> 描述與其相關屬性之間沒有空行。以下的範例中會實作一個使用 TLS 的安全通道，首先是全域的設定：</p></div><div class="literalblock programlisting"><div class=content><pre>#
# See slapd-config(5) for details on configuration options.
# This file should NOT be world readable.
#
dn: cn=config
objectClass: olcGlobal
cn: config
#
#
# Define global ACLs to disable default read access.
#
olcArgsFile: /var/run/openldap/slapd.args
olcPidFile: /var/run/openldap/slapd.pid
olcTLSCertificateFile: /usr/local/etc/openldap/server.crt
olcTLSCertificateKeyFile: /usr/local/etc/openldap/private/server.key
olcTLSCACertificateFile: /usr/local/etc/openldap/ca.crt
#olcTLSCipherSuite: HIGH
olcTLSProtocolMin: 3.1
olcTLSVerifyClient: never</pre></div></div><div class=paragraph><p>這個檔案中必須指定憑証機構 (Certificate Authority)、伺服器憑証 (Server Certificate) 與伺服器私鑰 (Server Private Key)，建議可讓客戶端決定使用的安全密碼 (Security Cipher)，略過 <code>olcTLSCipherSuite</code> 選項 (此選項不相容 <span class=filename>openssl</span> 以外的 TLS 客戶端)。選項 <code>olcTLSProtocolMin</code> 讓伺服器可要求一個安全等級的最低限度，建議使用。伺服器有進行驗証的必要，但客戶端並不需要，因此可設定 <code>olcTLSVerifyClient: never</code>。</p></div><div class=paragraph><p>第二個部份是設定後端要採用的模組有那些，可使用以下方式設定：</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Load dynamic backend modules:
#
dn: cn=module,cn=config
objectClass: olcModuleList
cn: module
olcModulepath:	/usr/local/libexec/openldap
olcModuleload:	back_mdb.la
#olcModuleload:	back_bdb.la
#olcModuleload:	back_hdb.la
#olcModuleload:	back_ldap.la
#olcModuleload:	back_passwd.la
#olcModuleload:	back_shell.la</pre></div></div><div class=paragraph><p>第三個部份要載入資料庫所需的 <code>ldif</code> 綱要 (Schema)，這個動作是必要的。</p></div><div class="literalblock programlisting"><div class=content><pre>dn: cn=schema,cn=config
objectClass: olcSchemaConfig
cn: schema

include: file:///usr/local/etc/openldap/schema/core.ldif
include: file:///usr/local/etc/openldap/schema/cosine.ldif
include: file:///usr/local/etc/openldap/schema/inetorgperson.ldif
include: file:///usr/local/etc/openldap/schema/nis.ldif</pre></div></div><div class=paragraph><p>接下來是前端設定的部份：</p></div><div class="literalblock programlisting"><div class=content><pre># Frontend settings
#
dn: olcDatabase={-1}frontend,cn=config
objectClass: olcDatabaseConfig
objectClass: olcFrontendConfig
olcDatabase: {-1}frontend
olcAccess: to * by * read
#
# Sample global access control policy:
#	Root DSE: allow anyone to read it
#	Subschema (sub)entry DSE: allow anyone to read it
#	Other DSEs:
#		Allow self write access
#		Allow authenticated users read access
#		Allow anonymous users to authenticate
#
#olcAccess: to dn.base=&#34;&#34; by * read
#olcAccess: to dn.base=&#34;cn=Subschema&#34; by * read
#olcAccess: to *
#	by self write
#	by users read
#	by anonymous auth
#
# if no access controls are present, the default policy
# allows anyone and everyone to read anything but restricts
# updates to rootdn.  (e.g., &#34;access to * by * read&#34;)
#
# rootdn can always read and write EVERYTHING!
#
olcPasswordHash: {SSHA}
# {SSHA} is already the default for olcPasswordHash</pre></div></div><div class=paragraph><p>再來是<em>設定後端</em>的部份，之後唯一能夠存取 OpenLDAP 伺服器設定的方式是使用全域超級使用者。</p></div><div class="literalblock programlisting"><div class=content><pre>dn: olcDatabase={0}config,cn=config
objectClass: olcDatabaseConfig
olcDatabase: {0}config
olcAccess: to * by * none
olcRootPW: {SSHA}iae+lrQZILpiUdf16Z9KmDmSwT77Dj4U</pre></div></div><div class=paragraph><p>預設的管理者使用者名稱是 <code>cn=config</code>，可在 Shell 中輸入 <span class=filename>slappasswd</span>，決定要使用的密碼並將其產生的編碼放到 <code>olcRootPW</code> 欄位中。若這個選項在這時沒有設定好，在匯入 <span class=filename>slapd.ldif</span> 之後將沒有任何人有辦法修改<em>全域的設定</em>。</p></div><div class=paragraph><p>最後一個部份是有關資料庫後端的設定：</p></div><div class="literalblock programlisting"><div class=content><pre>#######################################################################
# LMDB database definitions
#######################################################################
#
dn: olcDatabase=mdb,cn=config
objectClass: olcDatabaseConfig
objectClass: olcMdbConfig
olcDatabase: mdb
olcDbMaxSize: 1073741824
olcSuffix: dc=domain,dc=example
olcRootDN: cn=mdbadmin,dc=domain,dc=example
# Cleartext passwords, especially for the rootdn, should
# be avoided.  See slappasswd(8) and slapd-config(5) for details.
# Use of strong authentication encouraged.
olcRootPW: {SSHA}X2wHvIWDk6G76CQyCMS1vDCvtICWgn0+
# The database directory MUST exist prior to running slapd AND
# should only be accessible by the slapd and slap tools.
# Mode 700 recommended.
olcDbDirectory:	/var/db/openldap-data
# Indices to maintain
olcDbIndex: objectClass eq</pre></div></div><div class=paragraph><p>這裡指定的資料庫即<em>實際用來保存</em>LDAP 目錄的資料，也可以使用 <code>mdb</code> 以外的項目，資料庫的超級使用者可在這裡設定 (與全域的超級使用者是不同的東西)：<code>olcRootDN</code>　需填寫使用者名稱 (可自訂)，<code>olcRootPW</code> 需填寫該使用者編碼後的密碼，將密碼編碼可使用 <span class=filename>slappasswd</span> 如同前面所述。</p></div><div class=paragraph><p>這裡有個<a href="http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=tree;f=tests/data/regressions/its8444;h=8a5e808e63b0de3d2bdaf2cf34fecca8577ca7fd;hb=HEAD">檔案庫</a>內有四個 <span class=filename>slapd.ldif</span> 的範例，要將現有的 <span class=filename>slapd.conf</span> 轉換成 <span class=filename>slapd.ldif</span> 格式，可參考<a href=http://www.openldap.org/doc/admin24/slapdconf2.html>此頁</a> (注意，這裡面的說明也會介紹一些不常用的選項)。</p></div><div class=paragraph><p>當設定完成之後，需將 <span class=filename>slapd.ldif</span> 放在一個空的目錄當中，建議如以下方式建立：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /usr/local/etc/openldap/slapd.d/</span></code></pre></div></div><div class=paragraph><p>匯入設定資料庫：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/slapadd -n0 -F /usr/local/etc/openldap/slapd.d/ -l /usr/local/etc/openldap/slapd.ldif</span></code></pre></div></div><div class=paragraph><p>啟動 <span class=filename>slapd</span> Daemon：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/libexec/slapd -F /usr/local/etc/openldap/slapd.d/</span></code></pre></div></div><div class=paragraph><p>選項 <code>-d</code> 可以用來除錯使用，如同 slapd(8) 中所說明的，若要檢驗伺服器是否正常執行與運作可以：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ldapsearch -x -b &#39;&#39; -s base &#39;(objectclass=*)&#39; namingContexts</span>
<span class=c># extended LDIF</span>
<span class=c>#</span>
<span class=c># LDAPv3</span>
<span class=c># base &lt;&gt; with scope baseObject</span>
<span class=c># filter: (objectclass=*)</span>
<span class=c># requesting: namingContexts</span>
<span class=c>#</span>

<span class=c>#</span>
dn:
namingContexts: <span class=nv>dc</span><span class=o>=</span>domain,dc<span class=o>=</span>example

<span class=c># search result</span>
search: 2
result: 0 Success

<span class=c># numResponses: 2</span>
<span class=c># numEntries: 1</span></code></pre></div></div><div class=paragraph><p>伺服器端仍必須受到信任，若在此之前未做過這個動作，請依照以下指示操作。安裝 OpenSSL 套件或 Port：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install openssl</span></code></pre></div></div><div class=paragraph><p>進入 <span class=filename>ca.crt</span> 所在的目錄 (以這邊使用的例子來說則是 <span class=filename>/usr/local/etc/openldap</span>)，執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># c_rehash .</span></code></pre></div></div><div class=paragraph><p>現在 CA 與伺服器憑証可以依其用途被辨識，可進入 <span class=filename>server.crt</span> 所在的目錄執行以下指令來檢查：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl verify -verbose -CApath . server.crt</span></code></pre></div></div><div class=paragraph><p>若 <span class=filename>slapd</span> 已正在執行，就重新啟動它。如同 <span class=filename>/usr/local/etc/rc.d/slapd</span> 所述，要讓 <span class=filename>slapd</span> 開機時可正常執行，須要加入以下行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>lapd_enable=&#34;YES&#34;
slapd_flags=&#39;-h &#34;ldapi://%2fvar%2frun%2fopenldap%2fldapi/
ldap://0.0.0.0/&#34;&#39;
slapd_sockets=&#34;/var/run/openldap/ldapi&#34;
slapd_cn_config=&#34;YES&#34;</pre></div></div><div class=paragraph><p>開機啟動 <span class=filename>slapd</span> 並不會提供除錯的功能，您可以檢查 <span class=filename>/var/log/debug.log</span>, <span class=filename>dmesg -a</span> 及 <span class=filename>/var/log/messages</span> 檢確認是否有正常運作。</p></div><div class=paragraph><p>以下範例會新增群組 <code>team</code> 及使用者 <code>john</code> 到 <code>domain.example</code> LDAP 資料庫，而該資料庫目前是空的。首先要先建立 <span class=filename>domain.ldif</span> 檔：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat domain.ldif</span>
dn: <span class=nv>dc</span><span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: dcObject
objectClass: organization
o: domain.example
dc: domain

dn: <span class=nv>ou</span><span class=o>=</span><span class=nb>groups</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: organizationalunit
ou: <span class=nb>groups

</span>dn: <span class=nv>ou</span><span class=o>=</span><span class=nb>users</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: organizationalunit
ou: <span class=nb>users

</span>dn: <span class=nv>cn</span><span class=o>=</span>team,ou<span class=o>=</span><span class=nb>groups</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: posixGroup
cn: team
gidNumber: 10001

dn: <span class=nv>uid</span><span class=o>=</span>john,ou<span class=o>=</span><span class=nb>users</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: account
objectClass: posixAccount
objectClass: shadowAccount
cn: John McUser
uid: john
uidNumber: 10001
gidNumber: 10001
homeDirectory: /home/john/
loginShell: /usr/bin/bash
userPassword: secret</code></pre></div></div><div class=paragraph><p>請查看 OpenLDAP 說明文件取得更詳細的資訊，使用 <span class=filename>slappasswd</span> 來將純文字的密碼 <code>secret</code> 更改為已編碼的型式來填寫 <code>userPassword</code> 欄位。在 <code>loginShell</code> 所指定的路徑，必須在所有可讓 <code>john</code> 登入的系統中存在。最後是使用 <code>mdb</code> 管理者修改資料庫：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ldapadd -W -D &#34;cn=mdbadmin,dc=domain,dc=example&#34; -f domain.ldif</span></code></pre></div></div><div class=paragraph><p>要修改<em>全域設定</em>只能使用全域的超及使用者。例如，假設一開始採用了 <code>olcTLSCipherSuite: HIGH:MEDIUM:SSLv3</code> 選項，但最後想要把它移除，可以建立一個有以下內容的檔案：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat global_mod</span>
dn: <span class=nv>cn</span><span class=o>=</span>config
changetype: modify
delete: olcTLSCipherSuite</code></pre></div></div><div class=paragraph><p>然後套用修改內容：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ldapmodify -f global_mod -x -D &#34;cn=config&#34; -W</span></code></pre></div></div><div class=paragraph><p>當提示輸入密碼時，提供當時在<em>設定後端</em>一節所設定的密碼，在這裡無須填寫使用者名稱，<code>cn=config</code> 代表要修改資料庫資料的位置。也可以使用 <code>ldapmodify</code> 刪除其中一行屬性，或是 <code>ldapdelete</code> 刪除整筆資料。</p></div><div class=paragraph><p>若有問題無法正常執行，或是全域的超級使用者無法存取後端的設定，可以刪除並重建整個後端設定：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm -rf /usr/local/etc/openldap/slapd.d/</span></code></pre></div></div><div class=paragraph><p>可以修改 <span class=filename>slapd.ldif</span> 後再重新匯入一次。請注意，這個步驟只在沒有其他方式可用時才使用。</p></div><div class=paragraph><p>本章節的設定說明只針對伺服器端的部份，在同一台主機中也可以同時有安裝 LDAP 客戶端但需要額外做設定。</p></div></div></div><div class=sect2><h3 id=network-dhcp>29.6. 動態主機設置協定 (DHCP)<a class=anchor href=#network-dhcp></a></h3><div class=paragraph><p>動態主機設置協定 (Dynamic Host Configuration Protocol, DHCP) 可分配必要的位置資訊給一個連線到網路的系統以在該網路通訊。FreeBSD 內含 OpenBSD 版本的 <code>dhclient</code>，可用來做為客戶端來取得位置資訊。FreeBSD 預設並不會安裝 DHCP 伺服器，但在 FreeBSD Port 套件集中有許多可用的伺服器。有關 DHCP 通訊協定的完整說明位於 <a href=http://www.freesoft.org/CIE/RFC/2131/>RFC 2131</a>，相關資源也可至 <a href=http://www.isc.org/downloads/dhcp/>isc.org/downloads/dhcp/</a> 取得。</p></div><div class=paragraph><p>本節將介紹如何使用內建的 DHCP 客戶端，接著會介紹如何安裝並設定一個 DHCP 伺服器。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>在 FreeBSD 中，<a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> 裝置同時會被 DHCP 伺服器與 DHCP 客戶端所使用。這個裝置會在 <span class=filename>GENERIC</span> 核心中被引用並隨著 FreeBSD 安裝。想要建立自訂核心的使用者若要使用 DHCP 則須保留這個裝置。</p></div><div class=paragraph><p>另外要注意 <span class=filename>bpf</span> 也會讓有權限的使用者在該系統上可執行網路封包監聽程式。</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_設定_dhcp_客戶端>29.6.1. 設定 DHCP 客戶端<a class=anchor href=#_設定_dhcp_客戶端></a></h4><div class=paragraph><p>DHCP 客戶端內含在 FreeBSD 安裝程式當中，這讓在新安裝的系統上設定自動從 DHCP 伺服器接收網路位置資訊變的更簡單。請參考 <a href=./#bsdinstall-post>安裝後注意事項</a> 取得網路設置的範例。</p></div><div class=paragraph><p>當 <code>dhclient</code> 在客戶端機器上執行時，它便會開始廣播請求取得設置資訊。預設這些請求會使用 UDP 埠號 68。而伺服器則會在 UDP 埠號 67 來回覆，將 IP 位址與其他相關的網路資訊，如：子網路遮罩、預設閘道及 DNS 伺服器位址告訴客戶端，詳細的清單可在 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a> 找到。</p></div><div class=paragraph><p>預設當 FreeBSD 系統開機時，其 DHCP 客戶端會在背景執行或稱非同步 (<em>Asynchronously</em>) 執行，在完成 DHCP 程序的同時其他啟動 Script 會繼續執行，來加速系統啟動。</p></div><div class=paragraph><p>背景 DHCP 在 DHCP 伺服器可以快速的回應客戶端請求時可運作的很好。然而 DHCP 在某些系統可能需要較長的時間才能完成，若網路服務嘗試在 DHCP 尚未分配網路位置資訊前執行則會失敗。使用同步 (<em>Synchronous</em>) 模式執行 DHCP 可避免這個問題，因為同步模式會暫停啟動直到 DHCP 已設置完成。</p></div><div class=paragraph><p>在 <span class=filename>/etc/rc.conf</span> 中的這行用來設定採用背景 (非同步模式)：</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>若系統已經在安裝時設定使用 DHCP，這行可能會已存在。替換在例子中的 <em>fxp0</em> 為實際要動態設置的網路介面名稱，如 <a href=./#config-network-setup>設定網路介面卡</a> 中的說明。</p></div><div class=paragraph><p>要改設定系統採用同步模式，在啟動時暫停等候 DHCP 完成，使用 “SYNCDHCP”：</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;SYNCDHCP&#34;</pre></div></div><div class=paragraph><p>尚有其他可用的客戶端選項，請在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 搜尋 <code>dhclient</code> 來取得詳細資訊。</p></div><div class=paragraph><p>DHCP 客戶端會使用到以下檔案：</p></div><div class=ulist><ul><li><p><span class=filename>/etc/dhclient.conf</span></p><div class=paragraph><p><code>dhclient</code> 用到的設定檔。通常這個檔案只會有註解，因為預設便適用大多數客戶端。這個設定檔在 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a> 中有說明。</p></div></li><li><p><span class=filename>/sbin/dhclient</span></p><div class=paragraph><p>有關指令本身的更多資訊可於 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 找到。</p></div></li><li><p><span class=filename>/sbin/dhclient-script</span></p><div class=paragraph><p>FreeBSD 特定的 DHCP 客戶端設定 Script。在 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient-script&amp;sektion=8&amp;format=html">dhclient-script(8)</a> 中有說明，但應不須做任何修改便可正常運作。</p></div></li><li><p><span class=filename>/var/db/dhclient.leases.interface</span></p><div class=paragraph><p>DHCP 客戶端會在這個檔案中儲存有效租約的資料，寫入的格式類似日誌，在 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.leases&amp;sektion=5&amp;format=html">dhclient.leases(5)</a> 有說明。</p></div></li></ul></div></div><div class=sect3><h4 id=network-dhcp-server>29.6.2. 安裝並設定 DHCP 伺服器<a class=anchor href=#network-dhcp-server></a></h4><div class=paragraph><p>本節將示範如何設定 FreeBSD 系統成為 DHCP 伺服器，使用 Internet Systems Consortium (ISC) 所實作的 DHCP 伺服器，這個伺服器及其文件可使用 <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a> 套件或 Port 安裝。</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a> 的安裝程式會安裝一份範例設定檔，複製 <span class=filename>/usr/local/etc/dhcpd.conf.example</span> 到 <span class=filename>/usr/local/etc/dhcpd.conf</span> 並在這個新檔案做編輯。</p></div><div class=paragraph><p>這個設定檔內容包括了子網路及主機的宣告，用來定義要提供給 DHCP 客戶端的資訊。如以下行設定：</p></div><div class="literalblock programlisting"><div class=content><pre>option domain-name &#34;example.org&#34;;<i class=conum data-value=1></i><b>(1)</b>
option domain-name-servers ns1.example.org;<i class=conum data-value=2></i><b>(2)</b>
option subnet-mask 255.255.255.0;<i class=conum data-value=3></i><b>(3)</b>

default-lease-time 600;<i class=conum data-value=4></i><b>(4)</b>
max-lease-time 72400;<i class=conum data-value=5></i><b>(5)</b>
ddns-update-style none;<i class=conum data-value=6></i><b>(6)</b>

subnet 10.254.239.0 netmask 255.255.255.224 {
  range 10.254.239.10 10.254.239.20;<i class=conum data-value=7></i><b>(7)</b>
  option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;<i class=conum data-value=8></i><b>(8)</b>
}

host fantasia {
  hardware ethernet 08:00:07:26:c0:a5;<i class=conum data-value=9></i><b>(9)</b>
  fixed-address fantasia.fugue.com;<i class=conum data-value=10></i><b>(10)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>這個選項指定了要提供給客戶端的預設搜尋網域。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> 取得更多資訊。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>這個選項指定了客戶端應使用的 DNS 伺服器清單 (以逗號分隔)。如範例中所示，可使用伺服器的完整網域名稱 (Fully Qualified Domain Names, FQDN) 或伺服器的 IP
位址。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>要提供給客戶端的子網路遮罩。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>預設租約到期時間 (秒)。客戶端可以自行設定覆蓋這個數值。</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>一個租約最多允許的時間長度 (秒)。若客戶端請求更長的租約，仍會發出租約，但最多只會在 <code>max-lease-time</code> 內有效。</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>預設的 <code>none</code> 會關閉動態 DNS 更新。更改此值為 <code>interim</code> 可讓 DHCP 伺服器每當發出一個租約便通知 DNS 伺服器更新，如此一來 DNS 伺服器便知道網路中該電腦的 IP 位址。不要更改此預設值，除非 DNS 伺服器已設定為支援動態 DNS。</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>此行會建立一個可用 IP 位址的儲存池來保留這些要分配給 DHCP 客戶端的位址。位址範圍必須在前一行所指定的網路或子網路中有效。</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>宣告在開始的 <code>{</code> 括號之前所指定的網路或子網路中有效的預設通訊閘。</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>指定客戶端的硬體 MAC 位址，好讓 DHCP 伺服器在客戶端發出請求時可以辨識客戶端。</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>指定這個主機應分配相同的 IP 位址。在此處用主機名稱是正確的，由於 DHCP 伺服器會在回傳租約資訊前先解析主機名稱。</td></tr></tbody></table></div><div class=paragraph><p>此設定檔還支援其他選項，請參考隨伺服器一併安裝的 dhcpd.conf(5) 來取得詳細資訊與範例。</p></div><div class=paragraph><p>完成 <span class=filename>dhcpd.conf</span> 的設定之後，在 <span class=filename>/etc/rc.conf</span> 啟動 DHCP 伺服器：</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;
dhcpd_ifaces=&#34;dc0&#34;</pre></div></div><div class=paragraph><p>替換 <code>dc0</code> 為 DHCP 伺服器要傾聽 DHCP 客戶端請求的網路介面 (多個介面可以空白分隔)。</p></div><div class=paragraph><p>執行以下指令來啟動伺服器：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div><div class=paragraph><p>往後任何對伺服器設定的變更會需要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> 中止 dhcpd 服務然後啟動。</p></div><div class=paragraph><p>DHCP 伺服器會使用到以下檔案。注意，操作手冊會與伺服器軟體一同安裝。</p></div><div class=ulist><ul><li><p><span class=filename>/usr/local/sbin/dhcpd</span></p><div class=paragraph><p>更多有關 dhcpd 伺服器的資訊可在 dhcpd(8) 找到。</p></div></li><li><p><span class=filename>/usr/local/etc/dhcpd.conf</span></p><div class=paragraph><p>伺服器設定檔需要含有所有要提供給客戶端的資訊以及有關伺服器運作的資訊。在 dhcpd.conf(5) 有此設定檔的說明。</p></div></li><li><p><span class=filename>/var/db/dhcpd.leases</span></p><div class=paragraph><p>DHCP 伺服器會儲存一份已發出租約的資料於這個檔案，寫入的格式類似日誌。參考 dhcpd.leases(5) 會有更完整的說明。</p></div></li><li><p><span class=filename>/usr/local/sbin/dhcrelay</span></p><div class=paragraph><p>這個 Daemon 會用在更進階的環境中，在一個 DHCP 伺服器要轉發來自客戶端的請求到另一個網路的另一個 DHCP 伺服器的環境。若需要使用此功能，請安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-relay/>net/isc-dhcp44-relay</a> 套件或 Port，安裝會包含 dhcrelay(8)，裡面有提供更詳細的資訊。</p></div></li></ul></div></div></div><div class=sect2><h3 id=network-dns>29.7. 網域名稱系統 (DNS)<a class=anchor href=#network-dns></a></h3><div class=paragraph><p>網域名稱系統 (Domain Name System, DNS) 是一種協定用來轉換網域名稱為 IP 位址，反之亦然。DNS 會協調網際網路上有權的根節點 (Authoritative root)、最上層網域 (Top Level Domain, TLD) 及其他小規模名稱伺服器來取得結果，而這些伺服器可管理與快取個自的網域資訊。要在系統上做 DNS 查詢並不需要架設一個名稱伺服器。</p></div><div class=paragraph><p>以下表格會說明一些與 DNS 有關的術語：</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>表 26. DNS 術語</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">術語</th><th class="tableblock halign-left valign-top">定義</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>正向 DNS (Forward DNS)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>將主機名稱對應 IP 位址的動作。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>源頭 (Origin)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>代表某個轄區檔案中所涵蓋的網域。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>解析器 (Resolver)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>主機向名稱伺服器查詢轄區資訊的系統程序。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>反向 DNS (Reverse DNS)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>將 IP 對應主機名稱的動作。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>根轄區 (Root zone)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>網際網路轄區階層的最開始，所有的轄區會在根轄區之下，類似在檔案系統中所有的檔案會在根目錄底下。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>轄區 (Zone)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>獨立的網域、子網域或或由相同授權 (Authority) 管理的部分 DNS。</p></td></tr></tbody></table><div class=paragraph><p>轄區範例：</p></div><div class=ulist><ul><li><p><code>.</code> 是一般在文件中表達根轄區的方式。</p></li><li><p><code>org.</code> 是一個在根轄區底下的最上層網域 (Top Level Domain , TLD)。</p></li><li><p><code>example.org.</code> 是一個在 <code>org.</code> TLD 底下的轄區。</p></li><li><p><code>1.168.192.in-addr.arpa</code> 是一個轄區用來代表所有在 <code>192.168.1.*</code> IP 位址空間底下的 IP 位址。</p></li></ul></div><div class=paragraph><p>如您所見，更詳細的主機名稱會加在左方，例如 <code>example.org.</code> 比 <code>org.</code> 更具體，如同 <code>org.</code> 比根轄區更具體，主機名稱每一部份的架構很像檔案系統：<span class=filename>/dev</span> 目錄在根目錄底下，以此類推。</p></div><div class=sect3><h4 id=_要架設名稱伺服器的原因>29.7.1. 要架設名稱伺服器的原因<a class=anchor href=#_要架設名稱伺服器的原因></a></h4><div class=paragraph><p>名稱伺服器通常有兩種形式：有權的 (Authoritative) 名稱伺服器與快取 (或稱解析) 名稱伺服器。</p></div><div class=paragraph><p>以下情況會需要一台有權的名稱伺服器：</p></div><div class=ulist><ul><li><p>想要提供 DNS 資訊給全世界，做為官方回覆查詢。</p></li><li><p>已經註冊了一個網域，例如 <code>example.org</code>，且要將 IP 位址分配到主機名稱下。</p></li><li><p>一段 IP 位址範圍需要反向 DNS 項目 (IP 轉主機名稱)。</p></li><li><p>要有一台備援或次要名稱伺服器用來回覆查詢。</p></li></ul></div><div class=paragraph><p>以下情況會需要一台快取名稱伺服器：</p></div><div class=ulist><ul><li><p>比起查詢外部的名稱伺服器本地 DNS 伺服器可以快取並更快的回應。</p></li></ul></div><div class=paragraph><p>當查詢 <code>www.FreeBSD.org</code> 時，解析程式通常會查詢上游 ISP 的名稱伺服器然後接收其回覆，使用本地、快取 DNS 伺服器，只需要由快取 DNS 伺服器對外部做一次查詢，其他的查詢則不需要再向區域網路之外查詢，因為這些資訊已經在本地被快取了。</p></div></div><div class=sect3><h4 id=_dns_伺服器設定>29.7.2. DNS 伺服器設定<a class=anchor href=#_dns_伺服器設定></a></h4><div class=paragraph><p>Unbound 由 FreeBSD 基礎系統提供，預設只會提供本機的 DNS 解析，雖然基礎系統的套件可被設定提供本機以外的解析服務，但要解決這樣的需求仍建議安裝 FreeBSD Port 套件集中的 Unbound。</p></div><div class=paragraph><p>要開啟 Unbound 可加入下行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>local_unbound_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>任何已存在於 <span class=filename>/etc/resolv.conf</span> 中的名稱伺服器會在新的 Unbound 設定中被設為追隨者 (Forwarder)。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若任一個列在清單中的名稱伺服器不支援 DNSSEC，則本地的 DNS 解析便會失敗，請確認有測試每一台名稱伺服器並移除所有測試失敗的項目。以下指令會顯示出信認樹或在 <code>192.168.1.1</code> 上執行失敗的名稱伺服器：</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% drill <span class=nt>-S</span> FreeBSD.org @192.168.1.1</code></pre></div></div><div class=paragraph><p>確認完每一台名稱伺服器都支援 DNSSEC 後啟動 Unbound：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service local_unbound onestart</span></code></pre></div></div><div class=paragraph><p>這將會更新 <span class=filename>/etc/resolv.conf</span> 來讓查詢已用 DNSSEC 確保安全的網域現在可以運作，例如，執行以下指令來檢驗 FreeBSD.org DNSSEC 信任樹：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% drill <span class=nt>-S</span> FreeBSD.org
<span class=p>;;</span> Number of trusted keys: 1
<span class=p>;;</span> Chasing: freebsd.org. A

DNSSEC Trust tree:
freebsd.org. <span class=o>(</span>A<span class=o>)</span>
|---freebsd.org. <span class=o>(</span>DNSKEY keytag: 36786 alg: 8 flags: 256<span class=o>)</span>
    |---freebsd.org. <span class=o>(</span>DNSKEY keytag: 32659 alg: 8 flags: 257<span class=o>)</span>
    |---freebsd.org. <span class=o>(</span>DS keytag: 32659 digest <span class=nb>type</span>: 2<span class=o>)</span>
        |---org. <span class=o>(</span>DNSKEY keytag: 49587 alg: 7 flags: 256<span class=o>)</span>
            |---org. <span class=o>(</span>DNSKEY keytag: 9795 alg: 7 flags: 257<span class=o>)</span>
            |---org. <span class=o>(</span>DNSKEY keytag: 21366 alg: 7 flags: 257<span class=o>)</span>
            |---org. <span class=o>(</span>DS keytag: 21366 digest <span class=nb>type</span>: 1<span class=o>)</span>
            |   |---. <span class=o>(</span>DNSKEY keytag: 40926 alg: 8 flags: 256<span class=o>)</span>
            |       |---. <span class=o>(</span>DNSKEY keytag: 19036 alg: 8 flags: 257<span class=o>)</span>
            |---org. <span class=o>(</span>DS keytag: 21366 digest <span class=nb>type</span>: 2<span class=o>)</span>
                |---. <span class=o>(</span>DNSKEY keytag: 40926 alg: 8 flags: 256<span class=o>)</span>
                    |---. <span class=o>(</span>DNSKEY keytag: 19036 alg: 8 flags: 257<span class=o>)</span>
<span class=p>;;</span> Chase successful</code></pre></div></div></div></div><div class=sect2><h3 id=network-apache>29.8. Apache HTTP 伺服器<a class=anchor href=#network-apache></a></h3><div class=paragraph><p>開放源碼的 Apache HTTP Server 是目前最廣泛被使用的網頁伺服器，FreeBSD 預設並不會安裝這個網頁伺服器，但可從 <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache24/>www/apache24</a> 套件或 Port 安裝。</p></div><div class=paragraph><p>本節將會摘要如何設定並啟動在 FreeBSD 上 2.<em>x</em> 版的 Apache HTTP Server，要取得有關 Apache 更詳細的資訊及其設定項目請參考 <a href=http://httpd.apache.org/>httpd.apache.org</a>。</p></div><div class=sect3><h4 id=_設定並啟動_apache>29.8.1. 設定並啟動 Apache<a class=anchor href=#_設定並啟動_apache></a></h4><div class=paragraph><p>在 FreeBSD 中，主 Apache HTTP Server 設定檔會安裝於 <span class=filename>/usr/local/etc/apache2x/httpd.conf</span>，其中 <em>x</em> 代表版號，這份 ASCII 文字檔中以 <code>#</code> 做為行首的是註解，而最常需修改的項目有：</p></div><div class=dlist><dl><dt class=hdlist1><code>ServerRoot "/usr/local"</code></dt><dd><p>指定該 Apache 的預設安裝路徑，Binary 檔會儲存在伺服器根目錄 (Server root) 下的 <span class=filename>bin</span> 與 <span class=filename>sbin</span> 子目錄，而設定檔會儲存在 <span class=filename>etc/apache2x</span> 子目錄。</p></dd><dt class=hdlist1><code>ServerAdmin <a href=mailto:you@example.com>you@example.com</a></code></dt><dd><p>更改此項目為您要接收問題回報的電子郵件位址，這個位址也會顯示在一些伺服器產生的頁面上，如：錯誤頁面。</p></dd><dt class=hdlist1><code>ServerName www.example.com:80</code></dt><dd><p>讓管理者可以設定伺服器要回傳給客戶端的主機名稱 (Hostname)，例如，<code>www</code> 可以更改為實際的主機名稱，若系統並未有註冊的 DNS 名稱，則可改輸入其 IP 位址，若伺服器需要傾聽其他埠號，可更改 <code>80</code> 為其他埠號。</p></dd><dt class=hdlist1><code>DocumentRoot "/usr/local/www/apache2<em>x</em>/data"</code></dt><dd><p>提供文件的目錄，預設所有的請求均會到此目錄，但可以使用符號連結與別名來指向其他地方。</p></dd></dl></div><div class=paragraph><p>在對 Apache 設定檔做變更之前，建議先做備份，在 Apache 設定完成之後，儲存讓檔案並使用 <code>apachectl</code> 檢驗設定，執行 <code>apachectl configtest</code> 的結果應回傳 <code>Syntax OK</code>。</p></div><div class=paragraph><p>要在系統啟動時執行 Apache，可加入下行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>apache24_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>若 Apache 要使用非預設的選項啟動，可加入下行到 <span class=filename>/etc/rc.conf</span> 來指定所需的旗標參數：</p></div><div class="literalblock programlisting"><div class=content><pre>apache24_flags=&#34;&#34;</pre></div></div><div class=paragraph><p>若 apachectl 未回報設定錯，則可啟動 <code>httpd</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service apache24 start</span></code></pre></div></div><div class=paragraph><p><code>httpd</code> 服務可以透過在網頁瀏覽器中輸入 <code>http://<em>localhost</em></code> 來測試，將 <em>localhost</em> 更改為執行 <code>httpd</code> 那台主機的完整網域名稱 (Fully-qualified domain name)。預設會顯示的網頁為 <span class=filename>/usr/local/www/apache24/data/index.html</span>。</p></div><div class=paragraph><p>後續若有在 <code>httpd</code> 執行中時修改 Apache 設定檔可使用以下指令來測試是否有誤：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service apache24 configtest</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>注意，<code>configtest</code> 並非採用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 標準，不應預期其可在所有的啟動 Script 中正常運作。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_虛擬主機>29.8.2. 虛擬主機<a class=anchor href=#_虛擬主機></a></h4><div class=paragraph><p>虛擬主機允許在一個 Apache 伺服器執行多個網站，虛擬主機可以是以 IP 為主 (<em>IP-based</em>) 或以名稱為主 (<em>name-based</em>)。以 IP 為主的虛擬主機中的每一個網站要使用不同的 IP 位址。以名稱為主的虛擬主機會使用客戶端的 HTTP/1.1 標頭來判斷主機名稱，這可讓不同的網站共用相同的 IP 位址。</p></div><div class=paragraph><p>要設定 Apache 使用以名稱為主的虛擬主機可在每一個網站加入 <code>VirtualHost</code> 區塊，例如，有一個名稱為 <code>www.domain.tld</code> 的主機擁有一個 <code>www.someotherdomain.tld</code> 的虛擬網域，可加入以下項目到 <span class=filename>httpd.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;VirtualHost *&gt;
    ServerName www.domain.tld
    DocumentRoot /www/domain.tld
&lt;/VirtualHost&gt;

&lt;VirtualHost *&gt;
    ServerName www.someotherdomain.tld
    DocumentRoot /www/someotherdomain.tld
&lt;/VirtualHost&gt;</pre></div></div><div class=paragraph><p>每一個虛擬主機均需更改其 <code>ServerName</code> 與 <code>DocumentRoot</code> 的值為實際要使用的值。</p></div><div class=paragraph><p>更多有關設定虛擬主機的資訊，可參考 Apache 官方說明文件於：<a href=http://httpd.apache.org/docs/vhosts/>http://httpd.apache.org/docs/vhosts/</a>。</p></div></div><div class=sect3><h4 id=_apache_模組>29.8.3. Apache 模組<a class=anchor href=#_apache_模組></a></h4><div class=paragraph><p>Apache 使用模組 (Module) 來擴充伺服器所提供的功能。請參考 <a href=http://httpd.apache.org/docs/current/mod/>http://httpd.apache.org/docs/current/mod/</a> 來取得可用模組的完整清單與設定詳細資訊。</p></div><div class=paragraph><p>在 FreeBSD 中有些模組可以隨著 <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache24/>www/apache24</a> Port 編譯，只要在 <span class=filename>/usr/ports/www/apache24</span> 輸入 <code>make config</code> 便可查看有那一些模組是預設開啟的，若模組未與 Port 一併編譯，FreeBSD Port 套件集也提供了一個簡單的方式可安裝各種模組，本節將介紹最常使用的三個模組。</p></div><div class=sect4><h5 id=_mod_ssl>29.8.3.1. <span class=filename>mod_ssl</span><a class=anchor href=#_mod_ssl></a></h5><div class=paragraph><p><span class=filename>mod_ssl</span> 模組利用了 OpenSSL 透過 Secure Sockets Layer (SSLv3) 與 Transport Layer Security (TLSv1) 通訊協定來提供強大的加密，這個模組提供了向受信認的憑証簽署機構申請簽章憑証所需的任何東西，讓 FreeBSD 上能夠執行安全的網頁伺服器。</p></div><div class=paragraph><p>在 FreeBSD 中 <span class=filename>mod_ssl</span> 模組預設在套件與 Port 均是開啟的，可用的設定項目在 <a href=http://httpd.apache.org/docs/current/mod/mod_ssl.html>http://httpd.apache.org/docs/current/mod/mod_ssl.html</a> 會說明。</p></div></div><div class=sect4><h5 id=_mod_perl>29.8.3.2. <span class=filename>mod_perl</span><a class=anchor href=#_mod_perl></a></h5><div class=paragraph><p><span class=filename>mod_perl</span> 模組讓您可以使用 Perl 撰寫 Apache 模組，除此之外，嵌入到伺服器的直譯器可避免啟動外部直譯器的額外開銷與 Perl 耗費的啟動時間。</p></div><div class=paragraph><p><span class=filename>mod_perl</span> 可以使用 <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_perl2/>www/mod_perl2</a> 套件或 Port 安裝，有關使用此模組的說明文件可在 <a href=http://perl.apache.org/docs/2.0/index.html>http://perl.apache.org/docs/2.0/index.html</a> 中找到。</p></div></div><div class=sect4><h5 id=_mod_php>29.8.3.3. <span class=filename>mod_php</span><a class=anchor href=#_mod_php></a></h5><div class=paragraph><p><em>PHP: Hypertext Preprocessor</em> (PHP) 是一般用途的腳本 (Script) 語言，特別適用於網站開發，能夠嵌入在 HTML 當中，它的語法參考自 C, Java™ 及 Perl，目的在讓網頁開發人員能快速的寫出動態網頁。</p></div><div class=paragraph><p>要在 Apache 網頁伺服器上加入對 PHP5 的支援，可安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_php56/>www/mod_php56</a> 套件或 Port，這會安裝並設定支援動態 PHP 應用程式所需的模組。安裝過程會自動加入下行到 <span class=filename>/usr/local/etc/apache24/httpd.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>LoadModule php5_module        libexec/apache24/libphp5.so</pre></div></div><div class=paragraph><p>接著，執行 graceful 重新啟動來載入 PHP 模組：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># apachectl graceful</span></code></pre></div></div><div class=paragraph><p>由 <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_php56/>www/mod_php56</a> 所提供的 PHP 支援是有限的，若需要額外的支援可以使用 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php56-extensions/>lang/php56-extensions</a> Port 來安裝，該 Port 提供了選單介面來選擇可用的 PHP 擴充套件。</p></div><div class=paragraph><p>或者，可以找到適當的 Port 來安裝各別的擴充套件，例如，要增加 PHP 對 MySQL 資料庫伺服器的支援可安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/databases/php56-mysql/>databases/php56-mysql</a>。</p></div><div class=paragraph><p>在安裝完擴充套件之後，必須重新載入 Apache 伺服器來使用新的設定值：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># apachectl graceful</span></code></pre></div></div></div></div><div class=sect3><h4 id=_動態網站>29.8.4. 動態網站<a class=anchor href=#_動態網站></a></h4><div class=paragraph><p>除了 mod_perl 與 mod_php 外，也有其他語言可用來建立動態網頁內容，這包含了 Django 與 Ruby on Rails。</p></div><div class=sect4><h5 id=_django>29.8.4.1. Django<a class=anchor href=#_django></a></h5><div class=paragraph><p>Django 是以 BSD 授權的框架 (Framework)，指在讓開發人員能快速的寫出高效、優雅的網頁應用程式。它提供了物件關聯對應器 (Object-relational mapper)，所以各種資料型態可當做 Python 的物件來開發，且提供了豐富的動態資料庫存取 API 給這些物件，讓開發人員不再需要寫 SQL。它也同時提供了可擴充的樣板系統，來讓應用程式的邏輯與 HTML 呈現能夠被拆開。</p></div><div class=paragraph><p>Django 需要 <span class=filename>mod_python</span>，以及一個 SQL 資料庫引擎才能運作。在 FreeBSD 中的 <a class=package href=https://cgit.freebsd.org/ports/tree/www/py-django/>www/py-django</a> Port 會自動安裝 <span class=filename>mod_python</span> 以及對 PostgreSQL, MySQL 或 SQLite 資料庫的支援，預設為 SQLite，要更改資料庫引擎可在 <span class=filename>/usr/ports/www/py-django</span> 輸入 <code>make config</code> 然後再安裝該 Port。</p></div><div class=paragraph><p>Django 安裝完成之後，應用程式會需要一個專案目錄並搭配 Apache 設定才能使用內嵌的 Python 直譯器，此直譯器會用來呼叫網站上指定 URL 的應用程式。</p></div><div class=paragraph><p>要設定 Apache 傳遞某個 URL 請求到網站應用程式，可加入下行到 <span class=filename>httpd.conf</span> 來指定專案目錄的完整路徑：</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;Location &#34;/&#34;&gt;
    SetHandler python-program
    PythonPath &#34;[&#39;/dir/to/the/django/packages/&#39;] + sys.path&#34;
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mysite.settings
    PythonAutoReload On
    PythonDebug On
&lt;/Location&gt;</pre></div></div><div class=paragraph><p>請參考 <a href=https://docs.djangoproject.com>https://docs.djangoproject.com</a> 來取得如何使用 Django 的更多資訊。</p></div></div><div class=sect4><h5 id=_ruby_on_rails>29.8.4.2. Ruby on Rails<a class=anchor href=#_ruby_on_rails></a></h5><div class=paragraph><p>Ruby on Rails 是另外一套開放源碼的網站框架 (Framework)，提供了完整的開發堆疊，這使得網頁開發人員可以更有生產力且能夠快速的寫出強大的應用程式，在 FreeBSD 它可以使用 <a class=package href=https://cgit.freebsd.org/ports/tree/www/rubygem-rails/>www/rubygem-rails</a> 套件或 Port 安裝。</p></div><div class=paragraph><p>請參考 <a href=http://guides.rubyonrails.org>http://guides.rubyonrails.org</a> 來取得更多有關如何使用 Ruby on Rails 的資訊。</p></div></div></div></div><div class=sect2><h3 id=network-ftp>29.9. 檔案傳輸協定 (FTP)<a class=anchor href=#network-ftp></a></h3><div class=paragraph><p>檔案傳輸協定 (File Transfer Protocol, FTP) 提供了使用一個簡單的方式能夠將檔案傳輸到與接收自 FTP 伺服器，FreeBSD 內建了 FTP 伺服器軟體 ftpd 在基礎系統 (Base system) 中。</p></div><div class=paragraph><p>FreeBSD 提供了多個設定檔來控制對 FTP 伺服器的存取，本節將摘要這些檔案的設定方式，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> 來取得更多有關內建 FTP 伺服器的詳細資訊。</p></div><div class=sect3><h4 id=_設定_2>29.9.1. 設定<a class=anchor href=#_設定_2></a></h4><div class=paragraph><p>最重要的一個設定步驟便是決定那些帳號能夠存取 FTP 伺服器，FreeBSD 系統有數個系統帳號，這些帳號不應該能夠擁有 FTP 存取權，不允許存取 FTP 的使用者清單可在 <span class=filename>/etc/ftpusers</span> 找到，預設該檔案內會有所有的系統帳號，其他不應允許存取 FTP 的使用者也可在此加入。</p></div><div class=paragraph><p>在某些情況可能會布望限制某些使用者的存取，而不是完全避免這些使用者使用 FTP，這可以透過建立 <span class=filename>/etc/ftpchroot</span> 來完成，詳如 <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpchroot&amp;sektion=5&amp;format=html">ftpchroot(5)</a> 所述，這個檔案會列出受到 FTP 存取限制的使用者與群組。</p></div><div class=paragraph><p>要在伺服器上開啟匿名 FTP 存取權，可在 FreeBSD 系統上建立一個名稱為 <code>ftp</code> 使用者，使用者將能夠使用 <code>ftp</code> 或 <code>anonymous</code> 使用者名稱來登入 FTP 伺服器，當提示輸入密碼時，輸入任何值都會被接受，但是慣例上應使用電子郵件位址來當做密碼。當匿名使用者登入時 FTP 伺服器會呼叫 <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> 來限制使用者只能存取 <code>ftp</code> 使用者的家目錄。</p></div><div class=paragraph><p>要設定顯示給 FTP 客戶端的歡迎訊息有兩個文字檔可以建立，<span class=filename>/etc/ftpwelcome</span> 的內容會在收到登入提示前顯示給使用者看，登入成功能後，則會顯示 <span class=filename>/etc/ftpmotd</span> 的內容。注意，這個檔案的路徑是相對於登入環境的，所以 <span class=filename>~ftp/etc/ftpmotd</span> 的內容只會對匿名使用者顯示。</p></div><div class=paragraph><p>設定完 FTP 伺服器之後，在 <span class=filename>/etc/rc.conf</span> 設定適當的變數來在開機時啟動該服務：</p></div><div class="literalblock programlisting"><div class=content><pre>ftpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>要立即啟動服務可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ftpd start</span></code></pre></div></div><div class=paragraph><p>要測試到 FTP 伺服器的連線可輸入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ftp localhost</code></pre></div></div><div class=paragraph><p>ftpd daemon 會使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> 來記錄訊息，預設，系統記錄 Daemon 會寫入有關 FTP 的訊息到 <span class=filename>/var/log/xferlog</span>，FTP 記錄的位置可以透過更改 <span class=filename>/etc/syslog.conf</span> 中下行來做修改：</p></div><div class="literalblock programlisting"><div class=content><pre>ftp.info      /var/log/xferlog</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>要注意啟動匿名 FTP 伺服器可能的潛藏問題，尤其是要讓匿名使用者上傳檔案時要再次確認，因為這可能讓該 FTP 站變成用來交換未授權商業軟體的交流平台或者更糟的狀況。若真的需要匿名 FTP 上傳，那麼請檢查權限設定，讓這些檔案在尚未被管理者審查前不能夠被其他匿名使用者讀取。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-samba>29.10. Microsoft™Windows™ 用戶端檔案與列印服務 (Samba)<a class=anchor href=#network-samba></a></h3><div class=paragraph><p>Samba 是熱門的開放源碼軟體套件，使用 SMB/CIFS 通訊協定提供檔案與列印服務，此通訊協定內建於 Microsoft™ Windows™ 系統，在非 Microsoft™ Windows™ 的系統可透過安裝 Samba 客戶端程式庫來支援此協定。此通訊協定讓客戶端可以存取共享的資料與印表機，這些共享的資源可掛載到一個本機的磁碟機，而共享的印表機則可以當做本機的印表機使用。</p></div><div class=paragraph><p>在 FreeBSD 上，可以使用 <a class=package href=https://cgit.freebsd.org/ports/tree/net/samba48/>net/samba48</a> Port 或套件來安裝 Samba 客戶端程式庫，這個客戶端提供了讓 FreeBSD 系統能存取 SMB/CIFS 在 Microsoft™ Windows™ 網路中共享的資源。</p></div><div class=paragraph><p>FreeBSD 系統也可以透過安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/net/samba48/>net/samba48</a> Port 或套件來設定成 Samba 伺服器，這讓管理者可以在 FreeBSD 系統上建立 SMB/CIFS 的共享資源，讓執行 Microsoft™ Windows™ 或 Samba 客戶端程式庫的客戶端能夠存取。</p></div><div class=sect3><h4 id=_伺服器設定>29.10.1. 伺服器設定<a class=anchor href=#_伺服器設定></a></h4><div class=paragraph><p>Samba 的設定位於 <span class=filename>/usr/local/etc/smb4.conf</span>，必須先設定這個檔案才可使用 Samba。</p></div><div class=paragraph><p>要共享目錄與印表機給在工作群組中的 Windows™ 客戶端的簡易 <span class=filename>smb4.conf</span> 範例如下。對於涉及 LDAP 或 Active Directory 的複雜安裝，可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=samba-tool&amp;sektion=8&amp;format=html">samba-tool(8)</a> 來建立初始的 <span class=filename>smb4.conf</span>。</p></div><div class="literalblock programlisting"><div class=content><pre>[global]
workgroup = WORKGROUP
server string = Samba Server Version %v
netbios name = ExampleMachine
wins support = Yes
security = user
passdb backend = tdbsam

# Example: share /usr/src accessible only to &#39;developer&#39; user
[src]
path = /usr/src
valid users = developer
writable  = yes
browsable = yes
read only = no
guest ok = no
public = no
create mask = 0666
directory mask = 0755</pre></div></div><div class=sect4><h5 id=_全域設定>29.10.1.1. 全域設定<a class=anchor href=#_全域設定></a></h5><div class=paragraph><p>在 <span class=filename>/usr/local/etc/smb4.conf</span> 中加入用來描述網路環境的設定有：</p></div><div class=dlist><dl><dt class=hdlist1><code>workgroup</code></dt><dd><p>要提供的工作群組名稱。</p></dd><dt class=hdlist1><code>netbios name</code></dt><dd><p>Samba 伺服器已知的 NetBIOS 名稱，預設為主機的 DNS 名稱第一節。</p></dd><dt class=hdlist1><code>server string</code></dt><dd><p>會顯示於 <code>net view</code> 輸出結果以及其他會尋找伺服器描述文字並顯示的網路工具的文字。</p></dd><dt class=hdlist1><code>wins support</code></dt><dd><p>不論 Samba 是否要作為 WINS 伺服器，請不要在網路上開啟超過一台伺服器的 WINS 功能。</p></dd></dl></div></div><div class=sect4><h5 id=_安全性設定>29.10.1.2. 安全性設定<a class=anchor href=#_安全性設定></a></h5><div class=paragraph><p>在 <span class=filename>/usr/local/etc/smb4.conf</span> 中最重要的設定便是安全性模式以及後端密碼格式，以下項目管控的選項有：</p></div><div class=dlist><dl><dt class=hdlist1><code>security</code></dt><dd><p>最常見的設定為 <code>security = share</code> 以及 <code>security = user</code>，若客戶端使用的使用者名稱與在 FreeBSD 主機上使用的使用者名稱相同，則應該使用使用者 (user) 層級的安全性，這是預設的安全性原則且它會要求客戶端在存取共享資源前先登入。</p><div class=paragraph><p>安全性為共享 (share) 層級時，客戶端存取共享資源不需要先使用有效的使用者名稱與密碼登入伺服器，在是在舊版 Samba 所採用的預設安全性模式。</p></div></dd><dt class=hdlist1><code>passdb backend</code></dt><dd><p>Samba 支援數種不同的後端認証模式，客戶端可以使用 LDAP, NIS+, SQL 資料庫或修改過的密碼檔來認証，建議的認証方式是 <code>tdbsam</code>，適用於簡易的網路環境且在此處說明，對於較大或更複雜的網路則較建議使用 <code>ldapsam</code>，而 <code>smbpasswd</code> 是舊版的預設值，現在已廢棄不使用。</p></dd></dl></div></div><div class=sect4><h5 id=_samba_使用者>29.10.1.3. Samba 使用者<a class=anchor href=#_samba_使用者></a></h5><div class=paragraph><p>FreeBSD 使用者帳號必須對應 <code>SambaSAMAccount</code> 資料庫， 才能讓 Windows™ 客戶端存取共享資源，要對應既有的 FreeBSD 使用者帳號可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pdbedit&amp;sektion=8&amp;format=html">pdbedit(8)</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pdbedit -a username</span></code></pre></div></div><div class=paragraph><p>本節只會提到一些最常用的設定，請參考 <a href=http://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/>官方 Samba HOWTO</a> 來取得有關可用設定選項的額外資訊。</p></div></div></div><div class=sect3><h4 id=_啟動_samba>29.10.2. 啟動 Samba<a class=anchor href=#_啟動_samba></a></h4><div class=paragraph><p>要在開機時啟動 Samba，可加入下行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>samba_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>要立即啟動 Samba：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service samba_server start</span>
Performing sanity check on Samba configuration: OK
Starting nmbd.
Starting smbd.</code></pre></div></div><div class=paragraph><p>Samba 由三個獨立的 Daemon 所組成，nmbd 與 smbd daemon 可透過 <code>samba_enable</code> 來啟動，若同時也需要 winbind 名稱解析服務則需額外設定：</p></div><div class="literalblock programlisting"><div class=content><pre>winbindd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Samba 可以隨時停止，要停止可輸入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service samba_server stop</span></code></pre></div></div><div class=paragraph><p>Samba 是一套擁有能整合 Microsoft™ Windows™ 網路功能的複雜軟體套件，除了在此處說明的基礎設定，要取得更多的功能資訊，請參考 <a href=http://www.samba.org>http://www.samba.org</a>。</p></div></div></div><div class=sect2><h3 id=network-ntp>29.11. NTP 時間校對<a class=anchor href=#network-ntp></a></h3><div class=paragraph><p>隨著使用時間，電腦的時鐘會逐漸偏移，這對需要網路上電腦有相同準確度時間的許多網路服務來說是一個大問題。準確的時間同樣能確保檔案時間戳記的一致性。網路時間協定 (Network Time Protocol, NTP) 是一種在網路上可以確保時間準確的方式。</p></div><div class=paragraph><p>FreeBSD 內含 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> 可設定來查詢其他 NTP 伺服器來同步電腦的時間或提供時間服務給其他在網路上的電腦。</p></div><div class=paragraph><p>本節將會介紹如何設定 FreeBSD 上的 ntpd，更進一步的說明文件可於 <span class=filename>/usr/shared/doc/ntp/</span> 找到 HTML 格式的版本。</p></div><div class=sect3><h4 id=_ntp_設定>29.11.1. NTP 設定<a class=anchor href=#_ntp_設定></a></h4><div class=paragraph><p>在 FreeBSD，內建的 ntpd 可用來同步系統的時間，Ntpd 要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 中的變數以及下一節會詳細說明的 <span class=filename>/etc/ntp.conf</span> 來設定。</p></div><div class=paragraph><p>Ntpd 與網路中各節點的通訊採用 UDP 封包，在伺服器與 NTP 各節點間的防火牆必須設定成可允許進/出埠 123 的 UDP 封包。</p></div><div class=sect4><h5 id=_etcntp_conf_檔>29.11.1.1. <span class=filename>/etc/ntp.conf</span> 檔<a class=anchor href=#_etcntp_conf_檔></a></h5><div class=paragraph><p>Ntpd 會讀取 <span class=filename>/etc/ntp.conf</span> 來得知要從那些 NTP 伺服器查詢時間，建議可設定多個 NTP 伺服器，來避免萬一其中一個伺服器無法連線或是時間不可靠的問題，當 ntpd 收到回應，它會偏好先採用較可信賴的伺服器。查詢的伺服器可以是來自本地網路的 ISP 所提供，也可從<a href=http://support.ntp.org/bin/view/Servers/WebHome>線上可公開存取的NTP 伺服器清單</a>中挑選，您可以選擇一個離您地理位置較近的伺服器並閱讀它的使用規則。也有 <a href=http://support.ntp.org/bin/view/Servers/NTPPoolServers>可公開存取的 NTP 池線上清單</a>可用，由一個地理區域所組織，除此之外 FreeBSD 提供了計劃贊助的伺服器池，<code>0.freebsd.pool.ntp.org</code>。</p></div><div class=exampleblock><div class=title>例 49. <span class=filename>/etc/ntp.conf</span> 範例</div><div class=content><div class=paragraph><p>這份簡單的 <span class=filename>ntp.conf</span> 範例檔可以放心的使用，其中包含了建議的 <code>restrict</code> 選項可避免伺服器被公開存取。</p></div><div class="literalblock programlisting"><div class=content><pre># Disallow ntpq control/query access.  Allow peers to be added only
# based on pool and server statements in this file.
restrict default limited kod nomodify notrap noquery nopeer
restrict source  limited kod nomodify notrap noquery

# Allow unrestricted access from localhost for queries and control.
restrict 127.0.0.1
restrict ::1

# Add a specific server.
server ntplocal.example.com iburst

# Add FreeBSD pool servers until 3-6 good servers are available.
tos minclock 3 maxclock 6
pool 0.freebsd.pool.ntp.org iburst

# Use a local leap-seconds file.
leapfile &#34;/var/db/ntpd.leap-seconds.list&#34;</pre></div></div></div></div><div class=paragraph><p>這個檔案的格式在 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a> 有詳細說明，以下的說明僅快速的帶過以上範例檔有用到的一些關鍵字。</p></div><div class=paragraph><p>預設 NTP 伺服器是可以被任何網路主機所存取，<code>restrict</code> 關鍵字可以控制有那些系統可以存取伺服器。<code>restrict</code> 支援設定多項，每一項可再更進一步調整前面所做的設定。範例中的設定授權本地系統有完整的查詢及控制權限，而遠端系統只有查詢時間的權限。要了解更詳細的資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a> 中的 <code>Access Control Support</code> 一節。</p></div><div class=paragraph><p><code>server</code> 關鍵字可指定要查詢的伺服器，設定檔中可以使用多個 server 關鍵字，一個伺服器列一行。<code>pool</code> 關鍵字可指定伺服器池，Ntpd 會加入該伺服器池中的一或多台伺服器，直到數量滿足 <code>tos minclock</code> 的設定。<code>iburst</code> 關鍵字會指示 ntpd 在建立連線時執行 8 連發快速封包交換，可以更快的同步系統時間。</p></div><div class=paragraph><p><code>leapfile</code> 關鍵字用來指定含有閏秒 (Leap second) 資訊的檔案位置，該檔案是由 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 自動更新。這個關鍵字指定的檔案位置必須與 <span class=filename>/etc/rc.conf</span> 中設定的 <code>ntp_db_leapfile</code> 相同。</p></div></div><div class=sect4><h5 id=_在_etcrc_conf_中的_ntp_設定項目>29.11.1.2. 在 <span class=filename>/etc/rc.conf</span> 中的 NTP 設定項目<a class=anchor href=#_在_etcrc_conf_中的_ntp_設定項目></a></h5><div class=paragraph><p>設定 <code>ntpd_enable="YES"</code> 可讓開機時會啟動 ntpd。將 <code>ntpd_enable=YES</code> 加到 <span class=filename>/etc/rc.conf</span> 之後，可輸入以下指令讓 ntpd 不需重新開機立即啟動：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ntpd start</span></code></pre></div></div><div class=paragraph><p>要使用 ntpd 必須設定 <code>ntpd_enable</code>，以下所列的 <span class=filename>rc.conf</span> 變數可視所需請況設定。</p></div><div class=paragraph><p>設定 <code>ntpd_sync_on_start=YES</code> 可讓 ntpd 可以在系統啟動時一次同步任何差距的時間，正常情況若時鐘的差距超過 1000 秒便會記錄錯誤並且中止。這個設定項目在沒有電池備援的時鐘上特別有用。</p></div><div class=paragraph><p>設定 <code>ntpd_oomprotect=YES</code> 可保護 ntpd daemon 被系統中止並嘗試從記憶體不足 (Out Of Memory, OOM) 的情況恢復運作。</p></div><div class=paragraph><p>設定 <code>ntpd_config=</code> 可更改 <span class=filename>ntp.conf</span> 檔案的位置。</p></div><div class=paragraph><p>設定 <code>ntpd_flags=</code> 可設定使用任何其他所需 ntpd 參數，但要避免使用由 <span class=filename>/etc/rc.d/ntpd</span> 內部控管的參數如下：</p></div><div class=ulist><ul><li><p><code>-p</code> (pid 檔案位置)</p></li><li><p><code>-c</code> (改用 <code>ntpd_config=</code> 設定)</p></li></ul></div></div><div class=sect4><h5 id=_使用無特權的_ntpd_使用者執行_ntpd>29.11.1.3. 使用無特權的 <code>ntpd</code> 使用者執行 Ntpd<a class=anchor href=#_使用無特權的_ntpd_使用者執行_ntpd></a></h5><div class=paragraph><p>在 FreeBSD 上的 Ntpd 現在可以使用無特權的使用者啟動並執行，要達到這個功能需要 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ntpd&amp;sektion=4&amp;format=html">mac_ntpd(4)</a> 規則模組。<span class=filename>/etc/rc.d/ntpd</span> 啟動 Script 會先檢查 NTP 的設定，若可以的話它會載入 <code>mac_ntpd</code> 模組，然後以無特權的使用者 <code>ntpd</code> (user id 123) 來啟動 ntpd。為了避免檔案與目錄存取權限的問題，當設定中有任何檔案相關的選項時，啟動 Script 不會自動以 <code>ntpd</code> 身份啟動 ntpd。</p></div><div class=paragraph><p>在 <code>ntpd_flags</code> 若出現以下任何參數則需要以最下面的方式手動設定才能以 <code>ntpd</code> 使用者的身份執行：</p></div><div class=ulist><ul><li><p>-f 或 --driftfile</p></li><li><p>-i 或 --jaildir</p></li><li><p>-k 或 --keyfile</p></li><li><p>-l 或 --logfile</p></li><li><p>-s 或 --statsdir</p></li></ul></div><div class=paragraph><p>在 <span class=filename>ntp.conf</span> 若出現以下任何關鍵字則需要以最下面的方式手動設定才能以 <code>ntpd</code> 使用者的身份執行：</p></div><div class=ulist><ul><li><p>crypto</p></li><li><p>driftfile</p></li><li><p>key</p></li><li><p>logdir</p></li><li><p>statsdir</p></li></ul></div><div class=paragraph><p>要手動設定以使用者 <code>ntpd</code> 身份執行 ntpd 你必須：</p></div><div class=ulist><ul><li><p>確保 <code>ntpd</code> 使用者有權限存取所有在設定檔中指定的檔案與目錄。</p></li><li><p>讓 <code>mac_ntpd</code> 模組載入或編譯至核心，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ntpd&amp;sektion=4&amp;format=html">mac_ntpd(4)</a> 取得詳細資訊。</p></li><li><p>在 <span class=filename>/etc/rc.conf</span> 中設定 <code>ntpd_user="ntpd"</code></p></li></ul></div></div></div><div class=sect3><h4 id=_在_ppp_連線使用_ntp>29.11.2. 在 PPP 連線使用 NTP<a class=anchor href=#_在_ppp_連線使用_ntp></a></h4><div class=paragraph><p>ntpd 並不需要永久的網際網路連線才能正常運作，若有一個 PPP 連線是設定成需要時撥號，那麼便需要避免 NTP 的流量觸發撥號或是保持連線不中斷，這可在 <span class=filename>/etc/ppp/ppp.conf</span> 使用 <code>filter</code> 項目設定，例如：</p></div><div class="literalblock programlisting"><div class=content><pre>set filter dial 0 deny udp src eq 123
# Prevent NTP traffic from initiating dial out
set filter dial 1 permit 0 0
set filter alive 0 deny udp src eq 123
# Prevent incoming NTP traffic from keeping the connection open
set filter alive 1 deny udp dst eq 123
# Prevent outgoing NTP traffic from keeping the connection open
set filter alive 2 permit 0/0 0/0</pre></div></div><div class=paragraph><p>要取得更詳細的資訊，請參考於 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 的 <code>PACKET FILTERING</code> 小節以及在 <span class=filename>/usr/shared/examples/ppp/</span> 中的範例。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>部份網際網路存取提供商會封鎖較小編號的埠，這會讓 NTP 無法運作，因為回應永遠無到傳送到該主機。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-iscsi>29.12. iSCSI Initiator 與 Target 設定<a class=anchor href=#network-iscsi></a></h3><div class=paragraph><p>iSCSI is a way to share storage over a network. Unlike NFS, which works at the file system level, iSCSI works at the block device level.</p></div><div class=paragraph><p>In iSCSI terminology, the system that shares the storage is known as the <em>target</em>. The storage can be a physical disk, or an area representing multiple disks or a portion of a physical disk. For example, if the disk(s) are formatted with ZFS, a zvol can be created to use as the iSCSI storage.</p></div><div class=paragraph><p>The clients which access the iSCSI storage are called <em>initiators</em>. To initiators, the storage available through iSCSI appears as a raw, unformatted disk known as a LUN. Device nodes for the disk appear in <span class=filename>/dev/</span> and the device must be separately formatted and mounted.</p></div><div class=paragraph><p>FreeBSD provides a native, kernel-based iSCSI target and initiator. This section describes how to configure a FreeBSD system as a target or an initiator.</p></div><div class=sect3><h4 id=network-iscsi-target>29.12.1. 設定 iSCSI Target<a class=anchor href=#network-iscsi-target></a></h4><div class=paragraph><p>To configure an iSCSI target, create the <span class=filename>/etc/ctl.conf</span> configuration file, add a line to <span class=filename>/etc/rc.conf</span> to make sure the <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> daemon is automatically started at boot, and then start the daemon.</p></div><div class=paragraph><p>The following is an example of a simple <span class=filename>/etc/ctl.conf</span> configuration file. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ctl.conf&amp;sektion=5&amp;format=html">ctl.conf(5)</a> for a more complete description of this file’s available options.</p></div><div class="literalblock programlisting"><div class=content><pre>portal-group pg0 {
	discovery-auth-group no-authentication
	listen 0.0.0.0
	listen [::]
}

target iqn.2012-06.com.example:target0 {
	auth-group no-authentication
	portal-group pg0

	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre></div></div><div class=paragraph><p>The first entry defines the <code>pg0</code> portal group. Portal groups define which network addresses the <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> daemon will listen on. The <code>discovery-auth-group no-authentication</code> entry indicates that any initiator is allowed to perform iSCSI target discovery without authentication. Lines three and four configure <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> to listen on all IPv4 (<code>listen 0.0.0.0</code>) and IPv6 (<code>listen [::]</code>) addresses on the default port of 3260.</p></div><div class=paragraph><p>It is not necessary to define a portal group as there is a built-in portal group called <code>default</code>. In this case, the difference between <code>default</code> and <code>pg0</code> is that with <code>default</code>, target discovery is always denied, while with <code>pg0</code>, it is always allowed.</p></div><div class=paragraph><p>The second entry defines a single target. Target has two possible meanings: a machine serving iSCSI or a named group of LUNs. This example uses the latter meaning, where <code>iqn.2012-06.com.example:target0</code> is the target name. This target name is suitable for testing purposes. For actual use, change <code>com.example</code> to the real domain name, reversed. The <code>2012-06</code> represents the year and month of acquiring control of that domain name, and <code>target0</code> can be any value. Any number of targets can be defined in this configuration file.</p></div><div class=paragraph><p>The <code>auth-group no-authentication</code> line allows all initiators to connect to the specified target and <code>portal-group pg0</code> makes the target reachable through the <code>pg0</code> portal group.</p></div><div class=paragraph><p>The next section defines the LUN. To the initiator, each LUN will be visible as a separate disk device. Multiple LUNs can be defined for each target. Each LUN is identified by a number, where LUN 0 is mandatory. The <code>path /data/target0-0</code> line defines the full path to a file or zvol backing the LUN. That path must exist before starting <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a>. The second line is optional and specifies the size of the LUN.</p></div><div class=paragraph><p>Next, to make sure the <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> daemon is started at boot, add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ctld_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To start <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> now, run this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld start</span></code></pre></div></div><div class=paragraph><p>As the <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> daemon is started, it reads <span class=filename>/etc/ctl.conf</span>. If this file is edited after the daemon starts, use this command so that the changes take effect immediately:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld reload</span></code></pre></div></div><div class=sect4><h5 id=_認證>29.12.1.1. 認證<a class=anchor href=#_認證></a></h5><div class=paragraph><p>The previous example is inherently insecure as it uses no authentication, granting anyone full access to all targets. To require a username and password to access targets, modify the configuration as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>auth-group ag0 {
	chap username1 secretsecret
	chap username2 anothersecret
}

portal-group pg0 {
	discovery-auth-group no-authentication
	listen 0.0.0.0
	listen [::]
}

target iqn.2012-06.com.example:target0 {
	auth-group ag0
	portal-group pg0
	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre></div></div><div class=paragraph><p>The <code>auth-group</code> section defines username and password pairs. An initiator trying to connect to <code>iqn.2012-06.com.example:target0</code> must first specify a defined username and secret. However, target discovery is still permitted without authentication. To require target discovery authentication, set <code>discovery-auth-group</code> to a defined <code>auth-group</code> name instead of <code>no-authentication</code>.</p></div><div class=paragraph><p>It is common to define a single exported target for every initiator. As a shorthand for the syntax above, the username and password can be specified directly in the target entry:</p></div><div class="literalblock programlisting"><div class=content><pre>target iqn.2012-06.com.example:target0 {
	portal-group pg0
	chap username1 secretsecret

	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre></div></div></div></div><div class=sect3><h4 id=network-iscsi-initiator>29.12.2. 設定 iSCSI Initiator<a class=anchor href=#network-iscsi-initiator></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The iSCSI initiator described in this section is supported starting with FreeBSD 10.0-RELEASE. To use the iSCSI initiator available in older versions, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=iscontrol&amp;sektion=8&amp;format=html">iscontrol(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The iSCSI initiator requires that the <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a> daemon is running. This daemon does not use a configuration file. To start it automatically at boot, add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>iscsid_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To start <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a> now, run this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service iscsid start</span></code></pre></div></div><div class=paragraph><p>Connecting to a target can be done with or without an <span class=filename>/etc/iscsi.conf</span> configuration file. This section demonstrates both types of connections.</p></div><div class=sect4><h5 id=_不使用設定檔連線到_target>29.12.2.1. 不使用設定檔連線到 Target<a class=anchor href=#_不使用設定檔連線到_target></a></h5><div class=paragraph><p>To connect an initiator to a single target, specify the IP address of the portal and the name of the target:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -A -p 10.10.10.10 -t iqn.2012-06.com.example:target0</span></code></pre></div></div><div class=paragraph><p>To verify if the connection succeeded, run <code>iscsictl</code> without any arguments. The output should look similar to this:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Connected: da0</pre></div></div><div class=paragraph><p>In this example, the iSCSI session was successfully established, with <span class=filename>/dev/da0</span> representing the attached LUN. If the <code>iqn.2012-06.com.example:target0</code> target exports more than one LUN, multiple device nodes will be shown in that section of the output:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Connected: da0 da1 da2.</code></pre></div></div><div class=paragraph><p>Any errors will be reported in the output, as well as the system logs. For example, this message usually means that the <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a> daemon is not running:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Waiting for iscsid(8)</pre></div></div><div class=paragraph><p>The following message suggests a networking problem, such as a wrong IP address or port:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.11     Connection refused</pre></div></div><div class=paragraph><p>This message means that the specified target name is wrong:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Not found</pre></div></div><div class=paragraph><p>This message means that the target requires authentication:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Authentication failed</pre></div></div><div class=paragraph><p>To specify a CHAP username and secret, use this syntax:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -A -p 10.10.10.10 -t iqn.2012-06.com.example:target0 -u user -s secretsecret</span></code></pre></div></div></div><div class=sect4><h5 id=_使用設定檔連線到_target>29.12.2.2. 使用設定檔連線到 Target<a class=anchor href=#_使用設定檔連線到_target></a></h5><div class=paragraph><p>To connect using a configuration file, create <span class=filename>/etc/iscsi.conf</span> with contents like this:</p></div><div class="literalblock programlisting"><div class=content><pre>t0 {
	TargetAddress   = 10.10.10.10
	TargetName      = iqn.2012-06.com.example:target0
	AuthMethod      = CHAP
	chapIName       = user
	chapSecret      = secretsecret
}</pre></div></div><div class=paragraph><p>The <code>t0</code> specifies a nickname for the configuration file section. It will be used by the initiator to specify which configuration to use. The other lines specify the parameters to use during connection. The <code>TargetAddress</code> and <code>TargetName</code> are mandatory, whereas the other options are optional. In this example, the CHAP username and secret are shown.</p></div><div class=paragraph><p>To connect to the defined target, specify the nickname:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -An t0</span></code></pre></div></div><div class=paragraph><p>Alternately, to connect to all targets defined in the configuration file, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -Aa</span></code></pre></div></div><div class=paragraph><p>To make the initiator automatically connect to all targets in <span class=filename>/etc/iscsi.conf</span>, add the following to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>iscsictl_enable=&#34;YES&#34;
iscsictl_flags=&#34;-Aa&#34;</pre></div></div></div></div></div></div></div><div class=sect1><h2 id=firewalls>Chapter 30. 防火牆<a class=anchor href=#firewalls></a></h2><div class=sectionbody><div class=sect2><h3 id=firewalls-intro>30.1. 概述<a class=anchor href=#firewalls-intro></a></h3><div class=paragraph><p>防火牆能夠過濾透過系統內送 (Incoming) 與外發 (Outgoing) 的流量，防火牆可使用一組或多組 "規則 (Rules)" 來檢查網路連線中進出的網路封包(Network packets)，並且能允許或阻擋其通過。 而防火牆規則可以檢查封包中一個或數個特徵，例如通訊協定類型、來源或目的主機位址，以及來源及目地的連接埠 (Port)。</p></div><div class=paragraph><p>防火牆可以加強主機或網路的安全性，它可以用來完成下列事情：</p></div><div class=ulist><ul><li><p>保護並隔離內部網路的應用程式、服務與主機，避免來自網際網路不必要的存取。</p></li><li><p>限制或者禁止內部網路的主機存取網際網路服務。</p></li><li><p>支援網路位址轉譯 (Network address translation, NAT)，可允許內部網路使用私有 IP 位址並共用一個連線使用一個 IP 位址連到網際網路或者自動分配一個共用池當中的公開位址。</p></li></ul></div><div class=paragraph><p>FreeBSD 有三種內建於基礎系統的防火牆：PF, IPFW 與 IPFILTER 即 IPF。FreeBSD 也提供了兩種流量限制程式 (Traffic shaper) 來控制頻寬的用量：<a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> 與 <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>，ALTQ 一般配合 PF 使用，而 dummynet 會配合 IPFW。每一種防火牆都會使用規則來管制來自與送往 FreeBSD 的封包，儘管它們用不同的方式運作且有不同的規則語法。</p></div><div class=paragraph><p>FreeBSD 提供多個防火牆是為了滿足不同的需求與各種使用者的偏好，每位使用者應評估那一種防火牆最能滿足其需求。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>如何定義封包過濾規則。</p></li><li><p>FreeBSD 內建防火牆之間的差異。</p></li><li><p>如何使用與設定 PF 防火牆。</p></li><li><p>如何使用與設定 IPFW 防火牆。</p></li><li><p>如何使用與設定 IPFILTER 防火牆。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解 FreeBSD 基礎及網路概念。</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>由於所有防火牆均是以監控所選封包的控制欄位值為基礎運作，所以防火牆規則集的建立者必須很明白 TCP/IP 是如何運作的，在封包的控制欄位中會有那些數值，這些數值會被如何用在一般的連線階段，要了解更多相關資訊，可參考 <a href=http://www.ipprimer.com>Daryl’s TCP/IP Primer</a>。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=firewalls-concepts>30.2. 防火牆概念<a class=anchor href=#firewalls-concepts></a></h3><div class=paragraph><p>一個規則集 (Ruleset) 中會有一群根據封包內的資料來判斷通過或封鎖的規則，主機間雙向的封包交換構成一個連線階段的對話，防火牆規則集會同時處理接收自網際網路的封包以及由系統所產生的回應封包，每一個 TCP/IP 服務都會預先定義其通訊協定以及要傾聽的埠，要送往指定服務的封包會誕生在來源位址，使用一個不需特殊權限的埠並傳送給目標位址上特定服務的埠，所有上述過程中的參數均可用來當做建立規則的篩選條件，來允許或封鎖服務。</p></div><div class=paragraph><p>要查詢一個不清楚的埠號，可參考 <span class=filename>/etc/services</span>，或者至 <a href=http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers>http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a> 查詢埠號來找出特定埠號的用途。</p></div><div class=paragraph><p>查看這個連結來了解有 <a href=http://web.archive.org/web/20150803024617/http://www.sans.org/security-resources/idfaq/oddports.php>那些埠號會被木馬程式使用</a>。</p></div><div class=paragraph><p>FTP 有兩個模式：主動 (Active) 模式與被動 (Passive) 模式，兩者的差異在於取得資料通道的方式，被動模式會較安全，由於資料通道會取自 FTP 連線請求者。想要取得 FTP 與兩種模式更進一步的說明，詳見 <a href=http://www.slacksite.com/other/ftp.html>http://www.slacksite.com/other/ftp.html</a>。</p></div><div class=paragraph><p>防火牆規則集可以為排除式 ("exclusive") 或者內含式 ("inclusive")，一個排除式的防火牆會允許所有的連線通過除了符合規則集的連線，內含式的防火牆則會反過來只允許符合規則集的連線並封鎖其他任何的連線。</p></div><div class=paragraph><p>內含式的防火牆對於外發的流量有較好的控制，使其成為提供網際網路服務的系統的最佳選擇，它同時可以控制可存取私有網路的網際網路連線，所有不符合該規則的連線會被封鎖並記錄。一般來說，內含式的防火牆會比排除式的防火牆安全，因為內含式的防火牆可以明顯的減少不必要連線所造成風險。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>除非另有說明，否則所有在此章節的範例規則集均為內含式防火牆規則集。</p></div></td></tr></tbody></table></div><div class=paragraph><p>使用具狀態防火牆 ("Stateful firewall") 可以更進一步加強安全性，這種類型的防火牆可持續追蹤連線，只允許與現有連線相符的封包或符合允許條件的新連線通過。</p></div><div class=paragraph><p>狀態過濾技術 (Stateful filtering) 將所有的流量當做是一個由雙向封包交換所組成的連線階段，當在符合的規則上指定狀態 (State) 時，防火牆會自動產生內部規則來處理該連線階段中每個預期會通過的封包，這種防火牆有足夠的比對能力可以辨別是否為同一個連線階段的封包，任何不符合連線階段樣板的封包都會被自動拒絕。</p></div><div class=paragraph><p>當連線階段結束時，該規則將會動態狀態表 (Dynamic state table) 中移除。</p></div><div class=paragraph><p>Stateful filtering 讓管理者可以專注於封鎖/傳遞新的連線階段，若新的連線階段通過，那麼該連線階段後續的封包將會自動允許通過，且任何假冒的封包會自動被拒絕。若新的連線階最被封鎖，將不允許其任何後續的封包。Stateful filtering 提供了進階的比對能力，能夠抵禦不同種類由攻擊者發動的 flood 攻擊。</p></div><div class=paragraph><p>NAT 代表 <em>Network Address Translation</em> 即網路位址轉譯，NAT 功能讓在防火牆之後的私有 LAN 可以共用一個 ISP 分配的 IP 位址 (甚至是動態分配的)，NAT 每一台在該 LAN 中的電腦均可連線網際網路，而不需要支付 ISP 多個網路帳號或 IP 位址的額外費用。</p></div><div class=paragraph><p>NAT 在當封包要外送到防火牆之外的網際網路時，會自動轉譯每一台電腦在私有 LAN 的 IP 位址成為一個公有 IP 位址，它也同樣會對回傳的封包做反向轉譯。</p></div><div class=paragraph><p>根據 RFC1918，會保留以下範圍的 IP 位址做為私有網路使用，永遠不會被傳送到網際網路，因此可供 NAT 使用：</p></div><div class=ulist><ul><li><p><code>10.0.0.0/8</code>.</p></li><li><p><code>172.16.0.0/12</code>.</p></li><li><p><code>192.168.0.0/16</code>.</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>在使用防火牆規則時要_非常小心_，有一些設定_會將管理者鎖在伺服器之外_，保險起見的方式是在本機的 Console 做初次的防火牆設定，不要直接由遠端透過 ssh 來設定防火牆。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=firewalls-pf>30.3. PF<a class=anchor href=#firewalls-pf></a></h3><div class=paragraph><p>自 FreeBSD 5.3 開始，基礎系統便有內建 OpenBSD’s PF 防火牆的移植版本，PF 是一套完整、多功能的防火牆，並可選擇開啟 ALTQ (Alternate Queuing) 的支援來提供 Quality of Service (QoS) 機制。</p></div><div class=paragraph><p>OpenBSD 計劃有維護一份官方參考文件於 <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a> ，Peter Hansteen 有維一份詳盡的 PF 教學於 <a href=http://home.nuug.no/~peter/pf/>http://home.nuug.no/~peter/pf/</a>。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>When reading the <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a>, keep in mind that FreeBSD’s version of PF has diverged substantially from the upstream OpenBSD version over the years. Not all features work the same way on FreeBSD as they do in OpenBSD and vice versa.</p></div></td></tr></tbody></table></div><div class=paragraph><p>要詢問有關設定與執行 PF 防火牆的問題可至 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pf>FreeBSD packet filter 郵遞論壇</a>，在詢問問題之前請先查看該郵遞論壇的封存資料，因您的問題可能已有解答。</p></div><div class=paragraph><p>This section of the Handbook focuses on PF as it pertains to FreeBSD. It demonstrates how to enable PF and ALTQ. It also provides several examples for creating rulesets on a FreeBSD system.</p></div><div class=sect3><h4 id=_開啟_pf>30.3.1. 開啟 PF<a class=anchor href=#_開啟_pf></a></h4><div class=paragraph><p>To use PF, its kernel module must be first loaded. This section describes the entries that can be added to <span class=filename>/etc/rc.conf</span> to enable PF.</p></div><div class=paragraph><p>Start by adding <code>pf_enable=yes</code> to <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pf_enable=yes</span></code></pre></div></div><div class=paragraph><p>Additional options, described in <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a>, can be passed to PF when it is started. Add or change this entry in <span class=filename>/etc/rc.conf</span> and specify any required flags between the two quotes (<code>""</code>):</p></div><div class="literalblock programlisting"><div class=content><pre>pf_flags=&#34;&#34;                     # additional flags for pfctl startup</pre></div></div><div class=paragraph><p>PF will not start if it cannot find its ruleset configuration file. By default, FreeBSD does not ship with a ruleset and there is no <span class=filename>/etc/pf.conf</span>. Example rulesets can be found in <span class=filename>/usr/shared/examples/pf/</span>. If a custom ruleset has been saved somewhere else, add a line to <span class=filename>/etc/rc.conf</span> which specifies the full path to the file:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_rules=&#34;/path/to/pf.conf&#34;</pre></div></div><div class=paragraph><p>Logging support for PF is provided by <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a>. To enable logging support, add <code>pflog_enable=yes</code> to <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pflog_enable=yes</span></code></pre></div></div><div class=paragraph><p>The following lines can also be added to change the default location of the log file or to specify any additional flags to pass to <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a> when it is started:</p></div><div class="literalblock programlisting"><div class=content><pre>pflog_logfile=&#34;/var/log/pflog&#34;  # where pflogd should store the logfile
pflog_flags=&#34;&#34;                  # additional flags for pflogd startup</pre></div></div><div class=paragraph><p>Finally, if there is a LAN behind the firewall and packets need to be forwarded for the computers on the LAN, or NAT is required, enable the following option:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;            # Enable as LAN gateway</pre></div></div><div class=paragraph><p>After saving the needed edits, PF can be started with logging support by typing:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service pf start</span>
<span class=c># service pflog start</span></code></pre></div></div><div class=paragraph><p>By default, PF reads its configuration rules from <span class=filename>/etc/pf.conf</span> and modifies, drops, or passes packets according to the rules or definitions specified in this file. The FreeBSD installation includes several sample files located in <span class=filename>/usr/shared/examples/pf/</span>. Refer to the <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a> for complete coverage of PF rulesets.</p></div><div class=paragraph><p>To control PF, use <code>pfctl</code>. <a href=#pfctl>有用的 <code>pfctl</code> 選項</a> summarizes some useful options to this command. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> for a description of all available options:</p></div><table id=pfctl class="tableblock frame-none grid-all stretch"><caption class=title>表 27. 有用的 <code>pfctl</code> 選項</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">指令</th><th class="tableblock halign-left valign-top">用途</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enable PF.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Disable PF.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -F all -f /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Flush all NAT, filter, state, and table rules and reload <span class=filename>/etc/pf.conf</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -s [ rules | nat | states ]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Report on the filter rules, NAT rules, or state table.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -vnf /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Check <span class=filename>/etc/pf.conf</span> for errors, but do not load ruleset.</p></td></tr></tbody></table><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> is useful for running commands like <code>pfctl</code> that require elevated privileges. It can be installed from the Ports Collection.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To keep an eye on the traffic that passes through the PF firewall, consider installing the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/pftop/>sysutils/pftop</a> package or port. Once installed, pftop can be run to view a running snapshot of traffic in a format which is similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>.</p></div></div><div class=sect3><h4 id=pf-tutorial>30.3.2. PF 規則集<a class=anchor href=#pf-tutorial></a></h4><div class=paragraph><p>This section demonstrates how to create a customized ruleset. It starts with the simplest of rulesets and builds upon its concepts using several examples to demonstrate real-world usage of PF’s many features.</p></div><div class=paragraph><p>The simplest possible ruleset is for a single machine that does not run any services and which needs access to one network, which may be the Internet. To create this minimal ruleset, edit <span class=filename>/etc/pf.conf</span> so it looks like this:</p></div><div class="literalblock programlisting"><div class=content><pre>block in all
pass out all keep state</pre></div></div><div class=paragraph><p>The first rule denies all incoming traffic by default. The second rule allows connections created by this system to pass out, while retaining state information on those connections. This state information allows return traffic for those connections to pass back and should only be used on machines that can be trusted. The ruleset can be loaded with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -e ; pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>In addition to keeping state, PF provides <em>lists</em> and <em>macros</em> which can be defined for use when creating rules. Macros can include lists and need to be defined before use. As an example, insert these lines at the very top of the ruleset:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;</pre></div></div><div class=paragraph><p>PF understands port names as well as port numbers, as long as the names are listed in <span class=filename>/etc/services</span>. This example creates two macros. The first is a list of seven TCP port names and the second is one UDP port name. Once defined, macros can be used in rules. In this example, all traffic is blocked except for the connections initiated by this system for the seven specified TCP services and the one specified UDP service:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Even though UDP is considered to be a stateless protocol, PF is able to track some state information. For example, when a UDP request is passed which asks a name server about a domain name, PF will watch for the response to pass it back.</p></div><div class=paragraph><p>Whenever an edit is made to a ruleset, the new rules must be loaded so they can be used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>If there are no syntax errors, <code>pfctl</code> will not output any messages during the rule load. Rules can also be tested before attempting to load them:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -nf /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Including <code>-n</code> causes the rules to be interpreted only, but not loaded. This provides an opportunity to correct any errors. At all times, the last valid ruleset loaded will be enforced until either PF is disabled or a new ruleset is loaded.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Adding <code>-v</code> to a <code>pfctl</code> ruleset verify or load will display the fully parsed rules exactly the way they will be loaded. This is extremely useful when debugging rules.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=pftut-gateway>30.3.2.1. 使用 NAT 的簡單通訊閘<a class=anchor href=#pftut-gateway></a></h5><div class=paragraph><p>This section demonstrates how to configure a FreeBSD system running PF to act as a gateway for at least one other machine. The gateway needs at least two network interfaces, each connected to a separate network. In this example, <span class=filename>xl1</span> is connected to the Internet and <span class=filename>xl0</span> is connected to the internal network.</p></div><div class=paragraph><p>First, enable the gateway to let the machine forward the network traffic it receives on one interface to another interface. This sysctl setting will forward IPv4 packets:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>To forward IPv6 traffic, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet6.ip6.forwarding=1</span></code></pre></div></div><div class=paragraph><p>To enable these settings at system boot, use <a href="https://man.freebsd.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;format=html">sysrc(8)</a> to add them to <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc gateway_enable=yes</span>
<span class=c># sysrc ipv6_gateway_enable=yes</span></code></pre></div></div><div class=paragraph><p>Verify with <code>ifconfig</code> that both of the interfaces are up and running.</p></div><div class=paragraph><p>Next, create the PF rules to allow the gateway to pass traffic. While the following rule allows stateful traffic to pass from the Internet to hosts on the network, the <code>to</code> keyword does not guarantee passage all the way from source to destination:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in on xl1 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>That rule only lets the traffic pass in to the gateway on the internal interface. To let the packets go further, a matching rule is needed:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out on xl0 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>While these two rules will work, rules this specific are rarely needed. For a busy network admin, a readable ruleset is a safer ruleset. The remainder of this section demonstrates how to keep the rules as simple as possible for readability. For example, those two rules could be replaced with one rule:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from xl1:network to any port $ports keep state</pre></div></div><div class=paragraph><p>The <code>interface:network</code> notation can be replaced with a macro to make the ruleset even more readable. For example, a <code>$localnet</code> macro could be defined as the network directly attached to the internal interface (<code>$xl1:network</code>). Alternatively, the definition of <code>$localnet</code> could be changed to an <em>IP address/netmask</em> notation to denote a network, such as <code>192.168.100.1/24</code> for a subnet of private addresses.</p></div><div class=paragraph><p>If required, <code>$localnet</code> could even be defined as a list of networks. Whatever the specific needs, a sensible <code>$localnet</code> definition could be used in a typical pass rule as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from $localnet to any port $ports keep state</pre></div></div><div class=paragraph><p>The following sample ruleset allows all traffic initiated by machines on the internal network. It first defines two macros to represent the external and internal 3COM interfaces of the gateway.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For dialup users, the external interface will use <span class=filename>tun0</span>. For an ADSL connection, specifically those using PPP over Ethernet (PPPoE), the correct external interface is <span class=filename>tun0</span>, not the physical Ethernet interface.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>ext_if = &#34;xl0&#34;	# macro for external interface - use tun0 for PPPoE
int_if = &#34;xl1&#34;	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</pre></div></div><div class=paragraph><p>This ruleset introduces the <code>nat</code> rule which is used to handle the network address translation from the non-routable addresses inside the internal network to the IP address assigned to the external interface. The parentheses surrounding the last part of the nat rule <code>($ext_if)</code> is included when the IP address of the external interface is dynamically assigned. It ensures that network traffic runs without serious interruptions even if the external IP address changes.</p></div><div class=paragraph><p>Note that this ruleset probably allows more traffic to pass out of the network than is needed. One reasonable setup could create this macro:</p></div><div class="literalblock programlisting"><div class=content><pre>client_out = &#34;{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }&#34;</pre></div></div><div class=paragraph><p>to use in the main pass rule:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</pre></div></div><div class=paragraph><p>A few other pass rules may be needed. This one enables SSH on the external interface:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in inet proto tcp to $ext_if port ssh</pre></div></div><div class=paragraph><p>This macro definition and rule allows DNS and NTP for internal clients:</p></div><div class="literalblock programlisting"><div class=content><pre>udp_services = &#34;{ domain, ntp }&#34;
pass quick inet proto { tcp, udp } to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Note the <code>quick</code> keyword in this rule. Since the ruleset consists of several rules, it is important to understand the relationships between the rules in a ruleset. Rules are evaluated from top to bottom, in the sequence they are written. For each packet or connection evaluated by PF, <em>the last matching rule</em> in the ruleset is the one which is applied. However, when a packet matches a rule which contains the <code>quick</code> keyword, the rule processing stops and the packet is treated according to that rule. This is very useful when an exception to the general rules is needed.</p></div></div><div class=sect4><h5 id=pftut-ftp>30.3.2.2. 建立 FTP Proxy<a class=anchor href=#pftut-ftp></a></h5><div class=paragraph><p>Configuring working FTP rules can be problematic due to the nature of the FTP protocol. FTP pre-dates firewalls by several decades and is insecure in its design. The most common points against using FTP include:</p></div><div class=ulist><ul><li><p>Passwords are transferred in the clear.</p></li><li><p>The protocol demands the use of at least two TCP connections (control and data) on separate ports.</p></li><li><p>When a session is established, data is communicated using randomly selected ports.</p></li></ul></div><div class=paragraph><p>All of these points present security challenges, even before considering any potential security weaknesses in client or server software. More secure alternatives for file transfer exist, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, which both feature authentication and data transfer over encrypted connections..</p></div><div class=paragraph><p>For those situations when FTP is required, PF provides redirection of FTP traffic to a small proxy program called <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, which is included in the base system of FreeBSD. The role of the proxy is to dynamically insert and delete rules in the ruleset, using a set of anchors, to correctly handle FTP traffic.</p></div><div class=paragraph><p>To enable the FTP proxy, add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpproxy_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then start the proxy by running <code>service ftp-proxy start</code>.</p></div><div class=paragraph><p>For a basic configuration, three elements need to be added to <span class=filename>/etc/pf.conf</span>. First, the anchors which the proxy will use to insert the rules it generates for the FTP sessions:</p></div><div class="literalblock programlisting"><div class=content><pre>nat-anchor &#34;ftp-proxy/*&#34;
rdr-anchor &#34;ftp-proxy/*&#34;</pre></div></div><div class=paragraph><p>Second, a pass rule is needed to allow FTP traffic in to the proxy.</p></div><div class=paragraph><p>Third, redirection and NAT rules need to be defined before the filtering rules. Insert this <code>rdr</code> rule immediately after the <code>nat</code> rule:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</pre></div></div><div class=paragraph><p>Finally, allow the redirected traffic to pass:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out proto tcp from $proxy to any port ftp</pre></div></div><div class=paragraph><p>where <code>$proxy</code> expands to the address the proxy daemon is bound to.</p></div><div class=paragraph><p>Save <span class=filename>/etc/pf.conf</span>, load the new rules, and verify from a client that FTP connections are working:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>This example covers a basic setup where the clients in the local network need to contact FTP servers elsewhere. This basic configuration should work well with most combinations of FTP clients and servers. As shown in <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, the proxy’s behavior can be changed in various ways by adding options to the <code>ftpproxy_flags=</code> line. Some clients or servers may have specific quirks that must be compensated for in the configuration, or there may be a need to integrate the proxy in specific ways such as assigning FTP traffic to a specific queue.</p></div><div class=paragraph><p>For ways to run an FTP server protected by PF and <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, configure a separate <code>ftp-proxy</code> in reverse mode, using <code>-R</code>, on a separate port with its own redirecting pass rule.</p></div></div><div class=sect4><h5 id=pftut-icmp>30.3.2.3. 管理 ICMP<a class=anchor href=#pftut-icmp></a></h5><div class=paragraph><p>Many of the tools used for debugging or troubleshooting a TCP/IP network rely on the Internet Control Message Protocol (ICMP), which was designed specifically with debugging in mind.</p></div><div class=paragraph><p>The ICMP protocol sends and receives <em>control messages</em> between hosts and gateways, mainly to provide feedback to a sender about any unusual or difficult conditions enroute to the target host. Routers use ICMP to negotiate packet sizes and other transmission parameters in a process often referred to as <em>path MTU discovery</em>.</p></div><div class=paragraph><p>From a firewall perspective, some ICMP control messages are vulnerable to known attack vectors. Also, letting all diagnostic traffic pass unconditionally makes debugging easier, but it also makes it easier for others to extract information about the network. For these reasons, the following rule may not be optimal:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from any to any</pre></div></div><div class=paragraph><p>One solution is to let all ICMP traffic from the local network through while stopping all probes from outside the network:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</pre></div></div><div class=paragraph><p>Additional options are available which demonstrate some of PF’s flexibility. For example, rather than allowing all ICMP messages, one can specify the messages used by <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>. Start by defining a macro for that type of message:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;echoreq&#34;</pre></div></div><div class=paragraph><p>and a rule which uses the macro:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>If other types of ICMP packets are needed, expand <code>icmp_types</code> to a list of those packet types. Type <code>more /usr/src/sbin/pfctl/pfctl_parser.c</code> to see the list of ICMP message types supported by PF. Refer to <a href=http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml>http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</a> for an explanation of each message type.</p></div><div class=paragraph><p>Since Unix <code>traceroute</code> uses UDP by default, another rule is needed to allow Unix <code>traceroute</code>:</p></div><div class="literalblock programlisting"><div class=content><pre># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</pre></div></div><div class=paragraph><p>Since <code>TRACERT.EXE</code> on Microsoft Windows systems uses ICMP echo request messages, only the first rule is needed to allow network traces from those systems. Unix <code>traceroute</code> can be instructed to use other protocols as well, and will use ICMP echo request messages if <code>-I</code> is used. Check the <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> man page for details.</p></div><div class=sect5><h6 id=pftut-pathmtudisc>30.3.2.3.1. Path MTU Discovery<a class=anchor href=#pftut-pathmtudisc></a></h6><div class=paragraph><p>Internet protocols are designed to be device independent, and one consequence of device independence is that the optimal packet size for a given connection cannot always be predicted reliably. The main constraint on packet size is the <em>Maximum Transmission Unit</em> (MTU) which sets the upper limit on the packet size for an interface. Type <code>ifconfig</code> to view the MTUs for a system’s network interfaces.</p></div><div class=paragraph><p>TCP/IP uses a process known as path MTU discovery to determine the right packet size for a connection. This process sends packets of varying sizes with the "Do not fragment" flag set, expecting an ICMP return packet of "type 3, code 4" when the upper limit has been reached. Type 3 means "destination unreachable", and code 4 is short for "fragmentation needed, but the do-not-fragment flag is set". To allow path MTU discovery in order to support connections to other MTUs, add the <code>destination unreachable</code> type to the <code>icmp_types</code> macro:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;{ echoreq, unreach }&#34;</pre></div></div><div class=paragraph><p>Since the pass rule already uses that macro, it does not need to be modified to support the new ICMP type:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>PF allows filtering on all variations of ICMP types and codes. The list of possible types and codes are documented in <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp&amp;sektion=4&amp;format=html">icmp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp6&amp;sektion=4&amp;format=html">icmp6(4)</a>.</p></div></div></div><div class=sect4><h5 id=pftut-tables>30.3.2.4. 使用 Tables<a class=anchor href=#pftut-tables></a></h5><div class=paragraph><p>Some types of data are relevant to filtering and redirection at a given time, but their definition is too long to be included in the ruleset file. PF supports the use of tables, which are defined lists that can be manipulated without needing to reload the entire ruleset, and which can provide fast lookups. Table names are always enclosed within <code>&lt; ></code>, like this:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</pre></div></div><div class=paragraph><p>In this example, the <code>192.168.2.0/24</code> network is part of the table, except for the address <code>192.168.2.5</code>, which is excluded using the <code>!</code> operator. It is also possible to load tables from files where each item is on a separate line, as seen in this example <span class=filename>/etc/clients</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.2.0/24
!192.168.2.5</pre></div></div><div class=paragraph><p>To refer to the file, define the table like this:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; persist file &#34;/etc/clients&#34;</pre></div></div><div class=paragraph><p>Once the table is defined, it can be referenced by a rule:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</pre></div></div><div class=paragraph><p>A table’s contents can be manipulated live, using <code>pfctl</code>. This example adds another network to the table:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T add 192.168.1.0/16</span></code></pre></div></div><div class=paragraph><p>Note that any changes made this way will take affect now, making them ideal for testing, but will not survive a power failure or reboot. To make the changes permanent, modify the definition of the table in the ruleset or edit the file that the table refers to. One can maintain the on-disk copy of the table using a <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> job which dumps the table’s contents to disk at regular intervals, using a command such as <code>pfctl -t clients -T show >/etc/clients</code>. Alternatively, <span class=filename>/etc/clients</span> can be updated with the in-memory table contents:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T replace -f /etc/clients</span></code></pre></div></div></div><div class=sect4><h5 id=pftut-overload>30.3.2.5. 使用 Overload Tables 保護 SSH<a class=anchor href=#pftut-overload></a></h5><div class=paragraph><p>Those who run SSH on an external interface have probably seen something like this in the authentication logs:</p></div><div class="literalblock programlisting"><div class=content><pre>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</pre></div></div><div class=paragraph><p>This is indicative of a brute force attack where somebody or some program is trying to discover the user name and password which will let them into the system.</p></div><div class=paragraph><p>If external SSH access is needed for legitimate users, changing the default port used by SSH can offer some protection. However, PF provides a more elegant solution. Pass rules can contain limits on what connecting hosts can do and violators can be banished to a table of addresses which are denied some or all access. It is even possible to drop all existing connections from machines which overreach the limits.</p></div><div class=paragraph><p>To configure this, create this table in the tables section of the ruleset:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;bruteforce&gt; persist</pre></div></div><div class=paragraph><p>Then, somewhere early in the ruleset, add rules to block brute access while allowing legitimate access:</p></div><div class="literalblock programlisting"><div class=content><pre>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn 100, max-src-conn-rate 15/5, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class=paragraph><p>The part in parentheses defines the limits and the numbers should be changed to meet local requirements. It can be read as follows:</p></div><div class=paragraph><p><code>max-src-conn</code> is the number of simultaneous connections allowed from one host.</p></div><div class=paragraph><p><code>max-src-conn-rate</code> is the rate of new connections allowed from any single host (<em>15</em>) per number of seconds (<em>5</em>).</p></div><div class=paragraph><p><code>overload &lt;bruteforce></code> means that any host which exceeds these limits gets its address added to the <code>bruteforce</code> table. The ruleset blocks all traffic from addresses in the <code>bruteforce</code> table.</p></div><div class=paragraph><p>Finally, <code>flush global</code> says that when a host reaches the limit, that all (<code>global</code>) of that host’s connections will be terminated (<code>flush</code>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>These rules will <em>not</em> block slow bruteforcers, as described in <a href=http://home.nuug.no/~peter/hailmary2013/>http://home.nuug.no/~peter/hailmary2013/</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>This example ruleset is intended mainly as an illustration. For example, if a generous number of connections in general are wanted, but the desire is to be more restrictive when it comes to ssh, supplement the rule above with something like the one below, early on in the rule set:</p></div><div class="literalblock programlisting"><div class=content><pre>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>It May Not be Necessary to Block All Overloaders</div><div class=paragraph><p>It is worth noting that the overload mechanism is a general technique which does not apply exclusively to SSH, and it is not always optimal to entirely block all traffic from offenders.</p></div><div class=paragraph><p>For example, an overload rule could be used to protect a mail service or a web service, and the overload table could be used in a rule to assign offenders to a queue with a minimal bandwidth allocation or to redirect to a specific web page.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Over time, tables will be filled by overload rules and their size will grow incrementally, taking up more memory. Sometimes an IP address that is blocked is a dynamically assigned one, which has since been assigned to a host who has a legitimate reason to communicate with hosts in the local network.</p></div><div class=paragraph><p>For situations like these, pfctl provides the ability to expire table entries. For example, this command will remove <code>&lt;bruteforce></code> table entries which have not been referenced for <code>86400</code> seconds:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t bruteforce -T expire 86400</span></code></pre></div></div><div class=paragraph><p>Similar functionality is provided by <a class=package href=https://cgit.freebsd.org/ports/tree/security/expiretable/>security/expiretable</a>, which removes table entries which have not been accessed for a specified period of time.</p></div><div class=paragraph><p>Once installed, expiretable can be run to remove <code>&lt;bruteforce></code> table entries older than a specified age. This example removes all entries older than 24 hours:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</pre></div></div></div><div class=sect4><h5 id=pftut-spamd>30.3.2.6. SPAM 防護<a class=anchor href=#pftut-spamd></a></h5><div class=paragraph><p>Not to be confused with the spamd daemon which comes bundled with spamassassin, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> can be configured with PF to provide an outer defense against SPAM. This spamd hooks into the PF configuration using a set of redirections.</p></div><div class=paragraph><p>Spammers tend to send a large number of messages, and SPAM is mainly sent from a few spammer friendly networks and a large number of hijacked machines, both of which are reported to <em>blacklists</em> fairly quickly.</p></div><div class=paragraph><p>When an SMTP connection from an address in a blacklist is received, spamd presents its banner and immediately switches to a mode where it answers SMTP traffic one byte at a time. This technique, which is intended to waste as much time as possible on the spammer’s end, is called <em>tarpitting</em>. The specific implementation which uses one byte SMTP replies is often referred to as <em>stuttering</em>.</p></div><div class=paragraph><p>This example demonstrates the basic procedure for setting up spamd with automatically updated blacklists. Refer to the man pages which are installed with <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> for more information.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configuring spamd</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Install the <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> package or port. To use spamd’s greylisting features, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> must be mounted at <span class=filename>/dev/fd</span>. Add the following line to <span class=filename>/etc/fstab</span>:</p><div class="literalblock programlisting"><div class=content><pre> fdescfs /dev/fd fdescfs rw 0 0</pre></div></div><div class=paragraph><p>Then, mount the filesystem:</p></div><div class="literalblock programlisting"><div class=content><pre># mount fdescfs</pre></div></div></li><li><p>Next, edit the PF ruleset to include:</p><div class="literalblock programlisting"><div class=content><pre>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</pre></div></div><div class=paragraph><p>The two tables <code>&lt;spamd></code> and <code>&lt;spamd-white></code> are essential. SMTP traffic from an address listed in <code>&lt;spamd></code> but not in <code>&lt;spamd-white></code> is redirected to the spamd daemon listening at port 8025.</p></div></li><li><p>The next step is to configure spamd in <span class=filename>/usr/local/etc/spamd.conf</span> and to add some <span class=filename>rc.conf</span> parameters.</p><div class=paragraph><p>The installation of <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> includes a sample configuration file (<span class=filename>/usr/local/etc/spamd.conf.sample</span>) and a man page for <span class=filename>spamd.conf</span>. Refer to these for additional configuration options beyond those shown in this example.</p></div><div class=paragraph><p>One of the first lines in the configuration file that does not begin with a <code>#</code> comment sign contains the block which defines the <code>all</code> list, which specifies the lists to use:</p></div><div class="literalblock programlisting"><div class=content><pre>all:\
    :traplist:whitelist:</pre></div></div><div class=paragraph><p>This entry adds the desired blacklists, separated by colons (<code>:</code>). To use a whitelist to subtract addresses from a blacklist, add the name of the whitelist <em>immediately</em> after the name of that blacklist. For example: <code>:blacklist:whitelist:</code>.</p></div><div class=paragraph><p>This is followed by the specified blacklist’s definition:</p></div><div class="literalblock programlisting"><div class=content><pre>traplist:\
    :black:\
    :msg=&#34;SPAM. Your address %A has sent spam within the last 24 hours&#34;:\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</pre></div></div><div class=paragraph><p>where the first line is the name of the blacklist and the second line specifies the list type. The <code>msg</code> field contains the message to display to blacklisted senders during the SMTP dialogue. The <code>method</code> field specifies how spamd-setup fetches the list data; supported methods are <code>http</code>, <code>ftp</code>, from a <code>file</code> in a mounted file system, and via <code>exec</code> of an external program. Finally, the <code>file</code> field specifies the name of the file spamd expects to receive.</p></div><div class=paragraph><p>The definition of the specified whitelist is similar, but omits the <code>msg</code> field since a message is not needed:</p></div><div class="literalblock programlisting"><div class=content><pre>whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>Choose Data Sources with Care</div><div class=paragraph><p>Using all the blacklists in the sample <span class=filename>spamd.conf</span> will blacklist large blocks of the Internet. Administrators need to edit the file to create an optimal configuration which uses applicable data sources and, when necessary, uses custom lists.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Next, add this entry to <span class=filename>/etc/rc.conf</span>. Additional flags are described in the man page specified by the comment:</p></div><div class="literalblock programlisting"><div class=content><pre>spamd_flags=&#34;-v&#34; # use &#34;&#34; and see spamd-setup(8) for flags</pre></div></div><div class=paragraph><p>When finished, reload the ruleset, start spamd by typing <code>service obspamd start</code>, and complete the configuration using <code>spamd-setup</code>. Finally, create a <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> job which calls <code>spamd-setup</code> to update the tables at reasonable intervals.</p></div></li></ol></div></div></div><div class=paragraph><p>On a typical gateway in front of a mail server, hosts will soon start getting trapped within a few seconds to several minutes.</p></div><div class=paragraph><p>PF also supports <em>greylisting</em>, which temporarily rejects messages from unknown hosts with <em>45n</em> codes. Messages from greylisted hosts which try again within a reasonable time are let through. Traffic from senders which are set up to behave within the limits set by RFC 1123 and RFC 2821 are immediately let through.</p></div><div class=paragraph><p>More information about greylisting as a technique can be found at the <a href=http://www.greylisting.org/>greylisting.org</a> web site. The most amazing thing about greylisting, apart from its simplicity, is that it still works. Spammers and malware writers have been very slow to adapt to bypass this technique.</p></div><div class=paragraph><p>The basic procedure for configuring greylisting is as follows:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configuring Greylisting</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Make sure that <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> is mounted as described in Step 1 of the previous Procedure.</p></li><li><p>To run spamd in greylisting mode, add this line to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>spamd_grey=&#34;YES&#34;  # use spamd greylisting if YES</pre></div></div><div class=paragraph><p>Refer to the spamd man page for descriptions of additional related parameters.</p></div></li><li><p>To complete the greylisting setup:</p><div class="literalblock programlisting"><div class=content><pre># service obspamd restart
# service obspamlogd start</pre></div></div></li></ol></div></div></div><div class=paragraph><p>Behind the scenes, the spamdb database tool and the spamlogd whitelist updater perform essential functions for the greylisting feature. spamdb is the administrator’s main interface to managing the black, grey, and white lists via the contents of the <span class=filename>/var/db/spamdb</span> database.</p></div></div><div class=sect4><h5 id=pftut-hygiene>30.3.2.7. 網路保健<a class=anchor href=#pftut-hygiene></a></h5><div class=paragraph><p>This section describes how <code>block-policy</code>, <code>scrub</code>, and <code>antispoof</code> can be used to make the ruleset behave sanely.</p></div><div class=paragraph><p>The <code>block-policy</code> is an option which can be set in the <code>options</code> part of the ruleset, which precedes the redirection and filtering rules. This option determines which feedback, if any, PF sends to hosts that are blocked by a rule. The option has two possible values: <code>drop</code> drops blocked packets with no feedback, and <code>return</code> returns a status code such as <code>Connection refused</code>.</p></div><div class=paragraph><p>If not set, the default policy is <code>drop</code>. To change the <code>block-policy</code>, specify the desired value:</p></div><div class="literalblock programlisting"><div class=content><pre>set block-policy return</pre></div></div><div class=paragraph><p>In PF, <code>scrub</code> is a keyword which enables network packet normalization. This process reassembles fragmented packets and drops TCP packets that have invalid flag combinations. Enabling <code>scrub</code> provides a measure of protection against certain kinds of attacks based on incorrect handling of packet fragments. A number of options are available, but the simplest form is suitable for most configurations:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all</pre></div></div><div class=paragraph><p>Some services, such as NFS, require specific fragment handling options. Refer to <a href=https://home.nuug.no/~peter/pf/en/scrub.html>https://home.nuug.no/~peter/pf/en/scrub.html</a> for more information.</p></div><div class=paragraph><p>This example reassembles fragments, clears the "do not fragment" bit, and sets the maximum segment size to 1440 bytes:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all fragment reassemble no-df max-mss 1440</pre></div></div><div class=paragraph><p>The <code>antispoof</code> mechanism protects against activity from spoofed or forged IP addresses, mainly by blocking packets appearing on interfaces and in directions which are logically not possible.</p></div><div class=paragraph><p>These rules weed out spoofed traffic coming in from the rest of the world as well as any spoofed packets which originate in the local network:</p></div><div class="literalblock programlisting"><div class=content><pre>antispoof for $ext_if
antispoof for $int_if</pre></div></div></div><div class=sect4><h5 id=pftut-unrouteables>30.3.2.8. 處理不可路由 (Non-Routable) 的位址<a class=anchor href=#pftut-unrouteables></a></h5><div class=paragraph><p>Even with a properly configured gateway to handle network address translation, one may have to compensate for other people’s misconfigurations. A common misconfiguration is to let traffic with non-routable addresses out to the Internet. Since traffic from non-routeable addresses can play a part in several DoS attack techniques, consider explicitly blocking traffic from non-routeable addresses from entering the network through the external interface.</p></div><div class=paragraph><p>In this example, a macro containing non-routable addresses is defined, then used in blocking rules. Traffic to and from these addresses is quietly dropped on the gateway’s external interface.</p></div><div class="literalblock programlisting"><div class=content><pre>martians = &#34;{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }&#34;

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</pre></div></div></div></div><div class=sect3><h4 id=_開啟_altq>30.3.3. 開啟 ALTQ<a class=anchor href=#_開啟_altq></a></h4><div class=paragraph><p>On FreeBSD, ALTQ can be used with PF to provide Quality of Service (QOS). Once ALTQ is enabled, queues can be defined in the ruleset which determine the processing priority of outbound packets.</p></div><div class=paragraph><p>Before enabling ALTQ, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> to determine if the drivers for the network cards installed on the system support it.</p></div><div class=paragraph><p>ALTQ is not available as a loadable kernel module. If the system’s interfaces support ALTQ, create a custom kernel using the instructions in <a href=./#kernelconfig>設定 FreeBSD 核心</a>. The following kernel options are available. The first is needed to enable ALTQ. At least one of the other options is necessary to specify the queueing scheduler algorithm:</p></div><div class="literalblock programlisting"><div class=content><pre>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</pre></div></div><div class=paragraph><p>The following scheduler algorithms are available:</p></div><div class=dlist><dl><dt class=hdlist1>CBQ</dt><dd><p>Class Based Queuing (CBQ) is used to divide a connection’s bandwidth into different classes or queues to prioritize traffic based on filter rules.</p></dd><dt class=hdlist1>RED</dt><dd><p>Random Early Detection (RED) is used to avoid network congestion by measuring the length of the queue and comparing it to the minimum and maximum thresholds for the queue. When the queue is over the maximum, all new packets are randomly dropped.</p></dd><dt class=hdlist1>RIO</dt><dd><p>In Random Early Detection In and Out (RIO) mode, RED maintains multiple average queue lengths and multiple threshold values, one for each QOS level.</p></dd><dt class=hdlist1>HFSC</dt><dd><p>Hierarchical Fair Service Curve Packet Scheduler (HFSC) is described in <a href=http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html>http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</a>.</p></dd><dt class=hdlist1>PRIQ</dt><dd><p>Priority Queuing (PRIQ) always passes traffic that is in a higher queue first.</p></dd></dl></div><div class=paragraph><p>More information about the scheduling algorithms and example rulesets are available at the <a href=https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html>OpenBSD’s web archive</a>.</p></div></div></div><div class=sect2><h3 id=firewalls-ipfw>30.4. IPFW<a class=anchor href=#firewalls-ipfw></a></h3><div class=paragraph><p>IPFW 是一套專為 FreeBSD 所寫的具狀態防火牆 (Stateful firewall)，它同時支援 IPv4 與 IPv6，它由數個元件組成：核心防火牆過濾規則處理器與其整合的封包計帳設施、記錄設施、NAT、<a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> 流量限制程式、轉送設施、橋接設施以及 ipstealth 設施。</p></div><div class=paragraph><p>FreeBSD 提供一個範本規則集於 <span class=filename>/etc/rc.firewall</span>，其定義了幾個常見情境會使用的防火牆類型來協助初學的使用者撰寫合適的規則集。IPFW 提供了強大的語法讓進階的使用者可以用來自訂符合環境安全性要求的規則集。</p></div><div class=paragraph><p>本節將介紹如何開啟 IPFW、規則語法的概要以及示範幾種常見情境所使用的規則集。</p></div><div class=sect3><h4 id=firewalls-ipfw-enable>30.4.1. 開啟 IPFW<a class=anchor href=#firewalls-ipfw-enable></a></h4><div class=paragraph><p>IPFW is included in the basic FreeBSD install as a kernel loadable module, meaning that a custom kernel is not needed in order to enable IPFW.</p></div><div class=paragraph><p>For those users who wish to statically compile IPFW support into a custom kernel, see <a href=#firewalls-ipfw-kernelconfig>IPFW 核心選項</a>.</p></div><div class=paragraph><p>To configure the system to enable IPFW at boot time, add <code>firewall_enable="YES"</code> to <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_enable=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>To use one of the default firewall types provided by FreeBSD, add another line which specifies the type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_type=&#34;open&#34;</span></code></pre></div></div><div class=paragraph><p>The available types are:</p></div><div class=ulist><ul><li><p><code>open</code>: passes all traffic.</p></li><li><p><code>client</code>: protects only this machine.</p></li><li><p><code>simple</code>: protects the whole network.</p></li><li><p><code>closed</code>: entirely disables IP traffic except for the loopback interface.</p></li><li><p><code>workstation</code>: protects only this machine using stateful rules.</p></li><li><p><code>UNKNOWN</code>: disables the loading of firewall rules.</p></li><li><p><span class=filename>filename</span>: full path of the file containing the firewall ruleset.</p></li></ul></div><div class=paragraph><p>If <code>firewall_type</code> is set to either <code>client</code> or <code>simple</code>, modify the default rules found in <span class=filename>/etc/rc.firewall</span> to fit the configuration of the system.</p></div><div class=paragraph><p>Note that the <code>filename</code> type is used to load a custom ruleset.</p></div><div class=paragraph><p>An alternate way to load a custom ruleset is to set the <code>firewall_script</code> variable to the absolute path of an <em>executable script</em> that includes IPFW commands. The examples used in this section assume that the <code>firewall_script</code> is set to <span class=filename>/etc/ipfw.rules</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_script=&#34;/etc/ipfw.rules&#34;</span></code></pre></div></div><div class=paragraph><p>To enable logging through <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>, include this line:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logging=&#34;YES&#34;</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Only firewall rules with the <code>log</code> option will be logged. The default rules do not include this option and it must be manually added. Therefore it is advisable that the default ruleset is edited for logging. In addition, log rotation may be desired if the logs are stored in a separate file.</p></div></td></tr></tbody></table></div><div class=paragraph><p>There is no <span class=filename>/etc/rc.conf</span> variable to set logging limits. To limit the number of times a rule is logged per connection attempt, specify the number using this line in <span class=filename>/etc/sysctl.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;net.inet.ip.fw.verbose_limit=5&#34; &gt;&gt; /etc/sysctl.conf</span></code></pre></div></div><div class=paragraph><p>To enable logging through a dedicated interface named <code>ipfw0</code>, add this line to <span class=filename>/etc/rc.conf</span> instead:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logif=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Then use tcpdump to see what is being logged:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tcpdump -t -n -i ipfw0</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>There is no overhead due to logging unless tcpdump is attached.</p></div></td></tr></tbody></table></div><div class=paragraph><p>After saving the needed edits, start the firewall. To enable logging limits now, also set the <code>sysctl</code> value specified above:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ipfw start</span>
<span class=c># sysctl net.inet.ip.fw.verbose_limit=5</span></code></pre></div></div></div><div class=sect3><h4 id=firewalls-ipfw-rules>30.4.2. IPFW 規則語法<a class=anchor href=#firewalls-ipfw-rules></a></h4><div class=paragraph><p>When a packet enters the IPFW firewall, it is compared against the first rule in the ruleset and progresses one rule at a time, moving from top to bottom in sequence. When the packet matches the selection parameters of a rule, the rule’s action is executed and the search of the ruleset terminates for that packet. This is referred to as "first match wins". If the packet does not match any of the rules, it gets caught by the mandatory IPFW default rule number 65535, which denies all packets and silently discards them. However, if the packet matches a rule that contains the <code>count</code>, <code>skipto</code>, or <code>tee</code> keywords, the search continues. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> for details on how these keywords affect rule processing.</p></div><div class=paragraph><p>When creating an IPFW rule, keywords must be written in the following order. Some keywords are mandatory while other keywords are optional. The words shown in uppercase represent a variable and the words shown in lowercase must precede the variable that follows it. The <code>#</code> symbol is used to mark the start of a comment and may appear at the end of a rule or on its own line. Blank lines are ignored.</p></div><div class=paragraph><p><em>CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT OPTIONS</em></p></div><div class=paragraph><p>This section provides an overview of these keywords and their options. It is not an exhaustive list of every possible option. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> for a complete description of the rule syntax that can be used when creating IPFW rules.</p></div><div class=dlist><dl><dt class=hdlist1>CMD</dt><dd><p>Every rule must start with <span class=parameter>ipfw add</span>.</p></dd><dt class=hdlist1>RULE_NUMBER</dt><dd><p>Each rule is associated with a number from <code>1</code> to <code>65534</code>. The number is used to indicate the order of rule processing. Multiple rules can have the same number, in which case they are applied according to the order in which they have been added.</p></dd><dt class=hdlist1>SET_NUMBER</dt><dd><p>Each rule is associated with a set number from <code>0</code> to <code>31</code>. Sets can be individually disabled or enabled, making it possible to quickly add or delete a set of rules. If a SET_NUMBER is not specified, the rule will be added to set <code>0</code>.</p></dd><dt class=hdlist1>ACTION</dt><dd><p>A rule can be associated with one of the following actions. The specified action will be executed when the packet matches the selection criterion of the rule.</p><div class=paragraph><p><span class=parameter>allow | accept | pass | permit</span>: these keywords are equivalent and allow packets that match the rule.</p></div><div class=paragraph><p><span class=parameter>check-state</span>: checks the packet against the dynamic state table. If a match is found, execute the action associated with the rule which generated this dynamic rule, otherwise move to the next rule. A <code>check-state</code> rule does not have selection criterion. If no <code>check-state</code> rule is present in the ruleset, the dynamic rules table is checked at the first <code>keep-state</code> or <code>limit</code> rule.</p></div><div class=paragraph><p><span class=parameter>count</span>: updates counters for all packets that match the rule. The search continues with the next rule.</p></div><div class=paragraph><p><span class=parameter>deny | drop</span>: either word silently discards packets that match this rule.</p></div><div class=paragraph><p>Additional actions are available. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> for details.</p></div></dd><dt class=hdlist1>LOG_AMOUNT</dt><dd><p>When a packet matches a rule with the <code>log</code> keyword, a message will be logged to <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> with a facility name of <code>SECURITY</code>. Logging only occurs if the number of packets logged for that particular rule does not exceed a specified LOG_AMOUNT. If no LOG_AMOUNT is specified, the limit is taken from the value of <code>net.inet.ip.fw.verbose_limit</code>. A value of zero removes the logging limit. Once the limit is reached, logging can be re-enabled by clearing the logging counter or the packet counter for that rule, using <code>ipfw resetlog</code>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Logging is done after all other packet matching conditions have been met, and before performing the final action on the packet. The administrator decides which rules to enable logging on.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>PROTO</dt><dd><p>This optional value can be used to specify any protocol name or number found in <span class=filename>/etc/protocols</span>.</p></dd><dt class=hdlist1>SRC</dt><dd><p>The <code>from</code> keyword must be followed by the source address or a keyword that represents the source address. An address can be represented by <code>any</code>, <code>me</code> (any address configured on an interface on this system), <code>me6</code>, (any IPv6 address configured on an interface on this system), or <code>table</code> followed by the number of a lookup table which contains a list of addresses. When specifying an IP address, it can be optionally followed by its CIDR mask or subnet mask. For example, <code>1.2.3.4/25</code> or <code>1.2.3.4:255.255.255.128</code>.</p></dd><dt class=hdlist1>SRC_PORT</dt><dd><p>An optional source port can be specified using the port number or name from <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>DST</dt><dd><p>The <code>to</code> keyword must be followed by the destination address or a keyword that represents the destination address. The same keywords and addresses described in the SRC section can be used to describe the destination.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>An optional destination port can be specified using the port number or name from <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Several keywords can follow the source and destination. As the name suggests, OPTIONS are optional. Commonly used options include <code>in</code> or <code>out</code>, which specify the direction of packet flow, <code>icmptypes</code> followed by the type of ICMP message, and <code>keep-state</code>.</p><div class=paragraph><p>When a <span class=parameter>keep-state</span> rule is matched, the firewall will create a dynamic rule which matches bidirectional traffic between the source and destination addresses and ports using the same protocol.</p></div><div class=paragraph><p>The dynamic rules facility is vulnerable to resource depletion from a SYN-flood attack which would open a huge number of dynamic rules. To counter this type of attack with IPFW, use <code>limit</code>. This option limits the number of simultaneous sessions by checking the open dynamic rules, counting the number of times this rule and IP address combination occurred. If this count is greater than the value specified by <code>limit</code>, the packet is discarded.</p></div><div class=paragraph><p>Dozens of OPTIONS are available. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> for a description of each available option.</p></div></dd></dl></div></div><div class=sect3><h4 id=_範例規則集>30.4.3. 範例規則集<a class=anchor href=#_範例規則集></a></h4><div class=paragraph><p>This section demonstrates how to create an example stateful firewall ruleset script named <span class=filename>/etc/ipfw.rules</span>. In this example, all connection rules use <code>in</code> or <code>out</code> to clarify the direction. They also use <code>via</code> <em>interface-name</em> to specify the interface the packet is traveling over.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When first creating or testing a firewall ruleset, consider temporarily setting this tunable:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.ip.fw.default_to_accept=&#34;1&#34;</pre></div></div><div class=paragraph><p>This sets the default policy of <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> to be more permissive than the default <code>deny ip from any to any</code>, making it slightly more difficult to get locked out of the system right after a reboot.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The firewall script begins by indicating that it is a Bourne shell script and flushes any existing rules. It then creates the <code>cmd</code> variable so that <code>ipfw add</code> does not have to be typed at the beginning of every rule. It also defines the <code>pif</code> variable which represents the name of the interface that is attached to the Internet.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd=&#34;ipfw -q add&#34;
pif=&#34;dc0&#34;     # interface name of NIC attached to Internet</pre></div></div><div class=paragraph><p>The first two rules allow all traffic on the trusted internal interface and on the loopback interface:</p></div><div class="literalblock programlisting"><div class=content><pre># Change xl0 to LAN NIC interface name
$cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
$cmd 00010 allow all from any to any via lo0</pre></div></div><div class=paragraph><p>The next rule allows the packet through if it matches an existing entry in the dynamic rules table:</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 00101 check-state</pre></div></div><div class=paragraph><p>The next set of rules defines which stateful connections internal systems can create to hosts on the Internet:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

# Allow access to ISP&#39;s DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
$cmd 00120 allow log udp from any to any 67 out via $pif keep-state
#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

# Allow outbound HTTP and HTTPS connections
$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state
$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

# Allow outbound email connections
$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

# Allow outbound ping
$cmd 00250 allow icmp from any to any out via $pif keep-state

# Allow outbound NTP
$cmd 00260 allow udp from any to any 123 out via $pif keep-state

# Allow outbound SSH
$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

# deny and log all other outbound connections
$cmd 00299 deny log all from any to any out via $pif</pre></div></div><div class=paragraph><p>The next set of rules controls connections from Internet hosts to the internal network. It starts by denying packets typically associated with attacks and then explicitly allows specific types of connections. All the authorized services that originate from the Internet use <code>limit</code> to prevent flooding.</p></div><div class="literalblock programlisting"><div class=content><pre># Deny all inbound traffic from non-routable reserved address spaces
$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP
$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP
$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP
$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback
$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config
$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect
$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D &amp; E multicast

# Deny public pings
$cmd 00310 deny icmp from any to any in via $pif

# Deny ident
$cmd 00315 deny tcp from any to any 113 in via $pif

# Deny all Netbios services.
$cmd 00320 deny tcp from any to any 137 in via $pif
$cmd 00321 deny tcp from any to any 138 in via $pif
$cmd 00322 deny tcp from any to any 139 in via $pif
$cmd 00323 deny tcp from any to any 81 in via $pif

# Deny fragments
$cmd 00330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 00332 deny tcp from any to any established in via $pif

# Allow traffic from ISP&#39;s DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

# Allow HTTP connections to internal web server
$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow inbound SSH connections
$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Reject and log all other incoming connections
$cmd 00499 deny log all from any to any in via $pif</pre></div></div><div class=paragraph><p>The last rule logs all packets that do not match any of the rules in the ruleset:</p></div><div class="literalblock programlisting"><div class=content><pre># Everything else is denied and logged
$cmd 00999 deny log all from any to any</pre></div></div></div><div class=sect3><h4 id=in-kernel-nat>30.4.4. 核心內 NAT<a class=anchor href=#in-kernel-nat></a></h4><div class=paragraph><p>FreeBSD’s IPFW firewall has two implementations of NAT: one being the userland <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> daemon, and the more recent IPFW’s built-in NAT facility also known as in-kernel NAT. Both work in conjunction with IPFW to provide network address translation. This can be used to provide an Internet Connection Sharing solution so that several internal computers can connect to the Internet using a single public IP address.</p></div><div class=paragraph><p>To do this, the FreeBSD machine connected to the Internet must act as a gateway. This system must have two NICs, where one is connected to the Internet and the other is connected to the internal LAN. Each machine connected to the LAN should be assigned an IP address in the private network space, as defined by <a href=https://www.ietf.org/rfc/rfc1918.txt>RFC 1918</a>.</p></div><div class=paragraph><p>Some additional configuration is needed in order to enable the in-kernel NAT function of IPFW. To enable in-kernel NAT support at boot time, the following must be set in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
firewall_enable=&#34;YES&#34;
firewall_nat_enable=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When <code>firewall_enable</code> is not set, but <code>firewall_nat_enable</code> is, it will have no effect and do nothing, because the in-kernel NAT implementation is only compatible with IPFW.</p></div></td></tr></tbody></table></div><div class=paragraph><p>When the ruleset contains stateful rules, the positioning of the NAT rule is critical and the <code>skipto</code> action is used. The <code>skipto</code> action requires a rule number so that it knows which rule to jump to. Furthermore, because of the architecture of <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a>, a library implemented as a kernel module used for the in-kernel NAT facility of IPFW, it is necessary to disable TCP segmentation offloading, or in short TSO. TSO can be disabled on a per network interface basis by using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> or on a system wide basis using <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. To disable TSO system wide, the following must be set in <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.tcp.tso=&#34;0&#34;</pre></div></div><div class=paragraph><p>The example below builds upon the firewall ruleset shown in the previous section. It adds some additional entries and modifies some existing rules in order to configure the firewall for in-kernel NAT. It starts by adding some additional variables which represent the rule number to skip to, the <code>keep-state</code> option, and a list of TCP ports which will be used to reduce the number of rules.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ipfw -q -f flush
cmd=&#34;ipfw -q add&#34;
skip=&#34;skipto 1000&#34;
pif=dc0
ks=&#34;keep-state&#34;
good_tcpo=&#34;22,25,37,53,80,443,110&#34;</pre></div></div><div class=paragraph><p>A NAT instance will also be configured. With in-kernel NAT it is possible to have multiple NAT instances each with their own configuration. Although, for this example only one NAT instance is needed; NAT instance number 1. The configuration takes a few arguments and flags such as: <code>if</code> which indicates the public interface, <code>same_ports</code> which takes care that alliased ports and local port numbers are mapped the same, <code>unreg_only</code> will result in only unregistered (private) address spaces to be processed by the NAT instance, and <code>reset</code> which will help to keep a functioning NAT instance even when the public IP address of the IPFW machine changes. For all possible options that can be passed to a single NAT instance configuration consult <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Furthermore, because of the nature of a stateful NATing firewall, it is neseccary to allow translated packets to be reinjected in the firewall for further processing, this can be achieved by disabling <code>one_pass</code> behavior at the start of the firewall script.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw disable one_pass
ipfw -q nat 1 config if $pif same_ports unreg_only reset</pre></div></div><div class=paragraph><p>The inbound NAT rule is inserted <em>after</em> the two rules which allow all traffic on the trusted and loopback interfaces and after the reassamble rule but <em>before</em> the <code>check-state</code> rule. It is important that the rule number selected for this NAT rule, in this example <code>100</code>, is higher than the first three rules and lower than the <code>check-state</code> rule. Furthermore, because of the behavior of in-kernel NAT it is advised to place a reassamble rule just before the first NAT rule and after the rules that allow traffic on trusted interface. Normally, IP fragmentation should not happen, but when dealing with IPSEC/ESP/GRE tunneling traffic it might and the reassmabling of fragments is necessary before handing the complete packet over to the in-kernel NAT engine.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The reassemble rule was not needed with userland <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> because the internal workings of the IPFW <code>divert</code> action already takes care of this automatically as also stated in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div><div class=paragraph><p>The current NAT instance number and NAT rule number does not match with the default NAT instance number and rule number created by <span class=filename>rc.firewall</span> which is a script to set up the baked-in default firewall rulesets present in FreeBSD.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>$cmd 005 allow all from any to any via xl0  # exclude LAN traffic
$cmd 010 allow all from any to any via lo0  # exclude loopback traffic
$cmd 099 reass all from any to any in       # reassamble inbound packets
$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
$cmd 101 check-state</pre></div></div><div class=paragraph><p>The outbound rules are modified to replace the <code>allow</code> action with the <code>$skip</code> variable, indicating that rule processing will continue at rule <code>1000</code>. The seven <code>tcp</code> rules have been replaced by rule <code>125</code> as the <code>$good_tcpo</code> variable contains the seven allowed outbound ports.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Remember that IPFW’s firewall performance is largely determined by the number of rules present in the ruleset.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># Authorized outbound packets
$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks
$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks
$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
$cmd 130 $skip icmp from any to any out via $pif $ks</pre></div></div><div class=paragraph><p>The inbound rules remain the same, except for the very last rule which removes the <code>via $pif</code> in order to catch both inbound and outbound rules. The NAT rule must follow this last outbound rule, must have a higher number than that last rule, and the rule number must be referenced by the <code>skipto</code> action. In this ruleset, rule number <code>1000</code> handles passing all packets to our configured instance for NAT processing. The next rule allows any packet which has undergone NAT processing to pass.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 999 deny log all from any to any
$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules
$cmd 1001 allow ip from any to any</pre></div></div><div class=paragraph><p>In this example, rules <code>100</code>, <code>101</code>, <code>125</code>, <code>1000</code>, and <code>1001</code> control the address translation of the outbound and inbound packets so that the entries in the dynamic state table always register the private LANIP address.</p></div><div class=paragraph><p>Consider an internal web browser which initializes a new outbound HTTP session over port 80. When the first outbound packet enters the firewall, it does not match rule <code>100</code> because it is headed out rather than in. It passes rule <code>101</code> because this is the first packet and it has not been posted to the dynamic state table yet. The packet finally matches rule <code>125</code> as it is outbound on an allowed port and has a source IP address from the internal LAN. On matching this rule, two actions take place. First, the <code>keep-state</code> action adds an entry to the dynamic state table and the specified action, <code>skipto rule 1000</code>, is executed. Next, the packet undergoes NAT and is sent out to the Internet. This packet makes its way to the destination web server, where a response packet is generated and sent back. This new packet enters the top of the ruleset. It matches rule <code>100</code> and has its destination IP address mapped back to the original internal address. It then is processed by the <code>check-state</code> rule, is found in the table as an existing session, and is released to the LAN.</p></div><div class=paragraph><p>On the inbound side, the ruleset has to deny bad packets and allow only authorized services. A packet which matches an inbound rule is posted to the dynamic state table and the packet is released to the LAN. The packet generated as a response is recognized by the <code>check-state</code> rule as belonging to an existing session. It is then sent to rule <code>1000</code> to undergo NAT before being released to the outbound interface.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Transition from userland <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> to in-kernel NAT might seem seamless at first but there is small catch. When using the GENERIC kernel, IPFW will load the <span class=filename>libalias.ko</span> kernel module, when <code>firewall_nat_enable</code> is enabled in <span class=filename>rc.conf</span>. Although, the loaded module only provides basic NAT functionality, whereas the userland implementation <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> has all functionality available without any extra configuration from its userland library. All functionality refers to the following kernel modules that can additionally be loaded when needed besides the standard <span class=filename>libalias.ko</span> kernel module: <span class=filename>alias_cuseeme.ko</span>, <span class=filename>alias_ftp.ko</span>, <span class=filename>alias_bbt.ko</span>, <span class=filename>skinny.ko</span>, <span class=filename>irc.ko</span>, <span class=filename>alias_pptp.ko</span> and <span class=filename>alias_smedia.ko</span> using the <code>kld_list</code> directive in <span class=filename>rc.conf</span> to mimic the full functionality of the userland implementation. If a custom kernel is used, the full functionality of the userland library can be compiled in, in the kernel, using the <code>option LIBALIAS</code>.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_port_重新導向>30.4.4.1. Port 重新導向<a class=anchor href=#_port_重新導向></a></h5><div class=paragraph><p>The drawback with NAT in general is that the LAN clients are not accessible from the Internet. Clients on the LAN can make outgoing connections to the world but cannot receive incoming ones. This presents a problem if trying to run Internet services on one of the LAN client machines. A simple way around this is to redirect selected Internet ports on the NAT providing machine to a LAN client.</p></div><div class=paragraph><p>For example, an IRC server runs on client <code>A</code> and a web server runs on client <code>B</code>. For this to work properly, connections received on ports 6667 (IRC) and 80 (HTTP) must be redirected to the respective machines.</p></div><div class=paragraph><p>With in-kernel NAT all configuration is done in the NAT instance configuration. For a full list of options that an in-kernel NAT instance can use, consult <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. The IPFW syntax follows the syntax of natd. The syntax for <code>redirect_port</code> is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port proto targetIP:targetPORT[-targetPORT]
  [aliasIP:]aliasPORT[-aliasPORT]
  [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>To configure the above example setup, the arguments should be:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>After adding these arguments to the configuration of NAT instance 1 in the above ruleset, the TCP ports will be port forwarded to the LAN client machines running the IRC and HTTP services.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw -q nat 1 config if $pif same_ports unreg_only reset \
  redirect_port tcp 192.168.0.2:6667 6667 \
  redirect_port tcp 192.1683.0.3:80 80</pre></div></div><div class=paragraph><p>Port ranges over individual ports can be indicated with <code>redirect_port</code>. For example, <em>tcp 192.168.0.2:2000-3000 2000-3000</em> would redirect all connections received on ports 2000 to 3000 to ports 2000 to 3000 on client <code>A</code>.</p></div></div><div class=sect4><h5 id=_位址重新導向>30.4.4.2. 位址重新導向<a class=anchor href=#_位址重新導向></a></h5><div class=paragraph><p>Address redirection is useful if more than one IP address is available. Each LAN client can be assigned its own external IP address by <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>, which will then rewrite outgoing packets from the LAN clients with the proper external IP address and redirects all traffic incoming on that particular IP address back to the specific LAN client. This is also known as static NAT. For example, if IP addresses <code>128.1.1.1</code>, <code>128.1.1.2</code>, and <code>128.1.1.3</code> are available, <code>128.1.1.1</code> can be used as the <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> machine’s external IP address, while <code>128.1.1.2</code> and <code>128.1.1.3</code> are forwarded back to LAN clients <code>A</code> and <code>B</code>.</p></div><div class=paragraph><p>The <code>redirect_address</code> syntax is as below, where <code>localIP</code> is the internal IP address of the LAN client, and <code>publicIP</code> the external IP address corresponding to the LAN client.</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address localIP publicIP</pre></div></div><div class=paragraph><p>In the example, the arguments would read:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address 192.168.0.2 128.1.1.2
redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p>Like <code>redirect_port</code>, these arguments are placed in a NAT instance configuration. With address redirection, there is no need for port redirection, as all data received on a particular IP address is redirected.</p></div><div class=paragraph><p>The external IP addresses on the <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> machine must be active and aliased to the external interface. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> for details.</p></div></div><div class=sect4><h5 id=_userspace_nat>30.4.4.3. Userspace NAT<a class=anchor href=#_userspace_nat></a></h5><div class=paragraph><p>Let us start with a statement: the userspace NAT implementation: <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, has more overhead than in-kernel NAT. For <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> to translate packets, the packets have to be copied from the kernel to userspace and back which brings in extra overhead that is not present with in-kernel NAT.</p></div><div class=paragraph><p>要在開機時啟動 Userspace 的 NAT daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 需在 <span class=filename>/etc/rc.conf</span> 中做以下最小設定，其中 <code>natd_interface</code> 要設成連接到網際網路的 NIC 名稱，<a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> script of <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 會自動檢查是否有使用動態 IP 位址，並且自行設定並處理。</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
natd_enable=&#34;YES&#34;
natd_interface=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>In general, the above ruleset as explained for in-kernel NAT can also be used together with <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>. The only exceptions are the configuration of the in-kernel NAT instance <code>(ipfw -q nat 1 config …​)</code> not being applicable any more, rule number 100 and 1000 will have to change sligthly as below, and reassemble rule 99 is not needed anymore as the <code>divert</code> action is used which covers fragmentation.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 100 divert natd ip from any to any in via $pif
$cmd 1000 divert natd ip from any to any out via $pif</pre></div></div><div class=paragraph><p>To configure port or address redirection, a similar syntax as with in-kernel NAT is used. Although, now, instead of specifying the configuration in our ruleset script like with in-kernel NAT, configuration of <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> is best done in a configuration file. To do this, an extra flag must be passed via <span class=filename>/etc/rc.conf</span> which specifies the path of the configuration file.</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The specified file must contain a list of configuration options, one per line. For more information about the configuration file and possible variables, consult <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>. Below are two example entries, one per line:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_address 192.168.0.3 128.1.1.3</pre></div></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=firewalls-ipfw-cmd>30.4.5. IPFW 指令<a class=anchor href=#firewalls-ipfw-cmd></a></h4><div class=paragraph><p><code>ipfw</code> can be used to make manual, single rule additions or deletions to the active firewall while it is running. The problem with using this method is that all the changes are lost when the system reboots. It is recommended to instead write all the rules in a file and to use that file to load the rules at boot time and to replace the currently running firewall rules whenever that file changes.</p></div><div class=paragraph><p><code>ipfw</code> is a useful way to display the running firewall rules to the console screen. The IPFW accounting facility dynamically creates a counter for each rule that counts each packet that matches the rule. During the process of testing a rule, listing the rule with its counter is one way to determine if the rule is functioning as expected.</p></div><div class=paragraph><p>To list all the running rules in sequence:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw list</span></code></pre></div></div><div class=paragraph><p>To list all the running rules with a time stamp of when the last time the rule was matched:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -t list</span></code></pre></div></div><div class=paragraph><p>The next example lists accounting information and the packet count for matched rules along with the rules themselves. The first column is the rule number, followed by the number of matched packets and bytes, followed by the rule itself.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -a list</span></code></pre></div></div><div class=paragraph><p>To list dynamic rules in addition to static rules:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d list</span></code></pre></div></div><div class=paragraph><p>To also show the expired dynamic rules:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d -e list</span></code></pre></div></div><div class=paragraph><p>To zero the counters:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero</span></code></pre></div></div><div class=paragraph><p>To zero the counters for just the rule with number <em>NUM</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero NUM</span></code></pre></div></div><div class=sect4><h5 id=_記錄防火牆訊息>30.4.5.1. 記錄防火牆訊息<a class=anchor href=#_記錄防火牆訊息></a></h5><div class=paragraph><p>Even with the logging facility enabled, IPFW will not generate any rule logging on its own. The firewall administrator decides which rules in the ruleset will be logged, and adds the <code>log</code> keyword to those rules. Normally only deny rules are logged. It is customary to duplicate the "ipfw default deny everything" rule with the <code>log</code> keyword included as the last rule in the ruleset. This way, it is possible to see all the packets that did not match any of the rules in the ruleset.</p></div><div class=paragraph><p>Logging is a two edged sword. If one is not careful, an over abundance of log data or a DoS attack can fill the disk with log files. Log messages are not only written to syslogd, but also are displayed on the root console screen and soon become annoying.</p></div><div class=paragraph><p>The <code>IPFIREWALL_VERBOSE_LIMIT=5</code> kernel option limits the number of consecutive messages sent to <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>, concerning the packet matching of a given rule. When this option is enabled in the kernel, the number of consecutive messages concerning a particular rule is capped at the number specified. There is nothing to be gained from 200 identical log messages. With this option set to five, five consecutive messages concerning a particular rule would be logged to syslogd and the remainder identical consecutive messages would be counted and posted to syslogd with a phrase like the following:</p></div><div class="literalblock programlisting"><div class=content><pre>last message repeated 45 times</pre></div></div><div class=paragraph><p>All logged packets messages are written by default to <span class=filename>/var/log/security</span>, which is defined in <span class=filename>/etc/syslog.conf</span>.</p></div></div><div class=sect4><h5 id=firewalls-ipfw-rules-script>30.4.5.2. 建立規則 Script<a class=anchor href=#firewalls-ipfw-rules-script></a></h5><div class=paragraph><p>Most experienced IPFW users create a file containing the rules and code them in a manner compatible with running them as a script. The major benefit of doing this is the firewall rules can be refreshed in mass without the need of rebooting the system to activate them. This method is convenient in testing new rules as the procedure can be executed as many times as needed. Being a script, symbolic substitution can be used for frequently used values to be substituted into multiple rules.</p></div><div class=paragraph><p>This example script is compatible with the syntax used by the <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> shells. Symbolic substitution fields are prefixed with a dollar sign ($). Symbolic fields do not have the $ prefix. The value to populate the symbolic field must be enclosed in double quotes ("").</p></div><div class=paragraph><p>Start the rules file like this:</p></div><div class="literalblock programlisting"><div class=content><pre>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif=&#34;tun0&#34;             # out interface
odns=&#34;192.0.2.11&#34;      # ISP&#39;s DNS server IP address
cmd=&#34;ipfw -q add &#34;     # build rule prefix
ks=&#34;keep-state&#34;        # just too lazy to key this each time
$cmd 00500 check-state
$cmd 00502 deny all from any to any frag
$cmd 00501 deny tcp from any to any established
$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
$cmd 00611 allow udp from any to $odns 53 out via $oif $ks
################### End of example ipfw rules script ############</pre></div></div><div class=paragraph><p>The rules are not important as the focus of this example is how the symbolic substitution fields are populated.</p></div><div class=paragraph><p>If the above example was in <span class=filename>/etc/ipfw.rules</span>, the rules could be reloaded by the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/ipfw.rules</span></code></pre></div></div><div class=paragraph><p><span class=filename>/etc/ipfw.rules</span> can be located anywhere and the file can have any name.</p></div><div class=paragraph><p>The same thing could be accomplished by running these commands by hand:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -q -f flush</span>
<span class=c># ipfw -q add check-state</span>
<span class=c># ipfw -q add deny all from any to any frag</span>
<span class=c># ipfw -q add deny tcp from any to any established</span>
<span class=c># ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</span></code></pre></div></div></div></div><div class=sect3><h4 id=firewalls-ipfw-kernelconfig>30.4.6. IPFW 核心選項<a class=anchor href=#firewalls-ipfw-kernelconfig></a></h4><div class=paragraph><p>In order to statically compile IPFW support into a custom kernel, refer to the instructions in <a href=./#kernelconfig>設定 FreeBSD 核心</a>. The following options are available for the custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword to syslogd(8)
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT # sets default policy to pass what is not explicitly denied
options    IPFIREWALL_NAT		# enables in-kernel NAT support
options    IPFIREWALL_NAT64		# enables in-kernel NAT64 support
options    IPFIREWALL_NPTV6		# enables in-kernel IPv6 NPT support
options    IPFIREWALL_PMOD		# enables protocols modification module support
options    IPDIVERT			# enables NAT through natd(8)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>IPFW can be loaded as a kernel module: options above are built by default as modules or can be set at runtime using tunables.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=firewalls-ipf>30.5. IPFILTER (IPF)<a class=anchor href=#firewalls-ipf></a></h3><div class=paragraph><p>IPFILTER 即為 IPF，是一套跨平台、開放源碼的防火牆，已被移植到各種作業系統，包含 FreeBSD, NetBSD, OpenBSD 與 Solaris™。</p></div><div class=paragraph><p>IPFILTER 是核心端 (Kernel-side) 的防火牆且 NAT 機制可由 Userland 的程式控制與監控，防火牆規則可以使用 ipf 設定或刪除，NAT 規則可以使用 ipnat 設定或刪除，可使用 ipfstat 來列出 IPFILTER 在核心部份的執行期統計資訊，可使用 ipmon 來記錄 IPFILTER 動作到系統記錄檔。</p></div><div class=paragraph><p>IPF 原來是以 "最後一個符合的條件優先" 的規則處理邏輯所撰寫並只能使用無狀態 (Stateless) 的規則，之後 IPF 才被加強支援快速 (<code>quick</code>) 與保留狀態 (<code>keep state</code>) 的選項。</p></div><div class=paragraph><p>IPF FAQ 位於 <a href=http://www.phildev.net/ipf/index.html>http://www.phildev.net/ipf/index.html</a>，可搜尋的 IPFilter 郵遞論壇封存資料可至 <a href="http://marc.info/?l=ipfilter">http://marc.info/?l=ipfilter</a> 取得。</p></div><div class=paragraph><p>由於 FreeBSD 也支援 IPF 因此操作手冊特別在此章節對此介紹，本節提供幾個有使用快速 (<code>quick</code>) 與保留狀態 (<code>keep state</code>) 選項的規則範例。</p></div><div class=sect3><h4 id=_開啟_ipf>30.5.1. 開啟 IPF<a class=anchor href=#_開啟_ipf></a></h4><div class=paragraph><p>IPF is included in the basic FreeBSD install as a kernel loadable module, meaning that a custom kernel is not needed in order to enable IPF.</p></div><div class=paragraph><p>For users who prefer to statically compile IPF support into a custom kernel, refer to the instructions in <a href=./#kernelconfig>設定 FreeBSD 核心</a>. The following kernel options are available:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</pre></div></div><div class=paragraph><p>where <code>options IPFILTER</code> enables support for IPFILTER, <code>options IPFILTER_LOG</code> enables IPF logging using the <span class=filename>ipl</span> packet logging pseudo-device for every rule that has the <code>log</code> keyword, <code>IPFILTER_LOOKUP</code> enables IP pools in order to speed up IP lookups, and <code>options IPFILTER_DEFAULT_BLOCK</code> changes the default behavior so that any packet not matching a firewall <code>pass</code> rule gets blocked.</p></div><div class=paragraph><p>To configure the system to enable IPF at boot time, add the following entries to <span class=filename>/etc/rc.conf</span>. These entries will also enable logging and <code>default pass all</code>. To change the default policy to <code>block all</code> without compiling a custom kernel, remember to add a <code>block all</code> rule at the end of the ruleset.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfilter_enable=&#34;YES&#34;             # Start ipf firewall
ipfilter_rules=&#34;/etc/ipf.rules&#34;   # loads rules definition text file
ipmon_enable=&#34;YES&#34;                # Start IP monitor log
ipmon_flags=&#34;-Ds&#34;                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>If NAT functionality is needed, also add these lines:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;              # Enable as LAN gateway
ipnat_enable=&#34;YES&#34;                # Start ipnat function
ipnat_rules=&#34;/etc/ipnat.rules&#34;    # rules definition file for ipnat</pre></div></div><div class=paragraph><p>Then, to start IPF now:</p></div><div class="literalblock programlisting"><div class=content><pre># service ipfilter start</pre></div></div><div class=paragraph><p>To load the firewall rules, specify the name of the ruleset file using <code>ipf</code>. The following command can be used to replace the currently running firewall rules:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipf -Fa -f /etc/ipf.rules</span></code></pre></div></div><div class=paragraph><p>where <code>-Fa</code> flushes all the internal rules tables and <code>-f</code> specifies the file containing the rules to load.</p></div><div class=paragraph><p>This provides the ability to make changes to a custom ruleset and update the running firewall with a fresh copy of the rules without having to reboot the system. This method is convenient for testing new rules as the procedure can be executed as many times as needed.</p></div><div class=paragraph><p>Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> for details on the other flags available with this command.</p></div></div><div class=sect3><h4 id=_ipf_規則語法>30.5.2. IPF 規則語法<a class=anchor href=#_ipf_規則語法></a></h4><div class=paragraph><p>This section describes the IPF rule syntax used to create stateful rules. When creating rules, keep in mind that unless the <code>quick</code> keyword appears in a rule, every rule is read in order, with the <em>last matching rule</em> being the one that is applied. This means that even if the first rule to match a packet is a <code>pass</code>, if there is a later matching rule that is a <code>block</code>, the packet will be dropped. Sample rulesets can be found in <span class=filename>/usr/shared/examples/ipfilter</span>.</p></div><div class=paragraph><p>When creating rules, a <code>#</code> character is used to mark the start of a comment and may appear at the end of a rule, to explain that rule’s function, or on its own line. Any blank lines are ignored.</p></div><div class=paragraph><p>The keywords which are used in rules must be written in a specific order, from left to right. Some keywords are mandatory while others are optional. Some keywords have sub-options which may be keywords themselves and also include more sub-options. The keyword order is as follows, where the words shown in uppercase represent a variable and the words shown in lowercase must precede the variable that follows it:</p></div><div class=paragraph><p><em>ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT TCP_FLAG|ICMP_TYPE keep state STATE</em></p></div><div class=paragraph><p>This section describes each of these keywords and their options. It is not an exhaustive list of every possible option. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for a complete description of the rule syntax that can be used when creating IPF rules and examples for using each keyword.</p></div><div class=dlist><dl><dt class=hdlist1>ACTION</dt><dd><p>The action keyword indicates what to do with the packet if it matches that rule. Every rule <em>must</em> have an action. The following actions are recognized:</p><div class=paragraph><p><code>block</code>: drops the packet.</p></div><div class=paragraph><p><code>pass</code>: allows the packet.</p></div><div class=paragraph><p><code>log</code>: generates a log record.</p></div><div class=paragraph><p><code>count</code>: counts the number of packets and bytes which can provide an indication of how often a rule is used.</p></div><div class=paragraph><p><code>auth</code>: queues the packet for further processing by another program.</p></div><div class=paragraph><p><code>call</code>: provides access to functions built into IPF that allow more complex actions.</p></div><div class=paragraph><p><code>decapsulate</code>: removes any headers in order to process the contents of the packet.</p></div></dd><dt class=hdlist1>DIRECTION</dt><dd><p>Next, each rule must explicitly state the direction of traffic using one of these keywords:</p><div class=paragraph><p><code>in</code>: the rule is applied against an inbound packet.</p></div><div class=paragraph><p><code>out</code>: the rule is applied against an outbound packet.</p></div><div class=paragraph><p><code>all</code>: the rule applies to either direction.</p></div><div class=paragraph><p>If the system has multiple interfaces, the interface can be specified along with the direction. An example would be <code>in on fxp0</code>.</p></div></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Options are optional. However, if multiple options are specified, they must be used in the order shown here.</p><div class=paragraph><p><code>log</code>: when performing the specified ACTION, the contents of the packet’s headers will be written to the <a href="https://man.freebsd.org/cgi/man.cgi?query=ipl&amp;sektion=4&amp;format=html">ipl(4)</a> packet log pseudo-device.</p></div><div class=paragraph><p><code>quick</code>: if a packet matches this rule, the ACTION specified by the rule occurs and no further processing of any following rules will occur for this packet.</p></div><div class=paragraph><p><code>on</code>: must be followed by the interface name as displayed by <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. The rule will only match if the packet is going through the specified interface in the specified direction.</p></div><div class=paragraph><p>When using the <code>log</code> keyword, the following qualifiers may be used in this order:</p></div><div class=paragraph><p><code>body</code>: indicates that the first 128 bytes of the packet contents will be logged after the headers.</p></div><div class=paragraph><p><code>first</code>: if the <code>log</code> keyword is being used in conjunction with a <code>keep state</code> option, this option is recommended so that only the triggering packet is logged and not every packet which matches the stateful connection.</p></div><div class=paragraph><p>Additional options are available to specify error return messages. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for more details.</p></div></dd><dt class=hdlist1>PROTO_TYPE</dt><dd><p>The protocol type is optional. However, it is mandatory if the rule needs to specify a SRC_PORT or a DST_PORT as it defines the type of protocol. When specifying the type of protocol, use the <code>proto</code> keyword followed by either a protocol number or name from <span class=filename>/etc/protocols</span>. Example protocol names include <code>tcp</code>, <code>udp</code>, or <code>icmp</code>. If PROTO_TYPE is specified but no SRC_PORT or DST_PORT is specified, all port numbers for that protocol will match that rule.</p></dd><dt class=hdlist1>SRC_ADDR</dt><dd><p>The <code>from</code> keyword is mandatory and is followed by a keyword which represents the source of the packet. The source can be a hostname, an IP address followed by the CIDR mask, an address pool, or the keyword <code>all</code>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for examples.</p><div class=paragraph><p>There is no way to match ranges of IP addresses which do not express themselves easily using the dotted numeric form / mask-length notation. The <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/ipcalc/>net-mgmt/ipcalc</a> package or port may be used to ease the calculation of the CIDR mask. Additional information is available at the utility’s web page: <a href=http://jodies.de/ipcalc>http://jodies.de/ipcalc</a>.</p></div></dd><dt class=hdlist1>SRC_PORT</dt><dd><p>The port number of the source is optional. However, if it is used, it requires PROTO_TYPE to be first defined in the rule. The port number must also be preceded by the <code>proto</code> keyword.</p><div class=paragraph><p>A number of different comparison operators are supported: <code>=</code> (equal to), <code>!=</code> (not equal to), <code>&lt;</code> (less than), <code>></code> (greater than), <code>⇐</code> (less than or equal to), and <code>>=</code> (greater than or equal to).</p></div><div class=paragraph><p>To specify port ranges, place the two port numbers between <code>&lt;></code> (less than and greater than ), <code>>&lt;</code> (greater than and less than ), or <code>:</code> (greater than or equal to and less than or equal to).</p></div></dd><dt class=hdlist1>DST_ADDR</dt><dd><p>The <code>to</code> keyword is mandatory and is followed by a keyword which represents the destination of the packet. Similar to SRC_ADDR, it can be a hostname, an IP address followed by the CIDR mask, an address pool, or the keyword <code>all</code>.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>Similar to SRC_PORT, the port number of the destination is optional. However, if it is used, it requires PROTO_TYPE to be first defined in the rule. The port number must also be preceded by the <code>proto</code> keyword.</p></dd><dt class=hdlist1>TCP_FLAG|ICMP_TYPE</dt><dd><p>If <code>tcp</code> is specified as the PROTO_TYPE, flags can be specified as letters, where each letter represents one of the possible TCP flags used to determine the state of a connection. Possible values are: <code>S</code> (SYN), <code>A</code> (ACK), <code>P</code> (PSH), <code>F</code> (FIN), <code>U</code> (URG), <code>R</code> (RST), <code>C</code> (CWN), and <code>E</code> (ECN).</p><div class=paragraph><p>If <code>icmp</code> is specified as the PROTO_TYPE, the ICMP type to match can be specified. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for the allowable types.</p></div></dd><dt class=hdlist1>STATE</dt><dd><p>If a <code>pass</code> rule contains <code>keep state</code>, IPF will add an entry to its dynamic state table and allow subsequent packets that match the connection. IPF can track state for TCP, UDP, and ICMP sessions. Any packet that IPF can be certain is part of an active session, even if it is a different protocol, will be allowed.</p><div class=paragraph><p>In IPF, packets destined to go out through the interface connected to the public Internet are first checked against the dynamic state table. If the packet matches the next expected packet comprising an active session conversation, it exits the firewall and the state of the session conversation flow is updated in the dynamic state table. Packets that do not belong to an already active session are checked against the outbound ruleset. Packets coming in from the interface connected to the public Internet are first checked against the dynamic state table. If the packet matches the next expected packet comprising an active session, it exits the firewall and the state of the session conversation flow is updated in the dynamic state table. Packets that do not belong to an already active session are checked against the inbound ruleset.</p></div><div class=paragraph><p>Several keywords can be added after <code>keep state</code>. If used, these keywords set various options that control stateful filtering, such as setting connection limits or connection age. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for the list of available options and their descriptions.</p></div></dd></dl></div></div><div class=sect3><h4 id=_範例規則集_2>30.5.3. 範例規則集<a class=anchor href=#_範例規則集_2></a></h4><div class=paragraph><p>This section demonstrates how to create an example ruleset which only allows services matching <code>pass</code> rules and blocks all others.</p></div><div class=paragraph><p>FreeBSD uses the loopback interface (<span class=filename>lo0</span>) and the IP address <code>127.0.0.1</code> for internal communication. The firewall ruleset must contain rules to allow free movement of these internally used packets:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on loopback interface
pass in quick on lo0 all
pass out quick on lo0 all</pre></div></div><div class=paragraph><p>The public interface connected to the Internet is used to authorize and control access of all outbound and inbound connections. If one or more interfaces are cabled to private networks, those internal interfaces may require rules to allow packets originating from the LAN to flow between the internal networks or to the interface attached to the Internet. The ruleset should be organized into three major sections: any trusted internal interfaces, outbound connections through the public interface, and inbound connections through the public interface.</p></div><div class=paragraph><p>These two rules allow all traffic to pass through a trusted LAN interface named <span class=filename>xl0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all</pre></div></div><div class=paragraph><p>The rules for the public interface’s outbound and inbound sections should have the most frequently matched rules placed before less commonly matched rules, with the last rule in the section blocking and logging all packets for that interface and direction.</p></div><div class=paragraph><p>This set of rules defines the outbound section of the public interface named <span class=filename>dc0</span>. These rules keep state and identify the specific services that internal systems are authorized for public Internet access. All the rules use <code>quick</code> and specify the appropriate port numbers and, where applicable, destination addresses.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x. with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x. port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow access to ISP&#39;s specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all</pre></div></div><div class=paragraph><p>This example of the rules in the inbound section of the public interface blocks all undesirable packets first. This reduces the number of packets that are logged by the last rule.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81</pre></div></div><div class=paragraph><p>Any time there are logged messages on a rule with the <code>log first</code> option, run <code>ipfstat -hio</code> to evaluate how many times the rule has been matched. A large number of matches may indicate that the system is under attack.</p></div><div class=paragraph><p>The rest of the rules in the inbound section define which connections are allowed to be initiated from the Internet. The last rule denies all connections which were not explicitly allowed by previous rules in this section.</p></div><div class="literalblock programlisting"><div class=content><pre># Allow traffic in from ISP&#39;s DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all</pre></div></div></div><div class=sect3><h4 id=_設定_nat>30.5.4. 設定 NAT<a class=anchor href=#_設定_nat></a></h4><div class=paragraph><p>To enable NAT, add these statements to <span class=filename>/etc/rc.conf</span> and specify the name of the file containing the NAT rules:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
ipnat_enable=&#34;YES&#34;
ipnat_rules=&#34;/etc/ipnat.rules&#34;</pre></div></div><div class=paragraph><p>NAT rules are flexible and can accomplish many different things to fit the needs of both commercial and home users. The rule syntax presented here has been simplified to demonstrate common usage. For a complete rule syntax description, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipnat&amp;sektion=5&amp;format=html">ipnat(5)</a>.</p></div><div class=paragraph><p>The basic syntax for a NAT rule is as follows, where <code>map</code> starts the rule and <em>IF</em> should be replaced with the name of the external interface:</p></div><div class="literalblock programlisting"><div class=content><pre>map IF LAN_IP_RANGE -&gt; PUBLIC_ADDRESS</pre></div></div><div class=paragraph><p>The <em>LAN_IP_RANGE</em> is the range of IP addresses used by internal clients. Usually, it is a private address range such as <code>192.168.1.0/24</code>. The <em>PUBLIC_ADDRESS</em> can either be the static external IP address or the keyword <code>0/32</code> which represents the IP address assigned to <em>IF</em>.</p></div><div class=paragraph><p>In IPF, when a packet arrives at the firewall from the LAN with a public destination, it first passes through the outbound rules of the firewall ruleset. Then, the packet is passed to the NAT ruleset which is read from the top down, where the first matching rule wins. IPF tests each NAT rule against the packet’s interface name and source IP address. When a packet’s interface name matches a NAT rule, the packet’s source IP address in the private LAN is checked to see if it falls within the IP address range specified in <em>LAN_IP_RANGE</em>. On a match, the packet has its source IP address rewritten with the public IP address specified by <em>PUBLIC_ADDRESS</em>. IPF posts an entry in its internal NAT table so that when the packet returns from the Internet, it can be mapped back to its original private IP address before being passed to the firewall rules for further processing.</p></div><div class=paragraph><p>For networks that have large numbers of internal systems or multiple subnets, the process of funneling every private IP address into a single public IP address becomes a resource problem. Two methods are available to relieve this issue.</p></div><div class=paragraph><p>The first method is to assign a range of ports to use as source ports. By adding the <code>portmap</code> keyword, NAT can be directed to only use source ports in the specified range:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</pre></div></div><div class=paragraph><p>Alternately, use the <code>auto</code> keyword which tells NAT to determine the ports that are available for use:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</pre></div></div><div class=paragraph><p>The second method is to use a pool of public addresses. This is useful when there are too many LAN addresses to fit into a single public address and a block of public IP addresses is available. These public addresses can be used as a pool from which NAT selects an IP address as a packet’s address is mapped on its way out.</p></div><div class=paragraph><p>The range of public IP addresses can be specified using a netmask or CIDR notation. These two rules are equivalent:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</pre></div></div><div class=paragraph><p>A common practice is to have a publically accessible web server or mail server segregated to an internal network segment. The traffic from these servers still has to undergo NAT, but port redirection is needed to direct inbound traffic to the correct server. For example, to map a web server using the internal address <code>10.0.10.25</code> to its public IP address of <code>20.20.20.5</code>, use this rule:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>If it is the only web server, this rule would also work as it redirects all external HTTP requests to <code>10.0.10.25</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>IPF has a built in FTP proxy which can be used with NAT. It monitors all outbound traffic for active or passive FTP connection requests and dynamically creates temporary filter rules containing the port number used by the FTP data channel. This eliminates the need to open large ranges of high order ports for FTP connections.</p></div><div class=paragraph><p>In this example, the first rule calls the proxy for outbound FTP traffic from the internal LAN. The second rule passes the FTP traffic from the firewall to the Internet, and the third rule handles all non-FTP traffic from the internal LAN:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -&gt; 0/32</pre></div></div><div class=paragraph><p>The FTP <code>map</code> rules go before the NAT rule so that when a packet matches an FTP rule, the FTP proxy creates temporary filter rules to let the FTP session packets pass and undergo NAT. All LAN packets that are not FTP will not match the FTP rules but will undergo NAT if they match the third rule.</p></div><div class=paragraph><p>Without the FTP proxy, the following firewall rules would instead be needed. Note that without the proxy, all ports above <code>1024</code> need to be allowed:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</pre></div></div><div class=paragraph><p>Whenever the file containing the NAT rules is edited, run <code>ipnat</code> with <code>-CF</code> to delete the current NAT rules and flush the contents of the dynamic translation table. Include <code>-f</code> and specify the name of the NAT ruleset to load:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -CF -f /etc/ipnat.rules</span></code></pre></div></div><div class=paragraph><p>To display the NAT statistics:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -s</span></code></pre></div></div><div class=paragraph><p>To list the NAT table’s current mappings:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -l</span></code></pre></div></div><div class=paragraph><p>To turn verbose mode on and display information relating to rule processing and active rules and table entries:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -v</span></code></pre></div></div></div><div class=sect3><h4 id=_檢視_ipf_統計資訊>30.5.5. 檢視 IPF 統計資訊<a class=anchor href=#_檢視_ipf_統計資訊></a></h4><div class=paragraph><p>IPF includes <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> which can be used to retrieve and display statistics which are gathered as packets match rules as they go through the firewall. Statistics are accumulated since the firewall was last started or since the last time they were reset to zero using <code>ipf -Z</code>.</p></div><div class=paragraph><p>The default <code>ipfstat</code> output looks like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 0 lost 0
 fragment state<span class=o>(</span>out<span class=o>)</span>: kept 0 lost 0
 packet state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 169364 lost 0
 packet state<span class=o>(</span>out<span class=o>)</span>: kept 431395 lost 0
 ICMP replies: 0 TCP RSTs sent: 0
 Result cache hits<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 1215208 <span class=o>(</span>out<span class=o>)</span>: 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 TCP <span class=nb>cksum </span>fails<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 0 <span class=o>(</span>out<span class=o>)</span>: 0
 Packet log flags <span class=nb>set</span>: <span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Several options are available. When supplied with either <code>-i</code> for inbound or <code>-o</code> for outbound, the command will retrieve and display the appropriate list of filter rules currently installed and in use by the kernel. To also see the rule numbers, include <code>-n</code>. For example, <code>ipfstat -on</code> displays the outbound rules table with rule numbers:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Include <code>-h</code> to prefix each rule with a count of how many times the rule was matched. For example, <code>ipfstat -oh</code> displays the outbound internal rules table, prefixing each rule with its usage count:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>To display the state table in a format similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>, use <code>ipfstat -t</code>. When the firewall is under attack, this option provides the ability to identify and see the attacking packets. The optional sub-flags give the ability to select the destination or source IP, port, or protocol to be monitored in real time. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> for details.</p></div></div><div class=sect3><h4 id=_ipf_日誌>30.5.6. IPF 日誌<a class=anchor href=#_ipf_日誌></a></h4><div class=paragraph><p>IPF provides <code>ipmon</code>, which can be used to write the firewall’s logging information in a human readable format. It requires that <code>options IPFILTER_LOG</code> be first added to a custom kernel using the instructions in <a href=./#kernelconfig>設定 FreeBSD 核心</a>.</p></div><div class=paragraph><p>This command is typically run in daemon mode in order to provide a continuous system log file so that logging of past events may be reviewed. Since FreeBSD has a built in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> facility to automatically rotate system logs, the default <span class=filename>rc.conf</span><code>ipmon_flags</code> statement uses <code>-Ds</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipmon_flags=&#34;-Ds&#34; # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>Logging provides the ability to review, after the fact, information such as which packets were dropped, what addresses they came from, and where they were going. This information is useful in tracking down attackers.</p></div><div class=paragraph><p>Once the logging facility is enabled in <span class=filename>rc.conf</span> and started with <code>service ipmon start</code>, IPF will only log the rules which contain the <code>log</code> keyword. The firewall administrator decides which rules in the ruleset should be logged and normally only deny rules are logged. It is customary to include the <code>log</code> keyword in the last rule in the ruleset. This makes it possible to see all the packets that did not match any of the rules in the ruleset.</p></div><div class=paragraph><p>By default, <code>ipmon -Ds</code> mode uses <code>local0</code> as the logging facility. The following logging levels can be used to further segregate the logged data:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>LOG_INFO - packets logged using the <span class=s2>&#34;log&#34;</span> keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header</code></pre></div></div><div class=paragraph><p>In order to setup IPF to log all data to <span class=filename>/var/log/ipfilter.log</span>, first create the empty file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/ipfilter.log</span></code></pre></div></div><div class=paragraph><p>Then, to write all logged messages to the specified file, add the following statement to <span class=filename>/etc/syslog.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>local0.* /var/log/ipfilter.log</pre></div></div><div class=paragraph><p>To activate the changes and instruct <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> to read the modified <span class=filename>/etc/syslog.conf</span>, run <code>service syslogd reload</code>.</p></div><div class=paragraph><p>Do not forget to edit <span class=filename>/etc/newsyslog.conf</span> to rotate the new log file.</p></div><div class=paragraph><p>Messages generated by <code>ipmon</code> consist of data fields separated by white space. Fields common to all messages are:</p></div><div class="olist arabic"><ol class=arabic><li><p>The date of packet receipt.</p></li><li><p>The time of packet receipt. This is in the form HH:MM:SS.F, for hours, minutes, seconds, and fractions of a second.</p></li><li><p>The name of the interface that processed the packet.</p></li><li><p>The group and rule number of the rule in the format <code>@0:17</code>.</p></li><li><p>The action: <code>p</code> for passed, <code>b</code> for blocked, <code>S</code> for a short packet, <code>n</code> did not match any rules, and <code>L</code> for a log rule.</p></li><li><p>The addresses written as three fields: the source address and port separated by a comma, the → symbol, and the destination address and port. For example: <code>209.53.17.22,80 → 198.73.220.17,1722</code>.</p></li><li><p><code>PR</code> followed by the protocol name or number: for example, <code>PR tcp</code>.</p></li><li><p><code>len</code> followed by the header length and total length of the packet: for example, <code>len 20 40</code>.</p></li></ol></div><div class=paragraph><p>If the packet is a TCP packet, there will be an additional field starting with a hyphen followed by letters corresponding to any flags that were set. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for a list of letters and their flags.</p></div><div class=paragraph><p>If the packet is an ICMP packet, there will be two fields at the end: the first always being "icmp" and the next being the ICMP message and sub-message type, separated by a slash. For example: <code>icmp 3/3</code> for a port unreachable message.</p></div></div></div><div class=sect2><h3 id=firewalls-blacklistd>30.6. Blacklistd<a class=anchor href=#firewalls-blacklistd></a></h3><div class=paragraph><p>Blacklistd is a daemon listening to sockets to receive notifications from other daemons about connection attempts that failed or were successful. It is most widely used in blocking too many connection attempts on open ports. A prime example is SSH running on the internet getting a lot of requests from bots or scripts trying to guess passwords and gain access. Using blacklistd, the daemon can notify the firewall to create a filter rule to block excessive connection attempts from a single source after a number of tries. Blacklistd was first developed on NetBSD and appeared there in version 7. FreeBSD 11 imported blacklistd from NetBSD.</p></div><div class=paragraph><p>This chapter describes how to set up blacklistd, configure it, and provides examples on how to use it. Readers should be familiar with basic firewall concepts like rules. For details, refer to the firewall chapter. PF is used in the examples, but other firewalls available on FreeBSD should be able to work with blacklistd, too.</p></div><div class=sect3><h4 id=_開啟_blacklistd>30.6.1. 開啟 Blacklistd<a class=anchor href=#_開啟_blacklistd></a></h4><div class=paragraph><p>The main configuration for blacklistd is stored in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a>. Various command line options are also available to change blacklistd’s run-time behavior. Persistent configuration across reboots should be stored in <span class=filename>/etc/blacklistd.conf</span>. To enable the daemon during system boot, add a <code>blacklistd_enable</code> line to <span class=filename>/etc/rc.conf</span> like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc blacklistd_enable=yes</span></code></pre></div></div><div class=paragraph><p>To start the service manually, run this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service blacklistd start</span></code></pre></div></div></div><div class=sect3><h4 id=_建立_blacklistd_規則集>30.6.2. 建立 Blacklistd 規則集<a class=anchor href=#_建立_blacklistd_規則集></a></h4><div class=paragraph><p>Rules for blacklistd are configured in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> with one entry per line. Each rule contains a tuple separated by spaces or tabs. Rules either belong to a <code>local</code> or a <code>remote</code>, which applies to the machine where blacklistd is running or an outside source, respectively.</p></div><div class=sect4><h5 id=_本地規則>30.6.2.1. 本地規則<a class=anchor href=#_本地規則></a></h5><div class=paragraph><p>An example blacklistd.conf entry for a local rule looks like this:</p></div><div class="literalblock programlisting"><div class=content><pre>[local]
ssh             stream  *       *               *       3       24h</pre></div></div><div class=paragraph><p>All rules that follow the <code>[local]</code> section are treated as local rules (which is the default), applying to the local machine. When a <code>[remote]</code> section is encountered, all rules that follow it are handled as remote machine rules.</p></div><div class=paragraph><p>Seven fields define a rule separated by either tabs or spaces. The first four fields identify the traffic that should be blacklisted. The three fields that follow define backlistd’s behavior. Wildcards are denoted as asterisks (<code>*</code>), matching anything in this field. The first field defines the location. In local rules, these are the network ports. The syntax for the location field is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>[address|interface][/mask][:port]</pre></div></div><div class=paragraph><p>Adressses can be specified as IPv4 in numeric format or IPv6 in square brackets. An interface name like <code><em>em0</em></code> can also be used.</p></div><div class=paragraph><p>The socket type is defined by the second field. TCP sockets are of type <code>stream</code>, whereas UDP is denoted as <code>dgram</code>. The example above uses TCP, since SSH is using that protocol.</p></div><div class=paragraph><p>A protocol can be used in the third field of a blacklistd rule. The following protocols can be used: <code>tcp</code>, <code>udp</code>, <code>tcp6</code>, <code>udp6</code>, or numeric. A wildcard, like in the example, is typically used to match all protocols unless there is a reason to distinguish traffic by a certain protocol.</p></div><div class=paragraph><p>In the fourth field, the effective user or owner of the daemon process that is reporting the event is defined. The username or UID can be used here, as well as a wildcard (see example rule above).</p></div><div class=paragraph><p>The packet filter rule name is declared by the fifth field, which starts the behavior part of the rule. By default, blacklistd puts all blocks under a pf anchor called <code>blacklistd</code> in <span class=filename>pf.conf</span> like this:</p></div><div class="literalblock programlisting"><div class=content><pre>anchor &#34;blacklistd/*&#34; in on $ext_if
block in
pass out</pre></div></div><div class=paragraph><p>For separate blacklists, an anchor name can be used in this field. In other cases, the wildcard will suffice. When a name starts with a hyphen (<code>-</code>) it means that an anchor with the default rule name prepended should be used. A modified example from the above using the hyphen would look like this:</p></div><div class="literalblock programlisting"><div class=content><pre>ssh             stream  *       *               -ssh       3       24h</pre></div></div><div class=paragraph><p>With such a rule, any new blacklist rules are added to an anchor called <code>blacklistd-ssh</code>.</p></div><div class=paragraph><p>To block whole subnets for a single rule violation, a <code>/</code> in the rule name can be used. This causes the remaining portion of the name to be interpreted as the mask to be applied to the address specified in the rule. For example, this rule would block every address adjoining <code>/24</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>22              stream  tcp       *               */24    3       24h</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is important to specify the proper protocol here. IPv4 and IPv6 treat /24 differently, that is the reason why <code>*</code> cannot be used in the third field for this rule.</p></div></td></tr></tbody></table></div><div class=paragraph><p>This rule defines that if any one host in that network is misbehaving, everything else on that network will be blocked, too.</p></div><div class=paragraph><p>The sixth field, called <code>nfail</code>, sets the number of login failures required to blacklist the remote IP in question. When a wildcard is used at this position, it means that blocks will never happen. In the example rule above, a limit of three is defined meaning that after three attempts to log into SSH on one connection, the IP is blocked.</p></div><div class=paragraph><p>The last field in a blacklistd rule definition specifies how long a host is blacklisted. The default unit is seconds, but suffixes like <code>m</code>, <code>h</code>, and <code>d</code> can also be specified for minutes, hours, and days, respectively.</p></div><div class=paragraph><p>The example rule in its entirety means that after three times authenticating to SSH will result in a new PF block rule for that host. Rule matches are performed by first checking local rules one after another, from most specific to least specific. When a match occurs, the <code>remote</code> rules are applied and the name, <code>nfail</code>, and disable fields are changed by the <code>remote</code> rule that matched.</p></div></div><div class=sect4><h5 id=_遠端規則>30.6.2.2. 遠端規則<a class=anchor href=#_遠端規則></a></h5><div class=paragraph><p>Remote rules are used to specify how blacklistd changes its behavior depending on the remote host currently being evaluated. Each field in a remote rule is the same as in a local rule. The only difference is in the way blacklistd is using them. To explain it, this example rule is used:</p></div><div class="literalblock programlisting"><div class=content><pre>[remote]
203.0.113.128/25 *      *       *               =/25    =       48h</pre></div></div><div class=paragraph><p>The address field can be an IP address (either v4 or v6), a port or both. This allows setting special rules for a specific remote address range like in this example. The fields for type, protocol and owner are identically interpreted as in the local rule.</p></div><div class=paragraph><p>The name fields is different though: the equal sign (<code>=</code>) in a remote rule tells blacklistd to use the value from the matching local rule. It means that the firewall rule entry is taken and the <code>/25</code> prefix (a netmask of <code>255.255.255.128</code>) is added. When a connection from that address range is blacklisted, the entire subnet is affected. A PF anchor name can also be used here, in which case blacklistd will add rules for this address block to the anchor of that name. The default table is used when a wildcard is specified.</p></div><div class=paragraph><p>A custom number of failures in the <code>nfail</code> column can be defined for an address. This is useful for exceptions to a specific rule, to maybe allow someone a less strict application of rules or a bit more leniency in login tries. Blocking is disabled when an asterisk is used in this sixth field.</p></div><div class=paragraph><p>Remote rules allow a stricter enforcement of limits on attempts to log in compared to attempts coming from a local network like an office.</p></div></div></div><div class=sect3><h4 id=_blacklistd_客戶端設定>30.6.3. Blacklistd 客戶端設定<a class=anchor href=#_blacklistd_客戶端設定></a></h4><div class=paragraph><p>There are a few software packages in FreeBSD that can utilize blacklistd’s functionality. The two most prominent ones are <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> to block excessive connection attempts. To activate blacklistd in the SSH daemon, add the following line to <span class=filename>/etc/ssh/sshd_config</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>UseBlacklist yes</pre></div></div><div class=paragraph><p>接著重新啟動 sshd 來使變更生效。</p></div><div class=paragraph><p>Blacklisting for <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> is enabled using <code>-B</code>, either in <span class=filename>/etc/inetd.conf</span> or as a flag in <span class=filename>/etc/rc.conf</span> like this:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpd_flags=&#34;-B&#34;</pre></div></div><div class=paragraph><p>That is all that is needed to make these programs talk to blacklistd.</p></div></div><div class=sect3><h4 id=_blacklistd_管理>30.6.4. Blacklistd 管理<a class=anchor href=#_blacklistd_管理></a></h4><div class=paragraph><p>Blacklistd provides the user with a management utility called <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistctl&amp;sektion=8&amp;format=html">blacklistctl(8)</a>. It displays blocked addresses and networks that are blacklisted by the rules defined in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a>. To see the list of currently blocked hosts, use <code>dump</code> combined with <code>-b</code> like this.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -b</span>
      address/ma:port <span class=nb>id      </span>nfail   last access
213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19</code></pre></div></div><div class=paragraph><p>This example shows that there were 6 out of three permitted attempts on port 22 coming from the address range <code>213.0.123.128/25</code>. There are more attempts listed than are allowed because SSH allows a client to try multiple logins on a single TCP connection. A connection that is currently going on is not stopped by blacklistd. The last connection attempt is listed in the <code>last access</code> column of the output.</p></div><div class=paragraph><p>To see the remaining time that this host will be on the blacklist, add <code>-r</code> to the previous command.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -br</span>
      address/ma:port <span class=nb>id      </span>nfail   remaining <span class=nb>time
</span>213.0.123.128/25:22   OK      6/3     36s</code></pre></div></div><div class=paragraph><p>In this example, there are 36s seconds left until this host will not be blocked any more.</p></div></div><div class=sect3><h4 id=_從封鎖清單移除主機>30.6.5. 從封鎖清單移除主機<a class=anchor href=#_從封鎖清單移除主機></a></h4><div class=paragraph><p>Sometimes it is necessary to remove a host from the block list before the remaining time expires. Unfortunately, there is no functionality in blacklistd to do that. However, it is possible to remove the address from the PF table using pfctl. For each blocked port, there is a child anchor inside the blacklistd anchor defined in <span class=filename>/etc/pf.conf</span>. For example, if there is a child anchor for blocking port 22 it is called <code>blacklistd/22</code>. There is a table inside that child anchor that contains the blocked addresses. This table is called port followed by the port number. In this example, it would be called <code>port22</code>. With that information at hand, it is now possible to use <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> to display all addresses listed like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -t port22 -T show</span>
...
213.0.123.128/25
...</code></pre></div></div><div class=paragraph><p>After identifying the address to be unblocked from the list, the following command removes it from the list:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -T delete 213.0.123.128/25</span></code></pre></div></div><div class=paragraph><p>The address is now removed from PF, but will still show up in the blacklistctl list, since it does not know about any changes made in PF. The entry in blacklistd’s database will eventually expire and be removed from its output eventually. The entry will be added again if the host is matching one of the block rules in blacklistd again.</p></div></div></div></div></div><div class=sect1><h2 id=advanced-networking>Chapter 31. 進階網路設定<a class=anchor href=#advanced-networking></a></h2><div class=sectionbody><div class=sect2><h3 id=advanced-networking-synopsis>31.1. 概述<a class=anchor href=#advanced-networking-synopsis></a></h3><div class=paragraph><p>This chapter covers a number of advanced networking topics.</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>The basics of gateways and routes.</p></li><li><p>How to set up USB tethering.</p></li><li><p>How to set up IEEE™ 802.11 and Bluetooth™ devices.</p></li><li><p>How to make FreeBSD act as a bridge.</p></li><li><p>How to set up network PXE booting.</p></li><li><p>How to set up IPv6 on a FreeBSD machine.</p></li><li><p>How to enable and utilize the features of the Common Address Redundancy Protocol (CARP) in FreeBSD.</p></li><li><p>如何在 FreeBSD 上設定多個 VLAN。</p></li><li><p>Configure bluetooth headset.</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>Understand the basics of the <span class=filename>/etc/rc</span> scripts.</p></li><li><p>熟悉基本網路術語。</p></li><li><p>Know how to configure and install a new FreeBSD kernel (<a href=./#kernelconfig>設定 FreeBSD 核心</a>).</p></li><li><p>了解如何安裝其他第三方軟體 (<a href=./#ports>安裝應用程式：套件與 Port</a>)。</p></li></ul></div></div><div class=sect2><h3 id=network-routing>31.2. 通訊閘與路由<a class=anchor href=#network-routing></a></h3><div class=paragraph><p><em>Routing</em> is the mechanism that allows a system to find the network path to another system. A <em>route</em> is a defined pair of addresses which represent the "destination" and a "gateway". The route indicates that when trying to get to the specified destination, send the packets through the specified gateway. There are three types of destinations: individual hosts, subnets, and "default". The "default route" is used if no other routes apply. There are also three types of gateways: individual hosts, interfaces, also called links, and Ethernet hardware (MAC) addresses. Known routes are stored in a routing table.</p></div><div class=paragraph><p>This section provides an overview of routing basics. It then demonstrates how to configure a FreeBSD system as a router and offers some troubleshooting tips.</p></div><div class=sect3><h4 id=network-routing-default>31.2.1. 路由基礎概念<a class=anchor href=#network-routing-default></a></h4><div class=paragraph><p>To view the routing table of a FreeBSD system, use <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Internet:
Destination      Gateway            Flags     Refs     Use     Netif Expire
default          outside-gw         UGS        37      418       em0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1            UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>The entries in this example are as follows:</p></div><div class=dlist><dl><dt class=hdlist1>default</dt><dd><p>The first route in this table specifies the <code>default</code> route. When the local system needs to make a connection to a remote host, it checks the routing table to determine if a known path exists. If the remote host matches an entry in the table, the system checks to see if it can connect using the interface specified in that entry.</p><div class=paragraph><p>If the destination does not match an entry, or if all known paths fail, the system uses the entry for the default route. For hosts on a local area network, the <code>Gateway</code> field in the default route is set to the system which has a direct connection to the Internet. When reading this entry, verify that the <code>Flags</code> column indicates that the gateway is usable (<code>UG</code>).</p></div><div class=paragraph><p>The default route for a machine which itself is functioning as the gateway to the outside world will be the gateway machine at the Internet Service Provider (ISP).</p></div></dd><dt class=hdlist1>localhost</dt><dd><p>The second route is the <code>localhost</code> route. The interface specified in the <code>Netif</code> column for <code>localhost</code> is <span class=filename>lo0</span>, also known as the loopback device. This indicates that all traffic for this destination should be internal, rather than sending it out over the network.</p></dd><dt class=hdlist1>MAC address</dt><dd><p>The addresses beginning with <code>0:e0:</code> are MAC addresses. FreeBSD will automatically identify any hosts, <code>test0</code> in the example, on the local Ethernet and add a route for that host over the Ethernet interface, <span class=filename>re0</span>. This type of route has a timeout, seen in the <code>Expire</code> column, which is used if the host does not respond in a specific amount of time. When this happens, the route to this host will be automatically deleted. These hosts are identified using the Routing Information Protocol (RIP), which calculates routes to local hosts based upon a shortest path determination.</p></dd><dt class=hdlist1>subnet</dt><dd><p>FreeBSD will automatically add subnet routes for the local subnet. In this example, <code>10.20.30.255</code> is the broadcast address for the subnet <code>10.20.30</code> and <code>example.com</code> is the domain name associated with that subnet. The designation <code>link#1</code> refers to the first Ethernet card in the machine.</p><div class=paragraph><p>Local network hosts and local subnets have their routes automatically configured by a daemon called <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>. If it is not running, only routes which are statically defined by the administrator will exist.</p></div></dd><dt class=hdlist1>host</dt><dd><p>The <code>host1</code> line refers to the host by its Ethernet address. Since it is the sending host, FreeBSD knows to use the loopback interface (<span class=filename>lo0</span>) rather than the Ethernet interface.</p><div class=paragraph><p>The two <code>host2</code> lines represent aliases which were created using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. The <code>⇒</code> symbol after the <span class=filename>lo0</span> interface says that an alias has been set in addition to the loopback address. Such routes only show up on the host that supports the alias and all other hosts on the local network will have a <code>link#1</code> line for such routes.</p></div></dd><dt class=hdlist1>224</dt><dd><p>The final line (destination subnet <code>224</code>) deals with multicasting.</p></dd></dl></div><div class=paragraph><p>Various attributes of each route can be seen in the <code>Flags</code> column. <a href=#routeflags>常見路由表標記</a> summarizes some of these flags and their meanings:</p></div><table id=routeflags class="tableblock frame-none grid-all stretch"><caption class=title>表 28. 常見路由表標記</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">指令</th><th class="tableblock halign-left valign-top">用途</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The route is active (up).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The route destination is a single host.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Send anything for this destination on to this gateway, which will figure out from there where to send it.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>This route was statically configured.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clones a new route based upon this route for machines to connect to. This type of route is normally used for local networks.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The route was auto-configured based upon a local area network (clone) route.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Route involves references to Ethernet (link) hardware.</p></td></tr></tbody></table><div class=paragraph><p>On a FreeBSD system, the default route can defined in <span class=filename>/etc/rc.conf</span> by specifying the IP address of the default gateway:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>It is also possible to manually add the route using <code>route</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>Note that manually added routes will not survive a reboot. For more information on manual manipulation of network routing tables, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>.</p></div></div><div class=sect3><h4 id=network-static-routes>31.2.2. 設定路由器使用靜態路由<a class=anchor href=#network-static-routes></a></h4><div class=paragraph><p>A FreeBSD system can be configured as the default gateway, or router, for a network if it is a dual-homed system. A dual-homed system is a host which resides on at least two different networks. Typically, each network is connected to a separate network interface, though IP aliasing can be used to bind multiple addresses, each on a different subnet, to one physical interface.</p></div><div class=paragraph><p>In order for the system to forward packets between interfaces, FreeBSD must be configured as a router. Internet standards and good engineering practice prevent the FreeBSD Project from enabling this feature by default, but it can be configured to start at boot by adding this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>To enable routing now, set the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable <code>net.inet.ip.forwarding</code> to <code>1</code>. To stop routing, reset this variable to <code>0</code>.</p></div><div class=paragraph><p>The routing table of a router needs additional routes so it knows how to reach other networks. Routes can be either added manually using static routes or routes can be automatically learned using a routing protocol. Static routes are appropriate for small networks and this section describes how to add a static routing entry for a small network.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For large networks, static routes quickly become unscalable. FreeBSD comes with the standard BSD routing daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, which provides the routing protocols RIP, versions 1 and 2, and IRDP. Support for the BGP and OSPF routing protocols can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a> package or port.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Consider the following network:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p>In this scenario, <code>RouterA</code> is a FreeBSD machine that is acting as a router to the rest of the Internet. It has a default route set to <code>10.0.0.1</code> which allows it to connect with the outside world. <code>RouterB</code> is already configured to use <code>192.168.1.1</code> as its default gateway.</p></div><div class=paragraph><p>Before adding any static routes, the routing table on <code>RouterA</code> looks like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24        link1             UC          0        0    xl0
192.168.1.0/24     link2             UC          0        0    xl1</code></pre></div></div><div class=paragraph><p>With the current routing table, <code>RouterA</code> does not have a route to the <code>192.168.2.0/24</code> network. The following command adds the <code>Internal Net 2</code> network to <code>RouterA</code>'s routing table using <code>192.168.1.2</code> as the next hop:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Now, <code>RouterA</code> can reach any host on the <code>192.168.2.0/24</code> network. However, the routing information will not persist if the FreeBSD system reboots. If a static route needs to be persistent, add it to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a persistent static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>The <code>static_routes</code> configuration variable is a list of strings separated by a space, where each string references a route name. The variable <code><em>route_internalnet2</em></code> contains the static route for that route name.</p></div><div class=paragraph><p>Using more than one string in <code>static_routes</code> creates multiple static routes. The following shows an example of adding static routes for the <code>192.168.0.0/24</code> and <code>192.168.1.0/24</code> networks:</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div><div class=sect3><h4 id=network-routing-troubleshooting>31.2.3. 疑難排解<a class=anchor href=#network-routing-troubleshooting></a></h4><div class=paragraph><p>When an address space is assigned to a network, the service provider configures their routing tables so that all traffic for the network will be sent to the link for the site. But how do external sites know to send their packets to the network’s ISP?</p></div><div class=paragraph><p>There is a system that keeps track of all assigned address spaces and defines their point of connection to the Internet backbone, or the main trunk lines that carry Internet traffic across the country and around the world. Each backbone machine has a copy of a master set of tables, which direct traffic for a particular network to a specific backbone carrier, and from there down the chain of service providers until it reaches a particular network.</p></div><div class=paragraph><p>It is the task of the service provider to advertise to the backbone sites that they are the point of connection, and thus the path inward, for a site. This is known as route propagation.</p></div><div class=paragraph><p>Sometimes, there is a problem with route propagation and some sites are unable to connect. Perhaps the most useful command for trying to figure out where routing is breaking down is <code>traceroute</code>. It is useful when <code>ping</code> fails.</p></div><div class=paragraph><p>When using <code>traceroute</code>, include the address of the remote host to connect to. The output will show the gateway hosts along the path of the attempt, eventually either reaching the target host, or terminating because of a lack of connection. For more information, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect3><h4 id=network-routing-multicast>31.2.4. 群播 (Multicast) 注意事項<a class=anchor href=#network-routing-multicast></a></h4><div class=paragraph><p>FreeBSD natively supports both multicast applications and multicast routing. Multicast applications do not require any special configuration in order to run on FreeBSD. Support for multicast routing requires that the following option be compiled into a custom kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>The multicast routing daemon, mrouted can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/net/mrouted/>net/mrouted</a> package or port. This daemon implements the DVMRP multicast routing protocol and is configured by editing <span class=filename>/usr/local/etc/mrouted.conf</span> in order to set up the tunnels and DVMRP. The installation of mrouted also installs map-mbone and mrinfo, as well as their associated man pages. Refer to these for configuration examples.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>DVMRP has largely been replaced by the PIM protocol in many multicast installations. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=pim&amp;sektion=4&amp;format=html">pim(4)</a> for more information.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-wireless>31.3. 無線網路<a class=anchor href=#network-wireless></a></h3><div class=sect3><h4 id=_無線網路基礎>31.3.1. 無線網路基礎<a class=anchor href=#_無線網路基礎></a></h4><div class=paragraph><p>Most wireless networks are based on the IEEE™ 802.11 standards. A basic wireless network consists of multiple stations communicating with radios that broadcast in either the 2.4GHz or 5GHz band, though this varies according to the locale and is also changing to enable communication in the 2.3GHz and 4.9GHz ranges.</p></div><div class=paragraph><p>802.11 networks are organized in two ways. In <em>infrastructure mode</em>, one station acts as a master with all the other stations associating to it, the network is known as a BSS, and the master station is termed an access point (AP). In a BSS, all communication passes through the AP; even when one station wants to communicate with another wireless station, messages must go through the AP. In the second form of network, there is no master and stations communicate directly. This form of network is termed an IBSS and is commonly known as an <em>ad-hoc network</em>.</p></div><div class=paragraph><p>802.11 networks were first deployed in the 2.4GHz band using protocols defined by the IEEE™ 802.11 and 802.11b standard. These specifications include the operating frequencies and the MAC layer characteristics, including framing and transmission rates, as communication can occur at various rates. Later, the 802.11a standard defined operation in the 5GHz band, including different signaling mechanisms and higher transmission rates. Still later, the 802.11g standard defined the use of 802.11a signaling and transmission mechanisms in the 2.4GHz band in such a way as to be backwards compatible with 802.11b networks.</p></div><div class=paragraph><p>Separate from the underlying transmission techniques, 802.11 networks have a variety of security mechanisms. The original 802.11 specifications defined a simple security protocol called WEP. This protocol uses a fixed pre-shared key and the RC4 cryptographic cipher to encode data transmitted on a network. Stations must all agree on the fixed key in order to communicate. This scheme was shown to be easily broken and is now rarely used except to discourage transient users from joining networks. Current security practice is given by the IEEE™ 802.11i specification that defines new cryptographic ciphers and an additional protocol to authenticate stations to an access point and exchange keys for data communication. Cryptographic keys are periodically refreshed and there are mechanisms for detecting and countering intrusion attempts. Another security protocol specification commonly used in wireless networks is termed WPA, which was a precursor to 802.11i. WPA specifies a subset of the requirements found in 802.11i and is designed for implementation on legacy hardware. Specifically, WPA requires only the TKIP cipher that is derived from the original WEP cipher. 802.11i permits use of TKIP but also requires support for a stronger cipher, AES-CCM, for encrypting data. The AES cipher was not required in WPA because it was deemed too computationally costly to be implemented on legacy hardware.</p></div><div class=paragraph><p>The other standard to be aware of is 802.11e. It defines protocols for deploying multimedia applications, such as streaming video and voice over IP (VoIP), in an 802.11 network. Like 802.11i, 802.11e also has a precursor specification termed WME (later renamed WMM) that has been defined by an industry group as a subset of 802.11e that can be deployed now to enable multimedia applications while waiting for the final ratification of 802.11e. The most important thing to know about 802.11e and WME/WMM is that it enables prioritized traffic over a wireless network through Quality of Service (QoS) protocols and enhanced media access protocols. Proper implementation of these protocols enables high speed bursting of data and prioritized traffic flow.</p></div><div class=paragraph><p>FreeBSD supports networks that operate using 802.11a, 802.11b, and 802.11g. The WPA and 802.11i security protocols are likewise supported (in conjunction with any of 11a, 11b, and 11g) and QoS and traffic prioritization required by the WME/WMM protocols are supported for a limited set of wireless devices.</p></div></div><div class=sect3><h4 id=network-wireless-quick-start>31.3.2. 快速開始<a class=anchor href=#network-wireless-quick-start></a></h4><div class=paragraph><p>Connecting a computer to an existing wireless network is a very common situation. This procedure shows the steps required.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Obtain the SSID (Service Set Identifier) and PSK (Pre-Shared Key) for the wireless network from the network administrator.</p></li><li><p>Identify the wireless adapter. The FreeBSD <span class=filename>GENERIC</span> kernel includes drivers for many common wireless adapters. If the wireless adapter is one of those models, it will be shown in the output from <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig | <span class=nb>grep</span> <span class=nt>-B3</span> <span class=nt>-i</span> wireless</code></pre></div></div><div class=paragraph><p>On FreeBSD 11 or higher, use this command instead:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl net.wlan.devices</code></pre></div></div><div class=paragraph><p>If a wireless adapter is not listed, an additional kernel module might be required, or it might be a model not supported by FreeBSD.</p></div><div class=paragraph><p>This example shows the Atheros <code>ath0</code> wireless adapter.</p></div></li><li><p>Add an entry for this network to <span class=filename>/etc/wpa_supplicant.conf</span>. If the file does not exist, create it. Replace <em>myssid</em> and <em>mypsk</em> with the SSID and PSK provided by the network administrator.</p><div class="literalblock programlisting"><div class=content><pre>network={
	ssid=&#34;myssid&#34;
	psk=&#34;mypsk&#34;
}</pre></div></div></li><li><p>Add entries to <span class=filename>/etc/rc.conf</span> to configure the network on startup:</p><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA SYNCDHCP&#34;</pre></div></div></li><li><p>Restart the computer, or restart the network service to connect to the network:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=network-wireless-basic>31.3.3. 基礎設定<a class=anchor href=#network-wireless-basic></a></h4><div class=sect4><h5 id=_核心設定_2>31.3.3.1. 核心設定<a class=anchor href=#_核心設定_2></a></h5><div class=paragraph><p>To use wireless networking, a wireless networking card is needed and the kernel needs to be configured with the appropriate wireless networking support. The kernel is separated into multiple modules so that only the required support needs to be configured.</p></div><div class=paragraph><p>The most commonly used wireless devices are those that use parts made by Atheros. These devices are supported by <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> and require the following line to be added to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>if_ath_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The Atheros driver is split up into three separate pieces: the driver (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>), the hardware support layer that handles chip-specific functions (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath_hal&amp;sektion=4&amp;format=html">ath_hal(4)</a>), and an algorithm for selecting the rate for transmitting frames. When this support is loaded as kernel modules, any dependencies are automatically handled. To load support for a different type of wireless device, specify the module for that device. This example is for devices based on the Intersil Prism parts (<a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a>) driver:</p></div><div class="literalblock programlisting"><div class=content><pre>if_wi_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The examples in this section use an <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> device and the device name in the examples must be changed according to the configuration. A list of available wireless drivers and supported adapters can be found in the FreeBSD Hardware Notes, available on the <a href=https://www.FreeBSD.org/releases/>Release Information</a> page of the FreeBSD website. If a native FreeBSD driver for the wireless device does not exist, it may be possible to use the Windows™ driver with the help of the <a href=./#config-network-ndis>NDIS</a> driver wrapper.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In addition, the modules that implement cryptographic support for the security protocols to use must be loaded. These are intended to be dynamically loaded on demand by the <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a> module, but for now they must be manually configured. The following modules are available: <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a>. The <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a> drivers are only needed when using the WPA or 802.11i security protocols. If the network does not use encryption, <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a> support is not needed. To load these modules at boot time, add the following lines to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlan_wep_load=&#34;YES&#34;
wlan_ccmp_load=&#34;YES&#34;
wlan_tkip_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Once this information has been added to <span class=filename>/boot/loader.conf</span>, reboot the FreeBSD box. Alternately, load the modules by hand using <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For users who do not want to use modules, it is possible to compile these drivers into the kernel by adding the following lines to a custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC&#39;s
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</pre></div></div><div class=paragraph><p>With this information in the kernel configuration file, recompile the kernel and reboot the FreeBSD machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Information about the wireless device should appear in the boot messages, like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: <span class=o>[</span>ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</code></pre></div></div></div><div class=sect4><h5 id=_設定正確的區域>31.3.3.2. 設定正確的區域<a class=anchor href=#_設定正確的區域></a></h5><div class=paragraph><p>Since the regulatory situation is different in various parts of the world, it is necessary to correctly set the domains that apply to your location to have the correct information about what channels can be used.</p></div><div class=paragraph><p>The available region definitions can be found in <span class=filename>/etc/regdomain.xml</span>. To set the data at runtime, use <code>ifconfig</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 regdomain ETSI country AT</span></code></pre></div></div><div class=paragraph><p>To persist the settings, add it to <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc create_args_wlan0=&#34;country AT regdomain ETSI&#34;</span></code></pre></div></div></div></div><div class=sect3><h4 id=_主從式_infrastructure>31.3.4. 主從式 (Infrastructure)<a class=anchor href=#_主從式_infrastructure></a></h4><div class=paragraph><p>Infrastructure (BSS) mode is the mode that is typically used. In this mode, a number of wireless access points are connected to a wired network. Each wireless network has its own name, called the SSID. Wireless clients connect to the wireless access points.</p></div><div class=sect4><h5 id=_freebsd_客戶端>31.3.4.1. FreeBSD 客戶端<a class=anchor href=#_freebsd_客戶端></a></h5><div class=sect5><h6 id=_如何尋找存取點>31.3.4.1.1. 如何尋找存取點<a class=anchor href=#_如何尋找存取點></a></h6><div class=paragraph><p>To scan for available networks, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. This request may take a few moments to complete as it requires the system to switch to each available wireless frequency and probe for available access points. Only the superuser can initiate a scan:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M <span class=nt>-90</span>:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-83</span>:96   100 EPS  WPA</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The interface must be <code>up</code> before it can scan. Subsequent scan requests do not require the interface to be marked as up again.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The output of a scan request lists each BSS/IBSS network found. Besides listing the name of the network, the <code>SSID</code>, the output also shows the <code>BSSID</code>, which is the MAC address of the access point. The <code>CAPS</code> field identifies the type of each network and the capabilities of the stations operating there:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>表 29. 站台功能代號</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">功能代號</th><th class="tableblock halign-left valign-top">意義</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>E</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Extended Service Set (ESS). Indicates that the station is part of an infrastructure network rather than an IBSS/ad-hoc network.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>I</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IBSS/ad-hoc network. Indicates that the station is part of an ad-hoc network rather than an ESS network.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>P</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Privacy. Encryption is required for all data frames exchanged within the BSS using cryptographic means such as WEP, TKIP or AES-CCMP.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>S</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Short Preamble. Indicates that the network is using short preambles, defined in 802.11b High Rate/DSSS PHY, and utilizes a 56 bit sync field rather than the 128 bit field used in long preamble mode.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>s</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Short slot time. Indicates that the 802.11g network is using a short slot time because there are no legacy (802.11b) stations present.</p></td></tr></tbody></table><div class=paragraph><p>One can also display the current list of known networks with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 list scan</span></code></pre></div></div><div class=paragraph><p>This information may be updated automatically by the adapter or manually with a <code>scan</code> request. Old data is automatically removed from the cache, so over time this list may shrink unless more scans are done.</p></div></div><div class=sect5><h6 id=_基礎設定>31.3.4.1.2. 基礎設定<a class=anchor href=#_基礎設定></a></h6><div class=paragraph><p>This section provides a simple example of how to make the wireless network adapter work in FreeBSD without encryption. Once familiar with these concepts, it is strongly recommend to use <a href=#network-wireless-wpa>WPA</a> to set up the wireless network.</p></div><div class=paragraph><p>There are three basic steps to configure a wireless network: select an access point, authenticate the station, and configure an IP address. The following sections discuss each step.</p></div><div class=sect6><h7 id=_選擇存取點>31.3.4.1.2.1. 選擇存取點<a class=anchor href=#_選擇存取點></a></h7><div class=paragraph><p>Most of the time, it is sufficient to let the system choose an access point using the builtin heuristics. This is the default behavior when an interface is marked as up or it is listed in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>If there are multiple access points, a specific one can be selected by its SSID:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>In an environment where there are multiple access points with the same SSID, which is often done to simplify roaming, it may be necessary to associate to one specific device. In this case, the BSSID of the access point can be specified, with or without the SSID:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP&#34;</pre></div></div><div class=paragraph><p>There are other ways to constrain the choice of an access point, such as limiting the set of frequencies the system will scan on. This may be useful for a multi-band wireless card as scanning all the possible channels can be time-consuming. To limit operation to a specific band, use the <code>mode</code> parameter:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;mode 11g ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>This example will force the card to operate in 802.11g, which is defined only for 2.4GHz frequencies so any 5GHz channels will not be considered. This can also be achieved with the <code>channel</code> parameter, which locks operation to one specific frequency, and the <code>chanlist</code> parameter, to specify a list of channels for scanning. More information about these parameters can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect6><h7 id=_認證_2>31.3.4.1.2.2. 認證<a class=anchor href=#_認證_2></a></h7><div class=paragraph><p>Once an access point is selected, the station needs to authenticate before it can pass data. Authentication can happen in several ways. The most common scheme, open authentication, allows any station to join the network and communicate. This is the authentication to use for test purposes the first time a wireless network is setup. Other schemes require cryptographic handshakes to be completed before data traffic can flow, either using pre-shared keys or secrets, or more complex schemes that involve backend services such as RADIUS. Open authentication is the default setting. The next most common setup is WPA-PSK, also known as WPA Personal, which is described in <a href=#network-wireless-wpa-wpa-psk>WPA-PSK</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If using an Apple™AirPort™ Extreme base station for an access point, shared-key authentication together with a WEP key needs to be configured. This can be configured in <span class=filename>/etc/rc.conf</span> or by using <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. For a single AirPort™ base station, access can be configured with:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP&#34;</pre></div></div><div class=paragraph><p>In general, shared key authentication should be avoided because it uses the WEP key material in a highly-constrained manner, making it even easier to crack the key. If WEP must be used for compatibility with legacy devices, it is better to use WEP with <code>open</code> authentication. More information regarding WEP can be found in <a href=#network-wireless-wep>WEP</a>.</p></div></td></tr></tbody></table></div></div><div class=sect6><h7 id=_使用_dhcp_取得_ip_位址>31.3.4.1.2.3. 使用 DHCP 取得 IP 位址<a class=anchor href=#_使用_dhcp_取得_ip_位址></a></h7><div class=paragraph><p>Once an access point is selected and the authentication parameters are set, an IP address must be obtained in order to communicate. Most of the time, the IP address is obtained via DHCP. To achieve that, edit <span class=filename>/etc/rc.conf</span> and add <code>DHCP</code> to the configuration for the device:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>The wireless interface is now ready to bring up:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span></code></pre></div></div><div class=paragraph><p>Once the interface is running, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> to see the status of the interface <span class=filename>ath0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 <span class=o>(</span>2462 Mhz 11g<span class=o>)</span> bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>The <code>status: associated</code> line means that it is connected to the wireless network. The <code>bssid 00:13:46:49:41:76</code> is the MAC address of the access point and <code>authmode OPEN</code> indicates that the communication is not encrypted.</p></div></div><div class=sect6><h7 id=_靜態_ip_位址>31.3.4.1.2.4. 靜態 IP 位址<a class=anchor href=#_靜態_ip_位址></a></h7><div class=paragraph><p>If an IP address cannot be obtained from a DHCP server, set a fixed IP address. Replace the <code>DHCP</code> keyword shown above with the address information. Be sure to retain any other parameters for selecting the access point:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here&#34;</pre></div></div></div></div><div class=sect5><h6 id=network-wireless-wpa>31.3.4.1.3. WPA<a class=anchor href=#network-wireless-wpa></a></h6><div class=paragraph><p>Wi-Fi Protected Access (WPA) is a security protocol used together with 802.11 networks to address the lack of proper authentication and the weakness of WEP. WPA leverages the 802.1X authentication protocol and uses one of several ciphers instead of WEP for data integrity. The only cipher required by WPA is the Temporary Key Integrity Protocol (TKIP). TKIP is a cipher that extends the basic RC4 cipher used by WEP by adding integrity checking, tamper detection, and measures for responding to detected intrusions. TKIP is designed to work on legacy hardware with only software modification. It represents a compromise that improves security but is still not entirely immune to attack. WPA also specifies the AES-CCMP cipher as an alternative to TKIP, and that is preferred when possible. For this specification, the term WPA2 or RSN is commonly used.</p></div><div class=paragraph><p>WPA defines authentication and encryption protocols. Authentication is most commonly done using one of two techniques: by 802.1X and a backend authentication service such as RADIUS, or by a minimal handshake between the station and the access point using a pre-shared secret. The former is commonly termed WPA Enterprise and the latter is known as WPA Personal. Since most people will not set up a RADIUS backend server for their wireless network, WPA-PSK is by far the most commonly encountered configuration for WPA.</p></div><div class=paragraph><p>The control of the wireless connection and the key negotiation or authentication with a server is done using <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. This program requires a configuration file, <span class=filename>/etc/wpa_supplicant.conf</span>, to run. More information regarding this file can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</p></div><div class=sect6><h7 id=network-wireless-wpa-wpa-psk>31.3.4.1.3.1. WPA-PSK<a class=anchor href=#network-wireless-wpa-wpa-psk></a></h7><div class=paragraph><p>WPA-PSK, also known as WPA Personal, is based on a pre-shared key (PSK) which is generated from a given password and used as the master key in the wireless network. This means every wireless user will share the same key. WPA-PSK is intended for small networks where the use of an authentication server is not possible or desired.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Always use strong passwords that are sufficiently long and made from a rich alphabet so that they will not be easily guessed or attacked.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The first step is the configuration of <span class=filename>/etc/wpa_supplicant.conf</span> with the SSID and the pre-shared key of the network:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  psk=&#34;freebsdmall&#34;
}</pre></div></div><div class=paragraph><p>Then, in <span class=filename>/etc/rc.conf</span>, indicate that the wireless device configuration will be done with WPA and the IP address will be obtained with DHCP:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Then, bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Or, try to configure the interface manually using the information in <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:11:95:c3:0d:ac <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;freebsdap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2412 MHz<span class=o>)</span>
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac <span class=o>[</span><span class=nv>PTK</span><span class=o>=</span>CCMP <span class=nv>GTK</span><span class=o>=</span>CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed <span class=o>(</span>auth<span class=o>)</span> <span class=o>[</span><span class=nb>id</span><span class=o>=</span>0 <span class=nv>id_str</span><span class=o>=]</span></code></pre></div></div><div class=paragraph><p>The next operation is to launch <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> to get the IP address from the DHCP server:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient wlan0</span>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If <span class=filename>/etc/rc.conf</span> has an <code>ifconfig_wlan0="DHCP"</code> entry, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> will be launched automatically after <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> associates with the access point.</p></div></td></tr></tbody></table></div><div class=paragraph><p>If DHCP is not possible or desired, set a static IP address after <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> has authenticated the station:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</span>
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>When DHCP is not used, the default gateway and the nameserver also have to be manually set:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default your_default_router</span>
<span class=c># echo &#34;nameserver your_DNS_server&#34; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-tls>31.3.4.1.3.2. WPA 加上 EAP-TLS<a class=anchor href=#network-wireless-wpa-eap-tls></a></h7><div class=paragraph><p>The second way to use WPA is with an 802.1X backend authentication server. In this case, WPA is called WPA Enterprise to differentiate it from the less secure WPA Personal. Authentication in WPA Enterprise is based on the Extensible Authentication Protocol (EAP).</p></div><div class=paragraph><p>EAP does not come with an encryption method. Instead, EAP is embedded inside an encrypted tunnel. There are many EAP authentication methods, but EAP-TLS, EAP-TTLS, and EAP-PEAP are the most common.</p></div><div class=paragraph><p>EAP with Transport Layer Security (EAP-TLS) is a well-supported wireless authentication protocol since it was the first EAP method to be certified by the <a href=http://www.wi-fi.org/>Wi-Fi Alliance</a>. EAP-TLS requires three certificates to run: the certificate of the Certificate Authority (CA) installed on all machines, the server certificate for the authentication server, and one client certificate for each wireless client. In this EAP method, both the authentication server and wireless client authenticate each other by presenting their respective certificates, and then verify that these certificates were signed by the organization’s CA.</p></div><div class=paragraph><p>As previously, the configuration is done via <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34; <i class=conum data-value=1></i><b>(1)</b>
  proto=RSN  <i class=conum data-value=2></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class=conum data-value=3></i><b>(3)</b>
  eap=TLS <i class=conum data-value=4></i><b>(4)</b>
  identity=&#34;loader&#34; <i class=conum data-value=5></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=6></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class=conum data-value=7></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class=conum data-value=8></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class=conum data-value=9></i><b>(9)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This field indicates the network name (SSID).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>This example uses the RSN IEEE™ 802.11i protocol, also known as WPA2.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>key_mgmt</code> line refers to the key management protocol to use. In this example, it is WPA using EAP authentication.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>This field indicates the EAP method for the connection.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>The <code>identity</code> field contains the identity string for EAP.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificate.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>The <code>client_cert</code> line gives the pathname to the client certificate file. This certificate is unique to each wireless client of the network.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>The <code>private_key</code> field is the pathname to the client certificate private key file.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>The <code>private_key_passwd</code> field contains the passphrase for the private key.</td></tr></tbody></table></div><div class=paragraph><p>Then, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>The next step is to bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>It is also possible to bring up the interface manually using <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-ttls>31.3.4.1.3.3. WPA 加上 EAP-TTLS<a class=anchor href=#network-wireless-wpa-eap-ttls></a></h7><div class=paragraph><p>With EAP-TLS, both the authentication server and the client need a certificate. With EAP-TTLS, a client certificate is optional. This method is similar to a web server which creates a secure SSL tunnel even if visitors do not have client-side certificates. EAP-TTLS uses an encrypted TLS tunnel for safe transport of the authentication data.</p></div><div class=paragraph><p>The required configuration can be added to <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class=conum data-value=5></i><b>(5)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This field specifies the EAP method for the connection.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>identity</code> field contains the identity string for EAP authentication inside the encrypted TLS tunnel.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>password</code> field contains the passphrase for the EAP authentication.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificate.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>This field specifies the authentication method used in the encrypted TLS tunnel. In this example, EAP with MD5-Challenge is used. The "inner authentication" phase is often called "phase2".</td></tr></tbody></table></div><div class=paragraph><p>Next, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>The next step is to bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-peap>31.3.4.1.3.4. WPA 加上 EAP-PEAP<a class=anchor href=#network-wireless-wpa-eap-peap></a></h7><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>PEAPv0/EAP-MSCHAPv2 is the most common PEAP method. In this chapter, the term PEAP is used to refer to that method.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Protected EAP (PEAP) is designed as an alternative to EAP-TTLS and is the most used EAP standard after EAP-TLS. In a network with mixed operating systems, PEAP should be the most supported standard after EAP-TLS.</p></div><div class=paragraph><p>PEAP is similar to EAP-TTLS as it uses a server-side certificate to authenticate clients by creating an encrypted TLS tunnel between the client and the authentication server, which protects the ensuing exchange of authentication information. PEAP authentication differs from EAP-TTLS as it broadcasts the username in the clear and only the password is sent in the encrypted TLS tunnel. EAP-TTLS will use the TLS tunnel for both the username and password.</p></div><div class=paragraph><p>Add the following lines to <span class=filename>/etc/wpa_supplicant.conf</span> to configure the EAP-PEAP related settings:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34; <i class=conum data-value=5></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class=conum data-value=6></i><b>(6)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This field specifies the EAP method for the connection.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>identity</code> field contains the identity string for EAP authentication inside the encrypted TLS tunnel.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>password</code> field contains the passphrase for the EAP authentication.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificate.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>This field contains the parameters for the first phase of authentication, the TLS tunnel. According to the authentication server used, specify a specific label for authentication. Most of the time, the label will be "client EAP encryption" which is set by using <code>peaplabel=0</code>. More information can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>This field specifies the authentication protocol used in the encrypted TLS tunnel. In the case of PEAP, it is <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>將以下參數加到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Then, bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div></div><div class=sect5><h6 id=network-wireless-wep>31.3.4.1.4. WEP<a class=anchor href=#network-wireless-wep></a></h6><div class=paragraph><p>Wired Equivalent Privacy (WEP) is part of the original 802.11 standard. There is no authentication mechanism, only a weak form of access control which is easily cracked.</p></div><div class=paragraph><p>WEP can be set up using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \</span>
	    ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012</code></pre></div></div><div class=ulist><ul><li><p>The <code>weptxkey</code> specifies which WEP key will be used in the transmission. This example uses the third key. This must match the setting on the access point. When unsure which key is used by the access point, try <code>1</code> (the first key) for this value.</p></li><li><p>The <code>wepkey</code> selects one of the WEP keys. It should be in the format <em>index:key</em>. Key <code>1</code> is used by default; the index only needs to be set when using a key other than the first key.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Replace the <code>0x3456789012</code> with the key configured for use on the access point.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> for further information.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> facility can be used to configure a wireless interface with WEP. The example above can be set up by adding the following lines to <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;my_net&#34;
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</pre></div></div><div class=paragraph><p>Then:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:13:46:49:41:76 <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;dlinkap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2437 MHz<span class=o>)</span>
Associated with 00:13:46:49:41:76</code></pre></div></div></div></div></div><div class=sect3><h4 id=_對等式_ad_hoc>31.3.5. 對等式 (Ad-hoc)<a class=anchor href=#_對等式_ad_hoc></a></h4><div class=paragraph><p>IBSS mode, also called ad-hoc mode, is designed for point to point connections. For example, to establish an ad-hoc network between the machines <code>A</code> and <code>B</code>, choose two IP addresses and a SSID.</p></div><div class=paragraph><p>On <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>The <code>adhoc</code> parameter indicates that the interface is running in IBSS mode.</p></div><div class=paragraph><p><code>B</code> should now be able to detect <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 up scan</span>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M <span class=nt>-64</span>:-96  100 IS   WME</code></pre></div></div><div class=paragraph><p>The <code>I</code> in the output confirms that <code>A</code> is in ad-hoc mode. Now, configure <code>B</code> with a different IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>Both <code>A</code> and <code>B</code> are now ready to exchange information.</p></div></div><div class=sect3><h4 id=network-wireless-ap>31.3.6. FreeBSD 主機存取點<a class=anchor href=#network-wireless-ap></a></h4><div class=paragraph><p>FreeBSD can act as an Access Point (AP) which eliminates the need to buy a hardware AP or run an ad-hoc network. This can be particularly useful when a FreeBSD machine is acting as a gateway to another network such as the Internet.</p></div><div class=sect4><h5 id=network-wireless-ap-basic>31.3.6.1. 基礎設定<a class=anchor href=#network-wireless-ap-basic></a></h5><div class=paragraph><p>Before configuring a FreeBSD machine as an AP, the kernel must be configured with the appropriate networking support for the wireless card as well as the security protocols being used. For more details, see <a href=#network-wireless-basic>基礎設定</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The NDIS driver wrapper for Windows™ drivers does not currently support AP operation. Only native FreeBSD wireless drivers support AP mode.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Once wireless networking support is loaded, check if the wireless device supports the host-based access point mode, also known as hostap mode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 list caps</span>
<span class=nv>drivercaps</span><span class=o>=</span>6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
<span class=nv>cryptocaps</span><span class=o>=</span>1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</code></pre></div></div><div class=paragraph><p>This output displays the card’s capabilities. The <code>HOSTAP</code> word confirms that this wireless card can act as an AP. Various supported ciphers are also listed: WEP, TKIP, and AES. This information indicates which security protocols can be used on the AP.</p></div><div class=paragraph><p>The wireless device can only be put into hostap mode during the creation of the network pseudo-device, so a previously created device must be destroyed first:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 destroy</span></code></pre></div></div><div class=paragraph><p>then regenerated with the correct option before setting the other parameters:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</span></code></pre></div></div><div class=paragraph><p>Use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> again to see the status of the <span class=filename>wlan0</span> interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>The <code>hostap</code> parameter indicates the interface is running in the host-based access point mode.</p></div><div class=paragraph><p>The interface configuration can be done automatically at boot time by adding the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
create_args_wlan0=&#34;wlanmode hostap&#34;
ifconfig_wlan0=&#34;inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&#34;</pre></div></div></div><div class=sect4><h5 id=_無認證或加密的_host_based_存取點>31.3.6.2. 無認證或加密的 Host-based 存取點<a class=anchor href=#_無認證或加密的_host_based_存取點></a></h5><div class=paragraph><p>Although it is not recommended to run an AP without any authentication or encryption, this is a simple way to check if the AP is working. This configuration is also important for debugging client issues.</p></div><div class=paragraph><p>Once the AP is configured, initiate a scan from another wireless machine to find the AP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-66</span>:-96  100 ES   WME</code></pre></div></div><div class=paragraph><p>The client machine found the AP and can be associated with it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</code></pre></div></div></div><div class=sect4><h5 id=network-wireless-ap-wpa>31.3.6.3. WPA2 Host-based 存取點<a class=anchor href=#network-wireless-ap-wpa></a></h5><div class=paragraph><p>This section focuses on setting up a FreeBSD access point using the WPA2 security protocol. More details regarding WPA and the configuration of WPA-based wireless clients can be found in <a href=#network-wireless-wpa>WPA</a>.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> daemon is used to deal with client authentication and key management on the WPA2-enabled AP.</p></div><div class=paragraph><p>The following configuration operations are performed on the FreeBSD machine acting as the AP. Once the AP is correctly working, <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> can be automatically started at boot with this line in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostapd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Before trying to configure <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>, first configure the basic settings introduced in <a href=#network-wireless-ap-basic>基礎設定</a>.</p></div><div class=sect5><h6 id=_wpa2_psk>31.3.6.3.1. WPA2-PSK<a class=anchor href=#_wpa2_psk></a></h6><div class=paragraph><p>WPA2-PSK is intended for small networks where the use of a backend authentication server is not possible or desired.</p></div><div class=paragraph><p>The configuration is done in <span class=filename>/etc/hostapd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>interface=wlan0                  <i class=conum data-value=1></i><b>(1)</b>
debug=1                          <i class=conum data-value=2></i><b>(2)</b>
ctrl_interface=/var/run/hostapd  <i class=conum data-value=3></i><b>(3)</b>
ctrl_interface_group=wheel       <i class=conum data-value=4></i><b>(4)</b>
ssid=freebsdap                   <i class=conum data-value=5></i><b>(5)</b>
wpa=2                            <i class=conum data-value=6></i><b>(6)</b>
wpa_passphrase=freebsdmall       <i class=conum data-value=7></i><b>(7)</b>
wpa_key_mgmt=WPA-PSK             <i class=conum data-value=8></i><b>(8)</b>
wpa_pairwise=CCMP                <i class=conum data-value=9></i><b>(9)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Wireless interface used for the access point.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Level of verbosity used during the execution of <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>. A value of <code>1</code> represents the minimal level.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Pathname of the directory used by <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> to store domain socket files for communication with external programs such as <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd_cli&amp;sektion=8&amp;format=html">hostapd_cli(8)</a>. The default value is used in this example.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The group allowed to access the control interface files.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>The wireless network name, or SSID, that will appear in wireless scans.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Enable WPA and specify which WPA authentication protocol will be required. A value of <code>2</code> configures the AP for WPA2 and is recommended. Set to <code>1</code> only if the obsolete WPA is required.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>ASCII passphrase for WPA authentication.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>The key management protocol to use. This example sets WPA-PSK.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Encryption algorithms accepted by the access point. In this example, only the CCMP (AES) cipher is accepted. CCMP is an alternative to TKIP and is strongly preferred when possible. TKIP should be allowed only when there are stations incapable of using CCMP.</td></tr></tbody></table></div><div class=paragraph><p>The next step is to start <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hostapd forcestart</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether 04:f0:21:16:8e:10
	inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
	nd6 <span class=nv>options</span><span class=o>=</span>21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
	media: IEEE 802.11 Wireless Ethernet autoselect mode 11na &lt;hostap&gt;
	status: running
	ssid No5ignal channel 36 <span class=o>(</span>5180 MHz 11a ht/40+<span class=o>)</span> bssid 04:f0:21:16:8e:10
	country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
	AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
	scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
	dtimperiod 1 <span class=nt>-dfs</span>
	<span class=nb>groups</span>: wlan</code></pre></div></div><div class=paragraph><p>Once the AP is running, the clients can associate with it. See <a href=#network-wireless-wpa>WPA</a> for more details. It is possible to see the stations associated with the AP using <code>ifconfig <em>wlan0</em> list sta</code>.</p></div></div></div><div class=sect4><h5 id=_wep_host_based_存取點>31.3.6.4. WEP Host-based 存取點<a class=anchor href=#_wep_host_based_存取點></a></h5><div class=paragraph><p>It is not recommended to use WEP for setting up an AP since there is no authentication mechanism and the encryption is easily cracked. Some legacy wireless cards only support WEP and these cards will only support an AP without authentication or encryption.</p></div><div class=paragraph><p>The wireless device can now be put into hostap mode and configured with the correct SSID and IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \</span>
	ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</code></pre></div></div><div class=ulist><ul><li><p>The <code>weptxkey</code> indicates which WEP key will be used in the transmission. This example uses the third key as key numbering starts with <code>1</code>. This parameter must be specified in order to encrypt the data.</p></li><li><p>The <code>wepkey</code> sets the selected WEP key. It should be in the format <em>index:key</em>. If the index is not given, key <code>1</code> is set. The index needs to be set when using keys other than the first key.</p></li></ul></div><div class=paragraph><p>Use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> to see the status of the <span class=filename>wlan0</span> interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 4 <span class=o>(</span>2427 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
	  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>From another wireless machine, it is now possible to initiate a scan to find the AP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</code></pre></div></div><div class=paragraph><p>In this example, the client machine found the AP and can associate with it using the correct parameters. See <a href=#network-wireless-wep>WEP</a> for more details.</p></div></div></div><div class=sect3><h4 id=_同時使用有線及無線連線>31.3.7. 同時使用有線及無線連線<a class=anchor href=#_同時使用有線及無線連線></a></h4><div class=paragraph><p>A wired connection provides better performance and reliability, while a wireless connection provides flexibility and mobility. Laptop users typically want to roam seamlessly between the two types of connections.</p></div><div class=paragraph><p>On FreeBSD, it is possible to combine two or even more network interfaces together in a "failover" fashion. This type of configuration uses the most preferred and available connection from a group of network interfaces, and the operating system switches automatically when the link state changes.</p></div><div class=paragraph><p>Link aggregation and failover is covered in <a href=#network-aggregation>Link Aggregation 與容錯移轉</a> and an example for using both wired and wireless connections is provided at <a href=#networking-lagg-wired-and-wireless>乙太網路與無線介面間的容錯移轉模式</a>.</p></div></div><div class=sect3><h4 id=_疑難排解_5>31.3.8. 疑難排解<a class=anchor href=#_疑難排解_5></a></h4><div class=paragraph><p>This section describes a number of steps to help troubleshoot common wireless networking problems.</p></div><div class=ulist><ul><li><p>If the access point is not listed when scanning, check that the configuration has not limited the wireless device to a limited set of channels.</p></li><li><p>If the device cannot associate with an access point, verify that the configuration matches the settings on the access point. This includes the authentication scheme and any security protocols. Simplify the configuration as much as possible. If using a security protocol such as WPA or WEP, configure the access point for open authentication and no security to see if traffic will pass.</p><div class=paragraph><p>Debugging support is provided by <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Try running this utility manually with <code>-dd</code> and look at the system logs.</p></div></li><li><p>Once the system can associate with the access point, diagnose the network configuration using tools like <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>.</p></li><li><p>There are many lower-level debugging tools. Debugging messages can be enabled in the 802.11 protocol support layer using <a href="https://man.freebsd.org/cgi/man.cgi?query=wlandebug&amp;sektion=8&amp;format=html">wlandebug(8)</a>. For example, to enable console messages related to scanning for access points and the 802.11 protocol handshakes required to arrange communication:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wlandebug -i wlan0 +scan+auth+debug+assoc</span>
  net.wlan.0.debug: 0 <span class=o>=&gt;</span> 0xc80000&lt;assoc,auth,scan&gt;</code></pre></div></div><div class=paragraph><p>Many useful statistics are maintained by the 802.11 layer and <code>wlanstats</code>, found in <span class=filename>/usr/src/tools/tools/net80211</span>, will dump this information. These statistics should display all errors identified by the 802.11 layer. However, some errors are identified in the device drivers that lie below the 802.11 layer so they may not show up. To diagnose device-specific problems, refer to the drivers' documentation.</p></div></li></ul></div><div class=paragraph><p>If the above information does not help to clarify the problem, submit a problem report and include output from the above tools.</p></div></div></div><div class=sect2><h3 id=network-usb-tethering>31.4. USB 網路共享<a class=anchor href=#network-usb-tethering></a></h3><div class=paragraph><p>Many cellphones provide the option to share their data connection over USB (often called "tethering"). This feature uses either the RNDIS, CDC or a custom Apple™iPhone™/iPad™ protocol.</p></div><div class=ulist><ul><li><p>Android™ devices generally use the <a href="https://man.freebsd.org/cgi/man.cgi?query=urndis&amp;sektion=4&amp;format=html">urndis(4)</a> driver.</p></li><li><p>Apple™ devices use the <a href="https://man.freebsd.org/cgi/man.cgi?query=ipheth&amp;sektion=4&amp;format=html">ipheth(4)</a> driver.</p></li><li><p>Older devices will often use the <a href="https://man.freebsd.org/cgi/man.cgi?query=cdce&amp;sektion=4&amp;format=html">cdce(4)</a> driver.</p></li></ul></div><div class=paragraph><p>Before attaching a device, load the appropriate driver into the kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_urndis</span>
<span class=c># kldload if_cdce</span>
<span class=c># kldload if_ipheth</span></code></pre></div></div><div class=paragraph><p>Once the device is attached <code>ue<em>0</em></code> will be available for use like a normal network device. Be sure that the "USB tethering" option is enabled on the device.</p></div></div><div class=sect2><h3 id=network-bluetooth>31.5. 藍牙<a class=anchor href=#network-bluetooth></a></h3><div class=paragraph><p>Bluetooth is a wireless technology for creating personal networks operating in the 2.4 GHz unlicensed band, with a range of 10 meters. Networks are usually formed ad-hoc from portable devices such as cellular phones, handhelds, and laptops. Unlike Wi-Fi wireless technology, Bluetooth offers higher level service profiles, such as FTP-like file servers, file pushing, voice transport, serial line emulation, and more.</p></div><div class=paragraph><p>This section describes the use of a USB Bluetooth dongle on a FreeBSD system. It then describes the various Bluetooth protocols and utilities.</p></div><div class=sect3><h4 id=_載入藍牙支援>31.5.1. 載入藍牙支援<a class=anchor href=#_載入藍牙支援></a></h4><div class=paragraph><p>The Bluetooth stack in FreeBSD is implemented using the <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a> framework. A broad variety of Bluetooth USB dongles is supported by <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. Broadcom BCM2033 based Bluetooth devices are supported by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> drivers. The 3Com Bluetooth PC Card 3CRWB60-A is supported by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a> driver. Serial and UART based Bluetooth devices are supported by <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a>.</p></div><div class=paragraph><p>Before attaching a device, determine which of the above drivers it uses, then load the driver. For example, if the device uses the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> driver:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>If the Bluetooth device will be attached to the system during system startup, the system can be configured to load the module at boot time by adding the driver to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Once the driver is loaded, plug in the USB dongle. If the driver load was successful, output similar to the following should appear on the console and in <span class=filename>/var/log/messages</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class=paragraph><p>To start and stop the Bluetooth stack, use its startup script. It is a good idea to stop the stack before unplugging the device. Starting the bluetooth stack might require <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> to be started. When starting the stack, the output should be similar to the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></div><div class=sect3><h4 id=_尋找其他藍牙裝置>31.5.2. 尋找其他藍牙裝置<a class=anchor href=#_尋找其他藍牙裝置></a></h4><div class=paragraph><p>The Host Controller Interface (HCI) provides a uniform method for accessing Bluetooth baseband capabilities. In FreeBSD, a netgraph HCI node is created for each Bluetooth device. For more details, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a>.</p></div><div class=paragraph><p>One of the most common tasks is discovery of Bluetooth devices within RF proximity. This operation is called <em>inquiry</em>. Inquiry and other HCI related operations are done using <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a>. The example below shows how to find out which Bluetooth devices are in range. The list of devices should be displayed in a few seconds. Note that a remote device will only answer the inquiry if it is set to <em>discoverable</em> mode.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p>The <code>BD_ADDR</code> is the unique address of a Bluetooth device, similar to the MAC address of a network card. This address is needed for further communication with a device and it is possible to assign a human readable name to a <code>BD_ADDR</code>. Information regarding the known Bluetooth hosts is contained in <span class=filename>/etc/bluetooth/hosts</span>. The following example shows how to obtain the human readable name that was assigned to the remote device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>If an inquiry is performed on a remote Bluetooth device, it will find the computer as "your.host.name (ubt0)". The name assigned to the local device can be changed at any time.</p></div><div class=paragraph><p>Remote devices can be assigned aliases in <span class=filename>/etc/bluetooth/hosts</span>. More information about <span class=filename>/etc/bluetooth/hosts</span> file might be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=bluetooth.hosts&amp;sektion=5&amp;format=html">bluetooth.hosts(5)</a>.</p></div><div class=paragraph><p>The Bluetooth system provides a point-to-point connection between two Bluetooth units, or a point-to-multipoint connection which is shared among several Bluetooth devices. The following example shows how to create a connection to a remote device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci create_connection BT_ADDR</code></pre></div></div><div class=paragraph><p><code>create_connection</code> accepts <code>BT_ADDR</code> as well as host aliases in <span class=filename>/etc/bluetooth/hosts</span>.</p></div><div class=paragraph><p>The following example shows how to obtain the list of active baseband connections for the local device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>A <em>connection handle</em> is useful when termination of the baseband connection is required, though it is normally not required to do this by hand. The stack will automatically terminate inactive baseband connections.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Type <code>hccontrol help</code> for a complete listing of available HCI commands. Most of the HCI commands do not require superuser privileges.</p></div></div><div class=sect3><h4 id=_裝置配對>31.5.3. 裝置配對<a class=anchor href=#_裝置配對></a></h4><div class=paragraph><p>By default, Bluetooth communication is not authenticated, and any device can talk to any other device. A Bluetooth device, such as a cellular phone, may choose to require authentication to provide a particular service. Bluetooth authentication is normally done with a <em>PIN code</em>, an ASCII string up to 16 characters in length. The user is required to enter the same PIN code on both devices. Once the user has entered the PIN code, both devices will generate a <em>link key</em>. After that, the link key can be stored either in the devices or in a persistent storage. Next time, both devices will use the previously generated link key. This procedure is called <em>pairing</em>. Note that if the link key is lost by either device, the pairing must be repeated.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> daemon is responsible for handling Bluetooth authentication requests. The default configuration file is <span class=filename>/etc/bluetooth/hcsecd.conf</span>. An example section for a cellular phone with the PIN code set to <code>1234</code> is shown below:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>The only limitation on PIN codes is length. Some devices, such as Bluetooth headsets, may have a fixed PIN code built in. The <code>-d</code> switch forces <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> to stay in the foreground, so it is easy to see what is happening. Set the remote device to receive pairing and initiate the Bluetooth connection to the remote device. The remote device should indicate that pairing was accepted and request the PIN code. Enter the same PIN code listed in <span class=filename>hcsecd.conf</span>. Now the computer and the remote device are paired. Alternatively, pairing can be initiated on the remote device.</p></div><div class=paragraph><p>The following line can be added to <span class=filename>/etc/rc.conf</span> to configure <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> to start automatically on system start:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The following is a sample of the <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> daemon output:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect3><h4 id=_使用_ppp_profile_存取網路>31.5.4. 使用 PPP Profile 存取網路<a class=anchor href=#_使用_ppp_profile_存取網路></a></h4><div class=paragraph><p>A Dial-Up Networking (DUN) profile can be used to configure a cellular phone as a wireless modem for connecting to a dial-up Internet access server. It can also be used to configure a computer to receive data calls from a cellular phone.</p></div><div class=paragraph><p>Network access with a PPP profile can be used to provide LAN access for a single Bluetooth device or multiple Bluetooth devices. It can also provide PC to PC connection using PPP networking over serial cable emulation.</p></div><div class=paragraph><p>In FreeBSD, these profiles are implemented with <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> and the <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> wrapper which converts a Bluetooth connection into something PPP can use. Before a profile can be used, a new PPP label must be created in <span class=filename>/etc/ppp/ppp.conf</span>. Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> for examples.</p></div><div class=paragraph><p>In this example, <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> is used to open a connection to a remote device with a <code>BD_ADDR</code> of <code>00:80:37:29:19:a4</code> on a DUNRFCOMM channel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>The actual channel number will be obtained from the remote device using the SDP protocol. It is possible to specify the RFCOMM channel by hand, and in this case <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> will not perform the SDP query. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> to find out the RFCOMM channel on the remote device.</p></div><div class=paragraph><p>In order to provide network access with the PPPLAN service, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> must be running and a new entry for LAN clients must be created in <span class=filename>/etc/ppp/ppp.conf</span>. Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> for examples. Finally, start the RFCOMMPPP server on a valid RFCOMM channel number. The RFCOMMPPP server will automatically register the Bluetooth LAN service with the local SDP daemon. The example below shows how to start the RFCOMMPPP server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect3><h4 id=_藍牙通訊協定>31.5.5. 藍牙通訊協定<a class=anchor href=#_藍牙通訊協定></a></h4><div class=paragraph><p>This section provides an overview of the various Bluetooth protocols, their function, and associated utilities.</p></div><div class=sect4><h5 id=_logical_link_control_and_adaptation_protocol_l2cap>31.5.5.1. Logical Link Control and Adaptation Protocol (L2CAP)<a class=anchor href=#_logical_link_control_and_adaptation_protocol_l2cap></a></h5><div class=paragraph><p>The Logical Link Control and Adaptation Protocol (L2CAP) provides connection-oriented and connectionless data services to upper layer protocols. L2CAP permits higher level protocols and applications to transmit and receive L2CAP data packets up to 64 kilobytes in length.</p></div><div class=paragraph><p>L2CAP is based around the concept of <em>channels</em>. A channel is a logical connection on top of a baseband connection, where each channel is bound to a single protocol in a many-to-one fashion. Multiple channels can be bound to the same protocol, but a channel cannot be bound to multiple protocols. Each L2CAP packet received on a channel is directed to the appropriate higher level protocol. Multiple channels can share the same baseband connection.</p></div><div class=paragraph><p>In FreeBSD, a netgraph L2CAP node is created for each Bluetooth device. This node is normally connected to the downstream Bluetooth HCI node and upstream Bluetooth socket nodes. The default name for the L2CAP node is "devicel2cap". For more details refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a>.</p></div><div class=paragraph><p>A useful command is <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>, which can be used to ping other devices. Some Bluetooth implementations might not return all of the data sent to them, so <code>0 bytes</code> in the following example is normal.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> utility is used to perform various operations on L2CAP nodes. This example shows how to obtain the list of logical connections (channels) and the list of baseband connections for the local device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>Another diagnostic tool is <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a>. It is similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>, but for Bluetooth network-related data structures. The example below shows the same logical connection as <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> above.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect4><h5 id=_radio_frequency_communication_rfcomm>31.5.5.2. Radio Frequency Communication (RFCOMM)<a class=anchor href=#_radio_frequency_communication_rfcomm></a></h5><div class=paragraph><p>The RFCOMM protocol provides emulation of serial ports over the L2CAP protocol. RFCOMM is a simple transport protocol, with additional provisions for emulating the 9 circuits of RS-232 (EIATIA-232-E) serial ports. It supports up to 60 simultaneous connections (RFCOMM channels) between two Bluetooth devices.</p></div><div class=paragraph><p>For the purposes of RFCOMM, a complete communication path involves two applications running on the communication endpoints with a communication segment between them. RFCOMM is intended to cover applications that make use of the serial ports of the devices in which they reside. The communication segment is a direct connect Bluetooth link from one device to another.</p></div><div class=paragraph><p>RFCOMM is only concerned with the connection between the devices in the direct connect case, or between the device and a modem in the network case. RFCOMM can support other configurations, such as modules that communicate via Bluetooth wireless technology on one side and provide a wired interface on the other side.</p></div><div class=paragraph><p>In FreeBSD, RFCOMM is implemented at the Bluetooth sockets layer.</p></div></div><div class=sect4><h5 id=_service_discovery_protocol_sdp>31.5.5.3. Service Discovery Protocol (SDP)<a class=anchor href=#_service_discovery_protocol_sdp></a></h5><div class=paragraph><p>The Service Discovery Protocol (SDP) provides the means for client applications to discover the existence of services provided by server applications as well as the attributes of those services. The attributes of a service include the type or class of service offered and the mechanism or protocol information needed to utilize the service.</p></div><div class=paragraph><p>SDP involves communication between a SDP server and a SDP client. The server maintains a list of service records that describe the characteristics of services associated with the server. Each service record contains information about a single service. A client may retrieve information from a service record maintained by the SDP server by issuing a SDP request. If the client, or an application associated with the client, decides to use a service, it must open a separate connection to the service provider in order to utilize the service. SDP provides a mechanism for discovering services and their attributes, but it does not provide a mechanism for utilizing those services.</p></div><div class=paragraph><p>Normally, a SDP client searches for services based on some desired characteristics of the services. However, there are times when it is desirable to discover which types of services are described by an SDP server’s service records without any prior information about the services. This process of looking for any offered services is called <em>browsing</em>.</p></div><div class=paragraph><p>The Bluetooth SDP server, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>, and command line client, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a>, are included in the standard FreeBSD installation. The following example shows how to perform a SDP browse query.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class=paragraph><p>Note that each service has a list of attributes, such as the RFCOMM channel. Depending on the service, the user might need to make note of some of the attributes. Some Bluetooth implementations do not support service browsing and may return an empty list. In this case, it is possible to search for the specific service. The example below shows how to search for the OBEX Object Push (OPUSH) service:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>Offering services on FreeBSD to Bluetooth clients is done with the <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> server. The following line can be added to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then the <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> daemon can be started with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sdpd start</span></code></pre></div></div><div class=paragraph><p>The local server application that wants to provide a Bluetooth service to remote clients will register the service with the local SDP daemon. An example of such an application is <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Once started, it will register the Bluetooth LAN service with the local SDP daemon.</p></div><div class=paragraph><p>The list of services registered with the local SDP server can be obtained by issuing a SDP browse query via the local control channel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect4><h5 id=_obex_object_push_opush>31.5.5.4. OBEX Object Push (OPUSH)<a class=anchor href=#_obex_object_push_opush></a></h5><div class=paragraph><p>Object Exchange (OBEX) is a widely used protocol for simple file transfers between mobile devices. Its main use is in infrared communication, where it is used for generic file transfers between notebooks or PDAs, and for sending business cards or calendar entries between cellular phones and other devices with Personal Information Manager (PIM) applications.</p></div><div class=paragraph><p>The OBEX server and client are implemented by obexapp, which can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a> package or port.</p></div><div class=paragraph><p>The OBEX client is used to push and/or pull objects from the OBEX server. An example object is a business card or an appointment. The OBEX client can obtain the RFCOMM channel number from the remote device via SDP. This can be done by specifying the service name instead of the RFCOMM channel number. Supported service names are: <code>IrMC</code>, <code>FTRN</code>, and <code>OPUSH</code>. It is also possible to specify the RFCOMM channel as a number. Below is an example of an OBEX session where the device information object is pulled from the cellular phone, and a new object, the business card, is pushed into the phone’s directory.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>In order to provide the OPUSH service, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> must be running and a root folder, where all incoming objects will be stored, must be created. The default path to the root folder is <span class=filename>/var/spool/obex</span>. Finally, start the OBEX server on a valid RFCOMM channel number. The OBEX server will automatically register the OPUSH service with the local SDP daemon. The example below shows how to start the OBEX server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect4><h5 id=_serial_port_profile_spp>31.5.5.5. Serial Port Profile (SPP)<a class=anchor href=#_serial_port_profile_spp></a></h5><div class=paragraph><p>The Serial Port Profile (SPP) allows Bluetooth devices to perform serial cable emulation. This profile allows legacy applications to use Bluetooth as a cable replacement, through a virtual serial port abstraction.</p></div><div class=paragraph><p>In FreeBSD, <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> implements SPP and a pseudo tty is used as a virtual serial port abstraction. The example below shows how to connect to a remote device’s serial port service. A RFCOMM channel does not have to be specified as <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> can obtain it from the remote device via SDP. To override this, specify a RFCOMM channel on the command line.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t</span>
rfcomm_sppd[94692]: Starting on /dev/pts/6...
/dev/pts/6</code></pre></div></div><div class=paragraph><p>Once connected, the pseudo tty can be used as serial port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/pts/6</span></code></pre></div></div><div class=paragraph><p>The pseudo tty is printed on stdout and can be read by wrapper scripts:</p></div><div class="literalblock programlisting"><div class=content><pre>PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
cu -l $PTS</pre></div></div></div></div><div class=sect3><h4 id=_疑難排解_6>31.5.6. 疑難排解<a class=anchor href=#_疑難排解_6></a></h4><div class=paragraph><p>By default, when FreeBSD is accepting a new connection, it tries to perform a role switch and become master. Some older Bluetooth devices which do not support role switching will not be able to connect. Since role switching is performed when a new connection is being established, it is not possible to ask the remote device if it supports role switching. However, there is a HCI option to disable role switching on the local side:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div><div class=paragraph><p>To display Bluetooth packets, use the third-party package hcidump, which can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a> package or port. This utility is similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> and can be used to display the contents of Bluetooth packets on the terminal and to dump the Bluetooth packets to a file.</p></div></div></div><div class=sect2><h3 id=network-bridging>31.6. 橋接<a class=anchor href=#network-bridging></a></h3><div class=paragraph><p>It is sometimes useful to divide a network, such as an Ethernet segment, into network segments without having to create IP subnets and use a router to connect the segments together. A device that connects two networks together in this fashion is called a "bridge".</p></div><div class=paragraph><p>A bridge works by learning the MAC addresses of the devices on each of its network interfaces. It forwards traffic between networks only when the source and destination MAC addresses are on different networks. In many respects, a bridge is like an Ethernet switch with very few ports. A FreeBSD system with multiple network interfaces can be configured to act as a bridge.</p></div><div class=paragraph><p>Bridging can be useful in the following situations:</p></div><div class=dlist><dl><dt class=hdlist1>Connecting Networks</dt><dd><p>The basic operation of a bridge is to join two or more network segments. There are many reasons to use a host-based bridge instead of networking equipment, such as cabling constraints or firewalling. A bridge can also connect a wireless interface running in hostap mode to a wired network and act as an access point.</p></dd><dt class=hdlist1>Filtering/Traffic Shaping Firewall</dt><dd><p>A bridge can be used when firewall functionality is needed without routing or Network Address Translation (NAT).</p><div class=paragraph><p>An example is a small company that is connected via DSL or ISDN to an ISP. There are thirteen public IP addresses from the ISP and ten computers on the network. In this situation, using a router-based firewall is difficult because of subnetting issues. A bridge-based firewall can be configured without any IP addressing issues.</p></div></dd><dt class=hdlist1>Network Tap</dt><dd><p>A bridge can join two network segments in order to inspect all Ethernet frames that pass between them using <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> on the bridge interface or by sending a copy of all frames out an additional interface known as a span port.</p></dd><dt class=hdlist1>Layer 2 VPN</dt><dd><p>Two Ethernet networks can be joined across an IP link by bridging the networks to an EtherIP tunnel or a <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a> based solution such as OpenVPN.</p></dd><dt class=hdlist1>Layer 2 Redundancy</dt><dd><p>A network can be connected together with multiple links and use the Spanning Tree Protocol (STP) to block redundant paths.</p></dd></dl></div><div class=paragraph><p>This section describes how to configure a FreeBSD system as a bridge using <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a>. A netgraph bridging driver is also available, and is described in <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bridge&amp;sektion=4&amp;format=html">ng_bridge(4)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Packet filtering can be used with any firewall package that hooks into the <a href="https://man.freebsd.org/cgi/man.cgi?query=pfil&amp;sektion=9&amp;format=html">pfil(9)</a> framework. The bridge can be used as a traffic shaper with <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_開啟橋接>31.6.1. 開啟橋接<a class=anchor href=#_開啟橋接></a></h4><div class=paragraph><p>In FreeBSD, <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> is a kernel module which is automatically loaded by <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> when creating a bridge interface. It is also possible to compile bridge support into a custom kernel by adding <code>device if_bridge</code> to the custom kernel configuration file.</p></div><div class=paragraph><p>The bridge is created using interface cloning. To create the bridge interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge create</span>
bridge0
<span class=c># ifconfig bridge0</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:00:00:00:00:00 priority 0 ifcost 0 port 0</code></pre></div></div><div class=paragraph><p>When a bridge interface is created, it is automatically assigned a randomly generated Ethernet address. The <code>maxaddr</code> and <code>timeout</code> parameters control how many MAC addresses the bridge will keep in its forwarding table and how many seconds before each entry is removed after it is last seen. The other parameters control how STP operates.</p></div><div class=paragraph><p>Next, specify which network interfaces to add as members of the bridge. For the bridge to forward packets, all member interfaces and the bridge need to be up:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 up</span>
<span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span></code></pre></div></div><div class=paragraph><p>The bridge can now forward Ethernet frames between <span class=filename>fxp0</span> and <span class=filename>fxp1</span>. Add the following lines to <span class=filename>/etc/rc.conf</span> so the bridge is created at startup:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;addm fxp0 addm fxp1 up&#34;
ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;</pre></div></div><div class=paragraph><p>If the bridge host needs an IP address, set it on the bridge interface, not on the member interfaces. The address can be set statically or via DHCP. This example sets a static IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>It is also possible to assign an IPv6 address to a bridge interface. To make the changes permanent, add the addressing information to <span class=filename>/etc/rc.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When packet filtering is enabled, bridged packets will pass through the filter inbound on the originating interface on the bridge interface, and outbound on the appropriate interfaces. Either stage can be disabled. When direction of the packet flow is important, it is best to firewall on the member interfaces rather than the bridge itself.</p></div><div class=paragraph><p>The bridge has several configurable settings for passing non-IP and IP packets, and layer2 firewalling with <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. See <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> for more information.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_開啟_spanning_tree>31.6.2. 開啟 Spanning Tree<a class=anchor href=#_開啟_spanning_tree></a></h4><div class=paragraph><p>For an Ethernet network to function properly, only one active path can exist between two devices. The STP protocol detects loops and puts redundant links into a blocked state. Should one of the active links fail, STP calculates a different tree and enables one of the blocked paths to restore connectivity to all points in the network.</p></div><div class=paragraph><p>The Rapid Spanning Tree Protocol (RSTP or 802.1w) provides backwards compatibility with legacy STP. RSTP provides faster convergence and exchanges information with neighboring switches to quickly transition to forwarding mode without creating loops. FreeBSD supports RSTP and STP as operating modes, with RSTP being the default mode.</p></div><div class=paragraph><p>STP can be enabled on member interfaces using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. For a bridge with <span class=filename>fxp0</span> and <span class=filename>fxp1</span> as the current interfaces, enable STP with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 stp fxp0 stp fxp1</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>This bridge has a spanning tree ID of <code>00:01:02:4b:d4:50</code> and a priority of <code>32768</code>. As the <code>root id</code> is the same, it indicates that this is the root bridge for the tree.</p></div><div class=paragraph><p>Another bridge on the network also has STP enabled:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>The line <code>root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4</code> shows that the root bridge is <code>00:01:02:4b:d4:50</code> and has a path cost of <code>400000</code> from this bridge. The path to the root bridge is via <code>port 4</code> which is <span class=filename>fxp0</span>.</p></div></div><div class=sect3><h4 id=_橋接介面參數>31.6.3. 橋接介面參數<a class=anchor href=#_橋接介面參數></a></h4><div class=paragraph><p>Several <code>ifconfig</code> parameters are unique to bridge interfaces. This section summarizes some common uses for these parameters. The complete list of available parameters is described in <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class=dlist><dl><dt class=hdlist1>private</dt><dd><p>A private interface does not forward any traffic to any other port that is also designated as a private interface. The traffic is blocked unconditionally so no Ethernet frames will be forwarded, including ARP packets. If traffic needs to be selectively blocked, a firewall should be used instead.</p></dd><dt class=hdlist1>span</dt><dd><p>A span port transmits a copy of every Ethernet frame received by the bridge. The number of span ports configured on a bridge is unlimited, but if an interface is designated as a span port, it cannot also be used as a regular bridge port. This is most useful for snooping a bridged network passively on another host connected to one of the span ports of the bridge. For example, to send a copy of all frames out the interface named <span class=filename>fxp4</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 span fxp4</span></code></pre></div></div></dd><dt class=hdlist1>sticky</dt><dd><p>If a bridge member interface is marked as sticky, dynamically learned address entries are treated as static entries in the forwarding cache. Sticky entries are never aged out of the cache or replaced, even if the address is seen on a different interface. This gives the benefit of static address entries without the need to pre-populate the forwarding table. Clients learned on a particular segment of the bridge cannot roam to another segment.</p><div class=paragraph><p>An example of using sticky addresses is to combine the bridge with VLANs in order to isolate customer networks without wasting IP address space. Consider that <code>CustomerA</code> is on <code>vlan100</code>, <code>CustomerB</code> is on <code>vlan101</code>, and the bridge has the address <code>192.168.0.1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</span>
<span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>In this example, both clients see <code>192.168.0.1</code> as their default gateway. Since the bridge cache is sticky, one host cannot spoof the MAC address of the other customer in order to intercept their traffic.</p></div><div class=paragraph><p>Any communication between the VLANs can be blocked using a firewall or, as seen in this example, private interfaces:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 private vlan100 private vlan101</span></code></pre></div></div><div class=paragraph><p>The customers are completely isolated from each other and the full <code>/24</code> address range can be allocated without subnetting.</p></div><div class=paragraph><p>The number of unique source MAC addresses behind an interface can be limited. Once the limit is reached, packets with unknown source addresses are dropped until an existing host cache entry expires or is removed.</p></div><div class=paragraph><p>The following example sets the maximum number of Ethernet devices for <code>CustomerA</code> on <code>vlan100</code> to 10:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 ifmaxaddr vlan100 10</span></code></pre></div></div></dd></dl></div><div class=paragraph><p>Bridge interfaces also support monitor mode, where the packets are discarded after <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> processing and are not processed or forwarded further. This can be used to multiplex the input of two or more interfaces into a single <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> stream. This is useful for reconstructing the traffic for network taps that transmit the RX/TX signals out through two separate interfaces. For example, to read the input from four network interfaces as one stream:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</span>
<span class=c># tcpdump -i bridge0</span></code></pre></div></div></div><div class=sect3><h4 id=_snmp_監視>31.6.4. SNMP 監視<a class=anchor href=#_snmp_監視></a></h4><div class=paragraph><p>The bridge interface and STP parameters can be monitored via <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> which is included in the FreeBSD base system. The exported bridge MIBs conform to IETF standards so any SNMP client or monitoring package can be used to retrieve the data.</p></div><div class=paragraph><p>To enable monitoring on the bridge, uncomment this line in <span class=filename>/etc/snmpd.config</span> by removing the beginning <code>#</code> symbol:</p></div><div class="literalblock programlisting"><div class=content><pre>begemotSnmpdModulePath.&#34;bridge&#34; = &#34;/usr/lib/snmp_bridge.so&#34;</pre></div></div><div class=paragraph><p>Other configuration settings, such as community names and access lists, may need to be modified in this file. See <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=snmp_bridge&amp;sektion=3&amp;format=html">snmp_bridge(3)</a> for more information. Once these edits are saved, add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>bsnmpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then, start <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bsnmpd start</span></code></pre></div></div><div class=paragraph><p>The following examples use the Net-SNMP software (<a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/net-snmp/>net-mgmt/net-snmp</a>) to query a bridge from a client system. The <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/bsnmptools/>net-mgmt/bsnmptools</a> port can also be used. From the SNMP client which is running Net-SNMP, add the following lines to <span class=filename>$HOME/.snmp/snmp.conf</span> in order to import the bridge MIB definitions:</p></div><div class="literalblock programlisting"><div class=content><pre>mibdirs +/usr/shared/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</pre></div></div><div class=paragraph><p>To monitor a single bridge using the IETF BRIDGE-MIB (RFC4188):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 <span class=o>=</span> STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 <span class=o>=</span> INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 <span class=o>=</span> Timeticks: <span class=o>(</span>189959<span class=o>)</span> 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 <span class=o>=</span> Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 <span class=o>=</span> INTEGER: forwarding<span class=o>(</span>5<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortEnable.3 <span class=o>=</span> INTEGER: enabled<span class=o>(</span>1<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortPathCost.3 <span class=o>=</span> INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 <span class=o>=</span> INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 <span class=o>=</span> Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 <span class=o>=</span> Counter32: 1
RSTP-MIB::dot1dStpVersion.0 <span class=o>=</span> INTEGER: rstp<span class=o>(</span>2<span class=o>)</span></code></pre></div></div><div class=paragraph><p>The <code>dot1dStpTopChanges.0</code> value is two, indicating that the STP bridge topology has changed twice. A topology change means that one or more links in the network have changed or failed and a new tree has been calculated. The <code>dot1dStpTimeSinceTopologyChange.0</code> value will show when this happened.</p></div><div class=paragraph><p>To monitor multiple bridge interfaces, the private BEGEMOT-BRIDGE-MIB can be used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>116927<span class=o>)</span> 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>82773<span class=o>)</span> 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 50 8B B8 C6 A9</code></pre></div></div><div class=paragraph><p>To change the bridge interface being monitored via the <code>mib-2.dot1dBridge</code> subtree:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpset <span class=nt>-v</span> 2c <span class=nt>-c</span> private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</code></pre></div></div></div></div><div class=sect2><h3 id=network-aggregation>31.7. Link Aggregation 與容錯移轉<a class=anchor href=#network-aggregation></a></h3><div class=paragraph><p>FreeBSD provides the <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> interface which can be used to aggregate multiple network interfaces into one virtual interface in order to provide failover and link aggregation. Failover allows traffic to continue to flow as long as at least one aggregated network interface has an established link. Link aggregation works best on switches which support LACP, as this protocol distributes traffic bi-directionally while responding to the failure of individual links.</p></div><div class=paragraph><p>The aggregation protocols supported by the lagg interface determine which ports are used for outgoing traffic and whether or not a specific port accepts incoming traffic. The following protocols are supported by <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>:</p></div><div class=dlist><dl><dt class=hdlist1>failover</dt><dd><p>This mode sends and receives traffic only through the master port. If the master port becomes unavailable, the next active port is used. The first interface added to the virtual interface is the master port and all subsequently added interfaces are used as failover devices. If failover to a non-master port occurs, the original port becomes master once it becomes available again.</p></dd><dt class=hdlist1>fec / loadbalance</dt><dd><p>Cisco™ Fast EtherChannel™ (FEC) is found on older Cisco™ switches. It provides a static setup and does not negotiate aggregation with the peer or exchange frames to monitor the link. If the switch supports LACP, that should be used instead.</p></dd><dt class=hdlist1>lacp</dt><dd><p>The IEEE™ 802.3ad Link Aggregation Control Protocol (LACP) negotiates a set of aggregable links with the peer into one or more Link Aggregated Groups (LAGs). Each LAG is composed of ports of the same speed, set to full-duplex operation, and traffic is balanced across the ports in the LAG with the greatest total speed. Typically, there is only one LAG which contains all the ports. In the event of changes in physical connectivity, LACP will quickly converge to a new configuration.</p><div class=paragraph><p>LACP balances outgoing traffic across the active ports based on hashed protocol header information and accepts incoming traffic from any active port. The hash includes the Ethernet source and destination address and, if available, the VLAN tag, and the IPv4 or IPv6 source and destination address.</p></div></dd><dt class=hdlist1>roundrobin</dt><dd><p>This mode distributes outgoing traffic using a round-robin scheduler through all active ports and accepts incoming traffic from any active port. Since this mode violates Ethernet frame ordering, it should be used with caution.</p></dd></dl></div><div class=sect3><h4 id=_設定範例>31.7.1. 設定範例<a class=anchor href=#_設定範例></a></h4><div class=paragraph><p>This section demonstrates how to configure a Cisco™ switch and a FreeBSD system for LACP load balancing. It then shows how to configure two Ethernet interfaces in failover mode as well as how to configure failover mode between an Ethernet and a wireless interface.</p></div><div id=networking-lacp-aggregation-cisco class=exampleblock><div class=title>例 50. Cisco™ 交換器上設定 LACP Aggregation</div><div class=content><div class=paragraph><p>This example connects two <a href="https://man.freebsd.org/cgi/man.cgi?query=fxp&amp;sektion=4&amp;format=html">fxp(4)</a> Ethernet interfaces on a FreeBSD machine to the first two Ethernet ports on a Cisco™ switch as a single load balanced and fault tolerant link. More interfaces can be added to increase throughput and fault tolerance. Replace the names of the Cisco™ ports, Ethernet devices, channel group number, and IP address shown in the example to match the local configuration.</p></div><div class=paragraph><p>Frame ordering is mandatory on Ethernet links and any traffic between two stations always flows over the same physical link, limiting the maximum speed to that of one interface. The transmit algorithm attempts to use as much information as it can to distinguish different traffic flows and balance the flows across the available interfaces.</p></div><div class=paragraph><p>On the Cisco™ switch, add the <em>FastEthernet0/1</em> and <em>FastEthernet0/2</em> interfaces to channel group <em>1</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
<span class=o>!</span>
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</code></pre></div></div><div class=paragraph><p>On the FreeBSD system, create the <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> interface using the physical interfaces <em>fxp0</em> and <em>fxp1</em> and bring the interfaces up with an IP address of <em>10.0.0.3/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</span></code></pre></div></div><div class=paragraph><p>Next, verify the status of the virtual interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</code></pre></div></div><div class=paragraph><p>Ports marked as <code>ACTIVE</code> are part of the LAG that has been negotiated with the remote switch. Traffic will be transmitted and received through these active ports. Add <code>-v</code> to the above command to view the LAG identifiers.</p></div><div class=paragraph><p>To see the port status on the Cisco™ switch:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is <span class=k>in </span>Active mode       P - Device is <span class=k>in </span>Passive mode

Channel group 1 neighbors

Partner<span class=s1>&#39;s information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</span></code></pre></div></div><div class=paragraph><p>For more detail, type <code>show lacp neighbor detail</code>.</p></div><div class=paragraph><p>To retain this configuration across reboots, add the following entries to <span class=filename>/etc/rc.conf</span> on the FreeBSD system:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24&#34;</pre></div></div></div></div><div id=networking-lagg-failover class=exampleblock><div class=title>例 51. 容錯移轉模式</div><div class=content><div class=paragraph><p>Failover mode can be used to switch over to a secondary interface if the link is lost on the master interface. To configure failover, make sure that the underlying physical interfaces are up, then create the <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> interface. In this example, <em>fxp0</em> is the master interface, <em>fxp1</em> is the secondary interface, and the virtual interface is assigned an IP address of <em>10.0.0.15/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</span></code></pre></div></div><div class=paragraph><p>The virtual interface should look something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;</code></pre></div></div><div class=paragraph><p>Traffic will be transmitted and received on <em>fxp0</em>. If the link is lost on <em>fxp0</em>, <em>fxp1</em> will become the active link. If the link is restored on the master interface, it will once again become the active link.</p></div><div class=paragraph><p>To retain this configuration across reboots, add the following entries to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24&#34;</pre></div></div></div></div><div id=networking-lagg-wired-and-wireless class=exampleblock><div class=title>例 52. 乙太網路與無線介面間的容錯移轉模式</div><div class=content><div class=paragraph><p>For laptop users, it is usually desirable to configure the wireless device as a secondary which is only used when the Ethernet connection is not available. With <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>, it is possible to configure a failover which prefers the Ethernet connection for both performance and security reasons, while maintaining the ability to transfer data over the wireless connection.</p></div><div class=paragraph><p>This is achieved by overriding the physical wireless interface’s MAC address with that of the Ethernet interface.</p></div><div class=paragraph><p>In this example, the Ethernet interface, <em>bge0</em>, is the master and the wireless interface, <em>wlan0</em>, is the failover. The <em>wlan0</em> device was created from <em>iwn0</em> wireless interface, which will be configured with the MAC address of the Ethernet interface. First, determine the MAC address of the Ethernet interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bge0</span>
bge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	<span class=nv>options</span><span class=o>=</span>19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
	ether 00:21:70:da:ae:37
	inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
	nd6 <span class=nv>options</span><span class=o>=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
	media: Ethernet autoselect <span class=o>(</span>1000baseT &lt;full-duplex&gt;<span class=o>)</span>
	status: active</code></pre></div></div><div class=paragraph><p>Replace <em>bge0</em> to match the system’s Ethernet interface name. The <code>ether</code> line will contain the MAC address of the specified interface. Now, change the MAC address of the underlying wireless interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig iwn0 ether 00:21:70:da:ae:37</span></code></pre></div></div><div class=paragraph><p>Bring the wireless interface up, but do not set an IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev iwn0 ssid my_router up</span></code></pre></div></div><div class=paragraph><p>Make sure the <em>bge0</em> interface is up, then create the <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> interface with <em>bge0</em> as master with failover to <em>wlan0</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bge0 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport bge0 laggport wlan0</span></code></pre></div></div><div class=paragraph><p>The virtual interface should look something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:21:70:da:ae:37
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: wlan0 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        laggport: bge0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;</code></pre></div></div><div class=paragraph><p>Then, start the DHCP client to obtain an IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient lagg0</span></code></pre></div></div><div class=paragraph><p>To retain this configuration across reboots, add the following entries to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_bge0=&#34;up&#34;
wlans_iwn0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA&#34;
create_args_wlan0=&#34;wlanaddr 00:21:70:da:ae:37&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;up laggproto failover laggport bge0 laggport wlan0 DHCP&#34;</pre></div></div></div></div></div></div><div class=sect2><h3 id=network-diskless>31.8. PXE 無磁碟作業<a class=anchor href=#network-diskless></a></h3><div class=paragraph><p>The Intel™ Preboot eXecution Environment (PXE) allows an operating system to boot over the network. For example, a FreeBSD system can boot over the network and operate without a local disk, using file systems mounted from an NFS server. PXE support is usually available in the BIOS. To use PXE when the machine starts, select the <code>Boot from network</code> option in the BIOS setup or type a function key during system initialization.</p></div><div class=paragraph><p>In order to provide the files needed for an operating system to boot over the network, a PXE setup also requires properly configured DHCP, TFTP, and NFS servers, where:</p></div><div class=ulist><ul><li><p>Initial parameters, such as an IP address, executable boot filename and location, server name, and root path are obtained from the DHCP server.</p></li><li><p>The operating system loader file is booted using TFTP.</p></li><li><p>The file systems are loaded using NFS.</p></li></ul></div><div class=paragraph><p>When a computer PXE boots, it receives information over DHCP about where to obtain the initial boot loader file. After the host computer receives this information, it downloads the boot loader via TFTP and then executes the boot loader. In FreeBSD, the boot loader file is <span class=filename>/boot/pxeboot</span>. After <span class=filename>/boot/pxeboot</span> executes, the FreeBSD kernel is loaded and the rest of the FreeBSD bootup sequence proceeds, as described in <a href=./#boot>FreeBSD 開機程序</a>.</p></div><div class=paragraph><p>This section describes how to configure these services on a FreeBSD system so that other systems can PXE boot into FreeBSD. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a> for more information.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>As described, the system providing these services is insecure. It should live in a protected area of a network and be untrusted by other hosts.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=network-pxe-nfs>31.8.1. 設定 PXE 環境<a class=anchor href=#network-pxe-nfs></a></h4><div class=paragraph><p>The steps shown in this section configure the built-in NFS and TFTP servers. The next section demonstrates how to install and configure the DHCP server. In this example, the directory which will contain the files used by PXE users is <span class=filename>/b/tftpboot/FreeBSD/install</span>. It is important that this directory exists and that the same directory name is set in both <span class=filename>/etc/inetd.conf</span> and <span class=filename>/usr/local/etc/dhcpd.conf</span>.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Create the root directory which will contain a FreeBSD installation to be NFS mounted:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># export NFSROOTDIR=/b/tftpboot/FreeBSD/install</span>
<span class=c># mkdir -p ${NFSROOTDIR}</span></code></pre></div></div></li><li><p>Enable the NFS server by adding this line to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Export the diskless root directory via NFS by adding the following to <span class=filename>/etc/exports</span>:</p><div class="literalblock programlisting"><div class=content><pre>/b -ro -alldirs -maproot=root</pre></div></div></li><li><p>Start the NFS server:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div></li><li><p>Enable <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> by adding the following line to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div></li><li><p>Uncomment the following line in <span class=filename>/etc/inetd.conf</span> by making sure it does not start with a <code>#</code> symbol:</p><div class="literalblock programlisting"><div class=content><pre>tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Some PXE versions require the TCP version of TFTP. In this case, uncomment the second <code>tftp</code> line which contains <code>stream tcp</code>.</p></div></td></tr></tbody></table></div></li><li><p>Start <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div></li><li><p>Install the base system into <span class=filename>${NFSROOTDIR}</span>, either by decompressing the official archives or by rebuilding the FreeBSD kernel and userland (refer to <a href=./#makeworld>從原始碼更新 FreeBSD</a> for more detailed instructions, but do not forget to add <code>DESTDIR=<em>${NFSROOTDIR}</em></code> when running the <code>make installkernel</code> and <code>make installworld</code> commands.</p></li><li><p>Test that the TFTP server works and can download the boot loader which will be obtained via PXE:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp localhost</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div></li><li><p>Edit <span class=filename>${NFSROOTDIR}/etc/fstab</span> and create an entry to mount the root file system over NFS:</p><div class="literalblock programlisting"><div class=content><pre># Device                                         Mountpoint    FSType   Options  Dump Pass
myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</pre></div></div><div class=paragraph><p>Replace <em>myhost.example.com</em> with the hostname or IP address of the NFS server. In this example, the root file system is mounted read-only in order to prevent NFS clients from potentially deleting the contents of the root file system.</p></div></li><li><p>Set the root password in the PXE environment for client machines which are PXE booting :</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># passwd</span></code></pre></div></div></li><li><p>If needed, enable <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> root logins for client machines which are PXE booting by editing <span class=filename>${NFSROOTDIR}/etc/ssh/sshd_config</span> and enabling <code>PermitRootLogin</code>. This option is documented in <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a>.</p></li><li><p>Perform any other needed customizations of the PXE environment in <span class=filename>${NFSROOTDIR}</span>. These customizations could include things like installing packages or editing the password file with <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>.</p></li></ol></div></div></div><div class=paragraph><p>When booting from an NFS root volume, <span class=filename>/etc/rc</span> detects the NFS boot and runs <span class=filename>/etc/rc.initdiskless</span>. In this case, <span class=filename>/etc</span> and <span class=filename>/var</span> need to be memory backed file systems so that these directories are writable but the NFS root directory is read-only:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># mkdir -p conf/base</span>
<span class=c># tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</span>
<span class=c># tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</span></code></pre></div></div><div class=paragraph><p>When the system boots, memory file systems for <span class=filename>/etc</span> and <span class=filename>/var</span> will be created and mounted and the contents of the <span class=filename>cpio.gz</span> files will be copied into them. By default, these file systems have a maximum capacity of 5 megabytes. If your archives do not fit, which is usually the case for <span class=filename>/var</span> when binary packages have been installed, request a larger size by putting the number of 512 byte sectors needed (e.g., 5 megabytes is 10240 sectors) in <span class=filename>${NFSROOTDIR}/conf/base/etc/md_size</span> and <span class=filename>${NFSROOTDIR}/conf/base/var/md_size</span> files for <span class=filename>/etc</span> and <span class=filename>/var</span> file systems respectively.</p></div></div><div class=sect3><h4 id=network-pxe-setting-up-dhcp>31.8.2. 設定 DHCP 伺服器<a class=anchor href=#network-pxe-setting-up-dhcp></a></h4><div class=paragraph><p>The DHCP server does not need to be the same machine as the TFTP and NFS server, but it needs to be accessible in the network.</p></div><div class=paragraph><p>DHCP is not part of the FreeBSD base system but can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a> port or package.</p></div><div class=paragraph><p>Once installed, edit the configuration file, <span class=filename>/usr/local/etc/dhcpd.conf</span>. Configure the <code>next-server</code>, <code>filename</code>, and <code>root-path</code> settings as seen in this example:</p></div><div class="literalblock programlisting"><div class=content><pre>subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-servers 192.168.35.35, 192.168.35.36 ;
   option domain-name &#34;example.com&#34;;

   # IP address of TFTP server
   next-server 192.168.0.1 ;

   # path of boot loader obtained via tftp
   filename &#34;FreeBSD/install/boot/pxeboot&#34; ;

   # pxeboot boot loader will try to NFS mount this directory for root FS
   option root-path &#34;192.168.0.1:/b/tftpboot/FreeBSD/install/&#34; ;

}</pre></div></div><div class=paragraph><p>The <code>next-server</code> directive is used to specify the IP address of the TFTP server.</p></div><div class=paragraph><p>The <code>filename</code> directive defines the path to <span class=filename>/boot/pxeboot</span>. A relative filename is used, meaning that <span class=filename>/b/tftpboot</span> is not included in the path.</p></div><div class=paragraph><p>The <code>root-path</code> option defines the path to the NFS root file system.</p></div><div class=paragraph><p>Once the edits are saved, enable DHCP at boot time by adding the following line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then start the DHCP service:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div></div><div class=sect3><h4 id=_pxe_問題除錯>31.8.3. PXE 問題除錯<a class=anchor href=#_pxe_問題除錯></a></h4><div class=paragraph><p>Once all of the services are configured and started, PXE clients should be able to automatically load FreeBSD over the network. If a particular client is unable to connect, when that client machine boots up, enter the BIOS configuration menu and confirm that it is set to boot from the network.</p></div><div class=paragraph><p>This section describes some troubleshooting tips for isolating the source of the configuration problem should no clients be able to PXE boot.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Use the <a class=package href=https://cgit.freebsd.org/ports/tree/net/wireshark/>net/wireshark</a> package or port to debug the network traffic involved during the PXE booting process, which is illustrated in the diagram below.</p><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/pxe-nfs.png alt="pxe nfs"></div><div class=title>图 54. 使用 NFS Root Mount 進行 PXE 開機程序</div></div></li><li><p>On the TFTP server, read <span class=filename>/var/log/xferlog</span> to ensure that <span class=filename>pxeboot</span> is being retrieved from the correct location. To test this example configuration:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp 192.168.0.1</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div><div class=paragraph><p>The <code>BUGS</code> sections in <a href="https://man.freebsd.org/cgi/man.cgi?query=tftpd&amp;sektion=8&amp;format=html">tftpd(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=tftp&amp;sektion=1&amp;format=html">tftp(1)</a> document some limitations with TFTP.</p></div></li><li><p>Make sure that the root file system can be mounted via NFS. To test this example configuration:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</span></code></pre></div></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=network-ipv6>31.9. IPv6<a class=anchor href=#network-ipv6></a></h3><div class=paragraph><p>IPv6 is the new version of the well known IP protocol, also known as IPv4. IPv6 provides several advantages over IPv4 as well as many new features:</p></div><div class=ulist><ul><li><p>Its 128-bit address space allows for 340,282,366,920,938,463,463,374,607,431,768,211,456 addresses. This addresses the IPv4 address shortage and eventual IPv4 address exhaustion.</p></li><li><p>Routers only store network aggregation addresses in their routing tables, thus reducing the average space of a routing table to 8192 entries. This addresses the scalability issues associated with IPv4, which required every allocated block of IPv4 addresses to be exchanged between Internet routers, causing their routing tables to become too large to allow efficient routing.</p></li><li><p>Address autoconfiguration (<a href=http://www.ietf.org/rfc/rfc2462.txt>RFC2462</a>).</p></li><li><p>Mandatory multicast addresses.</p></li><li><p>Built-in IPsec (IP security).</p></li><li><p>Simplified header structure.</p></li><li><p>Support for mobile IP.</p></li><li><p>IPv6-to-IPv4 transition mechanisms.</p></li></ul></div><div class=paragraph><p>FreeBSD includes the <a href=http://www.kame.net/>http://www.kame.net/</a>IPv6 reference implementation and comes with everything needed to use IPv6. This section focuses on getting IPv6 configured and running.</p></div><div class=sect3><h4 id=_ipv6_位址的背景知識>31.9.1. IPv6 位址的背景知識<a class=anchor href=#_ipv6_位址的背景知識></a></h4><div class=paragraph><p>There are three different types of IPv6 addresses:</p></div><div class=dlist><dl><dt class=hdlist1>Unicast</dt><dd><p>A packet sent to a unicast address arrives at the interface belonging to the address.</p></dd><dt class=hdlist1>Anycast</dt><dd><p>These addresses are syntactically indistinguishable from unicast addresses but they address a group of interfaces. The packet destined for an anycast address will arrive at the nearest router interface. Anycast addresses are only used by routers.</p></dd><dt class=hdlist1>Multicast</dt><dd><p>These addresses identify a group of interfaces. A packet destined for a multicast address will arrive at all interfaces belonging to the multicast group. The IPv4 broadcast address, usually <code>xxx.xxx.xxx.255</code>, is expressed by multicast addresses in IPv6.</p></dd></dl></div><div class=paragraph><p>When reading an IPv6 address, the canonical form is represented as <code>x:x:x:x:x:x:x:x</code>, where each <code>x</code> represents a 16 bit hex value. An example is <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code>.</p></div><div class=paragraph><p>Often, an address will have long substrings of all zeros. A <code>::</code> (double colon) can be used to replace one substring per address. Also, up to three leading <code>0</code>s per hex value can be omitted. For example, <code>fe80::1</code> corresponds to the canonical form <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>.</p></div><div class=paragraph><p>A third form is to write the last 32 bits using the well known IPv4 notation. For example, <code>2002::10.0.0.1</code> corresponds to the hexadecimal canonical representation <code>2002:0000:0000:0000:0000:0000:0a00:0001</code>, which in turn is equivalent to <code>2002::a00:1</code>.</p></div><div class=paragraph><p>To view a FreeBSD system’s IPv6 address, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre></div></div><div class=paragraph><p>In this example, the <span class=filename>rl0</span> interface is using <code>fe80::200:21ff:fe03:8e1%rl0</code>, an auto-configured link-local address which was automatically generated from the MAC address.</p></div><div class=paragraph><p>Some IPv6 addresses are reserved. A summary of these reserved addresses is seen in <a href=#reservedip6>已保留的 IPv6 位址</a>:</p></div><table id=reservedip6 class="tableblock frame-none grid-all stretch"><caption class=title>表 30. 已保留的 IPv6 位址</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">IPv6 address</th><th class="tableblock halign-left valign-top">Prefixlength (Bits)</th><th class="tableblock halign-left valign-top">說明</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unspecified</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalent to <code>0.0.0.0</code> in IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>loopback address</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalent to <code>127.0.0.1</code> in IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>embedded IPv4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The lower 32 bits are the compatible IPv4 address.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 mapped IPv6 address</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The lower 32 bits are the IPv4 address for hosts which do not support IPv6.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::/10</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>link-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalent to 169.254.0.0/16 in IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fc00::/7</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unique-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Unique local addresses are intended for local communication and are only routable within a set of cooperating sites.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff00::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>multicast</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>2000::-3fff:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>global unicast</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All global unicast addresses are assigned from this pool. The first 3 bits are <code>001</code>.</p></td></tr></tbody></table><div class=paragraph><p>For further information on the structure of IPv6 addresses, refer to <a href=http://www.ietf.org/rfc/rfc3513.txt>RFC3513</a>.</p></div></div><div class=sect3><h4 id=_設定_ipv6>31.9.2. 設定 IPv6<a class=anchor href=#_設定_ipv6></a></h4><div class=paragraph><p>To configure a FreeBSD system as an IPv6 client, add these two lines to <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 accept_rtadv&#34;
rtsold_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The first line enables the specified interface to receive router advertisement messages. The second line enables the router solicitation daemon, <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsol&amp;sektion=8&amp;format=html">rtsol(8)</a>.</p></div><div class=paragraph><p>If the interface needs a statically assigned IPv6 address, add an entry to specify the static address and associated prefix length:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen 64&#34;</pre></div></div><div class=paragraph><p>To assign a default router, specify its address:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;2001:db8:4672:6565::1&#34;</pre></div></div></div><div class=sect3><h4 id=_連線到_provider>31.9.3. 連線到 Provider<a class=anchor href=#_連線到_provider></a></h4><div class=paragraph><p>In order to connect to other IPv6 networks, one must have a provider or a tunnel that supports IPv6:</p></div><div class=ulist><ul><li><p>Contact an Internet Service Provider to see if they offer IPv6.</p></li><li><p><a href=http://www.tunnelbroker.net>Hurricane Electric</a> offers tunnels with end-points all around the globe.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Install the <a class=package href=https://cgit.freebsd.org/ports/tree/net/freenet6/>net/freenet6</a> package or port for a dial-up connection.</p></div></td></tr></tbody></table></div><div class=paragraph><p>This section demonstrates how to take the directions from a tunnel provider and convert them into <span class=filename>/etc/rc.conf</span> settings that will persist through reboots.</p></div><div class=paragraph><p>The first <span class=filename>/etc/rc.conf</span> entry creates the generic tunneling interface <span class=filename>gif0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;gif0&#34;</pre></div></div><div class=paragraph><p>Next, configure that interface with the IPv4 addresses of the local and remote endpoints. Replace <em>MY_IPv4_ADDR</em> and <em>REMOTE_IPv4_ADDR</em> with the actual IPv4 addresses:</p></div><div class="literalblock programlisting"><div class=content><pre>create_args_gif0=&#34;tunnel MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre></div></div><div class=paragraph><p>To apply the IPv6 address that has been assigned for use as the IPv6 tunnel endpoint, add this line, replacing <em>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</em> with the assigned address:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_gif0_ipv6=&#34;inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Then, set the default route for the other side of the IPv6 tunnel. Replace <em>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</em> with the default gateway address assigned by the provider:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>If the FreeBSD system will route IPv6 packets between the rest of the network and the world, enable the gateway using this line:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_gateway_enable=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=_router_advertisement_與_host_auto_configuration>31.9.4. Router Advertisement 與 Host Auto Configuration<a class=anchor href=#_router_advertisement_與_host_auto_configuration></a></h4><div class=paragraph><p>This section demonstrates how to setup <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> to advertise the IPv6 default route.</p></div><div class=paragraph><p>To enable <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>, add the following to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>It is important to specify the interface on which to do IPv6 router advertisement. For example, to tell <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> to use <span class=filename>rl0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_interfaces=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>Next, create the configuration file, <span class=filename>/etc/rtadvd.conf</span> as seen in this example:</p></div><div class="literalblock programlisting"><div class=content><pre>rl0:\
	:addrs#1:addr=&#34;2001:db8:1f11:246::&#34;:prefixlen#64:tc=ether:</pre></div></div><div class=paragraph><p>Replace <span class=filename>rl0</span> with the interface to be used and <code>2001:db8:1f11:246::</code> with the prefix of the allocation.</p></div><div class=paragraph><p>For a dedicated <code>/64</code> subnet, nothing else needs to be changed. Otherwise, change the <code>prefixlen#</code> to the correct value.</p></div></div><div class=sect3><h4 id=_ipv6_與_ipv6_位址對應表>31.9.5. IPv6 與 IPv6 位址對應表<a class=anchor href=#_ipv6_與_ipv6_位址對應表></a></h4><div class=paragraph><p>When IPv6 is enabled on a server, there may be a need to enable IPv4 mapped IPv6 address communication. This compatibility option allows for IPv4 addresses to be represented as IPv6 addresses. Permitting IPv6 applications to communicate with IPv4 and vice versa may be a security issue.</p></div><div class=paragraph><p>This option may not be required in most cases and is available only for compatibility. This option will allow IPv6-only applications to work with IPv4 in a dual stack environment. This is most useful for third party applications which may not support an IPv6-only environment. To enable this feature, add the following to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ipv4mapping=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Reviewing the information in RFC 3493, section 3.6 and 3.7 as well as RFC 4038 section 4.2 may be useful to some administrators.</p></div></div></div><div class=sect2><h3 id=carp>31.10. 共用位址備援協定 (CARP)<a class=anchor href=#carp></a></h3><div class=paragraph><p>The Common Address Redundancy Protocol (CARP) allows multiple hosts to share the same IP address and Virtual Host ID (VHID) in order to provide <em>high availability</em> for one or more services. This means that one or more hosts can fail, and the other hosts will transparently take over so that users do not see a service failure.</p></div><div class=paragraph><p>In addition to the shared IP address, each host has its own IP address for management and configuration. All of the machines that share an IP address have the same VHID. The VHID for each virtual IP address must be unique across the broadcast domain of the network interface.</p></div><div class=paragraph><p>High availability using CARP is built into FreeBSD, though the steps to configure it vary slightly depending upon the FreeBSD version. This section provides the same example configuration for versions before and equal to or after FreeBSD 10.</p></div><div class=paragraph><p>This example configures failover support with three hosts, all with unique IP addresses, but providing the same web content. It has two different masters named <code>hosta.example.org</code> and <code>hostb.example.org</code>, with a shared backup named <code>hostc.example.org</code>.</p></div><div class=paragraph><p>These machines are load balanced with a Round Robin DNS configuration. The master and backup machines are configured identically except for their hostnames and management IP addresses. These servers must have the same configuration and run the same services. When the failover occurs, requests to the service on the shared IP address can only be answered correctly if the backup server has access to the same content. The backup machine has two additional CARP interfaces, one for each of the master content server’s IP addresses. When a failure occurs, the backup server will pick up the failed master machine’s IP address.</p></div><div class=sect3><h4 id=carp-10x>31.10.1. 使用 CARP 於 FreeBSD 10 及之後版本<a class=anchor href=#carp-10x></a></h4><div class=paragraph><p>Enable boot-time support for CARP by adding an entry for the <span class=filename>carp.ko</span> kernel module in <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To load the module now without rebooting:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>For users who prefer to use a custom kernel, include the following line in the custom kernel configuration file and compile the kernel as described in <a href=./#kernelconfig>設定 FreeBSD 核心</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>The hostname, management IP address and subnet mask, shared IP address, and VHID are all set by adding entries to <span class=filename>/etc/rc.conf</span>. This example is for <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 pass testpass alias 192.168.1.50/32&#34;</pre></div></div><div class=paragraph><p>The next set of entries are for <code>hostb.example.org</code>. Since it represents a second master, it uses a different shared IP address and VHID. However, the passwords specified with <code>pass</code> must be identical as CARP will only listen to and accept advertisements from machines with the correct password.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 2 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>The third machine, <code>hostc.example.org</code>, is configured to handle failover from either master. This machine is configured with two CARPVHIDs, one to handle the virtual IP address for each of the master hosts. The CARP advertising skew, <code>advskew</code>, is set to ensure that the backup host advertises later than the master, since <code>advskew</code> controls the order of precedence when there are multiple backup servers.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32&#34;
ifconfig_em0_alias1=&#34;inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>Having two CARPVHIDs configured means that <code>hostc.example.org</code> will notice if either of the master servers becomes unavailable. If a master fails to advertise before the backup server, the backup server will pick up the shared IP address until the master becomes available again.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If the original master server becomes available again, <code>hostc.example.org</code> will not release the virtual IP address back to it automatically. For this to happen, preemption has to be enabled. The feature is disabled by default, it is controlled via the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable <code>net.inet.carp.preempt</code>. The administrator can force the backup server to return the IP address to the master:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0 vhid 1 state backup</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Once the configuration is complete, either restart networking or reboot each system. High availability is now enabled.</p></div><div class=paragraph><p>CARP functionality can be controlled via several <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variables documented in the <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a> manual pages. Other actions can be triggered from CARP events by using <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>.</p></div></div><div class=sect3><h4 id=carp-9x>31.10.2. 使用 CARP 於 FreeBSD 9 及先前版本<a class=anchor href=#carp-9x></a></h4><div class=paragraph><p>The configuration for these versions of FreeBSD is similar to the one described in the previous section, except that a CARP device must first be created and referred to in the configuration.</p></div><div class=paragraph><p>Enable boot-time support for CARP by loading the <span class=filename>if_carp.ko</span> kernel module in <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>if_carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To load the module now without rebooting:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>For users who prefer to use a custom kernel, include the following line in the custom kernel configuration file and compile the kernel as described in <a href=./#kernelconfig>設定 FreeBSD 核心</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>Next, on each host, create a CARP device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 create</span></code></pre></div></div><div class=paragraph><p>Set the hostname, management IP address, the shared IP address, and VHID by adding the required lines to <span class=filename>/etc/rc.conf</span>. Since a virtual CARP device is used instead of an alias, the actual subnet mask of <code>/24</code> is used instead of <code>/32</code>. Here are the entries for <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpass 192.168.1.50/24&#34;</pre></div></div><div class=paragraph><p>On <code>hostb.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class=paragraph><p>The third machine, <code>hostc.example.org</code>, is configured to handle failover from either of the master hosts:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Preemption is disabled in the <span class=filename>GENERIC</span> FreeBSD kernel. If preemption has been enabled with a custom kernel, <code>hostc.example.org</code> may not release the IP address back to the original content server. The administrator can force the backup server to return the IP address to the master with the command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre></div></div><div class=paragraph><p>This should be done on the <span class=filename>carp</span> interface which corresponds to the correct host.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Once the configuration is complete, either restart networking or reboot each system. High availability is now enabled.</p></div></div></div><div class=sect2><h3 id=network-vlan>31.11. VLANs<a class=anchor href=#network-vlan></a></h3><div class=paragraph><p>VLANs are a way of virtually dividing up a network into many different subnetworks, also referred to as segmenting. Each segment will have its own broadcast domain and be isolated from other VLANs.</p></div><div class=paragraph><p>在 FreeBSD 上，要使用 VLANs 必須有網路卡驅動程式的支援，要查看那些驅動程式支援 vlan，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=vlan&amp;sektion=4&amp;format=html">vlan(4)</a> 操作手冊。</p></div><div class=paragraph><p>When configuring a VLAN, a couple pieces of information must be known. First, which network interface? Second, what is the VLAN tag?</p></div><div class=paragraph><p>To configure VLANs at run time, with a NIC of <code>em0</code> and a VLAN tag of <code>5</code> the command would look like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>See how the interface name includes the NIC driver name and the VLAN tag, separated by a period? This is a best practice to make maintaining the VLAN configuration easy when many VLANs are present on a machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To configure VLANs at boot time, <span class=filename>/etc/rc.conf</span> must be updated. To duplicate the configuration above, the following will need to be added:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_em0=&#34;5&#34;
ifconfig_em0_5=&#34;inet 192.168.20.20/24&#34;</pre></div></div><div class=paragraph><p>Additional VLANs may be added, by simply adding the tag to the <code>vlans<em>em0</em></code> field and adding an additional line configuring the network on that VLAN tag’s interface.</p></div><div class=paragraph><p>It is useful to assign a symbolic name to an interface so that when the associated hardware is changed, only a few configuration variables need to be updated. For example, security cameras need to be run over VLAN 1 on <code>em0</code>. Later, if the <code>em0</code> card is replaced with a card that uses the <a href="https://man.freebsd.org/cgi/man.cgi?query=ixgb&amp;sektion=4&amp;format=html">ixgb(4)</a> driver, all references to <code>em0.1</code> will not have to change to <code>ixgb0.1</code>.</p></div><div class=paragraph><p>To configure VLAN <code>5</code>, on the NIC <code>em0</code>, assign the interface name <code>cameras</code>, and assign the interface an IP address of <code><em>192.168.20.20</em></code> with a <code>24</code>-bit prefix, use this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>For an interface named <code>video</code>, use the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>To apply the changes at boot time, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_video=&#34;camera&#34;
create_args_camera=&#34;vlan 5&#34;
ifconfig_camera=&#34;inet 192.168.20.20/24&#34;</pre></div></div></div></div></div><h1 id=appendices class=sect0>Part V: 附錄<a class=anchor href=#appendices></a></h1><div class=sect1><h2 id=mirrors>附錄 A: 取得 FreeBSD<a class=anchor href=#mirrors></a></h2><div class=sectionbody><div class=sect2><h3 id=mirrors-cdrom>A.1. CD 與 DVD 合集<a class=anchor href=#mirrors-cdrom></a></h3><div class=paragraph><p>FreeBSD CD 以及 DVD 組可從以下幾個線上零售商取得：</p></div><div class=ulist><ul><li><p>FreeBSD Mall, Inc.<br>2420 Sand Creek Rd C-1 #347<br>Brentwood, CA<br>94513<br>USA<br>Phone: +1 925 240-6652<br>Fax: +1 925 674-0821<br>Email: &lt;<a href=mailto:info@freebsdmall.com>info@freebsdmall.com</a>><br>WWW: <a href=https://www.freebsdmall.com class=bare>https://www.freebsdmall.com</a></p></li><li><p>Getlinux<br>78 Rue de la Croix Rochopt<br>Épinay-sous-Sénart<br>91860<br>France<br>Email: &lt;<a href=mailto:contact@getlinux.fr>contact@getlinux.fr</a>><br>WWW: <a href=http://www.getlinux.fr/ class=bare>http://www.getlinux.fr/</a></p></li><li><p>Dr. Hinner EDV<br>Kochelseestr. 11<br>D-81371 München<br>Germany<br>Phone: (0177) 428 419 0<br>Email: &lt;<a href=mailto:infow@hinner.de>infow@hinner.de</a>><br>WWW: <a href=http://www.hinner.de/linux/freebsd.html class=bare>http://www.hinner.de/linux/freebsd.html</a></p></li><li><p>Linux Center<br>Galernaya Street, 55<br>Saint-Petersburg<br>190000<br>Russia<br>Phone: +7-812-309-06-86<br>Email: &lt;<a href=mailto:info@linuxcenter.ru>info@linuxcenter.ru</a>><br>WWW: <a href=http://linuxcenter.ru/shop/freebsd class=bare>http://linuxcenter.ru/shop/freebsd</a></p></li></ul></div></div><div class=sect2><h3 id=mirrors-ftp>A.2. FTP 站<a class=anchor href=#mirrors-ftp></a></h3><div class=paragraph><p>FreeBSD 的官方原始碼可從全球任一鏡像站透過匿名 FTP 取得。其中 <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/>ftp://ftp.FreeBSD.org/pub/FreeBSD/</a> 站可使用 HTTP 及 FTP，該站是由多台由計畫叢集管理員所維護的主機所組成，且在 GeoDNS 之後，可導向使用者到最近可用的鏡像站。</p></div><div class=paragraph><p>除此之外，FreeBSD 也可透過匿名 FTP 從下列鏡像站取得。要透過匿名 FTP 取得 FreeBSD 時，請先嘗試使用臨近的站台。列在 "主要鏡像站" 中的鏡像站通常會有完整的 FreeBSD 封存檔 (每一個架構目前所有可用的版本)，但若要考慮下載速度，可能要使用您所在國家或區域的站台。區域的站台會有熱門架構最近期的版本，但不會有完整的 FreeBSD 封存檔。所有站台皆提供匿名 FTP 存取只有部份站台會以其他方式提供存取。每個站台可用的存取方式會列在主機名稱後的括號當中。</p></div><div class=paragraph><p><a href=#central>Central Servers</a>, <a href=#primary>Primary Mirror Sites</a>, <a href=#armenia>Armenia</a>, <a href=#australia>Australia</a>, <a href=#austria>Austria</a>, <a href=#brazil>Brazil</a>, <a href=#czech-republic>Czech Republic</a>, <a href=#denmark>Denmark</a>, <a href=#estonia>Estonia</a>, <a href=#finland>Finland</a>, <a href=#france>France</a>, <a href=#germany>Germany</a>, <a href=#greece>Greece</a>, <a href=#hong-kong>Hong Kong</a>, <a href=#ireland>Ireland</a>, <a href=#japan>Japan</a>, <a href=#korea>Korea</a>, <a href=#latvia>Latvia</a>, <a href=#lithuania>Lithuania</a>, <a href=#netherlands>Netherlands</a>, <a href=#new-zealand>New Zealand</a>, <a href=#norway>Norway</a>, <a href=#poland>Poland</a>, <a href=#russia>Russia</a>, <a href=#saudi-arabia>Saudi Arabia</a>, <a href=#slovenia>Slovenia</a>, <a href=#south-africa>South Africa</a>, <a href=#spain>Spain</a>, <a href=#sweden>Sweden</a>, <a href=#switzerland>Switzerland</a>, <a href=#taiwan>Taiwan</a>, <a href=#ukraine>Ukraine</a>, <a href=#uk>United Kingdom</a>, <a href=#usa>United States of America</a>.</p></div><div class=paragraph><p>(as of UTC)</p></div><div id=central class=paragraph><p><strong>Central Servers</strong></p></div><div class=paragraph><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.FreeBSD.org/pub/FreeBSD/</a>)</p></div><div id=primary class=paragraph><p><strong>Primary Mirror Sites</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:mirror-admin@FreeBSD.org>mirror-admin@FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp10.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp10.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp10.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp11.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp14.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp14.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp14.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=armenia class=paragraph><p><strong>Armenia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@am.FreeBSD.org>hostmaster@am.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp1.am.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp1.am.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li></ul></div><div id=australia class=paragraph><p><strong>Australia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@au.FreeBSD.org>hostmaster@au.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=austria class=paragraph><p><strong>Austria</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@at.FreeBSD.org>hostmaster@at.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.at.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.at.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.at.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=brazil class=paragraph><p><strong>Brazil</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@br.FreeBSD.org>hostmaster@br.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp2.br.FreeBSD.org/FreeBSD/ class=bare>ftp://ftp2.br.FreeBSD.org/FreeBSD/</a> (ftp / <a href=http://ftp2.br.FreeBSD.org/ class=bare>http://ftp2.br.FreeBSD.org/</a>)</p></li><li><p><a href=ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=czech-republic class=paragraph><p><strong>Czech Republic</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@cz.FreeBSD.org>hostmaster@cz.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.cz.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=denmark class=paragraph><p><strong>Denmark</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:staff@dotsrc.org>staff@dotsrc.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.dk.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.dk.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=estonia class=paragraph><p><strong>Estonia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ee.FreeBSD.org>hostmaster@ee.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=finland class=paragraph><p><strong>Finland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@fi.FreeBSD.org>hostmaster@fi.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=france class=paragraph><p><strong>France</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@fr.FreeBSD.org>hostmaster@fr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp1.fr.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp1.fr.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=germany class=paragraph><p><strong>Germany</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:de-bsd-hubs@de.FreeBSD.org>de-bsd-hubs@de.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.de.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp1.de.FreeBSD.org/freebsd/ class=bare>ftp://ftp1.de.FreeBSD.org/freebsd/</a> (ftp / <a href=http://www1.de.FreeBSD.org/freebsd/ class=bare>http://www1.de.FreeBSD.org/freebsd/</a> / rsync://rsync3.de.FreeBSD.org/freebsd/)</p></li><li><p><a href=ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.de.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp4.de.FreeBSD.org/FreeBSD/ class=bare>ftp://ftp4.de.FreeBSD.org/FreeBSD/</a> (ftp / <a href=http://ftp4.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.de.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp7.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp7.de.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=greece class=paragraph><p><strong>Greece</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@gr.FreeBSD.org>hostmaster@gr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=hong-kong class=paragraph><p><strong>Hong Kong</strong></p></div><div class=paragraph><p><a href=ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></div><div id=ireland class=paragraph><p><strong>Ireland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ie.FreeBSD.org>hostmaster@ie.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li></ul></div><div id=japan class=paragraph><p><strong>Japan</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@jp.FreeBSD.org>hostmaster@jp.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=korea class=paragraph><p><strong>Korea</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@kr.FreeBSD.org>hostmaster@kr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.kr.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.kr.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=latvia class=paragraph><p><strong>Latvia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@lv.FreeBSD.org>hostmaster@lv.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.lv.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.lv.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=lithuania class=paragraph><p><strong>Lithuania</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@lt.FreeBSD.org>hostmaster@lt.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.lt.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.lt.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=netherlands class=paragraph><p><strong>Netherlands</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@nl.FreeBSD.org>hostmaster@nl.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.nl.FreeBSD.org/os/FreeBSD/ class=bare>http://ftp.nl.FreeBSD.org/os/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=new-zealand class=paragraph><p><strong>New Zealand</strong></p></div><div class=ulist><ul><li><p><a href=ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.nz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.nz.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=norway class=paragraph><p><strong>Norway</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@no.FreeBSD.org>hostmaster@no.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.no.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.no.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li></ul></div><div id=poland class=paragraph><p><strong>Poland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@pl.FreeBSD.org>hostmaster@pl.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p>ftp2.pl.FreeBSD.org</p></li></ul></div><div id=russia class=paragraph><p><strong>Russia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ru.FreeBSD.org>hostmaster@ru.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ru.FreeBSD.org/FreeBSD/ class=bare>http://ftp.ru.FreeBSD.org/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.ru.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.ru.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp5.ru.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp5.ru.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=saudi-arabia class=paragraph><p><strong>Saudi Arabia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:ftpadmin@isu.net.sa>ftpadmin@isu.net.sa</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.isu.net.sa/pub/ftp.freebsd.org class=bare>ftp://ftp.isu.net.sa/pub/ftp.freebsd.org</a> (ftp)</p></li></ul></div><div id=slovenia class=paragraph><p><strong>Slovenia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@si.FreeBSD.org>hostmaster@si.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.si.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.si.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=south-africa class=paragraph><p><strong>South Africa</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@za.FreeBSD.org>hostmaster@za.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=spain class=paragraph><p><strong>Spain</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@es.FreeBSD.org>hostmaster@es.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.es.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.es.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.es.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.es.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=sweden class=paragraph><p><strong>Sweden</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@se.FreeBSD.org>hostmaster@se.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.se.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync://ftp2.se.FreeBSD.org/)</p></li><li><p><a href=ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/ / rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/)</p></li><li><p><a href=ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp6.se.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=switzerland class=paragraph><p><strong>Switzerland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ch.FreeBSD.org>hostmaster@ch.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.ch.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=taiwan class=paragraph><p><strong>Taiwan</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@tw.FreeBSD.org>hostmaster@tw.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.tw.FreeBSD.org/ class=bare>http://ftp6.tw.FreeBSD.org/</a> / rsync)</p></li><li><p><a href=ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp11.tw.FreeBSD.org/FreeBSD/ class=bare>http://ftp11.tw.FreeBSD.org/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=ukraine class=paragraph><p><strong>Ukraine</strong></p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ua.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.ua.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.ua.FreeBSD.org/pub/FreeBSD class=bare>http://ftp6.ua.FreeBSD.org/pub/FreeBSD</a> / rsync://ftp6.ua.FreeBSD.org/FreeBSD/)</p></li><li><p><a href=ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=uk class=paragraph><p><strong>United Kingdom</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@uk.FreeBSD.org>hostmaster@uk.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync://ftp2.uk.FreeBSD.org/ftp.freebsd.org/pub/FreeBSD/)</p></li><li><p><a href=ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=usa class=paragraph><p><strong>United States of America</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@us.FreeBSD.org>hostmaster@us.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.us.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.us.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp13.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp13.us.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp14.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp14.us.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div></div><div class=sect2><h3 id=svn>A.3. 使用 Subversion<a class=anchor href=#svn></a></h3><div class=sect3><h4 id=svn-intro>A.3.1. 簡介<a class=anchor href=#svn-intro></a></h4><div class=paragraph><p>自 2012 年 7 月起，FreeBSD 儲存所有 FreeBSD 的原始碼、文件與 Port 套件集均使用 Subversion 作為其唯一的版本控制系統。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Subversion 只是一套開發人員工具。一般使用者可能會較喜歡使用 <code>freebsd-update</code> (<a href=./#updating-upgrading-freebsdupdate>FreeBSD 更新</a>) 來更新 FreeBSD 基礎系統及 <code>portsnap</code> (<a href=./#ports-using>使用 Port 套件集</a>) 來更新 FreeBSD Port 套件集。</p></div></td></tr></tbody></table></div><div class=paragraph><p>本節將示範如何在 FreeBSD 系統安裝 Subversion 以及使用它建立一個本地的 FreeBSD 檔案庫複本，也包含使用 Subversion 的其他資訊。</p></div></div><div class=sect3><h4 id=svn-ssl-certificates>A.3.2. 根 SSL 憑證<a class=anchor href=#svn-ssl-certificates></a></h4><div class=paragraph><p>安裝 <a class=package href=https://cgit.freebsd.org/ports/tree/security/ca_root_nss/>security/ca_root_nss</a> 可讓 Subversion 能夠驗証 HTTPS 檔案庫伺服器的身份。root SSL 憑証可從 Port 安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/security/ca_root_nss</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>或從套件：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install ca_root_nss</span></code></pre></div></div></div><div class=sect3><h4 id=svn-svnlite>A.3.3. Svnlite<a class=anchor href=#svn-svnlite></a></h4><div class=paragraph><p>輕量化版的 Subversion <code>svnlite</code> 已會隨 FreeBSD 安裝。Port 或套件版的 Subversion 僅在要使用其 Python 或 Perl API 時需要，或是新想要使用最新版本 Subversion 時才需要。</p></div><div class=paragraph><p>與正常 Subversion 唯一的差別只是指令名稱改為 <code>svnlite</code>。</p></div></div><div class=sect3><h4 id=svn-install>A.3.4. 安裝<a class=anchor href=#svn-install></a></h4><div class=paragraph><p>若無法使用 <code>svnlite</code> 或需要完整版本的 Subversion 就必須安裝。</p></div><div class=paragraph><p>Subversion 可從 Port 套件集安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/devel/subversion</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Subversion 也可以以套件安裝：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install subversion</span></code></pre></div></div></div><div class=sect3><h4 id=svn-usage>A.3.5. 執行 Subversion<a class=anchor href=#svn-usage></a></h4><div class=paragraph><p>要下載原始碼乾淨的複本到本地目錄可使用 <code>svn</code>。在此目錄中的檔案稱作 <em>本地工作複本 (Local working copy)</em>。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>在第一次使用 <code>checkout</code> 前請先移動或刪除目地現有的目錄。</p></div><div class=paragraph><p>在現有非 <code>svn</code> 目錄存在的情況下做取出 (Checkout) 的動作會導致現有檔案與檔案庫中的檔案發生衝突。</p></div></td></tr></tbody></table></div><div class=paragraph><p>Subversion 使用 URL 來指定檔案庫，使用的格式為 <em>protocol://hostname/path</em>。路徑的第一個部份為要存取的 FreeBSD 檔案庫，目前有三個檔案庫，<code>base</code> 為 FreeBSD 基礎系統原始碼、<code>ports</code> 為 Port 套件集以及 <code>doc</code> 為說明文件。舉例來說，URL <code><a href=https://svn.FreeBSD.org/ports/head/ class=bare>https://svn.FreeBSD.org/ports/head/</a></code> 代表 Port 檔案庫的主要分支，使用 <code>https</code> 通訊協定。</p></div><div class=paragraph><p>使用指令從指定的檔案庫取出 (Checkout) 原始碼如下：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/repository/branch lwcdir</span></code></pre></div></div><div class=paragraph><p>where:</p></div><div class=ulist><ul><li><p><em>repository</em> 要是下列專案檔案庫其中之一：<code>base</code>, <code>ports</code> 或 <code>doc</code>。</p></li><li><p><em>branch</em> 則依據使用的檔案庫來決定。<code>ports</code> 與 <code>doc</code> 大部份的更新皆在 <code>head</code> 分支，而 <code>base</code> 則會將 -CURRENT 的最新版本存放在 <code>head</code> 下，-STABLE 分支各自最新的版本則會放在 <code>stable/9</code> (9.<em>x</em>) 與 <code>stable/10</code> (10.<em>x</em>) 下。</p></li><li><p><em>lwcdir</em> 則是要存放指定分支內容的目標目錄，通常 <code>ports</code> 會置於 <span class=filename>/usr/ports</span>，<code>base</code> 會置於 <span class=filename>/usr/src</span> 以及 <code>doc</code> 會置於 <span class=filename>/usr/doc</span>。</p></li></ul></div><div class=paragraph><p>以下範例會使用 HTTPS 協定從 FreeBSD 的檔案庫取出 Port 套件集，並將本地工作複本放置於 <span class=filename>/usr/ports</span>。若 <span class=filename>/usr/ports</span> 已存在，且不是由 <code>svn</code> 所建立的，記得要在取出之前重新命名或刪除。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/ports/head /usr/ports</span></code></pre></div></div><div class=paragraph><p>由於首次取出的動作必須下載遠端檔案庫中完整的分支，會需要花費一段時間，請耐心等候。</p></div><div class=paragraph><p>首次取出之後，往後要更新本地工作複本可以執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update lwcdir</span></code></pre></div></div><div class=paragraph><p>要更新上述範例所建立的 <span class=filename>/usr/ports</span> 可執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update /usr/ports</span></code></pre></div></div><div class=paragraph><p>因為只會傳輸有更新過的檔案，更新的動作會比取出還要快速。</p></div><div class=paragraph><p>另一種在取出之後更新本地工作複本的方式是透過 <span class=filename>/usr/ports</span>, <span class=filename>/usr/src</span> 以及 <span class=filename>/usr/doc</span> 目錄所提供的 <span class=filename>Makefile</span>。設定 <code>SVN_UPDATE</code> 並使用 <code>update</code> 目標。例如要更新 <span class=filename>/usr/src</span>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make update SVN_UPDATE=yes</span></code></pre></div></div></div><div class=sect3><h4 id=svn-mirrors>A.3.6. Subversion 鏡像站<a class=anchor href=#svn-mirrors></a></h4><div class=paragraph><p>FreeBSD Subversion 的檔案庫為：</p></div><div class="literalblock programlisting"><div class=content><pre>svn.FreeBSD.org</pre></div></div><div class=paragraph><p>這是可公開存取的鏡像站，使用了 GeoDNS 會自動選擇適合的後端伺服器。若要由瀏覽器檢視 Subversion 檔案庫可以使用 <a href=https://svnweb.FreeBSD.org/>https://svnweb.FreeBSD.org/</a>。</p></div><div class=paragraph><p>HTTPS is the preferred protocol, but the <span class=filename>security/ca_root_nss</span> package will need to be installed in order to automatically validate certificates.</p></div></div><div class=sect3><h4 id=_取得更多資訊_2>A.3.7. 取得更多資訊<a class=anchor href=#_取得更多資訊_2></a></h4><div class=paragraph><p>要取得其他有關使用 Subversion 的資訊請參考 "Subversion Book"，其書名為 <a href=http://svnbook.red-bean.com/>Version Control with Subversion</a> 或是 <a href=http://subversion.apache.org/docs/>Subversion Documentation</a>。</p></div></div></div><div class=sect2><h3 id=mirrors-rsync>A.4. 使用 rsync<a class=anchor href=#mirrors-rsync></a></h3><div class=paragraph><p>這些站台讓 FreeBSD 可透過 rsync 通訊協定取得。rsync 工具只會傳輸兩個檔案集之間的差異，所以能夠大大的加快在網路上同步的速度，這對大多數 FreeBSD FTP 伺服器的鏡像站非常有用。rsync 在許多作業系統上也可以使用，在 FreeBSD 上請參考 <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> Port 或使用套件。</p></div><div class=dlist><dl><dt class=hdlist1>捷克 (Czech Republic)</dt><dd><p>rsync://ftp.cz.FreeBSD.org/</p><div class=paragraph><p>可用的檔案集：</p></div><div class=ulist><ul><li><p>ftp: FreeBSD FTP 伺服器的部份鏡像。</p></li><li><p>FreeBSD: FreeBSD FTP 伺服器的完整鏡像。</p></li></ul></div></dd><dt class=hdlist1>荷蘭 (Netherlands)</dt><dd><p>rsync://ftp.nl.FreeBSD.org/</p><div class=paragraph><p>可用的檔案集：</p></div><div class=ulist><ul><li><p>FreeBSD: FreeBSD FTP 伺服器的完整鏡像。</p></li></ul></div></dd><dt class=hdlist1>俄羅斯 (Russia)</dt><dd><p>rsync://ftp.mtu.ru/</p><div class=paragraph><p>可用的檔案集：</p></div><div class=ulist><ul><li><p>FreeBSD: FreeBSD FTP 伺服器的完整鏡像。</p></li><li><p>FreeBSD-Archive: FreeBSD 封存 FTP 伺服器的鏡像。</p></li></ul></div></dd><dt class=hdlist1>瑞典 (Sweden)</dt><dd><p>rsync://ftp4.se.freebsd.org/</p><div class=paragraph><p>可用的檔案集：</p></div><div class=ulist><ul><li><p>FreeBSD: FreeBSD FTP 伺服器的完整鏡像。</p></li></ul></div></dd><dt class=hdlist1>台灣 (Taiwan)</dt><dd><p>rsync://ftp.tw.FreeBSD.org/</p><div class=paragraph><p>rsync://ftp2.tw.FreeBSD.org/</p></div><div class=paragraph><p>rsync://ftp6.tw.FreeBSD.org/</p></div><div class=paragraph><p>可用的檔案集：</p></div><div class=ulist><ul><li><p>FreeBSD: FreeBSD FTP 伺服器的完整鏡像。</p></li></ul></div></dd><dt class=hdlist1>英國 (United Kingdom)</dt><dd><p>rsync://rsync.mirrorservice.org/</p><div class=paragraph><p>可用的檔案集：</p></div><div class=ulist><ul><li><p>ftp.freebsd.org: FreeBSD FTP 伺服器的完整鏡像。</p></li></ul></div></dd><dt class=hdlist1>美國 (USA)</dt><dd><p>rsync://ftp-master.FreeBSD.org/</p><div class=paragraph><p>此伺服器僅供 FreeBSD 主要鏡像站使用。</p></div><div class=paragraph><p>可用的檔案集：</p></div><div class=ulist><ul><li><p>FreeBSD: FreeBSD FTP 伺服器的主要封存。</p></li><li><p>acl: FreeBSD 主要 ACL 清單。</p><div class=paragraph><p>rsync://ftp13.FreeBSD.org/</p></div><div class=paragraph><p>可用的檔案集：</p></div></li><li><p>FreeBSD: FreeBSD FTP 伺服器的完整鏡像。</p></li></ul></div></dd></dl></div></div></div></div><div class=sect1><h2 id=bibliography>附錄 B: 參考書目<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p>雖然操作手冊提供 FreeBSD 作業系統各個部分完整的說明，卻難免有「小學而大遺」之憾，像是如何讓整個作業系統運作順暢。因此，身邊有 UNIX™ 系統管理的好書以及好的使用手冊是不可或缺的。</p></div><div class=sect2><h3 id=bibliography-freebsd>B.1. FreeBSD 相關書籍<a class=anchor href=#bibliography-freebsd></a></h3><div class=paragraph><p>國際書籍：</p></div><div class=ulist><ul><li><p><a href=http://jdli.tw.FreeBSD.org/publication/book/freebsd2/index.htm>FreeBSD 入門與應用 (光碟豪華版)</a> (繁體中文), <a href=http://www.drmaster.com.tw/>博碩文化</a>出版, 1997. ISBN 9-578-39435-7。</p></li><li><p>FreeBSD 技術內幕 (FreeBSD Unleashed 簡體中譯版), <a href=http://www.hzbook.com/>機械工業出版社</a>出版. ISBN 7-111-10201-0。</p></li><li><p>FreeBSD 使用大全第二版 (簡體中文), 機械工業出版社出版. ISBN 7-111-10286-X。</p></li><li><p>FreeBSD Handbook 第二版 (簡體中譯版), <a href=http://www.ptpress.com.cn/>人民郵電出版社</a>出版. ISBN 7-115-10541-3。</p></li><li><p>FreeBSD & Windows 集成組網實務 (簡體中文), <a href=http://www.tdpress.com/>中國鐵道出版社</a>出版. ISBN 7-113-03845-X。</p></li><li><p>FreeBSD 網站架設實務 (簡體中文), 中國鐵道出版社出版. ISBN 7-113-03423-3。</p></li><li><p>FreeBSD (日文), CUTT 出版. ISBN 4-906391-22-2 C3055 P2400E。</p></li><li><p><a href="http://www.shoeisha.com/book/Detail.asp?bid=650">Complete Introduction to FreeBSD</a> (日文), <a href=http://www.shoeisha.co.jp/>Shoeisha Co., Ltd</a> 出版. ISBN 4-88135-473-6 P3600E。</p></li><li><p><a href=http://www.ascii.co.jp/pb/book1/shinkan/detail/1322785.html>Personal UNIX Starter Kit FreeBSD</a> (日文), <a href=http://www.ascii.co.jp/>ASCII</a> 出版. ISBN 4-7561-1733-3 P3000E。</p></li><li><p>FreeBSD Handbook (日譯版), <a href=http://www.ascii.co.jp/>ASCII</a> 出版. ISBN 4-7561-1580-2 P3800E。</p></li><li><p>FreeBSD mit Methode (德文), <a href=http://www.cul.de>Computer und Literatur Verlag</a>/Vertrieb Hanser 出版, 1998. ISBN 3-932311-31-0。</p></li><li><p><a href=http://www.mitp.de/vmi/mitp/detail/pWert/1343/>FreeBSD de Luxe</a> (德文), <a href=http://www.mitp.de>Verlag Modere Industrie</a> 出版, 2003. ISBN 3-8266-1343-0。</p></li><li><p><a href=http://www.pc.mycom.co.jp/FreeBSD/install-manual.html>FreeBSD Install and Utilization Manual</a> (日文), <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a> 出版, 1998. ISBN 4-8399-0112-0。</p></li><li><p>Onno W Purbo, Dodi Maryanto, Syahrial Hubbany, Widjil Widodo <em><a href=http://maxwell.itb.ac.id/>Building Internet Server with FreeBSD</a></em> (印尼文), <a href=http://www.elexmedia.co.id/>Elex Media Komputindo</a> 出版。</p></li><li><p>FreeBSD 完全探索 (Absolute BSD: The Ultimate Guide to FreeBSD 繁體中譯版), <a href=http://www.grandtech.com.tw/>GrandTech Press</a> 出版, 2003. ISBN 986-7944-92-5。</p></li><li><p><a href=http://www.twbsd.org/cht/book/>FreeBSD 6.0 架設管理與應用</a> (繁體中文), 博碩出版, 2006. ISBN 9-575-27878-X。</p></li></ul></div><div class=paragraph><p>英文書籍：</p></div><div class=ulist><ul><li><p><a href=http://www.absoluteFreeBSD.com/>Absolute FreeBSD, 2nd Edition: The Complete Guide to FreeBSD</a>, published by <a href=http://www.nostarch.com/>No Starch Press</a>, 2007. ISBN: 978-1-59327-151-0</p></li><li><p><a href=http://www.freebsdmall.com/cgi-bin/fm/bsdcomp>The Complete FreeBSD</a>, published by <a href=http://www.oreilly.com/>O’Reilly</a>, 2003. ISBN: 0596005164</p></li><li><p><a href=http://www.freebsd-corp-net-guide.com/>The FreeBSD Corporate Networker’s Guide</a>, published by <a href=http://www.awl.com/aw/>Addison-Wesley</a>, 2000. ISBN: 0201704811</p></li><li><p><a href=http://andrsn.stanford.edu/FreeBSD/introbook/>FreeBSD: An Open-Source Operating System for Your Personal Computer</a>, published by The Bit Tree Press, 2001. ISBN: 0971204500</p></li><li><p>Teach Yourself FreeBSD in 24 Hours, published by <a href=http://www.samspublishing.com/>Sams</a>, 2002. ISBN: 0672324245</p></li><li><p>FreeBSD 6 Unleashed, published by <a href=http://www.samspublishing.com/>Sams</a>, 2006. ISBN: 0672328755</p></li><li><p>FreeBSD: The Complete Reference, published by <a href=http://books.mcgraw-hill.com>McGrawHill</a>, 2003. ISBN: 0072224096</p></li></ul></div></div><div class=sect2><h3 id=bibliography-userguides>B.2. 使用指南<a class=anchor href=#bibliography-userguides></a></h3><div class=ulist><ul><li><p>Ohio State University has written a <a href=http://www.cs.duke.edu/csl/docs/unix_course/>UNIX Introductory Course</a> which is available online in HTML and PostScript format.</p><div class=paragraph><p>An Italian <a href=https://www.FreeBSD.org/doc/it_IT.ISO8859-15/books/unix-introduction/index.html>translation</a> of this document is available as part of the FreeBSD Italian Documentation Project.</p></div></li><li><p><a href=http://www.ed.ac.uk/>Edinburgh University</a> has written an <a href=http://www.ed.ac.uk/information-services/help-consultancy/is-skills/catalogue/program-op-sys-catalogue/unix1>Online Guide</a> for newcomers to the UNIX environment.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-adminguides>B.3. 管理指南<a class=anchor href=#bibliography-adminguides></a></h3><div class=ulist><ul><li><p><a href=http://www.jp.FreeBSD.org/>Jpman Project, Japan FreeBSD Users Group</a>. <a href=http://www.pc.mycom.co.jp/FreeBSD/sam.html>FreeBSD System Administrator’s Manual</a> (Japanese translation). <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN4-8399-0109-0 P3300E.</p></li><li><p>Dreyfus, Emmanuel. <a href=http://www.eyrolles.com/Informatique/Livre/9782212114638/>Cahiers de l’Admin: BSD</a> 2nd Ed. (in French), Eyrolles, 2004. ISBN 2-212-11463-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-programmers>B.4. 開發指南<a class=anchor href=#bibliography-programmers></a></h3><div class=ulist><ul><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Reference Manual</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-078-3</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Supplementary Documents</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-079-1</p></li><li><p>Harbison, Samuel P. and Steele, Guy L. Jr. <em>C: A Reference Manual</em>. 4th Ed. Prentice Hall, 1995. ISBN 0-13-326224-3</p></li><li><p>Kernighan, Brian and Dennis M. Ritchie. <em>The C Programming Language</em>. 2nd Ed. PTR Prentice Hall, 1988. ISBN 0-13-110362-8</p></li><li><p>Lehey, Greg. <em>Porting UNIX Software</em>. O’Reilly & Associates, Inc., 1995. ISBN 1-56592-126-7</p></li><li><p>Plauger, P. J. <em>The Standard C Library</em>. Prentice Hall, 1992. ISBN 0-13-131509-9</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codereading/>Code Reading: The Open Source Perspective</a>. Addison-Wesley, 2003. ISBN 0-201-79940-5</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codequality/>Code Quality: The Open Source Perspective</a>. Addison-Wesley, 2006. ISBN 0-321-16607-8</p></li><li><p>Stevens, W. Richard and Stephen A. Rago. <em>Advanced Programming in the UNIX Environment</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 2005. ISBN 0-201-43307-9</p></li><li><p>Stevens, W. Richard. <em>UNIX Network Programming</em>. 2nd Ed, PTR Prentice Hall, 1998. ISBN 0-13-490012-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-osinternals>B.5. 深入作業系統<a class=anchor href=#bibliography-osinternals></a></h3><div class=ulist><ul><li><p>Andleigh, Prabhat K. <em>UNIX System Architecture</em>. Prentice-Hall, Inc., 1990. ISBN 0-13-949843-5</p></li><li><p>Jolitz, William. "Porting UNIX to the 386". <em>Dr. Dobb’s Journal</em>. January 1991-July 1992.</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, Michael J Karels and John Quarterman <em>The Design and Implementation of the 4.3BSD UNIX Operating System</em>. Reading, Mass. : Addison-Wesley, 1989. ISBN 0-201-06196-1</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, <em>The Design and Implementation of the 4.3BSD UNIX Operating System: Answer Book</em>. Reading, Mass. : Addison-Wesley, 1991. ISBN 0-201-54629-9</p></li><li><p>McKusick, Marshall Kirk, Keith Bostic, Michael J Karels, and John Quarterman. <em>The Design and Implementation of the 4.4BSD Operating System</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-54979-4</p><div class=paragraph><p>(Chapter 2 of this book is available <a href=https://www.FreeBSD.org/doc/en_US.ISO8859-1/books/design-44bsd/book.html>online</a> as part of the FreeBSD Documentation Project.)</p></div></li><li><p>Marshall Kirk McKusick, George V. Neville-Neil <em>The Design and Implementation of the FreeBSD Operating System</em>. Boston, Mass. : Addison-Wesley, 2004. ISBN 0-201-70245-2</p></li><li><p>Marshall Kirk McKusick, George V. Neville-Neil, Robert N. M. Watson <em>The Design and Implementation of the FreeBSD Operating System, 2nd Ed.</em>. Westford, Mass. : Pearson Education, Inc., 2014. ISBN 0-321-96897-2</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 1: The Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63346-9</p></li><li><p>Schimmel, Curt. <em>Unix Systems for Modern Architectures</em>. Reading, Mass. : Addison-Wesley, 1994. ISBN 0-201-63338-8</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63495-3</p></li><li><p>Vahalia, Uresh. <em>UNIX Internals — The New Frontiers</em>. Prentice Hall, 1996. ISBN 0-13-101908-2</p></li><li><p>Wright, Gary R. and W. Richard Stevens. <em>TCP/IP Illustrated, Volume 2: The Implementation</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63354-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-security>B.6. 安全性參考文獻<a class=anchor href=#bibliography-security></a></h3><div class=ulist><ul><li><p>Cheswick, William R. and Steven M. Bellovin. <em>Firewalls and Internet Security: Repelling the Wily Hacker</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63357-4</p></li><li><p>Garfinkel, Simson. <em>PGP Pretty Good Privacy</em> O’Reilly & Associates, Inc., 1995. ISBN 1-56592-098-8</p></li></ul></div></div><div class=sect2><h3 id=bibliography-hardware>B.7. 硬體參考文獻<a class=anchor href=#bibliography-hardware></a></h3><div class=ulist><ul><li><p>Anderson, Don and Tom Shanley. <em>Pentium Processor System Architecture</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40992-5</p></li><li><p>Ferraro, Richard F. <em>Programmer’s Guide to the EGA, VGA, and Super VGA Cards</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-62490-7</p></li><li><p>Intel Corporation publishes documentation on their CPUs, chipsets and standards on their <a href=http://developer.intel.com/>developer web site</a>, usually as PDF files.</p></li><li><p>Shanley, Tom. <em>80486 System Architecture</em>. 3rd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40994-1</p></li><li><p>Shanley, Tom. <em>ISA System Architecture</em>. 3rd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40996-8</p></li><li><p>Shanley, Tom. <em>PCI System Architecture</em>. 4th Ed. Reading, Mass. : Addison-Wesley, 1999. ISBN 0-201-30974-2</p></li><li><p>Van Gilluwe, Frank. <em>The Undocumented PC</em>, 2nd Ed. Reading, Mass: Addison-Wesley Pub. Co., 1996. ISBN 0-201-47950-8</p></li><li><p>Messmer, Hans-Peter. <em>The Indispensable PC Hardware Book</em>, 4th Ed. Reading, Mass : Addison-Wesley Pub. Co., 2002. ISBN 0-201-59616-4</p></li></ul></div></div><div class=sect2><h3 id=bibliography-history>B.8. UNIX™ 歷史<a class=anchor href=#bibliography-history></a></h3><div class=ulist><ul><li><p>Lion, John <em>Lion’s Commentary on UNIX, 6th Ed. With Source Code</em>. ITP Media Group, 1996. ISBN 1573980137</p></li><li><p>Raymond, Eric S. <em>The New Hacker’s Dictionary, 3rd edition</em>. MIT Press, 1996. ISBN 0-262-68092-0. Also known as the <a href=http://www.catb.org/~esr/jargon/html/index.html>Jargon File</a></p></li><li><p>Salus, Peter H. <em>A quarter century of UNIX</em>. Addison-Wesley Publishing Company, Inc., 1994. ISBN 0-201-54777-5</p></li><li><p>Simon Garfinkel, Daniel Weise, Steven Strassmann. <em>The UNIX-HATERS Handbook</em>. IDG Books Worldwide, Inc., 1994. ISBN 1-56884-203-1. Out of print, but available <a href=http://www.simson.net/ref/ugh.pdf>online</a>.</p></li><li><p>Don Libes, Sandy Ressler <em>Life with UNIX</em> — special edition. Prentice-Hall, Inc., 1989. ISBN 0-13-536657-7</p></li><li><p><em>The BSD family tree</em>. <a href="https://svnweb.freebsd.org/base/head/shared/misc/bsd-family-tree?view=co">https://svnweb.freebsd.org/base/head/shared/misc/bsd-family-tree?view=co</a> or <a href=file://localhost/usr/shared/misc/bsd-family-tree>/usr/shared/misc/bsd-family-tree</a> on a FreeBSD machine.</p></li><li><p><em>Networked Computer Science Technical Reports Library</em>. <a href=http://www.ncstrl.org/>http://www.ncstrl.org/</a></p></li><li><p><em>Old BSD releases from the Computer Systems Research group (CSRG)</em>. <a href=http://www.mckusick.com/csrg/>http://www.mckusick.com/csrg/</a>: The 4CD set covers all BSD versions from 1BSD to 4.4BSD and 4.4BSD-Lite2 (but not 2.11BSD, unfortunately). The last disk also holds the final sources plus the SCCS files.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-journals>B.9. 期刊與雜誌<a class=anchor href=#bibliography-journals></a></h3><div class=ulist><ul><li><p><a href=http://www.admin-magazin.de/>Admin Magazin</a> (in German), published by Medialinx AG. ISSN: 2190-1066</p></li><li><p><a href=http://www.bsdmag.org/>BSD Magazine</a>, published by Software Press Sp. z o.o. SK. ISSN: 1898-9144</p></li><li><p><a href=http://www.bsdnow.tv/>BSD Now — Video Podcast</a>, published by Jupiter Broadcasting LLC</p></li><li><p><a href=http://bsdtalk.blogspot.com/>BSD Talk Podcast</a>, by Will Backman</p></li><li><p><a href=http://freebsdjournal.com/>FreeBSD Journal</a>, published by S&amp;W Publishing, sponsored by The FreeBSD Foundation. ISBN: 978-0-615-88479-0</p></li></ul></div></div></div></div><div class=sect1><h2 id=eresources>附錄 C: 網路資源<a class=anchor href=#eresources></a></h2><div class=sectionbody><div class=paragraph><p>The rapid pace of FreeBSD progress makes print media impractical as a means of following the latest developments. Electronic resources are the best, if not often the only, way to stay informed of the latest advances. Since FreeBSD is a volunteer effort, the user community itself also generally serves as a "technical support department" of sorts, with electronic mail, web forums, and USENET news being the most effective way of reaching that community.</p></div><div class=paragraph><p>The most important points of contact with the FreeBSD user community are outlined below. Please send other resources not mentioned here to the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc>FreeBSD documentation project mailing list</a> so that they may also be included.</p></div><div class=sect2><h3 id=eresources-www>C.1. 網站<a class=anchor href=#eresources-www></a></h3><div class=ulist><ul><li><p><a href=https://forums.FreeBSD.org/>The FreeBSD Forums</a> provide a web based discussion forum for FreeBSD questions and technical discussion.</p></li><li><p>The <a href=http://www.youtube.com/bsdconferences>BSDConferences YouTube Channel</a> provides a collection of high quality videos from BSD conferences around the world. This is a great way to watch key developers give presentations about new work in FreeBSD.</p></li></ul></div></div><div class=sect2><h3 id=eresources-mail>C.2. 郵遞論壇 (Mailing List)<a class=anchor href=#eresources-mail></a></h3><div class=paragraph><p>The mailing lists are the most direct way of addressing questions or opening a technical discussion to a concentrated FreeBSD audience. There are a wide variety of lists on a number of different FreeBSD topics. Sending questions to the most appropriate mailing list will invariably assure a faster and more accurate response.</p></div><div class=paragraph><p>The charters for the various lists are given at the bottom of this document. <em>Please read the charter before joining or sending mail to any list</em>. Most list subscribers receive many hundreds of FreeBSD related messages every day, and the charters and rules for use are meant to keep the signal-to-noise ratio of the lists high. To do less would see the mailing lists ultimately fail as an effective communications medium for the Project.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>To test the ability to send email to FreeBSD lists, send a test message to <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-test>freebsd-test</a>.</em> Please do not send test messages to any other list.</p></div></td></tr></tbody></table></div><div class=paragraph><p>When in doubt about what list to post a question to, see <a href=https://www.FreeBSD.org/doc/en_US.ISO8859-1/articles/freebsd-questions>How to get best results from the FreeBSD-questions mailing list</a>.</p></div><div class=paragraph><p>Before posting to any list, please learn about how to best use the mailing lists, such as how to help avoid frequently-repeated discussions, by reading the <a href=https://www.FreeBSD.org/doc/en_US.ISO8859-1/articles/mailing-list-faq>Mailing List Frequently Asked Questions</a> (FAQ) document.</p></div><div class=paragraph><p>Archives are kept for all of the mailing lists and can be searched using the <a href=https://www.FreeBSD.org/search/index.html>FreeBSD World Wide Web server</a>. The keyword searchable archive offers an excellent way of finding answers to frequently asked questions and should be consulted before posting a question. Note that this also means that messages sent to FreeBSD mailing lists are archived in perpetuity. When protecting privacy is a concern, consider using a disposable secondary email address and posting only public information.</p></div><div class=sect3><h4 id=eresources-summary>C.2.1. 論壇摘要<a class=anchor href=#eresources-summary></a></h4><div class=paragraph><p><em>General lists:</em> The following are general lists which anyone is free (and encouraged) to join:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">List</th><th class="tableblock halign-left valign-top">用途</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-advocacy>freebsd-advocacy</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD Evangelism</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce>freebsd-announce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Important events and Project milestones (moderated)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-arch>freebsd-arch</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Architecture and design discussions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bugbusters>freebsd-bugbusters</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions pertaining to the maintenance of the FreeBSD problem report database and related tools</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bugs>freebsd-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bug reports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chat>freebsd-chat</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Non-technical items related to the FreeBSD community</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chromium>freebsd-chromium</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-specific Chromium issues</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>freebsd-current</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion concerning the use of FreeBSD-CURRENT</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-isp>freebsd-isp</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Issues for Internet Service Providers using FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-jobs>freebsd-jobs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD employment and consulting opportunities</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>freebsd-questions</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>User questions and technical support</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security-notifications>freebsd-security-notifications</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Security notifications (moderated)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-stable>freebsd-stable</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion concerning the use of FreeBSD-STABLE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-test>freebsd-test</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Where to send test messages instead of to one of the actual lists</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-women>freebsd-women</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD advocacy for women</p></td></tr></tbody></table><div class=paragraph><p><em>Technical lists:</em> The following lists are for technical discussion. Read the charter for each list carefully before joining or sending mail to one as there are firm guidelines for their use and content.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">List</th><th class="tableblock halign-left valign-top">用途</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ACPI and power management development</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-afs>freebsd-afs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting AFS to FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-amd64>freebsd-amd64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting FreeBSD to AMD64 systems (moderated)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-apache>freebsd-apache</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion about Apache related ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-arm>freebsd-arm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting FreeBSD to ARM™ processors</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-atm>freebsd-atm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Using ATM networking with FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bluetooth>freebsd-bluetooth</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Using Bluetooth™ technology in FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-cloud>freebsd-cloud</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD on cloud platforms (EC2, GCE, Azure, etc.)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-cluster>freebsd-cluster</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Using FreeBSD in a clustered environment</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-database>freebsd-database</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussing database use and development under FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-desktop>freebsd-desktop</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Using and improving FreeBSD on the desktop</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/dev-ci>dev-ci</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Build and test reports from the Continuous Integration servers</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/dev-reviews>dev-reviews</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Notifications of the FreeBSD review system</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc>freebsd-doc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Creating FreeBSD related documents</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-drivers>freebsd-drivers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Writing device drivers for FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-dtrace>freebsd-dtrace</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Using and working on DTrace in FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-eclipse>freebsd-eclipse</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD users of Eclipse IDE, tools, rich client applications and ports.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-elastic>freebsd-elastic</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-specific ElasticSearch discussions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-embedded>freebsd-embedded</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Using FreeBSD in embedded applications</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-eol>freebsd-eol</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Peer support of FreeBSD-related software that is no longer supported by the FreeBSD Project.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-emulation>freebsd-emulation</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Emulation of other systems such as Linux/MS-DOS™/Windows™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-enlightenment>freebsd-enlightenment</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting Enlightenment and Enlightenment applications</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-erlang>freebsd-erlang</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-specific Erlang discussions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-firewire>freebsd-firewire</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD FireWire™ (iLink, IEEE 1394) technical discussion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-fortran>freebsd-fortran</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fortran on FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-fs>freebsd-fs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File systems</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-games>freebsd-games</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Support for Games on FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-gecko>freebsd-gecko</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gecko Rendering Engine issues</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-geom>freebsd-geom</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GEOM-specific discussions and implementations</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-git>freebsd-git</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion of git use in the FreeBSD project</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-gnome>freebsd-gnome</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting GNOME and GNOME applications</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers>freebsd-hackers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>General technical discussion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-haskell>freebsd-haskell</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-specific Haskell issues and discussions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hardware>freebsd-hardware</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>General discussion of hardware for running FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-i18n>freebsd-i18n</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD Internationalization</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ia32>freebsd-ia32</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD on the IA-32 (Intel™ x86) platform</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ia64>freebsd-ia64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting FreeBSD to Intel™'s upcoming IA64 systems</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-infiniband>freebsd-infiniband</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Infiniband on FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ipfw>freebsd-ipfw</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Technical discussion concerning the redesign of the IP firewall code</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-isdn>freebsd-isdn</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ISDN developers</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-jail>freebsd-jail</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion about the <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> facility</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-java>freebsd-java</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Java™ developers and people porting JDK™s to FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://mail.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting KDE and KDE applications</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-lfs>freebsd-lfs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting LFS to FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-mips>freebsd-mips</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting FreeBSD to MIPS™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-mobile>freebsd-mobile</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions about mobile computing</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-mono>freebsd-mono</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mono and C# applications on FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-multimedia>freebsd-multimedia</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Multimedia applications</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-new-bus>freebsd-new-bus</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Technical discussions about bus architecture</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-net>freebsd-net</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Networking discussion and TCP/IP source code</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-numerics>freebsd-numerics</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions of high quality implementation of libm functions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ocaml>freebsd-ocaml</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-specific OCaml discussions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-office>freebsd-office</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Office applications on FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-performance>freebsd-performance</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Performance tuning questions for high performance/load installations</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-perl>freebsd-perl</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Maintenance of a number of Perl-related ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pf>freebsd-pf</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion and questions about the packet filter firewall system</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkg>freebsd-pkg</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Binary package management and package tools discussion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkg-fallout>freebsd-pkg-fallout</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fallout logs from package building</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkgbase>freebsd-pkgbase</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Packaging the FreeBSD base system</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-platforms>freebsd-platforms</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Concerning ports to non Intel™ architecture platforms</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports>freebsd-ports</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion of the Ports Collection</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-announce>freebsd-ports-announce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Important news and instructions about the Ports Collection (moderated)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-bugs>freebsd-ports-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion of the ports bugs/PRs</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ppc>freebsd-ppc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting FreeBSD to the PowerPC™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-proliant>freebsd-proliant</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Technical discussion of FreeBSD on HP ProLiant server platforms</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-python>freebsd-python</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-specific Python issues</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-rc>freebsd-rc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion related to the <span class=filename>rc.d</span> system and its development</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-realtime>freebsd-realtime</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Development of realtime extensions to FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ruby>freebsd-ruby</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-specific Ruby discussions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-scsi>freebsd-scsi</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The SCSI subsystem</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security>freebsd-security</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Security issues affecting FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-small>freebsd-small</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Using FreeBSD in embedded applications (obsolete; use <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-embedded>freebsd-embedded</a> instead)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-snapshots>freebsd-snapshots</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD Development Snapshot Announcements</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-sparc64>freebsd-sparc64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting FreeBSD to SPARC™ based systems</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-standards>freebsd-standards</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD’s conformance to the C99 and the POSIX™ standards</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-sysinstall>freebsd-sysinstall</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> development</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-tcltk>freebsd-tcltk</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-specific Tcl/Tk discussions</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-testing>freebsd-testing</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Testing on FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-tex>freebsd-tex</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting TeX and its applications to FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-threads>freebsd-threads</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Threading in FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-tilera>freebsd-tilera</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porting FreeBSD to the Tilera family of CPUs</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-tokenring>freebsd-tokenring</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Support Token Ring in FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-toolchain>freebsd-toolchain</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Maintenance of FreeBSD’s integrated toolchain</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-translators>freebsd-translators</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Translating FreeBSD documents and programs</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-transport>freebsd-transport</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions of transport level network protocols in FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-usb>freebsd-usb</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussing FreeBSD support for USB</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-virtualization>freebsd-virtualization</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion of various virtualization techniques supported by FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-vuxml>freebsd-vuxml</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion on VuXML infrastructure</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-x11>freebsd-x11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Maintenance and support of X11 on FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-xen>freebsd-xen</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussion of the FreeBSD port to Xen™ — implementation and usage</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-xfce>freebsd-xfce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>XFCE for FreeBSD — porting and maintaining</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-zope>freebsd-zope</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zope for FreeBSD — porting and maintaining</p></td></tr></tbody></table><div class=paragraph><p><em>Limited lists:</em> The following lists are for more specialized (and demanding) audiences and are probably not of interest to the general public. It is also a good idea to establish a presence in the technical lists before joining one of these limited lists in order to understand the communications etiquette involved.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">List</th><th class="tableblock halign-left valign-top">用途</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hubs>freebsd-hubs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>People running mirror sites (infrastructural support)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-user-groups>freebsd-user-groups</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>User group coordination</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-wip-status>freebsd-wip-status</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD Work-In-Progress Status</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-wireless>freebsd-wireless</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussions of 802.11 stack, tools, device driver development</p></td></tr></tbody></table><div class=paragraph><p><em>Digest lists:</em> All of the above lists are available in a digest format. Once subscribed to a list, the digest options can be changed in the account options section.</p></div><div class=paragraph><p><em>SVN lists:</em> The following lists are for people interested in seeing the log messages for changes to various areas of the source tree. They are <em>Read-Only</em> lists and should not have mail sent to them.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">List</th><th class="tableblock halign-left valign-top">Source area</th><th class="tableblock halign-left valign-top">Area Description (source for)</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-doc-all>svn-doc-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the doc Subversion repository (except for <span class=filename>user</span>, <span class=filename>projects</span> and <span class=filename>translations</span>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-doc-head>svn-doc-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the "head" branch of the doc Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-doc-projects>svn-doc-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>projects</span> area of the doc Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-doc-svnadmin>svn-doc-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the administrative scripts, hooks, and other configuration data of the doc Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-ports-all>svn-ports-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the ports Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-ports-head>svn-ports-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the "head" branch of the ports Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-ports-svnadmin>svn-ports-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the administrative scripts, hooks, and other configuration data of the ports Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-all>svn-src-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the src Subversion repository (except for <span class=filename>user</span> and <span class=filename>projects</span>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-head>svn-src-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the "head" branch of the src Subversion repository (the FreeBSD-CURRENT branch)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-projects>svn-src-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>projects</span> area of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-release>svn-src-release</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>releases</span> area of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-releng>svn-src-releng</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>releng</span> branches of the src Subversion repository (the security / release engineering branches)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable>svn-src-stable</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the all stable branches of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-6>svn-src-stable-6</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>stable/6</span> branch of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-7>svn-src-stable-7</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>stable/7</span> branch of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-8>svn-src-stable-8</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>stable/8</span> branch of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-9>svn-src-stable-9</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>stable/9</span> branch of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-10>svn-src-stable-10</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>stable/10</span> branch of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-11>svn-src-stable-11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>stable/11</span> branch of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-12>svn-src-stable-12</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the <span class=filename>stable/12</span> branch of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-other>svn-src-stable-other</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the older <span class=filename>stable</span> branches of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-svnadmin>svn-src-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the administrative scripts, hooks, and other configuration data of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-user>svn-src-user</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the experimental <span class=filename>user</span> area of the src Subversion repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-vendor>svn-src-vendor</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All changes to the vendor work area of the src Subversion repository</p></td></tr></tbody></table></div><div class=sect3><h4 id=eresources-subscribe>C.2.2. 如何訂閱<a class=anchor href=#eresources-subscribe></a></h4><div class=paragraph><p>To subscribe to a list, click the list name at <a href=http://lists.FreeBSD.org/mailman/listinfo>http://lists.FreeBSD.org/mailman/listinfo</a>. The page that is displayed should contain all of the necessary subscription instructions for that list.</p></div><div class=paragraph><p>To actually post to a given list, send mail to <a href=mailto:listname@FreeBSD.org>listname@FreeBSD.org</a>. It will then be redistributed to mailing list members world-wide.</p></div><div class=paragraph><p>To unsubscribe from a list, click on the URL found at the bottom of every email received from the list. It is also possible to send an email to <a href=mailto:listname-unsubscribe@FreeBSD.org>listname-unsubscribe@FreeBSD.org</a> to unsubscribe.</p></div><div class=paragraph><p>It is important to keep discussion in the technical mailing lists on a technical track. To only receive important announcements, instead join the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce>FreeBSD announcements mailing list</a>, which is intended for infrequent traffic.</p></div></div><div class=sect3><h4 id=eresources-charters>C.2.3. 論壇章程<a class=anchor href=#eresources-charters></a></h4><div class=paragraph><p><em>All</em> FreeBSD mailing lists have certain basic rules which must be adhered to by anyone using them. Failure to comply with these guidelines will result in two (2) written warnings from the FreeBSD Postmaster <a href=mailto:postmaster@FreeBSD.org>postmaster@FreeBSD.org</a>, after which, on a third offense, the poster will removed from all FreeBSD mailing lists and filtered from further posting to them. We regret that such rules and measures are necessary at all, but today’s Internet is a pretty harsh environment, it would seem, and many fail to appreciate just how fragile some of its mechanisms are.</p></div><div class=paragraph><p>Rules of the road:</p></div><div class=ulist><ul><li><p>The topic of any posting should adhere to the basic charter of the list it is posted to. If the list is about technical issues, the posting should contain technical discussion. Ongoing irrelevant chatter or flaming only detracts from the value of the mailing list for everyone on it and will not be tolerated. For free-form discussion on no particular topic, the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chat>FreeBSD chat mailing list</a> is freely available and should be used instead.</p></li><li><p>No posting should be made to more than 2 mailing lists, and only to 2 when a clear and obvious need to post to both lists exists. For most lists, there is already a great deal of subscriber overlap and except for the most esoteric mixes (say "-stable & -scsi"), there really is no reason to post to more than one list at a time. If a message is received with multiple mailing lists on the <code>Cc</code> line, trim the <code>Cc</code> line before replying. <em>The person who replies is still responsible for cross-posting, no matter who the originator might have been.</em></p></li><li><p>Personal attacks and profanity (in the context of an argument) are not allowed, and that includes users and developers alike. Gross breaches of netiquette, like excerpting or reposting private mail when permission to do so was not and would not be forthcoming, are frowned upon but not specifically enforced. <em>However</em>, there are also very few cases where such content would fit within the charter of a list and it would therefore probably rate a warning (or ban) on that basis alone.</p></li><li><p>Advertising of non-FreeBSD related products or services is strictly prohibited and will result in an immediate ban if it is clear that the offender is advertising by spam.</p></li></ul></div><div class=paragraph><p><em>Individual list charters:</em></p></div><div class=dlist><dl><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a></dt><dd><p><em>ACPI and power management development</em></p></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-afs>freebsd-afs</a></dt><dd><p><em>Andrew File System</em></p><div class=paragraph><p>This list is for discussion on porting and using AFS from CMU/Transarc</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce>freebsd-announce</a></dt><dd><p><em>Important events / milestones</em></p><div class=paragraph><p>This is the mailing list for people interested only in occasional announcements of significant FreeBSD events. This includes announcements about snapshots and other releases. It contains announcements of new FreeBSD capabilities. It may contain calls for volunteers etc. This is a low volume, strictly moderated mailing list.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-arch>freebsd-arch</a></dt><dd><p><em>Architecture and design discussions</em></p><div class=paragraph><p>This list is for discussion of the FreeBSD architecture. Messages will mostly be kept strictly technical in nature. Examples of suitable topics are:</p></div><div class=ulist><ul><li><p>How to re-vamp the build system to have several customized builds running at the same time.</p></li><li><p>What needs to be fixed with VFS to make Heidemann layers work.</p></li><li><p>How do we change the device driver interface to be able to use the same drivers cleanly on many buses and architectures.</p></li><li><p>How to write a network driver.</p></li></ul></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bluetooth>freebsd-bluetooth</a></dt><dd><p><em>Bluetooth™ in FreeBSD</em></p><div class=paragraph><p>This is the forum where FreeBSD’s Bluetooth™ users congregate. Design issues, implementation details, patches, bug reports, status reports, feature requests, and all matters related to Bluetooth™ are fair game.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bugbusters>freebsd-bugbusters</a></dt><dd><p><em>Coordination of the Problem Report handling effort</em></p><div class=paragraph><p>The purpose of this list is to serve as a coordination and discussion forum for the Bugmeister, his Bugbusters, and any other parties who have a genuine interest in the PR database. This list is not for discussions about specific bugs, patches or PRs.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bugs>freebsd-bugs</a></dt><dd><p><em>Bug reports</em></p><div class=paragraph><p>This is the mailing list for reporting bugs in FreeBSD. Whenever possible, bugs should be submitted using the <a href=https://bugs.freebsd.org/bugzilla/enter_bug.cgi>web interface</a> to it.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chat>freebsd-chat</a></dt><dd><p><em>Non technical items related to the FreeBSD community</em></p><div class=paragraph><p>This list contains the overflow from the other lists about non-technical, social information. It includes discussion about whether Jordan looks like a toon ferret or not, whether or not to type in capitals, who is drinking too much coffee, where the best beer is brewed, who is brewing beer in their basement, and so on. Occasional announcements of important events (such as upcoming parties, weddings, births, new jobs, etc) can be made to the technical lists, but the follow ups should be directed to this -chat list.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chromium>freebsd-chromium</a></dt><dd><p><em>FreeBSD-specific Chromium issues</em></p><div class=paragraph><p>This is a list for the discussion of Chromium support for FreeBSD. This is a technical list to discuss development and installation of Chromium.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-cloud>freebsd-cloud</a></dt><dd><p><em>Running FreeBSD on various cloud platforms</em></p><div class=paragraph><p>This list discusses running FreeBSD on Amazon EC2, Google Compute Engine, Microsoft Azure, and other cloud computing platforms.</p></div></dd><dt class=hdlist1>freebsd-core</dt><dd><p><em>FreeBSD core team</em></p><div class=paragraph><p>This is an internal mailing list for use by the core members. Messages can be sent to it when a serious FreeBSD-related matter requires arbitration or high-level scrutiny.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>freebsd-current</a></dt><dd><p><em>Discussions about the use of FreeBSD-CURRENT</em></p><div class=paragraph><p>This is the mailing list for users of FreeBSD-CURRENT. It includes warnings about new features coming out in -CURRENT that will affect the users, and instructions on steps that must be taken to remain -CURRENT. Anyone running "CURRENT" must subscribe to this list. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-desktop>freebsd-desktop</a></dt><dd><p><em>Using and improving FreeBSD on the desktop</em></p><div class=paragraph><p>This is a forum for discussion of FreeBSD on the desktop. It is primarily a place for desktop porters and users to discuss issues and improve FreeBSD’s desktop support.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/dev-ci>dev-ci</a></dt><dd><p><em>Continuous Integration reports of build and test results</em></p><div class=paragraph><p>All Continuous Integration reports of build and test results</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/dev-reviews>dev-reviews</a></dt><dd><p><em>Notifications of work in progress in FreeBSD’s review tool</em></p><div class=paragraph><p>Automated notifications of work in progress for review in FreeBSD’s review tools, including patches.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc>freebsd-doc</a></dt><dd><p><em>Documentation Project</em></p><div class=paragraph><p>This mailing list is for the discussion of issues and projects related to the creation of documentation for FreeBSD. The members of this mailing list are collectively referred to as "The FreeBSD Documentation Project". It is an open list; feel free to join and contribute!</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-drivers>freebsd-drivers</a></dt><dd><p><em>Writing device drivers for FreeBSD</em></p><div class=paragraph><p>This is a forum for technical discussions related to device drivers on FreeBSD. It is primarily a place for device driver writers to ask questions about how to write device drivers using the APIs in the FreeBSD kernel.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-dtrace>freebsd-dtrace</a></dt><dd><p><em>Using and working on DTrace in FreeBSD</em></p><div class=paragraph><p>DTrace is an integrated component of FreeBSD that provides a framework for understanding the kernel as well as user space programs at run time. The mailing list is an archived discussion for developers of the code as well as those using it.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-eclipse>freebsd-eclipse</a></dt><dd><p><em>FreeBSD users of Eclipse IDE, tools, rich client applications and ports.</em></p><div class=paragraph><p>The intention of this list is to provide mutual support for everything to do with choosing, installing, using, developing and maintaining the Eclipse IDE, tools, rich client applications on the FreeBSD platform and assisting with the porting of Eclipse IDE and plugins to the FreeBSD environment.</p></div><div class=paragraph><p>The intention is also to facilitate exchange of information between the Eclipse community and the FreeBSD community to the mutual benefit of both.</p></div><div class=paragraph><p>Although this list is focused primarily on the needs of Eclipse users it will also provide a forum for those who would like to develop FreeBSD specific applications using the Eclipse framework.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-embedded>freebsd-embedded</a></dt><dd><p><em>Using FreeBSD in embedded applications</em></p><div class=paragraph><p>This list discusses topics related to using FreeBSD in embedded systems. This is a technical mailing list for which strictly technical content is expected. For the purpose of this list, embedded systems are those computing devices which are not desktops and which usually serve a single purpose as opposed to being general computing environments. Examples include, but are not limited to, all kinds of phone handsets, network equipment such as routers, switches and PBXs, remote measuring equipment, PDAs, Point Of Sale systems, and so on.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-emulation>freebsd-emulation</a></dt><dd><p><em>Emulation of other systems such as Linux/MS-DOS™/Windows™</em></p><div class=paragraph><p>This is a forum for technical discussions related to running programs written for other operating systems on FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-enlightenment>freebsd-enlightenment</a></dt><dd><p><em>Enlightenment</em></p><div class=paragraph><p>Discussions concerning the Enlightenment Desktop Environment for FreeBSD systems. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-eol>freebsd-eol</a></dt><dd><p><em>Peer support of FreeBSD-related software that is no longer supported by the FreeBSD Project.</em></p><div class=paragraph><p>This list is for those interested in providing or making use of peer support of FreeBSD-related software for which the FreeBSD Project no longer provides official support in the form of security advisories and patches.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-firewire>freebsd-firewire</a></dt><dd><p><em>FireWire™ (iLink, IEEE 1394)</em></p><div class=paragraph><p>This is a mailing list for discussion of the design and implementation of a FireWire™ (aka IEEE 1394 aka iLink) subsystem for FreeBSD. Relevant topics specifically include the standards, bus devices and their protocols, adapter boards/cards/chips sets, and the architecture and implementation of code for their proper support.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-fortran>freebsd-fortran</a></dt><dd><p><em>Fortran on FreeBSD</em></p><div class=paragraph><p>This is the mailing list for discussion of Fortran related ports on FreeBSD: compilers, libraries, scientific and engineering applications from laptops to HPC clusters.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-fs>freebsd-fs</a></dt><dd><p><em>File systems</em></p><div class=paragraph><p>Discussions concerning FreeBSD filesystems. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-games>freebsd-games</a></dt><dd><p><em>Games on FreeBSD</em></p><div class=paragraph><p>This is a technical list for discussions related to bringing games to FreeBSD. It is for individuals actively working on porting games to FreeBSD, to bring up problems or discuss alternative solutions. Individuals interested in following the technical discussion are also welcome.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-gecko>freebsd-gecko</a></dt><dd><p><em>Gecko Rendering Engine</em></p><div class=paragraph><p>This is a forum about Gecko applications using FreeBSD.</p></div><div class=paragraph><p>Discussion centers around Gecko Ports applications, their installation, their development and their support within FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-geom>freebsd-geom</a></dt><dd><p><em>GEOM</em></p><div class=paragraph><p>Discussions specific to GEOM and related implementations. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-git>freebsd-git</a></dt><dd><p><em>Use of git in the FreeBSD project</em></p><div class=paragraph><p>Discussions of how to use git in FreeBSD infrastructure including the github mirror and other uses of git for project collaboration. Discussion area for people using git against the FreeBSD github mirror. People wanting to get started with the mirror or git in general on FreeBSD can ask here.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-gnome>freebsd-gnome</a></dt><dd><p><em>GNOME</em></p><div class=paragraph><p>Discussions concerning The GNOME Desktop Environment for FreeBSD systems. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-infiniband>freebsd-infiniband</a></dt><dd><p><em>Infiniband on FreeBSD</em></p><div class=paragraph><p>Technical mailing list discussing Infiniband, OFED, and OpenSM on FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ipfw>freebsd-ipfw</a></dt><dd><p><em>IP Firewall</em></p><div class=paragraph><p>This is the forum for technical discussions concerning the redesign of the IP firewall code in FreeBSD. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ia64>freebsd-ia64</a></dt><dd><p><em>Porting FreeBSD to IA64</em></p><div class=paragraph><p>This is a technical mailing list for individuals actively working on porting FreeBSD to the IA-64 platform from Intel™, to bring up problems or discuss alternative solutions. Individuals interested in following the technical discussion are also welcome.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-isdn>freebsd-isdn</a></dt><dd><p><em>ISDN Communications</em></p><div class=paragraph><p>This is the mailing list for people discussing the development of ISDN support for FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-java>freebsd-java</a></dt><dd><p><em>Java™ Development</em></p><div class=paragraph><p>This is the mailing list for people discussing the development of significant Java™ applications for FreeBSD and the porting and maintenance of JDK™s.</p></div></dd></dl></div><div id=eresources-charters-jobs class=dlist><dl><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-jobs>freebsd-jobs</a></dt><dd><p><em>Jobs offered and sought</em></p><div class=paragraph><p>This is a forum for posting employment notices specifically related to FreeBSD and resumes from those seeking FreeBSD-related employment. This is <em>not</em> a mailing list for general employment issues since adequate forums for that already exist elsewhere.</p></div><div class=paragraph><p>Note that this list, like other <code>FreeBSD.org</code> mailing lists, is distributed worldwide. Be clear about the geographic location and the extent to which telecommuting or assistance with relocation is available.</p></div><div class=paragraph><p>Email should use open formats only — preferably plain text, but basic Portable Document Format (PDF), HTML, and a few others are acceptable to many readers. Closed formats such as Microsoft™ Word (<span class=filename>.doc</span>) will be rejected by the mailing list server.</p></div></dd><dt class=hdlist1><a href=https://mail.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></dt><dd><p><em>KDE</em></p><div class=paragraph><p>Discussions concerning KDE on FreeBSD systems. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers>freebsd-hackers</a></dt><dd><p><em>Technical discussions</em></p><div class=paragraph><p>This is a forum for technical discussions related to FreeBSD. This is the primary technical mailing list. It is for individuals actively working on FreeBSD, to bring up problems or discuss alternative solutions. Individuals interested in following the technical discussion are also welcome. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hardware>freebsd-hardware</a></dt><dd><p><em>General discussion of FreeBSD hardware</em></p><div class=paragraph><p>General discussion about the types of hardware that FreeBSD runs on, various problems and suggestions concerning what to buy or avoid.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hubs>freebsd-hubs</a></dt><dd><p><em>Mirror sites</em></p><div class=paragraph><p>Announcements and discussion for people who run FreeBSD mirror sites.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-isp>freebsd-isp</a></dt><dd><p><em>Issues for Internet Service Providers</em></p><div class=paragraph><p>This mailing list is for discussing topics relevant to Internet Service Providers (ISPs) using FreeBSD. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-mono>freebsd-mono</a></dt><dd><p><em>Mono and C# applications on FreeBSD</em></p><div class=paragraph><p>This is a list for discussions related to the Mono development framework on FreeBSD. This is a technical mailing list. It is for individuals actively working on porting Mono or C# applications to FreeBSD, to bring up problems or discuss alternative solutions. Individuals interested in following the technical discussion are also welcome.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ocaml>freebsd-ocaml</a></dt><dd><p><em>FreeBSD-specific OCaml discussions</em></p><div class=paragraph><p>This is a list for discussions related to the OCaml support on FreeBSD. This is a technical mailing list. It is for individuals working on OCaml ports, 3rd party libraries and frameworks. Individuals interested in the technical discussion are also welcome.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-office>freebsd-office</a></dt><dd><p><em>Office applications on FreeBSD</em></p><div class=paragraph><p>Discussion centers around office applications, their installation, their development and their support within FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ops-announce>freebsd-ops-announce</a></dt><dd><p><em>Project Infrastructure Announcements</em></p><div class=paragraph><p>This is the mailing list for people interested in changes and issues related to the FreeBSD.org Project infrastructure.</p></div><div class=paragraph><p>This moderated list is strictly for announcements: no replies, requests, discussions, or opinions.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-performance>freebsd-performance</a></dt><dd><p><em>Discussions about tuning or speeding up FreeBSD</em></p><div class=paragraph><p>This mailing list exists to provide a place for hackers, administrators, and/or concerned parties to discuss performance related topics pertaining to FreeBSD. Acceptable topics includes talking about FreeBSD installations that are either under high load, are experiencing performance problems, or are pushing the limits of FreeBSD. Concerned parties that are willing to work toward improving the performance of FreeBSD are highly encouraged to subscribe to this list. This is a highly technical list ideally suited for experienced FreeBSD users, hackers, or administrators interested in keeping FreeBSD fast, robust, and scalable. This list is not a question-and-answer list that replaces reading through documentation, but it is a place to make contributions or inquire about unanswered performance related topics.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pf>freebsd-pf</a></dt><dd><p><em>Discussion and questions about the packet filter firewall system</em></p><div class=paragraph><p>Discussion concerning the packet filter (pf) firewall system in terms of FreeBSD. Technical discussion and user questions are both welcome. This list is also a place to discuss the ALTQ QoS framework.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkg>freebsd-pkg</a></dt><dd><p><em>Binary package management and package tools discussion</em></p><div class=paragraph><p>Discussion of all aspects of managing FreeBSD systems by using binary packages to install software, including binary package toolkits and formats, their development and support within FreeBSD, package repository management, and third party packages.</p></div><div class=paragraph><p>Note that discussion of ports which fail to generate packages correctly should generally be considered as ports problems, and so inappropriate for this list.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkg-fallout>freebsd-pkg-fallout</a></dt><dd><p><em>Fallout logs from package building</em></p><div class=paragraph><p>All packages building failures logs from the package building clusters</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkgbase>freebsd-pkgbase</a></dt><dd><p><em>Packaging the FreeBSD base system.</em></p><div class=paragraph><p>Discussions surrounding implementation and issues regarding packaging the FreeBSD base system.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-platforms>freebsd-platforms</a></dt><dd><p><em>Porting to Non Intel™ platforms</em></p><div class=paragraph><p>Cross-platform FreeBSD issues, general discussion and proposals for non Intel™ FreeBSD ports. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports>freebsd-ports</a></dt><dd><p><em>Discussion of "ports"</em></p><div class=paragraph><p>Discussions concerning FreeBSD’s "ports collection" (<span class=filename>/usr/ports</span>), ports infrastructure, and general ports coordination efforts. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-announce>freebsd-ports-announce</a></dt><dd><p><em>Important news and instructions about the FreeBSD "Ports Collection"</em></p><div class=paragraph><p>Important news for developers, porters, and users of the "Ports Collection" (<span class=filename>/usr/ports</span>), including architecture/infrastructure changes, new capabilities, critical upgrade instructions, and release engineering information. This is a low-volume mailing list, intended for announcements.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-bugs>freebsd-ports-bugs</a></dt><dd><p><em>Discussion of "ports" bugs</em></p><div class=paragraph><p>Discussions concerning problem reports for FreeBSD’s "ports collection" (<span class=filename>/usr/ports</span>), proposed ports, or modifications to ports. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-proliant>freebsd-proliant</a></dt><dd><p><em>Technical discussion of FreeBSD on HP ProLiant server platforms</em></p><div class=paragraph><p>This mailing list is to be used for the technical discussion of the usage of FreeBSD on HP ProLiant servers, including the discussion of ProLiant-specific drivers, management software, configuration tools, and BIOS updates. As such, this is the primary place to discuss the hpasmd, hpasmcli, and hpacucli modules.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-python>freebsd-python</a></dt><dd><p><em>Python on FreeBSD</em></p><div class=paragraph><p>This is a list for discussions related to improving Python-support on FreeBSD. This is a technical mailing list. It is for individuals working on porting Python, its third party modules and Zope stuff to FreeBSD. Individuals interested in following the technical discussion are also welcome.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>freebsd-questions</a></dt><dd><p><em>User questions</em></p><div class=paragraph><p>This is the mailing list for questions about FreeBSD. Do not send "how to" questions to the technical lists unless the question is quite technical.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ruby>freebsd-ruby</a></dt><dd><p><em>FreeBSD-specific Ruby discussions</em></p><div class=paragraph><p>This is a list for discussions related to the Ruby support on FreeBSD. This is a technical mailing list. It is for individuals working on Ruby ports, third party libraries and frameworks.</p></div><div class=paragraph><p>Individuals interested in the technical discussion are also welcome.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-scsi>freebsd-scsi</a></dt><dd><p><em>SCSI subsystem</em></p><div class=paragraph><p>This is the mailing list for people working on the SCSI subsystem for FreeBSD. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security>freebsd-security</a></dt><dd><p><em>Security issues</em></p><div class=paragraph><p>FreeBSD computer security issues (DES, Kerberos, known security holes and fixes, etc). This is a technical mailing list for which strictly technical discussion is expected. Note that this is not a question-and-answer list, but that contributions (BOTH question AND answer) to the FAQ are welcome.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security-notifications>freebsd-security-notifications</a></dt><dd><p><em>Security Notifications</em></p><div class=paragraph><p>Notifications of FreeBSD security problems and fixes. This is not a discussion list. The discussion list is FreeBSD-security.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-small>freebsd-small</a></dt><dd><p><em>Using FreeBSD in embedded applications</em></p><div class=paragraph><p>This list discusses topics related to unusually small and embedded FreeBSD installations. This is a technical mailing list for which strictly technical content is expected.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This list has been obsoleted by <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-embedded>freebsd-embedded</a>.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-snapshots>freebsd-snapshots</a></dt><dd><p><em>FreeBSD Development Snapshot Announcements</em></p><div class=paragraph><p>This list provides notifications about the availability of new FreeBSD development snapshots for the head/ and stable/ branches.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-stable>freebsd-stable</a></dt><dd><p><em>Discussions about the use of FreeBSD-STABLE</em></p><div class=paragraph><p>This is the mailing list for users of FreeBSD-STABLE. "STABLE" is the branch where development continues after a RELEASE, including bug fixes and new features. The ABI is kept stable for binary compatibility. It includes warnings about new features coming out in -STABLE that will affect the users, and instructions on steps that must be taken to remain -STABLE. Anyone running "STABLE" should subscribe to this list. This is a technical mailing list for which strictly technical content is expected.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-standards>freebsd-standards</a></dt><dd><p><em>C99 & POSIX Conformance</em></p><div class=paragraph><p>This is a forum for technical discussions related to FreeBSD Conformance to the C99 and the POSIX standards.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-teaching>freebsd-teaching</a></dt><dd><p><em>Teaching with FreeBSD</em></p><div class=paragraph><p>Non technical mailing list discussing teaching with FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-testing>freebsd-testing</a></dt><dd><p><em>Testing on FreeBSD</em></p><div class=paragraph><p>Technical mailing list discussing testing on FreeBSD, including ATF/Kyua, test build infrastructure, port tests to FreeBSD from other operating systems (NetBSD, …​), etc.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-tex>freebsd-tex</a></dt><dd><p><em>Porting TeX and its applications to FreeBSD</em></p><div class=paragraph><p>This is a technical mailing list for discussions related to TeX and its applications on FreeBSD. It is for individuals actively working on porting TeX to FreeBSD, to bring up problems or discuss alternative solutions. Individuals interested in following the technical discussion are also welcome.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-toolchain>freebsd-toolchain</a></dt><dd><p><em>Maintenance of FreeBSD’s integrated toolchain</em></p><div class=paragraph><p>This is the mailing list for discussions related to the maintenance of the toolchain shipped with FreeBSD. This could include the state of Clang and GCC, but also pieces of software such as assemblers, linkers and debuggers.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-transport>freebsd-transport</a></dt><dd><p><em>Discussions of transport level network protocols in FreeBSD</em></p><div class=paragraph><p>The transport mailing list exists for the discussion of issues and designs around the transport level protocols in the FreeBSD network stack, including TCP, SCTP and UDP. Other networking topics, including driver specific and network protocol issues should be discussed on the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-net>FreeBSD networking mailing list</a>.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-translators>freebsd-translators</a></dt><dd><p><em>Translating FreeBSD documents and programs</em></p><div class=paragraph><p>A discussion list where translators of FreeBSD documents from English into other languages can talk about translation methods and tools. New members are asked to introduce themselves and mention the languages they are interested in translating.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-usb>freebsd-usb</a></dt><dd><p><em>Discussing FreeBSD support for USB</em></p><div class=paragraph><p>This is a mailing list for technical discussions related to FreeBSD support for USB.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-user-groups>freebsd-user-groups</a></dt><dd><p><em>User Group Coordination List</em></p><div class=paragraph><p>This is the mailing list for the coordinators from each of the local area Users Groups to discuss matters with each other and a designated individual from the Core Team. This mail list should be limited to meeting synopsis and coordination of projects that span User Groups.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-virtualization>freebsd-virtualization</a></dt><dd><p><em>Discussion of various virtualization techniques supported by FreeBSD</em></p><div class=paragraph><p>A list to discuss the various virtualization techniques supported by FreeBSD. On one hand the focus will be on the implementation of the basic functionality as well as adding new features. On the other hand users will have a forum to ask for help in case of problems or to discuss their use cases.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-wip-status>freebsd-wip-status</a></dt><dd><p><em>FreeBSD Work-In-Progress Status</em></p><div class=paragraph><p>This mailing list can be used by developers to announce the creation and progress of FreeBSD related work. Messages will be moderated. It is suggested to send the message "To:" a more topical FreeBSD list and only "BCC:" this list. This way the WIP can also be discussed on the topical list, as no discussion is allowed on this list.</p></div><div class=paragraph><p>Look inside the archives for examples of suitable messages.</p></div><div class=paragraph><p>An editorial digest of the messages to this list might be posted to the FreeBSD website every few months as part of the Status Reports . Past reports are archived.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-wireless>freebsd-wireless</a></dt><dd><p><em>Discussions of 802.11 stack, tools device driver development</em></p><div class=paragraph><p>The FreeBSD-wireless list focuses on 802.11 stack (sys/net80211), device driver and tools development. This includes bugs, new features and maintenance.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-xen>freebsd-xen</a></dt><dd><p><em>Discussion of the FreeBSD port to Xen™ — implementation and usage</em></p><div class=paragraph><p>A list that focuses on the FreeBSD Xen™ port. The anticipated traffic level is small enough that it is intended as a forum for both technical discussions of the implementation and design details as well as administrative deployment issues.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-xfce>freebsd-xfce</a></dt><dd><p><em>XFCE</em></p><div class=paragraph><p>This is a forum for discussions related to bring the XFCE environment to FreeBSD. This is a technical mailing list. It is for individuals actively working on porting XFCE to FreeBSD, to bring up problems or discuss alternative solutions. Individuals interested in following the technical discussion are also welcome.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-zope>freebsd-zope</a></dt><dd><p><em>Zope</em></p><div class=paragraph><p>This is a forum for discussions related to bring the Zope environment to FreeBSD. This is a technical mailing list. It is for individuals actively working on porting Zope to FreeBSD, to bring up problems or discuss alternative solutions. Individuals interested in following the technical discussion are also welcome.</p></div></dd></dl></div></div><div class=sect3><h4 id=eresources-mailfiltering>C.2.4. 郵遞論壇過濾項目<a class=anchor href=#eresources-mailfiltering></a></h4><div class=paragraph><p>The FreeBSD mailing lists are filtered in multiple ways to avoid the distribution of spam, viruses, and other unwanted emails. The filtering actions described in this section do not include all those used to protect the mailing lists.</p></div><div class=paragraph><p>Only certain types of attachments are allowed on the mailing lists. All attachments with a MIME content type not found in the list below will be stripped before an email is distributed on the mailing lists.</p></div><div class=ulist><ul><li><p>application/octet-stream</p></li><li><p>application/pdf</p></li><li><p>application/pgp-signature</p></li><li><p>application/x-pkcs7-signature</p></li><li><p>message/rfc822</p></li><li><p>multipart/alternative</p></li><li><p>multipart/related</p></li><li><p>multipart/signed</p></li><li><p>text/html</p></li><li><p>text/plain</p></li><li><p>text/x-diff</p></li><li><p>text/x-patch</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Some of the mailing lists might allow attachments of other MIME content types, but the above list should be applicable for most of the mailing lists.</p></div></td></tr></tbody></table></div><div class=paragraph><p>If an email contains both an HTML and a plain text version, the HTML version will be removed. If an email contains only an HTML version, it will be converted to plain text.</p></div></div></div><div class=sect2><h3 id=eresources-news>C.3. Usenet 新聞群組<a class=anchor href=#eresources-news></a></h3><div class=paragraph><p>In addition to two FreeBSD specific newsgroups, there are many others in which FreeBSD is discussed or are otherwise relevant to FreeBSD users.</p></div><div class=sect3><h4 id=_bsd_專屬新聞群組>C.3.1. BSD 專屬新聞群組<a class=anchor href=#_bsd_專屬新聞群組></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix.bsd.freebsd.announce>comp.unix.bsd.freebsd.announce</a></p></li><li><p><a href=news:comp.unix.bsd.freebsd.misc>comp.unix.bsd.freebsd.misc</a></p></li><li><p><a href=news:de.comp.os.unix.bsd>de.comp.os.unix.bsd</a> (German)</p></li><li><p><a href=news:fr.comp.os.bsd>fr.comp.os.bsd</a> (French)</p></li></ul></div></div><div class=sect3><h4 id=_其他相關的_unix_新聞群組>C.3.2. 其他相關的 UNIX™ 新聞群組<a class=anchor href=#_其他相關的_unix_新聞群組></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix>comp.unix</a></p></li><li><p><a href=news:comp.unix.questions>comp.unix.questions</a></p></li><li><p><a href=news:comp.unix.admin>comp.unix.admin</a></p></li><li><p><a href=news:comp.unix.programmer>comp.unix.programmer</a></p></li><li><p><a href=news:comp.unix.shell>comp.unix.shell</a></p></li><li><p><a href=news:comp.unix.misc>comp.unix.misc</a></p></li><li><p><a href=news:comp.unix.bsd>comp.unix.bsd</a></p></li></ul></div></div><div class=sect3><h4 id=_x_視窗系統>C.3.3. X 視窗系統<a class=anchor href=#_x_視窗系統></a></h4><div class=ulist><ul><li><p><a href=news:comp.windows.x>comp.windows.x</a></p></li></ul></div></div></div><div class=sect2><h3 id=eresources-web>C.4. 官方鏡像站<a class=anchor href=#eresources-web></a></h3><div class=paragraph><p><a href=#central-mirrors>Central Servers</a>, <a href=#armenia-mirrors>Armenia</a>, <a href=#australia-mirrors>Australia</a>, <a href=#austria-mirrors>Austria</a>, <a href=#czech-republic-mirrors>Czech Republic</a>, <a href=#denmark-mirrors>Denmark</a>, <a href=#finland-mirrors>Finland</a>, <a href=#france-mirrors>France</a>, <a href=#germany-mirrors>Germany</a>, <a href=#hong-kong-mirrors>Hong Kong</a>, <a href=#ireland-mirrors>Ireland</a>, <a href=#japan-mirrors>Japan</a>, <a href=#latvia-mirrors>Latvia</a>, <a href=#lithuania-mirrors>Lithuania</a>, <a href=#netherlands-mirrors>Netherlands</a>, <a href=#norway-mirrors>Norway</a>, <a href=#russia-mirrors>Russia</a>, <a href=#slovenia-mirrors>Slovenia</a>, <a href=#south-africa-mirrors>South Africa</a>, <a href=#spain-mirrors>Spain</a>, <a href=#sweden-mirrors>Sweden</a>, <a href=#switzerland-mirrors>Switzerland</a>, <a href=#taiwan-mirrors>Taiwan</a>, <a href=#uk-mirrors>United Kingdom</a>, <a href=#usa-mirrors>United States of America</a>.</p></div><div class=paragraph><p>(as of UTC)</p></div><div id=central-mirrors class=paragraph><p><strong>Central Servers</strong></p></div><div class=ulist><ul><li><p><a href=https://www.FreeBSD.org/ class=bare>https://www.FreeBSD.org/</a></p></li></ul></div><div id=armenia-mirrors class=paragraph><p><strong>Armenia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.at.FreeBSD.org/ class=bare>http://www.at.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=australia-mirrors class=paragraph><p><strong>Australia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.au.FreeBSD.org/ class=bare>http://www.au.FreeBSD.org/</a></p></li><li><p><a href=http://www2.au.FreeBSD.org/ class=bare>http://www2.au.FreeBSD.org/</a></p></li></ul></div><div id=austria-mirrors class=paragraph><p><strong>Austria</strong></p></div><div class=ulist><ul><li><p><a href=http://www.at.FreeBSD.org/ class=bare>http://www.at.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=czech-republic-mirrors class=paragraph><p><strong>Czech Republic</strong></p></div><div class=ulist><ul><li><p><a href=http://www.cz.FreeBSD.org/ class=bare>http://www.cz.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=denmark-mirrors class=paragraph><p><strong>Denmark</strong></p></div><div class=ulist><ul><li><p><a href=http://www.dk.FreeBSD.org/ class=bare>http://www.dk.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=finland-mirrors class=paragraph><p><strong>Finland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.fi.FreeBSD.org/ class=bare>http://www.fi.FreeBSD.org/</a></p></li></ul></div><div id=france-mirrors class=paragraph><p><strong>France</strong></p></div><div class=ulist><ul><li><p><a href=http://www1.fr.FreeBSD.org/ class=bare>http://www1.fr.FreeBSD.org/</a></p></li></ul></div><div id=germany-mirrors class=paragraph><p><strong>Germany</strong></p></div><div class=ulist><ul><li><p><a href=http://www.de.FreeBSD.org/ class=bare>http://www.de.FreeBSD.org/</a></p></li></ul></div><div id=hong-kong-mirrors class=paragraph><p><strong>Hong Kong</strong></p></div><div class=ulist><ul><li><p><a href=http://www.hk.FreeBSD.org/ class=bare>http://www.hk.FreeBSD.org/</a></p></li></ul></div><div id=ireland-mirrors class=paragraph><p><strong>Ireland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ie.FreeBSD.org/ class=bare>http://www.ie.FreeBSD.org/</a></p></li></ul></div><div id=japan-mirrors class=paragraph><p><strong>Japan</strong></p></div><div class=ulist><ul><li><p><a href=http://www.jp.FreeBSD.org/www.FreeBSD.org/ class=bare>http://www.jp.FreeBSD.org/www.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=latvia-mirrors class=paragraph><p><strong>Latvia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.lv.FreeBSD.org/ class=bare>http://www.lv.FreeBSD.org/</a></p></li></ul></div><div id=lithuania-mirrors class=paragraph><p><strong>Lithuania</strong></p></div><div class=ulist><ul><li><p><a href=http://www.lt.FreeBSD.org/ class=bare>http://www.lt.FreeBSD.org/</a></p></li></ul></div><div id=netherlands-mirrors class=paragraph><p><strong>Netherlands</strong></p></div><div class=ulist><ul><li><p><a href=http://www.nl.FreeBSD.org/ class=bare>http://www.nl.FreeBSD.org/</a></p></li></ul></div><div id=norway-mirrors class=paragraph><p><strong>Norway</strong></p></div><div class=ulist><ul><li><p><a href=http://www.no.FreeBSD.org/ class=bare>http://www.no.FreeBSD.org/</a></p></li></ul></div><div id=russia-mirrors class=paragraph><p><strong>Russia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ru.FreeBSD.org/ class=bare>http://www.ru.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=slovenia-mirrors class=paragraph><p><strong>Slovenia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.si.FreeBSD.org/ class=bare>http://www.si.FreeBSD.org/</a></p></li></ul></div><div id=south-africa-mirrors class=paragraph><p><strong>South Africa</strong></p></div><div class=ulist><ul><li><p><a href=http://www.za.FreeBSD.org/ class=bare>http://www.za.FreeBSD.org/</a></p></li></ul></div><div id=spain-mirrors class=paragraph><p><strong>Spain</strong></p></div><div class=ulist><ul><li><p><a href=http://www.es.FreeBSD.org/ class=bare>http://www.es.FreeBSD.org/</a></p></li><li><p><a href=http://www2.es.FreeBSD.org/ class=bare>http://www2.es.FreeBSD.org/</a></p></li></ul></div><div id=sweden-mirrors class=paragraph><p><strong>Sweden</strong></p></div><div class=ulist><ul><li><p><a href=http://www.se.FreeBSD.org/ class=bare>http://www.se.FreeBSD.org/</a></p></li></ul></div><div id=switzerland-mirrors class=paragraph><p><strong>Switzerland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ch.FreeBSD.org/ class=bare>http://www.ch.FreeBSD.org/</a> (IPv6)</p></li><li><p><a href=http://www2.ch.FreeBSD.org/ class=bare>http://www2.ch.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=taiwan-mirrors class=paragraph><p><strong>Taiwan</strong></p></div><div class=ulist><ul><li><p><a href=http://www.tw.FreeBSD.org/ class=bare>http://www.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www2.tw.FreeBSD.org/ class=bare>http://www2.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www4.tw.FreeBSD.org/ class=bare>http://www4.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www5.tw.FreeBSD.org/ class=bare>http://www5.tw.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=uk-mirrors class=paragraph><p><strong>United Kingdom</strong></p></div><div class=ulist><ul><li><p><a href=http://www1.uk.FreeBSD.org class=bare>http://www1.uk.FreeBSD.org</a></p></li><li><p><a href=http://www3.uk.FreeBSD.org/ class=bare>http://www3.uk.FreeBSD.org/</a></p></li></ul></div><div id=usa-mirrors class=paragraph><p><strong>United States of America</strong></p></div><div class=ulist><ul><li><p><a href=http://www5.us.FreeBSD.org/ class=bare>http://www5.us.FreeBSD.org/</a> (IPv6)</p></li></ul></div></div></div></div><div class=sect1><h2 id=pgpkeys>附錄 D: OpenPGP 金鑰<a class=anchor href=#pgpkeys></a></h2><div class=sectionbody><div class=paragraph><p>The OpenPGP keys of the <code>FreeBSD.org</code> officers are shown here. These keys can be used to verify a signature or send encrypted email to one of the officers. A full list of FreeBSD OpenPGP keys is available in the <a href=https://docs.freebsd.org/en/articles/pgpkeys/>PGP Keys</a> article. The complete keyring can be downloaded at <a href=https://docs.FreeBSD.org/pgpkeys/pgpkeys.txt>pgpkeyring.txt</a>.</p></div><div class=sect2><h3 id=pgpkeys-officers>D.1. Officers<a class=anchor href=#pgpkeys-officers></a></h3><div class=sect3><h4 id=_security_officer_team_security_officerfreebsd_org>D.1.1. Security Officer Team <code>&lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>></code><a class=anchor href=#_security_officer_team_security_officerfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/D9AD2A18057474CB 2022-12-11 [C] [expires: 2026-01-24]
      Key fingerprint = 0BE3 3275 D74C 953C 79F8  1107 D9AD 2A18 0574 74CB
uid                            FreeBSD Security Officer &lt;security-officer@freebsd.org&gt;
sub   rsa4096/6E58DE901F001AEF 2022-12-11 [S] [expires: 2025-01-15]
sub   rsa4096/46DB26D62F6039B7 2022-12-11 [E] [expires: 2025-01-15]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGOVdeUBEADHF5VGg1iPbACB+7lomX6aDytUf0k2k2Yc/Kp6lfYv7JKU+1nr
TcNF7Gt1YkajPSeWRKNZw/X94g4w5TEOHbJ6QQWx9g+N7RjEq75actQ/r2N5zY4S
ujfFTepbvgR55mLTxlxGKFBmNrfNbpHRyh4GwFRgPlxf5Jy9SB+0m54yFS4QlSd0
pIzO0CLkjHUFy/8S93oSK2zUkgok5gLWruBXom+8VC3OtBElkWswPkE1pKZvMQCv
VyM+7BS+MCFXSdZczDZZoEzpQJGhUYFsdg0KqlLv6z1rP+HsgUYKTkRpcrumDQV0
MMuCE4ECU6nFDDTnbR8Wn3LF5oTt0GtwS0nWf+nZ1SFTDURcSPR4Lp/PKjuDAkOS
P8BaruCNx1ItHSwcnXw0gS4+h8FjtWNZpsawtzjjgApcl+m9KP6dkBcbN+i1DHm6
NG6YQVtVWyN8aOKmoC/FEm1CWh1bv+ri9XOkF2EqT/ktbjbT1hFoFGBkS9/35y1G
3KKyWtwKcyF4OXcArl6sQwGgiYnZEG3sUMaGrwQovRtMf7le3cAYsMkXyiAnEufa
deuabYLD8qp9L/eNo+9aZmhJqQg4EQb+ePH7bGPNDZ+M5oGUwReX857FoWaPhs4L
dAKQ1YwASxdKKh8wnaamjIeZSGP5TCjurH7pADAIaB3/D+ZNl2a7od+C1wARAQAB
tDdGcmVlQlNEIFNlY3VyaXR5IE9mZmljZXIgPHNlY3VyaXR5LW9mZmljZXJAZnJl
ZWJzZC5vcmc+iQJSBBMBCgA8AhsBBAsJCAcEFQoJCAUWAgMBAAIeBQIXgBYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJjlXeQBQkF3u+rAAoJENmtKhgFdHTLOVoQALS3
cj7rqYkHiV4zDYrgPEp9O1kAyGI8VdfGAMkDVTqr+wP4v/o7LIUrgwZl5qxesVFB
VknFr0Wp5g9h0iAjasoI5sDd6tH2SmumhBHXFVdftzDQhrugxH6fWRhHs0SaFYCk
Qt5nFbcpUfWgtQ35XTbsL8iENdYpjKXsSFQrJneGSwxIjWYTFn6ps/AI3gwR8+Bn
OffEFdYugJ049O6Vu6YBFJHrnMO7NbF4v95dVYuLtpMIaXWM+V9KITmhaBzFz5fM
Q7UOzcLlbxOYKNIWcp8QQk429mayKW5VUeUExUD1ZzBHn+P6ZG7QTMDu/RmBqiHo
ewCMVz4n9uXT5BiOngE4CvS0WQwHzK+k9MLpG2u/Bo9+LT0Ceh9Ou1rfU5+0tRwl
GyOFFjf3INS7I7gkcAwxQ7dzDItN/UQPZpg8y9mABU2x4enz0AvTnb61d/1dnTEr
tdNgU433he0ZnD1HurZCjBEWC656wv6iMdWcD8gjhMbmEpPmjvXcYlTO6zhEygSM
DiwdQCWK2W4++YJerA6ULBi3niNWBpofOFH8XylV56ruhjtHCo7+/3carcMoPOJv
lVZ1zCKxLro3TRBT15JTFBGqblRyTopFK3PuxW//GTnZOtpQEOV6yL4RAXcWeC1d
1hb5k/YxUmRF6XsDNEH4b08T8ZO8dV3dAV43Wh1oiQEzBBABCAAdFiEEuyjUCzYO
7pNq7RVv5fe8y6O93fgFAmObXVYACgkQ5fe8y6O93fiBlwf/W8y1XXJIx1ZA3n6u
f7aS70rbP9KFPr4U0dixwKE/gbtIQ9ckeNXrDDWz0v0NCz4qS+33IPiJg1WcY3vR
W90e7QgAueCo5TdZPImPbCs42vadpa5byMXS4Pw+xyT+d/yp2oLKYbj3En4bg1GM
w71DezIjvV+e01UR++u1t9yZ8LOWM5Kumz1zyQLZDZ8qIKt1bBfpa+E0cEqtNQWu
iGhQE3AHI8eWV+jBkg5y2zHRIevbWb1UPsj43lgkFtAGHk9rrM8Rmgr4AXr531iD
srBwauKZ/MElcF3MINuLH+gkPPaFHw/YIpLRLaZXZVsw3Xi1RNXI2n2ea29dvs/C
Lcf1vYkCMwQQAQgAHRYhBPwOh4rlr+eIAo1jVdOXkvSep+XCBQJjm14FAAoJENOX
kvSep+XC0DcP/1ZB7k9p1T+9QbbZZE1PJiHby3815ccH3XKexbNmmakHIn3L6Cet
F891Kqt9ssbhFRMNtyZ/k/8y8Hv5bKxVep5/HMyK+8aqfDFN0WMrqZh0/CiR6DJh
gnAmPNw/hAVHMHaYGII9kCrFfPFJ02FKoc81g9F08odb7TV+UlvRjkErhRxF+dGS
wQoO0RCbf0Z1cs7nd0Vb2z4IJh4XMxBjWc/uQ2Q9dH/0uRzwpAnR4YX+MG5YrX7Z
zBvDyR0r76iQwRSDKgioNgkr6R3rq1NZGdaj+8b0LzdOqtzKJ/eupDe3+H67e/EN
qymtreGjrubpiU9bKvYArisUqhE5KtguryvR6Qz9bj87nPg33DT3WWGVrwFRxBox
dbWzjQFv0wug8m4GAwVF7fPR5/eW7IHw8zvgn0vSPcZz7MZ4e6Y5jN4kA5/xWJYZ
Sps54qQWB+FA30unIXN68KqdIzONIbtaY3W4/JjJUCm4T+wEjKaH+wJX8w1DMjlg
mkTmGh/UrTyC1vXbPgk9Sy3cRTICR1T9z7W8UlmTtnKrUklrjlFR7SXzrEXzLGOX
Fm+NEHpHNXqzcm6c3QfzY/yQ9HSAQ/t7SUQ9caRePbDz3/msyPxtGFor9roQv6VN
wRXCyRgkH4Y5tPhJAQ8G/FxX+VXFb93QL0lfelb23/BBu6cUwW63SRn5uQINBGOV
dskBEADqo8z6TFAhrvHhJV5wHdj67guoYvpXP8gvdCqos8SLluqi0AWgJEwlqu7L
mKQ6qMoJ+2DN6y+dEtvOVgBAgF63LLf3FQKq9FB/3uqeIiQlCIl3H43f8KttEZzf
/lbry4Y6QhS2OXM31Ut9Q+1IfTGwvs1E8/J1U4jQrAGqNKknXyQyMweJ0jvvcSLJ
nv3S7COUJVOT3cTgVeh3RIQlFzqK2rSQmygDpS8bT8MjCsZr+KGezKpbddKXio4a
QW/e6nCMyYR8bo0GQ9DpsyAOsaENnkghncQhA7GdPZK9xLMNQMCp0OdcZlqRVjRZ
OutuzNW6PPoczs/NQq02YWK4BPtSV7+ldS9gPZTLIpnRNQRzcnA0vnQTqSAfasVw
sAGm+MpH7zcaMf2Tw1K08u7+5gyObgzUzQmGLCgo9VIncnDis0s4gfTmtrr5jCeV
7LYDQX+2fApMtXbVXeKJem1PS+Z6LPbW2HklxYuG5nFgewCYlQjKujfiwW1Clhi4
JQeE1Naobbaar99V/VeoHrOYAEWP0bkUyrFcocLJ+0g3KpjSkctIptgGGpMBKe4U
9O7pWoTki8Yz/uYQn/p0iZcG8SfKM8I4283jdsi5SUiNNJJZCBQTVA7d8MxUVv5+
qpX/v5XqYM3pHza2DLXzwfAE9O2dgN1OMZYIld+OnWcpm2PxIwARAQABiQRyBBgB
CgAmFiEEC+MydddMlTx5+BEH2a0qGAV0dMsFAmOVdskCGwIFCQICKQACQAkQ2a0q
GAV0dMvBdCAEGQEKAB0WIQS2FSd+gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBu
WN6QHwAa77gbEADpUBT14cesITuMsOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMP
Xih9G1tDo9ExIWT8jNjSSA+w0Viua/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJW
y944YegHF/5ytntwZ/L4BMYc3MztyZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37
bbUVw62xHQIn2zafSmMQ4oMXZTm9EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1
G9jqkwlaRYWjcLD0qxwc5m9LNrF6OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDC
lTTH+dAx3b6J1KFB0UiHP3FeTalFh8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2
RAo/o2X5r40qk/lhydQRZTSTFsiuH3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7r
e0jj8XMIO7G5yjQKQCnYuPdXbx++bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17
MEPIton1+NRfsU0peEVggQXlwdTcZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpK
a9qfIqBX/monjy7w5IHmhvLwAYI6IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69
PxMbOJbMpWSg8L7xW3LXKR1VwXggUC1+b3y67E5Ggi1hf0lfTnTMpL2ClO2QD/oC
hMIafhzxbjh2WzgYahVHZH3gpHc1/0Bnc07s9+Pa6EYYM9r0XzezLW7bswOjVloR
FreQ3FIF/2OSN0OGdm7dyYl0OliTIDDDlwK/l8bcckUcpHNR1dw0P3KvDlmLmzZy
G4HmzzSBa9jiFirEfcg2rnGc6Zi382jGVALuYVplPXyMOUiChp0AAQZzTIYpXw/g
pBE6em2k740yuK6WqG4yXXgk67FoH10TQvMd4Q73K4zw+9DMpThlUHcfBmAoViZw
il7C0xl+ysHX8ZI3JU8s1r3XAnpqdHi4Wpixm/ctXbVnTSA3FQr2SctJYqR1VHRW
GMW+Ii2SQDS+t9bZTzOgAPLDtfy+JqhBpwCB1a1EHftkJEojpfZipaYGkf3yc+vN
wUeUHp/csF9CT7Qbqaj1t7fVWzv7jcVKpRwngIT4vTSzqbo6WC34FuUAH0t7tJ5K
eZ625AqEFLmtqtDo+ydJhZrVrXBNXPfkx5hSVW/I9hvckMNwA3t0KfQC2sz+Z1Q1
a4vDWQYRytfyrgZkWGbXMn6l1JyqIolgJZuax2kYs7Vu3t8KptqCbv0ZBAGoMm7r
RLgVodhI9voA8YxCirSChrueJYn+JKk8MIyk3DdXpBoocMIAjFJAUgXjV5NQpZMy
xR8BEiQnBcHRIKVWEEyhbLtHpmCEsnKNyKVGoxs31IkEcgQYAQoAJgIbAhYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJlhctvBQkD8n2mAkDBdCAEGQEKAB0WIQS2FSd+
gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBuWN6QHwAa77gbEADpUBT14cesITuM
sOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMPXih9G1tDo9ExIWT8jNjSSA+w0Viu
a/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJWy944YegHF/5ytntwZ/L4BMYc3Mzt
yZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37bbUVw62xHQIn2zafSmMQ4oMXZTm9
EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1G9jqkwlaRYWjcLD0qxwc5m9LNrF6
OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDClTTH+dAx3b6J1KFB0UiHP3FeTalF
h8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2RAo/o2X5r40qk/lhydQRZTSTFsiu
H3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7re0jj8XMIO7G5yjQKQCnYuPdXbx++
bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17MEPIton1+NRfsU0peEVggQXlwdTc
ZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpKa9qfIqBX/monjy7w5IHmhvLwAYI6
IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69PxMbOJbMpWSg8L7xW3LXKR1VwXgg
UC1+b3y67E5Ggi1hf0lfTnTMpL2ClAkQ2a0qGAV0dMsjqhAAorQ725G342raJ+os
6+E/EFNsr4SR5H+AeinlQ2ymNSeO/ODsV6dmyYD3hed0mAXvIJt2B46fFC4eAP9f
VOIbMMhPMpnJuZyLPDi8gXcZLgWSRhJ88R98KIsmKlh+/fdZM4RI1JLjICi7kyNR
4jtKCzLj0DYVBzp1mn0lTwtFzv7SC9djpqFLnO5YoGPWfQHHhY02Trh2posRwAHO
oacXSFvsoQv6k6XNlStJ4lnrkH6t+Od4kU3/TJ0eQXs7Zd2WEVnMe1IhbihsGcAY
mzZzZlLOhskHCeVE2taHiXC6h4tC3/69I16N8ICauxGY41clPhiNmVaAzmkunOPz
ry5utl6HkpZ5/3UMVHI1JIvsfJW+vSMUhdcQILAv6DbRWWHeax3ZZ6iAVGCtJS7U
glwZM1Xor0okGtIS+aJ/Cw7tZ8Nm18lutcrf2MVW+BWpzMQKnWFQYTn1NEWjzYnx
9Na22+E8AvW02TdS0NSiP0sG/0q7lBNEck9vH4WEbbEXktj51Dg4ISUhQyW8BWwW
X+kSiNeqtcaikUb8SFj5vpTDotTSzikfT/jisvR5goTMNFCVHFZdXCdsbUZd8Iub
egAOh6Db/06y3mFYDEfcGJipab400OY03a2xw9Vz+YxrKfELCTBo2tZv+3K8kXgq
XFcbyJnkXmjnYM/sw5kKqtzuc7i5Ag0EY5V3BwEQAMpFVczZo9ZPNsgW791UW5o6
wnrnd1nIO+S4rc37q2TEz8KGHCuxo5NwffZ2t6Ln04BI54pbapg17b7a0hPka37H
FkL28n4VyMdx0CsAm3QEfUsdK6xwKV2SucYeVcrV1upcN4PdXD7su1I7/A4CWXFJ
G047zJ0Z89lJZiQEiAq7ghvEoinC0sm+0a6ao/ocqCgWCKM1yCPOyzJXleRrv29S
RnYziMR+q2U0x9xg9Xl6GMwUmFwbJc9nORVvLH7fbU6/du8EgoAYrglFOFZG/TSo
lSGWRSMiavz0JSD/i+rEN4aIT4WfBe+L9Wy1AmrNxiAO+zKmzHQu3JSxDncr+y+h
cd+W0gqw10FoI9jWLcL7kR+6a0iOjuJSXSopq2l3DafiPxtCFmr4CGQhzBHM6e4/
v/NNd3F0XpVbJ6RQph7lkfvfz8q2lvUlHhezJ0p1xXmhff9CHjdVMhmAmz5+imBA
Xk2mottNfKb0pFEen1xY3K/UPA4g+oPsSj495MsvIg9eIMCcC3/z0SEUMWH/styy
JzPqfpyfGwZeTcIj9vg2o+RnGvmcLVYA/EGToPk905kv/cK73oy8bZyOB0zMg7T9
PaWgLUO0sqjqo0Mw3knFySg3oRXlcilPQvfPdX0JvwLpc9DWlr1+1GkCXJ08lWug
Jc96CJQupKRb1IbC0oUXABEBAAGJAjwEGAEKACYWIQQL4zJ110yVPHn4EQfZrSoY
BXR0ywUCY5V3BwIbDAUJAgIpAAAKCRDZrSoYBXR0ywwtD/wIDmEcHdFlyFRTomUB
jbeK2uzcZIhkkgL58lc63UPle5iJ2FBvmYS+0rQS53sVEsccn5KfkOwTryKllvWb
l0IzuiqfawxALcfWpfZJHzTMSnDHfgXvOOyFMQruqRDAHAr7PNC0CnbT0sEF2ZFz
ad8M9fLqtkXUx4mgECNGJ4CVqg75KY8uUzv/BmRwEf587FT5/iAIed5MjFB2VFDX
9GABcvTTbHxCZIxnxl3cs15SxT0lAofZ2ueU6kWYWZSXFeaEM/4ymPJws2mmV0Ak
bJghLXCn9Mx3nX6NTZZ9Harbru+RzW3/Hg3DZd0J9vko8PafP0l1NWtgyX74CqvT
gjzTxXTnqrRXzcczK7fhcC2u4i0prPtXXcyyi7SwpoLikaZCLFFhUmOx+mS5Tjtg
FyFZBNxnO7iAwkzfcTcC9sPoWaFmiQf6q5EIYzG+WQpncj80mxl3HWOP6oFj/hZJ
RYseKeMkvJzLTo87rFdM6CsMrLwETR6e+aWM0btPFil1rXVACNOjsy0bxTV8OJEf
yxnYmyjvnBvB0kdiaVEDdVhxgSqzLAX4mgXa49/V6M/uzMr+n3/A1Jdk4V6fVm8S
5cFIXxoUat3cB4xGaT9OWD3o1NPr6eS9Vo0EsJlRl81SG68fS+Qtk2fX27T68YG4
Aa3zMfZxUsVuFLtTuQbRC+fJpIkCPAQYAQoAJgIbDBYhBAvjMnXXTJU8efgRB9mt
KhgFdHTLBQJlhcuqBQkD8n1oAAoJENmtKhgFdHTLoO0QAJsTE9fkleb7YzPEuP9G
J3jx8PGdWm7n+8UNdr24kS6gOXVUfPZrWa5So21hcIwZb4PZDqHSVSQnRciKhSnG
7gplYPNGZ4+FWbLr/mBRYarjkVFLUuCPexSIjxV1KSGJnWs9YTVAKZAz75GpCML6
jD6biCOQCQ86wqOdWvZIZR8YvurrxR64ABB0rjbsaG8cNOUX1cwAfdLwthf64dS+
2m3lqNGDHkP5eNL0RIxC5gXYEp0lvmlMH3ZuO5WrfH73PTDg89bxXeuhrFmSEwf4
xWm603oi8/2qQvR9/7jb0o+t71NQuWrWIFONZWWgZBUGso+uyT3XgY4YqKGR3z2Q
zKHYnJ6M7SvSYpqS7RtcxcCXF0HGNfES8cAgtKVpFtbtSwXXp8O8oLyjmVIO/NjU
pbLOGdFIsarsezLFV9f2fqZ63J34hyUSg8LrYVV1fA5DJUpebbX4hLpdk0MMtgG4
3BwKIGlJTpL5RkQ/uQU3YW2kairy7o+1imDD0TRzQxtdjVOI5vnlTNcfJZIIfLx4
drABA12OvpX3dfPV62R+8BAlJFT430CG6AISJIBqJRFvuikmnZGUvEHmOUs/FLbb
aXTPkKc7tR2WIwljRvMV+Qk84cWcX6YchMslMuiDM1mtlQZig34WHGSE+zCWnXAs
lIHlSwox7qfdO0Kz2XncSbIA
=QvUh
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_core_team_secretary_core_secretaryfreebsd_org>D.1.2. Core Team Secretary <code>&lt;<a href=mailto:core-secretary@FreeBSD.org>core-secretary@FreeBSD.org</a>></code><a class=anchor href=#_core_team_secretary_core_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/4D632518C3546B05 2024-02-17 [SC] [expires: 2025-02-16]
      Key fingerprint = 1A23 6A92 528D 00DD 7965  76FE 4D63 2518 C354 6B05
uid                            FreeBSD Core Team Secretary &lt;core-secretary@FreeBSD.org&gt;
sub   rsa4096/CABFDE12CA516ED2 2024-02-17 [E] [expires: 2025-02-16]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGXQ1o8BEAC+Rcg8cmVxuP17Vu+q5KgCx/XiulQuqKXAqqBlYCH2jqk6DINP
yFrREGBhzd/qNmlAYEahQ4Zgl0bUZNTrZVDyzicOvPP0jH+KSTQwRs7NOawEdlVO
cyHrwDCPEqf5ZzD4NhfTriEOw+j0pEH/onitUGvoQRtx15xWyaJQxDEBMTYMLewE
86D1bltwnTNczE3UZb7oQLJXkAX5hcLtou70XJGgZITvJkK+kp/xot2eFjnqRz/u
WeXnKhYAmC07EKwZ1uw047eHKwMMRBYqzApLwoQtfE430Kxf2q8de64x8zDbi6YM
1J4r8OAxOtHVyfJ0j7Q23DEZz0VVb4b1Tx5OG2Re/KSNvqI0awJO4TcRmOR88OyY
dzyXgnX6Sa7GVQY1FXvn7vtFuDAt7egZOzeomSHL9bdX07LTQ4UtM88EV9wm3q4q
smoatV9jsvPQ1zxCU3aQD/5eWTJH2/kz1LIuBL/Qi5XQpJn91lBtUWJrCgkHWPGu
f//rnnXmsG7DAChW+yZ7cFO8lfNa8sFhPqSxCYphWmJTrvadyQtDngB8JakWdnmK
pfGS6y5lel+181vw38ZZKt04AKM+nDY8051lBM7Q9Q6kTLI33UZeImndx5xYukVD
kV6aQ31HYfEark15c7iEz+OAcwFnM2ntXMt7kKGd40CqzusiPcQkPqPbAQARAQAB
tDhGcmVlQlNEIENvcmUgVGVhbSBTZWNyZXRhcnkgPGNvcmUtc2VjcmV0YXJ5QEZy
ZWVCU0Qub3JnPokCVwQTAQoAQRYhBBojapJSjQDdeWV2/k1jJRjDVGsFBQJl0NaP
AhsDBQkB4TOACAsJDQgMBwsDBRUKCQgLBRYDAgEAAh4FAheAAAoJEE1jJRjDVGsF
nacP/3PSg8JPmWoBfWrgT287NZ7OAU16/uGpDxlBUoVeEtkEDqZVW8yBFzrMhbwj
bJs3CZ+L85HMUDLZoxSwVnPM8PLVRzHTybYV7agYYzMox5C/jp2aeAgy9KYVd0Tk
07GMTYrSh4fhHWpxXz7IBOxk0RXvQxTHlg1u0DASkibYb2UTDcUNG5Q9kP/8jaIZ
kVDX8a5LDdOCgWaYdKPg4blv/UMjkegJz+Ayp7gXTcux6koW5F6ysSw9sgLBWb2D
b/KNIi4MBMe46xyXB/dqGAR4ibrUXTcQ4OAZNq1L6uWG1A49XuSgykdIwr00MzQw
wfVpKT31ww4ayVHLgj7NuqPlab9S5/fPfJ4MAvGE4GqWQFgsPKgKImUMgnnxTGpv
l7Dqk2MnWqn+wEi0bRES0PVBG96G+sZJQeaxBhoB+HwUSFqoZQg166AJIl//4t2w
bx0a1aWQSS0DZt3wsQW3NW9AE6L+FnFfIc2pQVoLjmvcGalDuvnemRmEOgotiZmt
32bi2aWxg0/Qio2rjLS2LpV+fhwDSN3Agvtnu53yUdD1TFFjTSMloM4SKhiXoPbI
XgfCLiBLNMsZL0AvO7wQfSePzPYxDLyEcwsfPJ8be+eGG1L62RUyad+MdfyXMH/S
m0sgqW/MW6Nv10RyPQOq3Jbgmp2laRMzKTOvQt5WwQf2FEl9uQINBGXQ1o8BEAC9
1cBYn6Z0QmM0OFWdXQI6fMOeNokaa6ngPgt7bzW5NjryqTdwyHOPZdm4DWf1SO/0
+fJRCqxbICyuMAFrb9fDle8bodALjm5ZquTL3D61HpZD4+RwOzOjYP6wLm7h38HT
/yIyK882Ovlw4Xz/TeSiL/VUSWE9twW7yz3oreCeLUBAfzacS9y+syO+aquEd0/x
JBz+mPQbrqfS64rCZXMZEivgsjkQoE6RM+n1rF4kw4Eu3E2kPevVwsoAaY+MEUM8
JAXaJMaNcLIhbeMy7dO/z6z2I3h5bUw5KxfVwzYSzSeRpYh53dNaB4NY+f5/vTrL
4dZmqBcLgcV0zZ02dj/u0SiwWlUFUpFGuSiW16DN7+2zG1zOWi7Nl44JawM62Tlf
mO8zruVGEHaV3e8fFwBLRKM0Sc7e3aLECISsfYeC5ZbRRbpQ1KX+VQr3FBKAMzG4
l9Go7vZ+UcLKpQx2rVPTJt1vDnRV49X6CF2Q/lV9iafQ4MTy6ACdAloT1yfH/lhU
iWQo1qDyRCSlmNBDsYl8gLrwMp4gGQAv3imZHxnJF5ru3nUYGG0U08D5mf2sWv5P
Wh7By8Jm8bmaP8cUF86lO9BJXh2d9QN5jqrAtXqYzenZ+ABSoL1XrD/yv3270rH7
H4gAUtgP+vJ3uMyRu9055OC+ie/b613NojCW5nYN2QARAQABiQI8BBgBCgAmFiEE
GiNqklKNAN15ZXb+TWMlGMNUawUFAmXQ1o8CGwwFCQHhM4AACgkQTWMlGMNUawXh
7w/+KjbEWTwAhjm2HJ3w4tXtPC5URg+A+BzYYVH/q0+956c1QeD0LYafHBw4LEMI
lhRvHQnmzwjtY8v/DgmLOVDMiMWVHo0Q2iQyMvOT1WyEPcgOTJLhvyVzDqRZx7AS
B4G8uNVkKAdBZ7OSXAP27lR/2SEoG05esw8b7Y39pVtucC3aeiua+19PLJWadBjj
XuvXuSCho0km+nk4IgadYmxIDyiMeyKZ8wCl7CJkzECm83q2OtNsMe3k8lgEXybt
KlQxnYApZmhqLMV5ob8WOk3AgAVsif1m332CiEIb1Sfx6wt3nXy/410CXdDDucuj
ndJVfJ6Un33tn0irZ5scPA2HmzK1PGMfgOGtkM8B3LE/x8kEKeWKb3l9boB32Unm
iTfKgEna+JISEab3bzOPWdCQFB8LyGXuWlhtvqmRoX8GtiMRy/F4mzh+l3lYHjj3
4EvPVyippO5zwU+S9HElJ2G37K6zrOmd5cGBrw4aBDoO70QVrMN4O86uvC9kChDb
qyFF5UgXg29QxJjiSCv98ksDMqpJ5AFYrmrsBtwU64OANrxxJ4AZLQ1apYmG9RWD
VHZgfeI60FNBLfKwix9UffFT7piQ/MLrjSde8gPH5S6ezBMrYpfGEopaI9A5qXe3
LnHz88gfdmaBM77YDZM/p23nmCrUxlE3kkbgjTY8NRjYyF8=
=MkAH
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_ports_management_team_secretary_portmgr_secretaryfreebsd_org>D.1.3. Ports Management Team Secretary <code>&lt;<a href=mailto:portmgr-secretary@FreeBSD.org>portmgr-secretary@FreeBSD.org</a>></code><a class=anchor href=#_ports_management_team_secretary_portmgr_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   ed25519/E3C401F60D709D59 2023-03-06 [SC] [expires: 2027-03-05]
      Key fingerprint = BED4 A1D3 6555 B681 2E9F  ABDA E3C4 01F6 0D70 9D59
uid                            FreeBSD Ports Management Team Secretary &lt;portmgr-secretary@FreeBSD.org&gt;
sub   cv25519/2C92B55E27A641C3 2023-03-06 [E] [expires: 2027-03-05]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZAXJvxYJKwYBBAHaRw8BAQdASFAC20WL3R1T6uNyGMZbfJCxDkcP4C5vi3Op
tcZ2fbq0R0ZyZWVCU0QgUG9ydHMgTWFuYWdlbWVudCBUZWFtIFNlY3JldGFyeSA8
cG9ydG1nci1zZWNyZXRhcnlARnJlZUJTRC5vcmc+iJYEExYKAD4WIQS+1KHTZVW2
gS6fq9rjxAH2DXCdWQUCZAXJvwIbAwUJB4TOAAULCQgHAwUVCgkICwUWAwIBAAIe
BQIXgAAKCRDjxAH2DXCdWYN1AP43TjyfZtZ3DLYT++g0+SuPsoO/3yWVybA+UmFL
zb8MngEA+LLNUfvEwCuXS/soh+ww5bpfmi3UUmeGiQEAXug3iA+JATMEEAEKAB0W
IQT7N0XIbxXo7ayBMvzYKU7Du8TX1QUCZAXLkwAKCRDYKU7Du8TX1XHMB/9R1MX4
6zMgpKqPPt76GOI+eGEdBK6bY8aJZjQGdqTh9f6VtXVoTGIG7cvhc9X8tDBoB0PT
2KZWheF51AV1+NHU4HwLAQ1BMebrFvWSfkw4xg4fBGwDhz9/GN85No+Js772V5ey
8lRiL6meRVWxMlLyWcxGd8JjcC5yX/iAUQ3SBGCLqW7unWjjg7CTd+AMBwcqPGrv
ax8q6eFVguJcHJAjMnKf6HAy4cpK3s+uMoUBCGnszSN12B3ysKfyC4pNO/pix5tA
Q5v8aRqTeFPh5zmNhWo0KGPzplTPqRQSHDl7GDQC8Ru3MhzFkeWzHsexjZVwS6W2
DPcYpuuAsA0XOZIZiQIzBBABCgAdFiEEEBpxaxYrAOVb7eoFrbv4YQo3ibcFAmQF
0u0ACgkQrbv4YQo3ibccwg/9F2Xuic3nhKxRbB3mJeDo6SYQETa/Gh1qQ34+8zlt
8UMazOx67gnYQfy+pXjro6eQ2up0a4eUYezcNOudqAQD21nRz3HA6EQVNcE/TzEA
xl5CJntTaLOt7S+EDXFW5BuQIvhhoMGgm8+WNVgA0EJ7tfL0OcYBSvr19fqwChEn
9c14cSk6mgHSsleP5NvskYN053pxHwy0LTSb8YBBv52th37t/CRFC1363rS5q+D7
JixFopd1O5pKpA5ipvE4gGgRjPtwjx0SjjepwK/3fuhEJQQyKzTIKlMfu2Dj/iR2
Li1Sfccau5LQXOj9fUITU3u1YG7yrm8VGzT7ao4d+KRwgMLjd2pLqiGIbbJwGBiP
FRmtilWQoeIlmSlFX4obAA517DOK0pW1mH8+eEn4EJd3SekT3yzFyKTASv0J48Z8
3F928xg+eZvHxVC0t1J+J5IG0gt3EEncuWKIPQGR7PiQbti6R3FQVTz6WfMWOebP
Qi0E9F/Aqakr6Vj2sKGrDq+ebpaF5G8Yw1YrUl2IDiPzkCegp3ZbI0wh11Xvzhi8
LXPQGK4jBQas4G8cegfitzmtdGRHYrbMv0R9I4mvaL+WlOuD2AvyVG28lguqVhnN
AZP+ohdquYyX2CNCVvbKWAtXo6Ur0vWG8BL8m6defAtEkIwVBALaOHQOSI3aNUz4
lwy4OARkBcm/EgorBgEEAZdVAQUBAQdAsefmSfxEOdOr02+K/6noYCuJ1FeAWVz6
jFYQ+9w6jggDAQgHiH4EGBYKACYWIQS+1KHTZVW2gS6fq9rjxAH2DXCdWQUCZAXJ
vwIbDAUJB4TOAAAKCRDjxAH2DXCdWRl4AP9h5ot212BK29S6ZcMBhHvmtF5PG1oD
c7LnZycSRmbFiwEAndCMpAGOhDW8iVgDd0wLQq/ZMPe+xccfG1b3zFH2EgE=
=iiAT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_doceng_secretaryfreebsd_org>D.1.4. <code>&lt;<a href=mailto:doceng-secretary@FreeBSD.org>doceng-secretary@FreeBSD.org</a>></code><a class=anchor href=#_doceng_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa2048/E1C03580AEB45E58 2019-10-31 [SC] [expires: 2022-10-30]
      Key fingerprint = F24D 7B32 B864 625E 5541  A0E4 E1C0 3580 AEB4 5E58
uid                            FreeBSD Doceng Team Secretary &lt;doceng-secretary@freebsd.org&gt;
sub   rsa2048/9EA8D713509472FC 2019-10-31 [E] [expires: 2022-10-30]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQENBF27FFcBCADeoSsIgyQUY8vREwkTikwFFlNg31MVy5s/Nq1cNK1PRfRMnprS
yfB62KqbYuz16bmQKaA9zHN4FGfiTvR6tl66LVHm1s/5HPiLv8sP14GsruLro9zN
v72dO7a9i68bMw+jarPOnu9dGiDFEI0dACOkdCGEYKEUapQeNpmWRrQ46BeXyFwF
JcNx76bJJUkwk6fWC0W63D762e6lCEX6ndoaPjjLBnFvtx13heNGUc8RukBwe2mA
U5pSGHj47J05bdWiRSwZaXa8PcW+20zTWaP755w7zWe4h60GANY7OsT9nuOqsioJ
QonxTrJuZweKRV8fNQ1EfDws3HZr7/7iXvO3ABEBAAG0PEZyZWVCU0QgRG9jZW5n
IFRlYW0gU2VjcmV0YXJ5IDxkb2Nlbmctc2VjcmV0YXJ5QGZyZWVic2Qub3JnPokB
VAQTAQoAPhYhBPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsDBQkFo5qABQsJ
CAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEOHANYCutF5YB2IIALw+EPYmOz9qlqIn
oTFmk/5MrcdzC5iLEfxubbF6TopDWsWPiOh5mAuvfEmROSGf6ctvdYe9UtQV3VNY
KeeyskeFrIBOFo2KG/dFqKPAWef6IfhbW3HWDWo5uOBg01jHzQ/pB1n6SMKiXfsM
idL9wN+UQKxF3Y7S/bVrZTV0isRUolO9+8kQeSYT/NMojVM0H2fWrTP/TaNEW4fY
JBDAl5hsktzdl8sdbNqdC0GiX3xb4GvgVzGGQELagsxjfuXk6PfOyn6Wx2d+yRcI
FrKojmhihBp5VGFQkntBIXQkaW0xhW+WBGxwXdaAl0drQlZ3W+edgdOl705x73kf
Uw3Fh2a5AQ0EXbsUVwEIANEPAsltM4vFj2pi5xEuHEcZIrIX/ZJhoaBtZkqvkB+H
4pu3/eQHK5hg0Dw12ugffPMz8mi57iGNI9TXd8ZYMJxAdvEZSDHCKZTX9G+FcxWa
/AzKNiG25uSISzz7rMB/lV1gofCdGtpHFRFTiNxFcoacugTdlYDiscgJZMJSg/hC
GXBdEKXR5WRAgAGandcL8llCToOt1lZEOkd5vJM861w6evgDhAZ2HGhRuG8/NDxG
r4UtlnYGUCFof/Q4oPNbDJzmZXF+8OQyTNcEpVD3leEOWG1Uv5XWS2XKVHcHZZ++
ISo/B5Q6Oi3SJFCVV9f+g09YF+PgfP/mVMBgif2fT20AEQEAAYkBPAQYAQoAJhYh
BPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsMBQkFo5qAAAoJEOHANYCutF5Y
kecIAMTh2VHQqjXHTszQMsy3NjiTVVITI3z+pzY0u2EYmLytXQ2pZMzLHMcklmub
5po0X4EvL6bZiJcLMI2mSrOs0Gp8P3hyMI40IkqoLMp7VA2LFlPgIJ7K5W4oVwf8
khY6lw7qg2l69APm/MM3xAyiL4p6MU8tpvWg5AncZ6lxyy27rxVflzEtCrKQuG/a
oVaOlMjH3uxvOK6IIxlhvWD0nKs/e2h2HIAZ+ILE6ytS5ZEg2GXuigoQZdEnv71L
xyvE9JANwGZLkDxnS5pgN2ikfkQYlFpJEkrNTQleCOHIIIp8vgJngEaP51xOIbQM
CiG/y3cmKQ/ZfH7BBvlZVtZKQsI=
=MQKT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div></div></div></div></div><hr><div class=last-modified><p><strong>最後修改於</strong>: December 8, 2023 由 <a href="https://cgit.freebsd.org/doc/commit/?id=c63cb8dc15" target=_blank>Ruey-Cherng Yu</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#book-preface>序</a><ul><li><a href=#preface-audience>給讀者的話</a></li><li><a href=#preface-changes-from3>自第三版後的主要修訂</a></li><li><a href=#preface-changes-from2>自第二版後的主要修訂 (2004)</a></li><li><a href=#preface-changes>自第一版後的主要修訂 (2001)</a></li><li><a href=#preface-overview>本書架構</a></li><li><a href=#preface-conv>本書的編排體裁</a></li><li><a href=#preface-acknowledgements>銘謝</a></li></ul></li><li><a href=#getting-started>Part I: 入門</a><ul><li><a href=#introduction>Chapter 1. 簡介</a></li><li><a href=#bsdinstall>Chapter 2. 安裝 FreeBSD</a></li><li><a href=#basics>Chapter 3. FreeBSD 基礎</a></li><li><a href=#ports>Chapter 4. 安裝應用程式：套件與 Port</a></li><li><a href=#x11>Chapter 5. X Window 系統</a></li></ul></li><li><a href=#common-tasks>Part II: 一般作業</a><ul><li><a href=#desktop>Chapter 6. 桌面應用程式</a></li><li><a href=#multimedia>Chapter 7. 多媒體</a></li><li><a href=#kernelconfig>Chapter 8. 設定 FreeBSD 核心</a></li><li><a href=#printing>Chapter 9. 列印</a></li><li><a href=#linuxemu>Chapter 10. Linux® Binary 相容性</a></li></ul></li><li><a href=#system-administration>Part III: 系統管理</a><ul><li><a href=#config-tuning>Chapter 11. 設定與調校</a></li><li><a href=#boot>Chapter 12. FreeBSD 開機程序</a></li><li><a href=#security>Chapter 13. 安全性</a></li><li><a href=#jails>Chapter 14. Jail</a></li><li><a href=#mac>Chapter 15. 強制存取控制 (MAC)</a></li><li><a href=#audit>Chapter 16. 安全事件稽查</a></li><li><a href=#disks>Chapter 17. 儲存設備</a></li><li><a href=#geom>Chapter 18. GEOM: 模組化磁碟轉換框架</a></li><li><a href=#zfs>Chapter 19. Z 檔案系統 (ZFS)</a></li><li><a href=#filesystems>Chapter 20. 其他檔案系統</a></li><li><a href=#virtualization>Chapter 21. 虛擬化</a></li><li><a href=#l10n>Chapter 22. 在地化 - i18n/L10n 使用與安裝</a></li><li><a href=#updating-upgrading>Chapter 23. 更新與升級 FreeBSD</a></li><li><a href=#dtrace>Chapter 24. DTrace</a></li><li><a href=#usb-device-mode>Chapter 25. USB Device Mode / USB OTG</a></li></ul></li><li><a href=#network-communication>Part IV: 網路通訊</a><ul><li><a href=#serialcomms>Chapter 26. 序列通訊</a></li><li><a href=#ppp-and-slip>Chapter 27. PPP</a></li><li><a href=#mail>Chapter 28. 電子郵件</a></li><li><a href=#network-servers>Chapter 29. 網路伺服器</a></li><li><a href=#firewalls>Chapter 30. 防火牆</a></li><li><a href=#advanced-networking>Chapter 31. 進階網路設定</a></li></ul></li><li><a href=#appendices>Part V: 附錄</a><ul><li><a href=#mirrors>附錄 A: 取得 FreeBSD</a></li><li><a href=#bibliography>附錄 B: 參考書目</a></li><li><a href=#eresources>附錄 C: 網路資源</a></li><li><a href=#pgpkeys>附錄 D: OpenPGP 金鑰</a></li></ul></li></ul></nav><hr><div class=resources><h3>資源</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="下載 PDF"></i><a href=https://download.freebsd.org/doc/zh-tw/books/handbook/handbook_zh-tw.pdf>下載 PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title=編輯此頁></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/zh-tw/book target=_blank>編輯此頁</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/zh-tw/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt=選擇語言>
<span>繁體中文</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>淺色</option><option value=theme-dark>深色</option><option value=theme-high-contrast>高對比</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/zh-tw class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/zh-tw/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>