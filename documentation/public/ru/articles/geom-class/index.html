<!doctype html><html class=theme-light lang=ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/ru/articles/geom-class/><title>Создание класса GEOM | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Создание класса GEOM"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="ru"><meta property="og:url" content="https://docs.freebsd.org/ru/articles/geom-class/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/ru\/articles\/geom-class\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>О нас
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>О нас</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>Фонд FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Кодекс Этики</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Получить FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Получить FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Информация о релизах</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Подготовка релизов</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Бюллетени Безопасности</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Документация
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/ru>Портал документации</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook>Руководство</a></li><li><a href=https://docs.freebsd.org/ru/books/porters-handbook>Руководство по созданию портов</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Учебник Проекта Документирования</a></li><li><a href=https://man.FreeBSD.org target=_blank>Страницы Справочника</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Презентации и публикации</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/ru/books>Книги</a></li><li><a href=https://docs.freebsd.org/ru/articles>Статьи</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Сообщество
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Сообщество</a></li><li><a href=https://docs.freebsd.org/ru/articles/contributing>Стать участником</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Форум</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Списки рассылки</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>Каналы IRC</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Трекер ошибок</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Поддержка</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=ru>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Пожертвования</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>Создание класса GEOM</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Этот перевод может быть устаревшим. Для того, чтобы помочь с переводом, пожалуйста, обратитесь к <a href=https://translate-dev.freebsd.org/ target=_blank>Сервер переводов FreeBSD</a>.</p></div><div class=legalnotice><a id=trademarks></a><details><summary>товарные знаки</summary><p>FreeBSD является зарегистрированным товарным знаком Фонда FreeBSD.</p><p>Intel, Celeron, EtherExpress, i386, i486, Itanium, Pentium и Xeon это торговые марки или зарегистрированные торговые марки Intel Corporation или ее дочерних компаний в Соединенных Штатах и других странах.</p><p>Многие из обозначений, используемые производителями и продавцами для обозначения своих продуктов, заявляются в качестве товарных знаков. Когда такие обозначения появляются в этом документе, и Проекту FreeBSD известно о товарном знаке, к обозначению добавляется знак “™” или “®”.</p></details></div><div class=toc-mobile><h3>Содержание</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Вступление</a></li><li><a href=#prelim>2. Подготовка</a></li><li><a href=#kernelprog>3. Программирование в ядре FreeBSD</a></li><li><a href=#geom>4. Программирование в системе GEOM</a></li></ul></nav></div><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Аннотация</p></div><div class=paragraph><p>Эта статья документирует некоторые начальные выкладки в разработке GEOM-классов, а также модулей ядра в общем. Предполагается, что читатель близко знаком с программированием на Си в контексте пространства пользовательских процессов (userland).</p></div><hr></div></div><div class=sect1><h2 id=intro>1. Вступление<a class=anchor href=#intro></a></h2><div class=sectionbody><div class=sect2><h3 id=intro-docs>1.1. Документация<a class=anchor href=#intro-docs></a></h3><div class=paragraph><p>Документация по программированию для ядра скудная, это одна из немногих областей программирования, где почти нет хороших учебных пособий, и совет "читай исходники!" - сохраняет свою справедливость. Однако, существует несколько статей и книг разной актуальности, которые рекомендуются к изучению перед тем, как начать программировать:</p></div><div class=ulist><ul><li><p><a href=https://docs.freebsd.org/ru/books/developers-handbook/>Руководство FreeBSD для разработчиков</a> - часть Проекта Документации FreeBSD, ничего специфичного о программировании ядра в нем нет, зато есть немного общей полезной информации.</p></li><li><p><a href=https://docs.freebsd.org/ru/books/arch-handbook/>Руководство по Архитектуре FreeBSD</a> - также является частью Проекта Документации FreeBSD, содержит описания некоторых низкоуровневых средств и процедур. Уделите внимание разделу номер 13 - <a href=https://docs.freebsd.org/ru/books/arch-handbook/#driverbasics>Написание драйверов устройств для FreeBSD</a>.</p></li><li><p>Несколько интересных статей об устройстве ядра можно найти на сайте <a href=http://www.freebsddiary.com>FreeBSD Diary</a>.</p></li><li><p>Страницы из раздела номер 9 системного справочника, содержат важную документацию по функциям ядра.</p></li><li><p>Страница справочника <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=4&amp;format=html">geom(4)</a>, а также <a href=http://phk.freebsd.dk/pubs/>слайды Пола-Хеннинга Кампа </a>- общее представление о подсистеме GEOM.</p></li><li><p>Страницы справочника <a href="https://man.freebsd.org/cgi/man.cgi?query=g_bio&amp;sektion=9&amp;format=html">g_bio(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_event&amp;sektion=9&amp;format=html">g_event(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_data&amp;sektion=9&amp;format=html">g_data(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_geom&amp;sektion=9&amp;format=html">g_geom(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_provider&amp;sektion=9&amp;format=html">g_provider(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_consumer&amp;sektion=9&amp;format=html">g_consumer(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_access&amp;sektion=9&amp;format=html">g_access(9)</a>, а также другие, связанные с вышеупомянутыми и раскрывающие специфический функционал подсистемы GEOM.</p></li><li><p>Страница справочника <a href="https://man.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9&amp;format=html">style(9)</a> - документирует соглашения о стиле оформления кода, которые обязаны быть соблюдены если вы планируете передать ваш код в Subversion репозиторий FreeBSD.</p></li></ul></div></div></div></div><div class=sect1><h2 id=prelim>2. Подготовка<a class=anchor href=#prelim></a></h2><div class=sectionbody><div class=paragraph><p>Для того, чтоб заниматься разработками для ядра, желательно иметь два отдельных компьютера. Один из них предназначен для среды разработки и исходных кодов, а второй - для запуска тестов отлаживаемого кода. Второму компьютеру для работы достаточно иметь возможность выполнять начальную загрузку по сети и монтирование файловых систем по сети. В этой ситуации, если отлаживаемый код содержит ошибки и вызовет аварийную остановку системы, то это не повлечет порчу или утерю исходного кода . Второму компьютеру даже не потребуется иметь свой монитор, достаточно будет соединения асинхронных портов кабелем RS-232 или соединения при помощи KVM-устройства.</p></div><div class=paragraph><p>Но так как далеко не у каждого есть два или более компьютеров под рукой, есть пара способов подготовить иную "живую" систему для разработки кода для ядра. Один из них - это разработка в <a href=http://www.vmware.com/>VMWare</a> или <a href=http://www.qemu.org/>QEmu</a> виртуальной машине (это лучшее из доступного, после, конечно-же, выделенного для тестов компьютера).</p></div><div class=sect2><h3 id=prelim-system>2.1. Настройка системы для разработки<a class=anchor href=#prelim-system></a></h3><div class=paragraph><p>Прежде всего необходимо иметь в ядре поддержку <code>INVARIANTS</code>. Добавьте следующие строки в файл конфигурации ядра:</p></div><div class="literalblock programlisting"><div class=content><pre>options INVARIANT_SUPPORT
options INVARIANTS</pre></div></div><div class=paragraph><p>Для большей информативности при отладке включите поддержку WITNESS, которая будет предупреждать вас в случае возникновения взаимоблокировок:</p></div><div class="literalblock programlisting"><div class=content><pre>options WITNESS_SUPPORT
options WITNESS</pre></div></div><div class=paragraph><p>Также включите отладочные символы, если планируете выполнять отладку по дампам аварийных отказов</p></div><div class="literalblock programlisting"><div class=content><pre>  makeoptions    DEBUG=-g</pre></div></div><div class=paragraph><p>Установка отладочного ядра обычным способом (<code>make installkernel</code>) не даст привычного результата: файл ядра будет называться <span class=filename>kernel.debug</span> и будет находиться в <span class=filename>/usr/obj/usr/src/sys/KERNELNAME/</span>. Для удобства, отладочное ядро необходимо скопировать в <span class=filename>/boot/kernel/</span>.</p></div><div class=paragraph><p>Также удобно иметь включенный отладчик ядра, так вы сможете исследовать паники сразу-же после их возникновения. Для включения отладчика добавьте следующие строки в файл конфигурации ядра:</p></div><div class="literalblock programlisting"><div class=content><pre>options KDB
options DDB
options KDB_TRACE</pre></div></div><div class=paragraph><p>Для автоматического запуска отладчика ядра после возникновения паники может понадобиться установить переменную sysctl:</p></div><div class="literalblock programlisting"><div class=content><pre>  debug.debugger_on_panic=1</pre></div></div><div class=paragraph><p>Паники системы будут происходить, поэтому уделите внимание кэшу файловой системы. Обычно, при включенном механизме softupdates, последняя версия файла может быть утеряна если паника произошла раньше сбрасывания кэша на устройство хранения. Выключение механизма softupdates (посредством монтирования файловой системы с опцией "sync") значительно сказывается на производительности и, опять-же, не гарантирует целостности данных. Как компромисс, можно сократить задержки сбрасывания кэша механизма softupdates. Есть три переменных sysctl, значения которых необходимо изменить (лучше всего - прописав их в <span class=filename>/etc/sysctl.conf</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>kern.filedelay=5
kern.dirdelay=4
kern.metadelay=3</pre></div></div><div class=paragraph><p>Значения этих переменных - секунды.</p></div><div class=paragraph><p>Для отладки паник ядра необходимы дампы памяти. Так как паника ядра может "сломать" файловую систему, дамп сначала сохраняется в "сырой" раздел. Обычно, это своп-раздел. Поэтому, размер своп-раздела должен быть не меньше размера ОЗУ компьютера. При последующей загрузке дамп копируется в обычный файл. Это происходит сразу-же после проверки и монтирования файловых систем, но перед активированием раздела свопа. Такое поведение контролируется следующими переменными <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dumpdev=&#34;/dev/ad0s4b&#34;
dumpdir=&#34;/usr/core&#34;</pre></div></div><div class=paragraph><p>Переменная <code>dumpdev</code> указывает на раздел подкачки, а <code>dumpdir</code> сообщает системе куда перемещать дамп ядра при следующей загрузке.</p></div><div class=paragraph><p>Сохранение дампа ядра - процесс медленный, и, если у вашего компьютера много оперативной памяти (>256M) и если паники случаются часто, то ожидание сохранения дампов может начать раздражать (вспомним, что над дампом происходит две операции: сохранение в своп-файл и перемещение на файловую систему). В таком случае может оказаться удобным ограничивание объема используемой системой памяти путем установки переменной в <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>  hw.physmem=&#34;256M&#34;</pre></div></div><div class=paragraph><p>Если паники случаются часто и размер файловых систем большой (или же вы просто не доверяете softupdates и фоновой проверке файловых систем), рекомендуется отключить фоновую проверку файловых систем посредством установки переменной в <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>  background_fsck=&#34;NO&#34;</pre></div></div><div class=paragraph><p>В этом случае файловые системы будут проверяться только при необходимости. Также заметьте, что в случае использования фоновой проверки, новая паника может случиться в то время, когда проверяются диски. Другими словами, наиболее безопасный способ - не иметь много локальных файловых систем, а использовать второй компьютер в качестве NFS-сервера.</p></div></div><div class=sect2><h3 id=prelim-starting>2.2. Начало проекта<a class=anchor href=#prelim-starting></a></h3><div class=paragraph><p>Для написания нового класса GEOM необходимо создать поддиректорию в любой доступной пользователю директории. Совсем не обязательно, чтоб ваш модуль изначально размещался в <span class=filename>/usr/src</span>.</p></div></div><div class=sect2><h3 id=prelim-makefile>2.3. Makefile<a class=anchor href=#prelim-makefile></a></h3><div class=paragraph><p>Правилом хорошего тона является создание <span class=filename>Makefile</span>-ов для каждого нетривиального проекта, примером которого конечно-же является создание модулей ядра.</p></div><div class=paragraph><p>Создание <span class=filename>Makefile</span> - дело не сложное благодаря исчерпывающему набору вспомогательных средств, предоставляемых системой. В вкратце, вот как должен выглядеть <span class=filename>Makefile</span> для модуля ядра:</p></div><div class="literalblock programlisting"><div class=content><pre>SRCS=g_journal.c
KMOD=geom_journal

.include &lt;bsd.kmod.mk&gt;</pre></div></div><div class=paragraph><p>Этот <span class=filename>Makefile</span> (с измененными именами файлов) подойдет к любому модулю ядра. Класс GEOM может размещаться в одном единственном модуле ядра. Если для сборки вашего модуля требуется больше, чем один файл, то перечислите их имена, разделенные пробельными символами, в переменной <code>SRCS</code>.</p></div></div></div></div><div class=sect1><h2 id=kernelprog>3. Программирование в ядре FreeBSD<a class=anchor href=#kernelprog></a></h2><div class=sectionbody><div class=sect2><h3 id=kernelprog-memalloc>3.1. Выделение памяти<a class=anchor href=#kernelprog-memalloc></a></h3><div class=paragraph><p>Прочитайте <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> - выделение памяти лишь немного отличается от своего эквивалента, используемого в пространстве пользовательских процессов (userland). Наиболее приметно то, что <code>malloc</code>() и <code>free</code>() принимают дополнительные параметры, которые описаны в странице справочника.</p></div><div class=paragraph><p>Тип "malloc_type" необходимо объявить в секции деклараций файла с исходным кодом, например:</p></div><div class="literalblock programlisting"><div class=content><pre>  static MALLOC_DEFINE(M_GJOURNAL, &#34;gjournal data&#34;, &#34;GEOM_JOURNAL Data&#34;);</pre></div></div><div class=paragraph><p>Для того, чтобы можно было использовать этот макрос, необходимо включить следующие заголовочные файлы: <span class=filename>sys/param.h</span>, <span class=filename>sys/kernel.h</span> и <span class=filename>sys/malloc.h</span></p></div><div class=paragraph><p>Существует еще один механизм выделения памяти - UMA (Universal Memory Allocator), описанный в <a href="https://man.freebsd.org/cgi/man.cgi?query=uma&amp;sektion=9&amp;format=html">uma(9)</a>. Это специфический метод, преимущественно предназначенный для быстрого выделения памяти под списки, состоящие из элементов одинакового размера (например, динамические массивы структур).</p></div></div><div class=sect2><h3 id=kernelprog-lists>3.2. Очереди и списки<a class=anchor href=#kernelprog-lists></a></h3><div class=paragraph><p>Ознакомьтесь с <a href="https://man.freebsd.org/cgi/man.cgi?query=queue&amp;sektion=3&amp;format=html">queue(3)</a> Во множестве случаев вам необходимо будет организовывать и управлять такой структурой данных, как списки. К счастью, эта структура данных реализована несколькими способами в виде макросов на Си, а также включена в систему. Наиболее гибкий и часто употребляемый тип списка - TAILQ. Этот тип списка также один из наиболее требовательных к памяти (его элементы - с двойными связями), а также - наиболее медленный (однако счет идет на несколько инструкций ЦПУ, поэтому последнее утверждение не следует воспринимать в всерьез).</p></div><div class=paragraph><p>Если важна скорость получения данных, то возьмите на вооружение <a href="https://man.freebsd.org/cgi/man.cgi?query=tree&amp;sektion=3&amp;format=html">tree(3)</a> и <a href="https://man.freebsd.org/cgi/man.cgi?query=hashinit&amp;sektion=9&amp;format=html">hashinit(9)</a>.</p></div></div><div class=sect2><h3 id=kernelprog-bios>3.3. BIOs<a class=anchor href=#kernelprog-bios></a></h3><div class=paragraph><p>Структура <code>bio</code> используется для всех операций ввода/вывода, касающихся GEOM. Она содержит информацию о том, какое устройство ('поставщик geom') должно ответить на запрос, тип запроса, смещение, длину и указатель на буфер, а также набор "определенных пользователем" флагов и полей .</p></div><div class=paragraph><p>Важным моментом является то, что <code>bio</code> обрабатываются асинхронно. Это значит, что во многих частях кода нет аналога к <a href="https://man.freebsd.org/cgi/man.cgi?query=read&amp;sektion=2&amp;format=html">read(2)</a> и <a href="https://man.freebsd.org/cgi/man.cgi?query=write&amp;sektion=2&amp;format=html">write(2)</a> функциям из пространства пользовательских процессов, которые не возвращают управление пока не выполнится системный вызов. Скорее, по завершении обработки запроса (или в случае ошибки при обработке) как извещение вызывается определенная пользователем функция.</p></div><div class=paragraph><p>Асинхронная модель программирования в чем-то сложней, нежели чаще используемая императивная модель, используемая в пространстве пользовательских процессов; в любом случае, привыкание займет некоторое время. В некоторых случаях могут быть использованы вспомогательные функции <code>g_write_data</code>() и <code>g_read_data</code>(), но <em>далеко не всегда</em>. В частности, эти функции не могут использоваться когда захвачен мьютекс; например, мьютекс GEOM-топологии или внутренний мьютекс, удерживаемый в ходе выполнения <code>.start</code>() или <code>.stop</code>().</p></div></div></div></div><div class=sect1><h2 id=geom>4. Программирование в системе GEOM<a class=anchor href=#geom></a></h2><div class=sectionbody><div class=sect2><h3 id=geom-ggate>4.1. Ggate<a class=anchor href=#geom-ggate></a></h3><div class=paragraph><p>Если максимальная производительность не требуется, то более простой способ совершать преобразования данных - это выполнять их в пространстве пользовательских процессов посредством ggate (GEOM gate). К недостаткам следует отнести невозможность простого переноса кода в ядро.</p></div></div><div class=sect2><h3 id=geom-class>4.2. Класс GEOM<a class=anchor href=#geom-class></a></h3><div class=paragraph><p>Класс GEOM выполняет преобразования данных. Эти преобразования могут быть скомпонованы друг с другом в виде дерева. Экземпляр класса GEOM называют <em>geom</em>.</p></div><div class=paragraph><p>В каждом классе GEOM есть несколько "методов класса", которые вызываются когда экземпляра класса нет в наличии (или же они не привязаны к конкретному экземпляру класса).</p></div><div class=ulist><ul><li><p><code>.init</code> вызывается тогда, когда системе GEOM становится известно о классе GEOM (например, когда загружается модуль ядра).</p></li><li><p><code>.fini</code> будет вызван в случае отказа GEOM системы от класса (например, при выгрузке модуля).</p></li><li><p><code>.taste</code> вызывается, когда в системе появляется новый класс или поставщик geom ("provider"). Если соответствие найдено, то эта функция обычно создает и запускает экземпляр geom.</p></li><li><p><code>.destroy_geom</code> вызывается при необходимости разрушить экземпляр geom.</p></li><li><p><code>.ctlconf</code> будет вызван, когда пользователь запросит изменение конфигурации существующего экземпляра geom</p></li></ul></div><div class=paragraph><p>Также определены функции событий GEOM, которые копируются в экземпляр geom.</p></div><div class=paragraph><p>Поле <code>.geom</code> в структуре <code>g_class</code> - это список (LIST) экземпляров geom, реализованных из класса.</p></div><div class=paragraph><p>Эти функции вызываются из g_event потока ядра.</p></div></div><div class=sect2><h3 id=geom-softc>4.3. Softc<a class=anchor href=#geom-softc></a></h3><div class=paragraph><p>"softc" - это устаревший термин для "приватных данных драйвера" ("driver private data"). Название вероятней всего происходит от устаревшего термина "software control block". В системе GEOM softc это структура (точнее: указатель на структуру) которая может быть присоединена к экземпляру geom и может содержать приватные данные экземпляра. У большинства классов GEOM есть следующие члены:</p></div><div class=ulist><ul><li><p><code>struct g_provider *provider</code> : "поставщик geom" предоставляемый данным экземпляром geom</p></li><li><p><code>uint16_t n_disks</code> : Количество потребителей geom ("consumer"), обслуживаемых данным экземпляром geom</p></li><li><p><code>struct g_consumer **disks</code> : Массив <code>struct g_consumer*</code>. (Невозможно обойтись одинарным указателем, потому что система GEOM создает для нас структуры struct g_consumer)</p></li></ul></div><div class=paragraph><p>Структура <code>softc</code> содержит состояние экземпляра geom. У каждого экземпляра есть свой softc.</p></div></div><div class=sect2><h3 id=geom-metadata>4.4. Метаданные<a class=anchor href=#geom-metadata></a></h3><div class=paragraph><p>Формат метаданных в той или иной мере зависит от конкретного класса, но <em>обязан</em> начинаться с:</p></div><div class=ulist><ul><li><p>16-байтного буфера для подписи - строки с завершающим нулем (обычно это имя класса)</p></li><li><p>uint32 идентификатора версии</p></li></ul></div><div class=paragraph><p>Подразумевается, что классы geom знают как обращаться с метаданными с идентификаторами версий ниже, чем их собственные.</p></div><div class=paragraph><p>Метаданные размещаются в последнем секторе поставщика geom (поэтому обязаны целиком умещаться в нем).</p></div><div class=paragraph><p>(Все это зависит от реализации, но весь существующий код работает подобно описанному и поддерживается библиотеками.)</p></div></div><div class=sect2><h3 id=geom-creating>4.5. Маркирование/создание экземпляра geom<a class=anchor href=#geom-creating></a></h3><div class=paragraph><p>Последовательность событий следующая:</p></div><div class=ulist><ul><li><p>пользователь запускает служебную программу <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=8&amp;format=html">geom(8)</a></p></li><li><p>программа решает каким классом geom ей придется управлять и ищет библиотеку <span class=filename>geom_CLASSNAME.so</span> (которая обычно находится в <span class=filename>/lib/geom</span>).</p></li><li><p>она открывает библиотеку при помощи <a href="https://man.freebsd.org/cgi/man.cgi?query=dlopen&amp;sektion=3&amp;format=html">dlopen(3)</a>, извлекает вспомогательные функции и определения параметров командной строки.</p></li></ul></div><div class=paragraph><p>Вот так происходит создание/маркирование нового экземпляра geom:</p></div><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=8&amp;format=html">geom(8)</a> ищет команду в аргументах командной строки (обычно это <code>label</code>) и вызывает вспомогательную функцию.</p></li><li><p>Вспомогательная функция проверяет параметры и собирает метаданные, которые записываются во все вовлеченные поставщики geom.</p></li><li><p>Это "повреждает (spoil)" существующие экземпляры geom (если они были) и порождает новый виток "тестирования" поставщиков geom. Целевой класс geom опознает метаданные и активирует экземпляр geom.</p></li></ul></div><div class=paragraph><p>(Приведенная выше последовательность событий зависит от конкретной реализации, но весь существующий код работает подобно описанному и поддерживается библиотеками.)</p></div></div><div class=sect2><h3 id=geom-command>4.6. Структура команд geom<a class=anchor href=#geom-command></a></h3><div class=paragraph><p>Вспомогательная библиотека <span class=filename>geom_CLASSNAME.so</span> экспортирует структуру <code>class_commands</code>, которая является массивом элементов <code>struct g_command</code>. Эти команды одинакового формата и выглядят следующим образом:</p></div><div class="literalblock programlisting"><div class=content><pre>  команда [-опции] имя_geom [другие]</pre></div></div><div class=paragraph><p>Общими командами являются:</p></div><div class=ulist><ul><li><p>label - записать метаданные в устройства, чтобы они могли быть опознаны в процессе тестирования и использованы в соответствующих экземплярах geom</p></li><li><p>destroy - разрушить метаданные, за которым последует разрушение экземпляров geom</p></li></ul></div><div class=paragraph><p>Общие опции:</p></div><div class=ulist><ul><li><p><code>-v</code> : детальный вывод</p></li><li><p><code>-f</code> : принудить</p></li></ul></div><div class=paragraph><p>Некоторые операции, к примеру маркирование метаданными и разрушение метаданных могут быть выполнены из пространства пользовательских процессов. Для этого, структура <code>g_command</code> содержит поле <code>gc_func</code>, которое может быть установлено на функцию (в том-же <span class=filename>.so</span>), которая будет вызвана для обработки команды. В случае, когда <code>gc_func</code> равно NULL, команда будет передана модулю ядра: функции <code>.ctlreq</code> класса GEOM.</p></div></div><div class=sect2><h3 id=geom-geoms>4.7. Экземпляры geom<a class=anchor href=#geom-geoms></a></h3><div class=paragraph><p>У экземпляров классов GEOM есть внутренние данные, которые хранятся в структурах softc, а также есть некоторые функции, посредством которых они реагируют на внешние события.</p></div><div class=paragraph><p>Функции событий:</p></div><div class=ulist><ul><li><p><code>.access</code> : просчитывает права доступа (чтение/запись/исключительный доступ)</p></li><li><p><code>.dumpconf</code> : возвращает информацию о экземпляре geom; формат XML</p></li><li><p><code>.orphan</code> : вызывается, когда отсоединяется любой из низлежащих поставщиков geom</p></li><li><p><code>.spoiled</code> : вызывается, когда производится запись в низлежащий поставщик geom</p></li><li><p><code>.start</code> : обрабатывает ввод/вывод</p></li></ul></div><div class=paragraph><p>Эти функции вызываются из ядерного потока <code>g_down</code> и в этом контексте не может быть блокировок (поищите определение "блокировка" в других источниках), что немного ограничивает свободу действий, но способствует быстроте обработки.</p></div><div class=paragraph><p>Из вышеупомянутых, наиболее важной и выполняющей полезную работу функцией является <code>.start</code>(), которая вызывается всякий раз, когда поставщику geom, управляемому экземпляром класса, приходит запрос BIO.</p></div></div><div class=sect2><h3 id=geom-threads>4.8. Потоки выполнения системы geom<a class=anchor href=#geom-threads></a></h3><div class=paragraph><p>Системой GEOM в ядре ОС создаются и используются три потока выполнения (kernel threads):</p></div><div class=ulist><ul><li><p><code>g_down</code> : Обрабатывает запросы, приходящие от высокоуровневых сущностей (таких, как запросы из пространства пользовательских процессов) на пути к физическим устройствам</p></li><li><p><code>g_up</code> : Обрабатывает ответы от драйверов устройств на запросы, выполненные высокоуровневыми сущностями</p></li><li><p><code>g_event</code> : Отрабатывает в остальных случаях, как-то создание экземпляра geom, просчитывание прав доступа, события "повреждения" и т.п.</p></li></ul></div><div class=paragraph><p>Когда пользовательский процесс запрашивает "прочитать данные X по смещению Y файла", происходит следующее:</p></div><div class=ulist><ul><li><p>Файловая система преобразует запрос в экземпляр структуры bio и передает его системе GEOM. Файловая система "знает", что экземпляр geom должен обработать запрос, так как файловые системы размещаются непосредственно над экземпляром geom.</p></li><li><p>Запрос завершается вызовом функции <code>.start</code>() в потоке g_down и достигает верхнего экземпляра geom.</p></li><li><p>Верхний экземпляр geom (например, это секционировщик разделов (partition slicer)) определяет, что запрос должен быть переадресован нижестоящему экземпляру geom (к примеру, драйверу диска). Вышестоящий экземпляр geom создает копию запроса bio (запросы bio <em>ВСЕГДА</em> копируются при передаче между экземплярами geom при помощи <code>g_clone_bio</code>()!), изменяет поля смещения и целевого поставщика geom и запускает на обработку копию при помощи функции <code>g_io_request</code>()</p></li><li><p>Драйвер диска также получает запрос bio, как вызов функции <code>.start</code>() в потоке <code>g_down</code>. Драйвер обращается к контроллеру диска, получает блок данных и вызывает функцию <code>g_io_deliver</code>() используя копию запроса bio</p></li><li><p>Теперь, извещение о завершении bio "всплывает" в потоке <code>g_up</code>. Сначала в потоке <code>g_up</code> вызывается функция <code>.done</code>() секционировщика разделов, последний использует полученную информацию, разрушает клонированный экземпляр структуры bio посредством <code>g_destroy_bio</code>() и вызывает <code>g_io_deliver</code>() используя первоначальный запрос</p></li><li><p>Файловая система получает данные и передает их пользовательскому процессу</p></li></ul></div><div class=paragraph><p>За информацией о том, как данные передаются в структуре <code>bio</code> между экземплярами geom, смотрите <a href="https://man.freebsd.org/cgi/man.cgi?query=g_bio&amp;sektion=9&amp;format=html">g_bio(9)</a> (обратите внимание на использование полей <code>bio_parent</code> и <code>bio_children</code>).</p></div><div class=paragraph><p>Важный момент в том, что <em>НЕЛЬЗЯ ДОПУСКАТЬ БЛОКИРОВОК В ПОТОКАХ G_UP И G_DOWN</em>. Вот неполный перечень того, что нельзя делать в этих потоках:</p></div><div class=ulist><ul><li><p>Вызывать функции <code>msleep</code>() или <code>tsleep</code>().</p></li><li><p>Использовать функции <code>g_write_data</code>() и <code>g_read_data</code>(), так как они блокируются в момент обмена данными с потребителями geom.</p></li><li><p>Ожидать ввод/вывод.</p></li><li><p>Вызывать <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> и <code>uma_zalloc</code>() с установленным флагом <code>M_WAITOK</code>.</p></li><li><p>Использовать <a href="https://man.freebsd.org/cgi/man.cgi?query=sx&amp;sektion=9&amp;format=html">sx(9)</a></p></li></ul></div><div class=paragraph><p>Это ограничение на код GEOM призвано избежать от "засорения" пути запроса ввода/вывода, так как блокировки обычно не имеют четких временных границ, и нет гарантий на занимаемое время (также на то есть и другие технические причины). Это также значит, что в вышеупомянутых потоках сколь-нибудь сложные операции выполнить нельзя, например: любое сложное преобразование требует выделения памяти. К счастью решение есть: создание дополнительных ядерных потоков.</p></div></div><div class=sect2><h3 id=geom-kernelthreads>4.9. Ядерные потоки выполнения, предназначенные для использования в коде geom<a class=anchor href=#geom-kernelthreads></a></h3><div class=paragraph><p>Ядерные потоки выполнения создаются функцией <a href="https://man.freebsd.org/cgi/man.cgi?query=kthread_create&amp;sektion=9&amp;format=html">kthread_create(9)</a>, в своем поведении они схожи с потоками, созданными в пространстве пользовательских процессов, но есть одно отличие: они не могут известить вызвавший их поток о своем завершении; по завершению - необходимо вызывать <a href="https://man.freebsd.org/cgi/man.cgi?query=kthread_exit&amp;sektion=9&amp;format=html">kthread_exit(9)</a></p></div><div class=paragraph><p>В коде GEOM обычное назначение этих потоков - разгрузить поток <code>g_down</code> (функцию <code>.start</code>() ) от обработки запросов. Эти потоки подобны "обработчикам событий" ("event handlers"): у них есть очередь событий (которая наполняется событиями от разных функций из разных потоков; очередь необходимо защищать мьютексом), события из очереди выбираются одно за другим и обрабатываются в большом блоке <code>switch</code>().</p></div><div class=paragraph><p>Основное преимущество использования отдельного потока, который обрабатывает запросы ввода/вывода, то, что он может блокироваться по мере необходимости. Это, несомненно, привлекательно, но должно быть хорошо обдумано. Блокирование - хорошо и удобно, но может существенно снизить производительность преобразований данных в системе GEOM. Особо требовательные к производительности классы могут делать всю работу в функции <code>.start</code>(), уделяя особое внимание ошибкам при работе с памятью.</p></div><div class=paragraph><p>Еще одно преимущество потока "обработчика событий" это сериализация всех запросов и ответов, приходящих с разных потоков geom в один поток. Это также удобно, но может быть медленным. В большинстве случаев, обработка запросов функцией <code>.done</code>() может быть оставлена потоку <code>g_up</code>.</p></div><div class=paragraph><p>У мьютексов в ядре FreeBSD (<a href="https://man.freebsd.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;format=html">mutex(9)</a>) есть одно различие с их аналогами из пространства пользовательских процессов - во время удержания мьютекса в коде не должно быть блокировки. Если в коде необходимо блокирование, то лучше использовать <a href="https://man.freebsd.org/cgi/man.cgi?query=sx&amp;sektion=9&amp;format=html">sx(9)</a>. С другой стороны, если вся ваша работа выполняется в одном потоке, вы можете обойтись вообще без мьютексов.</p></div></div></div></div><hr><div class=last-modified><p><strong>Изменено</strong>: 3 ноября 2021 г. by <a href="https://cgit.freebsd.org/doc/commit/?id=64acd169b8" target=_blank>Sergio Carlavilla Delgado</a></p></div></div><aside class=toc><div class=toc-content><h3>Содержание</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Вступление</a></li><li><a href=#prelim>2. Подготовка</a></li><li><a href=#kernelprog>3. Программирование в ядре FreeBSD</a></li><li><a href=#geom>4. Программирование в системе GEOM</a></li></ul></nav><hr><div class=resources><h3>Материалы</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Скачать PDF"></i><a href=https://download.freebsd.org/doc/ru/articles/geom-class/geom-class_ru.pdf>Скачать PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Редактировать эту страницу"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/ru/_index target=_blank>Редактировать эту страницу</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/ru/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Выберите язык">
<span>Русский</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>Система</option><option value=theme-light>Светлый</option><option value=theme-dark>Тёмный</option><option value=theme-high-contrast>Высокая контрастность</option></select></div></div></section><section class=about-column><h3 class=column-title>О нас</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>Фонд FreeBSD</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Получить FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Кодекс Этики</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Бюллетени Безопасности</a></li></ul></section><section class=documentation-column><h3 class=column-title>Документация</h3><ul class=column-elements-container><li><a href=/ru class=column-element>Портал документации</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Страницы Справочника</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Презентации и публикации</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Предыдущие версии</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>Документы 4.4BSD</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Сообщество</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/ru/articles/contributing class=column-element>Принять участие</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Форум Сообщества</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Списки рассылки</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>Каналы IRC</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Трекер ошибок</a></li></ul></section><section class=legal-column><h3 class=column-title>Юридическая информация</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Пожертвования</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Лицензирование</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Политика Конфиденциальности</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Юридические оговорки</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 Проект FreeBSD. Все права защищены</p><span>Сделано с помощью <span class=heart>♥</span> Сообществом FreeBSD</span></section></div></footer></body></html>