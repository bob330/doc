<!doctype html><html class=theme-light lang=ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/ru/books/handbook/security/><title>Глава 14. Безопасность | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Глава 14. Безопасность"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="ru"><meta property="og:url" content="https://docs.freebsd.org/ru/books/handbook/security/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/ru\/books\/handbook\/security\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>О нас
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>О нас</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>Фонд FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Кодекс Этики</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Получить FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Получить FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Информация о релизах</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Подготовка релизов</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Бюллетени Безопасности</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Документация
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/ru>Портал документации</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook>Руководство</a></li><li><a href=https://docs.freebsd.org/ru/books/porters-handbook>Руководство по созданию портов</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Учебник Проекта Документирования</a></li><li><a href=https://man.FreeBSD.org target=_blank>Страницы Справочника</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Презентации и публикации</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/ru/books>Книги</a></li><li><a href=https://docs.freebsd.org/ru/articles>Статьи</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Сообщество
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Сообщество</a></li><li><a href=https://docs.freebsd.org/ru/articles/contributing>Стать участником</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Форум</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Списки рассылки</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>Каналы IRC</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Трекер ошибок</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Поддержка</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=ru>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Пожертвования</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Поиск aria-label=Поиск maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/preface/>Предисловие</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/preface/#preface-audience>Целевая аудитория</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/preface/#preface-changes-from4>Четвёртое издание</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/preface/#preface-changes-from3>Третье издание</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/preface/#preface-changes-from2>Второе издание (2004)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/preface/#preface-changes>Первое издание (2001)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/preface/#preface-overview>Структура этой книги</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/preface/#preface-conv>Договоренности, используемые в этой книге</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/preface/#preface-acknowledgements>Благодарности</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/parti/>Часть I. В начале</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/introduction/>Глава 1. Введение</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/introduction/#introduction-synopsis>1.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/introduction/#nutshell>1.2. Добро пожаловать во FreeBSD!</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/introduction/#history>1.3. О Проекте FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-6aaec170775233b7c45f6cdcfb70d466 class=toggle>
<label class="icon cursor" for=chapter-6aaec170775233b7c45f6cdcfb70d466><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/install/>Глава 2. Установка FreeBSD версий 8.X и более ранних</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-synopsis>2.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-hardware>2.2. Аппаратные требования</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-pre>2.3. Перед установкой</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-start>2.4. Начало установки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#using-sysinstall>2.5. Введение в Sysinstall</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-steps>2.6. Выделение дискового пространства</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-choosing>2.7. Выбор устанавливаемых компонентов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-media>2.8. Выбор источника для установки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-final-warning>2.9. Подтверждение установки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-post>2.10. После установки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-trouble>2.11. Решение проблем</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-advanced>2.12. Расширенное руководство по установке</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/install/#install-diff-media>2.13. Подготовка собственного источника установки</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/>Глава 3. Установка FreeBSD версий 9.X и более поздних</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#bsdinstall-synopsis>3.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#bsdinstall-hardware>3.2. Аппаратные требования</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#bsdinstall-pre>3.3. Перед установкой</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#bsdinstall-start>3.4. Начало установки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#using-bsdinstall>3.5. Введение в bsdinstall</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#bsdinstall-netinstall>3.6. Установка по сети</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#bsdinstall-partitioning>3.7. Выделение дискового пространства</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#bsdinstall-final-warning>3.8. Завершение установки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#bsdinstall-post>3.9. После установки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#bsdinstall-install-trouble>3.10. Решение проблем</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bsdinstall/#using-live-cd>3.11. Использование Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/basics/>Глава 4. Основы UNIX</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#basics-synopsis>4.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#consoles>4.2. Виртуальные консоли и терминалы</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#users-synopsis>4.3. Пользователи и основы управления учетными записями</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#permissions>4.4. Права доступа</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#dirstructure>4.5. Структура каталогов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#disk-organization>4.6. Организация дисков</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#mount-unmount>4.7. Монтирование и размонтирование файловых систем</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#basics-processes>4.8. Процессы</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#basics-daemons>4.9. Даемоны, сигналы, уничтожение процессов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#shells>4.10. Интерпретатор команд</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#editors>4.11. Текстовые редакторы</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#basics-devices>4.12. Устройства и файлы устройств</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#binary-formats>4.13. Бинарные форматы</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/basics/#basics-more-information>4.14. Дополнительная информация</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/ports/>Глава 5. Установка приложений: порты и пакеты</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/ports/#ports-synopsis>5.1. Обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ports/#ports-overview>5.2. Обзор установки программного обеспечения</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ports/#ports-finding-applications>5.3. Поиск программного обеспечения</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ports/#packages-using>5.4. Использование бинарных пакетов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ports/#pkgng-intro>5.5. Использование pkgng для управления бинарными пакетами</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ports/#ports-using>5.6. Использование Коллекции Портов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ports/#ports-nextsteps>5.7. Действия после установки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ports/#ports-broken>5.8. Обработка нерабочих портов</a></li></ul></li><li><input type=checkbox id=chapter-f56428b9e0d0b77cc8e863910f96bbde class=toggle>
<label class="icon cursor" for=chapter-f56428b9e0d0b77cc8e863910f96bbde><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/wayland/>Глава 6. Wayland</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/wayland/#wayland-synopsis>6.1. Общие сведения о Wayland</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/wayland/#wayland-wayfire>6.2. Композитный менеджер Wayfire</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/wayland/#wayland-hikari>6.3. Композитный менеджер Hikari</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/wayland/#wayland-sway>6.4. Композитный менеджер Sway</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/wayland/#wayland-xwayland>6.5. Использование Xwayland</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/wayland/#wayland-remotedesktop>6.6. Организация Удалённого Рабочего Стола при помощи VNC</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/wayland/#wayland-ly>6.7. Менеджер регистраций Wayland</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/wayland/#wayland-utilities>6.8. Полезные Инструменты</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/x11/>Глава 6. X Window System</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/x11/#x11-synopsis>6.1. Обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/x11/#x-understanding>6.2. Основы X</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/x11/#x-install>6.3. Установка X11</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/x11/#x-config>6.4. Конфигурация X11</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/x11/#x-fonts>6.5. Использование шрифтов в X11</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/x11/#x-xdm>6.6. Менеджеры экранов (Display Managers) X</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/x11/#x11-wm>6.7. Графические оболочки</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/partii/>Часть II. Общие задачи</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/desktop/>Глава 7. Приложения для настольного компьютера</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/desktop/#desktop-synopsis>7.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/desktop/#desktop-browsers>7.2. Браузеры</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/desktop/#desktop-productivity>7.3. Бизнес приложения</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/desktop/#desktop-viewers>7.4. Программы просмотра документов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/desktop/#desktop-finance>7.5. Финансовые программы</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/desktop/#desktop-summary>7.6. Итоги</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/multimedia/>Глава 8. Мультимедиа</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/multimedia/#multimedia-synopsis>8.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/multimedia/#sound-setup>8.2. Настройка звуковой карты</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/multimedia/#sound-mp3>8.3. Звук MP3</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/multimedia/#video-playback>8.4. Воспроизведение видео</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/multimedia/#tvcard>8.5. Настройка ТВ тюнеров</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/multimedia/#scanners>8.6. Сканеры</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/kernelconfig/>Глава 9. Настройка ядра FreeBSD</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/kernelconfig/#kernelconfig-synopsis>9.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/kernelconfig/#kernelconfig-custom-kernel>9.2. Зачем собирать собственное ядро?</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/kernelconfig/#kernelconfig-devices>9.3. Определение аппаратного обеспечения</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/kernelconfig/#kernelconfig-modules>9.4. Драйвера, подсистемы и модули ядра</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/kernelconfig/#kernelconfig-building>9.5. Сборка и установка собственного ядра</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/kernelconfig/#kernelconfig-config>9.6. Конфигурационный файл</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/kernelconfig/#kernelconfig-trouble>9.7. Решение проблем</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/printing/>Глава 10. Печать</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/printing/#printing-synopsis>10.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/printing/#printing-intro-spooler>10.2. Введение</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/printing/#printing-intro-setup>10.3. Основная настройка</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/printing/#printing-advanced>10.4. Расширенная настройка принтера</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/printing/#printing-using>10.5. Использование принтеров</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/printing/#printing-lpd-alternatives>10.6. Альтернативы стандартному спулеру</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/printing/#printing-troubleshooting>10.7. Выявление проблем</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/linuxemu/>Глава 11. Двоичная совместимость с Linux</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/linuxemu/#linuxemu-synopsis>11.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/linuxemu/#linuxemu-lbc-install>11.2. Установка</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/linuxemu/#linuxemu-mathematica>11.3. Установка Mathematica®</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/linuxemu/#linuxemu-maple>11.4. Установка Maple™</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/linuxemu/#linuxemu-matlab>11.5. Установка MATLAB®</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/linuxemu/#linuxemu-oracle>11.6. Установка Oracle®</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/linuxemu/#sapr3>11.7. Установка SAP® R/3®</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/linuxemu/#linuxemu-advanced>11.8. Дополнительные сведения</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/partiii/>Часть III. Системное администрирование</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/config/>Глава 12. Настройка и оптимизация</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#config-synopsis>12.1. Введение</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-initial>12.2. Начальное конфигурирование</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-core-configuration>12.3. Основные настройки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-appconfig>12.4. Настройка приложений</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-starting-services>12.5. Запуск сервисов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-cron>12.6. Настройка утилиты <code>cron</code></a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-rcd>12.7. Использование rc во FreeBSD 5.X и последующих версиях</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#config-network-setup>12.8. Настройка карт сетевых интерфейсов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-virtual-hosts>12.9. Настройка виртуальных серверов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-configfiles>12.10. Файлы настройки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-sysctl>12.11. Настройка с помощью sysctl</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-disk>12.12. Оптимизация дисков</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#configtuning-kernel-limits>12.13. Изменение ограничений, накладываемых ядром</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#adding-swap-space>12.14. Увеличение объема подкачки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#acpi-overview>12.15. Управление питанием и ресурсами</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/config/#ACPI-debug>12.16. Использование и отладка FreeBSD ACPI</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/boot/>Глава 13. Процесс загрузки FreeBSD</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/boot/#boot-synopsis>13.1. Описание</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/boot/#boot-introduction>13.2. Проблема загрузки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/boot/#boot-blocks>13.3. Менеджер загрузки и этапы загрузки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/boot/#boot-kernel>13.4. Взаимодействие с ядром во время загрузки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/boot/#device-hints>13.5. Хинты устройств</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/boot/#boot-init>13.6. Init: инициализация управления процессами</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/boot/#boot-shutdown>13.7. Процесс остановки системы</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle checked>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/security/>Глава 14. Безопасность</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#security-synopsis>14.1. Краткое описание</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#security-intro>14.2. Введение</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#securing-freebsd>14.3. Защита FreeBSD</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#crypt>14.4. DES, MD5, и шифрование</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#one-time-passwords>14.5. Одноразовые пароли</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#tcpwrappers>14.6. TCP Wrappers</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#kerberosIV>14.7. KerberosIV</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#kerberos5>14.8. Kerberos5</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#openssl>14.9. OpenSSL</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#ipsec>14.10. VPN через IPsec</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#openssh>14.11. OpenSSH</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#fs-acl>14.12. Списки контроля доступа файловой системы (ACL)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#security-portaudit>14.13. Мониторинг вопросов безопасности в ПО сторонних разработчиков</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#security-advisories>14.14. Сообщения безопасности FreeBSD</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/security/#security-accounting>14.15. Учёт используемых ресурсов</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/mac/>Глава 15. Принудительный контроль доступа (MAC)</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-synopsis>15.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-inline-glossary>15.2. Ключевые термины этой главы</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-initial>15.3. Описание MAC</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-understandlabel>15.4. Метки MAC</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-modules>15.5. Настройка модулей</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-bsdextended>15.6. Модуль MAC bsdextended</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-ifoff>15.7. Модуль MAC ifoff</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-portacl>15.8. Модуль MAC portacl</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-labelingpolicies>15.9. Политики MAC, использующие метки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-partition>15.10. Модуль MAC partition</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-mls>15.11. Модуль многоуровневой безопасности MAC (MLS)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-biba>15.12. Модуль MAC Biba</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-lomac>15.13. Модуль MAC LOMAC</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-implementing>15.14. Реализация защищенной среды с MAC</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#MAC-examplehttpd>15.15. Другой пример: Использование MAC для защиты веб сервера</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mac/#mac-troubleshoot>15.16. Решение проблем с инфраструктурой MAC</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/audit/>Глава 16. Аудит событий безопасности</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/audit/#audit-synopsis>16.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/audit/#audit-inline-glossary>16.2. Ключевые понятия</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/audit/#audit-config>16.3. Настройка системы аудита</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/audit/#audit-administration>16.4. Работа с журналами аудита</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/disks/>Глава 17. Устройства хранения</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#disks-synopsis>17.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#disks-naming>17.2. Имена устройств</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#disks-adding>17.3. Добавление дисков</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#raid>17.4. RAID</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#usb-disks>17.5. USB устройства хранения</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#creating-cds>17.6. Запись и использование оптических носителей (CD)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#creating-dvds>17.7. Создание и использование оптических носителей (DVD)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#floppies>17.8. Дискеты</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#backups-tapebackups>17.9. Создание и использование архивных копий на магнитной ленте</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#backups-floppybackups>17.10. Создание резервных копий на дискетах</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#backup-strategies>17.11. Стратегии резервного копирования</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#backup-basics>17.12. Основы технологии резервного копирования</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#disks-virtual>17.13. Сетевые файловые системы, файловые системы в памяти и с отображением в файл</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#snapshots>17.14. Мгновенные копии файловых систем</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#quotas>17.15. Квотирование файловых систем</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#disks-encrypting>17.16. Шифрование дисковых разделов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/disks/#swap-encrypting>17.17. Шифрование области подкачки</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/geom/>Глава 18. GEOM: Модульная инфраструктура преобразования дисковых запросов</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/geom/#GEOM-synopsis>18.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/geom/#GEOM-intro>18.2. Введение в GEOM</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/geom/#GEOM-striping>18.3. RAID0 - Создание дисковой последовательности (Striping)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/geom/#GEOM-mirror>18.4. RAID1 - Зеркалирование (Mirroring)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/geom/#geom-ggate>18.5. Сетевые устройства GEOM Gate</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/geom/#geom-glabel>18.6. Метки дисковых устройств</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/geom/#geom-gjournal>18.7. Журналирование UFS средствами GEOM</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/filesystems/>Глава 19. Поддержка файловых систем</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/filesystems/#filesystems-synopsis>19.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/filesystems/#filesystems-zfs>19.2. Файловая система ZFS</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/l10n/>Глава 20. Локализация - использование и настройка i18n/L10n</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/l10n/#l10n-synopsis>20.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/l10n/#using-localization>20.2. Использование локализации</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/l10n/#l10n-compiling>20.3. Поиск приложений i18n</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/l10n/#lang-setup>20.4. Настройка локализации для некоторых языков</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/cutting-edge/>Глава 21. Обновление системы и смена версии FreeBSD</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/cutting-edge/#updating-upgrading-synopsis>21.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>21.2. Обновление FreeBSD</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/cutting-edge/#updating-upgrading-documentation>21.3. Обновление документации</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/cutting-edge/#current-stable>21.4. Использование ветви разработки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/cutting-edge/#synching>21.5. Синхронизация исходных текстов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/cutting-edge/#makeworld>21.6. Пересборка мира</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/cutting-edge/#small-lan>21.7. Отслеживание исходных текстов для нескольких машин</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/partiv/>Часть IV. Сетевые коммуникации</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/serialcomms/>Глава 22. Последовательные соединения</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/serialcomms/#serial-synopsis>22.1. Краткое описание</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/serialcomms/#serial>22.2. Введение</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/serialcomms/#term>22.3. Терминалы</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/serialcomms/#dialup>22.4. Входящие соединения по модему</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/serialcomms/#dialout>22.5. Исходящие соединения по модему</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/serialcomms/#serialconsole-setup>22.6. Настройка последовательной консоли</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/ppp-and-slip/>Глава 23. PPP и SLIP</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>23.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ppp-and-slip/#userppp>23.2. PPP уровня пользователя</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ppp-and-slip/#ppp>23.3. PPP уровня ядра</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ppp-and-slip/#ppp-troubleshoot>23.4. Решение проблем с соединениями PPP</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ppp-and-slip/#pppoe>23.5. Использование PPP через Ethernet (PPPoE)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ppp-and-slip/#pppoa>23.6. Использование PPP через ATM (PPPoA)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/ppp-and-slip/#slip>23.7. Использование SLIP</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/mail/>Глава 24. Электронная почта</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#mail-synopsis>24.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#mail-using>24.2. Использование электронной почты</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#sendmail>24.3. Настройка sendmail</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#mail-changingmta>24.4. Установка другой почтовой программы</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#mail-trouble>24.5. Поиск и устранение неисправностей</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#mail-advanced>24.6. Расширенное руководство</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#outgoing-only>24.7. Настройка почты только для отправки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#SMTP-dialup>24.8. Использование почты с коммутируемым соединением</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#SMTP-Auth>24.9. SMTP аутентификация</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#mail-agents>24.10. Почтовые программы пользователей</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#mail-fetchmail>24.11. Использование fetchmail</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mail/#mail-procmail>24.12. Использование procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/>Глава 25. Сетевые серверы</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-servers-synopsis>25.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-inetd>25.2. "Супер-сервер"inetd</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-nfs>25.3. Network File System (NFS)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-nis>25.4. Network Information System (NIS/YP)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-dhcp>25.5. Автоматическая настройка сети (DHCP)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-dns>25.6. Domain Name System (DNS)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-apache>25.7. Apache HTTP сервер</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-samba>25.8. Файл сервер и печать для Microsoft® Windows® клиентов (Samba)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-ftp>25.9. Протокол передачи файлов (FTP)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-ntp>25.10. Синхронизация часов через NTP</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/network-servers/#network-syslogd>25.11. * Remote Host Logging with <code>syslogd</code></a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/firewalls/>Глава 26. Межсетевые экраны</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/firewalls/#firewalls-intro>26.1. Введение</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/firewalls/#firewalls-concepts>26.2. Принципы работы межсетевых экранов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/firewalls/#firewalls-apps>26.3. Пакеты межсетевых экранов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/firewalls/#firewalls-pf>26.4. Packet Filter (PF, межсетевой экран OpenBSD) и ALTQ</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/firewalls/#firewalls-ipf>26.5. * IPFILTER (IPF)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/firewalls/#firewalls-ipfw>26.6. IPFW</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/>Глава 27. Сложные вопросы работы в сети</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#advanced-networking-synopsis>27.1. Краткий обзор</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#network-routing>27.2. Сетевые шлюзы и маршруты</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#network-wireless>27.3. Беспроводные сети</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#network-bluetooth>27.4. Bluetooth</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#network-bridging>27.5. Мосты</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#network-diskless>27.6. Работа с бездисковыми станциями</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#network-isdn>27.7. ISDN</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#network-natd>27.8. Даемон преобразования сетевых адресов (natd)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#network-plip>27.9. IP по параллельному порту (PLIP)</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#network-ipv6>27.10. IPv6</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/advanced-networking/#network-atm>27.11. Асинхронный режим передачи (ATM)</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/partv/>Часть V. Приложения</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/mirrors/>Приложение A. Получение FreeBSD</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/mirrors/#mirrors-cdrom>A.1. Наборы CD и DVD</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mirrors/#mirrors-ftp>A.2. FTP сайты</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mirrors/#ctm>A.3. Использование CTM</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mirrors/#svn>A.4. Использование Subversion</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/mirrors/#mirrors-rsync>A.5. Использование rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/bibliography/>Приложение B. Библиография</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/bibliography/#bibliography-freebsd>B.1. Книги и журналы, специализирующиеся на FreeBSD</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bibliography/#bibliography-userguides>B.2. Руководства для пользователей</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bibliography/#bibliography-adminguides>B.3. Руководства для администраторов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bibliography/#bibliography-programmers>B.4. Руководства для программистов</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bibliography/#bibliography-osinternals>B.5. Внутренности операционной системы</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bibliography/#bibliography-security>B.6. Безопасность</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bibliography/#bibliography-hardware>B.7. Оборудование</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bibliography/#bibliography-history>B.8. История UNIX®</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/bibliography/#bibliography-journals>B.9. Прочие издания</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/eresources/>Приложение C. Ресурсы в интернет</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/eresources/#eresources-mail>C.1. Списки рассылки</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/eresources/#eresources-news>C.2. Новостные группы Usenet</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/eresources/#eresources-web>C.3. Серверы World Wide Web</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook/eresources/#eresources-email>C.4. Адреса Email</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/ru/books/handbook/pgpkeys/>Приложение D. PGP ключи</a><ul><li><a href=https://docs.freebsd.org/ru/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Офицеры</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Меню книг"></i>
Меню книг</span></label></div><h1 class=title>Глава 14. Безопасность</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Этот перевод может быть устаревшим. Для того, чтобы помочь с переводом, пожалуйста, обратитесь к <a href=https://translate-dev.freebsd.org/ target=_blank>Сервер переводов FreeBSD</a>.</p></div><div class=toc-mobile><h3>Содержание</h3><nav id=TableOfContents><ul><li><a href=#security-synopsis>14.1. Краткое описание</a></li><li><a href=#security-intro>14.2. Введение</a></li><li><a href=#securing-freebsd>14.3. Защита FreeBSD</a></li><li><a href=#crypt>14.4. DES, MD5, и шифрование</a></li><li><a href=#one-time-passwords>14.5. Одноразовые пароли</a></li><li><a href=#tcpwrappers>14.6. TCP Wrappers</a></li><li><a href=#kerberosIV>14.7. KerberosIV</a></li><li><a href=#kerberos5>14.8. Kerberos5</a></li><li><a href=#openssl>14.9. OpenSSL</a></li><li><a href=#ipsec>14.10. VPN через IPsec</a></li><li><a href=#openssh>14.11. OpenSSH</a></li><li><a href=#fs-acl>14.12. Списки контроля доступа файловой системы (ACL)</a></li><li><a href=#security-portaudit>14.13. Мониторинг вопросов безопасности в ПО сторонних разработчиков</a></li><li><a href=#security-advisories>14.14. Сообщения безопасности FreeBSD</a></li><li><a href=#security-accounting>14.15. Учёт используемых ресурсов</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=security-synopsis>14.1. Краткое описание<a class=anchor href=#security-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Эта глава представляет введение в основные концепции безопасности системы, некоторые эмпирические правила и более подробно обращается к отдельным темам, касающимся FreeBSD. Большая часть затрагиваемых тем может быть применена к безопасности системы и безопасности в интернет вообще. Интернет больше не то "дружественное" место, где каждый хочет быть вам добрым соседом. Защита системы необходима для сохранения ваших данных, интеллектуальной собственности, времени и всего остального от хакеров и им подобных.</p></div><div class=paragraph><p>FreeBSD предоставляет массу утилит и механизмов для обеспечения целостности и безопасности системы и сети.</p></div><div class=paragraph><p>После прочтения этой главы вы узнаете:</p></div><div class=ulist><ul><li><p>Основные концепции безопасности системы, специфику FreeBSD.</p></li><li><p>О различных механизмах шифрования в FreeBSD, таких как DES и MD5.</p></li><li><p>Как настроить аутентификацию с использованием одноразовых паролей.</p></li><li><p>Как настроить TCP Wrappers для использования с <code>inetd</code>.</p></li><li><p>Как настроить KerberosIV в релизах FreeBSD до 5.0.</p></li><li><p>Как настроить Kerberos5 в FreeBSD.</p></li><li><p>Как настроить IPsec и создать VPN между компьютерами на FreeBSD/Windows®.</p></li><li><p>Как настроить и использовать OpenSSH, реализацию SSH в FreeBSD.</p></li><li><p>Что такое ACL и как их использовать.</p></li><li><p>Как использовать утилиту Portaudit для проверки пакетов сторонних разработчиков, установленных из Коллекции Портов.</p></li><li><p>Как работать с сообщениями безопасности FreeBSD.</p></li><li><p>Что такое Process Accounting и как активировать его во FreeBSD.</p></li></ul></div><div class=paragraph><p>Перед чтением этой главы вам потребуется:</p></div><div class=ulist><ul><li><p>Понимание основных концепций FreeBSD и интернет.</p></li></ul></div><div class=paragraph><p>В этой книге рассмотрены и другие вопросы безопасности. Например, принудительный контроль доступа (Mandatory Access Control) рассматривается в <a href=../mac/#mac>Принудительный контроль доступа (MAC)</a>, а брандмауэры в <a href=../firewalls/#firewalls>Межсетевые экраны</a>.</p></div></div></div><div class=sect1><h2 id=security-intro>14.2. Введение<a class=anchor href=#security-intro></a></h2><div class=sectionbody><div class=paragraph><p>Безопасность это первая и основная функция системного администратора. Хотя все многопользовательские системы BSD UNIX® уже снабжены некоторой защитой, работа по созданию и поддержке дополнительных механизмов безопасности, обеспечивающих защищенную работу пользователей, это одна из самых серьезных задач системного администратора. Компьютеры безопасны настолько, насколько вы сделаете их безопасными и требования безопасности всегда находятся в противоречии с удобством работы пользователей. Системы UNIX® способны одновременно работать с огромным количеством процессов и многие из этих процессов серверные - это означает, что с ними могут взаимодействовать внешние программы. Сегодня десктопы заменили мини-компьютеры и мэйнфрэймы, и поскольку компьютеры в наши дни подключены к сети интернет, безопасность важна как никогда.</p></div><div class=paragraph><p>Наилучшая реализация системы безопасности представима в виде "послойной" системы. Вообще говоря все, что нужно сделать, это создать столько слоев безопасности, сколько необходимо и затем внимательно следить за вторжениями в систему. Не переусердствуйте в настройке системы безопасности, иначе она сделает невозможной обнаружение вторжений, являющееся одним из наиболее важных аспектов механизма безопасности. Например, нет большого смысла в установке флага <code>schg</code> (<a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>) на каждый исполняемый файл системы, поскольку хотя таким способом можно временно защитить исполняемые файлы, это помешает обнаружению факта взлома системы.</p></div><div class=paragraph><p>Безопасность системы также относится к различным формам атак, имеющих своей целью вызвать крах системы, или сделать систему недоступной другим способом, но не пытающихся получить доступ к учётной записи <code>root</code> ("break root"). Угрозы безопасности могут быть поделены на несколько категорий:</p></div><div class="olist arabic"><ol class=arabic><li><p>Отказ в обслуживании (Denial of service, DoS).</p></li><li><p>Взлом пользовательских учётных записей.</p></li><li><p>Взлом учётной записи root через доступные сервисы.</p></li><li><p>Взлом учётной записи root через учётные записи пользователей.</p></li><li><p>Создание backdoor.</p></li></ol></div><div class=paragraph><p>Атака "отказ в обслуживании" отбирает у машины необходимые ресурсы. Обычно DoS атаки используют грубую силу, чтобы попытаться обрушить систему или сделать ее недоступной другим способом, превысив лимиты ее сервисов или сетевого стека. Некоторые DoS атаки пытаются использовать ошибки в сетевом стеке для обрушения системы одним пакетом. Эту проблему можно решить только исправив ядро системы. Атаки зачастую можно предотвратить правильной установкой параметров, ограничивающих нагрузку на систему в неблагоприятных условиях. С атаками, использующими грубую силу, бороться сложно. Например, атака с использованием пакетов с поддельными адресами, которую почти невозможно остановить, может быстро отключить вашу систему от интернет. Возможно, она не приведет к отказу системы, но сможет переполнить соединение с интернет.</p></div><div class=paragraph><p>Взлом учётной записи пользователя обычно встречается чаще, чем DoS атаки. Многие системные администраторы все еще используют стандартные сервисы telnetd, rlogind и ftpd на своих серверах. Эти сервисы по умолчанию не работают с зашифрованными соединениям. В результате при среднем количестве пользователей пароль одного или нескольких пользователей, входящих в систему через внешнее соединение (это обычный и наиболее удобный способ входа в систему), будет перехвачен. Внимательный системный администратор должен анализировать логи удаленного доступа на предмет подозрительных адресов пользователей даже в случае успешного входа.</p></div><div class=paragraph><p>Кто-то может предположить, что атакующий при наличии доступа к учётной записи пользователя может взломать учётную запись <code>root</code>. Однако, реальность такова, что в хорошо защищенной и поддерживаемой системе доступ к учётной записи пользователя не обязательно даст атакующему доступ к <code>root</code>. Разница между доступом к обычной учётной записи и к <code>root</code> важна, поскольку без доступа к <code>root</code> атакующий обычно не способен скрыть свои действия, и в худшем случае сможет лишь испортить файлы пользователя или вызвать крах системы. Взлом пользовательских учётных записей встречается очень часто, поскольку пользователи заботятся о безопасности так, как системные администраторы.</p></div><div class=paragraph><p>Системные администраторы должны помнить, что существует множество потенциальных способов взлома учётной записи <code>root</code>. Атакующий может узнать пароль <code>root</code>, найти ошибку в сервисе, работающем с привилегиями и взломать учётную запись <code>root</code> через сетевое соединение с этим сервисом, или узнать об ошибке в suid-root программе, позволяющей атакующему взлом <code>root</code> с помощью взломанной учётной записи пользователя. Если атакующий нашел способ взлома <code>root</code>, ему может не понадобиться установка backdoor. Многие из обнаруженных и закрытых на сегодняшний день брешей в системе, позволяющие взлом <code>root</code>, требуют от атакующего серьезной работы по заметанию следов, поэтому большинство атакующих устанавливают backdoor. Backdoor предоставляет атакующему простой способ восстановления доступа к системе с привилегиями <code>root</code>, но также дает системному администратору удобный способ обнаружения вторжения. Устранение возможности установки backdoor возможно повредит безопасности системы, поскольку это не устранит брешь, позволившую проникнуть в систему.</p></div><div class=paragraph><p>Меры безопасности всегда должны реализовываться на нескольких уровнях, которые могут быть классифицированы следующим образом:</p></div><div class="olist arabic"><ol class=arabic><li><p>Защита <code>root</code> и служебных учётных записей.</p></li><li><p>Защита работающих под <code>root</code> сервисов и suid/sgid исполняемых файлов.</p></li><li><p>Защита учётных записей пользователей.</p></li><li><p>Защита файла паролей.</p></li><li><p>Защита ядра, raw устройств и файловых систем.</p></li><li><p>Быстрое обнаружение несанкционированных изменений в системе.</p></li><li><p>Паранойя.</p></li></ol></div><div class=paragraph><p>В следующем разделе этой главы эти темы изложены более подробно.</p></div></div></div><div class=sect1><h2 id=securing-freebsd>14.3. Защита FreeBSD<a class=anchor href=#securing-freebsd></a></h2><div class=sectionbody><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Команда и протокол</div><div class=paragraph><p>В этом документе мы будет использовать выделенный текст, упоминая приложение, и <code>моноширинный</code> шрифт, упоминая определенные команды. Для протоколов используется обычный шрифт. Это типографическое отличие полезно для таких случаев, как ssh, поскольку это и команда и протокол.</p></div></td></tr></tbody></table></div><div class=paragraph><p>В последующем разделе будут рассмотрены методы защиты системы FreeBSD, упомянутые в <a href=#security-intro>предыдущем разделе</a> этой главы.</p></div><div class=sect2><h3 id=securing-root-and-staff>14.3.1. Защита учётной записи <code>root</code> и служебных учётных записей<a class=anchor href=#securing-root-and-staff></a></h3><div class=paragraph><p>Во-первых, не беспокойтесь о защите служебных учётных записей, если не защищена учётная запись <code>root</code>. В большинстве систем у учётной записи <code>root</code> есть пароль. Использование пароля <code>root</code> опасно <em>всегда</em>. Это не означает, что вы должны удалить пароль. Пароль почти всегда необходим для доступа по консоли. Но это означает, что вы должны сделать невозможным использование пароля не из консоли или может быть даже с помощью команды <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>. Например, убедитесь, что псевдо-терминалы в файле <span class=filename>/etc/ttys</span> перечислены с параметром <code>insecure</code>, что делает невозможным вход на них под <code>root</code> напрямую с помощью <code>telnet</code> или <code>rlogin</code>. При использовании других средств входа, таких как sshd, убедитесь что вход под <code>root</code> напрямую отключен и в них. Сделайте это, открыв файл <span class=filename>/etc/ssh/sshd_config</span>, и убедившись, что параметр <code>PermitRootLogin</code> установлен в <code>NO</code>. Проверьте каждый метод доступа - сервис FTP и ему подобные часто подвержены взлому. Прямой вход под <code>root</code> должен быть разрешен только с системной консоли.</p></div><div class=paragraph><p>Конечно, как системный администратор вы должны иметь доступ <code>root</code>, поэтому потребуется открыть несколько "лазеек". Но убедитесь, что для доступа к ним необходим дополнительный пароль. Одним из способов доступа к <code>root</code> является добавление соответствующих учётных записей к группе <code>wheel</code> (в файле <span class=filename>/etc/group</span>). Это позволяет использовать <code>su</code> для доступа к <code>root</code>. Вы никогда не должны давать таким учётным записям доступ к <code>wheel</code> непосредственно, помещая их в группу <code>wheel</code> в файле паролей. Служебные учётные записи должны помещаться в группу <code>staff</code>, а затем добавляться к группе <code>wheel</code> в файле <span class=filename>/etc/group</span>. Только те члены группы staff, которым действительно нужен доступ к <code>root</code>, должны быть помещены в группу <code>wheel</code>. При работе с такими методами аутентификации как Kerberos, возможно также использование файла <span class=filename>.k5login</span> в каталоге пользователя <code>root</code> для доступа к учётной записи <code>root</code> с помощью <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> без помещения кого-либо в группу <code>wheel</code>. Это решение возможно лучше, поскольку механизм <code>wheel</code> все еще позволяет взлом <code>root</code>, если злоумышленник получил копию файла паролей и смог взломать служебную учётную запись. Хотя использование механизма <code>wheel</code> лучше, чем работа через <code>root</code> напрямую, это не обязательно самый безопасный способ.</p></div><div class=paragraph><p>Непрямой способ защиты служебных учётных записей и конечно <code>root</code> это использование альтернативных методов доступа и замена зашифрованных паролей на символ “*”. Используя команду <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>, замените каждый зашифрованный пароль служебных учётных записей на этот символ для запрета входа с аутентификацией по паролю. Эта команда обновит файл <span class=filename>/etc/master.passwd</span> и базу данных пользователей/паролей.</p></div><div class=paragraph><p>Служебная учётная запись вроде этой:</p></div><div class="literalblock programlisting"><div class=content><pre>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre></div></div><div class=paragraph><p>Должна быть заменена на такую:</p></div><div class="literalblock programlisting"><div class=content><pre>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre></div></div><div class=paragraph><p>Это изменение предотвратит обычный вход, поскольку зашифрованный пароль никогда не совпадет с “*”. После этого члены группы staff должны использовать другой механизм аутентификации, например <a href="https://man.freebsd.org/cgi/man.cgi?query=kerberos&amp;sektion=1&amp;format=html">kerberos(1)</a> или <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> с парой ключей: публичным и приватным. При использовании такой системы как Kerberos, потребуется защитить сервер Kerberos и рабочую станцию. При использовании пары публичного/приватного ключей с ssh, потребуется защитить компьютер, <em>с</em> которого происходит вход (обычно это рабочая станция). Дополнительных слой защиты может быть добавлен путем защиты пары ключей при создании их с помощью <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>. Возможность заменить пароли служебных учётных записей на “*” гарантирует также, что вход может быть осуществлен только через защищенные методы доступа, которые вы настроили. Это принуждает всех членов staff использовать защищенные, шифрованные соединения для всех входов, что закрывает большую брешь, используемую многими нарушителями: перехват паролей с другого, слабо защищенного компьютера.</p></div><div class=paragraph><p>Более непрямой механизм безопасности предполагает, что вы входите с более защищенного сервера на менее защищенный. Например, если главный сервер работает со всеми сервисами, рабочая станция не должна работать ни с одним. Для поднятия уровня безопасности до приемлемого уровня, число запущенных на ней сервисов необходимо сократить до минимума, вплоть до отключения их всех, кроме того необходимо использовать защищенный паролем хранитель экрана. Конечно, при наличии физического доступа к рабочей станции атакующий может взломать любую систему безопасности. Это определенно проблема, которую вы должны учитывать, но учтите также тот факт, что большинство взломов совершаются удаленно, через сеть, людьми, которые не имеют физического доступа к вашим рабочим станциям или серверам.</p></div><div class=paragraph><p>Использование такой системы как Kerberos дает возможность заблокировать или изменить пароль в одном месте, что сразу отразиться на всех компьютерах, где существует служебная учётная запись. Если эта учётная запись будет взломана, возможность немедленно изменить пароль на всех компьютерах нельзя недооценивать. Без этой возможности изменение паролей на N машинах может стать проблемой. Вы можете также наложить ограничения на смену паролей с помощью Kerberos: не только установить значения timeout в Kerberos, но и добавить требование смены пароля пользователем после определенного периода времени (скажем, раз в месяц).</p></div></div><div class=sect2><h3 id=_защита_работающих_под_root_сервисов_и_suidsgid_исполняемых_файлов>14.3.2. Защита работающих под root сервисов и suid/sgid исполняемых файлов<a class=anchor href=#_защита_работающих_под_root_сервисов_и_suidsgid_исполняемых_файлов></a></h3><div class=paragraph><p>Предусмотрительный системный администратор запускает только те сервисы, в которых нуждается, ни больше ни меньше. Учитывайте, что сервисы сторонних разработчиков наиболее подвержены ошибкам. К примеру, работа со старыми версиями imapd или popper это все равно что раздача доступа <code>root</code> всему миру. Никогда не запускайте сервисы, которые вы не проверили достаточно внимательно. Многим сервисам не требуется работа под <code>root</code>. Например, даемоны ntalk, comsat, и finger могут быть запущены в так называемых <em>песочницах</em> (<em>sandboxes</em>). Песочница это не идеальное решение, поскольку вызывает много проблем, но она подходит под модель послойной безопасности: если кто-то сможет взломать сервис, работающий в песочнице, ему потребуется взломать еще и саму песочницу. Чем больше уровней ("слоев") потребуется пройти атакующему, тем меньше вероятность его успеха. Ошибки, позволяющие получать root доступ, находили фактически во всех сервисах, запускаемых под <code>root</code>, включая основные системные сервисы. Если вы обслуживаете машину, на которую входят только через sshd и никогда не входят через telnetd, rshd или rlogind, отключите эти сервисы!</p></div><div class=paragraph><p>В FreeBSD сервисы ntalkd, comsat и finger теперь по умолчанию работают в "песочнице". Другая программа, которая может быть кандидатом на запуск в "песочнице" это <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. <span class=filename>/etc/defaults/rc.conf</span> включает необходимые для запуска named в "песочнице" аргументы в закомментированой форме. В зависимости от того, устанавливаете ли вы новую систему, или обновляете старую, учётные записи пользователей, используемые этими "песочницами" могут не быть созданы. Предусмотрительный системный администратор должен узнать о "песочницах" для сервисов и установить их если есть возможность.</p></div><div class=paragraph><p>Есть множество других сервисов, которые обычно не работают в "песочницах": sendmail, popper, imapd, ftpd, и другие. Некоторым из этих сервисов есть альтернативы, но их установка может потребовать больше работы, чем вы готовы выполнить (фактор удобства). Вы можете запустить эти сервисы под <code>root</code> и положиться на другие механизмы обнаружения вторжений, которые могут пройти через них.</p></div><div class=paragraph><p>Другая большая потенциальная <code>root</code> брешь в системе это suid-root и sgid исполняемые файлы. Большинство этих исполняемых файлов, таких как rlogin, установлены в <span class=filename>/bin</span>, <span class=filename>/sbin</span>, <span class=filename>/usr/bin</span>, или <span class=filename>/usr/sbin</span>. Хотя ничто не может быть безопасно на 100%, находящиеся по умолчанию в системе suid и sgid исполняемые файлы могут быть признаны достаточно безопасными. Но <code>root</code> бреши все еще обнаруживаются в этих исполняемых файлах. <code>root</code> брешь, обнаруженная в <code>Xlib</code> в 1998 делала xterm (который обычно suid) подверженным взлому. Лучше сразу принять меры предосторожности, чем сожалеть потом. Предусмотрительный системный администратор ограничит права запуска suid исполняемых файлов, которые должны запускаться пользователями группы staff, только этой группой, а также запретит доступ (<code>chmod 000</code>) к тем исполняемым файлам suid, которые никем не используются. Серверу без монитора обычно не требуется исполняемый файл xterm. Исполняемые sgid исполняемые файлы могут быть почти так же опасны. Если нарушитель сможет взломать sgid-kmem исполняемый файл, он возможно сможет прочесть <span class=filename>/dev/kmem</span> и таким образом получить файл зашифрованных паролей, что потенциально делает возможным взлом любой защищённой паролем учётной записи. Аналогично нарушитель, проникший в группу <code>kmem</code>, может отслеживать последовательности клавиш, отправляемые через псевдо-терминалы, включая те, что используют защищённые соединения. Нарушитель, вошедший в группу <code>tty</code> может сделать вывод почти на любой пользовательский терминал. Если пользователь работает с терминальной программой или эмулятором с возможностью эмуляции клавиатуры, взломщик может потенциально сгенерировать поток данных, который заставит терминал пользователя ввести команду, и она будет запущена с правами этого пользователя.</p></div></div><div class=sect2><h3 id=secure-users>14.3.3. Защита учётных записей пользователей<a class=anchor href=#secure-users></a></h3><div class=paragraph><p>Учетные записи пользователей обычно сложнее всего защитить. Вы можете ввести драконовские ограничения доступа к служебным учётным записям, заменив их пароли на символ “*”, но возможно не сможете сделать то же с обычными учётными записями пользователей. Если есть такая возможность, вы возможно сможете защитить учётные записи пользователей соответствующим образом. Если нет, просто более бдительно отслеживайте эти учётные записи. Использование ssh и Kerberos для учётных записей пользователей более проблематично, поскольку требует дополнительной административной работы и технической поддержки, но все же это решение лучше, чем файл с шифрованными паролями.</p></div></div><div class=sect2><h3 id=_защита_файла_паролей>14.3.4. Защита файла паролей<a class=anchor href=#_защита_файла_паролей></a></h3><div class=paragraph><p>Единственный абсолютно надежный способ это замена на <code>*</code> максимально возможного количества паролей и использование ssh или Kerberos для доступа к таким учётным записям. Хотя файл с шифрованными паролями (<span class=filename>/etc/spwd.db</span>) доступен для чтения только <code>root</code>, возможно, что нарушитель сможет получить доступ на чтение к этому файлу, даже если не получит права <code>root</code> на запись.</p></div><div class=paragraph><p>Ваши скрипты безопасности должны всегда проверять и составлять отчет об изменениях файла паролей (обратитесь к разделу <a href=#security-integrity>Проверка целостности файлов</a> ниже по тексту).</p></div></div><div class=sect2><h3 id=_защита_ядра_raw_устройств_и_файловых_систем>14.3.5. Защита ядра, raw устройств и файловых систем<a class=anchor href=#_защита_ядра_raw_устройств_и_файловых_систем></a></h3><div class=paragraph><p>Если атакующий взломает <code>root</code>, он сможет сделать практически все, но есть способы усложнить его задачу. Например, в большинстве современных ядер встроено устройство перехвата пакетов. В FreeBSD оно называется <span class=filename>bpf</span>. Нарушитель обычно пытается запустить перехват пакетов на взломанной машине. Вы не должны предоставлять ему такой возможности, на большинстве систем устройство <span class=filename>bpf</span> не должно быть встроено в ядро.</p></div><div class=paragraph><p>Но даже если вы выключите устройство <span class=filename>bpf</span>, все еще остаются проблемы, связанные с устройствами <span class=filename>/dev/mem</span> и <span class=filename>/dev/kmem</span>. Нарушитель все еще может писать на дисковые raw устройства. Есть также другая возможность ядра, загрузка модулей, <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Активный нарушитель может использовать KLD модуль для установки собственного устройства <span class=filename>bpf</span> или другого перехватывающего устройства на работающее ядро. Для решения этих проблем запускайте ядро с большим уровнем безопасности, как минимум 1. Уровень безопасности может быть установлен с помощью <code>sysctl</code> через переменную <code>kern.securelevel</code>. После установки уровня безопасности в 1 доступ на запись в raw устройства будет запрещена и полностью заработают специальные флаги <code>chflags</code>, такие как <code>schg</code>. Убедитесь также, что флаг <code>schg</code> установлен на критически важных загрузочных исполняемых файлах, каталогах и файлах скриптов - на всем, что запускается до установке уровня безопасности. Это требует большого объема работы, и обновление системы на более высоком уровне безопасности может стать гораздо сложнее. Вы можете пойти на компромисс и запускать систему на высоком уровне безопасности, но не устанавливать флаг <code>schg</code> для каждого существующего системного файла и каталога. Другая возможность состоит в монтировании <span class=filename>/</span> и <span class=filename>/usr</span> только для чтения. Необходимо заметить, что такие правила слишком жесткие и могут помешать обнаружению вторжения.</p></div></div><div class=sect2><h3 id=security-integrity>14.3.6. Проверка целостности файлов: исполняемые, конфигурационные файлы и т.д.<a class=anchor href=#security-integrity></a></h3><div class=paragraph><p>Вы можете защищать только ядро, файлы настройки и управления системой только до тех пор, пока эта защита не вступит в конфликт с удобством работы в системе. Например, использование <code>chflags</code> для установки бита <code>schg</code> на большинство файлов в <span class=filename>/</span> вероятно может только навредить, поскольку хотя и может защитить файлы, препятствует обнаружению. Последний слой системы безопасности, возможно, наиболее важный - обнаружение. Остальные меры безопасности практически бесполезны (или, что еще хуже, могут дать вам ложное ощущение безопасности) если вы не обнаружите потенциальное вторжение. Половина функций системы безопасности направлена на замедление атакующего, а не на его остановку, для того, чтобы дать системе обнаружения возможность поймать нарушителя на месте преступления.</p></div><div class=paragraph><p>Лучший способ обнаружения вторжения - отслеживание измененных, отсутствующих, или неожиданно появившихся файлов. Для наблюдения за измененными файлами лучше всего использовать другую (зачастую централизованную) систему с ограниченным доступом. Добавление написанных вами скриптов к этой дополнительно защищенной системе с ограниченным доступом делает ее практически невидимой для потенциальных взломщиков, и это важно. В целях достижения максимального эффекта вам может потребоваться предоставить этой системе доступ к другим машинам в сети, обычно с помощью NFS экспорта только для чтения или сгенерировав пары ключей ssh для доступа к другим машинам по ssh. Помимо большого объема сетевого трафика, NFS более скрытый метод - он позволяет контролировать файловые системы на каждом клиентском компьютере практически незаметно. Если ваш сервер с ограниченным доступом подключен к клиентским компьютерам через коммутатор, NFS метод это зачастую лучший выбор. При соединении через концентратор, или через несколько маршрутизаторов, NFS метод может стать слишком небезопасным и использование ssh может стать лучшим выбором даже несмотря на то, что ssh оставляет следы своей работы.</p></div><div class=paragraph><p>Как только у вас появился сервер с ограниченным доступом, и как минимум доступ на чтение в клиентских системах, потребуется написать скрипты для выполнения мониторинга. При наличии доступа по NFS вы можете написать скрипты с помощью простых системных утилит, таких как <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a> и <a href="https://man.freebsd.org/cgi/man.cgi?query=md5&amp;sektion=1&amp;format=html">md5(1)</a>. Лучше всего подсчитывать md5 файлов на клиентском компьютере как минимум один раз в день, а файлы, контролирующие запуск из <span class=filename>/etc</span> и <span class=filename>/usr/local/etc</span> даже более часто. При обнаружении расхождений в md5, контролирующий компьютер должен просигналить системному администратору проверить изменившиеся файлы. Хороший скрипт безопасности проверит также наличие несоответствующих исполняемых suid файлов и новых или измененных файлов в системных разделах <span class=filename>/</span> и <span class=filename>/usr</span>.</p></div><div class=paragraph><p>При использовании ssh вместо NFS, написать скрипты безопасности гораздо сложнее. Вам обязательно потребуется скопировать (<code>scp</code>) скрипты на клиентский компьютер, сделать из невидимыми, и для безопасности потребуется также скопировать исполняемые файлы (такие как find), которые будут использоваться скриптом. Приложение ssh на клиентском компьютере может быть уже взломано. В конечном итоге, без ssh не обойтись при работе через небезопасные соединения, но его гораздо сложнее использовать.</p></div><div class=paragraph><p>Хороший скрипт безопасности проверит также изменения в файлах настройки, работающих при подключении пользователей и служебных учётных записей: <span class=filename>.rhosts</span>, <span class=filename>.shosts</span>, <span class=filename>.ssh/authorized_keys</span> и так далее…​ файлы, которые могли не попасть в область проверки <code>MD5</code>.</p></div><div class=paragraph><p>Если для пользователей выделен большой объем дискового пространства, проверка каждого файла на таких разделах может занять слишком много времени. В таком случае установка флагов монтирования для запрета suid исполняемых файлов и устройств на таких разделах это хорошая идея. Примените параметры <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> <code>nodev</code> и <code>nosuid</code>. Проверяйте эти разделы в любом случае, хотя бы раз в неделю, поскольку необходимо обнаруживать попытки взлома, независимо от того, эффективны они или нет.</p></div><div class=paragraph><p>Учет процессов (<a href="https://man.freebsd.org/cgi/man.cgi?query=accton&amp;sektion=8&amp;format=html">accton(8)</a>) это относительно несложная возможность операционной системы, которая может помочь как механизм обнаружения состоявшихся вторжений. Она особенно полезна для обнаружения пути проникновения нарушителя в систему, если файл не был затронут проникновением.</p></div><div class=paragraph><p>Наконец, скрипты безопасности должны обработать лог файлы, которые необходимо создавать настолько защищенным способом, насколько это возможно - подключение syslog удаленно может быть очень полезным. Злоумышленник попытается уничтожить следы взлома, и лог файлы критически важны для системного администратора, пытающегося отследить время и метод первого проникновения. Один из надежных способов получения лог файлов является подключение системной консоли к последовательному порту и постоянный сбор информации через защищенную машину, отслеживающую консоли.</p></div></div><div class=sect2><h3 id=_паранойя>14.3.7. Паранойя<a class=anchor href=#_паранойя></a></h3><div class=paragraph><p>Немного паранойи никогда не повредит. Как правило, системный администратор может добавлять элементы безопасности в любом количестве, пока это не влияет на удобство, а также некоторое количество элементов безопасности, <em>влияющих</em> на удобство. Что даже более важно, системный администратор должен немного изменить их - если вы используете рекомендации, например те, что даны в этом документе, они становятся известны атакующему, который также имеет доступ к этому документу.</p></div></div><div class=sect2><h3 id=_атаки_dos>14.3.8. Атаки DoS<a class=anchor href=#_атаки_dos></a></h3><div class=paragraph><p>Этот раздел охватывает DoS атаки. DoS атаки это обычно пакетные атаки. Хотя против современной атаки с подделкой пакетов, которая перегружает сеть, мало что можно сделать, вы можете ограничить повреждения, убедившись, что атака не может обрушить ваши сервера.</p></div><div class="olist arabic"><ol class=arabic><li><p>Ограничение количества порождаемых процессов.</p></li><li><p>Уменьшение последствий springboard атак (ICMP ответ, широковещательный ping и т.д.).</p></li><li><p>Кэш маршрутизации ядра.</p></li></ol></div><div class=paragraph><p>Обычная DoS атака против порождающего процессы сервера пытается исчерпать ресурсы сервера по процессам, файловым дескрипторам и памяти до тех пор, пока машина не "повиснет". У inetd (обратитесь к <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>) есть несколько параметров, позволяющих ограничить такие атаки. Необходимо учесть, что хотя можно предотвратить падение системы, в общем случае невозможно предотвратить прекращение работы сервиса. Внимательно прочтите страницу справочника и обратите особое внимание на параметры <code>-c</code>, <code>-C</code>, и <code>-R</code>. Учтите, что параметр <code>-C</code> не работает в случае атак с использованием поддельных IP пакетов, поэтому как правило необходимо использование комбинации параметров. Некоторые standalone сервисы используют собственные параметры, ограничивающие порождение процессов.</p></div><div class=paragraph><p>У Sendmail есть собственный параметр <code>-OMaxDaemonChildren</code>, которая работает гораздо лучше, чем параметр sendmail, ограничивающий нагрузку. Вам необходимо задать параметр запуска sendmail`MaxDaemonChildren` достаточно большим, чтобы обслуживать ожидаемую нагрузку, но так, чтобы компьютер мог обслужить такое количество приложений sendmail без падения системы. Хорошей мерой является запуск sendmail в режиме очереди (<code>-ODeliveryMode=queued</code>) и запуск даемона (<code>sendmail -bd</code>) отдельно от очереди (<code>sendmail -q15m</code>). Если вы все же хотите организовать доставку в режиме реального времени, запускайте очередь с меньшим интервалом <code>-q1m</code>, но убедитесь в правильной установке параметра sendmail <code>MaxDaemonChildren</code> для предотвращения ошибок.</p></div><div class=paragraph><p>Syslogd может быть атакован непосредственно, настоятельно рекомендуется использовать параметр <code>-s</code> если это возможно и параметр <code>-a</code> в остальных случаях.</p></div><div class=paragraph><p>Вы также должны быть очень осторожны с сервисами, совершающими обратное подключение, например, с TCP Wrapper и его обратным identd-запросом, который может быть атакован напрямую. По этой причине возможность TCP Wrapper генерировать обратный ident обычно не следует использовать.</p></div><div class=paragraph><p>Правильным будет запрет доступа к внутренним сервисам из внешней сети путем соответствующей настройки брандмауэра на внешнем маршрутизаторе. Идея в том, чтобы предотвратить перегрузку сервисов атаками из внешней сети, а кроме того защитить <code>root</code> от взлома через сеть. Всегда настраивайте исключающий брандмауэр, т.е. "закрыть все <em>кроме</em> портов A, B, C, D, и M-Z". Этим способом вы можете закрыть все порты нижнего диапазона, кроме явно указанных, таких как named (если вы поддерживаете интернет-зону), ntalkd, sendmail, и других сервисов, доступных из интернет. Если вы попробуете настроить брандмауэр другим способом - включающий, или разрешающий брандмауэр, есть большой шанс забыть "закрыть" пару сервисов, или добавить новый внутрисетевой сервис и забыть обновить брандмауэр. Вы можете открыть диапазон портов с большими номерами для обычных приложений без угрозы портам нижнего диапазона. Учтите также, что FreeBSD позволяет вам контролировать диапазоны портов, используемые для динамической привязки через различные переменные <code>sysctl``net.inet.ip.portrange</code> (<code>sysctl -a | fgrep portrange</code>), что позволяет упростить настройку брандмауэра. Например, вы можете использовать обычный диапазон портов со значениями от 4000 до 5000, и диапазон портов с большими номерами от 49152 до 65535, а затем заблокировать все до 4000 порта (конечно оставив доступ из интернет к определенным портам.</p></div><div class=paragraph><p>Другой распространенный тип DoS атак называется springboard - сервер атакуется таким образом, что генерируемые ответы перегружают его, локальную сеть или какие-то другие компьютеры. Наиболее распространенная атака этого вида это <em>широковещательная ICMP ping атака</em>. Атакующий подделывает пакеты ping, подставляя IP адрес машины, которую он намеревается атаковать, и отправляет их на широковещательный адрес вашей локальной сети. Если ваш внешний маршрутизатор не настроен на отбрасывание пакетов ping на широковещательные адреса, ваша сеть начинает генерировать соответствующие ответы на поддельный адрес, что приводит к перегрузке хоста-жертвы, особенно если атакующий использует этот же трюк с множеством широковещательных адресов в множестве сетей одновременно. Были зарегистрированы широковещательные атаки свыше ста двадцати мегабит. Другая распространенная springboard атака направлена на ICMP систему сообщения об ошибках. Конструируя пакеты, вызывающие ICMP сообщения об ошибках, атакующий может нагрузить входящее соединение сервера и вынудить сервер нагрузить исходящее соединение ICMP ответами. Этот тип атаки может также обрушить сервер, когда тот исчерпает mbuf, обычно если сервер не может ограничить число ответов ICMP, когда они генерируются слишком быстро. Используйте переменную sysctl`net.inet.icmp.icmplim`. Последний основной класс springboard атак относится к определенным внутренним сервисам inetd, таким как сервис udp echo. Атакующий просто подделывает адрес источника и адрес назначения UDP пакетов, устанавливая в их качестве соответственно echo порт сервера A и B, оба этих сервера принадлежат вашей локальной сети. Эти два сервера начинают перебрасываться этим пакетом друг с другом. Атакующий может вызвать перегрузку обеих серверов и их сетей, просто отправив несколько пакетов таким способом. Аналогичные проблемы существуют с портом chargen. Компетентный системный администратор должен отключить эти тестовые сервисы inetd.</p></div><div class=paragraph><p>Атаки с поддельными пакетами могут также использоваться для переполнения кэша маршрутизации ядра. Обратитесь к параметрам <code>sysctl``net.inet.ip.rtexpire</code>, <code>rtminexpire</code>, и <code>rtmaxcache</code>. Атака с поддельными пакетами, использующая произвольный IP адрес источника, заставит ядро сгенерировать временный кэшированный маршрут в таблице маршрутизации, который можно увидеть с помощью <code>netstat -rna | fgrep W3</code>. Эти маршруты обычно удаляются через 1600 секунд или около того. Если ядро определит, что кэшированная маршрутная таблица стала слишком большой, оно динамически уменьшит <code>rtexpire</code>, но никогда не станет делать его меньше чем <code>rtminexpire</code>. С этим связаны две проблемы:</p></div><div class="olist arabic"><ol class=arabic><li><p>Ядро не отреагирует достаточно быстро, когда легко нагруженный сервер будет внезапно атакован.</p></li><li><p>Значение <code>rtminexpire</code> недостаточно мало для поддержки работоспособности в условиях продолжительной атаки.</p></li></ol></div><div class=paragraph><p>Если ваши серверы подключены к интернет через линию T3 или более быструю, предусмотрительно будет изменить оба значения <code>rtexpire</code> и <code>rtminexpire</code> с помощью <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Никогда не устанавливайте ни один из этих параметров в нуль (если только вы не хотите обрушить систему). Установка обеих параметров в значение 2 секунды должна предотвратить таблицу маршрутизации от атак.</p></div></div><div class=sect2><h3 id=_проблемы_связанные_с_доступом_к_kerberos_и_ssh>14.3.9. Проблемы, связанные с доступом к Kerberos и SSH<a class=anchor href=#_проблемы_связанные_с_доступом_к_kerberos_и_ssh></a></h3><div class=paragraph><p>При использовании Kerberos и ssh необходимо учесть несколько возможных проблем. Kerberos V это отличный протокол аутентификации, но в адаптированных к нему приложениях telnet и rlogin есть несколько ошибок, которые могут сделать их непригодными к работе с бинарными потоками. К тому же, по умолчанию Kerberos не шифрует сессию, если вы не используете параметр <code>-x</code>. ssh шифрует все по умолчанию.</p></div><div class=paragraph><p>ssh работает очень хорошо во всех ситуациях, но пересылает ключи по умолчанию. Это означает, что если вы работаете с защищенной рабочей станции, ключи на которой дают доступ к остальной сети, и заходите по ssh на незащищенный компьютер, эти ключи могут быть использованы для взлома. Атакующему не удастся получить сами ключи, но поскольку ssh открывает порт во время входа в систему, то если на незащищенной машине взломан <code>root</code>, эти ключи могут быть использованы для доступа к другим компьютерам, на которых они действуют.</p></div><div class=paragraph><p>Мы рекомендуем использовать ssh в комбинации с Kerberos для служебных учётных записей если это возможно. ssh может быть собран с поддержкой Kerberos. Это уменьшает зависимость от потенциально подверженных взлому ssh ключей, и в то же время защищает пароли через Kerberos. Ключи ssh должны использоваться только для работы скриптов на защищенных компьютерах (там, где Kerberos использовать не получится). Мы также рекомендуем или выключить передачу ключей в настройках ssh, или использовать параметр <code>from=IP/DOMAIN</code>, поддерживаемый ssh в файле <span class=filename>authorized_keys</span>, который позволяет использовать ключи только с определенных компьютеров.</p></div></div></div></div><div class=sect1><h2 id=crypt>14.4. DES, MD5, и шифрование<a class=anchor href=#crypt></a></h2><div class=sectionbody><div class=paragraph><p>У каждого пользователя UNIX® системы есть пароль, связанный с его учётной записью. Очевидно, что эти пароли должны быть известны только пользователю и соответствующей операционной системе. Для защиты паролей они шифруются способом, известным как "односторонний хэш", то есть их можно легко зашифровать, но нельзя расшифровать. Другими словами, то, что мы сказали чуть раньше было очевидно, но не совсем верно: операционной системе <em>сам пароль</em> неизвестен. Ей известен только пароль в <em>зашифрованной</em> форме. Единственный способ получить "обычный" пароль это простой перебор всех возможных паролей.</p></div><div class=paragraph><p>К сожалению, единственный способ шифрования пароля при появлении UNIX® был основан на DES, Data Encryption Standard. Это не было проблемой для пользователей, живущих в США, но поскольку исходный код DES нельзя было экспортировать из США, FreeBSD нашла способ одновременно не нарушать законов США и сохранить совместимость со всеми другими вариантами UNIX®, где все еще использовался DES.</p></div><div class=paragraph><p>Решение было в разделении библиотек шифрования, чтобы пользователи в США могли устанавливать и использовать библиотеки DES, а у остальных пользователей был метод шифрования, разрешенный к экспорту. Так FreeBSD пришла к использованию MD5 в качестве метода шифрования по умолчанию. MD5 считается более безопасным, чем DES, поэтому установка DES рекомендуется в основном из соображений совместимости.</p></div><div class=sect2><h3 id=_определения_механизма_шифрования>14.4.1. Определения механизма шифрования<a class=anchor href=#_определения_механизма_шифрования></a></h3><div class=paragraph><p>На данный момент библиотека поддерживает хэши DES, MD5 и Blowfish. По умолчанию FreeBSD использует для шифрования паролей MD5.</p></div><div class=paragraph><p>Довольно легко определить какой метод шифрования используется в FreeBSD. Один из способов это проверка файла <span class=filename>/etc/master.passwd</span>. Пароли, зашифрованные в хэш MD5 длиннее, чем те, что зашифрованы с помощью DES и начинаются с символов <code>$1$</code>. Пароли, начинающиеся с символов <code>$2a$</code> зашифрованы с помощью Blowfish. Пароли, зашифрованные DES не содержат каких-то определенных идентифицирующих символов, но они короче, чем пароли MD5 и закодированы в 64-символьном алфавите, не содержащем символа <code>$</code>, поэтому относительно короткая строка, не начинающаяся с этого символа это скорее всего DES пароль.</p></div><div class=paragraph><p>Формат паролей, используемых для новых паролей, определяется параметром <code>passwd_format</code> в <span class=filename>/etc/login.conf</span>, которое может принимать значения <code>des</code>, <code>md5</code> или <code>blf</code>. Обратитесь к странице справочника <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> за дополнительной информацией о параметрах login.</p></div></div></div></div><div class=sect1><h2 id=one-time-passwords>14.5. Одноразовые пароли<a class=anchor href=#one-time-passwords></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD использует для одноразовых паролей OPIE (One-time Passwords In Everything). OPIE по умолчанию использует MD5.</p></div><div class=paragraph><p>Есть три различных вида паролей, о которых мы поговорим ниже. Первый вид это ваш обычный пароль UNIX® или пароль Kerberos; мы будем называть его "пароль UNIX®". Второй вид это одноразовый пароль, сгенерированный программой OPIE <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> и принимаемый командой <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> и в приглашении login; мы будем называть их "одноразовыми паролями". Последний вид паролей это защищенные пароли, которые вы передаете программам <code>opiekey</code> (и иногда <code>opiepasswd</code>), и которые эти программы используют для создания одноразовых паролей; мы будем называть его "защищенными паролями" или просто "паролями".</p></div><div class=paragraph><p>Защищенный пароль не имеет никакого отношения к вашему паролю UNIX®; они могут быть одинаковыми, но это не рекомендуется. Защищенные пароли OPIE не ограничены 8-ю символами, как старые UNIX® пароли, они могут быть настолько длинными, насколько вы захотите. Очень часто используются пароли длиной в шесть или семь символов. По большей части система OPIE работает полностью независимо от системы паролей UNIX®.</p></div><div class=paragraph><p>Помимо паролей, есть два других вида данных, важных для OPIE. Первый, известный как "seed" или "ключ", состоит из двух букв и пяти цифр. Другой, называемый "счетчиком цикла", это номер от 1 до 100. OPIE создает одноразовый пароль, соединяя ключ и защищенный пароль, а затем применяя MD4 столько раз, сколько указано счетчиком цикла и выдает результат в виде шести коротких слов на английском. Эти шесть слов на английском и есть ваш одноразовый пароль. Система аутентификации (как правило PAM) хранит последний использованный одноразовый пароль, и пользователь аутентифицируется если хэш вводимого пользователем пароля совпадает с предыдущим паролем. Поскольку используется односторонний хэш, невозможно сгенерировать следующий одноразовый пароль если получен предыдущий; счетчик цикла уменьшается после каждого успешного входа для поддержки синхронизации пользователя с программой login. Когда счетчик цикла уменьшается до 1, набор OPIE должен быть переинициализирован.</p></div><div class=paragraph><p>В каждой из обсуждаемых ниже систем задействованы три программы. Программа <code>opiekey</code> получает счетчик цикла, ключ и защищенный пароль и создает одноразовый пароль или последовательный список одноразовых паролей. Программа <code>opiepasswd</code> используется для инициализации OPIE соответственно, и для смены паролей, счетчиков цикла, или ключей; она принимает защищенный пароль или счетчик цикла, ключ и одноразовый пароль. Программа <code>opieinfo</code> проверяет соответствующий файл (<span class=filename>/etc/opiekeys</span>) и печатает текущий счетчик цикла и ключ вызывающего пользователя.</p></div><div class=paragraph><p>Мы рассмотрим четыре вида операций. Первая это использование <code>opiepasswd</code> через защищенное соединение для первоначальной настройки системы одноразовых паролей, или для изменения пароля или ключа. Вторая операция это использование в тех же целях <code>opiepasswd</code> через незащищенное соединение, в сочетании с <code>opiekey</code> через защищенное соединение. Третья это использование <code>opiekey</code> для входа через незащищенное соединение. Четвертая это использование <code>opiekey</code> для генерации набора ключей, которые могут быть записаны или распечатаны для соединения из места, где защищенное соединение недоступно.</p></div><div class=sect2><h3 id=_защищенная_установка_соединения>14.5.1. Защищенная установка соединения<a class=anchor href=#_защищенная_установка_соединения></a></h3><div class=paragraph><p>Для первоначальной настройки OPIE используется команда <code>opiepasswd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd <span class=nt>-c</span>
<span class=o>[</span>grimreaper] ~ <span class=nv>$ </span>opiepasswd <span class=nt>-f</span> <span class=nt>-c</span>
Adding unfurl:
Only use this method from the console<span class=p>;</span> NEVER from remote. If you are using
telnet, xterm, or a dial-in, <span class=nb>type</span> ^C now or <span class=nb>exit </span>with no password.
Then run opiepasswd without the <span class=nt>-c</span> parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</code></pre></div></div><div class=paragraph><p>В приглашениях <code>Enter new secret pass phrase:</code> или <code>Enter secret password:</code>, введите пароль или фразу. Запомните, это не тот пароль, с которым вы будете входить, он используется для генерации одноразовых паролей. Строка "ID" содержит информацию для вашего конкретного случая: имя пользователя, счетчик цикла и ключ. При входе система запомнит эти параметры и отправит их вам, поэтому их не надо запоминать. В последней строке находится одноразовый пароль, соответствующий этим параметрам и секретному паролю; если вы войдете в систему сразу, используйте этот одноразовый пароль.</p></div></div><div class=sect2><h3 id=_незащищенная_установка_соединения>14.5.2. Незащищенная установка соединения<a class=anchor href=#_незащищенная_установка_соединения></a></h3><div class=paragraph><p>Для инициализации или изменения защищенного пароля через незащищенное соединение, вам потребуется существующее защищенное соединение куда-то, где вы сможете запустить <code>opiekey</code>; это может быть shell на компьютере, которому вы доверяете. Вам потребуется также установить значение счетчика цикла (100 возможно подойдет), и задать ключ или использовать сгенерированный. Через незащищенное соединение (к компьютеру, на котором производится настройка), используйте команду <code>opiepasswd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</code></pre></div></div><div class=paragraph><p>Чтобы принять ключ по умолчанию нажмите <kbd>Enter</kbd>. Затем, перед вводом пароля доступа введите те же параметры в вашем защищенном соединении или средстве доступа OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</span></code></pre></div></div><div class=paragraph><p>Теперь переключитесь на незащищенное соединение и скопируйте одноразовый пароль, сгенерированный соответствующей программой.</p></div></div><div class=sect2><h3 id=_создание_одного_одноразового_пароля>14.5.3. Создание одного одноразового пароля<a class=anchor href=#_создание_одного_одноразового_пароля></a></h3><div class=paragraph><p>Как только вы настроите OPIE, во время входа появится приглашение вроде этого:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>example.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;username&gt;
otp-md5 498 gr4269 ext
Password:</code></pre></div></div><div class=paragraph><p>Кроме того, у OPIE есть полезная особенность (не показанная здесь): если вы нажмете <kbd>Enter</kbd> в приглашении на ввод пароля, включится эхо, и вы сможете увидеть то, что вводите. Это может быть очень полезно, если вы пытаетесь ввести пароль вручную, например с распечатки.</p></div><div class=paragraph><p>В этот момент вам потребуется сгенерировать одноразовый пароль, чтобы ввести его в приглашение. Это должно быть выполнено на защищенной системе, в которой вы можете запустить <code>opiekey</code> (есть версии для DOS, Windows® и Mac OS®). Им требуются значения счетчика цикла и ключ в качестве параметров командной строки. Вы можете скопировать и вставить их прямо из приглашения login компьютера, на который входите.</p></div><div class=paragraph><p>В защищенной системе:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</span></code></pre></div></div><div class=paragraph><p>Теперь, когда у вас есть одноразовый пароль, можете продолжить вход в систему.</p></div></div><div class=sect2><h3 id=_создание_нескольких_одноразовых_паролей>14.5.4. Создание нескольких одноразовых паролей<a class=anchor href=#_создание_нескольких_одноразовых_паролей></a></h3><div class=paragraph><p>Иногда вы отправляетесь туда, где нет доступа к защищенному компьютеру или защищенному соединению. В этом случае, можно использовать команду <code>opiekey</code> для создания нескольких одноразовых паролей, которые вы сможете распечатать и забрать с собой. Например:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey <span class=nt>-n</span> 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: &lt;secret password&gt;
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</span></code></pre></div></div><div class=paragraph><p>Параметр <code>-n 5</code> запрашивает пять паролей, <code>30</code> указывает значение последнего счетчика цикла. Обратите внимание, что пароли печатаются в <em>обратном</em> по сравнению с обычным использованием порядке. Если вы действительно параноик, перепишите результат вручную; иначе скопируйте и передайте его <code>lpr</code>. Обратите внимание, что каждая линия содержит как счетчик цикла, так и одноразовый пароль; вам может показаться удобным отрывать пароль после использования.</p></div></div><div class=sect2><h3 id=_ограничение_использования_unix_паролей>14.5.5. Ограничение использования UNIX® паролей<a class=anchor href=#_ограничение_использования_unix_паролей></a></h3><div class=paragraph><p>OPIE может ограничивать использование паролей UNIX® на основе IP адреса. Соответствующий файл называется <span class=filename>/etc/opieaccess</span>, он существует по умолчанию. Обратитесь к <a href="https://man.freebsd.org/cgi/man.cgi?query=opieaccess&amp;sektion=5&amp;format=html">opieaccess(5)</a> за более подробной информацией об этом файле и о предосторожностях, которые вы должны предпринять при использовании этого файла.</p></div><div class=paragraph><p>Вот пример файла <span class=filename>opieaccess</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>permit 192.168.0.0 255.255.0.0</pre></div></div><div class=paragraph><p>Эта строка позволяет пользователям, чей IP адрес (который подвержен подделке) соответствует указанному значению и маске, входить с паролем UNIX®.</p></div><div class=paragraph><p>Если ни одно из правил в <span class=filename>opieaccess</span> не сработало, поведением по умолчанию является запрет всех не-OPIE входов.</p></div></div></div></div><div class=sect1><h2 id=tcpwrappers>14.6. TCP Wrappers<a class=anchor href=#tcpwrappers></a></h2><div class=sectionbody><div class=paragraph><p>Каждый, кто знаком с <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>, возможно когда-то слышал о TCP Wrappers. Но немногие полностью понимают их полезность в сетевой среде: большинство используют брандмауэр. Хотя его применимость очень широка, есть вещи, с которыми брандмауэр не может работать, такие как отправка текста обратно вызывающей стороне. Программное обеспечение уровня TCP может делать это и многое другое. В следующих нескольких разделах обсуждаются многие возможности TCP Wrappers, и, когда это необходимо, даются примеры настроек.</p></div><div class=paragraph><p>Программное обеспечение TCP Wrappers расширяет возможность <code>inetd</code> по поддержке каждого даемона. С ним становится возможным протоколирование, возврат сообщений вызывающей стороне, ограничение подключений внутренней сетью и т.п. Хотя некоторые из этих возможностей могут быть реализованы брандмауэром, TCP Wrappers не только предоставляют дополнительный уровень защиты, но и дают больше контроля над системой, чем это возможно с брандмауэром.</p></div><div class=paragraph><p>Расширенная функциональность обработчиков TCP не может заменить хороший сетевой экран. Тем не менее, обработчики TCP могут использоваться совместно с сетевым экраном и другими средствами обеспечения информационной безопасности, обеспечивая тем самым дополнительный уровень защиты системы.</p></div><div class=paragraph><p>Поскольку рассматривается расширение к настройкам <code>inetd</code>, предполагается, что читатель ознакомился с разделом о <a href=../network-servers/#network-inetd>настройке inetd</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Хотя программы, запускаемые из <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>, на самом деле не соответствуют термину "даемоны", существует традиция называть их именно так. Этот термин и используется в данном разделе.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_начальная_настройка>14.6.1. Начальная настройка<a class=anchor href=#_начальная_настройка></a></h3><div class=paragraph><p>Единственное требование для использования TCP Wrappers в FreeBSD это наличие в <span class=filename>rc.conf</span> параметров запуска <code>inetd`</code>-Ww`; это настройки по умолчанию. Конечно, ожидается также наличие правильной настройки <span class=filename>/etc/hosts.allow</span>, но <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> отправит сообщения в системный протокол если что-то не так.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>В отличие от других реализаций TCP Wrappers, использование <span class=filename>hosts.deny</span> не поддерживается. Все параметры настройки должны быть помещены в <span class=filename>/etc/hosts.allow</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>В простейшей конфигурации, политика подключения сводится к разрешению или блокированию в зависимости от параметров в <span class=filename>/etc/hosts.allow</span>. Настройка в FreeBSD по умолчанию заключается в разрешении подключения к любому даемону, запущенному из <code>inetd</code>. Изменение этого поведения будет обсуждаться только после рассмотрения базовой настройки.</p></div><div class=paragraph><p>Базовая настройка обычно принимает форму <code>daemon : address : action</code>, где <code>daemon</code> это имя даемона, который запускается <code>inetd</code>. В поле <code>address</code> может находиться имя хоста, IP адрес, или IPv6 адрес, заключенный в квадратные скобки ([ ]). Поле action может принимать значения allow или deny, чтобы соответственно разрешать или запрещать доступ. Помните, что поиск правил производится до первого совпадения. При обнаружении совпадения применяется соответствующее правило и поиск прерывается.</p></div><div class=paragraph><p>Существуют и другие параметры, но они будут описаны в следующих разделах. Простая конфигурация может быть, например, такой: для разрешения соединений по протоколу POP3 к даемону <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a>, в <span class=filename>hosts.allow</span> необходимо добавить следующие строки:</p></div><div class="literalblock programlisting"><div class=content><pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre></div></div><div class=paragraph><p>После добавления этой строки, <code>inetd</code> необходимо перезапустить. Это можно выполнить командой <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> или скриптом <span class=filename>/etc/rc.d/inetd</span> с параметром <span class=parameter>restart</span>.</p></div></div><div class=sect2><h3 id=_расширенная_конфигурация>14.6.2. Расширенная конфигурация<a class=anchor href=#_расширенная_конфигурация></a></h3><div class=paragraph><p>У TCP Wrappers имеются дополнительные параметры; они дают дополнительные возможности контроля над соединениями. Иногда бывает полезно возвращать комментарий определенным хостам или при подключении к определенным даемонам. В других случаях может быть необходимо добавить запись в лог файл, или отправить письмо администратору. В определенных ситуациях сервис должен использоваться только для локальных соединений. Все это возможно с использованием параметров c шаблонами, символами подстановки и путем выполнения внешних команд. Следующие два раздела посвящены этим типам настроек.</p></div><div class=sect3><h4 id=_внешние_команды>14.6.2.1. Внешние команды<a class=anchor href=#_внешние_команды></a></h4><div class=paragraph><p>Предположим ситуацию, в которой соединение должно быть запрещено, а о причине необходимо сообщить вызывающей стороне. Как это можно сделать? Соответствующую возможность предоставляет параметр <code>twist</code>. При попытке подключения выполняется команда или скрипт, заданный этим параметром. Пример дан в файле <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo &#34;You are not welcome to use %d from %h.&#34;</pre></div></div><div class=paragraph><p>В этом примере сообщение, "You are not allowed to use <code>daemon</code> from <code>hostname</code>." будет возвращено от всех даемонов, которые не были предварительно настроены в файле доступа. Обратите внимание, что возвращаемое сообщение <em>должно</em> быть заключено в кавычки; из этого правила нет исключений.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Возможна реализация DoS атаки, когда группа атакующих производит множество запросов на подключение.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Возможно также использование параметра <code>spawn</code>. Как и параметр <code>twist</code>, параметр <code>spawn</code> подразумевает запрет соединения и может использоваться для запуска команд или скриптов. В отличие от <code>twist</code>, <code>spawn</code> не отправляет ответ вызывающей стороне. Например, следующая конфигурация:</p></div><div class="literalblock programlisting"><div class=content><pre># We do not allow connections from example.com:
ALL : .example.com \
        : spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
          /var/log/connections.log) \
        : deny</pre></div></div><div class=paragraph><p>отклонит все попытки соединения из домена <code>*.example.com</code>; имя хоста, IP адрес и даемон протоколируются в файл <span class=filename>/var/log/connections.log</span>.</p></div><div class=paragraph><p>Помимо приведенных выше символов подстановки, например %a, существует еще несколько символов. Обратитесь к странице <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> справочной системы за полным списком.</p></div></div><div class=sect3><h4 id=_параметры_шаблоны>14.6.2.2. Параметры - шаблоны<a class=anchor href=#_параметры_шаблоны></a></h4><div class=paragraph><p>До этого момента в примерах использовался шаблон <code>ALL</code>. Существуют и другие параметры, функциональность которых в дальнейшем может быть расширена. <code>ALL</code> соответствует любому даемону, домену или IP адресу. Другой доступный шаблон это <code>PARANOID</code>, который соответствует хосту, IP адрес которого может быть подделан. Другими словами, <code>paranoid</code> может быть использован для определения действия с хостами, IP адрес которых не соответствует имени хоста. Вот пример применения этого параметра:</p></div><div class="literalblock programlisting"><div class=content><pre># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</pre></div></div><div class=paragraph><p>В этом примере все запросы на подключения к <code>sendmail</code> от хостов, IP адрес которых не соответствует имени хоста, будут отклонены.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Использование <code>PARANOID</code> невозможно, если у клиента или сервера неправильно настроен DNS. В таких случаях необходимо вмешательство администратора.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Более подробная информация о шаблонах и их возможностях дана на странице <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> справочной системы.</p></div><div class=paragraph><p>Для того, чтобы любая выбранная конфигурация заработала, в <span class=filename>hosts.allow</span> необходимо закомментировать первую строку настройки. В начале раздела об этом не упоминалось.</p></div></div></div></div></div><div class=sect1><h2 id=kerberosIV>14.7. KerberosIV<a class=anchor href=#kerberosIV></a></h2><div class=sectionbody><div class=paragraph><p>Kerberos это сетевая дополнительная система/протокол, которая делает возможной аутентификацию пользователей через сервисы на защищенном сервере. Такие сервисы, как удаленный вход, удаленное копирование, защищенное копирование файлов между системами и другие задачи с высоким риском становятся допустимо безопасными и более контролируемыми.</p></div><div class=paragraph><p>Последующие инструкции могут использоваться в качестве руководства по настройке поставляемого с FreeBSD Kerberos. Тем не менее, вам могут потребоваться страницы справочника полного дистрибутива.</p></div><div class=sect2><h3 id=_установка_kerberosiv>14.7.1. Установка KerberosIV<a class=anchor href=#_установка_kerberosiv></a></h3><div class=paragraph><p>Kerberos это опциональный компонент FreeBSD. Простейший способ установки этой программы это выбор <code>krb4</code> или <code>krb5</code> из sysinstall во время первой установки FreeBSD. Будет установлен "eBones" (KerberosIV) или "Heimdal" (Kerberos5) вариант Kerberos. Включение этих реализаций объясняется тем, что они разработаны вне США/Канады и доступны вне этих стран, поскольку на них не влияют ограничения на экспорт криптографического кода из США.</p></div><div class=paragraph><p>Кроме того, реализация MIT Kerberos доступна из Коллекции Портов в виде пакета <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>.</p></div></div><div class=sect2><h3 id=_создание_базы_данных>14.7.2. Создание базы данных<a class=anchor href=#_создание_базы_данных></a></h3><div class=paragraph><p>Это необходимо сделать только на сервере Kerberos. Во-первых, убедитесь что не осталось старой базы данных Kerberos. Войдите в каталог <span class=filename>/etc/kerberosIV</span> и убедитесь, что в нем находятся только эти файлы:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/kerberosIV</span>
<span class=c># ls</span>
README	        krb.conf        krb.realms</code></pre></div></div><div class=paragraph><p>Если присутствуют еще какие-то файлы (такие как <span class=filename>principal.*</span> или <span class=filename>master_key</span>), используйте команду <code>kdb_destroy</code> для удаления старой базы данных Kerberos, или, если Kerberos не запущен, просто удалите эти файлы.</p></div><div class=paragraph><p>Затем отредактируйте файлы <span class=filename>krb.conf</span> и <span class=filename>krb.realms</span>, введя ваши данные. В этом примере уникальный идентификатор <code>EXAMPLE.COM</code>, сервер <code>grunt.example.com</code>. Отредактируем или создадим файл <span class=filename>krb.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.conf</span>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</code></pre></div></div><div class=paragraph><p>В этом примере другие идентификаторы введены для иллюстрации настройки c несколькими хостами. С целью упрощения настройки вы можете не включать их.</p></div><div class=paragraph><p>Первая строка содержит идентификатор, под которым работает эта система. Остальные строки связывают идентификаторы с именами хостов. Сначала указывается идентификатор, затем хост под этим идентификатором, работающий как "центр распространения ключей". Слова <code>admin server</code> с последующим именем хоста означают, что этот хост также является сервером администрирования базы данных. За дальнейшей информацией об этих терминах обратитесь к страницам справочника по Kerberos.</p></div><div class=paragraph><p>Мы добавили <code>grunt.example.com</code> к идентификатору <code>EXAMPLE.COM</code> и кроме того сопоставили всем хостам в домене <code>.example.com</code> идентификатор <code>EXAMPLE.COM</code>. Файл <span class=filename>krb.realms</span> будет выглядеть так:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.realms</span>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</code></pre></div></div><div class=paragraph><p>Как и в предыдущем примере, другие идентификаторы добавлены только для примера. С целью упрощения настройки вы можете не включать их.</p></div><div class=paragraph><p>В первой строке <em>определенная</em> система сопоставляется с идентификатором. В остальных строках показано, сопоставить идентификатору остальные системы определенного поддомена.</p></div><div class=paragraph><p>Теперь мы готовы к созданию базы данных. Потребуется всего лишь запустить сервер Kerberos (или центр распространения ключей). Используйте для этого <code>kdb_init</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_init</span>
Realm name <span class=o>[</span>default  ATHENA.MIT.EDU <span class=o>]</span>: EXAMPLE.COM
You will be prompted <span class=k>for </span>the database Master Password.
It is important that you NOT FORGET this password.

Введите главный ключ Kerberos:</code></pre></div></div><div class=paragraph><p>Теперь мы должны сохранить ключ, чтобы сервера на локальных компьютерах могли его взять. Используйте для этого команду <code>kstash</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!</code></pre></div></div><div class=paragraph><p>Этой командой зашифрованный главный пароль сохранен в <span class=filename>/etc/kerberosIV/master_key</span>.</p></div></div><div class=sect2><h3 id=_запуск_kerberos>14.7.3. Запуск Kerberos<a class=anchor href=#_запуск_kerberos></a></h3><div class=paragraph><p>Для каждой системы, защищаемой Kerberos, в базу данных должны быть добавлены две записи. Это <code>kpasswd</code> и <code>rcmd</code>. Они добавляются вместе с именем системы.</p></div><div class=paragraph><p>Эти даемоны, kpasswd и rcmd позволяют другим системам изменять пароли Kerberos и запускать такие команды как <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>.</p></div><div class=paragraph><p>Теперь добавим эти записи:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: passwd
Instance: grunt

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: passwd, Instance: grunt, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> enter RANDOM here
Verifying password

New Password: &lt;<span class=nt>----</span> enter RANDOM here

Random password <span class=o>[</span>y] ? y

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name: rcmd
Instance: grunt

&lt;Not found&gt;, Create [y] ?

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
New Password:		&lt;---- enter RANDOM here
Verifying password

New Password:           &lt;---- enter RANDOM here

Random password [y] ?

Principal&#39;</span>s new key version <span class=o>=</span> 1
Expiration <span class=nb>date</span> <span class=o>(</span>enter yyyy-mm-dd<span class=o>)</span> <span class=o>[</span> 2000-01-01 <span class=o>]</span> ?
Max ticket lifetime <span class=o>(</span><span class=k>*</span>5 minutes<span class=o>)</span> <span class=o>[</span> 255 <span class=o>]</span> ?
Attributes <span class=o>[</span> 0 <span class=o>]</span> ?
Edit O.K.
Principal name:         &lt;<span class=nt>----</span> null entry here will cause an <span class=nb>exit</span></code></pre></div></div></div><div class=sect2><h3 id=_создание_файла_настройки_сервера>14.7.4. Создание файла настройки сервера<a class=anchor href=#_создание_файла_настройки_сервера></a></h3><div class=paragraph><p>Теперь необходимо создать все записи сервисов, которые были определены для каждого компьютера. Используем для этого команду <code>ext_srvtab</code>. Будет создан файл, который должен быть скопирован или перемещен <em>безопасным способом</em> в каталог <span class=filename>/etc/kerberosIV</span> каждого Kerberos клиента. Этот файл должен присутствовать на каждом сервере и клиенте, он необходим для работы Kerberos.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ext_srvtab grunt</span>
Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating <span class=s1>&#39;grunt-new-srvtab&#39;</span>....</code></pre></div></div><div class=paragraph><p>Эта команда создаст временный файл, который должен быть переименован в <span class=filename>srvtab</span>, чтобы серверы смогли обратиться к нему. Используйте команду <a href="https://man.freebsd.org/cgi/man.cgi?query=mv&amp;sektion=1&amp;format=html">mv(1)</a> для перемещения его в исходной системе:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grunt-new-srvtab srvtab</span></code></pre></div></div><div class=paragraph><p>Если файл предназначен для клиентской системы, и сеть не безопасна, скопируйте <span class=filename>client-new-srvtab</span> на съемный носитель и перенесите файл с его помощью. Убедитесь, что переименовали его в <span class=filename>srvtab</span> в каталоге <span class=filename>/etc/kerberosIV</span> клиента, и что режим доступа к нему 600:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grumble-new-srvtab srvtab</span>
<span class=c># chmod 600 srvtab</span></code></pre></div></div></div><div class=sect2><h3 id=_пополнение_базы_данных>14.7.5. Пополнение базы данных<a class=anchor href=#_пополнение_базы_данных></a></h3><div class=paragraph><p>Теперь необходимо добавить в базу данных пользователей. Во-первых, создадим запись для пользователя <code>jane</code>. Используйте команду <code>kdb_edit</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance:

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: , kdc_key_ver: 1
New Password:                &lt;<span class=nt>----</span> enter a secure password here
Verifying password

New Password:                &lt;<span class=nt>----</span> re-enter the password here
Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name:		   &lt;---- null entry here will cause an exit</span></code></pre></div></div></div><div class=sect2><h3 id=_тестирование_всей_системы>14.7.6. Тестирование всей системы<a class=anchor href=#_тестирование_всей_системы></a></h3><div class=paragraph><p>Во-первых, запустите даемоны Kerberos. При правильном редактировании файла <span class=filename>/etc/rc.conf</span> они запустятся автоматически при перезагрузке. Это необходимо только на сервере Kerberos. Клиенты Kerberos получат все необходимые данные из каталога <span class=filename>/etc/kerberosIV</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kerberos &amp;</span>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
<span class=c># kadmind -n &amp;</span>
KADM Server KADM0.0A initializing
Please <span class=k>do </span>not use <span class=s1>&#39;kill -9&#39;</span> to <span class=nb>kill </span>this job, use a
regular <span class=nb>kill </span>instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</code></pre></div></div><div class=paragraph><p>Теперь для получения доступа через созданного пользователя <code>jane</code> используйте <code>kinit</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit jane
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Попробуйте просмотреть имеющиеся данные с помощью <code>klist</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% klist
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Теперь попробуйте изменить пароль с помощью <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a>, чтобы убедиться, что даемон kpasswd может получить информацию из базы данных Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
realm EXAMPLE.COM
Old password <span class=k>for </span>jane:
New Password <span class=k>for </span>jane:
Verifying password
New Password <span class=k>for </span>jane:
Password changed.</code></pre></div></div></div><div class=sect2><h3 id=_включение_su>14.7.7. Включение <code>su</code><a class=anchor href=#_включение_su></a></h3><div class=paragraph><p>Kerberos позволяет назначить <em>каждому</em> пользователю, который нуждается в привилегиях <code>root</code>, свой <em>собственный</em> пароль <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>. Необходимо добавить учётную запись, которой разрешено получать <code>root</code> доступ через <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>. Это делается путем связывания учётной записи <code>root</code> с пользовательской учётной записью. Создадим в базе данных Kerberos запись <code>jane.root</code> с помощью <code>kdb_edit</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance: root

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> enter a SECURE password here
Verifying password

New Password:    	 	 &lt;<span class=nt>----</span> re-enter the password here

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ? 12 &lt;--- Keep this short!
Attributes [ 0 ] ?
Edit O.K.
Principal name:		         &lt;---- null entry here will cause an exit</span></code></pre></div></div><div class=paragraph><p>Теперь проверим работоспособность этой записи:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kinit jane.root</span>
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane.root&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Необходимо добавить пользователя к <code>root</code> файлу <span class=filename>.klogin</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Теперь попробуйте выполнить <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:</code></pre></div></div><div class=paragraph><p>и посмотрите на имеющиеся данные:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># klist</span>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</code></pre></div></div></div><div class=sect2><h3 id=_использование_других_команд>14.7.8. Использование других команд<a class=anchor href=#_использование_других_команд></a></h3><div class=paragraph><p>В примере выше мы создали запись (principal) <code>jane</code> с доступом к <code>root</code> (instance). Она основана на пользователе с таким же именем, как и идентификатор, что принято Kerberos по умолчанию; <code>&lt;principal>.&lt;instance></code> в форме <code>&lt;username>.``root</code> позволяет использовать <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> для доступа к <code>root</code>, если соответствующие записи находятся в файле <span class=filename>.klogin</span> домашнего каталога <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>Подобно этому, если в файле <span class=filename>.klogin</span> из домашнего каталога пользователя есть строки в форме:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat</span> ~/.klogin
jane@EXAMPLE.COM
jack@EXAMPLE.COM</code></pre></div></div><div class=paragraph><p>это позволит любому с идентификатором <code>EXAMPLE.COM</code>, кто аутентифицировался как <code>jane</code> или <code>jack</code> (с помощью команды <code>kinit</code>, см. выше) получить доступ к учётной записи пользователя <code>jane</code> или файлам этой системы (<code>grunt</code>) через <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> или <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>.</p></div><div class=paragraph><p>Например, <code>jane</code> может входить в другую систему используя Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Password:
% rlogin grunt
Last login: Mon May  1 21:14:47 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div><div class=paragraph><p>Или <code>jack</code> входит в учётную запись <code>jane’s на этом же компьютере (файл <span class=filename>.klogin</span>`jane</code> настроен как показано выше, и в Kerberos настроена учётная запись <em>jack</em>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
% rlogin grunt <span class=nt>-l</span> jane
MIT Project Athena <span class=o>(</span>grunt.example.com<span class=o>)</span>
Password:
Last login: Mon May  1 21:16:55 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=kerberos5>14.8. Kerberos5<a class=anchor href=#kerberos5></a></h2><div class=sectionbody><div class=paragraph><p>Все релизы FreeBSD после FreeBSD-5.1 включают поддержку только Kerberos5. Таким образом, Kerberos5 это единственная включаемая в поставку версия и его конфигурация похожа на KerberosIV во многих аспектах. Эта информация применима только к Kerberos5 из релизов после FreeBSD-5.0. Пользователи, желающие использовать пакет KerberosIV, могут установить его из порта <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb4/>security/krb4</a>.</p></div><div class=paragraph><p>Kerberos это дополнительная сетевая система/протокол, позволяющая пользователям авторизоваться через защищенные сервисы на защищенном сервере. Такие сервисы как удаленный вход, удаленное копирование, защищенное копирование файлов между системами и другие задачи с высоким риском становятся допустимо безопасными и более контролируемыми.</p></div><div class=paragraph><p>Kerberos может быть описана как прокси система идентификации-проверки. Она также может быть описана как защищенная внешняя система аутентификации. Kerberos предоставляет только одну функцию - защищенную аутентификацию пользователей сети. Он не предоставляет функций авторизации (что разрешено делать пользователям) или функций аудита (какой пользователь что делает). После того, как клиент и сервер использовали Kerberos для идентификации, они могут зашифровать все соединения для гарантирования собственной безопасности и целостности данных.</p></div><div class=paragraph><p>Следовательно крайне рекомендуется использовать Kerberos с другими методами безопасности, предоставляющими сервисы авторизации и аудита.</p></div><div class=paragraph><p>Последующие инструкции могут использоваться в качестве руководства по настройке Kerberos, поставляемого с FreeBSD. Тем не менее, вам потребуется обратиться к соответствующим страницам справочника за полным описанием.</p></div><div class=paragraph><p>В целях демонстрации установки Kerberos, будут применены следующие обозначения:</p></div><div class=ulist><ul><li><p>DNS домен ("зона") example.org.</p></li><li><p>Уникальный идентификатор Kerberos EXAMPLE.ORG.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Используйте действующие имена доменов при настройке Kerberos даже если вы будете использовать его во внутренней сети. Это позволит избежать проблем с DNS и гарантирует возможность связи с Kerberos под другими идентификаторами.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_история>14.8.1. История<a class=anchor href=#_история></a></h3><div class=paragraph><p>Kerberos был создан MIT в качестве решения проблем с безопасностью сети. Протокол Kerberos использует стойкую криптографию, так что клиент может идентифицироваться на сервере (и обратно) через незащищенное сетевое соединение.</p></div><div class=paragraph><p>Kerberos это и имя сетевого протокола аутентификации и общий термин для описания программ, где он реализован (например, Kerberos telnet). Текущая версия протокола 5 описана в RFC 1510.</p></div><div class=paragraph><p>Доступно несколько свободных реализаций этого протокола, работающих на множестве операционных систем. Massachusetts Institute of Technology (MIT), где Kerberos был первоначально разработан, продолжает разрабатывать собственный пакет Kerberos. Он обычно использовался в США как криптографический продукт, и в этом качестве попадал под действие ограничений на экспорт. MITKerberos доступен в виде порта (<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>). Heimdal Kerberos это другая реализация версии 5, которая разрабатывалась исключительно вне США для обхода экспортных ограничений (и поэтому часто включалась в некоммерческие реализации UNIX®). Heimdal Kerberos доступен в виде порта (<a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a>), его минимальный комплект включен в базовую установку FreeBSD.</p></div><div class=paragraph><p>В целях получения наибольшей аудитории, в этих инструкциях предполагается использование Heimdal включаемого в FreeBSD.</p></div></div><div class=sect2><h3 id=_настройка_heimdal_kdc>14.8.2. Настройка Heimdal KDC<a class=anchor href=#_настройка_heimdal_kdc></a></h3><div class=paragraph><p>Центр распространения ключей (Key Distribution Center, KDC) это централизованный сервис аутентификации, предоставляемый Kerberos - это компьютер, который предоставляет доступ через Kerberos. KDC считается доверяемым всеми другими компьютерами с определенным идентификатором Kerberos и поэтому к нему предъявляются высокие требования безопасности.</p></div><div class=paragraph><p>Имейте ввиду, что хотя работа сервера Kerberos требует очень немного вычислительных ресурсов, из соображений безопасности для него рекомендуется отдельный компьютер, работающий только в качестве KDC.</p></div><div class=paragraph><p>Перед началом настройки KDC, убедитесь что в файле <span class=filename>/etc/rc.conf</span> содержатся правильные настройки для работы в качестве KDC (вам может потребоваться изменить пути в соответствии с собственной системой):</p></div><div class="literalblock programlisting"><div class=content><pre>kerberos5_server_enable=&#34;YES&#34;
kadmind5_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Затем приступим к редактированию файла настройки Kerberos, <span class=filename>/etc/krb5.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>Обратите внимание что в файле <span class=filename>/etc/krb5.conf</span> подразумевается наличие у KDC полного имени <code>kerberos.example.org</code>. Вам потребуется добавить CNAME (синоним) к файлу зоны, если у KDC другое имя.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Для больших сетей с правильно настроенным сервером BINDDNS пример выше может быть урезан до:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
      default_realm = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>Со следующими строками, добавленными в файл зоны <code>example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</pre></div></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Чтобы клиенты могли найти сервисы Kerberos, <em>необходимо</em> наличие или полностью настроенного <span class=filename>/etc/krb5.conf</span> или минимально настроенного <span class=filename>/etc/krb5.conf</span><em>и</em> правильно настроенного DNS сервера.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Создадим теперь базу данных Kerberos. Эта база данных содержит ключи всех основных хостов, зашифрованных с помощью главного пароля. Вам не требуется помнить этот пароль, он хранится в файле (<span class=filename>/var/heimdal/m-key</span>). Для создания главного ключа запустите <code>kstash</code> и введите пароль.</p></div><div class=paragraph><p>Как только будет создан главный ключ, вы можете инициализировать базу данных с помощью программы <code>kadmin</code> с ключом <code>-l</code> (означающим "local"). Этот ключ сообщает <code>kadmin</code> обращаться к файлам базы данных непосредственно вместо использования сетевого сервиса <code>kadmind</code>. Это помогает решить "проблему курицы и яйца", когда обращение идет к еще не созданной базе данных. Как только вы увидите приглашение <code>kadmin</code>, используйте команду <code>init</code> для создания базы данных идентификаторов.</p></div><div class=paragraph><p>Наконец, оставаясь в приглашении <code>kadmin</code>, создайте первую запись с помощью команды <code>add</code>. Оставьте неизменными параметры по умолчанию, вы всегда сможете изменить их позже с помощью команды <code>modify</code>. Обратите внимание, что вы всегда можете использовать команду <code>?</code> для просмотра доступных параметров.</p></div><div class=paragraph><p>Пример создания базы данных показан ниже:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>
Master key: xxxxxxxx
Verifying password - Master key: xxxxxxxx

<span class=c># kadmin -l</span>
kadmin&gt; init EXAMPLE.ORG
Realm max ticket life <span class=o>[</span>unlimited]:
kadmin&gt; add tillman
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx</code></pre></div></div><div class=paragraph><p>Теперь пришло время запустить сервисы KDC. Выполните команды <code>/etc/rc.d/kerberos start</code> и <code>/etc/rc.d/kadmind start</code> для запуска сервисов. Заметьте, что ни один из поддерживающих Kerberos даемонов на этот момент запущен не будет, но у вас должна быть возможность убедиться в том, что KDC функционирует путем получения списка доступа для пользователя, которого вы только что самостоятельно создали из командной строки самого KDC:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% k5init tillman
tillman@EXAMPLE.ORG<span class=s1>&#39;s Password:

% k5list
Credentials cache: FILE:/tmp/krb5cc_500
        Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</span></code></pre></div></div></div><div class=sect2><h3 id=_сервер_kerberos_с_сервисами_heimdal>14.8.3. Сервер Kerberos с сервисами Heimdal<a class=anchor href=#_сервер_kerberos_с_сервисами_heimdal></a></h3><div class=paragraph><p>Для начала нам потребуется копия файла настройки Kerberos, <span class=filename>/etc/krb5.conf</span>. Просто скопируйте его с KDC на клиентский компьютер безопасным способом (используя сетевые утилиты, такие как <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, или физически, с помощью дискеты).</p></div><div class=paragraph><p>Затем вам понадобится файл <span class=filename>/etc/krb5.keytab</span>. Это основное различие между сервером, поддерживающим Kerberos и рабочими станциями - на сервере должен быть файл <span class=filename>keytab</span>. В этом файле находится центральный ключ сервера, который позволяет KDC проверять все другие идентификаторы. Он должен быть помещен на сервер безопасным способом, поскольку безопасность сервера может быть нарушена, если ключ станет общедоступен. Это означает, что его передача через прозрачный канал, такой как FTP - очень плохая идея.</p></div><div class=paragraph><p>Обычно перенос файла <span class=filename>keytab</span> на сервер производится с помощью программы <code>kadmin</code>. Это удобно, поскольку вам потребуется также создать запись хоста (KDC часть <span class=filename>krb5.keytab</span>) с помощью <code>kadmin</code>.</p></div><div class=paragraph><p>Обратите внимание, что должны быть уже зарегистрированы в системе и необходимо наличие прав на использование интерфейса <code>kadmin</code> в файле <span class=filename>kadmind.acl</span>. Обратитесь к разделу "Remote administration" в info страницах Heimdal (<code>info heimdal</code>) за деталями по составлению списка доступа. Если вы не хотите включать удаленный доступ <code>kadmin</code>, можете просто подключиться к KDC через защищенное соединение (локальную консоль, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> или Kerberos <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>) и выполнять администрирование локально с помощью <code>kadmin -l</code>.</p></div><div class=paragraph><p>После добавления файла <span class=filename>/etc/krb5.conf</span>, вы можете использовать <code>kadmin</code> с сервера Kerberos. Команда <code>add --random-key</code> позволит вам добавить запись для сервера, а команда <code>ext</code> позволит перенести эту запись в собственный keytab файл сервера. Например:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; add <span class=nt>--random-key</span> host/myserver.example.org
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
kadmin&gt; ext host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Обратите внимание, что команда <code>ext</code> (сокращение от "extract") сохраняет полученный ключ в файле <span class=filename>/etc/krb5.keytab</span> по умолчанию.</p></div><div class=paragraph><p>Если на KDC не запущен <code>kadmind</code> (возможно по соображениям безопасности) и вы не можете получить доступ к <code>kadmin</code> удаленно, возможно добавление записи хоста (<code>host/myserver.EXAMPLE.ORG</code>) непосредственно на KDC с последующим извлечением ее во временный файл (и перезаписью <span class=filename>/etc/krb5.keytab</span> на KDC) примерно так:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; ext <span class=nt>--keytab</span><span class=o>=</span>/tmp/example.keytab host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Затем вы можете скопировать keytab на сервер защищенным способом (например, используя <code>scp</code> или дискету). Убедитесь, что используемое имя keytab не совпадает с именем по умолчанию во избежание перезаписывания keytab на KDC.</p></div><div class=paragraph><p>Теперь ваш сервер может связываться с KDC (добавлен файл <span class=filename>krb5.conf</span>) и идентифицировать себя (добавлен файл <span class=filename>krb5.keytab</span>). Теперь вы готовы к включению некоторых сервисов Kerberos. В этом примере мы включим сервис <code>telnet</code>, поместив в <span class=filename>/etc/inetd.conf</span> нижеприведенную строку и перезапустив сервис <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> командой <code>/etc/rc.d/inetd restart</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</pre></div></div><div class=paragraph><p>Очень важно установить ключ <code>-a</code> (тип аутентификации) в user. Обратитесь к странице справочника <a href="https://man.freebsd.org/cgi/man.cgi?query=telnetd&amp;sektion=8&amp;format=html">telnetd(8)</a> за подробной информацией.</p></div></div><div class=sect2><h3 id=_клиент_kerberos_с_heimdal>14.8.4. Клиент Kerberos с Heimdal<a class=anchor href=#_клиент_kerberos_с_heimdal></a></h3><div class=paragraph><p>Настройка клиентского компьютера почти тривиально проста. Как только настройка Kerberos закончена, вам потребуется только файл настройки Kerberos, <span class=filename>/etc/krb5.conf</span>. Просто скопируйте его безопасным способом на клиентский компьютер с KDC.</p></div><div class=paragraph><p>Протестируйте клиентский компьютер, попытавшись использовать <code>kinit</code>, <code>klist</code>, и <code>kdestroy</code> для получения, отображения и удаления списка доступа. Соединитесь с Kerberos севером используя клиент Kerberos, если соединение не работает и получение доступа является проблемой, это скорее всего проблема сервера, а не клиента или KDC.</p></div><div class=paragraph><p>При тестировании приложения вроде <code>telnet</code>, попробуйте использовать программу перехвата пакетов (такую как <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>), чтобы убедиться, что ваш пароль не передается незашифрованным. Попробуйте использовать <code>telnet</code> с параметром <code>-x</code>, чтобы зашифровать весь поток данных (подобно <code>ssh</code>).</p></div><div class=paragraph><p>Основные клиентские приложения Kerberos (традиционно называющиеся <code>kinit</code>, <code>klist</code>, <code>kdestroy</code>, и <code>kpasswd</code>) находятся в базовой установке FreeBSD. Обратите внимание, что в FreeBSD версий до 5.0 они были переименованы в <code>k5init</code>, <code>k5list</code>, <code>k5destroy</code>, <code>k5passwd</code>, и <code>k5stash</code> (хотя их обычно использовали лишь однократно).</p></div><div class=paragraph><p>Различные неосновные клиентские приложения Kerberos также устанавливаются по умолчанию. Здесь проявляется "минимальность" базовой установки Heimdal: <code>telnet</code> это единственное приложение, поддерживающее Kerberos.</p></div><div class=paragraph><p>Порт Heimdal добавляет некоторые отсутствующие клиентские приложения: поддерживающие Kerberos версии <code>ftp</code>, <code>rsh</code>, <code>rcp</code>, <code>rlogin</code>, и некоторые другие реже используемые программы. Порт MIT также содержит полный пакет клиентских приложений Kerberos.</p></div></div><div class=sect2><h3 id=_пользовательские_файлы_настройки_k5login_и_k5users>14.8.5. Пользовательские файлы настройки: <span class=filename>.k5login</span> и <span class=filename>.k5users</span><a class=anchor href=#_пользовательские_файлы_настройки_k5login_и_k5users></a></h3><div class=paragraph><p>Учётные записи пользователя в Kerberos (например <code>tillman@EXAMPLE.ORG</code>) обычно связаны с локальными учётными записями (например с локальной учётной записью6 <code>tillman</code>). Клиентские приложения, такие как <code>telnet</code>, обычно не требуют указания имени пользователя или учётной записи.</p></div><div class=paragraph><p>Тем не менее, время от времени вам может потребоваться дать доступ к локальной учётной записи кому-то, у кого нет соответствующей учётной записи Kerberos. Например, пользователю <code>tillman@EXAMPLE.ORG</code> может потребоваться доступ к локальной учётной записи <code>webdevelopers</code>. Другим учётным записям также может потребоваться доступ к этой локальной учётной записи.</p></div><div class=paragraph><p>Файлы <span class=filename>.k5login</span> и <span class=filename>.k5users</span>, помещенные в домашний каталог пользователя, могут быть использованы подобно действенной комбинации <span class=filename>.hosts</span> и <span class=filename>.rhosts</span> для решения этой проблемы. Например, файл <span class=filename>.k5login</span> со следующим содержанием:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>tillman@example.org
jdoe@example.org</code></pre></div></div><div class=paragraph><p>помещен в домашний каталог локального пользователя <code>webdevelopers</code>, то обе упомянутые учётные записи получат доступ к этой учётной записи без необходимости наличия общего пароля.</p></div><div class=paragraph><p>Рекомендуется прочитать страницу справочника по этим командам. Обратите внимание, что страница справочника о <code>ksu</code> содержит информацию по <span class=filename>.k5users</span>.</p></div></div><div class=sect2><h3 id=_подсказки_советы_и_решение_проблем_с_kerberos>14.8.6. Подсказки, советы и решение проблем с Kerberos<a class=anchor href=#_подсказки_советы_и_решение_проблем_с_kerberos></a></h3><div class=ulist><ul><li><p>При использовании портов как Heimdal так и MITKerberos убедитесь, что в <code>PATH</code> версии Kerberos клиентов указаны перед их версиями в базовой системе.</p></li><li><p>Все ли компьютеры в пределах данного realm синхронизированы по времени? Если нет, аутентификация может завершиться неудачно. <a href=../network-servers/#network-ntp>Синхронизация часов через NTP</a> описывает как синхронизировать часы с использованием NTP.</p></li><li><p>MIT и Heimdal успешно взаимодействуют. За исключением <code>kadmin</code>, протокол для которого не стандартизован.</p></li><li><p>Если вы изменяете hostname, потребуется также изменить учётную запись <code>host/</code> и обновить keytab. Это также необходимо для специальных записей в keytab, таких как <code>www/</code> запись модуля Apache <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_auth_kerb/>www/mod_auth_kerb</a>.</p></li><li><p>Все хосты под общим идентификатором должны разрешаться DNS (прямое и обратное разрешение), или как минимум через <span class=filename>/etc/hosts</span>. Записи CNAME будут работать, но записи A и PTR должны быть корректны и находиться на своем месте. Сообщение об ошибке не всегда интуитивно понятно: <code>Kerberos5 refuses authentication because Read req failed: Key table entry not found</code>.</p></li><li><p>Некоторые операционные системы, способные работать в качестве клиентов KDC не устанавливают права для <code>ksu</code> в setuid <code>root</code>. Это означает, что <code>ksu</code> не работает, что хорошо является хорошей идеей для безопасности, но неудобно. Это не ошибка KDC.</p></li><li><p>С MITKerberos, если вы хотите продлить действие доступа до значения большего, чем десять часов по умолчанию, используйте команду <code>modify_principal</code> в <code>kadmin</code> для изменения maxlife доступа к самой учётной записи и к учётной записи <code>krbtgt</code>. Затем возможно использование <code>kinit</code> с параметром <code>-l</code> для запроса доступа с большим временем действия.
*</p></li></ul></div><div class=exampleblock><div class=content><div class=paragraph><p>Если вы запускаете перехватчик пакетов на KDC для разрешения проблем, а затем запускаете <code>kinit</code> с рабочей станции, то увидите, что TGT посылается непосредственно при запуске <code>kinit</code> - даже до того, как вы введете пароль! Объяснение в том, что сервер Kerberos свободно распространяет TGT (Ticket Granting Ticket) на каждый неавторизованный запрос; однако, каждый TGT зашифрован ключом, полученным из пароля пользователя. Следовательно, когда пользователь вводит свой пароль, он не отправляется на KDC, а используется для расшифровка TGT, который уже получен <code>kinit</code>. Если в процессе расшифровки получается правильный билет с правильным значением времени, у пользователя есть действующее "удостоверение". Это удостоверение содержит ключ сессии для установления безопасного соединения с сервером Kerberos, как и действующий TGT, зашифрованный ключом сервера Kerberos. Второй уровень шифрования недоступен пользователю, но позволяет серверу Kerberos проверять правильность каждого TGT.</p></div></div></div><div class=ulist><ul><li><p>Если вы хотите установить большое время жизни доступа (например, неделю), и используете OpenSSH для соединения с компьютером, где хранится "билет", убедитесь, что параметр Kerberos`TicketCleanup` установлен в <code>no</code> в файле <span class=filename>sshd_config</span>, или билеты будут уничтожены при выходе из сеанса.</p></li><li><p>Запомните, что время жизни билетов хостов больше. Если время жизни билета для учётной записи пользователя составляет неделю, а время жизни учётной записи хоста, к которому вы подсоединяетесь девять часов, учётная запись хоста в кэше устареет и кэш билетов будет работать не так, как ожидается.</p></li><li><p>При настройке файла <span class=filename>krb5.dict</span> на предотвращение использования определенных плохих паролей (страница справочника для <code>kadmind</code> кратко рассказывает об этом), запомните, что это применимо только к учётным записям, для которых действует политика паролей. Формат файла <span class=filename>krb5.dict</span> прост: одно слово на строку. Может помочь создание символической ссылки на <span class=filename>/usr/shared/dict/words</span>.</p></li></ul></div></div><div class=sect2><h3 id=_отличия_от_порта_mit>14.8.7. Отличия от порта MIT<a class=anchor href=#_отличия_от_порта_mit></a></h3><div class=paragraph><p>Основное различие между установками MIT и Heimdal относится к программе <code>kadmin</code>, которая имеет другой (но эквивалентный) набор команд и использует другой протокол. Если ваш KDC работает на MIT, вы не сможете использовать <code>kadmin</code> для удаленного администрирования KDC (и наоборот, по этой же причине).</p></div><div class=paragraph><p>Опции командной строки клиентов также могут немного отличаться для одинаковых задач. Рекомендуется следование инструкциям на MITKerberos Web-сайте (<a href=http://web.mit.edu/Kerberos/www/>http://web.mit.edu/Kerberos/www/</a>). Будьте внимательны при определении <code>PATH</code>: порт MIT устанавливается по умолчанию в <span class=filename>/usr/local/</span>, и если в <code>PATH</code> вначале указаны системные каталоги, вместо приложений MIT могут быть запущены системные приложения.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>С портом MIT<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>, предоставляемым FreeBSD, убедитесь что файл <span class=filename>/usr/local/shared/doc/krb5/README.FreeBSD</span> установлен портом, если вы хотите понять почему вход через <code>telnetd</code> и <code>klogind</code> иногда происходит так странно. Наиболее важно, исправление "incorrect permissions on cache file" требует использования бинарного файла <code>login.krb5</code> для аутентификации, чтобы права на переданное удостоверение передавались правильно.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_преодоление_ограничений_обнаруженных_в_kerberos>14.8.8. Преодоление ограничений, обнаруженных в Kerberos<a class=anchor href=#_преодоление_ограничений_обнаруженных_в_kerberos></a></h3><div class=sect3><h4 id=_kerberos_это_все_или_ничего>14.8.8.1. Kerberos это все или ничего<a class=anchor href=#_kerberos_это_все_или_ничего></a></h4><div class=paragraph><p>Каждый сервис, работающий в сети, должен быть модифицирован для работы с Kerberos (или другим способом защищен от атак по сети) или удостоверения пользователей могут быть украдены или использованы повторно. В качестве примера может быть приведено использование Kerberos версий оболочек для удаленной работы (например через <code>rsh</code> и <code>telnet</code>), при наличии POP3 сервера, получающего пароли в незашифрованном виде.</p></div></div><div class=sect3><h4 id=_kerberos_предназначен_для_однопользовательских_рабочих_станций>14.8.8.2. Kerberos предназначен для однопользовательских рабочих станций<a class=anchor href=#_kerberos_предназначен_для_однопользовательских_рабочих_станций></a></h4><div class=paragraph><p>В многопользовательской среде Kerberos менее безопасен. Это потому, что он хранит билеты в каталоге <span class=filename>/tmp</span>, которая доступна для чтения всем. Если пользователь работает с несколькими другими пользователями одновременно на одном компьютере (т.е. в многопользовательской среде), возможна кража (копирование) билета другим пользователем.</p></div><div class=paragraph><p>Решить проблему можно с помощью параметра командной строки <code>-c</code> или (предпочтительно) с помощью переменной окружения <code>KRB5CCNAME</code>, но это делается редко. Для преодоления ограничения достаточно сохранять билет в домашнем каталоге пользователя и использовать простые ограничения на доступ к файлам.</p></div></div><div class=sect3><h4 id=_от_kdc_зависит_вся_система>14.8.8.3. От KDC зависит вся система<a class=anchor href=#_от_kdc_зависит_вся_система></a></h4><div class=paragraph><p>Архитектура системы такова, что KDC должен быть максимально защищен, поскольку главный пароль базы данных содержится в нем. На KDC не должно быть запущено никаких других сервисов и он должен быть защищен физически. Опасность велика, поскольку Kerberos хранит все пароли зашифрованными одним ключом ("главным" ключом), который хранится в файле на KDC.</p></div><div class=paragraph><p>Хорошей новостью является то, что кража главного ключа не станет такой проблемой, как может показаться. Главный ключ используется только для шифрования базы данных Kerberos и в качестве seed для генератора случайных чисел. Поскольку доступ к KDC защищен, атакующий мало что сможет сделать с главным ключом.</p></div><div class=paragraph><p>Кроме того, если KDC станет недоступен (возможно по причине атак DoS или проблем в сети) сетевые сервисы будет невозможно использовать, поскольку аутентификация не может быть выполнена. Уменьшить последствия можно при наличии нескольких KDC (один главный и один или несколько резервных) и с аккуратно реализованной резервной аутентификацией (отлично подойдет PAM).</p></div></div><div class=sect3><h4 id=_недостатки_kerberos>14.8.8.4. Недостатки Kerberos<a class=anchor href=#_недостатки_kerberos></a></h4><div class=paragraph><p>Kerberos позволяет пользователям, хостам и сервисам производить аутентификацию друг друга. В нем нет механизма аутентификации KDC для пользователей, хостов или сервисов. Это означает, что поддельный <code>kinit</code> (например) может записывать все имена пользователей и паролей. Помочь решить проблему может <a class=package href=https://cgit.freebsd.org/ports/tree/security/tripwire/>security/tripwire</a> или другой инструмент проверки целостности файловой системы.</p></div></div></div><div class=sect2><h3 id=_ресурсы_и_информация_для_дальнейшего_изучения>14.8.9. Ресурсы и информация для дальнейшего изучения<a class=anchor href=#_ресурсы_и_информация_для_дальнейшего_изучения></a></h3><div class=ulist><ul><li><p><a href=http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html>Kerberos FAQ</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/dialogue.html>Разработка системы аутентификации: диалог в четырех сценах</a></p></li><li><p><a href="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510, Kerberos Network Authentication Service (V5)</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/>Домашняя страница MIT Kerberos</a></p></li><li><p><a href=http://www.pdc.kth.se/heimdal/>Домашняя страница Heimdal Kerberos</a></p></li></ul></div></div></div></div><div class=sect1><h2 id=openssl>14.9. OpenSSL<a class=anchor href=#openssl></a></h2><div class=sectionbody><div class=paragraph><p>Одной из программ, требующих особого внимания пользователей, является набор программ OpenSSL, включенный в FreeBSD. OpenSSL предоставляет уровень шифрования поверх обычных уровней соединения; следовательно, он может быть использован многими сетевыми приложениями и сервисами.</p></div><div class=paragraph><p>OpenSSL может использоваться для шифрования соединений почтовых клиентов, транзакций через интернет, например для кредитных карт, и многого другого. Многие порты, такие как <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13-ssl/>www/apache13-ssl</a> и <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a> собираются с OpenSSL.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>В большинстве случаев в Коллекции Портов будет сделана попытка построения порта <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssl/>security/openssl</a>, если только переменная <code>WITH_OPENSSL_BASE</code> не установлена явно в "yes".</p></div></td></tr></tbody></table></div><div class=paragraph><p>Версия OpenSSL, включаемая в FreeBSD, поддерживает сетевые протоколы безопасности Secure Sockets Layer v2/v3 (SSLv2/SSLv3), Transport Layer Security v1 (TLSv1) и может быть использована в качестве основной криптографической библиотеки.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Хотя OpenSSL поддерживает алгоритм IDEA, по умолчанию он отключен из-за патентных ограничений Соединенных Штатов. Для его использования необходимо ознакомиться с лицензией, и, если ограничения приемлемы, установить в <span class=filename>make.conf</span> переменную <code>MAKE_IDEA</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Наиболее часто OpenSSL используется для создания сертификатов, используемых программными пакетами. Эти сертификаты подтверждают, что данные компании или частного лица верны и не подделаны. Если рассматриваемый сертификат не был проверен одним из нескольких сертификационных центров ("Certificate Authorities" - CA), обычно выводится предупреждение. Центр сертификации представляет собой компанию, такую, как <a href=http://www.verisign.com>VeriSign</a>, которая подписывает сертификаты для подтверждения данных частных лиц или компаний. Эта процедура не бесплатна и не является абсолютно необходимой для использования сертификатов; однако может успокоить некоторых особо осторожных пользователей.</p></div><div class=sect2><h3 id=_генерирование_сертификатов>14.9.1. Генерирование сертификатов<a class=anchor href=#_генерирование_сертификатов></a></h3><div class=paragraph><p>Для генерирования сертификатов доступна следующая команда:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -nodes -out req.pem -keyout cert.pem</span>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to <span class=s1>&#39;cert.pem&#39;</span>
<span class=nt>-----</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>eg, YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org

Please enter the following <span class=s1>&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class=o>[]</span>:SOME PASSWORD
An optional company name <span class=o>[]</span>:Another Name</code></pre></div></div><div class=paragraph><p>Ввод после приглашения "Common Name" содержит имя домена. Здесь вводится имя сервера для верификации; помещение в это поле чего-либо кроме этого имени приведет к созданию бесполезного сертификата. Доступны и другие параметры, например срок действия, альтернативные алгоритмы шифрования и т.д. Полный список находится на странице справочного руководства <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a>.</p></div><div class=paragraph><p>В текущем каталоге, из которого была вызвана вышеуказанная команда, должны появиться два файла. Файл <span class=filename>req.pem</span> с запросом на сертификацию может быть послан в центр выдачи сертификатов, который проверит введённые вами подтверждающие данные, подпишет запрос и возвратит сертификат вам. Второй созданный файл будет иметь название <span class=filename>cert.pem</span> и содержать приватный сертификационный ключ, который необходимо тщательно защищать; если он попадёт в руки посторонних лиц, то может быть использован для имитации лично вас (или вашего сервера).</p></div><div class=paragraph><p>Когда подпись CA не требуется, может быть создан самоподписанный сертификат. Сначала создайте ключ RSA:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl dsaparam -rand -genkey -out myRSA.key 1024</span></code></pre></div></div><div class=paragraph><p>Теперь создайте ключ CA:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl gendsa -des3 -out myca.key myRSA.key</span></code></pre></div></div><div class=paragraph><p>Используйте этот ключ при создании сертификата:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -x509 -days 365 -key myca.key -out new.crt</span></code></pre></div></div><div class=paragraph><p>В каталоге должно появиться два новых файла: подпись сертификата, <span class=filename>myca.key</span> и сам сертификат, <span class=filename>new.crt</span>. Они должны быть помещены в каталог, доступный для чтения только <code>root</code>, желательно внутри <span class=filename>/etc</span>. Права на каталог можно изменить <code>chmod</code> с параметрами 0700.</p></div></div><div class=sect2><h3 id=_использование_сертификатов_пример>14.9.2. Использование сертификатов, пример<a class=anchor href=#_использование_сертификатов_пример></a></h3><div class=paragraph><p>Итак, что могут сделать эти файлы? Хорошим применением может стать шифрование соединений для SendmailMTA. Это сделает ненужным использование простой текстовой аутентификации для тех, кто отправляет почту через локальный MTA.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Это не лучшее из возможных использований, поскольку некоторые MUA выдадут ошибку, если сертификат не установлен локально. Обратитесь к поставляемой с программой документации за информацией по установке сертификата.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Следующие строки должны быть помещены в локальный файл <span class=filename>.mc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dnl SSL Options
define(`confCACERT_PATH&#39;,`/etc/certs&#39;)dnl
define(`confCACERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_CERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_KEY&#39;,`/etc/certs/myca.key&#39;)dnl
define(`confTLS_SRV_OPTIONS&#39;, `V&#39;)dnl</pre></div></div><div class=paragraph><p>Где <span class=filename>/etc/certs/</span> это каталог для локального хранения сертификата и ключей. После настройки необходимо собрать локальный файл <span class=filename>.cf</span>. Это легко сделать, набрав <code>make</code><span class=parameter>install</span> в каталоге <span class=filename>/etc/mail</span>. Затем выполните команду <code>make</code><span class=parameter>restart</span>, которая должна запустить даемон Sendmail.</p></div><div class=paragraph><p>Если все пройдет нормально, в файле <span class=filename>/var/log/maillog</span> не появятся сообщения об ошибках и запустится процесс Sendmail.</p></div><div class=paragraph><p>Для проведения простого теста подключитесь к почтовому серверу программой <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># telnet example.com 25</span>
Trying 192.0.34.166...
Connected to example.com.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
220 example.com ESMTP Sendmail 8.12.10/8.12.10<span class=p>;</span> Tue, 31 Aug 2004 03:41:22 <span class=nt>-0400</span> <span class=o>(</span>EDT<span class=o>)</span>
ehlo example.com
250-example.com Hello example.com <span class=o>[</span>192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 example.com closing connection
Connection closed by foreign host.</code></pre></div></div><div class=paragraph><p>Если в выводе появилась строка "STARTTLS", все работает правильно.</p></div></div></div></div><div class=sect1><h2 id=ipsec>14.10. VPN через IPsec<a class=anchor href=#ipsec></a></h2><div class=sectionbody><div class=paragraph><p>Создание VPN между двумя сетями, соединенными через интернет, с использованием шлюзов FreeBSD.</p></div><div class=sect2><h3 id=_принципы_работы_ipsec>14.10.1. Принципы работы IPsec<a class=anchor href=#_принципы_работы_ipsec></a></h3><div class=paragraph><p>Этот раздел послужит вам руководством по настройке IPsec и его использованию в среде FreeBSD и Microsoft® Windows® 2000/XP, соединяемых безопасным способом. Для настройки IPsec необходимо ознакомиться с процессом сборки ядра (<a href=../kernelconfig/#kernelconfig>Настройка ядра FreeBSD</a>).</p></div><div class=paragraph><p><em>IPsec</em> это протокол, расположенный поверх слоя Internet Protocol (IP). Он позволяет двум или более хостам связываться защищенным способом (отсюда и название протокола). "Сетевой стек" FreeBSD IPsec основан на реализации <a href=http://www.kame.net/>KAME</a>, поддерживающей оба семейства протоколов, IPv4 и IPv6.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD содержит "аппаратно поддерживаемый" стек IPsec, известный как "Fast IPsec", заимствованный из OpenBSD. Для оптимизации производительности IPsec он задействует криптографическое оборудование (когда оно доступно) через подсистему <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=4&amp;format=html">crypto(4)</a>. Это новая подсистема и она не поддерживает всех возможностей, доступных в KAME версии IPsec. Для включения IPsec с аппаратной поддержкой необходимо добавить в файл настройки ядра следующий параметр:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options	  FAST_IPSEC  <span class=c># new IPsec (cannot define w/ IPSEC)</span></code></pre></div></div><div class=paragraph><p>Обратите внимание, что на данный момент невозможно использовать подсистему "Fast IPsec" вместе с KAME реализацией IPsec. Обратитесь к странице справочника <a href="https://man.freebsd.org/cgi/man.cgi?query=fast_ipsec&amp;sektion=4&amp;format=html">fast_ipsec(4)</a> за дальнейшей информацией.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Для того, чтобы применять к туннелям <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> межсетевые экраны, вам потребуется включить в ядро опцию <code>IPSEC_FILTERGIF</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_FILTERGIF  <span class=c>#filter ipsec packets from a tunnel</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>IPsec состоит из двух подпротоколов:</p></div><div class=ulist><ul><li><p><em>Encapsulated Security Payload (ESP)</em>, защищающей данные IP пакета от вмешательства третьей стороны путем шифрования содержимого с помощью симметричных криптографических алгоритмов (таких как Blowfish,3DES).</p></li><li><p><em>Authentication Header (AH)</em>, защищающий заголовок IP пакета от вмешательства третьей стороны и подделки путем вычисления криптографической контрольной суммы и хеширования полей заголовка IP пакета защищенной функцией хеширования. К пакету добавляется дополнительный заголовок с хэшем, позволяющий аутентификацию информации пакета.</p></li></ul></div><div class=paragraph><p>ESP и AH могут быть использованы вместе или по отдельности, в зависимости от обстоятельств.</p></div><div class=paragraph><p>IPsec может быть использован или для непосредственного шифрования трафика между двумя хостами (<em>транспортный режим</em>); или для построения "виртуальных туннелей" между двумя подсетями, которые могут быть использованы для защиты соединений между двумя корпоративными сетями (<em>туннельный режим</em>). Последний обычно называют <em>виртуальной частной сетью</em> (Virtual Private Network, VPN). За детальной информацией о подсистеме IPsec в FreeBSD обратитесь к странице справочника <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a>.</p></div><div class=paragraph><p>Для включения поддержки IPsec в ядре, добавьте следующие параметры к файлу настройки ядра:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC        <span class=c>#IP security</span>
options   IPSEC_ESP    <span class=c>#IP security (crypto; define w/ IPSEC)</span></code></pre></div></div><div class=paragraph><p>Если желательна поддержка отладки IPsec, должна быть также добавлена следующая строка:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_DEBUG  debug <span class=k>for </span>IP security</code></pre></div></div></div><div class=sect2><h3 id=_проблема>14.10.2. Проблема<a class=anchor href=#_проблема></a></h3><div class=paragraph><p>Не существует стандарта VPN. Они могут быть реализованы множеством различных технологий, каждая из которых имеет свои сильные и слабые стороны. Этот раздел представляет сценарий и стратегию реализации VPN для этого сценария.</p></div></div><div class=sect2><h3 id=_сценарий_две_сети_подключенных_к_интернет_работающие_как_одна>14.10.3. Сценарий: Две сети, подключенных к интернет, работающие как одна<a class=anchor href=#_сценарий_две_сети_подключенных_к_интернет_работающие_как_одна></a></h3><div class=paragraph><p>Исходные условия таковы:</p></div><div class=ulist><ul><li><p>Существует как минимум две сети</p></li><li><p>Внутри обеих сетей используется IP</p></li><li><p>Обе сети соединены через интернет через шлюз, работающий на FreeBSD.</p></li><li><p>У шлюза каждой из сетей есть как минимум один публичный IP адрес.</p></li><li><p>Внутренние IP адреса двух сетей могут быть публичными или приватными, не имеет значения. На шлюзе может работать NAT, если это необходимо.</p></li><li><p>Внутренние IP адреса двух сетей <em>не должны пересекаться</em>. Хотя вероятно теоретически возможно использование комбинации VPN технологии и NAT для настройки такой конфигурации, эта конфигурация будет кошмарна.</p></li></ul></div><div class=paragraph><p>Если две сети, которые вы пытаетесь соединить, используют один и тот же диапазон приватных адресов (например, обе используют <code>192.168.1.x</code>), номера в одной из сетей необходимо изменить.</p></div><div class=paragraph><p>Топология сети может выглядеть примерно так:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-network.png alt="ipsec network"></div></div><div class=paragraph><p>Заметьте, что здесь присутствуют два публичных IP-адреса. В дальнейшем для их обозначения будут использоваться буквы. Если вы увидите эти буквы, замените их на свои публичные IP адреса. Также обратите внимание, что у обеих шлюзов внутренний адрес заканчивается на .1 и диапазоны приватных адресов двух сетей различны (<code>192.168.1.x</code> и <code>192.168.2.x</code> соответственно). Все компьютеры локальных сетей настроены на использование в качестве шлюза по умолчанию компьютера с адресом, оканчивающимся на <code>.1</code>.</p></div><div class=paragraph><p>С сетевой точки зрения замысел в том, чтобы каждая сеть видела компьютеры из другой сети так, как если бы они были непосредственно подключены к тому же самому маршрутизатору - хотя и немного медленному маршрутизатору, иногда теряющему пакеты.</p></div><div class=paragraph><p>Это означает, что (например) компьютер <code>192.168.1.20</code> может запустить</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.34</pre></div></div><div class=paragraph><p>и это будет прозрачно работать. Компьютеры с Windows® должны видеть компьютеры в другой сети, просматривать сетевые ресурсы, и так далее, точно так же, как и для компьютеров в локальной сети.</p></div><div class=paragraph><p>И все это безопасным способом. Это означает, что трафик между сетями зашифрован.</p></div><div class=paragraph><p>Создание VPN между этими двумя сетями это многошаговый процесс. Этапы создания VPN таковы:</p></div><div class="olist arabic"><ol class=arabic><li><p>Создание "виртуального" сетевого подключения между двумя сетями через интернет. Тестирование подключения с помощью таких инструментов как <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>, чтобы убедиться, что оно работает.</p></li><li><p>Применение политики безопасности чтобы убедиться, что трафик между двумя сетями прозрачно шифруется и расшифровывается если необходимо. Тестирование с помощью таких инструментов как <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>, чтобы убедиться, что трафик шифруется.</p></li><li><p>Настройка дополнительных программ на шлюзах FreeBSD, чтобы компьютеры Windows® из одной сети видели компьютеры в другой через VPN.</p></li></ol></div><div class=sect3><h4 id=_шаг_1_создание_и_тестирование_виртуального_сетевого_подключения>14.10.3.1. Шаг 1: Создание и тестирование "виртуального" сетевого подключения<a class=anchor href=#_шаг_1_создание_и_тестирование_виртуального_сетевого_подключения></a></h4><div class=paragraph><p>Предположим, что вы работаете на шлюзе сети #1 (с публичным адресом <code>A.B.C.D</code>, приватным адресом <code>192.168.1.1</code>) и запускаете <code>ping 192.168.2.1</code>, т.е. на приватный адрес машины с IP адресом <code>W.X.Y.Z</code>. Что должно произойти, чтобы это сработало?</p></div><div class="olist arabic"><ol class=arabic><li><p>Шлюз должен знать, как достичь <code>192.168.2.1</code>. Другими словами, у него должен быть маршрут к <code>192.168.2.1</code>.</p></li><li><p>Приватные IP адреса, такие как диапазон <code>192.168.x</code> не адресуются в интернет. Каждый пакет, отправляемый на <code>192.168.2.1</code> должен быть "завернут" в другой пакет. Исходным адресом пакета должен быть <code>A.B.C.D</code>, а адресом назначения <code>W.X.Y.Z</code>. Этот процесс называется <em>инкапсуляцией</em>.</p></li><li><p>Как только этот пакет достигнет <code>W.X.Y.Z</code>, необходимо будет "декапсулировать" его и доставить к <code>192.168.2.1</code>.</p></li></ol></div><div class=paragraph><p>Как вы можете увидеть, это требует "туннеля" между двумя сетями. Два конца "туннеля" это IP адреса <code>A.B.C.D</code> и <code>W.X.Y.Z</code>. Туннель используется для передачи трафика с приватными IP адресами через интернет.</p></div><div class=paragraph><p>В FreeBSD этот туннель создается с помощью устройства generic interface, или <span class=filename>gif</span>. Как вы можете догадаться, интерфейс <span class=filename>gif</span> на каждом хосте должен быть настроен с четырьмя IP адресами; два для публичных IP адресов и два для приватных IP адресов.</p></div><div class=paragraph><p>В ядро обеих компьютеров FreeBSD должна быть встроена поддержка устройства gif. Вы можете сделать это, добавив строку:</p></div><div class="literalblock programlisting"><div class=content><pre>device gif</pre></div></div><div class=paragraph><p>к файлу настройки ядра на обеих компьютерах, с последующей компиляцией, установкой и перезагрузкой.</p></div><div class=paragraph><p>Настройка туннеля это двухшаговый процесс. Во-первых, необходимо задать сведения о внешнем (или публичном) IP адресе с помощью <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Затем о приватном IP адресе, также с помощью <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class=paragraph><p>На шлюзе сети #1 для настройки туннеля вам потребуется запустить следующие две команды.</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig gif0 A.B.C.D W.X.Y.Z
ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff</pre></div></div><div class=paragraph><p>На другом шлюзе подобные команды, но с IP адресами в обратном порядке.</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig gif0 W.X.Y.Z A.B.C.D
ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff</pre></div></div><div class=paragraph><p>Затем вы можете запустить:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig gif0</pre></div></div><div class=paragraph><p>для просмотра настройки. Например, на шлюзе сети #1 вы увидите:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0</span>
gif0: <span class=nv>flags</span><span class=o>=</span>8011&lt;UP,POINTTOPOINT,MULTICAST&gt; mtu 1280
inet 192.168.1.1 <span class=nt>--</span><span class=o>&gt;</span> 192.168.2.1 netmask 0xffffffff
physical address inet A.B.C.D <span class=nt>--</span><span class=o>&gt;</span> W.X.Y.Z</code></pre></div></div><div class=paragraph><p>Как вы можете видеть, был создан туннель между физическими адресами <code>A.B.C.D</code> и <code>W.X.Y.Z</code>, для туннелирования разрешен трафик между <code>192.168.1.1</code> и <code>192.168.2.1</code>.</p></div><div class=paragraph><p>Это также добавляет запись к таблице маршрутизации на обеих машинах, вы можете проверить запись командой <code>netstat -rn</code>. Вот вывод этой команды на шлюзе сети #1.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># netstat -rn</span>
Routing tables

Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...</code></pre></div></div><div class=paragraph><p>Как показывает значение поля "Flags", это маршрут к хосту, что означает, что каждый шлюз знает, как достичь другого шлюза, но не знает как достичь остальной части соответствующей сети. Эта проблема будет быстро решена.</p></div><div class=paragraph><p>Вероятно, на обеих машинах запущен брандмауэр. VPN должен обходить его. Вы можете разрешить весь трафик между двумя сетями, или включить правила, защищающие каждый конец соединения от другого.</p></div><div class=paragraph><p>Это сильно упрощает тестирование настройки брандмауэра, если вы разрешаете весь трафик через VPN. Вы всегда можете усилить защиту позже. Если вы используете на шлюзах <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>, команда вроде этой</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow ip from any to any via gif0</pre></div></div><div class=paragraph><p>разрешит весь трафик между двумя концами VPN без влияния на другие правила брандмауэра. Очевидно, вам потребуется запустить эту команду на обеих шлюзах.</p></div><div class=paragraph><p>Этого достаточно для включения ping с одного шлюза на другой. На <code>192.168.1.1</code>, вы сможете запустить</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>и получить ответ, и аналогично на другом шлюзе.</p></div><div class=paragraph><p>Однако, машины в другой сети пока недоступны. Это из-за маршрутизации - хотя шлюзы знают, как связаться друг с другом, они не знают, как связаться с сетью за другим шлюзом.</p></div><div class=paragraph><p>Для решения этой проблемы вы должны добавить статический маршрут на каждом шлюзе. Команда на первом шлюзе будет выглядеть так:</p></div><div class="literalblock programlisting"><div class=content><pre>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00</pre></div></div><div class=paragraph><p>Она говорит "Для достижения хостов в сети <code>192.168.2.0</code>, отправляйте пакеты хосту <code>192.168.2.1`". Вам потребуется запустить похожую команду на другом шлюзе, но с адресами `192.168.1.x</code>.</p></div><div class=paragraph><p>IP трафик с хостов в одной сети теперь может достичь хосты в другой сети.</p></div><div class=paragraph><p>Теперь создано две трети VPN между двумя сетями, поскольку это "виртуальная (virtual)""сеть (network)". Она еще не приватная (private). Вы можете протестировать ее с помощью <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> и <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>. Войдите на шлюз и запустите</p></div><div class="literalblock programlisting"><div class=content><pre>tcpdump dst host 192.168.2.1</pre></div></div><div class=paragraph><p>В другой сессии на этом же хосте запустите</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>Вы увидите примерно такие строки:</p></div><div class="literalblock programlisting"><div class=content><pre>16:10:24.018080 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply</pre></div></div><div class=paragraph><p>Как вы видите, ICMP сообщения пересылаются вперед и назад незашифрованными. Если вы использовали с <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> параметр <code>-s</code> для получения большего объема данных пакета, то увидите больше информации.</p></div><div class=paragraph><p>Конечно же это неприемлемо. В следующем разделе мы обсудим защиту соединения между двумя сетями, так что весь трафик будет автоматически шифроваться.</p></div><div class=ulist><div class=title>Резюме:</div><ul><li><p>Настройте оба ядра с "device gif".</p></li><li><p>Отредактируйте <span class=filename>/etc/rc.conf</span> на шлюзе #1 и добавьте следующие строки (подставляя IP адреса где необходимо).</p><div class="literalblock programlisting"><div class=content><pre>gifconfig_gif0=&#34;A.B.C.D W.X.Y.Z&#34;
ifconfig_gif0=&#34;inet 192.168.1.1 192.168.2.1 netmask 0xffffffff&#34;
static_routes=&#34;vpn&#34;
route_vpn=&#34;192.168.2.0 192.168.2.1 netmask 0xffffff00&#34;</pre></div></div></li><li><p>Отредактируйте скрипт брандмауэра (<span class=filename>/etc/rc.firewall</span>, или подобный) на обеих хостах и добавьте</p><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow ip from any to any via gif0</pre></div></div></li><li><p>Выполните соответствующие изменения в <span class=filename>/etc/rc.conf</span> на шлюзе #2, меняя порядок IP адресов.</p></li></ul></div></div><div class=sect3><h4 id=_шаг_2_защита_соединения>14.10.3.2. Шаг 2: Защита соединения<a class=anchor href=#_шаг_2_защита_соединения></a></h4><div class=paragraph><p>Для защиты соединения мы будем использовать IPsec. IPsec предоставляет хостам механизм определения ключа для шифрования и для последующего использования этого ключа для шифрования данных между двумя хостами.</p></div><div class=paragraph><p>Здесь будут рассмотрены два аспекта настройки.</p></div><div class="olist arabic"><ol class=arabic><li><p>У хостов должен быть способ согласования используемого алгоритма шифрования. Как только хосты договорятся об этом, можно говорить об установленном между ними "безопасном соединении".</p></li><li><p>Должен быть механизм определения, какой трафик необходимо шифровать. Конечно, вам не требуется шифровать весь исходящий трафик - достаточно шифровать только трафик, идущий через VPN. Правила, определяющие то, какой трафик необходимо шифровать, называются "политикой безопасности".</p></li></ol></div><div class=paragraph><p>Безопасное соединение и политика безопасности поддерживаются ядром, и могут быть изменены программами пользователя. Однако перед тем, как вы сможете сделать это, необходимо настроить поддержку протоколов IPsec и Encapsulated Security Payload (ESP) в ядре. Это делается добавлением в настройку ядра параметров:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPSEC
options IPSEC_ESP</pre></div></div><div class=paragraph><p>с последующим перекомпилированием, переустановкой и перезагрузкой. Как и прежде вам потребуется сделать это с ядрами на обеих шлюзах.</p></div><div class=paragraph><p>При настройке параметров безопасности (security associations) у вас есть два варианта. Вы можете настроить их вручную для обеих хостов, задав алгоритм шифрования, ключи для шифрования и так далее, или использовать даемоны, реализующие Internet Key Exchange protocol (IKE), который сделает это за вас.</p></div><div class=paragraph><p>Рекомендуется последнее. Помимо прочего, этот способ более прост.</p></div><div class=paragraph><p>Редактирование и отображение политики безопасности выполняется с помощью <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. По аналогии, <code>setkey</code> используется для настройки таблиц политики безопасности ядра так же, как <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> используется для настройки таблиц маршрутизации ядра. <code>setkey</code> также может отображать текущие параметры безопасности, и продолжая аналогию дальше, это соответствует <code>netstat -r</code>.</p></div><div class=paragraph><p>Существует множество даемонов для управления параметрами безопасности в FreeBSD. Здесь будет описано использование одного из них, racoon - он доступен в составе порта <a class=package href=https://cgit.freebsd.org/ports/tree/security/ipsec-tools/>security/ipsec-tools</a> в Коллекции Портов FreeBSD.</p></div><div class=paragraph><p>Даемон racoon должен работать на обеих шлюзах. На каждом из хостов он настраивается с IP адресом другого конца VPN, и секретным ключом (по вашему выбору, должен быть одним и тем же на обеих шлюзах).</p></div><div class=paragraph><p>Эти два даемона подключаются друг к другу, подтверждают, что они именно те, за кого себя выдают (используя секретный ключ, заданный вами). Затем даемоны генерируют новый секретный ключ и используют его для шифрования трафика через VPN. Они периодически изменяют этот ключ, так что даже если атакующий сломает один из ключей (что теоретически почти невозможно) это не даст ему слишком много - он сломал ключ, который два даемона уже сменили на другой.</p></div><div class=paragraph><p>Настройки racoon сохраняются в файле <span class=filename>${PREFIX}/etc/racoon</span>. Этот файл не требует слишком больших изменений. Другим компонентом настройки racoon, который потребуется изменить, является "предварительный ключ".</p></div><div class=paragraph><p>В настройке по умолчанию racoon ищет его в файле <span class=filename>${PREFIX}/etc/racoon/psk.txt</span>. Необходимо отметить, что предварительный ключ <em>не</em> используется для шифрования трафика через VPN соединение это просто маркер, позволяющий управляющим ключами даемонам доверять друг другу.</p></div><div class=paragraph><p><span class=filename>psk.txt</span> содержит строку для каждого удаленного сервера, с которым происходит соединение. В этом примере два сервера, каждый файл <span class=filename>psk.txt</span> будет содержать одну строку (каждый конец VPN общается только с другим концом.</p></div><div class=paragraph><p>На шлюзе #1 эта строка будет выглядеть примерно так:</p></div><div class="literalblock programlisting"><div class=content><pre>W.X.Y.Z            secret</pre></div></div><div class=paragraph><p>То есть <em>публичный</em> IP-адрес противоположной стороны, пробел и текстовая строка c секретной фразой. Конечно, вам не стоит использовать в качестве ключевой фразы слово "secret" — здесь применяются обычные правила выбора паролей.</p></div><div class=paragraph><p>На шлюзе #2 строка будет выглядеть примерно так:</p></div><div class="literalblock programlisting"><div class=content><pre>A.B.C.D            secret</pre></div></div><div class=paragraph><p>То есть публичный IP адрес удаленной стороны и та же секретная фраза. Перед запуском racoon режим доступа к файлу <span class=filename>psk.txt</span> должен быть установлен в <code>0600</code> (т.е. запись и чтение только для <code>root</code>).</p></div><div class=paragraph><p>Вы должны запустить racoon на обоих шлюзах. Вам также потребуется добавить правила для включения IKE трафика, передающегося по UDP через порт ISAKMP (Internet Security Association Key Management Protocol). Опять же, они должны быть расположены насколько возможно ближе к началу набора правил.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp</pre></div></div><div class=paragraph><p>Как только racoon будет запущен, вы можете попробовать выполнить ping с одного шлюза на другой. Соединение все еще не зашифровано, но racoon установит параметры безопасности между двумя хостами - это может занять время и вы можете заметить небольшую задержку перед началом ответа команды ping.</p></div><div class=paragraph><p>Как только параметры безопасности установлены, вы можете просмотреть их используя <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. Запустите</p></div><div class="literalblock programlisting"><div class=content><pre>setkey -D</pre></div></div><div class=paragraph><p>на любом из хостов для просмотра информации о параметрах безопасности.</p></div><div class=paragraph><p>Это одна сторона проблемы. Другая сторона это настройка политики безопасности.</p></div><div class=paragraph><p>Для создания разумной политики безопасности давайте вспомним, что уже было настроено. Это рассмотрение относится к обеим концам соединения.</p></div><div class=paragraph><p>Каждый отправляемый IP пакет имеет заголовок, содержащий информацию о пакете. Заголовок включает IP адреса источника и назначения. Как мы уже знаем, приватные IP адреса, такие как <code>192.168.x.y</code>, не могут появиться в интернет. Они должны быть сначала включены внутрь другого пакета. В этом пакете приватные IP адреса источника и назначения заменяются публичными IP адресами.</p></div><div class=paragraph><p>То есть исходящий пакет, который выглядит примерно так:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-out-pkt.png alt="ipsec out pkt"></div></div><div class=paragraph><p>будет инкапсулирован в другой пакет, выглядящий примерно так:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-encap-pkt.png alt="ipsec encap pkt"></div></div><div class=paragraph><p>Этой инкапсуляцией занимается устройство <span class=filename>gif</span>. Как вы можете видеть, теперь у пакета есть реальный IP адрес, исходный пакет был включен в этот пакет в виде данных, которые передаются через интернет.</p></div><div class=paragraph><p>Конечно, мы хотим зашифровать весь трафик между VPN. Вы можете сформулировать это на словах так:</p></div><div class=paragraph><p>"Если пакет отправляется с <code>A.B.C.D</code>, и предназначен для <code>W.X.Y.Z</code>, расшифровать его, используя необходимые параметры безопасности."</p></div><div class=paragraph><p>"Если пакет отправляется с <code>W.X.Y.Z</code>, и предназначен для <code>A.B.C.D</code>, расшифровать его, используя необходимые параметры безопасности."</p></div><div class=paragraph><p>Это похоже на желаемое, но не совсем то. Если вы сделаете это, весь трафик от и к <code>W.X.Y.Z</code>, даже если он не является частью VPN, будет зашифрован. Правильная политика такова:</p></div><div class=paragraph><p>"Если пакет отправляется с <code>A.B.C.D</code>, в нем инкапсулирован другой пакет и адрес назначения <code>W.X.Y.Z</code>, зашифровать его, используя необходимые параметры безопасности."</p></div><div class=paragraph><p>"Если пакет отправляется с <code>W.X.Y.Z</code>, в нем инкапсулирован другой пакет и адрес назначения <code>A.B.C.D</code>, зашифровать его, используя необходимые параметры безопасности."</p></div><div class=paragraph><p>Тонкое, но необходимое различие.</p></div><div class=paragraph><p>Политика безопасности также устанавливается с использованием <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. В <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> предусмотрен язык определения политики <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. Вы можете или ввести инструкции по настройке со стандартного ввода, или использовать параметр <code>-f</code> для задания файла, содержащего эти инструкции.</p></div><div class=paragraph><p>Настройка на шлюзе #1 (где есть публичный IP адрес <code>A.B.C.D</code>) для включения шифрования всего предназначенного <code>W.X.Y.Z</code> трафика:</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div><div class=paragraph><p>Поместите эти команды в файл (например, <span class=filename>/etc/ipsec.conf</span>) и запустите</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -f /etc/ipsec.conf</span></code></pre></div></div><div class=paragraph><p><code>spdadd</code> указывает <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> добавить правило к базе данных политики безопасности. Остальная часть строки указывает какие пакеты будут соответствовать политике. <code>A.B.C.D/32</code> и <code>W.X.Y.Z/32</code> это IP адреса и сетевые маски, определяющие сети или хосты, к которым будет применяться данная политика. В данном случае мы хотим применить их к трафику между этими двумя хостами. Параметр <code>ipencap</code> сообщает ядру, что эта политика должна применяться только к пакетам, инкапсулирующим другие пакеты. Параметр <code>-P out</code> сообщает, что эта политика применяется к исходящим пакетам, и <code>ipsec</code> - то, что пакеты будут зашифрованы.</p></div><div class=paragraph><p>Оставшаяся часть строки определяет, как эти пакеты будут зашифрованы. Будет использоваться протокол <code>esp</code>, а параметр <code>tunnel</code> показывает, что пакет в дальнейшем будет инкапсулирован в IPsec пакет. Повторное использование <code>A.B.C.D</code> и <code>W.X.Y.Z</code> предназначено для выбора используемых параметров безопасности, и наконец параметр <code>require</code> разрешает шифрование пакетов, попадающих под это правило.</p></div><div class=paragraph><p>Это правило соответствует только исходящим пакетам. Вам потребуется похожее правило, соответствующее входящим пакетам.</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</pre></div></div><div class=paragraph><p>Обратите внимание, что вместо <code>in</code> используется <code>out</code> и IP адреса переставлены.</p></div><div class=paragraph><p>Другому шлюзу (с публичным IP адресом <code>W.X.Y.Z</code>) потребуются похожие правила.</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div><div class=paragraph><p>Наконец, вам потребуется добавить правила к брандмауэру для включения прохождения пакетов ESP и IPENCAP в обе стороны. На обеих хостах потребуется добавить следующие правила:</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</pre></div></div><div class=paragraph><p>Поскольку правила симметричны, можно использовать их без изменения на обеих хостах</p></div><div class=paragraph><p>Исходящие пакеты теперь будут выглядеть примерно так:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-crypt-pkt.png alt="ipsec crypt pkt"></div></div><div class=paragraph><p>Когда эти пакеты будут получены на удаленном конце VPN соединения, они будут расшифрованы (используя параметры безопасности, о которых договорился racoon). Затем они будут переданы интерфейсу <span class=filename>gif</span>, который "развернет" второй слой, оставив пакет с внутренними адресами, который сможет попасть во внутреннюю сеть.</p></div><div class=paragraph><p>Вы можете проверить безопасность тем же <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>, который использовался ранее. Сначала войдите на шлюз <code>A.B.C.D</code> и запустите:</p></div><div class="literalblock programlisting"><div class=content><pre>tcpdump dst host 192.168.2.1</pre></div></div><div class=paragraph><p>В другой сессии на том же хосте запустите</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>В этот момент вы должны увидеть примерно это:</p></div><div class="literalblock programlisting"><div class=content><pre>XXX tcpdump output</pre></div></div><div class=paragraph><p>Теперь, как видите, <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> показывает ESP пакеты. Если вы попытаетесь просмотреть их с параметром <code>-s</code>, то вероятно увидите нечто непонятное, поскольку применяется шифрование.</p></div><div class=paragraph><p>Поздравляем. Вы только что настроили VPN между двумя удаленными сетями.</p></div><div class=ulist><div class=title>Резюме</div><ul><li><p>Настройте оба ядра с:</p><div class="literalblock programlisting"><div class=content><pre>options IPSEC
options IPSEC_ESP</pre></div></div></li><li><p>Установите <a class=package href=https://cgit.freebsd.org/ports/tree/security/ipsec-tools/>security/ipsec-tools</a>. Отредактируйте <span class=filename>${PREFIX}/etc/racoon/psk.txt</span> на обеих шлюзах, добавив запись для каждого IP адреса удаленного хоста и секретный ключ, который будет известен им обеим. Убедитесь, что режим доступа к файлу 0600.</p></li><li><p>Добавьте к <span class=filename>/etc/rc.conf</span> на каждом хосте следующие строки:</p><div class="literalblock programlisting"><div class=content><pre>ipsec_enable=&#34;YES&#34;
ipsec_file=&#34;/etc/ipsec.conf&#34;</pre></div></div></li><li><p>Создайте <span class=filename>/etc/ipsec.conf</span> на каждом хосте с необходимыми строками spdadd. На шлюзе #1 он будет таким:</p><div class="literalblock programlisting"><div class=content><pre>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;</pre></div></div><div class=paragraph><p>А на шлюзе #2 таким:</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div></li><li><p>Добавьте правила к брандмауэрам обеих хостов для включения IKE, ESP и IPENCAP трафика:</p><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</pre></div></div></li></ul></div><div class=paragraph><p>Двух приведенных шагов должно быть достаточно для настройки и включения VPN. Машины в каждой сети смогут обращаться друг к другу по IP адресам, и весь трафик через соединение будет автоматически надежно зашифрован.</p></div></div></div></div></div><div class=sect1><h2 id=openssh>14.11. OpenSSH<a class=anchor href=#openssh></a></h2><div class=sectionbody><div class=paragraph><p>OpenSSH это набор сетевых инструментов, используемых для защищенного доступа к удаленным компьютерам. Он может быть использован в качестве непосредственной замены <code>rlogin</code>, <code>rsh</code>, <code>rcp</code> и <code>telnet</code>. Кроме того, через SSH могут быть безопасно туннелированы и/или перенаправлены произвольные TCP/IP соединения. OpenSSH шифрует весь трафик, эффективно предотвращая кражу данных, перехват соединения и другие сетевые атаки.</p></div><div class=paragraph><p>OpenSSH поддерживается проектом OpenBSD, он основан на SSH v1.2.12 со всеми последними исправлениями и обновлениями, совместим с протоколами SSH версий 1 и 2.</p></div><div class=sect2><h3 id=_преимущества_использования_openssh>14.11.1. Преимущества использования OpenSSH<a class=anchor href=#_преимущества_использования_openssh></a></h3><div class=paragraph><p>Обычно при использовании <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> или <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a> данные пересылаются по сети в незашифрованной форме. Перехватчик пакетов в любой точке сети между клиентом и сервером может похитить информацию о пользователе/пароле или данные, передаваемые через соединение. Для предотвращения этого OpenSSH предлагает различные методы шифрования.</p></div></div><div class=sect2><h3 id=_включение_sshd>14.11.2. Включение sshd<a class=anchor href=#_включение_sshd></a></h3><div class=paragraph><p>В FreeBSD даемон sshd должен быть разрешен в процессе инсталляции. За запуск ответственна следующая строка в файле <span class=filename>rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>При следующей загрузке системы будет запущен <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>, даемон для OpenSSH. Вы можете также воспользоваться скриптом <span class=filename>/etc/rc.d/sshd</span> системы <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> для запуска OpenSSH:</p></div><div class="literalblock programlisting"><div class=content><pre>/etc/rc.d/sshd start</pre></div></div></div><div class=sect2><h3 id=_ssh_клиент>14.11.3. SSH клиент<a class=anchor href=#_ssh_клиент></a></h3><div class=paragraph><p>Утилита <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> работает подобно <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ssh user@example.com</span>
Host key not found from the list of known hosts.
Are you sure you want to <span class=k>continue </span>connecting <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>? <span class=nb>yes
</span>Host <span class=s1>&#39;example.com&#39;</span> added to the list of known hosts.
user@example.com<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>Вход продолжится так же, как если бы сессия была инициирована с использованием <code>rlogin</code> или <code>telnet</code>. SSH использует систему опознавательных ключей для проверки подлинности сервера при подключении клиента. Пользователю предлагается <code>yes</code> только при первом подключении. Дальнейшие попытки входа предваряются проверкой сохраненного ключа сервера. SSH клиент сообщит вам, если сохраненный ключ будет отличаться от только что полученного. Ключи серверов сохраняются в <span class=filename>~/.ssh/known_hosts</span>, или в <span class=filename>~/.ssh/known_hosts2</span> для SSH v2.</p></div><div class=paragraph><p>По умолчанию современные серверы OpenSSH настроены на приём только соединений SSH v2. Клиент будет использовать версию 2 там, где это возможно, а затем версию 1. Также, клиент можно заставить использовать конкретную версию при помощи опций <code>-1</code> и <code>-2</code> для указания соответствующей версии протокола. Версия 1 поддерживается ради совместимости со старыми серверами.</p></div></div><div class=sect2><h3 id=_безопасное_копирование>14.11.4. Безопасное копирование<a class=anchor href=#_безопасное_копирование></a></h3><div class=paragraph><p>Команда <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> работает подобно <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>; она копирует файл с удаленного компьютера, но делает это безопасным способом.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  scp user@example.com:/COPYRIGHT COPYRIGHT</span>
user@example.com<span class=s1>&#39;s password: *******
COPYRIGHT            100% |*****************************|  4735       00:00
#</span></code></pre></div></div><div class=paragraph><p>Поскольку в предыдущем примере ключ сервера уже был сохранен, в этом примере он проверяется при использовании <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>.</p></div><div class=paragraph><p>Параметры, передаваемые <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, похожи на параметры <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a>, с файлом или файлами в качестве первого аргумента и приемником копирования во втором. Поскольку файлы передаются по сети через SSH, один или более аргументов принимают форму <code>user@host:&lt;path_to_remote_file></code>.</p></div></div><div class=sect2><h3 id=_настройка>14.11.5. Настройка<a class=anchor href=#_настройка></a></h3><div class=paragraph><p>Системные файлы настройки для даемона и клиента OpenSSH расположены в каталоге <span class=filename>/etc/ssh</span>.</p></div><div class=paragraph><p>Файл <span class=filename>ssh_config</span> используется для настройки клиента, а <span class=filename>sshd_config</span> для даемона.</p></div><div class=paragraph><p>Кроме того, параметры <code>sshd_program</code> (по умолчанию <span class=filename>/usr/sbin/sshd</span>), и <code>sshd_flags</code><span class=filename>rc.conf</span> дают дополнительные возможности настройки.</p></div></div><div class=sect2><h3 id=ssh-keygen>14.11.6. ssh-keygen<a class=anchor href=#ssh-keygen></a></h3><div class=paragraph><p>Вместо использования паролей, с помощью <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> можно создать ключи DSA или RSA, которыми пользователи могут аутентифицироваться:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-keygen <span class=nt>-t</span> dsa
Generating public/private dsa key pair.
Enter file <span class=k>in </span>which to save the key <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>:
Created directory <span class=s1>&#39;/home/user/.ssh&#39;</span><span class=nb>.</span>
Enter passphrase <span class=o>(</span>empty <span class=k>for </span>no passphrase<span class=o>)</span>:
Enter same passphrase again:
Your identification has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.
Your public key has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> создаст пару публичного и приватного ключей, используемых для аутентификации. Приватный ключ сохраняется в <span class=filename>~/.ssh/id_dsa</span> или <span class=filename>~/.ssh/id_rsa</span>, а публичный в <span class=filename>~/.ssh/id_dsa.pub</span> или <span class=filename>~/.ssh/id_rsa.pub</span> (для ключей DSA и RSA соответственно). Для включения аутентификации по ключам публичный ключ должен быть помещен в файл <span class=filename>~/.ssh/authorized_keys</span> на удаленном компьютере.</p></div><div class=paragraph><p>Это позволяет соединяться с удаленным компьютером с помощью SSH-ключей вместо паролей.</p></div><div class=paragraph><p>Если при генерации ключей был использован пароль, каждый раз при использовании приватного ключа он будет запрашиваться у пользователя. Для того, чтобы избежать непрерывного набора кодовой фразы, можно использовать утилиту <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>, как описано в разделе <a href=#security-ssh-agent>Утилиты ssh-agent и ssh-add</a> ниже.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Параметры и имена файлов могут различаться для разных версий OpenSSH, установленных в системе, для решения проблем обратитесь к странице справочника <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=security-ssh-agent>14.11.7. Утилиты ssh-agent и ssh-add<a class=anchor href=#security-ssh-agent></a></h3><div class=paragraph><p>Утилиты <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> и <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> позволяют сохранять ключи SSH в памяти, чтобы не набирать кодовые фразы при каждом использовании ключа.</p></div><div class=paragraph><p>Утилита <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> обеспечивает процесс аутентификации загруженными в нее секретными ключами; для этого утилита <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> должна запустить внешний процесс. В самом простом случае это может быть шелл-процесс; в чуть более продвинутом - оконный менеджер.</p></div><div class=paragraph><p>Для использования <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> совместно с шеллом, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> должен быть запущен с именем этого шелла в качестве аргумента. После этого в его память при помощи утилиты <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> могут быть добавлены необходимые ключи; при этом будут запрошены соответствующие кодовые фразы. Добавленные ключи могут затем использоваться для <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> на машины, на которых установлены соответствующие публичные ключи:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-agent csh
% ssh-add
Enter passphrase <span class=k>for</span> /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>
%</code></pre></div></div><div class=paragraph><p>Для того чтобы использовать <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> в X11, вызов <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>должен быть помещен в файл <span class=filename>~/.xinitrc</span>. Это обеспечит поддержкой <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> все программы, запущенные в X11. Файл <span class=filename>~/.xinitrc</span> может выглядеть, например, так:</p></div><div class="literalblock programlisting"><div class=content><pre>exec ssh-agent startxfce4</pre></div></div><div class=paragraph><p>При этом будет запущен <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>, который, в свою очередь, вызовет запуск XFCE, при каждом старте X11. После запуска X11, выполните команду <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> для добавления ваших SSH-ключей.</p></div></div><div class=sect2><h3 id=security-ssh-tunneling>14.11.8. Туннелирование SSH<a class=anchor href=#security-ssh-tunneling></a></h3><div class=paragraph><p>OpenSSH поддерживает возможность создания туннеля для пропуска соединения по другому протоколу через защищенную сессию.</p></div><div class=paragraph><p>Следующая команда указывает <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> создать туннель для telnet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5023:localhost:23 user@foo.example.com
%</code></pre></div></div><div class=paragraph><p>Команда <code>ssh</code> используется со следующими параметрами:</p></div><div class=dlist><dl><dt class=hdlist1><code>-2</code></dt><dd><p>Указывает <code>ssh</code> использовать версию 2 протокола (не используйте этот параметр, если работаете со старыми SSH серверами).</p></dd><dt class=hdlist1><code>-N</code></dt><dd><p>Означает использование в не-командном режиме, только для туннелирования. Если этот параметр опущен, <code>ssh</code> запустит обычную сессию.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Указывает <code>ssh</code> запускаться в фоновом режиме.</p></dd><dt class=hdlist1><code>-L</code></dt><dd><p>Означает локальный туннель в стиле <em>localport:remotehost:remoteport</em>.</p></dd><dt class=hdlist1><code>user@foo.example.com</code></dt><dd><p>Удаленный сервер SSH.</p></dd></dl></div><div class=paragraph><p>Туннель SSH создается путем создания прослушивающего сокета на определенном порту <code>localhost</code>. Затем все принятые на локальном хосту/порту соединения переправляются через SSH на определенный удаленный хост и порт.</p></div><div class=paragraph><p>В этом примере, порт <em>5023</em> на <code>localhost</code> перенаправляется на порт <em>23</em> на <code>localhost</code> удаленного компьютера. Поскольку <em>23</em> это порт telnet, будет создано защищенное соединение telnet через туннель SSH.</p></div><div class=paragraph><p>Этот метод можно использовать для любого числа небезопасных протоколов, таких как SMTP, POP3, FTP, и так далее.</p></div><div class=exampleblock><div class=title>Пример 1. Использование SSH для создания защищенного туннеля на SMTP</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com<span class=s1>&#39;s password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;</span>^]<span class=s1>&#39;.
220 mailserver.example.com ESMTP</span></code></pre></div></div><div class=paragraph><p>Этот метод можно использовать вместе с <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> и дополнительными пользовательскими учётными записями для создания более удобного автоматического SSH туннелирования. Ключи могут быть использованы вместо паролей, и туннели могут запускаться от отдельных пользователей.</p></div></div></div><div class=sect3><h4 id=_практические_примеры_ssh_туннелирования>14.11.8.1. Практические примеры SSH туннелирования<a class=anchor href=#_практические_примеры_ssh_туннелирования></a></h4><div class=sect4><h5 id=_защищенный_доступ_к_серверу_pop3>14.11.8.1.1. Защищенный доступ к серверу POP3<a class=anchor href=#_защищенный_доступ_к_серверу_pop3></a></h5><div class=paragraph><p>На работе находится SSH сервер, принимающий соединения снаружи. В этой же офисной сети находится почтовый сервер, поддерживающий протокол POP3. Сеть или сетевое соединение между вашим домом и офисом могут быть или не быть полностью доверяемыми. По этой причине вам потребуется проверять почту через защищенное соединение. Решение состоит в создании SSH соединения к офисному серверу SSH и туннелирование через него к почтовому серверу.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com<span class=s1>&#39;s password: ******</span></code></pre></div></div><div class=paragraph><p>Когда туннель включен и работает, вы можете настроить почтовый клиент для отправки запросов POP3 на <code>localhost</code>, порт 2110. Соединение будет безопасно переправлено через туннель на <code>mail.example.com</code>.</p></div></div><div class=sect4><h5 id=_прохождение_через_драконовский_брандмауэр>14.11.8.1.2. Прохождение через Драконовский Брандмауэр<a class=anchor href=#_прохождение_через_драконовский_брандмауэр></a></h5><div class=paragraph><p>Некоторые сетевые администраторы устанавливают на брандмауэрах драконовские правила, фильтруя не только входящие соединения, но и исходящие. Вам может быть разрешен доступ к удаленным компьютерам только по портам 22 и 80, для SSH и просмотра сайтов.</p></div><div class=paragraph><p>Вам может потребоваться доступ к другому (возможно, не относящемуся к работе) сервису, такому как Ogg Vorbis для прослушивания музыки. Если этот сервер Ogg Vorbis выдает поток не с портов 22 или 80, вы не сможете получить к нему доступ.</p></div><div class=paragraph><p>Решение состоит в создании SSH соединения с компьютером вне брандмауэра и использование его для туннелирования сервера Ogg Vorbis.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 8888:music.example.com:8000 user@unfirewalled-system.example.org
user@unfirewalled-system.example.org<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>Клиентскую программу теперь можно настроить на <code>localhost</code> порт 8888, который будет перенаправлен на <code>music.example.com</code> порт 8000, успешно обойдя брандмауэр.</p></div></div></div></div><div class=sect2><h3 id=_параметр_ограничения_пользователей_allowusers>14.11.9. Параметр ограничения пользователей <code>AllowUsers</code><a class=anchor href=#_параметр_ограничения_пользователей_allowusers></a></h3><div class=paragraph><p>Зачастую хорошие результаты даёт ограничение того, какие именно пользователи и откуда могут регистрироваться в системе. Задание параметра <code>AllowUsers</code> является хорошим способом добиться этого. К примеру, для разрешения регистрации только пользователю <code>root</code> с машины <code>192.168.1.32</code>, в файле <span class=filename>/etc/ssh/sshd_config</span> нужно указать нечто вроде следующего:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32</pre></div></div><div class=paragraph><p>Для разрешения регистрации пользователя <code>admin</code> из любой точки, просто укажите имя пользователя:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers admin</pre></div></div><div class=paragraph><p>Несколько пользователей должны перечислять в одной строке, как здесь:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32 admin</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Важно, чтобы бы перечислили всех пользователей, которые должны регистрироваться на этой машине; в противном случае они будут заблокированы.</p></div></td></tr></tbody></table></div><div class=paragraph><p>После внесения изменений в <span class=filename>/etc/ssh/sshd_config</span> вы должны указать <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> на повторную загрузку конфигурационных файлов, выполнив следующую команду:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd reload</span></code></pre></div></div></div><div class=sect2><h3 id=_дополнительная_литература>14.11.10. Дополнительная литература<a class=anchor href=#_дополнительная_литература></a></h3><div class=paragraph><p><a href=http://www.openssh.com/>OpenSSH</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh_config&amp;sektion=5&amp;format=html">ssh_config(5)</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp-server&amp;sektion=8&amp;format=html">sftp-server(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a></p></div></div></div></div><div class=sect1><h2 id=fs-acl>14.12. Списки контроля доступа файловой системы (ACL)<a class=anchor href=#fs-acl></a></h2><div class=sectionbody><div class=paragraph><p>В дополнение к другим расширениям файловой системы, таким как снимки (snapshots), FreeBSD 5.0 и более поздние версии системы предлагают защиту с помощью списков контроля доступа файловой системы (File System Access Control Lists, ACLs).</p></div><div class=paragraph><p>Списки контроля доступа расширяют стандартную модель прав UNIX® высоко совместимым (POSIX®.1e) способом. Эта возможность позволяет администратору получить преимущество от использования более интеллектуальной модели безопасности.</p></div><div class=paragraph><p>Для включения поддержки ACL в файловой системе UFS, следующая строка:</p></div><div class="literalblock programlisting"><div class=content><pre>options UFS_ACL</pre></div></div><div class=paragraph><p>должна быть добавлена в файл настройки ядра. Если параметр не добавлен, при попытке монтирования систем, поддерживающих ACL, появится предупреждающее сообщение. Этот параметр включен в ядро <span class=filename>GENERIC</span>. ACL основывается на дополнительных атрибутах, встроенных в файловую систему. Дополнительные атрибуты поддерживаются по умолчанию следующим поколением файловых систем UNIX®, UFS2.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Для включения дополнительных атрибутов в UFS1 требуется больше усилий по сравнению с UFS2. Производительность дополнительных атрибутов в UFS2 также существенно выше. По этим причинам для работы с списками контроля доступа предпочтительно использование UFS2</p></div></td></tr></tbody></table></div><div class=paragraph><p>ACL включаются во время монтирования флагом <code>acls</code>, который добавляется к <span class=filename>/etc/fstab</span>. Этот флаг также можно сделать постоянным с помощью <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>, изменив флаг ACL в заголовке файловой системы. Вообще говоря, использование флага в суперблоке предпочтительно по нескольким причинам:</p></div><div class=ulist><ul><li><p>Постоянный ACL флаг не может быть изменен путем перемонтирования системы (<a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> <code>-u</code>), а только через <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> и <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Это означает, что ACL нельзя включить на корневой файловой системе после загрузки. Это также означает, что вы не можете изменить флаг на используемой файловой системе.</p></li><li><p>Установка флага в суперблоке приводит к постоянному монтированию файловой системы с включенным ACL, даже если нет записи в <span class=filename>fstab</span> или при смене порядка устройств. Это предотвращает случайное монтирование файловой системы без ACL, которое может повлечь за собой проблемы с безопасностью.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Мы можем изменить поведение ACL для включения флага без полного перемонтирования, но считаем, что желательно исключить случайное монтирование без ACL, поскольку вы можете попасть в неприятную ситуацию, если включите ACL, затем выключите их, затем опять включите без сброса расширенных атрибутов. Обычно, как только вы включили ACL в файловой системе, они не должны быть выключены, поскольку получающаяся защита файлов может быть не совместима с той, что применяется пользователями системы, и повторное включение ACL может подключить предыдущие списки контроля доступа к файлам, права на которые изменены, что приведет к непредсказуемому поведению.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Файловые системы с включенными ACLs показывают знак <code>+</code> при просмотре прав на файлы. Например:</p></div><div class="literalblock programlisting"><div class=content><pre>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</pre></div></div><div class=paragraph><p>Здесь мы видим, что каталоги <span class=filename>directory1</span>, <span class=filename>directory2</span>, и <span class=filename>directory3</span> используют преимущества ACL. Каталог <span class=filename>public_html</span> их не использует.</p></div><div class=sect2><h3 id=_использование_acl>14.12.1. Использование ACL<a class=anchor href=#_использование_acl></a></h3><div class=paragraph><p>ACL файловой системы можно просмотреть с помощью утилиты <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a>. Например, для просмотра настроек ACL файла <span class=filename>test</span>, может использоваться команда:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% getfacl <span class=nb>test</span>
        <span class=c>#file:test</span>
        <span class=c>#owner:1001</span>
        <span class=c>#group:1001</span>
        user::rw-
        group::r--
        other::r--</code></pre></div></div><div class=paragraph><p>Для изменения ACL этого файла, вызовите утилиту <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a>. Выполните:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-k</span> <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>Параметр <code>-k</code> удалит все установленные на данный момент ACL из файла или файловой системы. Более предпочтительный метод это использование параметра <code>-b</code>, который оставит необходимые для работы ACL поля.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-m</span> u:trhodes:rwx,group:web:r--,o::--- <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>В вышеприведенной команде параметр <code>-m</code> использован для изменения записей ACL по умолчанию. Поскольку предустановленных записей не было (они были удалены предыдущей командой), эта команда восстановит параметры по умолчанию и задаст приведенные параметры. Имейте ввиду, при добавлении пользователя или группы, которых нет в системе, на <span class=filename>stdout</span> будет выведена ошибка <code>Invalid argument</code>.</p></div></div></div></div><div class=sect1><h2 id=security-portaudit>14.13. Мониторинг вопросов безопасности в ПО сторонних разработчиков<a class=anchor href=#security-portaudit></a></h2><div class=sectionbody><div class=paragraph><p>В последние годы в области информационной безопасности произошло много улучшений, касающихся выработки оценки уязвимости. Угроза проникновения в систему увеличивается вместе с установкой и настройкой утилит сторонних разработчиков, какой бы современной операционной системы это ни касалось.</p></div><div class=paragraph><p>Оценка уязвимости является ключевым фактором обеспечения защиты, и хотя для базового комплекта FreeBSD выпускаются бюллетени безопасности, но делать это для каждой сторонней утилиты выше возможностей участников Проекта FreeBSD. Существует способ смягчения уязвимостей программного обеспечения сторонних разработчиков и предупреждения администраторов об известных проблемах с безопасностью. Во FreeBSD существует утилита под названием Portaudit, которая служит исключительно этой цели.</p></div><div class=paragraph><p>Порт <a class=package href=https://cgit.freebsd.org/ports/tree/security/portaudit/>security/portaudit</a> обращается к базе данных, обновляемой и поддерживаемой Группой информационной безопасности FreeBSD и разработчиками портов, для получения информации об известных проблемах с защитой.</p></div><div class=paragraph><p>Для того, чтобы приступить к использованию Portaudit, необходимо установить его из Коллекции Портов:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/security/portaudit &amp;&amp; make install clean</span></code></pre></div></div><div class=paragraph><p>В процессе установки будут обновлены конфигурационные файлы для <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>, в которые будет добавлена выдача Portaudit при ежедневном её запуске. Проверьте, что ежедневные сообщения электронной почты, касающиеся безопасности, которые посылаются на адрес <code>root</code>, прочитываются. Другой дополнительной настройки больше не понадобится.</p></div><div class=paragraph><p>После установки администратор может обновить базу данных и посмотреть список известных уязвимостей в установленных пакетах при помощи команды</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -Fda</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>База данных будет автоматически обновлена при запуске <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>; таким образом, предыдущая команду можно полностью опустить. Она требуется только для следующих примеров.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Для аудита утилит сторонних разработчиков, установленных как часть Коллекции Портов, администратору достаточно запускать только следующую команду:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -a</span></code></pre></div></div><div class=paragraph><p>Утилита portaudit выдаст примерно следующее:</p></div><div class="literalblock programlisting"><div class=content><pre>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</pre></div></div><div class=paragraph><p>Перейдя в Web-браузере по показанному URL, администратор может получить более подробную информацию о показанной уязвимости. В неё войдёт перечисление версий, затронутых соответствующей версией порта FreeBSD, а также другие Web-сайты, которые могут содержать бюллетени безопасности.</p></div><div class=paragraph><p>Если описывать вкратце, то Portaudit является мощной и, при использовании вместе с портом Portupgrade, чрезвычайно полезной утилитой.</p></div></div></div><div class=sect1><h2 id=security-advisories>14.14. Сообщения безопасности FreeBSD<a class=anchor href=#security-advisories></a></h2><div class=sectionbody><div class=paragraph><p>Как многие и высококачественные операционные системы, FreeBSD публикует "Сообщения безопасности" ("Security Advisories"). Эти сообщения обычно отправляются по почте в списки рассылки, посвященные безопасности и публикуются в списке проблем только после выхода исправлений к соответствующим релизам. В этом разделе разъясняется, что такое сообщения безопасности, как их читать и какие меры принимать для исправления системы.</p></div><div class=sect2><h3 id=_как_выглядит_сообщение>14.14.1. Как выглядит сообщение?<a class=anchor href=#_как_выглядит_сообщение></a></h3><div class=paragraph><p>Сообщение безопасности FreeBSD выглядит подобно сообщению ниже, взятому из списка рассылки <a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>Список рассылки FreeBSD, посвящённый срочным сообщениям, связанным с безопасностью</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem<i class=conum data-value=1></i><b>(1)</b>

Category:       core<i class=conum data-value=2></i><b>(2)</b>
Module:         sys<i class=conum data-value=3></i><b>(3)</b>
Announced:      2003-09-23<i class=conum data-value=4></i><b>(4)</b>
Credits:        Person@EMAIL-ADDRESS<i class=conum data-value=5></i><b>(5)</b>
Affects:        All releases of FreeBSD<i class=conum data-value=6></i><b>(6)</b>
                FreeBSD 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<i class=conum data-value=7></i><b>(7)</b>
CVE Name:   CVE-XXXX-XXXX<i class=conum data-value=8></i><b>(8)</b>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background<i class=conum data-value=9></i><b>(9)</b>

II.  Problem Description<i class=conum data-value=10></i><b>(10)</b>

III. Impact<i class=conum data-value=11></i><b>(11)</b>

IV.  Workaround<i class=conum data-value=12></i><b>(12)</b>

V.   Solution<i class=conum data-value=13></i><b>(13)</b>

VI.  Correction details<i class=conum data-value=14></i><b>(14)</b>

VII. References<i class=conum data-value=15></i><b>(15)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Поле <code>Topic</code> показывает в чем именно заключается проблема. Это обычно введение в сообщение безопасности, упоминающее утилиту, в которой возникла ошибка.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Поле <code>Category</code> относится к затронутой части системы и может быть выбрана из <code>core</code>, <code>contrib</code>, или <code>ports</code>. Категория <code>core</code> означает, что уязвимость затрагивает основной компонент операционной системы FreeBSD. Категория <code>contrib</code> означает, что уязвимость затрагивает программы, предоставленные проекту FreeBSD, например sendmail. Наконец, категория <code>ports</code> означает, что уязвимость затрагивает программное обеспечение, доступное из Коллекции Портов.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Поле <code>Module</code> указывает на местоположение компонента, например <code>sys</code>. В этом примере мы видим, что затронут модуль <code>sys</code>, следовательно, эта уязвимость относится к компоненту, используемому в ядре.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Поле <code>Announced</code> отражает дату публикации сообщения безопасности, или его анонсирования. Это означает, что команда обеспечения безопасности убедилась, что проблема существует и что патч помещён в хранилище исходных текстов FreeBSD.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Поле <code>Credits</code> упоминает частное лицо или организацию, обнаружившую уязвимость и сообщившую о ней.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Поле <code>Affects</code> дает информацию о релизах FreeBSD, к которым относится данная уязвимость. Для базовой системы, просмотр вывода команды <code>ident</code> для файлов, затронутых уязвимостью, поможет определить ревизию. Номер версии портов приведен после имени порта в каталоге <span class=filename>/var/db/pkg</span>. Если система не синхронизируется с CVS-хранилищем FreeBSD и не пересобирается ежедневно, высок шанс, что она затронута уязвимостью.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Поле <code>Corrected</code> показывает дату, время, смещение во времени и релиз, в котором исправлена ошибка.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Зарезервировано для идентификации уязвимости в общей базе данных CVD (Common Vulnerabilities Database).</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Поле <code>Background</code> дает информацию именно о той утилите, для которой выпущено сообщение. Как правило информация о том, зачем утилита присутствует в FreeBSD, для чего она используется, и немного информации о том, как появилась эта утилита.</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>Поле <code>Problem Description</code> дает более глубокие разъяснения возникшей проблемы. Оно может включать информацию об ошибочном коде, или даже о том, как утилита может быть использована для создания бреши в системе безопасности.</td></tr><tr><td><i class=conum data-value=11></i><b>11</b></td><td>Поле <code>Impact</code> описывает тип воздействия, который проблема может оказать на систему. Это может быть все, что угодно, от атаки на отказ в обслуживании до получения пользователями дополнительных привилегий, или даже получения атакующим прав суперпользователя.</td></tr><tr><td><i class=conum data-value=12></i><b>12</b></td><td>Поле <code>Workaround</code> предлагает тем, системным администраторам, которые не могут обновить систему, обходной путь решения проблемы. Он может пригодиться при недостатке времени, отсутствии подключения к сети или по массе других причин. В любом случае, к безопасности нельзя относиться несерьезно, и необходимо либо применить указанный обходной путь, либо исправить систему.</td></tr><tr><td><i class=conum data-value=13></i><b>13</b></td><td>Поле <code>Solution</code> предлагает инструкции по исправлению затронутой системы. Это пошаговое руководство, протестированный метод восстановления безопасности системы.</td></tr><tr><td><i class=conum data-value=14></i><b>14</b></td><td>Поле <code>Correction Details</code> показывает ветвь CVS (имя релиза с точками, замененными на символы подчеркивания). Здесь также показан номер ревизии каждого файла из каждой ветви.</td></tr><tr><td><i class=conum data-value=15></i><b>15</b></td><td>Поле <code>References</code> обычно упоминает другие источники информации. Это могут быть Web-страницы, книги, списки рассылки и группы новостей.</td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=security-accounting>14.15. Учёт используемых ресурсов<a class=anchor href=#security-accounting></a></h2><div class=sectionbody><div class=paragraph><p>Учёт используемых процессами ресурсов представляет собой метод защиты, при котором администратор может отслеживать использование системных ресурсов и их распределение между пользователями для нужд системного мониторинга и минимального отслеживания команд пользователей.</p></div><div class=paragraph><p>На самом деле здесь есть свои положительный и отрицательные моменты. Положительной стороной является то, что проникновение может быть отслежено до первоначальной точки входа. Отрицательной стороной является объём протоколов, который генерируется при мониторинге, и соответствующие требования к дисковому пространству. В этом разделе администратору даются основы учёта ресурсов процессов.</p></div><div class=sect2><h3 id=_активация_и_использование_учёта_ресурсов>14.15.1. Активация и использование учёта ресурсов<a class=anchor href=#_активация_и_использование_учёта_ресурсов></a></h3><div class=paragraph><p>Прежде чем использовать систему учёта ресурсов, её необходимо активировать. Для этого выполните следующие команды:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/account/acct</span>

<span class=c># accton /var/account/acct</span>

<span class=c># echo &#39;accounting_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span></code></pre></div></div><div class=paragraph><p>После активации система учёта ресурсов начнёт отслеживать статистику CPU, команд и так далее. Все протоколы учёта ведутся в формате, недоступном для чтения человеком, и могут просматриваться при помощи утилиты <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>. Запущенная без параметров, <code>sa</code> выдаст информацию, относящуюся к количеству вызовов в расчёте на каждого пользователя, общее затраченное время в минутах, общее время CPU и пользователя в минутах, среднее количество операций ввода/вывода и так далее.</p></div><div class=paragraph><p>Для просмотра информации о запущенных командах, необходимо воспользоваться утилитой <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>. Команду <code>lastcomm</code> можно использовать, например, для выдачи списка директив, выданных пользователями определённого терминала <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lastcomm ls trhodes ttyp1</span></code></pre></div></div><div class=paragraph><p>Эта команда выдаст все зафиксированные использования команды <code>ls</code> пользователем <code>trhodes</code> на терминале ttyp1.</p></div><div class=paragraph><p>Существует многие другие полезные параметры, которые описаны на соответствующих справочных страницах <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a> и <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>.</p></div></div></div></div></div><hr><div class=last-modified><p><strong>Изменено</strong>: 9 марта 2024 г. by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Назад></i><div class=container><a href=https://docs.freebsd.org/ru/books/handbook/boot class=direction>Назад</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Главная></i><div class=container><a href=../ class=direction>Главная</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/ru/books/handbook/mac class=direction>Далее</a></div><i class="fa fa-angle-right" aria-hidden=true title=Далее></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Содержание</h3><nav id=TableOfContents><ul><li><a href=#security-synopsis>14.1. Краткое описание</a></li><li><a href=#security-intro>14.2. Введение</a></li><li><a href=#securing-freebsd>14.3. Защита FreeBSD</a></li><li><a href=#crypt>14.4. DES, MD5, и шифрование</a></li><li><a href=#one-time-passwords>14.5. Одноразовые пароли</a></li><li><a href=#tcpwrappers>14.6. TCP Wrappers</a></li><li><a href=#kerberosIV>14.7. KerberosIV</a></li><li><a href=#kerberos5>14.8. Kerberos5</a></li><li><a href=#openssl>14.9. OpenSSL</a></li><li><a href=#ipsec>14.10. VPN через IPsec</a></li><li><a href=#openssh>14.11. OpenSSH</a></li><li><a href=#fs-acl>14.12. Списки контроля доступа файловой системы (ACL)</a></li><li><a href=#security-portaudit>14.13. Мониторинг вопросов безопасности в ПО сторонних разработчиков</a></li><li><a href=#security-advisories>14.14. Сообщения безопасности FreeBSD</a></li><li><a href=#security-accounting>14.15. Учёт используемых ресурсов</a></li></ul></nav><hr><div class=resources><h3>Материалы</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Скачать PDF"></i><a href=https://download.freebsd.org/doc/ru/books/handbook/handbook_ru.pdf>Скачать PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Редактировать эту страницу"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/ru/_index target=_blank>Редактировать эту страницу</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/ru/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Выберите язык">
<span>Русский</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>Система</option><option value=theme-light>Светлый</option><option value=theme-dark>Тёмный</option><option value=theme-high-contrast>Высокая контрастность</option></select></div></div></section><section class=about-column><h3 class=column-title>О нас</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>Фонд FreeBSD</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Получить FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Кодекс Этики</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Бюллетени Безопасности</a></li></ul></section><section class=documentation-column><h3 class=column-title>Документация</h3><ul class=column-elements-container><li><a href=/ru class=column-element>Портал документации</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Страницы Справочника</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Презентации и публикации</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Предыдущие версии</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>Документы 4.4BSD</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Сообщество</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/ru/articles/contributing class=column-element>Принять участие</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Форум Сообщества</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Списки рассылки</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>Каналы IRC</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Трекер ошибок</a></li></ul></section><section class=legal-column><h3 class=column-title>Юридическая информация</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Пожертвования</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Лицензирование</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Политика Конфиденциальности</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Юридические оговорки</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 Проект FreeBSD. Все права защищены</p><span>Сделано с помощью <span class=heart>♥</span> Сообществом FreeBSD</span></section></div></footer></body></html>