<!doctype html><html class=theme-light lang=ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/ru/books/design-44bsd/><title>Архитектура и реализация операционной системы 4.4BSD | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Архитектура и реализация операционной системы 4.4BSD"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="ru"><meta property="og:url" content="https://docs.freebsd.org/ru/books/design-44bsd/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/ru\/books\/design-44bsd\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>О нас
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>О нас</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>Фонд FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Кодекс Этики</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Получить FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Получить FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Информация о релизах</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Подготовка релизов</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Бюллетени Безопасности</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Документация
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/ru>Портал документации</a></li><li><a href=https://docs.freebsd.org/ru/books/handbook>Руководство</a></li><li><a href=https://docs.freebsd.org/ru/books/porters-handbook>Руководство по созданию портов</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Учебник Проекта Документирования</a></li><li><a href=https://man.FreeBSD.org target=_blank>Страницы Справочника</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Презентации и публикации</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/ru/books>Книги</a></li><li><a href=https://docs.freebsd.org/ru/articles>Статьи</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Сообщество
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Сообщество</a></li><li><a href=https://docs.freebsd.org/ru/articles/contributing>Стать участником</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Форум</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Списки рассылки</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>Каналы IRC</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Трекер ошибок</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Поддержка</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=ru>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Пожертвования</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>Архитектура и реализация операционной системы 4.4BSD</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Этот перевод может быть устаревшим. Для того, чтобы помочь с переводом, пожалуйста, обратитесь к <a href=https://translate-dev.freebsd.org/ target=_blank>Сервер переводов FreeBSD</a>.</p></div><div class=copyright>Copyright © 1996 Addison-Wesley Longman, Inc</div><div class=legalnotice><a id=trademarks></a><details><summary>товарные знаки</summary></details></div><div class=toc-mobile><h3>Содержание</h3><nav id=TableOfContents><ul><li><a href=#overview>2.1. Обзор архитектуры 4.4BSD</a><ul><li><a href=#overview-facilities>2.1.1. Системные сервисы 4.4BSD и ядро</a></li><li><a href=#overview-kernel-organization>2.1.2. Организация ядра</a></li><li><a href=#overview-kernel-service>2.1.3. Службы ядра</a></li><li><a href=#overview-process-management>2.1.4. Управление процессами</a></li><li><a href=#overview-memory-management>2.1.5. Управление памятью</a></li><li><a href=#overview-io-system>2.1.6. Система ввода/вывода</a></li><li><a href=#overview-filesystem>2.1.7. Файловые системы</a></li><li><a href=#overview-filestore>2.1.8. Размещение файлов</a></li><li><a href=#overview-nfs>2.1.9. Сетевая файловая система</a></li><li><a href=#overview-terminal>2.1.10. Терминалы</a></li><li><a href=#overview-ipc>2.1.11. Коммуникации между процессами</a></li><li><a href=#overview-network-communication>2.1.12. Сетевые коммуникации</a></li><li><a href=#overview-network-implementation>2.1.13. Сетевая реализация</a></li><li><a href=#overview-operation>2.1.14. Работа системы</a></li></ul></li><li><a href=#references>Ссылки</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><hr></div></div><div class=sect1><h2 id=overview>2.1. Обзор архитектуры 4.4BSD<a class=anchor href=#overview></a></h2><div class=sectionbody><div class=sect2><h3 id=overview-facilities>2.1.1. Системные сервисы 4.4BSD и ядро<a class=anchor href=#overview-facilities></a></h3><div class=paragraph><p>Ядро 4.4BSD предоставляет четыре основных системных сервиса: процессы, файловую систему, коммуникации и запуск системы. Этот раздел перечисляет, в каком месте этой книги описана каждая из этих служб.</p></div><div class="olist arabic"><ol class=arabic><li><p>Процессы образуют поток управления в адресном пространстве. Механизмы создания, завершения и другие управляющие процессы описаны в Главе 4. Для каждого процесса система мультиплексирует отдельное виртуальное адресное пространство; такое управление памятью обсуждается в Главе 5.</p></li><li><p>Механизм доступа пользователя к файловой системе и устройствам один и тот же; общие аспекты обсуждаются в Главе 6. Файловая система является набором именованных файлов, организованных в древовидную иерархию каталогов, а операции по управлению ими представлены в Главе 7. Файлы располагаются на таких физических носителях, как диски. 4.4BSD поддерживает несколько типов организации данных на диске, как описано далее в Главе 8. Доступ к файлам на удаленных машинах является предметом обсуждения в Главе 9. Для доступа к системе Терминалы используются терминалы; их функционированию посвящена глава 10.</p></li><li><p>Механизмы коммуникаций, предоставляемые традиционными UNIX-системами, включают однонаправленные потоки байтов между связанными процессами (смотрите материал о конвейерах в Разделе 11.1) и извещение об исключительных событиях (смотрите материал о сигналах в Разделе 4.7). В 4.4BSD имеется также механизм межпроцессного взаимодействия между процессами. Этот механизм, описываемый в Главе 11, использует способы доступа, отличающиеся от тех, что используются в файловой системе, но, как только соединение установлено, процесс может работать с ним, как будто это конвейер. Имеется и механизм работы с сетью, описываемый в Главе 12, который обычно используется как слой ниже механизма IPC. В Главе 13 дается детальное описание конкретной реализации механизма работы с сетью.</p></li><li><p>В любой операционной системе присутствуют вопросы управления, такие, как ее запуск. Запуск и вопросы управления обсуждаются в Главе 14.</p></li></ol></div><div class=paragraph><p>Разделы с 2.3 по 2.14 представляют собой вводный материал, относящийся к главам с 3 по 14. Мы определим понятия, коснемся основных системных вызовов и рассмотрим исторические разработки. Наконец, мы расскажем о причинах многих ключевых архитектурных решений.</p></div><div class=sect3><h4 id=_ядро>2.1.1.1. Ядро<a class=anchor href=#_ядро></a></h4><div class=paragraph><p><em>Ядро</em> является частью системы, которая работает в защищенном режиме и управляет доступом всех пользовательских программ к низкоуровнему аппаратному обеспечению (к примеру, ЦПУ, дискам, терминалам, сетевым связям) и программным компонентам (к примеру, файловой системе, сетевым протоколам). Ядро предоставляет основные системные услуги; оно создает процессы и управляет ими, предоставляет функции для доступа к файловой системе и службам связи. Такие функции, называемые <em>системными вызовами</em>, доступны процессам пользователей в виде библиотечных подпрограмм. Эти системные вызовы являются единственным способом доступа к таким услугам. Подробно механизм работы системных вызовов дается в Главе 3, вместе с описанием некоторых механизмов ядра, работа которых не является прямым результатом процесса, выполняющего системный вызов.</p></div><div class=paragraph><p><em>Ядро</em>, по традиционной терминологии операционных систем, является маленьким куском программного обеспечения, которое предоставляет только минимальный набор услуг, необходимый для реализации дополнительных служб операционной системы. В современных исследовательских операционных системах - таких, как Chorus <a href=#biblio-rozier>[Rozier et al, 1988]</a>, Mach <a href=#biblio-accetta>[Accetta et al, 1986]</a>, Tunis <a href=#biblio-ewens>[Ewens et al, 1985]</a>, и V Kernel <a href=#biblio-cheriton>[Cheriton, 1988]</a> - такое разделение функциональности выполнено не только логически. Такие службы, как файловые системы и сетевые протоколы, выполнены в виде прикладных процессов клиентов ядра или микроядра.</p></div><div class=paragraph><p>Ядро 4.4BSD не разбивается на несколько процессов. Это основополагающее архитектурное решение было сделано в самых ранних версиях UNIX. В первых двух реализациях Кена Томпсона (Ken Thompson) не было отображаемой памяти, и поэтому не было аппаратного различия между адресным пространством пользователя и ядра <a href=#biblio-ritchie>[Ritchie, 1988]</a>. Могла бы быть придумана система обмена сообщениями как реально реализуемая модель процессов ядра и пользователя. Для простоты и увеличения производительности было выбрано монолитное ядро. К тому же ранние ядра были маленькими; включение таких служб, как сетевые коммуникации, в ядро увеличило его размер. Современные тенденции в области операционных систем сводятся к уменьшению размера ядра за счет перевода таких служб в пользовательское адресное пространство.</p></div><div class=paragraph><p>Пользователи обычно общаются с системой через интерпретатор языка команд, называемый оболочкой (<em>shell</em>), и, может быть, через дополнительные прикладные пользовательские программы. Такие программы и оболочка реализованы в виде процессов. Подробное описание таких программ выходит за рамки этой книги, которая практически полностью посвящена работе ядра.</p></div><div class=paragraph><p>В разделах 2.3 и 2.4 описываются сервисы, предоставляемые ядром 4.4BSD, и дается обзор их архитектуры. Последующие главы описывают подробности архитектуры и реализации этих сервисов в 4.4BSD.</p></div></div></div><div class=sect2><h3 id=overview-kernel-organization>2.1.2. Организация ядра<a class=anchor href=#overview-kernel-organization></a></h3><div class=paragraph><p>В этом разделе мы рассматриваем организацию ядра 4.4BSD с двух точек зрения:</p></div><div class="olist arabic"><ol class=arabic><li><p>Как статический блок программного обеспечения, категоризуемый по функциональности модулей, составляющих ядро</p></li><li><p>В его динамике, категоризуемой по услугам, предоставляемым пользователям</p></li></ol></div><div class=paragraph><p>Самая большая часть ядра реализует системные услуги, к которым приложения обращаются через системные вызовы. В 4.4BSD это программное обеспечение организуется по следующим принципам:</p></div><div class=ulist><ul><li><p>Базовые услуги ядра: обработка таймеров и системного таймера, управление дескрипторами и процессами</p></li><li><p>Поддержка управления памятью: подкачка и выгрузка</p></li><li><p>Общесистемные интерфейсы: ввод/вывод, управление и мультиплексирование операций, выполняемых над дескрипторами</p></li><li><p>Файловая система: файлы, каталоги, преобразование маршрутов, блокировка файлов и управление буфером ввода/вывода</p></li><li><p>Поддержка работы с терминалами: драйвер терминального интерфейса и режимы работы терминального канала</p></li><li><p>Службы межпроцессного взаимодействия: сокеты</p></li><li><p>Поддержка сетевых коммуникаций: коммуникационные протоколы и общесетевые службы, такие, как маршрутизация</p></li></ul></div><table id=table-mach-indep class="tableblock frame-none grid-all stretch"><caption class=title>Таблица 1. Машинно-независимое программное обеспечение в ядре 4.4BSD</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Категория</th><th class="tableblock halign-left valign-top">Количество строк кода</th><th class="tableblock halign-left valign-top">Процент от всего ядра</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>файлы заголовков</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>9,393</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4.6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>инициализация</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1,107</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>службы ядра</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8,793</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4.4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>общесистемные интерфейсы</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,782</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>межпроцессное взаимодействие</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,540</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>работа с терминалами</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,911</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.9</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>виртуальная память</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>11,813</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5.8</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>управление vnode</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7,954</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3.9</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>именование файловой системы</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6,550</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3.2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>хранение файлов</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,365</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>хранение log-структур</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,337</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>хранение на основе памяти</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>645</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>файловая система cd9660</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,177</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>различные файловые системы (10)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>12,695</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>сетевая файловая система</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>17,199</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8.5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>сетевое взаимодействие</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8,630</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>протоколы internet</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>11,984</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5.9</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>протоколы ISO</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>23,924</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>11.8</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>протоколы X.25</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10,626</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>протоколы XNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5,192</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.6</p></td></tr></tbody><tfoot><tr><td class="tableblock halign-left valign-top"><p class=tableblock>всего машинно-независимая часть</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>162,617</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>80.4</p></td></tr></tfoot></table><div class=paragraph><p>Большая часть программного обеспечения в этих категориях является машинно-независимой и переносима между различными аппаратными архитектурами.</p></div><div class=paragraph><p>Машинно-зависимые аспекты ядра отделены от основного кода. В частности, ни в одной части машинно-независимого кода не содержится кода, зависимого от конкретной архитектуры. Когда требуется произвести действия, зависимые от архитектуры, машинно-независимый код вызывает функцию, зависимую от архитектуры машины, которая находится в машинно-зависимой части кода. Машинно-зависимое программное обеспечение включает в себя</p></div><div class=ulist><ul><li><p>Низкоуровневые действия по запуску системы</p></li><li><p>Обработка исключительных ситуаций и прерываний</p></li><li><p>Низкоуровневые манипуляции процессом во время работы</p></li><li><p>Конфигурация и инициализация аппаратных устройств</p></li><li><p>Поддержка устройств ввода/вывода во время работы</p></li></ul></div><table id=table-mach-dep class="tableblock frame-none grid-all stretch"><caption class=title>Таблица 2. Машинно-зависимое программное обеспечение для HP300 в ядре 4.4BSD</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Категория</th><th class="tableblock halign-left valign-top">Количество строк кода</th><th class="tableblock halign-left valign-top">Процент от всего ядра</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>машинно-зависимые заголовки</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1,562</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.8</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>заголовки драйверов устройств</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,495</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.7</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>исходные тексты драйверов устройств</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>17,506</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8.7</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>виртуальная память</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,087</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>остальная машинно-зависимая часть</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6,287</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3.1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>процедуры на ассемблере</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,014</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>совместимость с HP/UX</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,683</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.3</p></td></tr></tbody><tfoot><tr><td class="tableblock halign-left valign-top"><p class=tableblock>всего машинно-зависимая часть</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>39,634</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>19.6</p></td></tr></tfoot></table><div class=paragraph><p><a href=#table-mach-indep>Машинно-независимое программное обеспечение в ядре 4.4BSD</a> суммаризует машинно-независимый код, который составляет ядро 4.4BSD для HP300. Числа во второй колонке обозначают количество строк исходного кода на языке C, заголовочных файлов и ассемблерного кода. Практически весь код ядра написан на языке программирования C; менее двух процентов написано на языке ассемблера. Как показывает статистика в <a href=#table-mach-dep>Машинно-зависимое программное обеспечение для HP300 в ядре 4.4BSD</a>, машинно-зависимый код, не включающий поддержку HP/UX и устройств, составляет менее 6.9 процента ядра.</p></div><div class=paragraph><p>Лишь малая часть ядра отвечает за инициализацию системы. Этот код используется при <em>начальной загрузке</em> системы для перехода в рабочий режим и отвечает за настройку аппаратного и программного окружения ядра (обратитесь к Главе 14). Некоторые операционные системы (особенно те, что ограничены объемом физической памяти) выполняют действия по выгрузке или <em>перекрытию</em> программного кода, выполняющего эти функции, после окончания его работы. Ядро 4.4BSD не работает повторно с памятью, использованной начальным кодом, потому что этот объем памяти составляет менее 0.5 процентов ресурсов ядра, используемых на типичной машине. Также начальный код не находится только в одном месте ядра - он рассредоточен везде, и обычно появляется там, где логически связан с объектом инициализации.</p></div></div><div class=sect2><h3 id=overview-kernel-service>2.1.3. Службы ядра<a class=anchor href=#overview-kernel-service></a></h3><div class=paragraph><p>Разграничение между кодом уровней ядра и пользователя обеспечивается аппаратными методами, предоставляемыми оборудованием. Ядро работает в отдельном адресном пространстве, которое недоступно процессам пользователя. Привилегированные операции - такие, как осуществление ввода/вывода и остановка модуля центрального процессора (CPU) - доступны только ядру. Приложения делают запросы ядру на доступ к его сервисам при помощи <em>системных вызовов</em>. Системные вызовы используются для указания ядру на выполнение как сложных операций, таких, как запись данных во вторичный носитель, так и простых, таких, как получение текущего времени. Все системные вызовы выполняются <em>синхронно</em> с приложением: Приложение не будет продолжать работу, пока ядро не выполнит действия, соответствующие системному вызову. Ядро может завершить некоторые операции, связанные с системным вызовом, после его окончания. Например, системный вызов <em>write</em> будет копировать записываемые данные от пользовательского процесса в буфер ядра, пока процесс находится в ожидании, но, как правило, будет немедленно завершаться до того, как буфер ядра реально будет записан на диск.</p></div><div class=paragraph><p>Системный вызов обычно реализуется как аппаратное прерывание, которое изменяет режим работы CPU и текущее отображение адресного пространства. Параметры, передаваемые пользователями системным вызовам, перед использованием проверяются ядром. Такая проверка обеспечивает целостность системы. Все параметры, передаваемые в ядро, копируются в адресное пространство ядра, для того, чтобы проверенные параметры не могли быть изменены в результате побочного действия системного вызова. Результаты выполнения системного вызова возвращаются ядром либо в аппаратных регистрах, либо копированием их значений в области памяти, указанные пользователем. Как и параметры, переданные в ядро, адреса, используемые для возвращения результатов, должны быть проверены на то, что они являются частью адресного пространства приложения. Если при обработке системного вызова ядром возникает ошибка, код ошибки возвращается пользователю. В случае языка программирования C код этой ошибки сохраняется в глобальной переменной <em>errno</em>, а функция, соответствующая системному вызову, возвращает в качестве результата значение -1.</p></div><div class=paragraph><p>Пользовательские приложения и ядро работают независимо друг от друга. 4.4BSD не хранит управляющие блоки ввода/вывода и другие связанные с операционной системой структуры данных в адресном пространстве приложения. Каждому пользовательскому приложению предоставляется независимое адресное пространство, в котором оно и выполняется. Ядро выполняет большинство управляющих действий, таких, как приостановка процесса на время выполнения другого, незаметно для участвующих процессов.</p></div></div><div class=sect2><h3 id=overview-process-management>2.1.4. Управление процессами<a class=anchor href=#overview-process-management></a></h3><div class=paragraph><p>4.4BSD поддерживает многозадачность. Каждая задача или выполняющийся поток называется <em>процессом</em>. <em>Контекст</em> процесса 4.4BSD состоит из состояния пользовательского уровня, включая содержимое его адресного пространства и окружения времени выполнения, и состояния уровня ядра, в который включаются параметры планировщика задач, управляющие ресурсы и идентифицирующая информация. В контекст включается все, что используется ядром при предоставлении своих сервисов процессу. Пользователи могут создавать процессы, управлять их выполнением и получать уведомления при изменении состояния выполнения процессов. Каждому процессу назначается уникальное число, называемое <em>идентификатором процесса</em> (PID). Это число используется ядром для идентификации процесса при сообщении пользователю об изменении его состояния, и пользователем для указания процесса в системном вызове.</p></div><div class=paragraph><p>Ядро создает процесс, дублируя контекст другого процесса. Новый процесс считается <em>порожденным процессом</em> исходного <em>родительского процесса</em>. Контекст, копируемый в ходе создания процесса, включает как состояние выполнения процесса уровня пользователя, так и системное состояние процесса, управляемое ядром. Важные компоненты состояния ядра описаны в Главе 4.</p></div><div id=fig-process-lifecycle class=imageblock><div class=content><img src=../../../images/books/design-44bsd/fig1.png alt="Системные вызовы управления процессами"></div><div class=title>Рисунок 1. Жизненный цикл процесса</div></div><div class=paragraph><p>Жизненный цикл процесса изображен на <a href=#fig-process-lifecycle>Жизненный цикл процесса</a>. Процесс может создать новый процесс, который является копией исходного процесса с помощью системного вызова <em>fork</em>. Возврат из вызова <em>fork</em> происходит два раза: один раз в родительском процессе, в котором возвращаемое значение является идентификатором порожденного процесса, и второй раз в порожденном процессе, в котором возвращаемое значение равно 0. Связь родитель-потомок порождает иерархическую структуру процессов в системе. Новый процесс имеет доступ ко всем ресурсам его родителя, таким, как файловые дескрипторы, состояние обработки сигналов и распределение памяти.</p></div><div class=paragraph><p>Хотя есть ситуации, когда процесс должен быть копией своего родителя, наиболее типичным и полезным действием является загрузка и выполнение другой программы. Процесс может заместить себя образом памяти другой программы, передавая вновь созданному образу набор параметров, при помощи системного вызова <em>execve</em>. Одним из параметров является имя файла, содержимое которого имеет формате, распознаваемый системой - это либо двоичный выполняемый файл, либо файл, который приводит к запуску указанной программы интерпретации для обработки его содержимого.</p></div><div class=paragraph><p>Процесс может завершить работу, выполнив системный вызов <em>exit</em>, посылающий 8-битовое значение состояния завершения своему родителю. Если процесс хочет передать родительскому процессу информацию, превышающую один байт, он должен либо создать канал межпроцессных коммуникаций при помощи конвейеров или сокетов, или при помощи промежуточного файла. Коммуникации между процессами подробно обсуждаются в Главе 11.</p></div><div class=paragraph><p>Процесс может приостановить выполнение до тех пор, пока не завершит работу любой из порожденных им процессов, при помощи системного вызова <em>wait</em>, который возвращает PID и статус завершения выполненного дочернего процесса. Родительский процесс может быть настроен на получение сигнала в случае, когда порожденный процесс завершает работу или аварийно прекращает выполнение. При помощи системного вызова <em>wait4</em> родитель может получить информацию о событии, приведшем к завершению порожденного процесса и о ресурсах, использованных процессом за время его работы. Если процесс становится сиротой из-за того, что процесс, его породивший, завершил работу до окончания работы потомка, то ядро перенаправляет состояние завершения порожденного процесса особому системному процессу <em>init</em>: обратитесь к разделам 3.1 и 14.6).</p></div><div class=paragraph><p>Подробное описание того, как ядро создает и уничтожает процессы, дается в Главе 5.</p></div><div class=paragraph><p>Планирование выполнения процессов осуществляется согласно параметру <em>приоритетности процесса</em>. Этот приоритет управляется алгоритмом планирования задач в ядре. Пользователи могут влиять на выполнение процесса, задавая этот параметр (<em>nice</em>), который влияет на суммарный приоритет, но но ограничен использованием ресурсов CPU согласно алгоритму планировщика задач ядра.</p></div><div class=sect3><h4 id=_сигналы>2.1.4.1. Сигналы<a class=anchor href=#_сигналы></a></h4><div class=paragraph><p>В системе определен набор <em>сигналов</em>, которые могут быть отправлены процессу. Сигналы в 4.4BSD сделаны по образу аппаратных прерываний. Процесс может определить пользовательскую подпрограмму, которая будет являться <em>обработчиком</em>, и которой должен будет перенаправляться сигнал. Когда сигнал генерируется, он блокируется от повторного появления до тех пор, пока не будет <em>перехвачен</em> обработчиком. Перехват сигнала включает в себя сохранение контекста текущего процесса и построение нового, в котором запускается обработчик. Затем сигнал направляется обработчику, который может либо прервать процесс, либо передать управление обратно выполняемому процессу (может быть, после установки значения глобальной переменной). Если обработчик возвратил управление, сигнал разблокировывается и может быть сгенерирован (и получен) снова.</p></div><div class=paragraph><p>Либо процесс может определить, что сигнал будет <em>игнорироваться</em> или будет выполняться действие по умолчанию, определяемое ядром. Действием по умолчанию для некоторых сигналов является прекращение процесса. Это завершение работы может сопровождаться созданием <em>файла дампа</em>, содержащего текущий образ памяти процесса для использования в последующей отладке.</p></div><div class=paragraph><p>Некоторые сигналы не могут быть перехвачены или проигнорированы. К таким сигналам относятся <em>SIGKILL</em>, прерывающий неуправляемый процесс, и сигнал управления заданиями <em>SIGSTOP</em>.</p></div><div class=paragraph><p>Процесс может выбрать получение сигналов в специальный стек для выполнения хитроумных программных манипуляций стеком. Например, подпрограммам поддержки языка нужно иметь стек для каждой подпрограммы. Система времени выполнения языка может выделять эти стеки, разделяя единственный стек, предоставляемый в 4.4BSD. Если ядро не поддерживает отдельный стек сигналов, то пространство, выделяемое каждой подпрограмме, должно быть расширено на объем, требуемый для перехвата сигнала.</p></div><div class=paragraph><p>Все сигналы имеют один и тот же <em>приоритет</em>. Если обработки ожидают несколько сигналов, то порядок их направления процессу зависит от реализации. Обработчики сигналов, выполняемые по сигналу, который их вызвал, блокируются, но при этом могут быть сгенерированы дополнительные сигналы. Имеется механизм, позволяющий защитить критический участок кода от появления заданных сигналов.</p></div><div class=paragraph><p>Подробное описание архитектуры и реализации механизма сигналов дается в Разделе 4.7.</p></div></div><div class=sect3><h4 id=_группы_управления_и_сеансы>2.1.4.2. Группы управления и сеансы<a class=anchor href=#_группы_управления_и_сеансы></a></h4><div class=paragraph><p>Процессы организованы в <em>группы управления</em>. Группы управления используются для управления доступом к терминалам и для обеспечения передачи сигналов наборам связанных процессов. Процесс наследует группу управления от своего родительского процесса. Ядром обеспечиваются механизмы, позволяющие процессу изменять свою группу управления или группу управления своих наследников. Создание новой группы управления просто; значение, соответствующее новой группе управления, обычно является идентификатором создающего ее процесса.</p></div><div class=paragraph><p>Группу процессов в группе управления иногда называют <em>заданием</em> и оно управляется высокоуровневым системным программным обеспечением, таким, как командный процессор. Типичным примером задания, созданного командным процессором, является <em>конвейер</em> из нескольких связанных процессов, так что выходной поток первого процесса является входным потоком для второго, выходной поток второго процесса является входным потоком для третьего, и так далее. Командный процессор создает такое задание, порождая процесс для каждого участка конвейера, а затем помещая все эти процессы в отдельную группу обработки.</p></div><div class=paragraph><p>Пользовательский процесс может послать сигнал как всем процессам в группе управления, так и конкретному процессу. Процесс в заданной группе управления может получать программные прерывания, отражающиеся на группе, приводящие к приостановке или продолжению выполнения, или к прерыванию или завершению работы.</p></div><div class=paragraph><p>Терминалу ставится в соответствие идентификатор группы управления. Этот идентификатор обычно равен идентификатору группы управления, соответствующей терминалу. Управляющий заданиями командный процессор может создать несколько групп управления, связанных с одним и тем же терминалом; терминал является <em>управляющим терминалом</em> для каждого процесса в этих группах. Процесс может выполнять чтение из дескриптора своего управляющего терминала, если только идентификатор группы управления соответствует идентификатору группы этого процесса. Если идентификаторы не совпадают, процесс будет блокирован при попытке чтения с терминала. Изменяя идентификатор группы управления терминала, командный процессор может распределять терминал между несколькими различными заданиями. Такое распределение называется <em>управлением заданиями</em> и описывается вместе с группами управления в Разделе 4.8.</p></div><div class=paragraph><p>Так же, как и наборы связанных процессов могут объединяться в группы управления, набор групп управления может быть объединен в <em>сеанс</em>. Основное назначение сеансов заключается создании изолированного окружения для процесса-даемона и порожденных им процессов, а также для объединения начального командного процессора пользователя и заданий, которые он порождает.</p></div></div></div><div class=sect2><h3 id=overview-memory-management>2.1.5. Управление памятью<a class=anchor href=#overview-memory-management></a></h3><div class=paragraph><p>Каждый процесс имеет собственное адресное пространство. Адресное пространство изначально разделяется на три логических сегмента: <em>код</em>, <em>данные</em> и <em>стек</em>. Сегмент кода доступен только для чтения и содержит машинные коды программы. Сегменты данных и стека оба доступны как для чтения, так и для записи. Сегмент данных содержит как инициализированные, так и неинициализированные области данных программы, когда как стековый сегмент представляет собой стек программы на этапе выполнения. На большинстве машин сегмент стека автоматически расширяется ядром в процессе работы программы. Процесс может расширять или уменьшать свой сегмент данных, выполняя системный вызов, когда как размер сегмента кода процесс может изменить только когда содержимое сегмента перекрывается данными файловой системы или в процессе отладки. Начальное содержимое сегментов порожденного процесса копируется из сегментов родительского процесса.</p></div><div class=paragraph><p>Для выполнения процесса вовсе не обязательно постоянно хранить в памяти полное содержимое его адресного пространства. Если процесс обращается к области адресного пространства, которая не присутствует в оперативной памяти, то система <em>подгружает страницу</em> с необходимой информацией в память. Когда возникает нехватка системных ресурсов, то система использует двухуровневый подход к управлению имеющимися ресурсами. Если не хватает памяти, то система будет забирать ресурсы памяти от процессов, если они давно не использовались. Если ресурсов не хватает очень сильно, то система будет прибегать к <em>выгрузке</em> всего контекста процесса во вторичную подсистему хранения данных. <em>Постраничная подгрузка по требованию</em> и <em>выгрузка</em> выполняются системой абсолютно незаметно для процессов. Процесс может, однако, указать системе объем памяти, который будет использоваться, в качестве помощи.</p></div><div class=sect3><h4 id=_решения_bsd_по_архитектуре_управления_памятью>2.1.5.1. Решения BSD по архитектуре управления памятью<a class=anchor href=#_решения_bsd_по_архитектуре_управления_памятью></a></h4><div class=paragraph><p>В 4.2BSD требовалось реализовать поддержку больших несвязанных адресных пространств, отображаемых в память файлов и совместно используемой памяти. Был спроектирован интерфейс, который назвали <em>mmap</em>, позволяющий несвязанным процессам запрашивать отображение в их адресное пространство файла в режиме совместного использования. Если несколько процессов отображают в свое адресное пространство один и тот же файл, то изменение адресного пространства процесса, соответствующего файлу, в одном процессе, будет отображено в области отображения этого файла в другом процессе, а также и в самом файле. Однако в конце концов 4.2BSD была выпущена без интерфейса <em>mmap</em> из-за необходимости сделать в первую очередь другие возможности, такие, как работа с сетью.</p></div><div class=paragraph><p>Затем разработка интерфейса <em>mmap</em> продолжалась во время работы над 4.3BSD. Более 40 компаний и исследовательских групп принимали участие в обсуждениях, которые привели к появлению обновленной концепции, описанной в Berkeley Software Architecture Manual <a href=#biblio-mckusick-1>[McKusick et al, 1994]</a>. Несколько компаний реализовали этот обновленный интерфейс <a href=#biblio-gingell>[Gingell et al, 1987]</a>.</p></div><div class=paragraph><p>И снова сроки разработки не позволили включить в 4.3BSD реализацию этого интерфейса. Хотя позже она могла быть встроена в имеющуюся подсистему виртуальной памяти 4.3BSD, разработчики решили не включать ее сюда. потому что этой реализации было уже более 10 лет. Более того, оригинальная архитектура виртуальной памяти была основана на предположении, что компьютерная память мала и дорога, а диски подключены непосредственно к компьютеру, быстры и дешевы. Поэтому подсистема виртуальной памяти была разработана с упором на бережное использование памяти ценой более частых обращений к диску. Вдобавок реализация в 4.3BSD была пронизана зависимостями от аппаратной системы управления памятью машин VAX, что препятствовало ее переносу на другие аппаратные платформы. И наконец, подсистема виртуальной памяти не была предназначена для поддержки связных многопроцессорных систем, которые сейчас становятся все более распространенными и необходимыми.</p></div><div class=paragraph><p>Попытки постепенно усовершенствовать старую реализацию заведомо были обречены на неудачу. Полностью новая архитектура, с другой стороны, могла бы использовать большие объемы памяти, уменьшить дисковые операции и обеспечивать работу с несколькими процессорами. Наконец, система виртуальной памяти в 4.4BSD была полностью изменена. Система виртуальной памяти 4.4BSD основана на системе виртуальной памяти (VM) Mach 2.0 <a href=#biblio-tevanian>[Tevanian, 1987]</a> с заимствованиями из Mach 2.5 и Mach 3.0. В ней была эффективная поддержка совместного использования, полное разделение машинно-зависимой и машинно-независимой частей, а также (сейчас не используемая) поддержка работы с несколькими процессорами. Процессы могут отображать файлы в любую область своего адресного пространства. Они могут совместно использовать части своих адресных пространств посредством отображения в память одного и того же файла. Изменения, сделанные одним процессом, видны в адресном пространстве другого процесса, а также записываются и в сам файл. Процессы могут также запрашивать эксклюзивное отображение файла в память, при котором любые изменения, сделанные процессом, не видны другим процессам, которые отображают файл в память и не записываются обратно в файл.</p></div><div class=paragraph><p>Еще одной проблемой с системой виртуальной памяти является способ, которым информация передается ядру при выполнении системного вызова. 4.4BSD всегда копирует данные из адресного пространства процесса в буфер ядра. Для операций чтения и записи, при которых передаются большие объемы данных, выполнение копирования может оказаться занимающим время процессом. Альтернативным способом является манипуляции с адресным пространством процесса в ядре. Ядро 4.4BSD всегда копирует данные о нескольким причинам:</p></div><div class=ulist><ul><li><p>Зачастую пользовательские данные не выравнены по границе страницы памяти и их объем не кратен размеру аппаратной страницы памяти.</p></li><li><p>Если страница памяти забирается от процесса, он не может больше ссылаться на эту страницу. Некоторые программы зависят от данных, остающихся в буфере, даже после записи этих данных.</p></li><li><p>Если процесс позволяет хранить копию страницы памяти (как это делается в существующей 4.4BSD), то страница должна иметь атрибут <em>копирования-при-записи</em>. Такая страница является одной из таковых, что защищается от записи при помощи атрибута только-для-чтения. Если процесс пытается модифицировать страницу памяти, в ядре возникает ситуация ошибки записи. После этого ядро делает копию страницы, которую процесс может изменять. К несчастью, большинство процессов будет немедленно пытаться записать новые данные в свой буфер вывода, что приводит в любом случае к копированию данных.</p></li><li><p>Когда страницы переносятся в новые адреса виртуальной памяти, большинство аппаратных менеджеров памяти требуют, чтобы кэш аппаратного переназначения адресов был выборочно очищен. Очистка кэша зачастую выполняется медленно. В итоге получается, что переназначение адресов оказывается медленнее, чем копирование блоков данных, не превышающих 4 или 8 килобайт.</p></li></ul></div><div class=paragraph><p>Больше всего отображение памяти нужно для работы к большими файлами и передачи больших объемов данных между процессами. Интерфейс <em>mmap</em> дает методы для выполнения обеих этих операций без копирования.</p></div></div><div class=sect3><h4 id=_управление_памятью_внутри_ядра>2.1.5.2. Управление памятью внутри ядра<a class=anchor href=#_управление_памятью_внутри_ядра></a></h4><div class=paragraph><p>Ядро часто выполняет выделение памяти, которое нужно только для выполнения единственного системного вызова. В пользовательском процессе такая кратковременно используемая память будет выделяться в стеке во время выполнения. Так как ядро имеет ограниченный объем стека времени выполнения, то неэффективно выделять в нем даже блоки памяти среднего размера. Таким образом, такая память должна выделяться посредством более гибкого механизма. Например, когда системный вызов должен преобразовать имя каталога, он должен выделить буфер размером 1 Кбайт для хранения имени. Другие блоки памяти должны выделяться на более продолжительный срок, чем один системный вызов, и поэтому не могут выделяться в стеке, даже если там есть место. В качестве примера можно взять блоки управления протоколами, которые существуют на всем протяжении сетевого соединения.</p></div><div class=paragraph><p>Необходимость в динамическом выделении памяти в ядре становилась все более острой вместе с добавлением количества сервисов. Общий механизм выделения памяти уменьшает сложность написания кода в ядре. Поэтому в 4.4BSD ядро имеет единый механизм выделения памяти, который может использоваться в любой части системы. У него есть интерфейс, похожий на функции библиотеки языка C <em>malloc</em> и <em>free</em>, которые обеспечивают выделение памяти в прикладных программах <a href=#biblio-mckusick-2>[McKusick & Karels, 1988]</a>. Как интерфейс библиотеки языка C, функция выделения памяти получает параметр, указывающий на размер памяти, который необходим. Диапазон запрашиваемых объемов выделяемой памяти не ограничен; однако выделяемая физическая память не подвергается постраничной подгрузке. Функции освобождения памяти передается указатель на освобождаемый участок памяти, но указывать размер освобождаемого участка памяти не нужно.</p></div></div></div><div class=sect2><h3 id=overview-io-system>2.1.6. Система ввода/вывода<a class=anchor href=#overview-io-system></a></h3><div class=paragraph><p>Базовой моделью системы ввода/вывода UNIX является последовательность байт, доступ к которым может осуществляться как последовательно, так и в в произвольном порядке. В типичном пользовательском процессе UNIX нет таких понятий, как <em>методы доступа</em> или <em>управляющие блоки</em>.</p></div><div class=paragraph><p>Различные программы используют разнообразные структуры данных, но ядро не связывает ввод/вывод с используемыми структурами. Например, текстовым файлом считается файл из строк символов набора ASCII, которые разделены одним символом новой строки (символ ASCII перевода строки), но ядро не знает ничего об этом соглашении. Для удовлетворения потребностей большинства программ модель еще более упрощена и сводится к потоку байт данных, или <em>потоку ввода/вывода</em>. Такое единое представление данных позволяет работать характерному для UNIX подходу на основе инструментов <a href=#biblio-kernighan>[Kernighan & Pike, 1984]</a>. Поток ввода/вывода одной программы может быть подан в качестве входной информации практически любой другой программе. (Этот тип традиционных для UNIX потоков ввода/выводы не нужно путать с потоковой системой ввода/вывода из Eighth Edition или с потоками из System V, Release 3 (STREAMS), оба из которых доступны как обычные потоки ввода/вывода.)</p></div><div class=sect3><h4 id=_дескрипторы_и_вводвывод>2.1.6.1. Дескрипторы и ввод/вывод<a class=anchor href=#_дескрипторы_и_вводвывод></a></h4><div class=paragraph><p>Процессы UNIX для работы с потоками ввода/вывода используют <em>дескрипторы</em>. Дескрипторы представляют собой беззнаковые целые числа, получаемые после выполнения системных вызовов <em>open</em> и <em>socket</em>. Системный вызов <em>open</em> получает в качестве аргументов имя файла и режим доступа, который определяет, должен ли файл открываться для чтения, для записи или для обеих операций. Этот системный вызов может также использоваться для создания нового пустого файла. Системные вызовы <em>read</em> и <em>write</em> могут применяться к дескриптору для переноса данных. Системный вызов <em>close</em> может использоваться для уничтожения любого дескриптора.</p></div><div class=paragraph><p>Дескрипторы представляют низкоуровневые объекты, поддерживаемые ядром, и создаваемые системными вызовами, специфичными для каждого типа объектов. В 4.4BSD дескрипторы могут представлять три типа таких объектов: файлы, каналы и сокеты.</p></div><div class=ulist><ul><li><p><em>Файл</em> представляет собой линейную последовательность байт, имеющую по крайней мере одно имя. Файл существует, пока все его имена не удалены и ни один из процессов не хранит его дескриптор. Процесс получает дескриптор файла, открывая имя файла посредством системного вызова <em>open</em>. Работа с устройствами ввода/вывода осуществляется как с файлами.</p></li><li><p><em>Каналом</em> является линейная последовательность байт, такая же, как файл, но используемая исключительно как поток ввода/вывода, причем однонаправленный. У канала нет имени, и поэтому он не может быть открыт при помощи <em>open</em>. Вместо этого он создается посредством системного вызова <em>pipe</em>, который возвращает два дескриптора, один из которых принимает входные данные, без искажений, без повторений и в той же самой последовательности посылаемый на другой дескриптор. Система также поддерживает именованный канал, или FIFO. FIFO имеет те же самые свойства, что и канал, за исключением того, что он располагается в файловой системе; поэтому он может быть открыт системным вызовом <em>open</em>. Процессы, которые хотят обмениваться данными, открывают FIFO: Один процесс открывает его для чтения, а другой для записи.</p></li><li><p><em>Сокет</em> является промежуточным объектом, который используется для межпроцессных коммуникаций; он существует, пока какой-либо процесс хранит дескриптор, ссылающийся на него. Сокет создается системным вызовом <em>socket</em>, который возвращает его дескриптор. Имеется несколько типов сокетов, которые поддерживают различные коммуникационные возможности, такие, как надежную доставку данных, сохранение последовательности передаваемых сообщений, и сохранение границ сообщений.</p></li></ul></div><div class=paragraph><p>В системах, предшествующих 4.2BSD, каналы были реализованы в файловой системе, когда в 4.2BSD появились сокеты, то каналы были повторно реализованы как сокеты.</p></div><div class=paragraph><p>Для каждого процесса ядро хранит <em>таблицу дескрипторов</em>, которая является таблицей, используемой ядром для преобразования внешнего представления дескриптора в его внутреннее представление. (Дескриптор является просто индексом в этой таблице.) Таблица дескрипторов процесса наследуется от родительского процесса, и вместе с ней наследуется и доступ к объектам, на которые ссылаются дескрипторы. Основными способами, при помощи которых процесс может получить дескриптор, является открытие или создание объекта, а также наследование от родительского процесса. Кроме того, межпроцессные коммуникации при помощи сокетов позволяют передавать дескрипторы в сообщениях между несвязанными процессами на одной и той же машине.</p></div><div class=paragraph><p>Любой рабочий дескриптор имеет связанное с ним <em>смещение в файле</em> в байтах от начала объекта. Операции чтения и записи начинаются от этого смещения, который обновляется после каждой передачи данных. Для объектов, к которым разрешен произвольный доступ, смещение в файле может быть установлено посредством системного вызова <em>lseek</em>. Обычные файлы, а также некоторые устройства, разрешают произвольный доступ к ним. Каналы и сокеты этого делать не позволяют.</p></div><div class=paragraph><p>Когда процесс завершается, ядро освобождает все дескрипторы, которые использовались этим процессом. Если процесс хранил последнюю ссылку на объект, то менеджер объектов уведомляется для выполнения всех необходимых действий, таких, как окончательное удаление файла или уничтожение сокета.</p></div></div><div class=sect3><h4 id=_управление_дескрипторами>2.1.6.2. Управление дескрипторами<a class=anchor href=#_управление_дескрипторами></a></h4><div class=paragraph><p>Большинство процессов ожидают, что перед началом их работы уже будут открыты три дескриптора. Это дескрипторы 0, 1 и 2, больше известные как <em>стандартный ввод</em>, <em>стандартный вывод</em> и <em>стандартный поток диагностических сообщений</em>, соответственно. Как правило, все они связываются с пользовательским терминалом по время входа в систему (смотри Раздел 14.6) и наследуются через вызовы <em>fork</em> и <em>exec</em> процессами, запускаемыми пользователем. Таким образом, программа может считывать то, что набирает пользователь, из стандартного ввода, и программа может выдавать результат на экран пользователя, осуществляя запись в стандартный вывод. Дескриптор потока диагностических сообщений также открыт для записи и используется для вывода ошибок, когда как стандартный вывод используется для обычного вывода.</p></div><div class=paragraph><p>Эти (и другие) дескрипторы могут отображаться на объекты, отличающиеся от терминала; такое отображение называется <em>перенаправлением ввода/вывода</em>, и все стандартные командные процессоры позволяют пользователю это делать. Оболочка может направить вывод программы в файл, закрывая дескриптор 1 (стандартный вывод) и открывая выбранный выходной файл для создания нового дескриптора 1. Подобным же образом стандартный ввод может браться из файла, при этом закрывается дескриптор 0 и открывается файл.</p></div><div class=paragraph><p>Каналы позволяют выводу одной программы становиться вводом другой программы без переписывания и даже перекомпоновки программ. Вместо того, чтобы дескриптор 1 (стандартный вывод) исходной программы был настроен на запись на терминал, он настраивается на входной дескриптор канала. Аналогично дескриптор 0 (стандартный ввод) принимающей программы настраивается на обращение к выводу канала, а не к клавиатуре терминала. Результирующий набор двух процессов и соединяющий канал называется <em>конвейером</em>. Конвейеры могут быть весьма большими последовательностями процессов, соединенных каналами.</p></div><div class=paragraph><p>Системные вызовы <em>open</em>, <em>pipe</em> и <em>socket</em> порождают новые дескрипторы с наименьшим неиспользуемым номером, подходящим для дескриптора. Для того, чтобы конвейеры могли работать, должен существовать механизм для отображения таких дескрипторов в 0 и 1. Системный вызов <em>dup</em> создает копию дескриптора, которая указывает на ту же самую запись в таблице файлов. Новый дескриптор также является наименьшим неиспользуемым, но если нужный дескриптор сначала закрыть, то <em>dup</em> можно использовать для выполнения нужного отображения. Однако здесь требуется некоторая осторожность: если нужен дескриптор 1, а дескриптор 0 уже закрыт, то в результате получится дескриптор 0. Во избежание этой проблемы в системе имеется системный вызов <em>dup2</em>; он похож на <em>dup</em>, но воспринимает дополнительный аргумент, указывающий номер нужного дескриптора (если нужный дескриптор уже открыт, то <em>dup2</em> его закроет перед повторным использованием).</p></div></div><div class=sect3><h4 id=_устройства>2.1.6.3. Устройства<a class=anchor href=#_устройства></a></h4><div class=paragraph><p>Аппаратные устройства имеют связанные с ними имена файлов, и к ним может обращаться пользователь при помощи тех же самых системных вызовов, что используются для обычных файлов. Ядро может различать <em>специальный файл устройства</em> или просто <em>специальный файл</em>, и может определять, к какому устройству он относится, но большинство процессов не выполняют такого распознавания. Терминалы, принтеры и стримеры все доступны как последовательности байт, как дисковые файлы 4.4BSD. Таким образом, особенности работы устройств максимально скрываются ядром, и даже в ядре большинство из них отличаются в драйверах.</p></div><div class=paragraph><p>Аппаратные устройства могут быть разделены на <em>структурированные</em> или <em>неструктурированные</em>; они известны под названиями <em>блочные</em> и <em>посимвольные</em>, соответственно. Как правило, процессы обращаются к устройствам посредством <em>специальных файлов</em> в файловой системе. Операции ввода/вывода, выполняемые с такими файлами, обрабатываются постоянно находящимися в ядре программными модулями, называемыми <em>драйверами устройств</em>. Большинство аппаратных устройств для сетевых коммуникаций доступны только при помощи механизмов межпроцессного взаимодействия, и не имеют специальных устройств в пространстве имен файловой системы, так как интерфейс <em>низкоуровневых сокетов</em> дает более естественный интерфейс, чем специальный файл.</p></div><div class=paragraph><p>Структурированные или блочные устройства разделяются на диски и магнитные ленты и включают в себя большинство устройств с произвольным доступом. Ядро поддерживает операции буферизации типа чтение-изменение-запись с блочными структурированными устройствами для того, чтобы разрешить последним осуществлять чтение и запись полностью произвольным образом, как с обычными файлами. Файловые системы создаются на блочных устройствах.</p></div><div class=paragraph><p>Неструктурированными устройствами являются те, что не поддерживают блочную структуру. Типичными неструктурированными устройствами являются линии связи, растровые графопостроители и небуферизируемые магнитные ленты и диски. Неструктурированные устройства, как правило, поддерживают перенос больших объемов данных.</p></div><div class=paragraph><p>Неструктурированные файлы называют <em>символьными устройствами</em>, потому что первые из них являлись драйверами терминальных устройств. Интерфейс ядра к драйверу для этих устройств доказал удобство его использования для других неструктурированных устройств.</p></div><div class=paragraph><p>Специальные файлы устройств создаются системным вызовом <em>mknod</em>. Имеется дополнительный системный вызов, <em>ioctl</em>, для управления низкоуровневыми параметрами специальных файлов. Выполняемые операции для каждого устройства различны. Этот системный вызов позволяет осуществлять доступ к специальным характеристикам устройств, не перегружая смысл других системных вызовов. Например, для стримера существует <em>ioctl</em> для записи метки конца ленты, но нет особой или измененной версии функции <em>write</em>.</p></div></div><div class=sect3><h4 id=_механизм_межпроцессных_коммуникаций_посредством_сокетов>2.1.6.4. Механизм межпроцессных коммуникаций посредством сокетов<a class=anchor href=#_механизм_межпроцессных_коммуникаций_посредством_сокетов></a></h4><div class=paragraph><p>В ядре 4.2BSD появился механизм межпроцессного взаимодействия, более гибкий, чем каналы, основанный на <em>сокетах</em>. Сокет является конечной точкой коммуникаций, доступный через дескриптор, как файл или канал. Каждый из двух процессов может создать сокет, а затем соединить эти конечные точки для получения надежного канала передачи потока байт. После соединения процесс может выполнять с дескрипторами операции чтения и записи, как это делалось с каналами. Прозрачность сокетов позволяет ядру перенаправить вывод одного процесса на вход другого, работающего на другой машине. Большим различием между каналами и сокетами является то, что каналы требуют наличия общего родительского процесса для установки коммуникации. Соединение между сокетами может быть установлено двумя несвязанными процессами, возможно, работающими на разных машинах.</p></div><div class=paragraph><p>System V предоставляет механизм локального межпроцессного взаимодействия через FIFO (также называемые <em>именованными каналами</em>). FIFO отображаются как объекты файловой системы, которые могут быть открыты несвязанными процессами, и в которые можно открывать и посылать данные так же, как в случае каналов. Таким образом, FIFO не требуют общего родительского процесса для установки соединения; они могут быть соединены после того, как будут запущены два процесса. В отличие от сокетов, FIFO могут быть использованы только на локальной машине; они не могут быть использованы для связи между процессами, работающими на разных машинах. FIFO реализованы в 4.4BSD, потому что это требует стандарт POSIX.1. Их функциональность является подмножеством функций интерфейса сокетов.</p></div><div class=paragraph><p>Механизм сокетов требует расширения традиционных для UNIX системных вызовов ввода/вывода для обеспечения соответствующих имен и смыслов соединениям. Вместо того, чтобы перегружать существующий интерфейс, разработчики использовали существующие интерфейсы, расширив их так, что они продолжили работать без изменений, и разработали новые интерфейсы для работы с новыми возможностями. Системные вызовы <em>read</em> и <em>write</em> использовались для соединений типа потока байт, и было добавлено шесть новых системных вызовов, что позволило посылать и принимать адресованные сообщения, такие, как сетевые датаграммы. Системные вызовы для записи сообщений включают в себя <em>send</em>, <em>sendto</em> и <em>sendmsg</em>. Системные вызовы для чтения сообщений включают <em>recv</em>, <em>recvfrom</em> и <em>recvmsg</em>. В ретроспективе, первые два в каждом классе являются особыми случаями других; <em>recvfrom</em> и <em>sendto</em>, наверное, должны были быть добавлены как библиотечные интерфейсы к <em>recvmsg</em> и <em>sendmsg</em>, соответственно.</p></div></div><div class=sect3><h4 id=_множественный_вводвывод>2.1.6.5. Множественный ввод/вывод<a class=anchor href=#_множественный_вводвывод></a></h4><div class=paragraph><p>Кроме традиционных системных вызовов <em>read</em> и <em>write</em>, в 4.2BSD появилась возможность выполнять множественный ввод/вывод. Множественный ввод использует системный вызов <em>readv</em> для размещения результата единственной операции чтения в нескольких различных буферах. Обратно, системный вызов <em>writev</em> позволяет осуществлять запись нескольких различных буферов за одну атомарную операцию записи. Вместо передачи одного буфера и его длины в качестве параметров, как это делается при использовании системных вызовов <em>read</em> и <em>write</em>, процесс передает указатель на массив буферов и их длин, а также счетчик, определяющий размер массива.</p></div><div class=paragraph><p>Такой механизм позволяет буферам в различных областях адресного пространства процесса записываться атомарно, без необходимости копировать их в один буфер. Атомарные операции записи необходимы в случае, когда низкоуровневые абстракции основаны на записях, например, стримеры, которые выводят блок ленты при каждом запросе на запись. Также полезна возможность помещать результат одного запроса на чтение в нескольких различных буферах (например, заголовок записи в одно место, а данные в другое). Хотя приложение может симулировать возможность выполнять множественные операции посредством чтения данных в большой буфер с последующим копированием их частей в нужные области, и накладные расходы на копирование в памяти в таких случаях часто увеличивает время выполнения приложения чуть ли не вдвое.</p></div><div class=paragraph><p>Так же, как <em>send</em> и <em>recv</em> могут быть реализованы в виде библиотечных интерфейсов к <em>sendto</em> и <em>recvfrom</em>, возможно симулирование <em>read</em> через <em>readv</em> и <em>write</em> через <em>writev</em>. Однако <em>read</em> и <em>write</em> используются столь часто, что накладные расходы на такую симуляцию не стоят того.</p></div></div><div class=sect3><h4 id=_поддержка_нескольких_файловых_систем>2.1.6.6. Поддержка нескольких файловых систем<a class=anchor href=#_поддержка_нескольких_файловых_систем></a></h4><div class=paragraph><p>Вместе с распространением сетевых вычислений возникла потребность в поддержке как локальных, так и удаленных файловых систем. Для облегчения поддержки нескольких файловых систем разработчики добавили в ядро интерфейс виртуальных узлов файловой системы, или интерфейс <em>vnode</em>. Набор операций, экспортируемых через интерфейс vnode, похож на операции файловой системы, ранее поддерживаемые локальной файловой системой. Однако они могут поддерживаться широким спектром типов файловых систем:</p></div><div class=ulist><ul><li><p>Локальные файловые системы, использующие диск</p></li><li><p>Файлы, импортируемые при помощи разнообразных протоколов удаленных файловых систем</p></li><li><p>Файловые системы CD-ROM, доступные только для чтения</p></li><li><p>Файловые системы, предоставляющие специализированные услуги - к примеру, файловая система <span class=filename>/proc</span></p></li></ul></div><div class=paragraph><p>Некоторые варианты 4.4BSD, такие, как FreeBSD, позволяют выполнять динамическую загрузку файловых систем при первом обращении к ним при помощи системного вызова <em>mount</em>. Интерфейс vnode описан в Разделе 6.5; вдобавок он поддерживает функции, описанные в Разделе 6.6; некоторые из файловых систем специального назначения описаны в Разделе 6.7.</p></div></div></div><div class=sect2><h3 id=overview-filesystem>2.1.7. Файловые системы<a class=anchor href=#overview-filesystem></a></h3><div class=paragraph><p>Обычный файл представляет собой массив байтов, и может читаться и записываться, начиная с произвольного байта файла. Ядро не различает в обычных файлах границ записей, хотя многие программы воспринимают символы перевода строки в качестве признаков конца строк, но другие программы могут предполагать наличие других структур. В самом файле не хранится никакой системной информации о файле, но в файловой системе размещается некоторая информация о владельце, правах доступа и об использовании каждого файла.</p></div><div class=paragraph><p>Компонент под названием <em>имя файла</em> является строкой длиной до 255 символов. Эти имена хранятся в файле особого типа, который называется <em>каталогом</em>. Информация о файле в каталоге называется <em>записью каталога</em> и включает, кроме имени файла, указатель на сам файл. Записи каталога могут ссылаться как на другие каталоги, так и на обычные файлы. Таким образом формируется иерархия каталогов и файлов, которая и называется файловой системой <em>filesystem</em>;</p></div><div id=fig-small-fs class=imageblock><div class=content><img src=../../../images/books/design-44bsd/fig2.png alt="Дерево небольшой файловой системы"></div><div class=title>Рисунок 2. Небольшая файловая система</div></div><div class=paragraph><p>Одна небольшая файловая система показана на <a href=#fig-small-fs>Небольшая файловая система</a>. Каталоги могут содержать подкаталоги, и нет ограничений вложенности одного каталога в другой по глубине. Для соблюдения целостности файловой системы, ядро не позволяет процессу производить запись непосредственно в каталоги. Файловая система может хранить не только обычные файлы и каталоги, но также ссылки на другие объекты, такие, как устройства и сокеты.</p></div><div class=paragraph><p>Файловая система образует дерево, начало которого находится в <em>корневом каталоге</em>, иногда называемому по имени <em>слэш</em>, которое соответствует символу одинарной наклонной черты (/). Корневой каталог содержит файлы; в нашем примере на Рисунке 2.2, он содержит <span class=filename>vmunix</span>, копию выполнимого объектного файла ядра. В нем также расположены каталоги; в этом примере он содержит каталог <span class=filename>usr</span>. Внутри каталога <span class=filename>usr</span> располагается каталог <span class=filename>bin</span>, который в основном содержит выполнимый объектный код программ, таких, как <span class=filename>ls</span> и <span class=filename>vi</span>.</p></div><div class=paragraph><p>Процесс обращается к файлу, указывая <em>путь</em> до него, который является строкой, состоящей из нескольких или ни одного имен файлов, разделенных символами слэша (/). С каждым процессом ядро связывает два каталога, при помощи которых можно интерпретировать маршруты до файлов. <em>Корневой каталог</em> процесса является самой верхней точкой файловой системы, которую может достичь процесс; обычно он соответствует корневому каталогу всей файловой системы. Маршрут, начинающийся с символа слэша, называется <em>абсолютным маршрутом</em>, и интерпретируется ядром, начиная с корневого каталога процесса.</p></div><div class=paragraph><p>Имя пути, которое не начинается со слэша, называется <em>относительным маршрутом</em>, и интерпретируется относительно <em>текущего рабочего каталога</em> процесса. (Этот каталог кратко также называют <em>текущим каталогом</em> или <em>рабочим каталогом</em>.) Текущий каталог сам по себе можно обозначить непосредственно по имени <em>dot</em>, что соответствует одной точке (<span class=filename>.</span>). Имя файла <em>dot-dot</em> (<span class=filename>..</span>) обозначает родительский каталог текущего каталога. Корневой каталог является предком самому себе.</p></div><div class=paragraph><p>Процесс может задать собственный корневой каталог при помощи системного вызова <em>chroot</em>, и установить текущий каталог системным вызовом <em>chdir</em>. Каждый процесс может в любой момент выполнить вызов <em>chdir</em>, но <em>chroot</em> позволено выполнять только процессу с административными привилегиями. <em>Chroot</em> обычно используется для ограничения доступа к системе.</p></div><div class=paragraph><p>Взяв файловую систему, изображенную на Рисунке 2.2, и полагая, что процесс имеет в качестве корневого каталога корневой каталог файловой системы, и в качестве текущего каталога <span class=filename>/usr</span>, он может обратиться к файлу <span class=filename>vi</span> либо от корня по абсолютному имени <span class=filename>/usr/bin/vi</span>, либо из текущего каталога с относительным именем <span class=filename>bin/vi</span>.</p></div><div class=paragraph><p>Системные утилиты и базы данных располагаются в нескольких всем известных каталогах. Частью предопределенной иерархии является каталог, содержащий <em>домашний каталог</em> для каждого пользователя - например, <span class=filename>/usr/staff/mckusick</span> и <span class=filename>/usr/staff/karels</span> на Рисунке 2.2. Когда пользователи регистрируются в системе, то рабочий каталог их командного процессора устанавливается в домашний каталог. В своих домашних каталогах пользователи могут создавать каталоги так же легко, как и обычные файлы. Таким образом, пользователь может строить иерархии каталогов произвольной сложности.</p></div><div class=paragraph><p>Пользователь обычно знает только об одной файловой системе, но система может знать, что одна виртуальная файловая система на самом деле состоит из нескольких физических файловых систем, каждая из которых расположена на отдельном устройстве. Физическая файловая система не может располагаться на нескольких физических устройствах. Так как большинство физических дисковых устройств разбиваются на несколько логических устройств, то на одном физическом устройстве может располагаться более одной файловой системы, но не более одной для каждого логического устройства. Одна из файловых систем - та, с которой начинаются все абсолютные имена - называется <em>корневой файловой системой</em>, и она всегда доступна. Другие файловые системы могут монтироваться; это значит, что они могут интегрироваться в иерархию каталогов корневой файловой системы. Ссылки на каталог, в котором находится смонтированная в него файловая системе, прозрачно преобразуются ядром в ссылки на корневой каталог смонтированной файловой системы.</p></div><div class=paragraph><p>Системный вызов <em>link</em> в качестве параметров принимает имя существующего файла и новое имя, которое будет присвоено файлу. После успешного выполнения вызова <em>link</em>, файл может быть доступен по любому из имен. Имя файла может быть удалено при помощи системного вызова <em>unlink</em>. Когда удаляется последнее имя для файла (и последний процесс, который держал файл открытым, закрыл его), удаляется и сам файл.</p></div><div class=paragraph><p>Файлы организованы иерархически в <em>каталоги</em>. Каталог является типом файла, но, в отличие от обычных файлов, каталог имеет структуру, определяемую системой. Процесс может читать каталог, как будто это обычный файл, но только ядру разрешено изменять каталог. Каталоги создаются системным вызовом <em>mkdir</em> и удаляются системным вызовом <em>rmdir</em>. До 4.2BSD системные вызовы <em>mkdir</em> и <em>rmdir</em> были реализованы как последовательность системных вызовов <em>link</em> и <em>unlink</em>. Имелось три причины для добавления системных вызовов специально для создания и удаления каталогов:</p></div><div class="olist arabic"><ol class=arabic><li><p>Операция может быть сделана атомарной. Если система завершила работу аварийно, то каталог не может оставаться в промежуточном состоянии, что может случиться при последовательном вызове серии операций.</p></li><li><p>При работе сетевой файловой системы создание и удаление файлов и каталогов должны выполняться атомарно, чтобы могли выполняться последовательно.</p></li><li><p>При реализации поддержки не-UNIX файловых систем, таких, как файловая система MS-DOS, на другом разделе диска, может оказаться, что эта файловая система не поддерживает ссылочных операций. Хотя другие файловые системы могут поддерживать концепцию каталогов, скорее всего, они не будут создавать и удалять каталоги со ссылками, как это делается в файловой системе UNIX. Соответственно они могут создавать и и удалять каталоги только при наличии явных запросов на удаление или создание каталогов.</p></li></ol></div><div class=paragraph><p>Системный вызов <em>chown</em> устанавливает владельца и группу файла, а <em>chmod</em> изменяет атрибуты защиты. Вызов <em>stat</em>, примененный к имени файла, может использоваться для чтения этих свойств файла. Системные вызовы <em>fchown</em>, <em>fchmod</em> и <em>fstat</em> применяются с дескрипторами, а не с именами файлов, для выполнения того же самого набора операций. Системный вызов <em>rename</em> может использоваться для присвоения файлу нового имени в файловой системе с заменой старого имени файла. Как и операции по созданию и удалению каталогов, системный вызов <em>rename</em> был добавлен в 4.2BSD для придания атомарности изменению имен в локальной файловой системе. Позже он оправдал свою исключительную полезность для экспортирования операций по переименованию в сторонних файловых системах и по сети.</p></div><div class=paragraph><p>Системный вызов <em>truncate</em> был добавлен в 4.2BSD для того, чтобы файлы могли обрезаться по указанному смещению. Вызов был добавлен первоначально для поддержки библиотеки времени выполнения языка Fortran, в котором применялось понятие конца файла с произвольным доступом, который мог устанавливаться в любую позицию, в которой был последний раз доступ к файлу. Без системного вызова <em>truncate</em> единственным способом обрезать файл было копирование нужной части в новый файл, удаление старого и переименование копии в первоначальное имя. Библиотека могла теоретически отказываться работать на заполненной файловой системе, к тому же такой алгоритм оказывался медленным.</p></div><div class=paragraph><p>После того, как файловая система получила возможность обрезать файлы, ядро применяло эту возможность для уменьшения больших пустых каталогов. Преимущество в уменьшении пустых каталогов заключается в сокращении времени ядра на поиск в них при создании или удалении имен.</p></div><div class=paragraph><p>Вновь создаваемым файлам присваивается идентификатор пользователя процесса, который их создал, и идентификатор группы каталога, в котором они были созданы. Для защиты файлов применяется трехуровневый механизм управления доступом. Эти три уровня определяют доступность файла для</p></div><div class="olist arabic"><ol class=arabic><li><p>Пользователя, который является владельцем файла</p></li><li><p>Группы, которая приписана файлу</p></li><li><p>Всех остальных</p></li></ol></div><div class=paragraph><p>Каждый уровень доступа имеет отдельные индикаторы прав для чтения, записи и выполнения.</p></div><div class=paragraph><p>Файлы создаются с нулевым размером, который может увеличиться при выполнении операций записи. Пока файл открыт, система отслеживает указатель на файл, соответствующий текущему положению в файле, связанном с дескриптором. Этот указатель может перемешаться по файлу в произвольном порядке. Процессы, использующие один и тот же дескриптор файла посредством системных вызовов <em>fork</em> или <em>dup</em>, используют одновременно один и тот же указатель текущей позиции. Дескрипторы, созданные различными системными вызовами <em>open</em>, имеют различные указатели текущей позиции. В файлах могут присутствовать <em>дыры</em>. Дыры представляют собой пустые пространства в теле файла, в которые никаких данных не записывалось. Процесс может создать такие дыры, перемещая указатель за текущий конец файла и производя запись. При чтении дыры интерпретируются системой как заполненные нулевыми байтами.</p></div><div class=paragraph><p>Ранние версии UNIX имели ограничение в 14 символов на имя файла. Это ограничение зачастую вызывало проблемы. Например, кроме естественного желания пользователей давать файлам длинные описательные имена, распространенным способом формировать имена файлов является использование формата <span class=filename>basename.extension</span>, где расширение (указывающее на тип файла, скажем, <code>.c</code> для исходного года на языке C или <code>.o</code> для промежуточного двоичного объекта) имеет длину от одного до трех символов, оставляя от 10 до 12 символов на имя файла. Системы управления исходным кодом и редакторы обычно используют дополнительно два символа для своих целей, для префикса или суффикса имени файла, при этом остается от восьми до 10 символов. В качестве имени файла легко использовать от 10 до 12 символов одного английского слова (например, <code>multiplexer</code>).</p></div><div class=paragraph><p>Можно смириться с этими ограничениями, но это непоследовательно и даже опасно, потому что другие системы UNIX могут работать со строками, превышающими этот лимит, при создании файлов, но затем имя будет <em>обрезано</em>. Исходный файл с именем <span class=filename>multiplexer.c</span>, содержащий исходный код на языке C, (уже 13 символов) может иметь соответствующий файл из системы управления исходным кодом с префиксом <code>s.</code>, при этом получается имя файла <span class=filename>s.multiplexer</span>, которое не не будет отличаться от файла системы управления исходным кодом для файла <span class=filename>multiplexer.ms</span>, содержащего исходный код <code>troff</code> для документации программы на языке C. Содержимое двух оригинальных файлов может оказаться перепутанным без каких-либо предупреждений от системы управления исходным кодом. При тщательном кодировании эту проблему можно обнаружить, но поддержка длинных имен файлов, впервые появившаяся в 4.2BSD, практически полностью ликвидировала эту проблему.</p></div></div><div class=sect2><h3 id=overview-filestore>2.1.8. Размещение файлов<a class=anchor href=#overview-filestore></a></h3><div class=paragraph><p>Операции, определенные для локальных файловых систем, делятся на две категории. Общими для всех локальных систем являются иерархический принцип именования, блокировка, квоты, управление атрибутами и защита. Эти механизмы не зависят от того, как хранятся данные. В 4.4BSD имеется единая реализация для предоставления этих сервисов.</p></div><div class=paragraph><p>Другой частью локальной файловой системы является организация и управление данными на носителях информации. Размещение содержимого файлов на носителях является вопросом хранилища файлов. В 4.4BSD поддерживает три различных типа хранилищ файлов:</p></div><div class=ulist><ul><li><p>Традиционная файловая система Berkeley Fast Filesystem</p></li><li><p>Журналируемая файловая система, основанная на архитектуре операционной системы Sprite <a href=#biblio-rosenblum>[Rosenblum & Ousterhout, 1992]</a></p></li><li><p>Файловая система в памяти</p></li></ul></div><div class=paragraph><p>Хотя организация этих хранилищ совершенно различна, эти различия скрыты от процессов, использующих файловые системы.</p></div><div class=paragraph><p>В файловой системе Fast Filesystem организует данные в группы дорожек. Файлы, к которым, скорее всего, будет осуществляться доступ одновременно (на основе их расположения в иерархии файловой системы), хранятся на одной и той же группе дорожек. Файлы, к которым не предполагается одновременный доступ, перемещаются на разные группы дорожек. Таким образом, файлы, записываемые в одно и то же время, могут располагаться в абсолютно разных областях диска.</p></div><div class=paragraph><p>Файловая система с журнальной организацией организует данные в виде журнала. Все данные, записываемые в некоторый момент времени, собираются вместе и записываются в одно и то же место диска. Данные никогда не перезаписываются; вместо этого записывается новая копия файла, которая заменяет старую. Старые файлы уничтожаются процессом-сборщиком мусора, который запускается, когда файловая система переполняется и появляется необходимость в свободном пространстве.</p></div><div class=paragraph><p>Файловая система в памяти предназначена для хранения данных в виртуальной памяти. Она используется для файловых систем, в которых должны храниться временные данные с обеспечением быстрого доступа к ним, к примеру, <span class=filename>/tmp</span>. При организации файловой системы в памяти преследуется цель организовать максимально компактное хранение данных для минимизации использования ресурсов виртуальной памяти.</p></div></div><div class=sect2><h3 id=overview-nfs>2.1.9. Сетевая файловая система<a class=anchor href=#overview-nfs></a></h3><div class=paragraph><p>Изначально сетевые возможности использовались для передачи данных от одной машины к другой. Позже это получило свое развитие в обеспечении подключения пользователей удаленно к другим машинам. Следующим логическим шагом было предоставление данных пользователю, а не приближение пользователя к данным - так родились сетевые файловые системы. Пользователи, работающие локально, не ощущают сетевых задержек при каждом нажатии клавиши, так что они получают более удобное рабочее окружение.</p></div><div class=paragraph><p>Подключение файловой системы к локальной машине было одним из первых основных клиент-серверных приложений. <em>Сервер</em> является удаленной машиной, которая экспортирует одну или более своих файловых систем. <em>Клиентом</em> является локальная машина, которая импортирует эти файловые системы. С точки зрения локального клиента, смонтированные удаленные файловые системы появляются в пространстве имен дерева файлов, как любая другая локально смонтированная файловая система. Локальные клиенты могут перемещаться в каталоги на удаленной файловой системе, и могут осуществлять чтение, запись и выполнение двоичных файлов на удаленной файловой системе точно так же, как они выполняют эти операции на локальной файловой системе.</p></div><div class=paragraph><p>Когда локальный клиент выполняет операцию на удаленной файловой системе, оформляется и посылается запрос к серверу. Сервер выполняет запрошенную операцию и возвращает либо запрошенную информацию, либо ошибку, почему запрос был отклонен. Для получения удовлетворительной производительности, клиент должен кэшировать данные, к которым доступ осуществляется часто. Сложность удаленных файловых систем отражается на поддержке соответствия между сервером и множеством его клиентов.</p></div><div class=paragraph><p>Хотя за эти годы было разработано множество протоколов работы с удаленными файловыми системами, самой распространенной на системах UNIX является сетевая файловая система Network Filesystem (NFS), которая была спроектирована и реализована в Sun Microsystems. Ядро 4.4BSD поддерживает протокол NFS, хотя его реализация была выполнена независимо от спецификаций протокола <a href=#biblio-macklem>[Macklem, 1994]</a>. Протокол NFS описан в Главе 9.</p></div></div><div class=sect2><h3 id=overview-terminal>2.1.10. Терминалы<a class=anchor href=#overview-terminal></a></h3><div class=paragraph><p>Терминалы поддерживают стандартные системные операции ввода/вывода, а также набор операций, специфичных для терминалов, для управления редактированием входных символов и задержек вывода. На самом нижнем уровне находятся драйверы терминальных устройств, которые управляют портами аппаратных терминалов. Терминальный ввод обрабатывается согласно низлежащим характеристикам связи, таким, как скорость передачи, и согласно набору программно контролируемых параметров, таких, как контроль четности.</p></div><div class=paragraph><p>Выше уровня драйверов терминальных устройств находятся режимы каналов, которые обеспечивают различные уровни обработки символов. По умолчанию режим работы канала выбирается, когда порт используется для интерактивного входа в систему. Режим работы канала устанавливается в <em>канонический</em>; входной поток обрабатывается так, что обеспечиваются стандартные функции, ориентированные на редактирование строк, и он представляется процессу в виде целых строк.</p></div><div class=paragraph><p>Экранные редакторы и программы, которые взаимодействуют с другими машинами, обычно работают в <em>неканоническом режиме</em> (часто называемом <em>raw-режимом</em> или <em>посимвольным режимом</em>). В этом режиме входной поток передается в читающий процесс сразу же и без всякой обработки. Выключается вся обработка специальных символов, не выполняется удаление символов и другое редактирование строк, все символы передаются программе, которая выполняет чтение с терминала.</p></div><div class=paragraph><p>Терминал может быть настроен тысячами различных способов, промежуточных между этими двумя. Например, экранный редактор, которому необходимо получать прерывания от пользователя асинхронно, может разрешить использование специальных символов, которые генерируют сигналы и разрешить управление выходным потоком, в противном случае работать в неканоническом режиме; все остальные символы будут передаваться в процесс необработанными.</p></div><div class=paragraph><p>Что касается выходного потока, то терминальный обработчик предоставляет простые службы по его форматированию, включая</p></div><div class=ulist><ul><li><p>Преобразование символа перевода строки на двухсимвольную последовательность из символов возврата каретки и перевода строки</p></li><li><p>Выдерживание пауз после некоторых стандартных управляющих символов</p></li><li><p>Замещение символов табуляции</p></li><li><p>Вывод неграфических символов ASCII в виде двухсимвольных последовательностей вида <code>^C</code> (другими словами, вывод знака вставки, за которым следует символ, который находится по смещению от символа <code>@</code>, соответствующему значению этого символа).</p></li></ul></div><div class=paragraph><p>Каждый из этих сервисов преобразования может быть независимо выключен процессом при помощи управляющих запросов.</p></div></div><div class=sect2><h3 id=overview-ipc>2.1.11. Коммуникации между процессами<a class=anchor href=#overview-ipc></a></h3><div class=paragraph><p>Межпроцессные коммуникации в 4.4BSD организованы в <em>коммуникационные домены</em>. К поддерживаемым на данный момент доменам относятся <em>локальный домен</em> для взаимодействия между процессами, выполняющимися на одной и той же машине; <em>межсетевой домен</em> для связи между процессами посредством набора протоколов TCP/IP (возможно, в сети Интернет); семейство протоколов ISO/OSI для взаимодействия между сайтами, которым нужна именно такая связь, и <em>домен XNS</em> для коммуникаций между процессами при помощи протоколов XEROX Network Systems (XNS).</p></div><div class=paragraph><p>В пределах домена соединения имеют место между конечными точками связи, также называемыми <em>сокетами</em>. Как отмечено в Разделе 2.6, системный вызов <em>socket</em> создает сокет и возвращает дескриптор; другие системные вызовы IPC описаны в Главе 11. Каждый сокет имеет тип, определяющий его коммуникационные свойства; к ним относятся такие характеристики, как надежность, сохранение последовательности передаваемой информации и предупреждение дублирования сообщений.</p></div><div class=paragraph><p>с каждым сокетом связан некоторый <em>коммуникационный протокол</em>. Этот протокол обеспечивает выполнение операций, требуемых сокету, согласно его типу. Приложения могут задавать нужный протокол при создании сокета или могут разрешить системе выбрать протокол, который соответствует типу создаваемого сокета.</p></div><div class=paragraph><p>Сокеты могут иметь адреса, связанные с ними. Формат и смысл адресов сокетов зависят от коммуникационного домена, в котором был создан сокет. Привязка имени к сокету в локальном домене приводит к созданию файла в файловой системе.</p></div><div class=paragraph><p>Обычные данные, передаваемые и получаемые при помощи сокетов, не имеют типа. Вопросы представления данных зависят от библиотек, которые находятся на верху коммуникационных сервисов. Вдобавок к передаче обычных данных, коммуникационные домены могут поддерживать передачу и прием специальных типов данных, которые называются <em>правами доступа</em>. Например, локальный домен использует эту возможность для передачи дескрипторов между процессами.</p></div><div class=paragraph><p>До 4.2BSD сетевые реализации в UNIX обычно работали через интерфейсы символьных устройств. Одной из целей создания интерфейса сокетов было обеспечение работы простеньким программам без изменения на потоковых соединениях. Такие программы могут работать, если только не меняются системные вызовы <em>read</em> и <em>write</em>. Соответственно, оригинальные интерфейсы не трогались, но были исправлены для работы с потоковыми сокетами. Для более сложных сокетов, таких, как те, что используются для посылки датаграмм и в которых при каждом вызове <em>send</em> должен указываться адрес назначения, был добавлен новый интерфейс.</p></div><div class=paragraph><p>Другим достоинством является то, что новый интерфейс легко переносим. Вскоре после тестового релиза, полученного из Беркли, интерфейс сокетов был перенесен в System III поставщиком UNIX (хотя AT&amp;T не поддерживала интерфейс сокетов до выхода System V Release 4, решив использовать вместо него механизм потоков из Eighth Edition). Интерфейс сокетов был также перенесен для работы на многих адаптерах Ethernet поставщиками, такими, как Excelan и Interlan, который продавался на рынке PC, где компьютеры были слишком слабыми, чтобы обрабатывать сетевой код на основном процессоре. Сравнительно недавно интерфейс сокетов был использован в качестве основы для сетевого интерфейса Winsock от Microsoft для Windows.</p></div></div><div class=sect2><h3 id=overview-network-communication>2.1.12. Сетевые коммуникации<a class=anchor href=#overview-network-communication></a></h3><div class=paragraph><p>Некоторые из коммуникационных доменов, поддерживаемых IPC-механизмом <em>сокетов</em> дают доступ к сетевым протоколам. Эти протоколы реализованы как отдельный программный слой, логически находящийся ниже программного обеспечения сокетов в ядре. Ядро предоставляет много вспомогательных сервисов, таких, как управление буферами, маршрутизация сообщений, стандартные интерфейсы к протоколам и интерфейсы к драйверам сетевых интерфейсов для использования в различных сетевых протоколах.</p></div><div class=paragraph><p>В те времена, когда разрабатывалась 4.2BSD, использовалось или разрабатывалось много сетевых протоколов, каждый со своими сильными и слабыми сторонами. Не существует единственного подходящего на все случаи жизни протокола или набора протоколов. Поддерживая много протоколов, 4.2BSD может обеспечить взаимодействие и обмен ресурсами между различными машинами, которые были доступны в Беркли. Поддержка многих протоколов необходим также для изменений в будущем. Современные протоколы, разработанные для Ethernet со скоростями работы 10 и 100 Mbit в секунду, вряд ли будут соответствовать для завтрашних оптических сетей пропускной способностью 1 и 10 Gbit в секунду. Поэтому уровень сетевых коммуникаций разработан с учетом поддержки многих протоколов. Новые протоколы добавляются к ядру, не затрагивая поддержку старых протоколов. Старые приложения могут продолжать работать с использованием старых протоколов в той же самой физической сети, что использовалась для новых приложений, работающих с новым сетевым протоколом.</p></div></div><div class=sect2><h3 id=overview-network-implementation>2.1.13. Сетевая реализация<a class=anchor href=#overview-network-implementation></a></h3><div class=paragraph><p>Первым набором протоколов, реализованным в 4.2BSD, был Transmission Control Protocol/Internet Protocol (TCP/IP) от DARPA. CSRG выбрала TCP/IP в качестве первого для включения в набор протоколов IPC, потому что реализация на основе 4.1 была всем доступна из проекта, спонсируемого DARPA, в Bolt, Beranek и Newman (BBN). Это был выбор, повлиявший на многое: Реализация в 4.2BSD стала основной причиной очень широкой распространенности и использования этого набора протоколов. Более поздние усовершенствования производительности и возможностей TCP/IP были также широко приняты. Реализация TCP/IP подробно описана в Главе 13.</p></div><div class=paragraph><p>В релизе 4.3BSD появился набор протоколов Xerox Network Systems (XNS), частично основанный на работе, выполненной в Университете Мэрилэнда и Университете Корнелла. Этот набор был нужен для объединения отдельных машин, которые не могли работать с протоколом TCP/IP.</p></div><div class=paragraph><p>В релиз 4.4BSD был добавлен набор протоколов ISO из-за его все большей распространенности как внутри, так и во вне США. По причине использования в протоколах ISO несколько другого подхода к сети, в интерфейсе сокетов потребовалось сделать некоторые небольшие изменения для реализации этого подхода. Изменения были сделаны так, что они были незаметны для клиентов других существующих протоколов. Протоколы ISO требуют также большой работы с двухуровневыми таблицами маршрутизации, имеющимися в 4.3BSD. К значительно расширенным возможностям по маршрутизации в 4.4BSD относятся раздельные уровни маршрутизации с адресами переменной длины и сетевыми масками.</p></div></div><div class=sect2><h3 id=overview-operation>2.1.14. Работа системы<a class=anchor href=#overview-operation></a></h3><div class=paragraph><p>Механизмы начальной загрузки используются для запуска системы. Сначала ядро 4.4BSD должно быть загружено в основную память процессора. После загрузки оно должно пройти через фазу инициализации для установки аппаратуры в известное состояние. Затем ядро должно выполнить автоконфигурацию, в процессе которой распознаются и настраиваются периферийные устройства, подключенные к процессору. Система начинает работу в однопользовательском режиме, пока начальный скрипт выполняет проверку дисков и включает подсчет статистики и использования квот. Наконец, начальный скрипт запускает общесистемные службы и переводит систему в полностью многопользовательский режим.</p></div><div class=paragraph><p>При работе в многопользовательском режиме процессы ждут запросов на вход в систему с терминальных линий и сетевых портов, которые были настроены на вход пользователей. После обнаружения запроса на вход, вызывается процесс входа в систему и выполняется аутентификация пользователя. Если она прошла успешно, запускается начальная оболочка, из которой пользователь может запускать дополнительные процессы.</p></div></div></div></div><div class=sect1><h2 id=references>Ссылки<a class=anchor href=#references></a></h2><div class=sectionbody><div class=paragraph><p><a id=biblio-accetta></a>Accetta et al, 1986 Mach: A New Kernel Foundation for UNIX Development" M.Accetta R.Baron W.Bolosky D.Golub R.Rashid A.Tevanian M.Young 93-113 USENIX Association Conference Proceedings USENIX Association June 1986</p></div><div class=paragraph><p><a id=biblio-cheriton></a>Cheriton, 1988 The V Distributed System D. R.Cheriton 314-333 Comm ACM, 31, 3 March 1988</p></div><div class=paragraph><p><a id=biblio-ewens></a>Ewens et al, 1985 Tunis: A Distributed Multiprocessor Operating System P.Ewens D. R.Blythe M.Funkenhauser R. C.Holt 247-254 USENIX Assocation Conference Proceedings USENIX Association June 1985</p></div><div class=paragraph><p><a id=biblio-gingell></a>Gingell et al, 1987 Virtual Memory Architecture in SunOS R.Gingell J.Moran W.Shannon 81-94 USENIX Association Conference Proceedings USENIX Association June 1987</p></div><div class=paragraph><p><a id=biblio-kernighan></a>Kernighan & Pike, 1984 The UNIX Programming Environment B. W.Kernighan R.Pike Prentice-Hall Englewood Cliffs NJ 1984</p></div><div class=paragraph><p><a id=biblio-macklem></a>Macklem, 1994 The 4.4BSD NFS Implementation R.Macklem 6:1-14 4.4BSD System Manager’s Manual O’Reilly & Associates, Inc. Sebastopol CA 1994</p></div><div class=paragraph><p><a id=biblio-mckusick-2></a>McKusick & Karels, 1988 Design of a General Purpose Memory Allocator for the 4.3BSD UNIX Kernel M. K.McKusick M. J.Karels 295-304 USENIX Assocation Conference Proceedings USENIX Assocation June 1998</p></div><div class=paragraph><p><a id=biblio-mckusick-1></a>McKusick et al, 1994 Berkeley Software Architecture Manual, 4.4BSD Edition M. K.McKusick M. J.Karels S. J.Leffler W. N.Joy R. S.Faber 5:1-42 4.4BSD Programmer’s Supplementary Documents O’Reilly & Associates, Inc. Sebastopol CA 1994</p></div><div class=paragraph><p><a id=biblio-ritchie></a>Ritchie, 1988 Early Kernel Design private communication D. M.Ritchie March 1988</p></div><div class=paragraph><p><a id=biblio-rosenblum></a>Rosenblum & Ousterhout, 1992 The Design and Implementation of a Log-Structured File System M.Rosenblum K.Ousterhout 26-52 ACM Transactions on Computer Systems, 10, 1 Association for Computing Machinery February 1992</p></div><div class=paragraph><p><a id=biblio-rozier></a>Rozier et al, 1988 Chorus Distributed Operating Systems M.Rozier V.Abrossimov F.Armand I.Boule M.Gien M.Guillemont F.Herrmann C.Kaiser S.Langlois P.Leonard W.Neuhauser 305-370 USENIX Computing Systems, 1, 4 Fall 1988</p></div><div class=paragraph><p><a id=biblio-tevanian></a>Tevanian, 1987 Architecture-Independent Virtual Memory Management for Parallel and Distributed Environments: The Mach Approach Technical Report CMU-CS-88-106, A.Tevanian Department of Computer Science, Carnegie-Mellon University Pittsburgh PA December 1987</p></div></div></div></div><hr><div class=last-modified><p><strong>Изменено</strong>: 11 декабря 2021 г. by <a href="https://cgit.freebsd.org/doc/commit/?id=2b027dd017" target=_blank>Sergio Carlavilla Delgado</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Главная></i><div class=container><a href=../ class=direction>Главная</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Содержание</h3><nav id=TableOfContents><ul><li><a href=#overview>2.1. Обзор архитектуры 4.4BSD</a><ul><li><a href=#overview-facilities>2.1.1. Системные сервисы 4.4BSD и ядро</a></li><li><a href=#overview-kernel-organization>2.1.2. Организация ядра</a></li><li><a href=#overview-kernel-service>2.1.3. Службы ядра</a></li><li><a href=#overview-process-management>2.1.4. Управление процессами</a></li><li><a href=#overview-memory-management>2.1.5. Управление памятью</a></li><li><a href=#overview-io-system>2.1.6. Система ввода/вывода</a></li><li><a href=#overview-filesystem>2.1.7. Файловые системы</a></li><li><a href=#overview-filestore>2.1.8. Размещение файлов</a></li><li><a href=#overview-nfs>2.1.9. Сетевая файловая система</a></li><li><a href=#overview-terminal>2.1.10. Терминалы</a></li><li><a href=#overview-ipc>2.1.11. Коммуникации между процессами</a></li><li><a href=#overview-network-communication>2.1.12. Сетевые коммуникации</a></li><li><a href=#overview-network-implementation>2.1.13. Сетевая реализация</a></li><li><a href=#overview-operation>2.1.14. Работа системы</a></li></ul></li><li><a href=#references>Ссылки</a></li></ul></nav><hr><div class=resources><h3>Материалы</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Скачать PDF"></i><a href=https://download.freebsd.org/doc/ru/books/design-44bsd/design-44bsd_ru.pdf>Скачать PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Редактировать эту страницу"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/ru/_index target=_blank>Редактировать эту страницу</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/ru/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Выберите язык">
<span>Русский</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>Система</option><option value=theme-light>Светлый</option><option value=theme-dark>Тёмный</option><option value=theme-high-contrast>Высокая контрастность</option></select></div></div></section><section class=about-column><h3 class=column-title>О нас</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>Фонд FreeBSD</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Получить FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Кодекс Этики</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Бюллетени Безопасности</a></li></ul></section><section class=documentation-column><h3 class=column-title>Документация</h3><ul class=column-elements-container><li><a href=/ru class=column-element>Портал документации</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Страницы Справочника</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Презентации и публикации</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Предыдущие версии</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>Документы 4.4BSD</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Сообщество</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/ru/articles/contributing class=column-element>Принять участие</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Форум Сообщества</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Списки рассылки</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>Каналы IRC</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Трекер ошибок</a></li></ul></section><section class=legal-column><h3 class=column-title>Юридическая информация</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Пожертвования</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Лицензирование</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Политика Конфиденциальности</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Юридические оговорки</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 Проект FreeBSD. Все права защищены</p><span>Сделано с помощью <span class=heart>♥</span> Сообществом FreeBSD</span></section></div></footer></body></html>