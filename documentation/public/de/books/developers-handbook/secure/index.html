<!doctype html><html class=theme-light lang=de><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/de/books/developers-handbook/secure/><title>Kapitel 3. Sicheres Programmieren | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Kapitel 3. Sicheres Programmieren"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="https://docs.freebsd.org/de/books/developers-handbook/secure/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/de\/books\/developers-handbook\/secure\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=https://docs.freebsd.org/de/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/de/books>Books</a></li><li><a href=https://docs.freebsd.org/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-b1b18a35567534d1699b4dd27b58b2ff class=toggle>
<label for=chapter-b1b18a35567534d1699b4dd27b58b2ff><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/parti/>Teil I. Grundlagen</a></li><li><input type=checkbox id=chapter-3af9d0cd3607fbe44d37e3a13957c40f class=toggle>
<label class="icon cursor" for=chapter-3af9d0cd3607fbe44d37e3a13957c40f><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/introduction/>Kapitel 1. Einführung</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/introduction/#introduction-devel>1.1. Unter FreeBSD entwickeln</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/introduction/#introduction-bsdvision>1.2. Die Vision von BSD</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/introduction/#introduction-archguide>1.3. Grundlegende Richtlinien</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/introduction/#introduction-layout>1.4. Der Aufbau von <span class=filename>/usr/src</span></a></li></ul></li><li><input type=checkbox id=chapter-15219234c513f9a79d9cb2d3bcf73d13 class=toggle>
<label class="icon cursor" for=chapter-15219234c513f9a79d9cb2d3bcf73d13><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/>Kapitel 2. Werkzeuge zur Programmierung</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-synopsis>2.1. Überblick</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-intro>2.2. Zusammenfassung</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-programming>2.3. Einführung in die Programmierung</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-compiling>2.4. Kompilieren mit dem <code>cc</code></a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-make>2.5. Make</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#debugging>2.6. Debuggen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#emacs>2.7. Emacs als Entwicklungsumgebung verwenden</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-reading>2.8. Weiterführende Literatur</a></li></ul></li><li><input type=checkbox id=chapter-7319f5d899d5be33daaf1f2d5f180558 class=toggle checked>
<label class="icon cursor" for=chapter-7319f5d899d5be33daaf1f2d5f180558><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/>Kapitel 3. Sicheres Programmieren</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-synopsis>3.1. Zusammenfassung</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-philosophy>3.2. Methoden des sicheren Entwurfs</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-bufferov>3.3. Puffer-Überläufe</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-setuid>3.4. SetUID-Themen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-chroot>3.5. Die Umgebung ihrer Programme einschränken</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-trust>3.6. Vertrauen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-race-conditions>3.7. Race-Conditions</a></li></ul></li><li><input type=checkbox id=chapter-0240ccaf7010beed911378cfab7bd8fc class=toggle>
<label class="icon cursor" for=chapter-0240ccaf7010beed911378cfab7bd8fc><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/l10n/>Kapitel 4. Lokalisierung und Internationalisierung - L10N und I18N</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/l10n/#l10n-programming>4.1. I18N-konforme Anwendungen programmieren</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/l10n/#posix-nls>4.2. Lokalisierte Nachrichten mit POSIX.1 Native Language Support (NLS)</a></li></ul></li><li><input type=checkbox id=chapter-c3107aaf64e60e1ee09bc33fc9fd641a class=toggle>
<label class="icon cursor" for=chapter-c3107aaf64e60e1ee09bc33fc9fd641a><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/>Kapitel 5. Vorgaben und Richtlinien für das Quelltextverzeichnis</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/#policies-style>5.1. Stil-Richtlinien</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/#policies-maintainer>5.2. <code>MAINTAINER</code> eines Makefiles</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/#policies-contributed>5.3. Beigesteuerte Software</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/#policies-encumbered>5.4. Belastende Dateien</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/#policies-shlib>5.5. Shared-Libraries</a></li></ul></li><li><input type=checkbox id=chapter-c7b4fd5a7f8f049234fe3bc225acef44 class=toggle>
<label class="icon cursor" for=chapter-c7b4fd5a7f8f049234fe3bc225acef44><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/testing/>Kapitel 6. Regressions- und Performance-Tests</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/testing/#testing-micro-benchmark>6.1. Mikro-Benchmark-Checkliste</a></li></ul></li><li><input type=checkbox id=chapter-1f9b02a65f2bc5d4015a050d706fa837 class=toggle>
<label for=chapter-1f9b02a65f2bc5d4015a050d706fa837><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/partii/>Teil II. Interprozess-Kommunikation</a></li><li><input type=checkbox id=chapter-5e03777f678dd5731a581d7956d19c13 class=toggle>
<label for=chapter-5e03777f678dd5731a581d7956d19c13><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/sockets/>Kapitel 7. Sockets</a></li><li><input type=checkbox id=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3 class=toggle>
<label class="icon cursor" for=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/ipv6/>Kapitel 8. IPv6 Internals</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/ipv6/#ipv6-implementation>8.1. IPv6/IPsec-Implementierung</a></li></ul></li><li><input type=checkbox id=chapter-c9a07b517dc2e43d169c8e013e23cfc1 class=toggle>
<label for=chapter-c9a07b517dc2e43d169c8e013e23cfc1><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/partiii/>Teil III. Kernel</a></li><li><input type=checkbox id=chapter-db22f8e5e5e9496dbc711815e2e05f36 class=toggle>
<label class="icon cursor" for=chapter-db22f8e5e5e9496dbc711815e2e05f36><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/kernelbuild/>Kapitel 9. Einen FreeBSD-Kernel bauen und installieren</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kernelbuild/#kernelbuild-traditional>9.1. Einen Kernel auf die "traditionelle" Art und Weise bauen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kernelbuild/#kernelbuild-new>9.2. Einen Kernel auf die "neue" Art und Weise bauen</a></li></ul></li><li><input type=checkbox id=chapter-3036877c53948cfb76174f2776bbdf64 class=toggle>
<label class="icon cursor" for=chapter-3036877c53948cfb76174f2776bbdf64><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/>Kapitel 10. Kernel-Fehlersuche</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-obtain>10.1. Besorgen eines Speicherauszugs nach einem Kernel-Absturz (Kernel-Crash-Dump)</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-gdb>10.2. Fehlersuche in einem Speicherauszug nach einem Kernel-Absturz mit <code>kgdb</code></a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-ddd>10.3. Fehlersuche in einem Speicherauszug nach einem Absturz mit DDD</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-online-ddb>10.4. Online-Kernel-Fehlersuche mit DDB</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-online-gdb>10.5. Online-Kernel-Fehlersuche mit GDB auf einem entfernten System</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-console>10.6. Fehlersuche bei einem Konsolen-Treiber</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-deadlocks>10.7. Fehlersuche bei Deadlocks</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-options>10.8. Glossar der Kernel-Optionen zur Fehlersuche</a></li></ul></li><li><input type=checkbox id=chapter-86707094ce48d6e89e5f45569c084cea class=toggle>
<label for=chapter-86707094ce48d6e89e5f45569c084cea><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/partiv/>Teil IV. Architekturen</a></li><li><input type=checkbox id=chapter-43b1e1e6d2a94eb8b161876bc22ce644 class=toggle>
<label class="icon cursor" for=chapter-43b1e1e6d2a94eb8b161876bc22ce644><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/>Kapitel 11. x86-Assembler-Programmierung</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-intro>11.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-the-tools>11.2. Die Werkzeuge</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-system-calls>11.3. Systemaufrufe</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-return-values>11.4. Rückgabewerte</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-portable-code>11.5. Portablen Code erzeugen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-first-program>11.6. Unser erstes Programm</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-unix-filters>11.7. UNIX®-Filter schreiben</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-buffered-io>11.8. Gepufferte Eingabe und Ausgabe</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-command-line>11.9. Kommandozeilenparameter</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-environment>11.10. Die UNIX®-Umgebung</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-files>11.11. Arbeiten mit Dateien</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-one-pointed-mind>11.12. One-Pointed Mind</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-fpu>11.13. Die FPU verwenden</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-caveats>11.14. Vorsichtsmassnahmen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-acknowledgements>11.15. Danksagungen</a></li></ul></li><li><input type=checkbox id=chapter-c49dfe630861d471fb2f58f5b554ed84 class=toggle>
<label for=chapter-c49dfe630861d471fb2f58f5b554ed84><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/partv/>Teil V. Anhang</a></li><li><input type=checkbox id=chapter-ac9541a3f38001d13964c1b0b324bb83 class=toggle>
<label for=chapter-ac9541a3f38001d13964c1b0b324bb83><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/bibliography/>Literaturverzeichnis</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Kapitel 3. Sicheres Programmieren</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#secure-synopsis>3.1. Zusammenfassung</a></li><li><a href=#secure-philosophy>3.2. Methoden des sicheren Entwurfs</a></li><li><a href=#secure-bufferov>3.3. Puffer-Überläufe</a></li><li><a href=#secure-setuid>3.4. SetUID-Themen</a></li><li><a href=#secure-chroot>3.5. Die Umgebung ihrer Programme einschränken</a></li><li><a href=#secure-trust>3.6. Vertrauen</a></li><li><a href=#secure-race-conditions>3.7. Race-Conditions</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=secure-synopsis>3.1. Zusammenfassung<a class=anchor href=#secure-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Dieses Kapitel beschreibt einige Sicherheitsprobleme, die UNIX®-Programmierer seit Jahrzehnten quälen, und inzwischen verfügbare Werkzeuge, die Programmierern helfen, Sicherheitslücken in ihrem Quelltext zu vermeiden.</p></div></div></div><div class=sect1><h2 id=secure-philosophy>3.2. Methoden des sicheren Entwurfs<a class=anchor href=#secure-philosophy></a></h2><div class=sectionbody><div class=paragraph><p>Sichere Anwendungen zu schreiben erfordert eine sehr skeptische und pessimistische Lebenseinstellung. Anwendungen sollten nach dem Prinzip der "geringsten Privilegien" ausgeführt werden, sodass kein Prozess mit mehr als dem absoluten Minimum an Zugriffsrechten arbeitet, die er zum Erfüllen seiner Aufgabe benötigt. Wo es möglich ist, sollte Quelltext, der bereits überprüft wurde, wiederverwendet werden, um häufige Fehler, die andere schon korrigiert haben, zu vermeiden.</p></div><div class=paragraph><p>Eine der Stolperfallen der UNIX®-Umgebung ist, dass es sehr einfach ist Annahmen über die Konsistenz der Umgebung zu machen. Anwendungen sollten Nutzereingaben (in allen Formen) niemals trauen, genauso wenig wie den System-Ressourcen, der Inter-Prozess-Kommunikation oder dem zeitlichen Ablauf von Ereignissen. UNIX®-Prozesse arbeiten nicht synchron. Daher sind logische Operationen selten atomar.</p></div></div></div><div class=sect1><h2 id=secure-bufferov>3.3. Puffer-Überläufe<a class=anchor href=#secure-bufferov></a></h2><div class=sectionbody><div class=paragraph><p>Puffer-Überläufe gibt es schon seit den Anfängen der Von-Neuman-Architektur <a href=../bibliography/#cod>1</a>. Sie erlangten zum ersten Mal durch den Internetwurm Morris im Jahre 1988 öffentliche Bekanntheit. Unglücklicherweise funktioniert der gleiche grundlegende Angriff noch heute. Die bei weitem häufigste Form eines Puffer-Überlauf-Angriffs basiert darauf, den Stack zu korrumpieren.</p></div><div class=paragraph><p>Die meisten modernen Computer-Systeme verwenden einen Stack, um Argumente an Prozeduren zu übergeben und lokale Variablen zu speichern. Ein Stack ist ein last-in-first-out-Puffer (LIFO) im hohen Speicherbereich eines Prozesses. Wenn ein Programm eine Funktion aufruft wird ein neuer "Stackframe" erzeugt. Dieser besteht aus den Argumenten, die der Funktion übergeben wurden und einem variabel grossem Bereich für lokale Variablen. Der "Stack-Pointer" ist ein Register, dass die aktuelle Adresse der Stack-Spitze enthält. Da sich dieser Wert oft ändert, wenn neue Werte auf dem Stack abgelegt werden, bieten viele Implementierungen einen "Frame-Pointer", der nahe am Anfang des Stack-Frames liegt und es so leichter macht lokale Variablen relativ zum aktuellen Stackframe zu adressieren. <a href=../bibliography/#cod>1</a> Die Rücksprungadresse der Funktionen werden ebenfalls auf dem Stack gespeichert und das ist der Grund für Stack-Überlauf-Exploits. Denn ein böswilliger Nutzer kann die Rücksprungadresse der Funktion überschreiben indem er eine lokale Variable in der Funktion überlaufen lässt, wodurch es ihm möglich ist beliebigen Code auszuführen.</p></div><div class=paragraph><p>Obwohl Stack-basierte Angriffe bei weitem die Häufigsten sind, ist es auch möglich den Stack mit einem Heap-basierten (malloc/free) Angriff zu überschreiben.</p></div><div class=paragraph><p>Die C-Programmiersprache führt keine automatischen Bereichsüberprüfungen bei Feldern oder Zeigern durch, wie viele andere Sprachen das tun. Außerdem enthält die C-Standardbibliothek eine Handvoll sehr gefährlicher Funktionen.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>strcpy</code>(char *dest, const char *src)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer dest überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>strcat</code>(char *dest, const char *src)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer dest überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>getwd</code>(char *buf)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer buf überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>gets</code>(char *s)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer s überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>[vf]scanf</code>(const char *format, …​)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann sein Argument überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>realpath</code>(char *path, char resolved_path[])</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer path überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>[v]sprintf</code>(char *str, const char *format, …​)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer str überlaufen lassen</p></td></tr></tbody></table><div class=sect2><h3 id=_puffer_überlauf_beispiel>3.3.1. Puffer-Überlauf Beispiel<a class=anchor href=#_puffer_überlauf_beispiel></a></h3><div class=paragraph><p>Das folgende Quellcode-Beispiel enthält einen Puffer-Überlauf, der darauf ausgelegt ist die Rücksprungadresse zu überschreiben und die Anweisung direkt nach dem Funktionsaufruf zu überspringen. (Inspiriert durch <a href=../bibliography/#Phrack>4</a>)</p></div><div class="literalblock programlisting"><div class=content><pre>#include stdio.h

void manipulate(char *buffer) {
char newbuffer[80];
strcpy(newbuffer,buffer);
}

int main() {
char ch,buffer[4096];
int i=0;

while ((buffer[i++] = getchar()) != &#39;\n&#39;) {};

i=1;
manipulate(buffer);
i=2;
printf(&#34;The value of i is : %d\n&#34;,i);
return 0;
}</pre></div></div><div class=paragraph><p>Betrachten wir nun, wie das Speicherabbild dieses Prozesses aussehen würde, wenn wir 160 Leerzeichen in unser kleines Programm eingeben, bevor wir Enter drücken.</p></div><div class=paragraph><p>Offensichtlich kann man durch böswilligere Eingaben bereits kompilierten Programmtext ausführen (wie z.B. exec(/bin/sh)).</p></div></div><div class=sect2><h3 id=_puffer_überläufe_vermeiden>3.3.2. Puffer-Überläufe vermeiden<a class=anchor href=#_puffer_überläufe_vermeiden></a></h3><div class=paragraph><p>Die direkteste Lösung, um Stack-Überläufe zu vermeiden, ist immer grössenbegrenzten Speicher und String-Copy-Funktionen zu verwenden. <code>strncpy</code> und <code>strncat</code> sind Teil der C-Standardbibliothek. Diese Funktionen akzeptieren einen Längen-Parameter. Dieser Wert sollte nicht größer sein als die Länge des Zielpuffers. Die Funktionen kopieren dann bis zu <code>length</code> Bytes von der Quelle zum Ziel. Allerdings gibt es einige Probleme. Keine der Funktionen garantiert, dass die Zeichenkette NUL-terminiert ist, wenn die Größe des Eingabepuffers so groß ist wie das Ziel. Außerdem wird der Parameter length zwischen strncpy und strncat inkonsistent definiert, weshalb Programmierer leicht bezüglich der korrekten Verwendung durcheinander kommen können. Weiterhin gibt es einen spürbaren Leistungsverlust im Vergleich zu <code>strcpy</code>, wenn eine kurze Zeichenkette in einen großen Puffer kopiert wird. Denn <code>strncpy</code> fült den Puffer bis zur angegebenen Länge mit NUL auf.</p></div><div class=paragraph><p>In OpenBSD wurde eine weitere Möglichkeit zum kopieren von Speicherbereichen implementiert, die dieses Problem umgeht. Die Funktionen <code>strlcpy</code> und <code>strlcat</code> garantieren, dass das Ziel immer NUL-terminiert wird, wenn das Argument length ungleich null ist. Für weitere Informationen über diese Funktionen lesen Sie bitte <a href=../bibliography/#OpenBSD>6</a>. Die OpenBSD-Funktionen <code>strlcpy</code> und <code>strlcat</code> sind seit Version 3.3 auch in FreeBSD verfügbar.</p></div><div class=sect3><h4 id=_compiler_basierte_laufzeitüberprüfung_von_grenzen>3.3.2.1. Compiler-basierte Laufzeitüberprüfung von Grenzen<a class=anchor href=#_compiler_basierte_laufzeitüberprüfung_von_grenzen></a></h4><div class=paragraph><p>Unglücklicherweise gibt es immer noch sehr viel Quelltext, der allgemein verwendet wird und blind Speicher umherkopiert, ohne eine der gerade besprochenen Funktionen, die Begrenzungen unterstützen, zu verwenden. Glücklicherweise gibt es einen Weg, um solche Angriffe zu verhindern - Überprüfung der Grenzen zur Laufzeit, die in verschiedenen C/C++ Compilern eingebaut ist.</p></div><div class=paragraph><p>ProPolice ist eine solche Compiler-Eigenschaft und ist in den <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a> Versionen 4.1 und höher integriert. Es ersetzt und erweitert die <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a> StackGuard-Erweiterung von früher.</p></div><div class=paragraph><p>ProPolice schützt gegen stackbasierte Pufferüberläufe und andere Angriffe durch das Ablegen von Pseudo-Zufallszahlen in Schlüsselbereichen des Stacks bevor es irgendwelche Funktionen aufruft. Wenn eine Funktion beendet wird, werden diese "Kanarienvögel" überprüft und wenn festgestellt wird, dass diese verändert wurden wird das Programm sofort abgebrochen. Dadurch wird jeglicher Versuch, die Rücksprungadresse oder andere Variablen, die auf dem Stack gespeichert werden, durch die Ausführung von Schadcode zu manipulieren, nicht funktionieren, da der Angreifer auch die Pseudo-Zufallszahlen unberührt lassen müsste.</p></div><div class=paragraph><p>Ihre Anwendungen mit ProPolice neu zu kompilieren ist eine effektive Maßnahme, um sie vor den meisten Puffer-Überlauf-Angriffen zu schützen, aber die Programme können noch immer kompromittiert werden.</p></div></div><div class=sect3><h4 id=_bibliotheks_basierte_laufzeitüberprüfung_von_grenzen>3.3.2.2. Bibliotheks-basierte Laufzeitüberprüfung von Grenzen<a class=anchor href=#_bibliotheks_basierte_laufzeitüberprüfung_von_grenzen></a></h4><div class=paragraph><p>Compiler-basierte Mechanismen sind bei Software, die nur im Binärformat vertrieben wird, und die somit nicht neu kompiliert werden kann völlig nutzlos. Für diesen Fall gibt es einige Bibliotheken, welche die unsicheren Funktionen der C-Bibliothek (<code>strcpy</code>, <code>fscanf</code>, <code>getwd</code>, etc..) neu implementieren und sicherstellen, dass nicht hinter den Stack-Pointer geschrieben werden kann.</p></div><div class=ulist><ul><li><p>libsafe</p></li><li><p>libverify</p></li><li><p>libparanoia</p></li></ul></div><div class=paragraph><p>Leider haben diese Bibliotheks-basierten Verteidigungen mehrere Schwächen. Diese Bibliotheken schützen nur vor einer kleinen Gruppe von Sicherheitslücken und sie können das eigentliche Problem nicht lösen. Diese Maßnahmen können versagen, wenn die Anwendung mit -fomit-frame-pointer kompiliert wurde. Außerdem kann der Nutzer die Umgebungsvariablen LD_PRELOAD und LD_LIBRARY_PATH überschreiben oder löschen.</p></div></div></div></div></div><div class=sect1><h2 id=secure-setuid>3.4. SetUID-Themen<a class=anchor href=#secure-setuid></a></h2><div class=sectionbody><div class=paragraph><p>Es gibt zu jedem Prozess mindestens sechs verschiedene IDs, die diesem zugeordnet sind. Deshalb müssen Sie sehr vorsichtig mit den Zugriffsrechten sein, die Ihr Prozess zu jedem Zeitpunkt besitzt. Konkret bedeutet dass, das alle seteuid-Anwendungen ihre Privilegien abgeben sollten, sobald sie diese nicht mehr benötigen.</p></div><div class=paragraph><p>Die reale Benutzer-ID kann nur von einem Superuser-Prozess geändert werden. Das Programm login setzt sie, wenn sich ein Benutzer am System anmeldet, und sie wird nur selten geändert.</p></div><div class=paragraph><p>Die effektive Benutzer-ID wird von der Funktion <code>exec()</code> gesetzt, wenn ein Programm das seteuid-Bit gesetzt hat. Eine Anwendung kann <code>seteuid()</code> jederzeit aufrufen, um die effektive Benutzer-ID entweder auf die reale Benutzer-ID oder die gespeicherte set-user-ID zu setzen. Wenn eine der <code>exec()</code>-Funktionen die effektive Benutzer-ID setzt, wird der vorherige Wert als gespeicherte set-user-ID abgelegt.</p></div></div></div><div class=sect1><h2 id=secure-chroot>3.5. Die Umgebung ihrer Programme einschränken<a class=anchor href=#secure-chroot></a></h2><div class=sectionbody><div class=paragraph><p>Die herkömmliche Methode, um einen Prozess einzuschränken, besteht in dem Systemaufruf <code>chroot()</code>. Dieser Aufruf ändert das Wurzelverzeichnis, auf das sich alle Pfadangaben des Prozesses und jegliche Kind-Prozesse beziehen. Damit dieser Systemaufruf gelingt, muss der Prozess Ausführungsrechte (Durchsuchungsrechte) für das Verzeichnis haben, auf das er sich bezieht. Die neue Umgebung wird erst wirksam, wenn Sie mittels <code>chdir()</code> in Ihre neue Umgebung wechseln. Es sollte erwähnt werden, dass ein Prozess recht einfach aus der chroot-Umgebung ausbrechen kann, wenn er root-Rechte besitzt. Das kann man erreichen, indem man Gerätedateien anlegt, um Kernel-Speicher zu lesen, oder indem man einen Debugger mit einem Prozess außerhalb seiner <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a>-Umgebung verbindet, oder auf viele andere kreative Wege.</p></div><div class=paragraph><p>Das Verhalten des Systemaufrufs <code>chroot()</code> kann durch die kern.chroot.allow_open_directories <code>sysctl</code>-Variable beeinflusst werden. Wenn diese auf 0 gesetzt ist, wird <code>chroot()</code> mit EPERM fehlschlagen, wenn irgendwelche Verzeichnisse geöffnet sind. Wenn die Variable auf den Standardwert 1 gesetzt ist, wird <code>chroot()</code> mit EPERM fehlschlagen, wenn irgendwelche Verzeichnisse geöffnet sind und sich der Prozess bereits in einer <code>chroot()</code>-Umgebung befindet. Bei jedem anderen Wert wird die Überprüfung auf geöffnete Verzeichnisse komplett umgangen.</p></div><div class=sect2><h3 id=_die_jail_funktionalität_in_freebsd>3.5.1. Die Jail-Funktionalität in FreeBSD<a class=anchor href=#_die_jail_funktionalität_in_freebsd></a></h3><div class=paragraph><p>Das Konzept einer Jail (Gefängnis) erweitert <code>chroot()</code>, indem es die Macht des Superusers einschränkt, um einen echten 'virtuellen Server' zu erzeugen. Wenn ein solches Gefängnis einmal eingerichtet ist, muss die gesamte Netzwerkkommunikation über eine bestimmte IP-Adresse erfolgen und die "root-Privilegien" innerhalb der Jail sind sehr stark eingeschränkt.</p></div><div class=paragraph><p>Solange Sie sich in einer Jail befinden, werden alle Tests auf Superuser-Rechte durch den Aufruf von <code>suser()</code> fehlschlagen. Allerdings wurden einige Aufrufe von <code>suser()</code> abgeändert, um die neue <code>suser_xxx()</code>-Schnittstelle zu implementieren. Diese Funktion ist dafür verantwortlich, festzustellen, ob bestimmte Superuser-Rechte einem eingesperrten Prozess zur Verfügung stehen.</p></div><div class=paragraph><p>Ein Superuser-Prozess innerhalb einer Jail darf folgendes:</p></div><div class=ulist><ul><li><p>Berechtigungen verändern mittels: <code>setuid</code>, <code>seteuid</code>, <code>setgid</code>, <code>setegid</code>, <code>setgroups</code>, <code>setreuid</code>, <code>setregid</code>, <code>setlogin</code></p></li><li><p>Ressourcenbegrenzungen setzen mittels <code>setrlimit</code></p></li><li><p>Einige sysctl-Variablen (kern.hostname) verändern</p></li><li><p><code>chroot()</code></p></li><li><p>Ein Flag einer vnode setzen: <code>chflags</code>, <code>fchflags</code></p></li><li><p>Attribute einer vnode setzen wie Dateiberechtigungen, Eigentümer, Gruppe, Größe, Zugriffszeit und Modifikationszeit</p></li><li><p>Binden eines Prozesses an einen öffentlichen privilegierten Port (ports 1024)</p></li></ul></div><div class=paragraph><p><code>Jail</code>s sind ein mächtiges Werkzeug, um Anwendungen in einer sicheren Umgebung auszuführen, aber sie haben auch ihre Nachteile. Derzeit wurden die IPC-Mechanismen noch nicht an <code>suser_xxx</code> angepasst, so dass Anwendungen wie MySQL nicht innerhalb einer Jail ausgeführt werden können. Der Superuser-Zugriff hat in einer Jail nur eine sehr eingeschränkte Bedeutung, aber es gibt keine Möglichkeit zu definieren was "sehr eingeschränkt" heißt.</p></div></div><div class=sect2><h3 id=_posix_1e_prozess_capabilities>3.5.2. POSIX®.1e Prozess Capabilities<a class=anchor href=#_posix_1e_prozess_capabilities></a></h3><div class=paragraph><p>POSIX® hat einen funktionalen Entwurf (Working Draft) herausgegeben, der Ereignisüberprüfung, Zugriffskontrolllisten, feiner einstellbare Privilegien, Informationsmarkierung und verbindliche Zugriffskontrolle enthält.</p></div><div class=paragraph><p>Dies ist im Moment in Arbeit und das Hauptziel des <a href=http://www.trustedbsd.org/>TrustedBSD</a>-Projekts. Ein Teil der bisherigen Arbeit wurde in FreeBSD-CURRENT übernommen (cap_set_proc(3)).</p></div></div></div></div><div class=sect1><h2 id=secure-trust>3.6. Vertrauen<a class=anchor href=#secure-trust></a></h2><div class=sectionbody><div class=paragraph><p>Eine Anwendung sollte niemals davon ausgehen, dass irgendetwas in der Nutzerumgebung vernünftig ist. Das beinhaltet (ist aber sicher nicht darauf beschränkt): Nutzereingaben, Signale, Umgebungsvariablen, Ressourcen, IPC, mmaps, das Arbeitsverzeichnis im Dateisystem, Dateideskriptoren, die Anzahl geöffneter Dateien, etc..</p></div><div class=paragraph><p>Sie sollten niemals annehmen, dass Sie jede Art von inkorrekten Eingaben abfangen können, die ein Nutzer machen kann. Stattdessen sollte Ihre Anwendung positive Filterung verwenden, um nur eine bestimmte Teilmenge an Eingaben zuzulassen, die Sie für sicher halten. Ungeeignete Datenüberprüfung ist die Ursache vieler Exploits, besonders für CGI-Skripte im Internet. Bei Dateinamen müssen Sie besonders vorsichtig sein, wenn es sich um Pfade ("../", "/"), symbolische Verknüpfungen und Shell-Escape-Sequenzen handelt.</p></div><div class=paragraph><p>Perl bietet eine wirklich coole Funktion, den sogenannten "Taint"-Modus, der verwendet werden kann, um zu verhindern, dass Skripte Daten, die von außerhalb des Programmes stammen, auf unsichere Art und Weise verwenden. Dieser Modus überprüft Kommandozeilenargumente, Umgebungsvariablen, Lokalisierungsinformationen, die Ergebnisse von Systemaufrufen (<code>readdir()</code>, <code>readlink()</code>, <code>getpwxxx()</code>) und alle Dateieingaben.</p></div></div></div><div class=sect1><h2 id=secure-race-conditions>3.7. Race-Conditions<a class=anchor href=#secure-race-conditions></a></h2><div class=sectionbody><div class=paragraph><p>Eine Race-Condition ist ein unnormales Verhalten, das von einer unerwarteten Abhängigkeit beim Timing von Ereignissen verursacht wird. Mit anderen Worten heißt das, ein Programmierer nimmt irrtümlicher Weise an, dass ein bestimmtes Ereignis immer vor einem anderen stattfindet.</p></div><div class=paragraph><p>Einige der häufigsten Ursachen für Race-Conditions sind Signale, Zugriffsprüfungen und das Öffnen von Dateien. Signale sind von Natur aus asynchrone Ereignisse, deshalb ist besondere Vorsicht im Umgang damit geboten. Das Prüfen des Zugriffs mittels der Aufrufe <code>access(2)</code> gefolgt von <code>open(2)</code> ist offensichtlich nicht atomar. Benutzer können zwischen den beiden Aufrufen Dateien verschieben. Stattdessen sollten privilegierte Anwendungen <code>seteuid()</code> direkt gefolgt von <code>open()</code> aufrufen. Auf die gleiche Art sollte eine Anwendung immer eine korrekte Umask vor dem Aufruf von <code>open()</code> setzen, um störende Aufrufe von <code>chmod()</code> zu umgehen.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9. März 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/de/books/developers-handbook/tools class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/de/books/developers-handbook/l10n class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#secure-synopsis>3.1. Zusammenfassung</a></li><li><a href=#secure-philosophy>3.2. Methoden des sicheren Entwurfs</a></li><li><a href=#secure-bufferov>3.3. Puffer-Überläufe</a></li><li><a href=#secure-setuid>3.4. SetUID-Themen</a></li><li><a href=#secure-chroot>3.5. Die Umgebung ihrer Programme einschränken</a></li><li><a href=#secure-trust>3.6. Vertrauen</a></li><li><a href=#secure-race-conditions>3.7. Race-Conditions</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/developers-handbook/developers-handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/de/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>