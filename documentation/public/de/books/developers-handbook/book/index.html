<!doctype html><html class=theme-light lang=de><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/de/books/developers-handbook/book/><title>FreeBSD Developers' Handbook | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="FreeBSD Developers' Handbook"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="https://docs.freebsd.org/de/books/developers-handbook/book/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/de\/books\/developers-handbook\/book\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=https://docs.freebsd.org/de/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/de/books>Books</a></li><li><a href=https://docs.freebsd.org/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>FreeBSD Developers' Handbook</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2020 The FreeBSD Documentation Project</div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD ist ein eingetragenes Warenzeichen der FreeBSD Foundation.</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390 und ThinkPad sind Warenzeichen der International Business Machines Corporation in den Vereinigten Staaten, anderen Ländern oder beiden.</p><p>IEEE, POSIX und 802 sind eingetragene Warenzeichen vom Institute of Electrical and Electronics Engineers, Inc. in den Vereinigten Staaten.</p><p>Apple, FireWire, Mac, Macintosh, Mac OS, Quicktime und TrueType sind eingetragene Warenzeichen von Apple Computer, Inc., in den Vereinigten Staaten und anderen Ländern.</p><p>Intel, Celeron, EtherExpress, i386, i486, Itanium, Pentium und Xeon sind Warenzeichen oder eingetragene Warenzeichen der Intel Corporation oder ihrer Gesellschaften in den Vereinigten Staaten und in anderen Ländern.</p><p>Linux ist ein eingetragenes Warenzeichen von Linus Torvalds.</p><p>Microsoft, MS-DOS, Outlook, Windows, Windows Media und Windows NT sind entweder eingetragene Warenzeichen oder Warenzeichen der Microsoft Corporation in den Vereinigten Staaten und/oder in anderen Ländern.</p><p>Motif, OSF/1 und UNIX sind eingetragene Warenzeichen und IT DialTone und The Open Group sind Warenzeichen der The Open Group in den Vereinigten Staaten und in anderen Ländern.</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JSP, JVM, Netra, Solaris, StarOffice und SunOS sind Warenzeichen oder eingetragene Warenzeichen von Sun Microsystems, Inc. in den Vereinigten Staaten und in anderen Ländern.</p><p>Viele Produktbezeichnungen von Herstellern und Verkäufern sind Warenzeichen. Soweit dem FreeBSD Project das Warenzeichen bekannt ist, werden die in diesem Dokument vorkommenden Bezeichnungen mit dem Symbol “™” oder dem Symbol “®” gekennzeichnet.</p></details></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#basics>Teil I: Grundlagen</a><ul><li><a href=#introduction>Kapitel 1. Einführung</a></li><li><a href=#tools>Kapitel 2. Werkzeuge zur Programmierung</a></li><li><a href=#secure>Kapitel 3. Sicheres Programmieren</a></li><li><a href=#l10n>Kapitel 4. Lokalisierung und Internationalisierung - L10N und I18N</a></li><li><a href=#policies>Kapitel 5. Vorgaben und Richtlinien für das Quelltextverzeichnis</a></li><li><a href=#testing>Kapitel 6. Regressions- und Performance-Tests</a></li></ul></li><li><a href=#ipc>Teil II: Interprozess-Kommunikation</a><ul><li><a href=#sockets>Kapitel 7. Sockets</a></li><li><a href=#ipv6>Kapitel 8. IPv6 Internals</a></li></ul></li><li><a href=#kernel>Teil III: Kernel</a><ul><li><a href=#kernelbuild>Kapitel 9. Einen FreeBSD-Kernel bauen und installieren</a></li><li><a href=#kerneldebug>Kapitel 10. Kernel-Fehlersuche</a></li></ul></li><li><a href=#architectures>Teil IV: Architekturen</a><ul><li><a href=#x86>Kapitel 11. x86-Assembler-Programmierung</a></li></ul></li><li><a href=#appendices>Teil V: Anhang</a><ul><li><a href=#bibliography>Literaturverzeichnis</a></li></ul></li></ul></nav></div><div>[ <a href=../>Split HTML</a> / Single HTML ]</div><div class=book-content><div id=preamble><div class=sectionbody><div class="quoteblock abstract abstract-title"><blockquote>Zusammenfassung</blockquote></div><div class=paragraph><p>Willkommen zum Entwickler-Handbuch. Dieses Handbuch ist <em>jederzeit unter Bearbeitung</em> und das Ergebnis der Arbeit vieler Einzelpersonen. Dies kann dazu führen, dass bestimmte Bereiche nicht mehr aktuell sind und auf den neuesten Stand gebracht werden müssen. Bei Unklarheiten empfiehlt es sich daher stets, auch die <a href=https://docs.freebsd.org/de/books/developers-handbook/>englische Originalversion</a> des Handbuchs zu lesen.</p></div><div class=paragraph><p>Wenn Sie bei der Übersetzung dieses Handbuchs mithelfen möchten, senden Sie bitte eine E-Mail an die Mailingliste FreeBSD German Documentation Project &lt;<a href=mailto:de-bsd-translators@de.FreeBSD.org>de-bsd-translators@de.FreeBSD.org</a>>.</p></div><div class=paragraph><p>Die aktuelle Version dieses Handbuchs ist immer auf dem <a href=http://www.FreeBSD.org/>FreeBSD-Webserver</a> verfügbar und kann in verschiedenen Formaten und in komprimierter Form vom <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/doc>FreeBSD-FTP-Server</a> oder einem der zahlreichen <a href=https://docs.freebsd.org/de/books/handbook/mirrors/#mirrors-ftp>Spiegel</a> heruntergeladen werden (ältere Versionen finden Sie hingegen unter <a href=http://docs.FreeBSD.org/doc/>http://docs.FreeBSD.org/doc/</a>).</p></div><hr></div></div><h1 id=basics class=sect0>Teil I: Grundlagen<a class=anchor href=#basics></a></h1><div class=sect1><h2 id=introduction>Kapitel 1. Einführung<a class=anchor href=#introduction></a></h2><div class=sectionbody><div class=sect2><h3 id=introduction-devel>1.1. Unter FreeBSD entwickeln<a class=anchor href=#introduction-devel></a></h3><div class=paragraph><p>Hier sind wir also. Ihr System ist vollständig installiert und Sie wollen mit dem Programmieren beginnen. Aber womit sollen Sie anfangen? Was bietet Ihnen FreeBSD? Was kann es für einen Programmierer tun?</p></div><div class=paragraph><p>Dies sind einige der Fragen, welche dieses Handbuch zu beantworten versucht. Natürlich gibt es, analog zu anderen Berufen, auch bei Programmierern unterschiedliche Leistungsniveaus. Für die einen ist es ein Hobby, für die anderen ist es der Beruf. Die Informationen in diesem Kapitel dürften eher für den Programmieranfänger geeignet sein; allerdings könnte es auch für Programmierer, die bisher nichts mit der FreeBSD-Plattform zu tun hatten, interessante Informationen enthalten.</p></div></div><div class=sect2><h3 id=introduction-bsdvision>1.2. Die Vision von BSD<a class=anchor href=#introduction-bsdvision></a></h3><div class=paragraph><p>Ziel ist es, das bestmögliche UNIX®-artige Betriebssystempaket zu erstellen, mit dem gebührenden Respekt gegenüber der Ideologie der ursprünglichen Software, sowie der Bedienbarkeit, Leistungsfähigkeit und Stabilität.</p></div></div><div class=sect2><h3 id=introduction-archguide>1.3. Grundlegende Richtlinien<a class=anchor href=#introduction-archguide></a></h3><div class=paragraph><p>Unsere Ideologie kann durch die folgenden Leitfäden beschrieben werden.</p></div><div class=ulist><ul><li><p>Füge keine neue Funktionalität hinzu, solange ein Programmierer diese nicht zur Fertigstellung einer realen Anwendung benötigt.</p></li><li><p>Zu entscheiden, was ein System ist, ist genauso wichtig wie zu entscheiden, was ein System nicht ist. Versuchen Sie nicht, alle möglichen Wünsche zu erfüllen; machen Sie lieber das System erweiterbar, so dass zusätzliche Bedürfnisse in einer aufwärtskompatiblen Weise bedient werden können.</p></li><li><p>Das Einzige, das schlimmer ist, als von einem Beispiel auf die Allgemeinheit zu schließen, ist, von überhaupt keinem Beispiel auf die Allgemeinheit zu schließen.</p></li><li><p>Solange ein Problem nicht vollständig verstanden wurde, ist es besser, keine Lösung bereitzustellen.</p></li><li><p>Wenn Sie 90% des gewünschten Effektes bei nur 10% des Aufwands erreichen können, sollten Sie besser die einfachere Lösung verwenden.</p></li><li><p>Grenzen Sie Komplexität so gut wie möglich ein.</p></li><li><p>Stellen Sie Mechanismen anstelle von Strategien bereit. Überlassen Sie insbesondere Strategien für die Benutzerschnittstelle dem Benutzerprogramm.</p></li></ul></div><div class=paragraph><p>Aus Scheifler & Gettys: "X Window System"</p></div></div><div class=sect2><h3 id=introduction-layout>1.4. Der Aufbau von <span class=filename>/usr/src</span><a class=anchor href=#introduction-layout></a></h3><div class=paragraph><p>Der vollständige Quelltext von FreeBSD ist über unser öffentliches Repository verfügbar. Der Quelltext wird normalerweise in <span class=filename>/usr/src</span> abgelegt und enthält die folgenden Unterverzeichnisse:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Verzeichnis</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien in <span class=filename>/bin</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>cddl/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Programme, die unter der Common Development and Distribution License stehen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>contrib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien von beigesteuerter Software</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>crypto/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für die Kryptographie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>etc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien in <span class=filename>/etc</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>games/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien in <span class=filename>/usr/games</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>gnu/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programme, die unter der GNU Public License stehen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>include/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien in <span class=filename>/usr/include</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>kerberos5/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Kerberos Version 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>lib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien in <span class=filename>/usr/lib</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>libexec/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien in <span class=filename>/usr/libexec</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>release/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dateien, die für die Erstellung eines FreeBSD-Releases nötig sind</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>rescue/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bausystem für die <span class=filename>/rescue</span>-Programme</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien in <span class=filename>/sbin</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>secure/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für FreeSec</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>share/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien in <span class=filename>/usr/share</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>sys/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kernel-Quelldateien</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>tools/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programme zum Verwalten und Testen von FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>usr.bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien in <span class=filename>/usr/bin</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>usr.sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien für Dateien in <span class=filename>/usr/sbin</span></p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=tools>Kapitel 2. Werkzeuge zur Programmierung<a class=anchor href=#tools></a></h2><div class=sectionbody><div class=sect2><h3 id=tools-synopsis>2.1. Überblick<a class=anchor href=#tools-synopsis></a></h3><div class=paragraph><p>Dieses Kapitel ist eine Einführung in die Benutzung einiger der Werkzeuge zur Programmierung die mit FreeBSD ausgeliefert werden. Trotzdem ist vieles auch auf verschiedene andere Versionen von UNIX® übertragbar. Dieses Kapitel soll <em>kein</em> Versuch sein Programmierung detailliert zu beschreiben. Der größte Teil dieses Kapitels setzt wenige oder gar keine Programmierkenntnisse voraus, dennoch sollten die meisten Programmierer etwas Sinnvolles darin finden.</p></div></div><div class=sect2><h3 id=tools-intro>2.2. Zusammenfassung<a class=anchor href=#tools-intro></a></h3><div class=paragraph><p>FreeBSD bietet eine exzellente Entwicklungsumgebung. Compiler für C und C++, sowie ein Assembler sind im Basissystem enthalten. Natürlich finden sich auch klassische UNIX®-Werkzeuge wie <code>sed</code> und <code>awk</code>. Sollte das nicht genug sein, finden sich zahlreiche weitere Compiler und Interpreter in der Ports-Sammlung. Der folgende Abschnitt, <a href=#tools-programming>Einführung in die Programmierung</a>, zählt ein paar der verfügbaren Optionen auf. FreeBSD ist kompatibel zu vielen Standards wie POSIX® und ANSI C, sowie zu seinem eigenen BSD Erbe. So ist es möglich Anwendungen zu schreiben, welche ohne oder zumindest ohne wesentliche Änderungen auf einer großen Zahl an Plattformen kompilieren und laufen werden.</p></div><div class=paragraph><p>Allerdings können all diese Möglichkeiten anfangs etwas überwältigend sein, wenn Sie vorher nie Programme auf einem UNIX®-System geschrieben haben. Dieses Dokument hat die Zielsetzung ihnen beim Einstieg zu helfen ohne allzu weit in fortgeschrittene Themen vorzudringen. Die Intention ist, daß dieses Dokument ihnen ausreichend Basiswissen vermittelt und die weitergehende Dokumentation sinnvoll nutzen zu können.</p></div><div class=paragraph><p>Der größte Teil dieses Dokuments erfordert wenige oder gar keine Kenntnisse in der Programmierung, es werden trotzdem Basiswissen im Umgang mit UNIX® und die Bereitschaft zu lernen vorausgesetzt!</p></div></div><div class=sect2><h3 id=tools-programming>2.3. Einführung in die Programmierung<a class=anchor href=#tools-programming></a></h3><div class=paragraph><p>Ein Programm ist eine Zusammenstellung von Anweisungen, die den Computer auffordern verschiedenste Dinge zu tun. Dieser Abschnitt gibt ihnen einen Überblick über die beiden wesentlichen Methoden diese Anweisungen oder "Befehle", wie man diese Anweisungen üblicherweise nennt, zu geben. Die eine Methode nutzt einen <em>Interpreter</em>, die andere einen <em>Compiler</em>. Da menschliche Sprachen für einen Computer nicht unmissverständlich sind, werden diese Befehle in einer Sprache geschrieben die speziell für diesen Zweck gedacht ist.</p></div><div class=sect3><h4 id=_interpreter>2.3.1. Interpreter<a class=anchor href=#_interpreter></a></h4><div class=paragraph><p>Mit einem Interpreter ist die Sprache vielmehr eine Umgebung, in der Sie ein Kommando an der Kommandozeile eingeben welches dann von der Umgebung ausgeführt wird. Für kompliziertere Programme können Sie die Befehle in eine Datei schreiben und den Interpreter dazu bringen diese Datei zu laden und die enthaltenen Befehle auszuführen. Falls etwas schief geht werden viele Interpreter Sie an einen Debugger weiterleiten.</p></div><div class=paragraph><p>Der Vorteil hierbei ist, das Sie das Ergebnis ihres Befehls direkt sehen und Fehler sofort korrigiert werden können. Der größte Nachteil bei dieser Methode entsteht, wenn Sie ihr Programm mit jemandem teilen wollen. Diese Person muss den selben Interpreter nutzen wie Sie es tun und Sie muss wissen wie dieser zu bedienen ist. Zudem werden Benutzer es nicht begrüßen sich in einem Debugger wiederzufinden, wenn Sie einmal die falsche Taste drücken! Bei einem Blick auf die Leistungsfähigkeit brauchen Interpreter oftmals viel Speicher und erzeugen den Code nicht so effizient wie Compiler.</p></div><div class=paragraph><p>Meiner Meinung nach sind interpretierte Sprachen der beste Anfang, wenn Sie bisher noch nicht programmiert haben. Diese Art von Umgebung findet man typischerweise bei Sprachen wie Lisp, Smalltalk, Perl und Basic. Man könnte auch sagen, dass die UNIX® Shell (<code>sh</code>, <code>csh</code>) für sich bereits einen Interpreter darstellt und viele Leute schreiben tatsächlich Shell "Scripten" um sich bei einigen "Haushaltsaufgaben" auf ihren Maschinen helfen zu lassen. Tatsächlich war es ein wesentlicher Teil der originalen UNIX® Philosophie eine große Zahl an kleinen Hilfsprogrammen zur Verfügung zu stellen, welche mittels eines Shellskripts miteinander kombiniert werden um bestimmte Aufgaben zu übernehmen.</p></div></div><div class=sect3><h4 id=_für_freebsd_verfügbare_interpreter>2.3.2. Für FreeBSD verfügbare Interpreter<a class=anchor href=#_für_freebsd_verfügbare_interpreter></a></h4><div class=paragraph><p>Im folgenden eine Liste der über die FreeBSD Ports-Sammlung verfügbaren Interpreter einschließlich einer kurzen Erörterung der populären interpretierten Sprachen.</p></div><div class=paragraph><p>Anleitungen wie man Anwendungen aus der Ports-Sammlung erhält und installiert können Sie dem Kapitel <a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-using>Benutzen der Ports-Sammlung</a> aus dem FreeBSD Handbuch entnehmen.</p></div><div class=dlist><dl><dt class=hdlist1>BASIC</dt><dd><p>Kurz für Beginner’s All-purpose Symbolic Instruction Code. Entwickelt in den 50er Jahren um Studenten in Programmierung zu unterrichten, wurde BASIC in den 80er Jahren mit jedem anständigen Personal Computer ausgeliefert und war für viele Programmierer die erste Programmiersprache. BASIC ist auch die Grundlage für Visual Basic.</p><div class=paragraph><p>Der Bywater Basic Interpreter findet sich in der Ports-Sammlung unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/bwbasic/>lang/bwbasic</a> und Phil Cockroft’s Basic Interpreter (auch bekannt als Rabbit Basic) findet sich unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/pbasic/>lang/pbasic</a>.</p></div></dd><dt class=hdlist1>Lisp</dt><dd><p>Diese Sprache wurde in den späten 50er Jahren als Alternative zu den, zu dieser Zeit populären, "zahlenverarbeitenden" Sprachen entwickelt. Anstelle auf Zahlen basiert Lisp auf Listen; tatsächlich ist der Name Lisp eine Kurzform für "List Processing" (Listen abarbeiten). Sehr populär fü AI (Artificial Intelligence/ künstliche Intelligez) (Fach-) Kreisen.</p><div class=paragraph><p>Lisp ist eine extrem kraftvolle und durchdachte Sprache, kann aber auch recht groß und unhandlich sein.</p></div><div class=paragraph><p>Zahlreiche Ausformungen von Lisp, die auf UNIX® Systemen laufen sind über die Ports-Sammlung verfügbar. GNU Common Lisp befindet sich in <a class=package href=https://cgit.freebsd.org/ports/tree/lang/gcl/>lang/gcl</a>. CLISP von Bruno Haible und Michael Stoll ist in <a class=package href=https://cgit.freebsd.org/ports/tree/lang/clisp/>lang/clisp</a> zu finden. Für CMUCL, welches auch einen hoch-optimierten Compiler enthält, oder einfachere Ausformungen wie SLisp, das die meisten gängigen Lisp Konstrukte in wenigen hundert Zeilen C Code enthält sind in <a class=package href=https://cgit.freebsd.org/ports/tree/lang/cmucl/>lang/cmucl</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/lang/slisp/>lang/slisp</a> ebenfalls enthalten.</p></div></dd><dt class=hdlist1>Perl</dt><dd><p>Unter Systemadministratoren zum Schreiben von Skripten sehr beliebt; wird häufig auch auf World Wide Web Servern verwendet, um CGI-Skripte zu schreiben.</p><div class=paragraph><p>Perl ist in der Ports-Sammlung unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/perl5.8/>lang/perl5.8</a> für alle FreeBSD-Versionen verfügbar, und wird im Basissystem von 4.x als <code>/usr/bin/perl</code> installiert.</p></div></dd><dt class=hdlist1>Scheme</dt><dd><p>Ein Dialekt von Lisp, der kompakter und sauberer als Common Lisp ist. Dieser Dialekt ist an Universitäten sehr beliebt, da er zum einen für den Unterricht im Grundstudium einfach genug ist, und zum anderen ein ausreichend hohes Abstraktionsniveau für den Einsatz in der Forschung bietet.</p><div class=paragraph><p>Scheme ist in der Ports-Sammlung in Form des Elk Scheme Interpreters als <a class=package href=https://cgit.freebsd.org/ports/tree/lang/elk/>lang/elk</a> verfügbar. Den MIT Scheme Interpreter findet man unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/mit-scheme/>lang/mit-scheme</a>, und den SCM Scheme Interpreter unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/scm/>lang/scm</a>.</p></div></dd><dt class=hdlist1>Icon</dt><dd><p>Icon ist eine Hochsprache mit ausgereiften Möglichkeiten zur Verarbeitung von Zeichenketten und Strukturen. Die unter FreeBSD verfügbare Version von Icon steht in der Ports-Sammlung unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/icon/>lang/icon</a> zur Verfügung.</p></dd><dt class=hdlist1>Logo</dt><dd><p>Logo ist eine leicht zu erlernende Programmiersprache, welche in vielen Kursen als einführende Programmiersprache gewählt wird. Sie ist ein ideales Arbeitswerkzeug beim Unterricht mit jungen Menschen, da mit ihr die Erstellung komplizierter geometrischer Oberflächen selbst für kleine Kinder einfach ist.</p><div class=paragraph><p>Die für FreeBSD aktuellste, verfügbare Version findet man in der Ports-Sammlung unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/logo/>lang/logo</a>.</p></div></dd><dt class=hdlist1>Python</dt><dd><p>Python ist eine objektorientierte, interpretierte Programmiersprache. Die Verfechter von Python argumentieren, daß sie eine der besten Programmiersprachen für Programmieranfänger sei, da sie einfach zu erlernen ist, und anderen populären interpretierten Programmiersprachen, welche zur Entwicklung großer und komplexer Anwendungen verwendet werden, in nichts nachsteht (Perl und Tcl sind zwei solcher bekannten Programmiersprachen).</p><div class=paragraph><p>Die aktuellste Version von Python ist in der Ports-Sammlung unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/python/>lang/python</a> verfügbar.</p></div></dd><dt class=hdlist1>Ruby</dt><dd><p>Ruby ist eine interpretierte und rein objektorientierte Programmiersprache. Sie wurde wegen ihrer leicht verständlichen Syntax, ihrer Flexibilität und der Möglichkeit, große und komplexe Programme einfach zu entwickeln und zu pflegen, populär.</p><div class=paragraph><p>Ruby ist in der Ports-Sammlung unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/ruby18/>lang/ruby18</a> verfügbar.</p></div></dd><dt class=hdlist1>Tcl und Tk</dt><dd><p>Tcl ist eine einbettbare, interpretierte Programmiersprache, welche aufgrund ihrer Portierbarkeit auf viele unterschiedliche Plattformen eine weite Verbreitung erfahren hat. Sie kann sowohl für die schnelle Entwicklung kleinerer Prototypen, als auch (in Verbindung mit Tk, einem GUI Toolkit) vollwertiger, ausgereifter Programme verwendet werden.</p><div class=paragraph><p>Es sind mehrere Versionen von Tcl als Ports für FreeBSD verfügbar. Die aktuellste Version, Tcl 8.7, ist unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/tcl87/>lang/tcl87</a> verfügbar.</p></div></dd></dl></div></div><div class=sect3><h4 id=_compiler>2.3.3. Compiler<a class=anchor href=#_compiler></a></h4><div class=paragraph><p>Compiler sind eher anders. Zuerst schreibt man seinen Code unter Verwendung eines Editors in eine Datei (oder mehrere Dateien). Anschließend ruft man den Compiler auf um zu sehen, ob dieser das Programm annimmt. Wenn das Programm nicht kompiliert werden konnte, muß man die Zähne zusammenbeissen und wieder zum Editor zurückkehren; falls das Programm kompiliert und eine ausführbare Anwendung erzeugt wurde, kann man diese über eine Eingabeaufforderung oder über einen Debugger aufrufen um zu sehen, ob sie auch funktioniert.</p></div><div class=paragraph><p>Offensichtlich ist diese Art der Programmierung nicht so direkt wie die Verwendung eines Interpreters. Jedoch sind auf diese Weise viele Dinge möglich, die mit einem Interpreter nur sehr schwer oder überhaupt nicht realisierbar wären, wie z.B. das Schreiben von Code, der sehr eng mit dem Betriebsystem zusammen arbeitet-oder das Schreiben eines eigenen Betriebsystems selbst! Des weiteren ist so das Erzeugen von sehr effizientem Code möglich, da sich der Compiler für die Optimierung Zeit nehmen kann, was bei einem Interpreter inakzeptabel wäre. Ferner ist das Verbreiten von Programmen, welche für einen Compiler geschrieben wurden, einfacher als welche, die für einen Interpreter geschrieben wurden-man muss in ersterem Fall nur die ausführbare Datei verbreiten, vorausgesetzt, daß das gleiche Betriebssystem verwendet wird.</p></div><div class=paragraph><p>Programmiersprachen, die kompiliert werden, sind unter anderem Pascal, C und C. C und C sind eher unbarmherzige Programmiersprachen und daher eher für erfahrene Programmierer gedacht; Pascal auf der anderen Seite wurde zu Ausbildungszwecken entworfen, und stellt daher eine einsteigerfreundliche Programmiersprache dar. FreeBSD beinhaltet im Basissystem keine Unterstützung für Pascal, stellt jedoch über die Ports-Sammlung den Free Pascal Compiler unter <a class=package href=https://cgit.freebsd.org/ports/tree/lang/fpc/>lang/fpc</a> zur Verfügung.</p></div><div class=paragraph><p>Da der editier-kompilier-ausführ-debug-Kreislauf unter Verwendung mehrerer Programme eher mühsam ist haben viele Hersteller von Compilern integrierte Entwicklungsumgebungen (Integrated Development Environment; auch kurz IDE) entwickelt. FreeBSD bietet zwar im Basissystem keine IDE an, stellt jedoch über die Ports-Sammlung IDEs wie <a class=package href=https://cgit.freebsd.org/ports/tree/devel/kdevelop/>devel/kdevelop</a> oder Emacs zur Verfügung, wobei letztere weit verbreitet ist. Die Verwendung von Emacs als IDE wird unter <a href=#emacs>Emacs als Entwicklungsumgebung verwenden</a> diskutiert.</p></div></div></div><div class=sect2><h3 id=tools-compiling>2.4. Kompilieren mit dem <code>cc</code><a class=anchor href=#tools-compiling></a></h3><div class=paragraph><p>Dieser Abschnitt behandelt ausschließlich den GNU Compiler für C und C++, da dieser bereits im Basissystem von FreeBSD enthalten ist. Er kann mittels <code>cc</code> oder <code>gcc</code> aufgerufen werden. Die Details zur Erstellung einer Anwendung mit einem Interpreter variieren zwischen verschiedenen Interpretern mehr oder weniger stark, und werden meist ausführlich in der zugehörigen Dokumentation oder Online-Hilfe beschrieben.</p></div><div class=paragraph><p>Sobald Sie Ihr Meisterwerk fertig geschrieben haben besteht der nächste Schritt darin, dieses (hoffentlich!) unter FreeBSD zum Laufen zu bekommen. Dies beinhaltet üblicherweise mehrere Schritte, wobei jeder einzelne Schritt von einem separaten Programm durchgeführt wird.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Aufbereiten Ihres Quelltextes durch Entfernen von Kommentaren, sowie weiteren Tricks wie das Ersetzen von Macros in C.</p></li><li><p>Überprüfen der Syntax Ihres Quelltextes, um die Einhaltung der Sprachregeln sicherzustellen. Wenn Sie diese verletzt haben werden entsprechende Fehlermeldungen Ihnen dies mitteilen!</p></li><li><p>Übersetzen des Quelltextes in Assemblersprache -diese ist dem eigentlichen Maschinencode schon sehr nahe, jedoch immer noch für Menschen lesbar. Angeblich.</p></li><li><p>Übersetzen der Assemblersprache in Maschinencode-genau, wir sprechen hier von Bits und Bytes, Einsen und Nullen.</p></li><li><p>Überprüfen, ob Sie Dinge wie Funktionen und globale Variablen in einheitlicher Weise verwendet haben. Wenn Sie z.B. eine nicht existierende Funktion aufgerufen haben, wird eine entsprechende Fehlermeldung Ihnen dies mitteilen.</p></li><li><p>Wenn aus mehreren Quelltextdateien eine ausführbare Datei erstellt werden soll wird herausgefunden, wie die einzelnen Codeteile zusammengefügt werden müssen.</p></li><li><p>Ausarbeiten, wie das Programm aussehen muss, damit der Lader zur Laufzeit des Systems dieses in den Speicher laden und ausführen kann.</p></li><li><p>Endgültiges Schreiben der ausführbaren Datei in das Dateisystem.</p></li></ol></div></div></div><div class=paragraph><p>Das Wort <em>kompilieren</em> wird häufig für die Schritte 1 bis 4 verwendet-die anderen werden mit dem Wort <em>verlinken</em> zusammengefasst. Manchmal wird Schritt 1 auch als <em>Pre-Processing</em> und die Schritte 3-4 als <em>assemblieren</em> bezeichnet.</p></div><div class=paragraph><p>Glücklicherweise werden alle diese Details vor Ihnen verborgen, da <code>cc</code> ein Frontend ist, welches sich um die Ausführung all dieser Programme mit den richtigen Argumenten für Sie kümmert; einfaches eingeben von</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc foobar.c</code></pre></div></div><div class=paragraph><p>führt zur Übersetzung von <span class=filename>foobar.c</span> durch alle bereits erwähnten Schritte. Wenn Sie mehr als eine Datei übersetzen wollen müssen Sie etwas wie folgt eingeben</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc foo.c bar.c</code></pre></div></div><div class=paragraph><p>Beachten Sie, daß die Überprüfung der Syntax genau dies tut-das reine Überprüfen der Syntax. Es findet keine Überprüfung bzgl. logischer Fehler statt, die Sie vielleicht gemacht haben, wie z.B. das Programm in eine Endlosschleife zu versetzen, oder Bubble Sort zu verwenden, wenn Sie eigentlich Binary Sort benutzen wollten.</p></div><div class=paragraph><p>Es gibt haufenweise Optionen für <code>cc</code>, die alle in der zugehörigen Manualpage beschrieben werden. Im Folgenden werden ein paar der wichtigsten Optionen mit Beispielen ihrer Anwendung gezeigt.</p></div><div class=dlist><dl><dt class=hdlist1><code>-o <em>filename</em></code></dt><dd><p>Die Name der Ausgabedatei. Wenn Sie diese Option nicht verwenden erstellt <code>cc</code> eine Datei mit dem Namen <span class=filename>a.out</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc foobar.c               executable is a.out
% cc <span class=nt>-o</span> foobar foobar.c     executable is foobar</code></pre></div></div></dd><dt class=hdlist1><code>-c</code></dt><dd><p>Dies kompiliert die Datei nur, verlinkt sie jedoch nicht. Nützlich für Spielereien, um die Syntax auf Korrektheit zu überprüfen, oder falls Sie ein <span class=filename>Makefile</span> verwenden.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-c</span> foobar.c</code></pre></div></div><div class=paragraph><p>Dieser Befehl erzeugt eine <em>Objektdatei</em> (nicht ausführbar) mit den Namen <span class=filename>foobar.o</span>. Diese kann mit anderen Objektdateien zusammen zu einer ausführbaren Datei verlinkt werden.</p></div></dd><dt class=hdlist1><code>-g</code></dt><dd><p>Diese Option erzeugt die Debug-Version einer ausführbaren Datei. Dabei fügt der Compiler zusätzliche Informationen darüber, welcher Funktionsaufruf zu welcher Zeile im Quelltext gehört, der ausführbaren Datei hinzu. Ein Debugger kann Ihnen mit Hilfe dieser Information den zugehörigen Quelltext anzeigen, während Sie den Programmverlauf schrittweise verfolgen, was <em>sehr</em> hilfreich sein kann; der Nachteil dabei ist, daß durch die zusätzlichen Informationen das Programm viel größer wird. Normalerweise verwendet man die Option <code>-g</code> während der Entwicklung eines Programms, und für die "Release-Version", wenn man von der Korrektheit des Programms überzeugt ist, kompiliert man das Programm dann ohne diese Option.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-g</span> foobar.c</code></pre></div></div><div class=paragraph><p>Mit diesem Befehl wird eine Debug-Version des Programms erzeugt.</p></div></dd><dt class=hdlist1><code>-O</code></dt><dd><p>Diese Option erzeugt eine optimierte Version der ausführbaren Datei. Der Compiler verwendet einige clevere Tricks, um das erzeugte Programm schneller zu machen. Sie können hinter der Option <code>-O</code> eine Zahl angeben, um eine höheres Level der Optimierung festzulegen. Dadurch wird jedoch häufig eine fehlerhafte Optimierung seitens des Compilers aufgedeckt. Zum Beispiel erzeugte die Version des <code>cc</code>, welche mit dem FreeBSD Release 2.1.0 mitgeliefert wurde, bei Verwendung der Option <code>-O2</code> unter bestimmten Umständen falschen Code.</p><div class=paragraph><p>Optimierungen werden normalerweise nur beim Kompilieren von Release-Versionen aktiviert.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-O</span> <span class=nt>-o</span> foobar foobar.c</code></pre></div></div><div class=paragraph><p>Durch diesen Befehl wird eine optimierte Version von <span class=filename>foobar</span> erzeugt.</p></div></dd></dl></div><div class=paragraph><p>Die folgenden drei Flags zwingen den <code>cc</code> dazu, Ihren Code auf die Einhaltung der internationalen Standards hin zu überprüfen, welche häufig als ANSI Standards bezeichnet werden, obwohl sie streng genommen zum ISO Standard gehören.</p></div><div class=dlist><dl><dt class=hdlist1><code>-Wall</code></dt><dd><p>Aktivieren aller Warnmeldungen, die die Autoren des <code>cc</code> für wichtig halten. Trotz des Namens dieser Option werden dadurch nicht sämtliche Warnungen ausgegeben, die der <code>cc</code> ausgeben könnte.</p></dd><dt class=hdlist1><code>-ansi</code></dt><dd><p>Deaktivieren der meisten, jedoch nicht aller, nicht-ANSI C Eigenschaften, die der <code>cc</code> bietet. Trotz des Namens ist durch diese Option nicht sichergestellt, daß Ihr Code diese Standards auch vollständig einhält.</p></dd><dt class=hdlist1><code>-pedantic</code></dt><dd><p>Deaktivieren <em>aller</em> Eigenschaften des <code>cc</code>, welche nicht konform zu ANSI C sind.</p></dd></dl></div><div class=paragraph><p>Ohne diese Flags wird Ihnen der <code>cc</code> die Verwendung eigener Erweiterungen des Standards erlauben. Einige dieser Erweiterungen sind zwar sehr nützlich, werden jedoch nicht von anderen Compilern unterstützt-eigentlich ist eines der Hauptziele des Standards, das Leute Code so schreiben können, daß dieser mit jedem Compiler auf beliebigen Systemen funktioniert. Dies wird häufig als <em>portabler Code</em> bezeichnet.</p></div><div class=paragraph><p>Im Allgemeinen sollten Sie versuchen, Ihren Code so portabel wie möglich zu schreiben, da Sie ansonsten eventuell das gesamte Programm noch einmal neu schreiben müssen, falls dieser in einer anderen Umgebung laufen soll-und wer weiß schon was er in ein paar Jahren verwenden wird?</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-Wall</span> <span class=nt>-ansi</span> <span class=nt>-pedantic</span> <span class=nt>-o</span> foobar foobar.c</code></pre></div></div><div class=paragraph><p>Durch diesen Befehl wird eine ausführbare Datei namens <span class=filename>foobar</span> erzeugt, nachdem <span class=filename>foobar.c</span> auf die Einhaltung der Standards überprüft wurde.</p></div><div class=dlist><dl><dt class=hdlist1><code>-l <em>library</em></code></dt><dd><p>Mit dieser Option kann eine Bibliothek mit Funktionen angegeben werden, die während des Verlinkens verwendet wird.</p><div class=paragraph><p>Das am häufigsten auftretende Beispiel dieser Option ist die Übersetzung eines Programmes, welches einige der mathematischen Funktionen in C verwendet. Im Gegensatz zu den meisten anderen Plattformen befinden sich diese Funktionen in einer separaten Bibliothek, deren Verwendung Sie dem Compiler explizit mitteilen müssen.</p></div><div class=paragraph><p>Angenommen eine Bibliothek heißt <span class=filename>libirgendwas.a</span>, dann müssen Sie dem <code>cc</code> als Argument <code>-l <em>irgendwas</em></code> übergeben. Zum Beispiel heißt die Mathematik-Bibliothek <span class=filename>libm.a</span>, und daher müssen Sie dem <code>cc</code> als Argument <code>-lm</code> übergeben. Ein typisches "Manko" der Mathematik-Bibliothek ist, daß diese immer die letzte Bibliothek auf der Kommandozeile sein muß.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.c <span class=nt>-lm</span></code></pre></div></div><div class=paragraph><p>Durch diesen Befehl werden die Funktionen aus der Mathematik-Bibliothek in <span class=filename>foobar</span> gelinkt.</p></div><div class=paragraph><p>Wenn Sie c++ -Code kompilieren wollen, müssen Sie -lg++, bzw. -lstdc++ falls Sie FreeBSD 2.2 oder neuer verwenden, zu Ihrer Kommandozeile hinzufügen, um Ihr Programm gegen die Funktionen der C Bibliothek zu linken. Alternativ können Sie anstatt cc auch {c-plus-plus-command} aufrufen, welcher dies für Sie erledigt. C kann unter FreeBSD auch als g++ aufgerufen werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.cc <span class=nt>-lg</span>++     Bei FreeBSD 2.1.6 oder älter
% cc <span class=nt>-o</span> foobar foobar.cc <span class=nt>-lstdc</span>++  Bei FreeBSD 2.2 und neuer
% c++ <span class=nt>-o</span> foobar foobar.cc</code></pre></div></div><div class=paragraph><p>Beide Varianten erzeugen eine ausführbare <span class=filename>foobar</span> aus der c++ Quelltextdatei <span class=filename>foobar.cc</span>. Beachten Sie bitte, daß auf UNIX® Systemen c++ Quelltextdateien üblicherweise auf <span class=filename>.C</span>, <span class=filename>.cxx</span> oder <span class=filename>.cc</span> enden, und nicht wie bei MS-DOS® auf <span class=filename>.cpp</span> (welche schon anderweitig benutzt wurde). Der <code>gcc</code> hat normalerweise anhand dieser Information entschieden, welcher Compiler für die Quelltextdatei zum Einsatz kommen soll; allerdings gilt diese Einschränkung jetzt nicht mehr, und Sie können Ihre c++-Dateien ungestraft auf <span class=filename>.cpp</span> enden lassen!</p></div></dd></dl></div><div class=sect3><h4 id=_häufig_auftretende_cc_fragen_und_probleme>2.4.1. Häufig auftretende <code>cc</code>-Fragen und -Probleme<a class=anchor href=#_häufig_auftretende_cc_fragen_und_probleme></a></h4><div class=sect4><h5 id=_ich_versuche_ein_programm_zu_schreiben_welches_die_funktion_sin_verwendet_erhalte_jedoch_eine_fehlermeldung_was_bedeutet_diese>2.4.1.1. Ich versuche ein Programm zu schreiben, welches die Funktion sin() verwendet, erhalte jedoch eine Fehlermeldung. Was bedeutet diese?<a class=anchor href=#_ich_versuche_ein_programm_zu_schreiben_welches_die_funktion_sin_verwendet_erhalte_jedoch_eine_fehlermeldung_was_bedeutet_diese></a></h5><div class=paragraph><p>Wenn Sie mathematische Funktionen wie <code>sin()</code> verwenden wollen, müssen Sie den <code>cc</code> anweisen, die Mathematik-Bibliothek wie folgt zu verlinken:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.c <span class=nt>-lm</span></code></pre></div></div></div><div class=sect4><h5 id=_so_ich_habe_jetzt_dieses_einfache_programm_als_übung_für_lm_geschrieben_alles_was_es_macht_ist_2_1_hoch_6_zu_berechnen>2.4.1.2. So, ich habe jetzt dieses einfache Programm als Übung für -lm geschrieben. Alles was es macht ist, 2.1 hoch 6 zu berechnen.<a class=anchor href=#_so_ich_habe_jetzt_dieses_einfache_programm_als_übung_für_lm_geschrieben_alles_was_es_macht_ist_2_1_hoch_6_zu_berechnen></a></h5><div class=paragraph><p>Wenn der Compiler Ihren Funktionsaufruf sieht, überprüft er, ob er schon einmal einen Prototypen für diese gesehen hat. Wenn nicht nimmt er als Rückgabewert den Typ <span class=type>int</span> an, was sicherlich nicht das ist, was Sie an dieser Stelle wollen.</p></div></div><div class=sect4><h5 id=_wie_kann_ich_das_korrigieren>2.4.1.3. Wie kann ich das korrigieren?<a class=anchor href=#_wie_kann_ich_das_korrigieren></a></h5><div class=paragraph><p>Die Prototypen der mathematischen Funktionen befinden sich in der Datei <span class=filename>math.h</span>. Wenn Sie diese Datei in Ihrem Quelltext includen ist der Compiler in der Lage, den Prototypen zu finden, und wird aufhören, seltsame Dinge mit Ihrer Berechnung zu machen!</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int main() {
...</pre></div></div><div class=paragraph><p>Nach erneutem Compilieren sollte das Folgende bei der Ausführung ausgegeben werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./a.out
2.1 ^ 6 <span class=o>=</span> 85.766121</code></pre></div></div><div class=paragraph><p>Wenn Sie irgendwelche mathematischen Funktionen verwenden sollten Sie <em>immer</em> die Datei <span class=filename>math.h</span> includen und nicht vergessen, Ihr Programm gegen die Mathematik-Bibliothek zu verlinken.</p></div></div><div class=sect4><h5 id=_ich_habe_eine_datei_mit_dem_namen_foobar_c_kompiliert_kann_jedoch_nirgends_eine_ausführbare_datei_namens_foobar_finden_wo_befindet_sich_diese>2.4.1.4. Ich habe eine Datei mit dem Namen foobar.c kompiliert, kann jedoch nirgends eine ausführbare Datei namens foobar finden. Wo befindet sich diese?<a class=anchor href=#_ich_habe_eine_datei_mit_dem_namen_foobar_c_kompiliert_kann_jedoch_nirgends_eine_ausführbare_datei_namens_foobar_finden_wo_befindet_sich_diese></a></h5><div class=paragraph><p>Denken Sie daran, daß der <code>cc</code> die ausführbare Datei <span class=filename>a.out</span> nennt, wenn Sie nicht explizit einen Namen angeben. Verwenden Sie in solch einem Fall die Option <code>-o <em>filename</em></code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.c</code></pre></div></div></div><div class=sect4><h5 id=_ok_ich_habe_eine_ausführbare_datei_namens_foobar_ich_kann_sie_sehen_wenn_ich_ls_aufrufe_gebe_ich_jedoch_foobar_in_die_kommandozeile_ein_wird_mir_gesagt_daß_eine_datei_mit_diesem_namen_nicht_existiert_warum_kann_die_datei_nicht_gefunden_werden>2.4.1.5. OK, ich habe eine ausführbare Datei namens foobar, ich kann sie sehen, wenn ich ls aufrufe. Gebe ich jedoch foobar in die Kommandozeile ein wird mir gesagt, daß eine Datei mit diesem Namen nicht existiert. Warum kann die Datei nicht gefunden werden?<a class=anchor href=#_ok_ich_habe_eine_ausführbare_datei_namens_foobar_ich_kann_sie_sehen_wenn_ich_ls_aufrufe_gebe_ich_jedoch_foobar_in_die_kommandozeile_ein_wird_mir_gesagt_daß_eine_datei_mit_diesem_namen_nicht_existiert_warum_kann_die_datei_nicht_gefunden_werden></a></h5><div class=paragraph><p>Im Gegensatz zu MS-DOS® sucht UNIX® nicht im aktuellen Verzeichnis nach einem ausführbaren Programm, das Sie versuchen auszuführen, solange Sie dies nicht explizit mit angeben. Sie können entweder <code>./foobar</code> eingeben, was soviel bedeutet wie "führe eine Datei namens <span class=filename>foobar</span> im aktuellen Verzeichnis aus", oder Sie können Ihre Umgebungsvariable <code>PATH</code> so erweitern, daß sie ähnlich wie folgt aussieht</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bin:/usr/bin:/usr/local/bin:.</code></pre></div></div><div class=paragraph><p>Der Punkt am Ende bedeutet "siehe im aktuellen Verzeichnis nach, wenn es in keinem der anderen zu finden war".</p></div></div><div class=sect4><h5 id=_ich_habe_meine_ausführbare_datei_test_genannt_allerdings_passiert_nichts_wenn_ich_diese_aufrufe_was_ist_hier_los>2.4.1.6. Ich habe meine ausführbare Datei test genannt, allerdings passiert nichts wenn ich diese aufrufe. Was ist hier los?<a class=anchor href=#_ich_habe_meine_ausführbare_datei_test_genannt_allerdings_passiert_nichts_wenn_ich_diese_aufrufe_was_ist_hier_los></a></h5><div class=paragraph><p>Bei den meisten UNIX®-Systeme existiert bereits ein Programm mit dem Namen <code>test</code> im Verzeichnis <span class=filename>/usr/bin</span>, und die Shell nimmt dieses, bevor sie im aktuellen Verzeichnis nachsieht. Sie können entweder den folgenden Befehl eingeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./test</code></pre></div></div><div class=paragraph><p>oder Sie können einen geeigneteren Namen für Ihr Programm wählen!</p></div></div><div class=sect4><h5 id=_ich_habe_mein_programm_kompiliert_und_bei_dessen_aufruf_sah_zuerst_alles_gut_aus_jedoch_gab_es_dann_eine_fehlermeldung_welche_irgendetwas_mit_core_dumped_lautete_was_bedeutet_das>2.4.1.7. Ich habe mein Programm kompiliert und bei dessen Aufruf sah zuerst alles gut aus. Jedoch gab es dann eine Fehlermeldung, welche irgendetwas mit core dumped lautete. Was bedeutet das?<a class=anchor href=#_ich_habe_mein_programm_kompiliert_und_bei_dessen_aufruf_sah_zuerst_alles_gut_aus_jedoch_gab_es_dann_eine_fehlermeldung_welche_irgendetwas_mit_core_dumped_lautete_was_bedeutet_das></a></h5><div class=paragraph><p>Der Name <em>core dump</em> stammt noch aus sehr frühen Zeiten von UNIX®, als die Maschinen noch Kernspeicher zum Speichern von Daten verwendeten. Einfach ausgedrückt, wenn bei einem Programm unter bestimmen Bedingungen ein Fehler auftrat, hat das System den Inhalt des Kernspeichers auf der Festplatte in eine Datei namens <span class=filename>core</span> geschrieben, welche der Programmierer dann näher untersuchen konnte, um die Ursache des Fehlers herauszufinden.</p></div></div><div class=sect4><h5 id=_faszinierendes_zeugs_aber_was_soll_ich_jetzt_machen>2.4.1.8. Faszinierendes Zeugs, aber was soll ich jetzt machen?<a class=anchor href=#_faszinierendes_zeugs_aber_was_soll_ich_jetzt_machen></a></h5><div class=paragraph><p>Verwenden Sie den <code>gdb</code>, um das Speicherabbild zu untersuchen (siehe <a href=#debugging>Debuggen</a>).</p></div></div><div class=sect4><h5 id=_als_mein_programm_den_core_dump_erzeugt_hat_sagte_es_etwas_von_einem_segmentation_fault_was_ist_das>2.4.1.9. Als mein Programm den core dump erzeugt hat, sagte es etwas von einem segmentation fault. Was ist das?<a class=anchor href=#_als_mein_programm_den_core_dump_erzeugt_hat_sagte_es_etwas_von_einem_segmentation_fault_was_ist_das></a></h5><div class=paragraph><p>Diese Meldung heißt im Prinzip, daß Ihr Programm eine illegale Operation mit dem Speicher durchführen wollte; UNIX® wurde so entworfen, daß es das andere Programme und das Betriebssystem selbst vor wildgewordenen Programmen schützt.</p></div><div class=paragraph><p>Häufige Ursachen hierfür sind:</p></div><div class=ulist><ul><li><p>Der Versuch, einen NULL-Zeiger zu beschreiben, z.B.</p><div class="literalblock programlisting"><div class=content><pre>char *foo = NULL;
strcpy(foo, &#34;bang!&#34;);</pre></div></div></li><li><p>Einen Zeiger zu verwenden, welcher noch nicht initialisiert wurde, z.B.</p><div class="literalblock programlisting"><div class=content><pre>char *foo;
strcpy(foo, &#34;bang!&#34;);</pre></div></div><div class=paragraph><p>Der Zeiger hat einen zufälligen Wert, welcher mit etwas Glück in einen Bereich des Speichers zeigt, der für Ihr Programm nicht verfügbar ist, und der Kernel bricht Ihr Programm ab, bevor es irgendwelchen Schaden anrichten kann. Wenn Sie Pech haben zeigt der Zeiger irgendwo mitten in Ihr eigenes Programm, und verändert dort ihre eigenen Datenstrukturen, was zu sehr seltsamen Fehlern Ihres Programmes führt.</p></div></li><li><p>Der Versuch, auf Daten außerhalb eines Arrays zuzugreifen, z.B.</p><div class="literalblock programlisting"><div class=content><pre>int bar[20];
bar[27] = 6;</pre></div></div></li><li><p>Der Versuch, Daten in eine Speicherbereich zu schreiben, der nur lesbar ist, z.B.</p><div class="literalblock programlisting"><div class=content><pre>char *foo = &#34;My string&#34;;
strcpy(foo, &#34;bang!&#34;);</pre></div></div><div class=paragraph><p>UNIX®-Compiler speichern häufig feste Zeichenketten wie <code>"My string"</code> in nur lesbaren Speicherbereichen ab.</p></div></li><li><p>Wenn man unerlaubte Operationen mit <code>malloc()</code> und <code>free()</code> ausführt, z.B.</p><div class="literalblock programlisting"><div class=content><pre>char bar[80];
free(bar);</pre></div></div><div class=paragraph><p>oder</p></div><div class="literalblock programlisting"><div class=content><pre>char *foo = malloc(27);
free(foo);
free(foo);</pre></div></div></li></ul></div><div class=paragraph><p>Einzelne solcher Fehler führen zwar nicht immer zu einem Fehlverhalten des Programms, stellen jedoch immer eine falsche Verwendung dar. Manche Systeme und Compiler sind toleranter als andere, weshalb Programme auf dem einen System einwandfrei laufen, auf dem anderen System jedoch abstürzen.</p></div></div><div class=sect4><h5 id=_wenn_ich_einen_core_dump_erhalte_erscheint_manchmal_die_meldung_bus_error_in_meinem_unix_buch_steht_daß_die_ursache_ein_hardwareproblem_sei_der_computer_scheint_aber_weiterhin_zu_funktionieren_ist_dies_wahr>2.4.1.10. Wenn ich einen core dump erhalte erscheint manchmal die Meldung bus error. In meinem UNIX®-Buch steht, daß die Ursache ein Hardwareproblem sei. Der Computer scheint aber weiterhin zu funktionieren. Ist dies wahr?<a class=anchor href=#_wenn_ich_einen_core_dump_erhalte_erscheint_manchmal_die_meldung_bus_error_in_meinem_unix_buch_steht_daß_die_ursache_ein_hardwareproblem_sei_der_computer_scheint_aber_weiterhin_zu_funktionieren_ist_dies_wahr></a></h5><div class=paragraph><p>Nein, glücklicherweise nicht (es sei denn Sie haben wirklich ein Hardwareproblem…​). Üblicherweise ist dies ein Weg Ihnen mitzuteilen, daß Sie auf Speicher in einer Weise zugegriffen haben, in der Sie dies nicht tun sollten.</p></div></div><div class=sect4><h5 id=_diese_sache_mit_den_core_dumps_hört_sich_sehr_nützlich_an_wenn_ich_so_etwas_selber_an_beliebiger_stelle_bewirken_könnte_kann_ich_das_tun_oder_muß_ich_warten_bis_ein_fehler_auftritt>2.4.1.11. Diese Sache mit den core dumps hört sich sehr nützlich an, wenn ich so etwas selber an beliebiger Stelle bewirken könnte. Kann ich das tun, oder muß ich warten bis ein Fehler auftritt?<a class=anchor href=#_diese_sache_mit_den_core_dumps_hört_sich_sehr_nützlich_an_wenn_ich_so_etwas_selber_an_beliebiger_stelle_bewirken_könnte_kann_ich_das_tun_oder_muß_ich_warten_bis_ein_fehler_auftritt></a></h5><div class=paragraph><p>Ja, nehmen sie einfach eine andere Konsole oder XTerm und führen Sie</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps</code></pre></div></div><div class=paragraph><p>aus, um die Prozess-ID Ihres Programms herauszufinden. Führen Sie anschließend</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>kill</span> <span class=nt>-ABRT</span> pid</code></pre></div></div><div class=paragraph><p>aus, wobei <span class=parameter><em>pid</em></span> die Prozess-ID ist, die Sie vorher ermittelt haben.</p></div><div class=paragraph><p>Dies ist nützlich, wenn sich Ihr Programm z.B. in einer Endlosschleife verfangen hat. Sollte Ihr Programm das Signal SIGABRT abfangen, gibt es noch andere Möglichkeiten, die denselben Effekt haben.</p></div><div class=paragraph><p>Alternativ können Sie einen core dump aus Ihrem Programm heraus erstellen, indem Sie die Funktion <code>abort()</code> aufrufen. Weitere Informationen darüber können Sie in der Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=abort&amp;sektion=3&amp;format=html">abort(3)</a> nachlesen.</p></div><div class=paragraph><p>Wenn Sie einen core dump von außerhalb Ihres Programms erzeugen wollen, ohne dabei den Prozess abzubrechen, können Sie das Programm <code>gcore</code> verwenden. Weitere Informationen dazu finden Sie in der zugehörigen Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=gcore&amp;sektion=1&amp;format=html">gcore(1)</a>.</p></div></div></div></div><div class=sect2><h3 id=tools-make>2.5. Make<a class=anchor href=#tools-make></a></h3><div class=sect3><h4 id=_was_ist_make>2.5.1. Was ist <code>make</code>?<a class=anchor href=#_was_ist_make></a></h4><div class=paragraph><p>Wenn Sie an einem einfachen Programm mit nur einer oder zwei Quelltextdateien arbeiten, ist die Eingabe von</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc file1.c file2.c</code></pre></div></div><div class=paragraph><p>zwar nicht aufwendig, wird aber mit zunehmender Anzahl der Quelltextdateien sehr lästig-und auch das Kompilieren kann eine Weile dauern.</p></div><div class=paragraph><p>Eine Möglichkeit dies zu umgehen besteht in der Verwendung von Objektdateien, wobei man nur die Quelltextdateien neu kompiliert, die verändert wurden. So könnten wir etwa folgendes erhalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc file1.o file2.o … file37.c …</code></pre></div></div><div class=paragraph><p>falls wir seit dem letzten Kompiliervorgang nur die Datei <span class=filename>file37.c</span> verändert haben. Dadurch könnte der Kompiliervorgang um einiges beschleunigt werden, es muß jedoch immer noch alles von Hand eingegeben werden.</p></div><div class=paragraph><p>Oder wir könnten uns ein Shell Skript schreiben. Dieses würde jedoch alles immer wieder neu kompilieren, was bei einem großen Projekt sehr ineffizient wäre.</p></div><div class=paragraph><p>Was ist, wenn wir hunderte von Quelltextdateien hätten? Was ist, wenn wir in einem Team mit anderen Leuten arbeiten würden, die vergessen uns Bescheid zu sagen, falls sie eine der Quelltextdateien verändert haben, die wir ebenfalls benutzen?</p></div><div class=paragraph><p>Vielleicht könnten wir beide Lösungen kombinieren und etwas wie ein Shell Skript schreiben, welches eine Art magische Regel enthalten würde, die feststellt, welche Quelltextdateien neu kompiliert werden müssten. Alles was wir bräuchten wäre ein Programm, das diese Regeln verstehen könnte, da diese Aufgabe etwas zu kompliziert für eine Shell ist.</p></div><div class=paragraph><p>Dieses Programm heißt <code>make</code>. Es liest eine Datei namens <em>makefile</em>, welche ihm sagt, wie unterschiedliche Dateien voneinander abhängen, und berechnet, welche Dateien neu kompiliert werden müssen und welche nicht. Zum Beispiel könnte eine Regel etwas sagen wie "wenn <span class=filename>fromboz.o</span> älter als <span class=filename>fromboz.c</span> ist, bedeutet dies, daß jemand die Datei <span class=filename>fromboz.c</span> verändert haben muß, und diese daher neu kompiliert werden muß." Das makefile enthält außerdem Regeln die make sagen, <em>wie</em> die Quelltextdatei neu kompiliert werden muß, was dieses Tool noch sehr viel mächtiger macht.</p></div><div class=paragraph><p>Makefiles werden normalerweise im selben Verzeichnis wie die Quelltextdateien abgelegt, zu denen sie gehören, und kann <span class=filename>makefile</span>, <span class=filename>Makefile</span> oder <span class=filename>MAKEFILE</span> heißen. Die meisten Programmierer verwenden den Namen <span class=filename>Makefile</span>, da diese Schreibweise dafür sorgt, daß die Datei gut lesbar ganz oben in der Verzeichnisliste aufgeführt wird.</p></div></div><div class=sect3><h4 id=_beispielhafte_verwendung_von_make>2.5.2. Beispielhafte Verwendung von <code>make</code><a class=anchor href=#_beispielhafte_verwendung_von_make></a></h4><div class=paragraph><p>Hier ist eine sehr einfache make Datei:</p></div><div class="literalblock programlisting"><div class=content><pre>foo: foo.c
	cc -o foo foo.c</pre></div></div><div class=paragraph><p>Sie besteht aus zwei Zeilen, einer Abhängigkeitszeile und einer Erzeugungszeile.</p></div><div class=paragraph><p>Die Abhängigkeitszeile hier besteht aus dem Namen des Programms (auch <em>Ziel</em> genannt), gefolgt von einem Doppelpunkt und einem Leerzeichen, und anschließend dem Namen der Quelltextdatei. Wenn <code>make</code> diese Zeile liest überprüft es die Existenz von <span class=filename>foo</span>; falls diese Datei existiert vergleicht es das Datum der letzten Änderung von <span class=filename>foo</span> mit der von <span class=filename>foo.c</span>. Falls <span class=filename>foo</span> nicht existiert, oder älter als <span class=filename>foo.c</span> ist, liest es die Erzeugungszeile um herauszufinden, was zu tun ist. Mit anderen Worten, dies ist die Regel die festlegt, wann <span class=filename>foo.c</span> neu kompiliert werden muß.</p></div><div class=paragraph><p>Die Erzeugungszeile beginnt mit einem tab (drücken Sie dazu die <kbd>tab</kbd>-Taste) gefolgt von dem Befehl, mit dem Sie <span class=filename>foo</span> manuell erzeugen würden. Wenn <span class=filename>foo</span> veraltet ist, oder nicht existiert, führt <code>make</code> diesen Befehl aus, um die Datei zu erzeugen. Mit anderen Worten, dies ist die Regel die make sagt, wie <span class=filename>foo.c</span> kompiliert werden muß.</p></div><div class=paragraph><p>Wenn Sie also <code>make</code> eingeben wird dieses sicherstellen, daß <span class=filename>foo</span> bzgl. Ihrer letzten Änderungen an <span class=filename>foo.c</span> auf dem neuesten Stand ist. Dieses Prinzip kann auf <span class=filename>Makefile</span>s mit hunderten von Zielen-es ist bei FreeBSD praktisch möglich, das gesamte Betriebssystem zu kompilieren, indem man nur <code>make world</code> im richtigen Verzeichnis eingibt!</p></div><div class=paragraph><p>Eine weitere nützliche Eigenschaft der makefiles ist, daß die Ziele keine Programme sein müssen. Wir könnten zum Beispiel eine make Datei haben, die wie folgt aussieht:</p></div><div class="literalblock programlisting"><div class=content><pre>foo: foo.c
	cc -o foo foo.c

install:
	cp foo /home/me</pre></div></div><div class=paragraph><p>Wir können make sagen welches Ziel wir erzeugt haben wollen, indem wir etwas wie folgt eingeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% make target</code></pre></div></div><div class=paragraph><p><code>make</code> wird dann nur dieses Ziel beachten und alle anderen ignorieren. Wenn wir zum Beispiel <code>make foo</code> mit dem obigen makefile eingeben, dann wird make das Ziel <code>install</code> ignorieren.</p></div><div class=paragraph><p>Wenn wir nur <code>make</code> eingeben wird make immer nur nach dem ersten Ziel suchen und danach mit dem Suchen aufhören. Wenn wir hier also nur <code>make</code> eingegeben hätten, würde es nur zu dem Ziel <code>foo</code> gehen, gegebenenfalls <span class=filename>foo</span> neu kompilieren, und danach einfach aufhören, ohne das Ziel <code>install</code> zu beachten.</p></div><div class=paragraph><p>Beachten Sie, daß das <code>install</code>-Ziel von nichts anderem abhängt! Dies bedeutet, daß der Befehl in der nachfolgenden Zeile immer ausgeführt wird, wenn wir dieses Ziel mittels <code>make install</code> aufrufen. In diesem Fall wird die Datei <span class=filename>foo</span> in das Heimatverzeichnis des Benutzers kopiert. Diese Vorgehensweise wird häufig bei makefiles von Anwendungen benutzt, damit die Anwendung nach erfolgreicher Kompilierung in das richtige Verzeichnis installiert werden kann.</p></div><div class=paragraph><p>Dieser Teil ist etwas schwierig zu erklären. Wenn Sie immer noch nicht so richtig verstanden haben, wie <code>make</code> funktioniert, wäre es das Beste, sie erstellen sich selber ein einfaches Programm wie "hello world" und eine make Datei wie die weiter oben angegebene, und experimentieren damit selber ein bißchen herum. Als nächstes könnten Sie mehrere Quelltextdateien verwenden, oder in Ihrer Quelltextdatei eine Header-Datei includen. Der Befehl <code>touch</code> ist an dieser Stelle ganz hilfreich-er verändert das Datum einer Datei, ohne das Sie diese extra editieren müssen.</p></div></div><div class=sect3><h4 id=_make_und_include_dateien>2.5.3. Make und include-Dateien<a class=anchor href=#_make_und_include_dateien></a></h4><div class=paragraph><p>C-Code beginnt häufig mit einer Liste von Dateien, die included werden sollen, zum Beispiel stdio.h. Manche dieser Dateien sind include-Dateien des Systems, andere gehören zum aktuellen Projekt, an dem Sie gerade arbeiten:</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;stdio.h&gt;
#include &#34;foo.h&#34;

int main(....</pre></div></div><div class=paragraph><p>Um sicherzustellen, daß diese Datei neu kompiliert wird, wenn <span class=filename>foo.h</span> verändert wurde, müssen Sie diese Datei Ihrem <span class=filename>Makefile</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>foo: foo.c foo.h</pre></div></div><div class=paragraph><p>Sobald Ihr Projekt größer wird und Sie mehr und mehr eigene include-Dateien verwalten müssen wird es nur noch sehr schwer möglich sein, die Übersicht über alle include-Dateien und Dateien, die von diesen abhängen, beizubehalten. Falls Sie eine include-Datei verändern, jedoch das erneute Kompilieren aller Dateien, die von dieser Datei abhängen, vergessen, werden die Folgen verheerend sein. Der <code>gcc</code> besitzt eine Option, bei der er Ihre Dateien analysiert und eine Liste aller include-Dateien und deren Abhängigkeiten erstellt: <code>-MM</code>.</p></div><div class=paragraph><p>Wenn Sie das Folgende zu Ihrem Makefile hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>depend:
	gcc -E -MM *.c &gt; .depend</pre></div></div><div class=paragraph><p>und <code>make depend</code> ausführen, wird die Datei <span class=filename>.depend</span> mit einer Liste von Objekt-Dateien, C-Dateien und den include-Dateien auftauchen:</p></div><div class="literalblock programlisting"><div class=content><pre>foo.o: foo.c foo.h</pre></div></div><div class=paragraph><p>Falls Sie <span class=filename>foo.h</span> verändern werden beim nächsten Aufruf von <code>make</code> alle Dateien, die von <span class=filename>foo.h</span> abhängen, neu kompiliert.</p></div><div class=paragraph><p>Vergessen Sie nicht jedes mal <code>make depend</code> aufzurufen, wenn Sie eine include-Datei zu einer Ihrer Dateien hinzugefügt haben.</p></div></div><div class=sect3><h4 id=_freebsd_makefiles>2.5.4. FreeBSD Makefiles<a class=anchor href=#_freebsd_makefiles></a></h4><div class=paragraph><p>Makefiles können eher schwierig zu schreiben sein. Glücklicherweise kommen BSD-basierende Systeme wie FreeBSD mit einigen sehr mächtigen solcher Dateien als Teil des Systems daher. Ein sehr gutes Beispiel dafür ist das FreeBSD Portssystem. Hier ist der grundlegende Teil eines typischen <span class=filename>Makefile</span>s des Portssystems:</p></div><div class="literalblock programlisting"><div class=content><pre>MASTER_SITES=   ftp://freefall.cdrom.com/pub/FreeBSD/LOCAL_PORTS/
DISTFILES=      scheme-microcode+dist-7.3-freebsd.tgz

.include &lt;bsd.port.mk&gt;</pre></div></div><div class=paragraph><p>Wenn wir jetzt in das Verzeichnis dieses Ports wechseln und <code>make</code> aufrufen, passiert das Folgende:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Es wird überprüft, ob sich der Quelltext für diesen Port bereits auf Ihrem System befindet.</p></li><li><p>Falls dies nicht der Fall ist wird eine FTP-Verbindung zu der URL in MASTER_SITES aufgebaut und der Quelltext heruntergeladen.</p></li><li><p>Die Checksumme für den Quelltext wird berechnet und mit der schon bekannten und für sicher und gut empfundenen verglichen. Damit wird sichergestellt, daß der Quelltext bei der Übertragung nicht beschädigt wurde.</p></li><li><p>Sämtliche Anpassungen, die nötig sind, damit der Quelltext unter FreeBSD funktioniert, werden vorgenommen-dieser Vorgang wird auch <em>patchen</em> genannt.</p></li><li><p>Alle speziellen Konfigurationen, die am Quelltext nötig sind, werden vorgenommen. (Viele UNIX® Programmdistributionen versuchen herauszufinden, auf welcher UNIX®-Version sie kompiliert werden sollen und welche optionalen UNIX®-Features vorhanden sind-an dieser Stelle erhalten sie die Informationen im FreeBSD Ports Szenario).</p></li><li><p>Der Quelltext für das Programm wird kompiliert. Im Endeffekt wechseln wir in das Verzeichnis, in das der Quelltext entpackt wurde, und rufen <code>make</code> auf-die eigene make-Datei des Programms besitzt die nötigen Informationen um dieses zu bauen.</p></li><li><p>Wir haben jetzt eine kompilierte Version des Programmes. Wenn wir wollen können wir dieses jetzt testen; wenn wir überzeugt vom Programm sind, können wir <code>make install</code> eingeben. Dadurch werden das Programm sowie alle zugehörigen Dateien an die richtige Stelle kopiert; es wird auch ein Eintrag in der <code>Paketdatenbank</code> erzeugt, sodaß der Port sehr einfach wieder deinstalliert werden kann, falls wir unsere Meinung über dieses geändert haben.</p></li></ol></div></div></div><div class=paragraph><p>Ich glaube jetzt werden Sie mit mir übereinstimmen, daß dies ziemlich eindrucksvoll für ein Skript mit vier Zeilen ist!</p></div><div class=paragraph><p>Das Geheimnis liegt in der letzten Zeile, die <code>make</code> anweist, in das makefile des Systems mit dem Namen <span class=filename>bsd.port.mk</span> zu sehen. Man kann diese Zeile zwar leicht übersehen, aber hierher kommt all das klevere Zeugs-jemand hat ein makefile geschrieben, welches <code>make</code> anweist, alle weiter oben beschriebenen Schritte durchzuführen (neben vielen weiteren Dingen, die ich nicht angesprochen habe, einschließlich der Behandlung sämtlicher Fehler, die auftreten könnten) und jeder kann darauf zurückgreifen, indem er eine einzige Zeile in seine eigene make-Datei einfügt!</p></div><div class=paragraph><p>Falls Sie einen Blick in die makefiles des Systems werfen möchten, finden Sie diese in <span class=filename>/usr/shared/mk</span>. Es ist aber wahrscheinlich besser, wenn Sie damit noch warten, bis Sie ein bißchen mehr Praxiserfahrung mit makefiles gesammelt haben, da die dortigen makefiles sehr kompliziert sind (und wenn Sie sich diese ansehen sollten Sie besser eine Kanne starken Kaffee griffbereit haben!)</p></div></div><div class=sect3><h4 id=_fortgeschrittene_verwendung_von_make>2.5.5. Fortgeschrittene Verwendung von <code>make</code><a class=anchor href=#_fortgeschrittene_verwendung_von_make></a></h4><div class=paragraph><p><code>Make</code> ist ein sehr mächtiges Werkzeug und kann noch sehr viel mehr als die gezeigten einfachen Beispiele weiter oben. Bedauerlicherweise gibt es mehrere verschiedene Versionen von <code>make</code>, und sie alle unterscheiden sich beträchtlich voneinander. Der beste Weg herauszufinden was sie können ist wahrscheinlich deren Dokumentation zu lesen-hoffentlich hat diese Einführung Ihnen genügend Grundkenntnisse vermitteln können, damit Sie dies tun können.</p></div><div class=paragraph><p>Die Version von make, die in FreeBSD enthalten ist, ist Berkeley make; es gibt eine Anleitung dazu in <span class=filename>/usr/shared/doc/psd/12.make</span>. Um sich diese anzusehen, müssen Sie</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% zmore paper.ascii.gz</code></pre></div></div><div class=paragraph><p>in diesem Verzeichnis ausführen.</p></div><div class=paragraph><p>Viele Anwendungen in den Ports verwenden GNU make, welches einen sehr guten Satz an "info"-Seiten mitbringt. Falls Sie irgendeinen dieser Ports installiert haben wurde GNU make automatisch als <code>gmake</code> mit installiert. Es ist auch als eigenständiger Port und Paket verfügbar.</p></div><div class=paragraph><p>Um sich die Info-Seiten für GNU make anzusehen müssen Sie die Datei <span class=filename>dir</span> in <span class=filename>/usr/local/info</span> um einen entsprechenden Eintrag erweitern. Dies beinhaltet das Einfügen einer Zeile wie</p></div><div class="literalblock programlisting"><div class=content><pre> * Make: (make).                 The GNU Make utility.</pre></div></div><div class=paragraph><p>in die Datei. Nachdem Sie dies getan haben können Sie <code>info</code> eingeben und dann den Menüeintrag <span class=guimenuitem>make</span> auswählen (oder Sie können in Emacs die Tastenkombination <code>C-h i</code> verwenden).</p></div></div></div><div class=sect2><h3 id=debugging>2.6. Debuggen<a class=anchor href=#debugging></a></h3><div class=sect3><h4 id=_der_debugger>2.6.1. Der Debugger<a class=anchor href=#_der_debugger></a></h4><div class=paragraph><p>Der Debugger bei FreeBSD heißt <code>gdb</code> (GNU debugger). Sie können Ihn durch die Eingabe von</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gdb progname</code></pre></div></div><div class=paragraph><p>starten, wobei viele Leute ihn vorzugsweise innerhalb von Emacs aufrufen. Sie erreichen dies durch die Eingabe von:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> M-x gdb RET progname RET</code></pre></div></div><div class=paragraph><p>Die Verwendung eines Debuggers erlaubt Ihnen Ihr Programm unter kontrollierteren Bedingungen ausführen zu können. Typischerweise können Sie so Zeile für Zeile durch Ihr Programm gehen, die Werte von Variablen untersuchen, diese verändern, dem Debugger sagen er soll das Programm bis zu einem bestimmten Punkt ausführen und dann anhalten, und so weiter und so fort. Sie können damit sogar ein schon laufendes Programm untersuchen, oder eine Datei mit einem Kernspeicherabbild laden um herauszufinden, warum das Programm abgestürzt ist. Es ist sogar möglich damit den Kernel zu debuggen, wobei dies etwas trickreicher als bei den Benutzeranwendungen ist, welche wir in diesem Abschnitt behandeln werden.</p></div><div class=paragraph><p>Der <code>gdb</code> besitzt eine recht gute Online-Hilfe, sowie einen Satz von Info-Seiten, weshalb sich dieser Abschnitt auf ein paar grundlegende Befehle beschränken wird.</p></div><div class=paragraph><p>Falls Sie den textbasierten Kommandozeilen-Stil abstoßend finden gibt es ein graphisches Front-End dafür (<a class=package href=https://cgit.freebsd.org/ports/tree/devel/xxgdb/>devel/xxgdb</a>) in der Ports-Sammlung.</p></div><div class=paragraph><p>Dieser Abschnitt ist als Einführung in die Verwendung des <code>gdb</code> gedacht und beinhaltet nicht spezielle Themen wie das Debuggen des Kernels.</p></div></div><div class=sect3><h4 id=_ein_programm_im_debugger_ausführen>2.6.2. Ein Programm im Debugger ausführen<a class=anchor href=#_ein_programm_im_debugger_ausführen></a></h4><div class=paragraph><p>Sie müssen das Programm mit der Option <code>-g</code> kompiliert haben um den <code>gdb</code> effektiv einsetzen zu können. Es geht auch ohne diese Option, allerdings werden Sie dann nur den Namen der Funktion sehen, in der Sie sich gerade befinden, anstatt direkt den zugehörigen Quelltext. Falls Sie eine Meldung wie die folgende sehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>… <span class=o>(</span>no debugging symbols found<span class=o>)</span> …</code></pre></div></div><div class=paragraph><p>wenn der <code>gdb</code> gestartet wird, dann wissen Sie, daß das Programm nicht mit der Option <code>-g</code> kompiliert wurde.</p></div><div class=paragraph><p>Geben Sie in der Eingabeaufforderung des <code>gdb break main</code> ein. Dies weist den Debugger an, dass Sie nicht daran interessiert sind, den einleitenden Schritten beim Programmstart zuzusehen und dass am Anfang Ihres Codes die Ausführung beginnen soll. Geben Sie nun <code>run</code> ein, um das Programm zu starten - es wird starten und beim Aufruf von <code>main()</code> vom Debugger angehalten werden. (Falls Sie sich jemals gewundert haben von welcher Stelle <code>main()</code> aufgerufen wird, dann wissen Sie es jetzt!).</p></div><div class=paragraph><p>Sie können nun Schritt für Schritt durch Ihr Programm gehen, indem Sie <code>n</code> drücken. Wenn Sie zu einem Funktionsaufruf kommen können Sie diese Funktion durch drücken von <code>s</code> betreten. Sobald Sie sich in einem Funktionsaufruf befinden können Sie diesen durch drücken von <code>f</code> wieder verlassen. Sie können auch <code>up</code> und <code>down</code> verwenden, um sich schnell den Aufrufer einer Funktion anzusehen.</p></div><div class=paragraph><p>Hier ist ein einfaches Beispiel, wie man mit Hilfe des <code>gdb</code> einen Fehler in einem Programm findet. Dies ist unser eigenes Programm (mit einem absichtlich eingebauten Fehler):</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;stdio.h&gt;

int bazz(int anint);

main() {
	int i;

	printf(&#34;This is my program\n&#34;);
	bazz(i);
	return 0;
}

int bazz(int anint) {
	printf(&#34;You gave me %d\n&#34;, anint);
	return anint;
}</pre></div></div><div class=paragraph><p>Dieses Programm setzt i auf den Wert <code>5</code> und übergibt dies einer Funktion <code>bazz()</code>, welche den Wert ausgibt, den Sie von uns erhalten hat.</p></div><div class=paragraph><p>Wenn wir das Programm kompilieren und ausführen erhalten wir</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-g</span> <span class=nt>-o</span> temp temp.c
% ./temp
This is my program
anint <span class=o>=</span> 4231</code></pre></div></div><div class=paragraph><p>Das ist nicht was wir erwartet hatten! Es ist Zeit, daß wir sehen was hier passiert!</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gdb temp
GDB is free software and you are welcome to distribute copies of it
 under certain conditions<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show copying&#34;</span> to see the conditions.
There is absolutely no warranty <span class=k>for </span>GDB<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
GDB 4.13 <span class=o>(</span>i386-unknown-freebsd<span class=o>)</span>, Copyright 1994 Free Software Foundation, Inc.
<span class=o>(</span>gdb<span class=o>)</span> <span class=nb>break </span>main				Skip the set-up code
Breakpoint 1 at 0x160f: file temp.c, line 9.	gdb puts breakpoint at main<span class=o>()</span>
<span class=o>(</span>gdb<span class=o>)</span> run					Run as far as main<span class=o>()</span>
Starting program: /home/james/tmp/temp		Program starts running

Breakpoint 1, main <span class=o>()</span> at temp.c:9		gdb stops at main<span class=o>()</span>
<span class=o>(</span>gdb<span class=o>)</span> n						Go to next line
This is my program				Program prints out
<span class=o>(</span>gdb<span class=o>)</span> s						step into bazz<span class=o>()</span>
bazz <span class=o>(</span><span class=nv>anint</span><span class=o>=</span>4231<span class=o>)</span> at temp.c:17			gdb displays stack frame
<span class=o>(</span>gdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Halt mal! Wieso hat denn anint den Wert <code>4231</code>? Haben wir dieser Variablen nicht in <code>main()</code> den Wert <code>5</code> zugewiesen? Gehen wir mal zurück zu <code>main()</code> und schauen dort nach.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> up					Move up call stack
<span class=c>#1  0x1625 in main () at temp.c:11		gdb displays stack frame</span>
<span class=o>(</span>gdb<span class=o>)</span> p i					Show us the value of i
<span class=nv>$1</span> <span class=o>=</span> 4231					gdb displays 4231</code></pre></div></div><div class=paragraph><p>Oh! Anscheinend haben wir vergessen i zu initialisieren. Wir wollten eigentlich</p></div><div class="literalblock programlisting"><div class=content><pre>...
main() {
	int i;

	i = 5;
	printf(&#34;This is my program\n&#34;);
...</pre></div></div><div class=paragraph><p>schreiben, haben aber die Zeile mit <code>i=5;</code> vergessen. Da wir i nicht initialisiert haben hatte diese Variable gerade den Wert, der in dem ihr zugewiesenen Speicherbereich stand als wir das Programm gestartet haben, welcher in diesem Fall <code>4231</code> war.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Der <code>gdb</code> zeigt jedes mal, wenn wir eine Funktion betreten oder verlassen, den Inhalt des Stack-Rahmens an, selbst wenn wir uns mit <code>up</code> und <code>down</code> im Aufruf-Stack umher bewegen. Dabei wird der Name der Funktion sowie der übergebenen Argumente angezeigt, was uns dabei hilft, die Übersicht zu behalten. (Der Stack ist ein Speicherbereich, in dem ein Programm Informationen über die an eine Funktion übergebenen Argumente ablegt, sowie die Rücksprungadresse eines Funktionsaufrufes).</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_eine_kernspeicherdatei_untersuchen>2.6.3. Eine Kernspeicherdatei untersuchen<a class=anchor href=#_eine_kernspeicherdatei_untersuchen></a></h4><div class=paragraph><p>Eine Kernspeicherdatei ist im Prinzip eine Datei, die den vollständigen Zustand eines Prozesses enthält, als dieses abgestürzt ist. In "den guten alten Zeiten" mußten Programmierer hexadezimale Listen der Kernspeicherdatei ausdrucken und über Maschinencodehandbüchern schwitzen, aber heutzutage ist das Leben etwas einfacher geworden. Zufälligerweise wird die Kernspeicherdatei unter FreeBSD und anderen 4.4BSD-Systemen <span class=filename>progname.core</span> anstatt einfach nur <span class=filename>core</span> genannt, um deutlich zu machen, zu welchem Programm eine Kernspeicherdatei gehört.</p></div><div class=paragraph><p>Um eine Kernspeicherdatei zu untersuchen müssen Sie den <code>gdb</code> wie gewohnt starten. An Stelle von <code>break</code> oder <code>run</code> müssen Sie das Folgende eingeben</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> core progname.core</code></pre></div></div><div class=paragraph><p>Wenn Sie sich nicht in demselben Verzeichnis befinden wie die Kernspeicherdatei müssen Sie zuerst <code>dir /path/to/core/file</code> eingeben.</p></div><div class=paragraph><p>Sie sollten dann etwas wie folgt sehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gdb a.out
GDB is free software and you are welcome to distribute copies of it
 under certain conditions<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show copying&#34;</span> to see the conditions.
There is absolutely no warranty <span class=k>for </span>GDB<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
GDB 4.13 <span class=o>(</span>i386-unknown-freebsd<span class=o>)</span>, Copyright 1994 Free Software Foundation, Inc.
<span class=o>(</span>gdb<span class=o>)</span> core a.out.core
Core was generated by <span class=sb>`</span>a.out<span class=s1>&#39;.
Program terminated with signal 11, Segmentation fault.
Cannot access memory at address 0x7020796d.
#0  0x164a in bazz (anint=0x5) at temp.c:17
(gdb)</span></code></pre></div></div><div class=paragraph><p>In diesem Fall hieß das Programm <span class=filename>a.out</span>, weshalb die Kernspeicherdatei den Namen <span class=filename>a.out.core</span> trägt. Wie wir sehen können stürzte das Programm in einer Funktion namens <code>bazz</code> ab, als es versuchte auf einen Speicherbereich zuzugreifen, der dem Programm nicht zur Verfügung stand.</p></div><div class=paragraph><p>Manchmal ist es ganz nützlich zu sehen, wie eine Funktion aufgerufen wurde, da bei komplexen Programmen das eigentliche Problem schon sehr viel weiter oben auf dem Aufruf-Stack aufgetreten sein könnte. Der Befehl <code>bt</code> veranlaßt den <code>gdb</code> dazu, einen Backtrace des Aufruf-Stacks auszugeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> bt
<span class=c>#0  0x164a in bazz (anint=0x5) at temp.c:17</span>
<span class=c>#1  0xefbfd888 in end ()</span>
<span class=c>#2  0x162c in main () at temp.c:11</span>
<span class=o>(</span>gdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Die Funktion <code>end()</code> wird aufgerufen, wenn ein Programm abstürzt; in diesem Fall wurde die Funktion <code>bazz()</code> aus der <code>main()</code>-Funktion heraus aufgerufen.</p></div></div><div class=sect3><h4 id=_ein_bereits_laufendes_programm_untersuchen>2.6.4. Ein bereits laufendes Programm untersuchen<a class=anchor href=#_ein_bereits_laufendes_programm_untersuchen></a></h4><div class=paragraph><p>Eine der tollsten Features des <code>gdb</code> ist die Möglichkeit, damit bereits laufende Programme zu untersuchen. Dies bedeutet natürlich, daß Sie die erforderlichen Rechte dafür besitzen. Ein häufig auftretendes Problem ist das Untersuchen eines Programmes, welches sich selber forkt. Vielleicht will man den Kindprozess untersuchen, aber der Debugger erlaubt einem nur den Zugriff auf den Elternprozess.</p></div><div class=paragraph><p>Was Sie an solch einer Stelle machen ist, Sie starten einen weiteren <code>gdb</code>, ermitteln mit Hilfe von <code>ps</code> die Prozess-ID des Kindprozesses, und geben</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> attach pid</code></pre></div></div><div class=paragraph><p>im <code>gdb</code> ein, und können dann wie üblich mit der Fehlersuche fortfahren.</p></div><div class=paragraph><p>"Das ist zwar alles sehr schön," werden Sie jetzt vielleicht denken, "aber in der Zeit, in der ich diese Schritte durchführe, ist der Kindprozess schon längst über alle Berge". Fürchtet euch nicht, edler Leser, denn Ihr müßt wie folgt vorgehen (freundlicherweise zur Verfügung gestellt von den Info-Seite des <code>gdb</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>…
<span class=k>if</span> <span class=o>((</span>pid <span class=o>=</span> fork<span class=o>())</span> &lt; 0<span class=o>)</span>		/<span class=k>*</span> _Always_ check this <span class=k>*</span>/
	error<span class=o>()</span><span class=p>;</span>
<span class=k>else if</span> <span class=o>(</span>pid <span class=o>==</span> 0<span class=o>)</span> <span class=o>{</span>		/<span class=k>*</span> child <span class=k>*</span>/
	int PauseMode <span class=o>=</span> 1<span class=p>;</span>

	<span class=k>while</span> <span class=o>(</span>PauseMode<span class=o>)</span>
		<span class=nb>sleep</span><span class=o>(</span>10<span class=o>)</span><span class=p>;</span>	/<span class=k>*</span> Wait <span class=k>until </span>someone attaches to us <span class=k>*</span>/
	…
<span class=o>}</span> <span class=k>else</span> <span class=o>{</span>			/<span class=k>*</span> parent <span class=k>*</span>/
	…</code></pre></div></div><div class=paragraph><p>Alles was Sie jetzt noch tun müssen ist, sich an den Kindprozess ranzuhängen, PauseMode auf <code>0</code> zu setzen und auf den <code>sleep()</code> Funktionsaufruf zu warten, um zurückzukehren!</p></div></div></div><div class=sect2><h3 id=emacs>2.7. Emacs als Entwicklungsumgebung verwenden<a class=anchor href=#emacs></a></h3><div class=sect3><h4 id=_emacs>2.7.1. Emacs<a class=anchor href=#_emacs></a></h4><div class=paragraph><p>Leider werden UNIX®-Systeme nicht mit einem alles-was-du-jemals-brauchst-und-vieles-mehr-megapaket an integrierten Entwicklungsumgebungen ausgestattet, die bei anderen Systemen dabei sind. Trotzdem ist es möglich, seine eigene Entwicklungsumgebung aufzusetzen. Diese wird vielleicht nicht so hübsch und integriert sein, aber dafür können Sie sie Ihren eigenen Wünschen anpassen. Und sie ist frei. Und Sie haben die Quelltexte davon.</p></div><div class=paragraph><p>Der Schlüssel zu all dem ist Emacs. Es gibt zwar ein paar Leute die ihn hassen, es gibt jedoch auch viele die ihn lieben. Falls Sie zu ersteren gehören befürchte ich, daß dieser Abschnitt Ihnen wenig interessantes zu bieten hat. Des weiteren benötigen Sie eine angemessene Menge an freiem Speicher, um ihn zu benutzen-ich würde 8MB für den Textmodus und 16MB unter X als absolutes Minimum empfehlen, um eine halbwegs brauchbare Performance zu erhalten.</p></div><div class=paragraph><p>Emacs ist im Prinzip ein extrem anpassbarer Editor- in der Tat ist er so stark veränderbar, daß er eher einem Betriebssystem als einem Editor gleicht! Viele Entwickler und Systemadministratoren erledigen praktisch ihre gesamte Arbeit aus Emacs heraus und beenden ihn nur, um sich komplett auszuloggen.</p></div><div class=paragraph><p>Es ist nicht einmal möglich alles hier zusammenzufassen, was man mit dem Emacs machen kann. Im Folgenden werden einige Features aufgelistet, die für einen Entwickler interessant sein könnten:</p></div><div class=ulist><ul><li><p>Sehr mächtiger Editor, der suchen-und-ersetzen mit Zeichenfolgen und regulären Ausdrücken (Pattern) sowie das direkte Anspringen von Anfang/Ende von Blockausdrücken erlaubt, etc, etc.</p></li><li><p>Pull-Down Menüs und eine Online-Hilfe.</p></li><li><p>Sprachunabhängige Syntaxhervorhebung und automatische Einrückung.</p></li><li><p>Vollständig konfigurierbar.</p></li><li><p>Sie können Programme im Emacs kompilieren und debuggen.</p></li><li><p>Bei Kompilationsfehlern können Sie direkt zu der entsprechenden Zeile im Quelltext springen.</p></li><li><p>Benutzerfreundliches Front-End für das <code>info</code>-Programm, um die GNU Hypertext Dokumentation inklusive der Dokumentation des Emacs selber.</p></li><li><p>Benutzerfreundliches Front-End für den <code>gdb</code> um sich beim Verfolgen der Programmanweisungen den zugehörigen Quelltext anzeigen zu lassen.</p></li><li><p>Sie können E-Mails und News im Usenet lesen, während ihr Programm kompiliert wird.</p></li></ul></div><div class=paragraph><p>Und zweifelsfrei viele weitere Punkte, die ich übersehen habe.</p></div><div class=paragraph><p>Emacs kann unter FreeBSD über den <a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> Port installiert werden.</p></div><div class=paragraph><p>Sobald er installiert ist starten Sie ihn, und geben dann <code>C-h t</code> ein, um die Einführung in Emacs zu lesen-d.h. Sie sollen bei gedrückter <kbd>Strg</kbd>-Taste die <kbd>h</kbd>-Taste drücken, beide wieder loslassen und anschließend <kbd>t</kbd> drücken. (Alternativ können Sie mit der Maus den Eintrag <span class=guimenuitem>Emacs Tutorial</span> aus dem <b class=menuref>Hilfe</b>-Menü auswählen).</p></div><div class=paragraph><p>Obwohl der Emacs Menüs besitzt ist das Erlernen der Tastaturkombinationen lohnenswert, da man beim Editieren sehr viel schneller Tastenkombinationen eingeben kann, als die Maus zu finden und mit dieser dann an der richtigen Stelle zu klicken. Und wenn Sie sich mit erfahrenen Emacs-Benutzern unterhalten werden Sie feststellen, daß diese häufig nebenbei Ausdrücke wie “M-x replace-s RET foo RET bar RET” verwenden, weshalb das Erlernen dieser sehr nützlich ist. Und Emacs hat auf jeden Fall weit mehr nützliche Funktionen als das diese in der Menüleiste unterzubringen wären.</p></div><div class=paragraph><p>Zum Glück ist es sehr einfach die jeweiligen Tastaturkombinationen herauszubekommen, da diese direkt neben den Menüeinträgen stehen. Meine Empfehlung wäre, den Menüeintrag für, sagen wir, das Öffnen einer Datei zu verwenden, bis Sie die Funktionsweise verstanden haben und sie mit dieser vertraut sind, und es dann mit C-x C-f versuchen. Wenn Sie damit zufrieden sind, gehen Sie zum nächsten Menüeintrag.</p></div><div class=paragraph><p>Falls Sie sich nicht daran erinnern können, was eine bestimmte Tastenkombination macht, wählen Sie <span class=guimenuitem>Describe Key</span> aus dem <b class=menuref>Hilfe</b>-Menü aus und geben Sie die Tastenkombination ein-Emacs sagt Ihnen dann was diese macht. Sie können ebenfalls den Menüeintrag <span class=guimenuitem>Command Apropos</span> verwenden, um alle Befehle, die ein bestimmtes Wort enthalten, mit den zugehörigen Tastenkombinationen aufgelistet zu bekommen.</p></div><div class=paragraph><p>Übrigends bedeutet der Ausdruck weiter oben, bei gedrückter <kbd>Meta</kbd>-Taste <kbd>x</kbd> zu drücken, beide wieder loszulassen, <code>replace-s</code> einzugeben (Kurzversion für <code>replace-string</code>-ein weiteres Feature des Emacs ist, daß Sie Befehle abkürzen können), anschließend die <kbd>return</kbd>-Taste zu drücken, dann <code>foo</code> einzugeben (die Zeichenkette, die Sie ersetzen möchten), dann wieder <kbd>return</kbd>, dann die Leertaste zu drücken (die Zeichenkette, mit der Sie <code>foo</code> ersetzen möchten) und anschließend erneut <kbd>return</kbd> zu drücken. Emacs wird dann die gewünschte suchen-und-ersetzen-Operation ausführen.</p></div><div class=paragraph><p>Wenn Sie sich fragen was in aller Welt die <kbd>Meta</kbd>-Taste ist, das ist eine spezielle Taste die viele UNIX®-Workstations besitzen. Bedauerlicherweise haben PCs keine solche Taste, und daher ist es üblicherweise die <kbd>alt</kbd>-Taste (oder falls Sie Pech haben die <kbd>Esc</kbd>-Taste).</p></div><div class=paragraph><p>Oh, und um den Emacs zu verlassen müssen sie <code>C-x C-c</code> (das bedeutet, Sie müssen bei gedrückter <kbd>Strg</kbd>-Taste zuerst <kbd>x</kbd> und dann <kbd>c</kbd> drücken) eingeben. Falls Sie noch irgendwelche ungespeicherten Dateien offen haben wird Emacs Sie fragen ob Sie diese speichern wollen. (Ignorieren Sie bitte die Stelle der Dokumentation, an der gesagt wird, daß <code>C-z</code> der übliche Weg ist, Emacs zu verlassen-dadurch wird der Emacs in den Hintergrund geschaltet, was nur nützlich ist, wenn Sie an einem System ohne virtuelle Terminals arbeiten).</p></div></div><div class=sect3><h4 id=_emacs_konfigurieren>2.7.2. Emacs konfigurieren<a class=anchor href=#_emacs_konfigurieren></a></h4><div class=paragraph><p>Emacs kann viele wundervolle Dinge; manche dieser Dinge sind schon eingebaut, andere müssen erst konfiguriert werden.</p></div><div class=paragraph><p>Anstelle einer proprietären Macrosprache verwendet der Emacs für die Konfiguration eine speziell für Editoren angepaßte Version von Lisp, auch bekannt als Emacs Lisp. Das Arbeiten mit Emacs Lisp kann sehr hilfreich sein, wenn Sie darauf aufbauend etwas wie Common Lisp lernen möchten. Emacs Lisp hat viele Features von Common Lisp obwohl es beträchtlich kleiner ist (und daher auch einfacher zu beherrschen).</p></div><div class=paragraph><p>Der beste Weg um Emacs Lisp zu erlernen besteht darin, sich das <a href=ftp://ftp.gnu.org/old-gnu/emacs/elisp-manual-19-2.4.tar.gz>Emacs Tutorial</a> herunterzuladen.</p></div><div class=paragraph><p>Es ist jedoch keine Kenntnis von Lisp erforderlich, um mit der Konfiguration von Emacs zu beginnen, da ich eine beispielhafte <span class=filename>.emacs</span>-Datei hier eingefügt habe, die für den Anfang ausreichen sollte. Kopieren Sie diese einfach in Ihr Heimverzeichnis und starten Sie den Emacs neu, falls dieser bereits läuft; er wird die Befehle aus der Datei lesen und Ihnen (hoffentlich) eine brauchbare Grundeinstellung bieten.</p></div></div><div class=sect3><h4 id=_eine_beispielhafte_emacs_datei>2.7.3. Eine beispielhafte <span class=filename>.emacs</span>-Datei<a class=anchor href=#_eine_beispielhafte_emacs_datei></a></h4><div class=paragraph><p>Bedauerlicherweise gibt es hier viel zu viel, um es im Detail zu erklären; es gibt jedoch ein oder zwei Punkte, die besonders erwähnenswert sind.</p></div><div class=ulist><ul><li><p>Alles was mit einem <code>;</code> anfängt ist ein Kommentar und wird von Emacs ignoriert.</p></li><li><p>In der ersten Zeile mit <code>-<strong>- Emacs-Lisp -</strong>-</code> sorgt dafür, daß wir die Datei <span class=filename>.emacs</span> in Emacs selber editieren können und uns damit alle tollen Features zum Editieren von Emacs Lisp zur Verfügung stehen. Emacs versucht dies normalerweise anhand des Dateinamens auszumachen, was vielleicht bei <span class=filename>.emacs</span> nicht funktionieren könnte.</p></li><li><p>Die <kbd>Tab</kbd>-Taste ist in manchen Modi an die Einrückungsfunktion gebunden, so daß beim drücken dieser Taste die aktuelle Zeile eingerückt wird. Wenn Sie ein tab-Zeichen in einen Text, welchen auch immer Sie dabei schreiben, einfügen wollen, müssen Sie bei gedrückter <kbd>Strg</kbd>-Taste die <kbd>Tab</kbd>-Taste drücken.</p></li><li><p>Diese Datei unterstützt Syntax Highlighting für C, C++, Perl, Lisp und Scheme, indem die Sprache anhand des Dateinamens erraten wird.</p></li><li><p>Emacs hat bereits eine vordefinierte Funktion mit dem Namen <code>next-error</code>. Diese erlaubt es einem, in einem Fenster mit der Kompilierungsausgabe mittels <code>M-n</code> von einem zum nächsten Kompilierungsfehler zu springen; wir definieren eine komplementäre Funktion <code>previous-error</code>, die es uns erlaubt, mittels <code>M-p</code> von einem zum vorherigen Kompilierungsfehler zu springen. Das schönste Feature von allen ist, daß mittels <code>C-c C-c</code> die Quelltextdatei, in der der Fehler aufgetreten ist, geöffnet und die betreffende Zeile direkt angesprungen wird.</p></li><li><p>Wir aktivieren die Möglichkeit von Emacs als Server zu agieren, so daß wenn Sie etwas außerhalb von Emacs machen und eine Datei editieren möchten, Sie einfach das folgende eingeben können</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% emacsclient filename</code></pre></div></div><div class=paragraph><p>und dann die Datei in Ihrem Emacs editieren können!</p></div></li></ul></div><div class=exampleblock><div class=title>Beispiel 1. Eine einfache <span class=filename>.emacs</span>-Datei</div><div class=content><div class="literalblock programlisting"><div class=content><pre>;; -*-Emacs-Lisp-*-

;; This file is designed to be re-evaled; use the variable first-time
;; to avoid any problems with this.
(defvar first-time t
  &#34;Flag signifying this is the first time that .emacs has been evaled&#34;)

;; Meta
(global-set-key &#34;\M- &#34; &#39;set-mark-command)
(global-set-key &#34;\M-\C-h&#34; &#39;backward-kill-word)
(global-set-key &#34;\M-\C-r&#34; &#39;query-replace)
(global-set-key &#34;\M-r&#34; &#39;replace-string)
(global-set-key &#34;\M-g&#34; &#39;goto-line)
(global-set-key &#34;\M-h&#34; &#39;help-command)

;; Function keys
(global-set-key [f1] &#39;manual-entry)
(global-set-key [f2] &#39;info)
(global-set-key [f3] &#39;repeat-complex-command)
(global-set-key [f4] &#39;advertised-undo)
(global-set-key [f5] &#39;eval-current-buffer)
(global-set-key [f6] &#39;buffer-menu)
(global-set-key [f7] &#39;other-window)
(global-set-key [f8] &#39;find-file)
(global-set-key [f9] &#39;save-buffer)
(global-set-key [f10] &#39;next-error)
(global-set-key [f11] &#39;compile)
(global-set-key [f12] &#39;grep)
(global-set-key [C-f1] &#39;compile)
(global-set-key [C-f2] &#39;grep)
(global-set-key [C-f3] &#39;next-error)
(global-set-key [C-f4] &#39;previous-error)
(global-set-key [C-f5] &#39;display-faces)
(global-set-key [C-f8] &#39;dired)
(global-set-key [C-f10] &#39;kill-compilation)

;; Keypad bindings
(global-set-key [up] &#34;\C-p&#34;)
(global-set-key [down] &#34;\C-n&#34;)
(global-set-key [left] &#34;\C-b&#34;)
(global-set-key [right] &#34;\C-f&#34;)
(global-set-key [home] &#34;\C-a&#34;)
(global-set-key [end] &#34;\C-e&#34;)
(global-set-key [prior] &#34;\M-v&#34;)
(global-set-key [next] &#34;\C-v&#34;)
(global-set-key [C-up] &#34;\M-\C-b&#34;)
(global-set-key [C-down] &#34;\M-\C-f&#34;)
(global-set-key [C-left] &#34;\M-b&#34;)
(global-set-key [C-right] &#34;\M-f&#34;)
(global-set-key [C-home] &#34;\M-&lt;&#34;)
(global-set-key [C-end] &#34;\M-&gt;&#34;)
(global-set-key [C-prior] &#34;\M-&lt;&#34;)
(global-set-key [C-next] &#34;\M-&gt;&#34;)

;; Mouse
(global-set-key [mouse-3] &#39;imenu)

;; Misc
(global-set-key [C-tab] &#34;\C-q\t&#34;)	; Control tab quotes a tab.
(setq backup-by-copying-when-mismatch t)

;; Treat &#39;y&#39; or &lt;CR&gt; as yes, &#39;n&#39; as no.
(fset &#39;yes-or-no-p &#39;y-or-n-p)
(define-key query-replace-map [return] &#39;act)
(define-key query-replace-map [?\C-m] &#39;act)

;; Load packages
(require &#39;desktop)
(require &#39;tar-mode)

;; Pretty diff mode
(autoload &#39;ediff-buffers &#34;ediff&#34; &#34;Intelligent Emacs interface to diff&#34; t)
(autoload &#39;ediff-files &#34;ediff&#34; &#34;Intelligent Emacs interface to diff&#34; t)
(autoload &#39;ediff-files-remote &#34;ediff&#34;
  &#34;Intelligent Emacs interface to diff&#34;)

(if first-time
    (setq auto-mode-alist
	  (append &#39;((&#34;\\.cpp$&#34; . c++-mode)
		    (&#34;\\.hpp$&#34; . c++-mode)
		    (&#34;\\.lsp$&#34; . lisp-mode)
		    (&#34;\\.scm$&#34; . scheme-mode)
		    (&#34;\\.pl$&#34; . perl-mode)
		    ) auto-mode-alist)))

;; Auto font lock mode
(defvar font-lock-auto-mode-list
  (list &#39;c-mode &#39;c++-mode &#39;c++-c-mode &#39;emacs-lisp-mode &#39;lisp-mode &#39;perl-mode &#39;scheme-mode)
  &#34;List of modes to always start in font-lock-mode&#34;)

(defvar font-lock-mode-keyword-alist
  &#39;((c++-c-mode . c-font-lock-keywords)
    (perl-mode . perl-font-lock-keywords))
  &#34;Associations between modes and keywords&#34;)

(defun font-lock-auto-mode-select ()
  &#34;Automatically select font-lock-mode if the current major mode is in font-lock-auto-mode-list&#34;
  (if (memq major-mode font-lock-auto-mode-list)
      (progn
	(font-lock-mode t))
    )
  )

(global-set-key [M-f1] &#39;font-lock-fontify-buffer)

;; New dabbrev stuff
;(require &#39;new-dabbrev)
(setq dabbrev-always-check-other-buffers t)
(setq dabbrev-abbrev-char-regexp &#34;\\sw\\|\\s_&#34;)
(add-hook &#39;emacs-lisp-mode-hook
	  &#39;(lambda ()
	     (set (make-local-variable &#39;dabbrev-case-fold-search) nil)
	     (set (make-local-variable &#39;dabbrev-case-replace) nil)))
(add-hook &#39;c-mode-hook
	  &#39;(lambda ()
	     (set (make-local-variable &#39;dabbrev-case-fold-search) nil)
	     (set (make-local-variable &#39;dabbrev-case-replace) nil)))
(add-hook &#39;text-mode-hook
	  &#39;(lambda ()
	     (set (make-local-variable &#39;dabbrev-case-fold-search) t)
	     (set (make-local-variable &#39;dabbrev-case-replace) t)))

;; C++ and C mode...
(defun my-c++-mode-hook ()
  (setq tab-width 4)
  (define-key c++-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (define-key c++-mode-map &#34;\C-ce&#34; &#39;c-comment-edit)
  (setq c++-auto-hungry-initial-state &#39;none)
  (setq c++-delete-function &#39;backward-delete-char)
  (setq c++-tab-always-indent t)
  (setq c-indent-level 4)
  (setq c-continued-statement-offset 4)
  (setq c++-empty-arglist-indent 4))

(defun my-c-mode-hook ()
  (setq tab-width 4)
  (define-key c-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (define-key c-mode-map &#34;\C-ce&#34; &#39;c-comment-edit)
  (setq c-auto-hungry-initial-state &#39;none)
  (setq c-delete-function &#39;backward-delete-char)
  (setq c-tab-always-indent t)
;; BSD-ish indentation style
  (setq c-indent-level 4)
  (setq c-continued-statement-offset 4)
  (setq c-brace-offset -4)
  (setq c-argdecl-indent 0)
  (setq c-label-offset -4))

;; Perl mode
(defun my-perl-mode-hook ()
  (setq tab-width 4)
  (define-key c++-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (setq perl-indent-level 4)
  (setq perl-continued-statement-offset 4))

;; Scheme mode...
(defun my-scheme-mode-hook ()
  (define-key scheme-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent))

;; Emacs-Lisp mode...
(defun my-lisp-mode-hook ()
  (define-key lisp-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (define-key lisp-mode-map &#34;\C-i&#34; &#39;lisp-indent-line)
  (define-key lisp-mode-map &#34;\C-j&#34; &#39;eval-print-last-sexp))

;; Add all of the hooks...
(add-hook &#39;c++-mode-hook &#39;my-c++-mode-hook)
(add-hook &#39;c-mode-hook &#39;my-c-mode-hook)
(add-hook &#39;scheme-mode-hook &#39;my-scheme-mode-hook)
(add-hook &#39;emacs-lisp-mode-hook &#39;my-lisp-mode-hook)
(add-hook &#39;lisp-mode-hook &#39;my-lisp-mode-hook)
(add-hook &#39;perl-mode-hook &#39;my-perl-mode-hook)

;; Complement to next-error
(defun previous-error (n)
  &#34;Visit previous compilation error message and corresponding source code.&#34;
  (interactive &#34;p&#34;)
  (next-error (- n)))

;; Misc...
(transient-mark-mode 1)
(setq mark-even-if-inactive t)
(setq visible-bell nil)
(setq next-line-add-newlines nil)
(setq compile-command &#34;make&#34;)
(setq suggest-key-bindings nil)
(put &#39;eval-expression &#39;disabled nil)
(put &#39;narrow-to-region &#39;disabled nil)
(put &#39;set-goal-column &#39;disabled nil)
(if (&gt;= emacs-major-version 21)
	(setq show-trailing-whitespace t))

;; Elisp archive searching
(autoload &#39;format-lisp-code-directory &#34;lispdir&#34; nil t)
(autoload &#39;lisp-dir-apropos &#34;lispdir&#34; nil t)
(autoload &#39;lisp-dir-retrieve &#34;lispdir&#34; nil t)
(autoload &#39;lisp-dir-verify &#34;lispdir&#34; nil t)

;; Font lock mode
(defun my-make-face (face color &amp;optional bold)
  &#34;Create a face from a color and optionally make it bold&#34;
  (make-face face)
  (copy-face &#39;default face)
  (set-face-foreground face color)
  (if bold (make-face-bold face))
  )

(if (eq window-system &#39;x)
    (progn
      (my-make-face &#39;blue &#34;blue&#34;)
      (my-make-face &#39;red &#34;red&#34;)
      (my-make-face &#39;green &#34;dark green&#34;)
      (setq font-lock-comment-face &#39;blue)
      (setq font-lock-string-face &#39;bold)
      (setq font-lock-type-face &#39;bold)
      (setq font-lock-keyword-face &#39;bold)
      (setq font-lock-function-name-face &#39;red)
      (setq font-lock-doc-string-face &#39;green)
      (add-hook &#39;find-file-hooks &#39;font-lock-auto-mode-select)

      (setq baud-rate 1000000)
      (global-set-key &#34;\C-cmm&#34; &#39;menu-bar-mode)
      (global-set-key &#34;\C-cms&#34; &#39;scroll-bar-mode)
      (global-set-key [backspace] &#39;backward-delete-char)
					;      (global-set-key [delete] &#39;delete-char)
      (standard-display-european t)
      (load-library &#34;iso-transl&#34;)))

;; X11 or PC using direct screen writes
(if window-system
    (progn
      ;;      (global-set-key [M-f1] &#39;hilit-repaint-command)
      ;;      (global-set-key [M-f2] [?\C-u M-f1])
      (setq hilit-mode-enable-list
	    &#39;(not text-mode c-mode c++-mode emacs-lisp-mode lisp-mode
		  scheme-mode)
	    hilit-auto-highlight nil
	    hilit-auto-rehighlight &#39;visible
	    hilit-inhibit-hooks nil
	    hilit-inhibit-rebinding t)
      (require &#39;hilit19)
      (require &#39;paren))
  (setq baud-rate 2400)			; For slow serial connections
  )

;; TTY type terminal
(if (and (not window-system)
	 (not (equal system-type &#39;ms-dos)))
    (progn
      (if first-time
	  (progn
	    (keyboard-translate ?\C-h ?\C-?)
	    (keyboard-translate ?\C-? ?\C-h)))))

;; Under UNIX
(if (not (equal system-type &#39;ms-dos))
    (progn
      (if first-time
	  (server-start))))

;; Add any face changes here
(add-hook &#39;term-setup-hook &#39;my-term-setup-hook)
(defun my-term-setup-hook ()
  (if (eq window-system &#39;pc)
      (progn
;;	(set-face-background &#39;default &#34;red&#34;)
	)))

;; Restore the &#34;desktop&#34; - do this as late as possible
(if first-time
    (progn
      (desktop-load-default)
      (desktop-read)))

;; Indicate that this file has been read at least once
(setq first-time nil)

;; No need to debug anything now

(setq debug-on-error nil)

;; All done
(message &#34;All done, %s%s&#34; (user-login-name) &#34;.&#34;)</pre></div></div></div></div></div><div class=sect3><h4 id=_erweitern_des_von_emacs_unterstützten_sprachbereichs>2.7.4. Erweitern des von Emacs unterstützten Sprachbereichs<a class=anchor href=#_erweitern_des_von_emacs_unterstützten_sprachbereichs></a></h4><div class=paragraph><p>Das ist jetzt alles sehr schön wenn Sie ausschließlich in einer der Sprachen programmieren wollen, um die wir uns bereits in der <span class=filename>.emacs</span>-Datei gekümmert haben (C, C++, Perl, Lisp und Scheme), aber was passiert wenn eine neue Sprache namens "whizbang" herauskommt, mit jeder Menge neuen tollen Features?</p></div><div class=paragraph><p>Als erstes muß festgestellt werden, ob whizbang mit irgendwelchen Dateien daherkommt, die Emacs etwas über die Sprache sagen. Diese enden üblicherweise auf <span class=filename>.el</span>, der Kurzform für "Emacs Lisp". Falls whizbang zum Beispiel ein FreeBSD Port ist, könnten wir diese Dateien mittels</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% find /usr/ports/lang/whizbang <span class=nt>-name</span> <span class=s2>&#34;*.el&#34;</span> <span class=nt>-print</span></code></pre></div></div><div class=paragraph><p>finden und durch Kopieren in das Emacs-seitige Lisp-Verzeichnis installieren. Unter FreeBSD ist dies <span class=filename>/usr/local/shared/emacs/site-lisp</span>.</p></div><div class=paragraph><p>Wenn zum Beispiel die Ausgabe des find-Befehls wie folgt war</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/usr/ports/lang/whizbang/work/misc/whizbang.el</code></pre></div></div><div class=paragraph><p>könnten wir das folgende tun</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /usr/ports/lang/whizbang/work/misc/whizbang.el /usr/local/shared/emacs/site-lisp</span></code></pre></div></div><div class=paragraph><p>Als nächstes müssen wir festlegen, welche Dateiendung Quelltextdateien für whizbang haben. Lassen Sie uns um der Argumente Willen annehmen, die Dateiendung sei <span class=filename>.wiz</span>. Wir müssen dann einen Eintrag unserer <span class=filename>.emacs</span>-Datei hinzufügen um sicherzustellen, daß Emacs die Informationen in <span class=filename>whizbang.el</span> auch verwenden kann.</p></div><div class=paragraph><p>Suchen Sie den auto-mode-alist Eintrag in der <span class=filename>.emacs</span>-Datei und fügen Sie an dieser Stelle eine Zeile wie folgt für whizbang hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>...
(&#34;\\.lsp$&#34; . lisp-mode)
(&#34;\\.wiz$&#34; . whizbang-mode)
(&#34;\\.scm$&#34; . scheme-mode)
...</pre></div></div><div class=paragraph><p>Dies bedeutet das Emacs automatisch in den <code>whizbang-mode</code> wechseln wird, wenn Sie eine Datei mit der Dateiendung <span class=filename>.wiz</span> editieren.</p></div><div class=paragraph><p>Direkt darunter werden Sie den Eintrag font-lock-auto-mode-list finden. Erweitern Sie den <code>whizbang-mode</code> um diesen wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>;; Auto font lock mode
(defvar font-lock-auto-mode-list
  (list &#39;c-mode &#39;c++-mode &#39;c++-c-mode &#39;emacs-lisp-mode &#39;whizbang-mode &#39;lisp-mode &#39;perl-mode &#39;scheme-mode)
  &#34;List of modes to always start in font-lock-mode&#34;)</pre></div></div><div class=paragraph><p>Dies bedeutet das Emacs immer <code>font-lock-mode</code> (z.B. Syntax Highlighting) aktiviert, wenn Sie eine <span class=filename>.wiz</span>-Datei editieren.</p></div><div class=paragraph><p>Und das ist alles was benötigt wird. Falls es weitere Dinge gibt, die automatisch beim Öffnen einer <span class=filename>.wiz</span>-Datei ausgeführt werden sollen, können Sie einen <code>whizbang-mode hook</code>-Eintrag hinzufügen (für ein einfaches Beispiel, welches <code>auto-indent</code> hinzufügt, sehen Sie sich bitte <code>my-scheme-mode-hook</code> an).</p></div></div></div><div class=sect2><h3 id=tools-reading>2.8. Weiterführende Literatur<a class=anchor href=#tools-reading></a></h3><div class=paragraph><p>Für Informationen zum Aufsetzen einer Entwicklungsumgebung, um Fehlerbehebungen an FreeBSD selber beizusteuern sehen Sie sich bitte <a href="https://man.freebsd.org/cgi/man.cgi?query=development&amp;sektion=7&amp;format=html">development(7)</a> an.</p></div><div class=ulist><ul><li><p>Brian Harvey and Matthew Wright <em>Simply Scheme</em> MIT 1994. ISBN 0-262-08226-8</p></li><li><p>Randall Schwartz <em>Learning Perl</em> O’Reilly 1993 ISBN 1-56592-042-2</p></li><li><p>Patrick Henry Winston and Berthold Klaus Paul Horn <em>Lisp (3rd Edition)</em> Addison-Wesley 1989 ISBN 0-201-08319-1</p></li><li><p>Brian W. Kernighan and Rob Pike <em>The Unix Programming Environment</em> Prentice-Hall 1984 ISBN 0-13-937681-X</p></li><li><p>Brian W. Kernighan and Dennis M. Ritchie <em>The C Programming Language (2nd Edition)</em> Prentice-Hall 1988 ISBN 0-13-110362-8</p></li><li><p>Bjarne Stroustrup <em>The C++ Programming Language</em> Addison-Wesley 1991 ISBN 0-201-53992-6</p></li><li><p>W. Richard Stevens <em>Advanced Programming in the Unix Environment</em> Addison-Wesley 1992 ISBN 0-201-56317-7</p></li><li><p>W. Richard Stevens <em>Unix Network Programming</em> Prentice-Hall 1990 ISBN 0-13-949876-1</p></li></ul></div></div></div></div><div class=sect1><h2 id=secure>Kapitel 3. Sicheres Programmieren<a class=anchor href=#secure></a></h2><div class=sectionbody><div class=sect2><h3 id=secure-synopsis>3.1. Zusammenfassung<a class=anchor href=#secure-synopsis></a></h3><div class=paragraph><p>Dieses Kapitel beschreibt einige Sicherheitsprobleme, die UNIX®-Programmierer seit Jahrzehnten quälen, und inzwischen verfügbare Werkzeuge, die Programmierern helfen, Sicherheitslücken in ihrem Quelltext zu vermeiden.</p></div></div><div class=sect2><h3 id=secure-philosophy>3.2. Methoden des sicheren Entwurfs<a class=anchor href=#secure-philosophy></a></h3><div class=paragraph><p>Sichere Anwendungen zu schreiben erfordert eine sehr skeptische und pessimistische Lebenseinstellung. Anwendungen sollten nach dem Prinzip der "geringsten Privilegien" ausgeführt werden, sodass kein Prozess mit mehr als dem absoluten Minimum an Zugriffsrechten arbeitet, die er zum Erfüllen seiner Aufgabe benötigt. Wo es möglich ist, sollte Quelltext, der bereits überprüft wurde, wiederverwendet werden, um häufige Fehler, die andere schon korrigiert haben, zu vermeiden.</p></div><div class=paragraph><p>Eine der Stolperfallen der UNIX®-Umgebung ist, dass es sehr einfach ist Annahmen über die Konsistenz der Umgebung zu machen. Anwendungen sollten Nutzereingaben (in allen Formen) niemals trauen, genauso wenig wie den System-Ressourcen, der Inter-Prozess-Kommunikation oder dem zeitlichen Ablauf von Ereignissen. UNIX®-Prozesse arbeiten nicht synchron. Daher sind logische Operationen selten atomar.</p></div></div><div class=sect2><h3 id=secure-bufferov>3.3. Puffer-Überläufe<a class=anchor href=#secure-bufferov></a></h3><div class=paragraph><p>Puffer-Überläufe gibt es schon seit den Anfängen der Von-Neuman-Architektur <a href=./#cod>1</a>. Sie erlangten zum ersten Mal durch den Internetwurm Morris im Jahre 1988 öffentliche Bekanntheit. Unglücklicherweise funktioniert der gleiche grundlegende Angriff noch heute. Die bei weitem häufigste Form eines Puffer-Überlauf-Angriffs basiert darauf, den Stack zu korrumpieren.</p></div><div class=paragraph><p>Die meisten modernen Computer-Systeme verwenden einen Stack, um Argumente an Prozeduren zu übergeben und lokale Variablen zu speichern. Ein Stack ist ein last-in-first-out-Puffer (LIFO) im hohen Speicherbereich eines Prozesses. Wenn ein Programm eine Funktion aufruft wird ein neuer "Stackframe" erzeugt. Dieser besteht aus den Argumenten, die der Funktion übergeben wurden und einem variabel grossem Bereich für lokale Variablen. Der "Stack-Pointer" ist ein Register, dass die aktuelle Adresse der Stack-Spitze enthält. Da sich dieser Wert oft ändert, wenn neue Werte auf dem Stack abgelegt werden, bieten viele Implementierungen einen "Frame-Pointer", der nahe am Anfang des Stack-Frames liegt und es so leichter macht lokale Variablen relativ zum aktuellen Stackframe zu adressieren. <a href=./#cod>1</a> Die Rücksprungadresse der Funktionen werden ebenfalls auf dem Stack gespeichert und das ist der Grund für Stack-Überlauf-Exploits. Denn ein böswilliger Nutzer kann die Rücksprungadresse der Funktion überschreiben indem er eine lokale Variable in der Funktion überlaufen lässt, wodurch es ihm möglich ist beliebigen Code auszuführen.</p></div><div class=paragraph><p>Obwohl Stack-basierte Angriffe bei weitem die Häufigsten sind, ist es auch möglich den Stack mit einem Heap-basierten (malloc/free) Angriff zu überschreiben.</p></div><div class=paragraph><p>Die C-Programmiersprache führt keine automatischen Bereichsüberprüfungen bei Feldern oder Zeigern durch, wie viele andere Sprachen das tun. Außerdem enthält die C-Standardbibliothek eine Handvoll sehr gefährlicher Funktionen.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>strcpy</code>(char *dest, const char *src)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer dest überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>strcat</code>(char *dest, const char *src)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer dest überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>getwd</code>(char *buf)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer buf überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>gets</code>(char *s)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer s überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>[vf]scanf</code>(const char *format, …​)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann sein Argument überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>realpath</code>(char *path, char resolved_path[])</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer path überlaufen lassen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>[v]sprintf</code>(char *str, const char *format, …​)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kann den Puffer str überlaufen lassen</p></td></tr></tbody></table><div class=sect3><h4 id=_puffer_überlauf_beispiel>3.3.1. Puffer-Überlauf Beispiel<a class=anchor href=#_puffer_überlauf_beispiel></a></h4><div class=paragraph><p>Das folgende Quellcode-Beispiel enthält einen Puffer-Überlauf, der darauf ausgelegt ist die Rücksprungadresse zu überschreiben und die Anweisung direkt nach dem Funktionsaufruf zu überspringen. (Inspiriert durch <a href=./#Phrack>4</a>)</p></div><div class="literalblock programlisting"><div class=content><pre>#include stdio.h

void manipulate(char *buffer) {
char newbuffer[80];
strcpy(newbuffer,buffer);
}

int main() {
char ch,buffer[4096];
int i=0;

while ((buffer[i++] = getchar()) != &#39;\n&#39;) {};

i=1;
manipulate(buffer);
i=2;
printf(&#34;The value of i is : %d\n&#34;,i);
return 0;
}</pre></div></div><div class=paragraph><p>Betrachten wir nun, wie das Speicherabbild dieses Prozesses aussehen würde, wenn wir 160 Leerzeichen in unser kleines Programm eingeben, bevor wir Enter drücken.</p></div><div class=paragraph><p>Offensichtlich kann man durch böswilligere Eingaben bereits kompilierten Programmtext ausführen (wie z.B. exec(/bin/sh)).</p></div></div><div class=sect3><h4 id=_puffer_überläufe_vermeiden>3.3.2. Puffer-Überläufe vermeiden<a class=anchor href=#_puffer_überläufe_vermeiden></a></h4><div class=paragraph><p>Die direkteste Lösung, um Stack-Überläufe zu vermeiden, ist immer grössenbegrenzten Speicher und String-Copy-Funktionen zu verwenden. <code>strncpy</code> und <code>strncat</code> sind Teil der C-Standardbibliothek. Diese Funktionen akzeptieren einen Längen-Parameter. Dieser Wert sollte nicht größer sein als die Länge des Zielpuffers. Die Funktionen kopieren dann bis zu <code>length</code> Bytes von der Quelle zum Ziel. Allerdings gibt es einige Probleme. Keine der Funktionen garantiert, dass die Zeichenkette NUL-terminiert ist, wenn die Größe des Eingabepuffers so groß ist wie das Ziel. Außerdem wird der Parameter length zwischen strncpy und strncat inkonsistent definiert, weshalb Programmierer leicht bezüglich der korrekten Verwendung durcheinander kommen können. Weiterhin gibt es einen spürbaren Leistungsverlust im Vergleich zu <code>strcpy</code>, wenn eine kurze Zeichenkette in einen großen Puffer kopiert wird. Denn <code>strncpy</code> fült den Puffer bis zur angegebenen Länge mit NUL auf.</p></div><div class=paragraph><p>In OpenBSD wurde eine weitere Möglichkeit zum kopieren von Speicherbereichen implementiert, die dieses Problem umgeht. Die Funktionen <code>strlcpy</code> und <code>strlcat</code> garantieren, dass das Ziel immer NUL-terminiert wird, wenn das Argument length ungleich null ist. Für weitere Informationen über diese Funktionen lesen Sie bitte <a href=./#OpenBSD>6</a>. Die OpenBSD-Funktionen <code>strlcpy</code> und <code>strlcat</code> sind seit Version 3.3 auch in FreeBSD verfügbar.</p></div><div class=sect4><h5 id=_compiler_basierte_laufzeitüberprüfung_von_grenzen>3.3.2.1. Compiler-basierte Laufzeitüberprüfung von Grenzen<a class=anchor href=#_compiler_basierte_laufzeitüberprüfung_von_grenzen></a></h5><div class=paragraph><p>Unglücklicherweise gibt es immer noch sehr viel Quelltext, der allgemein verwendet wird und blind Speicher umherkopiert, ohne eine der gerade besprochenen Funktionen, die Begrenzungen unterstützen, zu verwenden. Glücklicherweise gibt es einen Weg, um solche Angriffe zu verhindern - Überprüfung der Grenzen zur Laufzeit, die in verschiedenen C/C++ Compilern eingebaut ist.</p></div><div class=paragraph><p>ProPolice ist eine solche Compiler-Eigenschaft und ist in den <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a> Versionen 4.1 und höher integriert. Es ersetzt und erweitert die <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a> StackGuard-Erweiterung von früher.</p></div><div class=paragraph><p>ProPolice schützt gegen stackbasierte Pufferüberläufe und andere Angriffe durch das Ablegen von Pseudo-Zufallszahlen in Schlüsselbereichen des Stacks bevor es irgendwelche Funktionen aufruft. Wenn eine Funktion beendet wird, werden diese "Kanarienvögel" überprüft und wenn festgestellt wird, dass diese verändert wurden wird das Programm sofort abgebrochen. Dadurch wird jeglicher Versuch, die Rücksprungadresse oder andere Variablen, die auf dem Stack gespeichert werden, durch die Ausführung von Schadcode zu manipulieren, nicht funktionieren, da der Angreifer auch die Pseudo-Zufallszahlen unberührt lassen müsste.</p></div><div class=paragraph><p>Ihre Anwendungen mit ProPolice neu zu kompilieren ist eine effektive Maßnahme, um sie vor den meisten Puffer-Überlauf-Angriffen zu schützen, aber die Programme können noch immer kompromittiert werden.</p></div></div><div class=sect4><h5 id=_bibliotheks_basierte_laufzeitüberprüfung_von_grenzen>3.3.2.2. Bibliotheks-basierte Laufzeitüberprüfung von Grenzen<a class=anchor href=#_bibliotheks_basierte_laufzeitüberprüfung_von_grenzen></a></h5><div class=paragraph><p>Compiler-basierte Mechanismen sind bei Software, die nur im Binärformat vertrieben wird, und die somit nicht neu kompiliert werden kann völlig nutzlos. Für diesen Fall gibt es einige Bibliotheken, welche die unsicheren Funktionen der C-Bibliothek (<code>strcpy</code>, <code>fscanf</code>, <code>getwd</code>, etc..) neu implementieren und sicherstellen, dass nicht hinter den Stack-Pointer geschrieben werden kann.</p></div><div class=ulist><ul><li><p>libsafe</p></li><li><p>libverify</p></li><li><p>libparanoia</p></li></ul></div><div class=paragraph><p>Leider haben diese Bibliotheks-basierten Verteidigungen mehrere Schwächen. Diese Bibliotheken schützen nur vor einer kleinen Gruppe von Sicherheitslücken und sie können das eigentliche Problem nicht lösen. Diese Maßnahmen können versagen, wenn die Anwendung mit -fomit-frame-pointer kompiliert wurde. Außerdem kann der Nutzer die Umgebungsvariablen LD_PRELOAD und LD_LIBRARY_PATH überschreiben oder löschen.</p></div></div></div></div><div class=sect2><h3 id=secure-setuid>3.4. SetUID-Themen<a class=anchor href=#secure-setuid></a></h3><div class=paragraph><p>Es gibt zu jedem Prozess mindestens sechs verschiedene IDs, die diesem zugeordnet sind. Deshalb müssen Sie sehr vorsichtig mit den Zugriffsrechten sein, die Ihr Prozess zu jedem Zeitpunkt besitzt. Konkret bedeutet dass, das alle seteuid-Anwendungen ihre Privilegien abgeben sollten, sobald sie diese nicht mehr benötigen.</p></div><div class=paragraph><p>Die reale Benutzer-ID kann nur von einem Superuser-Prozess geändert werden. Das Programm login setzt sie, wenn sich ein Benutzer am System anmeldet, und sie wird nur selten geändert.</p></div><div class=paragraph><p>Die effektive Benutzer-ID wird von der Funktion <code>exec()</code> gesetzt, wenn ein Programm das seteuid-Bit gesetzt hat. Eine Anwendung kann <code>seteuid()</code> jederzeit aufrufen, um die effektive Benutzer-ID entweder auf die reale Benutzer-ID oder die gespeicherte set-user-ID zu setzen. Wenn eine der <code>exec()</code>-Funktionen die effektive Benutzer-ID setzt, wird der vorherige Wert als gespeicherte set-user-ID abgelegt.</p></div></div><div class=sect2><h3 id=secure-chroot>3.5. Die Umgebung ihrer Programme einschränken<a class=anchor href=#secure-chroot></a></h3><div class=paragraph><p>Die herkömmliche Methode, um einen Prozess einzuschränken, besteht in dem Systemaufruf <code>chroot()</code>. Dieser Aufruf ändert das Wurzelverzeichnis, auf das sich alle Pfadangaben des Prozesses und jegliche Kind-Prozesse beziehen. Damit dieser Systemaufruf gelingt, muss der Prozess Ausführungsrechte (Durchsuchungsrechte) für das Verzeichnis haben, auf das er sich bezieht. Die neue Umgebung wird erst wirksam, wenn Sie mittels <code>chdir()</code> in Ihre neue Umgebung wechseln. Es sollte erwähnt werden, dass ein Prozess recht einfach aus der chroot-Umgebung ausbrechen kann, wenn er root-Rechte besitzt. Das kann man erreichen, indem man Gerätedateien anlegt, um Kernel-Speicher zu lesen, oder indem man einen Debugger mit einem Prozess außerhalb seiner <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a>-Umgebung verbindet, oder auf viele andere kreative Wege.</p></div><div class=paragraph><p>Das Verhalten des Systemaufrufs <code>chroot()</code> kann durch die kern.chroot.allow_open_directories <code>sysctl</code>-Variable beeinflusst werden. Wenn diese auf 0 gesetzt ist, wird <code>chroot()</code> mit EPERM fehlschlagen, wenn irgendwelche Verzeichnisse geöffnet sind. Wenn die Variable auf den Standardwert 1 gesetzt ist, wird <code>chroot()</code> mit EPERM fehlschlagen, wenn irgendwelche Verzeichnisse geöffnet sind und sich der Prozess bereits in einer <code>chroot()</code>-Umgebung befindet. Bei jedem anderen Wert wird die Überprüfung auf geöffnete Verzeichnisse komplett umgangen.</p></div><div class=sect3><h4 id=_die_jail_funktionalität_in_freebsd>3.5.1. Die Jail-Funktionalität in FreeBSD<a class=anchor href=#_die_jail_funktionalität_in_freebsd></a></h4><div class=paragraph><p>Das Konzept einer Jail (Gefängnis) erweitert <code>chroot()</code>, indem es die Macht des Superusers einschränkt, um einen echten 'virtuellen Server' zu erzeugen. Wenn ein solches Gefängnis einmal eingerichtet ist, muss die gesamte Netzwerkkommunikation über eine bestimmte IP-Adresse erfolgen und die "root-Privilegien" innerhalb der Jail sind sehr stark eingeschränkt.</p></div><div class=paragraph><p>Solange Sie sich in einer Jail befinden, werden alle Tests auf Superuser-Rechte durch den Aufruf von <code>suser()</code> fehlschlagen. Allerdings wurden einige Aufrufe von <code>suser()</code> abgeändert, um die neue <code>suser_xxx()</code>-Schnittstelle zu implementieren. Diese Funktion ist dafür verantwortlich, festzustellen, ob bestimmte Superuser-Rechte einem eingesperrten Prozess zur Verfügung stehen.</p></div><div class=paragraph><p>Ein Superuser-Prozess innerhalb einer Jail darf folgendes:</p></div><div class=ulist><ul><li><p>Berechtigungen verändern mittels: <code>setuid</code>, <code>seteuid</code>, <code>setgid</code>, <code>setegid</code>, <code>setgroups</code>, <code>setreuid</code>, <code>setregid</code>, <code>setlogin</code></p></li><li><p>Ressourcenbegrenzungen setzen mittels <code>setrlimit</code></p></li><li><p>Einige sysctl-Variablen (kern.hostname) verändern</p></li><li><p><code>chroot()</code></p></li><li><p>Ein Flag einer vnode setzen: <code>chflags</code>, <code>fchflags</code></p></li><li><p>Attribute einer vnode setzen wie Dateiberechtigungen, Eigentümer, Gruppe, Größe, Zugriffszeit und Modifikationszeit</p></li><li><p>Binden eines Prozesses an einen öffentlichen privilegierten Port (ports 1024)</p></li></ul></div><div class=paragraph><p><code>Jail</code>s sind ein mächtiges Werkzeug, um Anwendungen in einer sicheren Umgebung auszuführen, aber sie haben auch ihre Nachteile. Derzeit wurden die IPC-Mechanismen noch nicht an <code>suser_xxx</code> angepasst, so dass Anwendungen wie MySQL nicht innerhalb einer Jail ausgeführt werden können. Der Superuser-Zugriff hat in einer Jail nur eine sehr eingeschränkte Bedeutung, aber es gibt keine Möglichkeit zu definieren was "sehr eingeschränkt" heißt.</p></div></div><div class=sect3><h4 id=_posix_1e_prozess_capabilities>3.5.2. POSIX®.1e Prozess Capabilities<a class=anchor href=#_posix_1e_prozess_capabilities></a></h4><div class=paragraph><p>POSIX® hat einen funktionalen Entwurf (Working Draft) herausgegeben, der Ereignisüberprüfung, Zugriffskontrolllisten, feiner einstellbare Privilegien, Informationsmarkierung und verbindliche Zugriffskontrolle enthält.</p></div><div class=paragraph><p>Dies ist im Moment in Arbeit und das Hauptziel des <a href=http://www.trustedbsd.org/>TrustedBSD</a>-Projekts. Ein Teil der bisherigen Arbeit wurde in FreeBSD-CURRENT übernommen (cap_set_proc(3)).</p></div></div></div><div class=sect2><h3 id=secure-trust>3.6. Vertrauen<a class=anchor href=#secure-trust></a></h3><div class=paragraph><p>Eine Anwendung sollte niemals davon ausgehen, dass irgendetwas in der Nutzerumgebung vernünftig ist. Das beinhaltet (ist aber sicher nicht darauf beschränkt): Nutzereingaben, Signale, Umgebungsvariablen, Ressourcen, IPC, mmaps, das Arbeitsverzeichnis im Dateisystem, Dateideskriptoren, die Anzahl geöffneter Dateien, etc..</p></div><div class=paragraph><p>Sie sollten niemals annehmen, dass Sie jede Art von inkorrekten Eingaben abfangen können, die ein Nutzer machen kann. Stattdessen sollte Ihre Anwendung positive Filterung verwenden, um nur eine bestimmte Teilmenge an Eingaben zuzulassen, die Sie für sicher halten. Ungeeignete Datenüberprüfung ist die Ursache vieler Exploits, besonders für CGI-Skripte im Internet. Bei Dateinamen müssen Sie besonders vorsichtig sein, wenn es sich um Pfade ("../", "/"), symbolische Verknüpfungen und Shell-Escape-Sequenzen handelt.</p></div><div class=paragraph><p>Perl bietet eine wirklich coole Funktion, den sogenannten "Taint"-Modus, der verwendet werden kann, um zu verhindern, dass Skripte Daten, die von außerhalb des Programmes stammen, auf unsichere Art und Weise verwenden. Dieser Modus überprüft Kommandozeilenargumente, Umgebungsvariablen, Lokalisierungsinformationen, die Ergebnisse von Systemaufrufen (<code>readdir()</code>, <code>readlink()</code>, <code>getpwxxx()</code>) und alle Dateieingaben.</p></div></div><div class=sect2><h3 id=secure-race-conditions>3.7. Race-Conditions<a class=anchor href=#secure-race-conditions></a></h3><div class=paragraph><p>Eine Race-Condition ist ein unnormales Verhalten, das von einer unerwarteten Abhängigkeit beim Timing von Ereignissen verursacht wird. Mit anderen Worten heißt das, ein Programmierer nimmt irrtümlicher Weise an, dass ein bestimmtes Ereignis immer vor einem anderen stattfindet.</p></div><div class=paragraph><p>Einige der häufigsten Ursachen für Race-Conditions sind Signale, Zugriffsprüfungen und das Öffnen von Dateien. Signale sind von Natur aus asynchrone Ereignisse, deshalb ist besondere Vorsicht im Umgang damit geboten. Das Prüfen des Zugriffs mittels der Aufrufe <code>access(2)</code> gefolgt von <code>open(2)</code> ist offensichtlich nicht atomar. Benutzer können zwischen den beiden Aufrufen Dateien verschieben. Stattdessen sollten privilegierte Anwendungen <code>seteuid()</code> direkt gefolgt von <code>open()</code> aufrufen. Auf die gleiche Art sollte eine Anwendung immer eine korrekte Umask vor dem Aufruf von <code>open()</code> setzen, um störende Aufrufe von <code>chmod()</code> zu umgehen.</p></div></div></div></div><div class=sect1><h2 id=l10n>Kapitel 4. Lokalisierung und Internationalisierung - L10N und I18N<a class=anchor href=#l10n></a></h2><div class=sectionbody><div class=sect2><h3 id=l10n-programming>4.1. I18N-konforme Anwendungen programmieren<a class=anchor href=#l10n-programming></a></h3><div class=paragraph><p>Um Ihre Anwendung verwendbarer für andere Sprachen zu machen, hoffen wir, dass Sie I18N-konform programmieren. Der GNU gcc-Compiler und Bibliotheken für grafische Benutzeroberflächen wie QT und GTK unterstützen I18N durch eine spezielle Verarbeitung von Zeichenketten. Das Erstellen eines I18N-konformen Programms ist sehr einfach und erlaubt anderen Mitwirkenden, Ihre Programme leichter in andere Sprachen zu übersetzen. Lesen Sie die Bibliothek-spezifischen I18N-Dokumentationen für weitere Details.</p></div><div class=paragraph><p>Im Gegensatz zur allgemeinen Meinung ist I18N-konformer Code einfach zu programmieren. Üblicherweise umfasst dies nur das Einbetten Ihrer Zeichenketten in Bibliothek-spezifische Funktionen. Stellen Sie außerdem bitte sicher, dass Sie Unterstützung für Unicode- und Multibyte-Zeichen vorsehen.</p></div><div class=sect3><h4 id=_ein_aufruf_die_i18n_bemühungen_zu_vereinheitlichen>4.1.1. Ein Aufruf, die I18N-Bemühungen zu vereinheitlichen<a class=anchor href=#_ein_aufruf_die_i18n_bemühungen_zu_vereinheitlichen></a></h4><div class=paragraph><p>Wir sind darauf aufmerksam geworden, dass die einzelnen I18N-/L10N-Bemühungen für jedes Land wiederholt wurden. Viele von uns haben somit unproduktiverweise das Rad immer wieder neu erfunden. Wir hoffen, dass die verschiedenen großen Gruppen für I18N Ihre Bemühungen in einer Gruppe vereinen können, ähnlich der Zuständigkeit des Core-Teams.</p></div><div class=paragraph><p>Derzeit hoffen wir, dass wenn Sie I18N-konforme Programme schreiben oder portieren, diese an die betreffenden FreeBSD-Mailinglisten jedes Landes schicken, um sie testen zu lassen. Wir hoffen in Zukunft, Anwendungen zu entwickeln, die in allen Sprachen direkt und ohne unsaubere Änderungen funktionieren.</p></div><div class=paragraph><p>Die <a href=https://lists.FreeBSD.org/subscription/freebsd-i18n>FreeBSD internationalization</a>-Mailingliste ist eingerichtet worden. Wenn Sie I18N-/L10N-Entwickler sind, schicken Sie bitte Ihre Kommentare, Ideen, Fragen und alles, das Sie mit dem Thema in Verbindung bringen, dorthin.</p></div></div><div class=sect3><h4 id=_perl_und_python>4.1.2. Perl und Python<a class=anchor href=#_perl_und_python></a></h4><div class=paragraph><p>Perl und Python bieten Bibliotheken für I18N und zur Behandlung von Unicode-Zeichen. Bitte nutzen Sie diese für I18N-Konformität.</p></div></div></div><div class=sect2><h3 id=posix-nls>4.2. Lokalisierte Nachrichten mit POSIX.1 Native Language Support (NLS)<a class=anchor href=#posix-nls></a></h3><div class=paragraph><p>Über die Basisfunktionen von I18N hinaus, wie das Bereitstellen von verschiedenen Eingabecodierungen oder die diversen nationalen Konventionen, zum Beispiel die verschiedenen Dezimalpunkte, ist es auf einem höheren Level von I18N möglich, die Ausgabe von Programmen zu lokalisieren. Ein Weg dies zu tun besteht in der Nutzung der POSIX.1 NLS-Funktionen von FreeBSD.</p></div><div class=sect3><h4 id=nls-catalogs>4.2.1. Organisation von lokalisierten Mitteilungen in Katalog Dateien<a class=anchor href=#nls-catalogs></a></h4><div class=paragraph><p>POSIX.1 NLS basiert auf Katalogdateien, welche die lokalisierten Mitteilungen in der entsprechenden Codierung enthalten. Die Mitteilungen sind in Sets organisiert und jede Mitteilung ist durch eine eindeutige Zahl in dem jeweiligen Set identifiziert. Die Katalogdateien werden nach der Lokale, von den jeweiligen lokalisierten Mitteilungen, die sie enthalten, gefolgt von der <code>.msg</code> Endung benannt. Zum Beispiel werden die ungarischen Mitteilungen für das ISO8859-2 Encoding in einer Datei mit dem Dateinamen <span class=filename>hu_HU.ISO8859-2</span> gespeichert.</p></div><div class=paragraph><p>Diese Katalogdateien sind normale Textdateien, welche die nummerierten Mitteilungen enthalten. Es ist möglich Kommentare in die Dateien zu schreiben, indem Sie ein <code>$</code>-Zeichen an den Anfang der Zeile setzen. Das Setzen von Grenzen wird ebenfalls durch spezielle Kommentare möglich wobei das Schlüsselwort <code>set</code> direkt nach dem <code>$</code>-Zeichen folgen muss. Dem Schlüsselwort <code>set</code> folgt dann die Set-Nummer. Ein Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>$set 1</pre></div></div><div class=paragraph><p>Der aktuelle Mitteilungseintrag startet mit der Mitteilungsnummer gefolgt von der lokalisierten Nachricht. Die bekannten Modifikatoren von <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a> werden akzeptiert:</p></div><div class="literalblock programlisting"><div class=content><pre>15 &#34;File not found: %s\n&#34;</pre></div></div><div class=paragraph><p>Die Katalogdateien müssen in binärer Form vorliegen, bevor sie von einem Programm benutzt werden können. Dies wird mit dem <a href="https://man.freebsd.org/cgi/man.cgi?query=gencat&amp;sektion=1&amp;format=html">gencat(1)</a> Tool durchgeführt. Das erste Argument ist der Dateiname des kompilierten Katalogs und die weiteren Argumente sind die Eingabekataloge. Die lokalisierten Mitteilungen können auf mehrere Katalogdateien aufgeteilt sein. Danach werden dann alle auf einmal mit dem <a href="https://man.freebsd.org/cgi/man.cgi?query=gencat&amp;sektion=1&amp;format=html">gencat(1)</a> Tool kompiliert.</p></div></div><div class=sect3><h4 id=nls-using>4.2.2. Nutzung der Katalogdateien im Quellcode<a class=anchor href=#nls-using></a></h4><div class=paragraph><p>Das Benutzen der Katalogdateien ist einfach. Um die relevante Funktion zu nutzen, muss <span class=filename>nl_types.h</span> in die Quelldatei eingefügt werden. Bevor ein Katalog benutzt werden kann, muss er mit <a href="https://man.freebsd.org/cgi/man.cgi?query=catopen&amp;sektion=3&amp;format=html">catopen(3)</a> geöffnet werden. Die Funktion hat 2 Argumente. Der erste Parameter ist der Name des installierten und kompilierten Katalogs. Normalerweise wird der Name des Programmes, zum Beispiel grep, genutzt. Dieser Name wird zum Suchen der kompilierten Katalogdatei benutzt. Der Aufruf von <a href="https://man.freebsd.org/cgi/man.cgi?query=catopen&amp;sektion=3&amp;format=html">catopen(3)</a> sucht nach dieser Datei in <span class=filename>/usr/shared/nls/locale/catname</span> und in <span class=filename>/usr/local/shared/nls/locale/catname</span>, wobei <code>locale</code> die gesetzte Lokale und <code>catname</code> der Katalogname ist. Der zweite Parameter ist eine Konstante, die zwei Werte haben kann:</p></div><div class=ulist><ul><li><p><code>NL_CAT_LOCALE</code>, hat die Bedeutung, dass die benutzte Katalogdatei auf <code>LC_MESSAGES</code> basiert.</p></li><li><p><code>0</code>, hat die Bedeutung, dass <code>LANG</code> benutzt wird, um die Katalogdatei zu öffnen.</p></li></ul></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=catopen&amp;sektion=3&amp;format=html">catopen(3)</a> Aufruf gibt einen Katalogidentifizierer vom Type <code>nl_catd</code> zurück. Sehen Sie in der Manualpage nach, um eine Liste mit möglichen Fehlercodes zu erhalten.</p></div><div class=paragraph><p>Nach dem Öffnen eines Katalogs, kann <a href="https://man.freebsd.org/cgi/man.cgi?query=catgets&amp;sektion=3&amp;format=html">catgets(3)</a> benutzt werden, um Mitteilungen zu erhalten. Der erste Parameter ist der Katalogidentifizierer, der von <a href="https://man.freebsd.org/cgi/man.cgi?query=catopen&amp;sektion=3&amp;format=html">catopen(3)</a> zurück gegeben wurde, das zweite ist die Nummer des Sets, das dritte die Nummer der Mitteilung und das vierte ist eine Fallbackmitteilung, die angezeigt wird, falls die gewünschte Mitteilung in der Katalogdatei nicht verfügbar ist.</p></div><div class=paragraph><p>Nach der Nutzung der Katalogdatei, muss sie mit dem Kommando <a href="https://man.freebsd.org/cgi/man.cgi?query=catclose&amp;sektion=3&amp;format=html">catclose(3)</a>, geschlossen werden. Es besitzt ein Argument, die Katalog ID.</p></div></div><div class=sect3><h4 id=nls-example>4.2.3. Ein Beispiel aus der Praxis<a class=anchor href=#nls-example></a></h4><div class=paragraph><p>Das folgende Beispiel zeigt einen einfachen Weg wie man NLS-Kataloge flexibel nutzen kann.</p></div><div class=paragraph><p>Die nachfolgenden Zeilen müssen in eine allgemeine Headerdatei, die in allen Quelldateien vorhanden ist, die lokalisierte Mitteilungen benutzen, eingefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>#ifdef WITHOUT_NLS
#define getstr(n)         nlsstr[n]
#else
#include &lt;nl_types.h&gt;

extern nl_catd            catalog;
#define getstr(n)         catgets(catalog, 1, n, nlsstr[n])
#endif

extern char              *nlsstr[];</pre></div></div><div class=paragraph><p>Als nächstes fügen Sie die folgenden Zeilen in den globalen Deklarationsteil der Hauptquelldatei ein:</p></div><div class="literalblock programlisting"><div class=content><pre>#ifndef WITHOUT_NLS
#include &lt;nl_types.h&gt;
nl_catd   catalog;
#endif

/*
* Default messages to use when NLS is disabled or no catalog
* is found.
*/
char    *nlsstr[] = {
        &#34;&#34;,
/* 1*/  &#34;some random message&#34;,
/* 2*/  &#34;some other message&#34;
};</pre></div></div><div class=paragraph><p>Als nächstes kommt der Code der den Katalog öffnet, liest und schließt:</p></div><div class="literalblock programlisting"><div class=content><pre>#ifndef WITHOUT_NLS
 catalog = catopen(&#34;myapp&#34;, NL_CAT_LOCALE);
#endif

...

printf(getstr(1));

...

#ifndef WITHOUT_NLS
 catclose(catalog);
#endif</pre></div></div><div class=sect4><h5 id=_reduzierung_von_zu_lokalisierenden_zeichenketten>4.2.3.1. Reduzierung von zu lokalisierenden Zeichenketten<a class=anchor href=#_reduzierung_von_zu_lokalisierenden_zeichenketten></a></h5><div class=paragraph><p>Es gibt einen guten Weg, Zeichenketten die lokaliesert werden müssen, durch den Einsatz von libc-Fehlermeldungen zu reduzieren. Dadurch vermeidet man Duplikate und erstellt gleiche Meldungen für häufige Fehlermeldungen, die bei vielen Programmen auftreten können.</p></div><div class=paragraph><p>Als erstes ist hier ein Beispiel, dass keine libc-Fehlermeldungen benutzt:</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;err.h&gt;
...
if (!S_ISDIR(st.st_mode))
 err(1, &#34;argument is not a directory&#34;);</pre></div></div><div class=paragraph><p>Dies kann so abgeändert werden, dass eine Fehlermeldung durch Auslesen der Variabel <code>errno</code> ausgegeben wird. Die Fehlermeldung wird entsprechend dem Beispiel ausgegeben:</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;err.h&gt;
#include &lt;errno.h&gt;
...
if (!S_ISDIR(st.st_mode)) {
 errno = ENOTDIR;
 err(1, NULL);
}</pre></div></div><div class=paragraph><p>In diesem Beispiel wurde die benutzerdefinierte Zeichenkette entfernt. Übersetzer haben weniger Arbeit, wenn sie ein Programm lokalisieren und die Benutzer sehen die übliche "";Not a directory";" Fehlermeldung, wenn dieser Fehler auftritt. Diese Meldung wird ihnen wahrscheinlich vertraut erscheinen. Bitte beachten Sie, dass es notwendig ist, <span class=filename>errno.h</span> hinzuzufügen um einen direkten Zugriff auf <code>errno</code> zu haben.</p></div><div class=paragraph><p>Es lohnt sich darauf hinzuweisen, dass es Fälle gibt, in denen <code>errno</code> automatisch aufgerufen wird, so dass es nicht notwendig ist, es explizit zu tun:</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;err.h&gt;
...
if ((p = malloc(size)) == NULL)
 err(1, NULL);</pre></div></div></div></div><div class=sect3><h4 id=nls-mk>4.2.4. Benutzung von <span class=filename>bsd.nls.mk</span><a class=anchor href=#nls-mk></a></h4><div class=paragraph><p>Das Benutzen von Katalogdateien setzt einige sich wiederholende Schritte, wie das kompilieren und installieren der Kataloge, voraus. Um diese Schritte zu vereinfachen, stellt <span class=filename>bsd.nls.mk</span> einige Makros zur Verfügung. Es ist nicht notwendig <span class=filename>bsd.nls.mk</span> explizit hinein zu kopieren, es wird automatisch aus den allgemeinen Makefiles wie <span class=filename>bsd.prog.mk</span> oder <span class=filename>bsd.lib.mk</span> gezogen.</p></div><div class=paragraph><p>Normalerweise reicht es, <code>NLSNAME</code> zu definieren, die den Namen des Kataloges als erstes Argument von <a href="https://man.freebsd.org/cgi/man.cgi?query=catopen&amp;sektion=3&amp;format=html">catopen(3)</a> enthalten sollte und die Katalogdateien in <code>NLS</code> ohne ihre Endung <code>.msg</code> auflistet. Hier ist ein Beispiel, das es ermöglicht, NLS mit dem obigen Code zu deaktivieren. Die <code>WITHOUT_NLS</code> Variable von <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> muss so definiert werden, dass das Programm ohne NLS-Unterstützung gebaut wird.</p></div><div class="literalblock programlisting"><div class=content><pre>.if !defined(WITHOUT_NLS)
NLS=     es_ES.ISO8859-1
NLS+=    hu_HU.ISO8859-2
NLS+=    pt_BR.ISO8859-1
.else
CFLAGS+= -DWITHOUT_NLS
.endif</pre></div></div><div class=paragraph><p>Normalerweise werden die Katalogdateien in dem <span class=filename>nls</span>-Unterverzeichnis abgelegt. Dies ist der Standard von <span class=filename>bsd.nls.mk</span>. Es ist möglich, mit der <code>NLSSRCDIR</code>-Variablen von <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> diese zu überschreiben. Der Standardname der vorkompilierten Katalogdateien folgt den Namenskonventionen, wie oben beschrieben. Er kann durch die <code>NLSNAME</code>-Variablen überschrieben werden. Es gibt noch weitere Optionen, um eine Feinabstimmung zur Verarbeitung der Katalogdateien zu erreichen. Da sie nicht notwendig sind, werden sie hier nicht weiter beschrieben. Weitere Informationen über <span class=filename>bsd.nls.mk</span> finden Sie in der Datei selbst. Der Text ist kurz und leicht zu verstehen.</p></div></div></div></div></div><div class=sect1><h2 id=policies>Kapitel 5. Vorgaben und Richtlinien für das Quelltextverzeichnis<a class=anchor href=#policies></a></h2><div class=sectionbody><div class=paragraph><p>Dieses Kapitel dokumentiert verschiedene Vorgaben und Richtlinien für das FreeBSD-Quelltextverzeichnis.</p></div><div class=sect2><h3 id=policies-style>5.1. Stil-Richtlinien<a class=anchor href=#policies-style></a></h3><div class=paragraph><p>Ein konsistenter Code-Stil ist extrem wichtig, besonders in einem so grossen Projekt wie FreeBSD. Der Code sollte dem FreeBSD Code-Stil entsprechen, welcher in <a href="https://man.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9&amp;format=html">style(9)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=style.Makefile&amp;sektion=5&amp;format=html">style.Makefile(5)</a> genauer beschrieben ist.</p></div></div><div class=sect2><h3 id=policies-maintainer>5.2. <code>MAINTAINER</code> eines Makefiles<a class=anchor href=#policies-maintainer></a></h3><div class=paragraph><p>Wenn ein bestimmter Bereich der FreeBSD <span class=filename>src/</span>-Distribution von einer Person oder Gruppe gepflegt wird, kann dies durch einen Eintrag in die Datei <span class=filename>src/MAINTAINERS</span> der Öffentlichkeit mitgeteilt werden. Maintainer eines Ports in der Ports-Sammlung können ihre Verantwortung über den Port durch einen Eintrag in die <code>MAINTAINER</code>-Zeile im <span class=filename>Makefile</span> des Ports der Welt mitteilen.</p></div><div class="literalblock programlisting"><div class=content><pre>MAINTAINER= email-addresses</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Für andere Teile des Repositories oder andere Abschnitte, die noch keinen Maintainer aufweisen, oder falls Sie sich nicht sicher sind, wer der Maintainer ist, sehen Sie sich die Commit-Historie des betreffenden Ports an. Es ist recht häufig der Fall, dass ein Maintainer nicht explizit aufgeführt ist, aber trotzdem diejenigen Personen, die den Port seit den letzten paar Jahren aktiv betreuen, daran interessiert sind, Änderungen zu begutachten. Selbst wenn dies nicht explizit in der Dokumentation oder im Quellcode erwähnt ist, wird es trotzdem als höfliche Geste angesehen, wenn man nach einer Überprüfung der eigenen Änderungen fragt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Rolle eines Maintainers ist die folgende:</p></div><div class=ulist><ul><li><p>Der Maintainer ist verantwortlich für diesen Code. Er oder sie muss einerseits für die Behebung von Fehlern und das Beantworten von Problemberichten für diesen Code die Verantwortung tragen und andererseits, falls es sich um beigesteuerte Software handelt, neue Versionen verfolgen und bereitstellen.</p></li><li><p>Änderungen an Verzeichnissen, die ein Maintainer definiert hat, sollten an den Maintainer für eine Überprüfung gesendet werden, bevor diese committet werden. Nur wenn der Maintainer in einer inakzeptablen Zeitspanne auf mehrere E-Mails nicht antwortet, können die Änderungen, die mit dem Commit in Kraft treten, auch ohne Überprüfung durch den Maintainer vollzogen werden. Dennoch wird empfohlen, dass die Änderungen, falls möglich, von jemand anderem überprüft werden.</p></li><li><p>Es ist natürlich nicht akzeptabel, einer Person oder Gruppe den Status eines Maintainers zu geben, so lange sie nicht zustimmt, diese Pflicht auf sich zu nehmen. Andererseits muss es kein einzelner Mensch sein. Eine Gruppe von Menschen ist genauso in Ordnung.</p></li></ul></div></div><div class=sect2><h3 id=policies-contributed>5.3. Beigesteuerte Software<a class=anchor href=#policies-contributed></a></h3><div class=paragraph><p>Einige Teile der FreeBSD-Distribution enthalten Software, die aktiv außerhalb des FreeBSD-Projektes gepflegt wird. Aus historischen Gründen nennen wir dies <em>contributed</em> Software. Beispiele dafür sind sendmail, gcc und patch.</p></div><div class=paragraph><p>Über die Jahre wurden verschiedene Methoden genutzt, um solche Software zu verwalten, und jede hat Vor- wie auch Nachteile. So hat sich kein eindeutiger Gewinner herauskristallisiert.</p></div><div class=paragraph><p>Es wurde viel über diesen Umstand diskutiert und eine Methode als die "offizielle" vorgestellt, um in Zukunft diese Art der Software zu importieren. Ferner wird dringend geraten, dass sich existierende, beigesteuerte Software diesem Modell annähert, da es signifikante Vorteile gegenüber der alten Methode gibt. Dazu gehört auch, dass jeder einfach Diffs bezüglich der "offiziellen" Quelltext-Versionen erzeugen kann (auch ohne direkten Repository-Zugang). Dies wird es deutlich vereinfachen, Änderungen an die Hauptentwickler zurückfließen zu lassen.</p></div><div class=paragraph><p>Letztendlich kommt es jedoch auf die Menschen an, welche die Arbeit leisten. Wenn die Durchführung dieses Modells bei einem Paket mal nicht möglich ist, können Ausnahmen dieser Regeln nur mit Genehmigung des Core-Teams und der Übereinstimmung der anderen Entwickler gewährt werden. Die Fähigkeit, dieses Paket auch in Zukunft pflegen zu können, ist eine der Schlüsselfragen bei dieser Entscheidung.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Durch einige bedauernswerte Einschränkungen des RCS-Dateiformats und die Handhabung von Herstellerzweigen ist von unwesentlichen, trivialen und/oder kosmetischen Änderungen an Dateien <em>dringend abzuraten</em>, die dem Herstellerzweig folgen. "Grammatikalische oder sprachliche Fehlerbehebungen" sind explizit unter der "Kosmetik"-Kategorie einzuordnen und sollten vermieden werden. Das Repository kann sich durch Änderungen einzelner Zeichen dramatisch aufblähen.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=vendor-imports-cvs>5.3.1. Herstellerimports mit CVS<a class=anchor href=#vendor-imports-cvs></a></h4><div class=paragraph><p>Das file-Werkzeug soll als Beispiel dienen, wie dieses Modell funktioniert:</p></div><div class=paragraph><p><span class=filename>src/contrib/file</span> enthält den Quelltext so, wie vom Maintainer dieses Pakets bereitgestellt. Teile, die unter FreeBSD gänzlich unnutzbar sind, können entfernt werden. Im Fall von <a href="https://man.freebsd.org/cgi/man.cgi?query=file&amp;sektion=1&amp;format=html">file(1)</a> wurde u.a. das Unterverzeichnis <span class=filename>python</span> und Dateien mit dem Präfix <span class=filename>lt</span> vor dem Import entfernt.</p></div><div class=paragraph><p><span class=filename>src/lib/libmagic</span> enthält ein <span class=filename>Makefile</span> im bmake-Stil, das die Regeln des Standard-Makefiles <span class=filename>bsd.lib.mk</span> nutzt, um die Bibliothek zu erstellen und die Dokumentation zu installieren.</p></div><div class=paragraph><p><span class=filename>src/usr.bin/file</span> enthält ein <span class=filename>Makefile</span> im bmake-Stil, welches das <code>file</code>-Programm erstellt und installiert, ebenso die dazugehörigen Manualpages, welche die Regeln von <span class=filename>bsd.prog.mk</span> nutzen.</p></div><div class=paragraph><p>Das Entscheidende ist hier das <span class=filename>src/contrib/file</span>-Verzeichnis, welches nach den folgenden Regeln erstellt wird: Es muss den Quelltext aus dem Original enthalten (ohne RCS-Schlüsselworte und im korrekten Herstellerzweig) mit so wenig FreeBSD-spezifischen Änderungen wie möglich. Sollte es Zweifel geben, wie hier zu verfahren ist, unbedingt zuerst nachfragen und nicht auf gut Glück etwas probieren in der vagen Hoffnung, dass es "irgendwie funktioniert".</p></div><div class=paragraph><p>Aufgrund der eingangs schon erwähnten Einschränkungen bei Herstellerzweigen ist es erforderlich, dass "offizielle" Fehlerbehebungen vom Hersteller in die Originalquellen der Distribution einfließen und als Resultat wieder in den Herstellerzweig importiert werden. Offizielle Fehlerbehebungen sollten nie direkt in FreeBSD eingepflegt und "committet" werden, da dies den Herstellerzweig zerstören würde und der Import von zukünftigen Versionen wäre um ein Vielfaches schwerer, da es zu Konflikten kommen würde.</p></div><div class=paragraph><p>Da einige Pakete Dateien enthalten, die zur Kompatibilität mit anderen Architekturen und Umgebungen als FreeBSD gedacht sind, ist es zulässig, diese Teile zu löschen, wenn sie für FreeBSD nicht von Interesse sind, und so Speicherplatz zu sparen. Dateien, die ein Copyright und Release-artige Informationen zu den vorhandenen Dateien enthalten, sollten <em>nicht</em> gelöscht werden.</p></div><div class=paragraph><p>Falls es einfacher erscheint, können die <code>bmake</code>-<span class=filename>Makefile</span>s vom Verzeichnisbaum durch einige Dienstprogramme automatisch erstellt werden, was es hoffentlich sogar noch einfacher macht, eine Version zu aktualisieren. Ist dies geschehen, so stellen Sie bitte sicher, diese Werkzeuge in das Verzeichnis <span class=filename>src/tools</span> gleich mit dem Port an sich einzuchecken, sodass es für zukünftige Maintainer verfügbar ist.</p></div><div class=paragraph><p>Im Verzeichnis <span class=filename>src/contrib/file</span> sollte eine Datei mit dem Namen <span class=filename>FREEBSD-upgrade</span> hinzugefügt werden und sie sollte den Stand wie folgt anzeigen:</p></div><div class=ulist><ul><li><p>Welche Dateien ausgelassen wurden.</p></li><li><p>Von wo die Original-Distribution stammt und/oder wo die offizielle Hauptseite zu finden ist.</p></li><li><p>Wohin Fehlerbehebungen an den Originalautor gesendet werden können.</p></li><li><p>Möglicherweise eine Übersicht, welche FreeBSD-spezifischen Änderungen vorgenommen wurden.</p></li></ul></div><div class=paragraph><p>Ein Beispielinhalt von <span class=filename>src/contrib/groff/FREEBSD-upgrade</span> ist hier aufgelistet:</p></div><div class="literalblock programlisting"><div class=content><pre>$FreeBSD: src/contrib/groff/FREEBSD-upgrade,v 1.5.12.1 2005/11/15 22:06:18 ru Exp $

This directory contains virgin sources of the original distribution files
on a &#34;vendor&#34; branch.  Do not, under any circumstances, attempt to upgrade
the files in this directory via patches and a cvs commit.

To upgrade to a newer version of groff, when it is available:
        1. Unpack the new version into an empty directory.
           [Do not make ANY changes to the files.]

        2. Use the command:
                cvs import -m &#39;Virgin import of FSF groff v&lt;version&gt;&#39; \
                        src/contrib/groff FSF v&lt;version&gt;

           For example, to do the import of version 1.19.2, I typed:
                cvs import -m &#39;Virgin import of FSF groff v1.19.2&#39; \
                        src/contrib/groff FSF v1_19_2

        3. Follow the instructions printed out in step 2 to resolve any
           conflicts between local FreeBSD changes and the newer version.

Do not, under any circumstances, deviate from this procedure.

To make local changes to groff, simply patch and commit to the main
branch (aka HEAD).  Never make local changes on the FSF branch.

All local changes should be submitted to Werner Lemberg &lt;wl@gnu.org&gt; or
Ted Harding &lt;ted.harding@nessie.mcc.ac.uk&gt; for inclusion in the next
vendor release.

ru@FreeBSD.org - 20 October 2005</pre></div></div><div class=paragraph><p>Eine weitere Möglichkeit ist es, eine Liste von Dateien, die nicht enthalten sein sollen zu pflegen, was besonders dann sehr hilfreich sein kann, wenn die Liste ziemlich gross oder kompliziert ist bzw. Imports sehr häufig stattfinden. Durch erstellen einer Datei namens <span class=filename>FREEBSD-Xlist</span> im gleichen Verzeichnis, in welches das Herstellerverzeichnis importiert werden soll, die eine Liste von auszuschliessenden Dateinamen-Mustern pro Zeile enthält, können zukünftige Imports folgendermassen durchgeführt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>tar</span> <span class=nt>-X</span> FREEBSD-Xlist <span class=nt>-xzf</span> vendor-source.tgz</code></pre></div></div><div class=paragraph><p>Als Beispiel einer <span class=filename>FREEBSD-Xlist</span>-Datei wird hier diejenige von <span class=filename>src/contrib/tcsh</span> gezeigt:</p></div><div class="literalblock programlisting"><div class=content><pre>*/BUGS
*/config/a*
*/config/bs2000
*/config/bsd
*/config/bsdreno
*/config/[c-z]*
*/tests
*/win32</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bitte importieren Sie weder <span class=filename>FREEBSD-upgrade</span> noch <span class=filename>FREEBSD-Xlist</span> mit den beigesteuerten Quellen. Stattdessen sollten Sie diese Dateien nach dem initialen Import hinzufügen.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=vendor-import-svn>5.3.2. Herstellerimports mit SVN<a class=anchor href=#vendor-import-svn></a></h4><div class=paragraph><p>Dieser Abschnitt beschreibt die Prozedur für Herstellerimports mit Subversion im Detail.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Vorbereiten des Quellbaums</p><div class=paragraph><p>Wenn dies Ihr erster Import nach dem Wechsel zu SVN ist, sollen Sie den Herstellerbaum aufräumen, verflachen und die Merge-Historie in den Hauptzweig vorbereiten. Falls das nicht Ihr erster Import ist, können Sie diesen Schritt ohne Probleme überspringen.</p></div><div class=paragraph><p>Während der Konvertierung von CVS zu SVN wurden Herstellerzweige mit der gleichen Struktur wie der Hauptzweig importiert. Beispielsweise wurden die foo Herstellerquellen in <span class=filename>vendor/foo/dist/contrib/foo</span> abgelegt, jedoch ist dies unpraktisch und zwecklos. Was wir wirklich wollen, ist dass die Herstellerquellen direkt in <span class=filename>vendor/foo/dist</span> liegen, beispielsweise so:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>vendor/foo/dist/contrib/foo
% svn move <span class=si>$(</span>svn list<span class=si>)</span> ../..
% <span class=nb>cd</span> ../..
% svn remove contrib
% svn propdel <span class=nt>-R</span> svn:mergeinfo
% svn commit</code></pre></div></div><div class=paragraph><p>Beachten Sie, dass das <code>propdel</code>-Bit notwendig ist, da mit Subversion 1.5 automatisch <code>svn:mergeinfo</code> zu jedem Verzeichnis hinzugefügt wird, das Sie kopieren oder verschieben. In diesem Fall brauchen Sie diese Informationen nicht, da Sie nichts in den Zweig mergen werden, den Sie gelöscht haben.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sie werden wahrscheinlich die Tags genauso verflachen wollen. Die Prozedur dafür ist die selbe. Wenn Sie dies tun, sollten Sie den Commit bis zum Schluss aufschieben.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Prüfen Sie den <span class=filename>dist</span>-Baum und führen Sie alle nötigen Aufräumarbeiten durch, die Sie für sinnvoll erachten. Sie werden möglicherweise die Erweiterung von Schlüsselwörtern deaktivieren wollen, da dies auf unmodifizierten Quellen keinen Sinn ergibt. In machen Fällen kann dies sogar schädlich sein.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% svn propdel svn:keywords <span class=nt>-R</span> <span class=nb>.</span>
% svn commit</code></pre></div></div><div class=paragraph><p>Bootstrappen der <code>svn:mergeinfo</code> auf dem Zielverzeichnis (des Hauptzweiges) auf die Revision die mit der letzten Änderung, die im Herstellerzweig vor dem Import der neuen Quellen durchgeführt wurde, korrespondiert, wird ebenso benötigt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd head</span>/contrib/foo
% svn merge <span class=nt>--record-only</span> svn_base/vendor/foo/dist@12345678 <span class=nb>.</span>
% svn commit</code></pre></div></div><div class=paragraph><p>Dabei entspricht <em>svn_base</em> dem Basisverzeichnis Ihres SVN-Repositories, z.B. <code>svn+ssh://svn.FreeBSD.org/base</code>.</p></div></li><li><p>Neue Quellen importieren</p><div class=paragraph><p>Bereiten Sie einen kompletten, sauberen Baum mit Herstellerquellen vor. Mit SVN können wir eine komplette Distribution in dem Herstellerzweig aufbewahren, ohne den Hauptzweig aufzublähen. Importieren Sie alles, aber mergen Sie nur das, was wirklich benötigt wird.</p></div><div class=paragraph><p>Beachten Sie, dass Sie alle Dateien, die seit dem letzten Herstellerimport hinzugefügt wurden, auch einbeziehen und diejenigen, welche entfernt wurden, auch löschen müssen. Um dies zu bewerkstelligen, sollten Sie sortierte Listen der Bestandteile des Herstellerbaums und von den Quellen, Sie die vorhaben zu importieren, vorbereiten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>vendor/foo/dist
% svn list <span class=nt>-R</span> | <span class=nb>grep</span> <span class=nt>-v</span> <span class=s1>&#39;/$&#39;</span> | <span class=nb>sort</span> <span class=o>&gt;</span> ../old
% <span class=nb>cd</span> ../foo-9.9
% find <span class=nb>.</span> <span class=nt>-type</span> f | <span class=nb>cut</span> <span class=nt>-c</span> 3- | <span class=nb>sort</span> <span class=o>&gt;</span> ../new</code></pre></div></div><div class=paragraph><p>Mit diesen beiden Dateien, wird Ihnen das folgende Kommando alle Dateien auflisten, die entfernt wurden (nur die Dateien in <span class=filename>old</span>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>comm</span> <span class=nt>-23</span> ../old ../new</code></pre></div></div><div class=paragraph><p>Der folgende Befehl wird die hinzugefügten Dateien auflisten (nur diejenigen Dateien in <span class=filename>new</span>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>comm</span> <span class=nt>-13</span> ../old ../new</code></pre></div></div><div class=paragraph><p>Wir führen dies nun zusammen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>vendor/foo/foo-9.9
% <span class=nb>tar </span>cf - <span class=nb>.</span> | <span class=nb>tar </span>xf - <span class=nt>-C</span> ../dist
% <span class=nb>cd</span> ../dist
% <span class=nb>comm</span> <span class=nt>-23</span> ../old ../new | xargs svn remove
% <span class=nb>comm</span> <span class=nt>-13</span> ../old ../new | xargs svn add</code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Wenn in der neuen Version neue Verzeichnisse hinzugekommen sind, wird dieser letzte Befehl fehlschlagen. Sie müssen diese Verzeichnisse hinzufügen und anschliessend den Befehl erneut ausführen. Genauso müssen Sie Verzeichnisse, die entfernt wurden, händisch löschen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Prüfen Sie die Eigenschaften jeder neuen Datei:</p></div><div class=ulist><ul><li><p>Alle Textdateien sollten <code>svn:eol-style</code> auf den Wert <code>native</code> gesetzt haben.</p></li><li><p>Alle Binärdateien sollten <code>svn:mime-type</code> auf <code>application/octet-stream</code> gesetzt haben, ausser es existiert ein passenderer Medientyp.</p></li><li><p>Ausführbare Dateien sollten <code>svn:executable</code> auf <code>*</code> gesetzt haben.</p></li><li><p>Es sollten keine anderen Eigenschaften auf den Dateien im Baum gesetzt sein.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sie sind bereit, zu committen, jedoch sollten Sie zuerst die Ausgabe von <code>svn stat</code> und <code>svn diff</code> überprüfen, um sicher zu gehen, dass alles in Ordnung ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald Sie den die neue Release-Version des Herstellers committed haben, sollten Sie Ihn für zukünftige Referenzen taggen. Die beste und schnellste Methode ist, dies direkt im Repository zu tun:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% svn copy svn_base/vendor/foo/dist svn_base/vendor/foo/9.9</code></pre></div></div><div class=paragraph><p>Um den neuen Tag zu bekommen, brauchen Sie nur ihre Arbeitskopie von <span class=filename>vendor/foo</span> zu aktualisieren.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie lieber die Kopie in der ausgecheckten Kopie durchführen wollen, vergessen Sie nicht, die generierte <code>svn:mergeinfo</code> wie oben beschrieben zu entfernen.</p></div></td></tr></tbody></table></div></li></ul></div></li><li><p>Mit <em>-HEAD</em> mergen</p><div class=paragraph><p>Nachdem Sie Ihren Import vorbereitet haben, wird es Zeit zu mergen. Die Option <code>--accept=postpone</code> weist SVN an, noch keine merge-Konflikte aufzulösen, weil wir uns um diese manuell kümmern werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd head</span>/contrib/foo
% svn update
% svn merge <span class=nt>--accept</span><span class=o>=</span>postpone svn_base/vendor/foo/dist</code></pre></div></div><div class=paragraph><p>Lösen Sie die Konflikte und stellen Sie sicher, dass alle Dateien, die im Herstellerzweig hinzugefügt oder entfernt wurden, auch sauber im Hauptzweig hinzugefügt bzw. gelöscht wurden. Es ist immer ratsam, diese Unterschiede gegen den Herstellerbaum zu prüfen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% svn diff <span class=nt>--no-diff-deleted</span> <span class=nt>--old</span><span class=o>=</span>svn_base/vendor/foo/dist <span class=nt>--new</span><span class=o>=</span>.</code></pre></div></div><div class=paragraph><p>Die Option <code>--no-diff-deleted</code> weist SVN an, keine Dateien zu prüfen, die sich zwar im Herstellerbaum, aber nicht im Hauptzweig befinden.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bei SVN gibt es das Konzept von innerhalb und ausserhalb des Herstellerbaums nicht. Wenn eine Datei, die zuvor eine lokale Änderung hatte, aber nun keine mehr besitzt, entfernen Sie einfach das was übrig ist, wie FreeBSD Versionstags, damit diese nicht länger in den diffs gegen den Herstellerbaum erscheinen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn irgendwelche Änderungen notwendig sind, um die Welt mit den neuen Quellen zu bauen, machen Sie diese jetzt und testen Sie diese bis Sie sicher sind, dass alles korrekt gebaut wird und richtig funktionert.</p></div></li><li><p>Commit</p><div class=paragraph><p>Nun sind Sie bereit für den Commit. Stellen Sie sicher, dass Sie alles in einem einzigen Schritt durchführen. Idealerweise sollten Sie alle diese Schritte in einem sauberen Baum durchgeführt haben. Falls dies der Fall ist, können Sie einfach aus dem obersten Verzeichnis dieses Baums committen. Dies ist der beste Weg, um Überraschungen zu vermeiden. Wenn Sie dies korrekt durchführen, wird der Baum atomar von einem konsistenten Zustand mit dem alten Code in einen neuen konsistenten Zustand mit dem neuen Code überführt.</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=policies-encumbered>5.4. Belastende Dateien<a class=anchor href=#policies-encumbered></a></h3><div class=paragraph><p>Es kann gelegentlich notwendig sein, belastende Dateien in den FreeBSD-Quelltextbaum zu integrieren. Braucht ein Gerät zum Beispiel ein Stück binären Code, der zuerst geladen werden muss, bevor das Gerät funktioniert, und wir haben keine Quellen zu diesem Code, dann wird die binäre Datei als belastend bezeichnet. Die folgenden Richtlinien sind beim Aufnehmen von belastenden Dateien in den FreeBSD-Quelltextbaum zu beachten.</p></div><div class="olist arabic"><ol class=arabic><li><p>Jede Datei, die durch die System-CPU(s) ausgeführt wird und nicht als Quelltext vorliegt, ist belastend.</p></li><li><p>Jede Datei, deren Lizenz restriktiver ist als die BSD- oder GNU-Lizenz, ist belastend.</p></li><li><p>Eine Datei, die herunterladbare Binär-Daten enthält, ist nur belastend, wenn (1) oder (2) zutreffen. Sie muss in einem ASCII-Format gespeichert werden, das Architektur-neutral ist (file2c oder uuencoding wird empfohlen).</p></li><li><p>Jede belastende Datei braucht eine spezielle Genehmigung vom <a href=https://www.FreeBSD.org/administration/#t-core>Core-Team</a>, bevor diese in das Repository aufgenommen werden darf.</p></li><li><p>Belastende Dateien liegen unter <span class=filename>src/contrib</span> oder <span class=filename>src/sys/contrib</span>.</p></li><li><p>Das komplette Modul sollte auch am Stück aufbewahrt werden. Es gibt keinen Grund, dieses zu teilen, außer es gibt einen Code-Austausch mit Quelltext, der nicht belastend ist.</p></li><li><p>Objekt-Dateien werden wie folgt benannt: <span class=filename>arch/filename.o.uu></span>.</p></li><li><p>Kernel-Dateien:</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Sollten immer nach <span class=filename>conf/files.*</span> verweisen (um den Bau einfach zu halten).</p></li><li><p>Sollten sich immer in <span class=filename>LINT</span> befinden, jedoch entscheidet das <a href=https://www.FreeBSD.org/administration/#t-core>Core-Team</a> je nach Fall, ob es auskommentiert wird oder nicht. Das <a href=https://www.FreeBSD.org/administration/#t-core>Core-Team</a> kann sich zu einem späteren Zeitpunkt immer noch anders entscheiden.</p></li><li><p>Der <em>Release-Engineer</em> entscheidet, ob es in ein Release aufgenommen wird oder nicht.</p></li></ol></div></li><li><p>Userland-Dateien:</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Das <a href=https://www.FreeBSD.org/administration/#t-core>Core-Team</a> entscheidet, ob der Code von <code>make world</code> gebaut wird oder nicht.</p></li><li><p>Der <a href=https://www.FreeBSD.org/administration/#t-re>Release-Engineer</a> entscheidet, ob es in das Release aufgenommen wird oder nicht.</p></li></ol></div></li></ol></div></div><div class=sect2><h3 id=policies-shlib>5.5. Shared-Libraries<a class=anchor href=#policies-shlib></a></h3><div class=paragraph><p>Sollten Sie die Unterstützung für Shared-Libraries bei einem Port oder einem Stück Software, das dies nicht hat, hinzufügen, sollten die Versionsnummern dessen Regeln folgen. Im Allgemeinen hat die sich daraus resultierende Nummer nichts mit der Release-Version der Software zu tun.</p></div><div class=paragraph><p>Die drei Grundsätze zum Erstellen von Shared-Libraries sind:</p></div><div class=ulist><ul><li><p>Sie beginnen mit <code>1.0</code>.</p></li><li><p>Gibt es eine Änderung, die abwärtskompatibel ist, so springen Sie zur nächsten Minor-Version (beachten Sie, dass ELF-Systeme die Minor-Version ignorieren).</p></li><li><p>Gibt es eine inkompatible Änderung, so springen Sie bitte zur nächsten Major-Version.</p></li></ul></div><div class=paragraph><p>Zum Beispiel wird beim Hinzufügen von Funktionen und oder Fehlerbehebungen zur nächsten Minor-Version gesprungen, beim Löschen einer Funktion, Ändern von Funktionsaufrufen usw. ändert sich die Major-Version.</p></div><div class=paragraph><p>Bleiben Sie bei Versionsnummern in der Form major.minor (<em>x</em>.<em>y</em>). Unser dynamischer Linker a.out kann mit Versionsnummern in der Form <em>x</em>.<em>y</em>.<em>z</em> nicht gut umgehen. Jede Versionsnummer nach dem <em>y</em> (die dritte Zahl) wird völlig ignoriert, wenn Versionsnummern der Shared-Libraries verglichen werden, um zu bestimmen, mit welcher Bibliothek eine Anwendung verlinkt wird. Sind zwei Shared-Libraries vorhanden, die sich nur in der "micro"-Revision unterscheiden, so wird <code>ld.so</code> zu der höheren verlinken. Dies bedeutet, dass wenn Sie mit <span class=filename>libfoo.so.3.3.3</span> verlinken, der Linker nur <code>3.3</code> in den Header aufnimmt und alles linkt, was mit <em>libfoo.so.3</em> .<em>(irgendetwas >= 3)</em>.<em>(höchste verfügbare Nummer)</em> beginnt.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>ld.so</code> wird immer die höchste "Minor"-Revision benutzen. Beispielsweise wird es die <span class=filename>libc.so.2.2</span> bevorzugen gegenüber der <span class=filename>libc.so.2.0</span>, auch dann, wenn das Programm ursprünglich mit <span class=filename>libc.so.2.0</span> verlinkt war.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Unser dynamischer ELF-Linker kann keine Minor-Versionen handhaben. Dennoch sollten die Major- und Minor-Versionen genutzt werden, da unsere <span class=filename>Makefile</span>s "das Richtige machen" bezogen auf den Systemtyp.</p></div><div class=paragraph><p>Für nicht-Port-Bibliotheken lautet die Richtlinie, die Shared-Library-Versionsnummer nur einmal zwischen den Releases zu ändern. Weiterhin ist es vorgeschrieben, die Major-Version der Shared-Libraries nur bei Major-OS-Releases zu ändern (beispielsweise von 6.0 auf 7.0). Wenn Sie also eine Änderung an einer Systembibliothek vornehmen, die eine neue Versionsnummer benötigt, überprüfen Sie die Commit-Logs des <span class=filename>Makefile</span>s. Es liegt in der Verantwortung des Committers, dass sich eine erste solche Änderung seit dem letzten Release in der aktualisierten Versionsnummer der Shared-Library im <span class=filename>Makefile</span> äußert, folgende Änderungen werden nicht berücksichtigt.</p></div></div></div></div><div class=sect1><h2 id=testing>Kapitel 6. Regressions- und Performance-Tests<a class=anchor href=#testing></a></h2><div class=sectionbody><div class=paragraph><p>Regressions-Tests werden durchgeführt, um zu überprüfen, ob ein bestimmter Teil des Systems wie erwartet funktioniert, und um sicherzustellen, dass bereits beseitigte Fehler nicht wieder eingebaut werden.</p></div><div class=paragraph><p>Die FreeBSD-Regressions-Testwerkzeuge finden Sie im FreeBSD-Quelltextbaum unter <span class=filename>src/tools/regression</span>.</p></div><div class=sect2><h3 id=testing-micro-benchmark>6.1. Mikro-Benchmark-Checkliste<a class=anchor href=#testing-micro-benchmark></a></h3><div class=paragraph><p>Dieser Abschnitt enthält Tipps, wie ordnungsgemäße Mikro-Benchmarks unter FreeBSD oder für FreeBSD selbst erstellt werden.</p></div><div class=paragraph><p>Es ist nicht möglich, immer alle der folgenden Vorschläge zu berücksichtigen, aber je mehr davon, desto besser wird der Benchmark kleine Unterschiede nachweisen können.</p></div><div class=ulist><ul><li><p>Schalten Sie APM und alles andere, das den Systemtakt beeinflusst, ab (ACPI?).</p></li><li><p>Starten Sie in den Single-User-Modus. <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> und andere Systemdienste verursachen nur Störungen. Genauso der <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>-Systemdienst. Falls während des Tests SSH-Zugriff benötigt wird, schalten Sie entweder die Neuerstellung des SSHv1-Schlüssels ab oder beenden Sie den <code>sshd</code>-Elternprozess während der Tests.</p></li><li><p>Beenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>.</p></li><li><p>Falls <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a>-Ereignisse erzeugt werden, starten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> mit leerer <span class=filename>/etc/syslogd.conf</span> oder beenden Sie es.</p></li><li><p>Sorgen Sie für möglichst wenig Disk-I/O; vermeiden Sie es ganz wenn möglich.</p></li><li><p>Hängen Sie keine Dateisysteme ein, die Sie nicht benötigen.</p></li><li><p>Hängen Sie <span class=filename>/</span>, <span class=filename>/usr</span> und die anderen Dateisysteme nur lesbar ein wenn möglich. Dies verhindert, dass atime-Aktualisierungen auf der Festplatte (usw.) das Ergebnis verfälschen.</p></li><li><p>Initialisieren Sie das beschreibbare Test-Dateisystem mit <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> neu und füllen Sie es aus einer <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>- oder <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>-Datei vor jedem Lauf. Hängen Sie es aus und wieder ein, bevor Sie den Test starten. Dies sorgt für einen konsistenten Dateisystemaufbau. Bei einem "worldstone"-Test bezieht sich dies auf <span class=filename>/usr/obj</span> (Initialisieren Sie es einfach mit <code>newfs</code> neu und hängen Sie es ein). Um absolut reproduzierbare Ergebnisse zu bekommen, füllen Sie das Dateisystem aus einer <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a>-Datei (d.h. <code>dd if=myimage of=/dev/ad0s1h bs=1m</code>).</p></li><li><p>Benutzen Sie malloc-gestützte oder vorbelastete <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>-Partitionen.</p></li><li><p>Starten Sie zwischen den einzelnen Durchläufen neu, dies sichert einen konsistenteren Zustand.</p></li><li><p>Entfernen Sie alle nicht unbedingt benötigten Gerätetreiber aus dem Kernel. Wenn z.B. USB für den Test nicht benötigt wird, entfernen Sie es aus dem Kernel. Gerätetreiber, die sich Hardware zuteilen, haben oft "tickende" Timeouts.</p></li><li><p>Konfigurieren Sie nicht Hardware, die nicht benutzt wird. Entfernen Sie Festplatten mit <a href="https://man.freebsd.org/cgi/man.cgi?query=atacontrol&amp;sektion=8&amp;format=html">atacontrol(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a>, wenn diese für den Test nicht gebraucht werden.</p></li><li><p>Konfigurieren Sie nicht das Netzwerk, es sei denn es wird getestet, oder warten Sie, bis der Test fertig ist, wenn Sie das Ergebnis auf einen anderen Rechner übertragen wollen.</p><div class=paragraph><p>Falls das System an ein öffentliches Netzwerk angeschlossen sein muss, achten Sie auf Spitzen im Broadcast-Verkehr. Obwohl dieser kaum auffällt, wird er CPU-Zyklen brauchen. Ähnliches gilt für Multicast.</p></div></li><li><p>Legen Sie jedes Dateisystem auf eine eigene Festplatte. Dies minimiert Jitter durch Optimierungen von Lesekopfbewegungen.</p></li><li><p>Minimieren Sie Ausgaben auf serielle oder VGA-Konsolen. Ausgabenumleitung in Dateien ergibt weniger Jitter (serielle Konsolen werden leicht zum Flaschenhals). Benutzen Sie die Tastatur nicht, während der Test läuft, sogar <kbd>space</kbd> oder <kbd>back-space</kbd> wirken sich auf die Ergebnisse aus.</p></li><li><p>Stellen Sie sicher, dass der Test lang genug läuft, aber nicht zu lange. Wenn er zu kurz ist, sind Zeitstempel ein Problem. Wenn er zu lang ist, werden Temperaturänderungen und Drift die Frequenz von Quarzkristallen im Rechner beeinflussen. Daumenregel: mehr als eine Minute, weniger als eine Stunde.</p></li><li><p>Versuchen Sie, die Temperatur in der Umgebung des Rechners so stabil wie möglich zu halten. Diese beeinflusst sowohl Quarzkristalle als auch Festplatten-Algorithmen. Um einen wirklich stabilen Takt zu erhalten, wäre es auch möglich, einen stabilisierten Takt anzuschließen. D.h. besorgen Sie sich einen OCXO + PLL und koppeln Sie das Ausgangssignal mit den Taktgeberschaltkreisen anstelle des Quarzkristalls der Hauptplatine. Wenden Sie sich an Poul-Henning Kamp &lt;<a href=mailto:phk@FreeBSD.org>phk@FreeBSD.org</a>>, wenn Sie mehr Informationen hierüber benötigen.</p></li><li><p>Lassen Sie den Test mindestens drei Mal laufen, besser mehr als 20 Mal, sowohl für "vor" als auch für "nach" dem Code. Versuchen Sie abzuwechseln (d.h. nicht erst 20 Mal "vorher" und dann 20 Mal "nachher"), dies ermöglicht, umgebungsbedingte Effekte zu erkennen. Wechseln Sie nicht 1:1 ab, sondern 3:3; dies erlaubt, Wechselwirkungseffekte zu erkennen.</p><div class=paragraph><p>Ein gutes Muster ist: <code>bababa{bbbaaa}*</code>. Dies gibt Hinweise nach den ersten 1+1-Läufen (sodass Sie den Test stoppen können, falls er völlig daneben geht), Sie können die Standardabweichung nach den ersten 3+3-Läufen überprüfen (zeigt an, ob sich ein längerer Lauf lohnt), später Trends und Wechselwirkungen.</p></div></li><li><p>Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ministat&amp;sektion=1&amp;format=html">ministat(1)</a>, um festzustellen, ob Ihre Ergebnisse signifikant sind. Überlegen Sie sich, das Buch "Cartoon guide to statistics" ISBN: 0062731025 zu kaufen. Es ist sehr empfehlenswert, falls Sie Dinge wie Standardabweichung und Studentsche t-Verteilung vergessen oder nie gelernt haben.</p></li><li><p>Benutzen Sie keinen Hintergrund-<a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, wenn Sie ihn nicht selbst testen wollen. Schalten Sie auch <code>background_fsck</code> in <span class=filename>/etc/rc.conf</span> aus, es sei denn der Benchmark wird nicht mindestens 60+"Laufzeit von <code>fsck</code>" Sekunden nach Systemstart gestartet, da <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> startet und prüft, ob <code>fsck</code> auf irgendeinem der Dateisysteme laufen muss, wenn Hintergrund-<code>fsck</code> eingeschaltet ist. Stellen Sie ebenfalls sicher, dass keine Snapshots herumliegen, falls der Benchmark nicht ein Test mit Snapshots ist.</p></li><li><p>Falls der Benchmark unerwartet schlechte Performance zeigt, überprüfen Sie Dinge wie große Mengen Interrupts von unerwarteten Quellen. Es gibt Berichte, dass einige ACPI-Versionen sich "daneben benehmen" und ein Übermaß an Interrupts erzeugen. Um zu helfen, ungewöhnliche Testergebnisse zu diagnostizieren, machen Sie ein paar Momentaufnahmen von <code>vmstat -i</code> und suchen Sie nach Ungewöhnlichem.</p></li><li><p>Gehen Sie mit Parametern zur Optimierung von Kernel, Userland und Fehlersuche vorsichtig um. Es passiert schnell, irgendetwas durchrutschen zu lassen und dann später festzustellen, dass der Test nicht das gleiche verglichen hat.</p></li><li><p>Erstellen Sie nie Benchmarks unter Verwendung der Kernel-Optionen <code>WITNESS</code> und <code>INVARIANTS</code>, wenn der Test nicht diese Merkmale selbst untersuchen soll. <code>WITNESS</code> kann zu 400% und mehr Performance-Abnahme führen. Ähnliches gilt für Userland-<a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=3&amp;format=html">malloc(3)</a>-Parameter, Voreinstellungen hierbei unterscheiden sich bei -CURRENT von denen bei Production-Releases.</p></li></ul></div></div></div></div><h1 id=ipc class=sect0>Teil II: Interprozess-Kommunikation<a class=anchor href=#ipc></a></h1><div class=sect1><h2 id=sockets>Kapitel 7. Sockets<a class=anchor href=#sockets></a></h2><div class=sectionbody><div class=paragraph><p>Dieses Kapitel ist noch nicht übersetzt. Lesen Sie bitte <a href=#sockets>das Original in englischer Sprache</a>. Wenn Sie helfen wollen, dieses Kapitel zu übersetzen, senden Sie bitte eine E-Mail an die Mailingliste FreeBSD German Documentation Project &lt;<a href=mailto:de-bsd-translators@de.FreeBSD.org>de-bsd-translators@de.FreeBSD.org</a>>.</p></div></div></div><div class=sect1><h2 id=ipv6>Kapitel 8. IPv6 Internals<a class=anchor href=#ipv6></a></h2><div class=sectionbody><div class=sect2><h3 id=ipv6-implementation>8.1. IPv6/IPsec-Implementierung<a class=anchor href=#ipv6-implementation></a></h3><div class=paragraph><p>Dieser Abschnitt erklärt die von der IPv6- und IPsec-Implementierung abhängigen Internas. Die Funktionalitäten wurden vom <a href=http://www.kame.net/>KAME-Projekt</a> abgeleitet</p></div><div class=sect3><h4 id=ipv6details>8.1.1. IPv6<a class=anchor href=#ipv6details></a></h4><div class=sect4><h5 id=_konformität>8.1.1.1. Konformität<a class=anchor href=#_konformität></a></h5><div class=paragraph><p>Die IPv6 abhängigen Funktionen richten sich nach, oder versuchen sich nach den neuesten IPv6-Spezifikationen zu richten. (<em>Achtung</em>: Dies ist keine vollständige Liste - es wäre zu aufwändig, diese zu pflegen…​).</p></div><div class=paragraph><p>Für weitere Details beachten sie bitte die entsprechenden Kapitel, RFCs, manual pages, oder Kommentare in den Quelltexten.</p></div><div class=paragraph><p>Konformitätsprüfungen wurden basierend auf KAME-STABLE-Kit des TAHI-Projekts durchgeführt. Die Ergebnisse können unter <a href=http://www.tahi.org/report/KAME/>http://www.tahi.org/report/KAME/</a> eingesehen werden. In der Vergangenheit begleiteten wir auch Tests mit unseren älteren "Snapshots" an der Univ. of New Hampshire IOL (<a href=http://www.iol.unh.edu/>http://www.iol.unh.edu/</a>).</p></div><div class=ulist><ul><li><p>RFC1639: FTP Operation Over Big Address Records (FOOBAR)</p><div class=ulist><ul><li><p>RFC2428 wird gegenüber RFC1639 bevorzugt. FTP-Clients versuchen zuerst RFC2428, dann im Fehlerfall RFC1639.</p></li></ul></div></li><li><p>RFC1886: DNS Extensions to support IPv6</p></li><li><p>RFC1933: Transition Mechanisms for IPv6 Hosts and Routers</p><div class=ulist><ul><li><p>IPv4 kompatible Adressen werden nicht unterstützt.</p></li><li><p>Automatisches Tunneln (beschrieben in 4.3 dieses RFC) wird nicht unterstützt.</p></li><li><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a>-Schnittstelle implementiert einen IPv[46]-over-IPv[46] Tunnel in einer allgemeinen Art und Weise und es umfaßt "configured tunnel" wie in der Spezifikation beschrieben. Siehe auch <a href=#gif>23.5.1.5</a> in diese Dokument für weitere Details.</p></li></ul></div></li><li><p>RFC1981: Path MTU Discovery for IPv6</p></li><li><p>RFC2080: RIPng for IPv6</p><div class=ulist><ul><li><p>usr.sbin/route6d unterstützt dies.</p></li></ul></div></li><li><p>RFC2292: Advanced Sockets API for IPv6</p><div class=ulist><ul><li><p>Unterstützte Bibliotheksfunktionen bzw. Kernel-APIs, siehe auch <span class=filename>sys/netinet6/ADVAPI</span>.</p></li></ul></div></li><li><p>RFC2362: Protocol Independent Multicast-Sparse Mode (PIM-SM)</p><div class=ulist><ul><li><p>RFC2362 definiert Paketformate für PIM-SM. <span class=filename>draft-ietf-pim-ipv6-01.txt</span> wurde basierend auf diesem RFC verfaßt.</p></li></ul></div></li><li><p>RFC2373: IPv6 Addressing Architecture</p><div class=ulist><ul><li><p>Unterstützt vom Knoten erforderliche Adressen und richtet sich nach den Erfordernissen des Bereichs.</p></li></ul></div></li><li><p>RFC2374: An IPv6 Aggregatable Global Unicast Address Format</p><div class=ulist><ul><li><p>Unterstützt die 64-Bit-Breite einer Interface ID.</p></li></ul></div></li><li><p>RFC2375: IPv6 Multicast Address Assignments</p><div class=ulist><ul><li><p>Userland-Applikationen nutzen die bekannten Adressen, die in den RFC festgelegt sind.</p></li></ul></div></li><li><p>RFC2428: FTP Extensions for IPv6 and NATs</p><div class=ulist><ul><li><p>RFC2428 wird gegenüber RFC1639 bevorzugt. FTP-Clients versuchen zuerst RFC2428, dann im Fehlerfall RFC1639.</p></li></ul></div></li><li><p>RFC2460: IPv6 specification</p></li><li><p>RFC2461: Neighbor discovery for IPv6</p><div class=ulist><ul><li><p>Siehe auch <a href=#neighbor-discovery>23.5.1.2</a> in diesem Dokument für weitere Details.</p></li></ul></div></li><li><p>RFC2462: IPv6 Stateless Address Autoconfiguration</p><div class=ulist><ul><li><p>Siehe auch <a href=#ipv6-pnp>23.5.1.4</a> in diesem Dokument für weitere Details.</p></li></ul></div></li><li><p>RFC2463: ICMPv6 for IPv6 specification</p><div class=ulist><ul><li><p>Siehe auch <a href=#icmpv6>23.5.1.9</a> in diesem Dokument für weitere Details.</p></li></ul></div></li><li><p>RFC2464: Transmission of IPv6 Packets over Ethernet Networks</p></li><li><p>RFC2465: MIB for IPv6: Textual Conventions and General Group</p><div class=ulist><ul><li><p>Notwendige Statistiken werden vom Kernel gesammelt. Die aktuelle IPv6-MIB-Unterstützung wird als Patch-Sammlung für ucd-snmp bereitgestellt.</p></li></ul></div></li><li><p>RFC2466: MIB for IPv6: ICMPv6 group</p><div class=ulist><ul><li><p>Notwendige Statistiken werden vom Kernel gesammelt. Die aktuelle IPv6-MIB-Unterstützung wird als Patch-Sammlung für ucd-snmp bereitgestellt.</p></li></ul></div></li><li><p>RFC2467: Transmission of IPv6 Packets over FDDI Networks</p></li><li><p>RFC2497: Transmission of IPv6 packet over ARCnet Networks</p></li><li><p>RFC2553: Basic Socket Interface Extensions for IPv6</p><div class=ulist><ul><li><p>IPv4 mapped address (3.7) and special behavior of IPv6 wildcard bind socket (3.8) are supported. See <a href=#ipv6-wildcard-socket>23.5.1.12</a> in this document for details.</p></li></ul></div></li><li><p>RFC2675: IPv6 Jumbogramms</p><div class=ulist><ul><li><p>Siehe auch <a href=#ipv6-jumbo>23.5.1.7</a> in diesem Dokument für weitere Details.</p></li></ul></div></li><li><p>RFC2710: Multicast Listener Discovery for IPv6</p></li><li><p>RFC2711: IPv6 router alert option</p></li><li><p><span class=filename>draft-ietf-ipngwg-router-renum-08</span>: Router renumbering for IPv6</p></li><li><p><span class=filename>draft-ietf-ipngwg-icmp-namelookups-02</span>: IPv6 Name Lookups Through ICMP</p></li><li><p><span class=filename>draft-ietf-ipngwg-icmp-name-lookups-03</span>: IPv6 Name Lookups Through ICMP</p></li><li><p><span class=filename>draft-ietf-pim-ipv6-01.txt</span>: PIM for IPv6</p><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pim6dd&amp;sektion=8&amp;format=html">pim6dd(8)</a> implementiert dense mode. <a href="https://man.freebsd.org/cgi/man.cgi?query=pim6sd&amp;sektion=8&amp;format=html">pim6sd(8)</a> implementiert sparse mode.</p></li></ul></div></li><li><p><span class=filename>draft-itojun-ipv6-tcp-to-anycast-00</span>: Unterbrechen einer TCP-Verbindung toward IPv6 anycast address</p></li><li><p><span class=filename>draft-yamamoto-wideipv6-comm-model-00</span></p><div class=ulist><ul><li><p>Beachte <a href=#ipv6-sas>23.5.1.6</a> in deisem Dokument für weitere Deatils.</p></li></ul></div></li><li><p><span class=filename>draft-ietf-ipngwg-scopedaddr-format-00.txt</span>: Eine Erweiterung des Format for IPv6 Scoped Addresses</p></li></ul></div></div><div class=sect4><h5 id=neighbor-discovery>8.1.1.2. Neighbor Discovery<a class=anchor href=#neighbor-discovery></a></h5><div class=paragraph><p>Neighbor Discovery ist weitestgehend stabil. Zur Zeit werden Addressauflösung, Duplicated Address Detection (DAD), und Neighbor Unreachability Detection (NUD) unterstützt. In der näheren Zukunft werden wir Proxy Neighbor Advertisement Unterstützung in den Kernel einbauen und Unsolicited Neighbor Advertisement Übertragungskommandos als Verwaltungsprogramm zur Verfügung stellen.</p></div><div class=paragraph><p>Falls DAD versagt, wird die Adresse als "duplicated" markiert und eine Nachricht wird erzeugt, die an Syslog gesandt wird (und für gewöhnlich an die Konsole). Die "duplicated"-Markierung kann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> überprüft werden. Es liegt in der Verantwortung des Administrators, auf DAD-Fehler zu achten und diese zu beheben. Dieses Verhalten sollte in der näheren Zukunft verbessert werden.</p></div><div class=paragraph><p>Manche Netzwerktreiber verbinden Multicast-Pakete mit sich selbst, sogar, wenn es vorgeschrieben ist, es nicht zu tun (vor allem im Promiscuous-Modus). In solchen Fällen könnte DAD versagen, weil die DAD-Steuerung ein inbound NS packet sieht (eigentlich vom Knoten selber) und betrachtet es als ein Duplikat. Sie könnten sich die #if-Bedingung ansehen, die in sys/netinet6/nd6_nbr.c:nd6_dad_timer() als "Workaround" mit "heuristics" markiert ist (Beachte, dass das Kodefragment im Abschnitt "heuristics" nicht der Spezifikation entspricht).</p></div><div class=paragraph><p>Neighbor Discovery specification (RFC2461) kommuniziert in den folgenden Fällen nicht über neighbor cache handling:</p></div><div class="olist arabic"><ol class=arabic><li><p>Der Knoten empfing ein unverlangtes RS/NS/NA/redirect-Paket ohne Link-Layer-Adresse, wenn kein neighbor cache-Eintrag vorhanden ist.</p></li><li><p>neighbor cache handling bei Geräten ohne Link-Layer-Adresse (wir benötigen einen neighbor cache Eintrag für das IsRouter-Bit)</p></li></ol></div><div class=paragraph><p>Im ersten Fall implemenierten wir einen Workaround basierend auf Diskussionen in der IETF-Ipngwg-Mailing-Liste. Für weitere Details beachten Sie die Kommentare im Quelltext und im Email-Thread, der bei (IPng 7155) mit dem Datum vom 6. Feb 1999 gestartet wurde.</p></div><div class=paragraph><p>IPv6 on-link Erkennungsregel (RFC2461) ist recht unterschiedlich zu Übernahmen im BSD-Netzwerkkode. Zur Zeit wird keine on-link Erkennungsregel unterstützt, bei der die Defaultrouter-Liste leer ist (RFC2461, Abschnitt 5.2, letzter Satz im zweiten Absatz - beachte, dass die Spezifikation das Wort "host" und "Knoten" an mehreren Stellen im Abschnitt mißbraucht).</p></div><div class=paragraph><p>Um mögliche DoS-Attacken und unendliche Schleifen zu verhindern, werden bis jetzt nur 10 Optionen bei ND-Paketen akzeptiert. Deshalb werden nur die ersten 10 Präfixe berücksichtigt, wenn man 20-Präfixoptionen zu RA hinzugefügt hat. Falls das zu Schwierigkeiten führen sollte, dann sollte in der FREEBSD-CURRENT-Mailing-Liste gefragt werden und/oder die Variable nd6_maxndopt in <span class=filename>sys/netinet6/nd6.c</span> modifizieren. Falls die Nachfrage groß genug ist, könnte man einen sysctl-Knopf für die Variable vorsehen.</p></div></div><div class=sect4><h5 id=ipv6-scope-index>8.1.1.3. Bereichsindex<a class=anchor href=#ipv6-scope-index></a></h5><div class=paragraph><p>IPv6 benutzt Adressbereiche (Scoped Addresses). Deshalb ist es sehr wichtig, mit einer IPv6-Adresse einen Bereichsindex anzugeben (Schnittstellenindex für link-local-Adresse, oder einen Lageindex für site-local-Adressen). Ohne einen Bereichsindex ist ein IPv6-Adressbereich für den Kernel zweideutig und dem Kernel ist es nicht möglich, die Ausgabeschnittstelle für ein Paket festzustellen.</p></div><div class=paragraph><p>Gewöhnliche Userland-Anwendungen sollten die erweiterte Programmierschnittstelle (RFC2292) benutzen, um den Bereichsindex oder Schnittstellenindex festzulegen. Für ähnliche Zwecke wurde in RFC2553 sin6_scope_id member in der sockaddr_in6-Struktur definiert. Wie auch immer, die Semantik für sin6_scope_id ist ziemlich wage. Wenn man auf Portierbarkeit der Anwendung achten muß, dann schlagen wir vor, die erweiterte Programmierschnittstelle anstelle von sin6_scope_id zu benutzen.</p></div><div class=paragraph><p>Im Kernel ist ein Schnittstellenindex für link-local scoped-Adressen in das zweite 16bit-Wort (drittes und viertes Byte) der IPv6-Adresse eingebettet. Zum Beispiel sieht man folgendes</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>fe80:1::200:f8ff:fe01:6317</code></pre></div></div><div class=paragraph><p>in der Routing-Tabelle und in der Schnittstellenadress-Struktur (structin6_ifaddr). Oben genannte Adresse ist eine "link-local unicast address" die zu einer Netzwerkschnittstelle gehört, deren Schnittstellenbezeichner 1 (eins) ist. Der eingebettete Index ermöglicht es, IPv6 link local-Adressen über mehrere Schnittstellen hinweg effektiv und mit wenig Änderungen am Kode zu identifizieren.</p></div><div class=paragraph><p>Routing-Dämonen und Konfigurationsprogramme wie <a href="https://man.freebsd.org/cgi/man.cgi?query=route6d&amp;sektion=8&amp;format=html">route6d(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> werden den "eingebetteten" Bereichsindex verändern müssen. Diese Programme benutzen routing sockets und ioctls (wie SIOCGIFADDR_IN6) und die Kernel-Programmierschnittstelle wird IPv6-Adressen, dessen zweites 16-Bit-Word gesetzt ist, zurückgeben. Diese Programmierschnittstellen dienen zur Änderung der Kernel-internen Struktur. Programme, die diese Programmierschnittstellen benutzen, müssen ohnehin auf Unterschiede in den Kerneln vorbereitet sein.</p></div><div class=paragraph><p>Wenn man einen Adressbereich in der Kommandozeile angibt, schreibt man niemals die eingebettete Form (so etwas wie ff02:1::1 or fe80:2::fedc). Man erwartet nicht, dass es funktioniert. Man benutzt immer die Standardform wie ff02::1 oder fe80::fedc, zusammen mit der Kommandozeilenoption, die die Schnittstelle festlegt (wie <code>ping6 -I ne0 ff02::1</code>). Allgemein gilt, wenn ein Kommando keine Kommandozeilenoption hat, um die Ausgabeschnittstelle zu definieren, ist dieses Kommando noch nicht für Adressbereiche bereit. Dies scheint der Prämisse von IPv6 entgegenzustehen. Wir glauben, dass die Spezifikationen einige Verbesserungen benötigen.</p></div><div class=paragraph><p>Einige der Userland-Werkzeuge unterstützen die erweiterte numerische IPv6-Syntax wie sie in <span class=filename>draft-ietf-ipngwg-scopedaddr-format-00.txt</span> beschrieben ist. Man kann die ausgehende Verbindung angeben, indem man den Namen der ausgehenden Schnittstelle wie folgt benutzt: "fe80::1%ne0". Auf diese Art und Weise ist man in der Lage, eine link-local scoped Adresse ohne viele Schwierigkeiten anzugeben.</p></div><div class=paragraph><p>Um die Erweiterungen im eigenen Programm zu nutzen, muss man <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a> mit NI_WITHSCOPEID verwenden. Die Implementierung setzt im Moment eine 1-zu-1 Beziehung zwischen einer Verbindung und einer Schnittstelle voraus, die stärker ist, als es die Spezifikationen beschreiben.</p></div></div><div class=sect4><h5 id=ipv6-pnp>8.1.1.4. Plug and Play<a class=anchor href=#ipv6-pnp></a></h5><div class=paragraph><p>Der grösste Teil der statuslosen IPv6-Adress-Autokonfiguration ist im Kernel implementiert. Neighbor-Discovery-Funktionen sind als ganzes im Kernel implementiert. Router-Advertisement (RA) Eingabe für Hosts ist im Kernel implementiert. Router-Solicitation (RS) Ausgabe für Hosts, RS-Eingabe für Router und RA-Ausgabe für Router ist im Userland implementiert.</p></div><div class=sect5><h6 id=_zuweisung_von_link_local_und_speziellen_adressen>8.1.1.4.1. Zuweisung von link-local und speziellen Adressen<a class=anchor href=#_zuweisung_von_link_local_und_speziellen_adressen></a></h6><div class=paragraph><p>Die IPv6 link-local-Adresse wird aus einer IEEE802-Adresse (Ethernet MAC address) erzeugt. Jeder Schnittstelle wird automatisch eine IPv6 link-local-Adresse zugewiesen, sobald die Schnittstelle aktiv ist (IFF_UP). Ebenso wird eine direkte Route für die link-local-Adresse zur Routing-Tabelle hinzugefügt.</p></div><div class=paragraph><p>Hier ist eine Ausgabe des netstat-Kommandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Internet6:
Destination                   Gateway                   Flags      Netif Expire
fe80:1::%ed0/64               <span class=nb>link</span><span class=c>#1                    UC          ed0</span>
fe80:2::%ep0/64               <span class=nb>link</span><span class=c>#2                    UC          ep0</span></code></pre></div></div><div class=paragraph><p>Schnittstellen, die keine IEEE802-Adresse haben (Pseudo-Schnittstellen wie Tunnel-Schnittstellen oder ppp-Schnittstellen), borgen sich eine IEEE802-Adresse von anderen Schnittstellen wie Ethernet-Schnittstellen aus, wann immer das möglich ist. Wenn keine IEEE802-Geräte eingebaut sind, wird als letzte Möglichkeit eine Pseudo-Zufallszahl - MD5(hostname) - als Quelle für eine link-local-Adresse benutzt. Falls diese für den Einsatz nicht geeignet sein sollte, dann muss man eine link-local-Adresse manuell konfigurieren.</p></div><div class=paragraph><p>Falls eine Schnittstelle nicht imstande ist, IPv6-Adressen zu handhaben (wie fehlende Unterstützung des multicast), wird keine link-local-Adresse der Schnittstelle zugewiesen. Siehe Abschnitt 2 für weitere Details.</p></div><div class=paragraph><p>Jede Schnittstelle verbindet die solicited multicast Adresse und link-local all-nodes multicast-Adressen (z.B. fe80::1:ff01:6317 und ff02::1, jeweils zu der Verbindung, an die die Schnittstelle verbunden ist). zusätzlich zu einer link-local-Adresse wird eine loopback-Adresse (::1) einer loopback-Schnittstelle zugewiesen. Außerdem werden ::1/128 und ff01::/32 automatisch zur Routing-Tabelle hinzugefügt und die loopback-Schnittstelle verbindet sich mit der node-local multicast Gruppe ff01::1.</p></div></div><div class=sect5><h6 id=_stateless_address_autoconfiguration_beim_host>8.1.1.4.2. Stateless address autoconfiguration beim Host<a class=anchor href=#_stateless_address_autoconfiguration_beim_host></a></h6><div class=paragraph><p>In der IPv6-Spezifikation werden Knoten in zwei Kategorien unterteilt: <em>Router</em> und <em>Hosts</em>. Router leiten Pakete, die an andere adressiert sind, weiter, Hosts leiten Pakete nicht weiter. net.inet6.ip6.forwarding definiert, ob dieser Knoten ein Router oder ein Host ist (Router falls es 1 ist, Host, falls es 0 ist).</p></div><div class=paragraph><p>Sobald ein Host ein Router-Advertisement vom Router hört, kann er sich selbst mit statusloser automatischer Adressen konfigurieren. Dieses Verhalten kann mit net.inet6.ip6.accept_rtadv (der Host konfiguriert sich selber, wenn es auf 1 gesetzt ist) beeinflusst werden. Bei einer automatischen Konfiguration wird das Netzwerkadresspräfix für die empfangende Schnittstelle (für gewöhnlich das globale Adresspräfix) hinzugefügt. Die Standard-Route wird ebenso konfiguriert. Router erzeugen periodisch Router-Advertisement-Pakete. Um einen benachbarten Router aufzufordern, ein RA-Paket zu erzeugen, kann eine Host-Router-Solicitation übertragen werden. Um jederzeit ein RS-Paket zu erzeugen, benutzt man das <em>rtsol</em>-Kommando. Ein <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;format=html">rtsold(8)</a>-Dämon ist ebenso verfügbar. <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;format=html">rtsold(8)</a> erzeugt Router-Solicitation, wann immer es notwendig ist und es funktioniert großartig "bei normadischem Einsatz" (Notebooks/Laptops). Falls jemand Router-Advertisements zu ignorieren wünscht, setzt man mit sysctl et.inet6.ip6.accept_rtadv auf 0.</p></div><div class=paragraph><p>Um Router-Advertisement von einem Router aus zu erzeugen, benutzt man den <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>-Dämon.</p></div><div class=paragraph><p>Beachte, dass die IPv6-Spezifikation von folgenden Punkte ausgeht und nicht konforme Fälle werden als nicht spezifiziert ausgelassen:</p></div><div class=ulist><ul><li><p>Nur Hosts hören auf Router-Angebote</p></li><li><p>Hosts haben eine einzige Netzwerk-Schnittstelle (außer loopback)</p></li></ul></div><div class=paragraph><p>Deshalb ist es unklug, net.inet6.ip6.accept_rtadv bei Routern oder bei Hosts mit mehreren Schnittstellen einzuschalten. Ein falsch konfigurierter Knoten kann sich seltsam verhalten (nicht konforme Konfiguration ist für diejenigen erlaubt, die Experimente durchführen möchten).</p></div><div class=paragraph><p>Eine Zusammenfassung des sysctl-Angaben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	accept_rtadv forwarding Rolle des Knotens
   <span class=nt>---</span>	   <span class=nt>---</span>    <span class=nt>---</span>
    0       0    Host <span class=o>(</span>wird manuell konfiguriert<span class=o>)</span>
    0       1    Router
    1       0    automatisch konfigurierter Host
	             <span class=o>(</span>Die Spezifikation setzt voraus, dass der Host nur eine einzelne Schnittstelle hat, ein automatisch konfigurierter Host mit mehreren Schnittstellen ist außerhalb der Betrachtung<span class=o>)</span>
    1       1    ungültig, oder für Experimentierzwecke <span class=o>(</span>außerhalb der Spezifikation<span class=o>)</span></code></pre></div></div><div class=paragraph><p>RFC2462 hat eine Überprüfungsregel gegen eingehende RA-prefix-information-option, in 5.5.3 (e). Dies dient zum Schutz des Hosts vor schlecht oder falsch konfigurierten Routern, die eine sehr kurze Präfixlebenszeit ankündigen. Es gab Aktualisierungen von Jim Bound in der ipngwg-Mailing-Liste (suche nach "(ipng 6712)" im Archive) und es wurde Jims Aktualisierung implementiert.</p></div><div class=paragraph><p>Siehe auch <a href=#neighbor-discovery>23.5.1.2</a> im Dokument für das Verhältnis zwischen DAD und autoconfiguration.</p></div></div></div><div class=sect4><h5 id=gif>8.1.1.5. Generische Tunnel-Schnittstelle<a class=anchor href=#gif></a></h5><div class=paragraph><p>GIF (Generische Schnittstelle) ist eine Pseudoschnittstelle für konfigurierte Tunnel. Details sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> beschrieben. Im Moment sind</p></div><div class=ulist><ul><li><p>v6 in v6</p></li><li><p>v6 in v4</p></li><li><p>v4 in v6</p></li><li><p>v4 in v4</p></li></ul></div><div class=paragraph><p>verfügbar. Benutze <a href="https://man.freebsd.org/cgi/man.cgi?query=gifconfig&amp;sektion=8&amp;format=html">gifconfig(8)</a>, um die physikalische (außerhalb liegende) Quelle und die Zieladresse den gif-Schnittstellen zuzuweisen. Eine Konfiguration, die die selbe Adressfamilie für innere und äußere IP-Header (v4 in v4, oder v6 in v6) benutzt, ist gefährlich. Es ist sehr leicht, Schnittstellen und Routing-Tabellen so zu konfigurieren, dass eine unendliche Ebene von Tunneln ausgeführt wird. <em>Seien Sie also gewarnt</em>.</p></div><div class=paragraph><p>gif kann ECN-freundlich konfiguriert werden. Beachte <a href=#ipsec-ecn>23.5.4.5</a> für eine ECN-Freundlichkeit von Tunneln und <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> wie man sie konfiguriert.</p></div><div class=paragraph><p>Falls man einen IPv4-in-IPv6-Tunnel mit einer gif-Schnittstelle konfigurieren möchte, sollte man <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> sorgfältig lesen. Man muss die IPv6 link-local Adresse, die automatisch der gif-Schnittstelle zugewiesen wird, entfernen.</p></div></div><div class=sect4><h5 id=ipv6-sas>8.1.1.6. Source Address Selection<a class=anchor href=#ipv6-sas></a></h5><div class=paragraph><p>Im Moment ist die Regel zur Auswahl der Quelle bereichsorientiert (es gibt einige Ausnahmen - siehe unten). Für ein gegebenes Ziel wird eine Quell-IPv6-Adresse durch folgende Regel ausgewählt:</p></div><div class="olist arabic"><ol class=arabic><li><p>Falls die Quelladresse explizit durch den Benutzer angegeben ist (z.B. über das erweiterte API), dann wird die angegebene Adresse benutzt.</p></li><li><p>Falls eine Adresse der ausgehenden Schnittstelle zugewiesen wird, die den selben Bereich wie die Zieladresse hat (was normalerweise durch einen Blick in die Routing-Tabelle festgestellt werden kann), dann wird diese Adresse benutzt.</p><div class=paragraph><p>Dies ist ein typischer Fall.</p></div></li><li><p>Falls keine Adresse der obigen Bedingung genügt, dann wählt man eine globale Adresse, die einer der Schnittstellen des sendenden Knotens zugewiesen ist.</p></li><li><p>Falls keine Adresse der obigen Bedingung genügt und die Zieladresse ist im site local-Bereich, dann wählt man eine eine site local-Adresse, die einer der Schnittstellen des sendenden Knotens zugewiesen ist.</p></li><li><p>Falls keine Adresse der obigen Bedingung genügt, dann wählt man eine Adresse, die mit einem Eintrag in der Routing-Tabelle für das Ziel verbunden ist. Dies ist die letzte Möglichkeit, die eine Bereichsverletzung verursachen könnte.</p></li></ol></div><div class=paragraph><p>Zum Beispiel, ::1 ist ausgewählt für ff01::1, fe80:1::200:f8ff:fe01:6317 für fe80:1::2a0:24ff:feab:839b (beachte den eingebetteten Schnittstelleindex - beschrieben in <a href=#ipv6-scope-index>23.5.1.3</a> - er hilft uns, die richtige Quelladresse auszuwählen. Diese eingebetteten Indexe werden nicht übertragen). Falls die ausgehende Schnittstelle mehrere Adressen für einen Bereich hat, wird die Quelle gewählt, die die breiteste passende Basis hat (Regel 3). Angenommen 2001:0DB8:808:1:200:f8ff:fe01:6317 und 2001:0DB8:9:124:200:f8ff:fe01:6317 sind einer ausgehenden Schnittstelle zugewiesen. 2001:0DB8:808:1:200:f8ff:fe01:6317 wird als Quelle für das Ziel 2001:0DB8:800::1 ausgewählt.</p></div><div class=paragraph><p>Beachte, dass obige Regel nicht in der IPv6-Spezifikation dokumentiert ist. Es wird als "up to implementation"-Punkt betrachtet. Es gibt einige Fälle, bei denen die obige Regel nicht benutzt werden soll. Ein Beispiel ist die verbundene TCP-Sitzung und man benutzt die Adresse, die in tcb als Quelle gehalten wird. Ein anderes Beispiel ist die Quelladresse für Neighbor Advertisement. Laut Spezifikation (RFC2461 7.2.2) sollte die Quelle des NA die Zieladresse des korrespondierenden Ziel des NS sein. In diesem Fall folgen wir eher der Spezifikation, als der obigen longest-match-Regel.</p></div><div class=paragraph><p>Für neue Verbindungen werden (wenn Regel eins nicht zutrifft) abgelehnte Adressen (Adressen mit bevorzugter Lebenszeit = 0) nicht ausgewählt, wenn andere Auswahlmöglichkeiten bestehen. Wenn keine anderen Auswahlmöglichkeiten bestehen, werden abgelehnte Adressen als letzte Möglichkeit benutzt. Falls mehrere Auswahlmöglichkeiten für abgelehnte Adressen bestehen, dann wird ogige Regel verwendet, um aus diesen abgelehnten Adressen auszuwählen. Falls man aus bestimmten Gründen die Benutzung abgelehnter Adressen unterbinden möchte, dann setzt man net.inet6.ip6.use_deprecated auf 0. Der Punkt bezüglich der abgelehnten Adressen ist in RFC2462 5.5.4 beschrieben (Beachte: Im Moment wird in der IETF ipngwg darüber debatiert, wie angelehnte Adressen benutzt werden sollen).</p></div></div><div class=sect4><h5 id=ipv6-jumbo>8.1.1.7. Jumbo Payload<a class=anchor href=#ipv6-jumbo></a></h5><div class=paragraph><p>Die Jumbo-Payload hop-by-hop-Option ist implementiert und kann benutzt werden, um IPv6-Pakete mit Datenpaketen größer als 65.535 Oktette. Aber im Moment wird keine physikalische Schnittstelle unterstützt, deren MTU größer ist als 65.536, so dass diese Datenpakete nur bei den loopback-Schnittstellen zu finden sind (z.B. lo0).</p></div><div class=paragraph><p>Falls man die Jumbo Payloads testen möchte, muss man zunächst den Kernel rekonfigurieren, so dass die MTU der loopback-Schnittstelle grösser 65.535 Bytes sein kann. Füge folgende Zeile zur Kernel-Konfiguration hinzu:</p></div><div class=paragraph><p><code>options "LARGE_LOMTU" #Um Jumbo Payload zu testen</code></p></div><div class=paragraph><p>und dann kompiliere den Kernel neu.</p></div><div class=paragraph><p>Dann kann man die Jumbo-Payloads mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=ping6&amp;sektion=8&amp;format=html">ping6(8)</a>-Kommando mit den Optionen -b und -s testen. Die Option -b muss angegeben werden, um die Größe des Socket-Puffers zu erhön, und die Option -s gibt die Größe des Pakets an, die größer als 65.535 sein sollte. Beispielsweise gibt man folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping6 <span class=nt>-b</span> 70000 <span class=nt>-s</span> 68000 ::1</code></pre></div></div><div class=paragraph><p>Die IPv6-Spezifikation verlangt, dass die Jumbo-Payload-Option nicht in einem Paket verwendet werden darf, das einen fragmentierten Header hat. Falls diese Bedingung nicht zutrifft, dann muss eine ICMPv6-Parameter-Problem-Nachricht an den Absender geschickt werden. Die Spezifikation ist befolgt, aber man kann normalerweise nicht einen ICMPv6-Fehler sehen, der durch diese Forderung hervorgerufen wird.</p></div><div class=paragraph><p>Wenn ein IPv6-Paket empfangen wird, dann wird die Rahmenlänge geprüft und sie wird mit der Größe verglichen, die im Datenfeld für die Paketgröße des IPv6-Headers oder im Wert für die Jumbo-Payload-Option angegeben ist, sofern vorhanden. Falls ersterer kleiner als letzterer ist, dann wird das Paket abgelehnt und die Statistiken werden erhöht. Man kann die Statistik als Ausgabe des <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=8&amp;format=html">netstat(8)</a>-Kommandos mit der <code>-s -p ip6</code>-Option sehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-s</span> <span class=nt>-p</span> ip6
	  ip6:
		<span class=o>(</span>snip<span class=o>)</span>
		1 with data size &lt; data length</code></pre></div></div><div class=paragraph><p>So, der Kernel sendet keinen ICMPv6-Fehler, außer das fehlerhafte Paket ist ein aktuelles Jumbo-Payload, dessen Paketgröße größer als 65,535 Bytes ist. Wie oben beschrieben, gibt es momentan keine physikalische Schnittstelle, die eine so riesige MTU unterstützt, daher gibt es so selten einen ICMPv6-Fehler.</p></div><div class=paragraph><p>TCP/UDP over Jumbogramm wird im Moment nicht unterstützt. Dies kommt daher, weil wir kein Medium (außer loopback) haben, dies zu testen. Melden Sie sich, falls Sie es benötigen.</p></div><div class=paragraph><p>IPsec funktioniert nicht mit Jumbogramm. Dies ist bedingt durch einige Änderungen an der Spezifikation, welche die Unterstützung von AH mit Jumbogramm betrifft (AH-Header-Größe beeinflusst die Länge des Datenpakets und das macht es richtig schwierig, ein eingehendes Paket mit Jumbo-Payload-Option so gut zu authentifizieren wie ein AH).</p></div><div class=paragraph><p>Es gibt grundlegende Punkte in der *BSD-Unterstützung für Jumbogramms. Wir würden jene gerne ansprechen, aber wir benötigen mehr Zeit diese fertig zu stellen. Um ein paar zu benennen:</p></div><div class=ulist><ul><li><p>mbuf pkthdr.len-Feld ist in 4.4BSD typisiert als "int", so dass es kein Jumbogramm mit len > 2G bei 32Bit-Architekturen aufnehmen kann. Wenn wir Jumbogramme geeignet unterstützen wollten, dann muss das Feld erweitert werden, damit es 4G + IPv6-Header + link-layer-Header aufnehmen kann. Deshalb muss es schließlich auf int64_t (u_int32_t ist NICHT genug) erweitert werden.</p></li><li><p>Irrigerweise benutzen wir "int" an vielen Stellen, um die Paketlänge aufzunehmen. Wir müssen sie in einen größeren ganzzahligen Typ konvertieren. Es braucht große Vorsicht, weil wir sonst einen Überlauf während der Berechnung der Paketlänge erleben können.</p></li><li><p>Irrigerweise prüfen wir das ip6_plen-Feld des IPv6-Header für packet payload length an verschiedenen Stellen. Wir sollten mbuf pkthdr.len stattdessen prüfen. ip6_input() wird bei der Eingabe eine Prüfung der Jumbo -Payload-Option durchführen und wir können danach mbuf pkthdr.len sicher benutzen.</p></li><li><p>Natürlich braucht der TCP-Kode an einigen Stellen eine sorgfältige Aktualisierung.</p></li></ul></div></div><div class=sect4><h5 id=_verhindern_von_schleifen_beim_verarbeiten_von_headern>8.1.1.8. Verhindern von Schleifen beim Verarbeiten von Headern<a class=anchor href=#_verhindern_von_schleifen_beim_verarbeiten_von_headern></a></h5><div class=paragraph><p>Die IPv6-Spezifikation erlaubt eine willkürliche Zahl von Erweiterungs-Headern, die in einem Paket platziert werden können. Wenn wir IPv6-Kode für die Paketverarbeitung auf die Art und Weise implementieren wie wir es beim BSD-IPv4-Kode geschehen ist, dann würde wegen einer lange Kette von Funktionsaufrufen der Kernel-Stack überlaufen. sys/netinet6-Kode ist behutsam entwickelt wurden, um einen Überlauf des Kernel-Stacks zu verhindern. Deswegen definiert der sys/netinet6-Kode seine eigene Protocol-Switch-Struktur "struct ip6protosw" (siehe auch <span class=filename>netinet6/ip6protosw.h</span>). Aus Gründen der Kompatibilität gibt es keine solche Aktualisierung im IPv4-Teil (sys/netinet), aber eine kleine Änderung ist zum pr_input()-Prototyp hinzugefügt worden. So ist "struct ipprotosw" ebenso definiert. Deswegen kann der Kernel-Stack sich aufblähen, wenn man ein IPsec-over-IPv4-Paket mit einer massiven Zahl von IPSec-Header empfängt. IPsec-over-IPv6 ist in Ordnung. (Natürlich muss für all diese zu verarbeitenden IPSec-Header jeder einzelne IPSec-Header jede IPSec-Prüfung durchlaufen. So wird es einem anonymen Angreifer unmöglich gemacht eine Attacke durchzuführen.)</p></div></div><div class=sect4><h5 id=icmpv6>8.1.1.9. ICMPv6<a class=anchor href=#icmpv6></a></h5><div class=paragraph><p>Nachdem RFC2463 veröffentlicht worden war, hat die IETF-ipngwg beschlossen ICMPv6-Fehler-Pakete gegen ICMPv6 umzuleiten, um einen ICMPv6-Sturm auf einem Netzwerkmedium zu unterbinden. Dies ist bereits im Kernel implementiert.</p></div></div><div class=sect4><h5 id=_anwendungen>8.1.1.10. Anwendungen<a class=anchor href=#_anwendungen></a></h5><div class=paragraph><p>Für Programmierung des Userland unterstützen wir das IPv6-Socket-API wie es in RFC2553, RFC2292 und in aufkommenden Internet-Konzepten beschrieben ist.</p></div><div class=paragraph><p>TCP/UDP über IPv6 ist verfügbar und ziemlich stabil. Man kann sich an <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp&amp;sektion=1&amp;format=html">ftp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, usw. erfreuen. Diese Anwendungen sind unabhängig vom Protokoll. Das liegt daran, weil diese Programme automatisch IPv4 oder IPv6 entsprechend des DNS auswählen.</p></div></div><div class=sect4><h5 id=_kernel_interna>8.1.1.11. Kernel Interna<a class=anchor href=#_kernel_interna></a></h5><div class=paragraph><p>Während ip_forward() ip_output() aufruft, ruft ip6_forward() direkt if_output() auf, da Router IPv6-Pakete nicht in Fragmente teilen dürfen.</p></div><div class=paragraph><p>ICMPv6 sollte das original Paket so lang wie möglich bis maximal 1280 halten. UDP6/IP6 port unreach, zum Beispiel, sollte alle Erweiterungs-Header und die unveränderten UDP6- und IP6-Header enthalten. Um das originale Paket zu erhalten, konvertieren alle IP6-Funktionen außer TCP niemals Network-Byte-Order in Host-Byte-Order.</p></div><div class=paragraph><p>tcp_input(), udp6_input() und icmp6_input() können nicht voraussetzen, dass der IP6-Header vor dem Transport-Header, der zum Extension-Header gehört, kommt. Deshalb wurde in6_cksum() implementiert, um Pakete, deren IP6-Header und Transport-Header nicht fortlaufend ist, zu behandeln. Weder TCP/IP6- noch UDP6/IP6-Header-Strukturen existieren, um eine Prüsumme zu bilden.</p></div><div class=paragraph><p>Um IP6-Header, Extension-Header und Transport-Headers leichter verarbeiten zu können, werden nun Netzwerktreiber benötigt, die Pakete in einem internen mbuf oder in einem oder mehreren externen mbuf speichern können. Ein typischer alter Treiber legt zwei interne mbuf für 96 - 204 Bytes an Daten an, wie auch immer wird ein solches Paket jetzt in einem externen mbuf gespeichert.</p></div><div class=paragraph><p><code>netstat -s -p ip6</code> ermittelt, ob der Treiber sich nach solchen Erfordernissen richtet, oder nicht. Im folgenden Beispiel verletzt "cce0" dies Erfordernisse (Für weitere Informationen, siehe Abschnitt 2.).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mbuf statistics:
                317 one mbuf
                two or more mbuf::
                        lo0 <span class=o>=</span> 8
			cce0 <span class=o>=</span> 10
                3282 one ext mbuf
                0 two or more ext mbuf</code></pre></div></div><div class=paragraph><p>Jede Eingabefunktion ruft IP6_EXTHDR_CHECK am Anfang auf, um zu prüfen, ob der Bereich zwischen IP6 und seinen Header durchgehend ist. IP6_EXTHDR_CHECK ruft m_pullup() nur dann auf, wenn mbuf das M_LOOP-Flag gestzt hat, weil das Paket von der Loopback-Schnittstelle kommt. m_pullup() wird niemals aufgerufen, wenn Pakete von physikalischen Netzwerkschnittstellen kommen.</p></div><div class=paragraph><p>IP- und IP6-Reassemble-Funktionen rufen niemals m_pullup() auf.</p></div></div><div class=sect4><h5 id=ipv6-wildcard-socket>8.1.1.12. IPv4-Mapped-Address und IPv6-Wildcard-Socket<a class=anchor href=#ipv6-wildcard-socket></a></h5><div class=paragraph><p>RFC2553 beschreibt IPv4-Mapped-Address (3.7) und die spezielle Verhaltensweise des IPv6-Wildcard-Bind-Socket (3.8). Die Spezifikation gestattet es:</p></div><div class=ulist><ul><li><p>IPv4-Verbindungen von AF_INET6-Wildcard-Bind-Socket zu erlauben.</p></li><li><p>IPv4-Pakete über AF_INET6-Socket zu transportieren, indem eine spezielle Form der Adresse wie ::ffff:10.1.1.1 benutzt wird.</p></li></ul></div><div class=paragraph><p>Aber die Spezifikation ist sehr kompliziert und spezifiziert nicht, wie der Socket-Layer sich verhalten soll. Darauf Bezug nehmend nennen wir hier ersteren "hörende Seite" und letzteren "beginnende Seite".</p></div><div class=paragraph><p>Man kann einen Wildcard-Bind auf demselben Port bei beiden Adressfamilien durchführen.</p></div><div class=paragraph><p>Die folgende Tabelle zeigt das Verhalten von FreeBSD 4.x.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Hörende Seite          Beginnende Seite
                <span class=o>(</span>AF_INET6-Wildcard-      <span class=o>(</span>Verbindung zu ::ffff:10.1.1.1<span class=o>)</span>
                Socket erreicht IPv4 Verb.<span class=o>)</span>
                <span class=nt>---</span>                     <span class=nt>---</span>
FreeBSD 4.x     Konfigurierbar            unterstützt
                Standard: erlaubt</code></pre></div></div><div class=paragraph><p>Die folgende Abschnitte zeigen mehr Details und wie man das Verhalten konfigurieren kann.</p></div><div class=paragraph><p>Kommentare auf der hörenden Seite:</p></div><div class=paragraph><p>Es sieht so aus, dass RFC2553 zu wenig zu den Punkten über Wildcard-Bind erläutert, speziell zum Punkt über Port-Space, Fehler-Modus und Beziehung zwischen AF_INET/INET6 wildcard bind. Es kann mehrere unterschiedliche Interpretationen zu diesem RFC geben, die sich nach diesen richten, aber sich unterschiedlich verhalten. Um eine portable Anwendung zu implementieren, sollte man deshalb nicht ein bestimmtes Verhalten des Kernels voraussetzen. Der Einsatz von <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> ist der sicherste Weg. Port number space und wildcard bind issues wurden Mitte Mai 1999 detailliert in der Ipv6imp-Mailing-Liste diskutiert und es sieht so aus, als ob es keinen konkreten Konsens gab (means, up to implementers). Vielleicht sollte man die Archive der Mailing-Liste prüfen.</p></div><div class=paragraph><p>Wenn eine Server-Anwendung IPv4- und IPv6-Verbindungen annehmen möchte, dann gibt es zwei Alternativen.</p></div><div class=paragraph><p>Eine benutzt AF_INET- und AF_INET6-Socket (man benötigt zwei Sockets). Benutze <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> mit gesetztem AI_PASSIVE-Bit in ai_flags, <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;format=html">bind(2)</a> für alle zurückgegebenen Adressen. Mit dem öffnen mehrerer Sockets kann man Verbindungen an dem Socket mit der richtigen Adressfamilie annehmen. IPv4-Verbindungen werden vom AF_INET-Socket und IPv6-Verbindungen vom AF_INET6-Socket angenommen.</p></div><div class=paragraph><p>Ein anderer Weg ist einen AF_INET6 wildcard bind-Socket zu verwenden. Man benutzt <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> mit AI_PASSIVE in ai_flags, mit AF_INET6 in ai_family, man setzt das erste Argument hostname auf NULL, <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;format=html">bind(2)</a> auf die zurückgegebene Adresse (es sollte eine unspezifizierte IPv6-Adresse sein). Man kann IPv4- und IPv6-Paket über diesen Socket annehmen.</p></div><div class=paragraph><p>Um nur IPv6-Datenverkehr portabel an AF_INET6 wildcard gebundenen Socket zu unterstützen, prüft man, sobald die Verbindung Zustande gekommen ist, immer die Peer-Adresse gegen den hörenden AF_INET6-Socket. Wenn die Adresse eine IPv4-Mapped-Adresse ist, dann sollte man die Verbindung zurückweisen. Man kann die Bedingung mit dem IN6_IS_ADDR_V4MAPPED()-Makro prüfen.</p></div><div class=paragraph><p>Um diesen Punkt leichter lösen zu können, gibt es für <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a> die System abhängige Option IPV6_BINDV6ONLY, die wie folgt benutzt wird.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	int on<span class=p>;</span>

	setsockopt<span class=o>(</span>s, IPPROTO_IPV6, IPV6_BINDV6ONLY,
		   <span class=o>(</span>char <span class=k>*</span><span class=o>)</span>&amp;on, sizeof <span class=o>(</span>on<span class=o>))</span> &lt; 0<span class=o>))</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Wenn der Aufruf erfolgreich ist, dann empfängt dieser Socket nur IPv6-Pakete.</p></div><div class=paragraph><p>Kommentare zur sendenden Seite:</p></div><div class=paragraph><p>Ratschlag an Anwendungsentwickler: um eine portable IPv6-Anwendung zu implementieren (die mit verschiedenen IPv6-Kerneln funktioniert), ist das Folgende der Schlüssel zum Erfolg wie wir glauben:</p></div><div class=ulist><ul><li><p>NIEMALS AF_INET oder AF_INET6 hart kodieren.</p></li><li><p>Benutze <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a> überall im System. Benutze niemals gethostby*(), getaddrby*(), inet_*() oder getipnodeby*() (Um bestehende Applikationen leicht IPv6 fähig zu machen, wird getipnodeby*() manchmal nützlich sein. Falss es aber möglich sein sollte, versuche den Kode neu zu schreiben und <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a> zu benutzen)</p></li><li><p>Wenn man sich an ein Ziel verbinden möchte, benutze <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> und versuche alle zurückgegebenen Ziele, wie <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> es macht.</p></li><li><p>Einige IPv6-Stacks sind mit fehlerhafter <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> verschickt worden. Man verschickt als letzte Möglichkeit eine minimal arbeitende Version der Anwendung.</p></li></ul></div><div class=paragraph><p>Wenn man einen AF_INET6-Socket für jeweils eine ausgehende IPv4- und IPv6-Verbingung benutzen möchte, dann muss man <a href="https://man.freebsd.org/cgi/man.cgi?query=getipnodebyname&amp;sektion=3&amp;format=html">getipnodebyname(3)</a> benutzen. Wenn man seine existierende Anwendung mit wenig Aufwand IPv6-fähig machen möchte, dann sollte dieser Versuch gewählt werden. Aber beachte bitte, dass dies eine temporäre Lösung ist, weil <a href="https://man.freebsd.org/cgi/man.cgi?query=getipnodebyname&amp;sektion=3&amp;format=html">getipnodebyname(3)</a> selber noch zu empfehlen ist, da es noch keine Adressbereiche verarbeitet. Für eine IPv6-NAmensauflösung ist <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> das bevorzugte API. Deshalb sollte man seine Anwendung so umschreiben, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> benutzt wird, wann man Zeit dazu hat.</p></div><div class=paragraph><p>Wenn man Anwendungen schreibt, die ausgehende Verbindungen herstellen, wird die Geschichte viel einfacher, wenn man AF_INET und AF_INET6 als total getrennte Adressfamilien behandelt. {set,get}sockopt funktioniert viel einfacher, DNS-Angelegenheiten werden einfacher gemacht. Wir empfehlen sich nicht auf IPv4-Mapped-Adressen zu verlassen.</p></div><div class=sect5><h6 id=_einheitlicher_tcp_und_inpcb_kode>8.1.1.12.1. Einheitlicher TCP-und INPCB-Kode<a class=anchor href=#_einheitlicher_tcp_und_inpcb_kode></a></h6><div class=paragraph><p>FreeBSD 4.x benutzt shared TCP-Kode zwischen IPv4 und IPv6 (von sys/netinet/tcp*) und separaten udp4/6-Kode. Es benutzt eine vereinheitlichte inpcb-Struktur.</p></div><div class=paragraph><p>Die Plattform kann für eine Unterstützung von IPv4-mapped-Adressen konfiguriert werden. Die Kernel-Konfiguration läßt sich wie folgt zusammenfassen:</p></div><div class=ulist><ul><li><p>By default, AF_INET6 socket will grab IPv4 connections in certain condition, and can initiate connection to IPv4 destination embedded in IPv4 mapped IPv6 address.</p></li><li><p>Man kann es wie unten beschrieben abschalten.</p><div class=paragraph><p><code>sysctl net.inet6.ip6.mapped_addr=0</code></p></div></li></ul></div><div class=sect6><h7 id=_hörende_seite>8.1.1.12.1.1. Hörende Seite<a class=anchor href=#_hörende_seite></a></h7><div class=paragraph><p>Jeder Socket kann für eine Unterstützung eines speziellen AF_INET6 wildcard bind (Standardmäßig eingeschaltet) konfiguriert werden. Man kann es auf Socket-Basis mit <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a> wie unten beschrieben abschalten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	int on<span class=p>;</span>

	setsockopt<span class=o>(</span>s, IPPROTO_IPV6, IPV6_BINDV6ONLY,
		   <span class=o>(</span>char <span class=k>*</span><span class=o>)</span>&amp;on, sizeof <span class=o>(</span>on<span class=o>))</span> &lt; 0<span class=o>))</span><span class=p>;</span></code></pre></div></div><div class=dlist><dl><dt class=hdlist1>Wildcard-AF_INET6-Socket schnappt sich die IPv4-Verbindung, wenn, und nur wenn folgende Bedingungen erfüllt sind</dt><dd><div class=ulist><ul><li><p>Es gibt keinen AF_INET-Socket, der zu einer IPv4-Verbindung passt</p></li><li><p>Der AF_INET6-Socket ist so konfiguriert, dass er IPv4-Datenverkehr akzeptiert, z.B. gibt getsockopt(IPV6_BINDV6ONLY) 0 zurück.</p></li></ul></div></dd></dl></div><div class=paragraph><p>Es gibt kein Problem mit der Öffnen/Schließen-Reihenfolge.</p></div></div><div class=sect6><h7 id=_initiating_side>8.1.1.12.1.2. initiating side<a class=anchor href=#_initiating_side></a></h7><div class=paragraph><p>FreeBSD 4.x unterstützt ausgehende Verbindungen zu IPv4 mapped Adressen (::ffff:10.1.1.1), falls der Knoten so konfiguriert ist, dass er IPv4 mapped Adressen unterstützt.</p></div></div></div></div><div class=sect4><h5 id=_sockaddr_storage>8.1.1.13. sockaddr_storage<a class=anchor href=#_sockaddr_storage></a></h5><div class=paragraph><p>Als RFC2553 kurz vor der Vollendung stand, gab es eine Diskussion, wie struct sockaddr_storage Mitglieder benannt werden sollten. Ein Vorschlag war "<em>" den Mitgliedern (wie "</em>ss_len") voranzustellen und es sollten sie nicht verändert werden. Der andere Vorschlag war, nichts voranzustellen (wie "ss_len") also mußten wir solche Mitglieder direkt verändern. Es gab keinen klaren Konsens.</p></div><div class=paragraph><p>Als Ergebnis definiert RFC2553 die Struktur sockaddr_storage wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	struct sockaddr_storage <span class=o>{</span>
		u_char	__ss_len<span class=p>;</span>	/<span class=k>*</span> address length <span class=k>*</span>/
		u_char	__ss_family<span class=p>;</span>	/<span class=k>*</span> address family <span class=k>*</span>/
		/<span class=k>*</span> and bunch of padding <span class=k>*</span>/
	<span class=o>}</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Im Gegensatz dazu definiert der XNET-Entwurf die Struktur wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	struct sockaddr_storage <span class=o>{</span>
		u_char	ss_len<span class=p>;</span>		/<span class=k>*</span> address length <span class=k>*</span>/
		u_char	ss_family<span class=p>;</span>	/<span class=k>*</span> address family <span class=k>*</span>/
		/<span class=k>*</span> and bunch of padding <span class=k>*</span>/
	<span class=o>}</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Im Dezember 1999 kam man überein, dass RFC2553bis letztere Definition (XNET) aufnehmen sollte.</p></div><div class=paragraph><p>Die aktuelle Implementierung ist konform zur XNET-Definition basierend auf der RFC2553bis Diskussion.</p></div><div class=paragraph><p>Wenn man mehrere IPv6-Implementierungen betrachtet, wird man beide Definitionen sehen. Für Userland-Programmierer ist der folgende Weg der meist portable um damit umzugehen:</p></div><div class="olist arabic"><ol class=arabic><li><p>Man versichert sich, dass ss_family und/oder ss_len für die Plattform verfügbar sind, indem man GNU autoconf verwendet,</p></li><li><p>Man benutzet -Dss_family=<em>ss_family um alle Vorkommen (einschließlich der Header-Files) zu </em>ss_family zu vereinheitlichen, oder</p></li><li><p>Man benutzt niemals __ss_family. Man führe einen Typecast nach sockaddr * durch und verwendet sa_family wie folgt:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	struct sockaddr_storage ss<span class=p>;</span>
	family <span class=o>=</span> <span class=o>((</span>struct sockaddr <span class=k>*</span><span class=o>)</span>&amp;ss<span class=o>)</span>-&gt;sa_family</code></pre></div></div></li></ol></div></div></div><div class=sect3><h4 id=_netzwerktreiber>8.1.2. Netzwerktreiber<a class=anchor href=#_netzwerktreiber></a></h4><div class=paragraph><p>Die beiden folgenden Dinge müssen zwingend von Standardtreibern unterstützt werden:</p></div><div class="olist arabic"><ol class=arabic><li><p>Mbuf-Clustering-Erfordernis. In diesem stabilen Release haben wir für alle Betriebssystem MINCLSIZE in MHLEN+1 geändert, damit sich alle Treiber wie erwartet verhalten.</p></li><li><p>Multicast. Falls <a href="https://man.freebsd.org/cgi/man.cgi?query=ifmcstat&amp;sektion=8&amp;format=html">ifmcstat(8)</a> keine Multicast-Gruppe für die Schnittstelle liefert, dann muss diese Schnittstelle überarbeitet werden.</p></li></ol></div><div class=paragraph><p>Falls keiner der Treiber die Erfordernisse erfüllt, dann können die Treiber nicht für IPv6/IPSec-Kommunikation verwendet werden. Falls man ein Problem beim Einsatz von IPv6/IPSec mit seiner Karte hat, dann melde es bitte bei <a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>FreeBSD problem reports</a>.</p></div><div class=paragraph><p>(Beachte: In der Vergangenheit haben wir gefordert, dass alle PCMCIA-Treiber einen Aufruf nach in6_ifattach() haben. Inzwischen haben wir keine solche Forderung mehr)</p></div></div><div class=sect3><h4 id=_translator>8.1.3. Translator<a class=anchor href=#_translator></a></h4><div class=paragraph><p>Wir kategorisieren einen IPv4/IPv6-Translator in 4 Typen:</p></div><div class=ulist><ul><li><p><em>Translator A</em> --- Er wird im frühen Stadium des Übergangs benutzt um es zu ermöglichen, dass eine Verbindung von einem IPv6-Host auf einer IPv6-Insel zu einem IPv4-Host im IPv4-Ozean hergestellt wird.</p></li><li><p><em>Translator B</em> --- Er wird im frühen Stadium des Übergangs benutzt um es zu ermöglichen, dass eine Verbindung von einem IPv4-Host im IPv4-Ozean zu einem IPv6-Host auf einer IPv6-Insel hergestellt wird.</p></li><li><p><em>Translator C</em> --- Er wird im frühen Stadium des Übergangs benutzt um es zu ermöglichen, dass eine Verbindung von einem IPv4-Host auf einer IPv4-Insel zu einem IPv6-Host im IPv6-Ozean hergestellt wird.</p></li><li><p><em>Translator D</em> --- Er wird im frühen Stadium des Übergangs benutzt um es zu ermöglichen, dass eine Verbindung von einem IPv6-Host im IPv6-Ozean zu einem IPv4-Host auf einer IPv4-Insel hergestellt wird.</p></li></ul></div><div class=paragraph><p>Ein TCP-Relay-Translator der Kategorie A wird unterstützt. Er wird "FAITH" genannt. Wir stellen ebenso einen IP-Header-Translator der Kataegorie A zur Verfügung (Letzterer ist noch nicht in FreeBSD 4.x übernommen).</p></div><div class=sect4><h5 id=_faith_tcp_relay_translator>8.1.3.1. FAITH TCP-Relay-Translator<a class=anchor href=#_faith_tcp_relay_translator></a></h5><div class=paragraph><p>Das FAITH-System benutzt mit Hilfe des Kernels den <a href="https://man.freebsd.org/cgi/man.cgi?query=faithd&amp;sektion=8&amp;format=html">faithd(8)</a> genannten TCP-Relay-Daemon. FAITH wird einen IPv6-Adress-Präfix reservieren und eine TCP-Verbindungen an diesen Präfix zum IPv4-Ziel weiterleiten.</p></div><div class=dlist><dl><dt class=hdlist1>Wenn beispielsweise der IPv6-Präfix 2001:0DB8:0200:ffff</dt><dd><p>ist und das IPv6-Ziel für TCP-Verbindungen 2001:0DB8:0200:ffff::163.221.202.12 ist, dann wird die Verbindung an das IPv4-Ziel 163.221.202.12 weitergeleitet.</p></dd></dl></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	IPv4-Ziel-Knoten <span class=o>(</span>163.221.202.12<span class=o>)</span>
	  ^
	  | IPv4 tcp toward 163.221.202.12
	FAITH-relay dual stack node
	  ^
	  | IPv6 TCP toward 2001:0DB8:0200:ffff::163.221.202.12
	<span class=nb>source </span>IPv6 node</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=faithd&amp;sektion=8&amp;format=html">faithd(8)</a> muss auf FAITH-relay dual stack node aufgerufen werden.</p></div><div class=paragraph><p>Für weitere Details siehe <span class=filename>src/usr.sbin/faithd/README</span></p></div></div></div><div class=sect3><h4 id=ipsec-implementation>8.1.4. IPsec<a class=anchor href=#ipsec-implementation></a></h4><div class=paragraph><p>IPsec besteht hauptsächlich aus drei Komponenten.</p></div><div class="olist arabic"><ol class=arabic><li><p>Policy Management</p></li><li><p>Key Management</p></li><li><p>AH und ESP Behandlung</p></li></ol></div><div class=sect4><h5 id=_regel_management>8.1.4.1. Regel Management<a class=anchor href=#_regel_management></a></h5><div class=paragraph><p>Im Kernel ist experimenteller Kode für Regel-Management implementiert. Es gibt zwei Wege eine Sicherheitsregel zu handhaben. Einer ist eine Regel für jeden Socket mithilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a> zu konfigurieren. Für diesen Fall ist die Konfiguration der Regel in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec_set_policy&amp;sektion=3&amp;format=html">ipsec_set_policy(3)</a> beschrieben. Der andere Weg ist eine auf einem Kernel-Packet-Filter basierende Regel mithilfe der PF_KEY-Schnittstelle mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> zu konfigurieren.</p></div><div class=paragraph><p>Der Regeleintrag mit seinen Indices wird nicht sortiert, so dass es sehr wichtig ist, wann ein Eintrag hinzugefügt wird.</p></div></div><div class=sect4><h5 id=_key_management>8.1.4.2. Key Management<a class=anchor href=#_key_management></a></h5><div class=paragraph><p>Der in dieser Bibliothek (sys/netkey) implementierte Kode für das key management ist eine Eigenentwicklung der PFKEYv2-Implementierung. Er ist konform zu RFC2367.</p></div><div class=paragraph><p>Die Eigenentwicklung des IKE-Daemons "racoon" ist in der Bibliothek (kame/kame/racoon) implementiert. Grundsätzlich muss man racoon als Dämonprozess laufen lassen, dann setzt man eine Regel auf, die Schlüssel erwartet (ähnlich wie <code>ping -P 'out ipsec esp/transport//use'</code>). Der Kernel wird den racoon-Dämon wegen des notwendigen Austauschs der Schlüssel kontaktieren.</p></div></div><div class=sect4><h5 id=_ah_und_esp_handhabung>8.1.4.3. AH- und ESP-Handhabung<a class=anchor href=#_ah_und_esp_handhabung></a></h5><div class=paragraph><p>Das IPsec-Modul ist als "hook" in die Standard-IPv4/IPv6-Verarbeitung implementiert. Sobald ein Paket gesendet wird, prüft ip{,6_output(), ob eine ESP/AH-Verarbeitung notwendig ist. Es findet eine Überprüfung statt, ob eine passende SPD (Security Policy Database) gefunden wurde. Wenn ESP/AH benötigt wird, dann wird {esp,ah}{4,6}_output() aufgerufen und mbuf wird folglich aktualisiert. Wenn ein Paket empfangen wird, dann wird {esp,ah}4_input() basierend auf der Protokollnummer aufgerufen, z.B. (*inetsw[proto])(). {esp,ah}4_input() entschlüsselt/prüft die Authentizität des Pakets und entfernt den daisy-chained-Header und das Padding des ESP/AH. Es ist sicherer den ESP/AH-Header beim Empfang zu entfernen, weil man das empfangene Paket niemals so wie es ist benutzt.</p></div><div class=paragraph><p>Mit der Verwendung von ESP/AH wird die effektive TCP4/6-Datensegmentgröße durch weitere von ESP/AH eingefügte Daisy-chained-Headers beeinflußt. Unser Kode berücksichtigt dies.</p></div><div class=paragraph><p>Grundlegende Crypto-Funktionen sind im Verzeichnis "sys/crypto" zu finden. ESP/AH-Umformungen sind zusammen mit den Wrapper-Funktionen in {esp,ah}_core.c gelistet. Wenn man einige Algorithmen hinzufügen möchte, dann fügt man in {esp,ah}_core.c eine Wrapper-Funktion hinzu und trägt seinen Crypto-Algorithmus in sys/crypto ein.</p></div><div class=paragraph><p>Der Tunnel-Modus wird in diesem Release teilweise mit den folgenden Restriktionen unterstützt:</p></div><div class=ulist><ul><li><p>Der IPsec-Tunnel ist nicht mit der generischen Tunnelschnittstelle kombiniert. Man muss sehr vorsichtig sein, weil man sonst eine Endlosschleife zwischen ip_output() und tunnelifp→if_output() aufbaut. Die Meinungen gehen auseinander, ob es besser ist dies zu vereinheitlichen, oder nicht.</p></li><li><p>Die Betrachtung von MTU und des "Don’t Fragment"-Bits (IPv4) müssen mehr geprüft werden, aber grundsätzlichen arbeiten sie gut.</p></li><li><p>Das Authentifizierungsmodel für einen AH-Tunnel muss überarbeitet werden. Man muss eventuell die "policy management engine" überarbeiten.</p></li></ul></div></div><div class=sect4><h5 id=_konformität_zu_rfcs_und_ids>8.1.4.4. Konformität zu RFCs und IDs<a class=anchor href=#_konformität_zu_rfcs_und_ids></a></h5><div class=paragraph><p>Der IPsec-Kode im Kernel ist konform (oder versucht konform zu sein) zu den folgenden Standards:</p></div><div class=paragraph><p>Die "alte IPsec"-Spezifikation, die in <span class=filename>rfc182[5-9].txt</span> dokumentiert ist</p></div><div class=paragraph><p>Die "neue IPsec"-Spezifikation, die <span class=filename>rfc240[1-6].txt</span>, <span class=filename>rfc241[01].txt</span>, <span class=filename>rfc2451.txt</span> und <span class=filename>draft-mcdonald-simple-ipsec-api-01.txt</span> (Der Entwurf ist erloschen, aber man kann ihn sich von <a href=ftp://ftp.kame.net/pub/internet-drafts/>ftp://ftp.kame.net/pub/internet -drafts/</a> holen) dokumentiert ist (Beachte: Die IKE-Spezifikationen <span class=filename>rfc241[7-9].txt</span> sind im Userland als "racoon"-IKE-Daemon implementiert).</p></div><div class=paragraph><p>Aktuell werden folgende Algorithmen unterstützt:</p></div><div class=ulist><ul><li><p>altes IPsec-AH</p><div class=ulist><ul><li><p>null crypto Prüfsumme (Kein Dokument, nur für Debug-Zwecke)</p></li><li><p>keyed MD5 mit 128bit crypto Prüfsumme (<span class=filename>rfc1828.txt</span>)</p></li><li><p>keyed SHA1 mit 128bit crypto Prüfsumme (kein Document)</p></li><li><p>HMAC MD5 mit 128bit crypto Prüfsumme (<span class=filename>rfc2085.txt</span>)</p></li><li><p>HMAC SHA1 mit 128bit crypto Prüfsumme (kein Dokument)</p></li></ul></div></li><li><p>altes IPsec-ESP</p><div class=ulist><ul><li><p>null encryption (kein Dokument, ähnlich zu <span class=filename>rfc2410.txt</span>)</p></li><li><p>DES-CBC-Modus (<span class=filename>rfc1829.txt</span>)</p></li></ul></div></li><li><p>neues IPsec-AH</p><div class=ulist><ul><li><p>null crypto Prüfsumme (kein Dokument, nur für Debug-Zwecke)</p></li><li><p>keyed MD5 mit 96bit crypto Prüfsumme (kein Dokument)</p></li><li><p>keyed SHA1 mit 96bit crypto Prüfsumme (kein Dokument)</p></li><li><p>HMAC MD5 mit 96bit crypto Prüfsumme (<span class=filename>rfc2403.txt</span>)</p></li><li><p>HMAC SHA1 mit 96bit crypto Prüfsumme (<span class=filename>rfc2404.txt</span>)</p></li></ul></div></li><li><p>neues IPsec-ESP</p><div class=ulist><ul><li><p>null encryption (<span class=filename>rfc2410.txt</span>)</p></li><li><p>DES-CBC mit abgeleiteter IV (<span class=filename>draft-ietf-ipsec-ciph-des-derived-01.txt</span>, Entwurf abgelaufen)</p></li><li><p>DES-CBC mit expliziter IV (<span class=filename>rfc2405.txt</span>)</p></li><li><p>3DES-CBC mit expliziter IV (<span class=filename>rfc2451.txt</span>)</p></li><li><p>BLOWFISH CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>CAST128 CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>RC5 CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>Jeder Algorithmus kann kombiniert werden mit:</p><div class=ulist><ul><li><p>ESP-Beglaubigung mit HMAC-MD5(96bit)</p></li><li><p>ESP-Beglaubigung mit HMAC-SHA1(96bit)</p></li></ul></div></li></ul></div></li></ul></div><div class=paragraph><p>Die folgenden Algorithmen werden NICHT unterstützt:</p></div><div class=ulist><ul><li><p>altes IPsec-AH</p><div class=ulist><ul><li><p>HMAC MD5 mit 128bit crypto Prüfsumme + 64bit replay prevention (<span class=filename>rfc2085.txt</span>)</p></li><li><p>keyed SHA1 mit 160bit crypto Prüfsumme + 32bit padding (<span class=filename>rfc1852.txt</span>)</p></li></ul></div></li></ul></div><div class=paragraph><p>IPsec (im Kernel) und IKE (im Userland als "racoon") wurden bei unterschiedlichen Interoperabilitätstests geprüft und es ist bekannt, dass es mit vielen anderen Implementierungen gut zusammenarbeitet. Außerdem wurde die IPsec-Implementierung sowie die breite Abdeckung mit IPsec-Crypto-Algorithmen, die in den RFCs dokumentiert sind, geprüft (es werden nur Algorithmen ohne intellektuelle Besitzansprüche behandelt).</p></div></div><div class=sect4><h5 id=ipsec-ecn>8.1.4.5. ECN-Betrachtung von IPsec-Tunneln<a class=anchor href=#ipsec-ecn></a></h5><div class=paragraph><p>ECN-freundliche IPsec-Tunnel werden unterstützt wie es in <span class=filename>draft-ipsec-ecn-00.txt</span> beschrieben ist.</p></div><div class=paragraph><p>Normale IPsec-Tunnel sind in RFC2401 beschrieben. Für eine Kapselung wird das IPv4-TOS-Feld (oder das IPv6-Traffic-Class-Feld) vom inneren in den äußeren IP-Header kopiert. Für eine Entkapselung wird der ässere IP-Header einfach verworfen. Die Entkapselungsregel ist nicht mit ECN kompatibel, sobald das ECN-Bit im äußeren IP-TOS/Traffic-Class-Feld verloren geht.</p></div><div class=paragraph><p>Um einen IPsec-Tunnel ECN-freundlich zu machen, sollte man die Kapselungs- und Entkapselungsprozeduren modifizieren. Dies ist in <a href=http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt>http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt</a>, Kapitel 3, beschrieben.</p></div><div class=paragraph><p>Die IPsec-Tunnel-Implementierung kann drei Zustände annehmen, indem man net.inet.ipsec.ecn (oder net.inet6.ipsec6.ecn) auf diese Werte setzt:</p></div><div class=ulist><ul><li><p>RFC2401: Keine Betrachtung von ECN (Sysctl-Wert -1)</p></li><li><p>ECN verboten (Sysctl-Wert 0)</p></li><li><p>ECN erlaubt (Sysctl-Wert 1)</p></li></ul></div><div class=paragraph><p>Beachte, dass dieses Verhalten per-node konfigurierbar ist und nicht per-SA (draft-ipsec-ecn-00 möchte per-SA Konfiguration).</p></div><div class=paragraph><p>Das Verhalten ist wie folgt zusammengefaßt (man beachte auch den Quelltext für weitere Details):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                encapsulate                     decapsulate
                <span class=nt>---</span>                             <span class=nt>---</span>
RFC2401         kopiere alle TOS-Bits               lösche TOS-Bits im äußeren
                von innen nach außen.            <span class=o>(</span>benutze innere TOS-Bits so wie sie sind<span class=o>)</span>

ECN verboten   kopiere TOS-Bits außer für ECN    lösche TOS-Bits im äußeren
                <span class=o>(</span>maskiert mit 0xfc<span class=o>)</span> von innen   <span class=o>(</span>benutze innere TOS-Bits so wie sie sind<span class=o>)</span>
                nach außen.  Setze ECN-Bits auf 0.

ECN erlaubt     kopiere TOS-Bits außer für ECN    benutze innere TOS-Bits mit einigen Änderungen.
                CE <span class=o>(</span>maskiert mit 0xfe<span class=o>)</span> von      Wenn das äußere ECN-CE-Bit 1 ist,
                innen nach außen.                 setze das ECN-CE-Bit im
                Setze ECN-CE-Bit auf 0.            Inneren.</code></pre></div></div><div class=paragraph><p>Allgemeine Strategie zur Konfiguration:</p></div><div class=ulist><ul><li><p>Wenn beide IPsec-Tunnel-Endpunkte ein ECN-freundliches Verhalten beherrschen, dann sollte man besser beide Endpunkte auf "ECN allowed" (Sysctl-Wert 1) setzen.</p></li><li><p>Wenn das andere Ende das TOS-Bit sehr strikt handhabt, dann benutzt man "RFC2401" (Sysctl-Wert -1).</p></li><li><p>in den anderen Fällen benutzt man "ECN verboten" (Sysctl-Wert 0).</p></li></ul></div><div class=paragraph><p>Der Standard ist "ECN verboten" (Sysctl-Wert 0).</p></div><div class=paragraph><p>Für weitere Informationen siehe auch:</p></div><div class=paragraph><p><a href=http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt>http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt</a>, RFC2481 (Explicit Congestion Notification), src/sys/netinet6/{ah,esp}_input.c</p></div><div class=paragraph><p>(Dank gebührt Kenjiro Cho <a href=mailto:kjc@csl.sony.co.jp>kjc@csl.sony.co.jp</a> für seine detailliert Analyse)</p></div></div><div class=sect4><h5 id=_interoperabilität>8.1.4.6. Interoperabilität<a class=anchor href=#_interoperabilität></a></h5><div class=paragraph><p>Hier sind einige Plattformen angegeben, die in der Vergangenheit die IPsec/IKE-Interoperabilität mit dem KAME-Kode getestet haben. Beachte, dass beide Enden vielleicht ihre Implementierung verändert haben, deshalb sollte man folgende Liste nur für Referenzzwecke benutzen.</p></div><div class=paragraph><p>Altiga, Ashley-laurent (vpcom.com), Data Fellows (F-Secure), Ericsson ACC, FreeS/WAN, HITACHI, IBM AIX®, IIJ, Intel, Microsoft® Windows NT®, NIST (linux IPsec + plutoplus), Netscreen, OpenBSD, RedCreek, Routerware, SSH, Secure Computing, Soliton, Toshiba, VPNet, Yamaha RT100i</p></div></div></div></div></div></div><h1 id=kernel class=sect0>Teil III: Kernel<a class=anchor href=#kernel></a></h1><div class=sect1><h2 id=kernelbuild>Kapitel 9. Einen FreeBSD-Kernel bauen und installieren<a class=anchor href=#kernelbuild></a></h2><div class=sectionbody><div class=paragraph><p>Ein Kernelentwickler muss wissen, wie der Bau eines angepassten Kernels funktioniert, da das Debuggen des FreeBSD-Kernels nur durch den Bau eines neuen Kernels möglich ist. Es gibt zwei Wege, einen angepassten Kernel zu bauen:</p></div><div class=ulist><ul><li><p>Den "traditionellen" Weg</p></li><li><p>Den "neuen" Weg</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die folgenden Ausführungen setzen voraus, dass Sie den Abschnitt <a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-building>Erstellen und Installation eines angepassten Kernels</a> des FreeBSD-Handbuchs gelesen haben und daher wissen, wie man einen FreeBSD-Kernel baut.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=kernelbuild-traditional>9.1. Einen Kernel auf die "traditionelle" Art und Weise bauen<a class=anchor href=#kernelbuild-traditional></a></h3><div class=paragraph><p>Bis FreeBSD 4.X wurde dieser Weg zum Bau eines angepassten Kernels empfohlen. Sie können Ihren Kernel nach wie vor auf diese Art und Weise bauen (anstatt das Target "buildkernel" der Makefiles im Verzeichnis <span class=filename>/usr/src/</span> zu verwenden). Dies kann beispielsweise sinnvoll sein, wenn Sie am Kernel-Quellcode arbeiten. Haben Sie nur ein oder zwei Optionen der Kernelkonfigurationsdatei geändert, ist dieser Weg in der Regel schneller als der "neue" Weg. Andererseits kann es aber auch zu unerwarteten Fehlern beim Bau des Kernels kommen, wenn Sie Ihren Kernel unter aktuellen FreeBSD-Versionen auf diese Art und Weise bauen.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Erzeugen Sie den Kernel-Quellcode mit <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/config MYKERNEL</span></code></pre></div></div></li><li><p>Wechseln Sie in das Build-Verzeichnis. <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> gibt den Namen dieses Verzeichnisses aus, wenn die Erzeugung des Kernel-Quellcodes im vorherigen Schritt erfolgreich abgeschlossen wurde.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd ../compile/MYKERNEL</span></code></pre></div></div></li><li><p>Kompilieren Sie den neuen Kernel:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make depend</span>
<span class=c># make</span></code></pre></div></div></li><li><p>Installieren Sie den neuen Kernel:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make install</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect2><h3 id=kernelbuild-new>9.2. Einen Kernel auf die "neue" Art und Weise bauen<a class=anchor href=#kernelbuild-new></a></h3><div class=paragraph><p>Dieser Weg wird für alle aktuellen FreeBSD-Versionen empfohlen. Lesen Sie bitte den Abschnitt <a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-building>Erstellen und Installation eines angepassten Kernels</a> des FreeBSD-Handbuchs, wenn Sie Ihren Kernel auf diese Art und Weise bauen wollen.</p></div></div></div></div><div class=sect1><h2 id=kerneldebug>Kapitel 10. Kernel-Fehlersuche<a class=anchor href=#kerneldebug></a></h2><div class=sectionbody><div class=sect2><h3 id=kerneldebug-obtain>10.1. Besorgen eines Speicherauszugs nach einem Kernel-Absturz (Kernel-Crash-Dump)<a class=anchor href=#kerneldebug-obtain></a></h3><div class=paragraph><p>Wenn ein Entwicklungs-Kernel (z.B. FreeBSD-CURRENT) wie zum Beispiel ein Kernel unter Extrembedingungen (z.B. sehr hohe Belastungsraten (Load), eine äußerst hohe Anzahl an gleichzeitigen Benutzern, Hunderte <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>s usw.) eingesetzt oder eine neue Funktion oder ein neuer Gerätetreiber in FreeBSD-STABLE verwendet wird (z.B. PAE), tritt manchmal eine Kernel-Panic ein. In einem solchen Fall zeigt dieses Kapitel, wie dem Absturz nützliche Informationen entnommen werden können.</p></div><div class=paragraph><p>Bei Kernel-Panics ist ein Neustart unvermeidlich. Nachdem ein System neu gestartet wurde, ist der Inhalt des physikalischen Speichers (RAM), genauso wie jedes Bit, das sich vor der Panic auf dem Swap-Gerät befand, verloren. Um die Bits im physikalischen Speicher zu erhalten, zieht der Kernel Nutzen aus dem Swap-Gerät als vorübergehenden Ablageort, wo die Bits, welche sich im RAM befinden, auch nach einem Neustart nach einem Absturz verfügbar sind. Durch diese Vorgehensweise kann ein Kernel-Abbild, wenn FreeBSD nach einem Absturz startet, abgezogen und mit der Fehlersuche begonnen werden.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ein Swap-Gerät, das als Ausgabegerät (Dump-Device) konfiguriert wurde, verhält sich immer noch wie ein Swap-Gerät. Die Ausgabe auf Nicht-Swap-Geräte (wie zum Beispiel Bänder oder CDRWs) wird zur Zeit nicht unterstützt. Ein "Swap-Gerät" ist gleichbedeutend mit einer "Swap-Partition".</p></div></td></tr></tbody></table></div><div class=paragraph><p>Es stehen verschiedene Arten von Speicherabzügen zur Verfügung: komplette Speicherabzüge (full memory dumps), welche den gesamten Inhalt des physischen Speichers beinhalten, Miniauszüge (minidumps), die nur die gerade verwendeten Speicherseiten des Kernels enthalten (FreeBSD 6.2 und höhere Versionen) und Textauszüge (textdumps), welche geskriptete oder Debugger-Ausgaben enthalten (FreeBSD 7.1 und höher). Miniauszüge sind der Standardtyp der Abzüge seit FreeBSD 7.0 und fangen in den meisten Fällen alle nötigen Informationen ein, die in einem kompletten Kernel-Speicherabzug enthalten sind, da die meisten Probleme nur durch den Zustand des Kernels isoliert werden können.</p></div><div class=sect3><h4 id=config-dumpdev>10.1.1. Konfigurieren des Ausgabegeräts<a class=anchor href=#config-dumpdev></a></h4><div class=paragraph><p>Bevor der Kernel den Inhalt seines physikalischen Speichers auf einem Ausgabegerät ablegt, muss ein solches konfiguriert werden. Ein Ausgabegerät wird durch Benutzen des <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a>-Befehls festgelegt, um dem Kernel mitzuteilen, wohin die Speicherauszüge bei einem Kernel-Absturz gesichert werden sollen. Das <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a>-Programm muss aufgerufen werden, nachdem die Swap-Partition mit <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a> konfiguriert wurde. Dies wird normalerweise durch Setzen der <code>dumpdev</code>-Variable in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> auf den Pfad des Swap-Geräts (der empfohlene Weg, um einen Kernel-Speicherauszug zu entnehmen) bewerkstelligt, oder über <code>AUTO</code>, um die erste konfigurierte Swap-Partition zu verwenden. In HEAD ist die Standardeinstellung für <code>dumpdev</code><span class=filename>AUTO</span> und änderte sich in den RELENG_*-Zweigen (mit Ausnahme von RELENG_7, bei dem <code>AUTO</code> beibehalten wurde) auf <code>NO</code>. In FreeBSD 9.0-RELEASE und späteren Versionen fragt bsdinstall, ob Speicherauszüge für das Zielsystem während des Installationsvorgangs aktiviert werden sollen.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Vergleichen Sie <span class=filename>/etc/fstab</span> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=swapinfo&amp;sektion=8&amp;format=html">swapinfo(8)</a> für eine Liste der Swap-Geräte.</p></div></td></tr></tbody></table></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Stellen Sie sicher, dass das in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> festgelegte <code>dumpdir</code> vor einem Kernel-Absturz vorhanden ist.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/crash</span>
<span class=c># chmod 700 /var/crash</span></code></pre></div></div><div class=paragraph><p>Denken Sie auch daran, dass der Inhalt von <span class=filename>/var/crash</span> heikel ist und sehr wahrscheinlich vertrauliche Informationen wie Passwörter enthält.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=extract-dump>10.1.2. Entnehmen eines Kernel-Speicherauszugs (Kernel-Dump)<a class=anchor href=#extract-dump></a></h4><div class=paragraph><p>Sobald ein Speicherauszug auf ein Ausgabegerät geschrieben wurde, muss er entnommen werden, bevor das Swap-Gerät eingehängt wird. Um einen Speicherauszug aus einem Ausgabegerät zu entnehmen, benutzen Sie das <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a>-Programm. Falls <code>dumpdev</code> in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> gesetzt wurde, wird <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> automatisch beim ersten Start in den Multiuser-Modus nach dem Absturz und vor dem Einhängen des Swap-Geräts aufgerufen. Der Speicherort des entnommenen Kernels ist im <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>-Wert <code>dumpdir</code>, standardmäßig <span class=filename>/var/crash</span>, festgelegt und der Dateiname wird <span class=filename>vmcore.0</span> sein.</p></div><div class=paragraph><p>In dem Fall, dass bereits eine Datei mit dem Namen <span class=filename>vmcore.0</span> in <span class=filename>/var/crash</span> (oder auf was auch immer <code>dumpdir</code> gesetzt ist) vorhanden ist, erhöht der Kernel die angehängte Zahl bei jedem Absturz um eins und verhindert damit, dass ein vorhandener <span class=filename>vmcore</span> (z.B. <span class=filename>vmcore.1</span>) überschrieben wird. Während der Fehlersuche, möchten Sie höchst wahrscheinlich den <span class=filename>vmcore</span> mit der höchsten Version in <span class=filename>/var/crash</span> benutzen, wenn Sie den passenden <span class=filename>vmcore</span> suchen.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Falls Sie einen neuen Kernel testen, aber einen anderen starten müssen, um Ihr System wieder in Gang zu bringen, starten Sie es nur in den Singleuser-Modus, indem Sie das <code>-s</code>-Flag an der Boot-Eingabeaufforderung benutzen, und nehmen dann folgende Schritte vor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -p</span>
<span class=c># mount -a -t ufs       # make sure /var/crash is writable</span>
<span class=c># savecore /var/crash /dev/ad0s1b</span>
<span class=c># exit                  # exit to multi-user</span></code></pre></div></div><div class=paragraph><p>Dies weist <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> an, einen Kernel-Speicherauszug aus <span class=filename>/dev/ad0s1b</span> zu entnehmen und den Inhalt in <span class=filename>/var/crash</span> abzulegen. Vergessen Sie nicht sicherzustellen, dass das Zielverzeichnis <span class=filename>/var/crash</span> genug freien Speicherplatz für den Speicherauszug zur Verfügung hat. Vergessen Sie auch nicht, den korrekten Pfad des Swap-Geräts anzugeben, da es sehr wahrscheinlich anders als <span class=filename>/dev/ad0s1b</span> lautet!</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=kerneldebug-gdb>10.2. Fehlersuche in einem Speicherauszug nach einem Kernel-Absturz mit <code>kgdb</code><a class=anchor href=#kerneldebug-gdb></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dieser Abschnitt deckt <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> ab, wie es in FreeBSD 5.3 und später zu finden ist. In früheren Versionen muss <code>gdb -k</code> benutzt werden, um einen Kernspeicherauszug auszulesen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald ein Speicherauszug zur Verfügung steht, ist es recht einfach nützliche Informationen für einfache Probleme daraus zu bekommen. Bevor Sie sich auf die Interna von <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> stürzen, um die Fehler im Kernspeicherauszug zu suchen und zu beheben, machen Sie die Debug-Version Ihres Kernels (normalerweise <span class=filename>kernel.debug</span> genannt) und den Pfad der Quelldateien, die zum Bau Ihres Kernels verwendet wurden (normalerweise <span class=filename>/usr/obj/usr/src/sys/KERNCONF</span>, wobei <span class=filename>KERNCONF</span> das in einer Kernel-<a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a> festgelegte <code>ident</code> ist), ausfindig. Mit diesen beiden Informationen kann die Fehlersuche beginnen.</p></div><div class=paragraph><p>Um in den Debugger zu gelangen und mit dem Informationserhalt aus dem Speicherauszug zu beginnen, sind zumindest folgende Schritte nötig:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/obj/usr/src/sys/KERNCONF</span>
<span class=c># kgdb kernel.debug /var/crash/vmcore.0</span></code></pre></div></div><div class=paragraph><p>Sie können Fehler im Speicherauszug nach dem Absturz suchen, indem Sie die Kernel-Quellen benutzen, genauso wie Sie es bei jedem anderen Programm können.</p></div><div class=paragraph><p>Dieser erste Speicherauszug ist aus einem 5.2-BETA-Kernel und der Absturz ist tief im Kernel begründet. Die Ausgabe unten wurde dahingehend bearbeitet, dass sie nun Zeilennummern auf der linken Seite einschließt. Diese erste Ablaufverfolgung (Trace) untersucht den Befehlszeiger (Instruction-Pointer) und beschafft eine Zurückverfolgung (Back-Trace). Die Adresse, die in Zeile 41 für den <code>list</code>-Befehl benutzt wird, ist der Befehlszeiger und kann in Zeile 17 gefunden werden. Die meisten Entwickler wollen zumindest dies zugesendet bekommen, falls Sie das Problem nicht selber untersuchen und beheben können. Falls Sie jedoch das Problem lösen, stellen Sie sicher, dass Ihr Patch seinen Weg in den Quellbaum mittels eines Fehlerberichts, den Mailinglisten oder ihres Privilegs, zu committen, findet!</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 1:# <span class=nb>cd</span> /usr/obj/usr/src/sys/KERNCONF
 2:# kgdb kernel.debug /var/crash/vmcore.0
 3:GNU gdb 5.2.1 <span class=o>(</span>FreeBSD<span class=o>)</span>
 4:Copyright 2002 Free Software Foundation, Inc.
 5:GDB is free software, covered by the GNU General Public License, and you are
 6:welcome to change it and/or distribute copies of it under certain conditions.
 7:Type <span class=s2>&#34;show copying&#34;</span> to see the conditions.
 8:There is absolutely no warranty <span class=k>for </span>GDB.  Type <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
 9:This GDB was configured as <span class=s2>&#34;i386-undermydesk-freebsd&#34;</span>...
10:panic: page fault
11:panic messages:
12:---
13:Fatal <span class=nb>trap </span>12: page fault <span class=k>while in </span>kernel mode
14:cpuid <span class=o>=</span> 0<span class=p>;</span> apic <span class=nb>id</span> <span class=o>=</span> 00
15:fault virtual address   <span class=o>=</span> 0x300
16:fault code:             <span class=o>=</span> supervisor <span class=nb>read</span>, page not present
17:instruction pointer     <span class=o>=</span> 0x8:0xc0713860
18:stack pointer           <span class=o>=</span> 0x10:0xdc1d0b70
19:frame pointer           <span class=o>=</span> 0x10:0xdc1d0b7c
20:code segment            <span class=o>=</span> base 0x0, limit 0xfffff, <span class=nb>type </span>0x1b
21:                        <span class=o>=</span> DPL 0, pres 1, def32 1, gran 1
22:processor eflags        <span class=o>=</span> resume, IOPL <span class=o>=</span> 0
23:current process         <span class=o>=</span> 14394 <span class=o>(</span><span class=nb>uname</span><span class=o>)</span>
24:trap number             <span class=o>=</span> 12
25:panic: page fault
26      cpuid <span class=o>=</span> 0<span class=p>;</span>
27:Stack backtrace:
28
29:syncing disks, buffers remaining... 2199 2199 panic: mi_switch: switch <span class=k>in </span>a critical section
30:cpuid <span class=o>=</span> 0<span class=p>;</span>
31:Uptime: 2h43m19s
32:Dumping 255 MB
33: 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240
34:---
35:Reading symbols from /boot/kernel/snd_maestro3.ko...done.
36:Loaded symbols <span class=k>for</span> /boot/kernel/snd_maestro3.ko
37:Reading symbols from /boot/kernel/snd_pcm.ko...done.
38:Loaded symbols <span class=k>for</span> /boot/kernel/snd_pcm.ko
39:#0  doadump <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:240
40:240             dumping++<span class=p>;</span>
41:<span class=o>(</span>kgdb<span class=o>)</span> list <span class=k>*</span>0xc0713860
42:0xc0713860 is <span class=k>in </span>lapic_ipi_wait <span class=o>(</span>/usr/src/sys/i386/i386/local_apic.c:663<span class=o>)</span><span class=nb>.</span>
43:658                     incr <span class=o>=</span> 0<span class=p>;</span>
44:659                     delay <span class=o>=</span> 1<span class=p>;</span>
45:660             <span class=o>}</span> <span class=k>else
</span>46:661                     incr <span class=o>=</span> 1<span class=p>;</span>
47:662             <span class=k>for</span> <span class=o>(</span>x <span class=o>=</span> 0<span class=p>;</span> x &lt; delay<span class=p>;</span> x +<span class=o>=</span> incr<span class=o>)</span> <span class=o>{</span>
48:663                     <span class=k>if</span> <span class=o>((</span>lapic-&gt;icr_lo &amp; APIC_DELSTAT_MASK<span class=o>)</span> <span class=o>==</span> APIC_DELSTAT_IDLE<span class=o>)</span>
49:664                             <span class=k>return</span> <span class=o>(</span>1<span class=o>)</span><span class=p>;</span>
50:665                     ia32_pause<span class=o>()</span><span class=p>;</span>
51:666             <span class=o>}</span>
52:667             <span class=k>return</span> <span class=o>(</span>0<span class=o>)</span><span class=p>;</span>
53:<span class=o>(</span>kgdb<span class=o>)</span> backtrace
54:#0  doadump <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:240
55:#1  0xc055fd9b <span class=k>in </span>boot <span class=o>(</span><span class=nv>howto</span><span class=o>=</span>260<span class=o>)</span> at /usr/src/sys/kern/kern_shutdown.c:372
56:#2  0xc056019d <span class=k>in </span>panic <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:550
57:#3  0xc0567ef5 <span class=k>in </span>mi_switch <span class=o>()</span> at /usr/src/sys/kern/kern_synch.c:470
58:#4  0xc055fa87 <span class=k>in </span>boot <span class=o>(</span><span class=nv>howto</span><span class=o>=</span>256<span class=o>)</span> at /usr/src/sys/kern/kern_shutdown.c:312
59:#5  0xc056019d <span class=k>in </span>panic <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:550
60:#6  0xc0720c66 <span class=k>in </span>trap_fatal <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>0xdc1d0b30, <span class=nv>eva</span><span class=o>=</span>0<span class=o>)</span>
61:    at /usr/src/sys/i386/i386/trap.c:821
62:#7  0xc07202b3 <span class=k>in </span><span class=nb>trap</span> <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>
63:      <span class=o>{</span>tf_fs <span class=o>=</span> <span class=nt>-1065484264</span>, tf_es <span class=o>=</span> <span class=nt>-1065484272</span>, tf_ds <span class=o>=</span> <span class=nt>-1065484272</span>, tf_edi <span class=o>=</span> 1, tf_esi <span class=o>=</span> 0, tf_ebp <span class=o>=</span> <span class=nt>-602076292</span>, tf_isp <span class=o>=</span> <span class=nt>-602076324</span>, tf_ebx <span class=o>=</span> 0, tf_edx <span class=o>=</span> 0, tf_ecx <span class=o>=</span> 1000000, tf_eax <span class=o>=</span> 243, tf_trapno <span class=o>=</span> 12, tf_err <span class=o>=</span> 0, tf_eip <span class=o>=</span> <span class=nt>-1066321824</span>, tf_cs <span class=o>=</span> 8, tf_eflags <span class=o>=</span> 65671, tf_esp <span class=o>=</span> 243, tf_ss <span class=o>=</span> 0<span class=o>})</span>
64:    at /usr/src/sys/i386/i386/trap.c:250
65:#8  0xc070c9f8 <span class=k>in </span>calltrap <span class=o>()</span> at <span class=o>{</span>standard input<span class=o>}</span>:94
66:#9  0xc07139f3 <span class=k>in </span>lapic_ipi_vectored <span class=o>(</span><span class=nv>vector</span><span class=o>=</span>0, <span class=nv>dest</span><span class=o>=</span>0<span class=o>)</span>
67:    at /usr/src/sys/i386/i386/local_apic.c:733
68:#10 0xc0718b23 <span class=k>in </span>ipi_selected <span class=o>(</span><span class=nv>cpus</span><span class=o>=</span>1, <span class=nv>ipi</span><span class=o>=</span>1<span class=o>)</span>
69:    at /usr/src/sys/i386/i386/mp_machdep.c:1115
70:#11 0xc057473e <span class=k>in </span>kseq_notify <span class=o>(</span><span class=nv>ke</span><span class=o>=</span>0xcc05e360, <span class=nv>cpu</span><span class=o>=</span>0<span class=o>)</span>
71:    at /usr/src/sys/kern/sched_ule.c:520
72:#12 0xc0575cad <span class=k>in </span>sched_add <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
73:    at /usr/src/sys/kern/sched_ule.c:1366
74:#13 0xc05666c6 <span class=k>in </span>setrunqueue <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcc05e360<span class=o>)</span>
75:    at /usr/src/sys/kern/kern_switch.c:422
76:#14 0xc05752f4 <span class=k>in </span>sched_wakeup <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
77:    at /usr/src/sys/kern/sched_ule.c:999
78:#15 0xc056816c <span class=k>in </span>setrunnable <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
79:    at /usr/src/sys/kern/kern_synch.c:570
80:#16 0xc0567d53 <span class=k>in </span>wakeup <span class=o>(</span><span class=nv>ident</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
81:    at /usr/src/sys/kern/kern_synch.c:411
82:#17 0xc05490a8 <span class=k>in </span>exit1 <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5b40, <span class=nv>rv</span><span class=o>=</span>0<span class=o>)</span>
83:    at /usr/src/sys/kern/kern_exit.c:509
84:#18 0xc0548011 <span class=k>in </span>sys_exit <span class=o>()</span> at /usr/src/sys/kern/kern_exit.c:102
85:#19 0xc0720fd0 <span class=k>in </span>syscall <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>
86:      <span class=o>{</span>tf_fs <span class=o>=</span> 47, tf_es <span class=o>=</span> 47, tf_ds <span class=o>=</span> 47, tf_edi <span class=o>=</span> 0, tf_esi <span class=o>=</span> <span class=nt>-1</span>, tf_ebp <span class=o>=</span> <span class=nt>-1077940712</span>, tf_isp <span class=o>=</span> <span class=nt>-602075788</span>, tf_ebx <span class=o>=</span> 672411944, tf_edx <span class=o>=</span> 10, tf_ecx <span class=o>=</span> 672411600, tf_eax <span class=o>=</span> 1, tf_trapno <span class=o>=</span> 12, tf_err <span class=o>=</span> 2, tf_eip <span class=o>=</span> 671899563, tf_cs <span class=o>=</span> 31, tf_eflags <span class=o>=</span> 642, tf_esp <span class=o>=</span> <span class=nt>-1077940740</span>, tf_ss <span class=o>=</span> 47<span class=o>})</span>
87:    at /usr/src/sys/i386/i386/trap.c:1010
88:#20 0xc070ca4d <span class=k>in </span>Xint0x80_syscall <span class=o>()</span> at <span class=o>{</span>standard input<span class=o>}</span>:136
89:---Can<span class=s1>&#39;t read userspace from dump, or kernel process---
90:(kgdb) quit</span></code></pre></div></div><div class=paragraph><p>Diese nächste Ablaufverfolgung ist ein älterer Speicherauszug aus FreeBSD 2-Zeiten, aber ist komplizierter und zeigt mehr der <code>gdb</code>-Funktionen. Lange Zeilen wurden gefaltet, um die Lesbarkeit zu verbessern, und die Zeilen wurden zur Verweisung nummeriert. Trotzdem ist es eine reale Fehlerverfolgung (Error-Trace), die während der Entwicklung des pcvt-Konsolentreibers entstanden ist.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 1:Script started on Fri Dec 30 23:15:22 1994
 2:# <span class=nb>cd</span> /sys/compile/URIAH
 3:# gdb <span class=nt>-k</span> kernel /var/crash/vmcore.1
 4:Reading symbol data from /usr/src/sys/compile/URIAH/kernel
...done.
 5:IdlePTD 1f3000
 6:panic: because you said to!
 7:current pcb at 1e3f70
 8:Reading <span class=k>in </span>symbols <span class=k>for</span> ../../i386/i386/machdep.c...done.
 9:<span class=o>(</span>kgdb<span class=o>)</span> backtrace
10:#0  boot <span class=o>(</span><span class=nv>arghowto</span><span class=o>=</span>256<span class=o>)</span> <span class=o>(</span>../../i386/i386/machdep.c line 767<span class=o>)</span>
11:#1  0xf0115159 <span class=k>in </span>panic <span class=o>()</span>
12:#2  0xf01955bd <span class=k>in </span>diediedie <span class=o>()</span> <span class=o>(</span>../../i386/i386/machdep.c line 698<span class=o>)</span>
13:#3  0xf010185e <span class=k>in </span>db_fncall <span class=o>()</span>
14:#4  0xf0101586 <span class=k>in </span>db_command <span class=o>(</span><span class=nt>-266509132</span>, <span class=nt>-266509516</span>, <span class=nt>-267381073</span><span class=o>)</span>
15:#5  0xf0101711 <span class=k>in </span>db_command_loop <span class=o>()</span>
16:#6  0xf01040a0 <span class=k>in </span>db_trap <span class=o>()</span>
17:#7  0xf0192976 <span class=k>in </span>kdb_trap <span class=o>(</span>12, 0, <span class=nt>-272630436</span>, <span class=nt>-266743723</span><span class=o>)</span>
18:#8  0xf019d2eb <span class=k>in </span>trap_fatal <span class=o>(</span>...<span class=o>)</span>
19:#9  0xf019ce60 <span class=k>in </span>trap_pfault <span class=o>(</span>...<span class=o>)</span>
20:#10 0xf019cb2f <span class=k>in </span><span class=nb>trap</span> <span class=o>(</span>...<span class=o>)</span>
21:#11 0xf01932a1 <span class=k>in </span>exception:calltrap <span class=o>()</span>
22:#12 0xf0191503 <span class=k>in </span>cnopen <span class=o>(</span>...<span class=o>)</span>
23:#13 0xf0132c34 <span class=k>in </span>spec_open <span class=o>()</span>
24:#14 0xf012d014 <span class=k>in </span>vn_open <span class=o>()</span>
25:#15 0xf012a183 <span class=k>in </span>open <span class=o>()</span>
26:#16 0xf019d4eb <span class=k>in </span>syscall <span class=o>(</span>...<span class=o>)</span>
27:<span class=o>(</span>kgdb<span class=o>)</span> up 10
28:Reading <span class=k>in </span>symbols <span class=k>for</span> ../../i386/i386/trap.c...done.
29:#10 0xf019cb2f <span class=k>in </span><span class=nb>trap</span> <span class=o>(</span><span class=nv>frame</span><span class=o>={</span>tf_es <span class=o>=</span> <span class=nt>-260440048</span>, tf_ds <span class=o>=</span> 16, tf_<span class=se>\</span>
30:edi <span class=o>=</span> 3072, tf_esi <span class=o>=</span> <span class=nt>-266445372</span>, tf_ebp <span class=o>=</span> <span class=nt>-272630356</span>, tf_isp <span class=o>=</span> <span class=nt>-27</span><span class=se>\</span>
31:2630396, tf_ebx <span class=o>=</span> <span class=nt>-266427884</span>, tf_edx <span class=o>=</span> 12, tf_ecx <span class=o>=</span> <span class=nt>-266427884</span>, tf<span class=se>\</span>
32:_eax <span class=o>=</span> 64772224, tf_trapno <span class=o>=</span> 12, tf_err <span class=o>=</span> <span class=nt>-272695296</span>, tf_eip <span class=o>=</span> <span class=nt>-26</span><span class=se>\</span>
33:6672343, tf_cs <span class=o>=</span> <span class=nt>-266469368</span>, tf_eflags <span class=o>=</span> 66066, tf_esp <span class=o>=</span> 3072, tf_<span class=se>\</span>
34:ss <span class=o>=</span> <span class=nt>-266427884</span><span class=o>})</span> <span class=o>(</span>../../i386/i386/trap.c line 283<span class=o>)</span>
35:283                             <span class=o>(</span>void<span class=o>)</span> trap_pfault<span class=o>(</span>&amp;frame, FALSE<span class=o>)</span><span class=p>;</span>
36:<span class=o>(</span>kgdb<span class=o>)</span> frame frame-&gt;tf_ebp frame-&gt;tf_eip
37:Reading <span class=k>in </span>symbols <span class=k>for</span> ../../i386/isa/pcvt/pcvt_drv.c...done.
38:#0  0xf01ae729 <span class=k>in </span>pcopen <span class=o>(</span><span class=nv>dev</span><span class=o>=</span>3072, <span class=nv>flag</span><span class=o>=</span>3, <span class=nv>mode</span><span class=o>=</span>8192, <span class=nv>p</span><span class=o>=(</span>struct p<span class=se>\</span>
39:roc <span class=k>*</span><span class=o>)</span> 0xf07c0c00<span class=o>)</span> <span class=o>(</span>../../i386/isa/pcvt/pcvt_drv.c line 403<span class=o>)</span>
40:403             <span class=k>return</span> <span class=o>((</span><span class=k>*</span>linesw[tp-&gt;t_line].l_open<span class=o>)(</span>dev, tp<span class=o>))</span><span class=p>;</span>
41:<span class=o>(</span>kgdb<span class=o>)</span> list
42:398
43:399             tp-&gt;t_state |<span class=o>=</span> TS_CARR_ON<span class=p>;</span>
44:400             tp-&gt;t_cflag |<span class=o>=</span> CLOCAL<span class=p>;</span>  /<span class=k>*</span> cannot be a modem <span class=o>(</span>:-<span class=o>)</span> <span class=k>*</span>/
45:401
46:402     <span class=c>#if PCVT_NETBSD || (PCVT_FREEBSD &gt;= 200)</span>
47:403             <span class=k>return</span> <span class=o>((</span><span class=k>*</span>linesw[tp-&gt;t_line].l_open<span class=o>)(</span>dev, tp<span class=o>))</span><span class=p>;</span>
48:404     <span class=c>#else</span>
49:405             <span class=k>return</span> <span class=o>((</span><span class=k>*</span>linesw[tp-&gt;t_line].l_open<span class=o>)(</span>dev, tp, flag<span class=o>))</span><span class=p>;</span>
50:406     <span class=c>#endif /* PCVT_NETBSD || (PCVT_FREEBSD &gt;= 200) */</span>
51:407     <span class=o>}</span>
52:<span class=o>(</span>kgdb<span class=o>)</span> print tp
53:Reading <span class=k>in </span>symbols <span class=k>for</span> ../../i386/i386/cons.c...done.
54:<span class=nv>$1</span> <span class=o>=</span> <span class=o>(</span>struct <span class=nb>tty</span> <span class=k>*</span><span class=o>)</span> 0x1bae
55:<span class=o>(</span>kgdb<span class=o>)</span> print tp-&gt;t_line
56:<span class=nv>$2</span> <span class=o>=</span> 1767990816
57:<span class=o>(</span>kgdb<span class=o>)</span> up
58:#1  0xf0191503 <span class=k>in </span>cnopen <span class=o>(</span><span class=nv>dev</span><span class=o>=</span>0x00000000, <span class=nv>flag</span><span class=o>=</span>3, <span class=nv>mode</span><span class=o>=</span>8192, <span class=nv>p</span><span class=o>=(</span>st<span class=se>\</span>
59:ruct proc <span class=k>*</span><span class=o>)</span> 0xf07c0c00<span class=o>)</span> <span class=o>(</span>../../i386/i386/cons.c line 126<span class=o>)</span>
60:       <span class=k>return</span> <span class=o>((</span><span class=k>*</span>cdevsw[major<span class=o>(</span>dev<span class=o>)]</span>.d_open<span class=o>)(</span>dev, flag, mode, p<span class=o>))</span><span class=p>;</span>
61:<span class=o>(</span>kgdb<span class=o>)</span> up
62:#2  0xf0132c34 <span class=k>in </span>spec_open <span class=o>()</span>
63:<span class=o>(</span>kgdb<span class=o>)</span> up
64:#3  0xf012d014 <span class=k>in </span>vn_open <span class=o>()</span>
65:<span class=o>(</span>kgdb<span class=o>)</span> up
66:#4  0xf012a183 <span class=k>in </span>open <span class=o>()</span>
67:<span class=o>(</span>kgdb<span class=o>)</span> up
68:#5  0xf019d4eb <span class=k>in </span>syscall <span class=o>(</span><span class=nv>frame</span><span class=o>={</span>tf_es <span class=o>=</span> 39, tf_ds <span class=o>=</span> 39, tf_edi <span class=o>=</span><span class=se>\</span>
69: 2158592, tf_esi <span class=o>=</span> 0, tf_ebp <span class=o>=</span> <span class=nt>-272638436</span>, tf_isp <span class=o>=</span> <span class=nt>-272629788</span>, tf<span class=se>\</span>
70:_ebx <span class=o>=</span> 7086, tf_edx <span class=o>=</span> 1, tf_ecx <span class=o>=</span> 0, tf_eax <span class=o>=</span> 5, tf_trapno <span class=o>=</span> 582, <span class=se>\</span>
71:tf_err <span class=o>=</span> 582, tf_eip <span class=o>=</span> 75749, tf_cs <span class=o>=</span> 31, tf_eflags <span class=o>=</span> 582, tf_esp <span class=se>\</span>
72:<span class=o>=</span> <span class=nt>-272638456</span>, tf_ss <span class=o>=</span> 39<span class=o>})</span> <span class=o>(</span>../../i386/i386/trap.c line 673<span class=o>)</span>
73:673             error <span class=o>=</span> <span class=o>(</span><span class=k>*</span>callp-&gt;sy_call<span class=o>)(</span>p, args, rval<span class=o>)</span><span class=p>;</span>
74:<span class=o>(</span>kgdb<span class=o>)</span> up
75:Initial frame selected<span class=p>;</span> you cannot go up.
76:<span class=o>(</span>kgdb<span class=o>)</span> quit</code></pre></div></div><div class=paragraph><p>Kommentare zum Skript oben:</p></div><div class=dlist><dl><dt class=hdlist1>Zeile 6</dt><dd><p>Dies ist ein Speicherauszug, der innerhalb von DDB genommen wurde (siehe unten), deswegen der Kommentar zur Panic "because you said to!" und die eher lange Stack-Ablaufverfolgung (Stack-Trace); der anfängliche Grund für das Starten von DDB war jedoch ein Seitenfehler-Trap (Page-Fault-Trap).</p></dd><dt class=hdlist1>Zeile 20</dt><dd><p>Dies ist die Position der Funktion <code>trap()</code> in der Stack-Ablaufverfolgung.</p></dd><dt class=hdlist1>Zeile 36</dt><dd><p>Erzwingt die Benutzung eines neuen Stack-Frames; dies ist nicht mehr notwendig. Die Stack-Frames sollen jetzt an die richtige Stelle im Speicher zeigen, selbst im Falle eines Traps. Nach einem Blick auf den Code in Zeile 403 ergibt sich mit hoher Wahrscheinlichkeit, dass entweder der Zeigerzugriff auf "tp" fehlerbehaftet oder der Array-Zugriff unerlaubt war.</p></dd><dt class=hdlist1>Zeile 52</dt><dd><p>Der Zeiger scheint verdächtig, aber besitzt zufällig eine gültige Adresse.</p></dd><dt class=hdlist1>Zeile 56</dt><dd><p>Jedoch zeigt er offensichtlich auf nichts und so haben wir unseren Fehler gefunden! (Für diejenigen, die nichts mit diesem speziellen Stück Code anfangen können: <code>tp→t_line</code> verweist hier auf das Zeilenverhalten (Line-Discipline) des Konsolen-Geräts, was eine ziemlich kleine Ganzzahl (Integer) sein muss.)</p></dd></dl></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Falls Ihr System regelmäßig abstürzt und und Sie bald keinen freien Speicherplatz mehr zur Verfügung haben, könnte das Löschen alter <span class=filename>vmcore</span>-Dateien in <span class=filename>/var/core</span> einen beträchtlichen Betrag an Speicherplatz einsparen.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kerneldebug-ddd>10.3. Fehlersuche in einem Speicherauszug nach einem Absturz mit DDD<a class=anchor href=#kerneldebug-ddd></a></h3><div class=paragraph><p>Die Untersuchung eines Speicherauszugs nach einem Kernel-Absturz mit einem grafischen Debugger wie <code>ddd</code> ist auch möglich (Sie müssen den <a class=package href=https://cgit.freebsd.org/ports/tree/devel/ddd/>devel/ddd</a>-Port installieren, um den <code>ddd</code>-Debugger benutzen zu können). Nehmen Sie die <code>-k</code> mit in die <code>ddd</code>-Kommandozeile auf, die Sie normalerweise benutzen würden. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ddd --debugger kgdb kernel.debug /var/crash/vmcore.0</span></code></pre></div></div><div class=paragraph><p>Sie sollten nun in der Lage sein, die Untersuchung des Speicherauszugs nach dem Absturz unter Benutzung der grafischen Schnittstelle von <code>ddd</code> anzugehen.</p></div></div><div class=sect2><h3 id=kerneldebug-online-ddb>10.4. Online-Kernel-Fehlersuche mit DDB<a class=anchor href=#kerneldebug-online-ddb></a></h3><div class=paragraph><p>Während <code>kgdb</code> als Offline-Debugger eine Benutzerschnittstelle auf höchster Ebene bietet, gibt es einige Dinge, die es nicht kann. Die wichtigsten sind das Setzen von Breakpoints und das Abarbeiten des Kernel-Codes in Einzelschritten (Single-Stepping).</p></div><div class=paragraph><p>Falls Sie eine systemnahe Fehlersuche an Ihrem Kernel vorhaben, steht Ihnen ein Online-Debugger mit dem Namen DDB zur Verfügung. Er erlaubt Ihnen das Setzen von Breakpoints, die Abarbeitung von Kernel-Funktionen in Einzelschritten, das Untersuchen und Verändern von Kernel-Variablen usw. Jedoch hat er keinen Zugriff auf Kernel-Quelldateien, sondern kann nur, im Gegensatz zu <code>gdb</code>, welches auf die ganzen Informationen zur Fehlersuche zurückgreifen kann, auf globale und statische Symbole zugreifen.</p></div><div class=paragraph><p>Um DDB in Ihren Kernel einzubinden, fügen Sie die Optionen</p></div><div class="literalblock programlisting"><div class=content><pre>options KDB</pre></div></div><div class="literalblock programlisting"><div class=content><pre>options DDB</pre></div></div><div class=paragraph><p>Ihrer Konfigurationsdatei hinzu und bauen Sie den Kernel neu. (Details zur Konfiguration des FreeBSD-Kernels finden Sie im <a href=https://docs.freebsd.org/de/books/handbook/>FreeBSD-Handbuch</a>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls Sie eine ältere Version des Boot-Blocks haben, könnte es sein, dass Ihre Symbole zur Fehlersuche noch nicht einmal geladen werden. Aktualisieren Sie den Boot-Block; aktuelle Versionen laden die DDB-Symbole automatisch.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald Ihr Kernel mit DDB startet, gibt es mehrere Wege, um in DDB zu gelangen. Der erste und früheste Weg ist, das Boot-Flag <code>-d</code> gleich an der Boot-Eingabeaufforderung einzugeben. Der Kernel startet dann in den Debug-Modus und betritt DDB noch vor jedweder Gerätesuche. Somit können Sie Funktionen zur Gerätesuche/-bereitstellung auf Fehler untersuchen. FreeBSD-CURRENT-Benutzer müssen die sechste Option im Boot-Menü auswählen, um an eine Eingabeaufforderung zu gelangen.</p></div><div class=paragraph><p>Das zweite Szenario ist der Gang in den Debugger, sobald das System schon gestartet ist. Es gibt zwei einfache Wege dies zu erreichen. Falls Sie von der Eingabeaufforderung aus in den Debugger gelangen möchten, geben Sie einfach folgenden Befehl ab:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.kdb.enter=1</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um eine schnelle Panic zu erzwingen, geben Sie das folgende Kommando ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.kdb.panic=1</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Anderenfalls können Sie ein Tastenkürzel auf der Tastatur benutzen, wenn Sie an der Systemkonsole sind. Die Voreinstellung für die break-to-debugger-Sequenz ist <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>ESC</kbd></span>. In syscons kann diese Sequenz auf eine andere Tastenkombination gelegt werden (remap) und manche der verfügbaren Tastaturlayouts tun dies, stellen Sie also sicher, dass Sie die richtige Sequenz kennen, die benutzt werden soll. Für serielle Konsolen ist eine Option vorhanden, die die Benutzung einer Unterbrechung der seriellen Verbindung (BREAK) auf der Kommandozeile erlaubt, um in DDB zu gelangen (<code>options BREAK_TO_DEBUGGER</code> in der Kernel-Konfigurationsdatei). Dies ist jedoch nicht der Standard, da viele serielle Adapter in Verwendung sind, die grundlos eine BREAK-Bedingung erzeugen, zum Beispiel bei Ziehen des Kabels.</p></div><div class=paragraph><p>Die dritte Möglichkeit ist, dass jede Panic-Bedingung in DDB springt, falls der Kernel hierfür konfiguriert ist. Aus diesem Grund ist es nicht sinnvoll einen Kernel mit DDB für ein unbeaufsichtigtes System zu konfigurieren.</p></div><div class=paragraph><p>Um die unbeaufsichtigte Funktionsweise zu erreichen fügen Sie:</p></div><div class="literalblock programlisting"><div class=content><pre>options	KDB_UNATTENDED</pre></div></div><div class=paragraph><p>der Kernel-Konfigurationsdatei hinzu und bauen/installieren Sie den Kernel neu.</p></div><div class=paragraph><p>Die DDB-Befehle ähneln grob einigen <code>gdb</code>-Befehlen. Das Erste, das Sie vermutlich tun müssen, ist einen Breakpoint zu setzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>break </span><span class=k>function</span><span class=nt>-name</span> address</code></pre></div></div><div class=paragraph><p>Zahlen werden standardmäßig hexadezimal angegeben, aber um sie von Symbolnamen zu unterscheiden, muss Zahlen, die mit den Buchstaben <code>a-f</code> beginnen, <code>0x</code> vorangehen (dies ist für andere Zahlen beliebig). Einfache Ausdrücke sind erlaubt, zum Beispiel: <code>function-name + 0x103</code>.</p></div><div class=paragraph><p>Um den Debugger zu verlassen und mit der Abarbeitung fortzufahren, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=k>continue</span></code></pre></div></div><div class=paragraph><p>Um eine Stack-Ablaufverfolgung zu erhalten, benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> trace</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Beachten Sie, dass wenn Sie DDB mittels einer Schnelltaste betreten, der Kernel zurzeit einen Interrupt bereitstellt, sodass die Stack-Ablaufverfolgung Ihnen nicht viel nützen könnte.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Falls Sie einen Breakpoint entfernen möchten, benutzen Sie</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> del
 del address-expression</code></pre></div></div><div class=paragraph><p>Die erste Form wird direkt, nachdem ein Breakpoint anschlug, angenommen und entfernt den aktuellen Breakpoint. Die zweite kann jeden Breakpoint löschen, aber Sie müssen die genaue Adresse angeben; diese kann bezogen werden durch:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> show b</code></pre></div></div><div class=paragraph><p>oder:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> show <span class=nb>break</span></code></pre></div></div><div class=paragraph><p>Um den Kernel in Einzelschritten auszuführen, probieren Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> s</code></pre></div></div><div class=paragraph><p>Dies springt in Funktionen, aber Sie können DDB veranlassen, diese schrittweise zu verfolgen, bis die passende Rückkehranweisung (Return-Statement) erreicht ist. Nutzen Sie hierzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> n</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dies ist nicht das gleiche wie die <code>next</code>-Anweisung von <code>gdb</code>; es ist wie <code>gdb</code>s <code>finish</code>. Mehrmaliges Drücken von <kbd>n</kbd> führt zu einer Fortsetzung.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um Daten aus dem Speicher zu untersuchen, benutzen Sie (zum Beispiel):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>x/wx 0xf0133fe0,40
x/hd db_symtab_space
x/bc termbuf,10
x/s stringbuf</code></pre></div></div><div class=paragraph><p>für Word/Halfword/Byte-Zugriff und Hexadezimal/Dezimal/Character/String-Ausgabe. Die Zahl nach dem Komma ist der Objektzähler. Um die nächsten 0x10 Objekte anzuzeigen benutzen Sie einfach:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> x ,10</code></pre></div></div><div class=paragraph><p>Gleichermaßen benutzen Sie</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> x/ia foofunc,10</code></pre></div></div><div class=paragraph><p>um die ersten 0x10 Anweisungen aus <code>foofunc</code> zu zerlegen (disassemble) und Sie zusammen mit ihrem Adressabstand (Offset) vom Anfang von <code>foofunc</code> auszugeben.</p></div><div class=paragraph><p>Um Speicher zu verändern benutzen Sie den Schreibbefehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> w/b termbuf 0xa 0xb 0
 w/w 0xf0010030 0 0</code></pre></div></div><div class=paragraph><p>Die Befehlsoption (<code>b</code>/<code>h</code>/<code>w</code>) legt die Größe der Daten fest, die geschrieben werden sollen, der erste Ausdruck danach ist die Adresse, wohin geschrieben werden soll, und der Rest wird als Daten verarbeitet, die in aufeinander folgende Speicherstellen geschrieben werden.</p></div><div class=paragraph><p>Falls Sie die aktuellen Register wissen möchten, benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> show reg</code></pre></div></div><div class=paragraph><p>Alternativ können Sie den Inhalt eines einzelnen Registers ausgeben mit z.B.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> p <span class=nv>$eax</span></code></pre></div></div><div class=paragraph><p>und ihn bearbeiten mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set</span> <span class=nv>$eax</span> new-value</code></pre></div></div><div class=paragraph><p>Sollten Sie irgendeine Kernel-Funktion aus DDB heraus aufrufen wollen, geben Sie einfach ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> call func<span class=o>(</span>arg1, arg2, ...<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Der Rückgabewert wird ausgegeben.</p></div><div class=paragraph><p>Für eine Zusammenfassung aller laufenden Prozesse im Stil von <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> ps</code></pre></div></div><div class=paragraph><p>Nun haben Sie herausgefunden, warum Ihr Kernel fehlschlägt, und möchten neu starten. Denken Sie daran, dass, abhängig von der Schwere vorhergehender Störungen, nicht alle Teile des Kernels wie gewohnt funktionieren könnten. Führen Sie eine der folgenden Aktionen durch, um Ihr System herunterzufahren und neu zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> panic</code></pre></div></div><div class=paragraph><p>Dies wird Ihren Kernel dazu veranlassen abzustürzen, einen Speicherauszug abzulegen und neu zu starten, sodass Sie den Kernspeicherauszug später auf höherer Ebene mit <code>gdb</code> auswerten können. Diesem Befehl muss normalerweise eine weitere <code>continue</code>-Anweisung folgen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> call boot<span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Dürfte ein guter Weg sein, um das laufende System sauber herunterzufahren, alle Festplatten mittels <code>sync()</code> zu schreiben und schließlich, in manchen Fällen, neu zu starten. Solange die Festplatten- und Dateisystemschnittstellen des Kernels nicht beschädigt sind, könnte dies ein guter Weg für ein beinahe sauberes Abschalten sein.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> call cpu_reset<span class=o>()</span></code></pre></div></div><div class=paragraph><p>Dies ist der letzte Ausweg aus der Katastrophe und kommt beinahe dem Drücken des Ausschaltknopfes gleich.</p></div><div class=paragraph><p>Falls Sie eine kurze Zusammenfassung aller Befehle benötigen, geben Sie einfach ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>help</span></code></pre></div></div><div class=paragraph><p>Es ist strengstens empfohlen, eine ausgedruckte Version der <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a>-Manualpage während der Fehlersuche neben sich liegen zu haben. Denken Sie daran, dass es schwer ist, die Online-Hilfe zu lesen, während der Ausführung des Kernels in Einzelschritten.</p></div></div><div class=sect2><h3 id=kerneldebug-online-gdb>10.5. Online-Kernel-Fehlersuche mit GDB auf einem entfernten System<a class=anchor href=#kerneldebug-online-gdb></a></h3><div class=paragraph><p>Diese Funktion wird seit FreeBSD 2.2 unterstützt und ist wirklich sehr geschickt.</p></div><div class=paragraph><p>GDB unterstützt <em>die Fehlersuche von einem entfernten System aus</em> bereits einige Zeit. Dies geschieht unter Benutzung eines sehr einfachen Protokolls über eine serielle Verbindung. Anders als bei den anderen, oben beschriebenen, Vorgehensweisen werden hier zwei Systeme benötigt. Das eine ist das Hostsystem, welches die Umgebung zur Fehlersuche, einschließlich aller Quellen und einer Kopie der Kernel-Binärdatei mit allen Symbolen bereitstellt, und das andere das Zielsystem, welches einfach nur eine Kopie desselben Kernels ausführt (ohne die Informationen zur Fehlersuche).</p></div><div class=paragraph><p>Sie sollten den Kernel im Zweifelsfall mit <code>config -g</code> konfigurieren, <code>DDB</code> in die Konfiguration aufnehmen und den Kernel, wie sonst auch, kompilieren. Dies ergibt, aufgrund der zusätzlichen Informationen zur Fehlersuche, eine umfangreiche Binärdatei. Kopieren Sie diesen Kernel auf das Zielsystem, entfernen Sie die Symbole zur Fehlersuche mit <code>strip -x</code> und starten Sie ihn mit der <code>-d</code>-Boot-Option. Stellen Sie die serielle Verbindung zwischen dem Zielsystem, welches "flags 80" für dessen sio-Gerät gesetzt hat, und dem Hostsystem, welches die Fehlersuche übernimmt, her. Nun wechseln Sie auf dem Hostsystem in das Bauverzeichnis des Ziel-Kernels und starten <code>gdb</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kgdb kernel
GDB is free software and you are welcome to distribute copies of it
 under certain conditions<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show copying&#34;</span> to see the conditions.
There is absolutely no warranty <span class=k>for </span>GDB<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
GDB 4.16 <span class=o>(</span>i386-unknown-freebsd<span class=o>)</span>,
Copyright 1996 Free Software Foundation, Inc...
<span class=o>(</span>kgdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Stellen Sie die entfernte Sitzung zur Fehlersuche ein mit (angenommen, der erste serielle Port ist in Verwendung):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>kgdb<span class=o>)</span> target remote /dev/cuaa0</code></pre></div></div><div class=paragraph><p>Jetzt geben Sie auf dem Zielsystem, welches noch vor Beginn der Gerätesuche in DDB gelangt ist, ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Debugger<span class=o>(</span><span class=s2>&#34;Boot flags requested debugger&#34;</span><span class=o>)</span>
Stopped at Debugger+0x35: movb  <span class=nv>$0</span>, edata+0x51bc
db&gt; gdb</code></pre></div></div><div class=paragraph><p>DDB antwortet dann mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Next <span class=nb>trap </span>will enter GDB remote protocol mode</code></pre></div></div><div class=paragraph><p>Jedesmal wenn Sie <code>gdb</code> eingeben, wird zwischen dem lokalen DDB und entfernten GDB umgeschaltet. Um einen nächsten Trap sofort zu erzwingen, geben Sie einfach <code>s</code> (step) ein. Ihr GDB auf dem Hostsystem erhält nun die Kontrolle über den Ziel-Kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Remote debugging using /dev/cuaa0
Debugger <span class=o>(</span><span class=nv>msg</span><span class=o>=</span>0xf01b0383 <span class=s2>&#34;Boot flags requested debugger&#34;</span><span class=o>)</span>
    at ../../i386/i386/db_interface.c:257
<span class=o>(</span>kgdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Sie können mit dieser Sitzung wie mit jeder anderen GDB-Sitzung umgehen, einschließlich vollem Zugriff auf die Quellen, Starten im gud-Modus innerhalb eines Emacs-Fensters (was Ihnen automatische Quelltext-Ausgabe in einem weiteren Emacs-Fenster bietet), usw.</p></div></div><div class=sect2><h3 id=kerneldebug-console>10.6. Fehlersuche bei einem Konsolen-Treiber<a class=anchor href=#kerneldebug-console></a></h3><div class=paragraph><p>Da Sie nunmal einen Konsolen-Treiber benötigen, um DDB zu starten, ist alles ein wenig komplizierter, sobald der Konsolen-Treiber selbst versagt. Sie erinnern sich vielleicht an die Benutzung einer seriellen Konsole (entweder durch Verändern des Boot-Blocks oder Eingabe von <code>-h</code> an der <code>Boot:</code>-Eingabeaufforderung) und das Anschließen eines Standard-Terminals an Ihren ersten seriellen Port. DDB funktioniert auf jedem konfigurierten Konsolen-Treiber, auch auf einer seriellen Konsole.</p></div></div><div class=sect2><h3 id=kerneldebug-deadlocks>10.7. Fehlersuche bei Deadlocks<a class=anchor href=#kerneldebug-deadlocks></a></h3><div class=paragraph><p>Sie erleben vielleicht mal sogenannte Deadlocks, wobei ein System aufhört, nützliche Arbeit zu machen. Um in einer solchen Situation einen hilfreichen Fehlerbericht zu liefern, benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a>, wie oben beschrieben. Hängen Sie die Ausgabe von <code>ps</code> und <code>trace</code> für verdächtige Prozesse an den Bericht an.</p></div><div class=paragraph><p>Falls möglich, versuchen Sie, weitere Untersuchungen anzustellen. Der Empfang der Ausgaben unten ist besonders dann nützlich, wenn Sie den Auslöser für die Blockade des Systems auf VFS-Ebene vermuten. Fügen Sie die folgenden Optionen</p></div><div class="literalblock programlisting"><div class=content><pre>makeoptions		DEBUG=-g
	options		INVARIANTS
	options		INVARIANT_SUPPORT
	options		WITNESS
	options		DEBUG_LOCKS
	options		DEBUG_VFS_LOCKS
	options		DIAGNOSTIC</pre></div></div><div class=paragraph><p>der Kernel-Konfigurationsdatei hinzu. Wenn die Blockade ausgelöst wird, stellen Sie, zusätzlich der Ausgabe vom <code>ps</code>-Befehl, die Informationen aus <code>show pcpu</code>, <code>show allpcpu</code>, <code>show locks</code>, <code>show alllocks</code>, <code>show lockedvnods</code> und <code>alltrace</code> bereit.</p></div><div class=paragraph><p>Um aussagekräftige Zurückverfolgungen von in Threads aufgeteilten Prozesse zu erhalten, benutzen Sie <code>thread thread-id</code>, um zum Thread-Stack zu wechseln und eine Zurückverfolgung mit <code>where</code> anzustellen.</p></div></div><div class=sect2><h3 id=kerneldebug-options>10.8. Glossar der Kernel-Optionen zur Fehlersuche<a class=anchor href=#kerneldebug-options></a></h3><div class=paragraph><p>Dieser Abschnitt bietet ein kurzes Glossar der zur Kompilierzeit verfügbaren Kernel-Optionen, die die Fehlersuche unterstützen:</p></div><div class=ulist><ul><li><p><code>options KDB</code>: Kompiliert das Kernel-Debugger-Framework ein. Wird von <code>options DDB</code> und <code>options GDB</code> benötigt. Kein oder nur geringer Leistungs-Overhead. Standardmäßig wird bei einer Panic der Debugger gestartet, anstatt automatisch neu zu starten.</p></li><li><p><code>options KDB_UNATTENDED</code>: Setzt den Standard des <code>debug.debugger_on_panic</code>-sysctl-Werts auf 0, welcher regelt, ob der Debugger bei einer Panic gestartet wird. Solange <code>options KDB</code> nicht in den Kernel einkompiliert ist, wird bei einer Panic automatisch neu gestartet; sobald es in den Kernel einkompiliert ist, wird standardmäßig der Debugger gestartet, solange <code>options KDB_UNATTENDED</code> nicht einkompiliert ist. Falls Sie den Kernel-Debugger in den Kernel einkompiliert lassen wollen, aber möchten, dass das System neu startet, wenn Sie nicht zur Stelle sind, um den Debugger zur Diagnose zu benutzen, wählen Sie diese Option.</p></li><li><p><code>options KDB_TRACE</code>: Setzt den Standard des <code>debug.trace_on_panic</code>-sysctl-Werts auf 1, welcher regelt, ob der Debugger bei einer Panic automatisch eine Stack-Ablaufverfolgung ausgibt. Besonders wenn der Kernel mit <code>KDB_UNATTENDED</code> läuft, kann dies hilfreich sein, um grundlegende Informationen zur Fehlersuche auf der seriellen oder Firewire-Konsole zu erhalten, während immer noch zur Wiederherstellung neu gestartet wird.</p></li><li><p><code>options DDB</code>: Kompiliert die Unterstützung für den Konsolen-Debugger DDB ein. Dieser interaktive Debugger läuft auf was auch immer die aktive Konsole des Systems auf niedrigster Ebene ist, dazu gehören die Video-, serielle und Firewire-Konsole. Er bietet grundlegende, eingebaute Möglichkeiten zur Fehlersuche wie zum Beispiel das Erstellen von Stack-Ablaufverfolgungen, das Auflisten von Prozessen und Threads, das Ablegen des Lock-, VM- und Dateisystemstatus und die Verwaltung des Kernel-Speichers. DDB benötigt keine Software, die auf einem zweiten System läuft, oder die Fähigkeit, einen Kernspeicherauszug oder Kernel-Symbole zur vollen Fehlersuche zu erzeugen und bietet detaillierte Fehlerdiagnose des Kernels zur Laufzeit. Viele Fehler können allein unter Benutzung der DDB-Ausgabe untersucht werden. Diese Option hängt von <code>options KDB</code> ab.</p></li><li><p><code>options GDB</code>: Kompiliert die Unterstützung für den Debugger GDB ein, welcher von einem entfernten System aus über ein serielles Kabel oder Firewire agieren kann. Wenn der Debugger gestartet ist, kann GDB dazu verwendet werden, um Struktur-Inhalte einzusehen, Stack-Ablaufverfolgungen zu erzeugen, usw. Bei manchem Kernel-Status ist der Zugriff ungeschickter als mit DDB, welcher dazu in der Lage ist, nützliche Zusammenfassungen des Kernel-Status automatisch zu erstellen wie zum Beispiel das automatische Abgehen der Lock-Fehlersuche oder der Strukturen zur Kernel-Speicher-Verwaltung, und es wird ein zweites System benötigt. Auf der anderen Seite verbindet GDB Informationen aus den Kernel-Quellen mit vollständigen Symbolen zur Fehlersuche, erkennt komplette Datenstrukturdefinitionen, lokale Variablen und ist in Skripten einsetzbar. Diese Option hängt von <code>options KDB</code> ab, ist aber nicht zur Benutzung von GDB auf einem Kernel-Kernspeicherauszug nötig.</p></li><li><p><code>options BREAK_TO_DEBUGGER</code>, <code>options ALT_BREAK_TO_DEBUGGER</code>: Erlaubt ein Abbruch- oder Alternativ-Signal auf der Konsole, um in den Debugger zu gelangen. Falls sich das System ohne eine Panic aufhängt, ist dies ein nützlicher Weg, um den Debugger zu erreichen. Aufgrund der aktuellen Verriegelung durch den Kernel ist ein Abbruch-Signal, das auf einer seriellen Konsole erzeugt wurde, deutlich vertrauenswürdiger beim Gelangen in den Debugger und wird allgemein empfohlen. Diese Option hat kaum oder keine Auswirkung auf den Durchsatz.</p></li><li><p><code>options INVARIANTS</code>: Kompiliert eine große Anzahl an Aussageprüfungen und -tests (Assertion-Checks und -Tests) ein, welche ständig die Intaktheit der Kernel-Datenstrukturen und die Invarianten der Kernel-Algorithmen prüfen. Diese Tests können aufwendig sein und sind deswegen nicht von Anfang an einkompiliert, aber helfen nützliches "fail stop"-Verhalten, wobei bestimmte Gruppen nicht erwünschten Verhaltens den Debugger öffnen, bevor Beschädigungen an Kernel-Daten auftreten, bereitzustellen, welches es einfacher macht, diese auf Fehler hin zu untersuchen. Die Tests beinhalten Säubern von Speicher und use-after-free-Prüfungen, was eine der bedeutenderen Quellen von Overhead ist. Diese Option hängt von <code>options INVARIANT_SUPPORT</code> ab.</p></li><li><p><code>options INVARIANT_SUPPORT</code>: Viele der in <code>options INVARIANTS</code> vorhandenen Tests benötigen veränderte Datenstrukturen und zusätzliche Kernel-Symbole, die festgelegt werden müssen.</p></li><li><p><code>options WITNESS</code>: Diese Option aktiviert Verfolgung und Prüfung von Lock-Anforderungen zur Laufzeit und ist als Werkzeug für die Deadlock-Diagnose von unschätzbarem Wert. WITNESS pflegt ein Diagramm mit erworbenen Lock-Anträgen nach Typ geordnet und prüft bei jedem Erwerb nach Zyklen (implizit oder explizit). Falls ein Zyklus entdeckt wird, werden eine Warnung und eine Stack-Ablaufverfolgung erzeugt und als Hinweis, dass ein möglicher Deadlock gefunden wurde, auf der Konsole ausgegeben. WITNESS wird benötigt, um die DDB-Befehle <code>show locks</code>, <code>show witness</code> und <code>show alllocks</code> benutzen zu können. Diese Debug-Option hat einen bedeutenden Leistung-Overhead, welcher ein ein wenig durch Benutzung von <code>options WITNESS_SKIPSPIN</code> gemildert werden kann. Detaillierte Dokumentation kann in <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a> gefunden werden.</p></li><li><p><code>options WITNESS_SKIPSPIN</code>: Deaktiviert die Prüfung von Spinlock-Lock-Anforderungen mit WITNESS zur Laufzeit. Da Spinlocks am häufigsten im Scheduler angefordert werden und Scheduler-Ereignisse oft auftreten, kann diese Option Systeme, die mit WITNESS laufen, merklich beschleunigen. Diese Option hängt von <code>options WITNESS</code> ab.</p></li><li><p><code>options WITNESS_KDB</code>: Setzt den Standard des <code>debug.witness.kdb</code>-sysctl-Werts auf 1, was bewirkt, dass WITNESS den Debugger aufruft, sobald eine Lock-Anforderungsverletzung vorliegt, anstatt einfach nur eine Warnung auszugeben. Diese Option hängt von <code>options WITNESS</code> ab.</p></li><li><p><code>options SOCKBUF_DEBUG</code>: Führt umfassende Beschaffenheitsprüfungen in Socket-Puffern durch, was nützlich zur Fehlersuche bei Socket-Fehlern und Anzeichen für Ressourceblockaden (Race) in Protokollen und Gerätetreibern, die mit Sockets arbeiten, sein kann. Diese Option hat bedeutende Auswirkung auf die Netzwerkleistung und kann die Zeitverhältnisse bei gegenseitiger Ressourceblockade in Gerätetreibern ändern.</p></li><li><p><code>options DEBUG_VFS_LOCKS</code>: Verfolgt Lock-Anforderungs-Einzelheiten bei lockmgr/vnode-Locks, was die Menge der Informationen, die von <code>show lockdevnods</code> in DDB angezeigt werden, vergrößert. Diese Option hat messbare Auswirkung auf die Leistung.</p></li><li><p><code>options DEBUG_MEMGUARD</code>: Ein Ersatz für die Kernel-Speicher-Zuweisung durch <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>, die das VM-System benutzt, um Lese- und Schreibzugriffe auf zugewiesenen Speicher nach der Freigabe zu entdecken. Details können in <a href="https://man.freebsd.org/cgi/man.cgi?query=memguard&amp;sektion=9&amp;format=html">memguard(9)</a> gefunden werden. Diese Option hat bedeutende Auswirkung auf die Leistung, aber kann sehr nützlich bei der Fehlersuche sein, wenn Kernel-Speicher-Beschädigungen durch Fehler verursacht werden.</p></li><li><p><code>options DIAGNOSTIC</code>: Aktiviert zusätzliche, aufwendigere Diagnosetests analog zu <code>options INVARIANTS</code>.</p></li></ul></div></div></div></div><h1 id=architectures class=sect0>Teil IV: Architekturen<a class=anchor href=#architectures></a></h1><div class=sect1><h2 id=x86>Kapitel 11. x86-Assembler-Programmierung<a class=anchor href=#x86></a></h2><div class=sectionbody><div class=paragraph><p><em>Dieses Kapitel wurde geschrieben von G. Adam Stanislav &lt;<a href=mailto:adam@redprince.net>adam@redprince.net</a>>.</em></p></div><div class=sect2><h3 id=x86-intro>11.1. Synopsis<a class=anchor href=#x86-intro></a></h3><div class=paragraph><p>Assembler-Programmierung unter UNIX® ist höchst undokumentiert. Es wird allgemein angenommen, dass niemand sie jemals benutzen will, da UNIX®-Systeme auf verschiedenen Mikroprozessoren laufen, und man deshalb aus Gründen der Portabilität alles in C schreiben sollte.</p></div><div class=paragraph><p>In Wirklichkeit ist die Portabilität von C größtenteils ein Mythos. Auch C-Programme müssen angepasst werden, wenn man sie von einem UNIX® auf ein anderes portiert, egal auf welchem Prozessor jedes davon läuft. Typischerweise ist ein solches Programm voller Bedingungen, die unterscheiden für welches System es kompiliert wird.</p></div><div class=paragraph><p>Sogar wenn wir glauben, dass jede UNIX®-Software in C, oder einer anderen High-Level-Sprache geschrieben werden sollte, brauchen wir dennoch Assembler-Programmierer: Wer sonst sollte den Abschnitt der C-Bibliothek schreiben, die auf den Kernel zugreift?</p></div><div class=paragraph><p>In diesem Kapitel möchte ich versuchen zu zeigen, wie man Assembler-Sprache verwenden kann, um UNIX®-Programme, besonders unter FreeBSD, zu schreiben.</p></div><div class=paragraph><p>Dieses Kapitel erklärt nicht die Grundlagen der Assembler-Sprache. Zu diesem Thema gibt es bereits genug Quellen (einen vollständigen Online-Kurs finden Sie in Randall Hydes <a href=http://webster.cs.ucr.edu/>Art of Assembly Language</a>; oder falls Sie ein gedrucktes Buch bevorzugen, können Sie einen Blick auf Jeff Duntemanns <a href="http://www.int80h.org/cgi-bin/isbn?isbn=0471375233">Assembly Language Step-by-Step</a> werfen). Jedenfalls sollte jeder Assembler-Programmierer nach diesem Kapitel schnell und effizient Programme für FreeBSD schreiben können.</p></div><div class=paragraph><p>Copyright ® 2000-2001 G. Adam Stanislav. All rights reserved.</p></div></div><div class=sect2><h3 id=x86-the-tools>11.2. Die Werkzeuge<a class=anchor href=#x86-the-tools></a></h3><div class=sect3><h4 id=x86-the-assembler>11.2.1. Der Assembler<a class=anchor href=#x86-the-assembler></a></h4><div class=paragraph><p>Das wichtigste Werkzeug der Assembler-Programmierung ist der Assembler, diese Software übersetzt Assembler-Sprache in Maschinencode.</p></div><div class=paragraph><p>Für FreeBSD stehen zwei verschiedene Assembler zur Verfügung. Der erste ist <a href="https://man.freebsd.org/cgi/man.cgi?query=as&amp;sektion=1&amp;format=html">as(1)</a>, der die traditionelle UNIX®-Assembler-Sprache verwendet. Dieser ist Teil des Systems.</p></div><div class=paragraph><p>Der andere ist /usr/ports/devel/nasm. Dieser benutzt die Intel-Syntax und sein Vorteil ist, dass es Code fü viele Vetriebssysteme übersetzen kann. Er muss gesondert installiert werden, aber ist völlig frei.</p></div><div class=paragraph><p>In diesem Kapitel wird die nasm-Syntax verwendet. Einerseits weil es die meisten Assembler-Programmierer, die von anderen Systemen zu FreeBSD kommen, leichter verstehen werden. Und offen gesagt, weil es das ist, was ich gewohnt bin.</p></div></div><div class=sect3><h4 id=x86-the-linker>11.2.2. Der Linker<a class=anchor href=#x86-the-linker></a></h4><div class=paragraph><p>Die Ausgabe des Assemblers muss, genau wie der Code jedes Compilers, gebunden werden, um eine ausführbare Datei zu bilden.</p></div><div class=paragraph><p>Der Linker <a href="https://man.freebsd.org/cgi/man.cgi?query=ld&amp;sektion=1&amp;format=html">ld(1)</a> ist der Standard und Teil von FreeBSD. Er funktioniert mit dem Code beider Assembler.</p></div></div></div><div class=sect2><h3 id=x86-system-calls>11.3. Systemaufrufe<a class=anchor href=#x86-system-calls></a></h3><div class=sect3><h4 id=x86-default-calling-convention>11.3.1. Standard-Aufrufkonvention<a class=anchor href=#x86-default-calling-convention></a></h4><div class=paragraph><p>Standardmäßig benutzt der FreeBSD-Kernel die C-Aufrufkonvention. Weiterhin wird, obwohl auf den Kernel durch <code>int 80h</code> zugegriffen wird, angenommen, dass das Programm eine Funktion aufruft, die <code>int 80h</code> verwendet, anstatt <code>int 80h</code> direkt aufzurufen.</p></div><div class=paragraph><p>Diese Konvention ist sehr praktisch und der Microsoft®-Konvention von MS-DOS® überlegen. Warum? Weil es die UNIX®-Konvention jedem Programm, egal in welcher Sprache es geschrieben ist, erlaubt auf den Kernel zuzugreifen.</p></div><div class=paragraph><p>Ein Assembler-Programm kann das ebenfalls. Beispielsweise könnten wir eine Datei öffnen:</p></div><div class="literalblock programlisting"><div class=content><pre>kernel:
	int	80h	; Call kernel
	ret

open:
	push	dword mode
	push	dword flags
	push	dword path
	mov	eax, 5
	call	kernel
	add	esp, byte 12
	ret</pre></div></div><div class=paragraph><p>Das ist ein sehr sauberer und portabler Programmierstil. Wenn Sie das Programm auf ein anderes UNIX® portieren, das einen anderen Interrupt oder eie andere Art der Parameterübergabe verwendet, müssen sie nur die Prozedur kernel ändern.</p></div><div class=paragraph><p>Aber Assembler-Programmierer lieben es Taktzyklen zu schinden. Das obige Beispiel benötigt eine <code>call/ret</code>-Kombination. Das können wir entfernen, indem wir einen weiteren Parameter mit <code>push</code> übergeben:</p></div><div class="literalblock programlisting"><div class=content><pre>open:
	push	dword mode
	push	dword flags
	push	dword path
	mov	eax, 5
	push	eax		; Or any other dword
	int	80h
	add	esp, byte 16</pre></div></div><div class=paragraph><p>Die Konstante <span class=constant>5</span>, die wir in <code>EAX</code> ablegen, identifiziert die Kernel-Funktion, die wir aufrufen. In diesem Fall ist das <code>open</code>.</p></div></div><div class=sect3><h4 id=x86-alternate-calling-convention>11.3.2. Alternative Aufruf-Konvention<a class=anchor href=#x86-alternate-calling-convention></a></h4><div class=paragraph><p>FreeBSD ist ein extrem flexibles System. Es bietet noch andere Wege, um den Kernel aufzurufen. Damit diese funktionieren muss allerdings die Linux-Emulation installiert sein.</p></div><div class=paragraph><p>Linux ist ein UNIX®-artiges System. Allerdings verwendet dessen Kernel die gleiche Systemaufruf-Konvention, bei der Parameter in Registern abgelegt werden, wie MS-DOS®. Genau wie bei der UNIX®-Konvention wird die Nummer der Funktion in <code>EAX</code> abgelegt. Allerdings werden die Parameter nicht auf den Stack gelegt, sondern in die Register <code>EBX, ECX, EDX, ESI, EDI, EBP</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>open:
	mov	eax, 5
	mov	ebx, path
	mov	ecx, flags
	mov	edx, mode
	int	80h</pre></div></div><div class=paragraph><p>Diese Konvention hat einen großen Nachteil gegenüber der von UNIX®, was die Assembler-Programmierung angeht: Jedesmal, wenn Sie einen Kernel-Aufruf machen, müssen Sie die Register <code>push</code>en und sie später <code>pop</code>en. Das macht Ihren Code unförmiger und langsamer. Dennoch lässt FreeBSD ihnen die Wahl.</p></div><div class=paragraph><p>Wenn Sie sich für die Linux-Konvention entscheiden, müssen Sie es das System wissen lassen. Nachdem ihr Programm übersetzt und gebunden wurde, müssen Sie die ausführbare Datei kennzeichnen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>%
	brandelf <span class=nt>-t</span> Linux
	filename</code></pre></div></div></div><div class=sect3><h4 id=x86-use-geneva>11.3.3. Welche Konvention Sie verwenden sollten<a class=anchor href=#x86-use-geneva></a></h4><div class=paragraph><p>Wenn Sie speziell für FreeBSD programmieren, sollten Sie die UNIX®-Konvention verwenden: Diese ist schneller, Sie können globale Variablen in Registern ablegen, Sie müssen die ausführbare Datei nicht kennzeichnen und Sie erzwingen nicht die Installation der Linux-Emulation auf dem Zielsystem.</p></div><div class=paragraph><p>Wenn Sie portablen Programmcode erzeugen wollen, der auch unter Linux funktioniert, wollen Sie den FreeBSD-Nutzern vielleicht dennoch den effizientesten Programmcode bieten, der möglich ist. Ich werde Ihnen zeigen, wie Sie das erreichen können, nachdem ich die Grundlagen erklärt habe.</p></div></div><div class=sect3><h4 id=x86-call-numbers>11.3.4. Aufruf-Nummern<a class=anchor href=#x86-call-numbers></a></h4><div class=paragraph><p>Um dem Kernel mitzuteilen welchen Dienst Sie aufrufen, legen Sie dessen Nummer in <code>EAX</code> ab. Natürlich müssen Sie dazu wissen welche Nummer die Richtige ist.</p></div><div class=sect4><h5 id=x86-the-syscalls-file>11.3.4.1. Die Datei <span class=filename>syscalls</span><a class=anchor href=#x86-the-syscalls-file></a></h5><div class=paragraph><p>Die Nummer der Funktionen sind in der Datei <span class=filename>syscalls</span> aufgeführt. Mittels <code>locate syscalls</code> finden Sie diese in verschiedenen Formaten, die alle auf die gleiche Weise aus <span class=filename>syscalls.master</span> erzeugt werden.</p></div><div class=paragraph><p>Die Master-Datei für die UNIX®-Standard-Aufrufkonvention finden sie unter <span class=filename>/usr/src/sys/kern/syscalls.master</span>. Falls Sie die andere Konvention, die im Linux-Emulations-Modus implementiert ist, verwenden möchten, lesen Sie bitte <span class=filename>/usr/src/sys/i386/linux/syscalls.master</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD und Linux unterscheiden sich nicht nur in den Aufrufkonventionen, sie haben teilweise auch verschiedene Nummern für die gleiche Funktion.</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>syscalls.master</span> beschreibt, wie der Aufruf gemacht werden muss:</p></div><div class="literalblock programlisting"><div class=content><pre>0	STD	NOHIDE	{ int nosys(void); } syscall nosys_args int
1	STD	NOHIDE	{ void exit(int rval); } exit rexit_args void
2	STD	POSIX	{ int fork(void); }
3	STD	POSIX	{ ssize_t read(int fd, void *buf, size_t nbyte); }
4	STD	POSIX	{ ssize_t write(int fd, const void *buf, size_t nbyte); }
5	STD	POSIX	{ int open(char *path, int flags, int mode); }
6	STD	POSIX	{ int close(int fd); }
etc...</pre></div></div><div class=paragraph><p>In der ersten Spalte steht die Nummer, die in <code>EAX</code> abgelegt werden muss.</p></div><div class=paragraph><p>Die Spalte ganz rechts sagt uns welche Parameter wir <code>push</code>en müssen. Die Reihenfolge ist dabei <em>von rechts nach links</em>.</p></div><div class=exampleblock><div class=content><div class=paragraph><p>Um beispielsweise eine Datei mittels <code>open</code> zu öffnen, müssen wir zuerst den <code>mode</code> auf den Stack <code>push</code>en, danach die <code>flags</code>, dann die Adresse an der der <code>path</code> gespeichert ist.</p></div></div></div></div></div></div><div class=sect2><h3 id=x86-return-values>11.4. Rückgabewerte<a class=anchor href=#x86-return-values></a></h3><div class=paragraph><p>Ein Systemaufruf wäre meistens nicht sehr nützlich, wenn er nicht irgendeinen Wert zurückgibt: Beispielsweise den Dateideskriptor einer geöffneten Datei, die Anzahl an Bytes die in einen Puffer gelesen wurde, die Systemzeit, etc.</p></div><div class=paragraph><p>Außerdem muss Sie das System informieren, falls ein Fehler auftritt: Wenn eine Datei nicht existiert, die Systemressourcen erschöpft sind, wir ein ungültiges Argument übergeben haben, etc.</p></div><div class=sect3><h4 id=x86-man-pages>11.4.1. Manualpages<a class=anchor href=#x86-man-pages></a></h4><div class=paragraph><p>Der herkömmliche Ort, um nach Informationen über verschiedene Systemaufrufe unter UNIX®-Systemen zu suchen, sind die Manualpages. FreeBSD beschreibt seine Systemaufrufe in Abschnitt 2, manchmal auch Abschnitt 3.</p></div><div class=paragraph><p>In <a href="https://man.freebsd.org/cgi/man.cgi?query=open&amp;sektion=2&amp;format=html">open(2)</a> steht beispielsweise:</p></div><div class="paragraph blockquote"><p>Falls erfolgreich, gibt <code>open()</code> einen nicht negativen Integerwert, als Dateideskriptor bezeichnet, zurück. Es gibt <code>-1</code> im Fehlerfall zurück und setzt <code>errno</code> um den Fehler anzuzeigen.</p></div><div class=paragraph><p>Ein Assembler-Programmierer, der neu bei UNIX® und FreeBSD ist, wird sich sofort fragen: Wo finde ich <code>errno</code> und wie erreiche ich es?</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Information der Manualpage bezieht sich auf C-Programme. Der Assembler-Programmierer benötigt zusätzliche Informationen.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-where-return-values>11.4.2. Wo sind die Rückgabewerde?<a class=anchor href=#x86-where-return-values></a></h4><div class=paragraph><p>Leider gilt: Es kommt darauf an…​ Für die meisten Systemaufrufe liegt er in <code>EAX</code>, aber nicht für alle. Eine gute Daumenregel, wenn man zum ersten Mal mit einem Systemaufruf arbeitet, ist in <code>EAX</code> nach dem Rückgabewert zu suchen. Wenn er nicht dort ist, sind weitere Untersuchungen nötig.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Mir ist ein Systemaufruf bekannt, der den Rückgabewert in <code>EDX</code> ablegt: <code>SYS_fork</code> Alle anderen mit denen ich bisher gearbeitet habe verwenden <code>EAX</code>. Allerdings habe ich noch nicht mit allen gearbeitet.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Wenn Sie die Antwort weder hier, noch irgendwo anders finden, studieren Sie den Quelltext von libc und sehen sich an, wie es mit dem Kernel zusammenarbeitet.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-where-errno>11.4.3. Wo ist <code>errno</code>?<a class=anchor href=#x86-where-errno></a></h4><div class=paragraph><p>Tatsächlich, nirgendwo…​</p></div><div class=paragraph><p><code>errno</code> ist ein Teil der Sprache C, nicht des UNIX®-Kernels. Wenn man direkt auf Kernel-Dienste zugreift, wird der Fehlercode in <code>EAX</code> zurückgegeben, das selbe Register in dem der Rückgabewert, bei einem erfolgreichen Aufruf landet.</p></div><div class=paragraph><p>Das macht auch Sinn. Wenn kein Fehler auftritt, gibt es keinen Fehlercode. Wenn ein Fehler auftritt, gibt es keinen Rückgabewert. Ein einziges Register kann also beides enthalten.</p></div></div><div class=sect3><h4 id=x86-how-to-know-error>11.4.4. Feststellen, dass ein Fehler aufgetreten ist<a class=anchor href=#x86-how-to-know-error></a></h4><div class=paragraph><p>Wenn Sie die Standard FreeBSD-Aufrufkonvention verwenden wird das <code>carry flag</code> gelöscht wenn der Aufruf erfolgreich ist und gesetzt wenn ein Fehler auftritt.</p></div><div class=paragraph><p>Wenn Sie den Linux-Emulationsmodus verwenden ist der vorzeichenbehaftete Wert in <code>EAX</code> nicht negativ, bei einem erfolgreichen Aufruf. Wenn ein Fehler auftritt ist der Wert negativ, also <code>-errno</code>.</p></div></div></div><div class=sect2><h3 id=x86-portable-code>11.5. Portablen Code erzeugen<a class=anchor href=#x86-portable-code></a></h3><div class=paragraph><p>Portabilität ist im Allgemeinen keine Stärke der Assembler-Programmierung. Dennoch ist es, besonders mit nasm, möglich Assembler-Programme für verschiedene Plattformen zu schreiben. Ich selbst habe bereits Assembler-Bibliotheken geschrieben die auf so unterschiedlichen Systemen wie Windows® und FreeBSD übersetzt werden können.</p></div><div class=paragraph><p>Das ist um so besser möglich, wenn Ihr Code auf zwei Plattformen laufen soll , die, obwohl sie verschieden sind, auf ähnlichen Architekturen basieren.</p></div><div class=paragraph><p>Beispielsweise ist FreeBSD ein UNIX®, während Linux UNIX®-artig ist. Ich habe bisher nur drei Unterschiede zwischen beiden (aus Sicht eines Assembler-Programmierers) erwähnt: Die Aufruf-Konvention, die Funktionsnummern und die Art der Übergabe von Rückgabewerten.</p></div><div class=sect3><h4 id=x86-deal-with-function-numbers>11.5.1. Mit Funktionsnummern umgehen<a class=anchor href=#x86-deal-with-function-numbers></a></h4><div class=paragraph><p>In vielen Fällen sind die Funktionsnummern die selben. Allerdings kann man auch wenn sie es nicht sind leicht mit diesem Problem umgehen: Anstatt die Nummern in Ihrem Code zu verwenden, benutzen Sie Konstanten, die Sie abhängig von der Zielarchitektur unterschiedlich definieren:</p></div><div class="literalblock programlisting"><div class=content><pre>%ifdef	LINUX
%define	SYS_execve	11
%else
%define	SYS_execve	59
%endif</pre></div></div></div><div class=sect3><h4 id=x86-deal-with-geneva>11.5.2. Umgang mit Konventionen<a class=anchor href=#x86-deal-with-geneva></a></h4><div class=paragraph><p>Sowohl die Aufrufkonvention, als auch die Rückgabewerte (das <code>errno</code> Problem) kann man mit Hilfe von Makros lösen:</p></div><div class="literalblock programlisting"><div class=content><pre>%ifdef	LINUX

%macro	system	0
	call	kernel
%endmacro

align 4
kernel:
	push	ebx
	push	ecx
	push	edx
	push	esi
	push	edi
	push	ebp

	mov	ebx, [esp+32]
	mov	ecx, [esp+36]
	mov	edx, [esp+40]
	mov	esi, [esp+44]
	mov	ebp, [esp+48]
	int	80h

	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx

	or	eax, eax
	js	.errno
	clc
	ret

.errno:
	neg	eax
	stc
	ret

%else

%macro	system	0
	int	80h
%endmacro

%endif</pre></div></div></div><div class=sect3><h4 id=x86-deal-with-other-portability>11.5.3. Umgang mit anderen Portabilitätsangelegenheiten<a class=anchor href=#x86-deal-with-other-portability></a></h4><div class=paragraph><p>Die oben genannte Lösung funktioniert in den meisten Fällen, wenn man Code schreibt, der zwischen FreeBSD und Linux portierbar sein soll. Allerdings sind die Unterschiede bei einigen Kernel-Diensten tiefgreifender.</p></div><div class=paragraph><p>In diesem Fällen müssen Sie zwei verschiedene Handler für diese Systemaufrufe schreiben und bedingte Assemblierung benutzen, um diese zu übersetzen. Glücklicherweise wird der größte Teil Ihres Codes nicht den Kernel aufrufen und Sie werden deshalb nur wenige solcher bedingten Abschnitte benötigen.</p></div></div><div class=sect3><h4 id=x86-portable-library>11.5.4. Eine Bibliothek benutzen<a class=anchor href=#x86-portable-library></a></h4><div class=paragraph><p>Sie können Portabilitätsprobleme im Hauptteil ihres Codes komplett vermeiden, indem Sie eine Bibliothek für Systemaufrufe schreiben. Erstellen Sie eine Bibliothek für FreeBSD, eine für Linux und weitere für andere Betriebssysteme.</p></div><div class=paragraph><p>Schreiben Sie in ihrer Bibliothek eine gesonderte Funktion (oder Prozedur, falls Sie die traditionelle Assembler-Terminologie bevorzugen) für jeden Systemaufruf. Verwenden Sie dabei die C-Aufrufkonvention um Parameter zu übergeben, aber verwenden Sie weiterhin <code>EAX</code>, für die Aufrufnummer. In diesem Fall kann ihre FreeBSD-Bibliothek sehr einfach sein, da viele scheinbar unterschiedliche Funktionen als Label für denselben Code implementiert sein können:</p></div><div class="literalblock programlisting"><div class=content><pre>sys.open:
sys.close:
[etc...]
	int	80h
	ret</pre></div></div><div class=paragraph><p>Ihre Linux-Bibliothek wird mehr verschiedene Funktionen benötigen, aber auch hier können Sie Systemaufrufe, welche die Anzahl an Parametern akzeptieren zusammenfassen:</p></div><div class="literalblock programlisting"><div class=content><pre>sys.exit:
sys.close:
[etc... one-parameter functions]
	push	ebx
	mov	ebx, [esp+12]
	int	80h
	pop	ebx
	jmp	sys.return

...

sys.return:
	or	eax, eax
	js	sys.err
	clc
	ret

sys.err:
	neg	eax
	stc
	ret</pre></div></div><div class=paragraph><p>Der Bibliotheks-Ansatz mag auf den ersten Blick unbequem aussehen, weil Sie eine weitere Datei erzeugen müssen von der Ihr Code abhängt. Aber er hat viele Vorteile: Zum einen müssen Sie die Bibliothek nur einmal schreiben und können sie dann in allen Ihren Programmen verwenden. Sie können sie sogar von anderen Assembler-Programmierern verwenden lassen, oder eine die von jemand anderem geschrieben wurde verwenden. Aber der vielleicht größte Vorteil ist, dass Ihr Code sogar von anderen Programmierer auf andere Systeme portiert werden kann, einfach indem man eine neue Bibliothek schreibt, völlig ohne Änderungen an Ihrem Code.</p></div><div class=paragraph><p>Falls Ihnen der Gedanke eine Bibliothek zu nutzen nicht gefällt, können Sie zumindest all ihre Systemaufrufe in einer gesonderten Assembler-Datei ablegen und diese mit Ihrem Hauptprogramm zusammen binden. Auch hier müssen alle, die ihr Programm portieren, nur eine neue Objekt-Datei erzeugen und an Ihr Hauptprogramm binden.</p></div></div><div class=sect3><h4 id=x86-portable-include>11.5.5. Eine Include-Datei verwenden<a class=anchor href=#x86-portable-include></a></h4><div class=paragraph><p>Wenn Sie ihre Software als (oder mit dem) Quelltext ausliefern, können Sie Makros definieren und in einer getrennten Datei ablegen, die Sie ihrem Code beilegen.</p></div><div class=paragraph><p>Porter Ihrer Software schreiben dann einfach eine neue Include-Datei. Es ist keine Bibliothek oder eine externe Objekt-Datei nötig und Ihr Code ist portabel, ohne dass man ihn editieren muss.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das ist der Ansatz den wir in diesem Kapitel verwenden werden. Wir werden unsere Include-Datei <span class=filename>system.inc</span> nennen und jedesmal, wenn wir einen neuen Systemaufruf verwenden, den entsprechenden Code dort einfügen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wir können unsere <span class=filename>system.inc</span> beginnen indem wir die Standard-Dateideskriptoren deklarieren:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	stdin	0
%define	stdout	1
%define	stderr	2</pre></div></div><div class=paragraph><p>Als Nächstes erzeugen wir einen symbolischen Namen für jeden Systemaufruf:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_nosys	0
%define	SYS_exit	1
%define	SYS_fork	2
%define	SYS_read	3
%define	SYS_write	4
; [etc...]</pre></div></div><div class=paragraph><p>Wir fügen eine kleine, nicht globale Prozedur mit langem Namen ein, damit wir den Namen nicht aus Versehen in unserem Code wiederverwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>section	.text
align 4
access.the.bsd.kernel:
	int	80h
	ret</pre></div></div><div class=paragraph><p>Wir erzeugen ein Makro, das ein Argument erwartet, die Systemaufruf-Nummer:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	system	1
	mov	eax, %1
	call	access.the.bsd.kernel
%endmacro</pre></div></div><div class=paragraph><p>Letztlich erzeugen wir Makros für jeden Systemaufruf. Diese Argumente erwarten keine Argumente.</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.exit	0
	system	SYS_exit
%endmacro

%macro	sys.fork	0
	system	SYS_fork
%endmacro

%macro	sys.read	0
	system	SYS_read
%endmacro

%macro	sys.write	0
	system	SYS_write
%endmacro

; [etc...]</pre></div></div><div class=paragraph><p>Fahren Sie fort, geben das in Ihren Editor ein und speichern es als <span class=filename>system.inc</span>. Wenn wir Systemaufrufe besprechen, werden wir noch Ergänzungen in dieser Datei vornehmen.</p></div></div></div><div class=sect2><h3 id=x86-first-program>11.6. Unser erstes Programm<a class=anchor href=#x86-first-program></a></h3><div class=paragraph><p>Jetzt sind wir bereit für unser erstes Programm, das übliche Hello, World!</p></div><div class="literalblock programlisting"><div class=content><pre> 1:	%include	&#39;system.inc&#39;
 2:
 3:	section	.data
 4:	hello	db	&#39;Hello, World!&#39;, 0Ah
 5:	hbytes	equ	$-hello
 6:
 7:	section	.text
 8:	global	_start
 9:	_start:
10:	push	dword hbytes
11:	push	dword hello
12:	push	dword stdout
13:	sys.write
14:
15:	push	dword 0
16:	sys.exit</pre></div></div><div class=paragraph><p>Hier folgt die Erklärung des Programms: Zeile 1 fügt die Definitionen ein, die Makros und den Code aus <span class=filename>system.inc</span>.</p></div><div class=paragraph><p>Die Zeilen 3 bis 5 enthalten die Daten: Zeile 3 beginnt den Datenabschnitt/das Datensegment. Zeile 4 enthält die Zeichenkette "Hello, World!", gefolgt von einem Zeilenumbruch (<span class=constant>0Ah</span>). Zeile 5 erstellt eine Konstante, die die Länge der Zeichenkette aus Zeile 4 in Bytes enthält.</p></div><div class=paragraph><p>Die Zeilen 7 bis 16 enthalten den Code. Beachten Sie bitte, dass FreeBSD das Dateiformat <em>elf</em> für diese ausführbare Datei verwendet, bei dem jedes Programm mit dem Label <code>_start</code> beginnt (oder, um genau zu sein, wird dies vom Linker erwartet). Diese Label muss global sein.</p></div><div class=paragraph><p>Die Zeilen 10 bis 13 weisen das System an <code>hbytes</code> Bytes der Zeichenkette <code>hello</code> nach <code>stdout</code> zu schreiben.</p></div><div class=paragraph><p>Die Zeilen 15 und 16 weisen das System an das Programm mit dem Rückgabewert <span class=constant>0</span> zu beenden. Der Systemaufruf <code>SYS_exit</code> kehrt niemals zurück, somit endet das Programm hier.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie von MS-DOS®-Assembler zu UNIX® gekommen sind, sind Sie es vielleicht gewohnt direktauf die Video-Hardware zu schreiben. Unter FreeBSD müssen Sie sich darum keine Gedanken machen, ebenso bei jeder anderen Art von UNIX®. Soweit es Sie betrifft schreiben Sie in eine Datei namens <span class=filename>stdout</span>. Das kann der Bildschirm, oder ein telnet-Terminal, eine wirkliche Datei, oder die Eingabe eines anderen Programms sein. Es liegt beim System herauszufinden, welches davon es tatsächlich ist.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=x86-assemble-1>11.6.1. Den Code assemblieren<a class=anchor href=#x86-assemble-1></a></h4><div class=paragraph><p>Geben Sie den Code (außer den Zeilennummern) in einen Editor ein und speichern Sie ihn in einer Datei namens <span class=filename>hello.asm</span>. Um es zu assemblieren benötigen Sie nasm.</p></div><div class=sect4><h5 id=x86-get-nasm>11.6.1.1. nasm installieren<a class=anchor href=#x86-get-nasm></a></h5><div class=paragraph><p>Wenn Sie nasm noch nicht installiert haben geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:your root password
<span class=c># cd /usr/ports/devel/nasm</span>
<span class=c># make install</span>
<span class=c># exit</span>
%</code></pre></div></div><div class=paragraph><p>Sie können auch <code>make install clean</code> anstatt <code>make install</code> eingeben, wenn Sie den Quelltext von nasm nicht behalten möchten.</p></div><div class=paragraph><p>Auf jeden Fall wird FreeBSD nasm automatisch aus dem Internet herunterladen, es kompilieren und auf Ihrem System installieren.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn es sich bei Ihrem System nicht um FreeBSD handelt, müssen Sie nasm von dessen <a href=https://sourceforge.net/projects/nasm>Homepage</a> herunterladen. Sie können es aber dennoch verwenden um FreeBSD code zu assemblieren.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nun können Sie den Code assemblieren, binden und ausführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hello.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hello hello.o
% ./hello
Hello, World!
%</code></pre></div></div></div></div></div><div class=sect2><h3 id=x86-unix-filters>11.7. UNIX®-Filter schreiben<a class=anchor href=#x86-unix-filters></a></h3><div class=paragraph><p>Ein häufiger Typ von UNIX®-Anwendungen ist ein Filter - ein Programm, das Eingaben von <span class=filename>stdin</span> liest, sie verarbeitet und das Ergebnis nach <span class=filename>stdout</span> schreibt.</p></div><div class=paragraph><p>In diesem Kapitel möchten wir einen einfachen Filter entwickeln und lernen, wie wir von <span class=filename>stdin</span> lesen und nach <span class=filename>stdout</span> schreiben. Dieser Filter soll jedes Byte seiner Eingabe in eine hexadezimale Zahl gefolgt von einem Leerzeichen umwandeln.</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

section	.data
hex	db	&#39;0123456789ABCDEF&#39;
buffer	db	0, 0, &#39; &#39;

section	.text
global	_start
_start:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short _start

.done:
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>Im Datenabschnitt erzeugen wir ein Array mit Namen <code>hex</code>. Es enthält die 16 hexadezimalen Ziffern in aufsteigender Reihenfolge. Diesem Array folgt ein Puffer, den wir sowohl für die Ein- als auch für die Ausgabe verwenden. Die ersten beiden Bytes dieses Puffers werden am Anfang auf <span class=constant>0</span> gesetzt. Dorthin schreiben wir die beiden hexadezimalen Ziffern (das erste Byte ist auch die Stelle an die wir die Eingabe lesen). Das dritte Byte ist ein Leerzeichen.</p></div><div class=paragraph><p>Der Code-Abschnitt besteht aus vier Teilen: Das Byte lesen, es in eine hexadezimale Zahl umwandeln, das Ergebnis schreiben und letztendlich das Programm verlassen.</p></div><div class=paragraph><p>Um das Byte zu lesen, bitten wir das System ein Byte von <span class=filename>stdin</span> zu lesen und speichern es im ersten Byte von <code>buffer</code>. Das System gibt die Anzahl an Bytes, die gelesen wurden, in <code>EAX</code> zurück. Diese wird <span class=constant>1</span> sein, wenn eine Eingabe empfangen wird und <span class=constant>0</span>, wenn keine Eingabedaten mehr verfügbar sind. Deshalb überprüfen wir den Wert von <code>EAX</code>. Wenn dieser <span class=constant>0</span> ist, springen wir zu <code>.done</code>, ansonsten fahren wir fort.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Zu Gunsten der Einfachheit ignorieren wir hier die Möglichkeit eines Fehlers.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Umwandlungsroutine in eine Hexadezimalzahl liest das Byte aus <code>buffer</code> in <code>EAX</code>, oder genaugenommen nur in <code>AL</code>, wobei die übrigen Bits von <code>EAX</code> auf null gesetzt werden. Außerdem kopieren wir das Byte nach <code>EDX</code>, da wir die oberen vier Bits (Nibble) getrennt von den unteren vier Bits umwandeln müssen. Das Ergebnis speichern wir in den ersten beiden Bytes des Puffers.</p></div><div class=paragraph><p>Als Nächstes bitten wir das System die drei Bytes in den Puffer zu schreiben, also die zwei hexadezimalen Ziffern und das Leerzeichen nach <span class=filename>stdout</span>. Danach springen wir wieder an den Anfang des Programms und verarbeiten das nächste Byte.</p></div><div class=paragraph><p>Wenn die gesamte Eingabe verarbeitet ist, bitten wie das System unser Programm zu beenden und null zurückzuliefern, welches traditionell die Bedeutung hat, dass unser Programm erfolgreich war.</p></div><div class=paragraph><p>Fahren Sie fort und speichern Sie den Code in eine Datei namens <span class=filename>hex.asm</span>. Geben Sie danach folgendes ein (<code>^D</code> bedeutet, dass Sie die Steuerungstaste drücken und dann <code>D</code> eingeben, während Sie Steuerung gedrückt halten):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A ^D %</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie von MS-DOS® zu UNIX® wechseln, wundern Sie sich vielleicht, warum jede Zeile mit <span class=constant>0A</span> an Stelle von <span class=constant>0D 0A</span> endet. Das liegt daran, dass UNIX® nicht die CR/LF-Konvention, sondern die "new line"-Konvention verwendet, welches hexadezimal als <span class=constant>0A</span> dargestellt wird.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Können wir das Programm verbessern? Nun, einerseits ist es etwas verwirrend, dass die Eingabe, nachdem wir eine Zeile verarbeitet haben, nicht wieder am Anfang der Zeile beginnt. Deshalb können wir unser Programm anpassen um einen Zeilenumbruch an Stelle eines Leerzeichens nach jedem <span class=constant>0A</span> auszugeben:</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

section	.data
hex	db	&#39;0123456789ABCDEF&#39;
buffer	db	0, 0, &#39; &#39;

section	.text
global	_start
_start:
	mov	cl, &#39; &#39;

.loop:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	[buffer+2], cl
	cmp	al, 0Ah
	jne	.hex
	mov	[buffer+2], al

.hex:
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short .loop

.done:
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>Wir haben das Leerzeichen im Register <code>CL</code> abgelegt. Das können wir bedenkenlos tun, da UNIX®-Systemaufrufe im Gegensatz zu denen von Microsoft® Windows® keine Werte von Registern ändern in denen sie keine Werte zurückliefern.</p></div><div class=paragraph><p>Das bedeutet, dass wir <code>CL</code> nur einmal setzen müssen. Dafür haben wir ein neues Label <code>.loop</code> eingefügt, zu dem wir an Stelle von <code>_start</code> springen, um das nächste Byte einzulesen. Außerdem haben wir das Label <code>.hex</code> eingefügt, somit können wir wahlweise ein Leerzeichen oder einen Zeilenumbruch im dritten Byte von <code>buffer</code> ablegen.</p></div><div class=paragraph><p>Nachdem Sie <span class=filename>hex.asm</span> entsprechend der Neuerungen geändert haben, geben Sie Folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>Das sieht doch schon besser aus. Aber der Code ist ziemlich ineffizient! Wir führen für jeden einzelne Byte zweimal einen Systemaufruf aus (einen zum Lesen und einen um es in die Ausgabe zu schreiben).</p></div></div><div class=sect2><h3 id=x86-buffered-io>11.8. Gepufferte Eingabe und Ausgabe<a class=anchor href=#x86-buffered-io></a></h3><div class=paragraph><p>Wir können die Effizienz unseres Codes erhöhen, indem wir die Ein- und Ausgabe puffern. Wir erzeugen einen Eingabepuffer und lesen dann eine Folge von Bytes auf einmal. Danach holen wir sie Byte für Byte aus dem Puffer.</p></div><div class=paragraph><p>Wir erzeugen ebenfalls einen Ausgabepuffer. Darin speichern wir unsere Ausgabe bis er voll ist. Dann bitten wir den Kernel den Inhalt des Puffers nach <span class=filename>stdout</span> zu schreiben.</p></div><div class=paragraph><p>Diese Programm endet, wenn es keine weitere Eingaben gibt. Aber wir müssen den Kernel immernoch bitten den Inhalt des Ausgabepuffers ein letztes Mal nach <span class=filename>stdout</span> zu schreiben, denn sonst würde ein Teil der Ausgabe zwar im Ausgabepuffer landen, aber niemals ausgegeben werden. Bitte vergessen Sie das nicht, sonst fragen Sie sich später warum ein Teil Ihrer Ausgabe verschwunden ist.</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>Als dritten Abschnitt im Quelltext haben wir <code>.bss</code>. Dieser Abschnitt wird nicht in unsere ausführbare Datei eingebunden und kann daher nicht initialisiert werden. Wir verwenden <code>resb</code> anstelle von <code>db</code>. Dieses reserviert einfach die angeforderte Menge an uninitialisiertem Speicher zu unserer Verwendung.</p></div><div class=paragraph><p>Wir nutzen, die Tatsache, dass das System die Register nicht verändert: Wir benutzen Register, wo wir anderenfalls globale Variablen im Abschnitt <code>.data</code> verwenden müssten. Das ist auch der Grund, warum die UNIX®-Konvention, Parameter auf dem Stack zu übergeben, der von Microsoft, hierfür Register zu verwenden, überlegen ist: Wir können Register für unsere eigenen Zwecke verwenden.</p></div><div class=paragraph><p>Wir verwenden <code>EDI</code> und <code>ESI</code> als Zeiger auf das nächste zu lesende oder schreibende Byte. Wir verwenden <code>EBX</code> und <code>ECX</code>, um die Anzahl der Bytes in den beiden Puffern zu zählen, damit wir wissen, wann wir die Ausgabe an das System übergeben, oder neue Eingabe vom System entgegen nehmen müssen.</p></div><div class=paragraph><p>Lassen Sie uns sehen, wie es funktioniert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
Here I come!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>Nicht was Sie erwartet haben? Das Programm hat die Ausgabe nicht auf dem Bildschirm ausgegeben bis sie <code>^D</code> gedrückt haben. Das kann man leicht zu beheben indem man drei Zeilen Code einfügt, welche die Ausgabe jedesmal schreiben, wenn wir einen Zeilenumbruch in <span class=constant>0A</span> umgewandelt haben. Ich habe die betreffenden Zeilen mit > markiert (kopieren Sie die > bitte nicht mit in Ihre <span class=filename>hex.asm</span>).</p></div><div class="literalblock programlisting"><div class=content><pre>%include    &#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
&gt;	cmp	al, 0Ah
&gt;	jne	.loop
&gt;	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>Lassen Sie uns jetzt einen Blick darauf werfen, wie es funktioniert.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>Nicht schlecht für eine 644 Byte große Binärdatei, oder?</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dieser Ansatz für gepufferte Ein- und Ausgabe enthält eine Gefahr, auf die ich im Abschnitt <a href=#x86-buffered-dark-side>Die dunkle Seite des Buffering</a> eingehen werde.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=x86-ungetc>11.8.1. Ein Zeichen ungelesen machen<a class=anchor href=#x86-ungetc></a></h4><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Das ist vielleicht ein etwas fortgeschrittenes Thema, das vor allem für Programmierer interessant ist, die mit der Theorie von Compilern vertraut sind. Wenn Sie wollen, können Sie <a href=#x86-command-line>zum nächsten Abschnitt springen</a> und das hier vielleicht später lesen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Unser Beispielprogramm benötigt es zwar nicht, aber etwas anspruchsvollere Filter müssen häufig vorausschauen. Mit anderen Worten, sie müssen wissen was das nächste Zeichen ist (oder sogar mehrere Zeichen). Wenn das nächste Zeichen einen bestimmten Wert hat, ist es Teil des aktuellen Tokens, ansonsten nicht.</p></div><div class=paragraph><p>Zum Beispiel könnten Sie den Eingabestrom für eine Text-Zeichenfolge parsen (z.B. wenn Sie einen Compiler einer Sprache implementieren): Wenn einem Buchstaben ein anderer Buchstabe oder vielleicht eine Ziffer folgt, ist er ein Teil des Tokens, das Sie verarbeiten. Wenn ihm ein Leerzeichen folgt, oder ein anderer Wert, ist er nicht Teil des aktuellen Tokens.</p></div><div class=paragraph><p>Das führt uns zu einem interessanten Problem: Wie kann man ein Zeichen zurück in den Eingabestrom geben, damit es später noch einmal gelesen werden kann?</p></div><div class=paragraph><p>Eine mögliche Lösung ist, das Zeichen in einer Variable zu speichern und ein Flag zu setzen. Wir können <code>getchar</code> so anpassen, dass es das Flag überprüft und, wenn es gesetzt ist, das Byte aus der Variable anstatt dem Eingabepuffer liest und das Flag zurück setzt. Aber natürlich macht uns das langsamer.</p></div><div class=paragraph><p>Die Sprache C hat eine Funktion <code>ungetc()</code> für genau diesen Zweck. Gibt es einen schnellen Weg, diese in unserem Code zu implementieren? Ich möchte Sie bitten nach oben zu scrollen und sich die Prozedur <code>getchar</code> anzusehen und zu versuchen eine schöne und schnelle Lösung zu finden, bevor Sie den nächsten Absatz lesen. Kommen Sie danach hierher zurück und schauen sich meine Lösung an.</p></div><div class=paragraph><p>Der Schlüssel dazu ein Zeichen an den Eingabestrom zurückzugeben, liegt darin, wie wir das Zeichen bekommen:</p></div><div class=paragraph><p>Als erstes überprüfen wir, ob der Puffer leer ist, indem wir den Wert von <code>EBX</code> testen. Wenn er null ist, rufen wir die Prozedur <code>read</code> auf.</p></div><div class=paragraph><p>Wenn ein Zeichen bereit ist verwenden wir <code>lodsb</code>, dann verringern wir den Wert von <code>EBX</code>. Die Anweisung <code>lodsb</code> ist letztendlich identisch mit:</p></div><div class="literalblock programlisting"><div class=content><pre>	mov	al, [esi]
	  inc	esi</pre></div></div><div class=paragraph><p>Das Byte, welches wir abgerufen haben, verbleibt im Puffer bis <code>read</code> zum nächsten Mal aufgerufen wird. Wir wissen nicht wann das passiert, aber wir wissen, dass es nicht vor dem nächsten Aufruf von <code>getchar</code> passiert. Daher ist alles was wir tun müssen um das Byte in den Strom "zurückzugeben" ist den Wert von <code>ESI</code> zu verringern und den von <code>EBX</code> zu erhöhen:</p></div><div class="literalblock programlisting"><div class=content><pre>ungetc:
	  dec	esi
	  inc	ebx
	  ret</pre></div></div><div class=paragraph><p>Aber seien Sie vorsichtig! Wir sind auf der sicheren Seite, solange wir immer nur ein Zeichen im Voraus lesen. Wenn wir mehrere kommende Zeichen betrachten und <code>ungetc</code> mehrmals hintereinander aufrufen, wird es meistens funktionieren, aber nicht immer (und es wird ein schwieriger Debug). Warum?</p></div><div class=paragraph><p>Solange <code>getchar<code>read</code> nicht aufrufen muss, befinden sich alle im Voraus gelesenen Bytes noch im Puffer und <code>ungetc</code> arbeitet fehlerfrei. Aber sobald <code>getchar</code>read</code> aufruft verändert sich der Inhalt des Puffers.</p></div><div class=paragraph><p>Wir können uns immer darauf verlassen, dass <code>ungetc</code> auf dem zuletzt mit <code>getchar</code> gelesenen Zeichen korrekt arbeitet, aber nicht auf irgendetwas, das davor gelesen wurde.</p></div><div class=paragraph><p>Wenn Ihr Programm mehr als ein Byte im Voraus lesen soll, haben Sie mindestens zwei Möglichkeiten:</p></div><div class=paragraph><p>Die einfachste Lösung ist, Ihr Programm so zu ändern, dass es immer nur ein Byte im Voraus liest, wenn das möglich ist.</p></div><div class=paragraph><p>Wenn Sie diese Möglichkeit nicht haben, bestimmen Sie zuerst die maximale Anzahl an Zeichen, die Ihr Programm auf einmal an den Eingabestrom zurückgeben muss. Erhöhen Sie diesen Wert leicht, nur um sicherzugehen, vorzugsweise auf ein Vielfaches von 16-damit er sich schön ausrichtet. Dann passen Sie den <code>.bss</code> Abschnitt Ihres Codes an und erzeugen einen kleinen Reserver-Puffer, direkt vor ihrem Eingabepuffer, in etwa so:</p></div><div class="literalblock programlisting"><div class=content><pre>section	.bss
	  resb	16	; or whatever the value you came up with
  ibuffer	resb	BUFSIZE
  obuffer	resb	BUFSIZE</pre></div></div><div class=paragraph><p>Außerdem müssen Sie <code>ungetc</code> anpassen, sodass es den Wert des Bytes, das zurückgegeben werden soll, in <code>AL</code> übergibt:</p></div><div class="literalblock programlisting"><div class=content><pre>ungetc:
	  dec	esi
	  inc	ebx
	  mov	[esi], al
	  ret</pre></div></div><div class=paragraph><p>Mit dieser Änderung können Sie sicher <code>ungetc</code> bis zu 17 Mal hintereinander gqapaufrufen (der erste Aufruf erfolgt noch im Puffer, die anderen 16 entweder im Puffer oder in der Reserve).</p></div></div></div><div class=sect2><h3 id=x86-command-line>11.9. Kommandozeilenparameter<a class=anchor href=#x86-command-line></a></h3><div class=paragraph><p>Unser hex-Programm wird nützlicher, wenn es die Dateinamen der Ein- und Ausgabedatei über die Kommandozeile einlesen kann, d.h., wenn es Kommandozeilenparameter verarbeiten kann. Aber…​ Wo sind die?</p></div><div class=paragraph><p>Bevor ein UNIX®-System ein Programm ausführt, legt es einige Daten auf dem Stack ab (<code>push</code>) und springt dann an das <code>_start</code>-Label des Programms. Ja, ich sagte springen, nicht aufrufen. Das bedeutet, dass auf die Daten zugegriffen werden kann, indem <code>[esp+offset]</code> ausgelesen wird oder die Daten einfach vom Stack genommen werden (<code>pop</code>).</p></div><div class=paragraph><p>Der Wert ganz oben auf dem Stack enthält die Zahl der Kommandozeilenparameter. Er wird traditionell <code>argc</code> wie "argument count" genannt.</p></div><div class=paragraph><p>Die Kommandozeilenparameter folgen einander, alle <code>argc</code>. Von diesen wird üblicherweise als <code>argv</code> wie "argument value(s)" gesprochen. So erhalten wir <code>argv[0]</code>, <code>argv[1]</code>, <code>…​</code> und <code>argv[argc-1]</code>. Dies sind nicht die eigentlichen Parameter, sondern Zeiger (Pointer) auf diese, d.h., Speicheradressen der tatsächlichen Parameter. Die Parameter selbst sind durch NULL beendete Zeichenketten.</p></div><div class=paragraph><p>Der <code>argv</code>-Liste folgt ein NULL-Zeiger, was einfach eine <span class=constant>0</span> ist. Es gibt noch mehr, aber dies ist erst einmal genug für unsere Zwecke.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls Sie von der MS-DOS®-Programmierumgebung kommen, ist der größte Unterschied die Tatsache, dass jeder Parameter eine separate Zeichenkette ist. Der zweite Unterschied ist, dass es praktisch keine Grenze gibt, wie viele Parameter vorhanden sein können.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ausgerüstet mit diesen Kenntnissen, sind wir beinahe bereit für eine weitere Version von <span class=filename>hex.asm</span>. Zuerst müssen wir jedoch noch ein paar Zeilen zu <span class=filename>system.inc</span> hinzufügen:</p></div><div class=paragraph><p>Erstens benötigen wir zwei neue Einträge in unserer Liste mit den Systemaufrufnummern:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_open	5
%define	SYS_close	6</pre></div></div><div class=paragraph><p>Zweitens fügen wir zwei neue Makros am Ende der Datei ein:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.open	0
	system	SYS_open
%endmacro

%macro	sys.close	0
	system	SYS_close
%endmacro</pre></div></div><div class=paragraph><p>Und hier ist schließlich unser veränderter Quelltext:</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
err:
	push	dword 1		; return failure
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to input file
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	err		; open failed

	add	esp, byte 8
	mov	[fd.in], eax

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to output file
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	err

	add	esp, byte 12
	mov	[fd.out], eax

.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from input file or stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	cmp	al, dl
	jne	.loop
	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>In unserem <code>.data</code>-Abschnitt befinden sich nun die zwei neuen Variablen <code>fd.in</code> und <code>fd.out</code>. Hier legen wir die Dateideskriptoren der Ein- und Ausgabedatei ab.</p></div><div class=paragraph><p>Im <code>.text</code>-Abschnitt haben wir die Verweise auf <code>stdin</code> und <code>stdout</code> durch <code>[fd.in]</code> und <code>[fd.out]</code> ersetzt.</p></div><div class=paragraph><p>Der <code>.text</code>-Abschnitt beginnt nun mit einer einfachen Fehlerbehandlung, welche nur das Programm mit einem Rückgabewert von <span class=constant>1</span> beendet. Die Fehlerbehandlung befindet sich vor <code>_start</code>, sodass wir in geringer Entfernung von der Stelle sind, an der der Fehler auftritt.</p></div><div class=paragraph><p>Selbstverständlich beginnt die Programmausführung immer noch bei <code>_start</code>. Zuerst entfernen wir <code>argc</code> und <code>argv[0]</code> vom Stack: Sie sind für uns nicht von Interesse (sprich, in diesem Programm).</p></div><div class=paragraph><p>Wir nehmen <code>argv[1]</code> vom Stack und legen es in <code>ECX</code> ab. Dieses Register ist besonders für Zeiger geeignet, da wir mit <code>jecxz</code> NULL-Zeiger verarbeiten können. Falls <code>argv[1]</code> nicht NULL ist, versuchen wir, die Datei zu öffnen, die der erste Parameter festlegt. Andernfalls fahren wir mit dem Programm fort wie vorher: Lesen von <code>stdin</code> und Schreiben nach <code>stdout</code>. Falls wir die Eingabedatei nicht öffnen können (z.B. sie ist nicht vorhanden), springen wir zur Fehlerbehandlung und beenden das Programm.</p></div><div class=paragraph><p>Falls es keine Probleme gibt, sehen wir nun nach dem zweiten Parameter. Falls er vorhanden ist, öffnen wir die Ausgabedatei. Andernfalls schreiben wir die Ausgabe nach <code>stdout</code>. Falls wir die Ausgabedatei nicht öffnen können (z.B. sie ist zwar vorhanden, aber wir haben keine Schreibberechtigung), springen wir auch wieder in die Fehlerbehandlung.</p></div><div class=paragraph><p>Der Rest des Codes ist derselbe wie vorher, außer dem Schließen der Ein- und Ausgabedatei vor dem Verlassen des Programms und, wie bereits erwähnt, die Benutzung von <code>[fd.in]</code> und <code>[fd.out]</code>.</p></div><div class=paragraph><p>Unsere Binärdatei ist nun kolossale 768 Bytes groß.</p></div><div class=paragraph><p>Können wir das Programm immer noch verbessern? Natürlich! Jedes Programm kann verbessert werden. Hier finden sich einige Ideen, was wir tun könnten:</p></div><div class=ulist><ul><li><p>Die Fehlerbehandlung eine Warnung auf <code>stderr</code> ausgeben lassen.</p></li><li><p>Den <code>Lese</code>- und <code>Schreib</code>funkionen eine Fehlerbehandlung hinzufügen.</p></li><li><p>Schließen von <code>stdin</code>, sobald wir eine Eingabedatei öffnen, von <code>stdout</code>, sobald wir eine Ausgabedatei öffnen.</p></li><li><p>Hinzufügen von Kommandozeilenschaltern wie zum Beispiel <span class=parameter>-i</span> und <span class=parameter>-o</span>, sodass wir die Ein- und Ausgabedatei in irgendeiner Reihenfolge angeben oder vielleicht von <code>stdin</code> lesen und in eine Datei schreiben können.</p></li><li><p>Ausgeben einer Gebrauchsanweisung, falls die Kommandozeilenparameter fehlerhaft sind.</p></li></ul></div><div class=paragraph><p>Ich beabsichtige, diese Verbesserungen dem Leser als Übung zu hinterlassen: Sie wissen bereits alles, das Sie wissen müssen, um die Verbesserungen durchzuführen.</p></div></div><div class=sect2><h3 id=x86-environment>11.10. Die UNIX®-Umgebung<a class=anchor href=#x86-environment></a></h3><div class=paragraph><p>Ein entscheidendes Konzept hinter UNIX® ist die Umgebung, die durch <em>Umgebungsvariablen</em> festgelegt wird. Manche werden vom System gesetzt, andere von Ihnen und wieder andere von der shell oder irgendeinem Programm, das ein anderes lädt.</p></div><div class=sect3><h4 id=x86-find-environment>11.10.1. Umgebungsvariablen herausfinden<a class=anchor href=#x86-find-environment></a></h4><div class=paragraph><p>Ich sagte vorher, dass wenn ein Programm mit der Ausführung beginnt, der Stack <code>argc</code> gefolgt vom durch NULL beendeten <code>argv</code>-Array und etwas Anderem enthält. Das "etwas Andere" ist die <em>Umgebung</em> oder, um genauer zu sein, ein durch NULL beendetes Array von Zeigern auf <em>Umgebungsvariablen</em>. Davon wird oft als <code>env</code> gesprochen.</p></div><div class=paragraph><p>Der Aufbau von <code>env</code> entspricht dem von <code>argv</code>, eine Liste von Speicheradressen gefolgt von NULL (<span class=constant>0</span>). In diesem Fall gibt es kein <code>"envc"</code>-wir finden das Ende heraus, indem wir nach dem letzten NULL suchen.</p></div><div class=paragraph><p>Die Variablen liegen normalerweise in der Form <code>name=value</code> vor, aber manchmal kann der <code>=value</code>-Teil fehlen. Wir müssen diese Möglichkeit in Betracht ziehen.</p></div></div><div class=sect3><h4 id=x86-webvar>11.10.2. webvars<a class=anchor href=#x86-webvar></a></h4><div class=paragraph><p>Ich könnte Ihnen einfach etwas Code zeigen, der die Umgebung in der Art vom UNIX®-Befehl env ausgibt. Aber ich dachte, dass es interessanter sei, ein einfaches CGI-Werkzeug in Assembler zu schreiben.</p></div><div class=sect4><h5 id=x86-cgi>11.10.2.1. CGI: Ein kurzer Überblick<a class=anchor href=#x86-cgi></a></h5><div class=paragraph><p>Ich habe eine <a href=http://www.whizkidtech.redprince.net/cgi-bin/tutorial>detaillierte CGI-Anleitung</a> auf meiner Webseite, aber hier ist ein sehr kurzer Überblick über CGI:</p></div><div class=ulist><ul><li><p>Der Webserver kommuniziert mit dem CGI-Programm, indem er <em>Umgebungsvariablen</em> setzt.</p></li><li><p>Das CGI-Programm schreibt seine Ausgabe auf <span class=filename>stdout</span>. Der Webserver liest von da.</p></li><li><p>Die Ausgabe muss mit einem HTTP-Kopfteil gefolgt von zwei Leerzeilen beginnen.</p></li><li><p>Das Programm gibt dann den HTML-Code oder was für einen Datentyp es auch immer verarbeitet aus.
*</p></li></ul></div><div class=exampleblock><div class=content><div class=paragraph><p>Während bestimmte <em>Umgebungsvariablen</em> Standardnamen benutzen, unterscheiden sich andere, abhängig vom Webserver. Dies macht webvars zu einem recht nützlichen Werkzeug.</p></div></div></div></div><div class=sect4><h5 id=x86-webvars-the-code>11.10.2.2. Der Code<a class=anchor href=#x86-webvars-the-code></a></h5><div class=paragraph><p>Unser webvars-Programm muss also den HTTP-Kopfteil gefolgt von etwas HTML-Auszeichnung versenden. Dann muss es die <em>Umgebungsvariablen</em> eine nach der anderen auslesen und sie als Teil der HTML-Seite versenden.</p></div><div class=paragraph><p>Nun der Code. Ich habe Kommentare und Erklärungen direkt in den Code eingefügt:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; webvars.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (c) 2000 G. Adam Stanislav
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 1. Redistributions of source code must retain the above copyright
;    notice, this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
; SUCH DAMAGE.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Version 1.0
;
; Started:	 8-Dec-2000
; Updated:	 8-Dec-2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	&#39;system.inc&#39;

section	.data
http	db	&#39;Content-type: text/html&#39;, 0Ah, 0Ah
	db	&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;&#39;, 0Ah
	db	&#39;&lt;!DOCTYPE html PUBLIC &#34;-//W3C/DTD XHTML Strict//EN&#34; &#39;
	db	&#39;&#34;DTD/xhtml1-strict.dtd&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;html xmlns=&#34;http://www.w3.org/1999/xhtml&#34; &#39;
	db	&#39;xml.lang=&#34;en&#34; lang=&#34;en&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;head&gt;&#39;, 0Ah
	db	&#39;&lt;title&gt;Web Environment&lt;/title&gt;&#39;, 0Ah
	db	&#39;&lt;meta name=&#34;author&#34; content=&#34;G. Adam Stanislav&#34; /&gt;&#39;, 0Ah
	db	&#39;&lt;/head&gt;&#39;, 0Ah, 0Ah
	db	&#39;&lt;body bgcolor=&#34;#ffffff&#34; text=&#34;#000000&#34; link=&#34;#0000ff&#34; &#39;
	db	&#39;vlink=&#34;#840084&#34; alink=&#34;#0000ff&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;div class=&#34;webvars&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;h1&gt;Web Environment&lt;/h1&gt;&#39;, 0Ah
	db	&#39;&lt;p&gt;The following &lt;b&gt;environment variables&lt;/b&gt; are defined &#39;
	db	&#39;on this web server:&lt;/p&gt;&#39;, 0Ah, 0Ah
	db	&#39;&lt;table align=&#34;center&#34; width=&#34;80&#34; border=&#34;0&#34; cellpadding=&#34;10&#34; &#39;
	db	&#39;cellspacing=&#34;0&#34; class=&#34;webvars&#34;&gt;&#39;, 0Ah
httplen	equ	$-http
left	db	&#39;&lt;tr&gt;&#39;, 0Ah
	db	&#39;&lt;td class=&#34;name&#34;&gt;&lt;tt&gt;&#39;
leftlen	equ	$-left
middle	db	&#39;&lt;/tt&gt;&lt;/td&gt;&#39;, 0Ah
	db	&#39;&lt;td class=&#34;value&#34;&gt;&lt;tt&gt;&lt;b&gt;&#39;
midlen	equ	$-middle
undef	db	&#39;&lt;i&gt;(undefined)&lt;/i&gt;&#39;
undeflen	equ	$-undef
right	db	&#39;&lt;/b&gt;&lt;/tt&gt;&lt;/td&gt;&#39;, 0Ah
	db	&#39;&lt;/tr&gt;&#39;, 0Ah
rightlen	equ	$-right
wrap	db	&#39;&lt;/table&gt;&#39;, 0Ah
	db	&#39;&lt;/div&gt;&#39;, 0Ah
	db	&#39;&lt;/body&gt;&#39;, 0Ah
	db	&#39;&lt;/html&gt;&#39;, 0Ah, 0Ah
wraplen	equ	$-wrap

section	.text
global	_start
_start:
	; First, send out all the http and xhtml stuff that is
	; needed before we start showing the environment
	push	dword httplen
	push	dword http
	push	dword stdout
	sys.write

	; Now find how far on the stack the environment pointers
	; are. We have 12 bytes we have pushed before &#34;argc&#34;
	mov	eax, [esp+12]

	; We need to remove the following from the stack:
	;
	;	The 12 bytes we pushed for sys.write
	;	The  4 bytes of argc
	;	The EAX*4 bytes of argv
	;	The  4 bytes of the NULL after argv
	;
	; Total:
	;	20 + eax * 4
	;
	; Because stack grows down, we need to ADD that many bytes
	; to ESP.
	lea	esp, [esp+20+eax*4]
	cld		; This should already be the case, but let&#39;s be sure.

	; Loop through the environment, printing it out
.loop:
	pop	edi
	or	edi, edi	; Done yet?
	je	near .wrap

	; Print the left part of HTML
	push	dword leftlen
	push	dword left
	push	dword stdout
	sys.write

	; It may be tempting to search for the &#39;=&#39; in the env string next.
	; But it is possible there is no &#39;=&#39;, so we search for the
	; terminating NUL first.
	mov	esi, edi	; Save start of string
	sub	ecx, ecx
	not	ecx		; ECX = FFFFFFFF
	sub	eax, eax
repne	scasb
	not	ecx		; ECX = string length + 1
	mov	ebx, ecx	; Save it in EBX

	; Now is the time to find &#39;=&#39;
	mov	edi, esi	; Start of string
	mov	al, &#39;=&#39;
repne	scasb
	not	ecx
	add	ecx, ebx	; Length of name

	push	ecx
	push	esi
	push	dword stdout
	sys.write

	; Print the middle part of HTML table code
	push	dword midlen
	push	dword middle
	push	dword stdout
	sys.write

	; Find the length of the value
	not	ecx
	lea	ebx, [ebx+ecx-1]

	; Print &#34;undefined&#34; if 0
	or	ebx, ebx
	jne	.value

	mov	ebx, undeflen
	mov	edi, undef

.value:
	push	ebx
	push	edi
	push	dword stdout
	sys.write

	; Print the right part of the table row
	push	dword rightlen
	push	dword right
	push	dword stdout
	sys.write

	; Get rid of the 60 bytes we have pushed
	add	esp, byte 60

	; Get the next variable
	jmp	.loop

.wrap:
	; Print the rest of HTML
	push	dword wraplen
	push	dword wrap
	push	dword stdout
	sys.write

	; Return success
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>Dieser Code erzeugt eine 1.396-Byte große Binärdatei. Das meiste davon sind Daten, d.h., die HTML-Auszeichnung, die wir versenden müssen.</p></div><div class=paragraph><p>Assemblieren Sie es wie immer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf webvars.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> webvars webvars.o</code></pre></div></div><div class=paragraph><p>Um es zu benutzen, müssen Sie <span class=filename>webvars</span> auf Ihren Webserver hochladen. Abhängig von Ihrer Webserver-Konfiguration, müssen Sie es vielleicht in einem speziellen <span class=filename>cgi-bin</span>-Verzeichnis ablegen oder es mit einer <span class=filename>.cgi</span>-Dateierweiterung versehen.</p></div><div class=paragraph><p>Schließlich benötigen Sie Ihren Webbrowser, um sich die Ausgabe anzusehen. Um die Ausgabe auf meinem Webserver zu sehen, gehen Sie bitte auf <a href=http://www.int80h.org/webvars/>http://www.int80h.org/webvars/</a>. Falls Sie neugierig sind, welche zusätzlichen Variablen in einem passwortgeschützten Webverzeichnis vorhanden sind, gehen Sie auf <a href=http://www.int80h.org/private/>http://www.int80h.org/private/</a> unter Benutzung des Benutzernamens <code>asm</code> und des Passworts <code>programmer</code>.</p></div></div></div></div><div class=sect2><h3 id=x86-files>11.11. Arbeiten mit Dateien<a class=anchor href=#x86-files></a></h3><div class=paragraph><p>Wir haben bereits einfache Arbeiten mit Dateien gemacht: Wir wissen wie wir sie öffnen und schliessen, oder wie man sie mit Hilfe von Buffern liest und schreibt. Aber UNIX® bietet viel mehr Funktionalität wenn es um Dateien geht. Wir werden einige von ihnen in dieser Sektion untersuchen und dann mit einem netten Datei Konvertierungs Werkzeug abschliessen.</p></div><div class=paragraph><p>In der Tat, Lasst uns am Ende beginnen, also mit dem Datei Konvertierungs Werkzeug. Es macht Programmieren immer einfacher, wenn wir bereits am Anfang wissen was das End Produkt bezwecken soll.</p></div><div class=paragraph><p>Eines der ersten Programme die ich für UNIX® schrieb war <a href=ftp://ftp.int80h.org/unix/tuc/>tuc</a>, ein Text-Zu-UNIX® Datei Konvertierer. Es konvertiert eine Text Datei von einem anderen Betriebssystem zu einer UNIX® Text Datei. Mit anderen Worten, es ändert die verschiedenen Arten von Zeilen Begrenzungen zu der Zeilen Begrenzungs Konvention von UNIX®. Es speichert die Ausgabe in einer anderen Datei. Optional konvertiert es eine UNIX® Text Datei zu einer DOS Text Datei.</p></div><div class=paragraph><p>Ich habe tuc sehr oft benutzt, aber nur von irgendeinem anderen OS nach UNIX® zu konvertieren, niemals anders herum. Ich habe mir immer gewünscht das die Datei einfach überschrieben wird anstatt das ich die Ausgabe in eine andere Datei senden muss. Meistens, habe ich diesen Befehl verwendet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% tuc myfile tempfile
% <span class=nb>mv </span>tempfile myfile</code></pre></div></div><div class=paragraph><p>Es wäre schö ein ftuc zu haben, also, <em>fast tuc</em>, und es so zu benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ftuc myfile</code></pre></div></div><div class=paragraph><p>In diesem Kapitel werden wir dann, ftuc in Assembler schreiben (das Original tuc ist in C), und verschiedene Datei-Orientierte Kernel Dienste in dem Prozess studieren.</p></div><div class=paragraph><p>Auf erste Sicht, ist so eine Datei Konvertierung sehr simpel: Alles was du zu tun hast, ist die Wagenrückläufe zu entfernen, richtig?</p></div><div class=paragraph><p>Wenn du mit ja geantwortet hast, denk nochmal darüber nach: Dieses Vorgehen wird die meiste Zeit funktionieren (zumindest mit MSDOS Text Dateien), aber gelegentlich fehlschlagen.</p></div><div class=paragraph><p>Das Problem ist das nicht alle UNIX® Text Dateien ihre Zeilen mit einer Wagen Rücklauf / Zeilenvorschub Sequenz beenden. Manche benutzen Wagenrücklauf ohne Zeilenvorschub. Andere kombinieren mehrere leere Zeilen in einen einzigen Wagenrücklauf gefolgt von mehreren Zeilenvorschüben. Und so weiter.</p></div><div class=paragraph><p>Ein Text Datei Konvertierer muss dann also in der Lage sein mit allen möglichen Zeilenenden umzugehen:</p></div><div class=ulist><ul><li><p>Wagenrücklauf / Zeilenvorschub</p></li><li><p>Wagenrücklauf</p></li><li><p>Zeilenvorschub / Wagenrücklauf</p></li><li><p>Zeilenvorschub</p></li></ul></div><div class=paragraph><p>Es sollte außerdem in der Lage sein mit Dateien umzugehen die irgendeine Art von Kombination der oben stehenden Möglichkeiten verwendet. (z.B., Wagenrücklauf gefolgt von mehreren Zeilenvorschüben).</p></div><div class=sect3><h4 id=x86-finite-state-machine>11.11.1. Endlicher Zustandsautomat<a class=anchor href=#x86-finite-state-machine></a></h4><div class=paragraph><p>Das Problem wird einfach gelöst in dem man eine Technik benutzt die sich <em>Endlicher Zustandsautomat</em> nennt, ursprünglich wurde sie von den Designern digitaler elektronischer Schaltkreise entwickelt. Eine <em>Endlicher Zustandsautomat</em> ist ein digitaler Schaltkreis dessen Ausgabe nicht nur von der Eingabe abhängig ist sondern auch von der vorherigen Eingabe, d.h., von seinem Status. Der Mikroprozessor ist ein Beispiel für einen <em>Endlichen Zustandsautomaten</em>: Unser Assembler Sprach Code wird zu Maschinensprache übersetzt in der manche Assembler Sprach Codes ein einzelnes Byte produzieren, während andere mehrere Bytes produzieren. Da der Microprozessor die Bytes einzeln aus dem Speicher liest, ändern manche nur seinen Status anstatt eine Ausgabe zu produzieren. Wenn alle Bytes eines OP Codes gelesen wurden, produziert der Mikroprozessor eine Ausgabe, oder ändert den Wert eines Registers, etc.</p></div><div class=paragraph><p>Aus diesem Grund, ist jede Software eigentlich nur eine Sequenz von Status Anweisungen für den Mikroprozessor. Dennoch, ist das Konzept eines <em>Endlichen Zustandsautomaten</em> auch im Software Design sehr hilfreich.</p></div><div class=paragraph><p>Unser Text Datei Konvertierer kann als <em>Endlicher Zustandsautomat</em> mit 3 möglichen Stati desgined werden. Wir könnten diese von 0-2 benennen, aber es wird uns das Leben leichter machen wenn wir ihnen symbolische Namen geben:</p></div><div class=ulist><ul><li><p>ordinary</p></li><li><p>cr</p></li><li><p>lf</p></li></ul></div><div class=paragraph><p>Unser Programm wird in dem ordinary Status starten. Während dieses Status, hängt die Aktion des Programms von seiner Eingabe wie folgt ab:</p></div><div class=ulist><ul><li><p>Wenn die Eingabe etwas anderes als ein Wagenrücklauf oder einem Zeilenvorschub ist, wird die Eingabe einfach nur an die Ausgabe geschickt. Der Status bleibt unverändert.</p></li><li><p>Wenn die Eingabe ein Wagenrücklauf ist, wird der Status auf cr gesetzt. Die Eingabe wird dann verworfen, d.h., es entsteht keine Ausgabe.</p></li><li><p>Wenn die Eingabe ein Zeilenvorschub ist, wird der Status auf lf gesetzt. Die Eingabe wird dann verworfen.</p></li></ul></div><div class=paragraph><p>Wann immer wir in dem cr Status sind, ist das weil die letzte Eingabe ein Wagenrücklauf war, welcher nicht verarbeitet wurde. Was unsere Software in diesem Status macht hängt von der aktuellen Eingabe ab:</p></div><div class=ulist><ul><li><p>Wenn die Eingabe irgendetwas anderes als ein Wagenrücklauf oder ein Zeilenvorschub ist, dann gib einen Zeilenvorschub aus, dann gib die Eingabe aus und dann ändere den Status zu ordinary.</p></li><li><p>Wenn die Eingabe ein Wagenrücklauf ist, haben wir zwei (oder mehr) Wagenrückläufe in einer Reihe. Wir verwerfen die Eingabe, wir geben einen Zeilenvorschub aus und lassen den Status unverändert.</p></li><li><p>Wenn die Eingabe ein Zeilenvorschub ist, geben wir den Zeilenvorschub aus und ändern den Status zu ordinary. Achte darauf, dass das nicht das gleiche wie in dem Fall oben drüber ist - würden wir versuchen beide zu kombinieren, würden wir zwei Zeilenvorschübe anstatt einen ausgeben.</p></li></ul></div><div class=paragraph><p>Letztendlich, sind wir in dem lf Status nachdem wir einen Zeilenvorschub empfangen haben der nicht nach einem Wagenrücklauf kam. Das wird passieren wenn unsere Datei bereits im UNIX® Format ist, oder jedesmal wenn mehrere Zeilen in einer Reihe durch einen einzigen Wagenrücklauf gefolgt von mehreren Zeilenvorschüben ausgedrückt wird, oder wenn die Zeile mit einer Zeilenvorschub / Wagenrücklauf Sequenz endet. Wir sollten mit unserer Eingabe in diesem Status folgendermaßen umgehen:</p></div><div class=ulist><ul><li><p>Wenn die Eingabe irgendetwas anderes als ein Wagenrücklauf oder ein Zeilenvorschub ist, geben wir einen Zeilenvorschub aus, geben dann die Eingabe aus und ändern dann den Status zu ordinary. Das ist exakt die gleiche Aktion wie in dem cr Status nach dem Empfangen der selben Eingabe.</p></li><li><p>Wenn die Eingabe ein Wagenrücklauf ist, verwerfen wir die Eingabe, geben einen Zeilenvorschub aus und ändern dann den Status zu ordinary.</p></li><li><p>Wenn die Eingabe ein Zeilenvorschub ist, geben wir den Zeilenvorschub aus und lassen den Status unverändert.</p></li></ul></div><div class=sect4><h5 id=x86-final-state>11.11.1.1. Der Endgültige Status<a class=anchor href=#x86-final-state></a></h5><div class=paragraph><p>Der obige <em>Endliche Zustandsautomat</em> funktioniert für die gesamte Datei, aber lässt die Möglichkeit das die letzte Zeile ignoriert wird. Das wird jedesmal passieren wenn die Datei mit einem einzigen Wagenrücklauf oder einem einzigen Zeilenvorschub endet. Daran habe ich nicht gedacht als ich tuc schrieb, nur um festzustellen, daß das letzte Zeilenende gelegentlich weggelassen wird.</p></div><div class=paragraph><p>Das Problem wird einfach dadurch gelöst, indem man den Status überprüft nachdem die gesamte Datei verarbeitet wurde. Wenn der Status nicht ordinary ist, müssen wir nur den letzten Zeilenvorschub ausgeben.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nachdem wir unseren Algorithmus nun als einen <em>Endlichen Zustandsautomaten</em> formuliert haben, könnten wir einfach einen festgeschalteten digitalen elektronischen Schaltkreis (einen "Chip") designen, der die Umwandlung für uns übernimmt. Natürlich wäre das sehr viel teurer, als ein Assembler Programm zu schreiben.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=x86-tuc-counter>11.11.1.2. Der Ausgabe Zähler<a class=anchor href=#x86-tuc-counter></a></h5><div class=paragraph><p>Weil unser Datei Konvertierungs Programm möglicherweise zwei Zeichen zu einem kombiniert, müssen wir einen Ausgabe Zähler verwenden. Wir initialisieren den Zähler zu <span class=constant>0</span> und erhöhen ihn jedes mal wenn wir ein Zeichen an die Ausgabe schicken. Am Ende des Programms, wird der Zähler uns sagen auf welche Grösse wir die Datei setzen müssen.</p></div></div></div><div class=sect3><h4 id=x86-software-fsm>11.11.2. Implementieren von EZ als Software<a class=anchor href=#x86-software-fsm></a></h4><div class=paragraph><p>Der schwerste Teil beim arbeiten mit einer <em>Endlichen Zustandsmaschine</em> ist das analysieren des Problems und dem ausdrücken als eine <em>Endliche Zustandsmaschine</em>. That geschafft, schreibt sich die Software fast wie von selbst.</p></div><div class=paragraph><p>In eine höheren Sprache, wie etwa C, gibt es mehrere Hauptansätze. Einer wäre ein <code>switch</code> Angabe zu verwenden die auswählt welche Funktion genutzt werden soll. Zum Beispiel,</p></div><div class="literalblock programlisting"><div class=content><pre>	switch (state) {
	default:
	case REGULAR:
		regular(inputchar);
		break;
	case CR:
		cr(inputchar);
		break;
	case LF:
		lf(inputchar);
		break;
	}</pre></div></div><div class=paragraph><p>Ein anderer Ansatz ist es ein Array von Funktions Zeigern zu benutzen, etwa wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>	(output[state])(inputchar);</pre></div></div><div class=paragraph><p>Noch ein anderer ist es aus <code>state</code> einen Funktions Zeiger zu machen und ihn zu der entsprechenden Funktion zeigen zu lassen:</p></div><div class="literalblock programlisting"><div class=content><pre>	(*state)(inputchar);</pre></div></div><div class=paragraph><p>Das ist der Ansatz den wir in unserem Programm verwenden werden, weil es in Assembler sehr einfach und schnell geht. Wir werden einfach die Adresse der Prozedur in <code>EBX</code> speichern und dann einfach das ausgeben:</p></div><div class="literalblock programlisting"><div class=content><pre>	call	ebx</pre></div></div><div class=paragraph><p>Das ist wahrscheinlich schneller als die Adresse im Code zu hardcoden weil der Mikroprozessor die Adresse nicht aus dem Speicher lesen muss-es ist bereits in einer der Register gespeichert. Ich sagte <em>wahrscheinlich</em> weil durch das Cachen neuerer Mikroprozessoren beide Varianten in etwa gleich schnell sind.</p></div></div><div class=sect3><h4 id=memory-mapped-files>11.11.3. Speicher abgebildete Dateien<a class=anchor href=#memory-mapped-files></a></h4><div class=paragraph><p>Weil unser Programm nur mit einzelnen Dateien funktioniert, können wir nicht den Ansatz verwedenden der zuvor funktioniert hat, d.h., von einer Eingabe Datei zu lesen und in eine Ausgabe Datei zu schreiben.</p></div><div class=paragraph><p>UNIX® erlaubt es uns eine Datei, oder einen Bereich einer Datei, in den Speicher abzubilden. Um das zu tun, müssen wir zuerst eine Datei mit den entsprechenden Lese/Schreib Flags öffnen. Dann benutzen wir den <code>mmap</code> system call um sie in den Speicher abzubilden. Ein Vorteil von <code>mmap</code> ist, das es automatisch mit virtuellem Speicher arbeitet: Wir können mehr von der Datei im Speicher abbilden als wir überhaupt physikalischen Speicher zur Verfügung haben, noch immer haben wir aber durch normale OP Codes wie <code>mov</code>, <code>lods</code>, und <code>stos</code> Zugriff darauf. Egal welche Änderungen wir an dem Speicherabbild der Datei vornehmen, sie werden vom System in die Datei geschrieben. Wir müssen die Datei nicht offen lassen: So lange sie abgebildet bleibt, können wir von ihr lesen und in sie schreiben.</p></div><div class=paragraph><p>Ein 32-bit Intel Mikroprozessor kann auf bis zu vier Gigabyte Speicher zugreifen - physisch oder virtuell. Das FreeBSD System erlaubt es uns bis zu der Hälfte für die Datei Abbildung zu verwenden.</p></div><div class=paragraph><p>Zur Vereinfachung, werden wir in diesem Tutorial nur Dateien konvertieren die in ihrere Gesamtheit im Speicher abgebildet werden können. Es gibt wahrscheinlich nicht all zu viele Text Dateien die eine Grösse von zwei Gigabyte überschreiben. Falls unser Programm doch auf eine trifft, wird es einfach eine Meldung anzeigen mit dem Vorschlag das originale tuc statt dessen zu verwenden.</p></div><div class=paragraph><p>Wenn du deine Kopie von <span class=filename>syscalls.master</span> überprüfst, wirst du zwei verschiedene Systemaufrufe finden die sich <code>mmap</code> nennen. Das kommt von der Entwicklung von UNIX®: Es gab das traditionelle BSD<code>mmap</code>, Systemaufruf 71. Dieses wurde durch das POSIX® <code>mmap</code> ersetzt, Systemaufruf 197. Das FreeBSD System unterstützt beide, weil ältere Programme mit der originalen BSD Version geschrieben wurden. Da neue Software die POSIX® Version nutzt, werden wir diese auch verwenden.</p></div><div class=paragraph><p>Die <span class=filename>syscalls.master</span> Datei zeigt die POSIX® Version wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>197	STD	BSD	{ caddr_t mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }</pre></div></div><div class=paragraph><p>Das weicht etwas von dem ab was <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> sagt. Das ist weil <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> die C Version beschreibt.</p></div><div class=paragraph><p>Der Unterschiede liegt in dem <code>long pad</code> Argument, welches in der C Version nicht vorhanden ist. Wie auch immer, der FreeBSD Systemaufruf fügt einen 32-bit Block ein nachdem es ein 64-Bit Argument auf den Stack ge<code>push</code>t hat. In diesem Fall, ist <code>off_t</code> ein 64-Bit Wert.</p></div><div class=paragraph><p>Wenn wir fertig sind mit dem Arbeiten einer im Speicher abgebildeten Datei, entfernen wir das Speicherabbild mit dem <code>munmap</code> Systemaufruf:</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Für eine detailliert Behandlung von <code>mmap</code>, sieh in W. Richard Stevens' <a href="http://www.int80h.org/cgi-bin/isbn?isbn=0130810819">Unix Network Programming, Volume 2, Chapter 12</a> nach.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-file-size>11.11.4. Feststellen der Datei Grösse<a class=anchor href=#x86-file-size></a></h4><div class=paragraph><p>Weil wir <code>mmap</code> sagen müssen wie viele Bytes von Datei wir im Speicher abbilden wollen und wir außerdem die gesamte Datei abbilden wollen, müssen wir die Grösse der Datei feststellen.</p></div><div class=paragraph><p>Wir können den <code>fstat</code> Systemaufruf verwenden um alle Informationen über eine geöffnete Datei zu erhalten die uns das System geben kann. Das beinhaltet die Datei Grösse.</p></div><div class=paragraph><p>Und wieder, zeigt uns <span class=filename>syscalls.master</span> zwei Versionen von <code>fstat</code>, eine traditionelle (Systemaufruf 62), und eine POSIX® (Systemaufruf 189) Variante. Natürlich, verwenden wir die POSIX® Version:</p></div><div class="literalblock programlisting"><div class=content><pre>189	STD	POSIX	{ int fstat(int fd, struct stat *sb); }</pre></div></div><div class=paragraph><p>Das ist ein sehr unkomplizierter Aufruf: Wir übergeben ihm die Adresse einer <code>stat</code> Structure und den Deskriptor einer geöffneten Datei. Es wird den Inhalt der <code>stat</code> Struktur ausfüllen.</p></div><div class=paragraph><p>Ich muss allerdings sagen, das ich versucht habe die <code>stat</code> Struktur in dem <code>.bss</code> Bereich zu deklarieren, und <code>fstat</code> mochte es nicht: Es setzte das Carry Flag welches einen Fehler anzeigt. Nachdem ich den Code veränderte so dass er die Struktur auf dem Stack anlegt, hat alles gut funktioniert.</p></div></div><div class=sect3><h4 id=x86-ftruncate>11.11.5. Ändern der Dateigrösse<a class=anchor href=#x86-ftruncate></a></h4><div class=paragraph><p>Dadurch das unser Programm Wagenrücklauf/Zeilenvorschub-Sequenzen in einfache Zeilenvorschübe zusammenfassen könnte, könnte unsere Ausgabe kleiner sein als unsere Eingabe. Und da wir die Ausgabe in dieselbe Datei um, aus der wir unsere Eingabe erhalten, müssen wir eventuell die Dateigrösse anpassen.</p></div><div class=paragraph><p>Der Systemaufruf <code>ftruncate</code> erlaubt uns, dies zu tun. Abgesehen von dem etwas unglücklich gewählten Namen <code>ftruncate</code> können wir mit dieser Funktion eine Datei vergrössern, oder verkleinern.</p></div><div class=paragraph><p>Und ja, wir werden zwei Versionen von <code>ftruncate</code> in <span class=filename>syscalls.master</span> finden, eine ältere (130) und eine neuere (201). Wir werden die neuere Version verwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>201	STD	BSD	{ int ftruncate(int fd, int pad, off_t length); }</pre></div></div><div class=paragraph><p>Beachten Sie bitte, dass hier wieder <code>int pad</code> verwendet wird.</p></div></div><div class=sect3><h4 id=x86-ftuc>11.11.6. ftuc<a class=anchor href=#x86-ftuc></a></h4><div class=paragraph><p>Wir wissen jetzt alles nötige, um ftuc zu schreiben. Wir beginnen, indem wir ein paar neue Zeilen der Datei <span class=filename>system.inc</span> hinzufügen. Als erstes definieren wir irgendwo am Anfang der Datei einige Konstanten und Strukturen:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; open flags
%define	O_RDONLY	0
%define	O_WRONLY	1
%define	O_RDWR	2

;;;;;;; mmap flags
%define	PROT_NONE	0
%define	PROT_READ	1
%define	PROT_WRITE	2
%define	PROT_EXEC	4
;;
%define	MAP_SHARED	0001h
%define	MAP_PRIVATE	0002h

;;;;;;; stat structure
struc	stat
st_dev		resd	1	; = 0
st_ino		resd	1	; = 4
st_mode		resw	1	; = 8, size is 16 bits
st_nlink	resw	1	; = 10, ditto
st_uid		resd	1	; = 12
st_gid		resd	1	; = 16
st_rdev		resd	1	; = 20
st_atime	resd	1	; = 24
st_atimensec	resd	1	; = 28
st_mtime	resd	1	; = 32
st_mtimensec	resd	1	; = 36
st_ctime	resd	1	; = 40
st_ctimensec	resd	1	; = 44
st_size		resd	2	; = 48, size is 64 bits
st_blocks	resd	2	; = 56, ditto
st_blksize	resd	1	; = 64
st_flags	resd	1	; = 68
st_gen		resd	1	; = 72
st_lspare	resd	1	; = 76
st_qspare	resd	4	; = 80
endstruc</pre></div></div><div class=paragraph><p>Wir definieren die neuen Systemaufrufe:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_mmap	197
%define	SYS_munmap	73
%define	SYS_fstat	189
%define	SYS_ftruncate	201</pre></div></div><div class=paragraph><p>Wir fügen die Makros hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.mmap	0
	system	SYS_mmap
%endmacro

%macro	sys.munmap	0
	system	SYS_munmap
%endmacro

%macro	sys.ftruncate	0
	system	SYS_ftruncate
%endmacro

%macro	sys.fstat	0
	system	SYS_fstat
%endmacro</pre></div></div><div class=paragraph><p>Und hier ist unser Code:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; Fast Text-to-Unix Conversion (ftuc.asm) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Started:	21-Dec-2000
;; Updated:	22-Dec-2000
;;
;; Copyright 2000 G. Adam Stanislav.
;; All rights reserved.
;;
;;;;;;; v.1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	&#39;system.inc&#39;

section	.data
	db	&#39;Copyright 2000 G. Adam Stanislav.&#39;, 0Ah
	db	&#39;All rights reserved.&#39;, 0Ah
usg	db	&#39;Usage: ftuc filename&#39;, 0Ah
usglen	equ	$-usg
co	db	&#34;ftuc: Can&#39;t open file.&#34;, 0Ah
colen	equ	$-co
fae	db	&#39;ftuc: File access error.&#39;, 0Ah
faelen	equ	$-fae
ftl	db	&#39;ftuc: File too long, use regular tuc instead.&#39;, 0Ah
ftllen	equ	$-ftl
mae	db	&#39;ftuc: Memory allocation error.&#39;, 0Ah
maelen	equ	$-mae

section	.text

align 4
memerr:
	push	dword maelen
	push	dword mae
	jmp	short error

align 4
toolong:
	push	dword ftllen
	push	dword ftl
	jmp	short error

align 4
facerr:
	push	dword faelen
	push	dword fae
	jmp	short error

align 4
cantopen:
	push	dword colen
	push	dword co
	jmp	short error

align 4
usage:
	push	dword usglen
	push	dword usg

error:
	push	dword stderr
	sys.write

	push	dword 1
	sys.exit

align 4
global	_start
_start:
	pop	eax		; argc
	pop	eax		; program name
	pop	ecx		; file to convert
	jecxz	usage

	pop	eax
	or	eax, eax	; Too many arguments?
	jne	usage

	; Open the file
	push	dword O_RDWR
	push	ecx
	sys.open
	jc	cantopen

	mov	ebp, eax	; Save fd

	sub	esp, byte stat_size
	mov	ebx, esp

	; Find file size
	push	ebx
	push	ebp		; fd
	sys.fstat
	jc	facerr

	mov	edx, [ebx + st_size + 4]

	; File is too long if EDX != 0 ...
	or	edx, edx
	jne	near toolong
	mov	ecx, [ebx + st_size]
	; ... or if it is above 2 GB
	or	ecx, ecx
	js	near toolong

	; Do nothing if the file is 0 bytes in size
	jecxz	.quit

	; Map the entire file in memory
	push	edx
	push	edx		; starting at offset 0
	push	edx		; pad
	push	ebp		; fd
	push	dword MAP_SHARED
	push	dword PROT_READ | PROT_WRITE
	push	ecx		; entire file size
	push	edx		; let system decide on the address
	sys.mmap
	jc	near memerr

	mov	edi, eax
	mov	esi, eax
	push	ecx		; for SYS_munmap
	push	edi

	; Use EBX for state machine
	mov	ebx, ordinary
	mov	ah, 0Ah
	cld

.loop:
	lodsb
	call	ebx
	loop	.loop

	cmp	ebx, ordinary
	je	.filesize

	; Output final lf
	mov	al, ah
	stosb
	inc	edx

.filesize:
	; truncate file to new size
	push	dword 0		; high dword
	push	edx		; low dword
	push	eax		; pad
	push	ebp
	sys.ftruncate

	; close it (ebp still pushed)
	sys.close

	add	esp, byte 16
	sys.munmap

.quit:
	push	dword 0
	sys.exit

align 4
ordinary:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	stosb
	inc	edx
	ret

align 4
.cr:
	mov	ebx, cr
	ret

align 4
.lf:
	mov	ebx, lf
	ret

align 4
cr:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	al, ah
	stosb
	inc	edx
	ret

align 4
lf:
	cmp	al, ah
	je	.lf

	cmp	al, 0Dh
	je	.cr

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	ebx, ordinary
	mov	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	ret</pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Verwenden Sie dieses Programm nicht mit Dateien, die sich auf Datenträgern befinden, welche mit MS-DOS® oder Windows® formatiert wurden. Anscheinend gibt es im Code von FreeBSD einen subtilen Bug, wenn <code>mmap</code> auf solchen Datenträgern verwendet wird: Wenn die Datei eine bestimmte Grösse überschreitet, füllt <code>mmap</code> den Speicher mit lauter Nullen, und überschreibt damit anschliessend den Dateiinhalt.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x86-one-pointed-mind>11.12. One-Pointed Mind<a class=anchor href=#x86-one-pointed-mind></a></h3><div class=paragraph><p>Als ein Zen-Schüler liebe ich die Idee eines fokussierten Bewußtseins: Tu nur ein Ding zur gleichen Zeit, aber mache es richtig.</p></div><div class=paragraph><p>Das ist ziemlich genau die gleiche Idee, welche UNIX® richtig funktionieren lässt. Während eine typische Windows®-Applikation versucht alles Vorstellbare zu tun (und daher mit Fehler durchsetzt ist), versucht eine UNIX®-Applikation nur eine Funktion zu erfüllen und das gut.</p></div><div class=paragraph><p>Der typische UNIX®-Nutzer stellt sich sein eigenes System durch Shell-Skripte zusammen, die er selbst schreibt, und welche die Vorteile bestehender Applikationen dadurch kombinieren, indem sie die Ausgabe eines Programmes als Eingabe in ein anderes Programm durch eine Pipe übergeben.</p></div><div class=paragraph><p>Wenn Sie ihre eigene UNIX®-Software schreiben, ist es generell eine gute Idee zu betrachten, welcher Teil der Problemlösung durch bestehende Programme bewerkstelligt werden kann. Man schreibt nur die Programme selbst, für die keine vorhandene Lösung existiert.</p></div><div class=sect3><h4 id=x86-csv>11.12.1. CSV<a class=anchor href=#x86-csv></a></h4><div class=paragraph><p>Ich will dieses Prinzip an einem besonderen Beispiel aus der realen Welt demonstrieren, mit dem ich kürzlich konfrontiert wurde:</p></div><div class=paragraph><p>Ich mußte jeweils das elfte Feld von jedem Datensatz aus einer Datenbank extrahieren, die ich von einer Webseite heruntergeladen hatte. Die Datenbank war eine CSV-Datei, d.h. eine Liste von <em>Komma-getrennten Werten</em>. Dies ist ein ziemlich gewöhnliches Format für den Code-Austausch zwischen Menschen, die eine unterschiedliche Datenbank-Software nutzen.</p></div><div class=paragraph><p>Die erste Zeile der Datei enthält eine Liste der Felder durch Kommata getrennt. Der Rest der Datei enthält die einzelnen Datensätze mit durch Kommata getrennten Werten in jeder Zeile.</p></div><div class=paragraph><p>Ich versuchte awk unter Nutzung des Kommas als Trenner. Da aber einige Zeilen durch in Bindestriche gesetzte Kommata getrennt waren, extrahierte awk das falsche Feld aus diesen Zeilen.</p></div><div class=paragraph><p>Daher mußte ich meine eigene Software schreiben, um das elfte Feld aus der CSV-Datei auszulesen. Aber durch Anwendung der UNIX®-Philosophie mußte ich nur einen einfachen Filter schreiben, das Folgende tat:</p></div><div class=ulist><ul><li><p>Entferne die erste Zeile aus der Datei.</p></li><li><p>Ändere alle Kommata ohne Anführungszeichen in einen anderen Buchstaben.</p></li><li><p>Entferne alle Anführungszeichen.</p></li></ul></div><div class=paragraph><p>Streng genommen könnte ich sed benutzen, um die erste Zeile der Datei zu entfernen, aber das zu Bewerkstelligen war in meinem Programm sehr einfach, also entschloss ich mich dazu und reduzierte dadurch die Größe der Pipeline.</p></div><div class=paragraph><p>Unter Berücksichtigung aller Faktoren kostete mich das Schreiben dieses Programmes ca. 20 Minuten. Das Schreiben eines Programmes, welches jeweils das elfte Feld aus einer CSV-Datei extrahiert hätte wesentlich länger gedauert und ich hätte es nicht wiederverwenden können, um ein anderes Feld aus irgendeiner anderen Datenbank zu extrahieren.</p></div><div class=paragraph><p>Diesmal entschied ich mich dazu, etwas mehr Arbeit zu investieren, als man normalerweise für ein typisches Tutorial verwenden würde:</p></div><div class=ulist><ul><li><p>Es parst die Kommandozeilen nach Optionen.</p></li><li><p>Es zeigt die richtige Nutzung an, falls es ein falsches Argument findet.</p></li><li><p>Es gibt vernünftige Fehlermeldungen aus.</p></li></ul></div><div class=paragraph><p>Hier ist ein Beispiel für seine Nutzung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Usage: csv <span class=o>[</span><span class=nt>-t</span>&lt;delim&gt;] <span class=o>[</span><span class=nt>-c</span>&lt;comma&gt;] <span class=o>[</span><span class=nt>-p</span><span class=o>]</span> <span class=o>[</span><span class=nt>-o</span> &lt;outfile&gt;] <span class=o>[</span><span class=nt>-i</span> &lt;infile&gt;]</code></pre></div></div><div class=paragraph><p>Alle Parameter sind optional und können in beliebiger Reihenfolge auftauchen.</p></div><div class=paragraph><p>Der <span class=parameter>-t</span>-Parameter legt fest, was zu die Kommata zu ersetzen sind. Der <span class=constant>tab</span> ist die Vorgabe hierfür. Zum Beispiel wird <span class=parameter>-t;</span> alle unquotierten Kommata mit Semikolon ersetzen.</p></div><div class=paragraph><p>Ich brauche die <span class=parameter>-c</span>-Option nicht, aber sie könnte zukünftig nützlich sein. Sie ermöglicht mir festzulegen, daß ich einen anderen Buchstaben als das Kommata mit etwas anderem ersetzen möchte. Zum Beispiel wird der Parameter <span class=parameter>-c@</span> alle @-Zeichen ersetzen (nützlich, falls man eine Liste von Email-Adressen in Nutzername und Domain aufsplitten will).</p></div><div class=paragraph><p>Die <span class=parameter>-p</span>-Option erhält die erste Zeile, d.h. die erste Zeile der Datei wird nicht gelöscht. Als Vorgabe löschen wir die erste Zeile, weil die CSV-Datei in der ersten Zeile keine Daten, sondern Feldbeschreibungen enthält.</p></div><div class=paragraph><p>Die Parameter <span class=parameter>-i</span>- und <span class=parameter>-o</span>-Optionen erlauben es mir, die Ausgabe- und Eingabedateien festzulegen. Vorgabe sind <span class=filename>stdin</span> und <span class=filename>stdout</span>, also ist es ein regulärer UNIX®-Filter.</p></div><div class=paragraph><p>Ich habe sichergestellt, daß sowohl <span class=parameter>-i filename</span> und <span class=parameter>-ifilename</span> akzeptiert werden. Genauso habe ich dafür Sorge getragen, daß sowohl Eingabe- als auch Ausgabedateien festgelegt werden können.</p></div><div class=paragraph><p>Um das elfte Feld jeden Datensatzes zu erhalten kann ich nun folgendes eingeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% csv <span class=s1>&#39;-t;&#39;</span> data.csv | <span class=nb>awk</span> <span class=s1>&#39;-F;&#39;</span> <span class=s1>&#39;{print $11}&#39;</span></code></pre></div></div><div class=paragraph><p>Der Code speichert die Optionen (bis auf die Dateideskriptoren) in <code>EDX</code>: Das Kommata in <code>DH</code>, den neuen Feldtrenner in <code>DL</code> und das Flag für die <span class=parameter>-p</span>-Option in dem höchsten Bit von <code>EDX</code>. Ein kurzer Abgleich des Zeichens wird uns also eine schnelle Entscheidung darüber erlauben, was zu tun ist.</p></div><div class=paragraph><p>Hier ist der Code:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; csv.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Convert a comma-separated file to a something-else separated file.
;
; Started:	31-May-2001
; Updated:	 1-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
usg	db	&#39;Usage: csv [-t&lt;delim&gt;] [-c&lt;comma&gt;] [-p] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]&#39;, 0Ah
usglen	equ	$-usg
iemsg	db	&#34;csv: Can&#39;t open input file&#34;, 0Ah
iemlen	equ	$-iemsg
oemsg	db	&#34;csv: Can&#39;t create output file&#34;, 0Ah
oemlen	equ	$-oemsg

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	mov	edx, (&#39;,&#39; &lt;&lt; 8) | 9

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .init		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], &#39;-&#39;
	jne	usage

	inc	ecx
	mov	ax, [ecx]

.o:
	cmp	al, &#39;o&#39;
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	inc	ecx
	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, &#39;i&#39;
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	inc	ecx
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, &#39;p&#39;
	jne	.t
	or	ah, ah
	jne	near usage
	or	edx, 1 &lt;&lt; 31
	jmp	.arg

.t:
	cmp	al, &#39;t&#39;		; redefine output delimiter
	jne	.c
	or	ah, ah
	je	near usage
	mov	dl, ah
	jmp	.arg

.c:
	cmp	al, &#39;c&#39;
	jne	near usage
	or	ah, ah
	je	near usage
	mov	dh, ah
	jmp	.arg

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

	; See if we are to preserve the first line
	or	edx, edx
	js	.loop

.firstline:
	; get rid of the first line
	call	getchar
	cmp	al, 0Ah
	jne	.firstline

.loop:
	; read a byte from stdin
	call	getchar

	; is it a comma (or whatever the user asked for)?
	cmp	al, dh
	jne	.quote

	; Replace the comma with a tab (or whatever the user wants)
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

.quote:
	cmp	al, &#39;&#34;&#39;
	jne	.put

	; Print everything until you get another quote or EOL. If it
	; is a quote, skip it. If it is EOL, print it.
.qloop:
	call	getchar
	cmp	al, &#39;&#34;&#39;
	je	.loop

	cmp	al, 0Ah
	je	.put

	call	putchar
	jmp	short .qloop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret</pre></div></div><div class=paragraph><p>Vieles daraus ist aus <span class=filename>hex.asm</span> entnommen worden. Aber es gibt einen wichtigen Unterschied: Ich rufe nicht länger <code>write</code> auf, wann immer ich eine Zeilenvorschub ausgebe. Nun kann der Code sogar interaktiv genutzt werden.</p></div><div class=paragraph><p>Ich habe eine bessere Lösung gefunden für das Interaktivitätsproblem seit ich mit dem Schreiben dieses Kapitels begonnen habe. Ich wollte sichergehen, daß jede Zeile einzeln ausgegeben werden kann, falls erforderlich. Aber schlussendlich gibt es keinen Bedarf jede Zeile einzeln auszugeben, falls nicht-interaktiv genutzt.</p></div><div class=paragraph><p>Die neue Lösung besteht darin, die Funktion <code>write</code> jedesmal aufzurufen, wenn ich den Eingabepuffer leer vorfinde. Auf diesem Wege liest das Programm im interaktiven Modus eine Zeile aus der Tastatur des Nutzers, verarbeitet sie und stellt fest, ob deren Eingabepuffer leer ist, dann leert es seine Ausgabe und liest die nächste Zeile.</p></div><div class=sect4><h5 id=x86-buffered-dark-side>11.12.1.1. Die dunkle Seite des Buffering<a class=anchor href=#x86-buffered-dark-side></a></h5><div class=paragraph><p>Diese Änderung verhindert einen mysteriösen Aufhänger in einem speziellen Fall. Ich bezeichne dies als die <em>dunkle Seite des Buffering</em>, hauptsächlich, weil es eine nicht offensichtliche Gefahr darstellt.</p></div><div class=paragraph><p>Es ist unwahrscheinlich, daß dies mit dem csv-Programm oben geschieht aber lassen Sie uns einen weiteren Filter betrachten: Nehmen wir an ihre Eingabe sind rohe Daten, die Farbwerte darstellen, wie z.B. die Intensität eines Pixel mit den Farben <em>rot</em>, <em>grün</em> und <em>blau</em>. Unsere Ausgabe wird der negative Wert unserer Eingabe sein.</p></div><div class=paragraph><p>Solch ein Filter würde sehr einfach zu schreiben sein. Der größte Teil davon würde so aussehen wie all die anderen Filter, die wir bisher geschrieben haben, daher beziehe ich mich nur auf den Kern der Prozedur:</p></div><div class="literalblock programlisting"><div class=content><pre>.loop:
	call	getchar
	not	al		; Create a negative
	call	putchar
	jmp	short .loop</pre></div></div><div class=paragraph><p>Da dieser Filter mit rohen Daten arbeitet ist es unwahrscheinlich, daß er interaktiv genutzt werden wird.</p></div><div class=paragraph><p>Aber das Programm könnte als Bildbearbeitungssoftware tituliert werden. Wenn es nicht <code>write</code> vor jedem Aufruf von <code>read</code> durchführt, ist die Möglichkeit gegeben, das es sich aufhängt.</p></div><div class=paragraph><p>Dies könnte passieren:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Der Bildeditor wird unseren Filter laden mittels der C-Funktion <code>popen()</code>.</p></li><li><p>Er wird die erste Zeile von Pixeln laden aus einer Bitmap oder Pixmap.</p></li><li><p>Er wird die erste Zeile von Pixeln geschrieben in die <em>Pipe</em>, welche zur Variable <code>fd.in</code> unseres Filters führt.</p></li><li><p>Unser Filter wird jeden Pixel auslesen von der Eingabe, in in seinen negativen Wert umkehren und ihn in den Ausgabepuffer schreiben.</p></li><li><p>Unser Filter wird die Funktion <code>getchar</code> aufrufen, um das nächste Pixel abzurufen.</p></li><li><p>Die Funktion <code>getchar</code> wird einen leeren Eingabepuffer vorfinden und daher die Funktion <code>read</code> aufrufen.</p></li><li><p><code>read</code> wird den Systemaufruf <code>SYS_read</code> starten.</p></li><li><p>Der <em>Kernel</em> wird unseren Filter unterbrechen, bis der Bildeditor mehr Daten zur Pipe sendet.</p></li><li><p>Der Bildedior wird aus der anderen Pipe lesen, welche verbunden ist mit <code>fd.out</code> unseres Filters, damit er die erste Zeile des auszugebenden Bildes setzen kann <em>bevor</em> er uns die zweite Zeile der Eingabe einliest.</p></li><li><p>Der <em>Kernel</em> unterbricht den Bildeditor, bis er eine Ausgabe unseres Filters erhält, um ihn an den Bildeditor weiterzureichen.</p></li></ol></div></div></div><div class=paragraph><p>An diesem Punkt wartet unser Filter auf den Bildeditor, daß er ihm mehr Daten zur Verarbeitung schicken möge. Gleichzeitig wartet der Bildeditor darauf, daß unser Filter das Resultat der Berechnung ersten Zeile sendet. Aber das Ergebnis sitzt in unserem Ausgabepuffer.</p></div><div class=paragraph><p>Der Filter und der Bildeditor werden fortfahren bis in die Ewigkeit aufeinander zu warten (oder zumindest bis sie per kill entsorgt werden). Unsere Software hat den eine <a href=#secure-race-conditions>Race Condition</a> erreicht.</p></div><div class=paragraph><p>Das Problem tritt nicht auf, wenn unser Filter seinen Ausgabepuffer leert <em>bevor</em> er vom <em>Kernel</em> mehr Eingabedaten anfordert.</p></div></div></div></div><div class=sect2><h3 id=x86-fpu>11.13. Die FPU verwenden<a class=anchor href=#x86-fpu></a></h3><div class=paragraph><p>Seltsamerweise erwähnt die meiste Literatur zu Assemblersprachen nicht einmal die Existenz der FPU, oder <em>floating point unit</em> (Fließkomma-Recheneinheit), geschweige denn, daß auf die Programmierung mit dieser eingegangen wird.</p></div><div class=paragraph><p>Dabei kann die Assemblerprogrammierung gerade bei hoch optimiertem FPU-Code, der <em>nur</em> mit einer Assemblersprache realisiert werden kann, ihre große Stärke ausspielen.</p></div><div class=sect3><h4 id=x86-fpu-organization>11.13.1. Organisation der FPU<a class=anchor href=#x86-fpu-organization></a></h4><div class=paragraph><p>Die FPU besteht aus 8 80-bit Fließkomma-Registern. Diese sind in Form eines Stacks organisiert-Sie können einen Wert durch den Befehl <code>push</code> auf dem TOS (<em>top of stack</em>) ablegen, oder durch <code>pop</code> von diesem holen.</p></div><div class=paragraph><p>Da also die Befehle <code>push</code> und <code>pop</code> schon verwendet werden, kann es keine op-Codes in Assemblersprache mit diesen Namen geben.</p></div><div class=paragraph><p>Sie können mit einen Wert auf dem TOS ablegen, indem Sie <code>fld</code>, <code>fild</code>, und <code>fbld</code> verwenden. Mit weiteren op-Codes lassen sich <em>Konstanten</em>-wie z.B. <em>Pi</em>-auf dem TOS ablegen.</p></div><div class=paragraph><p>Analog dazu können Sie einen Wert holen, indem Sie <code>fst</code>, <code>fstp</code>, <code>fist</code>, <code>fistp</code>, und <code>fbstp</code> verwenden. Eigentlich holen (<code>pop</code>) nur die op-Codes, die auf <em>p</em> enden, einen Wert, während die anderen den Wert irgendwo speichern (<code>store</code>) ohne ihn vom TOS zu entfernen.</p></div><div class=paragraph><p>Daten können zwischen dem TOS und dem Hauptspeicher als 32-bit, 64-bit oder 80-bit <em>real</em>, oder als 16-bit, 32-bit oder 64-bit <em>Integer</em>, oder als 80-bit <em>packed decimal</em> übertragen werden.</p></div><div class=paragraph><p>Das 80-bit <em>packed decimal</em>-Format ist ein Spezialfall des <em>binary coded decimal</em>-Formates, welches üblicherweise bei der Konvertierung zwischen der ASCII- und FPU-Darstellung von Daten verwendet wird. Dieses erlaubt die Verwendung von 18 signifikanten Stellen.</p></div><div class=paragraph><p>Unabhängig davon, wie Daten im Speicher dargestellt werden, speichert die FPU ihre Daten immer im 80-bit <em>real</em>-Format in den Registern.</p></div><div class=paragraph><p>Ihre interne Genauigkeit beträgt mindestens 19 Dezimalstellen. Selbst wenn wir also Ergebnisse im ASCII-Format mit voller 18-stelliger Genauigkeit darstellen lassen, werden immer noch korrekte Werte angezeigt.</p></div><div class=paragraph><p>Des weiteren können mathematische Operationen auf dem TOS ausgeführt werden: Wir können dessen <em>Sinus</em> berechnen, wir können ihn <em>skalieren</em> (z.B. können wir ihn mit dem Faktor 2 Multiplizieren oder Dividieren), wir können dessen <em>Logarithmus</em> zur Basis 2 nehmen, und viele weitere Dinge.</p></div><div class=paragraph><p>Wir können auch FPU-Register <em>multiplizieren</em>, <em>dividieren</em>, <em>addieren</em> und <em>subtrahieren</em>, sogar einzelne Register mit sich selbst.</p></div><div class=paragraph><p>Der offizielle Intel op-Code für den TOS ist <code>st</code> und für die <em>Register</em> <code>st(0)</code>- <code>st(7)</code>. <code>st</code> und <code>st(0)</code> beziehen sich dabei auf das gleiche Register.</p></div><div class=paragraph><p>Aus welchen Gründen auch immer hat sich der Originalautor von nasm dafür entschieden, andere op-Codes zu verwenden, nämlich <code>st0</code>- <code>st7</code>. Mit anderen Worten, es gibt keine Klammern, und der TOS ist immer <code>st0</code>, niemals einfach nur <code>st</code>.</p></div><div class=sect4><h5 id=x86-fpu-packed-decimal>11.13.1.1. Das Packed Decimal-Format<a class=anchor href=#x86-fpu-packed-decimal></a></h5><div class=paragraph><p>Das <em>packed decimal</em>-Format verwendet 10 Bytes (80 Bits) zur Darstellung von 18 Ziffern. Die so dargestellte Zahl ist immer ein <em>Integer</em>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Sie können durch Multiplikation des TOS mit Potenzen von 10 die einzelnen Dezimalstellen verschieben.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Das höchste Bit des höchsten Bytes (Byte 9) ist das <em>Vorzeichenbit</em>: Wenn es gesetzt ist, ist die Zahl <em>negativ</em>, ansonsten <em>positiv</em>. Die restlichen Bits dieses Bytes werden nicht verwendet bzw. ignoriert.</p></div><div class=paragraph><p>Die restlichen 9 Bytes enthalten die 18 Ziffern der gespeicherten Zahl: 2 Ziffern pro Byte.</p></div><div class=paragraph><p>Die <em>signifikantere Ziffer</em> wird in der <em>oberen Hälfte</em> (4 Bits) eines Bytes gespeichert, die andere in der <em>unteren Hälfte</em>.</p></div><div class=paragraph><p>Vielleicht würden Sie jetzt annehmen, das <span class=constant>-1234567</span> auf die folgende Art im Speicher abgelegt wird (in hexadezimaler Notation):</p></div><div class="literalblock programlisting"><div class=content><pre>80 00 00 00 00 00 01 23 45 67</pre></div></div><div class=paragraph><p>Dem ist aber nicht so! Bei Intel werden alle Daten im <em>little-endian</em>-Format gespeichert, auch das <em>packed decimal</em>-Format.</p></div><div class=paragraph><p>Dies bedeutet, daß <span class=constant>-1234567</span> wie folgt gespeichert wird:</p></div><div class="literalblock programlisting"><div class=content><pre>67 45 23 01 00 00 00 00 00 80</pre></div></div><div class=paragraph><p>Erinnern Sie sich an diesen Umstand, bevor Sie sich aus lauter Verzweiflung die Haare ausreißen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das lesenswerte Buch-falls Sie es finden können-ist Richard Startz' <a href="http://www.int80h.org/cgi-bin/isbn?isbn=013246604X">8087/80287/80387 for the IBM PC & Compatibles</a>. Obwohl es anscheinend die Speicherung der <em>packed decimal</em> im little-endian-Format für gegeben annimmt. Ich mache keine Witze über meine Verzweiflung, als ich den Fehler im unten stehenden Filter gesucht habe, <em>bevor</em> mir einfiel, daß ich einfach mal versuchen sollte, das little-endian-Format, selbst für diesen Typ von Daten, anzuwenden.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=x86-pinhole-photography>11.13.2. Ausflug in die Lochblendenphotographie<a class=anchor href=#x86-pinhole-photography></a></h4><div class=paragraph><p>Um sinnvolle Programme zu schreiben, müssen wir nicht nur unsere Programmierwerkzeuge beherrschen, sondern auch das Umfeld, für das die Programme gedacht sind.</p></div><div class=paragraph><p>Unser nächster Filter wird uns dabei helfen, wann immer wir wollen, eine <em>Lochkamera</em> zu bauen. Wir brauchen also etwas Hintergrundwissen über die <em>Lochblendenphotographie</em>, bevor wir weiter machen können.</p></div><div class=sect4><h5 id=x86-camera>11.13.2.1. Die Kamera<a class=anchor href=#x86-camera></a></h5><div class=paragraph><p>Die einfachste Form, eine Kamera zu beschreiben, ist die eines abgeschlossenen, lichtundurchlässigen Raumes, in dessen Abdeckung sich ein kleines Loch befindet.</p></div><div class=paragraph><p>Die Abdeckung ist normalerweise fest (z.B. eine Schachtel), manchmal jedoch auch flexibel (z.B. ein Balgen). Innerhalb der Kamera ist es sehr dunkel. Nur durch ein kleines Loch kann Licht von einem einzigen Punkt aus in den Raum eindringen (in manchen Fällen sind es mehrere Löcher). Diese Lichtstrahlen kommen von einem Bild, einer Darstellung von dem was sich außerhalb der Kamera, vor dem kleinen Loch, befindet.</p></div><div class=paragraph><p>Wenn ein lichtempfindliches Material (wie z.B. ein Film) in der Kamera angebracht wird, so kann dieses das Bild einfangen.</p></div><div class=paragraph><p>Das Loch enthält häufig eine <em>Linse</em>, oder etwas linsenartiges, häufig auch einfach <em>Objektiv</em> genannt.</p></div></div><div class=sect4><h5 id=x86-the-pinhole>11.13.2.2. Die Lochblende<a class=anchor href=#x86-the-pinhole></a></h5><div class=paragraph><p>Streng genommen ist die Linse nicht notwendig: Die ursprünglichen Kameras verwendeten keine Linse, sondern eine <em>Lochblende</em>. Selbst heutzutage werden noch <em>Lochblenden</em> verwendet, zum einen, um die Funktionsweise einer Kamera zu erlernen, und zum anderen, um eine spezielle Art von Bildern zu erzeugen.</p></div><div class=paragraph><p>Das Bild, das von einer <em>Lochblende</em> erzeugt wird, ist überall scharf. Oder unscharf. Es gibt eine ideale Größe für eine Lochblende: Wenn sie größer oder kleiner ist, verliert das Bild seine Schärfe.</p></div></div><div class=sect4><h5 id=x86-focal-length>11.13.2.3. Brennweite<a class=anchor href=#x86-focal-length></a></h5><div class=paragraph><p>Dieser ideale Lochblendendurchmesser ist eine Funktion der Quadratwurzel der <em>Brennweite</em>, welche dem Abstand der Lochblende von dem Film entspricht.</p></div><div class="literalblock programlisting"><div class=content><pre>     D = PC * sqrt(FL)</pre></div></div><div class=paragraph><p>Hier ist <code>D</code> der ideale Durchmesser der Lochblende, <code>FL</code> die Brennweite und <span class=constant>PC</span> eine Konstante der Brennweite. Nach Jay Bender hat die Konstante den Wert <span class=constant>0.04</span>, nach Kenneth Connors <span class=constant>0.037</span>. Andere Leute haben andere Werte vorgeschlagen. Des weiteren gelten diese Werte nur für Tageslicht: Andere Arten von Licht benötigen andere konstante Werte, welche nur durch Experimente bestimmt werden können.</p></div></div><div class=sect4><h5 id=x86-f-number>11.13.2.4. Der f-Wert<a class=anchor href=#x86-f-number></a></h5><div class=paragraph><p>Der f-Wert ist eine sehr nützliche Größe, die angibt, wieviel Licht den Film erreicht. Ein Belichtungsmesser kann dies messen, um z.B. für einen Film mit einer Empfindlichkeit von f5.6 eine Belichtungsdauer von 1/1000 Sekunden auszurechnen.</p></div><div class=paragraph><p>Es spielt keine Rolle, ob es eine 35-mm- oder eine 6x9cm-Kamera ist, usw. Solange wir den f-Wert kennen, können wir die benötigte Belichtungszeit berechnen.</p></div><div class=paragraph><p>Der f-Wert läßt sich einfach wie folgt berechnen:</p></div><div class="literalblock programlisting"><div class=content><pre>    F = FL / D</pre></div></div><div class=paragraph><p>Mit anderen Worten, der f-Wert ergibt sich aus der Brennweite (FL), dividiert durch den Durchmesser (D) der Lochblende. Ein großer f-Wert impliziert also entweder eine kleine Lochblende, oder eine große Brennweite, oder beides. Je größer also der f-Wert ist, um so länger muß die Belichtungszeit sein.</p></div><div class=paragraph><p>Des weiteren sind der Lochblendendurchmesser und die Brennweite eindimensionale Meßgrößen, während der Film und die Lochblende an sich zweidimensionale Objekte darstellen. Das bedeutet, wenn man für einen f-Wert <code>A</code> eine Belichtungsdauer <code>t</code> bestimmt hat, dann ergibt sich daraus für einen f-Wert <code>B</code> eine Belichtungszeit von:</p></div><div class="literalblock programlisting"><div class=content><pre>    t * (B / A)²</pre></div></div></div><div class=sect4><h5 id=x86-normalized-f-number>11.13.2.5. Normalisierte f-Werte<a class=anchor href=#x86-normalized-f-number></a></h5><div class=paragraph><p>Während heutige moderne Kameras den Durchmesser der Lochblende, und damit deren f-Wert, weich und schrittweise verändern können, war dies früher nicht der Fall.</p></div><div class=paragraph><p>Um unterschiedliche f-Werte einstellen zu können, besaßen Kameras typischerweise eine Metallplatte mit Löchern unterschiedlichen Durchmessers als Lochblende.</p></div><div class=paragraph><p>Die Durchmesser wurden entsprechend obiger Formel gewählt, daß der resultierende f-Wert ein fester Standardwert war, der für alle Kameras verwendet wurde. Z.B. hat eine sehr alte Kodak Duaflex IV Kamera in meinem Besitz drei solche Löcher für die f-Werte 8, 11 und 16.</p></div><div class=paragraph><p>Eine neuere Kamera könnte f-Werte wie 2.8, 4, 5.6, 8, 11, 16, 22, und 32 (und weitere) besitzen. Diese Werte wurden nicht zufällig ausgewählt: Sie sind alle vielfache der Quadratwurzel aus 2, wobei manche Werte gerundet wurden.</p></div></div><div class=sect4><h5 id=x86-f-stop>11.13.2.6. Der f-Stopp<a class=anchor href=#x86-f-stop></a></h5><div class=paragraph><p>Eine typische Kamera ist so konzipiert, daß die Nummernscheibe bei den normalisierten f-Werten einrastet. Die Nummernscheibe <em>stoppt</em> an diesen Positionen. Daher werden diese Positionen auch f-Stopps genannt.</p></div><div class=paragraph><p>Da die f-Werte bei jedem Stopp vielfache der Quadratwurzel aus 2 sind, verdoppelt die Drehung der Nummernscheibe um einen Stopp die für die gleiche Belichtung benötigte Lichtmenge. Eine Drehung um 2 Stopps vervierfacht die benötigte Belichtungszeit. Eine Drehung um 3 Stopps verachtfacht sie, etc.</p></div></div></div><div class=sect3><h4 id=x86-pinhole-software>11.13.3. Entwurf der Lochblenden-Software<a class=anchor href=#x86-pinhole-software></a></h4><div class=paragraph><p>Wir können jetzt festlegen, was genau unsere Lochblenden-Software tun soll.</p></div><div class=sect4><h5 id=xpinhole-processing-input>11.13.3.1. Verarbeitung der Programmeingaben<a class=anchor href=#xpinhole-processing-input></a></h5><div class=paragraph><p>Da der Hauptzweck des Programms darin besteht, uns beim Entwurf einer funktionierenden Lochkamera zu helfen, wird die <em>Brennweite</em> die Programmeingabe sein. Dies ist etwas, das wir ohne zusätzliche Programme feststellen können: Die geeignete Brennweite ergibt sich aus der Größe des Films und der Art des Fotos, ob dieses ein "normales" Bild, ein Weitwinkelbild oder ein Telebild sein soll.</p></div><div class=paragraph><p>Die meisten bisher geschriebenen Programme arbeiteten mit einzelnen Zeichen, oder Bytes, als Eingabe: Das hex-Programm konvertierte einzelne Bytes in hexadezimale Werte, das csv-Programm ließ entweder einzelne Zeichen unverändert, löschte oder veränderte sie, etc.</p></div><div class=paragraph><p>Das Programm ftuc verwendete einen Zustandsautomaten, um höchstens zwei gleichzeitig eingegebene Bytes zu verarbeiten.</p></div><div class=paragraph><p>Das pinhole-Programm dagegen kann nicht nur mit einzelnen Zeichen arbeiten, sondern muß mit größeren syntaktischen Einheiten zurrecht kommen.</p></div><div class=paragraph><p>Wenn wir z.B. möchten, daß unser Programm den Lochblendendurchmesser (und weitere Werte, die wir später noch diskutieren werden) für die Brennweiten <span class=constant>100 mm</span>, <span class=constant>150 mm</span> und <span class=constant>210 mm</span> berechnet, wollen wir etwa folgendes eingeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 100, 150, 210</code></pre></div></div><div class=paragraph><p>Unser Programm muß mit der gleichzeitigen Eingabe von mehr als nur einem einzelnen Byte zurecht kommen. Wenn es eine <span class=constant>1</span> erkennt, muß es wissen, daß dies die erste Stelle einer dezimalen Zahl ist. Wenn es eine <span class=constant>0</span>, gefolgt von einer weiteren <span class=constant>0</span> sieht, muß es wissen, daß dies zwei unterschiedliche Stellen mit der gleichen Zahl sind.</p></div><div class=paragraph><p>Wenn es auf das erste Komma trifft, muß es wissen, daß die folgenden Stellen nicht mehr zur ersten Zahl gehören. Es muß die Stellen der ersten Zahl in den Wert <span class=constant>100</span> konvertieren können. Und die Stellen der zweiten Zahl müssen in den Wert <span class=constant>150</span> konvertiert werden. Und die Stellen der dritten Zahl müssen in den Wert <span class=constant>210</span> konvertiert werden.</p></div><div class=paragraph><p>Wir müssen festlegen, welche Trennsymbole zulässig sind: Sollen die Eingabewerte durch Kommas voneinander getrennt werden? Wenn ja, wie sollen zwei Zahlen behandelt werden, die durch ein anderes Zeichen getrennt sind?</p></div><div class=paragraph><p>Ich persönlich mag es einfach. Entweder etwas ist eine Zahl, dann wird es verarbeitet, oder es ist keine Zahl, dann wird es verworfen. Ich mag es nicht, wenn sich der Computer bei der <em>offensichtlichen</em> Eingabe eines zusätzlichen Zeichens beschwert. Duh!</p></div><div class=paragraph><p>Zusätzlich erlaubt es mir, die Monotonie des Tippens zu durchbrechen, und eine Anfrage anstelle einer simplen Zahl zu stellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> Was ist der beste Lochblendendurchmesser
	  bei einer Brennweite von 150?</code></pre></div></div><div class=paragraph><p>Es gibt keinen Grund dafür, die Ausgabe mehrerer Fehlermeldungen aufzuteilen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Syntax error: Was
Syntax error: ist
Syntax error: der
Syntax error: beste</code></pre></div></div><div class=paragraph><p>Et cetera, et cetera, et cetera.</p></div><div class=paragraph><p>Zweitens mag ich das <span class=constant>#</span>-Zeichen, um Kommentare zu markieren, die ab dem Zeichen bis zum Ende der jeweiligen Zeile gehen. Dies verlangt nicht viel Programmieraufwand, und ermöglicht es mir, Eingabedateien für meine Programme als ausführbare Skripte zu handhaben.</p></div><div class=paragraph><p>In unserem Fall müssen wir auch entscheiden, in welchen Einheiten die Dateneingabe erfolgen soll: Wir wählen <em>Millimeter</em>, da die meisten Photographen die Brennweite in dieser Einheit messen.</p></div><div class=paragraph><p>Letztendlich müssen wir noch entscheiden, ob wir die Verwendung des dezimalen Punktes erlauben (in diesem Fall müssen wir berücksichtigen, daß in vielen Ländern der Welt das dezimale <em>Komma</em> verwendet wird).</p></div><div class=paragraph><p>In unserem Fall würde das Zulassen eines dezimalen Punktes/Kommas zu einer fälschlicherweise angenommenen, höheren Genauigkeit führen: Der Unterschied zwischen den Brennweiten <span class=constant>50</span> und <span class=constant>51</span> ist fast nicht wahrnehmbar. Die Zulassung von Eingaben wie <span class=constant>50.5</span> ist also keine gute Idee. Beachten Sie bitte, das dies meine Meinung ist. In diesem Fall bin ich der Autor des Programmes. Bei Ihren eigenen Programmen müssen Sie selbst solche Entscheidungen treffen.</p></div></div><div class=sect4><h5 id=x86-pinhole-options>11.13.3.2. Optionen anbieten<a class=anchor href=#x86-pinhole-options></a></h5><div class=paragraph><p>Das wichtigste, was wir zum Bau einer Lochkamera wissen müssen, ist der Durchmesser der Lochblende. Da wir scharfe Bilder schießen wollen, werden wir obige Formel für die Berechnung des korrekten Durchmessers zu gegebener Brennweite verwenden. Da Experten mehrere Werte für die <span class=constant>PC</span>-Konstante anbieten, müssen wir uns hier für einen Wert entscheiden.</p></div><div class=paragraph><p>In der Programmierung unter UNIX® ist es üblich, zwei Hauptvarianten anzubieten, um Parameter an Programme zu übergeben, und des weiteren eine Standardeinstellung für den Fall zu haben, das der Benutzer gar keine Parameter angibt.</p></div><div class=paragraph><p>Warum zwei Varianten, Parameter anzugeben?</p></div><div class=paragraph><p>Ein Grund ist, eine (relativ) <em>feste</em> Einstellung anzubieten, die automatisch bei jedem Programmaufruf verwendet wird, ohne das wir diese Einstellung immer und immer wieder mit angeben müssen.</p></div><div class=paragraph><p>Die feste Einstellung kann in einer Konfigurationsdatei gespeichert sein, typischerweise im Heimatverzeichnis des Benutzers. Die Datei hat üblicherweise denselben Namen wie das zugehörige Programm, beginnt jedoch mit einem Punkt. Häufig wird <em>"rc"</em> dem Dateinamen hinzugefügt. Unsere Konfigurationsdatei könnte also <span class=filename>~/.pinhole</span> oder <span class=filename>~/.pinholerc</span> heißen. (Die Zeichenfolge <span class=filename>~/</span> steht für das Heimatverzeichnis des aktuellen Benutzers.)</p></div><div class=paragraph><p>Konfigurationsdateien werden häufig von Programmen verwendet, die viele konfigurierbare Parameter besitzen. Programme, die nur eine (oder wenige) Parameter anbieten, verwenden häufig eine andere Methode: Sie erwarten die Parameter in einer <em>Umgebungsvariablen</em>. In unserem Fall könnten wir eine Umgebungsvariable mit dem Namen <code>PINHOLE</code> benutzen.</p></div><div class=paragraph><p>Normalerweise verwendet ein Programm entweder die eine, oder die andere der beiden obigen Methoden. Ansonsten könnte ein Programm verwirrt werden, wenn eine Konfigurationsdatei das eine sagt, die Umgebungsvariable jedoch etwas anderes.</p></div><div class=paragraph><p>Da wir nur <em>einen</em> Parameter unterstützen müssen, verwenden wir die zweite Methode, und benutzen eine Umgebungsvariable mit dem Namen <code>PINHOLE</code>.</p></div><div class=paragraph><p>Der andere Weg erlaubt uns, <em>ad hoc</em> Entscheidungen zu treffen: <em>"Obwohl ich normalerweise einen Wert von 0.039 verwende, will ich dieses eine Mal einen Wert von 0.03872 anwenden."</em> Mit anderen Worten, dies erlaubt uns, die Standardeinstellung außer Kraft zu setzen.</p></div><div class=paragraph><p>Diese Art der Auswahl wird häufig über Kommandozeilenparameter gemacht.</p></div><div class=paragraph><p>Schließlich braucht ein Programm <em>immer</em> eine <em>Standardeinstellung</em>. Der Benutzer könnte keine Parameter angeben. Vielleicht weiß er auch gar nicht, was er einstellen sollte. Vielleicht will er es "einfach nur ausprobieren". Vorzugsweise wird die Standardeinstellung eine sein, die die meisten Benutzer sowieso wählen würden. Somit müssen diese keine zusätzlichen Parameter angeben, bzw. können die Standardeinstellung ohne zusätzlichen Aufwand benutzen.</p></div><div class=paragraph><p>Bei diesem System könnte das Programm widersprüchliche Optionen vorfinden, und auf die folgende Weise reagieren:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Wenn es eine <em>ad hoc</em>-Einstellung vorfindet (z.B. ein Kommandozeilenparameter), dann sollte es diese Einstellung annehmen. Es muß alle vorher festgelegten sowie die standardmäßige Einstellung ignorieren.</p></li><li><p><em>Andererseits</em>, wenn es eine festgelegte Option (z.B. eine Umgebungsvariable) vorfindet, dann sollte es diese akzeptieren und die Standardeinstellung ignorieren.</p></li><li><p><em>Ansonsten</em> sollte es die Standardeinstellung verwenden.</p></li></ol></div></div></div><div class=paragraph><p>Wir müssen auch entscheiden, welches <em>Format</em> unsere <span class=constant>PC</span>-Option haben soll.</p></div><div class=paragraph><p>Auf den ersten Blick scheint es einleuchtend, das Format <code>PINHOLE=0.04</code> für die Umgebungsvariable, und <span class=parameter>-p0.04</span> für die Kommandozeile zu verwenden.</p></div><div class=paragraph><p>Dies zuzulassen wäre eigentlich eine Sicherheitslücke. Die <span class=constant>PC</span>-Konstante ist eine sehr kleine Zahl. Daher würden wir unsere Anwendung mit verschiedenen, kleinen Werten für <span class=constant>PC</span> testen. Aber was würde passieren, wenn jemand das Programm mit einem sehr großen Wert aufrufen würde?</p></div><div class=paragraph><p>Es könnte abstürzen, weil wir das Programm nicht für den Umgang mit großen Werten entworfen haben.</p></div><div class=paragraph><p>Oder wir investieren noch weiter Zeit in das Programm, so daß dieses dann auch mit großen Zahlen umgehen kann. Wir könnten dies machen, wenn wir kommerzielle Software für computertechnisch unerfahrene Benutzer schreiben würden.</p></div><div class=paragraph><p>Oder wir könnten auch sagen <em>"Pech gehabt! Der Benutzer sollte es besser wissen."</em></p></div><div class=paragraph><p>Oder wir könnten es für den Benutzer unmöglich machen, große Zahlen einzugeben. Dies ist die Variante, die wir verwenden werden: Wir nehmen einen <em>impliziten 0.</em>-Präfix an.</p></div><div class=paragraph><p>Mit anderen Worten, wenn der Benutzer den Wert <span class=constant>0.04</span> angeben will, so muß er entweder <span class=parameter>-p04</span> als Parameter angeben, oder <code>PINHOLE=04</code> als Variable in seiner Umgebung definieren. Falls der Benutzer <span class=parameter>-p9999999</span> angibt, so wird dies als <span class=constant>0.9999999</span> interpretiert-zwar immer noch sinnlos, aber zumindest sicher.</p></div><div class=paragraph><p>Zweitens werden viele Benutzer einfach die Konstanten von Bender oder Connors benutzen wollen. Um es diesen Benutzern einfacher zu machen, werden wir <span class=parameter>-b</span> als <span class=parameter>-p04</span>, und <span class=parameter>-c</span> als <span class=parameter>-p037</span> interpretieren.</p></div></div><div class=sect4><h5 id=x86-pinhole-output>11.13.3.3. Die Ausgabe<a class=anchor href=#x86-pinhole-output></a></h5><div class=paragraph><p>Wir müssen festlegen, was und in welchem Format unsere Anwendung Daten ausgeben soll.</p></div><div class=paragraph><p>Da wir als Eingabe beliebig viele Brennweiten erlauben, macht es Sinn, die Ergebnisse in Form einer traditionellen Datenbank-Ausgabe darzustellen, bei der zeilenweise zu jeder Brennweite der zugehörige berechnete Wert, getrennt durch ein <span class=constant>tab</span>-Zeichen, ausgegeben wird.</p></div><div class=paragraph><p>Optional sollten wir dem Benutzer die Möglichkeit geben, die Ausgabe in dem schon beschriebenen CSV-Format festzulegen. In diesem Fall werden wir zu Beginn der Ausgabe eine Zeile einfügen, in der die Beschreibungen der einzelnen Felder, durch Kommas getrennt, aufgelistet werden, gefolgt von der Ausgabe der Daten wie schon beschrieben, wobei das <span class=constant>tab</span>-Zeichen durch ein <span class=constant>Komma</span> ersetzt wird.</p></div><div class=paragraph><p>Wir brauchen eine Kommandozeilenoption für das CSV-Format. Wir können nicht <span class=parameter>-c</span> verwenden, da diese Option bereits für <em>verwende Connors Konstante</em> steht. Aus irgendeinem seltsamen Grund bezeichnen viele Webseiten CSV-Dateien als <em>"Excel Kalkulationstabelle"</em> (obwohl das CSV-Format älter ist als Excel). Wir werden daher <span class=parameter>-e</span> als Schalter für die Ausgabe im CSV-Format verwenden.</p></div><div class=paragraph><p>Jede Zeile der Ausgabe wird mit einer Brennweite beginnen. Dies mag auf den ersten Blick überflüssig erscheinen, besonders im interaktiven Modus: Der Benutzer gibt einen Wert für die Brennweite ein, und das Programm wiederholt diesen.</p></div><div class=paragraph><p>Der Benutzer kann jedoch auch mehrere Brennweiten in einer Zeile angeben. Die Eingabe kann auch aus einer Datei, oder aus der Ausgabe eines anderen Programmes, kommen. In diesen Fällen sieht der Benutzer die Eingabewerte überhaupt nicht.</p></div><div class=paragraph><p>Ebenso kann die Ausgabe in eine Datei umgelenkt werden, was wir später noch untersuchen werden, oder sie könnte an einen Drucker geschickt werden, oder auch als Eingabe für ein weiteres Programm dienen.</p></div><div class=paragraph><p>Es macht also wohl Sinn, jede Zeile mit einer durch den Benutzer eingegebenen Brennweite beginnen zu lassen.</p></div><div class=paragraph><p>Halt! Nicht, wie der Benutzer die Daten eingegeben hat. Was passiert, wenn der Benutzer etwas wie folgt eingibt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 00000000150</code></pre></div></div><div class=paragraph><p>Offensichtlich müssen wir die führenden Nullen vorher abschneiden.</p></div><div class=paragraph><p>Wir müssen also die Eingabe des Benutzers sorgfältig prüfen, diese dann in der FPU in die binäre Form konvertieren, und dann von dort aus ausgeben.</p></div><div class=paragraph><p>Aber…​</p></div><div class=paragraph><p>Was ist, wenn der Benutzer etwas wie folgt eingibt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 17459765723452353453534535353530530534563507309676764423</code></pre></div></div><div class=paragraph><p>Ha! Das packed decimal-Format der FPU erlaubt uns die Eingabe einer 18-stelligen Zahl. Aber der Benutzer hat mehr als 18 Stellen eingegeben. Wie gehen wir damit um?</p></div><div class=paragraph><p>Wir <em>könnten</em> unser Programm so modifizieren, daß es die ersten 18 Stellen liest, der FPU übergibt, dann weitere 18 Stellen liest, den Inhalt des TOS mit einem Vielfachen von 10, entsprechend der Anzahl der zusätzlichen Stellen multipliziert, und dann beide Werte mittels <code>add</code> zusammen addiert.</p></div><div class=paragraph><p>Ja, wir könnten das machen. Aber in <em>diesem</em> Programm wäre es unnötig (in einem anderen wäre es vielleicht der richtige Weg): Selbst der Erdumfang in Millimetern ergibt nur eine Zahl mit 11 Stellen. Offensichtlich können wir keine Kamera dieser Größe bauen (jedenfalls jetzt noch nicht).</p></div><div class=paragraph><p>Wenn der Benutzer also eine so große Zahl eingibt, ist er entweder gelangweilt, oder er testet uns, oder er versucht, in das System einzudringen, oder er spielt- indem er irgendetwas anderes macht als eine Lochkamera zu entwerfen.</p></div><div class=paragraph><p>Was werden wir tun?</p></div><div class=paragraph><p>Wir werden ihn ohrfeigen, gewissermaßen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>17459765723452353453534535353530530534563507309676764423	???	???	???	???	???</code></pre></div></div><div class=paragraph><p>Um dies zu erreichen, werden wir einfach alle führenden Nullen ignorieren. Sobald wir eine Ziffer gefunden haben, die nicht Null ist, initialisieren wir einen Zähler mit <span class=constant>0</span> und beginnen mit drei Schritten:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Sende die Ziffer an die Ausgabe.</p></li><li><p>Füge die Ziffer einem Puffer hinzu, welchen wir später benutzen werden, um den packed decimal-Wert zu erzeugen, den wir an die FPU schicken können.</p></li><li><p>Erhöhe den Zähler um eins.</p></li></ol></div></div></div><div class=paragraph><p>Während wir diese drei Schritte wiederholen, müssen wir auf zwei Bedingungen achten:</p></div><div class=ulist><ul><li><p>Wenn der Zähler den Wert 18 übersteigt, hören wir auf, Ziffern dem Puffer hinzuzufügen. Wir lesen weiterhin Ziffern und senden sie an die Ausgabe.</p></li><li><p>Wenn, bzw. <em>falls</em>, das nächste Eingabezeichen keine Zahl ist, sind wir mit der Bearbeitung der Eingabe erst einmal fertig.</p><div class=paragraph><p>Übrigends können wir einfach Zeichen, die keine Ziffern sind, verwerfen, solange sie kein <span class=constant>#</span>-Zeichen sind, welches wir an den Eingabestrom zurückgeben müssen. Dieses Zeichen markiert den Beginn eines Kommentars. An dieser Stelle muß die Erzeugung der Ausgabe fertig sein, und wir müssen mit der Suche nach weiteren Eingabedaten fortfahren.</p></div></li></ul></div><div class=paragraph><p>Es bleibt immer noch eine Möglichkeit unberücksichtigt: Wenn der Benutzer eine Null (oder mehrere) eingibt, werden wir niemals eine von Null verschiedene Zahl vorfinden.</p></div><div class=paragraph><p>Wir können solch einen Fall immer anhand des Zählerstandes feststellen, welcher dann immer bei <span class=constant>0</span> bleibt. In diesem Fall müssen wir einfach eine <span class=constant>0</span> an die Ausgabe senden, und anschließend dem Benutzer erneut eine "Ohrfeige" verpassen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>0	???	???	???	???	???</code></pre></div></div><div class=paragraph><p>Sobald wir die Brennweite ausgegeben, und die Gültigkeit dieser Eingabe verifiziert haben, (größer als <span class=constant>0</span> und kleiner als 18 Zahlen) können wir den Durchmesser der Lochblende berechnen.</p></div><div class=paragraph><p>Es ist kein Zufall, daß <em>Lochblende</em> das Wort <em>Loch</em> enthält. In der Tat ist eine Lochblende buchstäblich eine <em>Loch Blende</em>, also eine Blende, in die mit einer Nadel vorsichtig ein kleines Loch gestochen wird.</p></div><div class=paragraph><p>Daher ist eine typische Lochblende sehr klein. Unsere Formel liefert uns das Ergebnis in Millimetern. Wir werden dieses mit <span class=constant>1000</span> multiplizieren, so daß die Ausgabe in <span class=constant>Mikrometern</span> erfolgt.</p></div><div class=paragraph><p>An dieser Stelle müssen wir auf eine weitere Falle achten: <em>Zu hohe Genauigkeit.</em></p></div><div class=paragraph><p>Ja, die FPU wurde für mathematische Berechnungen mit hoher Genauigkeit entworfen. Unsere Berechnungen hier erfordern jedoch keine solche mathematische Genauigkeit. Wir haben es hier mit Physik zu tun (Optik, um genau zu sein).</p></div><div class=paragraph><p>Angenommen, wir wollten aus eine Lastkraftwagen eine Lochkamera bauen (wir wären dabei nicht die ersten, die das versuchen würden!). Angenommen, die Länge des Laderaumes beträgt <span class=constant>12</span> Meter lang, so daß wir eine Brennweite von <span class=constant>12000</span> hätten. Verwenden wir Benders Konstante, so erhalten wir durch Multiplizieren von <span class=constant>0.04</span> mit der Quadratwurzel aus <span class=constant>12000</span> einen Wert von <span class=constant>4.381780460</span> Millimetern, oder <span class=constant>4381.780460</span> Micrometern.</p></div><div class=paragraph><p>So oder so ist das Rechenergebnis absurd präzise. Unser Lastkraftwagen ist nicht <em>genau</em><span class=constant>12000</span> Millimeter lang. Wir haben diese Länge nicht mit einer so hohen Genauigkeit gemessen, weswegen es falsch wäre zu behaupten, unser Lochblendendurchmesser müsse exakt <span class=constant>4.381780460</span> Millimeter sein. Es reicht vollkommen aus, wenn der Durchmesser <span class=constant>4.4</span> Millimeter beträgt.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ich habe in obigem Beispiel das Rechenergebnis "nur" auf 10 Stellen genau angegeben. Stellen Sie sich vor, wie absurd es wäre, die vollen uns zur Verfügung stehenden, 18 Stellen anzugeben!</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wir müssen also die Anzahl der signifikanten Stellen beschränken. Eine Möglichkeit wäre, die Mikrometer durch eine ganze Zahl darzustellen. Unser Lastkraftwaren würde dann eine Lochblende mit einem Durchmesser von <span class=constant>4382</span> Mikrometern benötigen. Betrachten wir diesen Wert, dann stellen wir fest, das <span class=constant>4400</span> Mikrometer, oder <span class=constant>4.4</span> Millimeter, immer noch genau genug ist.</p></div><div class=paragraph><p>Zusätzlich können wir noch, unabhängig von der Größe eines Rechenergebnisses, festlegen, daß wir nur vier signifikante Stellen anzeigen wollen (oder weniger). Leider bietet uns die FPU nicht die Möglichkeit, das Ergebnis automatisch bis auf eine bestimmte Stelle zu runden (sie sieht die Daten ja nicht als Zahlen, sondern als binäre Daten an).</p></div><div class=paragraph><p>Wir müssen also selber einen Algorithmus entwerfen, um die Anzahl der signifikanten Stellen zu reduzieren.</p></div><div class=paragraph><p>Hier ist meiner (ich denke er ist peinlich-wenn Ihnen ein besserer Algorithmus einfällt, verraten sie ihn mir <em>bitte</em>):</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Initialisiere einen Zähler mit <span class=constant>0</span>.</p></li><li><p>Solange die Zahl größer oder gleich <span class=constant>10000</span> ist, dividiere die Zahl durch <span class=constant>10</span>, und erhöhe den Zähler um eins.</p></li><li><p>Gebe das Ergebnis aus.</p></li><li><p>Solange der Zähler größer als <span class=constant>0</span> ist, gebe eine <span class=constant>0</span> aus, und reduziere den Zähler um eins.</p></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Der Wert <span class=constant>10000</span> ist nur für den Fall, daß Sie <em>vier</em> signifikante Stellen haben wollen. Für eine andere Anzahl signifikanter Stellen müssen Sie den Wert <span class=constant>10000</span> mit <span class=constant>10</span>, hoch der Anzahl der gewünschten signifikanten Stellen, ersetzen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wir können so den Lochblendendurchmesser, auf vier signifikante Stellen gerundet, ausgeben.</p></div><div class=paragraph><p>An dieser Stellen kennen wir nun die <em>Brennweite</em> und den <em>Lochblendendurchmesser</em>. Wir haben also jetzt genug Informationen, um den <em>f-Wert</em> zu bestimmen.</p></div><div class=paragraph><p>Wir werden den f-Wert, auf vier signifikante Stellen gerundet, ausgeben. Es könnte passieren, daß diese vier Stellen recht wenig aussagen. Um die Aussagekraft des f-Wertes zu erhöhen, könnten wir den nächstliegenden, <em>normalisierten f-Wert</em> bestimmen, also z.B. das nächstliegende Vielfache der Quadratwurzel aus 2.</p></div><div class=paragraph><p>Wir erreichen dies, indem wir den aktuellen f-Wert mit sich selbst multiplizieren, so daß wir dessen Quadrat (<code>square</code>) erhalten. Anschließend berechnen wir den Logarithmus zur Basis 2 von dieser Zahl. Dies ist sehr viel einfacher, als direkt den Logarithmus zur Basis der Quadratwurzel aus 2 zu berechnen! Wir runden dann das Ergebnis auf die nächstliegende ganze Zahl. Genau genommen können wir mit Hilfe der FPU diese Berechnung beschleunigen: Wir können den op-Code <code>fscale</code> verwenden, um eine Zahl um 1 zu "skalieren", was dasselbe ist, wie eine Zahl mittels <code>shift</code> um eine Stelle nach links zu verschieben. Am Ende berechnen wir noch die Quadratwurzel aus allem, und erhalten dann den nächstliegenden, normalisierten f-Wert.</p></div><div class=paragraph><p>Wenn das alles jetzt viel zu kompliziert wirkt-oder viel zu aufwendig-wird es vielleicht klarer, wenn man den Code selber betrachtet. Wir benötigen insgesamt 9 op-Codes:</p></div><div class="literalblock programlisting"><div class=content><pre>fmul    st0, st0
    fld1
    fld     st1
    fyl2x
    frndint
    fld1
    fscale
    fsqrt
    fstp    st1</pre></div></div><div class=paragraph><p>Die erste Zeile, <code>fmul st0, st0</code>, quadriert den Inhalt des TOS (Top Of Stack, was dasselbe ist wie <code>st</code>, von nasm auch <code>st0</code> genannt). Die Funktion <code>fld1</code> fügt eine <span class=constant>1</span> dem TOS hinzu.</p></div><div class=paragraph><p>Die nächste Zeile, <code>fld st1</code>, legt das Quadrat auf dem TOS ab. An diesem Punkt befindet sich das Quadrat sowohl in <code>st</code> als auch in <code>st(2)</code> (es wird sich gleich zeigen, warum wir eine zweite Kopie auf dem Stack lassen.) <code>st(1)</code> enthält die <span class=constant>1</span>.</p></div><div class=paragraph><p>Im nächsten Schritt, <code>fyl2x</code>, wird der Logarithmus von <code>st</code> zur Basis 2 berechnet, und anschließend mit <code>st(1)</code> multipliziert. Deshalb haben wir vorher die <span class=constant>1</span> in <code>st(1)</code> abgelegt.</p></div><div class=paragraph><p>An dieser Stelle enthält <code>st</code> den gerade berechneten Logarithmus, und <code>st(1)</code> das Quadrat des aktuellen f-Wertes, den wir für später gespeichert haben.</p></div><div class=paragraph><p><code>frndint</code> rundet den TOS zur nächstliegenden ganzen Zahl. <code>fld1</code> legt eine <span class=constant>1</span> auf dem Stack ab. <code>fscale</code> shiftet die <span class=constant>1</span> auf dem TOS um <code>st(1)</code> Stellen, wodurch im Endeffekt eine 2 in <code>st(1)</code> steht.</p></div><div class=paragraph><p>Schließlich berechnet <code>fsqrt</code> die Quadratwurzel des Rechenergebnisses, also des nächstliegenden, normalisierten f-Wertes.</p></div><div class=paragraph><p>Wir haben nun den nächstliegenden, normalisierten f-Wert auf dem TOS liegen, den auf den Logarithmus zur Basis 2 gerundeten, nächstliegenden ganzzahligen Wert in <code>st(1)</code>, und das Quadrat des aktuellen f-Wertes in <code>st(2)</code>. Wir speichern den Wert für eine spätere Verwendung in <code>st(2)</code>.</p></div><div class=paragraph><p>Aber wir brauchen den Inhalt von <code>st(1)</code> gar nicht mehr. Die letzte Zeile, <code>fstp st1</code>, platziert den Inhalt von <code>st</code> in <code>st(1)</code>, und erniedrigt den Stackpointer um eins. Dadurch ist der Inhalt von <code>st(1)</code> jetzt <code>st</code>, der Inhalt von <code>st(2)</code> jetzt <code>st(1)</code> usw. Der neue <code>st</code> speichert jetzt den normalisierten f-Wert. Der neue <code>st(1)</code> speichert das Quadrat des aktuellen f-Wertes für die Nachwelt.</p></div><div class=paragraph><p>Jetzt können wir den normalisierten f-Wert ausgeben. Da er normalisiert ist, werden wir ihn nicht auf vier signifikante Stellen runden, sondern stattdessen mit voller Genauigkeit ausgeben.</p></div><div class=paragraph><p>Der normalisierte f-Wert ist nützlich, solange er so klein ist, daß wir ihn auf einem Photometer wiederfinden können. Ansonsten brauchen wir eine andere Methode, um die benötigten Belichtungsdaten zu bestimmen.</p></div><div class=paragraph><p>Wir haben weiter oben eine Formel aufgestellt, über die wir einen f-Wert mit Hilfe eines anderen f-Wertes und den zugehörigen Belichtungsdaten bestimmen können.</p></div><div class=paragraph><p>Jedes Photometer, das ich jemals gesehen habe, konnte die benötigte Belichtungszeit für f5.6 berechnen. Wir werden daher einen <em>"f5.6 Multiplizierer"</em> berechnen, der uns den Faktor angibt, mit dem wir die bei f5.6 gemessene Belichtungszeit für unsere Lochkamera multiplizieren müssen.</p></div><div class=paragraph><p>Durch die Formel wissen wir, daß dieser Faktor durch Dividieren unseres f-Wertes (der aktuelle Wert, nicht der normalisierte) durch <span class=constant>5.6</span> und anschließendes Quadrieren, berechnen können.</p></div><div class=paragraph><p>Mathematisch äquivalent dazu wäre, wenn wir das Quadrat unseres f-Wertes durch das Quadrat von <span class=constant>5.6</span> dividieren würden.</p></div><div class=paragraph><p>Numerisch betrachtet wollen wir nicht zwei Zahlen quadrieren, wenn es möglich ist, nur eine Zahl zu quadrieren. Daher wirkt die erste Variante auf den ersten Blick besser.</p></div><div class=paragraph><p>Aber…​</p></div><div class=paragraph><p><span class=constant>5.6</span> ist eine <em>Konstante</em>. Wir müssen nicht wertvolle Rechenzeit der FPU verschwenden. Es reicht aus, daß wir die Quadrate der einzelnen f-Werte durch den konstanten Wert <span class=constant>5.6²</span> dividieren. Oder wir können den jeweiligen f-Wert durch <span class=constant>5.6</span> dividieren, und dann das Ergebnis quadrieren. Zwei Möglichkeiten, die gleich erscheinen.</p></div><div class=paragraph><p>Aber das sind sie nicht!</p></div><div class=paragraph><p>Erinnern wir uns an die Grundlagen der Photographie weiter oben, dann wissen wir, daß sich die Konstante <span class=constant>5.6</span> aus dem 5-fachen der Quadratwurzel aus 2 ergibt. Eine <em>irrationale</em> Zahl. Das Quadrat dieser Zahl ist <em>exakt</em><span class=constant>32</span>.</p></div><div class=paragraph><p><span class=constant>32</span> ist nicht nur eine ganze Zahl, sondern auch ein Vielfaches von 2. Wir brauchen also gar nicht das Quadrat eines f-Wertes durch <span class=constant>32</span> zu teilen. Wir müssen lediglich mittels <code>fscale</code> den f-Wert um fünf Stellen nach rechts shiften. Aus Sicht der FPU müssen wir also <code>fscale</code> mit <code>st(1)</code>, welcher gleich <span class=constant>-5</span> ist, auf den f-Wert anwenden. Dies ist <em>sehr viel schneller</em> als die Division.</p></div><div class=paragraph><p>Jetzt wird es auch klar, warum wir das Quadrat des f-Wertes ganz oben auf dem Stack der FPU gespeichert haben. Die Berechnung des f5.6 Multiplizierers ist die einfachste Berechnung des gesamten Programmes! Wir werden das Ergebnis auf vier signifikante Stellen gerundet ausgeben.</p></div><div class=paragraph><p>Es gibt noch eine weitere nützliche Zahl, die wir berechnen können: Die Anzahl der Stopps, die unser f-Wert von f5.6 entfernt ist. Dies könnte hilfreich sein, wenn unser f-Wert außerhalb des Meßbereiches unseres Photometers liegt, wir aber eine Blende haben, bei der wir unterschiedliche Geschwindigkeiten einstellen können, und diese Blende Stopps benutzt.</p></div><div class=paragraph><p>Angenommen, unser f-Wert ist 5 Stopps von f5.6 entfernt, und unser Photometer sagt uns, daß wir eine Belichtungszeit von 1/1000 Sek. einstellen sollen. Dann können wir unsere Blende auf die Geschwindigkeit 1/1000 einstellen, und unsere Skala um 5 Stopps verschieben.</p></div><div class=paragraph><p>Diese Rechnung ist ebenfalls sehr einfach. Alles, was wir tun müssen, ist, den Logarithmus des f5.6 Multiplizierers, den wir schon berechnet haben (wobei wir dessen Wert vor der Rundung nehmen müssen) zur Basis 2 zu nehmen. Wir runden dann das Ergebnis zur nächsten ganzen Zahl hin, und geben dies aus. Wir müssen uns nicht darum kümmern, ob wir mehr als vier signifikante Stellen haben: Das Ergebnis besteht höchstwahrscheinlich nur aus einer oder zwei Stellen.</p></div></div></div><div class=sect3><h4 id=x86-fpu-optimizations>11.13.4. FPU Optimierungen<a class=anchor href=#x86-fpu-optimizations></a></h4><div class=paragraph><p>In Assemblersprache können wir den Code für die FPU besser optimieren, als in einer der Hochsprachen, inklusive C.</p></div><div class=paragraph><p>Sobald eine C-Funktion die Berechnung einer Fließkommazahl durchführen will, lädt sie erst einmal alle benötigten Variablen und Konstanten in die Register der FPU. Dann werden die Berechnungen durchgeführt, um das korrekte Ergebnis zu erhalten. Gute C-Compiler können diesen Teil des Codes sehr gut optimieren.</p></div><div class=paragraph><p>Das Ergebnis wird "zurückgegeben", indem dieses auf dem TOS abgelegt wird. Vorher wird aufgeräumt. Sämtliche Variablen und Konstanten, die während der Berechnung verwendet wurden, werden dabei aus der FPU entfernt.</p></div><div class=paragraph><p>Was wir im vorherigen Abschnitt selber getan haben, kann so nicht durchgeführt werden: Wir haben das Quadrat des f-Wertes berechnet, und das Ergebnis für eine weitere Berechnung mit einer anderen Funktion auf dem Stack behalten.</p></div><div class=paragraph><p>Wir <em>wußten</em>, daß wir diesen Wert später noch einmal brauchen würden. Wir wußten auch, daß auf dem Stack genügend Platz war (welcher nur Platz für 8 Zahlen bietet), um den Wert dort zu speichern.</p></div><div class=paragraph><p>Ein C-Compiler kann nicht wissen, ob ein Wert auf dem Stack in naher Zukunft noch einmal gebraucht wird.</p></div><div class=paragraph><p>Natürlich könnte der C-Programmierer dies wissen. Aber die einzige Möglichkeit, die er hat, ist, den Wert im verfügbaren Speicher zu halten.</p></div><div class=paragraph><p>Das bedeutet zum einen, daß der Wert mit der FPU-internen, 80-stelligen Genauigkeit in einer normalen C-Variable vom Typ <em>double</em> (64 Bit) oder vom Typ <em>single</em> (32 Bit) gespeichert wird.</p></div><div class=paragraph><p>Dies bedeutet außerdem, daß der Wert aus dem TOS in den Speicher verschoben werden muß, und später wieder zurück. Von allen Operationen mit der FPU ist der Zugriff auf den Speicher die langsamste.</p></div><div class=paragraph><p>Wann immer also mit der FPU in einer Assemblersprache programmiert wird, sollte nach Möglichkeiten gesucht werden, Zwischenergebnisse auf dem Stack der FPU zu lassen.</p></div><div class=paragraph><p>Wir können mit dieser Idee noch einen Schritt weiter gehen! In unserem Programm verwenden wir eine <em>Konstante</em> (die wir <span class=constant>PC</span> genannt haben).</p></div><div class=paragraph><p>Es ist unwichtig, wieviele Lochblendendurchmesser wir berechnen: 1, 10, 20, 1000, wir verwenden immer dieselbe Konstante. Daher können wir unser Programm so optimieren, daß diese Konstante immer auf dem Stack belassen wird.</p></div><div class=paragraph><p>Am Anfang unseres Programmes berechnen wir die oben erwähnte Konstante. Wir müssen die Eingabe für jede Dezimalstelle der Konstanten durch <span class=constant>10</span> dividieren.</p></div><div class=paragraph><p>Multiplizieren geht sehr viel schneller als Dividieren. Wir teilen also zu Beginn unseres Programmes <span class=constant>1</span> durch <span class=constant>10</span>, um <span class=constant>0.1</span> zu erhalten, was wir auf dem Stack speichern: Anstatt daß wir nun für jede einzelne Dezimalstelle die Eingabe wieder durch <span class=constant>10</span> teilen, multiplizieren wir sie stattdessen mit <span class=constant>0.1</span>.</p></div><div class=paragraph><p>Auf diese Weise geben wir <span class=constant>0.1</span> nicht direkt ein, obwohl wir dies könnten. Dies hat einen Grund: Während <span class=constant>0.1</span> durch nur eine einzige Dezimalstelle dargestellt werden kann, wissen wir nicht, wieviele <em>binäre</em> Stellen benötigt werden. Wir überlassen die Berechnung des binären Wertes daher der FPU, mit dessen eigener, hoher Genauigkeit.</p></div><div class=paragraph><p>Wir verwenden noch weitere Konstanten: Wir multiplizieren den Lochblendendurchmesser mit <span class=constant>1000</span>, um den Wert von Millimeter in Micrometer zu konvertieren. Wir vergleichen Werte mit <span class=constant>10000</span>, wenn wir diese auf vier signifikante Stellen runden wollen. Wir behalten also beide Konstanten, <span class=constant>1000</span> und <span class=constant>10000</span>, auf dem Stack. Und selbstverständlich verwenden wir erneut die gespeicherte <span class=constant>0.1</span>, um Werte auf vier signifikante Stellen zu runden.</p></div><div class=paragraph><p>Zu guter letzt behalten wir <span class=constant>-5</span> noch auf dem Stack. Wir brauchen diesen Wert, um das Quadrat des f-Wertes zu skalieren, anstatt diesen durch <span class=constant>32</span> zu teilen. Es ist kein Zufall, daß wir diese Konstante als letztes laden. Dadurch wird diese Zahl die oberste Konstante auf dem Stack. Wenn später das Quadrat des f-Wertes skaliert werden muß, befindet sich die <span class=constant>-5</span> in <code>st(1)</code>, also genau da, wo die Funktion <code>fscale</code> diesen Wert erwartet.</p></div><div class=paragraph><p>Es ist üblich, einige Konstanten per Hand zu erzeugen, anstatt sie aus dem Speicher zu laden. Genau das machen wir mit der <span class=constant>-5</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>    	fld1			; TOS =  1
    	fadd	st0, st0	; TOS =  2
    	fadd	st0, st0	; TOS =  4
    	fld1			; TOS =  1
    	faddp	st1, st0	; TOS =  5
    	fchs			; TOS = -5</pre></div></div><div class=paragraph><p>Wir können all diese Optimierungen in einer Regel zusammenfassen: <em>Behalte wiederverwendbare Werte auf dem Stack!</em></p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><em>PostScript®</em> ist eine Stack-orientierte Programmiersprache. Es gibt weit mehr Bücher über PostScript®, als über die Assemblersprache der FPU: Werden Sie in PostScript® besser, dann werden Sie auch automatisch in der Programmierung der FPU besser.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-pinhole-the-code>11.13.5. pinhole-Der Code<a class=anchor href=#x86-pinhole-the-code></a></h4><div class="literalblock programlisting"><div class=content><pre>;;;;;;; pinhole.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Find various parameters of a pinhole camera construction and use
;
; Started:	 9-Jun-2001
; Updated:	10-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
align 4
ten	dd	10
thousand	dd	1000
tthou	dd	10000
fd.in	dd	stdin
fd.out	dd	stdout
envar	db	&#39;PINHOLE=&#39;	; Exactly 8 bytes, or 2 dwords long
pinhole	db	&#39;04,&#39;, 		; Bender&#39;s constant (0.04)
connors	db	&#39;037&#39;, 0Ah	; Connors&#39; constant
usg	db	&#39;Usage: pinhole [-b] [-c] [-e] [-p &lt;value&gt;] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]&#39;, 0Ah
usglen	equ	$-usg
iemsg	db	&#34;pinhole: Can&#39;t open input file&#34;, 0Ah
iemlen	equ	$-iemsg
oemsg	db	&#34;pinhole: Can&#39;t create output file&#34;, 0Ah
oemlen	equ	$-oemsg
pinmsg	db	&#34;pinhole: The PINHOLE constant must not be 0&#34;, 0Ah
pinlen	equ	$-pinmsg
toobig	db	&#34;pinhole: The PINHOLE constant may not exceed 18 decimal places&#34;, 0Ah
biglen	equ	$-toobig
huhmsg	db	9, &#39;???&#39;
separ	db	9, &#39;???&#39;
sep2	db	9, &#39;???&#39;
sep3	db	9, &#39;???&#39;
sep4	db	9, &#39;???&#39;, 0Ah
huhlen	equ	$-huhmsg
header	db	&#39;focal length in millimeters,pinhole diameter in microns,&#39;
	db	&#39;F-number,normalized F-number,F-5.6 multiplier,stops &#39;
	db	&#39;from F-5.6&#39;, 0Ah
headlen	equ	$-header

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE
dbuffer	resb	20		; decimal input buffer
bbuffer	resb	10		; BCD buffer

section	.text
align 4
huh:
	call	write
	push	dword huhlen
	push	dword huhmsg
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	ret

align 4
perr:
	push	dword pinlen
	push	dword pinmsg
	push	dword stderr
	sys.write
	push	dword 4		; return failure
	sys.exit

align 4
consttoobig:
	push	dword biglen
	push	dword toobig
	push	dword stderr
	sys.write
	push	dword 5		; return failure
	sys.exit

align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	sub	esi, esi

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .getenv		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], &#39;-&#39;
	jne	usage

	inc	ecx
	mov	ax, [ecx]
	inc	ecx

.o:
	cmp	al, &#39;o&#39;
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, &#39;i&#39;
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, &#39;p&#39;
	jne	.c
	or	ah, ah
	jne	.pcheck

	pop	ecx
	or	ecx, ecx
	je	near usage

	mov	ah, [ecx]

.pcheck:
	cmp	ah, &#39;0&#39;
	jl	near usage
	cmp	ah, &#39;9&#39;
	ja	near usage
	mov	esi, ecx
	jmp	.arg

.c:
	cmp	al, &#39;c&#39;
	jne	.b
	or	ah, ah
	jne	near usage
	mov	esi, connors
	jmp	.arg

.b:
	cmp	al, &#39;b&#39;
	jne	.e
	or	ah, ah
	jne	near usage
	mov	esi, pinhole
	jmp	.arg

.e:
	cmp	al, &#39;e&#39;
	jne	near usage
	or	ah, ah
	jne	near usage
	mov	al, &#39;,&#39;
	mov	[huhmsg], al
	mov	[separ], al
	mov	[sep2], al
	mov	[sep3], al
	mov	[sep4], al
	jmp	.arg

align 4
.getenv:
	; If ESI = 0, we did not have a -p argument,
	; and need to check the environment for &#34;PINHOLE=&#34;
	or	esi, esi
	jne	.init

	sub	ecx, ecx

.nextenv:
	pop	esi
	or	esi, esi
	je	.default	; no PINHOLE envar found

	; check if this envar starts with &#39;PINHOLE=&#39;
	mov	edi, envar
	mov	cl, 2		; &#39;PINHOLE=&#39; is 2 dwords long
rep	cmpsd
	jne	.nextenv

	; Check if it is followed by a digit
	mov	al, [esi]
	cmp	al, &#39;0&#39;
	jl	.default
	cmp	al, &#39;9&#39;
	jbe	.init
	; fall through

align 4
.default:
	; We got here because we had no -p argument,
	; and did not find the PINHOLE envar.
	mov	esi, pinhole
	; fall through

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	sub	edx, edx
	mov	edi, dbuffer+1
	mov	byte [dbuffer], &#39;0&#39;

	; Convert the pinhole constant to real
.constloop:
	lodsb
	cmp	al, &#39;9&#39;
	ja	.setconst
	cmp	al, &#39;0&#39;
	je	.processconst
	jb	.setconst

	inc	dl

.processconst:
	inc	cl
	cmp	cl, 18
	ja	near consttoobig
	stosb
	jmp	short .constloop

align 4
.setconst:
	or	dl, dl
	je	near perr

	finit
	fild	dword [tthou]

	fld1
	fild	dword [ten]
	fdivp	st1, st0

	fild	dword [thousand]
	mov	edi, obuffer

	mov	ebp, ecx
	call	bcdload

.constdiv:
	fmul	st0, st2
	loop	.constdiv

	fld1
	fadd	st0, st0
	fadd	st0, st0
	fld1
	faddp	st1, st0
	fchs

	; If we are creating a CSV file,
	; print header
	cmp	byte [separ], &#39;,&#39;
	jne	.bigloop

	push	dword headlen
	push	dword header
	push	dword [fd.out]
	sys.write

.bigloop:
	call	getchar
	jc	near done

	; Skip to the end of the line if you got &#39;#&#39;
	cmp	al, &#39;#&#39;
	jne	.num
	call	skiptoeol
	jmp	short .bigloop

.num:
	; See if you got a number
	cmp	al, &#39;0&#39;
	jl	.bigloop
	cmp	al, &#39;9&#39;
	ja	.bigloop

	; Yes, we have a number
	sub	ebp, ebp
	sub	edx, edx

.number:
	cmp	al, &#39;0&#39;
	je	.number0
	mov	dl, 1

.number0:
	or	dl, dl		; Skip leading 0&#39;s
	je	.nextnumber
	push	eax
	call	putchar
	pop	eax
	inc	ebp
	cmp	ebp, 19
	jae	.nextnumber
	mov	[dbuffer+ebp], al

.nextnumber:
	call	getchar
	jc	.work
	cmp	al, &#39;#&#39;
	je	.ungetc
	cmp	al, &#39;0&#39;
	jl	.work
	cmp	al, &#39;9&#39;
	ja	.work
	jmp	short .number

.ungetc:
	dec	esi
	inc	ebx

.work:
	; Now, do all the work
	or	dl, dl
	je	near .work0

	cmp	ebp, 19
	jae	near .toobig

	call	bcdload

	; Calculate pinhole diameter

	fld	st0	; save it
	fsqrt
	fmul	st0, st3
	fld	st0
	fmul	st5
	sub	ebp, ebp

	; Round off to 4 significant digits
.diameter:
	fcom	st0, st7
	fstsw	ax
	sahf
	jb	.printdiameter
	fmul	st0, st6
	inc	ebp
	jmp	short .diameter

.printdiameter:
	call	printnumber	; pinhole diameter

	; Calculate F-number

	fdivp	st1, st0
	fld	st0

	sub	ebp, ebp

.fnumber:
	fcom	st0, st6
	fstsw	ax
	sahf
	jb	.printfnumber
	fmul	st0, st5
	inc	ebp
	jmp	short .fnumber

.printfnumber:
	call	printnumber	; F number

	; Calculate normalized F-number
	fmul	st0, st0
	fld1
	fld	st1
	fyl2x
	frndint
	fld1
	fscale
	fsqrt
	fstp	st1

	sub	ebp, ebp
	call	printnumber

	; Calculate time multiplier from F-5.6

	fscale
	fld	st0

	; Round off to 4 significant digits
.fmul:
	fcom	st0, st6
	fstsw	ax
	sahf

	jb	.printfmul
	inc	ebp
	fmul	st0, st5
	jmp	short .fmul

.printfmul:
	call	printnumber	; F multiplier

	; Calculate F-stops from 5.6

	fld1
	fxch	st1
	fyl2x

	sub	ebp, ebp
	call	printnumber

	mov	al, 0Ah
	call	putchar
	jmp	.bigloop

.work0:
	mov	al, &#39;0&#39;
	call	putchar

align 4
.toobig:
	call	huh
	jmp	.bigloop

align 4
done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	finit

	; return success
	push	dword 0
	sys.exit

align 4
skiptoeol:
	; Keep reading until you come to cr, lf, or eof
	call	getchar
	jc	done
	cmp	al, 0Ah
	jne	.cr
	ret

.cr:
	cmp	al, 0Dh
	jne	skiptoeol
	ret

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	clc
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.empty
	sub	eax, eax
	ret

align 4
.empty:
	add	esp, byte 4
	stc
	ret

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret

align 4
bcdload:
	; EBP contains the number of chars in dbuffer
	push	ecx
	push	esi
	push	edi

	lea	ecx, [ebp+1]
	lea	esi, [dbuffer+ebp-1]
	shr	ecx, 1

	std

	mov	edi, bbuffer
	sub	eax, eax
	mov	[edi], eax
	mov	[edi+4], eax
	mov	[edi+2], ax

.loop:
	lodsw
	sub	ax, 3030h
	shl	al, 4
	or	al, ah
	mov	[edi], al
	inc	edi
	loop	.loop

	fbld	[bbuffer]

	cld
	pop	edi
	pop	esi
	pop	ecx
	sub	eax, eax
	ret

align 4
printnumber:
	push	ebp
	mov	al, [separ]
	call	putchar

	; Print the integer at the TOS
	mov	ebp, bbuffer+9
	fbstp	[bbuffer]

	; Check the sign
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jns	.leading

	; We got a negative number (should never happen)
	mov	al, &#39;-&#39;
	call	putchar

.leading:
	; Skip leading zeros
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jne	.first
	cmp	ebp, bbuffer
	jae	.leading

	; We are here because the result was 0.
	; Print &#39;0&#39; and return
	mov	al, &#39;0&#39;
	jmp	putchar

.first:
	; We have found the first non-zero.
	; But it is still packed
	test	al, 0F0h
	jz	.second
	push	eax
	shr	al, 4
	add	al, &#39;0&#39;
	call	putchar
	pop	eax
	and	al, 0Fh

.second:
	add	al, &#39;0&#39;
	call	putchar

.next:
	cmp	ebp, bbuffer
	jb	.done

	mov	al, [ebp]
	push	eax
	shr	al, 4
	add	al, &#39;0&#39;
	call	putchar
	pop	eax
	and	al, 0Fh
	add	al, &#39;0&#39;
	call	putchar

	dec	ebp
	jmp	short .next

.done:
	pop	ebp
	or	ebp, ebp
	je	.ret

.zeros:
	mov	al, &#39;0&#39;
	call	putchar
	dec	ebp
	jne	.zeros

.ret:
	ret</pre></div></div><div class=paragraph><p>Der Code folgt demselben Aufbau wie alle anderen Filter, die wir bisher gesehen haben, bis auf eine Kleinigkeit:</p></div><div class=paragraph><p>Wir nehmen nun nicht mehr an, daß das Ende der Eingabe auch das Ende der nötigen Arbeit bedeutet, etwas, das wir für <em>zeichenbasierte</em> Filter automatisch angenommen haben.</p></div><div class=paragraph><p>Dieser Filter verarbeitet keine Zeichen. Er verarbeitet eine <em>Sprache</em> (obgleich eine sehr einfache, die nur aus Zahlen besteht).</p></div><div class=paragraph><p>Wenn keine weiteren Eingaben vorliegen, kann das zwei Ursachen haben:</p></div><div class=ulist><ul><li><p>Wir sind fertig und können aufhören. Dies ist dasselbe wie vorher.</p></li><li><p>Das Zeichen, das wir eingelesen haben, war eine Zahl. Wir haben diese am Ende unseres ASCII -zu-float Kovertierungspuffers gespeichert. Wir müssen nun den gesamten Pufferinhalt in eine Zahl konvertieren, und die letzte Zeile unserer Ausgabe ausgeben.</p></li></ul></div><div class=paragraph><p>Aus diesem Grund haben wir unsere <code>getchar</code>- und <code>read</code>-Routinen so angepaßt, daß sie das <code>carry flag</code> <em>clear</em> immer dann zurückgeben, wenn wir ein weiteres Zeichen aus der Eingabe lesen, und das <code>carry flag</code> <em>set</em> immer dann zurückgeben, wenn es keine weiteren Eingabedaten gibt.</p></div><div class=paragraph><p>Selbstverständlich verwenden wir auch hier die Magie der Assemblersprache! Schauen Sie sich <code>getchar</code> näher an. Dieses gibt <em>immer</em> das <code>carry flag</code> <em>clear</em> zurück.</p></div><div class=paragraph><p>Dennoch basiert der Hauptteil unseres Programmes auf dem <code>carry flag</code>, um diesem eine Beendigung mitzuteilen-und es funktioniert.</p></div><div class=paragraph><p>Die Magie passiert in <code>read</code>. Wann immer weitere Eingaben durch das System zur Verfügung stehen, ruft diese Funktion <code>getchar</code> auf, welche ein weiteres Zeichen aus dem Eingabepuffer einliest, und anschließend das <code>carry flag</code> <em>clear</em>t.</p></div><div class=paragraph><p>Wenn aber <code>read</code> keine weiteren Eingaben von dem System bekommt, ruft dieses <em>nicht</em> <code>getchar</code> auf. Stattdessen addiert der op-Code <code>add esp, byte 4</code> 4 zu <code>ESP</code> hinzu, <em>setzt</em> das <code>carry flag</code>, und springt zurück.</p></div><div class=paragraph><p>Wo springt diese Funktion hin? Wann immer ein Programm den op-Code <code>call</code> verwendet, <code>push</code>t der Mikroprozessor die Rücksprungandresse, d.h. er speichert diese ganz oben auf dem Stack (nicht auf dem Stack der FPU, sondern auf dem Systemstack, der sich im Hauptspeicher befindet). Wenn ein Programm den op-Code <code>ret</code> verwendet, <code>pop</code>t der Mikroprozessor den Rückgabewert von dem Stack, und springt zu der Adresse, die dort gespeichert wurde.</p></div><div class=paragraph><p>Da wir aber 4 zu <code>ESP</code> hinzuaddiert haben (welches das Register der Stackzeiger ist), haben wir effektiv dem Mikroprzessor eine kleine <em>Amnesie</em> verpaßt: Dieser erinnert sich nun nicht mehr daran, daß <code>getchar</code> durch <code>read</code> aufgerufen wurde.</p></div><div class=paragraph><p>Und da <code>getchar</code> nichts vor dem Aufruf von <code>read</code> auf dem Stack abgelegt hat, enthält der Anfang des Stacks nun die Rücksprungadresse von der Funktion, die <code>getchar</code> aufgerufen hat. Soweit es den Aufrufer betrifft, hat dieser <code>getchar</code> ge<code>call</code>t, welche mit einem gesetzten <code>carry flag ret</code>urned.</p></div><div class=paragraph><p>Des weiteren wird die Routine <code>bcdload</code> bei einem klitzekleinen Problem zwischen der Big-Endian- und Little-Endian-Codierung aufgerufen.</p></div><div class=paragraph><p>Diese konvertiert die Textrepräsentation einer Zahl in eine andere Textrepräsentation: Der Text wird in der Big-Endian-Codierung gespeichert, die <em>packed decimal</em>-Darstellung jedoch in der Little-Endian-Codierung.</p></div><div class=paragraph><p>Um dieses Problem zu lösen haben wir vorher den op-Code <code>std</code> verwendet. Wir machen diesen Aufruf später mittels <code>cld</code> wieder rückgängig: Es ist sehr wichtig, daß wir keine Funktion mittels <code>call</code> aufrufen, die von einer Standardeinstellung des <em>Richtungsflags</em> abhängig ist, während <code>std</code> ausgeführt wird.</p></div><div class=paragraph><p>Alles weitere in dem Programm sollte leicht zu verstehen sein, vorausgesetzt, daß Sie das gesamte vorherige Kapitel gelesen haben.</p></div><div class=paragraph><p>Es ist ein klassisches Beispiel für das Sprichwort, daß das Programmieren eine Menge Denkarbeit, und nur ein wenig Programmcode benötigt. Sobald wir uns über jedes Detail im klaren sind, steht der Code fast schon da.</p></div></div><div class=sect3><h4 id=x86-pinhole-using>11.13.6. Das Programm pinhole verwenden<a class=anchor href=#x86-pinhole-using></a></h4><div class=paragraph><p>Da wir uns bei dem Programm dafür entschieden haben, alle Eingaben, die keine Zahlen sind, zu ignorieren (selbst die in Kommentaren), können wir jegliche <em>textbasierten Eingaben</em> verarbeiten. Wir <em>müssen</em> dies nicht tun, wir <em>könnten</em> aber.</p></div><div class=paragraph><p>Meiner bescheidenen Meinung nach wird ein Programm durch die Möglichkeit, anstatt einer strikten Eingabesyntax textbasierte Anfragen stellen zu können, sehr viel benutzerfreundlicher.</p></div><div class=paragraph><p>Angenommen, wir wollten eine Lochkamera für einen 4x5 Zoll Film bauen. Die standardmäßige Brennweite für diesen Film ist ungefähr 150mm. Wir wollen diesen Wert <em>optimieren</em>, so daß der Lochblendendurchmesser eine möglichst runde Zahl ergibt. Lassen Sie uns weiter annehmen, daß wir zwar sehr gut mit Kameras umgehen können, dafür aber nicht so gut mit Computern. Anstatt das wir nun eine Reihe von Zahlen eingeben, wollen wir lieber ein paar <em>Fragen</em> stellen.</p></div><div class=paragraph><p>Unsere Sitzung könnte wie folgt aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pinhole

Computer,

Wie groß müßte meine Lochblende bei einer Brennweite
von 150 sein?
150	490	306	362	2930	12
Hmmm... Und bei 160?
160	506	316	362	3125	12
Laß uns bitte 155 nehmen.
155	498	311	362	3027	12
Ah, laß uns 157 probieren...
157	501	313	362	3066	12
156?
156	500	312	362	3047	12
Das ist es! Perfekt! Vielen Dank!
^D</code></pre></div></div><div class=paragraph><p>Wir haben herausgefunden, daß der Lochblendendurchmesser bei einer Brennweite von 150 mm 490 Mikrometer, oder 0.49 mm ergeben würde. Bei einer fast identischen Brennweite von 156 mm würden wir einen Durchmesser von genau einem halben Millimeter bekommen.</p></div></div><div class=sect3><h4 id=x86-pinhole-scripting>11.13.7. Skripte schreiben<a class=anchor href=#x86-pinhole-scripting></a></h4><div class=paragraph><p>Da wir uns dafür entschieden haben, das Zeichen <span class=constant>#</span> als den Anfang eines Kommentares zu interpretieren, können wir unser pinhole-Programm auch als <em>Skriptsprache</em> verwenden.</p></div><div class=paragraph><p>Sie haben vielleicht schon einmal shell <em>-Skripte</em> gesehen, die mit folgenden Zeichen begonnen haben:</p></div><div class="literalblock programlisting"><div class=content><pre>#! /bin/sh</pre></div></div><div class=paragraph><p>oder</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh</pre></div></div><div class="olist lowerroman"><ol class=lowerroman type=i><li><p>da das Leerzeichen hinter dem <code>#!</code> optional ist.</p></li></ol></div><div class=paragraph><p>Wann immer UNIX® eine Datei ausführen soll, die mit einem <code>#!</code> beginnt, wird angenommen, das die Datei ein Skript ist. Es fügt den Befehl an das Ende der ersten Zeile an, und versucht dann, dieses auszuführen.</p></div><div class=paragraph><p>Angenommen, wir haben unser Programm pinhole unter /usr/local/bin/ installiert, dann können wir nun Skripte schreiben, um unterschiedliche Lochblendendurchmesser für mehrere Brennweiten zu berechnen, die normalerweise mit 120er Filmen verwendet werden.</p></div><div class=paragraph><p>Das Skript könnte wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>#! /usr/local/bin/pinhole -b -i
# Find the best pinhole diameter
# for the 120 film

### Standard
80

### Wide angle
30, 40, 50, 60, 70

### Telephoto
100, 120, 140</pre></div></div><div class=paragraph><p>Da ein 120er Film ein Film mittlerer Größe ist, könnten wir die Datei medium nennen.</p></div><div class=paragraph><p>Wir können die Datei ausführbar machen und dann aufrufen, als wäre es ein Programm:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>755 medium
% ./medium</code></pre></div></div><div class=paragraph><p>UNIX® wird den letzten Befehl wie folgt interpretieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% /usr/local/bin/pinhole <span class=nt>-b</span> <span class=nt>-i</span> ./medium</code></pre></div></div><div class=paragraph><p>Es wird den Befehl ausführen und folgendes ausgeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>80	358	224	256	1562	11
30	219	137	128	586	9
40	253	158	181	781	10
50	283	177	181	977	10
60	310	194	181	1172	10
70	335	209	181	1367	10
100	400	250	256	1953	11
120	438	274	256	2344	11
140	473	296	256	2734	11</code></pre></div></div><div class=paragraph><p>Lassen Sie uns nun das folgende eingeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./medium <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p>UNIX® wird dieses wie folgt behandeln:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% /usr/local/bin/pinhole <span class=nt>-b</span> <span class=nt>-i</span> ./medium <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p>Dadurch erhält das Programm zwei widersprüchliche Optionen: <span class=parameter>-b</span> und <span class=parameter>-c</span> (Verwende Benders Konstante und verwende Connors Konstante). Wir haben unser Programm so geschrieben, daß später eingelesene Optionen die vorheringen überschreiben-unser Programm wird also Connors Konstante für die Berechnungen verwenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>80	331	242	256	1826	11
30	203	148	128	685	9
40	234	171	181	913	10
50	262	191	181	1141	10
60	287	209	181	1370	10
70	310	226	256	1598	11
100	370	270	256	2283	11
120	405	296	256	2739	11
140	438	320	362	3196	12</code></pre></div></div><div class=paragraph><p>Wir entscheiden uns am Ende doch für Benders Konstante. Wir wollen die Ergebnisse im CSV-Format in einer Datei speichern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./medium <span class=nt>-b</span> <span class=nt>-e</span> <span class=o>&gt;</span> bender
% <span class=nb>cat </span>bender
focal length <span class=k>in </span>millimeters,pinhole diameter <span class=k>in </span>microns,F-number,normalized F-number,F-5.6 multiplier,stops from F-5.6
80,358,224,256,1562,11
30,219,137,128,586,9
40,253,158,181,781,10
50,283,177,181,977,10
60,310,194,181,1172,10
70,335,209,181,1367,10
100,400,250,256,1953,11
120,438,274,256,2344,11
140,473,296,256,2734,11
%</code></pre></div></div></div></div><div class=sect2><h3 id=x86-caveats>11.14. Vorsichtsmassnahmen<a class=anchor href=#x86-caveats></a></h3><div class=paragraph><p>Assembler-Programmierer, die aufwuchsen mit MS-DOS® und windows Windows® neigen oft dazu Shotcuts zu verwenden. Das Lesen der Tastatur-Scancodes und das direkte Schreiben in den Grafikspeicher sind zwei klassische Beispiele von Gewohnheiten, die unter MS-DOS® nicht verpönt sind, aber nicht als richtig angesehen werden.</p></div><div class=paragraph><p>Warum dies? Sowohl das PC-BIOS als auch MS-DOS® sind notorisch langsam bei der Ausführung dieser Operationen.</p></div><div class=paragraph><p>Sie mögen versucht sein ähnliche Angewohnheiten in der UNIX®-Umgebung fortzuführen. Zum Beispiel habe ich eine Webseite gesehen, welche erklärt, wie man auf einem beliebten UNIX®-Ableger die Tastatur-Scancodes verwendet.</p></div><div class=paragraph><p>Das ist generell eine <em>sehr schlechte Idee</em> in einer UNIX®-Umgebung! Lassen Sie mich erklären warum.</p></div><div class=sect3><h4 id=x86-protected>11.14.1. UNIX® ist geschützt<a class=anchor href=#x86-protected></a></h4><div class=paragraph><p>Zum Einen mag es schlicht nicht möglich sein. UNIX® läuft im Protected Mode. Nur der Kernel und Gerätetreiber dürfen direkt auf die Hardware zugreifen. Unter Umständen erlaubt es Ihnen ein bestimmter UNIX®-Ableger Tastatur-Scancodes auszulesen, aber ein wirkliches UNIX®-Betriebssystem wird dies zu verhindern wissen. Und falls eine Version es Ihnen erlaubt wird es eine andere nicht tun, daher kann eine sorgfältig erstellte Software über Nacht zu einem überkommenen Dinosaurier werden.</p></div></div><div class=sect3><h4 id=x86-abstraction>11.14.2. UNIX® ist eine Abstraktion<a class=anchor href=#x86-abstraction></a></h4><div class=paragraph><p>Aber es gibt einen viel wichtigeren Grund, weshalb Sie nicht versuchen sollten, die Hardware direkt anzusprechen (natürlich nicht, wenn Sie einen Gerätetreiber schreiben), selbst auf den UNIX®-ähnlichen Systemen, die es Ihnen erlauben:</p></div><div class=paragraph><p><em>UNIX® ist eine Abstraktion!</em></p></div><div class=paragraph><p>Es gibt einen wichtigen Unterschied in der Design-Philosophie zwischen MS-DOS® und UNIX®. MS-DOS® wurde entworfen als Einzelnutzer-System. Es läuft auf einem Rechner mit einer direkt angeschlossenen Tastatur und einem direkt angeschlossenem Bildschirm. Die Eingaben des Nutzers kommen nahezu immer von dieser Tastatur. Die Ausgabe Ihres Programmes erscheint fast immer auf diesem Bildschirm.</p></div><div class=paragraph><p>Dies ist NIEMALS garantiert unter UNIX®. Es ist sehr verbreitet für ein UNIX®, daß der Nutzer seine Aus- und Eingaben kanalisiert und umleitet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% program1 | program2 | program3 <span class=o>&gt;</span> file1</code></pre></div></div><div class=paragraph><p>Falls Sie eine Anwendung program2 geschrieben haben, kommt ihre Eingabe nicht von der Tastatur, sondern von der Ausgabe von program1. Gleichermassen geht Ihre Ausgabe nicht auf den Bildschirm, sondern wird zur Eingabe für program3, dessen Ausgabe wiederum in <span class=filename>file1</span> endet.</p></div><div class=paragraph><p>Aber es gibt noch mehr! Selbst wenn Sie sichergestellt haben, daß Ihre Eingabe und Ausgabe zum Terminal kommt bzw. gelangt, dann ist immer noch nicht garantiert, daß ihr Terminal ein PC ist: Es mag seinen Grafikspeicher nicht dort haben, wo Sie ihn erwarten, oder die Tastatur könnte keine PC-ähnlichen Scancodes erzeugen können. Es mag ein Macintosh® oder irgendein anderer Rechner sein.</p></div><div class=paragraph><p>Sie mögen nun den Kopf schütteln: Mein Programm ist in PC-Assembler geschrieben, wie kann es auf einem Macintosh® laufen? Aber ich habe nicht gesagt, daß Ihr Programm auf Macintosh® läuft, nur sein Terminal mag ein Macintosh® sein.</p></div><div class=paragraph><p>Unter UNIX® muß der Terminal nicht direkt am Rechner angeschlossen sein, auf dem die Software läuft, er kann sogar auf einem anderen Kontinent sein oder sogar auf einem anderen Planeten. Es ist nicht ungewöhnlich, daß ein Macintosh®-Nutzer in Australien sich auf ein UNIX®-System in Nordamerika (oder sonstwo) mittels telnet verbindet. Die Software läuft auf einem Rechner während das Terminal sich auf einem anderen Rechner befindet: Falls Sie versuchen sollten die Scancodes auszulesen werden Sie die falschen Eingaben erhalten!</p></div><div class=paragraph><p>Das Gleiche gilt für jede andere Hardware: Eine Datei, welche Sie einlesen, mag auf einem Laufwerk sein, auf das Sie keinen direkten Zugriff haben. Eine Kamera, deren Bilder Sie auslesen, befindet sich möglicherweise in einem Space Shuttle, durch Satelliten mit Ihnen verbunden.</p></div><div class=paragraph><p>Das sind die Gründe, weshalb Sie niemals unter UNIX® Annahmen treffen dürfen, woher Ihre Daten kommen oder gehen. Lassen Sie immer das System den physischen Zugriff auf die Hardware regeln.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das sind Vorsichtsmassnahmen, keine absoluten Regeln. Ausnahmen sind möglich. Wenn zum Beispiel ein Texteditor bestimmt hat, daß er auf einer lokalen Maschine läuft, dann mag er die Tastatur-Scancodes direkt auslesen, um eine bessere Kontrolle zu gewährleisten. Ich erwähne diese Vorsichtsmassnahmen nicht, um Ihnen zu sagen, was sie tun oder lassen sollen, ich will Ihnen nur bewusst machen, daß es bestimmte Fallstricke gibt, die Sie erwarten, wenn Sie soeben ihn UNIX® von MS-DOS® angelangt sind. Kreative Menschen brechen oft Regeln und das ist in Ordnung, solange sie wissen welche Regeln und warum.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x86-acknowledgements>11.15. Danksagungen<a class=anchor href=#x86-acknowledgements></a></h3><div class=paragraph><p>Dieses Handbuch wäre niemals möglich gewesen ohne die Hilfe vieler erfahrener FreeBSD-Programmierer aus <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>FreeBSD technical discussions</a>. Viele dieser Personen haben geduldig meine Fragen beantwortet und mich in die richtige Richtung gewiesen bei meinem Versuch, die tieferen liegenden Mechanismen der UNIX®-Systemprogrammierung zu erforschen im Allgemeinen und bei FreeBSD im Besonderen.</p></div><div class=paragraph><p>Thomas M. Sommers öffnete die Türen für mich. Seine <a href=http://www.codebreakers-journal.com/content/view/262/27/>Wie schreibe ich "Hallo Welt" in FreeBSD-Assembler?</a> Webseite war mein erster Kontakt mit Assembler-Programmierung unter FreeBSD.</p></div><div class=paragraph><p>Jake Burkholder hat die Tür offen gehalten durch das bereitwillige Beantworten all meiner Fragen und das Zurverfügungstellen von Assembler-Codebeispielen.</p></div><div class=paragraph><p>Copyright ® 2000-2001 G. Adam Stanislav. Alle Rechte vorbehalten.</p></div></div></div></div><h1 id=appendices class=sect0>Teil V: Anhang<a class=anchor href=#appendices></a></h1><div class=sect1><h2 id=bibliography>Literaturverzeichnis<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p><a id=COD></a>[1] Dave A Patterson and John L Hennessy. Copyright® 1998 Morgan Kaufmann Publishers, Inc. 1-55860-428-6. Morgan Kaufmann Publishers, Inc. Computer Organization and Design. The Hardware / Software Interface. 1-2.</p></div><div class=paragraph><p><a id=APUE></a>[2] W. Richard Stevens. Copyright® 1993 Addison Wesley Longman, Inc. 0-201-56317-7. Addison Wesley Longman, Inc. Advanced Programming in the Unix Environment. 1-2.</p></div><div class=paragraph><p><a id=DIFOS></a>[3] Marshall Kirk McKusick and George Neville-Neil. Copyright® 2004 Addison-Wesley. 0-201-70245-2. Addison-Wesley. The Design and Implementation of the FreeBSD Operating System. 1-2.</p></div><div class=paragraph><p><a id=Phrack></a>[4] Aleph One. Phrack 49; "Smashing the Stack for Fun and Profit".</p></div><div class=paragraph><p><a id=StackGuard></a>[5] Chrispin Cowan, Calton Pu, and Dave Maier. StackGuard; Automatic Adaptive Detection and Prevention of Buffer-Overflow Attacks.</p></div><div class=paragraph><p><a id=OpenBSD></a>[6] Todd Miller and Theo de Raadt. strlcpy and strlcat — consistent, safe string copy and concatenation.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 23. März 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=10c02774ea" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#basics>Teil I: Grundlagen</a><ul><li><a href=#introduction>Kapitel 1. Einführung</a></li><li><a href=#tools>Kapitel 2. Werkzeuge zur Programmierung</a></li><li><a href=#secure>Kapitel 3. Sicheres Programmieren</a></li><li><a href=#l10n>Kapitel 4. Lokalisierung und Internationalisierung - L10N und I18N</a></li><li><a href=#policies>Kapitel 5. Vorgaben und Richtlinien für das Quelltextverzeichnis</a></li><li><a href=#testing>Kapitel 6. Regressions- und Performance-Tests</a></li></ul></li><li><a href=#ipc>Teil II: Interprozess-Kommunikation</a><ul><li><a href=#sockets>Kapitel 7. Sockets</a></li><li><a href=#ipv6>Kapitel 8. IPv6 Internals</a></li></ul></li><li><a href=#kernel>Teil III: Kernel</a><ul><li><a href=#kernelbuild>Kapitel 9. Einen FreeBSD-Kernel bauen und installieren</a></li><li><a href=#kerneldebug>Kapitel 10. Kernel-Fehlersuche</a></li></ul></li><li><a href=#architectures>Teil IV: Architekturen</a><ul><li><a href=#x86>Kapitel 11. x86-Assembler-Programmierung</a></li></ul></li><li><a href=#appendices>Teil V: Anhang</a><ul><li><a href=#bibliography>Literaturverzeichnis</a></li></ul></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/developers-handbook/developers-handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/book target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/de/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>