<!doctype html><html class=theme-light lang=de><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/de/books/developers-handbook/ipv6/><title>Kapitel 8. IPv6 Internals | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Kapitel 8. IPv6 Internals"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="http://172.16.201.134:1313/de/books/developers-handbook/ipv6/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/de\/books\/developers-handbook\/ipv6\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/de/books>Books</a></li><li><a href=http://172.16.201.134:1313/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-b1b18a35567534d1699b4dd27b58b2ff class=toggle>
<label for=chapter-b1b18a35567534d1699b4dd27b58b2ff><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/parti/>Teil I. Grundlagen</a></li><li><input type=checkbox id=chapter-3af9d0cd3607fbe44d37e3a13957c40f class=toggle>
<label class="icon cursor" for=chapter-3af9d0cd3607fbe44d37e3a13957c40f><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/introduction/>Kapitel 1. Einführung</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/introduction/#introduction-devel>1.1. Unter FreeBSD entwickeln</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/introduction/#introduction-bsdvision>1.2. Die Vision von BSD</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/introduction/#introduction-archguide>1.3. Grundlegende Richtlinien</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/introduction/#introduction-layout>1.4. Der Aufbau von <span class=filename>/usr/src</span></a></li></ul></li><li><input type=checkbox id=chapter-15219234c513f9a79d9cb2d3bcf73d13 class=toggle>
<label class="icon cursor" for=chapter-15219234c513f9a79d9cb2d3bcf73d13><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/>Kapitel 2. Werkzeuge zur Programmierung</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-synopsis>2.1. Überblick</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-intro>2.2. Zusammenfassung</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-programming>2.3. Einführung in die Programmierung</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-compiling>2.4. Kompilieren mit dem <code>cc</code></a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-make>2.5. Make</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#debugging>2.6. Debuggen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#emacs>2.7. Emacs als Entwicklungsumgebung verwenden</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-reading>2.8. Weiterführende Literatur</a></li></ul></li><li><input type=checkbox id=chapter-7319f5d899d5be33daaf1f2d5f180558 class=toggle>
<label class="icon cursor" for=chapter-7319f5d899d5be33daaf1f2d5f180558><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/>Kapitel 3. Sicheres Programmieren</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-synopsis>3.1. Zusammenfassung</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-philosophy>3.2. Methoden des sicheren Entwurfs</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-bufferov>3.3. Puffer-Überläufe</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-setuid>3.4. SetUID-Themen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-chroot>3.5. Die Umgebung ihrer Programme einschränken</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-trust>3.6. Vertrauen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-race-conditions>3.7. Race-Conditions</a></li></ul></li><li><input type=checkbox id=chapter-0240ccaf7010beed911378cfab7bd8fc class=toggle>
<label class="icon cursor" for=chapter-0240ccaf7010beed911378cfab7bd8fc><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/l10n/>Kapitel 4. Lokalisierung und Internationalisierung - L10N und I18N</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/l10n/#l10n-programming>4.1. I18N-konforme Anwendungen programmieren</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/l10n/#posix-nls>4.2. Lokalisierte Nachrichten mit POSIX.1 Native Language Support (NLS)</a></li></ul></li><li><input type=checkbox id=chapter-c3107aaf64e60e1ee09bc33fc9fd641a class=toggle>
<label class="icon cursor" for=chapter-c3107aaf64e60e1ee09bc33fc9fd641a><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/>Kapitel 5. Vorgaben und Richtlinien für das Quelltextverzeichnis</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/#policies-style>5.1. Stil-Richtlinien</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/#policies-maintainer>5.2. <code>MAINTAINER</code> eines Makefiles</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/#policies-contributed>5.3. Beigesteuerte Software</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/#policies-encumbered>5.4. Belastende Dateien</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/#policies-shlib>5.5. Shared-Libraries</a></li></ul></li><li><input type=checkbox id=chapter-c7b4fd5a7f8f049234fe3bc225acef44 class=toggle>
<label class="icon cursor" for=chapter-c7b4fd5a7f8f049234fe3bc225acef44><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/testing/>Kapitel 6. Regressions- und Performance-Tests</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/testing/#testing-micro-benchmark>6.1. Mikro-Benchmark-Checkliste</a></li></ul></li><li><input type=checkbox id=chapter-1f9b02a65f2bc5d4015a050d706fa837 class=toggle>
<label for=chapter-1f9b02a65f2bc5d4015a050d706fa837><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/partii/>Teil II. Interprozess-Kommunikation</a></li><li><input type=checkbox id=chapter-5e03777f678dd5731a581d7956d19c13 class=toggle>
<label for=chapter-5e03777f678dd5731a581d7956d19c13><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/sockets/>Kapitel 7. Sockets</a></li><li><input type=checkbox id=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3 class=toggle checked>
<label class="icon cursor" for=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/ipv6/>Kapitel 8. IPv6 Internals</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/ipv6/#ipv6-implementation>8.1. IPv6/IPsec-Implementierung</a></li></ul></li><li><input type=checkbox id=chapter-c9a07b517dc2e43d169c8e013e23cfc1 class=toggle>
<label for=chapter-c9a07b517dc2e43d169c8e013e23cfc1><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/partiii/>Teil III. Kernel</a></li><li><input type=checkbox id=chapter-db22f8e5e5e9496dbc711815e2e05f36 class=toggle>
<label class="icon cursor" for=chapter-db22f8e5e5e9496dbc711815e2e05f36><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/kernelbuild/>Kapitel 9. Einen FreeBSD-Kernel bauen und installieren</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kernelbuild/#kernelbuild-traditional>9.1. Einen Kernel auf die "traditionelle" Art und Weise bauen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kernelbuild/#kernelbuild-new>9.2. Einen Kernel auf die "neue" Art und Weise bauen</a></li></ul></li><li><input type=checkbox id=chapter-3036877c53948cfb76174f2776bbdf64 class=toggle>
<label class="icon cursor" for=chapter-3036877c53948cfb76174f2776bbdf64><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/>Kapitel 10. Kernel-Fehlersuche</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-obtain>10.1. Besorgen eines Speicherauszugs nach einem Kernel-Absturz (Kernel-Crash-Dump)</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-gdb>10.2. Fehlersuche in einem Speicherauszug nach einem Kernel-Absturz mit <code>kgdb</code></a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-ddd>10.3. Fehlersuche in einem Speicherauszug nach einem Absturz mit DDD</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-online-ddb>10.4. Online-Kernel-Fehlersuche mit DDB</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-online-gdb>10.5. Online-Kernel-Fehlersuche mit GDB auf einem entfernten System</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-console>10.6. Fehlersuche bei einem Konsolen-Treiber</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-deadlocks>10.7. Fehlersuche bei Deadlocks</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-options>10.8. Glossar der Kernel-Optionen zur Fehlersuche</a></li></ul></li><li><input type=checkbox id=chapter-86707094ce48d6e89e5f45569c084cea class=toggle>
<label for=chapter-86707094ce48d6e89e5f45569c084cea><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/partiv/>Teil IV. Architekturen</a></li><li><input type=checkbox id=chapter-43b1e1e6d2a94eb8b161876bc22ce644 class=toggle>
<label class="icon cursor" for=chapter-43b1e1e6d2a94eb8b161876bc22ce644><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/>Kapitel 11. x86-Assembler-Programmierung</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-intro>11.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-the-tools>11.2. Die Werkzeuge</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-system-calls>11.3. Systemaufrufe</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-return-values>11.4. Rückgabewerte</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-portable-code>11.5. Portablen Code erzeugen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-first-program>11.6. Unser erstes Programm</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-unix-filters>11.7. UNIX®-Filter schreiben</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-buffered-io>11.8. Gepufferte Eingabe und Ausgabe</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-command-line>11.9. Kommandozeilenparameter</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-environment>11.10. Die UNIX®-Umgebung</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-files>11.11. Arbeiten mit Dateien</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-one-pointed-mind>11.12. One-Pointed Mind</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-fpu>11.13. Die FPU verwenden</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-caveats>11.14. Vorsichtsmassnahmen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-acknowledgements>11.15. Danksagungen</a></li></ul></li><li><input type=checkbox id=chapter-c49dfe630861d471fb2f58f5b554ed84 class=toggle>
<label for=chapter-c49dfe630861d471fb2f58f5b554ed84><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/partv/>Teil V. Anhang</a></li><li><input type=checkbox id=chapter-ac9541a3f38001d13964c1b0b324bb83 class=toggle>
<label for=chapter-ac9541a3f38001d13964c1b0b324bb83><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/bibliography/>Literaturverzeichnis</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Kapitel 8. IPv6 Internals</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#ipv6-implementation>8.1. IPv6/IPsec-Implementierung</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=ipv6-implementation>8.1. IPv6/IPsec-Implementierung<a class=anchor href=#ipv6-implementation></a></h2><div class=sectionbody><div class=paragraph><p>Dieser Abschnitt erklärt die von der IPv6- und IPsec-Implementierung abhängigen Internas. Die Funktionalitäten wurden vom <a href=http://www.kame.net/>KAME-Projekt</a> abgeleitet</p></div><div class=sect2><h3 id=ipv6details>8.1.1. IPv6<a class=anchor href=#ipv6details></a></h3><div class=sect3><h4 id=_konformität>8.1.1.1. Konformität<a class=anchor href=#_konformität></a></h4><div class=paragraph><p>Die IPv6 abhängigen Funktionen richten sich nach, oder versuchen sich nach den neuesten IPv6-Spezifikationen zu richten. (<em>Achtung</em>: Dies ist keine vollständige Liste - es wäre zu aufwändig, diese zu pflegen…​).</p></div><div class=paragraph><p>Für weitere Details beachten sie bitte die entsprechenden Kapitel, RFCs, manual pages, oder Kommentare in den Quelltexten.</p></div><div class=paragraph><p>Konformitätsprüfungen wurden basierend auf KAME-STABLE-Kit des TAHI-Projekts durchgeführt. Die Ergebnisse können unter <a href=http://www.tahi.org/report/KAME/>http://www.tahi.org/report/KAME/</a> eingesehen werden. In der Vergangenheit begleiteten wir auch Tests mit unseren älteren "Snapshots" an der Univ. of New Hampshire IOL (<a href=http://www.iol.unh.edu/>http://www.iol.unh.edu/</a>).</p></div><div class=ulist><ul><li><p>RFC1639: FTP Operation Over Big Address Records (FOOBAR)</p><div class=ulist><ul><li><p>RFC2428 wird gegenüber RFC1639 bevorzugt. FTP-Clients versuchen zuerst RFC2428, dann im Fehlerfall RFC1639.</p></li></ul></div></li><li><p>RFC1886: DNS Extensions to support IPv6</p></li><li><p>RFC1933: Transition Mechanisms for IPv6 Hosts and Routers</p><div class=ulist><ul><li><p>IPv4 kompatible Adressen werden nicht unterstützt.</p></li><li><p>Automatisches Tunneln (beschrieben in 4.3 dieses RFC) wird nicht unterstützt.</p></li><li><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a>-Schnittstelle implementiert einen IPv[46]-over-IPv[46] Tunnel in einer allgemeinen Art und Weise und es umfaßt "configured tunnel" wie in der Spezifikation beschrieben. Siehe auch <a href=#gif>23.5.1.5</a> in diese Dokument für weitere Details.</p></li></ul></div></li><li><p>RFC1981: Path MTU Discovery for IPv6</p></li><li><p>RFC2080: RIPng for IPv6</p><div class=ulist><ul><li><p>usr.sbin/route6d unterstützt dies.</p></li></ul></div></li><li><p>RFC2292: Advanced Sockets API for IPv6</p><div class=ulist><ul><li><p>Unterstützte Bibliotheksfunktionen bzw. Kernel-APIs, siehe auch <span class=filename>sys/netinet6/ADVAPI</span>.</p></li></ul></div></li><li><p>RFC2362: Protocol Independent Multicast-Sparse Mode (PIM-SM)</p><div class=ulist><ul><li><p>RFC2362 definiert Paketformate für PIM-SM. <span class=filename>draft-ietf-pim-ipv6-01.txt</span> wurde basierend auf diesem RFC verfaßt.</p></li></ul></div></li><li><p>RFC2373: IPv6 Addressing Architecture</p><div class=ulist><ul><li><p>Unterstützt vom Knoten erforderliche Adressen und richtet sich nach den Erfordernissen des Bereichs.</p></li></ul></div></li><li><p>RFC2374: An IPv6 Aggregatable Global Unicast Address Format</p><div class=ulist><ul><li><p>Unterstützt die 64-Bit-Breite einer Interface ID.</p></li></ul></div></li><li><p>RFC2375: IPv6 Multicast Address Assignments</p><div class=ulist><ul><li><p>Userland-Applikationen nutzen die bekannten Adressen, die in den RFC festgelegt sind.</p></li></ul></div></li><li><p>RFC2428: FTP Extensions for IPv6 and NATs</p><div class=ulist><ul><li><p>RFC2428 wird gegenüber RFC1639 bevorzugt. FTP-Clients versuchen zuerst RFC2428, dann im Fehlerfall RFC1639.</p></li></ul></div></li><li><p>RFC2460: IPv6 specification</p></li><li><p>RFC2461: Neighbor discovery for IPv6</p><div class=ulist><ul><li><p>Siehe auch <a href=#neighbor-discovery>23.5.1.2</a> in diesem Dokument für weitere Details.</p></li></ul></div></li><li><p>RFC2462: IPv6 Stateless Address Autoconfiguration</p><div class=ulist><ul><li><p>Siehe auch <a href=#ipv6-pnp>23.5.1.4</a> in diesem Dokument für weitere Details.</p></li></ul></div></li><li><p>RFC2463: ICMPv6 for IPv6 specification</p><div class=ulist><ul><li><p>Siehe auch <a href=#icmpv6>23.5.1.9</a> in diesem Dokument für weitere Details.</p></li></ul></div></li><li><p>RFC2464: Transmission of IPv6 Packets over Ethernet Networks</p></li><li><p>RFC2465: MIB for IPv6: Textual Conventions and General Group</p><div class=ulist><ul><li><p>Notwendige Statistiken werden vom Kernel gesammelt. Die aktuelle IPv6-MIB-Unterstützung wird als Patch-Sammlung für ucd-snmp bereitgestellt.</p></li></ul></div></li><li><p>RFC2466: MIB for IPv6: ICMPv6 group</p><div class=ulist><ul><li><p>Notwendige Statistiken werden vom Kernel gesammelt. Die aktuelle IPv6-MIB-Unterstützung wird als Patch-Sammlung für ucd-snmp bereitgestellt.</p></li></ul></div></li><li><p>RFC2467: Transmission of IPv6 Packets over FDDI Networks</p></li><li><p>RFC2497: Transmission of IPv6 packet over ARCnet Networks</p></li><li><p>RFC2553: Basic Socket Interface Extensions for IPv6</p><div class=ulist><ul><li><p>IPv4 mapped address (3.7) and special behavior of IPv6 wildcard bind socket (3.8) are supported. See <a href=#ipv6-wildcard-socket>23.5.1.12</a> in this document for details.</p></li></ul></div></li><li><p>RFC2675: IPv6 Jumbogramms</p><div class=ulist><ul><li><p>Siehe auch <a href=#ipv6-jumbo>23.5.1.7</a> in diesem Dokument für weitere Details.</p></li></ul></div></li><li><p>RFC2710: Multicast Listener Discovery for IPv6</p></li><li><p>RFC2711: IPv6 router alert option</p></li><li><p><span class=filename>draft-ietf-ipngwg-router-renum-08</span>: Router renumbering for IPv6</p></li><li><p><span class=filename>draft-ietf-ipngwg-icmp-namelookups-02</span>: IPv6 Name Lookups Through ICMP</p></li><li><p><span class=filename>draft-ietf-ipngwg-icmp-name-lookups-03</span>: IPv6 Name Lookups Through ICMP</p></li><li><p><span class=filename>draft-ietf-pim-ipv6-01.txt</span>: PIM for IPv6</p><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pim6dd&amp;sektion=8&amp;format=html">pim6dd(8)</a> implementiert dense mode. <a href="https://man.freebsd.org/cgi/man.cgi?query=pim6sd&amp;sektion=8&amp;format=html">pim6sd(8)</a> implementiert sparse mode.</p></li></ul></div></li><li><p><span class=filename>draft-itojun-ipv6-tcp-to-anycast-00</span>: Unterbrechen einer TCP-Verbindung toward IPv6 anycast address</p></li><li><p><span class=filename>draft-yamamoto-wideipv6-comm-model-00</span></p><div class=ulist><ul><li><p>Beachte <a href=#ipv6-sas>23.5.1.6</a> in deisem Dokument für weitere Deatils.</p></li></ul></div></li><li><p><span class=filename>draft-ietf-ipngwg-scopedaddr-format-00.txt</span>: Eine Erweiterung des Format for IPv6 Scoped Addresses</p></li></ul></div></div><div class=sect3><h4 id=neighbor-discovery>8.1.1.2. Neighbor Discovery<a class=anchor href=#neighbor-discovery></a></h4><div class=paragraph><p>Neighbor Discovery ist weitestgehend stabil. Zur Zeit werden Addressauflösung, Duplicated Address Detection (DAD), und Neighbor Unreachability Detection (NUD) unterstützt. In der näheren Zukunft werden wir Proxy Neighbor Advertisement Unterstützung in den Kernel einbauen und Unsolicited Neighbor Advertisement Übertragungskommandos als Verwaltungsprogramm zur Verfügung stellen.</p></div><div class=paragraph><p>Falls DAD versagt, wird die Adresse als "duplicated" markiert und eine Nachricht wird erzeugt, die an Syslog gesandt wird (und für gewöhnlich an die Konsole). Die "duplicated"-Markierung kann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> überprüft werden. Es liegt in der Verantwortung des Administrators, auf DAD-Fehler zu achten und diese zu beheben. Dieses Verhalten sollte in der näheren Zukunft verbessert werden.</p></div><div class=paragraph><p>Manche Netzwerktreiber verbinden Multicast-Pakete mit sich selbst, sogar, wenn es vorgeschrieben ist, es nicht zu tun (vor allem im Promiscuous-Modus). In solchen Fällen könnte DAD versagen, weil die DAD-Steuerung ein inbound NS packet sieht (eigentlich vom Knoten selber) und betrachtet es als ein Duplikat. Sie könnten sich die #if-Bedingung ansehen, die in sys/netinet6/nd6_nbr.c:nd6_dad_timer() als "Workaround" mit "heuristics" markiert ist (Beachte, dass das Kodefragment im Abschnitt "heuristics" nicht der Spezifikation entspricht).</p></div><div class=paragraph><p>Neighbor Discovery specification (RFC2461) kommuniziert in den folgenden Fällen nicht über neighbor cache handling:</p></div><div class="olist arabic"><ol class=arabic><li><p>Der Knoten empfing ein unverlangtes RS/NS/NA/redirect-Paket ohne Link-Layer-Adresse, wenn kein neighbor cache-Eintrag vorhanden ist.</p></li><li><p>neighbor cache handling bei Geräten ohne Link-Layer-Adresse (wir benötigen einen neighbor cache Eintrag für das IsRouter-Bit)</p></li></ol></div><div class=paragraph><p>Im ersten Fall implemenierten wir einen Workaround basierend auf Diskussionen in der IETF-Ipngwg-Mailing-Liste. Für weitere Details beachten Sie die Kommentare im Quelltext und im Email-Thread, der bei (IPng 7155) mit dem Datum vom 6. Feb 1999 gestartet wurde.</p></div><div class=paragraph><p>IPv6 on-link Erkennungsregel (RFC2461) ist recht unterschiedlich zu Übernahmen im BSD-Netzwerkkode. Zur Zeit wird keine on-link Erkennungsregel unterstützt, bei der die Defaultrouter-Liste leer ist (RFC2461, Abschnitt 5.2, letzter Satz im zweiten Absatz - beachte, dass die Spezifikation das Wort "host" und "Knoten" an mehreren Stellen im Abschnitt mißbraucht).</p></div><div class=paragraph><p>Um mögliche DoS-Attacken und unendliche Schleifen zu verhindern, werden bis jetzt nur 10 Optionen bei ND-Paketen akzeptiert. Deshalb werden nur die ersten 10 Präfixe berücksichtigt, wenn man 20-Präfixoptionen zu RA hinzugefügt hat. Falls das zu Schwierigkeiten führen sollte, dann sollte in der FREEBSD-CURRENT-Mailing-Liste gefragt werden und/oder die Variable nd6_maxndopt in <span class=filename>sys/netinet6/nd6.c</span> modifizieren. Falls die Nachfrage groß genug ist, könnte man einen sysctl-Knopf für die Variable vorsehen.</p></div></div><div class=sect3><h4 id=ipv6-scope-index>8.1.1.3. Bereichsindex<a class=anchor href=#ipv6-scope-index></a></h4><div class=paragraph><p>IPv6 benutzt Adressbereiche (Scoped Addresses). Deshalb ist es sehr wichtig, mit einer IPv6-Adresse einen Bereichsindex anzugeben (Schnittstellenindex für link-local-Adresse, oder einen Lageindex für site-local-Adressen). Ohne einen Bereichsindex ist ein IPv6-Adressbereich für den Kernel zweideutig und dem Kernel ist es nicht möglich, die Ausgabeschnittstelle für ein Paket festzustellen.</p></div><div class=paragraph><p>Gewöhnliche Userland-Anwendungen sollten die erweiterte Programmierschnittstelle (RFC2292) benutzen, um den Bereichsindex oder Schnittstellenindex festzulegen. Für ähnliche Zwecke wurde in RFC2553 sin6_scope_id member in der sockaddr_in6-Struktur definiert. Wie auch immer, die Semantik für sin6_scope_id ist ziemlich wage. Wenn man auf Portierbarkeit der Anwendung achten muß, dann schlagen wir vor, die erweiterte Programmierschnittstelle anstelle von sin6_scope_id zu benutzen.</p></div><div class=paragraph><p>Im Kernel ist ein Schnittstellenindex für link-local scoped-Adressen in das zweite 16bit-Wort (drittes und viertes Byte) der IPv6-Adresse eingebettet. Zum Beispiel sieht man folgendes</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>fe80:1::200:f8ff:fe01:6317</code></pre></div></div><div class=paragraph><p>in der Routing-Tabelle und in der Schnittstellenadress-Struktur (structin6_ifaddr). Oben genannte Adresse ist eine "link-local unicast address" die zu einer Netzwerkschnittstelle gehört, deren Schnittstellenbezeichner 1 (eins) ist. Der eingebettete Index ermöglicht es, IPv6 link local-Adressen über mehrere Schnittstellen hinweg effektiv und mit wenig Änderungen am Kode zu identifizieren.</p></div><div class=paragraph><p>Routing-Dämonen und Konfigurationsprogramme wie <a href="https://man.freebsd.org/cgi/man.cgi?query=route6d&amp;sektion=8&amp;format=html">route6d(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> werden den "eingebetteten" Bereichsindex verändern müssen. Diese Programme benutzen routing sockets und ioctls (wie SIOCGIFADDR_IN6) und die Kernel-Programmierschnittstelle wird IPv6-Adressen, dessen zweites 16-Bit-Word gesetzt ist, zurückgeben. Diese Programmierschnittstellen dienen zur Änderung der Kernel-internen Struktur. Programme, die diese Programmierschnittstellen benutzen, müssen ohnehin auf Unterschiede in den Kerneln vorbereitet sein.</p></div><div class=paragraph><p>Wenn man einen Adressbereich in der Kommandozeile angibt, schreibt man niemals die eingebettete Form (so etwas wie ff02:1::1 or fe80:2::fedc). Man erwartet nicht, dass es funktioniert. Man benutzt immer die Standardform wie ff02::1 oder fe80::fedc, zusammen mit der Kommandozeilenoption, die die Schnittstelle festlegt (wie <code>ping6 -I ne0 ff02::1</code>). Allgemein gilt, wenn ein Kommando keine Kommandozeilenoption hat, um die Ausgabeschnittstelle zu definieren, ist dieses Kommando noch nicht für Adressbereiche bereit. Dies scheint der Prämisse von IPv6 entgegenzustehen. Wir glauben, dass die Spezifikationen einige Verbesserungen benötigen.</p></div><div class=paragraph><p>Einige der Userland-Werkzeuge unterstützen die erweiterte numerische IPv6-Syntax wie sie in <span class=filename>draft-ietf-ipngwg-scopedaddr-format-00.txt</span> beschrieben ist. Man kann die ausgehende Verbindung angeben, indem man den Namen der ausgehenden Schnittstelle wie folgt benutzt: "fe80::1%ne0". Auf diese Art und Weise ist man in der Lage, eine link-local scoped Adresse ohne viele Schwierigkeiten anzugeben.</p></div><div class=paragraph><p>Um die Erweiterungen im eigenen Programm zu nutzen, muss man <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a> mit NI_WITHSCOPEID verwenden. Die Implementierung setzt im Moment eine 1-zu-1 Beziehung zwischen einer Verbindung und einer Schnittstelle voraus, die stärker ist, als es die Spezifikationen beschreiben.</p></div></div><div class=sect3><h4 id=ipv6-pnp>8.1.1.4. Plug and Play<a class=anchor href=#ipv6-pnp></a></h4><div class=paragraph><p>Der grösste Teil der statuslosen IPv6-Adress-Autokonfiguration ist im Kernel implementiert. Neighbor-Discovery-Funktionen sind als ganzes im Kernel implementiert. Router-Advertisement (RA) Eingabe für Hosts ist im Kernel implementiert. Router-Solicitation (RS) Ausgabe für Hosts, RS-Eingabe für Router und RA-Ausgabe für Router ist im Userland implementiert.</p></div><div class=sect4><h5 id=_zuweisung_von_link_local_und_speziellen_adressen>8.1.1.4.1. Zuweisung von link-local und speziellen Adressen<a class=anchor href=#_zuweisung_von_link_local_und_speziellen_adressen></a></h5><div class=paragraph><p>Die IPv6 link-local-Adresse wird aus einer IEEE802-Adresse (Ethernet MAC address) erzeugt. Jeder Schnittstelle wird automatisch eine IPv6 link-local-Adresse zugewiesen, sobald die Schnittstelle aktiv ist (IFF_UP). Ebenso wird eine direkte Route für die link-local-Adresse zur Routing-Tabelle hinzugefügt.</p></div><div class=paragraph><p>Hier ist eine Ausgabe des netstat-Kommandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Internet6:
Destination                   Gateway                   Flags      Netif Expire
fe80:1::%ed0/64               <span class=nb>link</span><span class=c>#1                    UC          ed0</span>
fe80:2::%ep0/64               <span class=nb>link</span><span class=c>#2                    UC          ep0</span></code></pre></div></div><div class=paragraph><p>Schnittstellen, die keine IEEE802-Adresse haben (Pseudo-Schnittstellen wie Tunnel-Schnittstellen oder ppp-Schnittstellen), borgen sich eine IEEE802-Adresse von anderen Schnittstellen wie Ethernet-Schnittstellen aus, wann immer das möglich ist. Wenn keine IEEE802-Geräte eingebaut sind, wird als letzte Möglichkeit eine Pseudo-Zufallszahl - MD5(hostname) - als Quelle für eine link-local-Adresse benutzt. Falls diese für den Einsatz nicht geeignet sein sollte, dann muss man eine link-local-Adresse manuell konfigurieren.</p></div><div class=paragraph><p>Falls eine Schnittstelle nicht imstande ist, IPv6-Adressen zu handhaben (wie fehlende Unterstützung des multicast), wird keine link-local-Adresse der Schnittstelle zugewiesen. Siehe Abschnitt 2 für weitere Details.</p></div><div class=paragraph><p>Jede Schnittstelle verbindet die solicited multicast Adresse und link-local all-nodes multicast-Adressen (z.B. fe80::1:ff01:6317 und ff02::1, jeweils zu der Verbindung, an die die Schnittstelle verbunden ist). zusätzlich zu einer link-local-Adresse wird eine loopback-Adresse (::1) einer loopback-Schnittstelle zugewiesen. Außerdem werden ::1/128 und ff01::/32 automatisch zur Routing-Tabelle hinzugefügt und die loopback-Schnittstelle verbindet sich mit der node-local multicast Gruppe ff01::1.</p></div></div><div class=sect4><h5 id=_stateless_address_autoconfiguration_beim_host>8.1.1.4.2. Stateless address autoconfiguration beim Host<a class=anchor href=#_stateless_address_autoconfiguration_beim_host></a></h5><div class=paragraph><p>In der IPv6-Spezifikation werden Knoten in zwei Kategorien unterteilt: <em>Router</em> und <em>Hosts</em>. Router leiten Pakete, die an andere adressiert sind, weiter, Hosts leiten Pakete nicht weiter. net.inet6.ip6.forwarding definiert, ob dieser Knoten ein Router oder ein Host ist (Router falls es 1 ist, Host, falls es 0 ist).</p></div><div class=paragraph><p>Sobald ein Host ein Router-Advertisement vom Router hört, kann er sich selbst mit statusloser automatischer Adressen konfigurieren. Dieses Verhalten kann mit net.inet6.ip6.accept_rtadv (der Host konfiguriert sich selber, wenn es auf 1 gesetzt ist) beeinflusst werden. Bei einer automatischen Konfiguration wird das Netzwerkadresspräfix für die empfangende Schnittstelle (für gewöhnlich das globale Adresspräfix) hinzugefügt. Die Standard-Route wird ebenso konfiguriert. Router erzeugen periodisch Router-Advertisement-Pakete. Um einen benachbarten Router aufzufordern, ein RA-Paket zu erzeugen, kann eine Host-Router-Solicitation übertragen werden. Um jederzeit ein RS-Paket zu erzeugen, benutzt man das <em>rtsol</em>-Kommando. Ein <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;format=html">rtsold(8)</a>-Dämon ist ebenso verfügbar. <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;format=html">rtsold(8)</a> erzeugt Router-Solicitation, wann immer es notwendig ist und es funktioniert großartig "bei normadischem Einsatz" (Notebooks/Laptops). Falls jemand Router-Advertisements zu ignorieren wünscht, setzt man mit sysctl et.inet6.ip6.accept_rtadv auf 0.</p></div><div class=paragraph><p>Um Router-Advertisement von einem Router aus zu erzeugen, benutzt man den <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>-Dämon.</p></div><div class=paragraph><p>Beachte, dass die IPv6-Spezifikation von folgenden Punkte ausgeht und nicht konforme Fälle werden als nicht spezifiziert ausgelassen:</p></div><div class=ulist><ul><li><p>Nur Hosts hören auf Router-Angebote</p></li><li><p>Hosts haben eine einzige Netzwerk-Schnittstelle (außer loopback)</p></li></ul></div><div class=paragraph><p>Deshalb ist es unklug, net.inet6.ip6.accept_rtadv bei Routern oder bei Hosts mit mehreren Schnittstellen einzuschalten. Ein falsch konfigurierter Knoten kann sich seltsam verhalten (nicht konforme Konfiguration ist für diejenigen erlaubt, die Experimente durchführen möchten).</p></div><div class=paragraph><p>Eine Zusammenfassung des sysctl-Angaben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	accept_rtadv forwarding Rolle des Knotens
   <span class=nt>---</span>	   <span class=nt>---</span>    <span class=nt>---</span>
    0       0    Host <span class=o>(</span>wird manuell konfiguriert<span class=o>)</span>
    0       1    Router
    1       0    automatisch konfigurierter Host
	             <span class=o>(</span>Die Spezifikation setzt voraus, dass der Host nur eine einzelne Schnittstelle hat, ein automatisch konfigurierter Host mit mehreren Schnittstellen ist außerhalb der Betrachtung<span class=o>)</span>
    1       1    ungültig, oder für Experimentierzwecke <span class=o>(</span>außerhalb der Spezifikation<span class=o>)</span></code></pre></div></div><div class=paragraph><p>RFC2462 hat eine Überprüfungsregel gegen eingehende RA-prefix-information-option, in 5.5.3 (e). Dies dient zum Schutz des Hosts vor schlecht oder falsch konfigurierten Routern, die eine sehr kurze Präfixlebenszeit ankündigen. Es gab Aktualisierungen von Jim Bound in der ipngwg-Mailing-Liste (suche nach "(ipng 6712)" im Archive) und es wurde Jims Aktualisierung implementiert.</p></div><div class=paragraph><p>Siehe auch <a href=#neighbor-discovery>23.5.1.2</a> im Dokument für das Verhältnis zwischen DAD und autoconfiguration.</p></div></div></div><div class=sect3><h4 id=gif>8.1.1.5. Generische Tunnel-Schnittstelle<a class=anchor href=#gif></a></h4><div class=paragraph><p>GIF (Generische Schnittstelle) ist eine Pseudoschnittstelle für konfigurierte Tunnel. Details sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> beschrieben. Im Moment sind</p></div><div class=ulist><ul><li><p>v6 in v6</p></li><li><p>v6 in v4</p></li><li><p>v4 in v6</p></li><li><p>v4 in v4</p></li></ul></div><div class=paragraph><p>verfügbar. Benutze <a href="https://man.freebsd.org/cgi/man.cgi?query=gifconfig&amp;sektion=8&amp;format=html">gifconfig(8)</a>, um die physikalische (außerhalb liegende) Quelle und die Zieladresse den gif-Schnittstellen zuzuweisen. Eine Konfiguration, die die selbe Adressfamilie für innere und äußere IP-Header (v4 in v4, oder v6 in v6) benutzt, ist gefährlich. Es ist sehr leicht, Schnittstellen und Routing-Tabellen so zu konfigurieren, dass eine unendliche Ebene von Tunneln ausgeführt wird. <em>Seien Sie also gewarnt</em>.</p></div><div class=paragraph><p>gif kann ECN-freundlich konfiguriert werden. Beachte <a href=#ipsec-ecn>23.5.4.5</a> für eine ECN-Freundlichkeit von Tunneln und <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> wie man sie konfiguriert.</p></div><div class=paragraph><p>Falls man einen IPv4-in-IPv6-Tunnel mit einer gif-Schnittstelle konfigurieren möchte, sollte man <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> sorgfältig lesen. Man muss die IPv6 link-local Adresse, die automatisch der gif-Schnittstelle zugewiesen wird, entfernen.</p></div></div><div class=sect3><h4 id=ipv6-sas>8.1.1.6. Source Address Selection<a class=anchor href=#ipv6-sas></a></h4><div class=paragraph><p>Im Moment ist die Regel zur Auswahl der Quelle bereichsorientiert (es gibt einige Ausnahmen - siehe unten). Für ein gegebenes Ziel wird eine Quell-IPv6-Adresse durch folgende Regel ausgewählt:</p></div><div class="olist arabic"><ol class=arabic><li><p>Falls die Quelladresse explizit durch den Benutzer angegeben ist (z.B. über das erweiterte API), dann wird die angegebene Adresse benutzt.</p></li><li><p>Falls eine Adresse der ausgehenden Schnittstelle zugewiesen wird, die den selben Bereich wie die Zieladresse hat (was normalerweise durch einen Blick in die Routing-Tabelle festgestellt werden kann), dann wird diese Adresse benutzt.</p><div class=paragraph><p>Dies ist ein typischer Fall.</p></div></li><li><p>Falls keine Adresse der obigen Bedingung genügt, dann wählt man eine globale Adresse, die einer der Schnittstellen des sendenden Knotens zugewiesen ist.</p></li><li><p>Falls keine Adresse der obigen Bedingung genügt und die Zieladresse ist im site local-Bereich, dann wählt man eine eine site local-Adresse, die einer der Schnittstellen des sendenden Knotens zugewiesen ist.</p></li><li><p>Falls keine Adresse der obigen Bedingung genügt, dann wählt man eine Adresse, die mit einem Eintrag in der Routing-Tabelle für das Ziel verbunden ist. Dies ist die letzte Möglichkeit, die eine Bereichsverletzung verursachen könnte.</p></li></ol></div><div class=paragraph><p>Zum Beispiel, ::1 ist ausgewählt für ff01::1, fe80:1::200:f8ff:fe01:6317 für fe80:1::2a0:24ff:feab:839b (beachte den eingebetteten Schnittstelleindex - beschrieben in <a href=#ipv6-scope-index>23.5.1.3</a> - er hilft uns, die richtige Quelladresse auszuwählen. Diese eingebetteten Indexe werden nicht übertragen). Falls die ausgehende Schnittstelle mehrere Adressen für einen Bereich hat, wird die Quelle gewählt, die die breiteste passende Basis hat (Regel 3). Angenommen 2001:0DB8:808:1:200:f8ff:fe01:6317 und 2001:0DB8:9:124:200:f8ff:fe01:6317 sind einer ausgehenden Schnittstelle zugewiesen. 2001:0DB8:808:1:200:f8ff:fe01:6317 wird als Quelle für das Ziel 2001:0DB8:800::1 ausgewählt.</p></div><div class=paragraph><p>Beachte, dass obige Regel nicht in der IPv6-Spezifikation dokumentiert ist. Es wird als "up to implementation"-Punkt betrachtet. Es gibt einige Fälle, bei denen die obige Regel nicht benutzt werden soll. Ein Beispiel ist die verbundene TCP-Sitzung und man benutzt die Adresse, die in tcb als Quelle gehalten wird. Ein anderes Beispiel ist die Quelladresse für Neighbor Advertisement. Laut Spezifikation (RFC2461 7.2.2) sollte die Quelle des NA die Zieladresse des korrespondierenden Ziel des NS sein. In diesem Fall folgen wir eher der Spezifikation, als der obigen longest-match-Regel.</p></div><div class=paragraph><p>Für neue Verbindungen werden (wenn Regel eins nicht zutrifft) abgelehnte Adressen (Adressen mit bevorzugter Lebenszeit = 0) nicht ausgewählt, wenn andere Auswahlmöglichkeiten bestehen. Wenn keine anderen Auswahlmöglichkeiten bestehen, werden abgelehnte Adressen als letzte Möglichkeit benutzt. Falls mehrere Auswahlmöglichkeiten für abgelehnte Adressen bestehen, dann wird ogige Regel verwendet, um aus diesen abgelehnten Adressen auszuwählen. Falls man aus bestimmten Gründen die Benutzung abgelehnter Adressen unterbinden möchte, dann setzt man net.inet6.ip6.use_deprecated auf 0. Der Punkt bezüglich der abgelehnten Adressen ist in RFC2462 5.5.4 beschrieben (Beachte: Im Moment wird in der IETF ipngwg darüber debatiert, wie angelehnte Adressen benutzt werden sollen).</p></div></div><div class=sect3><h4 id=ipv6-jumbo>8.1.1.7. Jumbo Payload<a class=anchor href=#ipv6-jumbo></a></h4><div class=paragraph><p>Die Jumbo-Payload hop-by-hop-Option ist implementiert und kann benutzt werden, um IPv6-Pakete mit Datenpaketen größer als 65.535 Oktette. Aber im Moment wird keine physikalische Schnittstelle unterstützt, deren MTU größer ist als 65.536, so dass diese Datenpakete nur bei den loopback-Schnittstellen zu finden sind (z.B. lo0).</p></div><div class=paragraph><p>Falls man die Jumbo Payloads testen möchte, muss man zunächst den Kernel rekonfigurieren, so dass die MTU der loopback-Schnittstelle grösser 65.535 Bytes sein kann. Füge folgende Zeile zur Kernel-Konfiguration hinzu:</p></div><div class=paragraph><p><code>options "LARGE_LOMTU" #Um Jumbo Payload zu testen</code></p></div><div class=paragraph><p>und dann kompiliere den Kernel neu.</p></div><div class=paragraph><p>Dann kann man die Jumbo-Payloads mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=ping6&amp;sektion=8&amp;format=html">ping6(8)</a>-Kommando mit den Optionen -b und -s testen. Die Option -b muss angegeben werden, um die Größe des Socket-Puffers zu erhön, und die Option -s gibt die Größe des Pakets an, die größer als 65.535 sein sollte. Beispielsweise gibt man folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping6 <span class=nt>-b</span> 70000 <span class=nt>-s</span> 68000 ::1</code></pre></div></div><div class=paragraph><p>Die IPv6-Spezifikation verlangt, dass die Jumbo-Payload-Option nicht in einem Paket verwendet werden darf, das einen fragmentierten Header hat. Falls diese Bedingung nicht zutrifft, dann muss eine ICMPv6-Parameter-Problem-Nachricht an den Absender geschickt werden. Die Spezifikation ist befolgt, aber man kann normalerweise nicht einen ICMPv6-Fehler sehen, der durch diese Forderung hervorgerufen wird.</p></div><div class=paragraph><p>Wenn ein IPv6-Paket empfangen wird, dann wird die Rahmenlänge geprüft und sie wird mit der Größe verglichen, die im Datenfeld für die Paketgröße des IPv6-Headers oder im Wert für die Jumbo-Payload-Option angegeben ist, sofern vorhanden. Falls ersterer kleiner als letzterer ist, dann wird das Paket abgelehnt und die Statistiken werden erhöht. Man kann die Statistik als Ausgabe des <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=8&amp;format=html">netstat(8)</a>-Kommandos mit der <code>-s -p ip6</code>-Option sehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-s</span> <span class=nt>-p</span> ip6
	  ip6:
		<span class=o>(</span>snip<span class=o>)</span>
		1 with data size &lt; data length</code></pre></div></div><div class=paragraph><p>So, der Kernel sendet keinen ICMPv6-Fehler, außer das fehlerhafte Paket ist ein aktuelles Jumbo-Payload, dessen Paketgröße größer als 65,535 Bytes ist. Wie oben beschrieben, gibt es momentan keine physikalische Schnittstelle, die eine so riesige MTU unterstützt, daher gibt es so selten einen ICMPv6-Fehler.</p></div><div class=paragraph><p>TCP/UDP over Jumbogramm wird im Moment nicht unterstützt. Dies kommt daher, weil wir kein Medium (außer loopback) haben, dies zu testen. Melden Sie sich, falls Sie es benötigen.</p></div><div class=paragraph><p>IPsec funktioniert nicht mit Jumbogramm. Dies ist bedingt durch einige Änderungen an der Spezifikation, welche die Unterstützung von AH mit Jumbogramm betrifft (AH-Header-Größe beeinflusst die Länge des Datenpakets und das macht es richtig schwierig, ein eingehendes Paket mit Jumbo-Payload-Option so gut zu authentifizieren wie ein AH).</p></div><div class=paragraph><p>Es gibt grundlegende Punkte in der *BSD-Unterstützung für Jumbogramms. Wir würden jene gerne ansprechen, aber wir benötigen mehr Zeit diese fertig zu stellen. Um ein paar zu benennen:</p></div><div class=ulist><ul><li><p>mbuf pkthdr.len-Feld ist in 4.4BSD typisiert als "int", so dass es kein Jumbogramm mit len > 2G bei 32Bit-Architekturen aufnehmen kann. Wenn wir Jumbogramme geeignet unterstützen wollten, dann muss das Feld erweitert werden, damit es 4G + IPv6-Header + link-layer-Header aufnehmen kann. Deshalb muss es schließlich auf int64_t (u_int32_t ist NICHT genug) erweitert werden.</p></li><li><p>Irrigerweise benutzen wir "int" an vielen Stellen, um die Paketlänge aufzunehmen. Wir müssen sie in einen größeren ganzzahligen Typ konvertieren. Es braucht große Vorsicht, weil wir sonst einen Überlauf während der Berechnung der Paketlänge erleben können.</p></li><li><p>Irrigerweise prüfen wir das ip6_plen-Feld des IPv6-Header für packet payload length an verschiedenen Stellen. Wir sollten mbuf pkthdr.len stattdessen prüfen. ip6_input() wird bei der Eingabe eine Prüfung der Jumbo -Payload-Option durchführen und wir können danach mbuf pkthdr.len sicher benutzen.</p></li><li><p>Natürlich braucht der TCP-Kode an einigen Stellen eine sorgfältige Aktualisierung.</p></li></ul></div></div><div class=sect3><h4 id=_verhindern_von_schleifen_beim_verarbeiten_von_headern>8.1.1.8. Verhindern von Schleifen beim Verarbeiten von Headern<a class=anchor href=#_verhindern_von_schleifen_beim_verarbeiten_von_headern></a></h4><div class=paragraph><p>Die IPv6-Spezifikation erlaubt eine willkürliche Zahl von Erweiterungs-Headern, die in einem Paket platziert werden können. Wenn wir IPv6-Kode für die Paketverarbeitung auf die Art und Weise implementieren wie wir es beim BSD-IPv4-Kode geschehen ist, dann würde wegen einer lange Kette von Funktionsaufrufen der Kernel-Stack überlaufen. sys/netinet6-Kode ist behutsam entwickelt wurden, um einen Überlauf des Kernel-Stacks zu verhindern. Deswegen definiert der sys/netinet6-Kode seine eigene Protocol-Switch-Struktur "struct ip6protosw" (siehe auch <span class=filename>netinet6/ip6protosw.h</span>). Aus Gründen der Kompatibilität gibt es keine solche Aktualisierung im IPv4-Teil (sys/netinet), aber eine kleine Änderung ist zum pr_input()-Prototyp hinzugefügt worden. So ist "struct ipprotosw" ebenso definiert. Deswegen kann der Kernel-Stack sich aufblähen, wenn man ein IPsec-over-IPv4-Paket mit einer massiven Zahl von IPSec-Header empfängt. IPsec-over-IPv6 ist in Ordnung. (Natürlich muss für all diese zu verarbeitenden IPSec-Header jeder einzelne IPSec-Header jede IPSec-Prüfung durchlaufen. So wird es einem anonymen Angreifer unmöglich gemacht eine Attacke durchzuführen.)</p></div></div><div class=sect3><h4 id=icmpv6>8.1.1.9. ICMPv6<a class=anchor href=#icmpv6></a></h4><div class=paragraph><p>Nachdem RFC2463 veröffentlicht worden war, hat die IETF-ipngwg beschlossen ICMPv6-Fehler-Pakete gegen ICMPv6 umzuleiten, um einen ICMPv6-Sturm auf einem Netzwerkmedium zu unterbinden. Dies ist bereits im Kernel implementiert.</p></div></div><div class=sect3><h4 id=_anwendungen>8.1.1.10. Anwendungen<a class=anchor href=#_anwendungen></a></h4><div class=paragraph><p>Für Programmierung des Userland unterstützen wir das IPv6-Socket-API wie es in RFC2553, RFC2292 und in aufkommenden Internet-Konzepten beschrieben ist.</p></div><div class=paragraph><p>TCP/UDP über IPv6 ist verfügbar und ziemlich stabil. Man kann sich an <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp&amp;sektion=1&amp;format=html">ftp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, usw. erfreuen. Diese Anwendungen sind unabhängig vom Protokoll. Das liegt daran, weil diese Programme automatisch IPv4 oder IPv6 entsprechend des DNS auswählen.</p></div></div><div class=sect3><h4 id=_kernel_interna>8.1.1.11. Kernel Interna<a class=anchor href=#_kernel_interna></a></h4><div class=paragraph><p>Während ip_forward() ip_output() aufruft, ruft ip6_forward() direkt if_output() auf, da Router IPv6-Pakete nicht in Fragmente teilen dürfen.</p></div><div class=paragraph><p>ICMPv6 sollte das original Paket so lang wie möglich bis maximal 1280 halten. UDP6/IP6 port unreach, zum Beispiel, sollte alle Erweiterungs-Header und die unveränderten UDP6- und IP6-Header enthalten. Um das originale Paket zu erhalten, konvertieren alle IP6-Funktionen außer TCP niemals Network-Byte-Order in Host-Byte-Order.</p></div><div class=paragraph><p>tcp_input(), udp6_input() und icmp6_input() können nicht voraussetzen, dass der IP6-Header vor dem Transport-Header, der zum Extension-Header gehört, kommt. Deshalb wurde in6_cksum() implementiert, um Pakete, deren IP6-Header und Transport-Header nicht fortlaufend ist, zu behandeln. Weder TCP/IP6- noch UDP6/IP6-Header-Strukturen existieren, um eine Prüsumme zu bilden.</p></div><div class=paragraph><p>Um IP6-Header, Extension-Header und Transport-Headers leichter verarbeiten zu können, werden nun Netzwerktreiber benötigt, die Pakete in einem internen mbuf oder in einem oder mehreren externen mbuf speichern können. Ein typischer alter Treiber legt zwei interne mbuf für 96 - 204 Bytes an Daten an, wie auch immer wird ein solches Paket jetzt in einem externen mbuf gespeichert.</p></div><div class=paragraph><p><code>netstat -s -p ip6</code> ermittelt, ob der Treiber sich nach solchen Erfordernissen richtet, oder nicht. Im folgenden Beispiel verletzt "cce0" dies Erfordernisse (Für weitere Informationen, siehe Abschnitt 2.).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mbuf statistics:
                317 one mbuf
                two or more mbuf::
                        lo0 <span class=o>=</span> 8
			cce0 <span class=o>=</span> 10
                3282 one ext mbuf
                0 two or more ext mbuf</code></pre></div></div><div class=paragraph><p>Jede Eingabefunktion ruft IP6_EXTHDR_CHECK am Anfang auf, um zu prüfen, ob der Bereich zwischen IP6 und seinen Header durchgehend ist. IP6_EXTHDR_CHECK ruft m_pullup() nur dann auf, wenn mbuf das M_LOOP-Flag gestzt hat, weil das Paket von der Loopback-Schnittstelle kommt. m_pullup() wird niemals aufgerufen, wenn Pakete von physikalischen Netzwerkschnittstellen kommen.</p></div><div class=paragraph><p>IP- und IP6-Reassemble-Funktionen rufen niemals m_pullup() auf.</p></div></div><div class=sect3><h4 id=ipv6-wildcard-socket>8.1.1.12. IPv4-Mapped-Address und IPv6-Wildcard-Socket<a class=anchor href=#ipv6-wildcard-socket></a></h4><div class=paragraph><p>RFC2553 beschreibt IPv4-Mapped-Address (3.7) und die spezielle Verhaltensweise des IPv6-Wildcard-Bind-Socket (3.8). Die Spezifikation gestattet es:</p></div><div class=ulist><ul><li><p>IPv4-Verbindungen von AF_INET6-Wildcard-Bind-Socket zu erlauben.</p></li><li><p>IPv4-Pakete über AF_INET6-Socket zu transportieren, indem eine spezielle Form der Adresse wie ::ffff:10.1.1.1 benutzt wird.</p></li></ul></div><div class=paragraph><p>Aber die Spezifikation ist sehr kompliziert und spezifiziert nicht, wie der Socket-Layer sich verhalten soll. Darauf Bezug nehmend nennen wir hier ersteren "hörende Seite" und letzteren "beginnende Seite".</p></div><div class=paragraph><p>Man kann einen Wildcard-Bind auf demselben Port bei beiden Adressfamilien durchführen.</p></div><div class=paragraph><p>Die folgende Tabelle zeigt das Verhalten von FreeBSD 4.x.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Hörende Seite          Beginnende Seite
                <span class=o>(</span>AF_INET6-Wildcard-      <span class=o>(</span>Verbindung zu ::ffff:10.1.1.1<span class=o>)</span>
                Socket erreicht IPv4 Verb.<span class=o>)</span>
                <span class=nt>---</span>                     <span class=nt>---</span>
FreeBSD 4.x     Konfigurierbar            unterstützt
                Standard: erlaubt</code></pre></div></div><div class=paragraph><p>Die folgende Abschnitte zeigen mehr Details und wie man das Verhalten konfigurieren kann.</p></div><div class=paragraph><p>Kommentare auf der hörenden Seite:</p></div><div class=paragraph><p>Es sieht so aus, dass RFC2553 zu wenig zu den Punkten über Wildcard-Bind erläutert, speziell zum Punkt über Port-Space, Fehler-Modus und Beziehung zwischen AF_INET/INET6 wildcard bind. Es kann mehrere unterschiedliche Interpretationen zu diesem RFC geben, die sich nach diesen richten, aber sich unterschiedlich verhalten. Um eine portable Anwendung zu implementieren, sollte man deshalb nicht ein bestimmtes Verhalten des Kernels voraussetzen. Der Einsatz von <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> ist der sicherste Weg. Port number space und wildcard bind issues wurden Mitte Mai 1999 detailliert in der Ipv6imp-Mailing-Liste diskutiert und es sieht so aus, als ob es keinen konkreten Konsens gab (means, up to implementers). Vielleicht sollte man die Archive der Mailing-Liste prüfen.</p></div><div class=paragraph><p>Wenn eine Server-Anwendung IPv4- und IPv6-Verbindungen annehmen möchte, dann gibt es zwei Alternativen.</p></div><div class=paragraph><p>Eine benutzt AF_INET- und AF_INET6-Socket (man benötigt zwei Sockets). Benutze <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> mit gesetztem AI_PASSIVE-Bit in ai_flags, <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;format=html">bind(2)</a> für alle zurückgegebenen Adressen. Mit dem öffnen mehrerer Sockets kann man Verbindungen an dem Socket mit der richtigen Adressfamilie annehmen. IPv4-Verbindungen werden vom AF_INET-Socket und IPv6-Verbindungen vom AF_INET6-Socket angenommen.</p></div><div class=paragraph><p>Ein anderer Weg ist einen AF_INET6 wildcard bind-Socket zu verwenden. Man benutzt <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> mit AI_PASSIVE in ai_flags, mit AF_INET6 in ai_family, man setzt das erste Argument hostname auf NULL, <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;format=html">bind(2)</a> auf die zurückgegebene Adresse (es sollte eine unspezifizierte IPv6-Adresse sein). Man kann IPv4- und IPv6-Paket über diesen Socket annehmen.</p></div><div class=paragraph><p>Um nur IPv6-Datenverkehr portabel an AF_INET6 wildcard gebundenen Socket zu unterstützen, prüft man, sobald die Verbindung Zustande gekommen ist, immer die Peer-Adresse gegen den hörenden AF_INET6-Socket. Wenn die Adresse eine IPv4-Mapped-Adresse ist, dann sollte man die Verbindung zurückweisen. Man kann die Bedingung mit dem IN6_IS_ADDR_V4MAPPED()-Makro prüfen.</p></div><div class=paragraph><p>Um diesen Punkt leichter lösen zu können, gibt es für <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a> die System abhängige Option IPV6_BINDV6ONLY, die wie folgt benutzt wird.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	int on<span class=p>;</span>

	setsockopt<span class=o>(</span>s, IPPROTO_IPV6, IPV6_BINDV6ONLY,
		   <span class=o>(</span>char <span class=k>*</span><span class=o>)</span>&amp;on, sizeof <span class=o>(</span>on<span class=o>))</span> &lt; 0<span class=o>))</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Wenn der Aufruf erfolgreich ist, dann empfängt dieser Socket nur IPv6-Pakete.</p></div><div class=paragraph><p>Kommentare zur sendenden Seite:</p></div><div class=paragraph><p>Ratschlag an Anwendungsentwickler: um eine portable IPv6-Anwendung zu implementieren (die mit verschiedenen IPv6-Kerneln funktioniert), ist das Folgende der Schlüssel zum Erfolg wie wir glauben:</p></div><div class=ulist><ul><li><p>NIEMALS AF_INET oder AF_INET6 hart kodieren.</p></li><li><p>Benutze <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a> überall im System. Benutze niemals gethostby*(), getaddrby*(), inet_*() oder getipnodeby*() (Um bestehende Applikationen leicht IPv6 fähig zu machen, wird getipnodeby*() manchmal nützlich sein. Falss es aber möglich sein sollte, versuche den Kode neu zu schreiben und <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a> zu benutzen)</p></li><li><p>Wenn man sich an ein Ziel verbinden möchte, benutze <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> und versuche alle zurückgegebenen Ziele, wie <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> es macht.</p></li><li><p>Einige IPv6-Stacks sind mit fehlerhafter <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> verschickt worden. Man verschickt als letzte Möglichkeit eine minimal arbeitende Version der Anwendung.</p></li></ul></div><div class=paragraph><p>Wenn man einen AF_INET6-Socket für jeweils eine ausgehende IPv4- und IPv6-Verbingung benutzen möchte, dann muss man <a href="https://man.freebsd.org/cgi/man.cgi?query=getipnodebyname&amp;sektion=3&amp;format=html">getipnodebyname(3)</a> benutzen. Wenn man seine existierende Anwendung mit wenig Aufwand IPv6-fähig machen möchte, dann sollte dieser Versuch gewählt werden. Aber beachte bitte, dass dies eine temporäre Lösung ist, weil <a href="https://man.freebsd.org/cgi/man.cgi?query=getipnodebyname&amp;sektion=3&amp;format=html">getipnodebyname(3)</a> selber noch zu empfehlen ist, da es noch keine Adressbereiche verarbeitet. Für eine IPv6-NAmensauflösung ist <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> das bevorzugte API. Deshalb sollte man seine Anwendung so umschreiben, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> benutzt wird, wann man Zeit dazu hat.</p></div><div class=paragraph><p>Wenn man Anwendungen schreibt, die ausgehende Verbindungen herstellen, wird die Geschichte viel einfacher, wenn man AF_INET und AF_INET6 als total getrennte Adressfamilien behandelt. {set,get}sockopt funktioniert viel einfacher, DNS-Angelegenheiten werden einfacher gemacht. Wir empfehlen sich nicht auf IPv4-Mapped-Adressen zu verlassen.</p></div><div class=sect4><h5 id=_einheitlicher_tcp_und_inpcb_kode>8.1.1.12.1. Einheitlicher TCP-und INPCB-Kode<a class=anchor href=#_einheitlicher_tcp_und_inpcb_kode></a></h5><div class=paragraph><p>FreeBSD 4.x benutzt shared TCP-Kode zwischen IPv4 und IPv6 (von sys/netinet/tcp*) und separaten udp4/6-Kode. Es benutzt eine vereinheitlichte inpcb-Struktur.</p></div><div class=paragraph><p>Die Plattform kann für eine Unterstützung von IPv4-mapped-Adressen konfiguriert werden. Die Kernel-Konfiguration läßt sich wie folgt zusammenfassen:</p></div><div class=ulist><ul><li><p>By default, AF_INET6 socket will grab IPv4 connections in certain condition, and can initiate connection to IPv4 destination embedded in IPv4 mapped IPv6 address.</p></li><li><p>Man kann es wie unten beschrieben abschalten.</p><div class=paragraph><p><code>sysctl net.inet6.ip6.mapped_addr=0</code></p></div></li></ul></div><div class=sect5><h6 id=_hörende_seite>8.1.1.12.1.1. Hörende Seite<a class=anchor href=#_hörende_seite></a></h6><div class=paragraph><p>Jeder Socket kann für eine Unterstützung eines speziellen AF_INET6 wildcard bind (Standardmäßig eingeschaltet) konfiguriert werden. Man kann es auf Socket-Basis mit <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a> wie unten beschrieben abschalten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	int on<span class=p>;</span>

	setsockopt<span class=o>(</span>s, IPPROTO_IPV6, IPV6_BINDV6ONLY,
		   <span class=o>(</span>char <span class=k>*</span><span class=o>)</span>&amp;on, sizeof <span class=o>(</span>on<span class=o>))</span> &lt; 0<span class=o>))</span><span class=p>;</span></code></pre></div></div><div class=dlist><dl><dt class=hdlist1>Wildcard-AF_INET6-Socket schnappt sich die IPv4-Verbindung, wenn, und nur wenn folgende Bedingungen erfüllt sind</dt><dd><div class=ulist><ul><li><p>Es gibt keinen AF_INET-Socket, der zu einer IPv4-Verbindung passt</p></li><li><p>Der AF_INET6-Socket ist so konfiguriert, dass er IPv4-Datenverkehr akzeptiert, z.B. gibt getsockopt(IPV6_BINDV6ONLY) 0 zurück.</p></li></ul></div></dd></dl></div><div class=paragraph><p>Es gibt kein Problem mit der Öffnen/Schließen-Reihenfolge.</p></div></div><div class=sect5><h6 id=_initiating_side>8.1.1.12.1.2. initiating side<a class=anchor href=#_initiating_side></a></h6><div class=paragraph><p>FreeBSD 4.x unterstützt ausgehende Verbindungen zu IPv4 mapped Adressen (::ffff:10.1.1.1), falls der Knoten so konfiguriert ist, dass er IPv4 mapped Adressen unterstützt.</p></div></div></div></div><div class=sect3><h4 id=_sockaddr_storage>8.1.1.13. sockaddr_storage<a class=anchor href=#_sockaddr_storage></a></h4><div class=paragraph><p>Als RFC2553 kurz vor der Vollendung stand, gab es eine Diskussion, wie struct sockaddr_storage Mitglieder benannt werden sollten. Ein Vorschlag war "<em>" den Mitgliedern (wie "</em>ss_len") voranzustellen und es sollten sie nicht verändert werden. Der andere Vorschlag war, nichts voranzustellen (wie "ss_len") also mußten wir solche Mitglieder direkt verändern. Es gab keinen klaren Konsens.</p></div><div class=paragraph><p>Als Ergebnis definiert RFC2553 die Struktur sockaddr_storage wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	struct sockaddr_storage <span class=o>{</span>
		u_char	__ss_len<span class=p>;</span>	/<span class=k>*</span> address length <span class=k>*</span>/
		u_char	__ss_family<span class=p>;</span>	/<span class=k>*</span> address family <span class=k>*</span>/
		/<span class=k>*</span> and bunch of padding <span class=k>*</span>/
	<span class=o>}</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Im Gegensatz dazu definiert der XNET-Entwurf die Struktur wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	struct sockaddr_storage <span class=o>{</span>
		u_char	ss_len<span class=p>;</span>		/<span class=k>*</span> address length <span class=k>*</span>/
		u_char	ss_family<span class=p>;</span>	/<span class=k>*</span> address family <span class=k>*</span>/
		/<span class=k>*</span> and bunch of padding <span class=k>*</span>/
	<span class=o>}</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Im Dezember 1999 kam man überein, dass RFC2553bis letztere Definition (XNET) aufnehmen sollte.</p></div><div class=paragraph><p>Die aktuelle Implementierung ist konform zur XNET-Definition basierend auf der RFC2553bis Diskussion.</p></div><div class=paragraph><p>Wenn man mehrere IPv6-Implementierungen betrachtet, wird man beide Definitionen sehen. Für Userland-Programmierer ist der folgende Weg der meist portable um damit umzugehen:</p></div><div class="olist arabic"><ol class=arabic><li><p>Man versichert sich, dass ss_family und/oder ss_len für die Plattform verfügbar sind, indem man GNU autoconf verwendet,</p></li><li><p>Man benutzet -Dss_family=<em>ss_family um alle Vorkommen (einschließlich der Header-Files) zu </em>ss_family zu vereinheitlichen, oder</p></li><li><p>Man benutzt niemals __ss_family. Man führe einen Typecast nach sockaddr * durch und verwendet sa_family wie folgt:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	struct sockaddr_storage ss<span class=p>;</span>
	family <span class=o>=</span> <span class=o>((</span>struct sockaddr <span class=k>*</span><span class=o>)</span>&amp;ss<span class=o>)</span>-&gt;sa_family</code></pre></div></div></li></ol></div></div></div><div class=sect2><h3 id=_netzwerktreiber>8.1.2. Netzwerktreiber<a class=anchor href=#_netzwerktreiber></a></h3><div class=paragraph><p>Die beiden folgenden Dinge müssen zwingend von Standardtreibern unterstützt werden:</p></div><div class="olist arabic"><ol class=arabic><li><p>Mbuf-Clustering-Erfordernis. In diesem stabilen Release haben wir für alle Betriebssystem MINCLSIZE in MHLEN+1 geändert, damit sich alle Treiber wie erwartet verhalten.</p></li><li><p>Multicast. Falls <a href="https://man.freebsd.org/cgi/man.cgi?query=ifmcstat&amp;sektion=8&amp;format=html">ifmcstat(8)</a> keine Multicast-Gruppe für die Schnittstelle liefert, dann muss diese Schnittstelle überarbeitet werden.</p></li></ol></div><div class=paragraph><p>Falls keiner der Treiber die Erfordernisse erfüllt, dann können die Treiber nicht für IPv6/IPSec-Kommunikation verwendet werden. Falls man ein Problem beim Einsatz von IPv6/IPSec mit seiner Karte hat, dann melde es bitte bei <a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>FreeBSD problem reports</a>.</p></div><div class=paragraph><p>(Beachte: In der Vergangenheit haben wir gefordert, dass alle PCMCIA-Treiber einen Aufruf nach in6_ifattach() haben. Inzwischen haben wir keine solche Forderung mehr)</p></div></div><div class=sect2><h3 id=_translator>8.1.3. Translator<a class=anchor href=#_translator></a></h3><div class=paragraph><p>Wir kategorisieren einen IPv4/IPv6-Translator in 4 Typen:</p></div><div class=ulist><ul><li><p><em>Translator A</em> --- Er wird im frühen Stadium des Übergangs benutzt um es zu ermöglichen, dass eine Verbindung von einem IPv6-Host auf einer IPv6-Insel zu einem IPv4-Host im IPv4-Ozean hergestellt wird.</p></li><li><p><em>Translator B</em> --- Er wird im frühen Stadium des Übergangs benutzt um es zu ermöglichen, dass eine Verbindung von einem IPv4-Host im IPv4-Ozean zu einem IPv6-Host auf einer IPv6-Insel hergestellt wird.</p></li><li><p><em>Translator C</em> --- Er wird im frühen Stadium des Übergangs benutzt um es zu ermöglichen, dass eine Verbindung von einem IPv4-Host auf einer IPv4-Insel zu einem IPv6-Host im IPv6-Ozean hergestellt wird.</p></li><li><p><em>Translator D</em> --- Er wird im frühen Stadium des Übergangs benutzt um es zu ermöglichen, dass eine Verbindung von einem IPv6-Host im IPv6-Ozean zu einem IPv4-Host auf einer IPv4-Insel hergestellt wird.</p></li></ul></div><div class=paragraph><p>Ein TCP-Relay-Translator der Kategorie A wird unterstützt. Er wird "FAITH" genannt. Wir stellen ebenso einen IP-Header-Translator der Kataegorie A zur Verfügung (Letzterer ist noch nicht in FreeBSD 4.x übernommen).</p></div><div class=sect3><h4 id=_faith_tcp_relay_translator>8.1.3.1. FAITH TCP-Relay-Translator<a class=anchor href=#_faith_tcp_relay_translator></a></h4><div class=paragraph><p>Das FAITH-System benutzt mit Hilfe des Kernels den <a href="https://man.freebsd.org/cgi/man.cgi?query=faithd&amp;sektion=8&amp;format=html">faithd(8)</a> genannten TCP-Relay-Daemon. FAITH wird einen IPv6-Adress-Präfix reservieren und eine TCP-Verbindungen an diesen Präfix zum IPv4-Ziel weiterleiten.</p></div><div class=dlist><dl><dt class=hdlist1>Wenn beispielsweise der IPv6-Präfix 2001:0DB8:0200:ffff</dt><dd><p>ist und das IPv6-Ziel für TCP-Verbindungen 2001:0DB8:0200:ffff::163.221.202.12 ist, dann wird die Verbindung an das IPv4-Ziel 163.221.202.12 weitergeleitet.</p></dd></dl></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	IPv4-Ziel-Knoten <span class=o>(</span>163.221.202.12<span class=o>)</span>
	  ^
	  | IPv4 tcp toward 163.221.202.12
	FAITH-relay dual stack node
	  ^
	  | IPv6 TCP toward 2001:0DB8:0200:ffff::163.221.202.12
	<span class=nb>source </span>IPv6 node</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=faithd&amp;sektion=8&amp;format=html">faithd(8)</a> muss auf FAITH-relay dual stack node aufgerufen werden.</p></div><div class=paragraph><p>Für weitere Details siehe <span class=filename>src/usr.sbin/faithd/README</span></p></div></div></div><div class=sect2><h3 id=ipsec-implementation>8.1.4. IPsec<a class=anchor href=#ipsec-implementation></a></h3><div class=paragraph><p>IPsec besteht hauptsächlich aus drei Komponenten.</p></div><div class="olist arabic"><ol class=arabic><li><p>Policy Management</p></li><li><p>Key Management</p></li><li><p>AH und ESP Behandlung</p></li></ol></div><div class=sect3><h4 id=_regel_management>8.1.4.1. Regel Management<a class=anchor href=#_regel_management></a></h4><div class=paragraph><p>Im Kernel ist experimenteller Kode für Regel-Management implementiert. Es gibt zwei Wege eine Sicherheitsregel zu handhaben. Einer ist eine Regel für jeden Socket mithilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a> zu konfigurieren. Für diesen Fall ist die Konfiguration der Regel in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec_set_policy&amp;sektion=3&amp;format=html">ipsec_set_policy(3)</a> beschrieben. Der andere Weg ist eine auf einem Kernel-Packet-Filter basierende Regel mithilfe der PF_KEY-Schnittstelle mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> zu konfigurieren.</p></div><div class=paragraph><p>Der Regeleintrag mit seinen Indices wird nicht sortiert, so dass es sehr wichtig ist, wann ein Eintrag hinzugefügt wird.</p></div></div><div class=sect3><h4 id=_key_management>8.1.4.2. Key Management<a class=anchor href=#_key_management></a></h4><div class=paragraph><p>Der in dieser Bibliothek (sys/netkey) implementierte Kode für das key management ist eine Eigenentwicklung der PFKEYv2-Implementierung. Er ist konform zu RFC2367.</p></div><div class=paragraph><p>Die Eigenentwicklung des IKE-Daemons "racoon" ist in der Bibliothek (kame/kame/racoon) implementiert. Grundsätzlich muss man racoon als Dämonprozess laufen lassen, dann setzt man eine Regel auf, die Schlüssel erwartet (ähnlich wie <code>ping -P 'out ipsec esp/transport//use'</code>). Der Kernel wird den racoon-Dämon wegen des notwendigen Austauschs der Schlüssel kontaktieren.</p></div></div><div class=sect3><h4 id=_ah_und_esp_handhabung>8.1.4.3. AH- und ESP-Handhabung<a class=anchor href=#_ah_und_esp_handhabung></a></h4><div class=paragraph><p>Das IPsec-Modul ist als "hook" in die Standard-IPv4/IPv6-Verarbeitung implementiert. Sobald ein Paket gesendet wird, prüft ip{,6_output(), ob eine ESP/AH-Verarbeitung notwendig ist. Es findet eine Überprüfung statt, ob eine passende SPD (Security Policy Database) gefunden wurde. Wenn ESP/AH benötigt wird, dann wird {esp,ah}{4,6}_output() aufgerufen und mbuf wird folglich aktualisiert. Wenn ein Paket empfangen wird, dann wird {esp,ah}4_input() basierend auf der Protokollnummer aufgerufen, z.B. (*inetsw[proto])(). {esp,ah}4_input() entschlüsselt/prüft die Authentizität des Pakets und entfernt den daisy-chained-Header und das Padding des ESP/AH. Es ist sicherer den ESP/AH-Header beim Empfang zu entfernen, weil man das empfangene Paket niemals so wie es ist benutzt.</p></div><div class=paragraph><p>Mit der Verwendung von ESP/AH wird die effektive TCP4/6-Datensegmentgröße durch weitere von ESP/AH eingefügte Daisy-chained-Headers beeinflußt. Unser Kode berücksichtigt dies.</p></div><div class=paragraph><p>Grundlegende Crypto-Funktionen sind im Verzeichnis "sys/crypto" zu finden. ESP/AH-Umformungen sind zusammen mit den Wrapper-Funktionen in {esp,ah}_core.c gelistet. Wenn man einige Algorithmen hinzufügen möchte, dann fügt man in {esp,ah}_core.c eine Wrapper-Funktion hinzu und trägt seinen Crypto-Algorithmus in sys/crypto ein.</p></div><div class=paragraph><p>Der Tunnel-Modus wird in diesem Release teilweise mit den folgenden Restriktionen unterstützt:</p></div><div class=ulist><ul><li><p>Der IPsec-Tunnel ist nicht mit der generischen Tunnelschnittstelle kombiniert. Man muss sehr vorsichtig sein, weil man sonst eine Endlosschleife zwischen ip_output() und tunnelifp→if_output() aufbaut. Die Meinungen gehen auseinander, ob es besser ist dies zu vereinheitlichen, oder nicht.</p></li><li><p>Die Betrachtung von MTU und des "Don’t Fragment"-Bits (IPv4) müssen mehr geprüft werden, aber grundsätzlichen arbeiten sie gut.</p></li><li><p>Das Authentifizierungsmodel für einen AH-Tunnel muss überarbeitet werden. Man muss eventuell die "policy management engine" überarbeiten.</p></li></ul></div></div><div class=sect3><h4 id=_konformität_zu_rfcs_und_ids>8.1.4.4. Konformität zu RFCs und IDs<a class=anchor href=#_konformität_zu_rfcs_und_ids></a></h4><div class=paragraph><p>Der IPsec-Kode im Kernel ist konform (oder versucht konform zu sein) zu den folgenden Standards:</p></div><div class=paragraph><p>Die "alte IPsec"-Spezifikation, die in <span class=filename>rfc182[5-9].txt</span> dokumentiert ist</p></div><div class=paragraph><p>Die "neue IPsec"-Spezifikation, die <span class=filename>rfc240[1-6].txt</span>, <span class=filename>rfc241[01].txt</span>, <span class=filename>rfc2451.txt</span> und <span class=filename>draft-mcdonald-simple-ipsec-api-01.txt</span> (Der Entwurf ist erloschen, aber man kann ihn sich von <a href=ftp://ftp.kame.net/pub/internet-drafts/>ftp://ftp.kame.net/pub/internet -drafts/</a> holen) dokumentiert ist (Beachte: Die IKE-Spezifikationen <span class=filename>rfc241[7-9].txt</span> sind im Userland als "racoon"-IKE-Daemon implementiert).</p></div><div class=paragraph><p>Aktuell werden folgende Algorithmen unterstützt:</p></div><div class=ulist><ul><li><p>altes IPsec-AH</p><div class=ulist><ul><li><p>null crypto Prüfsumme (Kein Dokument, nur für Debug-Zwecke)</p></li><li><p>keyed MD5 mit 128bit crypto Prüfsumme (<span class=filename>rfc1828.txt</span>)</p></li><li><p>keyed SHA1 mit 128bit crypto Prüfsumme (kein Document)</p></li><li><p>HMAC MD5 mit 128bit crypto Prüfsumme (<span class=filename>rfc2085.txt</span>)</p></li><li><p>HMAC SHA1 mit 128bit crypto Prüfsumme (kein Dokument)</p></li></ul></div></li><li><p>altes IPsec-ESP</p><div class=ulist><ul><li><p>null encryption (kein Dokument, ähnlich zu <span class=filename>rfc2410.txt</span>)</p></li><li><p>DES-CBC-Modus (<span class=filename>rfc1829.txt</span>)</p></li></ul></div></li><li><p>neues IPsec-AH</p><div class=ulist><ul><li><p>null crypto Prüfsumme (kein Dokument, nur für Debug-Zwecke)</p></li><li><p>keyed MD5 mit 96bit crypto Prüfsumme (kein Dokument)</p></li><li><p>keyed SHA1 mit 96bit crypto Prüfsumme (kein Dokument)</p></li><li><p>HMAC MD5 mit 96bit crypto Prüfsumme (<span class=filename>rfc2403.txt</span>)</p></li><li><p>HMAC SHA1 mit 96bit crypto Prüfsumme (<span class=filename>rfc2404.txt</span>)</p></li></ul></div></li><li><p>neues IPsec-ESP</p><div class=ulist><ul><li><p>null encryption (<span class=filename>rfc2410.txt</span>)</p></li><li><p>DES-CBC mit abgeleiteter IV (<span class=filename>draft-ietf-ipsec-ciph-des-derived-01.txt</span>, Entwurf abgelaufen)</p></li><li><p>DES-CBC mit expliziter IV (<span class=filename>rfc2405.txt</span>)</p></li><li><p>3DES-CBC mit expliziter IV (<span class=filename>rfc2451.txt</span>)</p></li><li><p>BLOWFISH CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>CAST128 CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>RC5 CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>Jeder Algorithmus kann kombiniert werden mit:</p><div class=ulist><ul><li><p>ESP-Beglaubigung mit HMAC-MD5(96bit)</p></li><li><p>ESP-Beglaubigung mit HMAC-SHA1(96bit)</p></li></ul></div></li></ul></div></li></ul></div><div class=paragraph><p>Die folgenden Algorithmen werden NICHT unterstützt:</p></div><div class=ulist><ul><li><p>altes IPsec-AH</p><div class=ulist><ul><li><p>HMAC MD5 mit 128bit crypto Prüfsumme + 64bit replay prevention (<span class=filename>rfc2085.txt</span>)</p></li><li><p>keyed SHA1 mit 160bit crypto Prüfsumme + 32bit padding (<span class=filename>rfc1852.txt</span>)</p></li></ul></div></li></ul></div><div class=paragraph><p>IPsec (im Kernel) und IKE (im Userland als "racoon") wurden bei unterschiedlichen Interoperabilitätstests geprüft und es ist bekannt, dass es mit vielen anderen Implementierungen gut zusammenarbeitet. Außerdem wurde die IPsec-Implementierung sowie die breite Abdeckung mit IPsec-Crypto-Algorithmen, die in den RFCs dokumentiert sind, geprüft (es werden nur Algorithmen ohne intellektuelle Besitzansprüche behandelt).</p></div></div><div class=sect3><h4 id=ipsec-ecn>8.1.4.5. ECN-Betrachtung von IPsec-Tunneln<a class=anchor href=#ipsec-ecn></a></h4><div class=paragraph><p>ECN-freundliche IPsec-Tunnel werden unterstützt wie es in <span class=filename>draft-ipsec-ecn-00.txt</span> beschrieben ist.</p></div><div class=paragraph><p>Normale IPsec-Tunnel sind in RFC2401 beschrieben. Für eine Kapselung wird das IPv4-TOS-Feld (oder das IPv6-Traffic-Class-Feld) vom inneren in den äußeren IP-Header kopiert. Für eine Entkapselung wird der ässere IP-Header einfach verworfen. Die Entkapselungsregel ist nicht mit ECN kompatibel, sobald das ECN-Bit im äußeren IP-TOS/Traffic-Class-Feld verloren geht.</p></div><div class=paragraph><p>Um einen IPsec-Tunnel ECN-freundlich zu machen, sollte man die Kapselungs- und Entkapselungsprozeduren modifizieren. Dies ist in <a href=http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt>http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt</a>, Kapitel 3, beschrieben.</p></div><div class=paragraph><p>Die IPsec-Tunnel-Implementierung kann drei Zustände annehmen, indem man net.inet.ipsec.ecn (oder net.inet6.ipsec6.ecn) auf diese Werte setzt:</p></div><div class=ulist><ul><li><p>RFC2401: Keine Betrachtung von ECN (Sysctl-Wert -1)</p></li><li><p>ECN verboten (Sysctl-Wert 0)</p></li><li><p>ECN erlaubt (Sysctl-Wert 1)</p></li></ul></div><div class=paragraph><p>Beachte, dass dieses Verhalten per-node konfigurierbar ist und nicht per-SA (draft-ipsec-ecn-00 möchte per-SA Konfiguration).</p></div><div class=paragraph><p>Das Verhalten ist wie folgt zusammengefaßt (man beachte auch den Quelltext für weitere Details):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                encapsulate                     decapsulate
                <span class=nt>---</span>                             <span class=nt>---</span>
RFC2401         kopiere alle TOS-Bits               lösche TOS-Bits im äußeren
                von innen nach außen.            <span class=o>(</span>benutze innere TOS-Bits so wie sie sind<span class=o>)</span>

ECN verboten   kopiere TOS-Bits außer für ECN    lösche TOS-Bits im äußeren
                <span class=o>(</span>maskiert mit 0xfc<span class=o>)</span> von innen   <span class=o>(</span>benutze innere TOS-Bits so wie sie sind<span class=o>)</span>
                nach außen.  Setze ECN-Bits auf 0.

ECN erlaubt     kopiere TOS-Bits außer für ECN    benutze innere TOS-Bits mit einigen Änderungen.
                CE <span class=o>(</span>maskiert mit 0xfe<span class=o>)</span> von      Wenn das äußere ECN-CE-Bit 1 ist,
                innen nach außen.                 setze das ECN-CE-Bit im
                Setze ECN-CE-Bit auf 0.            Inneren.</code></pre></div></div><div class=paragraph><p>Allgemeine Strategie zur Konfiguration:</p></div><div class=ulist><ul><li><p>Wenn beide IPsec-Tunnel-Endpunkte ein ECN-freundliches Verhalten beherrschen, dann sollte man besser beide Endpunkte auf "ECN allowed" (Sysctl-Wert 1) setzen.</p></li><li><p>Wenn das andere Ende das TOS-Bit sehr strikt handhabt, dann benutzt man "RFC2401" (Sysctl-Wert -1).</p></li><li><p>in den anderen Fällen benutzt man "ECN verboten" (Sysctl-Wert 0).</p></li></ul></div><div class=paragraph><p>Der Standard ist "ECN verboten" (Sysctl-Wert 0).</p></div><div class=paragraph><p>Für weitere Informationen siehe auch:</p></div><div class=paragraph><p><a href=http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt>http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt</a>, RFC2481 (Explicit Congestion Notification), src/sys/netinet6/{ah,esp}_input.c</p></div><div class=paragraph><p>(Dank gebührt Kenjiro Cho <a href=mailto:kjc@csl.sony.co.jp>kjc@csl.sony.co.jp</a> für seine detailliert Analyse)</p></div></div><div class=sect3><h4 id=_interoperabilität>8.1.4.6. Interoperabilität<a class=anchor href=#_interoperabilität></a></h4><div class=paragraph><p>Hier sind einige Plattformen angegeben, die in der Vergangenheit die IPsec/IKE-Interoperabilität mit dem KAME-Kode getestet haben. Beachte, dass beide Enden vielleicht ihre Implementierung verändert haben, deshalb sollte man folgende Liste nur für Referenzzwecke benutzen.</p></div><div class=paragraph><p>Altiga, Ashley-laurent (vpcom.com), Data Fellows (F-Secure), Ericsson ACC, FreeS/WAN, HITACHI, IBM AIX®, IIJ, Intel, Microsoft® Windows NT®, NIST (linux IPsec + plutoplus), Netscreen, OpenBSD, RedCreek, Routerware, SSH, Secure Computing, Soliton, Toshiba, VPNet, Yamaha RT100i</p></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9. März 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/de/books/developers-handbook/sockets class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/de/books/developers-handbook/partiii class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#ipv6-implementation>8.1. IPv6/IPsec-Implementierung</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/developers-handbook/developers-handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/de/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>