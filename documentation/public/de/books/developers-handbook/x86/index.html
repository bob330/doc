<!doctype html><html class=theme-light lang=de><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/de/books/developers-handbook/x86/><title>Kapitel 11. x86-Assembler-Programmierung | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Kapitel 11. x86-Assembler-Programmierung"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="https://docs.freebsd.org/de/books/developers-handbook/x86/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/de\/books\/developers-handbook\/x86\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=https://docs.freebsd.org/de/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/de/books>Books</a></li><li><a href=https://docs.freebsd.org/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-b1b18a35567534d1699b4dd27b58b2ff class=toggle>
<label for=chapter-b1b18a35567534d1699b4dd27b58b2ff><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/parti/>Teil I. Grundlagen</a></li><li><input type=checkbox id=chapter-3af9d0cd3607fbe44d37e3a13957c40f class=toggle>
<label class="icon cursor" for=chapter-3af9d0cd3607fbe44d37e3a13957c40f><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/introduction/>Kapitel 1. Einführung</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/introduction/#introduction-devel>1.1. Unter FreeBSD entwickeln</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/introduction/#introduction-bsdvision>1.2. Die Vision von BSD</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/introduction/#introduction-archguide>1.3. Grundlegende Richtlinien</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/introduction/#introduction-layout>1.4. Der Aufbau von <span class=filename>/usr/src</span></a></li></ul></li><li><input type=checkbox id=chapter-15219234c513f9a79d9cb2d3bcf73d13 class=toggle>
<label class="icon cursor" for=chapter-15219234c513f9a79d9cb2d3bcf73d13><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/>Kapitel 2. Werkzeuge zur Programmierung</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-synopsis>2.1. Überblick</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-intro>2.2. Zusammenfassung</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-programming>2.3. Einführung in die Programmierung</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-compiling>2.4. Kompilieren mit dem <code>cc</code></a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-make>2.5. Make</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#debugging>2.6. Debuggen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#emacs>2.7. Emacs als Entwicklungsumgebung verwenden</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/tools/#tools-reading>2.8. Weiterführende Literatur</a></li></ul></li><li><input type=checkbox id=chapter-7319f5d899d5be33daaf1f2d5f180558 class=toggle>
<label class="icon cursor" for=chapter-7319f5d899d5be33daaf1f2d5f180558><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/>Kapitel 3. Sicheres Programmieren</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-synopsis>3.1. Zusammenfassung</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-philosophy>3.2. Methoden des sicheren Entwurfs</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-bufferov>3.3. Puffer-Überläufe</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-setuid>3.4. SetUID-Themen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-chroot>3.5. Die Umgebung ihrer Programme einschränken</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-trust>3.6. Vertrauen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/secure/#secure-race-conditions>3.7. Race-Conditions</a></li></ul></li><li><input type=checkbox id=chapter-0240ccaf7010beed911378cfab7bd8fc class=toggle>
<label class="icon cursor" for=chapter-0240ccaf7010beed911378cfab7bd8fc><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/l10n/>Kapitel 4. Lokalisierung und Internationalisierung - L10N und I18N</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/l10n/#l10n-programming>4.1. I18N-konforme Anwendungen programmieren</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/l10n/#posix-nls>4.2. Lokalisierte Nachrichten mit POSIX.1 Native Language Support (NLS)</a></li></ul></li><li><input type=checkbox id=chapter-c3107aaf64e60e1ee09bc33fc9fd641a class=toggle>
<label class="icon cursor" for=chapter-c3107aaf64e60e1ee09bc33fc9fd641a><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/>Kapitel 5. Vorgaben und Richtlinien für das Quelltextverzeichnis</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/#policies-style>5.1. Stil-Richtlinien</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/#policies-maintainer>5.2. <code>MAINTAINER</code> eines Makefiles</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/#policies-contributed>5.3. Beigesteuerte Software</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/#policies-encumbered>5.4. Belastende Dateien</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/policies/#policies-shlib>5.5. Shared-Libraries</a></li></ul></li><li><input type=checkbox id=chapter-c7b4fd5a7f8f049234fe3bc225acef44 class=toggle>
<label class="icon cursor" for=chapter-c7b4fd5a7f8f049234fe3bc225acef44><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/testing/>Kapitel 6. Regressions- und Performance-Tests</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/testing/#testing-micro-benchmark>6.1. Mikro-Benchmark-Checkliste</a></li></ul></li><li><input type=checkbox id=chapter-1f9b02a65f2bc5d4015a050d706fa837 class=toggle>
<label for=chapter-1f9b02a65f2bc5d4015a050d706fa837><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/partii/>Teil II. Interprozess-Kommunikation</a></li><li><input type=checkbox id=chapter-5e03777f678dd5731a581d7956d19c13 class=toggle>
<label for=chapter-5e03777f678dd5731a581d7956d19c13><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/sockets/>Kapitel 7. Sockets</a></li><li><input type=checkbox id=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3 class=toggle>
<label class="icon cursor" for=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/ipv6/>Kapitel 8. IPv6 Internals</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/ipv6/#ipv6-implementation>8.1. IPv6/IPsec-Implementierung</a></li></ul></li><li><input type=checkbox id=chapter-c9a07b517dc2e43d169c8e013e23cfc1 class=toggle>
<label for=chapter-c9a07b517dc2e43d169c8e013e23cfc1><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/partiii/>Teil III. Kernel</a></li><li><input type=checkbox id=chapter-db22f8e5e5e9496dbc711815e2e05f36 class=toggle>
<label class="icon cursor" for=chapter-db22f8e5e5e9496dbc711815e2e05f36><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/kernelbuild/>Kapitel 9. Einen FreeBSD-Kernel bauen und installieren</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kernelbuild/#kernelbuild-traditional>9.1. Einen Kernel auf die "traditionelle" Art und Weise bauen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kernelbuild/#kernelbuild-new>9.2. Einen Kernel auf die "neue" Art und Weise bauen</a></li></ul></li><li><input type=checkbox id=chapter-3036877c53948cfb76174f2776bbdf64 class=toggle>
<label class="icon cursor" for=chapter-3036877c53948cfb76174f2776bbdf64><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/>Kapitel 10. Kernel-Fehlersuche</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-obtain>10.1. Besorgen eines Speicherauszugs nach einem Kernel-Absturz (Kernel-Crash-Dump)</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-gdb>10.2. Fehlersuche in einem Speicherauszug nach einem Kernel-Absturz mit <code>kgdb</code></a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-ddd>10.3. Fehlersuche in einem Speicherauszug nach einem Absturz mit DDD</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-online-ddb>10.4. Online-Kernel-Fehlersuche mit DDB</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-online-gdb>10.5. Online-Kernel-Fehlersuche mit GDB auf einem entfernten System</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-console>10.6. Fehlersuche bei einem Konsolen-Treiber</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-deadlocks>10.7. Fehlersuche bei Deadlocks</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/kerneldebug/#kerneldebug-options>10.8. Glossar der Kernel-Optionen zur Fehlersuche</a></li></ul></li><li><input type=checkbox id=chapter-86707094ce48d6e89e5f45569c084cea class=toggle>
<label for=chapter-86707094ce48d6e89e5f45569c084cea><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/partiv/>Teil IV. Architekturen</a></li><li><input type=checkbox id=chapter-43b1e1e6d2a94eb8b161876bc22ce644 class=toggle checked>
<label class="icon cursor" for=chapter-43b1e1e6d2a94eb8b161876bc22ce644><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/>Kapitel 11. x86-Assembler-Programmierung</a><ul><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-intro>11.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-the-tools>11.2. Die Werkzeuge</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-system-calls>11.3. Systemaufrufe</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-return-values>11.4. Rückgabewerte</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-portable-code>11.5. Portablen Code erzeugen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-first-program>11.6. Unser erstes Programm</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-unix-filters>11.7. UNIX®-Filter schreiben</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-buffered-io>11.8. Gepufferte Eingabe und Ausgabe</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-command-line>11.9. Kommandozeilenparameter</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-environment>11.10. Die UNIX®-Umgebung</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-files>11.11. Arbeiten mit Dateien</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-one-pointed-mind>11.12. One-Pointed Mind</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-fpu>11.13. Die FPU verwenden</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-caveats>11.14. Vorsichtsmassnahmen</a></li><li><a href=https://docs.freebsd.org/de/books/developers-handbook/x86/#x86-acknowledgements>11.15. Danksagungen</a></li></ul></li><li><input type=checkbox id=chapter-c49dfe630861d471fb2f58f5b554ed84 class=toggle>
<label for=chapter-c49dfe630861d471fb2f58f5b554ed84><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/partv/>Teil V. Anhang</a></li><li><input type=checkbox id=chapter-ac9541a3f38001d13964c1b0b324bb83 class=toggle>
<label for=chapter-ac9541a3f38001d13964c1b0b324bb83><a role=button></a></label><a href=https://docs.freebsd.org/de/books/developers-handbook/bibliography/>Literaturverzeichnis</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Kapitel 11. x86-Assembler-Programmierung</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#x86-intro>11.1. Synopsis</a></li><li><a href=#x86-the-tools>11.2. Die Werkzeuge</a></li><li><a href=#x86-system-calls>11.3. Systemaufrufe</a></li><li><a href=#x86-return-values>11.4. Rückgabewerte</a></li><li><a href=#x86-portable-code>11.5. Portablen Code erzeugen</a></li><li><a href=#x86-first-program>11.6. Unser erstes Programm</a></li><li><a href=#x86-unix-filters>11.7. UNIX®-Filter schreiben</a></li><li><a href=#x86-buffered-io>11.8. Gepufferte Eingabe und Ausgabe</a></li><li><a href=#x86-command-line>11.9. Kommandozeilenparameter</a></li><li><a href=#x86-environment>11.10. Die UNIX®-Umgebung</a></li><li><a href=#x86-files>11.11. Arbeiten mit Dateien</a></li><li><a href=#x86-one-pointed-mind>11.12. One-Pointed Mind</a></li><li><a href=#x86-fpu>11.13. Die FPU verwenden</a></li><li><a href=#x86-caveats>11.14. Vorsichtsmassnahmen</a></li><li><a href=#x86-acknowledgements>11.15. Danksagungen</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class=paragraph><p><em>Dieses Kapitel wurde geschrieben von G. Adam Stanislav &lt;<a href=mailto:adam@redprince.net>adam@redprince.net</a>>.</em></p></div></div></div><div class=sect1><h2 id=x86-intro>11.1. Synopsis<a class=anchor href=#x86-intro></a></h2><div class=sectionbody><div class=paragraph><p>Assembler-Programmierung unter UNIX® ist höchst undokumentiert. Es wird allgemein angenommen, dass niemand sie jemals benutzen will, da UNIX®-Systeme auf verschiedenen Mikroprozessoren laufen, und man deshalb aus Gründen der Portabilität alles in C schreiben sollte.</p></div><div class=paragraph><p>In Wirklichkeit ist die Portabilität von C größtenteils ein Mythos. Auch C-Programme müssen angepasst werden, wenn man sie von einem UNIX® auf ein anderes portiert, egal auf welchem Prozessor jedes davon läuft. Typischerweise ist ein solches Programm voller Bedingungen, die unterscheiden für welches System es kompiliert wird.</p></div><div class=paragraph><p>Sogar wenn wir glauben, dass jede UNIX®-Software in C, oder einer anderen High-Level-Sprache geschrieben werden sollte, brauchen wir dennoch Assembler-Programmierer: Wer sonst sollte den Abschnitt der C-Bibliothek schreiben, die auf den Kernel zugreift?</p></div><div class=paragraph><p>In diesem Kapitel möchte ich versuchen zu zeigen, wie man Assembler-Sprache verwenden kann, um UNIX®-Programme, besonders unter FreeBSD, zu schreiben.</p></div><div class=paragraph><p>Dieses Kapitel erklärt nicht die Grundlagen der Assembler-Sprache. Zu diesem Thema gibt es bereits genug Quellen (einen vollständigen Online-Kurs finden Sie in Randall Hydes <a href=http://webster.cs.ucr.edu/>Art of Assembly Language</a>; oder falls Sie ein gedrucktes Buch bevorzugen, können Sie einen Blick auf Jeff Duntemanns <a href="http://www.int80h.org/cgi-bin/isbn?isbn=0471375233">Assembly Language Step-by-Step</a> werfen). Jedenfalls sollte jeder Assembler-Programmierer nach diesem Kapitel schnell und effizient Programme für FreeBSD schreiben können.</p></div><div class=paragraph><p>Copyright ® 2000-2001 G. Adam Stanislav. All rights reserved.</p></div></div></div><div class=sect1><h2 id=x86-the-tools>11.2. Die Werkzeuge<a class=anchor href=#x86-the-tools></a></h2><div class=sectionbody><div class=sect2><h3 id=x86-the-assembler>11.2.1. Der Assembler<a class=anchor href=#x86-the-assembler></a></h3><div class=paragraph><p>Das wichtigste Werkzeug der Assembler-Programmierung ist der Assembler, diese Software übersetzt Assembler-Sprache in Maschinencode.</p></div><div class=paragraph><p>Für FreeBSD stehen zwei verschiedene Assembler zur Verfügung. Der erste ist <a href="https://man.freebsd.org/cgi/man.cgi?query=as&amp;sektion=1&amp;format=html">as(1)</a>, der die traditionelle UNIX®-Assembler-Sprache verwendet. Dieser ist Teil des Systems.</p></div><div class=paragraph><p>Der andere ist /usr/ports/devel/nasm. Dieser benutzt die Intel-Syntax und sein Vorteil ist, dass es Code fü viele Vetriebssysteme übersetzen kann. Er muss gesondert installiert werden, aber ist völlig frei.</p></div><div class=paragraph><p>In diesem Kapitel wird die nasm-Syntax verwendet. Einerseits weil es die meisten Assembler-Programmierer, die von anderen Systemen zu FreeBSD kommen, leichter verstehen werden. Und offen gesagt, weil es das ist, was ich gewohnt bin.</p></div></div><div class=sect2><h3 id=x86-the-linker>11.2.2. Der Linker<a class=anchor href=#x86-the-linker></a></h3><div class=paragraph><p>Die Ausgabe des Assemblers muss, genau wie der Code jedes Compilers, gebunden werden, um eine ausführbare Datei zu bilden.</p></div><div class=paragraph><p>Der Linker <a href="https://man.freebsd.org/cgi/man.cgi?query=ld&amp;sektion=1&amp;format=html">ld(1)</a> ist der Standard und Teil von FreeBSD. Er funktioniert mit dem Code beider Assembler.</p></div></div></div></div><div class=sect1><h2 id=x86-system-calls>11.3. Systemaufrufe<a class=anchor href=#x86-system-calls></a></h2><div class=sectionbody><div class=sect2><h3 id=x86-default-calling-convention>11.3.1. Standard-Aufrufkonvention<a class=anchor href=#x86-default-calling-convention></a></h3><div class=paragraph><p>Standardmäßig benutzt der FreeBSD-Kernel die C-Aufrufkonvention. Weiterhin wird, obwohl auf den Kernel durch <code>int 80h</code> zugegriffen wird, angenommen, dass das Programm eine Funktion aufruft, die <code>int 80h</code> verwendet, anstatt <code>int 80h</code> direkt aufzurufen.</p></div><div class=paragraph><p>Diese Konvention ist sehr praktisch und der Microsoft®-Konvention von MS-DOS® überlegen. Warum? Weil es die UNIX®-Konvention jedem Programm, egal in welcher Sprache es geschrieben ist, erlaubt auf den Kernel zuzugreifen.</p></div><div class=paragraph><p>Ein Assembler-Programm kann das ebenfalls. Beispielsweise könnten wir eine Datei öffnen:</p></div><div class="literalblock programlisting"><div class=content><pre>kernel:
	int	80h	; Call kernel
	ret

open:
	push	dword mode
	push	dword flags
	push	dword path
	mov	eax, 5
	call	kernel
	add	esp, byte 12
	ret</pre></div></div><div class=paragraph><p>Das ist ein sehr sauberer und portabler Programmierstil. Wenn Sie das Programm auf ein anderes UNIX® portieren, das einen anderen Interrupt oder eie andere Art der Parameterübergabe verwendet, müssen sie nur die Prozedur kernel ändern.</p></div><div class=paragraph><p>Aber Assembler-Programmierer lieben es Taktzyklen zu schinden. Das obige Beispiel benötigt eine <code>call/ret</code>-Kombination. Das können wir entfernen, indem wir einen weiteren Parameter mit <code>push</code> übergeben:</p></div><div class="literalblock programlisting"><div class=content><pre>open:
	push	dword mode
	push	dword flags
	push	dword path
	mov	eax, 5
	push	eax		; Or any other dword
	int	80h
	add	esp, byte 16</pre></div></div><div class=paragraph><p>Die Konstante <span class=constant>5</span>, die wir in <code>EAX</code> ablegen, identifiziert die Kernel-Funktion, die wir aufrufen. In diesem Fall ist das <code>open</code>.</p></div></div><div class=sect2><h3 id=x86-alternate-calling-convention>11.3.2. Alternative Aufruf-Konvention<a class=anchor href=#x86-alternate-calling-convention></a></h3><div class=paragraph><p>FreeBSD ist ein extrem flexibles System. Es bietet noch andere Wege, um den Kernel aufzurufen. Damit diese funktionieren muss allerdings die Linux-Emulation installiert sein.</p></div><div class=paragraph><p>Linux ist ein UNIX®-artiges System. Allerdings verwendet dessen Kernel die gleiche Systemaufruf-Konvention, bei der Parameter in Registern abgelegt werden, wie MS-DOS®. Genau wie bei der UNIX®-Konvention wird die Nummer der Funktion in <code>EAX</code> abgelegt. Allerdings werden die Parameter nicht auf den Stack gelegt, sondern in die Register <code>EBX, ECX, EDX, ESI, EDI, EBP</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>open:
	mov	eax, 5
	mov	ebx, path
	mov	ecx, flags
	mov	edx, mode
	int	80h</pre></div></div><div class=paragraph><p>Diese Konvention hat einen großen Nachteil gegenüber der von UNIX®, was die Assembler-Programmierung angeht: Jedesmal, wenn Sie einen Kernel-Aufruf machen, müssen Sie die Register <code>push</code>en und sie später <code>pop</code>en. Das macht Ihren Code unförmiger und langsamer. Dennoch lässt FreeBSD ihnen die Wahl.</p></div><div class=paragraph><p>Wenn Sie sich für die Linux-Konvention entscheiden, müssen Sie es das System wissen lassen. Nachdem ihr Programm übersetzt und gebunden wurde, müssen Sie die ausführbare Datei kennzeichnen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>%
	brandelf <span class=nt>-t</span> Linux
	filename</code></pre></div></div></div><div class=sect2><h3 id=x86-use-geneva>11.3.3. Welche Konvention Sie verwenden sollten<a class=anchor href=#x86-use-geneva></a></h3><div class=paragraph><p>Wenn Sie speziell für FreeBSD programmieren, sollten Sie die UNIX®-Konvention verwenden: Diese ist schneller, Sie können globale Variablen in Registern ablegen, Sie müssen die ausführbare Datei nicht kennzeichnen und Sie erzwingen nicht die Installation der Linux-Emulation auf dem Zielsystem.</p></div><div class=paragraph><p>Wenn Sie portablen Programmcode erzeugen wollen, der auch unter Linux funktioniert, wollen Sie den FreeBSD-Nutzern vielleicht dennoch den effizientesten Programmcode bieten, der möglich ist. Ich werde Ihnen zeigen, wie Sie das erreichen können, nachdem ich die Grundlagen erklärt habe.</p></div></div><div class=sect2><h3 id=x86-call-numbers>11.3.4. Aufruf-Nummern<a class=anchor href=#x86-call-numbers></a></h3><div class=paragraph><p>Um dem Kernel mitzuteilen welchen Dienst Sie aufrufen, legen Sie dessen Nummer in <code>EAX</code> ab. Natürlich müssen Sie dazu wissen welche Nummer die Richtige ist.</p></div><div class=sect3><h4 id=x86-the-syscalls-file>11.3.4.1. Die Datei <span class=filename>syscalls</span><a class=anchor href=#x86-the-syscalls-file></a></h4><div class=paragraph><p>Die Nummer der Funktionen sind in der Datei <span class=filename>syscalls</span> aufgeführt. Mittels <code>locate syscalls</code> finden Sie diese in verschiedenen Formaten, die alle auf die gleiche Weise aus <span class=filename>syscalls.master</span> erzeugt werden.</p></div><div class=paragraph><p>Die Master-Datei für die UNIX®-Standard-Aufrufkonvention finden sie unter <span class=filename>/usr/src/sys/kern/syscalls.master</span>. Falls Sie die andere Konvention, die im Linux-Emulations-Modus implementiert ist, verwenden möchten, lesen Sie bitte <span class=filename>/usr/src/sys/i386/linux/syscalls.master</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD und Linux unterscheiden sich nicht nur in den Aufrufkonventionen, sie haben teilweise auch verschiedene Nummern für die gleiche Funktion.</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>syscalls.master</span> beschreibt, wie der Aufruf gemacht werden muss:</p></div><div class="literalblock programlisting"><div class=content><pre>0	STD	NOHIDE	{ int nosys(void); } syscall nosys_args int
1	STD	NOHIDE	{ void exit(int rval); } exit rexit_args void
2	STD	POSIX	{ int fork(void); }
3	STD	POSIX	{ ssize_t read(int fd, void *buf, size_t nbyte); }
4	STD	POSIX	{ ssize_t write(int fd, const void *buf, size_t nbyte); }
5	STD	POSIX	{ int open(char *path, int flags, int mode); }
6	STD	POSIX	{ int close(int fd); }
etc...</pre></div></div><div class=paragraph><p>In der ersten Spalte steht die Nummer, die in <code>EAX</code> abgelegt werden muss.</p></div><div class=paragraph><p>Die Spalte ganz rechts sagt uns welche Parameter wir <code>push</code>en müssen. Die Reihenfolge ist dabei <em>von rechts nach links</em>.</p></div><div class=exampleblock><div class=content><div class=paragraph><p>Um beispielsweise eine Datei mittels <code>open</code> zu öffnen, müssen wir zuerst den <code>mode</code> auf den Stack <code>push</code>en, danach die <code>flags</code>, dann die Adresse an der der <code>path</code> gespeichert ist.</p></div></div></div></div></div></div></div><div class=sect1><h2 id=x86-return-values>11.4. Rückgabewerte<a class=anchor href=#x86-return-values></a></h2><div class=sectionbody><div class=paragraph><p>Ein Systemaufruf wäre meistens nicht sehr nützlich, wenn er nicht irgendeinen Wert zurückgibt: Beispielsweise den Dateideskriptor einer geöffneten Datei, die Anzahl an Bytes die in einen Puffer gelesen wurde, die Systemzeit, etc.</p></div><div class=paragraph><p>Außerdem muss Sie das System informieren, falls ein Fehler auftritt: Wenn eine Datei nicht existiert, die Systemressourcen erschöpft sind, wir ein ungültiges Argument übergeben haben, etc.</p></div><div class=sect2><h3 id=x86-man-pages>11.4.1. Manualpages<a class=anchor href=#x86-man-pages></a></h3><div class=paragraph><p>Der herkömmliche Ort, um nach Informationen über verschiedene Systemaufrufe unter UNIX®-Systemen zu suchen, sind die Manualpages. FreeBSD beschreibt seine Systemaufrufe in Abschnitt 2, manchmal auch Abschnitt 3.</p></div><div class=paragraph><p>In <a href="https://man.freebsd.org/cgi/man.cgi?query=open&amp;sektion=2&amp;format=html">open(2)</a> steht beispielsweise:</p></div><div class="paragraph blockquote"><p>Falls erfolgreich, gibt <code>open()</code> einen nicht negativen Integerwert, als Dateideskriptor bezeichnet, zurück. Es gibt <code>-1</code> im Fehlerfall zurück und setzt <code>errno</code> um den Fehler anzuzeigen.</p></div><div class=paragraph><p>Ein Assembler-Programmierer, der neu bei UNIX® und FreeBSD ist, wird sich sofort fragen: Wo finde ich <code>errno</code> und wie erreiche ich es?</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Information der Manualpage bezieht sich auf C-Programme. Der Assembler-Programmierer benötigt zusätzliche Informationen.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=x86-where-return-values>11.4.2. Wo sind die Rückgabewerde?<a class=anchor href=#x86-where-return-values></a></h3><div class=paragraph><p>Leider gilt: Es kommt darauf an…​ Für die meisten Systemaufrufe liegt er in <code>EAX</code>, aber nicht für alle. Eine gute Daumenregel, wenn man zum ersten Mal mit einem Systemaufruf arbeitet, ist in <code>EAX</code> nach dem Rückgabewert zu suchen. Wenn er nicht dort ist, sind weitere Untersuchungen nötig.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Mir ist ein Systemaufruf bekannt, der den Rückgabewert in <code>EDX</code> ablegt: <code>SYS_fork</code> Alle anderen mit denen ich bisher gearbeitet habe verwenden <code>EAX</code>. Allerdings habe ich noch nicht mit allen gearbeitet.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Wenn Sie die Antwort weder hier, noch irgendwo anders finden, studieren Sie den Quelltext von libc und sehen sich an, wie es mit dem Kernel zusammenarbeitet.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=x86-where-errno>11.4.3. Wo ist <code>errno</code>?<a class=anchor href=#x86-where-errno></a></h3><div class=paragraph><p>Tatsächlich, nirgendwo…​</p></div><div class=paragraph><p><code>errno</code> ist ein Teil der Sprache C, nicht des UNIX®-Kernels. Wenn man direkt auf Kernel-Dienste zugreift, wird der Fehlercode in <code>EAX</code> zurückgegeben, das selbe Register in dem der Rückgabewert, bei einem erfolgreichen Aufruf landet.</p></div><div class=paragraph><p>Das macht auch Sinn. Wenn kein Fehler auftritt, gibt es keinen Fehlercode. Wenn ein Fehler auftritt, gibt es keinen Rückgabewert. Ein einziges Register kann also beides enthalten.</p></div></div><div class=sect2><h3 id=x86-how-to-know-error>11.4.4. Feststellen, dass ein Fehler aufgetreten ist<a class=anchor href=#x86-how-to-know-error></a></h3><div class=paragraph><p>Wenn Sie die Standard FreeBSD-Aufrufkonvention verwenden wird das <code>carry flag</code> gelöscht wenn der Aufruf erfolgreich ist und gesetzt wenn ein Fehler auftritt.</p></div><div class=paragraph><p>Wenn Sie den Linux-Emulationsmodus verwenden ist der vorzeichenbehaftete Wert in <code>EAX</code> nicht negativ, bei einem erfolgreichen Aufruf. Wenn ein Fehler auftritt ist der Wert negativ, also <code>-errno</code>.</p></div></div></div></div><div class=sect1><h2 id=x86-portable-code>11.5. Portablen Code erzeugen<a class=anchor href=#x86-portable-code></a></h2><div class=sectionbody><div class=paragraph><p>Portabilität ist im Allgemeinen keine Stärke der Assembler-Programmierung. Dennoch ist es, besonders mit nasm, möglich Assembler-Programme für verschiedene Plattformen zu schreiben. Ich selbst habe bereits Assembler-Bibliotheken geschrieben die auf so unterschiedlichen Systemen wie Windows® und FreeBSD übersetzt werden können.</p></div><div class=paragraph><p>Das ist um so besser möglich, wenn Ihr Code auf zwei Plattformen laufen soll , die, obwohl sie verschieden sind, auf ähnlichen Architekturen basieren.</p></div><div class=paragraph><p>Beispielsweise ist FreeBSD ein UNIX®, während Linux UNIX®-artig ist. Ich habe bisher nur drei Unterschiede zwischen beiden (aus Sicht eines Assembler-Programmierers) erwähnt: Die Aufruf-Konvention, die Funktionsnummern und die Art der Übergabe von Rückgabewerten.</p></div><div class=sect2><h3 id=x86-deal-with-function-numbers>11.5.1. Mit Funktionsnummern umgehen<a class=anchor href=#x86-deal-with-function-numbers></a></h3><div class=paragraph><p>In vielen Fällen sind die Funktionsnummern die selben. Allerdings kann man auch wenn sie es nicht sind leicht mit diesem Problem umgehen: Anstatt die Nummern in Ihrem Code zu verwenden, benutzen Sie Konstanten, die Sie abhängig von der Zielarchitektur unterschiedlich definieren:</p></div><div class="literalblock programlisting"><div class=content><pre>%ifdef	LINUX
%define	SYS_execve	11
%else
%define	SYS_execve	59
%endif</pre></div></div></div><div class=sect2><h3 id=x86-deal-with-geneva>11.5.2. Umgang mit Konventionen<a class=anchor href=#x86-deal-with-geneva></a></h3><div class=paragraph><p>Sowohl die Aufrufkonvention, als auch die Rückgabewerte (das <code>errno</code> Problem) kann man mit Hilfe von Makros lösen:</p></div><div class="literalblock programlisting"><div class=content><pre>%ifdef	LINUX

%macro	system	0
	call	kernel
%endmacro

align 4
kernel:
	push	ebx
	push	ecx
	push	edx
	push	esi
	push	edi
	push	ebp

	mov	ebx, [esp+32]
	mov	ecx, [esp+36]
	mov	edx, [esp+40]
	mov	esi, [esp+44]
	mov	ebp, [esp+48]
	int	80h

	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx

	or	eax, eax
	js	.errno
	clc
	ret

.errno:
	neg	eax
	stc
	ret

%else

%macro	system	0
	int	80h
%endmacro

%endif</pre></div></div></div><div class=sect2><h3 id=x86-deal-with-other-portability>11.5.3. Umgang mit anderen Portabilitätsangelegenheiten<a class=anchor href=#x86-deal-with-other-portability></a></h3><div class=paragraph><p>Die oben genannte Lösung funktioniert in den meisten Fällen, wenn man Code schreibt, der zwischen FreeBSD und Linux portierbar sein soll. Allerdings sind die Unterschiede bei einigen Kernel-Diensten tiefgreifender.</p></div><div class=paragraph><p>In diesem Fällen müssen Sie zwei verschiedene Handler für diese Systemaufrufe schreiben und bedingte Assemblierung benutzen, um diese zu übersetzen. Glücklicherweise wird der größte Teil Ihres Codes nicht den Kernel aufrufen und Sie werden deshalb nur wenige solcher bedingten Abschnitte benötigen.</p></div></div><div class=sect2><h3 id=x86-portable-library>11.5.4. Eine Bibliothek benutzen<a class=anchor href=#x86-portable-library></a></h3><div class=paragraph><p>Sie können Portabilitätsprobleme im Hauptteil ihres Codes komplett vermeiden, indem Sie eine Bibliothek für Systemaufrufe schreiben. Erstellen Sie eine Bibliothek für FreeBSD, eine für Linux und weitere für andere Betriebssysteme.</p></div><div class=paragraph><p>Schreiben Sie in ihrer Bibliothek eine gesonderte Funktion (oder Prozedur, falls Sie die traditionelle Assembler-Terminologie bevorzugen) für jeden Systemaufruf. Verwenden Sie dabei die C-Aufrufkonvention um Parameter zu übergeben, aber verwenden Sie weiterhin <code>EAX</code>, für die Aufrufnummer. In diesem Fall kann ihre FreeBSD-Bibliothek sehr einfach sein, da viele scheinbar unterschiedliche Funktionen als Label für denselben Code implementiert sein können:</p></div><div class="literalblock programlisting"><div class=content><pre>sys.open:
sys.close:
[etc...]
	int	80h
	ret</pre></div></div><div class=paragraph><p>Ihre Linux-Bibliothek wird mehr verschiedene Funktionen benötigen, aber auch hier können Sie Systemaufrufe, welche die Anzahl an Parametern akzeptieren zusammenfassen:</p></div><div class="literalblock programlisting"><div class=content><pre>sys.exit:
sys.close:
[etc... one-parameter functions]
	push	ebx
	mov	ebx, [esp+12]
	int	80h
	pop	ebx
	jmp	sys.return

...

sys.return:
	or	eax, eax
	js	sys.err
	clc
	ret

sys.err:
	neg	eax
	stc
	ret</pre></div></div><div class=paragraph><p>Der Bibliotheks-Ansatz mag auf den ersten Blick unbequem aussehen, weil Sie eine weitere Datei erzeugen müssen von der Ihr Code abhängt. Aber er hat viele Vorteile: Zum einen müssen Sie die Bibliothek nur einmal schreiben und können sie dann in allen Ihren Programmen verwenden. Sie können sie sogar von anderen Assembler-Programmierern verwenden lassen, oder eine die von jemand anderem geschrieben wurde verwenden. Aber der vielleicht größte Vorteil ist, dass Ihr Code sogar von anderen Programmierer auf andere Systeme portiert werden kann, einfach indem man eine neue Bibliothek schreibt, völlig ohne Änderungen an Ihrem Code.</p></div><div class=paragraph><p>Falls Ihnen der Gedanke eine Bibliothek zu nutzen nicht gefällt, können Sie zumindest all ihre Systemaufrufe in einer gesonderten Assembler-Datei ablegen und diese mit Ihrem Hauptprogramm zusammen binden. Auch hier müssen alle, die ihr Programm portieren, nur eine neue Objekt-Datei erzeugen und an Ihr Hauptprogramm binden.</p></div></div><div class=sect2><h3 id=x86-portable-include>11.5.5. Eine Include-Datei verwenden<a class=anchor href=#x86-portable-include></a></h3><div class=paragraph><p>Wenn Sie ihre Software als (oder mit dem) Quelltext ausliefern, können Sie Makros definieren und in einer getrennten Datei ablegen, die Sie ihrem Code beilegen.</p></div><div class=paragraph><p>Porter Ihrer Software schreiben dann einfach eine neue Include-Datei. Es ist keine Bibliothek oder eine externe Objekt-Datei nötig und Ihr Code ist portabel, ohne dass man ihn editieren muss.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das ist der Ansatz den wir in diesem Kapitel verwenden werden. Wir werden unsere Include-Datei <span class=filename>system.inc</span> nennen und jedesmal, wenn wir einen neuen Systemaufruf verwenden, den entsprechenden Code dort einfügen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wir können unsere <span class=filename>system.inc</span> beginnen indem wir die Standard-Dateideskriptoren deklarieren:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	stdin	0
%define	stdout	1
%define	stderr	2</pre></div></div><div class=paragraph><p>Als Nächstes erzeugen wir einen symbolischen Namen für jeden Systemaufruf:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_nosys	0
%define	SYS_exit	1
%define	SYS_fork	2
%define	SYS_read	3
%define	SYS_write	4
; [etc...]</pre></div></div><div class=paragraph><p>Wir fügen eine kleine, nicht globale Prozedur mit langem Namen ein, damit wir den Namen nicht aus Versehen in unserem Code wiederverwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>section	.text
align 4
access.the.bsd.kernel:
	int	80h
	ret</pre></div></div><div class=paragraph><p>Wir erzeugen ein Makro, das ein Argument erwartet, die Systemaufruf-Nummer:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	system	1
	mov	eax, %1
	call	access.the.bsd.kernel
%endmacro</pre></div></div><div class=paragraph><p>Letztlich erzeugen wir Makros für jeden Systemaufruf. Diese Argumente erwarten keine Argumente.</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.exit	0
	system	SYS_exit
%endmacro

%macro	sys.fork	0
	system	SYS_fork
%endmacro

%macro	sys.read	0
	system	SYS_read
%endmacro

%macro	sys.write	0
	system	SYS_write
%endmacro

; [etc...]</pre></div></div><div class=paragraph><p>Fahren Sie fort, geben das in Ihren Editor ein und speichern es als <span class=filename>system.inc</span>. Wenn wir Systemaufrufe besprechen, werden wir noch Ergänzungen in dieser Datei vornehmen.</p></div></div></div></div><div class=sect1><h2 id=x86-first-program>11.6. Unser erstes Programm<a class=anchor href=#x86-first-program></a></h2><div class=sectionbody><div class=paragraph><p>Jetzt sind wir bereit für unser erstes Programm, das übliche Hello, World!</p></div><div class="literalblock programlisting"><div class=content><pre> 1:	%include	&#39;system.inc&#39;
 2:
 3:	section	.data
 4:	hello	db	&#39;Hello, World!&#39;, 0Ah
 5:	hbytes	equ	$-hello
 6:
 7:	section	.text
 8:	global	_start
 9:	_start:
10:	push	dword hbytes
11:	push	dword hello
12:	push	dword stdout
13:	sys.write
14:
15:	push	dword 0
16:	sys.exit</pre></div></div><div class=paragraph><p>Hier folgt die Erklärung des Programms: Zeile 1 fügt die Definitionen ein, die Makros und den Code aus <span class=filename>system.inc</span>.</p></div><div class=paragraph><p>Die Zeilen 3 bis 5 enthalten die Daten: Zeile 3 beginnt den Datenabschnitt/das Datensegment. Zeile 4 enthält die Zeichenkette "Hello, World!", gefolgt von einem Zeilenumbruch (<span class=constant>0Ah</span>). Zeile 5 erstellt eine Konstante, die die Länge der Zeichenkette aus Zeile 4 in Bytes enthält.</p></div><div class=paragraph><p>Die Zeilen 7 bis 16 enthalten den Code. Beachten Sie bitte, dass FreeBSD das Dateiformat <em>elf</em> für diese ausführbare Datei verwendet, bei dem jedes Programm mit dem Label <code>_start</code> beginnt (oder, um genau zu sein, wird dies vom Linker erwartet). Diese Label muss global sein.</p></div><div class=paragraph><p>Die Zeilen 10 bis 13 weisen das System an <code>hbytes</code> Bytes der Zeichenkette <code>hello</code> nach <code>stdout</code> zu schreiben.</p></div><div class=paragraph><p>Die Zeilen 15 und 16 weisen das System an das Programm mit dem Rückgabewert <span class=constant>0</span> zu beenden. Der Systemaufruf <code>SYS_exit</code> kehrt niemals zurück, somit endet das Programm hier.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie von MS-DOS®-Assembler zu UNIX® gekommen sind, sind Sie es vielleicht gewohnt direktauf die Video-Hardware zu schreiben. Unter FreeBSD müssen Sie sich darum keine Gedanken machen, ebenso bei jeder anderen Art von UNIX®. Soweit es Sie betrifft schreiben Sie in eine Datei namens <span class=filename>stdout</span>. Das kann der Bildschirm, oder ein telnet-Terminal, eine wirkliche Datei, oder die Eingabe eines anderen Programms sein. Es liegt beim System herauszufinden, welches davon es tatsächlich ist.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=x86-assemble-1>11.6.1. Den Code assemblieren<a class=anchor href=#x86-assemble-1></a></h3><div class=paragraph><p>Geben Sie den Code (außer den Zeilennummern) in einen Editor ein und speichern Sie ihn in einer Datei namens <span class=filename>hello.asm</span>. Um es zu assemblieren benötigen Sie nasm.</p></div><div class=sect3><h4 id=x86-get-nasm>11.6.1.1. nasm installieren<a class=anchor href=#x86-get-nasm></a></h4><div class=paragraph><p>Wenn Sie nasm noch nicht installiert haben geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:your root password
<span class=c># cd /usr/ports/devel/nasm</span>
<span class=c># make install</span>
<span class=c># exit</span>
%</code></pre></div></div><div class=paragraph><p>Sie können auch <code>make install clean</code> anstatt <code>make install</code> eingeben, wenn Sie den Quelltext von nasm nicht behalten möchten.</p></div><div class=paragraph><p>Auf jeden Fall wird FreeBSD nasm automatisch aus dem Internet herunterladen, es kompilieren und auf Ihrem System installieren.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn es sich bei Ihrem System nicht um FreeBSD handelt, müssen Sie nasm von dessen <a href=https://sourceforge.net/projects/nasm>Homepage</a> herunterladen. Sie können es aber dennoch verwenden um FreeBSD code zu assemblieren.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nun können Sie den Code assemblieren, binden und ausführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hello.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hello hello.o
% ./hello
Hello, World!
%</code></pre></div></div></div></div></div></div><div class=sect1><h2 id=x86-unix-filters>11.7. UNIX®-Filter schreiben<a class=anchor href=#x86-unix-filters></a></h2><div class=sectionbody><div class=paragraph><p>Ein häufiger Typ von UNIX®-Anwendungen ist ein Filter - ein Programm, das Eingaben von <span class=filename>stdin</span> liest, sie verarbeitet und das Ergebnis nach <span class=filename>stdout</span> schreibt.</p></div><div class=paragraph><p>In diesem Kapitel möchten wir einen einfachen Filter entwickeln und lernen, wie wir von <span class=filename>stdin</span> lesen und nach <span class=filename>stdout</span> schreiben. Dieser Filter soll jedes Byte seiner Eingabe in eine hexadezimale Zahl gefolgt von einem Leerzeichen umwandeln.</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

section	.data
hex	db	&#39;0123456789ABCDEF&#39;
buffer	db	0, 0, &#39; &#39;

section	.text
global	_start
_start:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short _start

.done:
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>Im Datenabschnitt erzeugen wir ein Array mit Namen <code>hex</code>. Es enthält die 16 hexadezimalen Ziffern in aufsteigender Reihenfolge. Diesem Array folgt ein Puffer, den wir sowohl für die Ein- als auch für die Ausgabe verwenden. Die ersten beiden Bytes dieses Puffers werden am Anfang auf <span class=constant>0</span> gesetzt. Dorthin schreiben wir die beiden hexadezimalen Ziffern (das erste Byte ist auch die Stelle an die wir die Eingabe lesen). Das dritte Byte ist ein Leerzeichen.</p></div><div class=paragraph><p>Der Code-Abschnitt besteht aus vier Teilen: Das Byte lesen, es in eine hexadezimale Zahl umwandeln, das Ergebnis schreiben und letztendlich das Programm verlassen.</p></div><div class=paragraph><p>Um das Byte zu lesen, bitten wir das System ein Byte von <span class=filename>stdin</span> zu lesen und speichern es im ersten Byte von <code>buffer</code>. Das System gibt die Anzahl an Bytes, die gelesen wurden, in <code>EAX</code> zurück. Diese wird <span class=constant>1</span> sein, wenn eine Eingabe empfangen wird und <span class=constant>0</span>, wenn keine Eingabedaten mehr verfügbar sind. Deshalb überprüfen wir den Wert von <code>EAX</code>. Wenn dieser <span class=constant>0</span> ist, springen wir zu <code>.done</code>, ansonsten fahren wir fort.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Zu Gunsten der Einfachheit ignorieren wir hier die Möglichkeit eines Fehlers.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Umwandlungsroutine in eine Hexadezimalzahl liest das Byte aus <code>buffer</code> in <code>EAX</code>, oder genaugenommen nur in <code>AL</code>, wobei die übrigen Bits von <code>EAX</code> auf null gesetzt werden. Außerdem kopieren wir das Byte nach <code>EDX</code>, da wir die oberen vier Bits (Nibble) getrennt von den unteren vier Bits umwandeln müssen. Das Ergebnis speichern wir in den ersten beiden Bytes des Puffers.</p></div><div class=paragraph><p>Als Nächstes bitten wir das System die drei Bytes in den Puffer zu schreiben, also die zwei hexadezimalen Ziffern und das Leerzeichen nach <span class=filename>stdout</span>. Danach springen wir wieder an den Anfang des Programms und verarbeiten das nächste Byte.</p></div><div class=paragraph><p>Wenn die gesamte Eingabe verarbeitet ist, bitten wie das System unser Programm zu beenden und null zurückzuliefern, welches traditionell die Bedeutung hat, dass unser Programm erfolgreich war.</p></div><div class=paragraph><p>Fahren Sie fort und speichern Sie den Code in eine Datei namens <span class=filename>hex.asm</span>. Geben Sie danach folgendes ein (<code>^D</code> bedeutet, dass Sie die Steuerungstaste drücken und dann <code>D</code> eingeben, während Sie Steuerung gedrückt halten):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A ^D %</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie von MS-DOS® zu UNIX® wechseln, wundern Sie sich vielleicht, warum jede Zeile mit <span class=constant>0A</span> an Stelle von <span class=constant>0D 0A</span> endet. Das liegt daran, dass UNIX® nicht die CR/LF-Konvention, sondern die "new line"-Konvention verwendet, welches hexadezimal als <span class=constant>0A</span> dargestellt wird.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Können wir das Programm verbessern? Nun, einerseits ist es etwas verwirrend, dass die Eingabe, nachdem wir eine Zeile verarbeitet haben, nicht wieder am Anfang der Zeile beginnt. Deshalb können wir unser Programm anpassen um einen Zeilenumbruch an Stelle eines Leerzeichens nach jedem <span class=constant>0A</span> auszugeben:</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

section	.data
hex	db	&#39;0123456789ABCDEF&#39;
buffer	db	0, 0, &#39; &#39;

section	.text
global	_start
_start:
	mov	cl, &#39; &#39;

.loop:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	[buffer+2], cl
	cmp	al, 0Ah
	jne	.hex
	mov	[buffer+2], al

.hex:
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short .loop

.done:
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>Wir haben das Leerzeichen im Register <code>CL</code> abgelegt. Das können wir bedenkenlos tun, da UNIX®-Systemaufrufe im Gegensatz zu denen von Microsoft® Windows® keine Werte von Registern ändern in denen sie keine Werte zurückliefern.</p></div><div class=paragraph><p>Das bedeutet, dass wir <code>CL</code> nur einmal setzen müssen. Dafür haben wir ein neues Label <code>.loop</code> eingefügt, zu dem wir an Stelle von <code>_start</code> springen, um das nächste Byte einzulesen. Außerdem haben wir das Label <code>.hex</code> eingefügt, somit können wir wahlweise ein Leerzeichen oder einen Zeilenumbruch im dritten Byte von <code>buffer</code> ablegen.</p></div><div class=paragraph><p>Nachdem Sie <span class=filename>hex.asm</span> entsprechend der Neuerungen geändert haben, geben Sie Folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>Das sieht doch schon besser aus. Aber der Code ist ziemlich ineffizient! Wir führen für jeden einzelne Byte zweimal einen Systemaufruf aus (einen zum Lesen und einen um es in die Ausgabe zu schreiben).</p></div></div></div><div class=sect1><h2 id=x86-buffered-io>11.8. Gepufferte Eingabe und Ausgabe<a class=anchor href=#x86-buffered-io></a></h2><div class=sectionbody><div class=paragraph><p>Wir können die Effizienz unseres Codes erhöhen, indem wir die Ein- und Ausgabe puffern. Wir erzeugen einen Eingabepuffer und lesen dann eine Folge von Bytes auf einmal. Danach holen wir sie Byte für Byte aus dem Puffer.</p></div><div class=paragraph><p>Wir erzeugen ebenfalls einen Ausgabepuffer. Darin speichern wir unsere Ausgabe bis er voll ist. Dann bitten wir den Kernel den Inhalt des Puffers nach <span class=filename>stdout</span> zu schreiben.</p></div><div class=paragraph><p>Diese Programm endet, wenn es keine weitere Eingaben gibt. Aber wir müssen den Kernel immernoch bitten den Inhalt des Ausgabepuffers ein letztes Mal nach <span class=filename>stdout</span> zu schreiben, denn sonst würde ein Teil der Ausgabe zwar im Ausgabepuffer landen, aber niemals ausgegeben werden. Bitte vergessen Sie das nicht, sonst fragen Sie sich später warum ein Teil Ihrer Ausgabe verschwunden ist.</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>Als dritten Abschnitt im Quelltext haben wir <code>.bss</code>. Dieser Abschnitt wird nicht in unsere ausführbare Datei eingebunden und kann daher nicht initialisiert werden. Wir verwenden <code>resb</code> anstelle von <code>db</code>. Dieses reserviert einfach die angeforderte Menge an uninitialisiertem Speicher zu unserer Verwendung.</p></div><div class=paragraph><p>Wir nutzen, die Tatsache, dass das System die Register nicht verändert: Wir benutzen Register, wo wir anderenfalls globale Variablen im Abschnitt <code>.data</code> verwenden müssten. Das ist auch der Grund, warum die UNIX®-Konvention, Parameter auf dem Stack zu übergeben, der von Microsoft, hierfür Register zu verwenden, überlegen ist: Wir können Register für unsere eigenen Zwecke verwenden.</p></div><div class=paragraph><p>Wir verwenden <code>EDI</code> und <code>ESI</code> als Zeiger auf das nächste zu lesende oder schreibende Byte. Wir verwenden <code>EBX</code> und <code>ECX</code>, um die Anzahl der Bytes in den beiden Puffern zu zählen, damit wir wissen, wann wir die Ausgabe an das System übergeben, oder neue Eingabe vom System entgegen nehmen müssen.</p></div><div class=paragraph><p>Lassen Sie uns sehen, wie es funktioniert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
Here I come!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>Nicht was Sie erwartet haben? Das Programm hat die Ausgabe nicht auf dem Bildschirm ausgegeben bis sie <code>^D</code> gedrückt haben. Das kann man leicht zu beheben indem man drei Zeilen Code einfügt, welche die Ausgabe jedesmal schreiben, wenn wir einen Zeilenumbruch in <span class=constant>0A</span> umgewandelt haben. Ich habe die betreffenden Zeilen mit > markiert (kopieren Sie die > bitte nicht mit in Ihre <span class=filename>hex.asm</span>).</p></div><div class="literalblock programlisting"><div class=content><pre>%include    &#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
&gt;	cmp	al, 0Ah
&gt;	jne	.loop
&gt;	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>Lassen Sie uns jetzt einen Blick darauf werfen, wie es funktioniert.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>Nicht schlecht für eine 644 Byte große Binärdatei, oder?</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dieser Ansatz für gepufferte Ein- und Ausgabe enthält eine Gefahr, auf die ich im Abschnitt <a href=#x86-buffered-dark-side>Die dunkle Seite des Buffering</a> eingehen werde.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=x86-ungetc>11.8.1. Ein Zeichen ungelesen machen<a class=anchor href=#x86-ungetc></a></h3><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Das ist vielleicht ein etwas fortgeschrittenes Thema, das vor allem für Programmierer interessant ist, die mit der Theorie von Compilern vertraut sind. Wenn Sie wollen, können Sie <a href=#x86-command-line>zum nächsten Abschnitt springen</a> und das hier vielleicht später lesen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Unser Beispielprogramm benötigt es zwar nicht, aber etwas anspruchsvollere Filter müssen häufig vorausschauen. Mit anderen Worten, sie müssen wissen was das nächste Zeichen ist (oder sogar mehrere Zeichen). Wenn das nächste Zeichen einen bestimmten Wert hat, ist es Teil des aktuellen Tokens, ansonsten nicht.</p></div><div class=paragraph><p>Zum Beispiel könnten Sie den Eingabestrom für eine Text-Zeichenfolge parsen (z.B. wenn Sie einen Compiler einer Sprache implementieren): Wenn einem Buchstaben ein anderer Buchstabe oder vielleicht eine Ziffer folgt, ist er ein Teil des Tokens, das Sie verarbeiten. Wenn ihm ein Leerzeichen folgt, oder ein anderer Wert, ist er nicht Teil des aktuellen Tokens.</p></div><div class=paragraph><p>Das führt uns zu einem interessanten Problem: Wie kann man ein Zeichen zurück in den Eingabestrom geben, damit es später noch einmal gelesen werden kann?</p></div><div class=paragraph><p>Eine mögliche Lösung ist, das Zeichen in einer Variable zu speichern und ein Flag zu setzen. Wir können <code>getchar</code> so anpassen, dass es das Flag überprüft und, wenn es gesetzt ist, das Byte aus der Variable anstatt dem Eingabepuffer liest und das Flag zurück setzt. Aber natürlich macht uns das langsamer.</p></div><div class=paragraph><p>Die Sprache C hat eine Funktion <code>ungetc()</code> für genau diesen Zweck. Gibt es einen schnellen Weg, diese in unserem Code zu implementieren? Ich möchte Sie bitten nach oben zu scrollen und sich die Prozedur <code>getchar</code> anzusehen und zu versuchen eine schöne und schnelle Lösung zu finden, bevor Sie den nächsten Absatz lesen. Kommen Sie danach hierher zurück und schauen sich meine Lösung an.</p></div><div class=paragraph><p>Der Schlüssel dazu ein Zeichen an den Eingabestrom zurückzugeben, liegt darin, wie wir das Zeichen bekommen:</p></div><div class=paragraph><p>Als erstes überprüfen wir, ob der Puffer leer ist, indem wir den Wert von <code>EBX</code> testen. Wenn er null ist, rufen wir die Prozedur <code>read</code> auf.</p></div><div class=paragraph><p>Wenn ein Zeichen bereit ist verwenden wir <code>lodsb</code>, dann verringern wir den Wert von <code>EBX</code>. Die Anweisung <code>lodsb</code> ist letztendlich identisch mit:</p></div><div class="literalblock programlisting"><div class=content><pre>	mov	al, [esi]
	  inc	esi</pre></div></div><div class=paragraph><p>Das Byte, welches wir abgerufen haben, verbleibt im Puffer bis <code>read</code> zum nächsten Mal aufgerufen wird. Wir wissen nicht wann das passiert, aber wir wissen, dass es nicht vor dem nächsten Aufruf von <code>getchar</code> passiert. Daher ist alles was wir tun müssen um das Byte in den Strom "zurückzugeben" ist den Wert von <code>ESI</code> zu verringern und den von <code>EBX</code> zu erhöhen:</p></div><div class="literalblock programlisting"><div class=content><pre>ungetc:
	  dec	esi
	  inc	ebx
	  ret</pre></div></div><div class=paragraph><p>Aber seien Sie vorsichtig! Wir sind auf der sicheren Seite, solange wir immer nur ein Zeichen im Voraus lesen. Wenn wir mehrere kommende Zeichen betrachten und <code>ungetc</code> mehrmals hintereinander aufrufen, wird es meistens funktionieren, aber nicht immer (und es wird ein schwieriger Debug). Warum?</p></div><div class=paragraph><p>Solange <code>getchar<code>read</code> nicht aufrufen muss, befinden sich alle im Voraus gelesenen Bytes noch im Puffer und <code>ungetc</code> arbeitet fehlerfrei. Aber sobald <code>getchar</code>read</code> aufruft verändert sich der Inhalt des Puffers.</p></div><div class=paragraph><p>Wir können uns immer darauf verlassen, dass <code>ungetc</code> auf dem zuletzt mit <code>getchar</code> gelesenen Zeichen korrekt arbeitet, aber nicht auf irgendetwas, das davor gelesen wurde.</p></div><div class=paragraph><p>Wenn Ihr Programm mehr als ein Byte im Voraus lesen soll, haben Sie mindestens zwei Möglichkeiten:</p></div><div class=paragraph><p>Die einfachste Lösung ist, Ihr Programm so zu ändern, dass es immer nur ein Byte im Voraus liest, wenn das möglich ist.</p></div><div class=paragraph><p>Wenn Sie diese Möglichkeit nicht haben, bestimmen Sie zuerst die maximale Anzahl an Zeichen, die Ihr Programm auf einmal an den Eingabestrom zurückgeben muss. Erhöhen Sie diesen Wert leicht, nur um sicherzugehen, vorzugsweise auf ein Vielfaches von 16-damit er sich schön ausrichtet. Dann passen Sie den <code>.bss</code> Abschnitt Ihres Codes an und erzeugen einen kleinen Reserver-Puffer, direkt vor ihrem Eingabepuffer, in etwa so:</p></div><div class="literalblock programlisting"><div class=content><pre>section	.bss
	  resb	16	; or whatever the value you came up with
  ibuffer	resb	BUFSIZE
  obuffer	resb	BUFSIZE</pre></div></div><div class=paragraph><p>Außerdem müssen Sie <code>ungetc</code> anpassen, sodass es den Wert des Bytes, das zurückgegeben werden soll, in <code>AL</code> übergibt:</p></div><div class="literalblock programlisting"><div class=content><pre>ungetc:
	  dec	esi
	  inc	ebx
	  mov	[esi], al
	  ret</pre></div></div><div class=paragraph><p>Mit dieser Änderung können Sie sicher <code>ungetc</code> bis zu 17 Mal hintereinander gqapaufrufen (der erste Aufruf erfolgt noch im Puffer, die anderen 16 entweder im Puffer oder in der Reserve).</p></div></div></div></div><div class=sect1><h2 id=x86-command-line>11.9. Kommandozeilenparameter<a class=anchor href=#x86-command-line></a></h2><div class=sectionbody><div class=paragraph><p>Unser hex-Programm wird nützlicher, wenn es die Dateinamen der Ein- und Ausgabedatei über die Kommandozeile einlesen kann, d.h., wenn es Kommandozeilenparameter verarbeiten kann. Aber…​ Wo sind die?</p></div><div class=paragraph><p>Bevor ein UNIX®-System ein Programm ausführt, legt es einige Daten auf dem Stack ab (<code>push</code>) und springt dann an das <code>_start</code>-Label des Programms. Ja, ich sagte springen, nicht aufrufen. Das bedeutet, dass auf die Daten zugegriffen werden kann, indem <code>[esp+offset]</code> ausgelesen wird oder die Daten einfach vom Stack genommen werden (<code>pop</code>).</p></div><div class=paragraph><p>Der Wert ganz oben auf dem Stack enthält die Zahl der Kommandozeilenparameter. Er wird traditionell <code>argc</code> wie "argument count" genannt.</p></div><div class=paragraph><p>Die Kommandozeilenparameter folgen einander, alle <code>argc</code>. Von diesen wird üblicherweise als <code>argv</code> wie "argument value(s)" gesprochen. So erhalten wir <code>argv[0]</code>, <code>argv[1]</code>, <code>…​</code> und <code>argv[argc-1]</code>. Dies sind nicht die eigentlichen Parameter, sondern Zeiger (Pointer) auf diese, d.h., Speicheradressen der tatsächlichen Parameter. Die Parameter selbst sind durch NULL beendete Zeichenketten.</p></div><div class=paragraph><p>Der <code>argv</code>-Liste folgt ein NULL-Zeiger, was einfach eine <span class=constant>0</span> ist. Es gibt noch mehr, aber dies ist erst einmal genug für unsere Zwecke.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls Sie von der MS-DOS®-Programmierumgebung kommen, ist der größte Unterschied die Tatsache, dass jeder Parameter eine separate Zeichenkette ist. Der zweite Unterschied ist, dass es praktisch keine Grenze gibt, wie viele Parameter vorhanden sein können.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ausgerüstet mit diesen Kenntnissen, sind wir beinahe bereit für eine weitere Version von <span class=filename>hex.asm</span>. Zuerst müssen wir jedoch noch ein paar Zeilen zu <span class=filename>system.inc</span> hinzufügen:</p></div><div class=paragraph><p>Erstens benötigen wir zwei neue Einträge in unserer Liste mit den Systemaufrufnummern:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_open	5
%define	SYS_close	6</pre></div></div><div class=paragraph><p>Zweitens fügen wir zwei neue Makros am Ende der Datei ein:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.open	0
	system	SYS_open
%endmacro

%macro	sys.close	0
	system	SYS_close
%endmacro</pre></div></div><div class=paragraph><p>Und hier ist schließlich unser veränderter Quelltext:</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
err:
	push	dword 1		; return failure
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to input file
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	err		; open failed

	add	esp, byte 8
	mov	[fd.in], eax

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to output file
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	err

	add	esp, byte 12
	mov	[fd.out], eax

.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from input file or stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	cmp	al, dl
	jne	.loop
	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>In unserem <code>.data</code>-Abschnitt befinden sich nun die zwei neuen Variablen <code>fd.in</code> und <code>fd.out</code>. Hier legen wir die Dateideskriptoren der Ein- und Ausgabedatei ab.</p></div><div class=paragraph><p>Im <code>.text</code>-Abschnitt haben wir die Verweise auf <code>stdin</code> und <code>stdout</code> durch <code>[fd.in]</code> und <code>[fd.out]</code> ersetzt.</p></div><div class=paragraph><p>Der <code>.text</code>-Abschnitt beginnt nun mit einer einfachen Fehlerbehandlung, welche nur das Programm mit einem Rückgabewert von <span class=constant>1</span> beendet. Die Fehlerbehandlung befindet sich vor <code>_start</code>, sodass wir in geringer Entfernung von der Stelle sind, an der der Fehler auftritt.</p></div><div class=paragraph><p>Selbstverständlich beginnt die Programmausführung immer noch bei <code>_start</code>. Zuerst entfernen wir <code>argc</code> und <code>argv[0]</code> vom Stack: Sie sind für uns nicht von Interesse (sprich, in diesem Programm).</p></div><div class=paragraph><p>Wir nehmen <code>argv[1]</code> vom Stack und legen es in <code>ECX</code> ab. Dieses Register ist besonders für Zeiger geeignet, da wir mit <code>jecxz</code> NULL-Zeiger verarbeiten können. Falls <code>argv[1]</code> nicht NULL ist, versuchen wir, die Datei zu öffnen, die der erste Parameter festlegt. Andernfalls fahren wir mit dem Programm fort wie vorher: Lesen von <code>stdin</code> und Schreiben nach <code>stdout</code>. Falls wir die Eingabedatei nicht öffnen können (z.B. sie ist nicht vorhanden), springen wir zur Fehlerbehandlung und beenden das Programm.</p></div><div class=paragraph><p>Falls es keine Probleme gibt, sehen wir nun nach dem zweiten Parameter. Falls er vorhanden ist, öffnen wir die Ausgabedatei. Andernfalls schreiben wir die Ausgabe nach <code>stdout</code>. Falls wir die Ausgabedatei nicht öffnen können (z.B. sie ist zwar vorhanden, aber wir haben keine Schreibberechtigung), springen wir auch wieder in die Fehlerbehandlung.</p></div><div class=paragraph><p>Der Rest des Codes ist derselbe wie vorher, außer dem Schließen der Ein- und Ausgabedatei vor dem Verlassen des Programms und, wie bereits erwähnt, die Benutzung von <code>[fd.in]</code> und <code>[fd.out]</code>.</p></div><div class=paragraph><p>Unsere Binärdatei ist nun kolossale 768 Bytes groß.</p></div><div class=paragraph><p>Können wir das Programm immer noch verbessern? Natürlich! Jedes Programm kann verbessert werden. Hier finden sich einige Ideen, was wir tun könnten:</p></div><div class=ulist><ul><li><p>Die Fehlerbehandlung eine Warnung auf <code>stderr</code> ausgeben lassen.</p></li><li><p>Den <code>Lese</code>- und <code>Schreib</code>funkionen eine Fehlerbehandlung hinzufügen.</p></li><li><p>Schließen von <code>stdin</code>, sobald wir eine Eingabedatei öffnen, von <code>stdout</code>, sobald wir eine Ausgabedatei öffnen.</p></li><li><p>Hinzufügen von Kommandozeilenschaltern wie zum Beispiel <span class=parameter>-i</span> und <span class=parameter>-o</span>, sodass wir die Ein- und Ausgabedatei in irgendeiner Reihenfolge angeben oder vielleicht von <code>stdin</code> lesen und in eine Datei schreiben können.</p></li><li><p>Ausgeben einer Gebrauchsanweisung, falls die Kommandozeilenparameter fehlerhaft sind.</p></li></ul></div><div class=paragraph><p>Ich beabsichtige, diese Verbesserungen dem Leser als Übung zu hinterlassen: Sie wissen bereits alles, das Sie wissen müssen, um die Verbesserungen durchzuführen.</p></div></div></div><div class=sect1><h2 id=x86-environment>11.10. Die UNIX®-Umgebung<a class=anchor href=#x86-environment></a></h2><div class=sectionbody><div class=paragraph><p>Ein entscheidendes Konzept hinter UNIX® ist die Umgebung, die durch <em>Umgebungsvariablen</em> festgelegt wird. Manche werden vom System gesetzt, andere von Ihnen und wieder andere von der shell oder irgendeinem Programm, das ein anderes lädt.</p></div><div class=sect2><h3 id=x86-find-environment>11.10.1. Umgebungsvariablen herausfinden<a class=anchor href=#x86-find-environment></a></h3><div class=paragraph><p>Ich sagte vorher, dass wenn ein Programm mit der Ausführung beginnt, der Stack <code>argc</code> gefolgt vom durch NULL beendeten <code>argv</code>-Array und etwas Anderem enthält. Das "etwas Andere" ist die <em>Umgebung</em> oder, um genauer zu sein, ein durch NULL beendetes Array von Zeigern auf <em>Umgebungsvariablen</em>. Davon wird oft als <code>env</code> gesprochen.</p></div><div class=paragraph><p>Der Aufbau von <code>env</code> entspricht dem von <code>argv</code>, eine Liste von Speicheradressen gefolgt von NULL (<span class=constant>0</span>). In diesem Fall gibt es kein <code>"envc"</code>-wir finden das Ende heraus, indem wir nach dem letzten NULL suchen.</p></div><div class=paragraph><p>Die Variablen liegen normalerweise in der Form <code>name=value</code> vor, aber manchmal kann der <code>=value</code>-Teil fehlen. Wir müssen diese Möglichkeit in Betracht ziehen.</p></div></div><div class=sect2><h3 id=x86-webvar>11.10.2. webvars<a class=anchor href=#x86-webvar></a></h3><div class=paragraph><p>Ich könnte Ihnen einfach etwas Code zeigen, der die Umgebung in der Art vom UNIX®-Befehl env ausgibt. Aber ich dachte, dass es interessanter sei, ein einfaches CGI-Werkzeug in Assembler zu schreiben.</p></div><div class=sect3><h4 id=x86-cgi>11.10.2.1. CGI: Ein kurzer Überblick<a class=anchor href=#x86-cgi></a></h4><div class=paragraph><p>Ich habe eine <a href=http://www.whizkidtech.redprince.net/cgi-bin/tutorial>detaillierte CGI-Anleitung</a> auf meiner Webseite, aber hier ist ein sehr kurzer Überblick über CGI:</p></div><div class=ulist><ul><li><p>Der Webserver kommuniziert mit dem CGI-Programm, indem er <em>Umgebungsvariablen</em> setzt.</p></li><li><p>Das CGI-Programm schreibt seine Ausgabe auf <span class=filename>stdout</span>. Der Webserver liest von da.</p></li><li><p>Die Ausgabe muss mit einem HTTP-Kopfteil gefolgt von zwei Leerzeilen beginnen.</p></li><li><p>Das Programm gibt dann den HTML-Code oder was für einen Datentyp es auch immer verarbeitet aus.
*</p></li></ul></div><div class=exampleblock><div class=content><div class=paragraph><p>Während bestimmte <em>Umgebungsvariablen</em> Standardnamen benutzen, unterscheiden sich andere, abhängig vom Webserver. Dies macht webvars zu einem recht nützlichen Werkzeug.</p></div></div></div></div><div class=sect3><h4 id=x86-webvars-the-code>11.10.2.2. Der Code<a class=anchor href=#x86-webvars-the-code></a></h4><div class=paragraph><p>Unser webvars-Programm muss also den HTTP-Kopfteil gefolgt von etwas HTML-Auszeichnung versenden. Dann muss es die <em>Umgebungsvariablen</em> eine nach der anderen auslesen und sie als Teil der HTML-Seite versenden.</p></div><div class=paragraph><p>Nun der Code. Ich habe Kommentare und Erklärungen direkt in den Code eingefügt:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; webvars.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (c) 2000 G. Adam Stanislav
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 1. Redistributions of source code must retain the above copyright
;    notice, this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
; SUCH DAMAGE.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Version 1.0
;
; Started:	 8-Dec-2000
; Updated:	 8-Dec-2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	&#39;system.inc&#39;

section	.data
http	db	&#39;Content-type: text/html&#39;, 0Ah, 0Ah
	db	&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;&#39;, 0Ah
	db	&#39;&lt;!DOCTYPE html PUBLIC &#34;-//W3C/DTD XHTML Strict//EN&#34; &#39;
	db	&#39;&#34;DTD/xhtml1-strict.dtd&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;html xmlns=&#34;http://www.w3.org/1999/xhtml&#34; &#39;
	db	&#39;xml.lang=&#34;en&#34; lang=&#34;en&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;head&gt;&#39;, 0Ah
	db	&#39;&lt;title&gt;Web Environment&lt;/title&gt;&#39;, 0Ah
	db	&#39;&lt;meta name=&#34;author&#34; content=&#34;G. Adam Stanislav&#34; /&gt;&#39;, 0Ah
	db	&#39;&lt;/head&gt;&#39;, 0Ah, 0Ah
	db	&#39;&lt;body bgcolor=&#34;#ffffff&#34; text=&#34;#000000&#34; link=&#34;#0000ff&#34; &#39;
	db	&#39;vlink=&#34;#840084&#34; alink=&#34;#0000ff&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;div class=&#34;webvars&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;h1&gt;Web Environment&lt;/h1&gt;&#39;, 0Ah
	db	&#39;&lt;p&gt;The following &lt;b&gt;environment variables&lt;/b&gt; are defined &#39;
	db	&#39;on this web server:&lt;/p&gt;&#39;, 0Ah, 0Ah
	db	&#39;&lt;table align=&#34;center&#34; width=&#34;80&#34; border=&#34;0&#34; cellpadding=&#34;10&#34; &#39;
	db	&#39;cellspacing=&#34;0&#34; class=&#34;webvars&#34;&gt;&#39;, 0Ah
httplen	equ	$-http
left	db	&#39;&lt;tr&gt;&#39;, 0Ah
	db	&#39;&lt;td class=&#34;name&#34;&gt;&lt;tt&gt;&#39;
leftlen	equ	$-left
middle	db	&#39;&lt;/tt&gt;&lt;/td&gt;&#39;, 0Ah
	db	&#39;&lt;td class=&#34;value&#34;&gt;&lt;tt&gt;&lt;b&gt;&#39;
midlen	equ	$-middle
undef	db	&#39;&lt;i&gt;(undefined)&lt;/i&gt;&#39;
undeflen	equ	$-undef
right	db	&#39;&lt;/b&gt;&lt;/tt&gt;&lt;/td&gt;&#39;, 0Ah
	db	&#39;&lt;/tr&gt;&#39;, 0Ah
rightlen	equ	$-right
wrap	db	&#39;&lt;/table&gt;&#39;, 0Ah
	db	&#39;&lt;/div&gt;&#39;, 0Ah
	db	&#39;&lt;/body&gt;&#39;, 0Ah
	db	&#39;&lt;/html&gt;&#39;, 0Ah, 0Ah
wraplen	equ	$-wrap

section	.text
global	_start
_start:
	; First, send out all the http and xhtml stuff that is
	; needed before we start showing the environment
	push	dword httplen
	push	dword http
	push	dword stdout
	sys.write

	; Now find how far on the stack the environment pointers
	; are. We have 12 bytes we have pushed before &#34;argc&#34;
	mov	eax, [esp+12]

	; We need to remove the following from the stack:
	;
	;	The 12 bytes we pushed for sys.write
	;	The  4 bytes of argc
	;	The EAX*4 bytes of argv
	;	The  4 bytes of the NULL after argv
	;
	; Total:
	;	20 + eax * 4
	;
	; Because stack grows down, we need to ADD that many bytes
	; to ESP.
	lea	esp, [esp+20+eax*4]
	cld		; This should already be the case, but let&#39;s be sure.

	; Loop through the environment, printing it out
.loop:
	pop	edi
	or	edi, edi	; Done yet?
	je	near .wrap

	; Print the left part of HTML
	push	dword leftlen
	push	dword left
	push	dword stdout
	sys.write

	; It may be tempting to search for the &#39;=&#39; in the env string next.
	; But it is possible there is no &#39;=&#39;, so we search for the
	; terminating NUL first.
	mov	esi, edi	; Save start of string
	sub	ecx, ecx
	not	ecx		; ECX = FFFFFFFF
	sub	eax, eax
repne	scasb
	not	ecx		; ECX = string length + 1
	mov	ebx, ecx	; Save it in EBX

	; Now is the time to find &#39;=&#39;
	mov	edi, esi	; Start of string
	mov	al, &#39;=&#39;
repne	scasb
	not	ecx
	add	ecx, ebx	; Length of name

	push	ecx
	push	esi
	push	dword stdout
	sys.write

	; Print the middle part of HTML table code
	push	dword midlen
	push	dword middle
	push	dword stdout
	sys.write

	; Find the length of the value
	not	ecx
	lea	ebx, [ebx+ecx-1]

	; Print &#34;undefined&#34; if 0
	or	ebx, ebx
	jne	.value

	mov	ebx, undeflen
	mov	edi, undef

.value:
	push	ebx
	push	edi
	push	dword stdout
	sys.write

	; Print the right part of the table row
	push	dword rightlen
	push	dword right
	push	dword stdout
	sys.write

	; Get rid of the 60 bytes we have pushed
	add	esp, byte 60

	; Get the next variable
	jmp	.loop

.wrap:
	; Print the rest of HTML
	push	dword wraplen
	push	dword wrap
	push	dword stdout
	sys.write

	; Return success
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>Dieser Code erzeugt eine 1.396-Byte große Binärdatei. Das meiste davon sind Daten, d.h., die HTML-Auszeichnung, die wir versenden müssen.</p></div><div class=paragraph><p>Assemblieren Sie es wie immer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf webvars.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> webvars webvars.o</code></pre></div></div><div class=paragraph><p>Um es zu benutzen, müssen Sie <span class=filename>webvars</span> auf Ihren Webserver hochladen. Abhängig von Ihrer Webserver-Konfiguration, müssen Sie es vielleicht in einem speziellen <span class=filename>cgi-bin</span>-Verzeichnis ablegen oder es mit einer <span class=filename>.cgi</span>-Dateierweiterung versehen.</p></div><div class=paragraph><p>Schließlich benötigen Sie Ihren Webbrowser, um sich die Ausgabe anzusehen. Um die Ausgabe auf meinem Webserver zu sehen, gehen Sie bitte auf <a href=http://www.int80h.org/webvars/>http://www.int80h.org/webvars/</a>. Falls Sie neugierig sind, welche zusätzlichen Variablen in einem passwortgeschützten Webverzeichnis vorhanden sind, gehen Sie auf <a href=http://www.int80h.org/private/>http://www.int80h.org/private/</a> unter Benutzung des Benutzernamens <code>asm</code> und des Passworts <code>programmer</code>.</p></div></div></div></div></div><div class=sect1><h2 id=x86-files>11.11. Arbeiten mit Dateien<a class=anchor href=#x86-files></a></h2><div class=sectionbody><div class=paragraph><p>Wir haben bereits einfache Arbeiten mit Dateien gemacht: Wir wissen wie wir sie öffnen und schliessen, oder wie man sie mit Hilfe von Buffern liest und schreibt. Aber UNIX® bietet viel mehr Funktionalität wenn es um Dateien geht. Wir werden einige von ihnen in dieser Sektion untersuchen und dann mit einem netten Datei Konvertierungs Werkzeug abschliessen.</p></div><div class=paragraph><p>In der Tat, Lasst uns am Ende beginnen, also mit dem Datei Konvertierungs Werkzeug. Es macht Programmieren immer einfacher, wenn wir bereits am Anfang wissen was das End Produkt bezwecken soll.</p></div><div class=paragraph><p>Eines der ersten Programme die ich für UNIX® schrieb war <a href=ftp://ftp.int80h.org/unix/tuc/>tuc</a>, ein Text-Zu-UNIX® Datei Konvertierer. Es konvertiert eine Text Datei von einem anderen Betriebssystem zu einer UNIX® Text Datei. Mit anderen Worten, es ändert die verschiedenen Arten von Zeilen Begrenzungen zu der Zeilen Begrenzungs Konvention von UNIX®. Es speichert die Ausgabe in einer anderen Datei. Optional konvertiert es eine UNIX® Text Datei zu einer DOS Text Datei.</p></div><div class=paragraph><p>Ich habe tuc sehr oft benutzt, aber nur von irgendeinem anderen OS nach UNIX® zu konvertieren, niemals anders herum. Ich habe mir immer gewünscht das die Datei einfach überschrieben wird anstatt das ich die Ausgabe in eine andere Datei senden muss. Meistens, habe ich diesen Befehl verwendet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% tuc myfile tempfile
% <span class=nb>mv </span>tempfile myfile</code></pre></div></div><div class=paragraph><p>Es wäre schö ein ftuc zu haben, also, <em>fast tuc</em>, und es so zu benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ftuc myfile</code></pre></div></div><div class=paragraph><p>In diesem Kapitel werden wir dann, ftuc in Assembler schreiben (das Original tuc ist in C), und verschiedene Datei-Orientierte Kernel Dienste in dem Prozess studieren.</p></div><div class=paragraph><p>Auf erste Sicht, ist so eine Datei Konvertierung sehr simpel: Alles was du zu tun hast, ist die Wagenrückläufe zu entfernen, richtig?</p></div><div class=paragraph><p>Wenn du mit ja geantwortet hast, denk nochmal darüber nach: Dieses Vorgehen wird die meiste Zeit funktionieren (zumindest mit MSDOS Text Dateien), aber gelegentlich fehlschlagen.</p></div><div class=paragraph><p>Das Problem ist das nicht alle UNIX® Text Dateien ihre Zeilen mit einer Wagen Rücklauf / Zeilenvorschub Sequenz beenden. Manche benutzen Wagenrücklauf ohne Zeilenvorschub. Andere kombinieren mehrere leere Zeilen in einen einzigen Wagenrücklauf gefolgt von mehreren Zeilenvorschüben. Und so weiter.</p></div><div class=paragraph><p>Ein Text Datei Konvertierer muss dann also in der Lage sein mit allen möglichen Zeilenenden umzugehen:</p></div><div class=ulist><ul><li><p>Wagenrücklauf / Zeilenvorschub</p></li><li><p>Wagenrücklauf</p></li><li><p>Zeilenvorschub / Wagenrücklauf</p></li><li><p>Zeilenvorschub</p></li></ul></div><div class=paragraph><p>Es sollte außerdem in der Lage sein mit Dateien umzugehen die irgendeine Art von Kombination der oben stehenden Möglichkeiten verwendet. (z.B., Wagenrücklauf gefolgt von mehreren Zeilenvorschüben).</p></div><div class=sect2><h3 id=x86-finite-state-machine>11.11.1. Endlicher Zustandsautomat<a class=anchor href=#x86-finite-state-machine></a></h3><div class=paragraph><p>Das Problem wird einfach gelöst in dem man eine Technik benutzt die sich <em>Endlicher Zustandsautomat</em> nennt, ursprünglich wurde sie von den Designern digitaler elektronischer Schaltkreise entwickelt. Eine <em>Endlicher Zustandsautomat</em> ist ein digitaler Schaltkreis dessen Ausgabe nicht nur von der Eingabe abhängig ist sondern auch von der vorherigen Eingabe, d.h., von seinem Status. Der Mikroprozessor ist ein Beispiel für einen <em>Endlichen Zustandsautomaten</em>: Unser Assembler Sprach Code wird zu Maschinensprache übersetzt in der manche Assembler Sprach Codes ein einzelnes Byte produzieren, während andere mehrere Bytes produzieren. Da der Microprozessor die Bytes einzeln aus dem Speicher liest, ändern manche nur seinen Status anstatt eine Ausgabe zu produzieren. Wenn alle Bytes eines OP Codes gelesen wurden, produziert der Mikroprozessor eine Ausgabe, oder ändert den Wert eines Registers, etc.</p></div><div class=paragraph><p>Aus diesem Grund, ist jede Software eigentlich nur eine Sequenz von Status Anweisungen für den Mikroprozessor. Dennoch, ist das Konzept eines <em>Endlichen Zustandsautomaten</em> auch im Software Design sehr hilfreich.</p></div><div class=paragraph><p>Unser Text Datei Konvertierer kann als <em>Endlicher Zustandsautomat</em> mit 3 möglichen Stati desgined werden. Wir könnten diese von 0-2 benennen, aber es wird uns das Leben leichter machen wenn wir ihnen symbolische Namen geben:</p></div><div class=ulist><ul><li><p>ordinary</p></li><li><p>cr</p></li><li><p>lf</p></li></ul></div><div class=paragraph><p>Unser Programm wird in dem ordinary Status starten. Während dieses Status, hängt die Aktion des Programms von seiner Eingabe wie folgt ab:</p></div><div class=ulist><ul><li><p>Wenn die Eingabe etwas anderes als ein Wagenrücklauf oder einem Zeilenvorschub ist, wird die Eingabe einfach nur an die Ausgabe geschickt. Der Status bleibt unverändert.</p></li><li><p>Wenn die Eingabe ein Wagenrücklauf ist, wird der Status auf cr gesetzt. Die Eingabe wird dann verworfen, d.h., es entsteht keine Ausgabe.</p></li><li><p>Wenn die Eingabe ein Zeilenvorschub ist, wird der Status auf lf gesetzt. Die Eingabe wird dann verworfen.</p></li></ul></div><div class=paragraph><p>Wann immer wir in dem cr Status sind, ist das weil die letzte Eingabe ein Wagenrücklauf war, welcher nicht verarbeitet wurde. Was unsere Software in diesem Status macht hängt von der aktuellen Eingabe ab:</p></div><div class=ulist><ul><li><p>Wenn die Eingabe irgendetwas anderes als ein Wagenrücklauf oder ein Zeilenvorschub ist, dann gib einen Zeilenvorschub aus, dann gib die Eingabe aus und dann ändere den Status zu ordinary.</p></li><li><p>Wenn die Eingabe ein Wagenrücklauf ist, haben wir zwei (oder mehr) Wagenrückläufe in einer Reihe. Wir verwerfen die Eingabe, wir geben einen Zeilenvorschub aus und lassen den Status unverändert.</p></li><li><p>Wenn die Eingabe ein Zeilenvorschub ist, geben wir den Zeilenvorschub aus und ändern den Status zu ordinary. Achte darauf, dass das nicht das gleiche wie in dem Fall oben drüber ist - würden wir versuchen beide zu kombinieren, würden wir zwei Zeilenvorschübe anstatt einen ausgeben.</p></li></ul></div><div class=paragraph><p>Letztendlich, sind wir in dem lf Status nachdem wir einen Zeilenvorschub empfangen haben der nicht nach einem Wagenrücklauf kam. Das wird passieren wenn unsere Datei bereits im UNIX® Format ist, oder jedesmal wenn mehrere Zeilen in einer Reihe durch einen einzigen Wagenrücklauf gefolgt von mehreren Zeilenvorschüben ausgedrückt wird, oder wenn die Zeile mit einer Zeilenvorschub / Wagenrücklauf Sequenz endet. Wir sollten mit unserer Eingabe in diesem Status folgendermaßen umgehen:</p></div><div class=ulist><ul><li><p>Wenn die Eingabe irgendetwas anderes als ein Wagenrücklauf oder ein Zeilenvorschub ist, geben wir einen Zeilenvorschub aus, geben dann die Eingabe aus und ändern dann den Status zu ordinary. Das ist exakt die gleiche Aktion wie in dem cr Status nach dem Empfangen der selben Eingabe.</p></li><li><p>Wenn die Eingabe ein Wagenrücklauf ist, verwerfen wir die Eingabe, geben einen Zeilenvorschub aus und ändern dann den Status zu ordinary.</p></li><li><p>Wenn die Eingabe ein Zeilenvorschub ist, geben wir den Zeilenvorschub aus und lassen den Status unverändert.</p></li></ul></div><div class=sect3><h4 id=x86-final-state>11.11.1.1. Der Endgültige Status<a class=anchor href=#x86-final-state></a></h4><div class=paragraph><p>Der obige <em>Endliche Zustandsautomat</em> funktioniert für die gesamte Datei, aber lässt die Möglichkeit das die letzte Zeile ignoriert wird. Das wird jedesmal passieren wenn die Datei mit einem einzigen Wagenrücklauf oder einem einzigen Zeilenvorschub endet. Daran habe ich nicht gedacht als ich tuc schrieb, nur um festzustellen, daß das letzte Zeilenende gelegentlich weggelassen wird.</p></div><div class=paragraph><p>Das Problem wird einfach dadurch gelöst, indem man den Status überprüft nachdem die gesamte Datei verarbeitet wurde. Wenn der Status nicht ordinary ist, müssen wir nur den letzten Zeilenvorschub ausgeben.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nachdem wir unseren Algorithmus nun als einen <em>Endlichen Zustandsautomaten</em> formuliert haben, könnten wir einfach einen festgeschalteten digitalen elektronischen Schaltkreis (einen "Chip") designen, der die Umwandlung für uns übernimmt. Natürlich wäre das sehr viel teurer, als ein Assembler Programm zu schreiben.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-tuc-counter>11.11.1.2. Der Ausgabe Zähler<a class=anchor href=#x86-tuc-counter></a></h4><div class=paragraph><p>Weil unser Datei Konvertierungs Programm möglicherweise zwei Zeichen zu einem kombiniert, müssen wir einen Ausgabe Zähler verwenden. Wir initialisieren den Zähler zu <span class=constant>0</span> und erhöhen ihn jedes mal wenn wir ein Zeichen an die Ausgabe schicken. Am Ende des Programms, wird der Zähler uns sagen auf welche Grösse wir die Datei setzen müssen.</p></div></div></div><div class=sect2><h3 id=x86-software-fsm>11.11.2. Implementieren von EZ als Software<a class=anchor href=#x86-software-fsm></a></h3><div class=paragraph><p>Der schwerste Teil beim arbeiten mit einer <em>Endlichen Zustandsmaschine</em> ist das analysieren des Problems und dem ausdrücken als eine <em>Endliche Zustandsmaschine</em>. That geschafft, schreibt sich die Software fast wie von selbst.</p></div><div class=paragraph><p>In eine höheren Sprache, wie etwa C, gibt es mehrere Hauptansätze. Einer wäre ein <code>switch</code> Angabe zu verwenden die auswählt welche Funktion genutzt werden soll. Zum Beispiel,</p></div><div class="literalblock programlisting"><div class=content><pre>	switch (state) {
	default:
	case REGULAR:
		regular(inputchar);
		break;
	case CR:
		cr(inputchar);
		break;
	case LF:
		lf(inputchar);
		break;
	}</pre></div></div><div class=paragraph><p>Ein anderer Ansatz ist es ein Array von Funktions Zeigern zu benutzen, etwa wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>	(output[state])(inputchar);</pre></div></div><div class=paragraph><p>Noch ein anderer ist es aus <code>state</code> einen Funktions Zeiger zu machen und ihn zu der entsprechenden Funktion zeigen zu lassen:</p></div><div class="literalblock programlisting"><div class=content><pre>	(*state)(inputchar);</pre></div></div><div class=paragraph><p>Das ist der Ansatz den wir in unserem Programm verwenden werden, weil es in Assembler sehr einfach und schnell geht. Wir werden einfach die Adresse der Prozedur in <code>EBX</code> speichern und dann einfach das ausgeben:</p></div><div class="literalblock programlisting"><div class=content><pre>	call	ebx</pre></div></div><div class=paragraph><p>Das ist wahrscheinlich schneller als die Adresse im Code zu hardcoden weil der Mikroprozessor die Adresse nicht aus dem Speicher lesen muss-es ist bereits in einer der Register gespeichert. Ich sagte <em>wahrscheinlich</em> weil durch das Cachen neuerer Mikroprozessoren beide Varianten in etwa gleich schnell sind.</p></div></div><div class=sect2><h3 id=memory-mapped-files>11.11.3. Speicher abgebildete Dateien<a class=anchor href=#memory-mapped-files></a></h3><div class=paragraph><p>Weil unser Programm nur mit einzelnen Dateien funktioniert, können wir nicht den Ansatz verwedenden der zuvor funktioniert hat, d.h., von einer Eingabe Datei zu lesen und in eine Ausgabe Datei zu schreiben.</p></div><div class=paragraph><p>UNIX® erlaubt es uns eine Datei, oder einen Bereich einer Datei, in den Speicher abzubilden. Um das zu tun, müssen wir zuerst eine Datei mit den entsprechenden Lese/Schreib Flags öffnen. Dann benutzen wir den <code>mmap</code> system call um sie in den Speicher abzubilden. Ein Vorteil von <code>mmap</code> ist, das es automatisch mit virtuellem Speicher arbeitet: Wir können mehr von der Datei im Speicher abbilden als wir überhaupt physikalischen Speicher zur Verfügung haben, noch immer haben wir aber durch normale OP Codes wie <code>mov</code>, <code>lods</code>, und <code>stos</code> Zugriff darauf. Egal welche Änderungen wir an dem Speicherabbild der Datei vornehmen, sie werden vom System in die Datei geschrieben. Wir müssen die Datei nicht offen lassen: So lange sie abgebildet bleibt, können wir von ihr lesen und in sie schreiben.</p></div><div class=paragraph><p>Ein 32-bit Intel Mikroprozessor kann auf bis zu vier Gigabyte Speicher zugreifen - physisch oder virtuell. Das FreeBSD System erlaubt es uns bis zu der Hälfte für die Datei Abbildung zu verwenden.</p></div><div class=paragraph><p>Zur Vereinfachung, werden wir in diesem Tutorial nur Dateien konvertieren die in ihrere Gesamtheit im Speicher abgebildet werden können. Es gibt wahrscheinlich nicht all zu viele Text Dateien die eine Grösse von zwei Gigabyte überschreiben. Falls unser Programm doch auf eine trifft, wird es einfach eine Meldung anzeigen mit dem Vorschlag das originale tuc statt dessen zu verwenden.</p></div><div class=paragraph><p>Wenn du deine Kopie von <span class=filename>syscalls.master</span> überprüfst, wirst du zwei verschiedene Systemaufrufe finden die sich <code>mmap</code> nennen. Das kommt von der Entwicklung von UNIX®: Es gab das traditionelle BSD<code>mmap</code>, Systemaufruf 71. Dieses wurde durch das POSIX® <code>mmap</code> ersetzt, Systemaufruf 197. Das FreeBSD System unterstützt beide, weil ältere Programme mit der originalen BSD Version geschrieben wurden. Da neue Software die POSIX® Version nutzt, werden wir diese auch verwenden.</p></div><div class=paragraph><p>Die <span class=filename>syscalls.master</span> Datei zeigt die POSIX® Version wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>197	STD	BSD	{ caddr_t mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }</pre></div></div><div class=paragraph><p>Das weicht etwas von dem ab was <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> sagt. Das ist weil <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> die C Version beschreibt.</p></div><div class=paragraph><p>Der Unterschiede liegt in dem <code>long pad</code> Argument, welches in der C Version nicht vorhanden ist. Wie auch immer, der FreeBSD Systemaufruf fügt einen 32-bit Block ein nachdem es ein 64-Bit Argument auf den Stack ge<code>push</code>t hat. In diesem Fall, ist <code>off_t</code> ein 64-Bit Wert.</p></div><div class=paragraph><p>Wenn wir fertig sind mit dem Arbeiten einer im Speicher abgebildeten Datei, entfernen wir das Speicherabbild mit dem <code>munmap</code> Systemaufruf:</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Für eine detailliert Behandlung von <code>mmap</code>, sieh in W. Richard Stevens' <a href="http://www.int80h.org/cgi-bin/isbn?isbn=0130810819">Unix Network Programming, Volume 2, Chapter 12</a> nach.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=x86-file-size>11.11.4. Feststellen der Datei Grösse<a class=anchor href=#x86-file-size></a></h3><div class=paragraph><p>Weil wir <code>mmap</code> sagen müssen wie viele Bytes von Datei wir im Speicher abbilden wollen und wir außerdem die gesamte Datei abbilden wollen, müssen wir die Grösse der Datei feststellen.</p></div><div class=paragraph><p>Wir können den <code>fstat</code> Systemaufruf verwenden um alle Informationen über eine geöffnete Datei zu erhalten die uns das System geben kann. Das beinhaltet die Datei Grösse.</p></div><div class=paragraph><p>Und wieder, zeigt uns <span class=filename>syscalls.master</span> zwei Versionen von <code>fstat</code>, eine traditionelle (Systemaufruf 62), und eine POSIX® (Systemaufruf 189) Variante. Natürlich, verwenden wir die POSIX® Version:</p></div><div class="literalblock programlisting"><div class=content><pre>189	STD	POSIX	{ int fstat(int fd, struct stat *sb); }</pre></div></div><div class=paragraph><p>Das ist ein sehr unkomplizierter Aufruf: Wir übergeben ihm die Adresse einer <code>stat</code> Structure und den Deskriptor einer geöffneten Datei. Es wird den Inhalt der <code>stat</code> Struktur ausfüllen.</p></div><div class=paragraph><p>Ich muss allerdings sagen, das ich versucht habe die <code>stat</code> Struktur in dem <code>.bss</code> Bereich zu deklarieren, und <code>fstat</code> mochte es nicht: Es setzte das Carry Flag welches einen Fehler anzeigt. Nachdem ich den Code veränderte so dass er die Struktur auf dem Stack anlegt, hat alles gut funktioniert.</p></div></div><div class=sect2><h3 id=x86-ftruncate>11.11.5. Ändern der Dateigrösse<a class=anchor href=#x86-ftruncate></a></h3><div class=paragraph><p>Dadurch das unser Programm Wagenrücklauf/Zeilenvorschub-Sequenzen in einfache Zeilenvorschübe zusammenfassen könnte, könnte unsere Ausgabe kleiner sein als unsere Eingabe. Und da wir die Ausgabe in dieselbe Datei um, aus der wir unsere Eingabe erhalten, müssen wir eventuell die Dateigrösse anpassen.</p></div><div class=paragraph><p>Der Systemaufruf <code>ftruncate</code> erlaubt uns, dies zu tun. Abgesehen von dem etwas unglücklich gewählten Namen <code>ftruncate</code> können wir mit dieser Funktion eine Datei vergrössern, oder verkleinern.</p></div><div class=paragraph><p>Und ja, wir werden zwei Versionen von <code>ftruncate</code> in <span class=filename>syscalls.master</span> finden, eine ältere (130) und eine neuere (201). Wir werden die neuere Version verwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>201	STD	BSD	{ int ftruncate(int fd, int pad, off_t length); }</pre></div></div><div class=paragraph><p>Beachten Sie bitte, dass hier wieder <code>int pad</code> verwendet wird.</p></div></div><div class=sect2><h3 id=x86-ftuc>11.11.6. ftuc<a class=anchor href=#x86-ftuc></a></h3><div class=paragraph><p>Wir wissen jetzt alles nötige, um ftuc zu schreiben. Wir beginnen, indem wir ein paar neue Zeilen der Datei <span class=filename>system.inc</span> hinzufügen. Als erstes definieren wir irgendwo am Anfang der Datei einige Konstanten und Strukturen:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; open flags
%define	O_RDONLY	0
%define	O_WRONLY	1
%define	O_RDWR	2

;;;;;;; mmap flags
%define	PROT_NONE	0
%define	PROT_READ	1
%define	PROT_WRITE	2
%define	PROT_EXEC	4
;;
%define	MAP_SHARED	0001h
%define	MAP_PRIVATE	0002h

;;;;;;; stat structure
struc	stat
st_dev		resd	1	; = 0
st_ino		resd	1	; = 4
st_mode		resw	1	; = 8, size is 16 bits
st_nlink	resw	1	; = 10, ditto
st_uid		resd	1	; = 12
st_gid		resd	1	; = 16
st_rdev		resd	1	; = 20
st_atime	resd	1	; = 24
st_atimensec	resd	1	; = 28
st_mtime	resd	1	; = 32
st_mtimensec	resd	1	; = 36
st_ctime	resd	1	; = 40
st_ctimensec	resd	1	; = 44
st_size		resd	2	; = 48, size is 64 bits
st_blocks	resd	2	; = 56, ditto
st_blksize	resd	1	; = 64
st_flags	resd	1	; = 68
st_gen		resd	1	; = 72
st_lspare	resd	1	; = 76
st_qspare	resd	4	; = 80
endstruc</pre></div></div><div class=paragraph><p>Wir definieren die neuen Systemaufrufe:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_mmap	197
%define	SYS_munmap	73
%define	SYS_fstat	189
%define	SYS_ftruncate	201</pre></div></div><div class=paragraph><p>Wir fügen die Makros hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.mmap	0
	system	SYS_mmap
%endmacro

%macro	sys.munmap	0
	system	SYS_munmap
%endmacro

%macro	sys.ftruncate	0
	system	SYS_ftruncate
%endmacro

%macro	sys.fstat	0
	system	SYS_fstat
%endmacro</pre></div></div><div class=paragraph><p>Und hier ist unser Code:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; Fast Text-to-Unix Conversion (ftuc.asm) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Started:	21-Dec-2000
;; Updated:	22-Dec-2000
;;
;; Copyright 2000 G. Adam Stanislav.
;; All rights reserved.
;;
;;;;;;; v.1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	&#39;system.inc&#39;

section	.data
	db	&#39;Copyright 2000 G. Adam Stanislav.&#39;, 0Ah
	db	&#39;All rights reserved.&#39;, 0Ah
usg	db	&#39;Usage: ftuc filename&#39;, 0Ah
usglen	equ	$-usg
co	db	&#34;ftuc: Can&#39;t open file.&#34;, 0Ah
colen	equ	$-co
fae	db	&#39;ftuc: File access error.&#39;, 0Ah
faelen	equ	$-fae
ftl	db	&#39;ftuc: File too long, use regular tuc instead.&#39;, 0Ah
ftllen	equ	$-ftl
mae	db	&#39;ftuc: Memory allocation error.&#39;, 0Ah
maelen	equ	$-mae

section	.text

align 4
memerr:
	push	dword maelen
	push	dword mae
	jmp	short error

align 4
toolong:
	push	dword ftllen
	push	dword ftl
	jmp	short error

align 4
facerr:
	push	dword faelen
	push	dword fae
	jmp	short error

align 4
cantopen:
	push	dword colen
	push	dword co
	jmp	short error

align 4
usage:
	push	dword usglen
	push	dword usg

error:
	push	dword stderr
	sys.write

	push	dword 1
	sys.exit

align 4
global	_start
_start:
	pop	eax		; argc
	pop	eax		; program name
	pop	ecx		; file to convert
	jecxz	usage

	pop	eax
	or	eax, eax	; Too many arguments?
	jne	usage

	; Open the file
	push	dword O_RDWR
	push	ecx
	sys.open
	jc	cantopen

	mov	ebp, eax	; Save fd

	sub	esp, byte stat_size
	mov	ebx, esp

	; Find file size
	push	ebx
	push	ebp		; fd
	sys.fstat
	jc	facerr

	mov	edx, [ebx + st_size + 4]

	; File is too long if EDX != 0 ...
	or	edx, edx
	jne	near toolong
	mov	ecx, [ebx + st_size]
	; ... or if it is above 2 GB
	or	ecx, ecx
	js	near toolong

	; Do nothing if the file is 0 bytes in size
	jecxz	.quit

	; Map the entire file in memory
	push	edx
	push	edx		; starting at offset 0
	push	edx		; pad
	push	ebp		; fd
	push	dword MAP_SHARED
	push	dword PROT_READ | PROT_WRITE
	push	ecx		; entire file size
	push	edx		; let system decide on the address
	sys.mmap
	jc	near memerr

	mov	edi, eax
	mov	esi, eax
	push	ecx		; for SYS_munmap
	push	edi

	; Use EBX for state machine
	mov	ebx, ordinary
	mov	ah, 0Ah
	cld

.loop:
	lodsb
	call	ebx
	loop	.loop

	cmp	ebx, ordinary
	je	.filesize

	; Output final lf
	mov	al, ah
	stosb
	inc	edx

.filesize:
	; truncate file to new size
	push	dword 0		; high dword
	push	edx		; low dword
	push	eax		; pad
	push	ebp
	sys.ftruncate

	; close it (ebp still pushed)
	sys.close

	add	esp, byte 16
	sys.munmap

.quit:
	push	dword 0
	sys.exit

align 4
ordinary:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	stosb
	inc	edx
	ret

align 4
.cr:
	mov	ebx, cr
	ret

align 4
.lf:
	mov	ebx, lf
	ret

align 4
cr:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	al, ah
	stosb
	inc	edx
	ret

align 4
lf:
	cmp	al, ah
	je	.lf

	cmp	al, 0Dh
	je	.cr

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	ebx, ordinary
	mov	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	ret</pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Verwenden Sie dieses Programm nicht mit Dateien, die sich auf Datenträgern befinden, welche mit MS-DOS® oder Windows® formatiert wurden. Anscheinend gibt es im Code von FreeBSD einen subtilen Bug, wenn <code>mmap</code> auf solchen Datenträgern verwendet wird: Wenn die Datei eine bestimmte Grösse überschreitet, füllt <code>mmap</code> den Speicher mit lauter Nullen, und überschreibt damit anschliessend den Dateiinhalt.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=x86-one-pointed-mind>11.12. One-Pointed Mind<a class=anchor href=#x86-one-pointed-mind></a></h2><div class=sectionbody><div class=paragraph><p>Als ein Zen-Schüler liebe ich die Idee eines fokussierten Bewußtseins: Tu nur ein Ding zur gleichen Zeit, aber mache es richtig.</p></div><div class=paragraph><p>Das ist ziemlich genau die gleiche Idee, welche UNIX® richtig funktionieren lässt. Während eine typische Windows®-Applikation versucht alles Vorstellbare zu tun (und daher mit Fehler durchsetzt ist), versucht eine UNIX®-Applikation nur eine Funktion zu erfüllen und das gut.</p></div><div class=paragraph><p>Der typische UNIX®-Nutzer stellt sich sein eigenes System durch Shell-Skripte zusammen, die er selbst schreibt, und welche die Vorteile bestehender Applikationen dadurch kombinieren, indem sie die Ausgabe eines Programmes als Eingabe in ein anderes Programm durch eine Pipe übergeben.</p></div><div class=paragraph><p>Wenn Sie ihre eigene UNIX®-Software schreiben, ist es generell eine gute Idee zu betrachten, welcher Teil der Problemlösung durch bestehende Programme bewerkstelligt werden kann. Man schreibt nur die Programme selbst, für die keine vorhandene Lösung existiert.</p></div><div class=sect2><h3 id=x86-csv>11.12.1. CSV<a class=anchor href=#x86-csv></a></h3><div class=paragraph><p>Ich will dieses Prinzip an einem besonderen Beispiel aus der realen Welt demonstrieren, mit dem ich kürzlich konfrontiert wurde:</p></div><div class=paragraph><p>Ich mußte jeweils das elfte Feld von jedem Datensatz aus einer Datenbank extrahieren, die ich von einer Webseite heruntergeladen hatte. Die Datenbank war eine CSV-Datei, d.h. eine Liste von <em>Komma-getrennten Werten</em>. Dies ist ein ziemlich gewöhnliches Format für den Code-Austausch zwischen Menschen, die eine unterschiedliche Datenbank-Software nutzen.</p></div><div class=paragraph><p>Die erste Zeile der Datei enthält eine Liste der Felder durch Kommata getrennt. Der Rest der Datei enthält die einzelnen Datensätze mit durch Kommata getrennten Werten in jeder Zeile.</p></div><div class=paragraph><p>Ich versuchte awk unter Nutzung des Kommas als Trenner. Da aber einige Zeilen durch in Bindestriche gesetzte Kommata getrennt waren, extrahierte awk das falsche Feld aus diesen Zeilen.</p></div><div class=paragraph><p>Daher mußte ich meine eigene Software schreiben, um das elfte Feld aus der CSV-Datei auszulesen. Aber durch Anwendung der UNIX®-Philosophie mußte ich nur einen einfachen Filter schreiben, das Folgende tat:</p></div><div class=ulist><ul><li><p>Entferne die erste Zeile aus der Datei.</p></li><li><p>Ändere alle Kommata ohne Anführungszeichen in einen anderen Buchstaben.</p></li><li><p>Entferne alle Anführungszeichen.</p></li></ul></div><div class=paragraph><p>Streng genommen könnte ich sed benutzen, um die erste Zeile der Datei zu entfernen, aber das zu Bewerkstelligen war in meinem Programm sehr einfach, also entschloss ich mich dazu und reduzierte dadurch die Größe der Pipeline.</p></div><div class=paragraph><p>Unter Berücksichtigung aller Faktoren kostete mich das Schreiben dieses Programmes ca. 20 Minuten. Das Schreiben eines Programmes, welches jeweils das elfte Feld aus einer CSV-Datei extrahiert hätte wesentlich länger gedauert und ich hätte es nicht wiederverwenden können, um ein anderes Feld aus irgendeiner anderen Datenbank zu extrahieren.</p></div><div class=paragraph><p>Diesmal entschied ich mich dazu, etwas mehr Arbeit zu investieren, als man normalerweise für ein typisches Tutorial verwenden würde:</p></div><div class=ulist><ul><li><p>Es parst die Kommandozeilen nach Optionen.</p></li><li><p>Es zeigt die richtige Nutzung an, falls es ein falsches Argument findet.</p></li><li><p>Es gibt vernünftige Fehlermeldungen aus.</p></li></ul></div><div class=paragraph><p>Hier ist ein Beispiel für seine Nutzung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Usage: csv <span class=o>[</span><span class=nt>-t</span>&lt;delim&gt;] <span class=o>[</span><span class=nt>-c</span>&lt;comma&gt;] <span class=o>[</span><span class=nt>-p</span><span class=o>]</span> <span class=o>[</span><span class=nt>-o</span> &lt;outfile&gt;] <span class=o>[</span><span class=nt>-i</span> &lt;infile&gt;]</code></pre></div></div><div class=paragraph><p>Alle Parameter sind optional und können in beliebiger Reihenfolge auftauchen.</p></div><div class=paragraph><p>Der <span class=parameter>-t</span>-Parameter legt fest, was zu die Kommata zu ersetzen sind. Der <span class=constant>tab</span> ist die Vorgabe hierfür. Zum Beispiel wird <span class=parameter>-t;</span> alle unquotierten Kommata mit Semikolon ersetzen.</p></div><div class=paragraph><p>Ich brauche die <span class=parameter>-c</span>-Option nicht, aber sie könnte zukünftig nützlich sein. Sie ermöglicht mir festzulegen, daß ich einen anderen Buchstaben als das Kommata mit etwas anderem ersetzen möchte. Zum Beispiel wird der Parameter <span class=parameter>-c@</span> alle @-Zeichen ersetzen (nützlich, falls man eine Liste von Email-Adressen in Nutzername und Domain aufsplitten will).</p></div><div class=paragraph><p>Die <span class=parameter>-p</span>-Option erhält die erste Zeile, d.h. die erste Zeile der Datei wird nicht gelöscht. Als Vorgabe löschen wir die erste Zeile, weil die CSV-Datei in der ersten Zeile keine Daten, sondern Feldbeschreibungen enthält.</p></div><div class=paragraph><p>Die Parameter <span class=parameter>-i</span>- und <span class=parameter>-o</span>-Optionen erlauben es mir, die Ausgabe- und Eingabedateien festzulegen. Vorgabe sind <span class=filename>stdin</span> und <span class=filename>stdout</span>, also ist es ein regulärer UNIX®-Filter.</p></div><div class=paragraph><p>Ich habe sichergestellt, daß sowohl <span class=parameter>-i filename</span> und <span class=parameter>-ifilename</span> akzeptiert werden. Genauso habe ich dafür Sorge getragen, daß sowohl Eingabe- als auch Ausgabedateien festgelegt werden können.</p></div><div class=paragraph><p>Um das elfte Feld jeden Datensatzes zu erhalten kann ich nun folgendes eingeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% csv <span class=s1>&#39;-t;&#39;</span> data.csv | <span class=nb>awk</span> <span class=s1>&#39;-F;&#39;</span> <span class=s1>&#39;{print $11}&#39;</span></code></pre></div></div><div class=paragraph><p>Der Code speichert die Optionen (bis auf die Dateideskriptoren) in <code>EDX</code>: Das Kommata in <code>DH</code>, den neuen Feldtrenner in <code>DL</code> und das Flag für die <span class=parameter>-p</span>-Option in dem höchsten Bit von <code>EDX</code>. Ein kurzer Abgleich des Zeichens wird uns also eine schnelle Entscheidung darüber erlauben, was zu tun ist.</p></div><div class=paragraph><p>Hier ist der Code:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; csv.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Convert a comma-separated file to a something-else separated file.
;
; Started:	31-May-2001
; Updated:	 1-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
usg	db	&#39;Usage: csv [-t&lt;delim&gt;] [-c&lt;comma&gt;] [-p] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]&#39;, 0Ah
usglen	equ	$-usg
iemsg	db	&#34;csv: Can&#39;t open input file&#34;, 0Ah
iemlen	equ	$-iemsg
oemsg	db	&#34;csv: Can&#39;t create output file&#34;, 0Ah
oemlen	equ	$-oemsg

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	mov	edx, (&#39;,&#39; &lt;&lt; 8) | 9

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .init		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], &#39;-&#39;
	jne	usage

	inc	ecx
	mov	ax, [ecx]

.o:
	cmp	al, &#39;o&#39;
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	inc	ecx
	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, &#39;i&#39;
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	inc	ecx
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, &#39;p&#39;
	jne	.t
	or	ah, ah
	jne	near usage
	or	edx, 1 &lt;&lt; 31
	jmp	.arg

.t:
	cmp	al, &#39;t&#39;		; redefine output delimiter
	jne	.c
	or	ah, ah
	je	near usage
	mov	dl, ah
	jmp	.arg

.c:
	cmp	al, &#39;c&#39;
	jne	near usage
	or	ah, ah
	je	near usage
	mov	dh, ah
	jmp	.arg

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

	; See if we are to preserve the first line
	or	edx, edx
	js	.loop

.firstline:
	; get rid of the first line
	call	getchar
	cmp	al, 0Ah
	jne	.firstline

.loop:
	; read a byte from stdin
	call	getchar

	; is it a comma (or whatever the user asked for)?
	cmp	al, dh
	jne	.quote

	; Replace the comma with a tab (or whatever the user wants)
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

.quote:
	cmp	al, &#39;&#34;&#39;
	jne	.put

	; Print everything until you get another quote or EOL. If it
	; is a quote, skip it. If it is EOL, print it.
.qloop:
	call	getchar
	cmp	al, &#39;&#34;&#39;
	je	.loop

	cmp	al, 0Ah
	je	.put

	call	putchar
	jmp	short .qloop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret</pre></div></div><div class=paragraph><p>Vieles daraus ist aus <span class=filename>hex.asm</span> entnommen worden. Aber es gibt einen wichtigen Unterschied: Ich rufe nicht länger <code>write</code> auf, wann immer ich eine Zeilenvorschub ausgebe. Nun kann der Code sogar interaktiv genutzt werden.</p></div><div class=paragraph><p>Ich habe eine bessere Lösung gefunden für das Interaktivitätsproblem seit ich mit dem Schreiben dieses Kapitels begonnen habe. Ich wollte sichergehen, daß jede Zeile einzeln ausgegeben werden kann, falls erforderlich. Aber schlussendlich gibt es keinen Bedarf jede Zeile einzeln auszugeben, falls nicht-interaktiv genutzt.</p></div><div class=paragraph><p>Die neue Lösung besteht darin, die Funktion <code>write</code> jedesmal aufzurufen, wenn ich den Eingabepuffer leer vorfinde. Auf diesem Wege liest das Programm im interaktiven Modus eine Zeile aus der Tastatur des Nutzers, verarbeitet sie und stellt fest, ob deren Eingabepuffer leer ist, dann leert es seine Ausgabe und liest die nächste Zeile.</p></div><div class=sect3><h4 id=x86-buffered-dark-side>11.12.1.1. Die dunkle Seite des Buffering<a class=anchor href=#x86-buffered-dark-side></a></h4><div class=paragraph><p>Diese Änderung verhindert einen mysteriösen Aufhänger in einem speziellen Fall. Ich bezeichne dies als die <em>dunkle Seite des Buffering</em>, hauptsächlich, weil es eine nicht offensichtliche Gefahr darstellt.</p></div><div class=paragraph><p>Es ist unwahrscheinlich, daß dies mit dem csv-Programm oben geschieht aber lassen Sie uns einen weiteren Filter betrachten: Nehmen wir an ihre Eingabe sind rohe Daten, die Farbwerte darstellen, wie z.B. die Intensität eines Pixel mit den Farben <em>rot</em>, <em>grün</em> und <em>blau</em>. Unsere Ausgabe wird der negative Wert unserer Eingabe sein.</p></div><div class=paragraph><p>Solch ein Filter würde sehr einfach zu schreiben sein. Der größte Teil davon würde so aussehen wie all die anderen Filter, die wir bisher geschrieben haben, daher beziehe ich mich nur auf den Kern der Prozedur:</p></div><div class="literalblock programlisting"><div class=content><pre>.loop:
	call	getchar
	not	al		; Create a negative
	call	putchar
	jmp	short .loop</pre></div></div><div class=paragraph><p>Da dieser Filter mit rohen Daten arbeitet ist es unwahrscheinlich, daß er interaktiv genutzt werden wird.</p></div><div class=paragraph><p>Aber das Programm könnte als Bildbearbeitungssoftware tituliert werden. Wenn es nicht <code>write</code> vor jedem Aufruf von <code>read</code> durchführt, ist die Möglichkeit gegeben, das es sich aufhängt.</p></div><div class=paragraph><p>Dies könnte passieren:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Der Bildeditor wird unseren Filter laden mittels der C-Funktion <code>popen()</code>.</p></li><li><p>Er wird die erste Zeile von Pixeln laden aus einer Bitmap oder Pixmap.</p></li><li><p>Er wird die erste Zeile von Pixeln geschrieben in die <em>Pipe</em>, welche zur Variable <code>fd.in</code> unseres Filters führt.</p></li><li><p>Unser Filter wird jeden Pixel auslesen von der Eingabe, in in seinen negativen Wert umkehren und ihn in den Ausgabepuffer schreiben.</p></li><li><p>Unser Filter wird die Funktion <code>getchar</code> aufrufen, um das nächste Pixel abzurufen.</p></li><li><p>Die Funktion <code>getchar</code> wird einen leeren Eingabepuffer vorfinden und daher die Funktion <code>read</code> aufrufen.</p></li><li><p><code>read</code> wird den Systemaufruf <code>SYS_read</code> starten.</p></li><li><p>Der <em>Kernel</em> wird unseren Filter unterbrechen, bis der Bildeditor mehr Daten zur Pipe sendet.</p></li><li><p>Der Bildedior wird aus der anderen Pipe lesen, welche verbunden ist mit <code>fd.out</code> unseres Filters, damit er die erste Zeile des auszugebenden Bildes setzen kann <em>bevor</em> er uns die zweite Zeile der Eingabe einliest.</p></li><li><p>Der <em>Kernel</em> unterbricht den Bildeditor, bis er eine Ausgabe unseres Filters erhält, um ihn an den Bildeditor weiterzureichen.</p></li></ol></div></div></div><div class=paragraph><p>An diesem Punkt wartet unser Filter auf den Bildeditor, daß er ihm mehr Daten zur Verarbeitung schicken möge. Gleichzeitig wartet der Bildeditor darauf, daß unser Filter das Resultat der Berechnung ersten Zeile sendet. Aber das Ergebnis sitzt in unserem Ausgabepuffer.</p></div><div class=paragraph><p>Der Filter und der Bildeditor werden fortfahren bis in die Ewigkeit aufeinander zu warten (oder zumindest bis sie per kill entsorgt werden). Unsere Software hat den eine <a href=#secure-race-conditions>Race Condition</a> erreicht.</p></div><div class=paragraph><p>Das Problem tritt nicht auf, wenn unser Filter seinen Ausgabepuffer leert <em>bevor</em> er vom <em>Kernel</em> mehr Eingabedaten anfordert.</p></div></div></div></div></div><div class=sect1><h2 id=x86-fpu>11.13. Die FPU verwenden<a class=anchor href=#x86-fpu></a></h2><div class=sectionbody><div class=paragraph><p>Seltsamerweise erwähnt die meiste Literatur zu Assemblersprachen nicht einmal die Existenz der FPU, oder <em>floating point unit</em> (Fließkomma-Recheneinheit), geschweige denn, daß auf die Programmierung mit dieser eingegangen wird.</p></div><div class=paragraph><p>Dabei kann die Assemblerprogrammierung gerade bei hoch optimiertem FPU-Code, der <em>nur</em> mit einer Assemblersprache realisiert werden kann, ihre große Stärke ausspielen.</p></div><div class=sect2><h3 id=x86-fpu-organization>11.13.1. Organisation der FPU<a class=anchor href=#x86-fpu-organization></a></h3><div class=paragraph><p>Die FPU besteht aus 8 80-bit Fließkomma-Registern. Diese sind in Form eines Stacks organisiert-Sie können einen Wert durch den Befehl <code>push</code> auf dem TOS (<em>top of stack</em>) ablegen, oder durch <code>pop</code> von diesem holen.</p></div><div class=paragraph><p>Da also die Befehle <code>push</code> und <code>pop</code> schon verwendet werden, kann es keine op-Codes in Assemblersprache mit diesen Namen geben.</p></div><div class=paragraph><p>Sie können mit einen Wert auf dem TOS ablegen, indem Sie <code>fld</code>, <code>fild</code>, und <code>fbld</code> verwenden. Mit weiteren op-Codes lassen sich <em>Konstanten</em>-wie z.B. <em>Pi</em>-auf dem TOS ablegen.</p></div><div class=paragraph><p>Analog dazu können Sie einen Wert holen, indem Sie <code>fst</code>, <code>fstp</code>, <code>fist</code>, <code>fistp</code>, und <code>fbstp</code> verwenden. Eigentlich holen (<code>pop</code>) nur die op-Codes, die auf <em>p</em> enden, einen Wert, während die anderen den Wert irgendwo speichern (<code>store</code>) ohne ihn vom TOS zu entfernen.</p></div><div class=paragraph><p>Daten können zwischen dem TOS und dem Hauptspeicher als 32-bit, 64-bit oder 80-bit <em>real</em>, oder als 16-bit, 32-bit oder 64-bit <em>Integer</em>, oder als 80-bit <em>packed decimal</em> übertragen werden.</p></div><div class=paragraph><p>Das 80-bit <em>packed decimal</em>-Format ist ein Spezialfall des <em>binary coded decimal</em>-Formates, welches üblicherweise bei der Konvertierung zwischen der ASCII- und FPU-Darstellung von Daten verwendet wird. Dieses erlaubt die Verwendung von 18 signifikanten Stellen.</p></div><div class=paragraph><p>Unabhängig davon, wie Daten im Speicher dargestellt werden, speichert die FPU ihre Daten immer im 80-bit <em>real</em>-Format in den Registern.</p></div><div class=paragraph><p>Ihre interne Genauigkeit beträgt mindestens 19 Dezimalstellen. Selbst wenn wir also Ergebnisse im ASCII-Format mit voller 18-stelliger Genauigkeit darstellen lassen, werden immer noch korrekte Werte angezeigt.</p></div><div class=paragraph><p>Des weiteren können mathematische Operationen auf dem TOS ausgeführt werden: Wir können dessen <em>Sinus</em> berechnen, wir können ihn <em>skalieren</em> (z.B. können wir ihn mit dem Faktor 2 Multiplizieren oder Dividieren), wir können dessen <em>Logarithmus</em> zur Basis 2 nehmen, und viele weitere Dinge.</p></div><div class=paragraph><p>Wir können auch FPU-Register <em>multiplizieren</em>, <em>dividieren</em>, <em>addieren</em> und <em>subtrahieren</em>, sogar einzelne Register mit sich selbst.</p></div><div class=paragraph><p>Der offizielle Intel op-Code für den TOS ist <code>st</code> und für die <em>Register</em> <code>st(0)</code>- <code>st(7)</code>. <code>st</code> und <code>st(0)</code> beziehen sich dabei auf das gleiche Register.</p></div><div class=paragraph><p>Aus welchen Gründen auch immer hat sich der Originalautor von nasm dafür entschieden, andere op-Codes zu verwenden, nämlich <code>st0</code>- <code>st7</code>. Mit anderen Worten, es gibt keine Klammern, und der TOS ist immer <code>st0</code>, niemals einfach nur <code>st</code>.</p></div><div class=sect3><h4 id=x86-fpu-packed-decimal>11.13.1.1. Das Packed Decimal-Format<a class=anchor href=#x86-fpu-packed-decimal></a></h4><div class=paragraph><p>Das <em>packed decimal</em>-Format verwendet 10 Bytes (80 Bits) zur Darstellung von 18 Ziffern. Die so dargestellte Zahl ist immer ein <em>Integer</em>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Sie können durch Multiplikation des TOS mit Potenzen von 10 die einzelnen Dezimalstellen verschieben.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Das höchste Bit des höchsten Bytes (Byte 9) ist das <em>Vorzeichenbit</em>: Wenn es gesetzt ist, ist die Zahl <em>negativ</em>, ansonsten <em>positiv</em>. Die restlichen Bits dieses Bytes werden nicht verwendet bzw. ignoriert.</p></div><div class=paragraph><p>Die restlichen 9 Bytes enthalten die 18 Ziffern der gespeicherten Zahl: 2 Ziffern pro Byte.</p></div><div class=paragraph><p>Die <em>signifikantere Ziffer</em> wird in der <em>oberen Hälfte</em> (4 Bits) eines Bytes gespeichert, die andere in der <em>unteren Hälfte</em>.</p></div><div class=paragraph><p>Vielleicht würden Sie jetzt annehmen, das <span class=constant>-1234567</span> auf die folgende Art im Speicher abgelegt wird (in hexadezimaler Notation):</p></div><div class="literalblock programlisting"><div class=content><pre>80 00 00 00 00 00 01 23 45 67</pre></div></div><div class=paragraph><p>Dem ist aber nicht so! Bei Intel werden alle Daten im <em>little-endian</em>-Format gespeichert, auch das <em>packed decimal</em>-Format.</p></div><div class=paragraph><p>Dies bedeutet, daß <span class=constant>-1234567</span> wie folgt gespeichert wird:</p></div><div class="literalblock programlisting"><div class=content><pre>67 45 23 01 00 00 00 00 00 80</pre></div></div><div class=paragraph><p>Erinnern Sie sich an diesen Umstand, bevor Sie sich aus lauter Verzweiflung die Haare ausreißen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das lesenswerte Buch-falls Sie es finden können-ist Richard Startz' <a href="http://www.int80h.org/cgi-bin/isbn?isbn=013246604X">8087/80287/80387 for the IBM PC & Compatibles</a>. Obwohl es anscheinend die Speicherung der <em>packed decimal</em> im little-endian-Format für gegeben annimmt. Ich mache keine Witze über meine Verzweiflung, als ich den Fehler im unten stehenden Filter gesucht habe, <em>bevor</em> mir einfiel, daß ich einfach mal versuchen sollte, das little-endian-Format, selbst für diesen Typ von Daten, anzuwenden.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x86-pinhole-photography>11.13.2. Ausflug in die Lochblendenphotographie<a class=anchor href=#x86-pinhole-photography></a></h3><div class=paragraph><p>Um sinnvolle Programme zu schreiben, müssen wir nicht nur unsere Programmierwerkzeuge beherrschen, sondern auch das Umfeld, für das die Programme gedacht sind.</p></div><div class=paragraph><p>Unser nächster Filter wird uns dabei helfen, wann immer wir wollen, eine <em>Lochkamera</em> zu bauen. Wir brauchen also etwas Hintergrundwissen über die <em>Lochblendenphotographie</em>, bevor wir weiter machen können.</p></div><div class=sect3><h4 id=x86-camera>11.13.2.1. Die Kamera<a class=anchor href=#x86-camera></a></h4><div class=paragraph><p>Die einfachste Form, eine Kamera zu beschreiben, ist die eines abgeschlossenen, lichtundurchlässigen Raumes, in dessen Abdeckung sich ein kleines Loch befindet.</p></div><div class=paragraph><p>Die Abdeckung ist normalerweise fest (z.B. eine Schachtel), manchmal jedoch auch flexibel (z.B. ein Balgen). Innerhalb der Kamera ist es sehr dunkel. Nur durch ein kleines Loch kann Licht von einem einzigen Punkt aus in den Raum eindringen (in manchen Fällen sind es mehrere Löcher). Diese Lichtstrahlen kommen von einem Bild, einer Darstellung von dem was sich außerhalb der Kamera, vor dem kleinen Loch, befindet.</p></div><div class=paragraph><p>Wenn ein lichtempfindliches Material (wie z.B. ein Film) in der Kamera angebracht wird, so kann dieses das Bild einfangen.</p></div><div class=paragraph><p>Das Loch enthält häufig eine <em>Linse</em>, oder etwas linsenartiges, häufig auch einfach <em>Objektiv</em> genannt.</p></div></div><div class=sect3><h4 id=x86-the-pinhole>11.13.2.2. Die Lochblende<a class=anchor href=#x86-the-pinhole></a></h4><div class=paragraph><p>Streng genommen ist die Linse nicht notwendig: Die ursprünglichen Kameras verwendeten keine Linse, sondern eine <em>Lochblende</em>. Selbst heutzutage werden noch <em>Lochblenden</em> verwendet, zum einen, um die Funktionsweise einer Kamera zu erlernen, und zum anderen, um eine spezielle Art von Bildern zu erzeugen.</p></div><div class=paragraph><p>Das Bild, das von einer <em>Lochblende</em> erzeugt wird, ist überall scharf. Oder unscharf. Es gibt eine ideale Größe für eine Lochblende: Wenn sie größer oder kleiner ist, verliert das Bild seine Schärfe.</p></div></div><div class=sect3><h4 id=x86-focal-length>11.13.2.3. Brennweite<a class=anchor href=#x86-focal-length></a></h4><div class=paragraph><p>Dieser ideale Lochblendendurchmesser ist eine Funktion der Quadratwurzel der <em>Brennweite</em>, welche dem Abstand der Lochblende von dem Film entspricht.</p></div><div class="literalblock programlisting"><div class=content><pre>     D = PC * sqrt(FL)</pre></div></div><div class=paragraph><p>Hier ist <code>D</code> der ideale Durchmesser der Lochblende, <code>FL</code> die Brennweite und <span class=constant>PC</span> eine Konstante der Brennweite. Nach Jay Bender hat die Konstante den Wert <span class=constant>0.04</span>, nach Kenneth Connors <span class=constant>0.037</span>. Andere Leute haben andere Werte vorgeschlagen. Des weiteren gelten diese Werte nur für Tageslicht: Andere Arten von Licht benötigen andere konstante Werte, welche nur durch Experimente bestimmt werden können.</p></div></div><div class=sect3><h4 id=x86-f-number>11.13.2.4. Der f-Wert<a class=anchor href=#x86-f-number></a></h4><div class=paragraph><p>Der f-Wert ist eine sehr nützliche Größe, die angibt, wieviel Licht den Film erreicht. Ein Belichtungsmesser kann dies messen, um z.B. für einen Film mit einer Empfindlichkeit von f5.6 eine Belichtungsdauer von 1/1000 Sekunden auszurechnen.</p></div><div class=paragraph><p>Es spielt keine Rolle, ob es eine 35-mm- oder eine 6x9cm-Kamera ist, usw. Solange wir den f-Wert kennen, können wir die benötigte Belichtungszeit berechnen.</p></div><div class=paragraph><p>Der f-Wert läßt sich einfach wie folgt berechnen:</p></div><div class="literalblock programlisting"><div class=content><pre>    F = FL / D</pre></div></div><div class=paragraph><p>Mit anderen Worten, der f-Wert ergibt sich aus der Brennweite (FL), dividiert durch den Durchmesser (D) der Lochblende. Ein großer f-Wert impliziert also entweder eine kleine Lochblende, oder eine große Brennweite, oder beides. Je größer also der f-Wert ist, um so länger muß die Belichtungszeit sein.</p></div><div class=paragraph><p>Des weiteren sind der Lochblendendurchmesser und die Brennweite eindimensionale Meßgrößen, während der Film und die Lochblende an sich zweidimensionale Objekte darstellen. Das bedeutet, wenn man für einen f-Wert <code>A</code> eine Belichtungsdauer <code>t</code> bestimmt hat, dann ergibt sich daraus für einen f-Wert <code>B</code> eine Belichtungszeit von:</p></div><div class="literalblock programlisting"><div class=content><pre>    t * (B / A)²</pre></div></div></div><div class=sect3><h4 id=x86-normalized-f-number>11.13.2.5. Normalisierte f-Werte<a class=anchor href=#x86-normalized-f-number></a></h4><div class=paragraph><p>Während heutige moderne Kameras den Durchmesser der Lochblende, und damit deren f-Wert, weich und schrittweise verändern können, war dies früher nicht der Fall.</p></div><div class=paragraph><p>Um unterschiedliche f-Werte einstellen zu können, besaßen Kameras typischerweise eine Metallplatte mit Löchern unterschiedlichen Durchmessers als Lochblende.</p></div><div class=paragraph><p>Die Durchmesser wurden entsprechend obiger Formel gewählt, daß der resultierende f-Wert ein fester Standardwert war, der für alle Kameras verwendet wurde. Z.B. hat eine sehr alte Kodak Duaflex IV Kamera in meinem Besitz drei solche Löcher für die f-Werte 8, 11 und 16.</p></div><div class=paragraph><p>Eine neuere Kamera könnte f-Werte wie 2.8, 4, 5.6, 8, 11, 16, 22, und 32 (und weitere) besitzen. Diese Werte wurden nicht zufällig ausgewählt: Sie sind alle vielfache der Quadratwurzel aus 2, wobei manche Werte gerundet wurden.</p></div></div><div class=sect3><h4 id=x86-f-stop>11.13.2.6. Der f-Stopp<a class=anchor href=#x86-f-stop></a></h4><div class=paragraph><p>Eine typische Kamera ist so konzipiert, daß die Nummernscheibe bei den normalisierten f-Werten einrastet. Die Nummernscheibe <em>stoppt</em> an diesen Positionen. Daher werden diese Positionen auch f-Stopps genannt.</p></div><div class=paragraph><p>Da die f-Werte bei jedem Stopp vielfache der Quadratwurzel aus 2 sind, verdoppelt die Drehung der Nummernscheibe um einen Stopp die für die gleiche Belichtung benötigte Lichtmenge. Eine Drehung um 2 Stopps vervierfacht die benötigte Belichtungszeit. Eine Drehung um 3 Stopps verachtfacht sie, etc.</p></div></div></div><div class=sect2><h3 id=x86-pinhole-software>11.13.3. Entwurf der Lochblenden-Software<a class=anchor href=#x86-pinhole-software></a></h3><div class=paragraph><p>Wir können jetzt festlegen, was genau unsere Lochblenden-Software tun soll.</p></div><div class=sect3><h4 id=xpinhole-processing-input>11.13.3.1. Verarbeitung der Programmeingaben<a class=anchor href=#xpinhole-processing-input></a></h4><div class=paragraph><p>Da der Hauptzweck des Programms darin besteht, uns beim Entwurf einer funktionierenden Lochkamera zu helfen, wird die <em>Brennweite</em> die Programmeingabe sein. Dies ist etwas, das wir ohne zusätzliche Programme feststellen können: Die geeignete Brennweite ergibt sich aus der Größe des Films und der Art des Fotos, ob dieses ein "normales" Bild, ein Weitwinkelbild oder ein Telebild sein soll.</p></div><div class=paragraph><p>Die meisten bisher geschriebenen Programme arbeiteten mit einzelnen Zeichen, oder Bytes, als Eingabe: Das hex-Programm konvertierte einzelne Bytes in hexadezimale Werte, das csv-Programm ließ entweder einzelne Zeichen unverändert, löschte oder veränderte sie, etc.</p></div><div class=paragraph><p>Das Programm ftuc verwendete einen Zustandsautomaten, um höchstens zwei gleichzeitig eingegebene Bytes zu verarbeiten.</p></div><div class=paragraph><p>Das pinhole-Programm dagegen kann nicht nur mit einzelnen Zeichen arbeiten, sondern muß mit größeren syntaktischen Einheiten zurrecht kommen.</p></div><div class=paragraph><p>Wenn wir z.B. möchten, daß unser Programm den Lochblendendurchmesser (und weitere Werte, die wir später noch diskutieren werden) für die Brennweiten <span class=constant>100 mm</span>, <span class=constant>150 mm</span> und <span class=constant>210 mm</span> berechnet, wollen wir etwa folgendes eingeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 100, 150, 210</code></pre></div></div><div class=paragraph><p>Unser Programm muß mit der gleichzeitigen Eingabe von mehr als nur einem einzelnen Byte zurecht kommen. Wenn es eine <span class=constant>1</span> erkennt, muß es wissen, daß dies die erste Stelle einer dezimalen Zahl ist. Wenn es eine <span class=constant>0</span>, gefolgt von einer weiteren <span class=constant>0</span> sieht, muß es wissen, daß dies zwei unterschiedliche Stellen mit der gleichen Zahl sind.</p></div><div class=paragraph><p>Wenn es auf das erste Komma trifft, muß es wissen, daß die folgenden Stellen nicht mehr zur ersten Zahl gehören. Es muß die Stellen der ersten Zahl in den Wert <span class=constant>100</span> konvertieren können. Und die Stellen der zweiten Zahl müssen in den Wert <span class=constant>150</span> konvertiert werden. Und die Stellen der dritten Zahl müssen in den Wert <span class=constant>210</span> konvertiert werden.</p></div><div class=paragraph><p>Wir müssen festlegen, welche Trennsymbole zulässig sind: Sollen die Eingabewerte durch Kommas voneinander getrennt werden? Wenn ja, wie sollen zwei Zahlen behandelt werden, die durch ein anderes Zeichen getrennt sind?</p></div><div class=paragraph><p>Ich persönlich mag es einfach. Entweder etwas ist eine Zahl, dann wird es verarbeitet, oder es ist keine Zahl, dann wird es verworfen. Ich mag es nicht, wenn sich der Computer bei der <em>offensichtlichen</em> Eingabe eines zusätzlichen Zeichens beschwert. Duh!</p></div><div class=paragraph><p>Zusätzlich erlaubt es mir, die Monotonie des Tippens zu durchbrechen, und eine Anfrage anstelle einer simplen Zahl zu stellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> Was ist der beste Lochblendendurchmesser
	  bei einer Brennweite von 150?</code></pre></div></div><div class=paragraph><p>Es gibt keinen Grund dafür, die Ausgabe mehrerer Fehlermeldungen aufzuteilen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Syntax error: Was
Syntax error: ist
Syntax error: der
Syntax error: beste</code></pre></div></div><div class=paragraph><p>Et cetera, et cetera, et cetera.</p></div><div class=paragraph><p>Zweitens mag ich das <span class=constant>#</span>-Zeichen, um Kommentare zu markieren, die ab dem Zeichen bis zum Ende der jeweiligen Zeile gehen. Dies verlangt nicht viel Programmieraufwand, und ermöglicht es mir, Eingabedateien für meine Programme als ausführbare Skripte zu handhaben.</p></div><div class=paragraph><p>In unserem Fall müssen wir auch entscheiden, in welchen Einheiten die Dateneingabe erfolgen soll: Wir wählen <em>Millimeter</em>, da die meisten Photographen die Brennweite in dieser Einheit messen.</p></div><div class=paragraph><p>Letztendlich müssen wir noch entscheiden, ob wir die Verwendung des dezimalen Punktes erlauben (in diesem Fall müssen wir berücksichtigen, daß in vielen Ländern der Welt das dezimale <em>Komma</em> verwendet wird).</p></div><div class=paragraph><p>In unserem Fall würde das Zulassen eines dezimalen Punktes/Kommas zu einer fälschlicherweise angenommenen, höheren Genauigkeit führen: Der Unterschied zwischen den Brennweiten <span class=constant>50</span> und <span class=constant>51</span> ist fast nicht wahrnehmbar. Die Zulassung von Eingaben wie <span class=constant>50.5</span> ist also keine gute Idee. Beachten Sie bitte, das dies meine Meinung ist. In diesem Fall bin ich der Autor des Programmes. Bei Ihren eigenen Programmen müssen Sie selbst solche Entscheidungen treffen.</p></div></div><div class=sect3><h4 id=x86-pinhole-options>11.13.3.2. Optionen anbieten<a class=anchor href=#x86-pinhole-options></a></h4><div class=paragraph><p>Das wichtigste, was wir zum Bau einer Lochkamera wissen müssen, ist der Durchmesser der Lochblende. Da wir scharfe Bilder schießen wollen, werden wir obige Formel für die Berechnung des korrekten Durchmessers zu gegebener Brennweite verwenden. Da Experten mehrere Werte für die <span class=constant>PC</span>-Konstante anbieten, müssen wir uns hier für einen Wert entscheiden.</p></div><div class=paragraph><p>In der Programmierung unter UNIX® ist es üblich, zwei Hauptvarianten anzubieten, um Parameter an Programme zu übergeben, und des weiteren eine Standardeinstellung für den Fall zu haben, das der Benutzer gar keine Parameter angibt.</p></div><div class=paragraph><p>Warum zwei Varianten, Parameter anzugeben?</p></div><div class=paragraph><p>Ein Grund ist, eine (relativ) <em>feste</em> Einstellung anzubieten, die automatisch bei jedem Programmaufruf verwendet wird, ohne das wir diese Einstellung immer und immer wieder mit angeben müssen.</p></div><div class=paragraph><p>Die feste Einstellung kann in einer Konfigurationsdatei gespeichert sein, typischerweise im Heimatverzeichnis des Benutzers. Die Datei hat üblicherweise denselben Namen wie das zugehörige Programm, beginnt jedoch mit einem Punkt. Häufig wird <em>"rc"</em> dem Dateinamen hinzugefügt. Unsere Konfigurationsdatei könnte also <span class=filename>~/.pinhole</span> oder <span class=filename>~/.pinholerc</span> heißen. (Die Zeichenfolge <span class=filename>~/</span> steht für das Heimatverzeichnis des aktuellen Benutzers.)</p></div><div class=paragraph><p>Konfigurationsdateien werden häufig von Programmen verwendet, die viele konfigurierbare Parameter besitzen. Programme, die nur eine (oder wenige) Parameter anbieten, verwenden häufig eine andere Methode: Sie erwarten die Parameter in einer <em>Umgebungsvariablen</em>. In unserem Fall könnten wir eine Umgebungsvariable mit dem Namen <code>PINHOLE</code> benutzen.</p></div><div class=paragraph><p>Normalerweise verwendet ein Programm entweder die eine, oder die andere der beiden obigen Methoden. Ansonsten könnte ein Programm verwirrt werden, wenn eine Konfigurationsdatei das eine sagt, die Umgebungsvariable jedoch etwas anderes.</p></div><div class=paragraph><p>Da wir nur <em>einen</em> Parameter unterstützen müssen, verwenden wir die zweite Methode, und benutzen eine Umgebungsvariable mit dem Namen <code>PINHOLE</code>.</p></div><div class=paragraph><p>Der andere Weg erlaubt uns, <em>ad hoc</em> Entscheidungen zu treffen: <em>"Obwohl ich normalerweise einen Wert von 0.039 verwende, will ich dieses eine Mal einen Wert von 0.03872 anwenden."</em> Mit anderen Worten, dies erlaubt uns, die Standardeinstellung außer Kraft zu setzen.</p></div><div class=paragraph><p>Diese Art der Auswahl wird häufig über Kommandozeilenparameter gemacht.</p></div><div class=paragraph><p>Schließlich braucht ein Programm <em>immer</em> eine <em>Standardeinstellung</em>. Der Benutzer könnte keine Parameter angeben. Vielleicht weiß er auch gar nicht, was er einstellen sollte. Vielleicht will er es "einfach nur ausprobieren". Vorzugsweise wird die Standardeinstellung eine sein, die die meisten Benutzer sowieso wählen würden. Somit müssen diese keine zusätzlichen Parameter angeben, bzw. können die Standardeinstellung ohne zusätzlichen Aufwand benutzen.</p></div><div class=paragraph><p>Bei diesem System könnte das Programm widersprüchliche Optionen vorfinden, und auf die folgende Weise reagieren:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Wenn es eine <em>ad hoc</em>-Einstellung vorfindet (z.B. ein Kommandozeilenparameter), dann sollte es diese Einstellung annehmen. Es muß alle vorher festgelegten sowie die standardmäßige Einstellung ignorieren.</p></li><li><p><em>Andererseits</em>, wenn es eine festgelegte Option (z.B. eine Umgebungsvariable) vorfindet, dann sollte es diese akzeptieren und die Standardeinstellung ignorieren.</p></li><li><p><em>Ansonsten</em> sollte es die Standardeinstellung verwenden.</p></li></ol></div></div></div><div class=paragraph><p>Wir müssen auch entscheiden, welches <em>Format</em> unsere <span class=constant>PC</span>-Option haben soll.</p></div><div class=paragraph><p>Auf den ersten Blick scheint es einleuchtend, das Format <code>PINHOLE=0.04</code> für die Umgebungsvariable, und <span class=parameter>-p0.04</span> für die Kommandozeile zu verwenden.</p></div><div class=paragraph><p>Dies zuzulassen wäre eigentlich eine Sicherheitslücke. Die <span class=constant>PC</span>-Konstante ist eine sehr kleine Zahl. Daher würden wir unsere Anwendung mit verschiedenen, kleinen Werten für <span class=constant>PC</span> testen. Aber was würde passieren, wenn jemand das Programm mit einem sehr großen Wert aufrufen würde?</p></div><div class=paragraph><p>Es könnte abstürzen, weil wir das Programm nicht für den Umgang mit großen Werten entworfen haben.</p></div><div class=paragraph><p>Oder wir investieren noch weiter Zeit in das Programm, so daß dieses dann auch mit großen Zahlen umgehen kann. Wir könnten dies machen, wenn wir kommerzielle Software für computertechnisch unerfahrene Benutzer schreiben würden.</p></div><div class=paragraph><p>Oder wir könnten auch sagen <em>"Pech gehabt! Der Benutzer sollte es besser wissen."</em></p></div><div class=paragraph><p>Oder wir könnten es für den Benutzer unmöglich machen, große Zahlen einzugeben. Dies ist die Variante, die wir verwenden werden: Wir nehmen einen <em>impliziten 0.</em>-Präfix an.</p></div><div class=paragraph><p>Mit anderen Worten, wenn der Benutzer den Wert <span class=constant>0.04</span> angeben will, so muß er entweder <span class=parameter>-p04</span> als Parameter angeben, oder <code>PINHOLE=04</code> als Variable in seiner Umgebung definieren. Falls der Benutzer <span class=parameter>-p9999999</span> angibt, so wird dies als <span class=constant>0.9999999</span> interpretiert-zwar immer noch sinnlos, aber zumindest sicher.</p></div><div class=paragraph><p>Zweitens werden viele Benutzer einfach die Konstanten von Bender oder Connors benutzen wollen. Um es diesen Benutzern einfacher zu machen, werden wir <span class=parameter>-b</span> als <span class=parameter>-p04</span>, und <span class=parameter>-c</span> als <span class=parameter>-p037</span> interpretieren.</p></div></div><div class=sect3><h4 id=x86-pinhole-output>11.13.3.3. Die Ausgabe<a class=anchor href=#x86-pinhole-output></a></h4><div class=paragraph><p>Wir müssen festlegen, was und in welchem Format unsere Anwendung Daten ausgeben soll.</p></div><div class=paragraph><p>Da wir als Eingabe beliebig viele Brennweiten erlauben, macht es Sinn, die Ergebnisse in Form einer traditionellen Datenbank-Ausgabe darzustellen, bei der zeilenweise zu jeder Brennweite der zugehörige berechnete Wert, getrennt durch ein <span class=constant>tab</span>-Zeichen, ausgegeben wird.</p></div><div class=paragraph><p>Optional sollten wir dem Benutzer die Möglichkeit geben, die Ausgabe in dem schon beschriebenen CSV-Format festzulegen. In diesem Fall werden wir zu Beginn der Ausgabe eine Zeile einfügen, in der die Beschreibungen der einzelnen Felder, durch Kommas getrennt, aufgelistet werden, gefolgt von der Ausgabe der Daten wie schon beschrieben, wobei das <span class=constant>tab</span>-Zeichen durch ein <span class=constant>Komma</span> ersetzt wird.</p></div><div class=paragraph><p>Wir brauchen eine Kommandozeilenoption für das CSV-Format. Wir können nicht <span class=parameter>-c</span> verwenden, da diese Option bereits für <em>verwende Connors Konstante</em> steht. Aus irgendeinem seltsamen Grund bezeichnen viele Webseiten CSV-Dateien als <em>"Excel Kalkulationstabelle"</em> (obwohl das CSV-Format älter ist als Excel). Wir werden daher <span class=parameter>-e</span> als Schalter für die Ausgabe im CSV-Format verwenden.</p></div><div class=paragraph><p>Jede Zeile der Ausgabe wird mit einer Brennweite beginnen. Dies mag auf den ersten Blick überflüssig erscheinen, besonders im interaktiven Modus: Der Benutzer gibt einen Wert für die Brennweite ein, und das Programm wiederholt diesen.</p></div><div class=paragraph><p>Der Benutzer kann jedoch auch mehrere Brennweiten in einer Zeile angeben. Die Eingabe kann auch aus einer Datei, oder aus der Ausgabe eines anderen Programmes, kommen. In diesen Fällen sieht der Benutzer die Eingabewerte überhaupt nicht.</p></div><div class=paragraph><p>Ebenso kann die Ausgabe in eine Datei umgelenkt werden, was wir später noch untersuchen werden, oder sie könnte an einen Drucker geschickt werden, oder auch als Eingabe für ein weiteres Programm dienen.</p></div><div class=paragraph><p>Es macht also wohl Sinn, jede Zeile mit einer durch den Benutzer eingegebenen Brennweite beginnen zu lassen.</p></div><div class=paragraph><p>Halt! Nicht, wie der Benutzer die Daten eingegeben hat. Was passiert, wenn der Benutzer etwas wie folgt eingibt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 00000000150</code></pre></div></div><div class=paragraph><p>Offensichtlich müssen wir die führenden Nullen vorher abschneiden.</p></div><div class=paragraph><p>Wir müssen also die Eingabe des Benutzers sorgfältig prüfen, diese dann in der FPU in die binäre Form konvertieren, und dann von dort aus ausgeben.</p></div><div class=paragraph><p>Aber…​</p></div><div class=paragraph><p>Was ist, wenn der Benutzer etwas wie folgt eingibt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 17459765723452353453534535353530530534563507309676764423</code></pre></div></div><div class=paragraph><p>Ha! Das packed decimal-Format der FPU erlaubt uns die Eingabe einer 18-stelligen Zahl. Aber der Benutzer hat mehr als 18 Stellen eingegeben. Wie gehen wir damit um?</p></div><div class=paragraph><p>Wir <em>könnten</em> unser Programm so modifizieren, daß es die ersten 18 Stellen liest, der FPU übergibt, dann weitere 18 Stellen liest, den Inhalt des TOS mit einem Vielfachen von 10, entsprechend der Anzahl der zusätzlichen Stellen multipliziert, und dann beide Werte mittels <code>add</code> zusammen addiert.</p></div><div class=paragraph><p>Ja, wir könnten das machen. Aber in <em>diesem</em> Programm wäre es unnötig (in einem anderen wäre es vielleicht der richtige Weg): Selbst der Erdumfang in Millimetern ergibt nur eine Zahl mit 11 Stellen. Offensichtlich können wir keine Kamera dieser Größe bauen (jedenfalls jetzt noch nicht).</p></div><div class=paragraph><p>Wenn der Benutzer also eine so große Zahl eingibt, ist er entweder gelangweilt, oder er testet uns, oder er versucht, in das System einzudringen, oder er spielt- indem er irgendetwas anderes macht als eine Lochkamera zu entwerfen.</p></div><div class=paragraph><p>Was werden wir tun?</p></div><div class=paragraph><p>Wir werden ihn ohrfeigen, gewissermaßen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>17459765723452353453534535353530530534563507309676764423	???	???	???	???	???</code></pre></div></div><div class=paragraph><p>Um dies zu erreichen, werden wir einfach alle führenden Nullen ignorieren. Sobald wir eine Ziffer gefunden haben, die nicht Null ist, initialisieren wir einen Zähler mit <span class=constant>0</span> und beginnen mit drei Schritten:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Sende die Ziffer an die Ausgabe.</p></li><li><p>Füge die Ziffer einem Puffer hinzu, welchen wir später benutzen werden, um den packed decimal-Wert zu erzeugen, den wir an die FPU schicken können.</p></li><li><p>Erhöhe den Zähler um eins.</p></li></ol></div></div></div><div class=paragraph><p>Während wir diese drei Schritte wiederholen, müssen wir auf zwei Bedingungen achten:</p></div><div class=ulist><ul><li><p>Wenn der Zähler den Wert 18 übersteigt, hören wir auf, Ziffern dem Puffer hinzuzufügen. Wir lesen weiterhin Ziffern und senden sie an die Ausgabe.</p></li><li><p>Wenn, bzw. <em>falls</em>, das nächste Eingabezeichen keine Zahl ist, sind wir mit der Bearbeitung der Eingabe erst einmal fertig.</p><div class=paragraph><p>Übrigends können wir einfach Zeichen, die keine Ziffern sind, verwerfen, solange sie kein <span class=constant>#</span>-Zeichen sind, welches wir an den Eingabestrom zurückgeben müssen. Dieses Zeichen markiert den Beginn eines Kommentars. An dieser Stelle muß die Erzeugung der Ausgabe fertig sein, und wir müssen mit der Suche nach weiteren Eingabedaten fortfahren.</p></div></li></ul></div><div class=paragraph><p>Es bleibt immer noch eine Möglichkeit unberücksichtigt: Wenn der Benutzer eine Null (oder mehrere) eingibt, werden wir niemals eine von Null verschiedene Zahl vorfinden.</p></div><div class=paragraph><p>Wir können solch einen Fall immer anhand des Zählerstandes feststellen, welcher dann immer bei <span class=constant>0</span> bleibt. In diesem Fall müssen wir einfach eine <span class=constant>0</span> an die Ausgabe senden, und anschließend dem Benutzer erneut eine "Ohrfeige" verpassen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>0	???	???	???	???	???</code></pre></div></div><div class=paragraph><p>Sobald wir die Brennweite ausgegeben, und die Gültigkeit dieser Eingabe verifiziert haben, (größer als <span class=constant>0</span> und kleiner als 18 Zahlen) können wir den Durchmesser der Lochblende berechnen.</p></div><div class=paragraph><p>Es ist kein Zufall, daß <em>Lochblende</em> das Wort <em>Loch</em> enthält. In der Tat ist eine Lochblende buchstäblich eine <em>Loch Blende</em>, also eine Blende, in die mit einer Nadel vorsichtig ein kleines Loch gestochen wird.</p></div><div class=paragraph><p>Daher ist eine typische Lochblende sehr klein. Unsere Formel liefert uns das Ergebnis in Millimetern. Wir werden dieses mit <span class=constant>1000</span> multiplizieren, so daß die Ausgabe in <span class=constant>Mikrometern</span> erfolgt.</p></div><div class=paragraph><p>An dieser Stelle müssen wir auf eine weitere Falle achten: <em>Zu hohe Genauigkeit.</em></p></div><div class=paragraph><p>Ja, die FPU wurde für mathematische Berechnungen mit hoher Genauigkeit entworfen. Unsere Berechnungen hier erfordern jedoch keine solche mathematische Genauigkeit. Wir haben es hier mit Physik zu tun (Optik, um genau zu sein).</p></div><div class=paragraph><p>Angenommen, wir wollten aus eine Lastkraftwagen eine Lochkamera bauen (wir wären dabei nicht die ersten, die das versuchen würden!). Angenommen, die Länge des Laderaumes beträgt <span class=constant>12</span> Meter lang, so daß wir eine Brennweite von <span class=constant>12000</span> hätten. Verwenden wir Benders Konstante, so erhalten wir durch Multiplizieren von <span class=constant>0.04</span> mit der Quadratwurzel aus <span class=constant>12000</span> einen Wert von <span class=constant>4.381780460</span> Millimetern, oder <span class=constant>4381.780460</span> Micrometern.</p></div><div class=paragraph><p>So oder so ist das Rechenergebnis absurd präzise. Unser Lastkraftwagen ist nicht <em>genau</em><span class=constant>12000</span> Millimeter lang. Wir haben diese Länge nicht mit einer so hohen Genauigkeit gemessen, weswegen es falsch wäre zu behaupten, unser Lochblendendurchmesser müsse exakt <span class=constant>4.381780460</span> Millimeter sein. Es reicht vollkommen aus, wenn der Durchmesser <span class=constant>4.4</span> Millimeter beträgt.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ich habe in obigem Beispiel das Rechenergebnis "nur" auf 10 Stellen genau angegeben. Stellen Sie sich vor, wie absurd es wäre, die vollen uns zur Verfügung stehenden, 18 Stellen anzugeben!</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wir müssen also die Anzahl der signifikanten Stellen beschränken. Eine Möglichkeit wäre, die Mikrometer durch eine ganze Zahl darzustellen. Unser Lastkraftwaren würde dann eine Lochblende mit einem Durchmesser von <span class=constant>4382</span> Mikrometern benötigen. Betrachten wir diesen Wert, dann stellen wir fest, das <span class=constant>4400</span> Mikrometer, oder <span class=constant>4.4</span> Millimeter, immer noch genau genug ist.</p></div><div class=paragraph><p>Zusätzlich können wir noch, unabhängig von der Größe eines Rechenergebnisses, festlegen, daß wir nur vier signifikante Stellen anzeigen wollen (oder weniger). Leider bietet uns die FPU nicht die Möglichkeit, das Ergebnis automatisch bis auf eine bestimmte Stelle zu runden (sie sieht die Daten ja nicht als Zahlen, sondern als binäre Daten an).</p></div><div class=paragraph><p>Wir müssen also selber einen Algorithmus entwerfen, um die Anzahl der signifikanten Stellen zu reduzieren.</p></div><div class=paragraph><p>Hier ist meiner (ich denke er ist peinlich-wenn Ihnen ein besserer Algorithmus einfällt, verraten sie ihn mir <em>bitte</em>):</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Initialisiere einen Zähler mit <span class=constant>0</span>.</p></li><li><p>Solange die Zahl größer oder gleich <span class=constant>10000</span> ist, dividiere die Zahl durch <span class=constant>10</span>, und erhöhe den Zähler um eins.</p></li><li><p>Gebe das Ergebnis aus.</p></li><li><p>Solange der Zähler größer als <span class=constant>0</span> ist, gebe eine <span class=constant>0</span> aus, und reduziere den Zähler um eins.</p></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Der Wert <span class=constant>10000</span> ist nur für den Fall, daß Sie <em>vier</em> signifikante Stellen haben wollen. Für eine andere Anzahl signifikanter Stellen müssen Sie den Wert <span class=constant>10000</span> mit <span class=constant>10</span>, hoch der Anzahl der gewünschten signifikanten Stellen, ersetzen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wir können so den Lochblendendurchmesser, auf vier signifikante Stellen gerundet, ausgeben.</p></div><div class=paragraph><p>An dieser Stellen kennen wir nun die <em>Brennweite</em> und den <em>Lochblendendurchmesser</em>. Wir haben also jetzt genug Informationen, um den <em>f-Wert</em> zu bestimmen.</p></div><div class=paragraph><p>Wir werden den f-Wert, auf vier signifikante Stellen gerundet, ausgeben. Es könnte passieren, daß diese vier Stellen recht wenig aussagen. Um die Aussagekraft des f-Wertes zu erhöhen, könnten wir den nächstliegenden, <em>normalisierten f-Wert</em> bestimmen, also z.B. das nächstliegende Vielfache der Quadratwurzel aus 2.</p></div><div class=paragraph><p>Wir erreichen dies, indem wir den aktuellen f-Wert mit sich selbst multiplizieren, so daß wir dessen Quadrat (<code>square</code>) erhalten. Anschließend berechnen wir den Logarithmus zur Basis 2 von dieser Zahl. Dies ist sehr viel einfacher, als direkt den Logarithmus zur Basis der Quadratwurzel aus 2 zu berechnen! Wir runden dann das Ergebnis auf die nächstliegende ganze Zahl. Genau genommen können wir mit Hilfe der FPU diese Berechnung beschleunigen: Wir können den op-Code <code>fscale</code> verwenden, um eine Zahl um 1 zu "skalieren", was dasselbe ist, wie eine Zahl mittels <code>shift</code> um eine Stelle nach links zu verschieben. Am Ende berechnen wir noch die Quadratwurzel aus allem, und erhalten dann den nächstliegenden, normalisierten f-Wert.</p></div><div class=paragraph><p>Wenn das alles jetzt viel zu kompliziert wirkt-oder viel zu aufwendig-wird es vielleicht klarer, wenn man den Code selber betrachtet. Wir benötigen insgesamt 9 op-Codes:</p></div><div class="literalblock programlisting"><div class=content><pre>fmul    st0, st0
    fld1
    fld     st1
    fyl2x
    frndint
    fld1
    fscale
    fsqrt
    fstp    st1</pre></div></div><div class=paragraph><p>Die erste Zeile, <code>fmul st0, st0</code>, quadriert den Inhalt des TOS (Top Of Stack, was dasselbe ist wie <code>st</code>, von nasm auch <code>st0</code> genannt). Die Funktion <code>fld1</code> fügt eine <span class=constant>1</span> dem TOS hinzu.</p></div><div class=paragraph><p>Die nächste Zeile, <code>fld st1</code>, legt das Quadrat auf dem TOS ab. An diesem Punkt befindet sich das Quadrat sowohl in <code>st</code> als auch in <code>st(2)</code> (es wird sich gleich zeigen, warum wir eine zweite Kopie auf dem Stack lassen.) <code>st(1)</code> enthält die <span class=constant>1</span>.</p></div><div class=paragraph><p>Im nächsten Schritt, <code>fyl2x</code>, wird der Logarithmus von <code>st</code> zur Basis 2 berechnet, und anschließend mit <code>st(1)</code> multipliziert. Deshalb haben wir vorher die <span class=constant>1</span> in <code>st(1)</code> abgelegt.</p></div><div class=paragraph><p>An dieser Stelle enthält <code>st</code> den gerade berechneten Logarithmus, und <code>st(1)</code> das Quadrat des aktuellen f-Wertes, den wir für später gespeichert haben.</p></div><div class=paragraph><p><code>frndint</code> rundet den TOS zur nächstliegenden ganzen Zahl. <code>fld1</code> legt eine <span class=constant>1</span> auf dem Stack ab. <code>fscale</code> shiftet die <span class=constant>1</span> auf dem TOS um <code>st(1)</code> Stellen, wodurch im Endeffekt eine 2 in <code>st(1)</code> steht.</p></div><div class=paragraph><p>Schließlich berechnet <code>fsqrt</code> die Quadratwurzel des Rechenergebnisses, also des nächstliegenden, normalisierten f-Wertes.</p></div><div class=paragraph><p>Wir haben nun den nächstliegenden, normalisierten f-Wert auf dem TOS liegen, den auf den Logarithmus zur Basis 2 gerundeten, nächstliegenden ganzzahligen Wert in <code>st(1)</code>, und das Quadrat des aktuellen f-Wertes in <code>st(2)</code>. Wir speichern den Wert für eine spätere Verwendung in <code>st(2)</code>.</p></div><div class=paragraph><p>Aber wir brauchen den Inhalt von <code>st(1)</code> gar nicht mehr. Die letzte Zeile, <code>fstp st1</code>, platziert den Inhalt von <code>st</code> in <code>st(1)</code>, und erniedrigt den Stackpointer um eins. Dadurch ist der Inhalt von <code>st(1)</code> jetzt <code>st</code>, der Inhalt von <code>st(2)</code> jetzt <code>st(1)</code> usw. Der neue <code>st</code> speichert jetzt den normalisierten f-Wert. Der neue <code>st(1)</code> speichert das Quadrat des aktuellen f-Wertes für die Nachwelt.</p></div><div class=paragraph><p>Jetzt können wir den normalisierten f-Wert ausgeben. Da er normalisiert ist, werden wir ihn nicht auf vier signifikante Stellen runden, sondern stattdessen mit voller Genauigkeit ausgeben.</p></div><div class=paragraph><p>Der normalisierte f-Wert ist nützlich, solange er so klein ist, daß wir ihn auf einem Photometer wiederfinden können. Ansonsten brauchen wir eine andere Methode, um die benötigten Belichtungsdaten zu bestimmen.</p></div><div class=paragraph><p>Wir haben weiter oben eine Formel aufgestellt, über die wir einen f-Wert mit Hilfe eines anderen f-Wertes und den zugehörigen Belichtungsdaten bestimmen können.</p></div><div class=paragraph><p>Jedes Photometer, das ich jemals gesehen habe, konnte die benötigte Belichtungszeit für f5.6 berechnen. Wir werden daher einen <em>"f5.6 Multiplizierer"</em> berechnen, der uns den Faktor angibt, mit dem wir die bei f5.6 gemessene Belichtungszeit für unsere Lochkamera multiplizieren müssen.</p></div><div class=paragraph><p>Durch die Formel wissen wir, daß dieser Faktor durch Dividieren unseres f-Wertes (der aktuelle Wert, nicht der normalisierte) durch <span class=constant>5.6</span> und anschließendes Quadrieren, berechnen können.</p></div><div class=paragraph><p>Mathematisch äquivalent dazu wäre, wenn wir das Quadrat unseres f-Wertes durch das Quadrat von <span class=constant>5.6</span> dividieren würden.</p></div><div class=paragraph><p>Numerisch betrachtet wollen wir nicht zwei Zahlen quadrieren, wenn es möglich ist, nur eine Zahl zu quadrieren. Daher wirkt die erste Variante auf den ersten Blick besser.</p></div><div class=paragraph><p>Aber…​</p></div><div class=paragraph><p><span class=constant>5.6</span> ist eine <em>Konstante</em>. Wir müssen nicht wertvolle Rechenzeit der FPU verschwenden. Es reicht aus, daß wir die Quadrate der einzelnen f-Werte durch den konstanten Wert <span class=constant>5.6²</span> dividieren. Oder wir können den jeweiligen f-Wert durch <span class=constant>5.6</span> dividieren, und dann das Ergebnis quadrieren. Zwei Möglichkeiten, die gleich erscheinen.</p></div><div class=paragraph><p>Aber das sind sie nicht!</p></div><div class=paragraph><p>Erinnern wir uns an die Grundlagen der Photographie weiter oben, dann wissen wir, daß sich die Konstante <span class=constant>5.6</span> aus dem 5-fachen der Quadratwurzel aus 2 ergibt. Eine <em>irrationale</em> Zahl. Das Quadrat dieser Zahl ist <em>exakt</em><span class=constant>32</span>.</p></div><div class=paragraph><p><span class=constant>32</span> ist nicht nur eine ganze Zahl, sondern auch ein Vielfaches von 2. Wir brauchen also gar nicht das Quadrat eines f-Wertes durch <span class=constant>32</span> zu teilen. Wir müssen lediglich mittels <code>fscale</code> den f-Wert um fünf Stellen nach rechts shiften. Aus Sicht der FPU müssen wir also <code>fscale</code> mit <code>st(1)</code>, welcher gleich <span class=constant>-5</span> ist, auf den f-Wert anwenden. Dies ist <em>sehr viel schneller</em> als die Division.</p></div><div class=paragraph><p>Jetzt wird es auch klar, warum wir das Quadrat des f-Wertes ganz oben auf dem Stack der FPU gespeichert haben. Die Berechnung des f5.6 Multiplizierers ist die einfachste Berechnung des gesamten Programmes! Wir werden das Ergebnis auf vier signifikante Stellen gerundet ausgeben.</p></div><div class=paragraph><p>Es gibt noch eine weitere nützliche Zahl, die wir berechnen können: Die Anzahl der Stopps, die unser f-Wert von f5.6 entfernt ist. Dies könnte hilfreich sein, wenn unser f-Wert außerhalb des Meßbereiches unseres Photometers liegt, wir aber eine Blende haben, bei der wir unterschiedliche Geschwindigkeiten einstellen können, und diese Blende Stopps benutzt.</p></div><div class=paragraph><p>Angenommen, unser f-Wert ist 5 Stopps von f5.6 entfernt, und unser Photometer sagt uns, daß wir eine Belichtungszeit von 1/1000 Sek. einstellen sollen. Dann können wir unsere Blende auf die Geschwindigkeit 1/1000 einstellen, und unsere Skala um 5 Stopps verschieben.</p></div><div class=paragraph><p>Diese Rechnung ist ebenfalls sehr einfach. Alles, was wir tun müssen, ist, den Logarithmus des f5.6 Multiplizierers, den wir schon berechnet haben (wobei wir dessen Wert vor der Rundung nehmen müssen) zur Basis 2 zu nehmen. Wir runden dann das Ergebnis zur nächsten ganzen Zahl hin, und geben dies aus. Wir müssen uns nicht darum kümmern, ob wir mehr als vier signifikante Stellen haben: Das Ergebnis besteht höchstwahrscheinlich nur aus einer oder zwei Stellen.</p></div></div></div><div class=sect2><h3 id=x86-fpu-optimizations>11.13.4. FPU Optimierungen<a class=anchor href=#x86-fpu-optimizations></a></h3><div class=paragraph><p>In Assemblersprache können wir den Code für die FPU besser optimieren, als in einer der Hochsprachen, inklusive C.</p></div><div class=paragraph><p>Sobald eine C-Funktion die Berechnung einer Fließkommazahl durchführen will, lädt sie erst einmal alle benötigten Variablen und Konstanten in die Register der FPU. Dann werden die Berechnungen durchgeführt, um das korrekte Ergebnis zu erhalten. Gute C-Compiler können diesen Teil des Codes sehr gut optimieren.</p></div><div class=paragraph><p>Das Ergebnis wird "zurückgegeben", indem dieses auf dem TOS abgelegt wird. Vorher wird aufgeräumt. Sämtliche Variablen und Konstanten, die während der Berechnung verwendet wurden, werden dabei aus der FPU entfernt.</p></div><div class=paragraph><p>Was wir im vorherigen Abschnitt selber getan haben, kann so nicht durchgeführt werden: Wir haben das Quadrat des f-Wertes berechnet, und das Ergebnis für eine weitere Berechnung mit einer anderen Funktion auf dem Stack behalten.</p></div><div class=paragraph><p>Wir <em>wußten</em>, daß wir diesen Wert später noch einmal brauchen würden. Wir wußten auch, daß auf dem Stack genügend Platz war (welcher nur Platz für 8 Zahlen bietet), um den Wert dort zu speichern.</p></div><div class=paragraph><p>Ein C-Compiler kann nicht wissen, ob ein Wert auf dem Stack in naher Zukunft noch einmal gebraucht wird.</p></div><div class=paragraph><p>Natürlich könnte der C-Programmierer dies wissen. Aber die einzige Möglichkeit, die er hat, ist, den Wert im verfügbaren Speicher zu halten.</p></div><div class=paragraph><p>Das bedeutet zum einen, daß der Wert mit der FPU-internen, 80-stelligen Genauigkeit in einer normalen C-Variable vom Typ <em>double</em> (64 Bit) oder vom Typ <em>single</em> (32 Bit) gespeichert wird.</p></div><div class=paragraph><p>Dies bedeutet außerdem, daß der Wert aus dem TOS in den Speicher verschoben werden muß, und später wieder zurück. Von allen Operationen mit der FPU ist der Zugriff auf den Speicher die langsamste.</p></div><div class=paragraph><p>Wann immer also mit der FPU in einer Assemblersprache programmiert wird, sollte nach Möglichkeiten gesucht werden, Zwischenergebnisse auf dem Stack der FPU zu lassen.</p></div><div class=paragraph><p>Wir können mit dieser Idee noch einen Schritt weiter gehen! In unserem Programm verwenden wir eine <em>Konstante</em> (die wir <span class=constant>PC</span> genannt haben).</p></div><div class=paragraph><p>Es ist unwichtig, wieviele Lochblendendurchmesser wir berechnen: 1, 10, 20, 1000, wir verwenden immer dieselbe Konstante. Daher können wir unser Programm so optimieren, daß diese Konstante immer auf dem Stack belassen wird.</p></div><div class=paragraph><p>Am Anfang unseres Programmes berechnen wir die oben erwähnte Konstante. Wir müssen die Eingabe für jede Dezimalstelle der Konstanten durch <span class=constant>10</span> dividieren.</p></div><div class=paragraph><p>Multiplizieren geht sehr viel schneller als Dividieren. Wir teilen also zu Beginn unseres Programmes <span class=constant>1</span> durch <span class=constant>10</span>, um <span class=constant>0.1</span> zu erhalten, was wir auf dem Stack speichern: Anstatt daß wir nun für jede einzelne Dezimalstelle die Eingabe wieder durch <span class=constant>10</span> teilen, multiplizieren wir sie stattdessen mit <span class=constant>0.1</span>.</p></div><div class=paragraph><p>Auf diese Weise geben wir <span class=constant>0.1</span> nicht direkt ein, obwohl wir dies könnten. Dies hat einen Grund: Während <span class=constant>0.1</span> durch nur eine einzige Dezimalstelle dargestellt werden kann, wissen wir nicht, wieviele <em>binäre</em> Stellen benötigt werden. Wir überlassen die Berechnung des binären Wertes daher der FPU, mit dessen eigener, hoher Genauigkeit.</p></div><div class=paragraph><p>Wir verwenden noch weitere Konstanten: Wir multiplizieren den Lochblendendurchmesser mit <span class=constant>1000</span>, um den Wert von Millimeter in Micrometer zu konvertieren. Wir vergleichen Werte mit <span class=constant>10000</span>, wenn wir diese auf vier signifikante Stellen runden wollen. Wir behalten also beide Konstanten, <span class=constant>1000</span> und <span class=constant>10000</span>, auf dem Stack. Und selbstverständlich verwenden wir erneut die gespeicherte <span class=constant>0.1</span>, um Werte auf vier signifikante Stellen zu runden.</p></div><div class=paragraph><p>Zu guter letzt behalten wir <span class=constant>-5</span> noch auf dem Stack. Wir brauchen diesen Wert, um das Quadrat des f-Wertes zu skalieren, anstatt diesen durch <span class=constant>32</span> zu teilen. Es ist kein Zufall, daß wir diese Konstante als letztes laden. Dadurch wird diese Zahl die oberste Konstante auf dem Stack. Wenn später das Quadrat des f-Wertes skaliert werden muß, befindet sich die <span class=constant>-5</span> in <code>st(1)</code>, also genau da, wo die Funktion <code>fscale</code> diesen Wert erwartet.</p></div><div class=paragraph><p>Es ist üblich, einige Konstanten per Hand zu erzeugen, anstatt sie aus dem Speicher zu laden. Genau das machen wir mit der <span class=constant>-5</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>    	fld1			; TOS =  1
    	fadd	st0, st0	; TOS =  2
    	fadd	st0, st0	; TOS =  4
    	fld1			; TOS =  1
    	faddp	st1, st0	; TOS =  5
    	fchs			; TOS = -5</pre></div></div><div class=paragraph><p>Wir können all diese Optimierungen in einer Regel zusammenfassen: <em>Behalte wiederverwendbare Werte auf dem Stack!</em></p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><em>PostScript®</em> ist eine Stack-orientierte Programmiersprache. Es gibt weit mehr Bücher über PostScript®, als über die Assemblersprache der FPU: Werden Sie in PostScript® besser, dann werden Sie auch automatisch in der Programmierung der FPU besser.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=x86-pinhole-the-code>11.13.5. pinhole-Der Code<a class=anchor href=#x86-pinhole-the-code></a></h3><div class="literalblock programlisting"><div class=content><pre>;;;;;;; pinhole.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Find various parameters of a pinhole camera construction and use
;
; Started:	 9-Jun-2001
; Updated:	10-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
align 4
ten	dd	10
thousand	dd	1000
tthou	dd	10000
fd.in	dd	stdin
fd.out	dd	stdout
envar	db	&#39;PINHOLE=&#39;	; Exactly 8 bytes, or 2 dwords long
pinhole	db	&#39;04,&#39;, 		; Bender&#39;s constant (0.04)
connors	db	&#39;037&#39;, 0Ah	; Connors&#39; constant
usg	db	&#39;Usage: pinhole [-b] [-c] [-e] [-p &lt;value&gt;] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]&#39;, 0Ah
usglen	equ	$-usg
iemsg	db	&#34;pinhole: Can&#39;t open input file&#34;, 0Ah
iemlen	equ	$-iemsg
oemsg	db	&#34;pinhole: Can&#39;t create output file&#34;, 0Ah
oemlen	equ	$-oemsg
pinmsg	db	&#34;pinhole: The PINHOLE constant must not be 0&#34;, 0Ah
pinlen	equ	$-pinmsg
toobig	db	&#34;pinhole: The PINHOLE constant may not exceed 18 decimal places&#34;, 0Ah
biglen	equ	$-toobig
huhmsg	db	9, &#39;???&#39;
separ	db	9, &#39;???&#39;
sep2	db	9, &#39;???&#39;
sep3	db	9, &#39;???&#39;
sep4	db	9, &#39;???&#39;, 0Ah
huhlen	equ	$-huhmsg
header	db	&#39;focal length in millimeters,pinhole diameter in microns,&#39;
	db	&#39;F-number,normalized F-number,F-5.6 multiplier,stops &#39;
	db	&#39;from F-5.6&#39;, 0Ah
headlen	equ	$-header

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE
dbuffer	resb	20		; decimal input buffer
bbuffer	resb	10		; BCD buffer

section	.text
align 4
huh:
	call	write
	push	dword huhlen
	push	dword huhmsg
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	ret

align 4
perr:
	push	dword pinlen
	push	dword pinmsg
	push	dword stderr
	sys.write
	push	dword 4		; return failure
	sys.exit

align 4
consttoobig:
	push	dword biglen
	push	dword toobig
	push	dword stderr
	sys.write
	push	dword 5		; return failure
	sys.exit

align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	sub	esi, esi

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .getenv		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], &#39;-&#39;
	jne	usage

	inc	ecx
	mov	ax, [ecx]
	inc	ecx

.o:
	cmp	al, &#39;o&#39;
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, &#39;i&#39;
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, &#39;p&#39;
	jne	.c
	or	ah, ah
	jne	.pcheck

	pop	ecx
	or	ecx, ecx
	je	near usage

	mov	ah, [ecx]

.pcheck:
	cmp	ah, &#39;0&#39;
	jl	near usage
	cmp	ah, &#39;9&#39;
	ja	near usage
	mov	esi, ecx
	jmp	.arg

.c:
	cmp	al, &#39;c&#39;
	jne	.b
	or	ah, ah
	jne	near usage
	mov	esi, connors
	jmp	.arg

.b:
	cmp	al, &#39;b&#39;
	jne	.e
	or	ah, ah
	jne	near usage
	mov	esi, pinhole
	jmp	.arg

.e:
	cmp	al, &#39;e&#39;
	jne	near usage
	or	ah, ah
	jne	near usage
	mov	al, &#39;,&#39;
	mov	[huhmsg], al
	mov	[separ], al
	mov	[sep2], al
	mov	[sep3], al
	mov	[sep4], al
	jmp	.arg

align 4
.getenv:
	; If ESI = 0, we did not have a -p argument,
	; and need to check the environment for &#34;PINHOLE=&#34;
	or	esi, esi
	jne	.init

	sub	ecx, ecx

.nextenv:
	pop	esi
	or	esi, esi
	je	.default	; no PINHOLE envar found

	; check if this envar starts with &#39;PINHOLE=&#39;
	mov	edi, envar
	mov	cl, 2		; &#39;PINHOLE=&#39; is 2 dwords long
rep	cmpsd
	jne	.nextenv

	; Check if it is followed by a digit
	mov	al, [esi]
	cmp	al, &#39;0&#39;
	jl	.default
	cmp	al, &#39;9&#39;
	jbe	.init
	; fall through

align 4
.default:
	; We got here because we had no -p argument,
	; and did not find the PINHOLE envar.
	mov	esi, pinhole
	; fall through

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	sub	edx, edx
	mov	edi, dbuffer+1
	mov	byte [dbuffer], &#39;0&#39;

	; Convert the pinhole constant to real
.constloop:
	lodsb
	cmp	al, &#39;9&#39;
	ja	.setconst
	cmp	al, &#39;0&#39;
	je	.processconst
	jb	.setconst

	inc	dl

.processconst:
	inc	cl
	cmp	cl, 18
	ja	near consttoobig
	stosb
	jmp	short .constloop

align 4
.setconst:
	or	dl, dl
	je	near perr

	finit
	fild	dword [tthou]

	fld1
	fild	dword [ten]
	fdivp	st1, st0

	fild	dword [thousand]
	mov	edi, obuffer

	mov	ebp, ecx
	call	bcdload

.constdiv:
	fmul	st0, st2
	loop	.constdiv

	fld1
	fadd	st0, st0
	fadd	st0, st0
	fld1
	faddp	st1, st0
	fchs

	; If we are creating a CSV file,
	; print header
	cmp	byte [separ], &#39;,&#39;
	jne	.bigloop

	push	dword headlen
	push	dword header
	push	dword [fd.out]
	sys.write

.bigloop:
	call	getchar
	jc	near done

	; Skip to the end of the line if you got &#39;#&#39;
	cmp	al, &#39;#&#39;
	jne	.num
	call	skiptoeol
	jmp	short .bigloop

.num:
	; See if you got a number
	cmp	al, &#39;0&#39;
	jl	.bigloop
	cmp	al, &#39;9&#39;
	ja	.bigloop

	; Yes, we have a number
	sub	ebp, ebp
	sub	edx, edx

.number:
	cmp	al, &#39;0&#39;
	je	.number0
	mov	dl, 1

.number0:
	or	dl, dl		; Skip leading 0&#39;s
	je	.nextnumber
	push	eax
	call	putchar
	pop	eax
	inc	ebp
	cmp	ebp, 19
	jae	.nextnumber
	mov	[dbuffer+ebp], al

.nextnumber:
	call	getchar
	jc	.work
	cmp	al, &#39;#&#39;
	je	.ungetc
	cmp	al, &#39;0&#39;
	jl	.work
	cmp	al, &#39;9&#39;
	ja	.work
	jmp	short .number

.ungetc:
	dec	esi
	inc	ebx

.work:
	; Now, do all the work
	or	dl, dl
	je	near .work0

	cmp	ebp, 19
	jae	near .toobig

	call	bcdload

	; Calculate pinhole diameter

	fld	st0	; save it
	fsqrt
	fmul	st0, st3
	fld	st0
	fmul	st5
	sub	ebp, ebp

	; Round off to 4 significant digits
.diameter:
	fcom	st0, st7
	fstsw	ax
	sahf
	jb	.printdiameter
	fmul	st0, st6
	inc	ebp
	jmp	short .diameter

.printdiameter:
	call	printnumber	; pinhole diameter

	; Calculate F-number

	fdivp	st1, st0
	fld	st0

	sub	ebp, ebp

.fnumber:
	fcom	st0, st6
	fstsw	ax
	sahf
	jb	.printfnumber
	fmul	st0, st5
	inc	ebp
	jmp	short .fnumber

.printfnumber:
	call	printnumber	; F number

	; Calculate normalized F-number
	fmul	st0, st0
	fld1
	fld	st1
	fyl2x
	frndint
	fld1
	fscale
	fsqrt
	fstp	st1

	sub	ebp, ebp
	call	printnumber

	; Calculate time multiplier from F-5.6

	fscale
	fld	st0

	; Round off to 4 significant digits
.fmul:
	fcom	st0, st6
	fstsw	ax
	sahf

	jb	.printfmul
	inc	ebp
	fmul	st0, st5
	jmp	short .fmul

.printfmul:
	call	printnumber	; F multiplier

	; Calculate F-stops from 5.6

	fld1
	fxch	st1
	fyl2x

	sub	ebp, ebp
	call	printnumber

	mov	al, 0Ah
	call	putchar
	jmp	.bigloop

.work0:
	mov	al, &#39;0&#39;
	call	putchar

align 4
.toobig:
	call	huh
	jmp	.bigloop

align 4
done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	finit

	; return success
	push	dword 0
	sys.exit

align 4
skiptoeol:
	; Keep reading until you come to cr, lf, or eof
	call	getchar
	jc	done
	cmp	al, 0Ah
	jne	.cr
	ret

.cr:
	cmp	al, 0Dh
	jne	skiptoeol
	ret

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	clc
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.empty
	sub	eax, eax
	ret

align 4
.empty:
	add	esp, byte 4
	stc
	ret

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret

align 4
bcdload:
	; EBP contains the number of chars in dbuffer
	push	ecx
	push	esi
	push	edi

	lea	ecx, [ebp+1]
	lea	esi, [dbuffer+ebp-1]
	shr	ecx, 1

	std

	mov	edi, bbuffer
	sub	eax, eax
	mov	[edi], eax
	mov	[edi+4], eax
	mov	[edi+2], ax

.loop:
	lodsw
	sub	ax, 3030h
	shl	al, 4
	or	al, ah
	mov	[edi], al
	inc	edi
	loop	.loop

	fbld	[bbuffer]

	cld
	pop	edi
	pop	esi
	pop	ecx
	sub	eax, eax
	ret

align 4
printnumber:
	push	ebp
	mov	al, [separ]
	call	putchar

	; Print the integer at the TOS
	mov	ebp, bbuffer+9
	fbstp	[bbuffer]

	; Check the sign
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jns	.leading

	; We got a negative number (should never happen)
	mov	al, &#39;-&#39;
	call	putchar

.leading:
	; Skip leading zeros
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jne	.first
	cmp	ebp, bbuffer
	jae	.leading

	; We are here because the result was 0.
	; Print &#39;0&#39; and return
	mov	al, &#39;0&#39;
	jmp	putchar

.first:
	; We have found the first non-zero.
	; But it is still packed
	test	al, 0F0h
	jz	.second
	push	eax
	shr	al, 4
	add	al, &#39;0&#39;
	call	putchar
	pop	eax
	and	al, 0Fh

.second:
	add	al, &#39;0&#39;
	call	putchar

.next:
	cmp	ebp, bbuffer
	jb	.done

	mov	al, [ebp]
	push	eax
	shr	al, 4
	add	al, &#39;0&#39;
	call	putchar
	pop	eax
	and	al, 0Fh
	add	al, &#39;0&#39;
	call	putchar

	dec	ebp
	jmp	short .next

.done:
	pop	ebp
	or	ebp, ebp
	je	.ret

.zeros:
	mov	al, &#39;0&#39;
	call	putchar
	dec	ebp
	jne	.zeros

.ret:
	ret</pre></div></div><div class=paragraph><p>Der Code folgt demselben Aufbau wie alle anderen Filter, die wir bisher gesehen haben, bis auf eine Kleinigkeit:</p></div><div class=paragraph><p>Wir nehmen nun nicht mehr an, daß das Ende der Eingabe auch das Ende der nötigen Arbeit bedeutet, etwas, das wir für <em>zeichenbasierte</em> Filter automatisch angenommen haben.</p></div><div class=paragraph><p>Dieser Filter verarbeitet keine Zeichen. Er verarbeitet eine <em>Sprache</em> (obgleich eine sehr einfache, die nur aus Zahlen besteht).</p></div><div class=paragraph><p>Wenn keine weiteren Eingaben vorliegen, kann das zwei Ursachen haben:</p></div><div class=ulist><ul><li><p>Wir sind fertig und können aufhören. Dies ist dasselbe wie vorher.</p></li><li><p>Das Zeichen, das wir eingelesen haben, war eine Zahl. Wir haben diese am Ende unseres ASCII -zu-float Kovertierungspuffers gespeichert. Wir müssen nun den gesamten Pufferinhalt in eine Zahl konvertieren, und die letzte Zeile unserer Ausgabe ausgeben.</p></li></ul></div><div class=paragraph><p>Aus diesem Grund haben wir unsere <code>getchar</code>- und <code>read</code>-Routinen so angepaßt, daß sie das <code>carry flag</code> <em>clear</em> immer dann zurückgeben, wenn wir ein weiteres Zeichen aus der Eingabe lesen, und das <code>carry flag</code> <em>set</em> immer dann zurückgeben, wenn es keine weiteren Eingabedaten gibt.</p></div><div class=paragraph><p>Selbstverständlich verwenden wir auch hier die Magie der Assemblersprache! Schauen Sie sich <code>getchar</code> näher an. Dieses gibt <em>immer</em> das <code>carry flag</code> <em>clear</em> zurück.</p></div><div class=paragraph><p>Dennoch basiert der Hauptteil unseres Programmes auf dem <code>carry flag</code>, um diesem eine Beendigung mitzuteilen-und es funktioniert.</p></div><div class=paragraph><p>Die Magie passiert in <code>read</code>. Wann immer weitere Eingaben durch das System zur Verfügung stehen, ruft diese Funktion <code>getchar</code> auf, welche ein weiteres Zeichen aus dem Eingabepuffer einliest, und anschließend das <code>carry flag</code> <em>clear</em>t.</p></div><div class=paragraph><p>Wenn aber <code>read</code> keine weiteren Eingaben von dem System bekommt, ruft dieses <em>nicht</em> <code>getchar</code> auf. Stattdessen addiert der op-Code <code>add esp, byte 4</code> 4 zu <code>ESP</code> hinzu, <em>setzt</em> das <code>carry flag</code>, und springt zurück.</p></div><div class=paragraph><p>Wo springt diese Funktion hin? Wann immer ein Programm den op-Code <code>call</code> verwendet, <code>push</code>t der Mikroprozessor die Rücksprungandresse, d.h. er speichert diese ganz oben auf dem Stack (nicht auf dem Stack der FPU, sondern auf dem Systemstack, der sich im Hauptspeicher befindet). Wenn ein Programm den op-Code <code>ret</code> verwendet, <code>pop</code>t der Mikroprozessor den Rückgabewert von dem Stack, und springt zu der Adresse, die dort gespeichert wurde.</p></div><div class=paragraph><p>Da wir aber 4 zu <code>ESP</code> hinzuaddiert haben (welches das Register der Stackzeiger ist), haben wir effektiv dem Mikroprzessor eine kleine <em>Amnesie</em> verpaßt: Dieser erinnert sich nun nicht mehr daran, daß <code>getchar</code> durch <code>read</code> aufgerufen wurde.</p></div><div class=paragraph><p>Und da <code>getchar</code> nichts vor dem Aufruf von <code>read</code> auf dem Stack abgelegt hat, enthält der Anfang des Stacks nun die Rücksprungadresse von der Funktion, die <code>getchar</code> aufgerufen hat. Soweit es den Aufrufer betrifft, hat dieser <code>getchar</code> ge<code>call</code>t, welche mit einem gesetzten <code>carry flag ret</code>urned.</p></div><div class=paragraph><p>Des weiteren wird die Routine <code>bcdload</code> bei einem klitzekleinen Problem zwischen der Big-Endian- und Little-Endian-Codierung aufgerufen.</p></div><div class=paragraph><p>Diese konvertiert die Textrepräsentation einer Zahl in eine andere Textrepräsentation: Der Text wird in der Big-Endian-Codierung gespeichert, die <em>packed decimal</em>-Darstellung jedoch in der Little-Endian-Codierung.</p></div><div class=paragraph><p>Um dieses Problem zu lösen haben wir vorher den op-Code <code>std</code> verwendet. Wir machen diesen Aufruf später mittels <code>cld</code> wieder rückgängig: Es ist sehr wichtig, daß wir keine Funktion mittels <code>call</code> aufrufen, die von einer Standardeinstellung des <em>Richtungsflags</em> abhängig ist, während <code>std</code> ausgeführt wird.</p></div><div class=paragraph><p>Alles weitere in dem Programm sollte leicht zu verstehen sein, vorausgesetzt, daß Sie das gesamte vorherige Kapitel gelesen haben.</p></div><div class=paragraph><p>Es ist ein klassisches Beispiel für das Sprichwort, daß das Programmieren eine Menge Denkarbeit, und nur ein wenig Programmcode benötigt. Sobald wir uns über jedes Detail im klaren sind, steht der Code fast schon da.</p></div></div><div class=sect2><h3 id=x86-pinhole-using>11.13.6. Das Programm pinhole verwenden<a class=anchor href=#x86-pinhole-using></a></h3><div class=paragraph><p>Da wir uns bei dem Programm dafür entschieden haben, alle Eingaben, die keine Zahlen sind, zu ignorieren (selbst die in Kommentaren), können wir jegliche <em>textbasierten Eingaben</em> verarbeiten. Wir <em>müssen</em> dies nicht tun, wir <em>könnten</em> aber.</p></div><div class=paragraph><p>Meiner bescheidenen Meinung nach wird ein Programm durch die Möglichkeit, anstatt einer strikten Eingabesyntax textbasierte Anfragen stellen zu können, sehr viel benutzerfreundlicher.</p></div><div class=paragraph><p>Angenommen, wir wollten eine Lochkamera für einen 4x5 Zoll Film bauen. Die standardmäßige Brennweite für diesen Film ist ungefähr 150mm. Wir wollen diesen Wert <em>optimieren</em>, so daß der Lochblendendurchmesser eine möglichst runde Zahl ergibt. Lassen Sie uns weiter annehmen, daß wir zwar sehr gut mit Kameras umgehen können, dafür aber nicht so gut mit Computern. Anstatt das wir nun eine Reihe von Zahlen eingeben, wollen wir lieber ein paar <em>Fragen</em> stellen.</p></div><div class=paragraph><p>Unsere Sitzung könnte wie folgt aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pinhole

Computer,

Wie groß müßte meine Lochblende bei einer Brennweite
von 150 sein?
150	490	306	362	2930	12
Hmmm... Und bei 160?
160	506	316	362	3125	12
Laß uns bitte 155 nehmen.
155	498	311	362	3027	12
Ah, laß uns 157 probieren...
157	501	313	362	3066	12
156?
156	500	312	362	3047	12
Das ist es! Perfekt! Vielen Dank!
^D</code></pre></div></div><div class=paragraph><p>Wir haben herausgefunden, daß der Lochblendendurchmesser bei einer Brennweite von 150 mm 490 Mikrometer, oder 0.49 mm ergeben würde. Bei einer fast identischen Brennweite von 156 mm würden wir einen Durchmesser von genau einem halben Millimeter bekommen.</p></div></div><div class=sect2><h3 id=x86-pinhole-scripting>11.13.7. Skripte schreiben<a class=anchor href=#x86-pinhole-scripting></a></h3><div class=paragraph><p>Da wir uns dafür entschieden haben, das Zeichen <span class=constant>#</span> als den Anfang eines Kommentares zu interpretieren, können wir unser pinhole-Programm auch als <em>Skriptsprache</em> verwenden.</p></div><div class=paragraph><p>Sie haben vielleicht schon einmal shell <em>-Skripte</em> gesehen, die mit folgenden Zeichen begonnen haben:</p></div><div class="literalblock programlisting"><div class=content><pre>#! /bin/sh</pre></div></div><div class=paragraph><p>oder</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh</pre></div></div><div class="olist lowerroman"><ol class=lowerroman type=i><li><p>da das Leerzeichen hinter dem <code>#!</code> optional ist.</p></li></ol></div><div class=paragraph><p>Wann immer UNIX® eine Datei ausführen soll, die mit einem <code>#!</code> beginnt, wird angenommen, das die Datei ein Skript ist. Es fügt den Befehl an das Ende der ersten Zeile an, und versucht dann, dieses auszuführen.</p></div><div class=paragraph><p>Angenommen, wir haben unser Programm pinhole unter /usr/local/bin/ installiert, dann können wir nun Skripte schreiben, um unterschiedliche Lochblendendurchmesser für mehrere Brennweiten zu berechnen, die normalerweise mit 120er Filmen verwendet werden.</p></div><div class=paragraph><p>Das Skript könnte wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>#! /usr/local/bin/pinhole -b -i
# Find the best pinhole diameter
# for the 120 film

### Standard
80

### Wide angle
30, 40, 50, 60, 70

### Telephoto
100, 120, 140</pre></div></div><div class=paragraph><p>Da ein 120er Film ein Film mittlerer Größe ist, könnten wir die Datei medium nennen.</p></div><div class=paragraph><p>Wir können die Datei ausführbar machen und dann aufrufen, als wäre es ein Programm:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>755 medium
% ./medium</code></pre></div></div><div class=paragraph><p>UNIX® wird den letzten Befehl wie folgt interpretieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% /usr/local/bin/pinhole <span class=nt>-b</span> <span class=nt>-i</span> ./medium</code></pre></div></div><div class=paragraph><p>Es wird den Befehl ausführen und folgendes ausgeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>80	358	224	256	1562	11
30	219	137	128	586	9
40	253	158	181	781	10
50	283	177	181	977	10
60	310	194	181	1172	10
70	335	209	181	1367	10
100	400	250	256	1953	11
120	438	274	256	2344	11
140	473	296	256	2734	11</code></pre></div></div><div class=paragraph><p>Lassen Sie uns nun das folgende eingeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./medium <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p>UNIX® wird dieses wie folgt behandeln:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% /usr/local/bin/pinhole <span class=nt>-b</span> <span class=nt>-i</span> ./medium <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p>Dadurch erhält das Programm zwei widersprüchliche Optionen: <span class=parameter>-b</span> und <span class=parameter>-c</span> (Verwende Benders Konstante und verwende Connors Konstante). Wir haben unser Programm so geschrieben, daß später eingelesene Optionen die vorheringen überschreiben-unser Programm wird also Connors Konstante für die Berechnungen verwenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>80	331	242	256	1826	11
30	203	148	128	685	9
40	234	171	181	913	10
50	262	191	181	1141	10
60	287	209	181	1370	10
70	310	226	256	1598	11
100	370	270	256	2283	11
120	405	296	256	2739	11
140	438	320	362	3196	12</code></pre></div></div><div class=paragraph><p>Wir entscheiden uns am Ende doch für Benders Konstante. Wir wollen die Ergebnisse im CSV-Format in einer Datei speichern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./medium <span class=nt>-b</span> <span class=nt>-e</span> <span class=o>&gt;</span> bender
% <span class=nb>cat </span>bender
focal length <span class=k>in </span>millimeters,pinhole diameter <span class=k>in </span>microns,F-number,normalized F-number,F-5.6 multiplier,stops from F-5.6
80,358,224,256,1562,11
30,219,137,128,586,9
40,253,158,181,781,10
50,283,177,181,977,10
60,310,194,181,1172,10
70,335,209,181,1367,10
100,400,250,256,1953,11
120,438,274,256,2344,11
140,473,296,256,2734,11
%</code></pre></div></div></div></div></div><div class=sect1><h2 id=x86-caveats>11.14. Vorsichtsmassnahmen<a class=anchor href=#x86-caveats></a></h2><div class=sectionbody><div class=paragraph><p>Assembler-Programmierer, die aufwuchsen mit MS-DOS® und windows Windows® neigen oft dazu Shotcuts zu verwenden. Das Lesen der Tastatur-Scancodes und das direkte Schreiben in den Grafikspeicher sind zwei klassische Beispiele von Gewohnheiten, die unter MS-DOS® nicht verpönt sind, aber nicht als richtig angesehen werden.</p></div><div class=paragraph><p>Warum dies? Sowohl das PC-BIOS als auch MS-DOS® sind notorisch langsam bei der Ausführung dieser Operationen.</p></div><div class=paragraph><p>Sie mögen versucht sein ähnliche Angewohnheiten in der UNIX®-Umgebung fortzuführen. Zum Beispiel habe ich eine Webseite gesehen, welche erklärt, wie man auf einem beliebten UNIX®-Ableger die Tastatur-Scancodes verwendet.</p></div><div class=paragraph><p>Das ist generell eine <em>sehr schlechte Idee</em> in einer UNIX®-Umgebung! Lassen Sie mich erklären warum.</p></div><div class=sect2><h3 id=x86-protected>11.14.1. UNIX® ist geschützt<a class=anchor href=#x86-protected></a></h3><div class=paragraph><p>Zum Einen mag es schlicht nicht möglich sein. UNIX® läuft im Protected Mode. Nur der Kernel und Gerätetreiber dürfen direkt auf die Hardware zugreifen. Unter Umständen erlaubt es Ihnen ein bestimmter UNIX®-Ableger Tastatur-Scancodes auszulesen, aber ein wirkliches UNIX®-Betriebssystem wird dies zu verhindern wissen. Und falls eine Version es Ihnen erlaubt wird es eine andere nicht tun, daher kann eine sorgfältig erstellte Software über Nacht zu einem überkommenen Dinosaurier werden.</p></div></div><div class=sect2><h3 id=x86-abstraction>11.14.2. UNIX® ist eine Abstraktion<a class=anchor href=#x86-abstraction></a></h3><div class=paragraph><p>Aber es gibt einen viel wichtigeren Grund, weshalb Sie nicht versuchen sollten, die Hardware direkt anzusprechen (natürlich nicht, wenn Sie einen Gerätetreiber schreiben), selbst auf den UNIX®-ähnlichen Systemen, die es Ihnen erlauben:</p></div><div class=paragraph><p><em>UNIX® ist eine Abstraktion!</em></p></div><div class=paragraph><p>Es gibt einen wichtigen Unterschied in der Design-Philosophie zwischen MS-DOS® und UNIX®. MS-DOS® wurde entworfen als Einzelnutzer-System. Es läuft auf einem Rechner mit einer direkt angeschlossenen Tastatur und einem direkt angeschlossenem Bildschirm. Die Eingaben des Nutzers kommen nahezu immer von dieser Tastatur. Die Ausgabe Ihres Programmes erscheint fast immer auf diesem Bildschirm.</p></div><div class=paragraph><p>Dies ist NIEMALS garantiert unter UNIX®. Es ist sehr verbreitet für ein UNIX®, daß der Nutzer seine Aus- und Eingaben kanalisiert und umleitet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% program1 | program2 | program3 <span class=o>&gt;</span> file1</code></pre></div></div><div class=paragraph><p>Falls Sie eine Anwendung program2 geschrieben haben, kommt ihre Eingabe nicht von der Tastatur, sondern von der Ausgabe von program1. Gleichermassen geht Ihre Ausgabe nicht auf den Bildschirm, sondern wird zur Eingabe für program3, dessen Ausgabe wiederum in <span class=filename>file1</span> endet.</p></div><div class=paragraph><p>Aber es gibt noch mehr! Selbst wenn Sie sichergestellt haben, daß Ihre Eingabe und Ausgabe zum Terminal kommt bzw. gelangt, dann ist immer noch nicht garantiert, daß ihr Terminal ein PC ist: Es mag seinen Grafikspeicher nicht dort haben, wo Sie ihn erwarten, oder die Tastatur könnte keine PC-ähnlichen Scancodes erzeugen können. Es mag ein Macintosh® oder irgendein anderer Rechner sein.</p></div><div class=paragraph><p>Sie mögen nun den Kopf schütteln: Mein Programm ist in PC-Assembler geschrieben, wie kann es auf einem Macintosh® laufen? Aber ich habe nicht gesagt, daß Ihr Programm auf Macintosh® läuft, nur sein Terminal mag ein Macintosh® sein.</p></div><div class=paragraph><p>Unter UNIX® muß der Terminal nicht direkt am Rechner angeschlossen sein, auf dem die Software läuft, er kann sogar auf einem anderen Kontinent sein oder sogar auf einem anderen Planeten. Es ist nicht ungewöhnlich, daß ein Macintosh®-Nutzer in Australien sich auf ein UNIX®-System in Nordamerika (oder sonstwo) mittels telnet verbindet. Die Software läuft auf einem Rechner während das Terminal sich auf einem anderen Rechner befindet: Falls Sie versuchen sollten die Scancodes auszulesen werden Sie die falschen Eingaben erhalten!</p></div><div class=paragraph><p>Das Gleiche gilt für jede andere Hardware: Eine Datei, welche Sie einlesen, mag auf einem Laufwerk sein, auf das Sie keinen direkten Zugriff haben. Eine Kamera, deren Bilder Sie auslesen, befindet sich möglicherweise in einem Space Shuttle, durch Satelliten mit Ihnen verbunden.</p></div><div class=paragraph><p>Das sind die Gründe, weshalb Sie niemals unter UNIX® Annahmen treffen dürfen, woher Ihre Daten kommen oder gehen. Lassen Sie immer das System den physischen Zugriff auf die Hardware regeln.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das sind Vorsichtsmassnahmen, keine absoluten Regeln. Ausnahmen sind möglich. Wenn zum Beispiel ein Texteditor bestimmt hat, daß er auf einer lokalen Maschine läuft, dann mag er die Tastatur-Scancodes direkt auslesen, um eine bessere Kontrolle zu gewährleisten. Ich erwähne diese Vorsichtsmassnahmen nicht, um Ihnen zu sagen, was sie tun oder lassen sollen, ich will Ihnen nur bewusst machen, daß es bestimmte Fallstricke gibt, die Sie erwarten, wenn Sie soeben ihn UNIX® von MS-DOS® angelangt sind. Kreative Menschen brechen oft Regeln und das ist in Ordnung, solange sie wissen welche Regeln und warum.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=x86-acknowledgements>11.15. Danksagungen<a class=anchor href=#x86-acknowledgements></a></h2><div class=sectionbody><div class=paragraph><p>Dieses Handbuch wäre niemals möglich gewesen ohne die Hilfe vieler erfahrener FreeBSD-Programmierer aus <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>FreeBSD technical discussions</a>. Viele dieser Personen haben geduldig meine Fragen beantwortet und mich in die richtige Richtung gewiesen bei meinem Versuch, die tieferen liegenden Mechanismen der UNIX®-Systemprogrammierung zu erforschen im Allgemeinen und bei FreeBSD im Besonderen.</p></div><div class=paragraph><p>Thomas M. Sommers öffnete die Türen für mich. Seine <a href=http://www.codebreakers-journal.com/content/view/262/27/>Wie schreibe ich "Hallo Welt" in FreeBSD-Assembler?</a> Webseite war mein erster Kontakt mit Assembler-Programmierung unter FreeBSD.</p></div><div class=paragraph><p>Jake Burkholder hat die Tür offen gehalten durch das bereitwillige Beantworten all meiner Fragen und das Zurverfügungstellen von Assembler-Codebeispielen.</p></div><div class=paragraph><p>Copyright ® 2000-2001 G. Adam Stanislav. Alle Rechte vorbehalten.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9. März 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/de/books/developers-handbook/partiv class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/de/books/developers-handbook/partv class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#x86-intro>11.1. Synopsis</a></li><li><a href=#x86-the-tools>11.2. Die Werkzeuge</a></li><li><a href=#x86-system-calls>11.3. Systemaufrufe</a></li><li><a href=#x86-return-values>11.4. Rückgabewerte</a></li><li><a href=#x86-portable-code>11.5. Portablen Code erzeugen</a></li><li><a href=#x86-first-program>11.6. Unser erstes Programm</a></li><li><a href=#x86-unix-filters>11.7. UNIX®-Filter schreiben</a></li><li><a href=#x86-buffered-io>11.8. Gepufferte Eingabe und Ausgabe</a></li><li><a href=#x86-command-line>11.9. Kommandozeilenparameter</a></li><li><a href=#x86-environment>11.10. Die UNIX®-Umgebung</a></li><li><a href=#x86-files>11.11. Arbeiten mit Dateien</a></li><li><a href=#x86-one-pointed-mind>11.12. One-Pointed Mind</a></li><li><a href=#x86-fpu>11.13. Die FPU verwenden</a></li><li><a href=#x86-caveats>11.14. Vorsichtsmassnahmen</a></li><li><a href=#x86-acknowledgements>11.15. Danksagungen</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/developers-handbook/developers-handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/de/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>