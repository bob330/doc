<!doctype html><html class=theme-light lang=de><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/><title>Kapitel 10. Kernel-Fehlersuche | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Kapitel 10. Kernel-Fehlersuche"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/de\/books\/developers-handbook\/kerneldebug\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/de/books>Books</a></li><li><a href=http://172.16.201.134:1313/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-b1b18a35567534d1699b4dd27b58b2ff class=toggle>
<label for=chapter-b1b18a35567534d1699b4dd27b58b2ff><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/parti/>Teil I. Grundlagen</a></li><li><input type=checkbox id=chapter-3af9d0cd3607fbe44d37e3a13957c40f class=toggle>
<label class="icon cursor" for=chapter-3af9d0cd3607fbe44d37e3a13957c40f><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/introduction/>Kapitel 1. Einführung</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/introduction/#introduction-devel>1.1. Unter FreeBSD entwickeln</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/introduction/#introduction-bsdvision>1.2. Die Vision von BSD</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/introduction/#introduction-archguide>1.3. Grundlegende Richtlinien</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/introduction/#introduction-layout>1.4. Der Aufbau von <span class=filename>/usr/src</span></a></li></ul></li><li><input type=checkbox id=chapter-15219234c513f9a79d9cb2d3bcf73d13 class=toggle>
<label class="icon cursor" for=chapter-15219234c513f9a79d9cb2d3bcf73d13><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/>Kapitel 2. Werkzeuge zur Programmierung</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-synopsis>2.1. Überblick</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-intro>2.2. Zusammenfassung</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-programming>2.3. Einführung in die Programmierung</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-compiling>2.4. Kompilieren mit dem <code>cc</code></a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-make>2.5. Make</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#debugging>2.6. Debuggen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#emacs>2.7. Emacs als Entwicklungsumgebung verwenden</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/tools/#tools-reading>2.8. Weiterführende Literatur</a></li></ul></li><li><input type=checkbox id=chapter-7319f5d899d5be33daaf1f2d5f180558 class=toggle>
<label class="icon cursor" for=chapter-7319f5d899d5be33daaf1f2d5f180558><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/>Kapitel 3. Sicheres Programmieren</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-synopsis>3.1. Zusammenfassung</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-philosophy>3.2. Methoden des sicheren Entwurfs</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-bufferov>3.3. Puffer-Überläufe</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-setuid>3.4. SetUID-Themen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-chroot>3.5. Die Umgebung ihrer Programme einschränken</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-trust>3.6. Vertrauen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/secure/#secure-race-conditions>3.7. Race-Conditions</a></li></ul></li><li><input type=checkbox id=chapter-0240ccaf7010beed911378cfab7bd8fc class=toggle>
<label class="icon cursor" for=chapter-0240ccaf7010beed911378cfab7bd8fc><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/l10n/>Kapitel 4. Lokalisierung und Internationalisierung - L10N und I18N</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/l10n/#l10n-programming>4.1. I18N-konforme Anwendungen programmieren</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/l10n/#posix-nls>4.2. Lokalisierte Nachrichten mit POSIX.1 Native Language Support (NLS)</a></li></ul></li><li><input type=checkbox id=chapter-c3107aaf64e60e1ee09bc33fc9fd641a class=toggle>
<label class="icon cursor" for=chapter-c3107aaf64e60e1ee09bc33fc9fd641a><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/>Kapitel 5. Vorgaben und Richtlinien für das Quelltextverzeichnis</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/#policies-style>5.1. Stil-Richtlinien</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/#policies-maintainer>5.2. <code>MAINTAINER</code> eines Makefiles</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/#policies-contributed>5.3. Beigesteuerte Software</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/#policies-encumbered>5.4. Belastende Dateien</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/policies/#policies-shlib>5.5. Shared-Libraries</a></li></ul></li><li><input type=checkbox id=chapter-c7b4fd5a7f8f049234fe3bc225acef44 class=toggle>
<label class="icon cursor" for=chapter-c7b4fd5a7f8f049234fe3bc225acef44><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/testing/>Kapitel 6. Regressions- und Performance-Tests</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/testing/#testing-micro-benchmark>6.1. Mikro-Benchmark-Checkliste</a></li></ul></li><li><input type=checkbox id=chapter-1f9b02a65f2bc5d4015a050d706fa837 class=toggle>
<label for=chapter-1f9b02a65f2bc5d4015a050d706fa837><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/partii/>Teil II. Interprozess-Kommunikation</a></li><li><input type=checkbox id=chapter-5e03777f678dd5731a581d7956d19c13 class=toggle>
<label for=chapter-5e03777f678dd5731a581d7956d19c13><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/sockets/>Kapitel 7. Sockets</a></li><li><input type=checkbox id=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3 class=toggle>
<label class="icon cursor" for=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/ipv6/>Kapitel 8. IPv6 Internals</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/ipv6/#ipv6-implementation>8.1. IPv6/IPsec-Implementierung</a></li></ul></li><li><input type=checkbox id=chapter-c9a07b517dc2e43d169c8e013e23cfc1 class=toggle>
<label for=chapter-c9a07b517dc2e43d169c8e013e23cfc1><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/partiii/>Teil III. Kernel</a></li><li><input type=checkbox id=chapter-db22f8e5e5e9496dbc711815e2e05f36 class=toggle>
<label class="icon cursor" for=chapter-db22f8e5e5e9496dbc711815e2e05f36><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/kernelbuild/>Kapitel 9. Einen FreeBSD-Kernel bauen und installieren</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kernelbuild/#kernelbuild-traditional>9.1. Einen Kernel auf die "traditionelle" Art und Weise bauen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kernelbuild/#kernelbuild-new>9.2. Einen Kernel auf die "neue" Art und Weise bauen</a></li></ul></li><li><input type=checkbox id=chapter-3036877c53948cfb76174f2776bbdf64 class=toggle checked>
<label class="icon cursor" for=chapter-3036877c53948cfb76174f2776bbdf64><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/>Kapitel 10. Kernel-Fehlersuche</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-obtain>10.1. Besorgen eines Speicherauszugs nach einem Kernel-Absturz (Kernel-Crash-Dump)</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-gdb>10.2. Fehlersuche in einem Speicherauszug nach einem Kernel-Absturz mit <code>kgdb</code></a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-ddd>10.3. Fehlersuche in einem Speicherauszug nach einem Absturz mit DDD</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-online-ddb>10.4. Online-Kernel-Fehlersuche mit DDB</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-online-gdb>10.5. Online-Kernel-Fehlersuche mit GDB auf einem entfernten System</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-console>10.6. Fehlersuche bei einem Konsolen-Treiber</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-deadlocks>10.7. Fehlersuche bei Deadlocks</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/kerneldebug/#kerneldebug-options>10.8. Glossar der Kernel-Optionen zur Fehlersuche</a></li></ul></li><li><input type=checkbox id=chapter-86707094ce48d6e89e5f45569c084cea class=toggle>
<label for=chapter-86707094ce48d6e89e5f45569c084cea><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/partiv/>Teil IV. Architekturen</a></li><li><input type=checkbox id=chapter-43b1e1e6d2a94eb8b161876bc22ce644 class=toggle>
<label class="icon cursor" for=chapter-43b1e1e6d2a94eb8b161876bc22ce644><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/>Kapitel 11. x86-Assembler-Programmierung</a><ul><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-intro>11.1. Synopsis</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-the-tools>11.2. Die Werkzeuge</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-system-calls>11.3. Systemaufrufe</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-return-values>11.4. Rückgabewerte</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-portable-code>11.5. Portablen Code erzeugen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-first-program>11.6. Unser erstes Programm</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-unix-filters>11.7. UNIX®-Filter schreiben</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-buffered-io>11.8. Gepufferte Eingabe und Ausgabe</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-command-line>11.9. Kommandozeilenparameter</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-environment>11.10. Die UNIX®-Umgebung</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-files>11.11. Arbeiten mit Dateien</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-one-pointed-mind>11.12. One-Pointed Mind</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-fpu>11.13. Die FPU verwenden</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-caveats>11.14. Vorsichtsmassnahmen</a></li><li><a href=http://172.16.201.134:1313/de/books/developers-handbook/x86/#x86-acknowledgements>11.15. Danksagungen</a></li></ul></li><li><input type=checkbox id=chapter-c49dfe630861d471fb2f58f5b554ed84 class=toggle>
<label for=chapter-c49dfe630861d471fb2f58f5b554ed84><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/partv/>Teil V. Anhang</a></li><li><input type=checkbox id=chapter-ac9541a3f38001d13964c1b0b324bb83 class=toggle>
<label for=chapter-ac9541a3f38001d13964c1b0b324bb83><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/developers-handbook/bibliography/>Literaturverzeichnis</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Kapitel 10. Kernel-Fehlersuche</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#kerneldebug-obtain>10.1. Besorgen eines Speicherauszugs nach einem Kernel-Absturz (Kernel-Crash-Dump)</a></li><li><a href=#kerneldebug-gdb>10.2. Fehlersuche in einem Speicherauszug nach einem Kernel-Absturz mit <code>kgdb</code></a></li><li><a href=#kerneldebug-ddd>10.3. Fehlersuche in einem Speicherauszug nach einem Absturz mit DDD</a></li><li><a href=#kerneldebug-online-ddb>10.4. Online-Kernel-Fehlersuche mit DDB</a></li><li><a href=#kerneldebug-online-gdb>10.5. Online-Kernel-Fehlersuche mit GDB auf einem entfernten System</a></li><li><a href=#kerneldebug-console>10.6. Fehlersuche bei einem Konsolen-Treiber</a></li><li><a href=#kerneldebug-deadlocks>10.7. Fehlersuche bei Deadlocks</a></li><li><a href=#kerneldebug-options>10.8. Glossar der Kernel-Optionen zur Fehlersuche</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=kerneldebug-obtain>10.1. Besorgen eines Speicherauszugs nach einem Kernel-Absturz (Kernel-Crash-Dump)<a class=anchor href=#kerneldebug-obtain></a></h2><div class=sectionbody><div class=paragraph><p>Wenn ein Entwicklungs-Kernel (z.B. FreeBSD-CURRENT) wie zum Beispiel ein Kernel unter Extrembedingungen (z.B. sehr hohe Belastungsraten (Load), eine äußerst hohe Anzahl an gleichzeitigen Benutzern, Hunderte <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>s usw.) eingesetzt oder eine neue Funktion oder ein neuer Gerätetreiber in FreeBSD-STABLE verwendet wird (z.B. PAE), tritt manchmal eine Kernel-Panic ein. In einem solchen Fall zeigt dieses Kapitel, wie dem Absturz nützliche Informationen entnommen werden können.</p></div><div class=paragraph><p>Bei Kernel-Panics ist ein Neustart unvermeidlich. Nachdem ein System neu gestartet wurde, ist der Inhalt des physikalischen Speichers (RAM), genauso wie jedes Bit, das sich vor der Panic auf dem Swap-Gerät befand, verloren. Um die Bits im physikalischen Speicher zu erhalten, zieht der Kernel Nutzen aus dem Swap-Gerät als vorübergehenden Ablageort, wo die Bits, welche sich im RAM befinden, auch nach einem Neustart nach einem Absturz verfügbar sind. Durch diese Vorgehensweise kann ein Kernel-Abbild, wenn FreeBSD nach einem Absturz startet, abgezogen und mit der Fehlersuche begonnen werden.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ein Swap-Gerät, das als Ausgabegerät (Dump-Device) konfiguriert wurde, verhält sich immer noch wie ein Swap-Gerät. Die Ausgabe auf Nicht-Swap-Geräte (wie zum Beispiel Bänder oder CDRWs) wird zur Zeit nicht unterstützt. Ein "Swap-Gerät" ist gleichbedeutend mit einer "Swap-Partition".</p></div></td></tr></tbody></table></div><div class=paragraph><p>Es stehen verschiedene Arten von Speicherabzügen zur Verfügung: komplette Speicherabzüge (full memory dumps), welche den gesamten Inhalt des physischen Speichers beinhalten, Miniauszüge (minidumps), die nur die gerade verwendeten Speicherseiten des Kernels enthalten (FreeBSD 6.2 und höhere Versionen) und Textauszüge (textdumps), welche geskriptete oder Debugger-Ausgaben enthalten (FreeBSD 7.1 und höher). Miniauszüge sind der Standardtyp der Abzüge seit FreeBSD 7.0 und fangen in den meisten Fällen alle nötigen Informationen ein, die in einem kompletten Kernel-Speicherabzug enthalten sind, da die meisten Probleme nur durch den Zustand des Kernels isoliert werden können.</p></div><div class=sect2><h3 id=config-dumpdev>10.1.1. Konfigurieren des Ausgabegeräts<a class=anchor href=#config-dumpdev></a></h3><div class=paragraph><p>Bevor der Kernel den Inhalt seines physikalischen Speichers auf einem Ausgabegerät ablegt, muss ein solches konfiguriert werden. Ein Ausgabegerät wird durch Benutzen des <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a>-Befehls festgelegt, um dem Kernel mitzuteilen, wohin die Speicherauszüge bei einem Kernel-Absturz gesichert werden sollen. Das <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a>-Programm muss aufgerufen werden, nachdem die Swap-Partition mit <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a> konfiguriert wurde. Dies wird normalerweise durch Setzen der <code>dumpdev</code>-Variable in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> auf den Pfad des Swap-Geräts (der empfohlene Weg, um einen Kernel-Speicherauszug zu entnehmen) bewerkstelligt, oder über <code>AUTO</code>, um die erste konfigurierte Swap-Partition zu verwenden. In HEAD ist die Standardeinstellung für <code>dumpdev</code><span class=filename>AUTO</span> und änderte sich in den RELENG_*-Zweigen (mit Ausnahme von RELENG_7, bei dem <code>AUTO</code> beibehalten wurde) auf <code>NO</code>. In FreeBSD 9.0-RELEASE und späteren Versionen fragt bsdinstall, ob Speicherauszüge für das Zielsystem während des Installationsvorgangs aktiviert werden sollen.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Vergleichen Sie <span class=filename>/etc/fstab</span> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=swapinfo&amp;sektion=8&amp;format=html">swapinfo(8)</a> für eine Liste der Swap-Geräte.</p></div></td></tr></tbody></table></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Stellen Sie sicher, dass das in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> festgelegte <code>dumpdir</code> vor einem Kernel-Absturz vorhanden ist.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/crash</span>
<span class=c># chmod 700 /var/crash</span></code></pre></div></div><div class=paragraph><p>Denken Sie auch daran, dass der Inhalt von <span class=filename>/var/crash</span> heikel ist und sehr wahrscheinlich vertrauliche Informationen wie Passwörter enthält.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=extract-dump>10.1.2. Entnehmen eines Kernel-Speicherauszugs (Kernel-Dump)<a class=anchor href=#extract-dump></a></h3><div class=paragraph><p>Sobald ein Speicherauszug auf ein Ausgabegerät geschrieben wurde, muss er entnommen werden, bevor das Swap-Gerät eingehängt wird. Um einen Speicherauszug aus einem Ausgabegerät zu entnehmen, benutzen Sie das <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a>-Programm. Falls <code>dumpdev</code> in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> gesetzt wurde, wird <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> automatisch beim ersten Start in den Multiuser-Modus nach dem Absturz und vor dem Einhängen des Swap-Geräts aufgerufen. Der Speicherort des entnommenen Kernels ist im <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>-Wert <code>dumpdir</code>, standardmäßig <span class=filename>/var/crash</span>, festgelegt und der Dateiname wird <span class=filename>vmcore.0</span> sein.</p></div><div class=paragraph><p>In dem Fall, dass bereits eine Datei mit dem Namen <span class=filename>vmcore.0</span> in <span class=filename>/var/crash</span> (oder auf was auch immer <code>dumpdir</code> gesetzt ist) vorhanden ist, erhöht der Kernel die angehängte Zahl bei jedem Absturz um eins und verhindert damit, dass ein vorhandener <span class=filename>vmcore</span> (z.B. <span class=filename>vmcore.1</span>) überschrieben wird. Während der Fehlersuche, möchten Sie höchst wahrscheinlich den <span class=filename>vmcore</span> mit der höchsten Version in <span class=filename>/var/crash</span> benutzen, wenn Sie den passenden <span class=filename>vmcore</span> suchen.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Falls Sie einen neuen Kernel testen, aber einen anderen starten müssen, um Ihr System wieder in Gang zu bringen, starten Sie es nur in den Singleuser-Modus, indem Sie das <code>-s</code>-Flag an der Boot-Eingabeaufforderung benutzen, und nehmen dann folgende Schritte vor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -p</span>
<span class=c># mount -a -t ufs       # make sure /var/crash is writable</span>
<span class=c># savecore /var/crash /dev/ad0s1b</span>
<span class=c># exit                  # exit to multi-user</span></code></pre></div></div><div class=paragraph><p>Dies weist <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> an, einen Kernel-Speicherauszug aus <span class=filename>/dev/ad0s1b</span> zu entnehmen und den Inhalt in <span class=filename>/var/crash</span> abzulegen. Vergessen Sie nicht sicherzustellen, dass das Zielverzeichnis <span class=filename>/var/crash</span> genug freien Speicherplatz für den Speicherauszug zur Verfügung hat. Vergessen Sie auch nicht, den korrekten Pfad des Swap-Geräts anzugeben, da es sehr wahrscheinlich anders als <span class=filename>/dev/ad0s1b</span> lautet!</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=kerneldebug-gdb>10.2. Fehlersuche in einem Speicherauszug nach einem Kernel-Absturz mit <code>kgdb</code><a class=anchor href=#kerneldebug-gdb></a></h2><div class=sectionbody><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dieser Abschnitt deckt <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> ab, wie es in FreeBSD 5.3 und später zu finden ist. In früheren Versionen muss <code>gdb -k</code> benutzt werden, um einen Kernspeicherauszug auszulesen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald ein Speicherauszug zur Verfügung steht, ist es recht einfach nützliche Informationen für einfache Probleme daraus zu bekommen. Bevor Sie sich auf die Interna von <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> stürzen, um die Fehler im Kernspeicherauszug zu suchen und zu beheben, machen Sie die Debug-Version Ihres Kernels (normalerweise <span class=filename>kernel.debug</span> genannt) und den Pfad der Quelldateien, die zum Bau Ihres Kernels verwendet wurden (normalerweise <span class=filename>/usr/obj/usr/src/sys/KERNCONF</span>, wobei <span class=filename>KERNCONF</span> das in einer Kernel-<a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a> festgelegte <code>ident</code> ist), ausfindig. Mit diesen beiden Informationen kann die Fehlersuche beginnen.</p></div><div class=paragraph><p>Um in den Debugger zu gelangen und mit dem Informationserhalt aus dem Speicherauszug zu beginnen, sind zumindest folgende Schritte nötig:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/obj/usr/src/sys/KERNCONF</span>
<span class=c># kgdb kernel.debug /var/crash/vmcore.0</span></code></pre></div></div><div class=paragraph><p>Sie können Fehler im Speicherauszug nach dem Absturz suchen, indem Sie die Kernel-Quellen benutzen, genauso wie Sie es bei jedem anderen Programm können.</p></div><div class=paragraph><p>Dieser erste Speicherauszug ist aus einem 5.2-BETA-Kernel und der Absturz ist tief im Kernel begründet. Die Ausgabe unten wurde dahingehend bearbeitet, dass sie nun Zeilennummern auf der linken Seite einschließt. Diese erste Ablaufverfolgung (Trace) untersucht den Befehlszeiger (Instruction-Pointer) und beschafft eine Zurückverfolgung (Back-Trace). Die Adresse, die in Zeile 41 für den <code>list</code>-Befehl benutzt wird, ist der Befehlszeiger und kann in Zeile 17 gefunden werden. Die meisten Entwickler wollen zumindest dies zugesendet bekommen, falls Sie das Problem nicht selber untersuchen und beheben können. Falls Sie jedoch das Problem lösen, stellen Sie sicher, dass Ihr Patch seinen Weg in den Quellbaum mittels eines Fehlerberichts, den Mailinglisten oder ihres Privilegs, zu committen, findet!</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 1:# <span class=nb>cd</span> /usr/obj/usr/src/sys/KERNCONF
 2:# kgdb kernel.debug /var/crash/vmcore.0
 3:GNU gdb 5.2.1 <span class=o>(</span>FreeBSD<span class=o>)</span>
 4:Copyright 2002 Free Software Foundation, Inc.
 5:GDB is free software, covered by the GNU General Public License, and you are
 6:welcome to change it and/or distribute copies of it under certain conditions.
 7:Type <span class=s2>&#34;show copying&#34;</span> to see the conditions.
 8:There is absolutely no warranty <span class=k>for </span>GDB.  Type <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
 9:This GDB was configured as <span class=s2>&#34;i386-undermydesk-freebsd&#34;</span>...
10:panic: page fault
11:panic messages:
12:---
13:Fatal <span class=nb>trap </span>12: page fault <span class=k>while in </span>kernel mode
14:cpuid <span class=o>=</span> 0<span class=p>;</span> apic <span class=nb>id</span> <span class=o>=</span> 00
15:fault virtual address   <span class=o>=</span> 0x300
16:fault code:             <span class=o>=</span> supervisor <span class=nb>read</span>, page not present
17:instruction pointer     <span class=o>=</span> 0x8:0xc0713860
18:stack pointer           <span class=o>=</span> 0x10:0xdc1d0b70
19:frame pointer           <span class=o>=</span> 0x10:0xdc1d0b7c
20:code segment            <span class=o>=</span> base 0x0, limit 0xfffff, <span class=nb>type </span>0x1b
21:                        <span class=o>=</span> DPL 0, pres 1, def32 1, gran 1
22:processor eflags        <span class=o>=</span> resume, IOPL <span class=o>=</span> 0
23:current process         <span class=o>=</span> 14394 <span class=o>(</span><span class=nb>uname</span><span class=o>)</span>
24:trap number             <span class=o>=</span> 12
25:panic: page fault
26      cpuid <span class=o>=</span> 0<span class=p>;</span>
27:Stack backtrace:
28
29:syncing disks, buffers remaining... 2199 2199 panic: mi_switch: switch <span class=k>in </span>a critical section
30:cpuid <span class=o>=</span> 0<span class=p>;</span>
31:Uptime: 2h43m19s
32:Dumping 255 MB
33: 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240
34:---
35:Reading symbols from /boot/kernel/snd_maestro3.ko...done.
36:Loaded symbols <span class=k>for</span> /boot/kernel/snd_maestro3.ko
37:Reading symbols from /boot/kernel/snd_pcm.ko...done.
38:Loaded symbols <span class=k>for</span> /boot/kernel/snd_pcm.ko
39:#0  doadump <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:240
40:240             dumping++<span class=p>;</span>
41:<span class=o>(</span>kgdb<span class=o>)</span> list <span class=k>*</span>0xc0713860
42:0xc0713860 is <span class=k>in </span>lapic_ipi_wait <span class=o>(</span>/usr/src/sys/i386/i386/local_apic.c:663<span class=o>)</span><span class=nb>.</span>
43:658                     incr <span class=o>=</span> 0<span class=p>;</span>
44:659                     delay <span class=o>=</span> 1<span class=p>;</span>
45:660             <span class=o>}</span> <span class=k>else
</span>46:661                     incr <span class=o>=</span> 1<span class=p>;</span>
47:662             <span class=k>for</span> <span class=o>(</span>x <span class=o>=</span> 0<span class=p>;</span> x &lt; delay<span class=p>;</span> x +<span class=o>=</span> incr<span class=o>)</span> <span class=o>{</span>
48:663                     <span class=k>if</span> <span class=o>((</span>lapic-&gt;icr_lo &amp; APIC_DELSTAT_MASK<span class=o>)</span> <span class=o>==</span> APIC_DELSTAT_IDLE<span class=o>)</span>
49:664                             <span class=k>return</span> <span class=o>(</span>1<span class=o>)</span><span class=p>;</span>
50:665                     ia32_pause<span class=o>()</span><span class=p>;</span>
51:666             <span class=o>}</span>
52:667             <span class=k>return</span> <span class=o>(</span>0<span class=o>)</span><span class=p>;</span>
53:<span class=o>(</span>kgdb<span class=o>)</span> backtrace
54:#0  doadump <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:240
55:#1  0xc055fd9b <span class=k>in </span>boot <span class=o>(</span><span class=nv>howto</span><span class=o>=</span>260<span class=o>)</span> at /usr/src/sys/kern/kern_shutdown.c:372
56:#2  0xc056019d <span class=k>in </span>panic <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:550
57:#3  0xc0567ef5 <span class=k>in </span>mi_switch <span class=o>()</span> at /usr/src/sys/kern/kern_synch.c:470
58:#4  0xc055fa87 <span class=k>in </span>boot <span class=o>(</span><span class=nv>howto</span><span class=o>=</span>256<span class=o>)</span> at /usr/src/sys/kern/kern_shutdown.c:312
59:#5  0xc056019d <span class=k>in </span>panic <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:550
60:#6  0xc0720c66 <span class=k>in </span>trap_fatal <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>0xdc1d0b30, <span class=nv>eva</span><span class=o>=</span>0<span class=o>)</span>
61:    at /usr/src/sys/i386/i386/trap.c:821
62:#7  0xc07202b3 <span class=k>in </span><span class=nb>trap</span> <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>
63:      <span class=o>{</span>tf_fs <span class=o>=</span> <span class=nt>-1065484264</span>, tf_es <span class=o>=</span> <span class=nt>-1065484272</span>, tf_ds <span class=o>=</span> <span class=nt>-1065484272</span>, tf_edi <span class=o>=</span> 1, tf_esi <span class=o>=</span> 0, tf_ebp <span class=o>=</span> <span class=nt>-602076292</span>, tf_isp <span class=o>=</span> <span class=nt>-602076324</span>, tf_ebx <span class=o>=</span> 0, tf_edx <span class=o>=</span> 0, tf_ecx <span class=o>=</span> 1000000, tf_eax <span class=o>=</span> 243, tf_trapno <span class=o>=</span> 12, tf_err <span class=o>=</span> 0, tf_eip <span class=o>=</span> <span class=nt>-1066321824</span>, tf_cs <span class=o>=</span> 8, tf_eflags <span class=o>=</span> 65671, tf_esp <span class=o>=</span> 243, tf_ss <span class=o>=</span> 0<span class=o>})</span>
64:    at /usr/src/sys/i386/i386/trap.c:250
65:#8  0xc070c9f8 <span class=k>in </span>calltrap <span class=o>()</span> at <span class=o>{</span>standard input<span class=o>}</span>:94
66:#9  0xc07139f3 <span class=k>in </span>lapic_ipi_vectored <span class=o>(</span><span class=nv>vector</span><span class=o>=</span>0, <span class=nv>dest</span><span class=o>=</span>0<span class=o>)</span>
67:    at /usr/src/sys/i386/i386/local_apic.c:733
68:#10 0xc0718b23 <span class=k>in </span>ipi_selected <span class=o>(</span><span class=nv>cpus</span><span class=o>=</span>1, <span class=nv>ipi</span><span class=o>=</span>1<span class=o>)</span>
69:    at /usr/src/sys/i386/i386/mp_machdep.c:1115
70:#11 0xc057473e <span class=k>in </span>kseq_notify <span class=o>(</span><span class=nv>ke</span><span class=o>=</span>0xcc05e360, <span class=nv>cpu</span><span class=o>=</span>0<span class=o>)</span>
71:    at /usr/src/sys/kern/sched_ule.c:520
72:#12 0xc0575cad <span class=k>in </span>sched_add <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
73:    at /usr/src/sys/kern/sched_ule.c:1366
74:#13 0xc05666c6 <span class=k>in </span>setrunqueue <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcc05e360<span class=o>)</span>
75:    at /usr/src/sys/kern/kern_switch.c:422
76:#14 0xc05752f4 <span class=k>in </span>sched_wakeup <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
77:    at /usr/src/sys/kern/sched_ule.c:999
78:#15 0xc056816c <span class=k>in </span>setrunnable <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
79:    at /usr/src/sys/kern/kern_synch.c:570
80:#16 0xc0567d53 <span class=k>in </span>wakeup <span class=o>(</span><span class=nv>ident</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
81:    at /usr/src/sys/kern/kern_synch.c:411
82:#17 0xc05490a8 <span class=k>in </span>exit1 <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5b40, <span class=nv>rv</span><span class=o>=</span>0<span class=o>)</span>
83:    at /usr/src/sys/kern/kern_exit.c:509
84:#18 0xc0548011 <span class=k>in </span>sys_exit <span class=o>()</span> at /usr/src/sys/kern/kern_exit.c:102
85:#19 0xc0720fd0 <span class=k>in </span>syscall <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>
86:      <span class=o>{</span>tf_fs <span class=o>=</span> 47, tf_es <span class=o>=</span> 47, tf_ds <span class=o>=</span> 47, tf_edi <span class=o>=</span> 0, tf_esi <span class=o>=</span> <span class=nt>-1</span>, tf_ebp <span class=o>=</span> <span class=nt>-1077940712</span>, tf_isp <span class=o>=</span> <span class=nt>-602075788</span>, tf_ebx <span class=o>=</span> 672411944, tf_edx <span class=o>=</span> 10, tf_ecx <span class=o>=</span> 672411600, tf_eax <span class=o>=</span> 1, tf_trapno <span class=o>=</span> 12, tf_err <span class=o>=</span> 2, tf_eip <span class=o>=</span> 671899563, tf_cs <span class=o>=</span> 31, tf_eflags <span class=o>=</span> 642, tf_esp <span class=o>=</span> <span class=nt>-1077940740</span>, tf_ss <span class=o>=</span> 47<span class=o>})</span>
87:    at /usr/src/sys/i386/i386/trap.c:1010
88:#20 0xc070ca4d <span class=k>in </span>Xint0x80_syscall <span class=o>()</span> at <span class=o>{</span>standard input<span class=o>}</span>:136
89:---Can<span class=s1>&#39;t read userspace from dump, or kernel process---
90:(kgdb) quit</span></code></pre></div></div><div class=paragraph><p>Diese nächste Ablaufverfolgung ist ein älterer Speicherauszug aus FreeBSD 2-Zeiten, aber ist komplizierter und zeigt mehr der <code>gdb</code>-Funktionen. Lange Zeilen wurden gefaltet, um die Lesbarkeit zu verbessern, und die Zeilen wurden zur Verweisung nummeriert. Trotzdem ist es eine reale Fehlerverfolgung (Error-Trace), die während der Entwicklung des pcvt-Konsolentreibers entstanden ist.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 1:Script started on Fri Dec 30 23:15:22 1994
 2:# <span class=nb>cd</span> /sys/compile/URIAH
 3:# gdb <span class=nt>-k</span> kernel /var/crash/vmcore.1
 4:Reading symbol data from /usr/src/sys/compile/URIAH/kernel
...done.
 5:IdlePTD 1f3000
 6:panic: because you said to!
 7:current pcb at 1e3f70
 8:Reading <span class=k>in </span>symbols <span class=k>for</span> ../../i386/i386/machdep.c...done.
 9:<span class=o>(</span>kgdb<span class=o>)</span> backtrace
10:#0  boot <span class=o>(</span><span class=nv>arghowto</span><span class=o>=</span>256<span class=o>)</span> <span class=o>(</span>../../i386/i386/machdep.c line 767<span class=o>)</span>
11:#1  0xf0115159 <span class=k>in </span>panic <span class=o>()</span>
12:#2  0xf01955bd <span class=k>in </span>diediedie <span class=o>()</span> <span class=o>(</span>../../i386/i386/machdep.c line 698<span class=o>)</span>
13:#3  0xf010185e <span class=k>in </span>db_fncall <span class=o>()</span>
14:#4  0xf0101586 <span class=k>in </span>db_command <span class=o>(</span><span class=nt>-266509132</span>, <span class=nt>-266509516</span>, <span class=nt>-267381073</span><span class=o>)</span>
15:#5  0xf0101711 <span class=k>in </span>db_command_loop <span class=o>()</span>
16:#6  0xf01040a0 <span class=k>in </span>db_trap <span class=o>()</span>
17:#7  0xf0192976 <span class=k>in </span>kdb_trap <span class=o>(</span>12, 0, <span class=nt>-272630436</span>, <span class=nt>-266743723</span><span class=o>)</span>
18:#8  0xf019d2eb <span class=k>in </span>trap_fatal <span class=o>(</span>...<span class=o>)</span>
19:#9  0xf019ce60 <span class=k>in </span>trap_pfault <span class=o>(</span>...<span class=o>)</span>
20:#10 0xf019cb2f <span class=k>in </span><span class=nb>trap</span> <span class=o>(</span>...<span class=o>)</span>
21:#11 0xf01932a1 <span class=k>in </span>exception:calltrap <span class=o>()</span>
22:#12 0xf0191503 <span class=k>in </span>cnopen <span class=o>(</span>...<span class=o>)</span>
23:#13 0xf0132c34 <span class=k>in </span>spec_open <span class=o>()</span>
24:#14 0xf012d014 <span class=k>in </span>vn_open <span class=o>()</span>
25:#15 0xf012a183 <span class=k>in </span>open <span class=o>()</span>
26:#16 0xf019d4eb <span class=k>in </span>syscall <span class=o>(</span>...<span class=o>)</span>
27:<span class=o>(</span>kgdb<span class=o>)</span> up 10
28:Reading <span class=k>in </span>symbols <span class=k>for</span> ../../i386/i386/trap.c...done.
29:#10 0xf019cb2f <span class=k>in </span><span class=nb>trap</span> <span class=o>(</span><span class=nv>frame</span><span class=o>={</span>tf_es <span class=o>=</span> <span class=nt>-260440048</span>, tf_ds <span class=o>=</span> 16, tf_<span class=se>\</span>
30:edi <span class=o>=</span> 3072, tf_esi <span class=o>=</span> <span class=nt>-266445372</span>, tf_ebp <span class=o>=</span> <span class=nt>-272630356</span>, tf_isp <span class=o>=</span> <span class=nt>-27</span><span class=se>\</span>
31:2630396, tf_ebx <span class=o>=</span> <span class=nt>-266427884</span>, tf_edx <span class=o>=</span> 12, tf_ecx <span class=o>=</span> <span class=nt>-266427884</span>, tf<span class=se>\</span>
32:_eax <span class=o>=</span> 64772224, tf_trapno <span class=o>=</span> 12, tf_err <span class=o>=</span> <span class=nt>-272695296</span>, tf_eip <span class=o>=</span> <span class=nt>-26</span><span class=se>\</span>
33:6672343, tf_cs <span class=o>=</span> <span class=nt>-266469368</span>, tf_eflags <span class=o>=</span> 66066, tf_esp <span class=o>=</span> 3072, tf_<span class=se>\</span>
34:ss <span class=o>=</span> <span class=nt>-266427884</span><span class=o>})</span> <span class=o>(</span>../../i386/i386/trap.c line 283<span class=o>)</span>
35:283                             <span class=o>(</span>void<span class=o>)</span> trap_pfault<span class=o>(</span>&amp;frame, FALSE<span class=o>)</span><span class=p>;</span>
36:<span class=o>(</span>kgdb<span class=o>)</span> frame frame-&gt;tf_ebp frame-&gt;tf_eip
37:Reading <span class=k>in </span>symbols <span class=k>for</span> ../../i386/isa/pcvt/pcvt_drv.c...done.
38:#0  0xf01ae729 <span class=k>in </span>pcopen <span class=o>(</span><span class=nv>dev</span><span class=o>=</span>3072, <span class=nv>flag</span><span class=o>=</span>3, <span class=nv>mode</span><span class=o>=</span>8192, <span class=nv>p</span><span class=o>=(</span>struct p<span class=se>\</span>
39:roc <span class=k>*</span><span class=o>)</span> 0xf07c0c00<span class=o>)</span> <span class=o>(</span>../../i386/isa/pcvt/pcvt_drv.c line 403<span class=o>)</span>
40:403             <span class=k>return</span> <span class=o>((</span><span class=k>*</span>linesw[tp-&gt;t_line].l_open<span class=o>)(</span>dev, tp<span class=o>))</span><span class=p>;</span>
41:<span class=o>(</span>kgdb<span class=o>)</span> list
42:398
43:399             tp-&gt;t_state |<span class=o>=</span> TS_CARR_ON<span class=p>;</span>
44:400             tp-&gt;t_cflag |<span class=o>=</span> CLOCAL<span class=p>;</span>  /<span class=k>*</span> cannot be a modem <span class=o>(</span>:-<span class=o>)</span> <span class=k>*</span>/
45:401
46:402     <span class=c>#if PCVT_NETBSD || (PCVT_FREEBSD &gt;= 200)</span>
47:403             <span class=k>return</span> <span class=o>((</span><span class=k>*</span>linesw[tp-&gt;t_line].l_open<span class=o>)(</span>dev, tp<span class=o>))</span><span class=p>;</span>
48:404     <span class=c>#else</span>
49:405             <span class=k>return</span> <span class=o>((</span><span class=k>*</span>linesw[tp-&gt;t_line].l_open<span class=o>)(</span>dev, tp, flag<span class=o>))</span><span class=p>;</span>
50:406     <span class=c>#endif /* PCVT_NETBSD || (PCVT_FREEBSD &gt;= 200) */</span>
51:407     <span class=o>}</span>
52:<span class=o>(</span>kgdb<span class=o>)</span> print tp
53:Reading <span class=k>in </span>symbols <span class=k>for</span> ../../i386/i386/cons.c...done.
54:<span class=nv>$1</span> <span class=o>=</span> <span class=o>(</span>struct <span class=nb>tty</span> <span class=k>*</span><span class=o>)</span> 0x1bae
55:<span class=o>(</span>kgdb<span class=o>)</span> print tp-&gt;t_line
56:<span class=nv>$2</span> <span class=o>=</span> 1767990816
57:<span class=o>(</span>kgdb<span class=o>)</span> up
58:#1  0xf0191503 <span class=k>in </span>cnopen <span class=o>(</span><span class=nv>dev</span><span class=o>=</span>0x00000000, <span class=nv>flag</span><span class=o>=</span>3, <span class=nv>mode</span><span class=o>=</span>8192, <span class=nv>p</span><span class=o>=(</span>st<span class=se>\</span>
59:ruct proc <span class=k>*</span><span class=o>)</span> 0xf07c0c00<span class=o>)</span> <span class=o>(</span>../../i386/i386/cons.c line 126<span class=o>)</span>
60:       <span class=k>return</span> <span class=o>((</span><span class=k>*</span>cdevsw[major<span class=o>(</span>dev<span class=o>)]</span>.d_open<span class=o>)(</span>dev, flag, mode, p<span class=o>))</span><span class=p>;</span>
61:<span class=o>(</span>kgdb<span class=o>)</span> up
62:#2  0xf0132c34 <span class=k>in </span>spec_open <span class=o>()</span>
63:<span class=o>(</span>kgdb<span class=o>)</span> up
64:#3  0xf012d014 <span class=k>in </span>vn_open <span class=o>()</span>
65:<span class=o>(</span>kgdb<span class=o>)</span> up
66:#4  0xf012a183 <span class=k>in </span>open <span class=o>()</span>
67:<span class=o>(</span>kgdb<span class=o>)</span> up
68:#5  0xf019d4eb <span class=k>in </span>syscall <span class=o>(</span><span class=nv>frame</span><span class=o>={</span>tf_es <span class=o>=</span> 39, tf_ds <span class=o>=</span> 39, tf_edi <span class=o>=</span><span class=se>\</span>
69: 2158592, tf_esi <span class=o>=</span> 0, tf_ebp <span class=o>=</span> <span class=nt>-272638436</span>, tf_isp <span class=o>=</span> <span class=nt>-272629788</span>, tf<span class=se>\</span>
70:_ebx <span class=o>=</span> 7086, tf_edx <span class=o>=</span> 1, tf_ecx <span class=o>=</span> 0, tf_eax <span class=o>=</span> 5, tf_trapno <span class=o>=</span> 582, <span class=se>\</span>
71:tf_err <span class=o>=</span> 582, tf_eip <span class=o>=</span> 75749, tf_cs <span class=o>=</span> 31, tf_eflags <span class=o>=</span> 582, tf_esp <span class=se>\</span>
72:<span class=o>=</span> <span class=nt>-272638456</span>, tf_ss <span class=o>=</span> 39<span class=o>})</span> <span class=o>(</span>../../i386/i386/trap.c line 673<span class=o>)</span>
73:673             error <span class=o>=</span> <span class=o>(</span><span class=k>*</span>callp-&gt;sy_call<span class=o>)(</span>p, args, rval<span class=o>)</span><span class=p>;</span>
74:<span class=o>(</span>kgdb<span class=o>)</span> up
75:Initial frame selected<span class=p>;</span> you cannot go up.
76:<span class=o>(</span>kgdb<span class=o>)</span> quit</code></pre></div></div><div class=paragraph><p>Kommentare zum Skript oben:</p></div><div class=dlist><dl><dt class=hdlist1>Zeile 6</dt><dd><p>Dies ist ein Speicherauszug, der innerhalb von DDB genommen wurde (siehe unten), deswegen der Kommentar zur Panic "because you said to!" und die eher lange Stack-Ablaufverfolgung (Stack-Trace); der anfängliche Grund für das Starten von DDB war jedoch ein Seitenfehler-Trap (Page-Fault-Trap).</p></dd><dt class=hdlist1>Zeile 20</dt><dd><p>Dies ist die Position der Funktion <code>trap()</code> in der Stack-Ablaufverfolgung.</p></dd><dt class=hdlist1>Zeile 36</dt><dd><p>Erzwingt die Benutzung eines neuen Stack-Frames; dies ist nicht mehr notwendig. Die Stack-Frames sollen jetzt an die richtige Stelle im Speicher zeigen, selbst im Falle eines Traps. Nach einem Blick auf den Code in Zeile 403 ergibt sich mit hoher Wahrscheinlichkeit, dass entweder der Zeigerzugriff auf "tp" fehlerbehaftet oder der Array-Zugriff unerlaubt war.</p></dd><dt class=hdlist1>Zeile 52</dt><dd><p>Der Zeiger scheint verdächtig, aber besitzt zufällig eine gültige Adresse.</p></dd><dt class=hdlist1>Zeile 56</dt><dd><p>Jedoch zeigt er offensichtlich auf nichts und so haben wir unseren Fehler gefunden! (Für diejenigen, die nichts mit diesem speziellen Stück Code anfangen können: <code>tp→t_line</code> verweist hier auf das Zeilenverhalten (Line-Discipline) des Konsolen-Geräts, was eine ziemlich kleine Ganzzahl (Integer) sein muss.)</p></dd></dl></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Falls Ihr System regelmäßig abstürzt und und Sie bald keinen freien Speicherplatz mehr zur Verfügung haben, könnte das Löschen alter <span class=filename>vmcore</span>-Dateien in <span class=filename>/var/core</span> einen beträchtlichen Betrag an Speicherplatz einsparen.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=kerneldebug-ddd>10.3. Fehlersuche in einem Speicherauszug nach einem Absturz mit DDD<a class=anchor href=#kerneldebug-ddd></a></h2><div class=sectionbody><div class=paragraph><p>Die Untersuchung eines Speicherauszugs nach einem Kernel-Absturz mit einem grafischen Debugger wie <code>ddd</code> ist auch möglich (Sie müssen den <a class=package href=https://cgit.freebsd.org/ports/tree/devel/ddd/>devel/ddd</a>-Port installieren, um den <code>ddd</code>-Debugger benutzen zu können). Nehmen Sie die <code>-k</code> mit in die <code>ddd</code>-Kommandozeile auf, die Sie normalerweise benutzen würden. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ddd --debugger kgdb kernel.debug /var/crash/vmcore.0</span></code></pre></div></div><div class=paragraph><p>Sie sollten nun in der Lage sein, die Untersuchung des Speicherauszugs nach dem Absturz unter Benutzung der grafischen Schnittstelle von <code>ddd</code> anzugehen.</p></div></div></div><div class=sect1><h2 id=kerneldebug-online-ddb>10.4. Online-Kernel-Fehlersuche mit DDB<a class=anchor href=#kerneldebug-online-ddb></a></h2><div class=sectionbody><div class=paragraph><p>Während <code>kgdb</code> als Offline-Debugger eine Benutzerschnittstelle auf höchster Ebene bietet, gibt es einige Dinge, die es nicht kann. Die wichtigsten sind das Setzen von Breakpoints und das Abarbeiten des Kernel-Codes in Einzelschritten (Single-Stepping).</p></div><div class=paragraph><p>Falls Sie eine systemnahe Fehlersuche an Ihrem Kernel vorhaben, steht Ihnen ein Online-Debugger mit dem Namen DDB zur Verfügung. Er erlaubt Ihnen das Setzen von Breakpoints, die Abarbeitung von Kernel-Funktionen in Einzelschritten, das Untersuchen und Verändern von Kernel-Variablen usw. Jedoch hat er keinen Zugriff auf Kernel-Quelldateien, sondern kann nur, im Gegensatz zu <code>gdb</code>, welches auf die ganzen Informationen zur Fehlersuche zurückgreifen kann, auf globale und statische Symbole zugreifen.</p></div><div class=paragraph><p>Um DDB in Ihren Kernel einzubinden, fügen Sie die Optionen</p></div><div class="literalblock programlisting"><div class=content><pre>options KDB</pre></div></div><div class="literalblock programlisting"><div class=content><pre>options DDB</pre></div></div><div class=paragraph><p>Ihrer Konfigurationsdatei hinzu und bauen Sie den Kernel neu. (Details zur Konfiguration des FreeBSD-Kernels finden Sie im <a href=https://docs.freebsd.org/de/books/handbook/>FreeBSD-Handbuch</a>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls Sie eine ältere Version des Boot-Blocks haben, könnte es sein, dass Ihre Symbole zur Fehlersuche noch nicht einmal geladen werden. Aktualisieren Sie den Boot-Block; aktuelle Versionen laden die DDB-Symbole automatisch.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald Ihr Kernel mit DDB startet, gibt es mehrere Wege, um in DDB zu gelangen. Der erste und früheste Weg ist, das Boot-Flag <code>-d</code> gleich an der Boot-Eingabeaufforderung einzugeben. Der Kernel startet dann in den Debug-Modus und betritt DDB noch vor jedweder Gerätesuche. Somit können Sie Funktionen zur Gerätesuche/-bereitstellung auf Fehler untersuchen. FreeBSD-CURRENT-Benutzer müssen die sechste Option im Boot-Menü auswählen, um an eine Eingabeaufforderung zu gelangen.</p></div><div class=paragraph><p>Das zweite Szenario ist der Gang in den Debugger, sobald das System schon gestartet ist. Es gibt zwei einfache Wege dies zu erreichen. Falls Sie von der Eingabeaufforderung aus in den Debugger gelangen möchten, geben Sie einfach folgenden Befehl ab:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.kdb.enter=1</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um eine schnelle Panic zu erzwingen, geben Sie das folgende Kommando ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.kdb.panic=1</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Anderenfalls können Sie ein Tastenkürzel auf der Tastatur benutzen, wenn Sie an der Systemkonsole sind. Die Voreinstellung für die break-to-debugger-Sequenz ist <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>ESC</kbd></span>. In syscons kann diese Sequenz auf eine andere Tastenkombination gelegt werden (remap) und manche der verfügbaren Tastaturlayouts tun dies, stellen Sie also sicher, dass Sie die richtige Sequenz kennen, die benutzt werden soll. Für serielle Konsolen ist eine Option vorhanden, die die Benutzung einer Unterbrechung der seriellen Verbindung (BREAK) auf der Kommandozeile erlaubt, um in DDB zu gelangen (<code>options BREAK_TO_DEBUGGER</code> in der Kernel-Konfigurationsdatei). Dies ist jedoch nicht der Standard, da viele serielle Adapter in Verwendung sind, die grundlos eine BREAK-Bedingung erzeugen, zum Beispiel bei Ziehen des Kabels.</p></div><div class=paragraph><p>Die dritte Möglichkeit ist, dass jede Panic-Bedingung in DDB springt, falls der Kernel hierfür konfiguriert ist. Aus diesem Grund ist es nicht sinnvoll einen Kernel mit DDB für ein unbeaufsichtigtes System zu konfigurieren.</p></div><div class=paragraph><p>Um die unbeaufsichtigte Funktionsweise zu erreichen fügen Sie:</p></div><div class="literalblock programlisting"><div class=content><pre>options	KDB_UNATTENDED</pre></div></div><div class=paragraph><p>der Kernel-Konfigurationsdatei hinzu und bauen/installieren Sie den Kernel neu.</p></div><div class=paragraph><p>Die DDB-Befehle ähneln grob einigen <code>gdb</code>-Befehlen. Das Erste, das Sie vermutlich tun müssen, ist einen Breakpoint zu setzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>break </span><span class=k>function</span><span class=nt>-name</span> address</code></pre></div></div><div class=paragraph><p>Zahlen werden standardmäßig hexadezimal angegeben, aber um sie von Symbolnamen zu unterscheiden, muss Zahlen, die mit den Buchstaben <code>a-f</code> beginnen, <code>0x</code> vorangehen (dies ist für andere Zahlen beliebig). Einfache Ausdrücke sind erlaubt, zum Beispiel: <code>function-name + 0x103</code>.</p></div><div class=paragraph><p>Um den Debugger zu verlassen und mit der Abarbeitung fortzufahren, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=k>continue</span></code></pre></div></div><div class=paragraph><p>Um eine Stack-Ablaufverfolgung zu erhalten, benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> trace</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Beachten Sie, dass wenn Sie DDB mittels einer Schnelltaste betreten, der Kernel zurzeit einen Interrupt bereitstellt, sodass die Stack-Ablaufverfolgung Ihnen nicht viel nützen könnte.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Falls Sie einen Breakpoint entfernen möchten, benutzen Sie</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> del
 del address-expression</code></pre></div></div><div class=paragraph><p>Die erste Form wird direkt, nachdem ein Breakpoint anschlug, angenommen und entfernt den aktuellen Breakpoint. Die zweite kann jeden Breakpoint löschen, aber Sie müssen die genaue Adresse angeben; diese kann bezogen werden durch:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> show b</code></pre></div></div><div class=paragraph><p>oder:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> show <span class=nb>break</span></code></pre></div></div><div class=paragraph><p>Um den Kernel in Einzelschritten auszuführen, probieren Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> s</code></pre></div></div><div class=paragraph><p>Dies springt in Funktionen, aber Sie können DDB veranlassen, diese schrittweise zu verfolgen, bis die passende Rückkehranweisung (Return-Statement) erreicht ist. Nutzen Sie hierzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> n</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dies ist nicht das gleiche wie die <code>next</code>-Anweisung von <code>gdb</code>; es ist wie <code>gdb</code>s <code>finish</code>. Mehrmaliges Drücken von <kbd>n</kbd> führt zu einer Fortsetzung.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um Daten aus dem Speicher zu untersuchen, benutzen Sie (zum Beispiel):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>x/wx 0xf0133fe0,40
x/hd db_symtab_space
x/bc termbuf,10
x/s stringbuf</code></pre></div></div><div class=paragraph><p>für Word/Halfword/Byte-Zugriff und Hexadezimal/Dezimal/Character/String-Ausgabe. Die Zahl nach dem Komma ist der Objektzähler. Um die nächsten 0x10 Objekte anzuzeigen benutzen Sie einfach:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> x ,10</code></pre></div></div><div class=paragraph><p>Gleichermaßen benutzen Sie</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> x/ia foofunc,10</code></pre></div></div><div class=paragraph><p>um die ersten 0x10 Anweisungen aus <code>foofunc</code> zu zerlegen (disassemble) und Sie zusammen mit ihrem Adressabstand (Offset) vom Anfang von <code>foofunc</code> auszugeben.</p></div><div class=paragraph><p>Um Speicher zu verändern benutzen Sie den Schreibbefehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> w/b termbuf 0xa 0xb 0
 w/w 0xf0010030 0 0</code></pre></div></div><div class=paragraph><p>Die Befehlsoption (<code>b</code>/<code>h</code>/<code>w</code>) legt die Größe der Daten fest, die geschrieben werden sollen, der erste Ausdruck danach ist die Adresse, wohin geschrieben werden soll, und der Rest wird als Daten verarbeitet, die in aufeinander folgende Speicherstellen geschrieben werden.</p></div><div class=paragraph><p>Falls Sie die aktuellen Register wissen möchten, benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> show reg</code></pre></div></div><div class=paragraph><p>Alternativ können Sie den Inhalt eines einzelnen Registers ausgeben mit z.B.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> p <span class=nv>$eax</span></code></pre></div></div><div class=paragraph><p>und ihn bearbeiten mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set</span> <span class=nv>$eax</span> new-value</code></pre></div></div><div class=paragraph><p>Sollten Sie irgendeine Kernel-Funktion aus DDB heraus aufrufen wollen, geben Sie einfach ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> call func<span class=o>(</span>arg1, arg2, ...<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Der Rückgabewert wird ausgegeben.</p></div><div class=paragraph><p>Für eine Zusammenfassung aller laufenden Prozesse im Stil von <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> ps</code></pre></div></div><div class=paragraph><p>Nun haben Sie herausgefunden, warum Ihr Kernel fehlschlägt, und möchten neu starten. Denken Sie daran, dass, abhängig von der Schwere vorhergehender Störungen, nicht alle Teile des Kernels wie gewohnt funktionieren könnten. Führen Sie eine der folgenden Aktionen durch, um Ihr System herunterzufahren und neu zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> panic</code></pre></div></div><div class=paragraph><p>Dies wird Ihren Kernel dazu veranlassen abzustürzen, einen Speicherauszug abzulegen und neu zu starten, sodass Sie den Kernspeicherauszug später auf höherer Ebene mit <code>gdb</code> auswerten können. Diesem Befehl muss normalerweise eine weitere <code>continue</code>-Anweisung folgen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> call boot<span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Dürfte ein guter Weg sein, um das laufende System sauber herunterzufahren, alle Festplatten mittels <code>sync()</code> zu schreiben und schließlich, in manchen Fällen, neu zu starten. Solange die Festplatten- und Dateisystemschnittstellen des Kernels nicht beschädigt sind, könnte dies ein guter Weg für ein beinahe sauberes Abschalten sein.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> call cpu_reset<span class=o>()</span></code></pre></div></div><div class=paragraph><p>Dies ist der letzte Ausweg aus der Katastrophe und kommt beinahe dem Drücken des Ausschaltknopfes gleich.</p></div><div class=paragraph><p>Falls Sie eine kurze Zusammenfassung aller Befehle benötigen, geben Sie einfach ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>help</span></code></pre></div></div><div class=paragraph><p>Es ist strengstens empfohlen, eine ausgedruckte Version der <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a>-Manualpage während der Fehlersuche neben sich liegen zu haben. Denken Sie daran, dass es schwer ist, die Online-Hilfe zu lesen, während der Ausführung des Kernels in Einzelschritten.</p></div></div></div><div class=sect1><h2 id=kerneldebug-online-gdb>10.5. Online-Kernel-Fehlersuche mit GDB auf einem entfernten System<a class=anchor href=#kerneldebug-online-gdb></a></h2><div class=sectionbody><div class=paragraph><p>Diese Funktion wird seit FreeBSD 2.2 unterstützt und ist wirklich sehr geschickt.</p></div><div class=paragraph><p>GDB unterstützt <em>die Fehlersuche von einem entfernten System aus</em> bereits einige Zeit. Dies geschieht unter Benutzung eines sehr einfachen Protokolls über eine serielle Verbindung. Anders als bei den anderen, oben beschriebenen, Vorgehensweisen werden hier zwei Systeme benötigt. Das eine ist das Hostsystem, welches die Umgebung zur Fehlersuche, einschließlich aller Quellen und einer Kopie der Kernel-Binärdatei mit allen Symbolen bereitstellt, und das andere das Zielsystem, welches einfach nur eine Kopie desselben Kernels ausführt (ohne die Informationen zur Fehlersuche).</p></div><div class=paragraph><p>Sie sollten den Kernel im Zweifelsfall mit <code>config -g</code> konfigurieren, <code>DDB</code> in die Konfiguration aufnehmen und den Kernel, wie sonst auch, kompilieren. Dies ergibt, aufgrund der zusätzlichen Informationen zur Fehlersuche, eine umfangreiche Binärdatei. Kopieren Sie diesen Kernel auf das Zielsystem, entfernen Sie die Symbole zur Fehlersuche mit <code>strip -x</code> und starten Sie ihn mit der <code>-d</code>-Boot-Option. Stellen Sie die serielle Verbindung zwischen dem Zielsystem, welches "flags 80" für dessen sio-Gerät gesetzt hat, und dem Hostsystem, welches die Fehlersuche übernimmt, her. Nun wechseln Sie auf dem Hostsystem in das Bauverzeichnis des Ziel-Kernels und starten <code>gdb</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kgdb kernel
GDB is free software and you are welcome to distribute copies of it
 under certain conditions<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show copying&#34;</span> to see the conditions.
There is absolutely no warranty <span class=k>for </span>GDB<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
GDB 4.16 <span class=o>(</span>i386-unknown-freebsd<span class=o>)</span>,
Copyright 1996 Free Software Foundation, Inc...
<span class=o>(</span>kgdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Stellen Sie die entfernte Sitzung zur Fehlersuche ein mit (angenommen, der erste serielle Port ist in Verwendung):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>kgdb<span class=o>)</span> target remote /dev/cuaa0</code></pre></div></div><div class=paragraph><p>Jetzt geben Sie auf dem Zielsystem, welches noch vor Beginn der Gerätesuche in DDB gelangt ist, ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Debugger<span class=o>(</span><span class=s2>&#34;Boot flags requested debugger&#34;</span><span class=o>)</span>
Stopped at Debugger+0x35: movb  <span class=nv>$0</span>, edata+0x51bc
db&gt; gdb</code></pre></div></div><div class=paragraph><p>DDB antwortet dann mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Next <span class=nb>trap </span>will enter GDB remote protocol mode</code></pre></div></div><div class=paragraph><p>Jedesmal wenn Sie <code>gdb</code> eingeben, wird zwischen dem lokalen DDB und entfernten GDB umgeschaltet. Um einen nächsten Trap sofort zu erzwingen, geben Sie einfach <code>s</code> (step) ein. Ihr GDB auf dem Hostsystem erhält nun die Kontrolle über den Ziel-Kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Remote debugging using /dev/cuaa0
Debugger <span class=o>(</span><span class=nv>msg</span><span class=o>=</span>0xf01b0383 <span class=s2>&#34;Boot flags requested debugger&#34;</span><span class=o>)</span>
    at ../../i386/i386/db_interface.c:257
<span class=o>(</span>kgdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Sie können mit dieser Sitzung wie mit jeder anderen GDB-Sitzung umgehen, einschließlich vollem Zugriff auf die Quellen, Starten im gud-Modus innerhalb eines Emacs-Fensters (was Ihnen automatische Quelltext-Ausgabe in einem weiteren Emacs-Fenster bietet), usw.</p></div></div></div><div class=sect1><h2 id=kerneldebug-console>10.6. Fehlersuche bei einem Konsolen-Treiber<a class=anchor href=#kerneldebug-console></a></h2><div class=sectionbody><div class=paragraph><p>Da Sie nunmal einen Konsolen-Treiber benötigen, um DDB zu starten, ist alles ein wenig komplizierter, sobald der Konsolen-Treiber selbst versagt. Sie erinnern sich vielleicht an die Benutzung einer seriellen Konsole (entweder durch Verändern des Boot-Blocks oder Eingabe von <code>-h</code> an der <code>Boot:</code>-Eingabeaufforderung) und das Anschließen eines Standard-Terminals an Ihren ersten seriellen Port. DDB funktioniert auf jedem konfigurierten Konsolen-Treiber, auch auf einer seriellen Konsole.</p></div></div></div><div class=sect1><h2 id=kerneldebug-deadlocks>10.7. Fehlersuche bei Deadlocks<a class=anchor href=#kerneldebug-deadlocks></a></h2><div class=sectionbody><div class=paragraph><p>Sie erleben vielleicht mal sogenannte Deadlocks, wobei ein System aufhört, nützliche Arbeit zu machen. Um in einer solchen Situation einen hilfreichen Fehlerbericht zu liefern, benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a>, wie oben beschrieben. Hängen Sie die Ausgabe von <code>ps</code> und <code>trace</code> für verdächtige Prozesse an den Bericht an.</p></div><div class=paragraph><p>Falls möglich, versuchen Sie, weitere Untersuchungen anzustellen. Der Empfang der Ausgaben unten ist besonders dann nützlich, wenn Sie den Auslöser für die Blockade des Systems auf VFS-Ebene vermuten. Fügen Sie die folgenden Optionen</p></div><div class="literalblock programlisting"><div class=content><pre>makeoptions		DEBUG=-g
	options		INVARIANTS
	options		INVARIANT_SUPPORT
	options		WITNESS
	options		DEBUG_LOCKS
	options		DEBUG_VFS_LOCKS
	options		DIAGNOSTIC</pre></div></div><div class=paragraph><p>der Kernel-Konfigurationsdatei hinzu. Wenn die Blockade ausgelöst wird, stellen Sie, zusätzlich der Ausgabe vom <code>ps</code>-Befehl, die Informationen aus <code>show pcpu</code>, <code>show allpcpu</code>, <code>show locks</code>, <code>show alllocks</code>, <code>show lockedvnods</code> und <code>alltrace</code> bereit.</p></div><div class=paragraph><p>Um aussagekräftige Zurückverfolgungen von in Threads aufgeteilten Prozesse zu erhalten, benutzen Sie <code>thread thread-id</code>, um zum Thread-Stack zu wechseln und eine Zurückverfolgung mit <code>where</code> anzustellen.</p></div></div></div><div class=sect1><h2 id=kerneldebug-options>10.8. Glossar der Kernel-Optionen zur Fehlersuche<a class=anchor href=#kerneldebug-options></a></h2><div class=sectionbody><div class=paragraph><p>Dieser Abschnitt bietet ein kurzes Glossar der zur Kompilierzeit verfügbaren Kernel-Optionen, die die Fehlersuche unterstützen:</p></div><div class=ulist><ul><li><p><code>options KDB</code>: Kompiliert das Kernel-Debugger-Framework ein. Wird von <code>options DDB</code> und <code>options GDB</code> benötigt. Kein oder nur geringer Leistungs-Overhead. Standardmäßig wird bei einer Panic der Debugger gestartet, anstatt automatisch neu zu starten.</p></li><li><p><code>options KDB_UNATTENDED</code>: Setzt den Standard des <code>debug.debugger_on_panic</code>-sysctl-Werts auf 0, welcher regelt, ob der Debugger bei einer Panic gestartet wird. Solange <code>options KDB</code> nicht in den Kernel einkompiliert ist, wird bei einer Panic automatisch neu gestartet; sobald es in den Kernel einkompiliert ist, wird standardmäßig der Debugger gestartet, solange <code>options KDB_UNATTENDED</code> nicht einkompiliert ist. Falls Sie den Kernel-Debugger in den Kernel einkompiliert lassen wollen, aber möchten, dass das System neu startet, wenn Sie nicht zur Stelle sind, um den Debugger zur Diagnose zu benutzen, wählen Sie diese Option.</p></li><li><p><code>options KDB_TRACE</code>: Setzt den Standard des <code>debug.trace_on_panic</code>-sysctl-Werts auf 1, welcher regelt, ob der Debugger bei einer Panic automatisch eine Stack-Ablaufverfolgung ausgibt. Besonders wenn der Kernel mit <code>KDB_UNATTENDED</code> läuft, kann dies hilfreich sein, um grundlegende Informationen zur Fehlersuche auf der seriellen oder Firewire-Konsole zu erhalten, während immer noch zur Wiederherstellung neu gestartet wird.</p></li><li><p><code>options DDB</code>: Kompiliert die Unterstützung für den Konsolen-Debugger DDB ein. Dieser interaktive Debugger läuft auf was auch immer die aktive Konsole des Systems auf niedrigster Ebene ist, dazu gehören die Video-, serielle und Firewire-Konsole. Er bietet grundlegende, eingebaute Möglichkeiten zur Fehlersuche wie zum Beispiel das Erstellen von Stack-Ablaufverfolgungen, das Auflisten von Prozessen und Threads, das Ablegen des Lock-, VM- und Dateisystemstatus und die Verwaltung des Kernel-Speichers. DDB benötigt keine Software, die auf einem zweiten System läuft, oder die Fähigkeit, einen Kernspeicherauszug oder Kernel-Symbole zur vollen Fehlersuche zu erzeugen und bietet detaillierte Fehlerdiagnose des Kernels zur Laufzeit. Viele Fehler können allein unter Benutzung der DDB-Ausgabe untersucht werden. Diese Option hängt von <code>options KDB</code> ab.</p></li><li><p><code>options GDB</code>: Kompiliert die Unterstützung für den Debugger GDB ein, welcher von einem entfernten System aus über ein serielles Kabel oder Firewire agieren kann. Wenn der Debugger gestartet ist, kann GDB dazu verwendet werden, um Struktur-Inhalte einzusehen, Stack-Ablaufverfolgungen zu erzeugen, usw. Bei manchem Kernel-Status ist der Zugriff ungeschickter als mit DDB, welcher dazu in der Lage ist, nützliche Zusammenfassungen des Kernel-Status automatisch zu erstellen wie zum Beispiel das automatische Abgehen der Lock-Fehlersuche oder der Strukturen zur Kernel-Speicher-Verwaltung, und es wird ein zweites System benötigt. Auf der anderen Seite verbindet GDB Informationen aus den Kernel-Quellen mit vollständigen Symbolen zur Fehlersuche, erkennt komplette Datenstrukturdefinitionen, lokale Variablen und ist in Skripten einsetzbar. Diese Option hängt von <code>options KDB</code> ab, ist aber nicht zur Benutzung von GDB auf einem Kernel-Kernspeicherauszug nötig.</p></li><li><p><code>options BREAK_TO_DEBUGGER</code>, <code>options ALT_BREAK_TO_DEBUGGER</code>: Erlaubt ein Abbruch- oder Alternativ-Signal auf der Konsole, um in den Debugger zu gelangen. Falls sich das System ohne eine Panic aufhängt, ist dies ein nützlicher Weg, um den Debugger zu erreichen. Aufgrund der aktuellen Verriegelung durch den Kernel ist ein Abbruch-Signal, das auf einer seriellen Konsole erzeugt wurde, deutlich vertrauenswürdiger beim Gelangen in den Debugger und wird allgemein empfohlen. Diese Option hat kaum oder keine Auswirkung auf den Durchsatz.</p></li><li><p><code>options INVARIANTS</code>: Kompiliert eine große Anzahl an Aussageprüfungen und -tests (Assertion-Checks und -Tests) ein, welche ständig die Intaktheit der Kernel-Datenstrukturen und die Invarianten der Kernel-Algorithmen prüfen. Diese Tests können aufwendig sein und sind deswegen nicht von Anfang an einkompiliert, aber helfen nützliches "fail stop"-Verhalten, wobei bestimmte Gruppen nicht erwünschten Verhaltens den Debugger öffnen, bevor Beschädigungen an Kernel-Daten auftreten, bereitzustellen, welches es einfacher macht, diese auf Fehler hin zu untersuchen. Die Tests beinhalten Säubern von Speicher und use-after-free-Prüfungen, was eine der bedeutenderen Quellen von Overhead ist. Diese Option hängt von <code>options INVARIANT_SUPPORT</code> ab.</p></li><li><p><code>options INVARIANT_SUPPORT</code>: Viele der in <code>options INVARIANTS</code> vorhandenen Tests benötigen veränderte Datenstrukturen und zusätzliche Kernel-Symbole, die festgelegt werden müssen.</p></li><li><p><code>options WITNESS</code>: Diese Option aktiviert Verfolgung und Prüfung von Lock-Anforderungen zur Laufzeit und ist als Werkzeug für die Deadlock-Diagnose von unschätzbarem Wert. WITNESS pflegt ein Diagramm mit erworbenen Lock-Anträgen nach Typ geordnet und prüft bei jedem Erwerb nach Zyklen (implizit oder explizit). Falls ein Zyklus entdeckt wird, werden eine Warnung und eine Stack-Ablaufverfolgung erzeugt und als Hinweis, dass ein möglicher Deadlock gefunden wurde, auf der Konsole ausgegeben. WITNESS wird benötigt, um die DDB-Befehle <code>show locks</code>, <code>show witness</code> und <code>show alllocks</code> benutzen zu können. Diese Debug-Option hat einen bedeutenden Leistung-Overhead, welcher ein ein wenig durch Benutzung von <code>options WITNESS_SKIPSPIN</code> gemildert werden kann. Detaillierte Dokumentation kann in <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a> gefunden werden.</p></li><li><p><code>options WITNESS_SKIPSPIN</code>: Deaktiviert die Prüfung von Spinlock-Lock-Anforderungen mit WITNESS zur Laufzeit. Da Spinlocks am häufigsten im Scheduler angefordert werden und Scheduler-Ereignisse oft auftreten, kann diese Option Systeme, die mit WITNESS laufen, merklich beschleunigen. Diese Option hängt von <code>options WITNESS</code> ab.</p></li><li><p><code>options WITNESS_KDB</code>: Setzt den Standard des <code>debug.witness.kdb</code>-sysctl-Werts auf 1, was bewirkt, dass WITNESS den Debugger aufruft, sobald eine Lock-Anforderungsverletzung vorliegt, anstatt einfach nur eine Warnung auszugeben. Diese Option hängt von <code>options WITNESS</code> ab.</p></li><li><p><code>options SOCKBUF_DEBUG</code>: Führt umfassende Beschaffenheitsprüfungen in Socket-Puffern durch, was nützlich zur Fehlersuche bei Socket-Fehlern und Anzeichen für Ressourceblockaden (Race) in Protokollen und Gerätetreibern, die mit Sockets arbeiten, sein kann. Diese Option hat bedeutende Auswirkung auf die Netzwerkleistung und kann die Zeitverhältnisse bei gegenseitiger Ressourceblockade in Gerätetreibern ändern.</p></li><li><p><code>options DEBUG_VFS_LOCKS</code>: Verfolgt Lock-Anforderungs-Einzelheiten bei lockmgr/vnode-Locks, was die Menge der Informationen, die von <code>show lockdevnods</code> in DDB angezeigt werden, vergrößert. Diese Option hat messbare Auswirkung auf die Leistung.</p></li><li><p><code>options DEBUG_MEMGUARD</code>: Ein Ersatz für die Kernel-Speicher-Zuweisung durch <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>, die das VM-System benutzt, um Lese- und Schreibzugriffe auf zugewiesenen Speicher nach der Freigabe zu entdecken. Details können in <a href="https://man.freebsd.org/cgi/man.cgi?query=memguard&amp;sektion=9&amp;format=html">memguard(9)</a> gefunden werden. Diese Option hat bedeutende Auswirkung auf die Leistung, aber kann sehr nützlich bei der Fehlersuche sein, wenn Kernel-Speicher-Beschädigungen durch Fehler verursacht werden.</p></li><li><p><code>options DIAGNOSTIC</code>: Aktiviert zusätzliche, aufwendigere Diagnosetests analog zu <code>options INVARIANTS</code>.</p></li></ul></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9. März 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/de/books/developers-handbook/kernelbuild class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/de/books/developers-handbook/partiv class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#kerneldebug-obtain>10.1. Besorgen eines Speicherauszugs nach einem Kernel-Absturz (Kernel-Crash-Dump)</a></li><li><a href=#kerneldebug-gdb>10.2. Fehlersuche in einem Speicherauszug nach einem Kernel-Absturz mit <code>kgdb</code></a></li><li><a href=#kerneldebug-ddd>10.3. Fehlersuche in einem Speicherauszug nach einem Absturz mit DDD</a></li><li><a href=#kerneldebug-online-ddb>10.4. Online-Kernel-Fehlersuche mit DDB</a></li><li><a href=#kerneldebug-online-gdb>10.5. Online-Kernel-Fehlersuche mit GDB auf einem entfernten System</a></li><li><a href=#kerneldebug-console>10.6. Fehlersuche bei einem Konsolen-Treiber</a></li><li><a href=#kerneldebug-deadlocks>10.7. Fehlersuche bei Deadlocks</a></li><li><a href=#kerneldebug-options>10.8. Glossar der Kernel-Optionen zur Fehlersuche</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/developers-handbook/developers-handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/de/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>