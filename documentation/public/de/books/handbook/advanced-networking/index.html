<!doctype html><html class=theme-light lang=de><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/><title>Kapitel 31. Weiterführende Netzwerkthemen | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Kapitel 31. Weiterführende Netzwerkthemen"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="http://172.16.201.134:1313/de/books/handbook/advanced-networking/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/de\/books\/handbook\/advanced-networking\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/de/books>Books</a></li><li><a href=http://172.16.201.134:1313/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/preface/>Vorwort</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-audience>Über dieses Buch</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-changes-from3>Änderungen gegenüber der dritten Auflage</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-changes-from2>Änderungen gegenüber der zweiten Auflage (2004)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-changes>Änderungen gegenüber der ersten Auflage (2001)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-overview>Gliederung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-conv>Konventionen in diesem Buch</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-acknowledgements>Danksagung</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/parti/>Teil I. Erste Schritte</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/introduction/>Kapitel 1. Einleitung</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/introduction/#introduction-synopsis>1.1. Überblick</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/introduction/#nutshell>1.2. Willkommen zu FreeBSD!</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/introduction/#history>1.3. Über das FreeBSD Projekt</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/>Kapitel 2. FreeBSD installieren</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Minimale Hardwareanforderungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Vor der Installation</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-start>2.4. Die Installation starten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#using-bsdinstall>2.5. Verwendung von bsdinstall</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Plattenplatz bereitstellen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Abrufen der Distributionen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-post>2.8. Benutzerkonten, Zeitzone, Dienste und Sicherheitsoptionen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-network>2.9. Netzwerkschnittstellen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Fehlerbehebung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#using-live-cd>2.11. Verwendung der Live-CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/basics/>Kapitel 3. Grundlagen des FreeBSD Betriebssystems</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#basics-synopsis>3.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#consoles>3.2. Virtuelle Konsolen und Terminals</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#users-synopsis>3.3. Benutzer und grundlegende Account-Verwaltung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#permissions>3.4. Zugriffsrechte</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#dirstructure>3.5. Verzeichnis-Strukturen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#disk-organization>3.6. Festplatten, Slices und Partitionen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#mount-unmount>3.7. Anhängen und Abhängen von Dateisystemen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#basics-processes>3.8. Prozesse und Dämonen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#editors>3.10. Text-Editoren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#basics-devices>3.11. Geräte und Gerätedateien</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#basics-more-information>3.12. Manualpages</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/ports/>Kapitel 4. Installieren von Anwendungen: Pakete und Ports</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-synopsis>4.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-overview>4.2. Installation von Software</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-finding-applications>4.3. Suchen einer Anwendung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#pkgng-intro>4.4. Benutzen von pkg zur Verwaltung von Binärpaketen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-using>4.5. Benutzen der Ports-Sammlung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-poudriere>4.6. Pakete mit Poudriere bauen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-nextsteps>4.7. Nach der Installation</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-broken>4.8. Kaputte Ports</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/x11/>Kapitel 5. Das X-Window-System</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x11-synopsis>5.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-understanding>5.2. Terminologie</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-install>5.3. Xorg installieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-config>5.4. Xorg konfigurieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-fonts>5.5. Schriftarten in Xorg benutzen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-xdm>5.6. Der X-Display-Manager</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x11-wm>5.7. Grafische Oberflächen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-compiz-fusion>5.8. Compiz Fusion installieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x11-troubleshooting>5.9. Fehlersuche</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/partii/>Teil II. Oft benutzte Funktionen</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/desktop/>Kapitel 6. Desktop-Anwendungen</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/desktop/#desktop-synopsis>6.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/desktop/#desktop-browsers>6.2. Browser</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/desktop/#desktop-productivity>6.3. Büroanwendungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/desktop/#desktop-viewers>6.4. Anzeigen von Dokumenten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/desktop/#desktop-finance>6.5. Finanzsoftware</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/>Kapitel 7. Multimedia</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#multimedia-synopsis>7.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#sound-setup>7.2. Soundkarten einrichten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#sound-mp3>7.3. MP3-Audio</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#video-playback>7.4. Videos wiedergeben</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#tvcard>7.5. TV-Karten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#scanners>7.7. Scanner</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/>Kapitel 8. Konfiguration des FreeBSD-Kernels</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Wieso einen eigenen Kernel bauen?</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Informationen über die vorhandene Hardware beschaffen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-config>8.4. Die Kernelkonfigurationsdatei</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-building>8.5. Einen angepassten Kernel bauen und installieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. Wenn etwas schiefgeht</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/printing/>Kapitel 9. Drucken</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-quick-start>9.1. Schnellstart</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-connections>9.2. Druckerverbindungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-pdls>9.3. Gebräuchliche Seitenbeschreibungssprachen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-direct>9.4. Direktes Drucken</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-lpd>9.5. LPD (Line Printer Daemon)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-other>9.6. Andere Drucksysteme</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/linuxemu/>Kapitel 10. Linux®-Binärkompatibilität</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Konfiguration der Linux®-Binärkompatibilität</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/linuxemu/#linuxemu-advanced>10.3. Weiterführende Themen</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/partiii/>Teil III. Systemadministration</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/config/>Kapitel 11. Konfiguration und Tuning</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#config-synopsis>11.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-starting-services>11.2. Start von Diensten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-cron>11.3. cron(8) konfigurieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-rcd>11.4. Dienste unter FreeBSD verwalten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#config-network-setup>11.5. Einrichten von Netzwerkkarten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-virtual-hosts>11.6. Virtual Hosts</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-syslog>11.7. Konfiguration der Systemprotokollierung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-configfiles>11.8. Konfigurationsdateien</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-sysctl>11.9. Einstellungen mit sysctl(8)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-disk>11.10. Tuning von Laufwerken</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-kernel-limits>11.11. Einstellungen von Kernel Limits</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#adding-swap-space>11.12. Hinzufügen von Swap-Bereichen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#acpi-overview>11.13. Energie- und Ressourcenverwaltung</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/boot/>Kapitel 12. FreeBSDs Bootvorgang</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/boot/#boot-synopsis>12.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/boot/#boot-introduction>12.2. FreeBSDs Bootvorgang</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/boot/#boot-splash>12.3. Willkommensbildschirme während des Bootvorgangs konfigurieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/boot/#device-hints>12.4. Konfiguration von Geräten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/boot/#boot-shutdown>12.5. Der Shutdown-Vorgang</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/security/>Kapitel 13. Sicherheit</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-synopsis>13.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-intro>13.2. Einführung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#one-time-passwords>13.3. Einmalpasswörter</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#ipsec>13.7. VPN mit IPsec</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#fs-acl>13.9. Zugriffskontrolllisten für Dateisysteme (ACL)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-pkg>13.10. Sicherheitsprobleme in Software von Drittanbietern überwachen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-advisories>13.11. FreeBSD Sicherheitshinweise</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-accounting>13.12. Prozess-Überwachung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-resourcelimits>13.13. Einschränkung von Ressourcen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-sudo>13.14. Gemeinsame Administration mit Sudo</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/jails/>Kapitel 14. Jails</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-synopsis>14.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-terms>14.2. Jails - Definitionen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-build>14.3. Einrichtung und Verwaltung von Jails</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-tuning>14.4. Feinabstimmung und Administration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-application>14.5. Mehrere Jails aktualisieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-ezjail>14.6. Verwaltung von Jails mit ezjail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/mac/>Kapitel 15. Verbindliche Zugriffskontrolle</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-synopsis>15.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-inline-glossary>15.2. Schlüsselbegriffe</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-initial>15.3. Erläuterung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-understandlabel>15.4. MAC Labels verstehen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-planning>15.5. Planung eines Sicherheitsmodells</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-modules>15.6. Modulkonfiguration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-seeotheruids>15.7. Das MAC Modul seeotheruids</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-bsdextended>15.8. Das MAC Modul bsdextended</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-ifoff>15.9. Das MAC Modul ifoff</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-portacl>15.10. Das MAC Modul portacl</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-partition>15.11. Das MAC Modul partition</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-mls>15.12. Das MAC Modul Multi-Level Security</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-biba>15.13. Das MAC Modul Biba</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-lomac>15.14. Das MAC Modul LOMAC</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-implementing>15.15. Beispiel 1: Nagios in einer MAC Jail</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-userlocked>15.16. Beispiel 2: User Lock Down</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-troubleshoot>15.17. Fehler im MAC beheben</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/audit/>Kapitel 16. Security Event Auditing</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/audit/#audit-synopsis>16.1. Einleitung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/audit/#audit-inline-glossary>16.2. Schlüsselbegriffe</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/audit/#audit-config>16.3. Audit Konfiguration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/audit/#audit-administration>16.4. Audit-Trails</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/disks/>Kapitel 17. Speichermedien</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-synopsis>17.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-adding>17.2. Hinzufügen von Laufwerken</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-growing>17.3. Partitionen vergrößern</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#usb-disks>17.4. USB Speichermedien</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#creating-cds>17.5. Erstellen und Verwenden von CDs</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#creating-dvds>17.6. DVDs benutzen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#floppies>17.7. Disketten benutzen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#backup-basics>17.8. Datensicherung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-virtual>17.9. Speicherbasierte Laufwerke</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#snapshots>17.10. Schnappschüsse von Dateisystemen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#quotas>17.11. Disk Quotas</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-encrypting>17.12. Partitionen verschlüsseln</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#swap-encrypting>17.13. Den Auslagerungsspeicher verschlüsseln</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-hast>17.14. Highly Available Storage (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/geom/>Kapitel 18. GEOM: Modulares Framework zur Plattentransformation</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-synopsis>18.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-mirror>18.3. RAID1 - Spiegelung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-raid3>18.4. RAID3 - Byte-Level Striping mit dedizierter Parität</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-graid>18.5. Software RAID</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-ggate>18.6. GEOM Gate Netzwerk</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-glabel>18.7. Das Labeln von Laufwerken</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-gjournal>18.8. UFS Journaling in GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/zfs/>Kapitel 19. Das Z-Dateisystem (ZFS)</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-differences>19.1. Was ZFS anders macht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-quickstart>19.2. Schnellstartanleitung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-zpool>19.3. <code>zpool</code> Administration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-zfs>19.4. <code>zfs</code> Administration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-zfs-allow>19.5. Delegierbare Administration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-advanced>19.6. Themen für Fortgeschrittene</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-links>19.7. Zusätzliche Informationen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-term>19.8. ZFS-Eigenschaften und Terminologie</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/filesystems/>Kapitel 20. Dateisystemunterstützung</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/filesystems/#filesystems-synopsis>20.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/filesystems/#filesystems-linux>20.2. Linux® Dateisysteme</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/>Kapitel 21. Virtualisierung</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-synopsis>21.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-guest-parallels>21.2. FreeBSD als Gast-Betriebssystem unter Parallels für Mac OS® X</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. FreeBSD als Gast-Betriebssystem unter Virtual PC für Windows®</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-guest-vmware>21.4. FreeBSD als Gast-Betriebssystem unter VMware Fusion für Mac OS®</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-guest-virtualbox-guest-additions>21.5. FreeBSD als Gast mit VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. FreeBSD als Host mit Virtualbox</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-host-bhyve>21.7. FreeBSD als Host mit bhyve</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-host-xen>21.8. FreeBSD als Xen™-Host</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/l10n/>Kapitel 22. Lokalisierung – I18N/L10N einrichten und benutzen</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/l10n/#l10n-synopsis>22.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/l10n/#using-localization>22.2. Lokale Anpassungen benutzen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/l10n/#l10n-compiling>22.3. I18N-Programme</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/l10n/#lang-setup>22.4. Lokalisierung für einzelne Sprachen</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/>Kapitel 23. FreeBSD aktualisieren</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. FreeBSD-Update</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. Aktualisieren der Dokumentationssammlung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#current-stable>23.4. Einem Entwicklungszweig folgen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#makeworld>23.5. FreeBSD aus den Quellen aktualisieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#small-lan>23.6. Installation mehrerer Maschinen</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/dtrace/>Kapitel 24. DTrace</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/dtrace/#dtrace-synopsis>24.1. Überblick</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/dtrace/#dtrace-implementation>24.2. Unterschiede in der Implementierung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/dtrace/#dtrace-enable>24.3. Die DTrace Unterstützung aktivieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/dtrace/#dtrace-using>24.4. DTrace verwenden</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/usb-device-mode/>Kapitel 25. USB Gerätemodus</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. Virtuelle serielle USB-Ports</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. Netzwerkkarten im USB-Gerätemodus</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. Virtuelle USB-Speichergeräte</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/partiv/>Teil IV. Netzwerke</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/>Kapitel 26. Serielle Datenübertragung</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#serial-synopsis>26.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#serial>26.2. Begriffe und Hardware</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#term>26.3. Terminals</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#dialup>26.4. Einwählverbindungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#dialout>26.5. Verbindungen nach Außen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#serialconsole-setup>26.6. Einrichten der seriellen Konsole</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/>Kapitel 27. PPP</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/#userppp>27.2. PPP konfigurieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. Probleme bei PPP-Verbindungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/#pppoe>27.4. PPP over Ethernet (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/#pppoa>27.5. PPP over ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/mail/>Kapitel 28. Elektronische Post (E-Mail)</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-de-term>28.1. Terminologie</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-synopsis>28.2. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-using>28.3. E-Mail Komponenten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#sendmail>28.4. Sendmail-Konfigurationsdateien</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-changingmta>28.5. Wechseln des Mailübertragungs-Agenten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-trouble>28.6. Fehlerbehebung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-advanced>28.7. Weiterführende Themen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#outgoing-only>28.8. Ausgehende E-Mail über einen Relay versenden</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#SMTP-dialup>28.9. E-Mail über Einwahl-Verbindungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#SMTP-Auth>28.10. SMTP-Authentifizierung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-agents>28.11. E-Mail-Programme</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-fetchmail>28.12. E-Mails mit fetchmail abholen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-procmail>28.13. E-Mails mit procmail filtern</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/>Kapitel 29. Netzwerkserver</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-servers-synopsis>29.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-inetd>29.2. Der inetd"Super-Server"</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-nis>29.4. Network Information System (NIS)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-ldap>29.5. Lightweight Access Directory Protocol (LDAP)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-dhcp>29.6. Dynamic Host Configuration Protocol (DHCP)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-dns>29.7. Domain Name System (DNS)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-apache>29.8. Apache HTTP-Server</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-ftp>29.9. File Transfer Protocol (FTP)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-samba>29.10. Datei- und Druckserver für Microsoft® Windows®-Clients (Samba)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-ntp>29.11. Die Uhrzeit mit NTP synchronisieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-iscsi>29.12. iSCSI Initiator und Target Konfiguration</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/>Kapitel 30. Firewalls</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-intro>30.1. Einführung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-concepts>30.2. Firewallkonzepte</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle checked>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/>Kapitel 31. Weiterführende Netzwerkthemen</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-routing>31.2. Gateways und Routen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-wireless>31.3. Drahtlose Netzwerke</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-bluetooth>31.5. Bluetooth</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-bridging>31.6. LAN-Kopplung mit einer Bridge</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-aggregation>31.7. Link-Aggregation und Failover</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-diskless>31.8. Plattenloser Betrieb mit PXE</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#carp>31.10. Common Address Redundancy Protocol (CARP)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/partv/>Teil V. Anhang</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/mirrors/>Anhang A. Bezugsquellen für FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/mirrors/#mirrors-cdrom>A.1. CD and DVD Sets</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mirrors/#mirrors-ftp>A.2. FTP-Server</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mirrors/#svn>A.3. Benutzen von Subversion</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mirrors/#mirrors-rsync>A.4. Benutzen von rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/>Anhang B. Bibliografie</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-freebsd>B.1. Bücher speziell für FreeBSD</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-userguides>B.2. Handbücher</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-adminguides>B.3. Administrations-Anleitungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-programmers>B.4. Programmierhandbücher</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-osinternals>B.5. Betriebssystem-Interna</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-security>B.6. Sicherheits-Anleitung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-hardware>B.7. Hardware-Anleitung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-history>B.8. UNIX® Geschichte</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-journals>B.9. Zeitschriften, Magazine und Journale</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/eresources/>Anhang C. Ressourcen im Internet</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/eresources/#eresources-www>C.1. Webseiten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/eresources/#eresources-mail>C.2. Mailinglisten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/eresources/#eresources-news>C.3. Usenet-News</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/eresources/#eresources-web>C.4. Offizielle Spiegel</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/pgpkeys/>Anhang D. OpenPGP-Schlüssel</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Ansprechpartner</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Kapitel 31. Weiterführende Netzwerkthemen</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>31.1. Übersicht</a></li><li><a href=#network-routing>31.2. Gateways und Routen</a></li><li><a href=#network-wireless>31.3. Drahtlose Netzwerke</a></li><li><a href=#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=#network-bluetooth>31.5. Bluetooth</a></li><li><a href=#network-bridging>31.6. LAN-Kopplung mit einer Bridge</a></li><li><a href=#network-aggregation>31.7. Link-Aggregation und Failover</a></li><li><a href=#network-diskless>31.8. Plattenloser Betrieb mit PXE</a></li><li><a href=#network-ipv6>31.9. IPv6</a></li><li><a href=#carp>31.10. Common Address Redundancy Protocol (CARP)</a></li><li><a href=#network-vlan>31.11. VLANs</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=advanced-networking-synopsis>31.1. Übersicht<a class=anchor href=#advanced-networking-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Dieses Kapitel beschreibt verschiedene weiterführende Netzwerkthemen.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</p></div><div class=ulist><ul><li><p>Die Grundlagen von Gateways und Routen kennen.</p></li><li><p>Wissen, wie man USB Tethering einrichtet.</p></li><li><p>Bluetooth®- sowie drahtlose, der Norm IEEE® 802.11 entsprechende, Geräte mit FreeBSD verwenden können.</p></li><li><p>Eine Bridge unter FreeBSD einrichten können.</p></li><li><p>Wissen, wie man mithilfe von PXE über ein Netzwerk von einem NFS Root-Dateisystem bootet.</p></li><li><p>IPv6 auf einem FreeBSD-Rechner einrichten können.</p></li><li><p>Das Common Address Redundancy Protocol (CARP) unter FreeBSD einsetzen können.</p></li><li><p>Wissen, wie VLANs unter FreeBSD konfiguriert werden.</p></li><li><p>Wissen, wie Bluetooth-Kopfhörer konfiguriert werden.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie</p></div><div class=ulist><ul><li><p>Die Grundlagen der <span class=filename>/etc/rc</span>-Skripte verstanden haben.</p></li><li><p>Mit der grundlegenden Netzwerkterminologie vertraut sein.</p></li><li><p>Einen neuen FreeBSD-Kernel konfigurieren und installieren können (<a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a>).</p></li><li><p>Wissen, wie man zusätzliche Software von Drittherstellern installiert (<a href=../ports/#ports>Installieren von Anwendungen: Pakete und Ports</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=network-routing>31.2. Gateways und Routen<a class=anchor href=#network-routing></a></h2><div class=sectionbody><div class=paragraph><p>Der Mechanismus mit dem ein Rechner einen Rechner über ein Netzwerk finden kann, wird als <em>Routing</em> bezeichnet. Eine "Route" besteht aus einem definierten Adresspaar: Einem "Ziel" und einem "Gateway". Die Route zeigt an, dass Pakete über das <em>Gateway</em> zum <em>Ziel</em> gelangen können. Es gibt drei Arten von Zielen: Einzelne Rechner (Hosts), Subnetze und das "Standard"ziel. Die "Standardroute" wird verwendet, wenn keine andere Route zutrifft. Außerdem gibt es drei Arten von Gateways: Einzelne Rechner (Hosts), Schnittstellen (Interfaces, auch als "Links" bezeichnet), sowie Ethernet Hardware-Adressen (MAC). Bekannte Adressen werden in einer Routingtabelle gespeichert.</p></div><div class=paragraph><p>Dieser Abschnitt bietet einen Überblick über die Grundlagen des Routings. Er demonstriert, wie ein FreeBSD-System als Router konfiguriert werden kann und bietet einige Tipps zur Fehlerbehebung.</p></div><div class=sect2><h3 id=network-routing-default>31.2.1. Grundlagen des Routings<a class=anchor href=#network-routing-default></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> zeigt die Routingtabellen eines FreeBSD-Systems an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Internet:
Destination      Gateway            Flags     Refs     Use     Netif Expire
default          outside-gw         UGS        37      418       em0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1            UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>Die Einträge in diesem Beispiel sind wie folgt:</p></div><div class=dlist><dl><dt class=hdlist1>default</dt><dd><p>Die erste Route in der Ausgabe gibt die Standardroute (<code>default</code>) an. Wenn sich der lokale Rechner mit einem entfernten Rechner verbinden will, wird die Routingtabelle überprüft, um festzustellen, ob bereits ein bekannter Pfad vorhanden ist. Wird für den entfernten Rechner ein Eintrag in der Routingtabelle gefunden, so prüft das System ob es sich über die angegebene Schnittstelle verbinden kann.</p><div class=paragraph><p>Wenn das Zielsystem mit keinem Eintrag übereinstimmt, oder wenn alle bekannten Routen fehlschlagen, verwendet das System die Standardroute. Für die Rechner im lokalen Netzwerk ist das Feld <code>Gateway</code> auf das System gesetzt, welches direkt mit dem Internet verbunden ist. <code>UG</code> in der Spalte <code>Flags</code> zeigt an, dass das Gateway einsatzbereit ist.</p></div><div class=paragraph><p>Die Standardroute für einen Rechner, der selbst als Gateway zur Außenwelt fungiert, ist der Gateway-Rechner des Internetanbieters (ISP).</p></div></dd><dt class=hdlist1>localhost</dt><dd><p>Die zweite Route zeigt die <code>localhost</code> Route. Die festgelegte Schnittstelle in der <code>Netif</code>-Spalte für <code>localhost</code> ist <code>lo0</code>, das auch als loopback-Gerät bekannt ist. Das bedeutet, dass der gesamte Datenverkehr für dieses Ziel intern bleibt, anstatt ihn über ein Netzwerk zu versenden.</p></dd><dt class=hdlist1>MAC-Adresse</dt><dd><p>Bei den mit <code>0:e0:</code> beginnenden Adressen handelt es sich um MAC-Adressen. FreeBSD identifiziert Rechner im lokalen Netz, im Beispiel <code>test0</code>, automatisch und fügt eine direkte Route über die Ethernet-Schnittstelle <span class=filename>re0</span> zu diesem Rechner hinzu. Außerdem existiert in der Spalte <code>Expire</code> ein Timeout, der verwendet wird, wenn dieser Rechner in einem definierten Zeitraum nicht reagiert. Wenn dies passiert, wird die Route zu diesem Rechner automatisch gelöscht. Rechner im lokalen Netz werden über das Routing Information Protocol (RIP) identifiziert, welches den kürzesten Weg zu den jeweiligen Rechnern berechnet.</p></dd><dt class=hdlist1>Subnetz</dt><dd><p>FreeBSD wird automatisch Subnetzrouten für das lokale Subnetz hinzufügen. In diesem Beispiel ist <code>10.20.30.255</code> die Broadcast-Adresse für das Subnetz <code>10.20.30</code>, und <code>example.com</code> ist der zu diesem Subnetz gehörige Domainname. Das Ziel <code>link#1</code> bezieht sich auf die erste Ethernet-Karte im Rechner.</p><div class=paragraph><p>Routen für Rechner im lokalen Netz und lokale Subnetze werden automatisch durch den <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a> Daemon konfiguriert. Ist dieser nicht gestartet, existieren nur statische Routen, die vom Administrator definiert werden.</p></div></dd><dt class=hdlist1>Host</dt><dd><p>Die Zeile <code>host1</code> bezieht sich auf den Rechner, der durch seine Ethernetadresse bekannt ist. Da es sich um den sendenden Rechner handelt, verwendet FreeBSD automatisch das Loopback-Gerät (<span class=filename>lo0</span>), anstatt den Datenverkehr über die Ethernet-Schnittstelle zu senden.</p><div class=paragraph><p>Die zwei <code>host2</code> Zeilen repräsentieren Aliase, die mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> erstellt wurden. Das Symbol <code>⇒</code> nach der <span class=filename>lo0</span>-Schnittstelle sagt aus, dass zusätzlich zur Loopback-Adresse auch ein Alias eingestellt ist. Solche Routen sind nur auf Rechnern vorhanden, die den Alias bereitstellen. Alle anderen Rechner im lokalen Netz haben für solche Routen nur eine <code>link#1</code> Zeile.</p></div></dd><dt class=hdlist1>224</dt><dd><p>Die letzte Zeile (Zielsubnetz <code>224</code>) behandelt Multicasting.</p></dd></dl></div><div class=paragraph><p>Schließlich gibt es für Routen noch verschiedene Attribute, die sich in der Spalte <code>Flags</code> befinden. <a href=#routeflags>Allgemeine Attribute in Routingtabellen</a> fasst einige dieser Flags und deren Bedeutung zusammen:</p></div><table id=routeflags class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 1. Allgemeine Attribute in Routingtabellen</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Attribut</th><th class="tableblock halign-left valign-top">Bedeutung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die Route ist aktiv (up).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das Ziel der Route ist ein einzelner Rechner (Host).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alle Daten, die an dieses Ziel gesendet werden, werden von dem Gateway an ihr jeweiliges Ziel weitergeleitet.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diese Route wurde statisch konfiguriert.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Erzeugt eine neue Route, basierend auf der Route für den Rechner, mit dem wir uns verbinden. Diese Routenart wird normalerweise für lokale Netzwerke verwendet.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eine Route, die automatisch konfiguriert wurde. Sie basiert auf einer lokalen Netzwerkroute (Clone).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die Route beinhaltet einen Verweis auf eine Ethernetkarte (Link).</p></td></tr></tbody></table><div class=paragraph><p>In FreeBSD kann die Standardroute durch die Angabe der IP-Adresse des Standard-Gateways in <span class=filename>/etc/rc.conf</span> definiert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>Die Standardroute kann mit <code>route</code> auch manuell gesetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>Beachten Sie, dass manuell hinzugefügte Routen bei einem Neustart des Systems verloren gehen. Weitere Informationen zum Bearbeiten von Netzwerk-Routingtabellen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>.</p></div></div><div class=sect2><h3 id=network-static-routes>31.2.2. Statische Routen einrichten<a class=anchor href=#network-static-routes></a></h3><div class=paragraph><p>Ein FreeBSD-System kann als Standard-Gateway bzw. Router für ein Netzwerk konfiguriert werden, wenn es sich um einen Dual-Homed-Host handelt. Ein Dual-Homed-Host ist ein Rechner, der sich in mindestens zwei verschiedenen Netzwerken befindet. Typischerweise ist jedes Netzwerk über eine separate Netzwerkschnittstelle verbunden. Mit IP Aliasing können mehrere Adressen, die jeweils zu einem andren Subnetz gehören, an eine physikalische Schnittstelle gebunden werden.</p></div><div class=paragraph><p>Damit Pakete zwischen den Schnittstellen weitergeleitet werden können, muss das FreeBSD-System als Router konfiguriert werden. Internetstandards und gute Ingenieurspraxis sorgten dafür, dass diese Funktion in FreeBSD in der Voreinstellung deaktiviert ist. Sie kann jedoch aktiviert werden, indem folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzugefügt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;          # Auf YES setzen, wenn der Rechner als Gateway arbeiten soll</pre></div></div><div class=paragraph><p>Um das Routing zu aktivieren, setzen Sie die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>net.inet.ip.forwarding</code> auf <code>1</code>. Um das Routing zu stoppen, muss die Variable wieder auf <code>0</code> gesetzt werden.</p></div><div class=paragraph><p>Die Routingtabelle eines Routers benötigt zusätzliche Routen, damit er weiß, wie er andere Netzwerke erreichen kann. Die Routen können entweder manuell als statische Routen hinzugefügt werden, oder aber der Router lernt automatisch die Routen anhand des Routing-Protokolls. Statische Routen eignen sich für kleine Netzwerke und dieser Abschnitt beschreibt, wie Sie eine statische Route für ein kleines Netzwerk hinzufügen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In großen Netzwerken sind statische Routen schlecht skalierbar. FreeBSD beinhaltet den BSD-Routing-Daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, der die Protokolle RIP (Version 1 und Version 2) sowie IRDP unterstützt. Die Routing-Protokolle BGP und OSPF können über den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a> installiert werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nehmen wir an, dass wir über folgendes Netzwerk verfügen:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p><code>RouterA</code>, ein FreeBSD-Rechner, dient als Router für den Zugriff auf das Internet. Die Standardroute ist auf <code>10.0.0.1</code> gesetzt, damit ein Zugriff auf das Internet möglich wird. <code>RouterB</code> ist bereits konfiguriert, da er <code>192.168.1.1</code> als Standard-Gateway benutzt.</p></div><div class=paragraph><p>Bevor die statischen Routen hinzugefügt werden, sieht die Routingtabelle auf <code>RouterA</code> in etwa so aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1/24       <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>Mit dieser Routingtabelle hat <code>RouterA</code> keine Route zum Netzwerk <code>192.168.2.0/24</code>. Der folgende Befehl wird das interne Netz 2 in die Routingtabelle von <code>RouterA</code> aufnehmen und dabei <code>192.168.1.2</code> als nächsten Zwischenschritt (Hop) verwenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Ab sofort kann <code>RouterA</code> alle Rechner des Netzwerks <code>192.168.2.0/24</code> erreichen. Allerdings gehen die Routing-Informationen verloren, wenn das FreeBSD-System neu gestartet wird. Um statische Routen dauerhaft einzurichten, müssen diese in <span class=filename>/etc/rc.conf</span> eingetragen werden:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a persistent static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>Die Variable <code>static_routes</code> enthält eine Reihe von Strings, die durch Leerzeichen getrennt sind. Jeder String bezieht sich auf den Namen einer Route. Die Variable <code>route__internalnet2_</code> enthält die statische Route.</p></div><div class=paragraph><p>Wird mit der Variablen <code>static_routes</code> mehr als eine Variable angegeben, so werden auch mehrere Routen angelegt. Im folgenden Beispiel werden statische Routen zu den Netzwerken <code>192.168.0.0/24</code> und <code>192.168.1.0/24</code> angelegt.</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div><div class=sect2><h3 id=network-routing-troubleshooting>31.2.3. Problembehandlung<a class=anchor href=#network-routing-troubleshooting></a></h3><div class=paragraph><p>Wenn ein Adressraum einem Netzwerk zugeordnet wird, konfiguriert der Dienstanbieter seine Routing-Tabellen, so dass der gesamte Verkehr für das Netzwerk über die Verbindung zu der Seite gesendet wird. Aber woher wissen externe Webseiten, dass sie die Daten an das Netzwerk des ISP senden sollen?</p></div><div class=paragraph><p>Es gibt ein System, das alle zugewiesenen Adressräume verwaltet und die Verbindung zum Internet-Backbone definiert. Der "Backbone" ist das Netz aus Hauptverbindungen, die den Internetverkehr in der ganzen Welt transportieren und verteilen. Jeder Backbone-Rechner verfügt über eine Kopie von Master-Tabellen, die den Verkehr für ein bestimmtes Netzwerk hierarchisch vom Backbone über eine Kette von Dienstanbietern bis hin zu einem bestimmten Netzwerk leiten.</p></div><div class=paragraph><p>Es ist die Aufgabe des Dienstanbieters, den Backbone-Seiten mitzuteilen, dass sie mit einer Seite verbunden wurden. Dieser Vorgang wird als <em>Bekanntmachung von Routen</em> (routing propagation) bezeichnet.</p></div><div class=paragraph><p>Manchmal kommt es zu Problemen bei der Bekanntmachung von Routen, und einige Seiten sind nicht in der Lage, sich zu verbinden. Der vielleicht nützlichste Befehl, um festzustellen wo das Routing nicht funktioniert, ist <code>traceroute</code>. Das Programm ist nützlich, falls <code>ping</code> fehlschlägt.</p></div><div class=paragraph><p>Rufen Sie <code>traceroute</code> mit dem Namen des entfernten Rechners auf, mit dem eine Verbindung aufgebaut werden soll. Die Ausgabe zeigt die Gateway-Rechner entlang des Verbindungspfades an. Schließlich wird der Zielrechner erreicht oder es kommt zu einem Verbindungsabbruch. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect2><h3 id=network-routing-multicast>31.2.4. Multicast-Routing<a class=anchor href=#network-routing-multicast></a></h3><div class=paragraph><p>FreeBSD unterstützt sowohl Multicast-Anwendungen als auch Multicast-Routing. Multicast-Anwendungen benötigen keine spezielle Konfiguration, um auf FreeBSD lauffähig zu sein. Damit Multicast-Routing unterstützt wird, muss die folgende Option in der Kernelkonfiguration aktiviert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>Der Multicast-Routing-Daemon mrouted kann als Port oder Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net/mroute/>net/mroute</a> installiert werden. Dieser Daemon implementiert das DVMRP Multicast-Routing-Protokoll. Um die Tunnel und DVMRP einzurichten, muss <span class=filename>/usr/local/etc/mrouted.conf</span> bearbeitet werden. Bei der Installation von mrouted wird auch map-mbone und mrinfo sowie die zugehörigen Manualpages installiert, in denen Sie auch Konfigurationsbeispiele finden können.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>DVMRP wurde in vielen Multicast-Installationen weitgehend durch das PIM-Protokoll ersetzt. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=pim&amp;sektion=4&amp;format=html">pim(4)</a>.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=network-wireless>31.3. Drahtlose Netzwerke<a class=anchor href=#network-wireless></a></h2><div class=sectionbody><div class=sect2><h3 id=_grundlagen>31.3.1. Grundlagen<a class=anchor href=#_grundlagen></a></h3><div class=paragraph><p>Die meisten drahtlosen Netzwerke basieren auf dem Standard IEEE® 802.11. Ein einfaches drahtloses Netzwerk besteht aus Stationen, die im 2,4 GHz- oder im 5 GHz-Band miteinander kommunizieren. Es ist aber auch möglich, dass regional andere Frequenzen, beispielsweise im 2,3 GHz- oder 4,9 GHz-Band, verwendet werden.</p></div><div class=paragraph><p>802.11-Netzwerke können auf zwei verschiedene Arten aufgebaut sein: Im <em>Infrastruktur-Modus</em> agiert eine Station als Master, mit dem sich alle anderen Stationen verbinden. Die Summe aller Stationen wird als Basic Service Set (BSS), die Master-Station hingegen als Access Point (AP) bezeichnet. In einem BSS läuft jedwede Kommunikation über den Access Point. Die zweite Form drahtloser Netzwerke sind die sogenannten <em>Ad-hoc-Netzwerke</em> (auch als IBSS bezeichnet), in denen es keinen Access Point gibt und in denen die Stationen direkt miteinander kommunizieren.</p></div><div class=paragraph><p>Die ersten 802.11-Netzwerke arbeiteten im 2,4 GHz-Band und nutzten dazu Protokolle der IEEE®-Standards 802.11 sowie 802.11b. Diese Standards legen unter anderem Betriebsfrequenzen sowie Merkmale des MAC-Layers (wie Frames und Transmissionsraten) fest. Später kam der Standard 802.11a hinzu, der im 5 GHz-Band, im Gegensatz zu den ersten beiden Standards aber mit unterschiedlichen Signalmechanismen und höheren Transmissionsraten arbeitet. Der neueste Standard 802.11g implementiert die Signal- und Transmissionsmechanismen von 802.11a im 2,4 GHz-Band, ist dabei aber abwärtskompatibel zu 802.11b-Netzwerken.</p></div><div class=paragraph><p>Unabhängig von den zugrundeliegenden Transportmechanismen verfügen 802.11-Netzwerke über diverse Sicherheitsmechanismen. Der ursprüngliche 802.11-Standard definierte lediglich ein einfaches Sicherheitsprotokoll namens WEP. Dieses Protokoll verwendet einen fixen, gemeinsam verwendeten Schlüssel sowie die RC4-Kryptografie-Chiffre, um Daten verschlüsselt über das drahtlose Netzwerk zu senden. Alle Stationen des Netzwerks müssen sich auf den gleichen fixen Schlüssel einigen, um miteinander kommunizieren zu können. Dieses Schema ist sehr leicht zu knacken und wird deshalb heute kaum mehr eingesetzt. Aktuelle Sicherheitsmechanismen bauen auf dem Standard IEEE® 802.11i auf, der neue kryptographische Schlüssel (Chiffren), ein neues Protokoll für die Anmeldung von Stationen an einem Access Point, sowie Mechanismen zum Austausch von Schlüsseln als Vorbereitung der Kommunikation zwischen verschiedenen Geräten festlegt. Kryptografische Schlüssel werden in regelmäßigen Abständen aktualisiert. Außerdem gibt es Mechanismen zur Feststellung und Prävention von Einbruchsversuchen. Ein weiteres häufig verwendetes Sicherheitsprotokoll ist WPA. Dabei handelt es sich um einen Vorläufer von 802.11i, der von einem Industriekonsortium als Zwischenlösung bis zur endgültigen Verabschiedung von 802.11i entwickelt wurde. WPA definiert eine Untergruppe der Anforderungen des 802.11i-Standards und ist für den Einsatz in älterer Hardware vorgesehen. WPA benötigt nur den TKIP-Chiffre, welcher auf dem ursprünglichen WEP-Code basiert. 802.11i erlaubt zwar auch die Verwendung von TKIP, benötigt aber zusätzlich eine stärkere Chiffre (AES-CCM) für die Datenverschlüsselung. AES war für WPA nicht vorgesehen, weil man es als zu rechenintensiv für den Einsatz in älteren Geräten ansah.</p></div><div class=paragraph><p>Ein weiterer zu beachtender Standard ist 802.11e. Dieser definiert Protokolle zur Übertragung von Multimedia-Anwendungen, wie das Streaming von Videodateien oder Voice-over-IP (VoIP) in einem 802.11-Netzwerk. Analog zu 802.11i verfügt auch 802.11e über eine vorläufige Spezifikation namens WMM (ursprünglich WME), die von einem Industriekonsortium als Untergruppe von 802.11e spezifiziert wurde, um Multimedia-Anwendungen bereits vor der endgültigen Verabschiedung des 802.11e-Standards implementieren zu können. 802.11e sowie WME/WMM erlauben eine Prioritätenvergabe beim Datentransfer in einem drahtlosen Netzwerk. Möglich wird dies durch den Einsatz von Quality of Service-Protokollen (QoS) und erweiterten Medienzugriffsprotokollen. Werden diese Protokolle korrekt implementiert, erlauben sie hohe Datenübertragungsraten und einen priorisierten Datenfluss.</p></div><div class=paragraph><p>FreeBSD unterstützt die Standards 802.11a, 802.11b und 802.11g. Ebenfalls unterstützt werden WPA sowie die Sicherheitsprotokolle gemäß 802.11i (sowohl für 11a, 11b als auch 11g). QoS und Verkehrspriorisierung, die von den WME/WMM-Protokollen benötigt werden, werden für einen begrenzten Satz von drahtlosen Geräten unterstützt.</p></div></div><div class=sect2><h3 id=network-wireless-quick-start>31.3.2. Schnellstartanleitung<a class=anchor href=#network-wireless-quick-start></a></h3><div class=paragraph><p>Häufig soll ein Computer an ein vorhandenes Drahtlosnetzwerk angeschlossen werden. Diese Prozedur zeigt die dazu erforderlichen Schritte.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Besorgen Sie sich vom Netzwerkadministrator die SSID (Service Set Identifier) und den PSK (Pre Shared Key) für das Drahtlosnetzwerk.</p></li><li><p>Ermitteln Sie den drahtlosen Adapter. Der <span class=filename>GENERIC</span>-Kernel von FreeBSD enthält Treiber für viele gängige Adapter. Wenn der drahtlose Adapter eines dieser Modelle ist, wird das in der Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> angezeigt:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig | <span class=nb>grep</span> <span class=nt>-B3</span> <span class=nt>-i</span> wireless</code></pre></div></div><div class=paragraph><p>In FreeBSD 11 und neueren Versionen verwenden Sie stattdessen diesen Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl net.wlan.devices</code></pre></div></div><div class=paragraph><p>Wenn der drahtlose Adapter nicht aufgeführt wird, könnte ein zusätzliches Kernelmodul erforderlich sein. Es besteht jedoch auch die Möglichkeit, dass der Adapter von FreeBSD nicht unterstützt wird.</p></div><div class=paragraph><p>Dieses Beispiel verwendet einen drahtlosen Atheros-Adapter <code>ath0</code>.</p></div></li><li><p>Fügen Sie in <span class=filename>/etc/wpa_supplicant.conf</span> einen Eintrag für das Netzwerk hinzu. Wenn die Datei nicht existiert, müssen Sie diese erstellen. Ersetzen Sie <em>myssid</em> und <em>psk</em> durch die SSID und den PSK. Diese Informationen werden vom Netzwerkadministrator zur Verfügung gestellt.</p><div class="literalblock programlisting"><div class=content><pre>network={
	ssid=&#34;myssid&#34;
	psk=&#34;mypsk&#34;
}</pre></div></div></li><li><p>Fügen Sie die entsprechenden Einträge in <span class=filename>/etc/rc.conf</span> ein, um das Netzwerk beim Start zu konfigurieren:</p><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA SYNCDHCP&#34;</pre></div></div></li><li><p>Starten Sie den Computer oder den Netzwerkdienst neu, um sich mit dem Netzwerk zu verbinden:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div></li></ol></div></div><div class=sect2><h3 id=network-wireless-basic>31.3.3. Basiskonfiguration<a class=anchor href=#network-wireless-basic></a></h3><div class=sect3><h4 id=_kernelkonfiguration>31.3.3.1. Kernelkonfiguration<a class=anchor href=#_kernelkonfiguration></a></h4><div class=paragraph><p>Um ein drahtloses Netzwerk zu nutzen, wird eine drahtlose Netzwerkkarte benötigt und ein Kernel, der drahtlose Netzwerke unterstützt. Der Kernel unterstützt den Einsatz von Kernelmodulen. Daher muss nur die Unterstützung für die verwendeten Geräte aktiviert werden.</p></div><div class=paragraph><p>Die meisten drahtlosen Geräte verwenden Bauteile von Atheros und werden deshalb vom <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>-Treiber unterstützt. Um diesen Treiber zu verwenden, muss die folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>if_ath_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Der Atheros-Treiber besteht aus drei Teilen: dem Treiber selbst (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>), dem Hardware-Support-Layer für die chip-spezifischen Funktionen (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath_hal&amp;sektion=4&amp;format=html">ath_hal(4)</a>) sowie einem Algorithmus zur Auswahl der Frame-Übertragungsrate (ath_rate_sample). Wenn diese Unterstützung als Kernelmodul geladen wird, kümmert sich das Modul automatisch um Abhängigkeiten. Um die Unterstützung für ein anderes drahtloses Gerät zu laden, geben Sie das entsprechende Modul für dieses Gerät an. Dieses Beispiel zeigt die Verwendung von Geräten, die auf Bauteilen von Intersil Prism basieren und den Treiber <a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a> benötigen:</p></div><div class="literalblock programlisting"><div class=content><pre>if_wi_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Beispiele in diesem Abschnitt verwenden den <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>-Treiber. Verwenden Sie ein anderes Gerät, muss der Gerätename an die Konfiguration angepasst werden. Eine Liste aller verfügbaren Treiber und unterstützten drahtlosen Geräte finden sich in den FreeBSD Hardware Notes unter <a href=https://www.FreeBSD.org/releases/>Release Information</a> der FreeBSD Homepage. Gibt es keinen nativen FreeBSD-Treiber für das drahtlose Gerät, kann möglicherweise mit <a href=../config/#config-network-ndis>NDIS</a> ein Windows®-Treiber verwendet werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Zusätzlich müssen die Module zur Verschlüsselung des drahtlosen Netzwerks geladen werden. Diese werden normalerweise dynamisch vom <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a>-Modul geladen. Im folgenden Beispiel erfolgt allerdings eine manuelle Konfiguration. Folgende Module sind verfügbar: <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a>. Sowohl <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> als auch <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a> werden nur benötigt, wenn WPA und/oder die Sicherheitsprotokolle von 802.11i verwendet werden. Wenn das Netzwerk keine Verschlüsselung verwendet, wird die <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a>-Unterstützung nicht benötigt. Um diese Module beim Systemstart zu laden, fügen Sie folgende Zeilen in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>wlan_wep_load=&#34;YES&#34;
wlan_ccmp_load=&#34;YES&#34;
wlan_tkip_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Sobald diese Einträge in <span class=filename>/boot/loader.conf</span> vorhanden sind, muss das FreeBSD-System neu gestartet werden. Alternativ können die Kernelmodule auch manuell mit <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> geladen werden.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Benutzer, die keine Kernelmodule verwenden wollen, können die benötigten Treiber auch in den Kernel kompilieren. Dazu müssen die folgenden Zeilen in die Kernelkonfigurationsdatei aufgenommen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC&#39;s
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</pre></div></div><div class=paragraph><p>Mit diesen Informationen in der Kernelkonfigurationsdatei kann der Kernel neu gebaut, und das FreeBSD-System anschließend neu gestartet werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Informationen über das drahtlose Gerät sollten in den Boot-Meldungen folgendermaßen angezeigt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: <span class=o>[</span>ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</code></pre></div></div></div><div class=sect3><h4 id=_konfiguration_der_entsprechenden_region>31.3.3.2. Konfiguration der entsprechenden Region<a class=anchor href=#_konfiguration_der_entsprechenden_region></a></h4><div class=paragraph><p>Da die rechtliche Situation in verschiedenen Teilen der Welt unterschiedlich ist, ist es notwendig, die für Ihre Region geltenden Domänen korrekt einzustellen, um die richtigen Informationen darüber zu erhalten, welche Kanäle benutzt werden können.</p></div><div class=paragraph><p>Die verfügbaren Definitionen der Regionen finden Sie in <span class=filename>/etc/regdomain.xml</span>. Um die Daten zur Laufzeit einzustellen, benutzen Sie <code>ifconfig</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 regdomain ETSI country AT</span></code></pre></div></div><div class=paragraph><p>Um die Einstellungen beizubehalten, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc create_args_wlan0=&#34;country AT regdomain ETSI&#34;</span></code></pre></div></div></div></div><div class=sect2><h3 id=_infrastruktur_modus>31.3.4. Infrastruktur-Modus<a class=anchor href=#_infrastruktur_modus></a></h3><div class=paragraph><p>Drahtlose Netzwerke werden in der Regel im Infrastruktur-Modus (BSS) betrieben. Dazu werden mehrere drahtlose Access Points zu einem gemeinsamen drahtlosen Netzwerk verbunden. Jedes dieser drahtlosen Netzwerke hat einen eigenen Namen, der als >SSID> bezeichnet wird. Alle Clients eines drahtlosen Netzwerks verbinden sich in diesem Modus mit einem Access Point.</p></div><div class=sect3><h4 id=_freebsd_clients>31.3.4.1. FreeBSD-Clients<a class=anchor href=#_freebsd_clients></a></h4><div class=sect4><h5 id=_einen_access_point_finden>31.3.4.1.1. Einen Access Point finden<a class=anchor href=#_einen_access_point_finden></a></h5><div class=paragraph><p>Um nach verfügbaren drahtlosen Netzwerken zu suchen verwenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Dieser Scanvorgang kann einen Moment dauern, da jede verfügbare Frequenz auf verfügbare Access Points hin überprüft werden muss. Nur der Super-User kann einen Scanvorgang starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M <span class=nt>-90</span>:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-83</span>:96   100 EPS  WPA</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Netzwerkkarte muss in den Status <code>up</code> versetzt werden, bevor der erste Scanvorgang gestartet werden kann. Für spätere Scans ist dies aber nicht mehr erforderlich.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Als Ergebnis erhalten Sie eine Liste mit allen gefundenen BSS/IBSS-Netzwerken. Zusätzlich zum Namen des Netzwerks, der <code>SSID</code>, wird auch die <code>BSSID</code> ausgegeben. Dabei handelt es sich um die MAC-Adresse des Access Points. Das Feld <code>CAPS</code> gibt den Typ des Netzwerks sowie die Fähigkeiten der Stationen innerhalb des Netzwerks an:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 2. Station Capability Codes</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Capability Code</th><th class="tableblock halign-left valign-top">Bedeutung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>E</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Extended Service Set (ESS). Zeigt an, dass die Station Teil eines Infrastruktur-Netzwerks ist, und nicht eines IBSS/Ad-hoc-Netzwerks.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>I</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IBSS/Ad-hoc-Netzwerk. Die Station ist Teil eines Ad-hoc-Netzwerks und nicht eines ESS-Netzwerks.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>P</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Privacy. Alle Datenframes, die innerhalb des BSS ausgetauscht werden, sind verschlüsselt. Dieses BSS verwendet dazu kryptographische Verfahren wie WEP, TKIP oder AES-CCMP.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>S</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Short Preamble. Das Netzwerk verwendet eine kurze Präambel (definiert in 802.11b High Rate/DSSS PHY). Eine kurze Präambel verwendet ein 56 Bit langes Sync-Feld, im Gegensatz zu einer langen Präambel, die ein 128 Bit langes Sync-Feld verwendet.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>s</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Short slot time. Das 802.11g-Netzwerk verwendet eine kurze Slotzeit, da es in diesem Netzwerk keine veralteten (802.11b) Geräte gibt.</p></td></tr></tbody></table><div class=paragraph><p>Um eine Liste der bekannten Netzwerke auszugeben, verwenden Sie den folgenden Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 list scan</span></code></pre></div></div><div class=paragraph><p>Diese Liste kann entweder automatisch durch das drahtlose Gerät oder manuell durch eine <code>scan</code>-Aufforderung aktualisiert werden. Veraltete Informationen werden dabei automatisch entfernt.</p></div></div><div class=sect4><h5 id=_basiseinstellungen>31.3.4.1.2. Basiseinstellungen<a class=anchor href=#_basiseinstellungen></a></h5><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie eine drahtlose Netzwerkkarte ohne Verschlüsselung unter FreeBSD einrichten. Nachdem Sie sich mit den Informationen dieses Abschnitts vertraut gemacht haben, sollten Sie das drahtlose Netzwerk mit <a href=#network-wireless-wpa>WPA</a> verschlüsseln.</p></div><div class=paragraph><p>Das Einrichten eines drahtlosen Netzwerks erfolgt in drei Schritten: Der Auswahl eines Access Points, die Anmeldung der Station sowie der Konfiguration der IP-Adresse.</p></div><div class=sect5><h6 id=_einen_access_point_auswählen>31.3.4.1.2.1. Einen Access Point auswählen<a class=anchor href=#_einen_access_point_auswählen></a></h6><div class=paragraph><p>Im Normalfall wird sich die Station automatisch mit einem der zur Verfügung stehenden Access Points verbinden. Dazu muss lediglich das drahtlose Gerät aktiviert, oder in <span class=filename>/etc/rc.conf</span> eingetragen sein:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Stehen mehrere Access Points zur Verfügung, kann ein spezifischer durch Angabe der SSID gewählt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid Ihre_SSID DHCP&#34;</pre></div></div><div class=paragraph><p>Gibt es in einem Netzwerk mehrere Access Points mit der gleichen SSID, was das Routing vereinfacht, kann es notwendig sein, dass ein bestimmtes Gerät verbunden werden muss. Dazu muss lediglich die BSSID des Access Points angeben werden. Die Angabe der SSID ist hierbei nicht zwingend notwendig:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid Ihre_SSID bssid xx:xx:xx:xx:xx:xx DHCP&#34;</pre></div></div><div class=paragraph><p>Es gibt noch weitere Möglichkeiten, den Zugriff auf bestimmte Access Point zu beschränken, beispielsweise durch die Begrenzung der Frequenzen, auf denen eine Station nach einem Access Point sucht. Sinnvoll ist ein solches Vorgehen beispielsweise, wenn das drahtlose Gerät in verschiedenen Frequenzbereichen arbeiten kann, da in diesem Fall das Prüfen aller Frequenzen sehr zeitintensiv sein kann. Um nur innerhalb eines bestimmten Frequenzbereichs nach einem Access Point zu suchen, verwenden Sie die Option <code>mode</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;mode 11g ssid Ihre_SSID DHCP&#34;</pre></div></div><div class=paragraph><p>In diesem Beispiel sucht das drahtlose Gerät nur im 2,4 GHz-Band (802.11g), aber nicht innerhalb des 5 GHz-Bandes nach einem Access Point. Mit der Option <code>channel</code> kann eine bestimmte Frequenz vorgegeben werden, auf der gesucht werden soll. Die Option <code>chanlist</code> erlaubt die Angabe mehrerer erlaubter Frequenzen. Eine umfassende Beschreibung dieser Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect5><h6 id=_authentifizierung>31.3.4.1.2.2. Authentifizierung<a class=anchor href=#_authentifizierung></a></h6><div class=paragraph><p>Sobald ein Access Point gefunden wurde, muss sich die Station am Access Point authentifizieren, bevor Daten übertragen werden können. Dazu gibt es verschiedene Möglichkeiten. Am häufigsten wird die sogenannte <em>offene Authentifizierung</em> verwendet. Dabei wird es jeder Station erlaubt, sich mit einem Netzwerk zu verbinden und Daten zu übertragen. Aus Sicherheitsgründen sollte diese Methode allerdings nur zu Testzwecken bei der erstmaligen Einrichtung eines drahtlosen Netzwerks verwendet werden. Andere Authentifizierungsmechanismen erfordern den Austausch kryptographischer Informationen, bevor sie die Übertragung von Daten erlauben. Dazu gehören der Austausch fixer (vorher vereinbarter) Schlüssel oder Kennwörter, sowie der Einsatz komplexerer Verfahren mit Backend-Diensten wie RADIUS. Die offene Authentifizierung ist die Voreinstellung. Am zweithäufigsten kommt das im <a href=#network-wireless-wpa-wpa-psk>WPA-PSK</a> beschriebene WPA-PSK zum Einsatz, welches auch als WPA Personal bezeichnet wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Kommt eine Apple® AirPort® Extreme-Basisstation als Access Point zum Einsatz, muss sowohl die Shared-Key-Authentifizierung als auch ein WEP-Schlüssel konfiguriert werden. Die entsprechende Konfiguration erfolgt entweder in <span class=filename>/etc/rc.conf</span> oder über das Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Für eine einzelne AirPort®-Basisstation kann der Zugriff wie folgt konfiguriert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP&#34;</pre></div></div><div class=paragraph><p>Normalerweise sollte Shared-Key-Authentifizierung nicht verwendet werden, da diese die Sicherheit des WEP-Schlüssel noch weiter verringert. Wenn WEP für Kompatibilität mit älteren Geräten verwendet werden muss, ist es besser, WEP mit offener Authentifizierung zu verwenden. Weitere Informationen zu WEP finden Sie im <a href=#network-wireless-wep>WEP</a>.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_eine_ip_adresse_über_dhcp_beziehen>31.3.4.1.2.3. Eine IP-Adresse über DHCP beziehen<a class=anchor href=#_eine_ip_adresse_über_dhcp_beziehen></a></h6><div class=paragraph><p>Sobald ein Access Point ausgewählt ist und die Authentifizierungsparameter festgelegt sind, wird eine IP-Adresse benötigt. In der Regel wird die IP-Adresse über DHCP bezogen. Um dies zu erreichen, bearbeiten Sie <span class=filename>/etc/rc.conf</span> und fügen Sie <code>DHCP</code> für das drahtlose Gerät in die Konfiguration hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Das drahtlose Gerät kann nun gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span></code></pre></div></div><div class=paragraph><p>Nachdem das Gerät aktiviert wurde, kann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> der Status des Geräts <span class=filename>ath0</span> abgefragt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 <span class=o>(</span>2462 Mhz 11g<span class=o>)</span> bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</code></pre></div></div><div class=paragraph><p><code>status: associated</code> besagt, dass sich das Gerät mit dem drahtlosen Netzwerk verbunden hat. <code>bssid 00:13:46:49:41:76</code> ist die MAC-Adresse des Access Points und <code>authmode OPEN</code> zeigt an, dass die Kommunikation nicht verschlüsselt wird.</p></div></div><div class=sect5><h6 id=_statische_ip_adressen>31.3.4.1.2.4. Statische IP-Adressen<a class=anchor href=#_statische_ip_adressen></a></h6><div class=paragraph><p>Wenn eine IP-Adresse nicht von einem DHCP-Server bezogen werden kann, vergeben Sie eine statische IP-Adresse. Ersetzten Sie dazu das oben gezeigte Schlüsselwort <code>DHCP</code> durch die entsprechende IP-Adresse. Beachten Sie dabei, dass Sie die anderen Konfigurationsparameter nicht versehentlich verändern:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here&#34;</pre></div></div></div></div><div class=sect4><h5 id=network-wireless-wpa>31.3.4.1.3. WPA<a class=anchor href=#network-wireless-wpa></a></h5><div class=paragraph><p>Wi-Fi Protected Access (WPA) ist ein Sicherheitsprotokoll, das in 802.11-Netzwerken verwendet wird, um die fehlende Authentifizierung und Schwächen von WEP zu vermeiden. WPA stellt das aktuelle 802.1X-Authentifizierungsprotokoll dar und verwendet eine von mehreren Chiffren, um die Datensicherheit zu gewährleisten. Die einzige Chiffre, die von WPA verlangt wird, ist Temporary Key Integrity Protocol (TKIP). TKIP ist eine Chiffre, die die von WEP verwendete RC4-Chiffre um Funktionen zur Prüfung der Datenintegrität und zur Erkennung und Bekämpfung von Einbruchsversuchen erweitert. TKIP ist durch Softwaremodifikationen auch unter veralteter Hardware lauffähig. Im Vergleich zu WEP ist WPA zwar sehr viel sicherer, es ist aber dennoch nicht völlig immun gegen Angriffe. WPA definiert mit AES-CCMP noch eine weitere Chiffre als Alternative zu TKIP. AES-CCMP, welches häufig als WPA2 oder RSN bezeichnet wird, sollte bevorzugt eingesetzt werden.</p></div><div class=paragraph><p>WPA definiert Authentifizierungs- und Verschlüsselungsprotokolle. Die Authentifizierung erfolgt in der Regel über eine der folgenden Techniken: 802.1X gemeinsam mit einem Backend-Authentifizierungsdienst wie RADIUS, oder durch einen Minimal-Handshake zwischen der Station und dem Access Point mit einem vorher vereinbarten gemeinsamen Schlüssel. Die erste Technik wird als WPA Enterprise, die zweite hingegen als WPA Personal bezeichnet. Da sich der Aufwand für das Aufsetzen eines RADIUS-Backend-Servers für die meisten drahtlosen Netzwerke nicht lohnt, wird WPA in der Regel als WPA-PSK konfiguriert.</p></div><div class=paragraph><p>Die Kontrolle der drahtlosen Verbindung sowie das Aushandeln des Schlüssel, oder die Authentifizierung mit einem Server, erfolgt über <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Dieses Programm benötigt eine Konfigurationsdatei, <span class=filename>/etc/wpa_supplicant.conf</span>. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</p></div><div class=sect5><h6 id=network-wireless-wpa-wpa-psk>31.3.4.1.3.1. WPA-PSK<a class=anchor href=#network-wireless-wpa-wpa-psk></a></h6><div class=paragraph><p>WPA-PSK, das auch als WPA-Personal bekannt ist, basiert auf einem gemeinsamen, vorher vereinbarten Schlüssel (PSK), der aus einem Passwort generiert und danach als Master-Key des drahtlosen Netzwerks verwendet wird. Jeder Benutzer des drahtlosen Netzwerks verwendet daher <em>den gleichen</em> Schlüssel. WPA-PSK sollte nur in kleinen Netzwerken eingesetzt werden, in denen die Konfiguration eines Authentifizierungsservers nicht möglich oder erwünscht ist.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Achten Sie darauf, immer starke Passwörter zu verwenden, die ausreichend lang sind und auch Sonderzeichen enthalten, damit diese nicht leicht erraten oder umgangen werden können.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Der erste Schritt zum Einsatz von WPA-PSK ist die Konfiguration der SSID und des gemeinsamen Schlüssels des Netzwerks in <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  psk=&#34;freebsdmall&#34;
}</pre></div></div><div class=paragraph><p>Danach wird in <span class=filename>/etc/rc.conf</span> definiert, dass WPA zur Verschlüsselung eingesetzt werden soll und dass die IP-Adresse über DHCP bezogen wird:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Nun kann das drahtlose Gerät aktiviert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Alternativ kann das drahtlose Gerät manuell, mit Hilfe der Informationen aus <span class=filename>/etc/wpa_supplicant.conf</span> konfiguriert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:11:95:c3:0d:ac <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;freebsdap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2412 MHz<span class=o>)</span>
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac <span class=o>[</span><span class=nv>PTK</span><span class=o>=</span>CCMP <span class=nv>GTK</span><span class=o>=</span>CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed <span class=o>(</span>auth<span class=o>)</span> <span class=o>[</span><span class=nb>id</span><span class=o>=</span>0 <span class=nv>id_str</span><span class=o>=]</span></code></pre></div></div><div class=paragraph><p>Im zweiten Schritt starten Sie nun <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>, um eine IP-Adresse vom DHCP-Server zu beziehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient wlan0</span>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Enthält <span class=filename>/etc/rc.conf</span> bereits die Zeile <code>ifconfig_wlan0="DHCP"</code>, wird <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> automatisch gestartet, nachdem <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> sich mit dem Access Point verbunden hat.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sollte der Einsatz von DHCP nicht möglich oder nicht gewünscht sein, konfigurieren Sie eine statische IP-Adresse, nachdem <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> die Station authentifiziert hat:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</span>
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Falls DHCP nicht verwendet wird, müssen zusätzlich noch das Standard-Gateway sowie der Nameserver manuell festgelegt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default your_default_router</span>
<span class=c># echo &#34;nameserver your_DNS_server&#34; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-tls>31.3.4.1.3.2. WPA und EAP-TLS<a class=anchor href=#network-wireless-wpa-eap-tls></a></h6><div class=paragraph><p>Die zweite Möglichkeit, WPA einzusetzen, ist die Verwendung eines 802.1X-Backend-Authentifizierungsservers. Diese Variante wird als WPA-Enterprise bezeichnet, um sie vom weniger sicheren WPA-Personal abzugrenzen. Die bei WPA-Enterprise verwendete Authentifizierung basiert auf dem Extensible Authentication Protocol (EAP).</p></div><div class=paragraph><p>EAP selbst bietet keine Verschlüsselung, sondern operiert in einem verschlüsselten Tunnel. Es gibt verschiedene auf EAP basierende Authentifizierungsmethoden, darunter EAP-TLS, EAP-TTLS und EAP-PEAP.</p></div><div class=paragraph><p>EAP mit Transport Layers Security (EAP-TLS) ist ein sehr gut unterstütztes Authentifizierungsprotokoll, da es sich dabei um die erste EAP-Methode handelt, die von der <a href=http://www.wi-fi.org/>Wi-Fi Alliance</a> zertifiziert wurde. EAP-TLS erfordert drei Zertifikate: Das auf allen Rechnern installierte CA-Zertifikat, das Server-Zertifikat des Authentifizierungsservers, sowie ein Client-Zertifikat für jeden drahtlosen Client. Sowohl der Authentifizierungsservers als auch die drahtlosen Clients authentifizieren sich gegenseitig über Zertifikate, wobei sie überprüfen, ob diese Zertifikate auch von der Zertifizierungs-Authorität (CA) des jeweiligen Unternehmens signiert wurden.</p></div><div class=paragraph><p>Die Konfiguration erfolgt (analog zu WPA-PSK) über <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34; <i class=conum data-value=1></i><b>(1)</b>
  proto=RSN  <i class=conum data-value=2></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class=conum data-value=3></i><b>(3)</b>
  eap=TLS <i class=conum data-value=4></i><b>(4)</b>
  identity=&#34;loader&#34; <i class=conum data-value=5></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=6></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class=conum data-value=7></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class=conum data-value=8></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class=conum data-value=9></i><b>(9)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Der Name des Netzwerks (SSID).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Das als WPA2 bekannte RSN IEEE® 802.11i Protokoll wird verwendet.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Die <code>key_mgmt</code>-Zeile bezieht sich auf das verwendete Key-Management-Protokoll. In diesem Beispiel wird WPA gemeinsam mit der EAP-Authentifizierung verwendet.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Die für die Verbindung verwendete EAP-Methode.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Das <code>identity</code>-Feld enthält den von EAP verwendeten Identifizierungsstring.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Das Feld <code>ca_cert</code> gibt den Pfad zum CA-Zertifikat an. Diese Datei wird zur Verifizierung des Server-Zertifikats benötigt.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Die <code>client_cert</code>-Zeile gibt den Pfad zum Client-Zertifikat an. Jeder Client hat ein eigenes, innerhalb des Netzwerks eindeutiges, Zertifikat.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Das Feld <code>private_key</code> gibt den Pfad zum privaten Schlüssel des Client-Zertifikat an.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Das Feld <code>private_key_passwd</code> enthält die Passphrase für den privaten Schlüssel.</td></tr></tbody></table></div><div class=paragraph><p>Danach fügen Sie die folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Nun können Sie das drahtlose Gerät aktivieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Alternativ kann das drahtlose Gerät manuell mit <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> aktiviert werden.</p></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-ttls>31.3.4.1.3.3. WPA mit EAP-TTLS<a class=anchor href=#network-wireless-wpa-eap-ttls></a></h6><div class=paragraph><p>Bei EAP-TLS müssen sowohl der Authentifizierungsserver als auch die Clients jeweils ein eigenes Zertifikat aufweisen. Bei EAP-TTLS ist das Client-Zertifikat optional. EAP-TTLS geht dabei vor wie ein Webserver, der einen sicheren SSL-Tunnel erzeugen kann, ohne dass der Besucher dabei über ein clientseitiges Zertifikat verfügen muss. EAP-TTLS verwendet einen verschlüsselten TLS-Tunnel zum sicheren Transport der Authentifizierungsdaten.</p></div><div class=paragraph><p>Die erforderliche Konfiguration erfolgt in <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class=conum data-value=5></i><b>(5)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Die für die Verbindung verwendete EAP-Methode.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Das <code>identity</code>-Feld enthält den Identifizierungsstring für die EAP-Authentifizierung innerhalb des verschlüsselten TLS-Tunnels.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Das <code>password</code>-Feld enthält die Passphrase für die EAP-Authentifizierung.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Das Feld <code>ca_cert</code> gibt den Pfad zum CA-Zertifikat an. Diese Datei wird zur Verifizierung des Server-Zertifikats benötigt.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Die innerhalb des verschlüsselten TLS-Tunnels verwendete Authentifizierungsmethode. In Fall von PEAP ist dies <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>Folgende Zeilen müssen in <span class=filename>/etc/rc.conf</span> aufgenommen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Nun kann das drahtlose Gerät aktiviert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-peap>31.3.4.1.3.4. WPA mit EAP-PEAP<a class=anchor href=#network-wireless-wpa-eap-peap></a></h6><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>PEAPv0/EAP-MSCHAPv2 ist die gängigste PEAP-Methode. In diesem Kapitel wird der Begriff PEAP stellvertretend für diese Methode verwendet.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Protected EAP (PEAP) wurde als Alternative zu EAP-TTLS entwickelt und ist nach EAP-TLS der meist genutzte EAP-Standard. In einem Netzwerk mit verschiedenen Betriebssystemen sollte PEAP das am besten unterstützte Standard nach EAP-TLS sein.</p></div><div class=paragraph><p>PEAP arbeitet ähnlich wie EAP-TTLS. Es verwendet ein serverseitiges Zertifikat, um einen verschlüsselten TLS-Tunnel, über den die sichere Authentifizierung zwischen den Clients und dem Authentifizierungsserver erfolgt. In Sachen Sicherheit unterscheiden sich EAP-TTLS und PEAP allerdings: PEAP überträgt den Benutzernamen im Klartext und verschlüsselt nur das Passwort, während EAP-TTLS sowohl den Benutzernamen, als auch das Passwort über den TLS-Tunnel überträgt.</p></div><div class=paragraph><p>Um EAP-PEAP zu konfigurieren, fügen Sie die folgenden Zeilen in <span class=filename>/etc/wpa_supplicant.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34;  <i class=conum data-value=5></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class=conum data-value=6></i><b>(6)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Die für die Verbindung verwendete EAP-Methode.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Das <code>identity</code>-Feld enthält den Identifizierungsstring für die innerhalb des verschlüsselten TLS-Tunnels erfolgende EAP-Authentifizierung.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Das Feld <code>password</code> enthält die Passphrase für die EAP-Authentifizierung.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Das Feld <code>ca_cert</code> gibt den Pfad zum CA-Zertifikat an. Diese Datei wird zur Verifizierung des Server-Zertifikats benötigt.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Dieses Feld enthält die Parameter für die erste Phase der Authentifizierung, den TLS-Tunnel. Je nachdem, welcher Authentifizierungsserver benutzt wird, kann
ein spezifisches Label für die Authentifizierung verwendet werden. Meistens lautet das Label "client EAP encryption", dass durch <code>peaplabel=0</code> gesetzt wird. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Das innerhalb des verschlüsselten TLS-Tunnels verwendete Authentifizierungsprotokoll. In unserem Beispiel handelt es sich dabei um <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>Danach fügen Sie die folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Nun kann das drahtlose Gerät aktiviert werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div></div><div class=sect4><h5 id=network-wireless-wep>31.3.4.1.4. WEP<a class=anchor href=#network-wireless-wep></a></h5><div class=paragraph><p>Wired Equivalent Privacy (WEP) ist Teil des ursprünglichen 802.11-Standards. Es enthält keinen Authentifzierungsmechanismus und verfügt lediglich über eine schwache Zugriffskontrolle, die sehr leicht umgangen werden kann.</p></div><div class=paragraph><p>WEP kann über <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> aktiviert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \</span>
            ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012</code></pre></div></div><div class=ulist><ul><li><p><code>weptxkey</code> definiert den WEP-Schlüssel, der für die Datenübertragung verwendet wird. Dieses Beispiel verwendet den dritten Schlüssel. Der gleiche Schlüssel muss auch am Access Point eingestellt sein. Kennen Sie den vom Access Point verwendeten Schlüssel nicht, sollten Sie zuerst den Wert <code>1</code> (den ersten Schlüssel) für diese Variable verwenden.</p></li><li><p><code>wepkey</code> legt den zu verwendenden WEP-Schlüssel in der Form <em>Nummer:Schlüssel</em> fest. Schlüssel <code>1</code> wird standardmäßig verwendet. Die "Nummer" muss nur angegeben werden, wenn ein anderer als der erste Schlüssel verwendet werden soll.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ersetzen Sie <code>0x3456789012</code> durch den am Access Point konfigurierten Schlüssel.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class=paragraph><p>Das Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> eignet sich ebenfalls dazu, WEP für drahtlose Geräte zu aktivieren. Obige Konfiguration lässt sich dabei durch die Aufnahme der folgenden Zeilen in <span class=filename>/etc/wpa_supplicant.conf</span> realisieren:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;my_net&#34;
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</pre></div></div><div class=paragraph><p>Danach müssen Sie das Programm noch aufrufen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:13:46:49:41:76 <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;dlinkap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2437 MHz<span class=o>)</span>
Associated with 00:13:46:49:41:76</code></pre></div></div></div></div></div><div class=sect2><h3 id=_ad_hoc_modus>31.3.5. Ad-hoc-Modus<a class=anchor href=#_ad_hoc_modus></a></h3><div class=paragraph><p>Der IBSS-Modus, der auch als Ad-hoc-Modus bezeichnet wird, ist für Punkt-zu-Punkt-Verbindungen vorgesehen. Um beispielsweise eine Ad-hoc-Verbindung zwischen den Rechnern <code>A</code> und <code>B</code> aufzubauen, werden lediglich zwei IP-Adressen und eine SSID benötigt.</p></div><div class=paragraph><p>Auf Rechner <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>Der <code>adhoc</code>-Parameter zeigt an, dass die Schnittstelle im IBSS-Modus läuft.</p></div><div class=paragraph><p>Rechner <code>B</code> sollte nun in der Lage sein, Rechner <code>A</code> zu finden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 up scan</span>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M <span class=nt>-64</span>:-96  100 IS   WME</code></pre></div></div><div class=paragraph><p>Der Wert <code>I</code> (Spalte CAPS) in dieser Ausgabe bestätigt, dass sich Rechner <code>A</code> im Ad-hoc-Modus befindet. Nun müssen Sie noch Rechner <code>B</code> eine andere IP-Adresse zuweisen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>Damit sind die Rechner <code>A</code> und <code>B</code> bereit und können untereinander Daten austauschen.</p></div></div><div class=sect2><h3 id=network-wireless-ap>31.3.6. FreeBSD Host Access Points<a class=anchor href=#network-wireless-ap></a></h3><div class=paragraph><p>FreeBSD kann als Access Point (AP) agieren. Dies verhindert, dass man sich einen Hardware AP kaufen oder ein Ad-hoc Netzwerk laufen lassen muss. Dies kann sinnvoll sein, falls der FreeBSD-Computer als Gateway zu einem anderen Netzwerk, wie dem Internet, fungiert.</p></div><div class=sect3><h4 id=network-wireless-ap-basic>31.3.6.1. Grundeinstellungen<a class=anchor href=#network-wireless-ap-basic></a></h4><div class=paragraph><p>Bevor Sie einen FreeBSD-Computer als AP konfigurieren, muss der Kernel mit der entsprechenden Netzwerkunterstützung für die drahtlose Karte, sowie die Sicherheitsprotokolle konfiguriert werden. Weitere Informationen finden Sie im <a href=#network-wireless-basic>Basiskonfiguration</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Verwendung der NDIS Treiber für Windows® erlauben zur Zeit keinen AP-Modus. Nur die nativen FreeBSD-Wireless-Treiber unterstützen den AP-Modus.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nachdem die Netzwerkunterstützung geladen ist, überprüfen Sie, ob das Wireless-Gerät den hostbasierenden Access-Point Modus, der auch als hostap-Modus bekannt ist, unterstützt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 list caps</span>
<span class=nv>drivercaps</span><span class=o>=</span>6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
<span class=nv>cryptocaps</span><span class=o>=</span>1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</code></pre></div></div><div class=paragraph><p>Diese Ausgabe zeigt die Eigenschaften der Karte. Das Wort <code>HOSTAP</code> bestätigt, dass diese Wireless-Karte als AP agieren kann. Die verschiedenen unterstützten Algorithmen werden ebenfalls angezeigt: WEP, TKIP und AES. Diese Informationen zeigen an, welche Sicherheitsprotokolle auf dem AP nutzbar sind.</p></div><div class=paragraph><p>Das Wireless-Gerät kann nur während der Erzeugung des Pseudo-Geräts in den hostap-Modus gesetzt werden. Zuvor erstellte Pseudo-Geräte müssen also vorher zerstört werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 destroy</span></code></pre></div></div><div class=paragraph><p>Danach muss das Gerät erneut erstellt werden, bevor die restlichen Netzwerkparameter konfiguriert werden können:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie danach erneut <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, um den Status der <span class=filename>wlan0</span>-Schnittstelle abzufragen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>Die <code>hostap</code>-Parameter geben die Schnittstelle an, die im hostbasierenden Access Point Modus läuft.</p></div><div class=paragraph><p>Die Konfiguration der Schnittstelle kann durch Hinzufügen der folgenden Zeilen in die Datei <span class=filename>/etc/rc.conf</span> automatisch während des Bootvorganges erfolgen:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
create_args_wlan0=&#34;wlanmode hostap&#34;
ifconfig_wlan0=&#34;inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&#34;</pre></div></div></div><div class=sect3><h4 id=_hostbasierender_access_point_ohne_authentifizierung_oder_verschlüsselung>31.3.6.2. Hostbasierender Access Point ohne Authentifizierung oder Verschlüsselung<a class=anchor href=#_hostbasierender_access_point_ohne_authentifizierung_oder_verschlüsselung></a></h4><div class=paragraph><p>Obwohl es nicht empfohlen wird, einen AP ohne jegliche Authentifizierung oder Verschlüsselung laufen zu lassen, ist es eine einfache Art zu testen, ob der AP funktioniert. Diese Konfiguration ist auch wichtig für die Fehlersuche bei Client-Problemen.</p></div><div class=paragraph><p>Nachdem der AP konfiguriert wurde, ist es möglich von einem anderen drahtlosen Computer eine Suche nach dem AP zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-66</span>:-96  100 ES   WME</code></pre></div></div><div class=paragraph><p>Der Client-Rechner hat den AP gefunden und kann nun eine Verbindung aufbauen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
      scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
      roam:rate 5 protmode CTS wme burst</code></pre></div></div></div><div class=sect3><h4 id=network-wireless-ap-wpa>31.3.6.3. WPA2-hostbasierter Access Point<a class=anchor href=#network-wireless-ap-wpa></a></h4><div class=paragraph><p>Dieser Abschnitt beschäftigt sich mit der Konfiguration eines FreeBSD Access Point mit dem WPA2-Sicherheitsprotokoll. Weitere Einzelheiten zu WPA und der Konfiguration von Clients mit WPA finden Sie im <a href=#network-wireless-wpa>WPA</a>.</p></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>-Dienst wird genutzt, um die Client-Authentifizierung und das Schlüsselmanagement auf dem AP mit aktiviertem WPA2 zu nutzen.</p></div><div class=paragraph><p>Die folgende Konfiguration wird auf dem FreeBSD-Computer ausgeführt, der als AP agiert. Nachdem der AP korrekt arbeitet, sollte <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> automatisch beim Booten durch folgende Zeile in <span class=filename>/etc/rc.conf</span> aktiviert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>hostapd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Bevor Sie versuchen <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> zu konfigurieren, konfigurieren Sie zunächst die Grundeinstellungen, wie im <a href=#network-wireless-ap-basic>Grundeinstellungen</a> beschrieben.</p></div><div class=sect4><h5 id=_wpa2_psk>31.3.6.3.1. WPA2-PSK<a class=anchor href=#_wpa2_psk></a></h5><div class=paragraph><p>WPA2-PSK ist für kleine Netzwerke gedacht, in denen die Verwendung eines Authentifizierungs-Backend-Server nicht möglich oder nicht erwünscht ist.</p></div><div class=paragraph><p>Die Konfiguration wird in <span class=filename>/etc/hostapd.conf</span> durchgeführt:</p></div><div class="literalblock programlisting"><div class=content><pre>interface=wlan0                  <i class=conum data-value=1></i><b>(1)</b>
debug=1                          <i class=conum data-value=2></i><b>(2)</b>
ctrl_interface=/var/run/hostapd  <i class=conum data-value=3></i><b>(3)</b>
ctrl_interface_group=wheel       <i class=conum data-value=4></i><b>(4)</b>
ssid=freebsdap                   <i class=conum data-value=5></i><b>(5)</b>
wpa=2                            <i class=conum data-value=6></i><b>(6)</b>
wpa_passphrase=freebsdmall       <i class=conum data-value=7></i><b>(7)</b>
wpa_key_mgmt=WPA-PSK             <i class=conum data-value=8></i><b>(8)</b>
wpa_pairwise=CCMP                <i class=conum data-value=9></i><b>(9)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Die Wireless-Schnittstelle, die für den Access Point verwendet wird an.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Der debuglevel von <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> während der Ausführung. Ein Wert von <code>1</code> ist der kleinste zulässige Wert.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Der Pfadname des Verzeichnisses, der von <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> genutzt wird, um die Domain-Socket-Dateien zu speichern, die für die Kommunikation mit externen Programmen, wie z.B. <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd_cli&amp;sektion=8&amp;format=html">hostapd_cli(8)</a>, benutzt werden. In diesem Beispiel wird der Standardwert verwendet.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Die Gruppe die Zugriff auf die Schnittstellendateien hat.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Der Name des drahtlosen Netzwerks (SSID).</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Aktiviert WPA und gibt an welches WPA-Authentifizierungprotokoll benötigt wird. Ein Wert von <code>2</code> konfiguriert den AP mit WPA2. Setzen Sie den Wert nur auf <code>1</code>, wenn Sie das veraltete WPA benötigen.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Das ASCII-Passwort für die WPA-Authentifizierung.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Das verwendete Schlüsselmanagement-Protokoll. Dieses Beispiel nutzt WPA-PSK.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Die zulässigen Verschlüsselungsverfahren des Access-Points. In diesem Beispiel wird nur CCMP (AES) akzeptiert. CCMP ist eine Alternative zu TKIP und sollte wenn möglich eingesetzt werden. TKIP sollte nur da eingesetzt werden, wo kein CCMP möglich ist.</td></tr></tbody></table></div><div class=paragraph><p>Als nächstes wird hostapd gestartet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hostapd forcestart</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether 04:f0:21:16:8e:10
	inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
	nd6 <span class=nv>options</span><span class=o>=</span>21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
	media: IEEE 802.11 Wireless Ethernet autoselect mode 11na &lt;hostap&gt;
	status: running
	ssid No5ignal channel 36 <span class=o>(</span>5180 MHz 11a ht/40+<span class=o>)</span> bssid 04:f0:21:16:8e:10
	country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
	AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
	scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
	dtimperiod 1 <span class=nt>-dfs</span>
	<span class=nb>groups</span>: wlan</code></pre></div></div><div class=paragraph><p>Sobald der AP läuft, können sich die Clients mit ihm verbinden. Weitere Informationen finden Sie im <a href=#network-wireless-wpa>WPA</a>. Es ist möglich zu sehen, welche Stationen mit dem AP verbunden sind. Geben Sie dazu <code>ifconfig <em>wlan0</em> list sta</code> ein.</p></div></div></div><div class=sect3><h4 id=_wep_hostbasierter_access_point>31.3.6.4. WEP-hostbasierter Access Point<a class=anchor href=#_wep_hostbasierter_access_point></a></h4><div class=paragraph><p>Es ist nicht empfehlenswert, einen AP mit WEP zu konfigurieren, da es keine Authentifikationsmechanismen gibt und WEP leicht zu knacken ist. Einige ältere drahtlose Karten unterstützen nur WEP als Sicherheitsprotokoll. Diese Karten können nur mit einem AP ohne Authentifikation oder Verschlüsselung genutzt werden.</p></div><div class=paragraph><p>Das Wireless-Gerät kann nun in den hostap-Modus versetzt werden und mit der korrekten SSID und IP-Adresse konfiguriert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \</span>
  ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</code></pre></div></div><div class=ulist><ul><li><p>Der <code>weptxkey</code> zeigt an, welcher WEP-Schlüssel bei der Übertragung benutzt wird. In diesem Beispiel wird der dritte Schlüssel benutzt, da die Nummerierung bei <code>1</code> beginnt. Dieser Parameter muss angegeben werden, damit die Daten verschlüsselt werden.</p></li><li><p>Der <code>wepkey</code> gibt den gewählten WEP-Schlüssel an. Er sollte im folgenden Format <em>index:key</em> vorliegen. Wenn kein Index vorhanden ist, wird der Schlüssel <code>1</code> benutzt. Ansonsten muss der Index manuell festgelegt werden.</p></li></ul></div><div class=paragraph><p>Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> um den Status der <span class=filename>wlan0</span>-Schnittstelle erneut anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 4 <span class=o>(</span>2427 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
      txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>Es ist möglich, von einem anderen drahtlosen Computer eine Suche nach dem AP zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</code></pre></div></div><div class=paragraph><p>Der Client-Rechner hat den AP gefunden und kann nun eine Verbindung aufbauen. Weitere Informationen finden Sie im <a href=#network-wireless-wep>WEP</a>.</p></div></div></div><div class=sect2><h3 id=_benutzung_von_drahtgebundenen_und_drahtlosen_verbindungen>31.3.7. Benutzung von drahtgebundenen und drahtlosen Verbindungen<a class=anchor href=#_benutzung_von_drahtgebundenen_und_drahtlosen_verbindungen></a></h3><div class=paragraph><p>Eine Verbindung per Kabel bietet eine bessere Leistung und eine höhere Zuverlässigkeit, während die Wireless-Verbindung eine höhere Flexibilität und Mobilität bietet. Benutzer von Laptops wollen normalerweise beides nutzen und zwischen beiden Verbindungen hin und her schalten.</p></div><div class=paragraph><p>Unter FreeBSD ist es möglich zwei oder mehr Netzwerkschnittstellen in einem "failover"-Mode zu kombinieren. Diese Konfiguration nutzt die beste verfügbare Verbindung aus einer Gruppe von Netzwerkverbindungen. Sobald sich der Linkstatus ändert, wechselt das Betriebssystem automatisch auf eine andere Verbindung.</p></div><div class=paragraph><p>Link-Aggregation und Failover werden im <a href=#network-aggregation>Link-Aggregation und Failover</a> behandelt. Ein Beispiel für die Verwendung von kabelgebundenen und drahtlosen Verbindungen gibt es im <a href=#networking-lagg-wired-and-wireless>Failover Modus zwischen Ethernet- und drahtlosen Schnittstellen</a>.</p></div></div><div class=sect2><h3 id=_problembehandlung>31.3.8. Problembehandlung<a class=anchor href=#_problembehandlung></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt eine Reihe von Maßnahmen zur Behebung von alltäglichen Problemen mit Drahtlosnetzwerken.</p></div><div class=ulist><ul><li><p>Wird der Access Point bei der Suche nicht gefunden, überprüfen Sie, dass die Konfiguration des drahtlosen Geräts nicht die Anzahl der Kanäle beschränkt.</p></li><li><p>Wenn sich das Gerät nicht mit dem Access Point verbinden kann, überprüfen Sie, ob die Konfiguration der Station auch der des Access Points entspricht. Dazu gehören auch die Authentifzierungsmethode und die Sicherheitsprotokolle. Halten Sie die Konfiguration so einfach wie möglich. Wenn Sie ein Sicherheitsprotokoll wie WPA oder WEP verwenden, können Sie testweise den Access Point auf <em>offene Authentifizierung</em> und <em>keine Sicherheit</em> einstellen.</p><div class=paragraph><p>Für die Fehlersuche steht <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> zur Verfügung. Starten Sie das Programm manuell mit der Option <code>-dd</code> und durchsuchen Sie anschließend die Systemprotokolle nach eventuellen Fehlermeldungen.</p></div></li><li><p>Sobald sich das Gerät mit dem Access Point verbinden kann, prüfen Sie die Netzwerkkonfiguration mit einfachen Werkzeugen wie <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>.</p></li><li><p>Zusätzlich gibt es auch zahlreiche Low-Level-Debugging-Werkzeuge. Die Ausgabe von Debugging-Informationen des 802.11 Protocol Support Layers lassen sich mit dem Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=wlandebug&amp;sektion=8&amp;format=html">wlandebug(8)</a> aktivieren. Um beispielsweise während der Suche nach Access Points und des Aufbaus von 802.11-Verbindungen (Handshake) auftretende Systemmeldungen auf die Konsole auszugeben, verwenden Sie den folgenden Befehl:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wlandebug -i wlan0 +scan+auth+debug+assoc</span>
  net.wlan.0.debug: 0 <span class=o>=&gt;</span> 0xc80000&lt;assoc,auth,scan&gt;</code></pre></div></div><div class=paragraph><p>Der 802.11-Layer liefert umfangreiche Statistiken, die mit dem Werkzeug <code>wlanstats</code>, das sich in <span class=filename>/usr/src/tools/tools/net80211</span> befindet, abgerufen werden können. Diese Statistiken sollten alle Fehler identifizieren, die im 802.11-Layer auftreten. Beachten Sie aber, dass einige Fehler bereits im darunterliegenden Gerätetreiber auftreten und daher in diesen Statistiken nicht enthalten sind. Wie Sie Probleme des Gerätetreibers identifizieren, entnehmen Sie bitte der Dokumentation des Gerätetreibers.</p></div></li></ul></div><div class=paragraph><p>Wenn die oben genannten Informationen nicht helfen das Problem zu klären, erstellen Sie einen Problembericht, der die Ausgabe der weiter oben genannten Werkzeuge beinhaltet.</p></div></div></div></div><div class=sect1><h2 id=network-usb-tethering>31.4. USB Tethering<a class=anchor href=#network-usb-tethering></a></h2><div class=sectionbody><div class=paragraph><p>Viele Mobiltelefone bieten die Möglichkeit, ihre Datenverbindung über USB (oft "Tethering" genannt) zu teilen. Diese Funktion verwendet entweder das RNDIS-, CDC- oder ein Apple® iPhone®/iPad®-Protokoll.</p></div><div class=ulist><ul><li><p>Android™-Geräte benutzen in der Regel den <a href="https://man.freebsd.org/cgi/man.cgi?query=urndis&amp;sektion=4&amp;format=html">urndis(4)</a>-Treiber.</p></li><li><p>Apple®-Geräte benutzen den <a href="https://man.freebsd.org/cgi/man.cgi?query=ipheth&amp;sektion=4&amp;format=html">ipheth(4)</a>-Treiber.</p></li><li><p>Ältere Geräte benutzen oft den <a href="https://man.freebsd.org/cgi/man.cgi?query=cdce&amp;sektion=4&amp;format=html">cdce(4)</a>-Treiber.</p></li></ul></div><div class=paragraph><p>Bevor Sie ein Gerät anschließen, laden Sie den entsprechenden Treiber in den Kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_urndis</span>
<span class=c># kldload if_cdce</span>
<span class=c># kldload if_ipheth</span></code></pre></div></div><div class=paragraph><p>Sobald das Gerät angeschlossen ist, steht es unter <code>ue</code><em>0</em> wie ein normales Netzwerkgerät zur Verfügung. Stellen Sie sicher, dass die Option "USB Tethering" auf dem Gerät aktiviert ist.</p></div><div class=paragraph><p>Um diese Änderungen dauerhaft zu speichern und den Treiber beim Booten als Modul zu laden, müssen die entsprechenden Zeilen in <span class=filename>/boot/loader.conf</span> konfiguriert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>if_urndis_load=&#34;YES&#34;
if_cdce_load=&#34;YES&#34;
if_ipteth_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect1><h2 id=network-bluetooth>31.5. Bluetooth<a class=anchor href=#network-bluetooth></a></h2><div class=sectionbody><div class=paragraph><p>Bluetooth ermöglicht die Bildung von persönlichen Netzwerken über drahtlose Verbindungen bei einer maximalen Reichweite von 10 Metern und operiert im unlizensierten 2,4-GHz-Band. Solche Netzwerke werden normalerweise spontan gebildet, wenn sich mobile Geräte, wie Mobiltelefone, Handhelds oder Notebooks miteinander verbinden. Im Gegensatz zu Wireless LAN ermöglicht Bluetooth auch höherwertige Dienste, wie FTP-ähnliche Dateiserver, Filepushing, Sprachübertragung, Emulation von seriellen Verbindungen und mehr.</p></div><div class=paragraph><p>Dieses Kapitel beschreibt die Verwendung von USB-Bluetooth-Adaptern in FreeBSD. Weiterhin werden verschiedene Bluetooth-Protokolle und Programme vorgestellt.</p></div><div class=sect2><h3 id=_die_bluetooth_unterstützung_aktivieren>31.5.1. Die Bluetooth-Unterstützung aktivieren<a class=anchor href=#_die_bluetooth_unterstützung_aktivieren></a></h3><div class=paragraph><p>Der Bluetooth-Stack von FreeBSD verwendet das <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a>-Framework. Viele Bluetooth-USB-Adapter werden durch den <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>-Treiber unterstützt. Auf dem Chip BCM2033 von Broadcom basierende Bluetooth-Geräte werden von den Treibern <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> unterstützt. Die Bluetooth-PC-Card 3CRWB60-A von 3Com verwendet den <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a>-Treiber. Serielle sowie auf UART basierende Bluetooth-Geräte werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a> unterstützt.</p></div><div class=paragraph><p>Bevor ein Gerät angeschlossen wird, muss der entsprechende Treiber in den Kernel geladen werden. Hier verwendet das Gerät den <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>-Treiber:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>Ist das Bluetooth-Gerät beim Systemstart angeschlossen, kann das entsprechende Modul bei Booten geladen werden, indem der entsprechende Treiber in <span class=filename>/boot/loader.conf</span> hinzugefügt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Sobald der Treiber geladen ist, schließen Sie den USB-Adapter an. Eine Meldung ähnlich der folgenden wird auf der Konsole und in <span class=filename>/var/log/messages</span> erscheinen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class=paragraph><p>Verwenden Sie das Startskript zum Starten und Beenden des Bluetooth-Stacks. Es ist empfehlenswert, den Bluetooth-Stack zu beenden, bevor Sie den Adapter entfernen. Das Starten des Bluetooth-Stacks kann das Starten von <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> erfordern. Wenn Sie den Bluetooth-Stack starten, erhalten Sie eine Meldung ähnlich der folgenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></div><div class=sect2><h3 id=_suche_nach_anderen_bluetooth_geräten>31.5.2. Suche nach anderen Bluetooth-Geräten<a class=anchor href=#_suche_nach_anderen_bluetooth_geräten></a></h3><div class=paragraph><p>Das Host Controller Interface (HCI) bietet eine einheitliche Methode für den Zugriff auf Bluetooth-Basisband-Funktionen. In FreeBSD wird ein netgraph HCI-Knoten für jedes Bluetooth-Gerät erstellt. Weitere Einzelheiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a>.</p></div><div class=paragraph><p>Eine der wichtigsten Aufgaben ist das Auffinden von sich in Reichweite befindenden Bluetooth-Geräten. Diese Funktion wird als <em>inquiry</em> bezeichnet. Inquiry sowie andere mit HCI in Verbindung stehende Funktionen werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a> zur Verfügung gestellt. Das folgende Beispiel zeigt, wie man herausfindet, welche Bluetooth-Geräte sich in Reichweite befinden. Eine solche Abfrage dauert nur wenige Sekunden. Beachten Sie, dass ein Gerät nur dann antwortet, wenn es sich im Modus <em>discoverable</em> befindet.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p><code>BD_ADDR</code> stellt, ähnlich der MAC-Adresse einer Netzwerkkarte, die eindeutige Adresse eines Bluetooth-Gerätes dar. Diese Adresse ist für die Kommunikation mit dem Gerät nötig. Es ist aber auch möglich, <code>BD_ADDR</code> einen Klartextnamen zuzuweisen. <span class=filename>/etc/bluetooth/hosts</span> enthält Informationen über die bekannten Bluetooth-Rechner. Das folgende Beispiel zeigt, wie man den Klartextnamen eines entfernten Geräts in Erfahrung bringen kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>Wenn Sie ein entferntes Bluetooth-Gerät abfragen, wird dieses den Rechner unter dem Namen "your.host.name (ubt0)" finden. Dieser Name kann aber jederzeit geändert werden.</p></div><div class=paragraph><p>Entfernten Geräten können Aliase in <span class=filename>/etc/bluetooth/hosts</span> zugewiesen werden. Weitere Informationen zu <span class=filename>/etc/bluetooth/hosts</span> finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=bluetooth.hosts&amp;sektion=5&amp;format=html">bluetooth.hosts(5)</a>.</p></div><div class=paragraph><p>Bluetooth ermöglicht Punkt-zu-Punkt-Verbindungen an denen nur zwei Bluetooth-Geräte beteiligt sind, aber auch Punkt-zu-Multipunkt-Verbindungen, bei denen eine Verbindung von mehreren Bluetooth-Geräten gemeinsam genutzt wird. Das folgende Beispiel zeigt, wie man eine Verbindung zu einem entferntem Gerät aufbauen kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci create_connection BT_ADDR</code></pre></div></div><div class=paragraph><p><code>create_connection</code> aktzeptiert <code>BT_ADDR</code> oder auch einen Alias aus <span class=filename>/etc/bluetooth/hosts</span>.</p></div><div class=paragraph><p>Das folgende Beispiel zeigt, wie man die aktiven Basisbandverbindungen des lokalen Gerätes anzeigen kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>Ein <em>connection handle</em> ist für die Beendigung einer Basisbandverbindung nützlich. Im Normalfall werden inaktive Verbindungen aber automatisch vom Bluetooth-Stack getrennt.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Rufen Sie <code>hccontrol help</code> auf, wenn Sie eine komplette Liste aller verfügbaren HCI-Befehle benötigen. Die meisten dieser Befehle müssen nicht als <code>root</code> ausgeführt werden.</p></div></div><div class=sect2><h3 id=_erstmaliger_verbindungsaufbau_zwischen_zwei_bluetooth_geräten_pairing>31.5.3. Erstmaliger Verbindungsaufbau zwischen zwei Bluetooth-Geräten (Pairing)<a class=anchor href=#_erstmaliger_verbindungsaufbau_zwischen_zwei_bluetooth_geräten_pairing></a></h3><div class=paragraph><p>In der Voreinstellung nutzt Bluetooth keine Authentifizierung, daher kann sich jedes Bluetoothgerät mit jedem anderen Gerät verbinden. Ein Bluetoothgerät, wie beispielsweise ein Mobiltelefon, kann jedoch für einen bestimmten Dienst, etwa eine Einwählverbindung, eine Authentifizierung anfordern. Bluetooth verwendet zu diesem Zweck <em>PIN-Codes</em>. Ein PIN-Code ist ein maximal 16 Zeichen langer ASCII-String. Damit eine Verbindung zustande kommt, muss auf beiden Geräten der gleiche PIN-Code verwendet werden. Nachdem der Code eingegeben wurde, erzeugen beide Geräte einen <em>link key</em>, der auf den Geräten gespeichert wird. Beim nächsten Verbindungsaufbau wird der zuvor erzeugte Link Key verwendet. Diesen Vorgang bezeichnet man als Pairing. Geht der Link Key auf einem Gerät verloren, muss das Pairing wiederholt werden.</p></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>-Daemon verarbeitet Bluetooth-Authentifzierungsanforderungen und wird über die Datei <span class=filename>/etc/bluetooth/hcsecd.conf</span> konfiguriert. Der folgende Ausschnitt dieser Datei zeigt die Konfiguration für ein Mobiltelefon, das den PIN-Code "1234" verwendet:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>Von der Länge abgesehen, unterliegen PIN-Codes keinen Einschränkungen. Einige Geräte, beispielsweise Bluetooth-Headsets, haben einen festen PIN-Code eingebaut. Die Option <code>-d</code> sorgt dafür, dass der <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>-Daemon im Vordergrund läuft. Dadurch kann der Ablauf einfach verfolgt werden. Stellen Sie das entfernte Gerät auf receive pairing und initiieren Sie die Bluetoothverbindung auf dem entfernten Gerät. Sie erhalten die Meldung, dass Pairing akzeptiert wurde und der PIN-Code benötigt wird. Geben Sie den gleichen PIN-Code ein, den Sie in <span class=filename>hcsecd.conf</span> festgelegt haben. Der Computer und das entfernte Gerät sind nun miteinander verbunden. Alternativ können Sie das Pairing auch auf dem entfernten Gerät initiieren.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> kann durch das Einfügen der folgenden Zeile in <span class=filename>/etc/rc.conf</span> beim Systemstart automatisch aktiviert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Es folgt nun eine beispielhafte Ausgabe des <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>-Daemons:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect2><h3 id=_einwahlverbindungen_und_netzwerkverbindungen_mit_ppp_profilen_einrichten>31.5.4. Einwahlverbindungen und Netzwerkverbindungen mit PPP-Profilen einrichten<a class=anchor href=#_einwahlverbindungen_und_netzwerkverbindungen_mit_ppp_profilen_einrichten></a></h3><div class=paragraph><p>Ein Dial-Up Networking-Profil (DUN) kann dazu benutzt werden, ein Mobiltelefon als drahtloses Modem zu nutzen, um sich über einen Einwahlprovider mit dem Internet zu verbinden. Es kann auch dazu genutzt werden, einen Computer so zu konfigurieren, dass dieser Datenabfragen empfängt.</p></div><div class=paragraph><p>Der Zugriff auf ein Netzwerk über ein PPP-Profil kann einen Zugriff auf das LAN für ein oder mehrere Bluetooth-Geräte bieten. Eine PC-zu-PC-Verbindung unter Verwendung einer PPP-Verbindung über eine serielle Verbindung ist ebenfalls möglich.</p></div><div class=paragraph><p>Diese Profile werden unter FreeBSD durch <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> implementiert - einem Wrapper, der Bluetooth-Verbindungen unter PPP nutzbar macht. Bevor ein Profil verwendet werden kann, muss ein neuer PPP-Abschnitt in <span class=filename>/etc/ppp/ppp.conf</span> erzeugt werden. Beispielkonfigurationen zu diesem Thema finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>.</p></div><div class=paragraph><p>Dieses Beispiel verwendet <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>, um eine Verbindung zu einem entfernten Gerät mit der <code>BD_ADDR 00:80:37:29:19:a4</code> auf dem RFCOMM-Kanal <code>DUN</code> aufzubauen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>Die aktuelle Kanalnummer des entfernten Geräts erhalten Sie über das SDP-Protokoll. Es ist auch möglich, manuell einen RFCOMM-Kanal festzulegen. In diesem Fall führt <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> keine SDP-Abfrage durch. Verwenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a>, um die RFCOMM-Kanäle des entfernten Geräts herauszufinden.</p></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>-Server muss laufen, damit ein Netzzugriff mit dem PPPLAN-Profil möglich ist. Außerdem muss für den LAN-Client ein neuer Eintrag in <span class=filename>/etc/ppp/ppp.conf</span> erzeugt werden. Beispielkonfigurationen zu diesem Thema finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Danach starten Sie den RFCOMMPPP-Server über eine gültige RFCOMM-Kanalnummer. Der RFCOMMPPP-Server bindet dadurch den Bluetooth-LAN-Dienst an den lokalen SDP-Daemon. Das folgende Beispiel zeigt, wie man den RFCOMMPPP-Server startet.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect2><h3 id=_bluetooth_protokolle>31.5.5. Bluetooth-Protokolle<a class=anchor href=#_bluetooth_protokolle></a></h3><div class=paragraph><p>Dieser Abschnitt gibt einen Überblick über die verschiedenen Bluetooth-Protokolle, ihre Funktionen sowie weitere Programme.</p></div><div class=sect3><h4 id=_das_logical_link_control_and_adaptation_protocol_l2cap>31.5.5.1. Das Logical Link Control and Adaptation Protocol (L2CAP)<a class=anchor href=#_das_logical_link_control_and_adaptation_protocol_l2cap></a></h4><div class=paragraph><p>Das Logical Link Control and Adaptation Protocol (L2CAP) bietet höherwertigen Protokollen verbindungsorientierte und verbindungslose Datendienste an. L2CAP erlaubt höherwertigen Protokollen und Programmen den Versand und Empfang von L2CAP-Datenpaketen mit einer Länge von bis zu 64 Kilobytes.</p></div><div class=paragraph><p>L2CAP arbeitet _kanal_basiert. Ein Kanal ist eine logische Verbindung innerhalb einer Basisbandverbindung. Jeder Kanal ist dabei an ein einziges Protokoll gebunden. Mehrere Geräte können an das gleiche Protokoll gebunden sein, es ist aber nicht möglich, einen Kanal an mehrere Protokolle zu binden. Jedes über einen Kanal ankommende L2CAP-Paket wird an das entsprechende höherwertige Protokoll weitergeleitet. Mehrere Kanäle können sich die gleiche Basisbandverbindung teilen.</p></div><div class=paragraph><p>Unter FreeBSD wird eine netgraph-Gerätedatei vom Typ <em>l2cap</em> für jedes einzelne Bluetooth-Gerät erzeugt. Diese Gerätedatei ist normalerweise mit der Bluetooth-HCI-Gerätedatei (downstream) sowie der Bluetooth-Socket-Gerätedatei (upstream) verbunden. Der Standardname für die L2CAP-Gerätedatei lautet "devicel2cap". Weitere Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a>.</p></div><div class=paragraph><p>Ein nützlicher Befehl zum Anpingen von anderen Geräten ist <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>. Einige Bluetooth-Geräte senden allerdings nicht alle erhaltenen Daten zurück. Die Ausgabe <code>0 bytes</code> im folgenden Beispiel ist also kein Fehler:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>Das Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> liefert Informationen über L2CAP-Dateien. Das folgende Beispiel zeigt, wie man die Liste der logischen Verbindungen (Kanäle) sowie die Liste der Basisbandverbindungen abfragen kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a> ist ein weiteres Diagnoseprogramm. Es funktioniert ähnlich wie <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>, arbeitet aber mit Bluetooth-Datenstrukturen. Das folgende Beispiel zeigt die gleiche Liste der logischen Verbindungen wie <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> im vorherigen Beispiel.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect3><h4 id=_radio_frequency_communication_rfcomm>31.5.5.2. Radio Frequency Communication (RFCOMM)<a class=anchor href=#_radio_frequency_communication_rfcomm></a></h4><div class=paragraph><p>Das RFCOMM-Protokoll emuliert serielle Verbindungen über das L2CAP-Protokoll. Bei RFCOMM handelt es sich um ein einfaches Transportprotokoll, das um Funktionen zur Emulation der 9poligen Schaltkreise von mit RS-232 (EIATIA-232-E) kompatiblen seriellen Ports ergänzt wurde. Es erlaubt bis zu 60 simultane Verbindungen (RFCOMM-Kanäle) zwischen zwei Bluetooth-Geräten.</p></div><div class=paragraph><p>Eine RFCOMM-Kommunikation besteht aus zwei Anwendungen (den Kommunikationsendpunkten), die über das Kommunikationssegment miteinander verbunden sind. RFCOMM unterstützt Anwendungen, die auf serielle Ports angewiesen sind. Das Kommunikationssegment entspricht der direkten Bluetooth-Verbindung zwischen den beiden Geräten.</p></div><div class=paragraph><p>RFCOMM kümmert sich um die direkte Verbindung von zwei Geräten, oder um die Verbindung zwischen einem Gerät und einem Modem über eine Netzwerkverbindung. RFCOMM unterstützt auch andere Konfigurationen. Ein Beispiel dafür sind Module, die drahtlose Bluetooth-Geräte mit einer verkabelten Schnittstelle verbinden können.</p></div><div class=paragraph><p>Unter FreeBSD ist das RFCOMM-Protokoll im Bluetooth Socket-Layer implementiert.</p></div></div><div class=sect3><h4 id=_das_service_discovery_protocol_sdp>31.5.5.3. Das Service Discovery Protocol (SDP)<a class=anchor href=#_das_service_discovery_protocol_sdp></a></h4><div class=paragraph><p>Das Service Discovery Protocol (SDP) erlaubt es Clientanwendungen, von Serveranwendungen angebotene Dienste sowie deren Eigenschaften abzufragen. Zu diesen Eigenschaften gehören die Art oder die Klasse der angebotenen Dienste sowie der Mechanismus oder das Protokoll, die zur Nutzung des Dienstes notwendig sind.</p></div><div class=paragraph><p>SDP ermöglicht Verbindungen zwischen einem SDP-Server und einem SDP-Client. Der Server enthält eine Liste mit den Eigenschaften der vom Server angebotenen Dienste. Jeder Eintrag beschreibt jeweils einen einzigen Serverdienst. Ein Client kann diese Informationen durch eine SDP-Anforderung vom SDP-Server beziehen. Wenn der Client oder eine Anwendung des Clients einen Dienst nutzen will, muss eine separate Verbindung mit dem Dienstanbieter aufgebaut werden. SDP bietet einen Mechanismus zum Auffinden von Diensten und deren Eigenschaften an, es bietet aber keine Mechanismen zur Verwendung dieser Dienste.</p></div><div class=paragraph><p>Normalerweise sucht ein SDP-Client nur nach Diensten, die bestimmte geforderte Eigenschaften erfüllen. Es ist aber auch möglich, anhand der Dienstbeschreibungen eine allgemeine Suche nach den von einem SDP-Server angebotenen Diensten durchzuführen. Diesen Vorgang bezeichnet man als Browsing.</p></div><div class=paragraph><p>Der Bluetooth-SDP-Server <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> und der Kommandozeilenclient <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> sind bereits in der Standardinstallation von FreeBSD enthalten. Das folgende Beispiel zeigt, wie eine SDP-Abfrage durchgeführt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class=paragraph><p>Beachten Sie, dass jeder Dienst eine Liste seiner Eigenschaften, wie etwa den RFCOMM-Kanal, zurückgibt. Je nachdem, welche Dienste der Benutzer benötigt, sollten einige dieser Eigenschaften notiert werden. Einige Bluetooth-Implementationen unterstützen kein Service Browsing und geben daher eine leere Liste zurück. Ist dies der Fall, ist es dennoch möglich, nach einem bestimmten Dienst zu suchen. Das folgende Beispiel demonstriert die Suche nach dem OBEX Object Push (OPUSH) Dienst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>Unter FreeBSD ist es die Aufgabe des <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>-Servers, Bluetooth-Clients verschiedene Dienste anzubieten. Sie können diesen Server durch das Einfügen der folgenden Zeile in <span class=filename>/etc/rc.conf</span> aktivieren:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Nun kann der <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>-Daemon durch folgende Eingabe gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sdpd start</span></code></pre></div></div><div class=paragraph><p>Der lokale Server, der den entfernten Clients Bluetooth-Dienste anbieten soll, bindet diese Dienste an den lokalen SDP-Daemon. Ein Beispiel für eine solche Anwendung ist <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Einmal gestartet, wird der Bluetooth-LAN-Dienst an den lokalen SDP-Daemon gebunden.</p></div><div class=paragraph><p>Die Liste der vorhandenen Dienste, die am lokalen SDP-Server registriert sind, lässt sich durch eine SDP-Abfrage über einen lokalen Kontrollkanal abfragen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect3><h4 id=_obex_object_push_opush>31.5.5.4. OBEX Object-Push (OPUSH)<a class=anchor href=#_obex_object_push_opush></a></h4><div class=paragraph><p>OBEX ist ein häufig verwendetes Protokoll für den Dateitransfer zwischen Mobilgeräten. Sein Hauptzweck ist die Kommunikation über die Infrarotschnittstelle. Es dient daher zum Datentransfer zwischen Notebooks oder PDAs sowie zum Austausch von Visitenkarten oder Kalendereinträgen zwischen Mobiltelefonen und anderen Geräten mit PIM-Funktionen.</p></div><div class=paragraph><p>Server und Client von OBEX werden durch obexapp bereitgestellt, das als Paket oder Port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a> installiert werden kann.</p></div><div class=paragraph><p>Mit dem OBEX-Client werden Objekte zum OBEX-Server geschickt oder angefordert. Ein Objekt kann etwa eine Visitenkarte oder ein Termin sein. Der OBEX-Client fordert über SDP die Nummer des RFCOMM-Kanals vom entfernten Gerät an. Dies kann auch durch die Verwendung des Servicenamens anstelle der RFCOMM-Kanalnummer erfolgen. Folgende Dienste werden unterstützt: <code>IrMC</code>, <code>FTRN</code> und <code>OPUSH</code>. Es ist möglich, den RFCOMM-Kanal als Nummer anzugeben. Es folgt ein Beispiel für eine OBEX-Sitzung, bei der ein Informationsobjekt vom Mobiltelefon angefordert und ein neues Objekt (hier eine Visitenkarte) an das Telefonbuch des Mobiltelefons geschickt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Um OBEX-Push-Dienste anbieten zu können, muss der sdpd-Server gestartet sein. Ein Wurzelverzeichnis, in dem alle ankommenden Objekte gespeichert werden, muss zusätzlich angelegt werden. In der Voreinstellung ist dies <span class=filename>/var/spool/obex</span>. Starten Sie den OBEX-Server mit einer gültigen Kanalnummer. Der OBEX-Server registriert nun den OBEX-Push-Dienst mit dem lokalen SDP-Daemon. Das folgende Beispiel zeigt, wie der OBEX-Server gestartet wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect3><h4 id=_das_serial_port_profil_spp>31.5.5.5. Das Serial-Port Profil (SPP)<a class=anchor href=#_das_serial_port_profil_spp></a></h4><div class=paragraph><p>Das Serial Port Profile (SSP) ermöglicht es Bluetooth-Geräten eine serielle Kabelverbindung zu emulieren. Anwendungen sind dadurch in der Lage, über eine virtuelle serielle Verbindung Bluetooth als Ersatz für eine Kabelverbindung zu nutzen.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> implementiert unter FreeBSD SSP und ein Pseudo-tty, das als virtuelle serielle Verbindung verwendet wird. Das folgende Beispiel zeigt, wie man eine Verbindung mit einem entfernten Serial-Port-Dienst herstellt. Ein RFCOMM-Kanal muss dabei nicht angegeben werden, da <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> den Kanal über SDP abfragen kann. Um dies zu umgehen, geben Sie einen RFCOMM-Kanal auf der Kommandozeile an.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t</span>
rfcomm_sppd[94692]: Starting on /dev/pts/6...
/dev/pts/6</code></pre></div></div><div class=paragraph><p>Sobald die Verbindung hergestellt ist, kann pseudo-tty als serieller Port verwenden werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/pts/6</span></code></pre></div></div><div class=paragraph><p>Das pseudo-tty wird auf der Standardausgabe ausgegeben und kann von Wrapper-Skripten gelesen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
cu -l $PTS</pre></div></div></div></div><div class=sect2><h3 id=_problembehandlung_2>31.5.6. Problembehandlung<a class=anchor href=#_problembehandlung_2></a></h3><div class=paragraph><p>Wenn FreeBSD eine neue Verbindung akzeptiert, versucht es, die Rolle zu tauschen, um zum Master zu werden. Einige ältere Geräte, die dies nicht unterstützen, können keine Verbindung aufbauen. Da der Rollentausch ausgeführt wird sobald eine neue Verbindung aufgebaut wird, ist es nicht möglich, das entfernte Gerät zu fragen ob es den Rollentausch unterstützt. Es gibt jedoch eine HCI-Option, die dieses Verhalten deaktiviert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div><div class=paragraph><p>Verwenden Sie hcidump, das als Paket Port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a> installiert werden kann, um Bluetooth-Pakete anzuzeigen. Dieses Programm hat Ähnlichkeiten mit <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> und kann zur Anzeige der Bluetooth-Pakete in einem Terminal, oder zur Speicherung von Paketen in einer Datei (Dump) verwendet werden.</p></div></div></div></div><div class=sect1><h2 id=network-bridging>31.6. LAN-Kopplung mit einer Bridge<a class=anchor href=#network-bridging></a></h2><div class=sectionbody><div class=paragraph><p>Manchmal ist es nützlich, ein Netzwerk, wie ein Ethernetsegment, in separate Netzwerke aufzuteilen, ohne gleich IP-Subnetze zu erzeugen, die über einen Router miteinander verbunden sind. Ein Gerät, das zwei Netze auf diese Weise verbindet, wird als "Bridge" bezeichnet.</p></div><div class=paragraph><p>Eine Bridge arbeitet, indem sie die MAC-Adressen der Geräte in ihren Netzwerksegmenten lernt. Der Verkehr wird nur dann zwischen zwei Segmenten weitergeleitet, wenn sich Sender und Empfänger in verschiedenen Netzwerksegmenten befinden. Jedes FreeBSD-System mit zwei Netzwerkkarten kann als Bridge fungieren.</p></div><div class=paragraph><p>Bridging kann in den folgenden Situationen sinnvoll sein:</p></div><div class=dlist><dl><dt class=hdlist1>Verbinden von Netzwerken</dt><dd><p>Die Hauptaufgabe einer Bridge ist die Verbindung von zwei oder mehreren Netzwerksegmenten. Es gibt viele Gründe, eine hostbasierte Bridge einzusetzen, anstelle von Netzwerkkomponenten, wie beispielsweise Kabelverbindungen oder Firewalls. Eine Bridge kann außerdem ein drahtloses Gerät mit einem Kabelnetzwerk verbinden. Diese Fähigkeit der Bridge wird als HostAP-Modus bezeichnet. Die Bridge agiert in diesem Fall als Access Point für das drahtlose Gerät.</p></dd><dt class=hdlist1>Filtering / Traffic Shaping Firewall</dt><dd><p>Eine Bridge kann eingesetzt werden, wenn Firewallfunktionen benötigt werden, ohne dabei Routing oder Network Adress Translation (NAT) zu verwenden.</p><div class=paragraph><p>Ein Beispiel dafür wäre ein kleines Unternehmen, das über DSL oder ISDN an einen ISP angebunden ist. Es verfügt über 13 erreichbare IP-Adressen und das Netzwerk besteht aus 10 Rechnern. In dieser Situation ist der Einsatz von Subnetzen sowie einer routerbasierten Firewall aufgrund der IP-Adressierung schwierig. Eine Bridge-basierte Firewall kann hingegen ohne Probleme konfiguriert werden.</p></div></dd><dt class=hdlist1>Netzwerküberwachung</dt><dd><p>Eine Bridge kann zwei Netzwerksegmente miteinander verbinden und danach alle Ethernet-Rahmen überprüfen, die zwischen den beiden Netzwerksegmenten ausgetauscht werden. Dazu verwendet man entweder <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> auf dem Netzgerät der Bridge oder schickt Kopien aller Rahmen an ein zusätzliches Netzgerät, das als Span Port bekannt ist.</p></dd><dt class=hdlist1>Layer 2 VPN</dt><dd><p>Zwei Ethernetnetzwerke können über einen IP-Link miteinander verbunden werden, indem die beiden Netzwerke über einen EtherIP-Tunnel gekoppelt werden, oder eine <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a>-basierte Lösung wie OpenVPN eingesetzt wird.</p></dd><dt class=hdlist1>Layer 2 Redundanz</dt><dd><p>Die Systeme eines Netzwerks können über das Spanning Tree Protocol (STP) redundant miteinander verbunden sein, um redundante Pfade zu blockieren.</p></dd></dl></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie ein FreeBSD-System mit Hilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> als Bridge konfiguriert wird. Ein netgraph-Bridge-Treiber ist ebenfalls verfügbar und wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bridge&amp;sektion=4&amp;format=html">ng_bridge(4)</a> beschrieben.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Paketfilter können mit allen Firewallpaketen verwendet werden, die das <a href="https://man.freebsd.org/cgi/man.cgi?query=pfil&amp;sektion=9&amp;format=html">pfil(9)</a>-Framework benutzen. Eine Bridge kann auch als Traffic Shaper verwendet werden, wenn Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> einsetzen.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_die_bridge_aktivieren>31.6.1. Die Bridge aktivieren<a class=anchor href=#_die_bridge_aktivieren></a></h3><div class=paragraph><p>In FreeBSD handelt es sich bei <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> um ein Kernelmodul, das von <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> automatisch geladen wird, wenn eine Bridge-Schnittstelle erzeugt wird. Es ist auch möglich, die Unterstützung für den Treiber in den Kernel zu kompilieren, indem die Zeile <code>device if_bridge</code> in die Kernelkonfigurationsdatei hinzugefügt wird.</p></div><div class=paragraph><p>Eine Bridge wird durch das Klonen von Schnittstellen erzeugt. Um eine Bridge zu erzeugen, verwenden Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge create</span>
bridge0
<span class=c># ifconfig bridge0</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:00:00:00:00:00 priority 0 ifcost 0 port 0</code></pre></div></div><div class=paragraph><p>Wenn eine Bridge erzeugt wird, erhält sie automatisch eine zufällig generierte Ethernet-Adresse. Die Parameter <code>maxaddr</code> sowie <code>timeout</code> legen fest, wie viele MAC-Adressen die Bridge in ihrer Forward-Tabelle halten kann und wie viele Sekunden jeder Eintrag erhalten bleiben soll, nachdem er zuletzt verwendet wurde. Die restlichen Parameter sind für die Konfiguration von STP notwendig.</p></div><div class=paragraph><p>Im nächsten Schritt werden die Schnittstellen, die die Bridge verbinden soll, zugewiesen. Damit die Bridge Datenpakete weiterleiten kann, müssen sowohl die Bridge als auch die Schnittstellen der zu verbindenden Netzwerksegmente aktiviert sein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 up</span>
<span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span></code></pre></div></div><div class=paragraph><p>Jetzt ist die Bridge in der Lage, Ethernet-Rahmen zwischen den Schnittstellen <span class=filename>fxp0</span> und <span class=filename>fxp1</span> weiterzuleiten. Um diese Konfiguration beim Systemstart automatisch zu aktivieren, müssen die folgenden Zeilen in <span class=filename>/etc/rc.conf</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;addm fxp0 addm fxp1 up&#34;
ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;</pre></div></div><div class=paragraph><p>Wenn die Bridge eine IP-Adresse benötigt, muss diese der Schnittstelle der Bridge zugewiesen werden und nicht der Schnittstelle der gekoppelten Netzwerksegmente. Die IP-Adresse kann manuell gesetzt, oder über DHCP bezogen werden. Dieses Beispiel verwendet eine statische IP-Adresse:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>Es ist auch möglich der Bridge-Schnittstelle eine IPv6-Adresse zuzuweisen. Um die Änderungen dauerhaft zu speichern, fügen Sie die Adressinformationen in <span class=filename>/etc/rc.conf</span> ein.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nachdem ein Paketfilter aktiviert wurde, können Datenpakete, die von den Schnittstellen der gekoppelten Netzwerksegmente gesendet und empfangen werden, über die Bridge weitergeleitet oder nach bestimmten Regeln gefiltert oder auch komplett geblockt werden. Ist die Richtung des Paketflusses wichtig, ist es am besten, eine Firewall auf den Schnittstellen der einzelnen Netzwerksegmente einzurichten und nicht auf der Bridge selbst.</p></div><div class=paragraph><p>Eine Bridge verfügt über verschiedene Optionen zur Weiterleitung von Nicht-IP- und IP-Paketen, sowie Paketfilterung auf Layer 2 mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_spanning_tree_aktivieren>31.6.2. Spanning Tree aktivieren<a class=anchor href=#_spanning_tree_aktivieren></a></h3><div class=paragraph><p>Damit ein Ethernet-Netzwerk richtig funktioniert, kann nur ein aktiver Pfad zwischen zwei Geräten existieren. Das STP-Protokoll erkennt Schleifen in einer Netzwerktopologie und setzt redundante Pfade in einen blockierten Zustand. Sollte eine der aktiven Verbindungen ausfallen, berechnet STP einen anderen Baum und ermöglicht es dann einem blockierten Pfad, alle Netzwerkverbindungen wiederherzustellen.</p></div><div class=paragraph><p>Das Rapid Spanning Tree Protocol (RSTP oder 802.1w), ist abwärtskompatibel zum veralteten STP. RSTP arbeitet schneller und tauscht Informationen mit benachbarten Switchen aus, um Pakete korrekt weiterzuleiten und eine Schleifenbildung zu verhindern. FreeBSD unterstützt die Betriebsmodi RSTP und STP, wobei RSTP als Standardmodus voreingestellt ist.</p></div><div class=paragraph><p>STP kann auf den Schnittstellen der durch die Bridge verbundenen Netzwerksegmente mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> aktiviert werden. Für eine Bridge, die die Schnittstellen <span class=filename>fxp0</span> und <span class=filename>fxp1</span> verbindet, aktivieren Sie STP wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 stp fxp0 stp fxp1</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>Diese Bridge hat die Spanning-Tree-ID <code>00:01:02:4b:d4:50</code> und die Priorität <code>32768</code>. Da diese ID mit der <code>Root-ID</code> identisch ist, handelt es sich um die Root-Bridge dieses Netzwerks.</p></div><div class=paragraph><p>Auf einer anderen Bridge des Netzwerks ist STP ebenfalls aktiviert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>Die Zeile <code>root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4</code> zeigt an, dass die Root-Bridge die ID <code>00:01:02:4b:d4:50</code> hat. Die Pfadkosten hin zur Root-Bridge betragen <code>400000</code>, wobei der Pfad zur Root-Bridge über <code>port 4</code> geht, der wiederum der Schnittstelle <span class=filename>fxp0</span> entspricht.</p></div></div><div class=sect2><h3 id=_parameter_der_bridge_schnittstelle>31.6.3. Parameter der Bridge-Schnittstelle<a class=anchor href=#_parameter_der_bridge_schnittstelle></a></h3><div class=paragraph><p>Einige Parameter von <code>ifconfig</code> dienen ausschließlich der Konfiguration von Bridge-Schnittstellen. Dieser Abschnitt fasst die Verwendung dieser Parameter zusammen. Die vollständige Liste der verfügbaren Parameter wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> beschrieben.</p></div><div class=dlist><dl><dt class=hdlist1>private</dt><dd><p>Eine private Schnittstelle leitet keine Daten an einen Port weiter, bei dem es sich ebenfalls um eine private Schnittstelle handelt. Der Datenverkehr wird dabei komplett blockiert, auch Ethernet-Rahmen und ARP-Pakete werden nicht weitergeleitet. Wollen Sie hingegen nur spezifische Datenpakete blockieren, sollten Sie eine Firewall einsetzen.</p></dd><dt class=hdlist1>span</dt><dd><p>Ein Span Port übertragt eine Kopie jedes Ethernet-Rahmens, der an der Bridge ankommt. Auf einer Bridge können beliebig viele Span Ports festgelegt werden. Wird eine Schnittstelle als Span Port konfiguriert, kann sie nicht mehr als normaler Bridge-Port verwendet werden. Eine derartige Konfiguration ist beispielsweise sinnvoll, um den Datenverkehr, der in einem Netzwerk über die Bridge läuft, auf einen Rechner zu übertragen, der mit einem Span Port der Bridge verbunden ist. Um beispielsweise eine Kopie aller Ethernet-Rahmen über die Schnittstelle <span class=filename>fxp0</span> zu übertragen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 span fxp4</span></code></pre></div></div></dd><dt class=hdlist1>sticky</dt><dd><p>Wenn die Schnittstelle eines über eine Bridge verbundenen Netzwerksegments als sticky gekennzeichnet wird, werden alle dynamisch gelernten Adressen als statische Adressen behandelt, sobald sie in den Forward-Cache der Bridge aufgenommen wurden. Sticky-Einträge werden niemals aus dem Cache entfernt oder ersetzt. Selbst dann nicht, wenn die Adresse von einer anderen Schnittstelle verwendet wird. Sie können dadurch die Vorteile statischer Adresseinträge nutzen, ohne die Forward-Tabelle vor dem Einsatz der Bridge mit statischen Einträgen füllen zu müssen. Clients, die sich in einem bestimmten von der Bridge verwalteten Segmente befinden, können dabei nicht in ein anderes Segment wechseln.</p><div class=paragraph><p>Ein Beispiel für den Einsatz von Sticky-Adressen ist die Kombination einer Bridge mit mehreren VLANs, um einen Router zu konfigurieren, der einzelne Kundennetzwerke voneinander trennt, ohne dabei IP-Adressbereiche zu verschwenden. Für das folgende Beispiel nehmen wir an, dass sich der Client <code>CustomerA</code> im VLAN <code>vlan100</code> und der Client <code>CustomerB</code> im VLAN <code>vlan101</code> befinden. Die Bridge hat die IP-Adresse <code>192.168.0.1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</span>
<span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>In diesem Beispiel sehen beide Clients <code>192.168.0.1</code> als das Default-Gateway. Da der Brücken-Cache <em>sticky</em> ist, sind Sie nicht dazu in der Lage, die MAC-Adresse des anderen Kunden zu spoofen und dessen Datenverkehr abzufangen.</p></div><div class=paragraph><p>Sie können die Kommunikation zwischen den VLANs vollständig unterbinden, wenn Sie private Schnittstellen oder eine Firewall einsetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 private vlan100 private vlan101</span></code></pre></div></div><div class=paragraph><p>Die Kunden sind nun komplett voneinander isoliert und der komplette <code>/24</code>-Adressbereich kann zugewiesen werden, ohne dass Subnetze eingesetzt werden.</p></div><div class=paragraph><p>Die maximale mögliche Anzahl an eindeutigen MAC-Adressen hinter einer Schnittstelle kann festgelegt werden. Sobald das Limit erreicht ist, werden Pakete mit einer unbekannten Quell-Adresse solange verworfen, bis ein existierender Eintrag gelöscht wird oder abläuft.</p></div><div class=paragraph><p>Das folgende Beispiel setzt die maximale Anzahl von Netzgeräten für <code>CustomerA</code> für das VLAN <code>vlan100</code> auf 10.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 ifmaxaddr vlan100 10</span></code></pre></div></div></dd></dl></div><div class=paragraph><p>Die Bridge unterstützt auch den Monitormodus. Dabei werden alle Pakete verworfen, nachdem sie von <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> verarbeitet wurden. In diesem Modus erfolgt keine weitere Bearbeitung und auch keine Weiterleitung von Datenpaketen. Es ist daher möglich, die Eingabe von zwei oder mehr Netzwerkschnittstellen in einen einzigen gemeinsamen <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>-Stream zu vereinen. Ein solcher Datenstrom ist beispielsweise nützlich, um den Datenverkehr für "network taps" zu rekonstruieren, die ihre RX/TX-Signale über verschiedene Schnittstellen senden. Um beispielsweise die Eingabe von vier Netzwerkschnittstellen in einzigen gemeinsamen Datenstrom zu vereinen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</span>
<span class=c># tcpdump -i bridge0</span></code></pre></div></div></div><div class=sect2><h3 id=_snmp_monitoring>31.6.4. SNMP-Monitoring<a class=anchor href=#_snmp_monitoring></a></h3><div class=paragraph><p>Die Schnittstelle der Bridge sowie die STP-Parameter können durch den im Basissystem enthaltenen <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> überwacht werden. Die exportierten Bridge-MIBs entsprechen den IETF-Standards, daher kann ein beliebiger SNMP-Client oder ein beliebiges Monitoring-Werkzeug eingesetzt werden, um die benötigten Daten zu erhalten.</p></div><div class=paragraph><p>Um das Monitoring auf der Bridge zu aktivieren, kommentieren Sie diese Zeile in <span class=filename>/etc/snmpd.config</span> aus, indem Sie das Zeichen <code>#</code> entfernen:</p></div><div class="literalblock programlisting"><div class=content><pre>begemotSnmpdModulePath.&#34;bridge&#34; = &#34;/usr/lib/snmp_bridge.so&#34;</pre></div></div><div class=paragraph><p>Weitere Konfigurationsparameter wie Community-Namen und Zugriffslisten müssen ebenfalls in dieser Datei angepasst werden. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=snmp_bridge&amp;sektion=3&amp;format=html">snmp_bridge(3)</a>. Nachdem die Änderungen gespeichert wurden, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>bsnmpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Danach starten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bsnmpd start</span></code></pre></div></div><div class=paragraph><p>Die folgenden Beispiele verwenden das Softwarepaket Net-SNMP (<a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/net-snmp/>net-mgmt/net-snmp</a>), um die Bridge vom Client aus abzufragen. Alternativ kann auch der Port <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/bsnmptools/>net-mgmt/bsnmptools</a> benutzt werden. Auf dem SNMP-Client müssen danach die folgenden Zeilen in <span class=filename>$HOME/.snmp/snmp.conf</span> hinzugefügt werden, um die MIB-Definitionen der Bridge in Net-SNMP zu importieren:</p></div><div class="literalblock programlisting"><div class=content><pre>mibdirs +/usr/shared/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</pre></div></div><div class=paragraph><p>Um eine einzelne Bridge über den IETF BRIDGE-MIB (RFC4188) zu überwachen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 <span class=o>=</span> STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 <span class=o>=</span> INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 <span class=o>=</span> Timeticks: <span class=o>(</span>189959<span class=o>)</span> 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 <span class=o>=</span> Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 <span class=o>=</span> INTEGER: forwarding<span class=o>(</span>5<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortEnable.3 <span class=o>=</span> INTEGER: enabled<span class=o>(</span>1<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortPathCost.3 <span class=o>=</span> INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 <span class=o>=</span> INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 <span class=o>=</span> Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 <span class=o>=</span> Counter32: 1
RSTP-MIB::dot1dStpVersion.0 <span class=o>=</span> INTEGER: rstp<span class=o>(</span>2<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Der Wert der Variable <code>dot1dStpTopChanges.0</code> ist hier 2, die STP-Topologie der Bridge wurde also bereits zweimal geändert. Unter einer Änderung versteht man die Anpassung eines oder mehrerer Links und die Kalkulation eines neuen Baums. Der Wert der Variable <code>dot1dStpTimeSinceTopologyChange.0</code> gibt an, wann dies zuletzt geschah.</p></div><div class=paragraph><p>Um mehrere Bridge-Schnittstellen zu überwachen, kann der private BEGEMOT-BRIDGE-MIB eingesetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>116927<span class=o>)</span> 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>82773<span class=o>)</span> 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 50 8B B8 C6 A9</code></pre></div></div><div class=paragraph><p>Um die über den <code>mib-2.dot1dBridge</code>-Subtree überwachte Bridge-Schnittstelle zu ändern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpset <span class=nt>-v</span> 2c <span class=nt>-c</span> private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</code></pre></div></div></div></div></div><div class=sect1><h2 id=network-aggregation>31.7. Link-Aggregation und Failover<a class=anchor href=#network-aggregation></a></h2><div class=sectionbody><div class=paragraph><p>Die von FreeBSD unterstützte <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>-Schnittstelle erlaubt die Gruppierung von mehreren Netzwerkadaptern als eine virtuelle Schnittstelle, mit dem Ziel, Ausfallsicherheit (Failover) und Link Aggregation bereitzustellen. Bei Failover kann der Verkehr auch dann weiter fließen, wenn nur eine Schnittstelle verfügbar ist. Link Aggregation funktioniert am besten mit Switches, die LCAP unterstützen, da dieses Protokoll den Datenverkehr bidirektional verteilt, während es auch auf den Ausfall einzelner Verbindungen reagiert.</p></div><div class=paragraph><p>Die von der lagg-Schnittstelle unterstützten Protokolle bestimmen, welche Ports für den ausgehenden Datenverkehr benutzt werden, und ob ein bestimmter Port eingehenden Datenverkehr akzeptiert. Die folgenden Protokolle werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> unterstützt:</p></div><div class=dlist><dl><dt class=hdlist1>Failover (Ausfallsicherheit)</dt><dd><p>Dieser Modus sendet und empfängt Datenverkehr nur auf dem Masterport. Sollte der Masterport nicht zur Verfügung stehen, wird der nächste aktive Port verwendet. Der zuerst hinzugefügte Adapter der virtuellen Schnittstelle wird zum Masterport, jeder weitere Adapter dient als Gerät zur Ausfallsicherheit. Wenn ein Failover auf einem Nicht-Master Port stattfindet, wird der ursprüngliche Port wieder zum Master-Port, sobald er wieder verfügbar ist.</p></dd><dt class=hdlist1>fec / loadbalance (Lastverteilung)</dt><dd><p>Cisco® Fast EtherChannel® (FEC) findet sich auf älteren Cisco® Switches. Es bietet eine statische Konfiguration und handelt weder Aggregation mit der Gegenstelle aus, noch werden Frames zur Überwachung der Verbindung ausgetauscht. Wenn der Switch LACP unterstützt, sollte diese Option auch verwendet werden.</p></dd><dt class=hdlist1>lacp</dt><dd><p>Das IEEE® 802.3ad Link-Aggregation Control Protokoll (LACP). Mit LACP wird eine Menge von aggregierbaren Verbindungen mit der Gegenstelle in einer oder mehreren Link Aggregated Groups (LAG) ausgehandelt. Jede LAG besteht aus Ports der gleichen Geschwindigkeit, eingestellt auf Voll-Duplex-Betrieb. Der Verkehr wird über die Ports in der LAG mit der größten Gesamtgeschwindigkeit balanciert. Typischerweise gibt es nur eine LAG, die alle Ports enthält. Im Falle von Änderungen in der physischen Anbindung wird LACP schnell zu einer neuen Konfiguration konvergieren.</p><div class=paragraph><p>LACP balanciert ausgehenden Verkehr über die aktiven Ports basierend auf der gehashten Protokollheaderinformation und akzeptiert eingehenden Verkehr auf jedem aktiven Port. Der Hash beinhaltet die Ethernet-Quell- und Zieladresse, und, soweit verfügbar, den VLAN-Tag, sowie die IPv4 oder IPv6 Quell- und Zieladresse.</p></div></dd><dt class=hdlist1>roundrobin</dt><dd><p>Dieser Modus verteilt ausgehenden Verkehr mittels einer Round-Robin-Zuteilung über alle aktiven Ports und akzeptiert eingehenden Verkehr auf jedem aktiven Port. Da dieser Modus die Reihenfolge von Ethernet-Rahmen verletzt, sollte er mit Vorsicht eingesetzt werden.</p></dd></dl></div><div class=sect2><h3 id=_beispiele>31.7.1. Beispiele<a class=anchor href=#_beispiele></a></h3><div class=paragraph><p>Dieser Abschnitt zeigt, wie man einen Cisco® Switch und ein FreeBSD-System für LACP Load Balancing konfiguriert. Weiterhin wird gezeigt, wie man zwei Ethernet-Schnittstellen, sowie eine Ethernet- und eine Drahtlos-Schnittstelle für den Failover-Modus konfigurieren kann.</p></div><div id=networking-lacp-aggregation-cisco class=exampleblock><div class=title>Beispiel 1. LACP Aggregation mit einem Cisco® Switch</div><div class=content><div class=paragraph><p>Dieses Beispiel verbindet zwei <a href="https://man.freebsd.org/cgi/man.cgi?query=fxp&amp;sektion=4&amp;format=html">fxp(4)</a> Ethernet-Schnittstellen einer FreeBSD-Maschine zu den ersten zwei Ethernet-Ports auf einem Cisco® Switch als eine einzelne, lastverteilte und ausfallsichere Verbindung. Weitere Adapter können hinzugefügt werden, um den Durchsatz zu erhöhen und die Ausfallsicherheit zu steigern. Ersetzen Sie die Namen der Cisco®-Ports, Ethernet-Geräte, channel-group Nummern und IP-Adressen im Beispiel durch Namen, die mit Ihrer lokalen Konfiguration übereinstimmen.</p></div><div class=paragraph><p>Da die Reihenfolge der Frames bei Ethernet zwingend eingehalten werden muss, fließt auch jeglicher Verkehr zwischen zwei Stationen über den gleichen physischen Kanal, was die maximale Geschwindigkeit der Verbindung auf die eines einzelnen Adapters beschränkt. Der Übertragungsalgorithmus versucht, so viele Informationen wie möglich zu verwenden, um die verschiedenen Verkehrsflüsse zu unterscheiden und balanciert diese über die verfügbaren Adapter.</p></div><div class=paragraph><p>Fügen Sie auf dem Cisco®-Switch die Adapter <em>FastEthernet0/1</em> und <em>FastEthernet0/2</em> zu der channel-group <em>1</em> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
<span class=o>!</span>
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</code></pre></div></div><div class=paragraph><p>Erstellen Sie auf der FreeBSD Maschine die <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>-Schnittstelle unter Verwendung von <em>fxp0</em> und <em>fxp1</em> und starten Sie die Schnittstelle mit der IP-Adresse <em>10.0.0.3/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</span></code></pre></div></div><div class=paragraph><p>Überprüfen Sie den Status der virtuellen Schnittstelle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</code></pre></div></div><div class=paragraph><p>Ports, die als <em>ACTIVE</em> markiert sind, sind Teil der aktiven Aggregations-Gruppe, die mit dem Switch ausgehandelt wurde. Der Verkehr wird über diese Gruppe übertragen und empfangen. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> mit <code>-v</code>, um sich die LAG-Bezeichner anzeigen zu lassen.</p></div><div class=paragraph><p>Um den Status der Ports auf dem Switch anzuzeigen, benutzen Sie <code>show lacp neighbor</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is <span class=k>in </span>Active mode       P - Device is <span class=k>in </span>Passive mode

Channel group 1 neighbors

Partner<span class=s1>&#39;s information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie <code>show lacp neighbor detail</code>, um weitere Informationen zu erhalten.</p></div><div class=paragraph><p>Damit diese Konfiguration auch nach einem Neustart erhalten bleibt, fügen Sie auf dem FreeBSD-System folgende Einträge in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0
ifconfig_lagg0=&#34;laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24&#34;</pre></div></div></div></div><div id=networking-lagg-failover class=exampleblock><div class=title>Beispiel 2. Ausfallsicherer Modus</div><div class=content><div class=paragraph><p>Der ausfallsichere Modus kann verwendet werden, um zu einer zweiten Schnittstelle zu wechseln, sollte die Verbindung mit der Master-Schnittstelle ausfallen. Um den ausfallsicheren Modus zu konfigurieren, aktivieren Sie zunächst die zugrunde liegenden physikalischen Schnittstellen. Erstellen Sie dann die <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>-Schnittstelle mit <em>fxp0</em> als Master-Schnittstelle und <em>fxp1</em> als sekundäre Schnittstelle. Der virtuellen Schnittstelle wird die IP-Adresse <em>10.0.0.15/24</em> zugewiesen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</span></code></pre></div></div><div class=paragraph><p>Die virtuelle Schnittstelle sollte in etwa so aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;</code></pre></div></div><div class=paragraph><p>Der Verkehr wird auf <em>fxp0</em> übertragen und empfangen. Wenn die Verbindung auf <em>fxp0</em> abbricht, wird <em>fxp1</em> die Verbindung übernehmen. Sobald die Verbindung auf der Master-Schnittstelle wiederhergestellt ist, wird diese wieder als aktive Schnittstelle genutzt.</p></div><div class=paragraph><p>Damit diese Konfiguration auch nach einem Neustart erhalten bleibt, fügen Sie folgende Einträge in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0
ifconfig_lagg0=&#34;laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24&#34;</pre></div></div></div></div><div id=networking-lagg-wired-and-wireless class=exampleblock><div class=title>Beispiel 3. Failover Modus zwischen Ethernet- und drahtlosen Schnittstellen</div><div class=content><div class=paragraph><p>Für Laptop-Benutzer ist es normalerweise wünschenswert, "wireless" als sekundäre Schnittstelle einzurichten, die verwendet wird, wenn die Ethernet-Verbindung nicht verfügbar ist. Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> ist es möglich, ein Failover mit einer IP-Adresse zu konfigurieren, welches die Ethernet-Verbindung aus Performance- und Sicherheitsgründen bevorzugt, während es gleichzeitig möglich bleibt, Daten über die drahtlose Verbindung zu übertragen.</p></div><div class=paragraph><p>Dies wird erreicht, indem die MAC-Adresse der Ethernet-Schnittstelle mit der MAC Adresse der drahtlosen Schnittstelle überschrieben wird.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>Theoretisch kann die Ethernet- oder die drahtlose MAC-Adresse so geändert werden, dass sie mit der jeweils anderen Adresse übereinstimmt. Bei einigen drahtlosen Schnittstellen fehlt jedoch die Unterstützung für das Überschreiben der MAC-Adresse. Daher wird empfohlen, die MAC-Adresse der Ethernet-Schnittstelle für diesen Zweck zu überschreiben.</p></div></div></div><div class=sidebarblock><div class=content><div class=paragraph><p>Wenn der Treiber für die drahtlose Schnittstelle nicht im <code>GENERIC</code>-Kernel oder in einem angepassten Kernel enthalten ist, kann unter FreeBSD 12.1 mit <code>_driver__load="YES"</code> die entsprechende <span class=filename>.ko</span>-Datei in <span class=filename>/boot/loader.conf</span> geladen werden. Dann muss das System neu gestartet werden. Ein anderer, besserer Weg ist es, den Treiber über <span class=filename>/etc/rc.conf</span> zu laden, indem Sie ihn zu <code>kld_list</code> (siehe <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>) hinzufügen und dann das System neu starten. Dies ist notwendig, da sonst der Treiber zum Zeitpunkt der Konfiguration der <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>-Schnittstelle noch nicht geladen ist.</p></div></div></div><div class=paragraph><p>In diesem Beispiel ist die Ethernet-Schnittstelle <em>re0</em> der Master und die drahtlose Schnittstelle <em>wlan0</em> der Failover. Die Schnittstelle <em>wlan0</em> wurde aus der physischen Schnittstelle <em>ath0</em> erstellt, und die Ethernet-Schnittstelle wird mit der MAC-Adresse der drahtlosen Schnittstelle konfiguriert. Im ersten Schritt wird die MAC-Adresse der drahtlosen Schnittstelle ermittelt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether b8:ee:65:5b:32:59
	<span class=nb>groups</span>: wlan
	ssid Bbox-A3BD2403 channel 6 <span class=o>(</span>2437 MHz 11g ht/20<span class=o>)</span> bssid 00:37:b7:56:4b:60
	regdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON
	deftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60
	protmode CTS ampdulimit 64k ampdudensity 8 shortgi <span class=nt>-stbctx</span> stbcrx
	<span class=nt>-ldpc</span> wme burst roaming MANUAL
	media: IEEE 802.11 Wireless Ethernet MCS mode 11ng
	status: associated
	nd6 <span class=nv>options</span><span class=o>=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;</code></pre></div></div><div class=paragraph><p>Ersetzen Sie <em>ath0</em> durch den Namen der drahtlosen Schnittstelle. Die <code>ether</code>-Zeile wird die MAC-Adresse der angegebenen Schnittstelle enthalten. Ändern Sie nun die MAC-Adresse der zugrunde liegenden Ethernet-Schnittstelle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 ether b8:ee:65:5b:32:59</span></code></pre></div></div><div class=paragraph><p>Starten Sie die drahtlose Schnittstelle, aber ohne eine IP-Adresse zu setzen. Ersetzen Sie <em>FR</em> durch den entsprechenden Ländercode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev iwn0 country FR ssid my_router up</span></code></pre></div></div><div class=paragraph><p>Stellen Sie sicher, dass die <em>re0</em>-Schnittstelle aktiv ist. Erstellen Sie die <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>-Schnittstelle mit <em>re0</em> als Master und <em>wlan0</em> als Failover:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0</span></code></pre></div></div><div class=paragraph><p>Die virtuelle Schnittstelle sollte in etwa so aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether b8:ee:65:5b:32:59
        laggproto failover lagghash l2,l3,l4
        laggport: re0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;
        laggport: wlan0 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        <span class=nb>groups</span>: lagg
        media: Ethernet autoselect
        status: active</code></pre></div></div><div class=paragraph><p>Starten Sie dann den DHCP-Client, um eine IP-Adresse zu erhalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient lagg0</span></code></pre></div></div><div class=paragraph><p>Damit diese Konfiguration auch nach einem Neustart erhalten bleibt, fügen Sie folgende Einträge in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_re0=&#34;ether b8:ee:65:5b:32:59&#34;
wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA&#34;
create_args_wlan0=&#34;country FR&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;up laggproto failover laggport re0 laggport wlan0 DHCP&#34;</pre></div></div></div></div></div></div></div><div class=sect1><h2 id=network-diskless>31.8. Plattenloser Betrieb mit PXE<a class=anchor href=#network-diskless></a></h2><div class=sectionbody><div class=paragraph><p>Das Intel® Preboot eXecution Environment (PXE) erlaubt es dem Betriebssystem über das Netzwerk zu starten. Zum Beispiel kann ein FreeBSD-System, ohne lokale Festplatte, über das Netzwerk gestartet und betrieben werden. Die Dateisysteme werden dabei über einen NFS-Server eingehangen. PXE-Unterstützung steht in der Regel im BIOS zur Verfügung. Um PXE beim Systemstart zu verwenden, müssen Sie im BIOS des Rechners die Option <code>Über das Netzwerk starten</code> aktivieren. Alternativ können Sie während der PC-Initialisierung auch eine Funktionstaste drücken.</p></div><div class=paragraph><p>Um die notwendigen Dateien für ein Betriebssystem für den Start über das Netzwerk bereitzustellen, benötigt ein PXE-Setup einen richtig konfigurierten DHCP-, TFTP- und NFS-Server, wobei:</p></div><div class=ulist><ul><li><p>Die initialen Parameter, wie IP-Adresse, Dateiname und Speicherort der ausführbaren Bootdateien, Servername sowie Root-Pfad vom DHCP-Server bezogen werden.</p></li><li><p>Der Loader für das Betriebssystem über TFTP gestartet wird.</p></li><li><p>Die Dateisysteme über NFS geladen werden.</p></li></ul></div><div class=paragraph><p>Sobald das Gastsystem über PXE startet, erhält es vom DHCP-Server Informationen, wo der initiale Bootloader per TFTP zu bekommen ist. Nachdem das Gastsystem diese Informationen erhalten hat, lädt es den Bootloader über TFTP herunter und führt diesen anschließend aus. In FreeBSD ist <span class=filename>/boot/pxeboot</span> der Bootloader. Nachdem <span class=filename>/boot/pxeboot</span> ausgeführt und der FreeBSD-Kernel geladen wurde, wird mit dem Rest der FreeBSD-Bootsequenz, wie in <a href=../boot/#boot>FreeBSDs Bootvorgang</a> beschrieben, fortgefahren.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie diese Dienste auf einem FreeBSD-System so konfigurieren, sodass andere Systeme FreeBSD über PXE starten können. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Wie beschrieben, ist das System, welches diese Dienste bereitstellt, unsicher. Daher sollte es in einem geschützten Bereich des Netzwerks aufgestellt und von anderen Hosts als nicht vertrauenswürdig eingestuft werden.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=network-pxe-nfs>31.8.1. Konfiguration der PXE-Umgebung<a class=anchor href=#network-pxe-nfs></a></h3><div class=paragraph><p>Die in diesem Abschnitt dargestellten Schritte konfigurieren die in FreeBSD enthaltenen NFS- und TFTP-Server. Der folgende Abschnitt beschreibt die Installation und Konfiguration des DHCP-Servers. In diesem Beispiel verwenden wir <span class=filename>/b/tftpboot/FreeBSD/install</span>, welches die Dateien für PXE-Benutzer enthält. Es ist wichtig, dass dieses Verzeichnis existiert und das der gleiche Verzeichnisname ebenfalls in <span class=filename>/etc/inetd.conf</span> und <span class=filename>/usr/local/etc/dhcpd.conf</span> gesetzt wird.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Erstellen Sie das Root-Verzeichnis, welches eine FreeBSD-Installation enthält und über NFS eingehangen werden kann:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># export NFSROOTDIR=/b/tftpboot/FreeBSD/install</span>
<span class=c># mkdir -p ${NFSROOTDIR}</span></code></pre></div></div></li><li><p>Aktivieren Sie den NFS-Server, indem Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzufügen:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Exportieren Sie das Root-Verzeichnis über NFS, indem Sie folgende Zeile in <span class=filename>/etc/exports</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>/b -ro -alldirs -maproot=root</pre></div></div></li><li><p>Starten Sie den NFS-Server:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div></li><li><p>Aktivieren Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>, indem Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzufügen:</p><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div></li><li><p>Kommentieren Sie die folgende Zeile in <span class=filename>/etc/inetd.conf</span> aus, indem Sie sicherstellen, dass die Zeile nicht mit einem <code>#</code>-Zeichen beginnt:</p><div class="literalblock programlisting"><div class=content><pre>tftp dgram udp wait root /usr/libexec/tftp tftp -l -s /b/tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Einige PXE-Versionen benötigen die TCP-Version von TFTP. In diesem Fall können Sie die zweite <code>tftp</code>-Zeile, welche <code>stream tcp</code> enthält, auskommentieren.</p></div></td></tr></tbody></table></div></li><li><p>Starten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div></li><li><p>Installieren Sie das Basissystem nach <span class=filename>${NFSROOTDIR}</span>, indem Sie die offiziellen Archive entpacken, oder ein neues Basissystem und einen FreeBSD-Kernel erstellen. Detaillierte Anweisungen hierzu finden Sie im <a href=../cutting-edge/#makeworld>“FreeBSD aus den Quellen aktualisieren”</a>. Vergessen Sie jedoch nicht <code>DESTDIR=<em>${NFSROOTDIR}</em></code> hinzuzufügen, wenn Sie die Kommandos <code>make installkernel</code> und <code>make installworld</code> ausführen.</p></li><li><p>Testen Sie den TFTP-Server und vergewissern Sie sich, dass Sie den Bootloader herunterladen können, der über PXE bereitgestellt wird:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp localhost</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div></li><li><p>Bearbeiten Sie <span class=filename>${NFSROOTDIR}/etc/fstab</span> und erstellen Sie einen Eintrag, um das Root-Dateisystem über NFS einzuhängen:</p><div class="literalblock programlisting"><div class=content><pre># Device                                         Mountpoint    FSType   Options  Dump Pass$
	    myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</pre></div></div><div class=paragraph><p>Ersetzen Sie <em>myhost.example.com</em> durch den Hostnamen oder die IP-Adresse des NFS-Servers. In diesem Beispiel wird das Root-Dateisystem schreibgeschützt eingehangen, um ein potenzielles Löschen des Inhalts durch die NFS-Clients zu verhindern.</p></div></li><li><p>Setzen Sie das root-Passwort in der PXE-Umgebung für Client-Maschinen, die über PXE starten:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># passwd</span></code></pre></div></div></li><li><p>Falls erforderlich, aktivieren Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> root-Logins für Client-Maschinen, die über PXE starten, indem Sie die Option <code>PermitRootLogin</code> in <span class=filename>${NFSROOTDIR}/etc/ssh/sshd_config</span> aktivieren. Dies ist in <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a> dokumentiert.</p></li><li><p>Führen Sie alle weiteren Anpassungen der PXE-Umgebung in <span class=filename>${NFSROOTDIR}</span> durch, wie zum Beispiel die Installation weiterer Pakete, oder dass Bearbeiten der Passwortdatei mit <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>.</p></li></ol></div><div class=paragraph><p>Booten Sie von einem NFS-Root-Volume, so erkennt <span class=filename>/etc/rc</span> dies und startet daraufhin das <span class=filename>/etc/rc.initdiskless</span> Skript. Lesen Sie die Kommentare in diesem Skript um zu verstehen, was dort vor sich geht. Weil das NFS-Root-Verzeichnis schreibgeschützt ist, wir aber Schreibzugriff für <span class=filename>/etc</span> und <span class=filename>/var</span> benötigen, müssen wir diese Verzeichnisse über Speicher-Dateisysteme (memory backed file system) einbinden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># mkdir -p conf/base</span>
<span class=c># tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</span>
<span class=c># tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</span></code></pre></div></div><div class=paragraph><p>Wenn das System bootet, werden Speicher-Dateisysteme für <span class=filename>/etc</span> und <span class=filename>/var</span> erstellt und eingehangen. Anschließend wird der Inhalt der <span class=filename>cpio.gz</span>-Dateien in diese Dateisysteme kopiert. Standardmäßig haben diese Dateisysteme eine maximale Kapazität von 5 Megabyte. Wenn die Archive nicht passen, was für gewöhnlich bei <span class=filename>/var</span> der Fall ist, erhöhen Sie die Kapazität indem Sie die Anzahl der benötigten 512 Byte Sektoren (5 Megabyte sind 10240 Sektoren) in <span class=filename>${NFSROOTDIR}/conf/base/etc/md_size</span> und <span class=filename>${NFSROOTDIR}/conf/base/var/md_size</span> für die Dateisysteme <span class=filename>/etc</span> und <span class=filename>/var</span> eintragen.</p></div></div><div class=sect2><h3 id=network-pxe-setting-up-dhcp>31.8.2. Konfiguration des DHCP-Servers<a class=anchor href=#network-pxe-setting-up-dhcp></a></h3><div class=paragraph><p>Der DHCP-Server muss nicht auf derselben Maschine laufen wie der TFTP- und NFS-Server, aber er muss über das Netzwerk erreichbar sein.</p></div><div class=paragraph><p>DHCP ist nicht Bestandteil des FreeBSD Basissystems, kann jedoch über den Port <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a> oder als Paket nachinstalliert werden.</p></div><div class=paragraph><p>Einmal installiert, bearbeiten Sie die Konfigurationsdatei <span class=filename>/usr/local/etc/dhcpd.conf</span>. Konfigurieren Sie die <code>next-server</code>, <code>filename</code> und <code>root-path</code> Einstellungen, wie in diesem Beispiel zu sehen ist:</p></div><div class="literalblock programlisting"><div class=content><pre>subnet 192.168.0.0 netmask 255.255.255.0 {
range 192.168.0.2 192.168.0.3;
option subnet-mask 255.255.255.0;
option routers 192.168.0.1;
option broadcast-address 192.168.0.255;
option domain-name-servers 192.168.35.35, 192.168.35.36;
option domain-name &#34;example.com&#34;;

# IP address of TFTP server
next-server 192.168.0.1;

# path of boot loader obtained via tftp
filename &#34;FreeBSD/install/boot/pxeboot&#34;;

# pxeboot boot loader will try to NFS mount this directory for root FS
option root-path &#34;192.168.0.1:/b/tftpboot/FreeBSD/install/&#34;;
}</pre></div></div><div class=paragraph><p>Die Anweisung <code>next-server</code> wird benutzt, um die IP-Adresse des TFTP-Servers anzugeben.</p></div><div class=paragraph><p>Die Anweisung <code>filename</code> definiert den Pfad zu <span class=filename>/boot/pxeboot</span>. Da hier der relative Dateiname verwendet wird, bedeutet das, dass <span class=filename>/b/tftpboot</span> nicht im Pfad enthalten ist.</p></div><div class=paragraph><p>Die Option <code>root-path</code> bestimmt den Pfad zum NFS root-Dateisystem.</p></div><div class=paragraph><p>Sobald die Änderungen gespeichert werden, aktivieren Sie DHCP beim Systemstart, indem Sie die folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten Sie anschließend den DHCP-Dienst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div></div><div class=sect2><h3 id=_fehlersuche_bei_pxe_problemen>31.8.3. Fehlersuche bei PXE Problemen<a class=anchor href=#_fehlersuche_bei_pxe_problemen></a></h3><div class=paragraph><p>Sobald alle Dienste konfiguriert und gestartet wurden, sollten PXE-Clients in der Lage sein, FreeBSD automatisch über das Netzwerk zu starten. Wenn ein bestimmter Client beim hochfahren keine Verbindung herstellen kann, sehen Sie im BIOS nach, ob die Option für den Start über das Netzwerk konfiguriert ist.</p></div><div class=paragraph><p>Dieser Abschnitt gibt einige Tipps zu Fehlerbehebung und zeigt, wie Sie Konfigurationsprobleme eingrezen können für den Fall, dass PXE-Clients nicht in der Lage sind über das Netzwerk zu starten.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Benutzen Sie den <a class=package href=https://cgit.freebsd.org/ports/tree/net/wireshark/>net/wireshark</a> Port um Fehler im Netzwerkverkehr während des Bootvorgangs von PXE zu finden. Der Bootvorgang wird im folgenden Diagramm schematisch dargestellt.</p><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/pxe-nfs.png alt="pxe nfs"></div><div class=title>Abbildung 1. PXE-Bootvorgang mit NFS Root Mount</div></div></li><li><p>Schauen Sie in <span class=filename>/var/log/xferlog</span> auf dem TFTP-Server und vergewissern Sie sich, dass die <span class=filename>pxeboot</span>-Datei von der richtigen Adresse heruntergeladen wurde. Um die obige Konfiguration von <span class=filename>/usr/local/etc/dhcpd.conf</span> zu testen, geben Sie folgendes ein:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp 192.168.0.1</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=tftpd&amp;sektion=8&amp;format=html">tftpd(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=tftp&amp;sektion=1&amp;format=html">tftp(1)</a>. Die <code>BUGS</code>-Sektionen dieser Seiten dokumentieren einige Einschränkungen von TFTP.</p></div></li><li><p>Achten Sie darauf, dass Sie das Root-Dateisystem über NFS einhängen können. Auch hier können Sie Ihre Einstellungen aus <span class=filename>/usr/local/etc/dhcpd.conf</span> wie folgt testen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect1><h2 id=network-ipv6>31.9. IPv6<a class=anchor href=#network-ipv6></a></h2><div class=sectionbody><div class=paragraph><p>IPv6 ist die neueste Version des bekannten IP-Protokolls, das auch als IPv4 bezeichnet wird. IPv6 bietet gegenüber IPv4 mehrere Vorteile sowie viele neue Funktionen:</p></div><div class=ulist><ul><li><p>IPv6 hat einen 128 Bit großen Adressraum, der 340.282.366.920.938.463.463.374.607.431.768.211.456 Adressen erlaubt. Dies behebt das Problem der immer knapper werdenden IPv4-Adressen und einer eventuellen Erschöpfung des IPv4-Adressraums.</p></li><li><p>Router speichern nur noch Netzwerk-Aggregationsadressen in ihren Routingtabellen. Dadurch reduziert sich die durchschnittliche Größe einer Routingtabelle auf 8192 Einträge. Dies ist mit den Problemen bei der Skalierbarkeit von IPv4 verbunden, da jeder zugeordnete Block von IPv4-Adressen erfordert, dass Routing-Informationen zwischen vielen Routern im Internet ausgetauscht werden müssen. Die Routing-Tabellen wurden mit der Zeit so groß, dass ein effizientes Routing jetzt kaum noch möglich ist.</p></li><li><p>Die automatische Konfiguration von Adressen, die im <a href=http://www.ietf.org/rfc/rfc2462.txt>RFC2462</a> beschrieben wird.</p></li><li><p>Verpflichtende Multicast-Adressen.</p></li><li><p>Integriertes IPsec (IP-Security).</p></li><li><p>Eine vereinfachte Headerstruktur.</p></li><li><p>Unterstützung für mobile IP-Adressen.</p></li><li><p>Die Umwandlung von IPv4- in IPv6-Adressen.</p></li></ul></div><div class=paragraph><p>FreeBSD enthält die IPv6-Referenzimplementation von <a href=http//www.kame.net/>KAME</a> und erfüllt damit bereits alle für die Nutzung von IPv6 nötigen Voraussetzungen. Dieser Abschnitt konzentriert sich auf die Konfiguration und den Betrieb von IPv6.</p></div><div class=sect2><h3 id=_hintergrundinformationen_zu_ipv6_adressen>31.9.1. Hintergrundinformationen zu IPv6-Adressen<a class=anchor href=#_hintergrundinformationen_zu_ipv6_adressen></a></h3><div class=paragraph><p>Es gibt verschiedene Arten von IPv6-Adressen:</p></div><div class=dlist><dl><dt class=hdlist1>Unicast</dt><dd><p>Ein Paket, das an eine Unicast-Adresse gesendet wird, kommt nur an der Schnittstelle an, die dieser Adresse zugeordnet ist.</p></dd><dt class=hdlist1>Anycast</dt><dd><p>Anycast-Adressen unterscheiden sich in ihrer Syntax nicht von Unicast-Adressen, sie wählen allerdings aus mehreren Schnittstellen eine Schnittstelle aus. Ein für eine Anycast-Adresse bestimmtes Paket kommt an der nächstgelegenen (entsprechend der Router-Metrik) Schnittstelle an. Anycast-Adressen werden nur von Routern verwendet.</p></dd><dt class=hdlist1>Mulitcast</dt><dd><p>Multicast-Adressen bestimmen Gruppen, denen mehrere Schnittstellen angehören. Ein Paket, das an eine Multicast-Adresse geschickt wird, kommt an allen Schnittstellen an, die zur Multicast-Gruppe gehören. Die von IPv4 bekannte Broadcast-Adresse (normalerweise <code>xxx.xxx.xxx.255</code>) wird bei IPv6 durch Multicast-Adressen verwirklicht.</p></dd></dl></div><div class=paragraph><p>Die kanonische Form einer IPv6-Adresse lautet <code>x:x:x:x:x:x:x:x</code>, wobei jedes "x" für einen 16-Bit-Hexadezimalwert steht. Ein Beispiel für eine IPv6-Adresse wäre etwa <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code>.</p></div><div class=paragraph><p>Eine IPv6-Adresse enthält oft Teilzeichenfolgen aus lauter Nullen. Eine solche Zeichenfolge kann zu "::" verkürzt werden. Bis zu drei führende Nullen eines Hexquads können ebenfalls weggelassen werden. <code>fe80::1</code> entspricht also der Adresse <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>.</p></div><div class=paragraph><p>Eine weitere Möglichkeit ist die Darstellung der letzten 32 Bit in der bekannten IPv4-Notation. <code>2002::10.0.0.1</code> ist also eine andere Schreibweise für die (hexadezimale) kanonische Form <code>2002:0000:0000:0000:0000:0000:0a00:0001</code>, die wiederum der Adresse <code>2002::a00:1</code> entspricht.</p></div><div class=paragraph><p>Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, um die IPv6-Adresse eines FreeBSD-Systems anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span>
rl0: <span class=nv>flags</span><span class=o>=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect <span class=o>(</span>100baseTX <span class=o>)</span>
         status: active</code></pre></div></div><div class=paragraph><p>Bei <code>fe80::200:21ff:fe03:8e1%rl0</code> handelt es sich um eine automatisch konfigurierte link-local-Adresse. Sie wird im Rahmen der automatischen Konfiguration aus der MAC-Adresse erzeugt.</p></div><div class=paragraph><p>Einige IPv6-Adressen sind reserviert. Eine Zusammenfassung dieser Adressen finden Sie in <a href=#reservedip6>Reservierte IPv6-Adressen</a>:</p></div><table id=reservedip6 class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 3. Reservierte IPv6-Adressen</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">IPv6-Adresse</th><th class="tableblock halign-left valign-top">Präfixlänge</th><th class="tableblock halign-left valign-top">Beschreibung</th><th class="tableblock halign-left valign-top">Anmerkungen</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>nicht festgelegt</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>entspricht <code>0.0.0.0</code> bei IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Loopback-Adresse</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>entspricht <code>127.0.0.1</code> bei IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eingebettete IPv4-Adresse</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die niedrigen 32 Bit sind die kompatiblen IPv4-Adressen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eine auf IPv6 abgebildete IPv4-Adresse.</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die niedrigen 32 Bit sind IPv4-Adressen für Hosts, die kein IPv6 unterstützen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::/10</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>link-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Entspricht 196.254.0.0/16 bei IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fc00::/7</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unique-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diese einzigartigen Adressen sind für die lokale Kommunikation bestimmt und werden nur innerhalb von abgegrenzten Standorten (Sites) weitergeleitet.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff00::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Multicast</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>2000::-3fff::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Globaler Unicast</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alle globalen Unicast-Adressen stammen aus diesem Pool. Die ersten 3 Bit lauten <code>001</code>.</p></td></tr></tbody></table><div class=paragraph><p>Weitere Informationen zum Aufbau von IPv6-Adressen finden Sie im <a href=http://www.ietf.org/rfc/rfc3513.txt>RFC3513</a>.</p></div></div><div class=sect2><h3 id=_ipv6_konfigurieren>31.9.2. IPv6 konfigurieren<a class=anchor href=#_ipv6_konfigurieren></a></h3><div class=paragraph><p>Um ein FreeBSD-System als IPv6-Client zu konfigurieren, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 accept_rtadv&#34;
rtsold_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Die erste Zeile ermöglicht der angegebenen Schnittstelle, Router-Advertisement-Nachrichten zu empfangen. Die zweite Zeile aktiviert den Router-Solicitation-Daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;format=html">rtsold(8)</a>.</p></div><div class=paragraph><p>Falls die Schnittstelle eine statisch zugewiesene IPv6-Adresse benötigt, fügen Sie einen Eintrag mit der statischen Adresse und dem zugehörigen Präfix für das Subnetz hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen 64&#34;</pre></div></div><div class=paragraph><p>Um einen Standardrouter festzulegen, fügen Sie die Adresse hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;2001:db8:4672:6565::1&#34;</pre></div></div></div><div class=sect2><h3 id=_verbindung_zu_einem_provider_aufbauen>31.9.3. Verbindung zu einem Provider aufbauen<a class=anchor href=#_verbindung_zu_einem_provider_aufbauen></a></h3><div class=paragraph><p>Um sich mit anderen IPv6-Netzwerken zu verbinden, benötigen Sie einen Provider oder einen Tunnel, der IPv6 unterstützt:</p></div><div class=ulist><ul><li><p>Fragen Sie einen Internetprovider, ob er IPv6 anbietet.</p></li><li><p><a href=http://www.tunnelbroker.net>Hurricane Electric</a> bietet weltweit IPv6-Tunnelverbindungen an.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Verwendung des Ports <span class=filename>/usr/ports/net/freenet6</span> für Einwahlverbindungen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie die Anweisungen eines Tunnel-Providers dauerhaft in <span class=filename>/etc/rc.conf</span> einrichten.</p></div><div class=paragraph><p>Der erste Eintrag in <span class=filename>/etc/rc.conf</span> erzeugt die generische Tunnelschnittstelle <span class=filename>gif0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;gif0&#34;</pre></div></div><div class=paragraph><p>Als nächstes konfigurieren Sie die IPv4-Adressen der lokalen und entfernten Endpunkte. Ersetzen Sie <em>MY_IPv4_ADDR</em> und <em>REMOTE_IPv4_ADDR</em> durch die tatsächlichen IPv4-Adressen:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces_gif0=&#34;MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre></div></div><div class=paragraph><p>Um die zugewiesene IPv6-Adresse als Endpunkt für den IPv6-Tunnel zu verwenden, fügen Sie folgende Zeile für FreeBSD 9.<em>x</em> (und neuer) ein:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_gif0_ipv6=&#34;inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Legen Sie dann die Standardroute für das andere Ende des IPv6-Tunnels fest. Ersetzen Sie <em>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</em> mit der Adresse des Standard-Gateways des Providers:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Wenn das FreeBSD-System IPv6-Verkehr zwischen dem Netzwerk und der Außenwelt routen muss, aktivieren Sie das Gateway mit dieser Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_gateway_enable=&#34;YES&#34;</pre></div></div></div><div class=sect2><h3 id=_bekanntmachung_von_routen_und_automatische_rechnerkonfiguration>31.9.4. Bekanntmachung von Routen und automatische Rechnerkonfiguration<a class=anchor href=#_bekanntmachung_von_routen_und_automatische_rechnerkonfiguration></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt die Einrichtung von <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>, das Sie bei der Bekanntmachung der IPv6-Standardroute unterstützt.</p></div><div class=paragraph><p>Um <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> zu aktivieren, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Es ist wichtig, die Schnittstelle anzugeben, über die IPv6-Routen bekanntgemacht werden sollen. Soll <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> <span class=filename>rl0</span> verwenden, ist folgender Eintrag nötig:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_interfaces=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>Danach erzeugen Sie die Konfigurationsdatei <span class=filename>/etc/rtadvd.conf</span>. Dazu ein Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>rl0:\
    :addrs#1:addr=&#34;2001:db8:1f11:246::&#34;:prefixlen#64:tc=ether:</pre></div></div><div class=paragraph><p>Ersetzen Sie dabei <span class=filename>fxp0</span> durch die zu verwendende Schnittstelle, und <code>2001:db8:1f11:246::</code> durch das entsprechend zugewiesene Präfix.</p></div><div class=paragraph><p>Bei einem <code>/64</code>-Subnetz müssen keine weiteren Anpassungen vorgenommen werden. Anderenfalls muss <code>prefixlen#</code> auf den korrekten Wert gesetzt werden.</p></div></div><div class=sect2><h3 id=_ipv6_und_abbildung_von_ipv6_adressen>31.9.5. IPv6 und Abbildung von IPv6-Adressen<a class=anchor href=#_ipv6_und_abbildung_von_ipv6_adressen></a></h3><div class=paragraph><p>Wenn IPv6 auf einem Server aktiviert ist, kann es für die Kommunikation erforderlich sein, IPv4-Adressen auf IPv6-Adressen abzubilden. Diese Kompatibilität erlaubt es, das IPv4-Adressen als IPv6-Adressen dargestellt werden. Die Kommunikation von IPv6-Anwendungen mit IPv4 und umgekehrt kann jedoch ein Sicherheitsrisiko darstellen.</p></div><div class=paragraph><p>Diese Option dient nur der Kompatibilität und wird in den meisten Fällen nicht erforderlich sein. Die Option ermöglicht es IPv6-Anwendungen zusammen mit IPv4 in einer Dual-Stack-Umgebung zu funktionieren. Dies ist besonders nützlich für Anwendungen von Drittanbietern, die evtl. keine IPv6-Umgebungen unterstützen. Um diese Funktion zu aktivieren, fügen Sie folgendes in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ip4mapping=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Für einige Administratoren können die Informationen im RFC 3493 (Sektion 3.6 und 3.7) und RFC 4038 (Sektion 4.2) hilfreich sein.</p></div></div></div></div><div class=sect1><h2 id=carp>31.10. Common Address Redundancy Protocol (CARP)<a class=anchor href=#carp></a></h2><div class=sectionbody><div class=paragraph><p>Das Common Address Redundancy Protocol (CARP) erlaubt es, mehreren Rechnern die gleiche IP-Adresse und Virtual Host ID (VHID) zuzuweisen und <em>Hochverfügbarkeit</em> bereitzustellen. Das bedeutet, dass ein oder mehrere Rechner ausfallen können und die anderen Rechner transparent einspringen, ohne dass die Benutzer etwas von einem Ausfall mitbekommen.</p></div><div class=paragraph><p>Neben der gemeinsamen IP-Adresse, haben die jeweiligen Rechner auch eine eindeutige IP-Adresse zur Verwaltung und Konfiguration. Alle Maschinen, die sich eine IP-Adresse teilen, verwenden die gleiche VHID. Die VHID für jede einzelne IP-Adresse muss, entsprechend der Broadcast-Domäne der Netzwerkschnittstelle, eindeutig sein.</p></div><div class=paragraph><p>Hochverfügbarkeit mit CARP ist in FreeBSD enthalten, jedoch unterscheidet sich die Konfiguration von der eingesetzten FreeBSD-Version. Dieser Abschnitt enthält die gleichen Konfigurationsdateien für verschiedene Versionen von FreeBSD.</p></div><div class=paragraph><p>Dieses Beispiel konfiguriert eine Failover-Unterstützung mit drei Servern (mit jeweils eigener, eindeutiger IP-Adresse), die alle den gleichen Web-Inhalt anbieten. Es werden zwei verschiedene Master namens <code>hosta.example.org</code> und <code>hostb.example.org</code> benutzt, mit einem gemeinsamen Backup namens <code>hostc.example.org</code>.</p></div><div class=paragraph><p>Die Lastverteilung dieser Maschinen wird dabei über Round RobinDNS konfiguriert. Mit Ausnahme des Hostnamens und der IP-Management-Adresse sind Master- und Backup-Maschinen identisch konfiguriert. Die Server müssen die gleiche Konfiguration und die gleichen Dienste aktiviert haben. Tritt ein Failover auf, können Anfragen an den Dienst mit der gemeinsam genutzten IP-Adresse nur dann richtig beantwortet werden, wenn der Backup-Server Zugriff auf denselben Inhalt hat. Die Backup-Maschine verfügt über zwei zusätzliche CARP-Schnittstellen, eine für jede IP-Adresse des Master-Content-Servers. Sobald ein Fehler auftritt, übernimmt der Backup-Server die IP-Adresse des ausgefallenen Master-Servers.</p></div><div class=sect2><h3 id=carp-10x>31.10.1. CARP mit FreeBSD 10 (und neuer) benutzen<a class=anchor href=#carp-10x></a></h3><div class=paragraph><p>Unterstützung für CARP erhalten Sie durch das Laden des Kernelmoduls <span class=filename>carp.ko</span> in <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>So laden Sie das Modul ohne Neustart:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Benutzer, die einen angepassten Kernel verwenden möchten, müssen die folgende Zeile in die Konfigurationsdatei aufnehmen. Anschließend muss der Kernel, wie in <a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a> beschrieben, neu gebaut werden:</p></div><div class="literalblock programlisting"><div class=content><pre>device  carp</pre></div></div><div class=paragraph><p>Hostname, IP-Management-Adresse, Subnetzmaske, gemeinsame IP-Adresse und VHID werden durch Einträge in <span class=filename>/etc/rc.conf</span> gesetzt. Dieses Beispiel ist für <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 pass testpass alias 192.168.1.50/32&#34;</pre></div></div><div class=paragraph><p>Die nächsten Einträge sind für <code>hostb.example.org</code>. Da der Rechner einen zweiten Master darstellt, verwendet er eine andere gemeinsame IP-Adresse und VHID. Die mittels <code>pass</code> angegebenen Passwörter müssen jedoch identisch sein, da CARP nur mit Systemen kommuniziert, die über das richtige Passwort verfügen.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 2 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>Die dritte Maschine, <code>hostc.example.org</code> ist so konfiguriert, das sie aktiviert wird, wenn einer der beiden Masterserver ausfällt. Diese Maschine ist mit zwei CARPVHIDs konfiguriert, eine für jede virtuelle IP-Adresse der beiden Master-Server. Die CARP advertising skew, <code>advskew</code> wird gesetzt, um sicherzustellen, dass sich der Backup-Server später ankündigt wie der Master-Server, da <code>advskew</code> die Rangfolge steuert für den Fall, dass mehrere Backup-Server zur Verfügung stehen.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32&#34;
ifconfig_em0_alias1=&#34;inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>Durch die beiden konfigurierten CARPVHIDs ist <code>hostc.example.org</code> in der Lage festzustellen, wenn einer der Master-Server nicht mehr reagiert. Wenn der Master-Server sich später ankündigt als der Backup-Server, übernimmt der Backup-Server die gemeinsame IP-Adresse, bis der Master-Server erneut verfügbar ist.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Auch wenn der ursprüngliche Master-Server wieder verfügbar wird, gibt <code>hostc.example.org</code> die virtuelle IP-Adresse nicht automatisch wieder frei. Dazu muss Preemption aktiviert werden. Preemption ist standardmäßig deaktiviert und wird über die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>net.inet.carp.preempt</code> gesteuert. Der Administrator kann den Backup-Server zwingen, die IP-Adresse an den Master zurückzugeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0 vhid 1 state backup</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald die Konfiguration abgeschlossen ist, muss das Netzwerk oder die Maschine neu gestartet werden. Hochverfügbarkeit ist nun aktiviert.</p></div><div class=paragraph><p>Die Funktionalität von CARP kann, wie in der Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a> beschrieben, über verschiedene <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> Parameter kontrolliert werden. Mit dem Einsatz von <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> können weitere Aktionen zu CARP-Ereignissen ausgelöst werden.</p></div></div><div class=sect2><h3 id=carp-9x>31.10.2. CARP mit FreeBSD 9 (und älter) benutzen<a class=anchor href=#carp-9x></a></h3><div class=paragraph><p>Die Konfiguration für diese Versionen von FreeBSD ist ähnlich wie im vorhergehenden Abschnitt beschrieben, mit der Ausnahme, dass zuerst ein CARP-Gerät in der Konfiguration erstellt und bezeichnet werden muss.</p></div><div class=paragraph><p>Unterstützung für CARP erhalten Sie durch das Laden des Kernelmoduls <span class=filename>carp.ko</span> in <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>if_carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>So laden Sie das Modul ohne Neustart:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Benutzer, die einen angepassten Kernel verwenden möchten, müssen die folgende Zeile in die Konfigurationsdatei aufnehmen. Anschließend muss der Kernel, wie in <a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a> beschrieben, neu gebaut werden:</p></div><div class="literalblock programlisting"><div class=content><pre>device    carp</pre></div></div><div class=paragraph><p>Als nächstes erstellen Sie auf jedem Rechner eine CARP-Schnittstelle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 create</span></code></pre></div></div><div class=paragraph><p>Konfigurieren Sie Hostnamen, IP-Management-Adresse, die gemeinsam genutzte IP-Adresse und die VHID, indem Sie die erforderlichen Zeilen in <span class=filename>/etc/rc.conf</span> hinzufügen. Da anstelle eines Alias eine virtuelles CARP-Gerät verwendet wird, wird die tatsächliche Subnetzmaske <code>/24</code> anstatt <code>/32</code> benutzt. Hier sind die Einträge für <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpass 192.168.1.50/24&#34;</pre></div></div><div class=paragraph><p>Beispiel für <code>hostb.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class=paragraph><p>Die dritte Maschine, <code>hostc.example.org</code> ist so konfiguriert, das sie aktiviert wird, wenn einer der beiden Masterserver ausfällt:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Preemption ist im <span class=filename>GENERIC</span>-Kernel deaktiviert. Haben Sie jedoch Preemption in einem angepassten Kernel aktiviert, dass <code>hostc.example.org</code> die virtuelle IP-Adresse nicht wieder an den Master-Server zurückgibt. Der Administrator kann jedoch den Backup-Server dazu zwingen, die übernommene IP-Adresse wieder an den Master-Server zurückzugeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre></div></div><div class=paragraph><p>Dieser Befehl muss auf dem <span class=filename>carp</span>-Gerät ausgeführt werden, dass dem betroffenen System zugeordnet ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald die Konfiguration abgeschlossen ist, muss das Netzwerk oder die Maschine neu gestartet werden. Hochverfügbarkeit ist nun aktiviert.</p></div></div></div></div><div class=sect1><h2 id=network-vlan>31.11. VLANs<a class=anchor href=#network-vlan></a></h2><div class=sectionbody><div class=paragraph><p>VLANs sind eine Möglichkeit ein Netzwerk virtuell in viele Subnetze zu unterteilen. Man spricht hier auch von Segmentierung. Jedes Subnetz hat seine eigene Broadcast-Domäne und ist von anderen VLANs isoliert.</p></div><div class=paragraph><p>Unter FreeBSD müssen VLANs vom Treiber der Netzwerkkarte unterstützt werden. <a href="https://man.freebsd.org/cgi/man.cgi?query=vlan&amp;sektion=4&amp;format=html">vlan(4)</a> enthält eine Liste von Treibern mit integrierter VLAN-Unterstützung.</p></div><div class=paragraph><p>Für die Konfiguration eines VLAN werden zwei Informationen benötigt: die verwendete Netzwerkschnittstelle und das VLAN-Tag.</p></div><div class=paragraph><p>Das folgende Kommando konfiguriert ein VLAN mit der Netzwerkschnittstelle <code>em0</code> und dem VLAN-Tag <code>5</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In diesem Beispiel fällt auf, dass der Name der Schnittstelle den Treibernamen und das VLAN-Tag enthält, getrennt durch einen Punkt. Diese Methode hat sich bewährt, da sie die Konfiguration von Systemen mit mehreren VLANs deutlich erleichtert.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um VLANs beim Booten zu konfigurieren, muss <span class=filename>/etc/rc.conf</span> angepasst werden. Für das obige Beispiel müssten folgende Zeilen in die Konfiguration aufgenommen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_em0=&#34;5&#34;
ifconfig_em0_5=&#34;inet 192.168.20.20/24&#34;</pre></div></div><div class=paragraph><p>Das gleiche Schema kann benutzt werden, um weitere VLANs hinzuzufügen.</p></div><div class=paragraph><p>Es ist sinnvoll, einer Schnittstelle einen symbolischen Namen zuzuweisen, so dass bei einem Wechsel der zugehörigen Hardware nur wenige Konfigurationsvariablen aktualisiert werden müssen. Nehmen wir beispielsweise an, dass Überwachungskameras im VLAN1 auf <code>em0</code> betrieben werden. Wenn später die Karte <code>em0</code> durch eine Karte ersetzt wird, die den <a href="https://man.freebsd.org/cgi/man.cgi?query=ixgb&amp;sektion=4&amp;format=html">ixgb(4)</a> Treiber verwendet, müssen nicht alle Referenzen auf <code>em0.1</code> durch <code>ixgb0.1</code> ersetzt werden.</p></div><div class=paragraph><p>Der folgende Befehl konfiguriert VLAN <code>5</code> auf der Netzwerkkarte <code>em0</code>. Die Schnittstelle bekommt den Namen <code>cameras</code> und eine IP-Adresse <code><em>192.168.20.20</em></code> mit einem <code>24</code>-Bit Präfix.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Dieser Befehl konfiguriert die Schnittstelle mit dem Namen <code>video</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Um die Änderungen beim Booten anzuwenden, fügen Sie folgenden Zeilen in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_video=&#34;cameras&#34;
create_args_cameras=&#34;vlan 5&#34;
ifconfig_cameras=&#34;inet 192.168.20.20/24&#34;</pre></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9. März 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/de/books/handbook/firewalls class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/de/books/handbook/partv class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>31.1. Übersicht</a></li><li><a href=#network-routing>31.2. Gateways und Routen</a></li><li><a href=#network-wireless>31.3. Drahtlose Netzwerke</a></li><li><a href=#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=#network-bluetooth>31.5. Bluetooth</a></li><li><a href=#network-bridging>31.6. LAN-Kopplung mit einer Bridge</a></li><li><a href=#network-aggregation>31.7. Link-Aggregation und Failover</a></li><li><a href=#network-diskless>31.8. Plattenloser Betrieb mit PXE</a></li><li><a href=#network-ipv6>31.9. IPv6</a></li><li><a href=#carp>31.10. Common Address Redundancy Protocol (CARP)</a></li><li><a href=#network-vlan>31.11. VLANs</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/handbook/handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/de/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>