<!doctype html><html class=theme-light lang=de><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/de/books/handbook/disks/><title>Kapitel 17. Speichermedien | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Kapitel 17. Speichermedien"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="https://docs.freebsd.org/de/books/handbook/disks/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/de\/books\/handbook\/disks\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=https://docs.freebsd.org/de/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/de/books>Books</a></li><li><a href=https://docs.freebsd.org/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/preface/>Vorwort</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-audience>Über dieses Buch</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-changes-from3>Änderungen gegenüber der dritten Auflage</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-changes-from2>Änderungen gegenüber der zweiten Auflage (2004)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-changes>Änderungen gegenüber der ersten Auflage (2001)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-overview>Gliederung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-conv>Konventionen in diesem Buch</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-acknowledgements>Danksagung</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/parti/>Teil I. Erste Schritte</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/introduction/>Kapitel 1. Einleitung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/introduction/#introduction-synopsis>1.1. Überblick</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/introduction/#nutshell>1.2. Willkommen zu FreeBSD!</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/introduction/#history>1.3. Über das FreeBSD Projekt</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/>Kapitel 2. FreeBSD installieren</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Minimale Hardwareanforderungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Vor der Installation</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-start>2.4. Die Installation starten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#using-bsdinstall>2.5. Verwendung von bsdinstall</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Plattenplatz bereitstellen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Abrufen der Distributionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-post>2.8. Benutzerkonten, Zeitzone, Dienste und Sicherheitsoptionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-network>2.9. Netzwerkschnittstellen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Fehlerbehebung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#using-live-cd>2.11. Verwendung der Live-CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/basics/>Kapitel 3. Grundlagen des FreeBSD Betriebssystems</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-synopsis>3.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#consoles>3.2. Virtuelle Konsolen und Terminals</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#users-synopsis>3.3. Benutzer und grundlegende Account-Verwaltung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#permissions>3.4. Zugriffsrechte</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#dirstructure>3.5. Verzeichnis-Strukturen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#disk-organization>3.6. Festplatten, Slices und Partitionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#mount-unmount>3.7. Anhängen und Abhängen von Dateisystemen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-processes>3.8. Prozesse und Dämonen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#editors>3.10. Text-Editoren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-devices>3.11. Geräte und Gerätedateien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-more-information>3.12. Manualpages</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/ports/>Kapitel 4. Installieren von Anwendungen: Pakete und Ports</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-synopsis>4.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-overview>4.2. Installation von Software</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-finding-applications>4.3. Suchen einer Anwendung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#pkgng-intro>4.4. Benutzen von pkg zur Verwaltung von Binärpaketen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-using>4.5. Benutzen der Ports-Sammlung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-poudriere>4.6. Pakete mit Poudriere bauen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-nextsteps>4.7. Nach der Installation</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-broken>4.8. Kaputte Ports</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/x11/>Kapitel 5. Das X-Window-System</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x11-synopsis>5.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-understanding>5.2. Terminologie</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-install>5.3. Xorg installieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-config>5.4. Xorg konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-fonts>5.5. Schriftarten in Xorg benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-xdm>5.6. Der X-Display-Manager</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x11-wm>5.7. Grafische Oberflächen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-compiz-fusion>5.8. Compiz Fusion installieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x11-troubleshooting>5.9. Fehlersuche</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partii/>Teil II. Oft benutzte Funktionen</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/desktop/>Kapitel 6. Desktop-Anwendungen</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-synopsis>6.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-browsers>6.2. Browser</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-productivity>6.3. Büroanwendungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-viewers>6.4. Anzeigen von Dokumenten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-finance>6.5. Finanzsoftware</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/multimedia/>Kapitel 7. Multimedia</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#multimedia-synopsis>7.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#sound-setup>7.2. Soundkarten einrichten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#sound-mp3>7.3. MP3-Audio</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#video-playback>7.4. Videos wiedergeben</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#tvcard>7.5. TV-Karten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#scanners>7.7. Scanner</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/>Kapitel 8. Konfiguration des FreeBSD-Kernels</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Wieso einen eigenen Kernel bauen?</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Informationen über die vorhandene Hardware beschaffen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-config>8.4. Die Kernelkonfigurationsdatei</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-building>8.5. Einen angepassten Kernel bauen und installieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. Wenn etwas schiefgeht</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/printing/>Kapitel 9. Drucken</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-quick-start>9.1. Schnellstart</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-connections>9.2. Druckerverbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-pdls>9.3. Gebräuchliche Seitenbeschreibungssprachen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-direct>9.4. Direktes Drucken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-lpd>9.5. LPD (Line Printer Daemon)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-other>9.6. Andere Drucksysteme</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/>Kapitel 10. Linux®-Binärkompatibilität</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Konfiguration der Linux®-Binärkompatibilität</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/#linuxemu-advanced>10.3. Weiterführende Themen</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partiii/>Teil III. Systemadministration</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/config/>Kapitel 11. Konfiguration und Tuning</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/config/#config-synopsis>11.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-starting-services>11.2. Start von Diensten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-cron>11.3. cron(8) konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-rcd>11.4. Dienste unter FreeBSD verwalten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#config-network-setup>11.5. Einrichten von Netzwerkkarten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-virtual-hosts>11.6. Virtual Hosts</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-syslog>11.7. Konfiguration der Systemprotokollierung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-configfiles>11.8. Konfigurationsdateien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-sysctl>11.9. Einstellungen mit sysctl(8)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-disk>11.10. Tuning von Laufwerken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-kernel-limits>11.11. Einstellungen von Kernel Limits</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#adding-swap-space>11.12. Hinzufügen von Swap-Bereichen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#acpi-overview>11.13. Energie- und Ressourcenverwaltung</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/boot/>Kapitel 12. FreeBSDs Bootvorgang</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-synopsis>12.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-introduction>12.2. FreeBSDs Bootvorgang</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-splash>12.3. Willkommensbildschirme während des Bootvorgangs konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#device-hints>12.4. Konfiguration von Geräten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-shutdown>12.5. Der Shutdown-Vorgang</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/security/>Kapitel 13. Sicherheit</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-synopsis>13.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-intro>13.2. Einführung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#one-time-passwords>13.3. Einmalpasswörter</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#ipsec>13.7. VPN mit IPsec</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#fs-acl>13.9. Zugriffskontrolllisten für Dateisysteme (ACL)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-pkg>13.10. Sicherheitsprobleme in Software von Drittanbietern überwachen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-advisories>13.11. FreeBSD Sicherheitshinweise</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-accounting>13.12. Prozess-Überwachung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-resourcelimits>13.13. Einschränkung von Ressourcen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-sudo>13.14. Gemeinsame Administration mit Sudo</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/jails/>Kapitel 14. Jails</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-synopsis>14.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-terms>14.2. Jails - Definitionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-build>14.3. Einrichtung und Verwaltung von Jails</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-tuning>14.4. Feinabstimmung und Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-application>14.5. Mehrere Jails aktualisieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-ezjail>14.6. Verwaltung von Jails mit ezjail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/mac/>Kapitel 15. Verbindliche Zugriffskontrolle</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-synopsis>15.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-inline-glossary>15.2. Schlüsselbegriffe</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-initial>15.3. Erläuterung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-understandlabel>15.4. MAC Labels verstehen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-planning>15.5. Planung eines Sicherheitsmodells</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-modules>15.6. Modulkonfiguration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-seeotheruids>15.7. Das MAC Modul seeotheruids</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-bsdextended>15.8. Das MAC Modul bsdextended</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-ifoff>15.9. Das MAC Modul ifoff</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-portacl>15.10. Das MAC Modul portacl</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-partition>15.11. Das MAC Modul partition</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-mls>15.12. Das MAC Modul Multi-Level Security</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-biba>15.13. Das MAC Modul Biba</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-lomac>15.14. Das MAC Modul LOMAC</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-implementing>15.15. Beispiel 1: Nagios in einer MAC Jail</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-userlocked>15.16. Beispiel 2: User Lock Down</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-troubleshoot>15.17. Fehler im MAC beheben</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/audit/>Kapitel 16. Security Event Auditing</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-synopsis>16.1. Einleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-inline-glossary>16.2. Schlüsselbegriffe</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-config>16.3. Audit Konfiguration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-administration>16.4. Audit-Trails</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle checked>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/disks/>Kapitel 17. Speichermedien</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-synopsis>17.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-adding>17.2. Hinzufügen von Laufwerken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-growing>17.3. Partitionen vergrößern</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#usb-disks>17.4. USB Speichermedien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#creating-cds>17.5. Erstellen und Verwenden von CDs</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#creating-dvds>17.6. DVDs benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#floppies>17.7. Disketten benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#backup-basics>17.8. Datensicherung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-virtual>17.9. Speicherbasierte Laufwerke</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#snapshots>17.10. Schnappschüsse von Dateisystemen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#quotas>17.11. Disk Quotas</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-encrypting>17.12. Partitionen verschlüsseln</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#swap-encrypting>17.13. Den Auslagerungsspeicher verschlüsseln</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-hast>17.14. Highly Available Storage (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/geom/>Kapitel 18. GEOM: Modulares Framework zur Plattentransformation</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-synopsis>18.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-mirror>18.3. RAID1 - Spiegelung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-raid3>18.4. RAID3 - Byte-Level Striping mit dedizierter Parität</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-graid>18.5. Software RAID</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-ggate>18.6. GEOM Gate Netzwerk</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-glabel>18.7. Das Labeln von Laufwerken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-gjournal>18.8. UFS Journaling in GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/zfs/>Kapitel 19. Das Z-Dateisystem (ZFS)</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-differences>19.1. Was ZFS anders macht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-quickstart>19.2. Schnellstartanleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-zpool>19.3. <code>zpool</code> Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-zfs>19.4. <code>zfs</code> Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-zfs-allow>19.5. Delegierbare Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-advanced>19.6. Themen für Fortgeschrittene</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-links>19.7. Zusätzliche Informationen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-term>19.8. ZFS-Eigenschaften und Terminologie</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/filesystems/>Kapitel 20. Dateisystemunterstützung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/filesystems/#filesystems-synopsis>20.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/filesystems/#filesystems-linux>20.2. Linux® Dateisysteme</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/virtualization/>Kapitel 21. Virtualisierung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-synopsis>21.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-parallels>21.2. FreeBSD als Gast-Betriebssystem unter Parallels für Mac OS® X</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. FreeBSD als Gast-Betriebssystem unter Virtual PC für Windows®</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-vmware>21.4. FreeBSD als Gast-Betriebssystem unter VMware Fusion für Mac OS®</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-virtualbox-guest-additions>21.5. FreeBSD als Gast mit VirtualBox™</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. FreeBSD als Host mit Virtualbox</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-host-bhyve>21.7. FreeBSD als Host mit bhyve</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-host-xen>21.8. FreeBSD als Xen™-Host</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/l10n/>Kapitel 22. Lokalisierung – I18N/L10N einrichten und benutzen</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#l10n-synopsis>22.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#using-localization>22.2. Lokale Anpassungen benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#l10n-compiling>22.3. I18N-Programme</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#lang-setup>22.4. Lokalisierung für einzelne Sprachen</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/>Kapitel 23. FreeBSD aktualisieren</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. FreeBSD-Update</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. Aktualisieren der Dokumentationssammlung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#current-stable>23.4. Einem Entwicklungszweig folgen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#makeworld>23.5. FreeBSD aus den Quellen aktualisieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#small-lan>23.6. Installation mehrerer Maschinen</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/dtrace/>Kapitel 24. DTrace</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-synopsis>24.1. Überblick</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-implementation>24.2. Unterschiede in der Implementierung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-enable>24.3. Die DTrace Unterstützung aktivieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-using>24.4. DTrace verwenden</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/>Kapitel 25. USB Gerätemodus</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. Virtuelle serielle USB-Ports</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. Netzwerkkarten im USB-Gerätemodus</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. Virtuelle USB-Speichergeräte</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partiv/>Teil IV. Netzwerke</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/>Kapitel 26. Serielle Datenübertragung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#serial-synopsis>26.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#serial>26.2. Begriffe und Hardware</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#term>26.3. Terminals</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#dialup>26.4. Einwählverbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#dialout>26.5. Verbindungen nach Außen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#serialconsole-setup>26.6. Einrichten der seriellen Konsole</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/>Kapitel 27. PPP</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#userppp>27.2. PPP konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. Probleme bei PPP-Verbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#pppoe>27.4. PPP over Ethernet (PPPoE)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#pppoa>27.5. PPP over ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/mail/>Kapitel 28. Elektronische Post (E-Mail)</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-de-term>28.1. Terminologie</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-synopsis>28.2. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-using>28.3. E-Mail Komponenten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#sendmail>28.4. Sendmail-Konfigurationsdateien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-changingmta>28.5. Wechseln des Mailübertragungs-Agenten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-trouble>28.6. Fehlerbehebung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-advanced>28.7. Weiterführende Themen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#outgoing-only>28.8. Ausgehende E-Mail über einen Relay versenden</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#SMTP-dialup>28.9. E-Mail über Einwahl-Verbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#SMTP-Auth>28.10. SMTP-Authentifizierung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-agents>28.11. E-Mail-Programme</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-fetchmail>28.12. E-Mails mit fetchmail abholen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-procmail>28.13. E-Mails mit procmail filtern</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/network-servers/>Kapitel 29. Netzwerkserver</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-servers-synopsis>29.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-inetd>29.2. Der inetd"Super-Server"</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-nis>29.4. Network Information System (NIS)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-ldap>29.5. Lightweight Access Directory Protocol (LDAP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-dhcp>29.6. Dynamic Host Configuration Protocol (DHCP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-dns>29.7. Domain Name System (DNS)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-apache>29.8. Apache HTTP-Server</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-ftp>29.9. File Transfer Protocol (FTP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-samba>29.10. Datei- und Druckserver für Microsoft® Windows®-Clients (Samba)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-ntp>29.11. Die Uhrzeit mit NTP synchronisieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-iscsi>29.12. iSCSI Initiator und Target Konfiguration</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/firewalls/>Kapitel 30. Firewalls</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-intro>30.1. Einführung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-concepts>30.2. Firewallkonzepte</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/>Kapitel 31. Weiterführende Netzwerkthemen</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-routing>31.2. Gateways und Routen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-wireless>31.3. Drahtlose Netzwerke</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-bluetooth>31.5. Bluetooth</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-bridging>31.6. LAN-Kopplung mit einer Bridge</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-aggregation>31.7. Link-Aggregation und Failover</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-diskless>31.8. Plattenloser Betrieb mit PXE</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#carp>31.10. Common Address Redundancy Protocol (CARP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partv/>Teil V. Anhang</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/mirrors/>Anhang A. Bezugsquellen für FreeBSD</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#mirrors-cdrom>A.1. CD and DVD Sets</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#mirrors-ftp>A.2. FTP-Server</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#svn>A.3. Benutzen von Subversion</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#mirrors-rsync>A.4. Benutzen von rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/bibliography/>Anhang B. Bibliografie</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-freebsd>B.1. Bücher speziell für FreeBSD</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-userguides>B.2. Handbücher</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-adminguides>B.3. Administrations-Anleitungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-programmers>B.4. Programmierhandbücher</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-osinternals>B.5. Betriebssystem-Interna</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-security>B.6. Sicherheits-Anleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-hardware>B.7. Hardware-Anleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-history>B.8. UNIX® Geschichte</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-journals>B.9. Zeitschriften, Magazine und Journale</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/eresources/>Anhang C. Ressourcen im Internet</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-www>C.1. Webseiten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-mail>C.2. Mailinglisten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-news>C.3. Usenet-News</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-web>C.4. Offizielle Spiegel</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/pgpkeys/>Anhang D. OpenPGP-Schlüssel</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Ansprechpartner</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Kapitel 17. Speichermedien</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#disks-synopsis>17.1. Übersicht</a></li><li><a href=#disks-adding>17.2. Hinzufügen von Laufwerken</a></li><li><a href=#disks-growing>17.3. Partitionen vergrößern</a></li><li><a href=#usb-disks>17.4. USB Speichermedien</a></li><li><a href=#creating-cds>17.5. Erstellen und Verwenden von CDs</a></li><li><a href=#creating-dvds>17.6. DVDs benutzen</a></li><li><a href=#floppies>17.7. Disketten benutzen</a></li><li><a href=#backup-basics>17.8. Datensicherung</a></li><li><a href=#disks-virtual>17.9. Speicherbasierte Laufwerke</a></li><li><a href=#snapshots>17.10. Schnappschüsse von Dateisystemen</a></li><li><a href=#quotas>17.11. Disk Quotas</a></li><li><a href=#disks-encrypting>17.12. Partitionen verschlüsseln</a></li><li><a href=#swap-encrypting>17.13. Den Auslagerungsspeicher verschlüsseln</a></li><li><a href=#disks-hast>17.14. Highly Available Storage (HAST)</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=disks-synopsis>17.1. Übersicht<a class=anchor href=#disks-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Dieses Kapitel behandelt die Benutzung von Laufwerken unter FreeBSD. Hierzu zählen SCSI- und IDE-Geräte, CD- und DVD-Medien, speicherbasierte Laufwerke und USB-Geräte.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes wissen:</p></div><div class=ulist><ul><li><p>Wie Sie zusätzliche Laufwerke zu einem FreeBSD-System hinzufügen.</p></li><li><p>Wie Sie unter FreeBSD die Partition einer Festplatte vergrößern.</p></li><li><p>Wie Sie FreeBSD zur Verwendung von USB-Speichermedien konfigurieren.</p></li><li><p>Wie Sie CD- und DVD-Medien unter FreeBSD benutzen.</p></li><li><p>Wie Sie die unter FreeBSD erhältlichen Backup-Programme benutzen.</p></li><li><p>Wie Sie RAM-Disks einrichten.</p></li><li><p>Was Dateisystem-Schnappschüsse sind und wie sie effizient eingesetzt werden.</p></li><li><p>Wie Sie mit Quotas die Benutzung von Laufwerken einschränken.</p></li><li><p>Wie Sie Festplatten und Swap verschlüsseln, um Daten vor Angreifern zu schützen.</p></li><li><p>Wie Sie ein hochverfügbares Speichernetzwerk konfigurieren.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen,</p></div><div class=ulist><ul><li><p>sollten Sie wissen, wie Sie einen <a href=../kernelconfig/#kernelconfig>neuen FreeBSD-Kernel konfigurieren und installieren</a>.</p></li></ul></div></div></div><div class=sect1><h2 id=disks-adding>17.2. Hinzufügen von Laufwerken<a class=anchor href=#disks-adding></a></h2><div class=sectionbody><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie ein neues SATA-Laufwerk zu einer Maschine hinzufügen, die momentan nur ein Laufwerk hat. Dazu schalten Sie zuerst den Rechner aus und installieren das Laufwerk entsprechend der Anleitungen Ihres Rechners, Ihres Controllers und des Laufwerkherstellers. Starten Sie das System neu und melden Sie sich als Benutzer <code>root</code> an.</p></div><div class=paragraph><p>Kontrollieren Sie <span class=filename>/var/run/dmesg.boot</span>, um sicherzustellen, dass das neue Laufwerk gefunden wurde. In diesem Beispiel erscheint das neu hinzugefügte SATA-Laufwerk als <span class=filename>ada1</span>.</p></div><div class=paragraph><p>In diesem Beispiel wird eine einzige große Partition auf der Festplatte erstellt. Verwendet wird das <a href=https://de.wikipedia.org/wiki/GUID_Partition_Table>GPT</a>-Partitionsschema, welches gegenüber dem älteren und weniger vielseitigen MBR-Schema bevorzug wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn die hinzugefügte Festplatte nicht leer ist, können alte Partitionsinformationen mit <code>gpart delete</code> entfernt werden. Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Zuerst wird das Partitionsschema erstellt und dann eine einzelne Partition angefügt. Zur Verbesserung der Leistung auf neueren Festplatten mit größeren Blockgrößen, wird die Partition an einer Megabyte-Grenze ausgerichtet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT ada1</span>
<span class=c># gpart add -t freebsd-ufs -a 1M ada1</span></code></pre></div></div><div class=paragraph><p>Je nach Anwendung kann es wünschenswert sein, mehrere kleinere Partitionen zu haben. In <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> finden Sie Optionen zum Erstellen von kleineren Partitionen.</p></div><div class=paragraph><p>Informationen über die Partitionen der Festplatte werden mit <code>gpart show</code> angezeigt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gpart show ada1
<span class=o>=&gt;</span>        34  1465146988  ada1  GPT  <span class=o>(</span>699G<span class=o>)</span>
          34        2014        - free -  <span class=o>(</span>1.0M<span class=o>)</span>
        2048  1465143296     1  freebsd-ufs  <span class=o>(</span>699G<span class=o>)</span>
  1465145344        1678        - free -  <span class=o>(</span>839K<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Ein Dateisystem wird in der neuen Partition erstellt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/ada1p1</span></code></pre></div></div><div class=paragraph><p>Ein leeres Verzeichnis wird als Mountpunkt erstellt, also ein Speicherort für die Montage der neuen Festplatte im originalen Dateisystem:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /newdisk</span></code></pre></div></div><div class=paragraph><p>Abschließend wird ein Eintrag in <span class=filename>/etc/fstab</span> hinzugefügt, damit die neue Festplatte automatisch beim Start eingehängt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1p1	/newdisk      ufs   rw	    2	  2</pre></div></div><div class=paragraph><p>Die neue Festplatte kann manuell montiert werden, ohne das System neu zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /newdisk</span></code></pre></div></div></div></div><div class=sect1><h2 id=disks-growing>17.3. Partitionen vergrößern<a class=anchor href=#disks-growing></a></h2><div class=sectionbody><div class=paragraph><p>Die Kapazität einer Festplatte kann sich ohne Änderungen an bereits vorhandenen Daten erhöhen. Dies geschieht üblicherweise mit virtuellen Maschinen, wenn sich herausstellt, dass die virtuelle Festplatte zu klein ist und vergrößert werden soll. Zuweilen wird auch ein Abbild einer Platte auf einen USB-Stick geschrieben, ohne dabei die volle Kapazität zu nutzen. Dieser Abschnitt beschreibt, wie man Platten vergrößert, bzw. <em>erweitert</em>, um die Vorteile der erhöhten Kapazität zu nutzen.</p></div><div class=paragraph><p>Überprüfen Sie <span class=filename>/var/run/dmesg.boot</span>, um den Gerätenamen der Festplatte zu bestimmen, die vergrößert werden soll. In diesem Beispiel gibt es nur eine SATA-Festplatte im System, so dass die Platte als <span class=filename>ada0</span> angezeigt wird.</p></div><div class=paragraph><p>Um die aktuelle Konfiguration der Partitionen auf der Festplatte anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>      34  83886013  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span> <span class=o>[</span>CORRUPT]
        34       128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
       162  79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
  79691810   4194236     3  freebsd-swap  <span class=o>(</span>2G<span class=o>)</span>
  83886046         1        - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn die Festplatte mit dem <a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>GPT</a>-Partitionsschema formatiert wurde kann es vorkommen, dass sie als "corrupted" angezeigt wird, weil sich die Sicherung der GPT-Partitionstabellen nicht mehr am Ende des Laufwerks befinden. Reparieren Sie in so einem Fall die Partitionstabelle mit <code>gpart</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart recover ada0</span>
ada0 recovered</code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Nun steht der zusätzliche Speicherplatz zur Verfügung und kann verwendet werden, um eine neue Partition anzulegen oder eine bestehende Partition zu erweitern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
   79691810    4194236     3  freebsd-swap  <span class=o>(</span>2G<span class=o>)</span>
   83886046   18513921        - free -  <span class=o>(</span>8.8G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Partitionen können nur auf zusammenhängenden, freien Speicherplatz vergrößert werden. In diesem Beispiel wird die letzte Partition der Platte als Swap-Speicher genutzt, aber die zweite Partition ist die, dessen Größe verändert werden soll. Weil der Swap-Speicher nur temporäre Daten enthält, kann er gefahrlos ausgehangen, gelöscht und nachdem die zweite Partition vergrößert wurde, als dritte Partition neu erstellt werden.</p></div><div class=paragraph><p>Deaktivieren Sie Swap-Speicher Partition:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapoff /dev/ada0p3</span></code></pre></div></div><div class=paragraph><p>Löschen Sie die dritte Partition, angegeben mit dem Schalter <code>-i</code>, der Festplatte <em>ada0</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart delete -i 3 ada0</span>
ada0p3 deleted
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
	79691810   22708157        - free -  <span class=o>(</span>10G<span class=o>)</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Es besteht die Gefahr von Datenverlust, wenn die Partitionstabelle eines eingehangenen Dateisystems verändert wird. Es empfiehlt sich daher, die folgenden Schritte auf einem ausgehangenen Dateisystem durchzuführen, während die Umsetzung über eine Live-CD-ROM oder von einem USB-Gerät erfolgt. Wenn es jedoch absolut notwendig ist, kann ein eingehangenes Dateisystem auch vergrößert werden, nachdem die Sicherheitsfunktionen von GEOM deaktiviert wurden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.debugflags=16</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Vergrößern Sie die Partition und lassen Sie Platz, um die Swap-Partition in der gewünschten Größe neu erstellen zu können. Die zu ändernde Partition wird mit <code>-i</code> und die neue gewünschte Größe mit <code>-s</code> angegeben. Optional wird die Ausrichtung der Partition mit <code>-a</code> festgelegt. Dieser Schritt ändert nur die Größe der Partition. Das Dateisystem innerhalb der Partition wird in einem separaten Schritt erweitert.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart resize -i 2 -s 47G -a 4k ada0</span>
ada0p2 resized
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   98566144     2  freebsd-ufs  <span class=o>(</span>47G<span class=o>)</span>
   98566306    3833661        - free -  <span class=o>(</span>1.8G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Erstellen Sie die Swap-Partition neu und aktivieren Sie sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart add -t freebsd-swap -a 4k ada0</span>
ada0p3 added
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   98566144     2  freebsd-ufs  <span class=o>(</span>47G<span class=o>)</span>
   98566306    3833661     3  freebsd-swap  <span class=o>(</span>1.8G<span class=o>)</span>
<span class=c># swapon /dev/ada0p3</span></code></pre></div></div><div class=paragraph><p>Erweitern Sie das UFS-Dateisystem, um die Kapazität der vergrößerten Partition zu nutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growfs /dev/ada0p2</span>
Device is mounted read-write<span class=p>;</span> resizing will result <span class=k>in </span>temporary write suspension <span class=k>for</span> /.
It<span class=s1>&#39;s strongly recommended to make a backup before growing the file system.
OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes
super-block backups (for fsck -b #) at:
 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432</span></code></pre></div></div><div class=paragraph><p>Wenn das Dateisystem ZFS ist, wird die Größenänderung mit dem Unterkommando <code>online</code> und <code>-e</code> ausgelöst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs online -e zroot /dev/ada0p2</span></code></pre></div></div><div class=paragraph><p>Sowohl die Partition als auch das Dateisystem wurden jetzt vergrößert, um den neu zur Verfügung stehenden Speicherplatz zu nutzen.</p></div></div></div><div class=sect1><h2 id=usb-disks>17.4. USB Speichermedien<a class=anchor href=#usb-disks></a></h2><div class=sectionbody><div class=paragraph><p>Der Universal Serial Bus (USB) wird von vielen externen Speichern benutzt: Festplatten, USB-Thumbdrives sowie von CD- und DVD-Brennern. FreeBSD bietet Unterstützung für Geräte mit USB 1.x, 2.0 und 3.0.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Unterstützung für USB 3.0 ist mit einiger Hardware, einschließlich Haswell (Lynx Point) Chipsätzen, nicht kompatibel. Wenn FreeBSD beim Booten mit dem Fehler <code>failed with error 19</code> abbricht, müssen Sie xHCI/USB3 im BIOS deaktivieren.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Unterstützung für USB-Massenspeicher ist im <span class=filename>GENERIC</span>-Kernel enthalten. Für einen angepassten Kernel müssen die nachstehenden Zeilen in der Kernelkonfigurationsdatei enthalten sein:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus    # SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da
device cd	# needed for CD and DVD burners</pre></div></div><div class=paragraph><p>FreeBSD benutzt den <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a>-Treiber, der das SCSI-Subsystem verwendet um auf USB-Geräte zuzugreifen. Da alle USB-Geräte vom System als SCSI-Geräte erkannt werden, dürfen Sie <em>nicht</em> <code>device atapicam</code> in die Kernelkonfigurationsdatei aufnehmen, wenn es sich bei dem Gerät um einen CD- oder DVD-Brenner handelt.</p></div><div class=paragraph><p>Der übrige Abschnitt beschreibt, wie Sie überprüfen können ob ein USB-Gerät von FreeBSD erkannt wird und wie Sie das Gerät so konfigurieren, dass es verwendet werden kann.</p></div><div class=sect2><h3 id=_konfiguration_von_geräten>17.4.1. Konfiguration von Geräten<a class=anchor href=#_konfiguration_von_geräten></a></h3><div class=paragraph><p>Um die USB-Konfiguration zu testen, schließen Sie das USB-Gerät an. Verwenden Sie <code>dmesg</code> um zu überprüfen, ob das Gerät in den Systemmeldungen erscheint. Dies sollte in etwa so aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: &lt;STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3&gt; on usbus0
umass0:  SCSI over Bulk-Only<span class=p>;</span> quirks <span class=o>=</span> 0x0100
umass0:4:0:-1: Attached to scbus4
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; Fixed Direct Access SCSI-4 device
da0: Serial Number WD-WXE508CAN263
da0: 40.000MB/s transfers
da0: 152627MB <span class=o>(</span>312581808 512 byte sectors: 255H 63S/T 19457C<span class=o>)</span>
da0: <span class=nv>quirks</span><span class=o>=</span>0x2&lt;NO_6_BYTE&gt;</code></pre></div></div><div class=paragraph><p>Fabrikat, Gerätedatei (<span class=filename>da0</span>), Geschwindigkeit und Kapazität werden je nach Gerät unterschiedlich sein.</p></div><div class=paragraph><p>Da ein USB-Gerät als SCSI-Gerät erkannt wird, kann <code>camcontrol</code> benutzt werden, um die mit dem System verbundenen USB-Massenspeicher anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;STECH Simple Drive 1.04&gt;          at scbus4 target 0 lun 0 <span class=o>(</span>pass3,da0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Alternativ kann <code>usbconfig</code> benutzt werden, um die Geräte aufzulisten. Weitere Informationen zu diesem Kommando finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># usbconfig</span>
ugen0.3: &lt;Simple Drive STECH&gt; at usbus0, <span class=nv>cfg</span><span class=o>=</span>0 <span class=nv>md</span><span class=o>=</span>HOST <span class=nv>spd</span><span class=o>=</span>HIGH <span class=o>(</span>480Mbps<span class=o>)</span> <span class=nv>pwr</span><span class=o>=</span>ON <span class=o>(</span>2mA<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Wenn das Gerät noch nicht formatiert ist, finden Sie in <a href=#disks-adding>Hinzufügen von Laufwerken</a> Informationen, wie Sie USB-Laufwerke formatieren und Partitionen einrichten. Wenn das Laufwerk bereits ein Dateisystem enthält, kann es von <code>root</code> nach den Anweisungen in <a href=../basics/#mount-unmount>“Anhängen und Abhängen von Dateisystemen”</a> eingehängt werden.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Aus Sicherheitsgründen sollten Sie Benutzern, denen Sie nicht vertrauen, das Einhängen (z.B. durch die unten beschriebene Aktivierung von <code>vfs.usermount</code>) beliebiger Medien verbieten. Die meisten Dateisysteme wurden nicht entwickelt, um sich vor böswilligen Geräten zu schützen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um auch normalen Anwendern das Einhängen des Laufwerks zu gestatten, könnten Sie beispielsweise mit <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> alle potentiellen Benutzer dieser Gerätedateien in die Gruppe <code>operator</code> aufnehmen. Außerdem muss sichergestellt werden, dass <code>operator</code> Schreib- und Lesezugriff auf diese Gerätedateien haben. Hierfür werden die folgenden Zeilen in <span class=filename>/etc/devfs.rules</span> hinzugefügt:</p></div><div class="literalblock programlisting"><div class=content><pre>[localrules=5]
add path &#39;da*&#39; mode 0660 group operator</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Verfügt das System über interne SCSI-Laufwerke, so verändern Sie die zweite Zeile wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;da[3-9]*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>Dies wird die ersten drei SCSI-Laufwerke (<span class=filename>da0</span> bis <span class=filename>da2</span>) davon ausschließen, in die Gruppe <code>operator</code> aufgenommen zu werden. Ersetzen Sie <code>3</code> durch die Anzahl der SCSI-Laufwerke. Weitere Informationen zu dieser Datei finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Aktivieren Sie nun die Regeln in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;localrules&#34;</pre></div></div><div class=paragraph><p>Als nächstes müssen Sie das System anweisen, auch normalen Benutzern das mounten von Dateisystemen zu erlauben, indem Sie die folgende Zeile in <span class=filename>/etc/sysctl.conf</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>vfs.usermount=1</pre></div></div><div class=paragraph><p>Da diese Einstellung erst nach einem Neustart wirksam wird, können Sie diese Variable mit <code>sysctl</code> auch direkt setzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1</code></pre></div></div><div class=paragraph><p>Zuletzt müssen Sie noch ein Verzeichnis anlegen, in das das USB-Laufwerk eingehängt werden soll. Dieses Verzeichnis muss dem Benutzer gehören, der das USB-Laufwerk in den Verzeichnisbaum einhängen will. Dazu legen Sie als <code>root</code> ein Unterverzeichnis <span class=filename>/mnt/username</span> an, wobei Sie <em>username</em> durch den Login des jeweiligen Benutzers sowie <em>usergroup</em> durch die primäre Gruppe des Benutzers ersetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /mnt/username</span>
<span class=c># chown username:usergroup /mnt/username</span></code></pre></div></div><div class=paragraph><p>Wenn Sie nun beispielsweise einen USB-Stick anschließen, wird automatisch die Gerätedatei <span class=filename>/dev/da0s1</span> erzeugt. Ist das Gerät mit einem FAT-Dateisystem formatiert, kann es der Benutzer mit dem folgenden Befehl in den Verzeichnisbaum einhängen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mount <span class=nt>-t</span> msdosfs <span class=nt>-o</span> <span class=nt>-m</span><span class=o>=</span>644,-M<span class=o>=</span>755 /dev/da0s1 /mnt/username</code></pre></div></div><div class=paragraph><p>Bevor das Gerät entfernt werden kann, <em>muss</em> es abgehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt/username</span></code></pre></div></div><div class=paragraph><p>Nach Entfernen des Geräts stehen in den Systemmeldungen Einträge, ähnlich der folgenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: at uhub3, port 2, addr 3 <span class=o>(</span>disconnected<span class=o>)</span>
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; s/n WD-WXE508CAN263          detached
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: Periph destroyed</code></pre></div></div></div><div class=sect2><h3 id=_automatisches_einhängen_von_wechselmedien>17.4.2. Automatisches Einhängen von Wechselmedien<a class=anchor href=#_automatisches_einhängen_von_wechselmedien></a></h3><div class=paragraph><p>Damit USB-Geräte automatisch eingehängt werden, muss der Kommentar für folgende Zeile in <span class=filename>/etc/auto_master</span> entfernt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/media		<span class=nt>-media</span>		<span class=nt>-nosuid</span></code></pre></div></div><div class=paragraph><p>Anschließend fügen Sie folgende Zeilen in <span class=filename>/etc/devd.conf</span> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>notify 100 <span class=o>{</span>
	match <span class=s2>&#34;system&#34;</span> <span class=s2>&#34;GEOM&#34;</span><span class=p>;</span>
	match <span class=s2>&#34;subsystem&#34;</span> <span class=s2>&#34;DEV&#34;</span><span class=p>;</span>
	action <span class=s2>&#34;/usr/sbin/automount -c&#34;</span><span class=p>;</span>
<span class=o>}</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Falls <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> bereits ausgeführt werden, müssen Sie die Konfiguration neu einlesen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount restart</span>
<span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> wird beim Booten automatisch gestartet, wenn Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>autofs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Damit <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> funktioniert, muss <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> aktiviert sein, was aber in der Voreinstellung der Fall ist.</p></div><div class=paragraph><p>Starten Sie jetzt die Dienste:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount start</span>
<span class=c># service automountd start</span>
<span class=c># service autounmountd start</span>
<span class=c># service devd start</span></code></pre></div></div><div class=paragraph><p>Jedes Dateisystem, das automatisch eingehängt werden kann, erscheint als ein Verzeichnis unterhalb von <span class=filename>media</span>. Das Verzeichnis wird nach dem Dateisystemlabel benannt, bzw. nach dem Gerätenamen, falls kein Label existiert.</p></div><div class=paragraph><p>Das Dateisystem wird transparent beim ersten Zugriff in den Verzeichnisbaum eingehängt und auch nach gewisser Zeit der Inaktivität wieder ausgehängt. Laufwerke können auch manuell ausgehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># automount -fu</span></code></pre></div></div><div class=paragraph><p>Diese Methode wird in der Regel bei Speicherkarten und USB-Sticks verwendet. Sie funktioniert aber mit allen Blockgeräten, einschließlich optischen Laufwerken und iSCSI-LUNs.</p></div></div></div></div><div class=sect1><h2 id=creating-cds>17.5. Erstellen und Verwenden von CDs<a class=anchor href=#creating-cds></a></h2><div class=sectionbody><div class=paragraph><p>CDs besitzen einige Eigenschaften, die sie von konventionellen Laufwerken unterscheiden. Sie wurden so entworfen, dass sie ununterbrochen, ohne Verzögerungen durch Kopfbewegungen zwischen den Spuren, gelesen werden können. CDs besitzen Spuren, aber damit ist der Teil Daten gemeint, der ununterbrochen gelesen wird, und nicht eine physikalische Eigenschaft der CD. Das ISO 9660-Dateisystem wurde entworfen, um mit diesen Unterschieden umzugehen.</p></div><div class=paragraph><p>Die FreeBSD Ports-Sammlung bietet einige Werkzeuge zum Brennen und Kopieren von Audio- und Daten-CDs. Dieses Kapitel beschreibt die Verwendung von mehreren Kommandozeilen-Werkzeugen. Wenn Sie eine graphische Oberfläche zum Brennen von CDs benutzen, können Sie <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xcdroast/>sysutils/xcdroast</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a> installieren.</p></div><div class=sect2><h3 id=atapicam>17.5.1. Unterstützte Geräte<a class=anchor href=#atapicam></a></h3><div class=paragraph><p>Der <span class=filename>GENERIC</span>-Kernel enthält Unterstützung für SCSI, USB und ATAPICD Lesegeräte und Brenner. Wird ein angepasster Kernel erstellt, unterscheiden sich die Optionen für die Kernelkonfigurationsdatei je nach Art des Geräts.</p></div><div class=paragraph><p>Für einen SCSI-Brenner müssen folgende Optionen vorhanden sein:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	  # SCSI bus (required for ATA/SCSI)
device da	  # Direct Access (disks)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd	  # needed for CD and DVD burners</pre></div></div><div class=paragraph><p>Für einen USB-Brenner müssen folgende Optionen vorhanden sein:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	  # SCSI bus (required for ATA/SCSI)
device da	  # Direct Access (disks)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd&gt;	  # needed for CD and DVD burners
device uhci	  # provides USB 1.x support
device ohci	  # provides USB 1.x support
device ehci	  # provides USB 2.0 support
device xhci	  # provides USB 3.0 support
device usb	  # USB Bus (required)
device umass	  # Disks/Mass storage - Requires scbus and da</pre></div></div><div class=paragraph><p>Für einen ATAPI-Brenner müssen folgende Optionen vorhanden sein:</p></div><div class="literalblock programlisting"><div class=content><pre>device ata	  # Legacy ATA/SATA controllers
device scbus	  # SCSI bus (required for ATA/SCSI)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd	  # needed for CD and DVD burners</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Unter FreeBSD Versionen kleiner 10.x wird auch diese Option in der Kernelkonfigurationsdatei benötigt, falls der Brenner ein ATAPI-Gerät ist:</p></div><div class="literalblock programlisting"><div class=content><pre>device atapicam</pre></div></div><div class=paragraph><p>Alternativ kann folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzugefügt werden, um den Treiber beim Booten automatisch zu laden:</p></div><div class="literalblock programlisting"><div class=content><pre>atapicam_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Hierzu ist ein Neustart des Systems erforderlich, da dieser Treiber nur beim Booten geladen werden kann.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Mit <code>dmesg</code> können Sie prüfen, ob das Gerät von FreeBSD erkannt wurde. Unter FreeBSD Versionen kleiner 10.x lautet der Gerätename <span class=filename>acd0</span> anstelle von <span class=filename>cd0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% dmesg | <span class=nb>grep cd
</span>cd0 at ahcich1 bus 0 scbus1 target 0 lun 0
cd0: &lt;HL-DT-ST DVDRAM GU70N LT20&gt; Removable CD-ROM SCSI-0 device
cd0: Serial Number M3OD3S34152
cd0: 150.000MB/s transfers <span class=o>(</span>SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes<span class=o>)</span>
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</code></pre></div></div></div><div class=sect2><h3 id=cdrecord>17.5.2. Eine CD brennen<a class=anchor href=#cdrecord></a></h3><div class=paragraph><p>Unter FreeBSD kann <code>cdrecord</code> zum Brennen von CDs benutzt werden. Dieses Programm wird aus dem Port oder Paket <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> installiert.</p></div><div class=paragraph><p>Obwohl <code>cdrecord</code> viele Optionen besitzt, ist die grundlegende Benutzung sehr einfach. Geben Sie den Namen der zu brennenden ISO-Datei an. Wenn das System über mehrere Brenner verfügt, müssen Sie auch den Namen des Gerätes angeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord dev=device imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie <code>-scanbus</code> um den Gerätenamen des Brenners zu bestimmen. Die Ausgabe könnte wie folgt aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord -scanbus</span>
ProDVD-ProBD-Clone 3.00 <span class=o>(</span>amd64-unknown-freebsd10.0<span class=o>)</span> Copyright <span class=o>(</span>C<span class=o>)</span> 1995-2010 Jörg Schilling
Using libscg version <span class=s1>&#39;schily-0.9&#39;</span>
scsibus0:
        0,0,0     0<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39236LW       &#39;</span> <span class=s1>&#39;0004&#39;</span> Disk
        0,1,0     1<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39173W        &#39;</span> <span class=s1>&#39;5958&#39;</span> Disk
        0,2,0     2<span class=o>)</span> <span class=k>*</span>
        0,3,0     3<span class=o>)</span> <span class=s1>&#39;iomega  &#39;</span> <span class=s1>&#39;jaz 1GB         &#39;</span> <span class=s1>&#39;J.86&#39;</span> Removable Disk
        0,4,0     4<span class=o>)</span> <span class=s1>&#39;NEC     &#39;</span> <span class=s1>&#39;CD-ROM DRIVE:466&#39;</span> <span class=s1>&#39;1.26&#39;</span> Removable CD-ROM
        0,5,0     5<span class=o>)</span> <span class=k>*</span>
        0,6,0     6<span class=o>)</span> <span class=k>*</span>
        0,7,0     7<span class=o>)</span> <span class=k>*</span>
scsibus1:
        1,0,0   100<span class=o>)</span> <span class=k>*</span>
        1,1,0   101<span class=o>)</span> <span class=k>*</span>
        1,2,0   102<span class=o>)</span> <span class=k>*</span>
        1,3,0   103<span class=o>)</span> <span class=k>*</span>
        1,4,0   104<span class=o>)</span> <span class=k>*</span>
        1,5,0   105<span class=o>)</span> <span class=s1>&#39;YAMAHA  &#39;</span> <span class=s1>&#39;CRW4260         &#39;</span> <span class=s1>&#39;1.0q&#39;</span> Removable CD-ROM
        1,6,0   106<span class=o>)</span> <span class=s1>&#39;ARTEC   &#39;</span> <span class=s1>&#39;AM12S           &#39;</span> <span class=s1>&#39;1.06&#39;</span> Scanner
        1,7,0   107<span class=o>)</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie die drei durch Kommas separierten Zahlen, die für den CD-Brenner angegeben sind, als Argument für <code>dev</code>. Im Beispiel ist das Yamaha-Gerät <code>1,5,0</code>, so dass die passende Eingabe <code>dev=1,5,0</code> ist. Einfachere Wege das Argument anzugeben, sowie Informationen über Audiospuren und das Einstellen der Geschwindigkeit, sind in der Manualpage von <code>cdrecord</code> beschrieben.</p></div><div class=paragraph><p>Alternativ können Sie den folgenden Befehl ausführen, um die Geräteadresse des Brenners zu ermitteln:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 <span class=o>(</span>cd0,pass0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Verwenden Sie die numerischen Werte für <code>scbus</code>, <code>target</code> und <code>lun</code>. Für dieses Beispiel wäre <code>1,0,0</code> als Gerätename zu verwenden.</p></div></div><div class=sect2><h3 id=mkisofs>17.5.3. Daten auf ISO-Dateisystem schreiben<a class=anchor href=#mkisofs></a></h3><div class=paragraph><p>Die Datendateien müssen vorbereitet sein, bevor sie auf eine CD gebrannt werden. In FreeBSD wird <code>mkisofs</code> vom Paket oder Port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> installiert. Dieses Programm kann aus einem UNIX® Verzeichnisbaum ein ISO 9660-Dateisystem erzeugen. Im einfachsten Fall müssen Sie lediglich den Namen der zu erzeugenden ISO-Datei und den Pfad zu den Dateien angeben, die auf dem ISO 9660-Dateisystem platziert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -o imagefile.iso /path/to/tree</span></code></pre></div></div><div class=paragraph><p>Bei diesem Kommando werden die Dateinamen auf Namen abgebildet, die den Restriktionen des ISO 9660-Dateisystem entsprechen. Dateien, die diesem Standard nicht entsprechen bleiben unberücksichtigt.</p></div><div class=paragraph><p>Es gibt einige Optionen, um die Beschränkungen dieses Standards zu überwinden. Die unter UNIX® Systemen üblichen Rock-Ridge-Erweiterungen werden durch <code>-R</code> aktiviert und <code>-J</code> aktiviert die von Microsoft® Systemen benutzten Joliet-Erweiterungen.</p></div><div class=paragraph><p>Für CDs, die nur auf FreeBSD-Systemen verwendet werden sollen, kann <code>-U</code> genutzt werden, um alle Beschränkungen für Dateinamen aufzuheben. Zusammen mit <code>-R</code> wird ein Abbild des Dateisystems, identisch zu angegebenen FreeBSD-Dateibaum erstellt, selbst wenn dies den ISO 9660 Standard verletzt.</p></div><div class=paragraph><p>Die letzte übliche Option ist <code>-b</code>. Sie wird benutzt, um den Ort eines Bootimages einer "El Torito" bootbaren CD anzugeben. Das Argument zu dieser Option ist der Pfad zu einem Bootimage ausgehend von der Wurzel des Baumes, der auf die CD geschrieben werden soll. In der Voreinstellung erzeugt <code>mkisofs</code> ein ISO-Image im "Diskettenemulations"-Modus. Dabei muss das Image genau 1200, 1440 oder 2880 KB groß sein. Einige Bootloader, darunter der auf den FreeBSD Installationsmedien verwendete, kennen keinen Emulationsmodus. Daher sollte in diesen Fällen <code>-no-emul-boot</code> verwendet werden. Wenn <span class=filename>/tmp/myboot</span> ein bootbares FreeBSD-System enthält, dessen Bootimage sich in <span class=filename>/tmp/myboot/boot/cdboot</span> befindet, dann würde folgendes Kommando <span class=filename>/tmp/bootable.iso</span> erstellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</span></code></pre></div></div><div class=paragraph><p>Das resultierende ISO-Abbild kann als speicherbasiertes Laufwerk eingehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Jetzt können Sie überprüfen, dass <span class=filename>/mnt</span> und <span class=filename>/tmp/myboot</span> identisch sind.</p></div><div class=paragraph><p>Sie können das Verhalten von <code>mkisofs</code> mit einer Vielzahl von Optionen beeinflussen. Details dazu entnehmen Sie bitte <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es ist möglich eine Daten-CD in eine Datei zu kopieren, die einem Image entspricht, das mit <code>mkisofs</code> erstellt wurde. Verwenden Sie dazu <code>dd</code> mit dem Gerätenamen als Eingabedatei und den Namen der ISO als Ausgabedatei:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/cd0 of=file.iso bs=2048</span></code></pre></div></div><div class=paragraph><p>Das resultierende Abbild kann auf eine CD gebrannt werden, wie in <a href=#cdrecord>Eine CD brennen</a> beschrieben.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mounting-cd>17.5.4. Einhängen von Daten-CDs<a class=anchor href=#mounting-cd></a></h3><div class=paragraph><p>Sobald ein Abbild auf eine CD gebrannt wurde, kann es durch Angabe des Dateisystemtyp, des CD-Laufwerks und des Mountpunktes eingehangen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Da <code>mount</code> davon ausgeht, dass ein Dateisystem vom Typ <code>ufs</code> ist, würde die Fehlermeldung <code>Incorrect super block</code> erscheinen, wenn Sie beim Einhängen einer Daten-CD auf die Angabe <code>-t cd9660</code> verzichten.</p></div><div class=paragraph><p>Auf diese Weise können Daten-CDs von jedem Hersteller verwendet werden. Es kann allerdings zu Problemen mit CDs kommen, die verschiedene ISO 9660-Erweiterungen benutzen. So speichern Joliet-CDs alle Dateinamen unter Verwendung von zwei Byte langen Unicode-Zeichen. Tauchen statt bestimmter Zeichen nur Fragezeichen auf, so muss über die Option <code>-C</code> der benötigte Zeichensatz angegeben werden. Weitere Informationen zu diesem Problem finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Damit der Kernel diese Zeichenkonvertierung (festgelegt durch die Option <code>-C</code>) erkennt, müssen Sie das Kernelmodul <span class=filename>cd9660_iconv.ko</span> laden. Dazu fügen Sie folgende Zeile in <span class=filename>loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>cd9660_iconv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Danach müssen Sie allerdings Ihr System neu starten. Alternativ können Sie das Kernelmodul auch direkt über <code>kldload</code> laden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Manchmal werden Sie die Meldung <code>Device not configured</code> erhalten, wenn Sie versuchen, eine Daten-CD einzuhängen. Für gewöhnlich liegt das daran, dass das Laufwerk keine CD erkannt hat, oder dass das Laufwerk auf dem Bus nicht erkannt wird. Es kann einige Sekunden dauern, bevor das Laufwerk die CD erkennt. Seien Sie also geduldig.</p></div><div class=paragraph><p>Manchmal wird ein SCSI-CD nicht erkannt, weil es keine Zeit hatte, auf das Zurücksetzen des Busses zu antworten. Um dieses Problem zu lösen, fügen Sie die folgende Zeile in die Kernelkonfiguration ein und erstellen Sie einen angepassten Kernel nach den Anweisungen in <a href=../kernelconfig/#kernelconfig-building>“Einen angepassten Kernel bauen und installieren”</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options SCSI_DELAY=15000</pre></div></div><div class=paragraph><p>Die Zeile bewirkt, dass nach dem Zurücksetzen des SCSI-Busses beim Booten 15 Sekunden gewartet wird, um dem CD-Laufwerk genügend Zeit zu geben, darauf zu antworten.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es ist möglich eine Datei auch direkt auf eine CD zu brennen, ohne vorher auf ihr ein ISO 9660-Dateisystem einzurichten. Man sagt auch, Daten werden roh auf die CD gebrannt. Einige Leute nutzen dies, um Datensicherungen durchzuführen.</p></div><div class=paragraph><p>Eine auf diese Weise gefertigte Daten-CD kann nicht in das Dateisystem eingehangen werden. Um auf die Daten einer solchen CD zuzugreifen, müssen die Daten vom rohen Gerät gelesen werden. Beispielsweise würde dieser Befehl eine komprimierte tar-Datei auf dem zweiten CD-Laufwerk in das aktuelle Verzeichnis extrahieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /dev/cd1</span></code></pre></div></div><div class=paragraph><p>Um eine Daten-CD in das System einzuhängen, müssen die Daten mit <code>mkisofs</code> geschrieben werden.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=duplicating-audiocds>17.5.5. Kopieren von Audio-CDs<a class=anchor href=#duplicating-audiocds></a></h3><div class=paragraph><p>Um eine Kopie einer Audio-CD zu erstellen, kopieren Sie die Stücke der CD in einzelne Dateien und brennen diese Dateien dann auf eine leere CD.</p></div><div class=paragraph><p><a href=#using-cdrecord>Procedure: Eine Audio-CD kopieren</a> beschreibt, wie eine Audio-CD kopiert und gebrannt wird. Wenn die Version älter als FreeBSD 10.0 ist und ein ATAPI-Gerät verwendet wird, muss zunächst das Modul <code>atapicam</code> nach den Anweisungen in <a href=#atapicam>Unterstützte Geräte</a> geladen werden.</p></div><div id=using-cdrecord class="olist arabic procedure"><div class=title>Procedure: Eine Audio-CD kopieren</div><ol class=arabic><li><p>Der Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> installiert <code>cdda2wav</code>. Mit diesem Kommando können Audiodaten in das aktuelle Verzeichnis extrahiert werden, wobei jede Datei in eine separate WAV-Datei geschrieben wird:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdda2wav <span class=nt>-vall</span> <span class=nt>-B</span> <span class=nt>-Owav</span></code></pre></div></div><div class=paragraph><p>Wenn das System nur über ein CD-Laufwerk verfügt, muss der Gerätename nicht angegeben werden. Lesen Sie die Manualpage von <code>cdda2wav</code> für Anweisungen, wie ein Gerät spezifiziert wird und weitere verfügbare Optionen für dieses Kommando.</p></div></li><li><p>Die erzeugten <span class=filename>.wav</span> Dateien schreiben Sie mit <code>cdrecord</code> auf eine leere CD:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdrecord <span class=nt>-v</span> <span class=nv>dev</span><span class=o>=</span>2,0 <span class=nt>-dao</span> <span class=nt>-useinfo</span> <span class=k>*</span>.wav</code></pre></div></div><div class=paragraph><p>Das Argument von <code>dev</code> gibt das verwendete Gerät an, das wie in <a href=#cdrecord>Eine CD brennen</a> ermittelt werden kann.</p></div></li></ol></div></div></div></div><div class=sect1><h2 id=creating-dvds>17.6. DVDs benutzen<a class=anchor href=#creating-dvds></a></h2><div class=sectionbody><div class=paragraph><p>Nach der CD ist die DVD die nächste Generation optischer Speichermedien. Auf einer DVD können mehr Daten als auf einer CD gespeichert werden. DVDs werden als Standardmedium für Videos verwendet.</p></div><div class=paragraph><p>Für beschreibbare DVDs existieren fünf Medienformate:</p></div><div class=ulist><ul><li><p>DVD-R: Dies war das erste verfügbare Format. Das Format wurde vom <a href=http://www.dvdforum.org/forum.shtml>DVD-Forum</a> festgelegt. Die Medien sind nur einmal beschreibbar.</p></li><li><p>DVD-RW: Dies ist die wiederbeschreibbare Version des DVD-R Standards. Eine DVD-RW kann ungefähr 1000 Mal beschrieben werden.</p></li><li><p>DVD-RAM: Dies ist ein wiederbeschreibbares Format, das wie ein Wechsellaufwerk betrachtet werden kann. Allerdings sind die Medien nicht kompatibel zu den meisten DVD-ROM-Laufwerken und DVD-Video-Spielern, da das DVD-RAM-Format nur von wenigen Brennern unterstützt wird. Informationen zur Nutzung von DVD-RAM finden Sie in <a href=#creating-dvd-ram>DVD-RAM</a>.</p></li><li><p>DVD+RW: Ist ein wiederbeschreibbares Format, das von der <a href=https://de.wikipedia.org/wiki/DVD%2BRW_Alliance>DVD+RW Alliance</a> festgelegt wurde. Eine DVD+RW kann ungefähr 1000 Mal beschrieben werden.</p></li><li><p>DVD+R: Dieses Format ist die nur einmal beschreibbare Variante des DVD+RW Formats.</p></li></ul></div><div class=paragraph><p>Auf einer einfach beschichteten DVD können 4.700.000.000 Bytes gespeichert werden. Das sind 4,38 GB oder 4485 MB (1 Kilobyte sind 1024 Bytes).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die physischen Medien sind unabhängig von der Anwendung. Ein DVD-Video ist eine spezielle Anordnung von Dateien, die auf irgendein Medium, beispielsweise DVD-R, DVD+R oder DVD-RW geschrieben werden kann. Bevor Sie ein Medium auswählen, müssen Sie sicherstellen, dass der Brenner und der DVD-Spieler mit dem Medium umgehen können.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_konfiguration>17.6.1. Konfiguration<a class=anchor href=#_konfiguration></a></h3><div class=paragraph><p>Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>, um DVDs zu beschreiben. Das Kommando ist Bestandteil von <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dvd+rw-tools/>sysutils/dvd+rw-tools</a>, und kann mit allen DVD-Medien umgehen.</p></div><div class=paragraph><p>Diese Werkzeuge verwenden das SCSI-Subsystem, um auf die Geräte zuzugreifen. Daher muss <a href=#atapicam>ATAPI/CAM-Unterstützung</a> geladen, oder statisch in den Kernel kompiliert werden. Sollte der Brenner jedoch die USB-Schnittstelle nutzen, wird diese Unterstützung nicht benötigt. Weitere Informationen zur Konfiguration von USB-Geräten finden Sie in <a href=#usb-disks>USB Speichermedien</a>.</p></div><div class=paragraph><p>Für ATAPI-Geräte müssen ebenfalls DMA-Zugriffe aktiviert werden. Dazu wird die folgende Zeile in <span class=filename>/boot/loader.conf</span> eingefügt:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Bevor Sie dvd+rw-tools benutzen, lesen Sie bitte die Hardware-Informationen auf der Seite <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html>Hardware Compatibility Notes</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Für eine grafische Oberfläche sollten Sie sich <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a> ansehen, das eine benutzerfreundliche Schnittstelle zu <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> und vielen anderen Werkzeugen bietet.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_daten_dvds_brennen>17.6.2. Daten-DVDs brennen<a class=anchor href=#_daten_dvds_brennen></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> erstellt mit dem Programm <a href=#mkisofs>mkisofs</a> das Dateisystem und brennt anschließend die DVD. Vor dem Brennen braucht daher kein Abbild der Daten erstellt zu werden.</p></div><div class=paragraph><p>Wenn Sie von den Daten im Verzeichnis <span class=filename>/path/to/data</span> eine DVD+R oder eine DVD-R brennen wollen, benutzen Sie das nachstehende Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>In diesem Beispiel wird <code>-J -R</code> an <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> durchgereicht und dient zum Erstellen des Dateisystems (hier: ein ISO-9660-Dateisystem mit Joliet- und Rock-Ridge-Erweiterungen). Weiteres entnehmen Sie bitte der Hilfeseite <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div><div class=paragraph><p>Die Option <code>-Z</code> wird für die erste Aufnahme einer Single- oder Multisession benötigt. Ersetzen Sie <em>/dev/cd0</em> mit dem Gerätenamen des DVD-Gerätes. Die Nutzung von <code>-dvd-compat</code> schließt das Medium, weitere Daten können danach nicht mehr angehängt werden. Dies sollte auch eine bessere Kompatibilität mit anderen DVD-ROM-Laufwerken bieten.</p></div><div class=paragraph><p>Um ein vorher erstelltes Abbild der Daten zu brennen, beispielsweise <em>imagefile.iso</em>, verwenden Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Die Schreibgeschwindigkeit hängt von den verwendeten Medium sowie dem verwendeten Gerät ab und sollte automatisch gesetzt werden. Um die Schreibgeschwindigkeit vorzugeben, verwenden Sie <code>-speed=</code>. Beispiele finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um größere Dateien als 4.38GB zu unterstützen, ist es notwendig ein UDF/ISO-9660 Hybrid-Dateisystem zu erstellen. Dieses Dateisystem muss mit zusätzlichen Parametern <code>-udf -iso-level 3</code> bei <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> und allen relevanten Programmen, wie beispielsweise <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>) erzeugt werden. Dies ist nur notwendig, wenn Sie ein ISO-Image erstellen oder direkt auf eine DVD schreiben wollen. DVDs, die in dieser Weise hergestellt worden sind, müssen als UDF-Dateisystem mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_udf&amp;sektion=8&amp;format=html">mount_udf(8)</a> eingehangen werden. Sie sind nur auf Betriebssystemen, die UDF unterstützen brauchbar, ansonsten sieht es so aus, als ob sie kaputte Dateien enthalten würden.</p></div><div class=paragraph><p>Um diese Art von ISO-Datei zu erstellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mkisofs <span class=nt>-R</span> <span class=nt>-J</span> <span class=nt>-udf</span> <span class=nt>-iso-level</span> 3 <span class=nt>-o</span> imagefile.iso /path/to/data</code></pre></div></div><div class=paragraph><p>Um Daten direkt auf eine DVD zu brennen, geben Sie den folgenden Befehl ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Wenn ein ISO-Abbild bereits große Dateien enthält, sind keine weiteren Optionen für <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> notwendig, um das Abbild auf die DVD zu brennen.</p></div><div class=paragraph><p>Achten Sie darauf, eine aktuelle Version von <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> zu verwenden, welche <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> enthält, da ältere Versionen keinen Support für große Dateien enthalten. Falls die neueste Version nicht funktioniert, installieren Sie <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools-devel/>sysutils/cdrtools-devel</a> und lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_dvd_videos_brennen>17.6.3. DVD-Videos brennen<a class=anchor href=#_dvd_videos_brennen></a></h3><div class=paragraph><p>Ein DVD-Video ist eine spezielle Anordnung von Dateien, die auf den ISO-9660 und den micro-UDF (M-UDF) Spezifikationen beruht. Da DVD-Video auf eine bestimmte Datei-Hierarchie angewiesen ist, müssen DVDs mit speziellen Programmen wie <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a> erstellt werden.</p></div><div class=paragraph><p>Ist bereits ein Abbild des Dateisystems eines DVD-Videos vorhanden, kann es auf die gleiche Weise wie jedes andere Abbild gebrannt werden. Wenn <code>dvdauthor</code> verwendet wurde, um die DVD zu erstellen und die Resultate in <span class=filename>/path/to/video</span> liegen, kann das folgende Kommando verwendet werden, um ein DVD-Video zu brennen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -dvd-video /path/to/video</span></code></pre></div></div><div class=paragraph><p><code>-dvd-video</code> wird an <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> weitergereicht, um die Datei-Hierarchie für ein DVD-Video zu erstellen. Weiterhin bewirkt diese Option, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> mit <code>-dvd-compat</code> aufgerufen wird.</p></div></div><div class=sect2><h3 id=_dvdrw_medien_benutzen>17.6.4. DVD+RW-Medien benutzen<a class=anchor href=#_dvdrw_medien_benutzen></a></h3><div class=paragraph><p>Im Gegensatz zu CD-RW-Medien müssen DVD+RW-Medien erst formatiert werden, bevor sie benutzt werden können. Es wird <em>empfohlen</em> <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> einzusetzen, da das Programm Medien automatisch formatiert, wenn es erforderlich ist. Es ist jedoch möglich, auch <code>dvd+rw-format</code> zu nutzen, um die DVD+RW zu formatieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Dieser Vorgang muss nur einmal durchgeführt werden. Denken Sie daran, dass nur neue DVD+RWs formatiert werden müssen. Anschließend können DVD+RWs, wie gewohnt gebrannt werden.</p></div><div class=paragraph><p>Wenn Sie auf einer DVD+RW ein neues Dateisystem erstellen wollen, brauchen Sie die DVD+RW vorher nicht zu löschen. Überschreiben Sie einfach das vorige Dateisystem indem Sie eine neue Session anlegen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/newdata</span></code></pre></div></div><div class=paragraph><p>Das DVD+RW-Format erlaubt es, Daten an eine vorherige Aufnahme anzuhängen. Dazu wird eine neue Session mit der schon bestehenden zusammengeführt. Es wird keine Multi-Session geschrieben, sondern <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> <em>vergrößert</em> das ISO-9660-Dateisystem auf dem Medium.</p></div><div class=paragraph><p>Das folgende Kommando fügt weitere Daten zu einer vorher erstellten DVD+RW hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>Wenn Sie eine DVD+RW erweitern, verwenden Sie dieselben <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>-Optionen wie beim Erstellen der DVD+RW.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Verwenden Sie <code>-dvd-compat</code>, um bessere Kompatibilität mit DVD-ROM-Laufwerken zu gewährleisten. Zu einem DVD+RW-Medium können Sie mit dieser Option auch weiterhin Daten hinzufügen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um das Medium zu löschen, verwenden Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0=/dev/zero</span></code></pre></div></div></div><div class=sect2><h3 id=_dvd_rw_medien_benutzen>17.6.5. DVD-RW-Medien benutzen<a class=anchor href=#_dvd_rw_medien_benutzen></a></h3><div class=paragraph><p>Eine DVD-RW kann mit zwei Methoden beschrieben werden: <em>Sequential-Recording</em> oder <em>Restricted-Overwrite</em>. Voreingestellt ist Sequential-Recording.</p></div><div class=paragraph><p>Eine neue DVD-RW kann direkt beschrieben werden; sie muss nicht vorher formatiert werden. Allerdings muss eine DVD-RW, die mit Sequential-Recording aufgenommen wurde, zuerst gelöscht werden, bevor eine neue Session aufgenommen werden kann.</p></div><div class=paragraph><p>Der folgende Befehl löscht eine DVD-RW im Sequential-Recording-Modus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das vollständige Löschen mit <code>-blank=full</code> dauert mit einem 1x Medium ungefähr eine Stunde. Wenn die DVD-RW im Disk-At-Once-Modus (DAO) aufgenommen wurde, kann sie mit <code>-blank</code> schneller gelöscht werden. Um eine DVD-RW im DAO-Modus zu brennen, benutzen Sie das folgende Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Die Option <code>-use-the-force-luke=dao</code> sollte nicht erforderlich sein, da <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> den DAO-Modus automatisch erkennt.</p></div><div class=paragraph><p>Der Restricted-Overwrite-Modus sollte mit jeder DVD-RW verwendet werden, da er flexibler als der voreingestellte Sequential-Recording-Modus ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um Daten auf eine DVD-RW im Sequential-Recording-Modus zu schreiben, benutzen Sie dasselbe Kommando wie für die anderen DVD-Formate:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Um weitere Daten zu einer Aufnahme hinzuzufügen, benutzen Sie <code>-M</code> mit <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. Werden die Daten im Sequential-Recording-Modus hinzugefügt, wird eine neue Session erstellt. Das Ergebnis ist ein Multi-Session-Medium.</p></div><div class=paragraph><p>Eine DVD-RW im Restricted-Overwrite-Modus muss nicht gelöscht werden, um eine neue Session aufzunehmen. Das Medium kann einfach mit <code>-Z</code> überschrieben werden. Mit <code>-M</code> kann das ISO-9660-Dateisystem, wie mit einer DVD+RW, vergrößert werden. Die DVD enthält danach eine Session.</p></div><div class=paragraph><p>Benutzen sie das nachstehende Kommando, um den Restricted-Overwrite-Modus einzustellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Das folgende Kommando stellt den Modus wieder auf Sequential-Recording zurück:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div></div><div class=sect2><h3 id=_multi_session>17.6.6. Multi-Session<a class=anchor href=#_multi_session></a></h3><div class=paragraph><p>Nur wenige DVD-ROM-Laufwerke unterstützen Multi-Session-DVDs und lesen meist nur die erste Session. Mehrere Sessions werden von DVD+R, DVD-R und DVD-RW im Sequential-Recording-Modus unterstützt. Im Modus Restricted-Overwrite gibt nur eine Session.</p></div><div class=paragraph><p>Wenn das Medium noch nicht geschlossen ist, erstellt das nachstehende Kommando eine neue Session auf einer DVD+R, DVD-R oder DVD-RW im Sequential-Recording-Modus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>Wird dieses Kommando mit DVD+RW- oder DVD-RW-Medien im Restricted-Overwrite-Modus benutzt, werden die neuen Daten mit den Daten der bestehenden Session zusammengeführt. Das Medium enthält danach eine Session. Nutzen Sie diese Methode, um neue Daten zu einer bestehenden Session hinzuzufügen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Für den Anfang und das Ende einer Session wird auf dem Medium zusätzlicher Platz verbraucht. Um den Speicherplatz auf dem Medium optimal auszunutzen, sollten Sie daher Sessions mit vielen Daten hinzufügen. Auf ein DVD+R-Medium passen maximal 154 Sessions, 2000 Sessions auf ein DVD-R-Medium und 127 Sessions auf eine DVD+R Double Layer.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_weiterführendes>17.6.7. Weiterführendes<a class=anchor href=#_weiterführendes></a></h3><div class=paragraph><p><code>dvd+rw-mediainfo <em>/dev/cd0</em></code> zeigt Informationen über eine im Laufwerk liegende DVD an.</p></div><div class=paragraph><p>Weiteres zu dvd+rw-tools finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>, auf der <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/>dvd+rw-tools Web-Seite</a> und in den Archiven der <a href=http://lists.debian.org/cdwrite/>cdwrite-Mailingliste</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie einen Problembericht zur Nutzung der dvd+rw-tools erstellen, fügen Sie immer die Ausgabe von <code>dvd+rw-mediainfo</code> hinzu.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=creating-dvd-ram>17.6.8. DVD-RAM<a class=anchor href=#creating-dvd-ram></a></h3><div class=paragraph><p>DVD-RAM-fähige Brenner nutzten die SCSI- oder ATAPI-Schnittstelle. Für ATAPI-Geräte muss der DMA-Modus aktiviert werden, indem die folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzugefügt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Eine DVD-RAM kann mit einer Wechselplatte verglichen werden. Wie diese, muss auch eine DVD-RAM vor dem ersten Einsatz formatiert werden. In diesem Beispiel wird das gesamte Medium mit dem Standard-UFS2-Dateisystem formatiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/acd0 bs=2k count=1</span>
<span class=c># bsdlabel -Bw acd0</span>
<span class=c># newfs /dev/acd0</span></code></pre></div></div><div class=paragraph><p>Denken Sie dabei daran, dass Sie gegebenenfalls die Gerätedatei (hier <span class=filename>acd0</span>) an Ihre Konfiguration anpassen müssen.</p></div><div class=paragraph><p>Nachdem die DVD-RAM formatiert ist, kann sie wie eine normale Festplatte gemountet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/acd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Danach kann schreibend und lesend auf das DVD-RAM Medium zugegriffen werden.</p></div></div></div></div><div class=sect1><h2 id=floppies>17.7. Disketten benutzen<a class=anchor href=#floppies></a></h2><div class=sectionbody><div class=paragraph><p>Dieser Abschnitt beschreibt die Formatierung von 3,5 Zoll Disketten in FreeBSD.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><div class=title>Procedure: Disketten formatieren</div><p>Bevor eine Diskette benutzt werden kann, muss sie (low-level) formatiert werden, was normalerweise der Hersteller schon gemacht hat. Sie können die Diskette allerdings noch einmal formatieren, um das Medium zu überprüfen. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a>, um Disketten unter FreeBSD zu formatieren. Achten Sie dabei auf Fehlermeldungen, die schlechte Speichermedien anzeigen.</p></div><div class="olist arabic"><ol class=arabic><li><p>Um eine Diskette zu formatieren, legen Sie eine 3,5 Zoll Diskette in das erste Diskettenlaufwerk ein und führen das folgende Kommando aus:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat -f 1440 /dev/fd0</span></code></pre></div></div></li><li><p>Nach dem Formatieren muss auf der Diskette ein Disklabel erstellt werden, um die Größe und Geometrie der Diskette zu erkennen. Eine Liste der unterstützten Geometrien finden Sie in <span class=filename>/etc/disktab</span>.</p><div class=paragraph><p>Erstellen Sie nun das Label mit <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/bsdlabel -B -w /dev/fd0 fd1440</span></code></pre></div></div></li><li><p>Auf der Diskette kann nun ein Dateisystem erstellt werden (high-level Formatierung). Das Dateisystem der Diskette kann entweder UFS oder FAT sein, wobei FAT für Disketten in der Regel die bessere Wahl ist.</p><div class=paragraph><p>Um die Diskette mit FAT zu formatieren, geben Sie folgendes Kommando ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/newfs_msdos /dev/fd0</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Die Diskette kann nun benutzt werden. Um die Diskette zu verwenden, kann sie mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> eingehängt werden. Man kann auch <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> aus der Ports-Sammlung installieren, um mit der Diskette zu arbeiten.</p></div></div></div><div class=sect1><h2 id=backup-basics>17.8. Datensicherung<a class=anchor href=#backup-basics></a></h2><div class=sectionbody><div class=paragraph><p>Die Planung und Umsetzung einer Backup-Strategie ist unerlässlich, um Daten in bestimmten Situationen wiederherstellen zu können, zum Beispiel bei Plattendefekten, versehentlichem Löschen von Dateien, willkürlicher Korrumpierung von Dateien oder der vollständigen Zerstörung des Systems und der Backups, die am gleichen Ort aufbewahrt werden.</p></div><div class=paragraph><p>Die Art und der Zeitplan des Backups kann variieren, abhängig von der Wichtigkeit der Daten, der benötigten Granularität zur Wiederherstellung von Dateien und der Dauer einer akzeptablen Ausfallzeit. Zu den möglichen Backup-Strategien gehören unter anderem:</p></div><div class=ulist><ul><li><p>Die Archivierung des kompletten Systems auf externen Datenträgern. Dieser Ansatz schützt zwar vor allen oben aufgeführten Problemen, ist aber zeitaufwändig und unbequem bei der Wiederherstellung, insbesondere für nicht privilegierte Benutzer.</p></li><li><p>Dateisystem-Snapshots sind nützlich bei der Wiederherstellung von gelöschten Dateien, bzw. früheren Versionen von Dateien.</p></li><li><p>Kopien ganzer Dateisysteme oder Festplatten, die mit einem anderen System im Netzwerk mittels <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> synchronisiert werden.</p></li><li><p>Hardware oder Software RAID, was im Falle von Plattendefekten die Ausfallzeit minimiert oder vermeidet.</p></li></ul></div><div class=paragraph><p>Üblicherweise wird eine Mischung aus verschiedenen Strategien verwendet. Es kann zum Beispiel ein Sicherungsplan erstellt und automatisiert werden, um eine wöchentliche, vollständige Systemsicherung, ergänzt mit stündlichen ZFS-Snapshots, zu erstellen. Darüber hinaus könnte man eine manuelle Sicherung einzelner Verzeichnisse oder Dateien machen, bevor diese bearbeitet oder gelöscht werden.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt einige Programme, die zur Erstellung und Verwaltung von Sicherungen unter FreeBSD verwendet werden können.</p></div><div class=sect2><h3 id=_sicherung_von_dateisystemen>17.8.1. Sicherung von Dateisystemen<a class=anchor href=#_sicherung_von_dateisystemen></a></h3><div class=paragraph><p>Die traditionellen UNIX®-Programme zum Sichern und Wiederherstellen von Dateisystemen sind <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>. Diese Programme arbeiten auf der Block-Ebene der Festplatte, also unterhalb des Abstraktionslevels von Dateien, Links und Verzeichnissen, die die Grundlage des Dateisystemkonzepts bilden. Im Gegensatz zu anderen Backup-Programmen sichert <code>dump</code> ein ganzes Dateisystem und nicht nur einen Teil des Dateisystems, oder einen Verzeichnisbaum, der mehr als ein Dateisystem umfasst. Anstatt Dateien oder Verzeichnisse zu schreiben, schreibt <code>dump</code> die Blöcke, aus denen die Dateien und Verzeichnisse bestehen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wird <code>dump</code> benutzt, um das Root-Verzeichnis zu sichern, werden <span class=filename>/home</span>, <span class=filename>/usr</span> und viele andere Verzeichnisse nicht gesichert, da dies normalerweise Mountpunkte für andere Dateisysteme oder symbolische Links zu diesen Dateisystemen sind.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn <code>restore</code> zum Extrahieren von Daten verwendet wird, werden temporäre Dateien standardmäßig in <span class=filename>/tmp</span> abgelegt. Wenn Sie von einer Platte mit einem kleinen <span class=filename>/tmp</span>-Verzeichnis zurücksichern, setzen Sie die Umgebungsvariable <code>TMPDIR</code> auf ein Verzeichnis mit mehr freiem Speicherplatz, damit die Wiederherstellung gelingt.</p></div><div class=paragraph><p>Beachten Sie bei der Verwendung von <code>dump</code>, dass es einige Eigenarten aus den frühen Tagen der Version 6 von AT&amp;T UNIX® (ca. 1975) beibehalten hat. Die Standardparameter gehen davon aus, dass auf einem 9-Spur-Band gesichert wird, und nicht auf ein anderes Medium oder auf Sicherungsbänder mit hoher Dichte. Diese Standardwerte müssen auf der Kommandozeile überschrieben werden.</p></div><div class=paragraph><p>Es ist möglich, das Dateisystem über das Netzwerk auf einem anderen Rechner zu sichern, oder auf einem Bandlaufwerk eines anderen Rechners. Obwohl die Programme <a href="https://man.freebsd.org/cgi/man.cgi?query=rdump&amp;sektion=8&amp;format=html">rdump(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=rrestore&amp;sektion=8&amp;format=html">rrestore(8)</a> für diese Zwecke benutzt werden können, gelten sie als nicht sicher.</p></div><div class=paragraph><p>Verwenden Sie stattdessen <code>dump</code> und <code>restore</code> in einer sichereren Weise über eine SSH-Verbindung. In diesem Beispiel wird eine vollständige, komprimierte Sicherung von <span class=filename>/usr</span> erstellt, das anschließend an einen bestimmten Host über eine SSH-Verbindung gesendet wird.</p></div><div class=exampleblock><div class=title>Beispiel 1. <code>dump</code> mit ssh benutzen</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \</span>
	  targetuser@targetmachine.example.com <span class=nb>dd </span><span class=nv>of</span><span class=o>=</span>/mybigfiles/dump-usr-l0.gz</code></pre></div></div></div></div><div class=paragraph><p>In diesem Beispiel wird <code>RSH</code> gesetzt, um über eine SSH-Verbindung eine Sicherung auf ein Bandlaufwerk eines entfernten Systems zu schreiben:</p></div><div class=exampleblock><div class=title>Beispiel 2. <code>dump</code> über ssh mit gesetzter <code>RSH</code> benutzen</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># env RSH=/usr/bin/ssh /sbin/dump -0uan -f tatargetuser@targetmachine.example.com:/dev/sa0 /usr</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=_sicherung_von_verzeichnissen>17.8.2. Sicherung von Verzeichnissen<a class=anchor href=#_sicherung_von_verzeichnissen></a></h3><div class=paragraph><p>Einige integrierte Werkzeuge stehen zur Sicherung und Wiederherstellung von bestimmten Dateien und Verzeichnissen bei Bedarf zur Verfügung.</p></div><div class=paragraph><p>Wenn es um die Sicherung von Dateien in einem Verzeichnis geht, ist <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> eine gute Wahl. Dieses Werkzeug stammt aus Version 6 von AT&amp;T UNIX® und erwartet standardmäßig eine rekursive Sicherung auf ein lokales Band. Es können jedoch Optionen angegeben werden, um den Namen einer Sicherungsdatei zu bestimmen.</p></div><div class=paragraph><p>In diesem Beispiel wird eine komprimierte Sicherung des aktuellen Verzeichnisses nach <span class=filename>/tmp/mybackup.tgz</span> gespeichert. Achten Sie bei der Sicherungsdatei darauf, dass sie nicht in dem Verzeichnis gespeichert wird, welches gesichert werden soll.</p></div><div class=exampleblock><div class=title>Beispiel 3. Das aktuelle Verzeichnis mit <code>tar</code> sichern</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar czvf /tmp/mybackup.tgz .</span></code></pre></div></div></div></div><div class=paragraph><p>Um eine komplette Sicherung wiederherzustellen, wechseln Sie mit <code>cd</code> in das Verzeichnis, in dem Sie die Daten wiederherstellen möchten und geben Sie den Namen der Sicherungsdatei an. Beachten Sie, dass dabei alle Dateien in dem Verzeichnis überschrieben werden. Im Zweifel sichern Sie besser in einem temporären Verzeichnis, oder geben Sie den Verzeichnisnamen bei der Wiederherstellung an.</p></div><div class=exampleblock><div class=title>Beispiel 4. Wiederherstellung mit <code>tar</code> in das aktuelle Verzeichnis</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /tmp/mybackup.tgz</span></code></pre></div></div></div></div><div class=paragraph><p>Es gibt dutzende Optionen, die in <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> beschrieben werden. Das Programm unterstützt auch die Verwendung von Ausschlußmustern, um bestimmte Dateien von der Sicherung oder Wiederherstellung von Verzeichnissen auszuschließen.</p></div><div class=paragraph><p>Um bestimmte, aufgelistete Dateien und Verzeichnisse zu sichern, ist <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> eine gute Wahl. Im Gegensatz zu <code>tar</code> weiß <code>cpio</code> nicht wie ein Verzeichnisbaum durchlaufen wird. Daher ist es auf eine Liste von zu sichernden Dateien angewiesen.</p></div><div class=paragraph><p>So kann beispielsweise eine Liste von Dateien mit <code>ls</code> oder <code>find</code> erzeugt werden. Dieses Beispiel erstellt eine rekursive Liste des aktuellen Verzeichnisses, die dann über eine Pipe an <code>cpio</code> übergeben wird, um eine Sicherung namens <span class=filename>/tmp/mybackup.cpio</span> zu erstellen.</p></div><div class=exampleblock><div class=title>Beispiel 5. Rekursive Sicherung des aktuellen Verzeichnisses mit <code>ls</code> und <code>cpio</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -R | cpio -ovF /tmp/mybackup.cpio</span></code></pre></div></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a> ist ein Programm, welches versucht die Funktionen von <code>tar</code> und <code>cpio</code> zu kombinieren. Über die Jahre hinweg sind die verschiedenen Versionen von <code>tar</code> und <code>cpio</code> leicht inkompatibel geworden. Daher hat POSIX® <code>pax</code> geschaffen, welches versucht viele der unterschiedlichen <code>cpio</code>- und <code>tar</code>-Formate zu lesen und zu schreiben, außerdem einige neue, eigene Formate.</p></div><div class=paragraph><p>Für die vorangegangenen Beispiele wäre ein äquivalenter Aufruf von <code>pax</code>:</p></div><div class=exampleblock><div class=title>Beispiel 6. Das aktuelle Verzeichnis mit <code>pax</code> sichern</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pax -wf /tmp/mybackup.pax .</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=backups-tapebackups>17.8.3. Bandmedien benutzen<a class=anchor href=#backups-tapebackups></a></h3><div class=paragraph><p>Obwohl sich Bandmedien mit der Zeit weiterentwickelt haben, verwenden moderne Backup-Systeme in der Regel Offsite-Backups in Verbindung mit lokalen Wechseldatenträgern. FreeBSD unterstützt alle SCSI-Bandlaufwerke, wie etwa LTO und DAT. Zusätzlich gibt es begrenzte Unterstützung für SATA- und USB-Bandlaufwerke.</p></div><div class=paragraph><p>Für SCSI-Bandlaufwerke nutzt FreeBSD den <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=4&amp;format=html">sa(4)</a> Treiber, der die Schnittstellen <span class=filename>/dev/sa0</span>, <span class=filename>/dev/nsa0</span> und <span class=filename>/dev/esa0</span> bereitstellt. Der Name des physikalischen Geräts ist <span class=filename>/dev/sa0</span>. Wird <span class=filename>/dev/nsa0</span> benutzt, dann wird die Backup-Anwendung nach dem Schreibvorgang das Band nicht zurückspulen, was es ermöglicht, mehr als eine Datei auf das Band zu schreiben. Die Verwendung von <span class=filename>/dev/esa0</span> wirft das Band aus, nachdem das Gerät geschlossen wurde.</p></div><div class=paragraph><p>FreeBSD nutzt <code>mt</code> für die Steuerung der Operationen des Bandlaufwerks, wie die Suche nach Dateien auf einem Band, oder um Kontrollmarkierungen auf ein Band zu schreiben. Beispielsweise können die ersten drei Dateien auf einem Band erhalten bleiben, indem sie übersprungen werden, bevor eine neue Datei auf das Band geschrieben wird</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mt -f /dev/nsa0 fsf 3</span></code></pre></div></div><div class=paragraph><p>Dieses Werkzeug unterstützt viele Operationen. Weitere Einzelheiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mt&amp;sektion=1&amp;format=html">mt(1)</a>.</p></div><div class=paragraph><p>Um eine Datei mit <code>tar</code> auf ein Band zu schreiben, geben Sie den Namen des Bandlaufwerks und den Dateinamen an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar cvf /dev/sa0 file</span></code></pre></div></div><div class=paragraph><p>Wiederherstellung von Dateien aus dem <code>tar</code>-Archiv von Band in das aktuelle Verzeichnis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xvf /dev/sa0</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie <code>dump</code>, um ein UFS-Dateisystem zu sichern. Dieses Beispiel sichert <span class=filename>/usr</span>, ohne danach das Band zurückzuspulen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dump -0aL -b64 -f /dev/nsa0 /usr</span></code></pre></div></div><div class=paragraph><p>Interaktive Wiederherstellung von Dateien aus einer <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>-Datei von Band in das aktuelle Verzeichnis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># restore -i -f /dev/nsa0</span></code></pre></div></div></div><div class=sect2><h3 id=backups-programs-amanda>17.8.4. Backup-Software von Drittanbietern<a class=anchor href=#backups-programs-amanda></a></h3><div class=paragraph><p>Die FreeBSD Ports-Sammlung enthält viele Programme von Drittanbietern, die verwendet werden können um die zeitliche Erstellung von Sicherungen zu planen, zu vereinfachen und bequemer zu machen. Viele dieser Programme basieren auf dem Client-Server-Modell und können benutzt werden, um die Sicherung von einzelnen Systemen oder allen Rechnern in einem Netzwerk zu automatisieren.</p></div><div class=paragraph><p>Zu den bekannten Programmen gehören Amanda, Bacula, rsync und duplicity.</p></div></div><div class=sect2><h3 id=_die_wiederherstellung_in_einem_notfall>17.8.5. Die Wiederherstellung in einem Notfall<a class=anchor href=#_die_wiederherstellung_in_einem_notfall></a></h3><div class=paragraph><p>Zusätzlich zu den regelmäßigen Sicherungen empfiehlt es sich, die folgenden Schritte im Rahmen eines Notfallplans durchzuführen.</p></div><div class=paragraph><p>Erstellen Sie einen Ausdruck der Ausgabe der folgenden Kommandos:</p></div><div class=ulist><ul><li><p><code>gpart show</code></p></li><li><p><code>more /etc/fstab</code></p></li><li><p><code>dmesg</code></p></li></ul></div><div class=paragraph><p>Bewahren Sie diesen Ausdruck und eine Kopie des Installationsmediums an einem sicheren Ort auf. Im Falle einer Wiederherstellung im Notfall, starten Sie von dem Installationsmedium und wählen Sie <code>Live CD</code>, um eine Rettungs-Shell zu starten. Dieser Rettungsmodus kann verwendet werden, um den aktuellen Stand des Systems anzuzeigen, und wenn nötig, Festplatten zu formatieren und Daten aus den Sicherungen wiederherzustellen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das Installationsmedium für FreeBSD/i386 11.2-RELEASE enthält keine Rettungs-Shell. Laden Sie für diese Version ein Abbild der Livefs CD von <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Als nächstes testen Sie die Rettungs-Shell und die Sicherungen. Dokumentieren Sie diesen Ablauf. Bewahren Sie diese Notizen zusammen mit den Medien, den Ausdrucken und den Sicherungen auf. Diese Notizen können Ihnen im Notfall helfen eine versehentliche Zerstörung der Sicherungen zu verhindern, während Sie unter Stress eine Wiederherstellung durchführen.</p></div><div class=paragraph><p>Als zusätzliche Sicherheitsvorkehrung kann jeweils die letzte Sicherung an einem entfernten Standort aufbewahrt werden. Dieser Standort sollte räumlich von den Computern und Festplatten durch eine erhebliche Entfernung getrennt sein.</p></div></div></div></div><div class=sect1><h2 id=disks-virtual>17.9. Speicherbasierte Laufwerke<a class=anchor href=#disks-virtual></a></h2><div class=sectionbody><div class=paragraph><p>Neben physikalischen Laufwerken unterstützt FreeBSD auch speicherbasierte Laufwerke. Eine mögliche Verwendung für ein speicherbasiertes Laufwerk ist der Zugriff auf ein ISO-Dateisystem, jedoch ohne vorher die Daten auf eine CD oder DVD zu brennen und dann das Medium einzuhängen.</p></div><div class=paragraph><p>FreeBSD verwendet den <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> Treiber um Unterstützung für speicherbasierte Laufwerke bereitzustellen. Dieser Treiber ist bereits im <span class=filename>GENERIC</span>-Kernel enthalten. Wenn Sie eine angepasste Kernelkonfigurationsdatei verwenden, stellen Sie sicher, dass folgende Zeile enthalten ist:</p></div><div class="literalblock programlisting"><div class=content><pre>device md</pre></div></div><div class=sect2><h3 id=disks-mdconfig>17.9.1. Ein- und Aushängen von bestehenden Abbildern<a class=anchor href=#disks-mdconfig></a></h3><div class=paragraph><p>Um ein bestehendes Abbild eines Dateisystems einzuhängen, verwenden Sie <code>mdconfig</code> zusammen mit dem Namen der ISO-Datei und einer freien Gerätenummer. Benutzen Sie dann diese Gerätenummer, um das Abbild in einen existierenden Mountpunkt einzuhängen. Sobald dies erledigt ist, erscheinen die Dateien des Abbildes unterhalb des Mountpunktes. Dieses Beispiel wird <span class=filename>diskimage.iso</span> an das speicherbasierte Laufwerk <span class=filename>/dev/md0</span> binden und dann in <span class=filename>/mnt</span> einhängen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -f diskimage.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Beachten Sie, dass <code>-t cd9660</code> benutzt wurde, um ein ISO-Format einzuhängen. Wenn keine Gerätenummer mit <code>-u</code> angegeben ist, wird von <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> automatisch eine ungenutzte Gerätenummer zugewiesen. Das zugewiesene Gerät wird auf der Standardausgabe ausgegeben (zum Beispiel <span class=filename>md4</span>). Weitere Informationen zu diesem Kommando und dessen Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>.</p></div><div class=paragraph><p>Wenn ein speicherbasiertes Laufwerk nicht mehr in Gebrauch ist, sollten seine belegten Ressourcen wieder an das System zurückgegeben werden. Hängen Sie zuerst das Dateisystem aus, dann verwenden Sie <code>mdconfig</code>, um die Platte vom System zu trennen und die Ressourcen freizugeben.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 0</span></code></pre></div></div><div class=paragraph><p>Um festzustellen, ob noch irgendwelche speicherbasierten Laufwerke am System angeschlossen sind, benutzen Sie <code>mdconfig -l</code>.</p></div></div><div class=sect2><h3 id=disks-md-freebsd5>17.9.2. Ein datei- oder speicherbasiertes Laufwerk erzeugen<a class=anchor href=#disks-md-freebsd5></a></h3><div class=paragraph><p>FreeBSD unterstützt auch speicherbasierte Laufwerke, bei denen der verwendete Speicher entweder einer Festplatte, oder einem Bereich im Arbeitsspeicher zugewiesen wird. Die erste Methode ist gemeinhin als dateibasiertes Dateisystem, die zweite als speicherbasiertes Dateisystem bekannt. Beide Typen können mit <code>mdconfig</code> erzeugt werden.</p></div><div class=paragraph><p>Um ein speicherbasiertes Dateisystem zu erstellen, geben Sie den Typ <code>swap</code> sowie die gewünschte Größe des Laufwerks an. Dieses Beispiel erzeugt ein 5 MB großes Laufwerk an der Gerätenummer <code>1</code>. Das Laufwerk wird mit dem UFS-Dateisystem formatiert, bevor es eingehängt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t swap -s 5m -u 1</span>
<span class=c># newfs -U md1</span>
/dev/md1: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2752, 5344, 7936
<span class=c># mount /dev/md1 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</code></pre></div></div><div class=paragraph><p>Um ein dateibasiertes Dateisystem zu erstellen, muss zunächst ein Stück Speicher auf der Festplatte reserviert werden. Dieses Beispiel erzeugt eine 5 MB große Datei namens <span class=filename>newimage</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out</code></pre></div></div><div class=paragraph><p>Als nächstes muss diese Datei an ein speicherbasiertes Laufwerk gebunden, gelabelt und mit dem UFS-Dateisystem formatiert werden. Danach können Sie das Laufwerk einhängen und die Größe überprüfen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -f newimage -u 0</span>
<span class=c># bsdlabel -w md0 auto</span>
<span class=c># newfs -U md0a</span>
/dev/md0a: 5.0MB <span class=o>(</span>10224 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.25MB, 80 blks, 192 inodes.
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2720, 5280, 7840
<span class=c># mount /dev/md0a /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</code></pre></div></div><div class=paragraph><p>Es benötigt mehrere Befehle, um ein datei- oder speicherbasiertes Dateisystem mit <code>mdconfig</code> zu erstellen. FreeBSD enthält auch <code>mdmfs</code>, das ein speicherbasiertes Laufwerk automatisch konfigurieren, formatieren und einhängen kann. Nachdem beispielsweise <span class=filename>newimage</span> mit <code>dd</code> erstellt wurde, hätte auch der folgende Befehl benutzt werden können, anstelle der oben verwendeten Kommandos <code>bsdlabel</code>, <code>newfs</code> und <code>mount</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -F newimage -s 5m md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Um hingegen ein speicherbasiertes Laufwerk mit <code>mdmfs</code> zu erstellen, wird dieser Befehl benutzt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -s 5m md1 /mnt</span></code></pre></div></div><div class=paragraph><p>Wenn die Gerätenummer nicht angegeben wird, wählt <code>mdmfs</code> automatisch ein ungenutztes Gerät aus. Weitere Einzelheiten über <code>mdmfs</code> finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>.</p></div></div></div></div><div class=sect1><h2 id=snapshots>17.10. Schnappschüsse von Dateisystemen<a class=anchor href=#snapshots></a></h2><div class=sectionbody><div class=paragraph><p>Zusammen mit <a href=../cutting-edge/#soft-updates>Soft Updates</a> bietet FreeBSD eine weitere Funktion: Schnappschüsse von Dateisystemen.</p></div><div class=paragraph><p>UFS-Schnappschüsse sind Dateien, die ein Abbild eines Dateisystems enthalten und müssen auf dem jeweiligen Dateisystem erstellt werden. Pro Dateisystem darf es maximal 20 Schnappschüsse, die im Superblock vermerkt werden, geben. Schnappschüsse bleiben erhalten, wenn das Dateisystem abgehangen, neu eingehangen oder das System neu gestartet wird. Wenn ein Schnappschuss nicht mehr benötigt wird, kann er mit <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a> gelöscht werden. Es ist egal, in welcher Reihenfolge Schnappschüsse gelöscht werden. Es kann allerdings vorkommen, dass nicht der gesamte Speicherplatz wieder freigegeben wird, da ein anderer Schnappschuss einen Teil der entfernten Blöcke für sich beanspruchen kann.</p></div><div class=paragraph><p>Das unveränderliche <code>Snapshot</code>-Dateiflag wird nach der Erstellung des Snapshots von <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> gesetzt. Durch die Verwendung von <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=1&amp;format=html">unlink(1)</a> ist es allerdings möglich, einen Schnappschuss zu löschen.</p></div><div class=paragraph><p>Schnappschüsse werden mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> erstellt. Das folgende Kommando legt einen Schnappschuss von <span class=filename>/var</span> in <span class=filename>/var/snapshot/snap</span> ab:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o snapshot /var/snapshot/snap /var</span></code></pre></div></div><div class=paragraph><p>Alternativ kann der Schnappschuss auch mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> erstellt werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mksnap_ffs /var /var/snapshot/snap</span></code></pre></div></div><div class=paragraph><p>Um Schnappschüsse auf einem Dateisystem, beispielsweise <span class=filename>/var</span> zu finden, kann man <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a> verwenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># find /var -flags snapshot</span></code></pre></div></div><div class=paragraph><p>Nachdem ein Schnappschuss erstellt wurde, können Sie ihn für verschiedene Zwecke benutzen:</p></div><div class=ulist><ul><li><p>Sie können den Schnappschuss für die Datensicherung benutzen und ihn auf eine CD oder ein Band schreiben.</p></li><li><p>Die Integrität des Schnappschusses kann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> geprüft werden. Wenn das Dateisystem zum Zeitpunkt der Erstellung des Schnappschusses in Ordnung war, sollte <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> immer erfolgreich durchlaufen.</p></li><li><p>Sie können den Schnappschuss mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> sichern. Sie erhalten dann eine konsistente Sicherung des Dateisystems zu dem Zeitpunkt, der durch den Zeitstempel des Schnappschusses gegeben ist. Der Schalter <code>-L</code> von <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> erstellt für die Sicherung einen Schnappschuss und entfernt diesen am Ende der Sicherung wieder.</p></li><li><p>Sie können einen Schnappschuss in den Verzeichnisbaum einhängen und sich dann den Zustand des Dateisystems zu dem Zeitpunkt ansehen, an dem der Schnappschuss erstellt wurde. Der folgende Befehl hängt den Schnappschuss <span class=filename>/var/snapshot/snap</span> ein:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4</span>
<span class=c># mount -r /dev/md4 /mnt</span></code></pre></div></div></li></ul></div><div class=paragraph><p>Der eingefrorene Stand des <span class=filename>/var</span>-Dateisystems ist nun unterhalb von <span class=filename>/mnt</span> verfügbar. Mit Ausnahme der früheren Schnappschüsse, die als leere Dateien auftauchen, wird zu Beginn alles so aussehen, wie zum Zeitpunkt der Erstellung des Schnappschusses. Der Schnappschuss kann wie folgt abgehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>Weitere Informationen über Soft Updates und Schnappschüsse von Dateisystemen sowie technische Artikel finden Sie auf der <a href=http://www.mckusick.com/>Webseite von Marshall Kirk McKusick</a>.</p></div></div></div><div class=sect1><h2 id=quotas>17.11. Disk Quotas<a class=anchor href=#quotas></a></h2><div class=sectionbody><div class=paragraph><p>Disk Quotas erlauben dem Administrator, den Plattenplatz und/oder die Anzahl der Dateien eines Benutzers oder der Mitglieder einer Gruppe, auf Dateisystemebene zu beschränken. Dadurch wird verhindert, dass ein Benutzer oder eine Gruppe von Benutzern den ganzen verfügbaren Plattenplatz belegt.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt die Konfiguration von Disk Quotas für UFS-Dateisysteme. Lesen Sie <a href=../zfs/#zfs-zfs-quota>Dataset-, Benutzer- und Gruppenquotas</a>, wenn Sie Disk Quotas auf einem ZFS-Dateisystem einrichten möchten.</p></div><div class=sect2><h3 id=_disk_quotas_aktivieren>17.11.1. Disk Quotas aktivieren<a class=anchor href=#_disk_quotas_aktivieren></a></h3><div class=paragraph><p>Prüfen Sie zunächst, ob der FreeBSD-Kernel Disk Quotas unterstützt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.features.ufs_quota
kern.features.ufs_quota: 1</code></pre></div></div><div class=paragraph><p>In diesem Beispiel zeigt die <code>1</code> an, das Quotas unterstützt werden. Falls <code>0</code> ausgegeben wird, fügen Sie folgende Zeile in die Kernelkonfigurationsdatei ein, und folgen Sie den Anweisungen in <a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a> um den Kernel zu aktualisieren:</p></div><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>Als nächstes aktivieren Sie Disk Quotas in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>quota_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Normalerweise wird beim Booten die Integrität der Quotas auf allen Dateisystemen mit <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a> überprüft. Dieses Programm stellt sicher, dass die Quota-Datenbank mit den Daten auf einem Dateisystem übereinstimmt. Dies ist allerdings ein zeitraubender Prozess, der die Zeit, die das System zum Booten braucht, signifikant beeinflusst. Eine Variable in <span class=filename>/etc/rc.config</span> erlaubt es, diesen Schritt zu überspringen:</p></div><div class="literalblock programlisting"><div class=content><pre>check_quotas=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Zuletzt muss noch <span class=filename>/etc/fstab</span> bearbeitet werden, um die Plattenquotas auf Dateisystemebene zu aktivieren. Um Quotas pro Benutzer für ein Dateisystem zu aktivieren, geben Sie für dieses Dateisystem <code>userquota</code> im Feld Optionen von <span class=filename>/etc/fstab</span> an. Zum Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g   /home    ufs rw,userquota 1 2</pre></div></div><div class=paragraph><p>Um Quotas für Gruppen einzurichten, verwenden Sie <code>groupquota</code>. Um Quotas für Benutzer und Gruppen einzurichten, trennen Sie die Optionen durch Kommata:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</pre></div></div><div class=paragraph><p>Quota-Dateien werden standardmäßig im Rootverzeichnis des Dateisystems unter <span class=filename>quota.user</span> und <span class=filename>quota.group</span> abgelegt. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a>. Es wird nicht empfohlen, Quota-Dateien an anderen Stellen zu speichern.</p></div><div class=paragraph><p>Sobald die Konfiguration abgeschlossen ist, starten Sie das System neu. <span class=filename>/etc/rc</span> wird dann automatisch die richtigen Kommandos aufrufen, um die Quota-Dateien für alle in <span class=filename>/etc/rc.conf</span> definierten Quotas anzulegen.</p></div><div class=paragraph><p>Normalerweise brauchen die Kommandos <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaon&amp;sektion=8&amp;format=html">quotaon(8)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaoff&amp;sektion=8&amp;format=html">quotaoff(8)</a> nicht von Hand aufgerufen werden, obwohl man die entsprechenden Seiten im Manual lesen sollte, um sich mit ihnen vertraut zu machen.</p></div></div><div class=sect2><h3 id=_setzen_von_quota_limits>17.11.2. Setzen von Quota-Limits<a class=anchor href=#_setzen_von_quota_limits></a></h3><div class=paragraph><p>Stellen Sie sicher, dass Quotas auch tatsächlich aktiviert sind:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># quota -v</span></code></pre></div></div><div class=paragraph><p>Für jedes Dateisystem, auf dem Quotas aktiviert sind, sollte eine Zeile mit der Plattenauslastung und den aktuellen Quota-Limits zu sehen sein.</p></div><div class=paragraph><p>Mit <code>edquota</code> können nun Quota-Limits zugewiesen werden.</p></div><div class=paragraph><p>Mehrere Möglichkeiten stehen zur Verfügung, um Limits für den Plattenplatz, den ein Benutzer oder eine Gruppe verbrauchen kann, oder die Anzahl der Dateien, die angelegt werden dürfen, festzulegen. Die Limits können auf dem Plattenplatz (Block-Quotas), der Anzahl der Dateien (Inode-Quotas) oder einer Kombination von beiden basieren. Jedes Limit wird weiterhin in zwei Kategorien geteilt: Hardlimits und Softlimits.</p></div><div class=paragraph><p>Ein Hardlimit kann nicht überschritten werden. Hat der Benutzer einmal ein Hardlimit erreicht, so kann er auf dem betreffenden Dateisystem keinen weiteren Platz mehr beanspruchen. Hat ein Benutzer beispielsweise ein Hardlimit von 500 Kilobytes auf einem Dateisystem und benutzt davon 490 Kilobyte, so kann er nur noch 10 weitere Kilobytes beanspruchen. Der Versuch, weitere 11 Kilobytes zu beanspruchen, wird fehlschlagen.</p></div><div class=paragraph><p>Softlimits können für eine befristete Zeit überschritten werden. Diese Frist beträgt in der Grundeinstellung eine Woche. Hat der Benutzer das Softlimit über die Frist hinaus überschritten, so wird das Softlimit in ein Hardlimit umgewandelt und der Benutzer kann keinen weiteren Platz mehr beanspruchen. Wenn er einmal das Softlimit unterschreitet, wird die Frist wieder zurückgesetzt.</p></div><div class=paragraph><p>Im folgenden Beispiel wird das Quota des Benutzerkonto <code>test</code> bearbeitet. Wenn <code>edquota</code> aufgerufen wird, wird der in <code>EDITOR</code> definierte Editor aufgerufen, um die Quota-Limts zu konfigurieren. Der Standard-Editor ist vi.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -u test</span>

Quotas <span class=k>for </span>user <span class=nb>test</span>:

/usr: kbytes <span class=k>in </span>use: 65, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 75<span class=o>)</span>
        inodes <span class=k>in </span>use: 7, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 60<span class=o>)</span>
/usr/var: kbytes <span class=k>in </span>use: 0, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 75<span class=o>)</span>
        inodes <span class=k>in </span>use: 0, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 60<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Für jedes Dateisystem, auf dem Quotas aktiv sind, sind zwei Zeilen zu sehen. Eine repräsentiert die Block-Quotas und die andere die Inode-Quotas. Um ein Limit zu modifizieren, ändern Sie einfach den angezeigten Wert. Um beispielsweise das Blocklimit von <span class=filename>/usr</span> auf ein Softlimit von <code>500</code> und ein Hardlimit von <code>600</code> zu erhöhen, ändern Sie die Zeile wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</pre></div></div><div class=paragraph><p>Die neuen Limits sind wirksam, sobald der Editor verlassen wird.</p></div><div class=paragraph><p>Manchmal ist es wünschenswert, die Limits für eine Reihe von Benutzern zu setzen. Dazu weisen Sie zunächst einem Benutzer das gewünschte Quota-Limit zu. Anschließend benutzen Sie <code>-p</code>, um das Quota auf einen bestimmten Bereich von Benutzer-IDs (UID) zu duplizieren. Der folgende Befehl dupliziert die Quota-Limits auf die UIDs <code>10000</code> bis <code>19999</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -p test 10000-19999</span></code></pre></div></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>.</p></div></div><div class=sect2><h3 id=_überprüfen_von_quota_limits_und_plattennutzung>17.11.3. Überprüfen von Quota-Limits und Plattennutzung<a class=anchor href=#_überprüfen_von_quota_limits_und_plattennutzung></a></h3><div class=paragraph><p>Um die Limits oder die Plattennutzung individueller Benutzer und Gruppen zu überprüfen, kann <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> benutzt werden. Ein Benutzer kann nur die eigenen Quotas und die Quotas der Gruppe, der er angehört untersuchen. Nur der Superuser darf sich alle Limits ansehen. Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a> erhalten Sie eine Zusammenfassung von allen Limits und der Plattenausnutzung für alle Dateisysteme, auf denen Quotas aktiv sind.</p></div><div class=paragraph><p>In der Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> werden Dateisysteme, auf denen ein Benutzer keinen Platz verbraucht, nicht angezeigt, auch wenn diesem Quotas zugewiesen wurden. Benutzen Sie <code>-v</code> um solche Dateisysteme ebenfalls anzuzeigen. Das folgende Beispiel zeigt die Ausgabe von <code>quota -v</code> für einen Benutzer, der Quota-Limits auf zwei Dateisystemen besitzt:</p></div><div class="literalblock programlisting"><div class=content><pre>Disk quotas for user test (uid 1002):
     Filesystem  usage   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</pre></div></div><div class=paragraph><p>Im Dateisystem <span class=filename>/usr</span> liegt der Benutzer momentan 15 Kilobytes über dem Softlimit von 50 Kilobytes und hat noch 5 Tage seiner Frist übrig. Der Stern <code>*</code> zeigt an, dass der Benutzer sein Limit überschritten hat.</p></div></div><div class=sect2><h3 id=_quotas_über_nfs>17.11.4. Quotas über NFS<a class=anchor href=#_quotas_über_nfs></a></h3><div class=paragraph><p>Quotas werden von dem Quota-Subsystem auf dem NFS-Server erzwungen. Der <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.rquotad&amp;sektion=8&amp;format=html">rpc.rquotad(8)</a> Daemon stellt <code>quota</code> die Quota Informationen auf dem NFS-Client zur Verfügung, so dass Benutzer auf diesen Systemen ihre Quotas abfragen können.</p></div><div class=paragraph><p>Sie aktivieren <code>rpc.rquotad</code> auf dem NFS-Server, indem Sie das Zeichen <code>#</code> auf folgender Zeile in <span class=filename>/etc/inetd.conf</span> entfernen:</p></div><div class="literalblock programlisting"><div class=content><pre>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</pre></div></div><div class=paragraph><p>Anschließend starten Sie <code>inetd</code> neu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd restart</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=disks-encrypting>17.12. Partitionen verschlüsseln<a class=anchor href=#disks-encrypting></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD bietet ausgezeichnete Möglichkeiten, Daten vor unberechtigten Zugriffen zu schützen. Wenn das Betriebssystem läuft, schützen Zugriffsrechte und vorgeschriebene Zugriffskontrollen (MAC) (siehe <a href=../mac/#mac>Verbindliche Zugriffskontrolle</a>) die Daten. Die Zugriffskontrollen des Betriebssystems schützen allerdings nicht vor einem Angreifer, der Zugriff auf den Rechner hat. Der Angreifer kann eine Festplatte in ein anderes System einbauen und dort die Daten analysieren.</p></div><div class=paragraph><p>Die für FreeBSD verfügbaren kryptografischen Subsysteme, GEOM Based Disk Encryption (<code>gbde</code>) und <code>geli</code> sind in der Lage, Daten auf Dateisystemen auch vor hoch motivierten Angreifern zu schützen, die über erhebliche Mittel verfügen. Dieser Schutz ist unabhängig von der Art und Weise, durch die ein Angreifer Zugang zu einer Festplatte oder zu einem Rechner erlangt hat. Im Gegensatz zu anderen Verschlüsselungsmethoden, bei denen einzelne Dateien verschlüsselt werden, verschlüsseln gbde und <code>geli</code> transparent ganze Dateisysteme. Auf der Festplatte werden dabei keine Daten im Klartext gespeichert.</p></div><div class=paragraph><p>Dieses Kapitel zeigt, wie ein verschlüsseltes Dateisystem unter FreeBSD erstellt wird. Zunächst wird der Ablauf für gbde beschrieben und anschließend das gleiche Beispiel für geli.</p></div><div class=sect2><h3 id=_plattenverschlüsselung_mit_gbde>17.12.1. Plattenverschlüsselung mit gbde<a class=anchor href=#_plattenverschlüsselung_mit_gbde></a></h3><div class=paragraph><p>Das Ziel von <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> ist es, einen Angreifer vor eine große Herausforderung zu stellen, um an die Daten einer Festplatte zu gelangen. Falls jedoch der Rechner kompromittiert wurde, während er im Betrieb war und das Speichergerät aktiv verbunden war, oder wenn der Angreifer eine gültige Passphrase kennt, bietet dieses System keinen Schutz für die Daten der Festplatte. Daher ist es wichtig, für die physische Sicherheit zu sorgen, während das System im Betrieb ist. Außerdem muss die Passphrase für den Verschlüsselungsmechanismus geschützt werden.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> besitzt einige Funktionen um die Daten, die in einem Sektor gespeichert sind, zu schützen. Es benutzt 128-Bit AES im CBC-Modus, um die Daten eines Sektors zu verschlüsseln. Jeder Sektor einer Festplatte wird mit einem anderen AES-Schlüssel verschlüsselt. Weitere Informationen zum kryptographischen Design und wie die Schlüssel für einen Sektor aus der gegebenen Passphrase ermittelt werden, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a>.</p></div><div class=paragraph><p>FreeBSD enthält ein Kernelmodul für gbde, das wie folgt geladen werden kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_bde</span></code></pre></div></div><div class=paragraph><p>Wenn Sie einen angepassten Kernel verwenden, stellen Sie sicher, dass folgende Zeile in der Kernelkonfigurationsdatei enthalten ist:</p></div><div class=paragraph><p><code>options GEOM_BDE</code></p></div><div class=paragraph><p>Das folgende Beispiel beschreibt, wie eine Partition auf einer neuen Festplatte verschlüsselt wird. Die Partition wird in <span class=filename>/private</span> eingehangen.</p></div><div class="olist arabic procedure"><div class=title>Procedure: Eine Partition mit gbde verschlüsseln</div><ol class=arabic><li><p>Installieren der Festplatte</p><div class=paragraph><p>Installieren Sie die Festplatte wie in <a href=#disks-adding>Hinzufügen von Laufwerken</a> beschrieben. Im Beispiel wird die Partition <span class=filename>/dev/ad4s1c</span> verwendet. Die Gerätedateien <span class=filename>/dev/ad0s1*</span> sind Standard-Partitionen des FreeBSD-Systems.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</code></pre></div></div></li><li><p>Verzeichnis für gbde-Lock-Dateien anlegen</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /etc/gbde</span></code></pre></div></div><div class=paragraph><p>Die Lock-Dateien sind für den Zugriff von gbde auf verschlüsselte Partitionen notwendig. Ohne die Lock-Dateien können die Daten nur mit erheblichem manuellen Aufwand wieder entschlüsselt werden (dies wird auch von der Software nicht unterstützt). Jede verschlüsselte Partition benötigt eine gesonderte Lock-Datei.</p></div></li><li><p>Vorbereiten der gbde-Partition</p><div class=paragraph><p>Eine von gbde benutzte Partition muss einmalig initialisiert werden, bevor sie benutzt werden kann. Das Programm öffnet eine Vorlage im Standard-Editor, um verschiedene Optionen zu konfigurieren. Setzen Sie <code>sector_size</code> auf <code>2048</code>, wenn Sie UFS benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</span>
<span class=nv>$FreeBSD</span>: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp <span class=err>$</span>
<span class=c>#</span>
<span class=c># Sector size is the smallest unit of data which can be read or written.</span>
<span class=c># Making it too small decreases performance and decreases available space.</span>
<span class=c># Making it too large may prevent filesystems from working.  512 is the</span>
<span class=c># minimum and always safe.  For UFS, use the fragment size</span>
<span class=c>#</span>
sector_size     <span class=o>=</span>       2048
<span class=o>[</span>...]</code></pre></div></div><div class=paragraph><p>Sobald die Änderungen gespeichert werden, wird der Benutzer zweimal aufgefordert, die zum Schutz der Daten verwendete Passphrase einzugeben. Die Passphrase muss beide Mal gleich eingegeben werden. Die Sicherheit der Daten hängt allein von der Qualität der gewählten Passphrase ab. Die Auswahl einer sicheren und leicht zu merkenden Passphrase wird auf der Webseite <a href=http://world.std.com/~reinhold/diceware.html>http://world.std.com/~reinhold/diceware.html</a> beschrieben.</p></div><div class=paragraph><p>Bei der Initialisierung wird eine Lock-Datei für die gbde-Partition erstellt. In diesem Beispiel <span class=filename>/etc/gbde/ad4s1c.lock</span>. Lock-Dateien müssen die Dateiendung ".lock" aufweisen, damit sie von <span class=filename>/etc/rc.d/gbde</span>, dem Startskript von gbde, erkannt werden.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Lock-Dateien müssen immer zusammen mit den verschlüsselten Dateisystemen gesichert werden. Ohne die Lock-Datei können Sie allerdings nicht auf die verschlüsselten Daten zugreifen.</p></div></td></tr></tbody></table></div></li><li><p>Einbinden der verschlüsselten Partition in den Kernel</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</span></code></pre></div></div><div class=paragraph><p>Dieses Kommando fragt die Passphrase ab, die bei der Initialisierung der verschlüsselten Partition eingegeben wurde. Das neue verschlüsselte Gerät erscheint danach in <span class=filename>/dev</span> als <span class=filename>/dev/device_name.bde</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</code></pre></div></div></li><li><p>Dateisystem auf dem verschlüsselten Gerät anlegen</p><div class=paragraph><p>Nachdem die verschlüsselte Partition im Kernel eingebunden ist, kann ein Dateisystem erstellt werden. Dieses Beispiel erstellt ein UFS-Dateisystem mit aktivierten Soft Updates. Achten Sie darauf, die Partition mit der Erweiterung <span class=filename>*.bde</span> zu benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U -O2 /dev/ad4s1c.bde</span></code></pre></div></div></li><li><p>Einhängen der verschlüsselten Partition</p><div class=paragraph><p>Legen Sie einen Mountpunkt für das verschlüsselte Dateisystem an. Hängen Sie anschließend das Dateisystem ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /private</span>
<span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div></li><li><p>Überprüfen des verschlüsselten Dateisystems</p><div class=paragraph><p>Das verschlüsselte Dateisystem sollte jetzt erkannt und benutzt werden können:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>df</span> <span class=nt>-H</span>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div><div class=paragraph><p>Nach jedem Neustart müssen verschlüsselte Dateisysteme dem Kernel wieder bekannt gemacht werden, auf Fehler überprüft werden und eingehangen werden. Für die dazu nötigen Schritte fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>gbde_autoattach_all=&#34;YES&#34;
gbde_devices=&#34;ad4s1c&#34;
gbde_lockdir=&#34;/etc/gbde&#34;</pre></div></div><div class=paragraph><p>Durch diese Argumente muss beim Systemstart auf der Konsole die Passphrase eingegeben werden. Erst nach Eingabe der korrekten Passphrase wird die verschlüsselte Partition automatisch in den Verzeichnisbaum eingehängt. Weitere Bootoptionen von gbde finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>sysinstall ist nicht kompatibel mit gbde-verschlüsselten Geräten. Bevor sysinstall gestartet wird, müssen alle <span class=filename>*.bde</span> Geräte vom Kernel getrennt werden, da sonst der Kernel bei der ersten Suche nach Geräten abstürzt. Um das verschlüsselte Gerät aus dem Beispiel zu trennen, benutzen Sie das folgende Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde detach /dev/ad4s1c</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=disks-encrypting-geli>17.12.2. Plattenverschlüsselung mit <code>geli</code><a class=anchor href=#disks-encrypting-geli></a></h3><div class=paragraph><p>Mit <code>geli</code> steht eine alternative kryptografische GEOM-Klasse zur Verfügung. Dieses Werkzeug unterstützt unterschiedliche Fähigkeiten und verfolgt einen anderen Ansatz für die Verschlüsselung. geli bietet die folgenden Funktionen:</p></div><div class=ulist><ul><li><p>Die Nutzung des <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=9&amp;format=html">crypto(9)</a>-Frameworks. Wenn das System über kryptografische Hardware verfügt, wird diese von <code>geli</code> automatisch verwendet.</p></li><li><p>Die Unterstützung verschiedener kryptografischer Algorithmen, wie AES, Blowfish, und 3DES.</p></li><li><p>Die Möglichkeit, die root-Partition zu verschlüsseln. Um auf die verschlüsselte root-Partition zugreifen zu können, muss beim Systemstart die Passphrase eingegeben werden.</p></li><li><p>Erlaubt den Einsatz von zwei voneinander unabhängigen Schlüsseln.</p></li><li><p>Es ist durch einfache Sektor-zu-Sektor-Verschlüsselung sehr schnell.</p></li><li><p>Die Möglichkeit, Master-Keys zu sichern und wiederherzustellen. Wenn ein Benutzer seinen Schlüssel zerstört, kann er über seinen zuvor gesicherten Schlüssel wieder auf seine Daten zugreifen.</p></li><li><p><code>geli</code> erlaubt es, Platten mit einem zufälligen Einmal-Schlüssel einzusetzen, was für Swap-Partitionen und temporäre Dateisysteme interessant ist.</p></li></ul></div><div class=paragraph><p>Weitere Funktionen und Anwendungsbeispiele finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></div><div class=paragraph><p>Das folgende Beispiel beschreibt, wie eine Schlüsseldatei erzeugt wird, die als Teil des Master-Keys für den Verschlüsselungs-Provider verwendet wird, der unter <span class=filename>/private</span> in den Verzeichnisbaum eingehängt wird. Die Schlüsseldatei liefert zufällige Daten, die für die Verschlüsselung des Master-Keys benutzt werden. Zusätzlich wird der Master-Key durch eine Passphrase geschützt. Die Sektorgröße des Providers beträgt 4 KB. Das Beispiel beschreibt, wie Sie einen <code>geli</code>-Provider aktivieren, ein vom ihm verwaltetes Dateisystem erzeugen, es mounten, mit ihm arbeiten und wie Sie es schließlich wieder unmounten und den Provider deaktivieren.</p></div><div class="olist arabic procedure"><div class=title>Procedure: Eine Partition mit <code>geli</code> verschlüsseln</div><ol class=arabic><li><p>Laden der <code>geli</code>-Unterstützung</p><div class=paragraph><p>Die Unterstützung für <code>geli</code> wird über ein ladbares Kernelmodul zur Verfügung gestellt. Damit das Modul automatisch beim Booten geladen wird, fügen Sie folgende Zeile in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_eli_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Um das Modul direkt zu laden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_eli</span></code></pre></div></div><div class=paragraph><p>Stellen Sie bei einer angepassten Kernelkonfigurationsdatei sicher, dass diese Zeilen enthalten sind:</p></div><div class="literalblock programlisting"><div class=content><pre>options GEOM_ELI
device crypto</pre></div></div></li><li><p>Erzeugen des Master-Keys</p><div class=paragraph><p>Die folgenden Befehle erzeugen einen Master-Key, mit dem alle Daten verschlüsselt werden. Dieser Schlüssel kann niemals geändert werden. Anstatt ihn direkt zu benutzen, wird er mit einem oder mehrere Schlüsseln verschlüsselt. Die Schlüssel bestehen aus einer optionalen Kombination von zufälligen Bytes aus einer Datei, <span class=filename>/root/da2.key</span>, und/oder einer Passphrase. In diesem Fall ist die Datenquelle der Schlüsseldatei <span class=filename>/dev/random</span>. Dieser Befehl konfiguriert auch die Sektorgröße des Providers (<span class=filename>/dev/da2.eli</span>) mit 4 KB, um eine bessere Leistung zu erzielen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/root/da2.key bs=64 count=1</span>
<span class=c># geli init -K /root/da2.key -s 4096 /dev/da2</span>
Enter new passphrase:
Reenter new passphrase:</code></pre></div></div><div class=paragraph><p>Es ist nicht zwingend nötig, sowohl eine Passphrase als auch eine Schlüsseldatei zu verwenden. Die einzelnen Methoden können auch unabhängig voneinander eingesetzt werden.</p></div><div class=paragraph><p>Wird für die Schlüsseldatei "-" angegeben, wird dafür die Standardeingabe verwendet. Das folgende Kommando erzeugt beispielsweise drei Schlüsseldateien:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</span></code></pre></div></div></li><li><p>Aktivieren des Providers mit dem erzeugten Schlüssel</p><div class=paragraph><p>Um den Provider zu aktivieren, geben Sie die Schlüsseldatei, den Namen des Laufwerks und die Passphrase an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geli attach -k /root/da2.key /dev/da2</span>
Enter passphrase:</code></pre></div></div><div class=paragraph><p>Dadurch wird ein neues Gerät mit der Erweiterung <span class=filename>.eli</span> angelegt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/da2*</span>
/dev/da2  /dev/da2.eli</code></pre></div></div></li><li><p>Das neue Dateisystem erzeugen</p><div class=paragraph><p>Als nächstes muss das Gerät mit dem UFS-Dateisystem formatiert und an einen vorhandenen Mountpunkt eingehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/da2.eli bs=1m</span>
<span class=c># newfs /dev/da2.eli</span>
<span class=c># mount /dev/da2.eli /private</span></code></pre></div></div><div class=paragraph><p>Das verschlüsselte Dateisystem sollte jetzt erkannt und benutzt werden können:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df -H</span>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div><div class=paragraph><p>Wenn Sie nicht mehr mit dem verschlüsselten Dateisystem arbeiten und die unter <span class=filename>/private</span> eingehängte Partition daher nicht mehr benötigen, sollten Sie diese unmounten und den <code>geli</code>-Verschlüsselungs-Provider wieder deaktivieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /private</span>
<span class=c># geli detach da2.eli</span></code></pre></div></div><div class=paragraph><p>FreeBSD verfügt über ein <span class=filename>rc.d</span>-Skript, das dass Einhängen von verschlüsselten Geräten beim Booten deutlich vereinfacht. Für dieses Beispiel, fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>geli_devices=&#34;da2&#34;
geli_da2_flags=&#34;-p -k /root/da2.key&#34;</pre></div></div><div class=paragraph><p>Dies konfiguriert <span class=filename>/dev/da2</span> als <code>geli</code>-Provider mit dem Master-Key <span class=filename>/root/da2.key</span>. Das System wird den Provider automatisch deaktivieren, bevor es heruntergefahren wird. Während des Startvorgangs fordert das Skript die Passphrase an, bevor der Provider aktiviert wird. Vor und nach der Eingabeaufforderung für die Passphrase werden noch weitere Kernelmeldungen angezeigt. Achten Sie sorgfältig auf die Eingabeaufforderung zwischen den anderen Meldungen, falls es zu Problemen beim Startvorgang kommt. Sobald die richtige Passphrase eingegeben wurde, wird der Provider aktiviert. Anschließend werden die Dateisysteme gemäß <span class=filename>/etc/fstab</span> eingehängt. Lesen Sie <a href=../basics/#mount-unmount>“Anhängen und Abhängen von Dateisystemen”</a> wenn Sie wissen möchten, wie Sie ein Dateisystem konfigurieren, sodass es beim booten automatisch gestartet wird.</p></div></div></div></div><div class=sect1><h2 id=swap-encrypting>17.13. Den Auslagerungsspeicher verschlüsseln<a class=anchor href=#swap-encrypting></a></h2><div class=sectionbody><div class=paragraph><p>Wie die Verschlüsselung von Partitionen, wird auch der Auslagerungsspeicher verschlüsselt, um sensible Informationen zu schützen. Stellen Sie sich eine Anwendung vor, die mit Passwörtern umgeht. Solange sich diese Passwörter im Arbeitsspeicher befinden, werden sie nicht auf die Festplatte geschrieben und nach einem Neustart gelöscht. Falls FreeBSD jedoch damit beginnt Speicher auszulagern, um Platz für andere Anwendungen zu schaffen, können die Passwörter unverschlüsselt auf die Festplatte geschrieben werden. Die Verschlüsselung des Auslagerungsspeichers kann in solchen Situationen Abhilfe schaffen.</p></div><div class=paragraph><p>Dieser Abschnitt zeigt die Konfiguration eines verschlüsselten Auslagerungsspeichers mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>. In den Beispielen repräsentiert <span class=filename>/dev/ada0s1b</span> die Swap-Partition.</p></div><div class=sect2><h3 id=_konfiguration_eines_verschlüsselten_auslagerungsspeichers>17.13.1. Konfiguration eines verschlüsselten Auslagerungsspeichers<a class=anchor href=#_konfiguration_eines_verschlüsselten_auslagerungsspeichers></a></h3><div class=paragraph><p>Swap-Partitionen werden standardmäßig nicht verschlüsselt. Sie sollten daher alle sensiblen Daten im Auslagerungsspeicher löschen, bevor Sie fortfahren. Führen Sie folgenden Befehl aus, um die Swap-Partition mit Zufallsdaten zu überschreiben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/ada0s1b bs=1m</span></code></pre></div></div><div class=paragraph><p>Um den Auslagerungsspeicher mit <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> zu verschlüsseln, fügen Sie in <span class=filename>/etc/fstab</span> das Suffix <code>.bde</code> an den Gerätenamen der Swap-Partition hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ada0s1b.bde         none            swap    sw              0       0</pre></div></div><div class=paragraph><p>Wenn Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> benutzen, verwenden Sie stattdessen das Suffix <code>.eli</code>, um den Auslagerungsspeicher zu verschlüsseln:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ada0s1b.eli         none            swap    sw              0       0</pre></div></div><div class=paragraph><p>In der Voreinstellung verschlüsselt <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> mit dem AES-Algorithmus und einer Schlüssellänge von 128 Bit. Diese Voreinstellungen sind in der Regel ausreichend, können jedoch im Options-Feld in <span class=filename>/etc/fstab</span> angepasst werden. Mögliche Optionen sind:</p></div><div class=dlist><dl><dt class=hdlist1>aalgo</dt><dd><p>Der Algorithmus für die Prüfung der Datenintegrität. Dieser wird benutzt um sicherzustellen, dass die verschlüsselten Daten nicht manipuliert wurden. Eine Liste der unterstützten Algorithmen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></dd><dt class=hdlist1>ealgo</dt><dd><p>Der Verschlüsselungsalgorithmus, der verwendet wird um die Daten zu schützen. Eine Liste der unterstützten Algorithmen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></dd><dt class=hdlist1>keylen</dt><dd><p>Die Länge des Schlüssels für den Verschlüsselungsalgorithmus. In <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> können Sie lesen, welche Schlüssellängen von welchem Algorithmus unterstützt werden.</p></dd><dt class=hdlist1>sectorsize</dt><dd><p>Die Größe, in der die Datenblöcke aufgeteilt werden, bevor sie verschlüsselt werden. Größere Blöcke erhöhen die Leistung auf Kosten des Speicherverbrauchs. Die empfohlene Größe beträgt 4096 Byte.</p></dd></dl></div><div class=paragraph><p>Dieses Beispiel konfiguriert eine verschlüsselte Swap-Partition mit dem Blowfish-Algorithmus, einer Schlüssellänge von 128 Bit und einer Sektorgröße von 4 KB:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options				Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw,ealgo=blowfish,keylen=128,sectorsize=4096	0	0</pre></div></div></div><div class=sect2><h3 id=_überprüfung_des_verschlüsselten_auslagerungsspeichers>17.13.2. Überprüfung des verschlüsselten Auslagerungsspeichers<a class=anchor href=#_überprüfung_des_verschlüsselten_auslagerungsspeichers></a></h3><div class=paragraph><p>Nachdem das System neu gestartet wurde, kann die korrekte Funktion des verschlüsselten Auslagerungsspeichers mit <code>swapinfo</code> geprüft werden.</p></div><div class=paragraph><p>Wenn Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> einsetzen, erhalten Sie eine Meldung ähnlich der folgenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.bde    542720        0   542720     0%</code></pre></div></div><div class=paragraph><p>Wenn Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> einsetzen, erhalten Sie hingegen eine Ausgabe ähnlich der folgenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.eli    542720        0   542720     0%</code></pre></div></div></div></div></div><div class=sect1><h2 id=disks-hast>17.14. Highly Available Storage (HAST)<a class=anchor href=#disks-hast></a></h2><div class=sectionbody><div class=paragraph><p>Hochverfügbarkeit ist eine der Hauptanforderungen von ernsthaften Geschäftsanwendungen und hochverfügbarer Speicher ist eine Schlüsselkomponente in solchen Umgebungen. Highly Available STorage (HAST) ist ein Framework in FreeBSD, welches die transparente Speicherung der gleichen Daten über mehrere physikalisch getrennte Maschinen ermöglicht, die über ein TCP/IP-Netzwerk verbunden sind. HAST kann als ein netzbasiertes RAID1 (Spiegel) verstanden werden und ist dem DRBD®-Speichersystem der GNU/Linux®-Plattform ähnlich. In Kombination mit anderen Hochverfügbarkeitseigenschaften von FreeBSD wie CARP, ermöglicht es HAST, hochverfügbare Speichercluster zu bauen, die in der Lage sind, Hardwareausfällen zu widerstehen.</p></div><div class=paragraph><p>Die Hauptmerkmale von HAST sind:</p></div><div class=ulist><ul><li><p>Es kann zur Maskierung von I/O-Fehlern auf lokalen Festplatten eingesetzt werden.</p></li><li><p>Dateisystem-unabhängig, was es erlaubt, jedes von FreeBSD unterstützte Dateisystem zu verwenden.</p></li><li><p>Effiziente und schnelle Resynchronisation: es werden nur die Blöcke synchronisiert, die während der Ausfallzeit eines Knotens geändert wurden.</p></li><li><p>Es kann in einer bereits bestehenden Umgebung eingesetzt werden, um zusätzliche Redundanz zu erreichen.</p></li><li><p>Zusammen mit CARP, Heartbeat, oder anderen Werkzeugen, ist es möglich, ein robustes und dauerhaftes Speichersystem zu bauen.</p></li></ul></div><div class=paragraph><p>Nachdem Sie diesen Abschnitt gelesen haben, werden Sie folgendes wissen:</p></div><div class=ulist><ul><li><p>Was HAST ist, wie es funktioniert und welche Eigenschaften es besitzt.</p></li><li><p>Wie man HAST unter FreeBSD aufsetzt und verwendet.</p></li><li><p>Wie man CARP und <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> kombiniert, um ein robustes Speichersystem zu bauen.</p></li></ul></div><div class=paragraph><p>Bevor Sie diesen Abschnitt lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>die Grundlagen von UNIX® und FreeBSD verstanden haben (<a href=../basics/#basics>Grundlagen des FreeBSD Betriebssystems</a>).</p></li><li><p>wissen, wie man Netzwerkschnittstellen und andere Kernsysteme von FreeBSD konfiguriert (<a href=../config/#config-tuning>Konfiguration und Tuning</a>).</p></li><li><p>ein gutes Verständnis der FreeBSD-Netzwerkfunktionalität besitzen (<a href=../partiv/#network-communication>Netzwerke</a>).</p></li></ul></div><div class=paragraph><p>Das HAST-Projekt wurde von der FreeBSD Foundation mit Unterstützung der <a href=http://www.omc.net/>OMCnet Internet Service GmbH</a> und <a href=http://www.transip.nl/>TransIP BV</a> gesponsert.</p></div><div class=sect2><h3 id=_hast_im_einsatz>17.14.1. HAST im Einsatz<a class=anchor href=#_hast_im_einsatz></a></h3><div class=paragraph><p>HAST bietet eine synchrone Replikation auf Blockebene zwischen zwei Maschinen: einem <code>primary</code>, auch bekannt als <code>master</code> Knoten, sowie dem <code>secondary</code>, oder <code>slave</code> Knoten. Diese beiden Maschinen zusammen werden als Cluster bezeichnet.</p></div><div class=paragraph><p>Da HAST in einer primär-sekundär-Konfiguration funktioniert, ist immer nur ein Knoten des Clusters zu jeder Zeit aktiv. Der primäre Knoten, auch <em>active</em> genannt, ist derjenige, der alle I/O-Anfragen verarbeitet, die an die HAST-Schnittstelle gesendet werden. Der sekundäre Knoten wird automatisch vom primären Knoten aus synchronisiert.</p></div><div class=paragraph><p>Die physischen Komponenten des HAST-Systems sind die lokale Platte am Primärknoten und die entfernte Platte am Sekundärknoten.</p></div><div class=paragraph><p>HAST arbeitet synchron auf Blockebene, was es für Dateisysteme und Anwendungen transparent macht. HAST stellt gewöhnliche GEOM-Provider in <span class=filename>/dev/hast/</span> für die Verwendung durch andere Werkzeuge oder Anwendungen zur Verfügung. Es gibt keinen Unterschied zwischen dem Einsatz von HAST bereitgestellten Geräten und herkömmlichen Platten oder Partitionen.</p></div><div class=paragraph><p>Jede Schreib-, Lösch- oder Entleerungsoperation wird an die lokale und über TCP/IP zu der entfernt liegenden Platte gesendet. Jede Leseoperation wird von der lokalen Platte durchgeführt, es sei denn, die lokale Platte ist nicht aktuell oder es tritt ein I/O-Fehler auf. In solchen Fällen wird die Leseoperation an den Sekundärknoten geschickt.</p></div><div class=paragraph><p>HAST versucht, eine schnelle Fehlerbereinigung zu gewährleisten. Aus diesem Grund ist es wichtig, die Synchronisationszeit nach dem Ausfall eines Knotens zu reduzieren. Um eine schnelle Synchronisation zu ermöglichen, verwaltet HAST eine Bitmap von unsauberen Bereichen auf der Platte und synchronisiert nur diese während einer regulären Synchronisation (mit Ausnahme der initialen Synchronisation).</p></div><div class=paragraph><p>Es gibt viele Wege, diese Synchronisation zu behandeln. HAST implementiert mehrere Replikationsarten, um unterschiedliche Methoden der Synchronisation zu realisieren:</p></div><div class=ulist><ul><li><p><em>memsync</em>: Dieser Modus meldet Schreiboperationen als vollständig, wenn die lokale Schreiboperation beendet ist und der entfernt liegende Knoten die Ankunft der Daten bestätigt hat, jedoch bevor die Daten wirklich gespeichert wurden. Die Daten werden auf dem entfernt liegenden Knoten direkt nach dem Senden der Bestätigung gespeichert. Dieser Modus ist dafür gedacht, Latenzen zu verringern und zusätzlich eine gute Verlässlichkeit zu bieten. In der Voreinstellung wird dieser Modus benutzt.</p></li><li><p><em>fullsync</em>: Dieser Modus meldet Schreiboperationen als vollständig, wenn sowohl die lokale, als auch die entfernte Schreiboperation abgeschlossen wurde. Dies ist der sicherste und zugleich der langsamste Replikationsmodus.</p></li><li><p><em>async</em>: Dieser Modus meldet Schreiboperationen als vollständig, wenn lokale Schreibvorgänge abgeschlossen wurden. Dies ist der schnellste und gefährlichste Replikationsmodus. Er sollte nur verwendet werden, wenn die Latenz zu einem entfernten Knoten bei einer Replikation zu hoch ist für andere Modi.</p></li></ul></div></div><div class=sect2><h3 id=_hast_konfiguration>17.14.2. HAST-Konfiguration<a class=anchor href=#_hast_konfiguration></a></h3><div class=paragraph><p>Das HAST-Framework besteht aus mehreren Komponenten:</p></div><div class=ulist><ul><li><p>Dem <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a>-Daemon, welcher für Datensynchronisation verantwortlich ist. Wenn dieser Daemon gestartet wird, wird automatisch <code>geom_gate.ko</code> geladen.</p></li><li><p>Dem <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a> Management-Werkzeug.</p></li><li><p>Der Konfigurationsdatei <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a>. Diese Datei muss vorhanden sein, bevor hastd gestartet wird.</p></li></ul></div><div class=paragraph><p>Alternativ lässt sich die <code>GEOM_GATE</code>-Unterstützung in den Kernel statisch einbauen, indem folgende Zeile zur Kernelkonfigurationsdatei hinzugefügt wird. Anschließend muss der Kernel, wie in <a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a> beschrieben, neu gebaut werden:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_GATE</pre></div></div><div class=paragraph><p>Das folgende Beispiel beschreibt, wie man zwei Knoten als master-slave / primary-secondary mittels HAST konfiguriert, um Daten zwischen diesen beiden auszutauschen. Die Knoten werden als <code>hasta</code> mit der IP-Adresse <code>172.16.0.1</code> und <code>hastb</code> mit der IP-Adresse <code>172.16.0.2</code> bezeichnet. Beide Knoten besitzen eine dedizierte Festplatte <span class=filename>/dev/ad6</span> mit der gleichen Größe für den HAST-Betrieb. Der HAST-Pool, manchmal auch Ressource genannt, oder der GEOM-Provider in <span class=filename>/dev/hast/</span> wird als <span class=filename>test</span> bezeichnet.</p></div><div class=paragraph><p>Die Konfiguration von HAST wird in <span class=filename>/etc/hast.conf</span> vorgenommen. Diese Datei sollte auf beiden Knoten gleich sein. Die einfachste Konfiguration ist folgende:</p></div><div class="literalblock programlisting"><div class=content><pre>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</pre></div></div><div class=paragraph><p>Fortgeschrittene Konfigurationsmöglichkeiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Es ist ebenfalls möglich, den Hostnamen in den <code>remote</code>-Anweisungen zu verwenden, falls die Rechner aufgelöst werden können und in <span class=filename>/etc/hosts</span>, oder im lokalen DNS definiert sind.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald die Konfiguration auf beiden Rechnern vorhanden ist, kann ein HAST-Pool erstellt werden. Lassen Sie diese Kommandos auf beiden Knoten ablaufen, um die initialen Metadaten auf die lokale Platte zu schreiben und starten Sie anschließend <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl create test</span>
<span class=c># service hastd onestart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es ist <em>nicht</em> möglich, GEOM-Provider mit einem bereits bestehenden Dateisystem zu verwenden, um beispielsweise einen bestehenden Speicher in einen von HAST verwalteten Pool zu konvertieren. Dieses Verfahren muss einige Metadaten auf den Provider schreiben und dafür würde nicht genug freier Platz zur Verfügung stehen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Rolle eines HAST Knotens, <code>primary</code> oder <code>secondary</code>, wird vom einem Administrator, oder einer Software wie Heartbeat, mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a> festgelegt. Auf dem primären Knoten <code>hasta</code> geben Sie diesen Befehl ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role primary test</span></code></pre></div></div><div class=paragraph><p>Geben Sie folgendes Kommando auf dem sekundären Knoten <code>hastb</code> ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role secondary test</span></code></pre></div></div><div class=paragraph><p>Überprüfen Sie das Ergebnis mit <code>hastctl</code> auf beiden Knoten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl status test</span></code></pre></div></div><div class=paragraph><p>Überprüfen Sie die <code>status</code>-Zeile. Wird hier <code>degraded</code> angezeigt, dann ist etwas mit der Konfigurationsdatei nicht in Ordnung. Auf jedem Konten sollte <code>complete</code> angezeigt werden, was bedeutet, dass die Synchronisation zwischen den beiden Knoten gestartet wurde. Die Synchronisierung ist abgeschlossen, wenn <code>hastctl status</code> meldet, dass die <code>dirty</code>-Bereiche 0 Bytes betragen.</p></div><div class=paragraph><p>Der nächste Schritt ist, ein Dateisystem auf dem GEOM-Provider anzulegen und dieses ins System einzuhängen. Dies muss auf dem <code>primary</code>-Knoten durchgeführt werden. Die Erstellung des Dateisystems kann ein paar Minuten dauern, abhängig von der Größe der Festplatte. Dieses Beispiel erstellt ein UFS-Dateisystem auf <span class=filename>/dev/hast/test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/hast/test</span>
<span class=c># mkdir /hast/test</span>
<span class=c># mount /dev/hast/test /hast/test</span></code></pre></div></div><div class=paragraph><p>Sobald das HAST-Framework richtig konfiguriert wurde, besteht der letzte Schritt nun darin, sicherzustellen, dass HAST während des Systemstarts automatisch gestartet wird. Fügen Sie diese Zeile in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>hastd_enable=&#34;YES&#34;</pre></div></div><div class=sect3><h4 id=_failover_konfiguration>17.14.2.1. Failover-Konfiguration<a class=anchor href=#_failover_konfiguration></a></h4><div class=paragraph><p>Das Ziel dieses Beispiels ist, ein robustes Speichersystem zu bauen, welches Fehlern auf einem beliebigen Knoten widerstehen kann. Wenn der <code>primary</code>-Knoten ausfällt, ist der <code>secondary</code>-Knoten da, um nahtlos einzuspringen, das Dateisystem zu prüfen, einzuhängen und mit der Arbeit fortzufahren, ohne dass auch nur ein einzelnes Bit an Daten verloren geht.</p></div><div class=paragraph><p>Um diese Aufgabe zu bewerkstelligen, wird das Common Address Redundancy Protocol (CARP) benutzt, welches ein automatisches Failover auf der IP-Schicht ermöglicht. CARP erlaubt es mehreren Rechnern im gleichen Netzsegment, die gleiche IP-Adresse zu verwenden. Setzen Sie CARP auf beiden Knoten des Clusters anhand der Dokumentation in <a href=../advanced-networking/#carp>“Common Address Redundancy Protocol (CARP)”</a> auf. In diesem Beispiel hat jeder Knoten seine eigene Management IP-Adresse und die geteilte IP-Adresse <em>172.16.0.254</em>. Der primäre HAST-Knoten des Clusters muss der CARP-Masterknoten sein.</p></div><div class=paragraph><p>Der HAST-Pool, welcher im vorherigen Abschnitt erstellt wurde, ist nun bereit für den Export über das Netzwerk auf den anderen Rechner. Dies kann durch den Export über NFS oder Samba erreicht werden, indem die geteilte IP-Adresse <em>172.16.0.254</em> verwendet wird. Das einzige ungelöste Problem ist der automatische Failover, sollte der primäre Knoten einmal ausfallen.</p></div><div class=paragraph><p>Falls die CARP-Schnittstelle aktiviert oder deaktiviert wird, generiert das FreeBSD-Betriebssystem ein <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>-Ereignis, was es ermöglicht, Zustandsänderungen auf den CARP-Schnittstellen zu überwachen. Eine Zustandsänderung auf der CARP-Schnittstelle ist ein Indiz dafür, dass einer der Knoten gerade ausgefallen oder wieder verfügbar ist. Diese Zustandsänderungen machen es möglich, ein Skript zu starten, welches automatisch den HAST-Failover durchführt.</p></div><div class=paragraph><p>Um Zustandsänderungen auf der CARP-Schnittstelle abzufangen, müssen diese Zeilen in <span class=filename>/etc/devd.conf</span> auf jedem Knoten hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_UP&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch master&#34;;
};

notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_DOWN&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch slave&#34;;
};</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn auf dem System FreeBSD 10 oder höher eingesetzt wird, ersetzen Sie <span class=filename>carp0</span> durch den Namen der konfigurierten Schnittstelle für CARP.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Starten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> auf beiden Knoten neu, um die neue Konfiguration wirksam werden zu lassen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p>Wenn die Schnittstelle aktiviert oder deaktiviert wird, erzeugt das System eine Meldung, was es dem <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>-Subsystem ermöglicht, ein automatisches Failover-Skript zu starten, <span class=filename>/usr/local/sbin/carp-hast-switch</span>. Weitere Informationen zu dieser Konfiguration finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=devd.conf&amp;sektion=5&amp;format=html">devd.conf(5)</a>.</p></div><div class=paragraph><p>Es folgt ein Beispiel für ein automatisches Failover-Skript:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources=&#34;test&#34;

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log=&#34;local0.debug&#34;
name=&#34;carp-hast&#34;

# end of user configurable stuff

case &#34;$1&#34; in
	master)
		logger -p $log -t $name &#34;Switching to primary provider for ${resources}.&#34;
		sleep ${delay}

		# Wait for any &#34;hastd secondary&#34; processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf &#34;hastd: ${disk} \(secondary\)&#34; &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to change role to primary for resource ${disk}.&#34;
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c &#34;/dev/hast/${disk}&#34; ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c &#34;/dev/hast/${disk}&#34; ]; then
				logger -p $log -t $name &#34;GEOM provider /dev/hast/${disk} did not appear.&#34;
				exit 1
			fi
		done

		logger -p $log -t $name &#34;Role for HAST resources ${resources} switched to primary.&#34;

		logger -p $log -t $name &#34;Mounting disks.&#34;
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name &#34;Switching to secondary provider for ${resources}.&#34;

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q &#34;^/dev/hast/${disk} on &#34;
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to switch role to secondary for resource ${disk}.&#34;
				exit 1
			fi
			logger -p $log -t $name &#34;Role switched to secondary for resource ${disk}.&#34;
		done
	;;
esac</pre></div></div><div class=paragraph><p>Im Kern führt das Skript die folgenden Aktionen durch, sobald ein Knoten zum Master wird:</p></div><div class=ulist><ul><li><p>Es ernennt den HAST-Pool als den primären für einen gegebenen Knoten.</p></li><li><p>Es prüft das Dateisystem, dass auf dem HAST-Pool erstellt wurde.</p></li><li><p>Es hängt den Pool ins System ein.</p></li></ul></div><div class=paragraph><p>Wenn ein Knoten zum Sekundären ernannt wird:</p></div><div class=ulist><ul><li><p>Hängt es den HAST-Pool aus dem Dateisystem aus.</p></li><li><p>Degradiert es den HAST-Pool zum sekundären.</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Dieses Skript ist nur ein Beispiel für eine mögliche Lösung. Es behandelt nicht alle möglichen Szenarien, die auftreten können und sollte erweitert bzw. abgeändert werden, so dass z.B. benötigte Dienste gestartet oder gestoppt werden.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Für dieses Beispiel wurde ein UFS-Dateisystem verwendet. Um die Zeit für die Wiederherstellung zu verringern, kann ein UFS mit Journal oder ein ZFS-Dateisystem benutzt werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Weitere detaillierte Informationen mit zusätzlichen Beispielen können unter <a href=http://wiki.FreeBSD.org/HAST>http://wiki.FreeBSD.org/HAST</a> abgerufen werden.</p></div></div></div><div class=sect2><h3 id=_fehlerbehebung>17.14.3. Fehlerbehebung<a class=anchor href=#_fehlerbehebung></a></h3><div class=paragraph><p>HAST sollte generell ohne Probleme funktionieren. Jedoch kann es, wie bei jeder anderen Software auch, zu gewissen Zeiten sein, dass sie sich nicht so verhält wie angegeben. Die Quelle dieser Probleme kann unterschiedlich sein, jedoch sollte als Faustregel gewährleistet werden, dass die Zeit für alle Knoten im Cluster synchron läuft.</p></div><div class=paragraph><p>Für die Fehlersuche bei HAST sollte die Anzahl an Debugging-Meldungen von <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> erhöht werden. Dies kann durch das Starten von <code>hastd</code> mit <code>-d</code> erreicht werden. Diese Option kann mehrfach angegeben werden, um die Anzahl an Meldungen weiter zu erhöhen. Sie sollten ebenfalls die Verwendung von <code>-F</code> in Erwägung ziehen, was <code>hastd</code> im Vordergrund startet.</p></div><div class=sect3><h4 id=disks-hast-sb>17.14.3.1. Auflösung des Split-brain-Zustands<a class=anchor href=#disks-hast-sb></a></h4><div class=paragraph><p><code>split-brain</code> bezeichnet eine Situation, in der beide Knoten des Clusters nicht in der Lage sind, miteinander zu kommunizieren und dadurch beide als primäre Knoten fungieren. Dies ist ein gefährlicher Zustand, weil es beiden Knoten erlaubt ist, Änderungen an den Daten vorzunehmen, die miteinander nicht in Einklang gebracht werden können. Diese Situation muss vom Systemadministrator manuell bereinigt werden.</p></div><div class=paragraph><p>Der Administrator muss entscheiden, welcher Knoten die wichtigeren Änderungen besitzt, oder die Zusammenführung manuell durchführen. Anschließend kann HAST die volle Synchronisation mit dem Knoten durchführen, der die beschädigten Daten enthält. Um dies zu tun, geben Sie folgende Befehle auf dem Knoten ein, der neu synchronisiert werden muss:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role init test</span>
<span class=c># hastctl create test</span>
<span class=c># hastctl role secondary test</span></code></pre></div></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9. März 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/de/books/handbook/audit class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/de/books/handbook/geom class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#disks-synopsis>17.1. Übersicht</a></li><li><a href=#disks-adding>17.2. Hinzufügen von Laufwerken</a></li><li><a href=#disks-growing>17.3. Partitionen vergrößern</a></li><li><a href=#usb-disks>17.4. USB Speichermedien</a></li><li><a href=#creating-cds>17.5. Erstellen und Verwenden von CDs</a></li><li><a href=#creating-dvds>17.6. DVDs benutzen</a></li><li><a href=#floppies>17.7. Disketten benutzen</a></li><li><a href=#backup-basics>17.8. Datensicherung</a></li><li><a href=#disks-virtual>17.9. Speicherbasierte Laufwerke</a></li><li><a href=#snapshots>17.10. Schnappschüsse von Dateisystemen</a></li><li><a href=#quotas>17.11. Disk Quotas</a></li><li><a href=#disks-encrypting>17.12. Partitionen verschlüsseln</a></li><li><a href=#swap-encrypting>17.13. Den Auslagerungsspeicher verschlüsseln</a></li><li><a href=#disks-hast>17.14. Highly Available Storage (HAST)</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/handbook/handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/de/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>