<!doctype html><html class=theme-light lang=de><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/de/books/handbook/geom/><title>Kapitel 18. GEOM: Modulares Framework zur Plattentransformation | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Kapitel 18. GEOM: Modulares Framework zur Plattentransformation"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="https://docs.freebsd.org/de/books/handbook/geom/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/de\/books\/handbook\/geom\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=https://docs.freebsd.org/de/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/de/books>Books</a></li><li><a href=https://docs.freebsd.org/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/preface/>Vorwort</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-audience>Über dieses Buch</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-changes-from3>Änderungen gegenüber der dritten Auflage</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-changes-from2>Änderungen gegenüber der zweiten Auflage (2004)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-changes>Änderungen gegenüber der ersten Auflage (2001)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-overview>Gliederung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-conv>Konventionen in diesem Buch</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-acknowledgements>Danksagung</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/parti/>Teil I. Erste Schritte</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/introduction/>Kapitel 1. Einleitung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/introduction/#introduction-synopsis>1.1. Überblick</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/introduction/#nutshell>1.2. Willkommen zu FreeBSD!</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/introduction/#history>1.3. Über das FreeBSD Projekt</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/>Kapitel 2. FreeBSD installieren</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Minimale Hardwareanforderungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Vor der Installation</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-start>2.4. Die Installation starten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#using-bsdinstall>2.5. Verwendung von bsdinstall</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Plattenplatz bereitstellen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Abrufen der Distributionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-post>2.8. Benutzerkonten, Zeitzone, Dienste und Sicherheitsoptionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-network>2.9. Netzwerkschnittstellen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Fehlerbehebung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#using-live-cd>2.11. Verwendung der Live-CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/basics/>Kapitel 3. Grundlagen des FreeBSD Betriebssystems</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-synopsis>3.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#consoles>3.2. Virtuelle Konsolen und Terminals</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#users-synopsis>3.3. Benutzer und grundlegende Account-Verwaltung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#permissions>3.4. Zugriffsrechte</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#dirstructure>3.5. Verzeichnis-Strukturen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#disk-organization>3.6. Festplatten, Slices und Partitionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#mount-unmount>3.7. Anhängen und Abhängen von Dateisystemen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-processes>3.8. Prozesse und Dämonen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#editors>3.10. Text-Editoren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-devices>3.11. Geräte und Gerätedateien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-more-information>3.12. Manualpages</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/ports/>Kapitel 4. Installieren von Anwendungen: Pakete und Ports</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-synopsis>4.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-overview>4.2. Installation von Software</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-finding-applications>4.3. Suchen einer Anwendung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#pkgng-intro>4.4. Benutzen von pkg zur Verwaltung von Binärpaketen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-using>4.5. Benutzen der Ports-Sammlung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-poudriere>4.6. Pakete mit Poudriere bauen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-nextsteps>4.7. Nach der Installation</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-broken>4.8. Kaputte Ports</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/x11/>Kapitel 5. Das X-Window-System</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x11-synopsis>5.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-understanding>5.2. Terminologie</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-install>5.3. Xorg installieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-config>5.4. Xorg konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-fonts>5.5. Schriftarten in Xorg benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-xdm>5.6. Der X-Display-Manager</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x11-wm>5.7. Grafische Oberflächen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-compiz-fusion>5.8. Compiz Fusion installieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x11-troubleshooting>5.9. Fehlersuche</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partii/>Teil II. Oft benutzte Funktionen</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/desktop/>Kapitel 6. Desktop-Anwendungen</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-synopsis>6.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-browsers>6.2. Browser</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-productivity>6.3. Büroanwendungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-viewers>6.4. Anzeigen von Dokumenten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-finance>6.5. Finanzsoftware</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/multimedia/>Kapitel 7. Multimedia</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#multimedia-synopsis>7.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#sound-setup>7.2. Soundkarten einrichten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#sound-mp3>7.3. MP3-Audio</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#video-playback>7.4. Videos wiedergeben</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#tvcard>7.5. TV-Karten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#scanners>7.7. Scanner</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/>Kapitel 8. Konfiguration des FreeBSD-Kernels</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Wieso einen eigenen Kernel bauen?</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Informationen über die vorhandene Hardware beschaffen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-config>8.4. Die Kernelkonfigurationsdatei</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-building>8.5. Einen angepassten Kernel bauen und installieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. Wenn etwas schiefgeht</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/printing/>Kapitel 9. Drucken</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-quick-start>9.1. Schnellstart</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-connections>9.2. Druckerverbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-pdls>9.3. Gebräuchliche Seitenbeschreibungssprachen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-direct>9.4. Direktes Drucken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-lpd>9.5. LPD (Line Printer Daemon)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-other>9.6. Andere Drucksysteme</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/>Kapitel 10. Linux®-Binärkompatibilität</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Konfiguration der Linux®-Binärkompatibilität</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/#linuxemu-advanced>10.3. Weiterführende Themen</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partiii/>Teil III. Systemadministration</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/config/>Kapitel 11. Konfiguration und Tuning</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/config/#config-synopsis>11.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-starting-services>11.2. Start von Diensten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-cron>11.3. cron(8) konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-rcd>11.4. Dienste unter FreeBSD verwalten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#config-network-setup>11.5. Einrichten von Netzwerkkarten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-virtual-hosts>11.6. Virtual Hosts</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-syslog>11.7. Konfiguration der Systemprotokollierung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-configfiles>11.8. Konfigurationsdateien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-sysctl>11.9. Einstellungen mit sysctl(8)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-disk>11.10. Tuning von Laufwerken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-kernel-limits>11.11. Einstellungen von Kernel Limits</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#adding-swap-space>11.12. Hinzufügen von Swap-Bereichen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#acpi-overview>11.13. Energie- und Ressourcenverwaltung</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/boot/>Kapitel 12. FreeBSDs Bootvorgang</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-synopsis>12.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-introduction>12.2. FreeBSDs Bootvorgang</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-splash>12.3. Willkommensbildschirme während des Bootvorgangs konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#device-hints>12.4. Konfiguration von Geräten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-shutdown>12.5. Der Shutdown-Vorgang</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/security/>Kapitel 13. Sicherheit</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-synopsis>13.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-intro>13.2. Einführung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#one-time-passwords>13.3. Einmalpasswörter</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#ipsec>13.7. VPN mit IPsec</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#fs-acl>13.9. Zugriffskontrolllisten für Dateisysteme (ACL)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-pkg>13.10. Sicherheitsprobleme in Software von Drittanbietern überwachen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-advisories>13.11. FreeBSD Sicherheitshinweise</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-accounting>13.12. Prozess-Überwachung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-resourcelimits>13.13. Einschränkung von Ressourcen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-sudo>13.14. Gemeinsame Administration mit Sudo</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/jails/>Kapitel 14. Jails</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-synopsis>14.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-terms>14.2. Jails - Definitionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-build>14.3. Einrichtung und Verwaltung von Jails</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-tuning>14.4. Feinabstimmung und Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-application>14.5. Mehrere Jails aktualisieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-ezjail>14.6. Verwaltung von Jails mit ezjail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/mac/>Kapitel 15. Verbindliche Zugriffskontrolle</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-synopsis>15.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-inline-glossary>15.2. Schlüsselbegriffe</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-initial>15.3. Erläuterung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-understandlabel>15.4. MAC Labels verstehen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-planning>15.5. Planung eines Sicherheitsmodells</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-modules>15.6. Modulkonfiguration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-seeotheruids>15.7. Das MAC Modul seeotheruids</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-bsdextended>15.8. Das MAC Modul bsdextended</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-ifoff>15.9. Das MAC Modul ifoff</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-portacl>15.10. Das MAC Modul portacl</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-partition>15.11. Das MAC Modul partition</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-mls>15.12. Das MAC Modul Multi-Level Security</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-biba>15.13. Das MAC Modul Biba</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-lomac>15.14. Das MAC Modul LOMAC</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-implementing>15.15. Beispiel 1: Nagios in einer MAC Jail</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-userlocked>15.16. Beispiel 2: User Lock Down</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-troubleshoot>15.17. Fehler im MAC beheben</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/audit/>Kapitel 16. Security Event Auditing</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-synopsis>16.1. Einleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-inline-glossary>16.2. Schlüsselbegriffe</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-config>16.3. Audit Konfiguration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-administration>16.4. Audit-Trails</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/disks/>Kapitel 17. Speichermedien</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-synopsis>17.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-adding>17.2. Hinzufügen von Laufwerken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-growing>17.3. Partitionen vergrößern</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#usb-disks>17.4. USB Speichermedien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#creating-cds>17.5. Erstellen und Verwenden von CDs</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#creating-dvds>17.6. DVDs benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#floppies>17.7. Disketten benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#backup-basics>17.8. Datensicherung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-virtual>17.9. Speicherbasierte Laufwerke</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#snapshots>17.10. Schnappschüsse von Dateisystemen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#quotas>17.11. Disk Quotas</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-encrypting>17.12. Partitionen verschlüsseln</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#swap-encrypting>17.13. Den Auslagerungsspeicher verschlüsseln</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-hast>17.14. Highly Available Storage (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle checked>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/geom/>Kapitel 18. GEOM: Modulares Framework zur Plattentransformation</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-synopsis>18.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-mirror>18.3. RAID1 - Spiegelung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-raid3>18.4. RAID3 - Byte-Level Striping mit dedizierter Parität</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-graid>18.5. Software RAID</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-ggate>18.6. GEOM Gate Netzwerk</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-glabel>18.7. Das Labeln von Laufwerken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-gjournal>18.8. UFS Journaling in GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/zfs/>Kapitel 19. Das Z-Dateisystem (ZFS)</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-differences>19.1. Was ZFS anders macht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-quickstart>19.2. Schnellstartanleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-zpool>19.3. <code>zpool</code> Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-zfs>19.4. <code>zfs</code> Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-zfs-allow>19.5. Delegierbare Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-advanced>19.6. Themen für Fortgeschrittene</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-links>19.7. Zusätzliche Informationen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-term>19.8. ZFS-Eigenschaften und Terminologie</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/filesystems/>Kapitel 20. Dateisystemunterstützung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/filesystems/#filesystems-synopsis>20.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/filesystems/#filesystems-linux>20.2. Linux® Dateisysteme</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/virtualization/>Kapitel 21. Virtualisierung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-synopsis>21.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-parallels>21.2. FreeBSD als Gast-Betriebssystem unter Parallels für Mac OS® X</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. FreeBSD als Gast-Betriebssystem unter Virtual PC für Windows®</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-vmware>21.4. FreeBSD als Gast-Betriebssystem unter VMware Fusion für Mac OS®</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-virtualbox-guest-additions>21.5. FreeBSD als Gast mit VirtualBox™</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. FreeBSD als Host mit Virtualbox</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-host-bhyve>21.7. FreeBSD als Host mit bhyve</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-host-xen>21.8. FreeBSD als Xen™-Host</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/l10n/>Kapitel 22. Lokalisierung – I18N/L10N einrichten und benutzen</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#l10n-synopsis>22.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#using-localization>22.2. Lokale Anpassungen benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#l10n-compiling>22.3. I18N-Programme</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#lang-setup>22.4. Lokalisierung für einzelne Sprachen</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/>Kapitel 23. FreeBSD aktualisieren</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. FreeBSD-Update</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. Aktualisieren der Dokumentationssammlung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#current-stable>23.4. Einem Entwicklungszweig folgen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#makeworld>23.5. FreeBSD aus den Quellen aktualisieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#small-lan>23.6. Installation mehrerer Maschinen</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/dtrace/>Kapitel 24. DTrace</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-synopsis>24.1. Überblick</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-implementation>24.2. Unterschiede in der Implementierung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-enable>24.3. Die DTrace Unterstützung aktivieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-using>24.4. DTrace verwenden</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/>Kapitel 25. USB Gerätemodus</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. Virtuelle serielle USB-Ports</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. Netzwerkkarten im USB-Gerätemodus</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. Virtuelle USB-Speichergeräte</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partiv/>Teil IV. Netzwerke</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/>Kapitel 26. Serielle Datenübertragung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#serial-synopsis>26.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#serial>26.2. Begriffe und Hardware</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#term>26.3. Terminals</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#dialup>26.4. Einwählverbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#dialout>26.5. Verbindungen nach Außen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#serialconsole-setup>26.6. Einrichten der seriellen Konsole</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/>Kapitel 27. PPP</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#userppp>27.2. PPP konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. Probleme bei PPP-Verbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#pppoe>27.4. PPP over Ethernet (PPPoE)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#pppoa>27.5. PPP over ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/mail/>Kapitel 28. Elektronische Post (E-Mail)</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-de-term>28.1. Terminologie</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-synopsis>28.2. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-using>28.3. E-Mail Komponenten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#sendmail>28.4. Sendmail-Konfigurationsdateien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-changingmta>28.5. Wechseln des Mailübertragungs-Agenten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-trouble>28.6. Fehlerbehebung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-advanced>28.7. Weiterführende Themen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#outgoing-only>28.8. Ausgehende E-Mail über einen Relay versenden</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#SMTP-dialup>28.9. E-Mail über Einwahl-Verbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#SMTP-Auth>28.10. SMTP-Authentifizierung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-agents>28.11. E-Mail-Programme</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-fetchmail>28.12. E-Mails mit fetchmail abholen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-procmail>28.13. E-Mails mit procmail filtern</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/network-servers/>Kapitel 29. Netzwerkserver</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-servers-synopsis>29.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-inetd>29.2. Der inetd"Super-Server"</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-nis>29.4. Network Information System (NIS)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-ldap>29.5. Lightweight Access Directory Protocol (LDAP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-dhcp>29.6. Dynamic Host Configuration Protocol (DHCP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-dns>29.7. Domain Name System (DNS)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-apache>29.8. Apache HTTP-Server</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-ftp>29.9. File Transfer Protocol (FTP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-samba>29.10. Datei- und Druckserver für Microsoft® Windows®-Clients (Samba)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-ntp>29.11. Die Uhrzeit mit NTP synchronisieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-iscsi>29.12. iSCSI Initiator und Target Konfiguration</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/firewalls/>Kapitel 30. Firewalls</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-intro>30.1. Einführung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-concepts>30.2. Firewallkonzepte</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/>Kapitel 31. Weiterführende Netzwerkthemen</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-routing>31.2. Gateways und Routen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-wireless>31.3. Drahtlose Netzwerke</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-bluetooth>31.5. Bluetooth</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-bridging>31.6. LAN-Kopplung mit einer Bridge</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-aggregation>31.7. Link-Aggregation und Failover</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-diskless>31.8. Plattenloser Betrieb mit PXE</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#carp>31.10. Common Address Redundancy Protocol (CARP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partv/>Teil V. Anhang</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/mirrors/>Anhang A. Bezugsquellen für FreeBSD</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#mirrors-cdrom>A.1. CD and DVD Sets</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#mirrors-ftp>A.2. FTP-Server</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#svn>A.3. Benutzen von Subversion</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#mirrors-rsync>A.4. Benutzen von rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/bibliography/>Anhang B. Bibliografie</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-freebsd>B.1. Bücher speziell für FreeBSD</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-userguides>B.2. Handbücher</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-adminguides>B.3. Administrations-Anleitungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-programmers>B.4. Programmierhandbücher</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-osinternals>B.5. Betriebssystem-Interna</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-security>B.6. Sicherheits-Anleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-hardware>B.7. Hardware-Anleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-history>B.8. UNIX® Geschichte</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-journals>B.9. Zeitschriften, Magazine und Journale</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/eresources/>Anhang C. Ressourcen im Internet</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-www>C.1. Webseiten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-mail>C.2. Mailinglisten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-news>C.3. Usenet-News</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-web>C.4. Offizielle Spiegel</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/pgpkeys/>Anhang D. OpenPGP-Schlüssel</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Ansprechpartner</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Kapitel 18. GEOM: Modulares Framework zur Plattentransformation</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#geom-synopsis>18.1. Übersicht</a></li><li><a href=#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=#geom-mirror>18.3. RAID1 - Spiegelung</a></li><li><a href=#geom-raid3>18.4. RAID3 - Byte-Level Striping mit dedizierter Parität</a></li><li><a href=#geom-graid>18.5. Software RAID</a></li><li><a href=#geom-ggate>18.6. GEOM Gate Netzwerk</a></li><li><a href=#geom-glabel>18.7. Das Labeln von Laufwerken</a></li><li><a href=#geom-gjournal>18.8. UFS Journaling in GEOM</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=geom-synopsis>18.1. Übersicht<a class=anchor href=#geom-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>GEOM erlaubt den Zugriff und die Kontrolle von Klassen, wie beispielsweise Master Boot Records und BSD-Label, durch die Nutzung von Datenträgern (Providern) oder den besonderen Dateien in <span class=filename>/dev</span>. Verschiedene Software RAID-Konfigurationen unterstützend, gewährt GEOM transparenten Zugriff auf das Betriebssystem und die System-Dienstprogramme.</p></div><div class=paragraph><p>Dieses Kapitel behandelt den Einsatz von Laufwerken mit dem GEOM-Framework in FreeBSD. Dies beinhaltet auch die wichtigen RAID-Überwachungswerkzeuge, welche das Framework zur Konfiguration nutzen. Dieses Kapitel ist kein ausführlicher Leitfaden für RAID-Konfigurationen. Nur die von GEOM unterstützten RAID-Klassen werden erörtert.</p></div><div class=paragraph><p>Nach Lesen dieses Kapitels werden Sie folgendes wissen:</p></div><div class=ulist><ul><li><p>Welche Art von RAID-Unterstützung durch GEOM verfügbar ist.</p></li><li><p>Wie man die Basis-Dienstprogramme nutzt, um verschiedene RAID-Stufen zu konfigurieren, zu manipulieren und zu warten.</p></li><li><p>Wie man mittels GEOM spiegelt, striped, verschlüsselt und entfernte Laufwerke verbindet.</p></li><li><p>Wie man an Laufwerken, welche an das GEOM-Framework angeschlossen sind, Fehler behebt.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>Verstehen, wie FreeBSD Laufwerke behandelt (<a href=../disks/#disks>Speichermedien</a>).</p></li><li><p>Wissen wie man einen neuen FreeBSD-Kernel konfiguriert und installiert (<a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=geom-striping>18.2. RAID0 - Striping<a class=anchor href=#geom-striping></a></h2><div class=sectionbody><div class=paragraph><p>Striping (stripe = Streifen) fasst verschiedene Laufwerke in einem einzigen Datenträger zusammen. Dies wird durch die Nutzung von Hardware-Controllern bewerkstelligt. Das GEOM-Subsystem unterstützt Software-RAID0, welches auch als Striping bekannt ist. Bei dieser Technik wird kein RAID-Controller benötigt.</p></div><div class=paragraph><p>In einem RAID0-System werden die Daten in einzelne Blöcke aufgeteilt, welche über alle angeschlossenen Laufwerke in einem Datenfeld (Array) geschrieben werden. Anstatt darauf warten zu müssen, dass 256K auf ein einzelnes Laufwerk geschrieben werden, kann ein RAID0-System gleichzeitig 64K auf jedes von vier Laufwerken schreiben mit entsprechend besserer I/O-Leistung. Dieser Durchsatz kann durch die Verwendung mehrerer Controller noch zusätzlich gesteigert werden.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/geom/striping.png alt="Disk Striping Illustration"></div></div><div class=paragraph><p>Jedes Laufwerk in einem RAID0-Stripe muss die gleiche Größe haben, da I/O-Anforderungen für das Lesen und Schreiben abwechselnd auf mehrere Laufwerke parallel erfolgen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>RAID0 bietet keine Redundanz. Das bedeutet, dass wenn eine Platte im Array ausfällt, die gesamten Daten auf den Platten verloren gehen. Wenn es sich um wichtige Daten handelt, sollten Sie eine Backup-Strategie entwickeln, die regelmäßig Sicherungen auf einem entferntem System speichert.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Erstellung eines GEOM-basierten RAID0 auf einem FreeBSD-System wird im folgenden beschrieben. Nachdem das Stripe erzeugt wurde, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=gstripe&amp;sektion=8&amp;format=html">gstripe(8)</a> weitere Informationen zur Verwaltung der vorhandenen Stripes.</p></div><div class="sidebarblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Ein Stripe aus unformatierten ATA-Platten erzeugen</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Laden Sie das <span class=filename>geom_stripe.ko</span>-Modul:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_stripe</span></code></pre></div></div></li><li><p>Stellen Sie sicher, dass ein geeigneter Mountpunkt existiert. Falls dieser Datenträger eine Root-Partition werden soll, dann nutzen Sie zeitweise einen anderen Mountpunkt, beispielsweise <span class=filename>/mnt</span>.</p></li><li><p>Bestimmen Sie die Gerätenamen derjenigen Platten, welche gestriped werden sollen, und erzeugen Sie ein neues Stripe-Gerät. Das folgende Beispiel verwendet zwei unbenutzte und unpartitionierte ATA-Platten, die gestriped werden sollen. Die Gerätenamen lauten <span class=filename>/dev/ad2</span> und <span class=filename>/dev/ad3</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gstripe label -v st0 /dev/ad2 /dev/ad3</span>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</code></pre></div></div></li><li><p>Schreiben Sie einen Standard-Label (auch als Partitions-Tabelle bekannt) auf den neuen Datenträger und installieren Sie den normalen Bootstrap-Code:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/stripe/st0</span></code></pre></div></div></li><li><p>Dieser Prozess sollte zwei weitere Geräte im Verzeichnis <span class=filename>/dev/stripe</span> (zusätzlich zum Gerät <span class=filename>st0</span>) erzeugt haben. Diese schliessen <span class=filename>st0a</span> und <span class=filename>st0c</span> ein. Nun kann mit <code>newfs</code> ein UFS-Dateisystem auf dem Gerät <span class=filename>st0a</span> erzeugt werden:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/stripe/st0a</span></code></pre></div></div><div class=paragraph><p>Viele Zahlen rauschen nun über den Bildschirm und nach ein paar Sekunden wird der Prozess abgeschlossen sein. Der Datenträger wurde erzeugt und kann in den Verzeichnisbaum eingehängt werden.</p></div></li><li><p>Um das erzeugte Stripe manuell zu mounten:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/stripe/st0a /mnt</span></code></pre></div></div></li><li><p>Um das erzeugte Dateisystem automatisch während des Startvorgangs zu mounten, muss die Datenträgerinformation in <span class=filename>/etc/fstab</span> eingetragen werden. In diesem Beispiel wird ein permanenter Mountpunkt namens <span class=filename>stripe</span> erstellt:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /stripe</span>
<span class=c># echo &#34;/dev/stripe/st0a /stripe ufs rw 2 2&#34; \</span>
<span class=o>&gt;&gt;</span> /etc/fstab</code></pre></div></div></li><li><p>Das <span class=filename>geom_stripe.ko</span>-Modul muss ebenfalls automatisch beim Systemstart geladen werden (durch die Aufnahme der folgenden Zeile in die Datei <span class=filename>/boot/loader.conf</span>):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;geom_stripe_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div></li></ol></div></div></div></div></div><div class=sect1><h2 id=geom-mirror>18.3. RAID1 - Spiegelung<a class=anchor href=#geom-mirror></a></h2><div class=sectionbody><div class=paragraph><p>Spiegelung (RAID1 / <em>Mirroring</em>) ist eine Technik, bei der identische Daten auf mehr als ein Laufwerk geschrieben werden. Spiegel werden in der Regel zum Schutz vor Datenverlust aufgrund von Festplattenausfällen verwendet. Jedes Laufwerk in einem Spiegel enthält eine identische Kopie der Daten. Wenn ein einzelnes Laufwerk ausfällt, funktioniert der Spiegel weiterhin und die Daten werden von den restlichen Festplatten bereit gestellt. Der Rechner läuft einfach weiter und der Administrator hat die Gelegentheit, das defekte Laufwerk auszutauschen.</p></div><div class=paragraph><p>Zwei häufige Situationen werden in diesem Beispiel erläutert. Im ersten Beispiel wird ein Spiegel aus zwei neuen Laufwerken erstellt, der die existierende Platte ersetzt. Das zweite Beispiel erzeugt ein Spiegel mit einem einzigen Laufwerk, kopiert dann die Daten von der alten Platte und fügt die alte Platte zum Spiegel hinzu. Obwohl dieses Verfahren etwas komplizierter ist, wird nur ein neues Laufwerk benötigt.</p></div><div class=paragraph><p>Traditionell sind die Laufwerke in einem Spiegel vom gleichen Modell und besitzen die gleiche Kapazität. Dies ist jedoch keine Voraussetzung für <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a>. Hier können Spiegel mit unterschiedlichen Kapazitäten verwendet werden. Die Kapazität richtet sich dann nach dem kleinsten Laufwerk im Spiegel. Zusätzlicher Speicherplatz auf größeren Laufwerken bleibt dann ungenutzt. Werden später weitere Laufwerke zum Spiegel hinzugefügt, müssen diese mindestens so viel Kapazität haben wie das kleinste Laufwerk im Spiegel.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Die hier gezeigten Verfahren löschen keine Daten. Dennoch sollte, wie bei jeder größeren Operation, zuerst eine vollständige Sicherung erstellt werden.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Obwohl in diesem Abschnitt <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> zum Kopieren der Dateisysteme verwendet wird, funktioniert es nicht auf Dateisystemen mit aktiviertem Soft-Updates Journaling. In <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> finden Sie Informationen, wie Sie Soft-Updates Journaling erkennen und deaktivieren.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=geom-mirror-metadata>18.3.1. Probleme mit Metadaten<a class=anchor href=#geom-mirror-metadata></a></h3><div class=paragraph><p>Viele Plattensysteme speichern Metadaten am Ende der Platte. Alte Metadaten sollten vor der Wiederverwendung in einem Spiegel gelöscht werden, da die meisten Probleme aus zwei Arten von übrig gebliebenen Metadaten resultieren: GPT-Partitionstabellen und alte Metadaten aus einem vorherigen Spiegel.</p></div><div class=paragraph><p>GPT-Metadaten können mit <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> gelöscht werden. Dieses Beispiel löscht sowohl die primären, als auch die GPT-Partitionstabelle von der Festplatte <span class=filename>ada8</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart destroy -F ada8</span></code></pre></div></div><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> kann eine Platte aus einem aktiven Spiegel entfernt und gleichzeitig die Metadaten gelöscht werden. In diesem Beispiel wird die Platte <span class=filename>ada8</span> aus dem aktiven Spiegel <span class=filename>gm4</span> entfernt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror remove gm4 ada8</span></code></pre></div></div><div class=paragraph><p>Wenn der Spiegel nicht aktiv ist, sich jedoch noch alte Metadaten auf der Festplatte befinden, benutzen Sie <code>gmirror clear</code>, um die Metadaten zu entfernen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror clear ada8</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> speichert einen Datenblock an Metadaten am Ende der Festplatte. Da das GPT-Partitionschema die Metadaten auch am Ende der Platte speichert, wird es nicht empfohlen, mit <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> einen Spiegel aus einem gesamten GPT-Datenträger zu erstellen. In diesen Fällen sollte eine MBR-Partitionierung benutzt werden, weil hier nur eine Partitionstabelle am Anfang der Platte gespeichert wird und somit nicht mit den Metadaten des Spiegels im Konflikt steht.</p></div></div><div class=sect2><h3 id=geom-mirror-two-new-disks>18.3.2. Einen Spiegel mit zwei neuen Festplatten erstellen<a class=anchor href=#geom-mirror-two-new-disks></a></h3><div class=paragraph><p>In diesem Beispiel wurde FreeBSD bereits auf der vorhandenen Festplatte <span class=filename>ada0</span> installiert. Zwei neue Platten, <span class=filename>ada1</span> und <span class=filename>ada2</span>, wurden bereits mit dem System verbunden. Ein neuer Spiegel soll mit diesen beiden Platten erzeugt und verwendet werden, um die alte vorhandene Platte zu ersetzen.</p></div><div class=paragraph><p>Das Kernelmodul <span class=filename>geom_mirror.ko</span> muss entweder in den Kernel eingebaut, oder zur Laufzeit geladen werden. Sie können das Modul manuell laden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Erstellen Sie den Spiegel mit den beiden neuen Festplatten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror label -v gm0 /dev/ada1 /dev/ada2</span></code></pre></div></div><div class=paragraph><p><span class=filename>gm0</span> ist ein vom Benutzer gewählter Name, der dem neuen Spiegel zugeordnet wird. Nachdem der Spiegel gestartet wurde, erscheint dieser Gerätename in <span class=filename>/dev/mirror/</span>.</p></div><div class=paragraph><p>MBR- und bsdlabel-Partitionstabellen können jetzt auf dem neuen Spiegel erzeugt werden. Dieses Beispiel verwendet das herkömmliche Dateisystem-Layout für <span class=filename>/</span>, swap, <span class=filename>/var</span>, <span class=filename>/tmp</span> und <span class=filename>/usr</span>. Eine einzelne Root- und Swap-Partition würde ebenfalls funktionieren.</p></div><div class=paragraph><p>Die Partitionen auf dem Spiegel müssen nicht zwingend die gleiche Größe wie die auf der Festplatte haben, aber sie müssen groß genug sein, um alle Daten aufnehmen zu können, die bereits auf <span class=filename>ada0</span> gespeichert sind.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s MBR mirror/gm0</span>
<span class=c># gpart add -t freebsd -a 4k mirror/gm0</span>
<span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>       63  156301423  mirror/gm0  MBR  <span class=o>(</span>74G<span class=o>)</span>
         63         63                    - free -  <span class=o>(</span>31k<span class=o>)</span>
        126  156301299                 1  freebsd  <span class=o>(</span>74G<span class=o>)</span>
  156301425         61                    - free -  <span class=o>(</span>30k<span class=o>)</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s BSD mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k mirror/gm0s1</span>
<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>        0  156301299  mirror/gm0s1  BSD  <span class=o>(</span>74G<span class=o>)</span>
          0          2                      - free -  <span class=o>(</span>1.0k<span class=o>)</span>
          2    4194304                   1  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
    4194306    8388608                   2  freebsd-swap <span class=o>(</span>4.0G<span class=o>)</span>
   12582914    4194304                   4  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
   16777218    2097152                   5  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
   18874370  137426928                   6  freebsd-ufs  <span class=o>(</span>65G<span class=o>)</span>
  156301298          1                      - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Damit von dem Spiegel gebootet werden kann, muss der Bootcode in den MBR installiert, ein bsdlabel erstellt und die aktive Partition gesetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Erstellen Sie die Dateisysteme auf dem neuen Spiegel und aktivieren Sie Soft-Updates:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span></code></pre></div></div><div class=paragraph><p>Die Dateisysteme der vorhandenen Platte <span class=filename>ada0</span> können jetzt mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> auf den Spiegel kopiert werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/tmp</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/usr</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Fügen Sie die Dateisysteme für den Spiegel in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre># Device          Mountpoint       FStype  Options Dump    Pass#
/dev/mirror/gm0s1a      /               ufs     rw       1       1
/dev/mirror/gm0s1b      none            swap    sw       0       0
/dev/mirror/gm0s1d      /var            ufs     rw       2       2
/dev/mirror/gm0s1e      /tmp            ufs     rw       2       2
/dev/mirror/gm0s1f      /usr            ufs     rw       2       2</pre></div></div><div class=paragraph><p>Wenn das Modul <span class=filename>geom_mirror.ko</span> nicht im Kernel enthalten ist, können Sie <span class=filename>/mnt/boot/loader.conf</span> bearbeiten, damit das Modul beim Systemstart geladen wird:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten Sie das System neu und überprüfen Sie, ob alle Daten erfolgreich kopiert wurden. Das BIOS wird den Spiegel vermutlich als zwei einzelne Laufwerke erkennen. Da beide Laufwerke jedoch identisch sind, spielt es keine Rolle, welches Laufwerk zum Booten ausgewählt wird.</p></div><div class=paragraph><p>Falls es Probleme beim Booten gibt, lesen Sie den <a href=#gmirror-troubleshooting>Fehlerbehebung</a>. Die alte Festplatte <span class=filename>ada0</span> kann vom System getrennt und als Offline-Sicherung aufbewahrt werden.</p></div><div class=paragraph><p>Im laufenden Betrieb verhält sich der Spiegel genau wie ein einzelnes Laufwerk.</p></div></div><div class=sect2><h3 id=geom-mirror-existing-drive>18.3.3. Einen Spiegel mit einem vorhandenen Laufwerk erstellen<a class=anchor href=#geom-mirror-existing-drive></a></h3><div class=paragraph><p>In diesem Beispiel wurde FreeBSD bereits auf der Festplatte <span class=filename>ada0</span> installiert und eine weitere Platte, <span class=filename>ada1</span>, wurde an das System angeschlossen. Zunächst wird ein Spiegel mit einer Festplatte erstellt, dann das vorhandene System auf den Spiegel kopiert. Zuletzt wird die alte Festplatte in den Spiegel eingefügt. Diese etwas komplexere Vorgehensweise ist erforderlich, da <code>gmirror</code> 512 Byte an Metadaten am Ende der Festplatte speichert, und die bestehende Platte, <span class=filename>ada0</span>, in der Regel den Platz bereits belegt hat.</p></div><div class=paragraph><p>Laden Sie das Kernelmodul <span class=filename>geom_mirror.ko</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Prüfen Sie mit <code>diskinfo</code> die Mediengröße der vorhandenen Festplatte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># diskinfo -v ada0 | head -n3</span>
/dev/ada0
        512             <span class=c># sectorsize</span>
        1000204821504   <span class=c># mediasize in bytes (931G)</span></code></pre></div></div><div class=paragraph><p>Jetzt können Sie den Spiegel auf der neuen Festplatte erzeugen. Um sicherzustellen, dass die Kapazität nicht größer ist, als die Kapazität der vorhandenen Platte <span class=filename>ada0</span>, benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=gnop&amp;sektion=8&amp;format=html">gnop(8)</a> um eine Platte mit der exakt gleichen Größe zu imitieren. Diese Platte speichert keine Daten und wird nur verwendet, um die Größe des Spiegels zu begrenzen. <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> wird die Kapazität des Spiegels auf die Größe von <span class=filename>gzero.nop</span> beschränken, auch wenn die neue Festplatte <span class=filename>ada1</span> mehr Platz zur Verfügung hätte. Beachten Sie, dass <em>1000204821504</em> in der zweiten Zeile der ermittelten Mediengröße von <code>diskinfo</code> entspricht.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geom zero load</span>
<span class=c># gnop create -s 1000204821504 gzero</span>
<span class=c># gmirror label -v gm0 gzero.nop ada1</span>
<span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Da <span class=filename>gzero.nop</span> keine Daten speichert, sieht der Spiegel sie als nicht verbunden an. Der Spiegel ist so konfiguriert, dass er nicht verbundene Komponenten einfach "vergisst". Das Ergebnis ist ein Spiegel mit nur einer einzigen Platte, <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Sehen Sie sich nach der Erstellung von <span class=filename>gm0</span> die Partitionstabelle von <span class=filename>ada0</span> an. Diese Ausgabe stammt von einer 1 TB Festplatte. Falls am Ende der Platte noch freier Speicherplatz ist, kann der Inhalt von <span class=filename>ada0</span> direkt auf den Spiegel kopiert werden.</p></div><div class=paragraph><p>Falls jedoch der gesamte Speicherplatz auf der Platte zugeordnet ist, dann gibt es keinen Platz mehr für die 512 Byte Metadaten für den Spiegel am Ende der Platte, wie in dieser Auflistung zu sehen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>        63  1953525105        ada0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525105           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>In diesem Fall muss die Partitionstabelle bearbeitet werden, um die Kapazität von <span class=filename>mirror/gm0</span> um einen Sektor zu reduzieren. Dieses Verfahren wird später erläutert.</p></div><div class=paragraph><p>In beiden Fällen sollte die Partitionstabelle der primären Platte mit <code>gpart backup</code> gesichert werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart backup ada0 &gt; table.ada0</span>
<span class=c># gpart backup ada0s1 &gt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>Diese Kommandos erstellen zwei Dateien, <span class=filename>table.ada0</span> und <span class=filename>table.ada0s1</span>. Das Beispiel verwendet eine 1 TB Festplatte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525105   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640881</code></pre></div></div><div class=paragraph><p>Wenn am Ende der Platte kein Platz vorhanden ist, muss die Größe des Slice und der letzten Partition verringert werden. Bearbeiten Sie die beiden Dateien, und verringern Sie die Größe der Slice und der Partition jeweils um eins. Dies bezieht sich auf die letzten Zahlen in der Liste.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525104   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640880</code></pre></div></div><div class=paragraph><p>Wenn mindestens ein Sektor der Platte nicht zugewiesen wurde, kann die Platte ohne Modifikation verwendet werden.</p></div><div class=paragraph><p>Jetzt kann die Partitionstabelle auf <span class=filename>mirror/gm0</span> wiederhergestellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart restore mirror/gm0 &lt; table.ada0</span>
<span class=c># gpart restore mirror/gm0s1 &lt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>Prüfen Sie die Partitionstabellen mit <code>gpart show</code>. Dieses Beispiel nutzt <span class=filename>gm0s1a</span> für <span class=filename>/</span>, <span class=filename>gm0s1d</span> für <span class=filename>/var</span>, <span class=filename>gm0s1e</span> für <span class=filename>/usr</span>, <span class=filename>gm0s1f</span> für <span class=filename>/data1</span> und <span class=filename>gm0s1g</span> für <span class=filename>/data2</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>        63  1953525104  mirror/gm0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525042           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span>
  1953525105          62              - free -  <span class=o>(</span>31k<span class=o>)</span>

<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>         0  1953525042  mirror/gm0s1  BSD  <span class=o>(</span>931G<span class=o>)</span>
           0     2097152             1  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
     2097152    16777216             2  freebsd-swap  <span class=o>(</span>8.0G<span class=o>)</span>
    18874368    41943040             4  freebsd-ufs  <span class=o>(</span>20G<span class=o>)</span>
    60817408    20971520             5  freebsd-ufs  <span class=o>(</span>10G<span class=o>)</span>
    81788928   629145600             6  freebsd-ufs  <span class=o>(</span>300G<span class=o>)</span>
   710934528  1242590514             7  freebsd-ufs  <span class=o>(</span>592G<span class=o>)</span>
  1953525042          63                - free -  <span class=o>(</span>31k<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Sowohl die Slice, als auch die letzte Partition, muss mindestens einen freien Block am Ende der Platte haben.</p></div><div class=paragraph><p>Erstellen Sie Dateisysteme auf diesen neuen Partitionen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span>
<span class=c># newfs -U /dev/mirror/gm0s1g</span></code></pre></div></div><div class=paragraph><p>Damit Sie von dem Spiegel booten können, müssen Sie den Bootcode in den MBR installieren, ein bsdlabel anlegen und das aktive Slice setzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Bearbeiten Sie <span class=filename>/etc/fstab</span>, um die neuen Partitionen auf dem Spiegel nutzen zu können. Speichern Sie zunächst eine Kopie der Datei unter <span class=filename>/etc/fstab.orig</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/fstab /etc/fstab.orig</span></code></pre></div></div><div class=paragraph><p>Ersetzen Sie in <span class=filename>/etc/fstab</span> <span class=filename>/dev/ada0</span> durch <span class=filename>mirror/gm0</span>.</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/usr		ufs	rw	2	2
/dev/mirror/gm0s1f	/data1		ufs	rw	2	2
/dev/mirror/gm0s1g	/data2		ufs	rw	2	2</pre></div></div><div class=paragraph><p>Wenn das Modul <span class=filename>geom_mirror.ko</span> nicht im Kernel enthalten ist, können Sie <span class=filename>/boot/loader.conf</span> bearbeiten, damit das Modul beim Systemstart geladen wird:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Die Dateisysteme der ursprünglichen Platte können jetzt mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> auf den Spiegel kopiert werden. Wenn Sie das Dateisystem mit <code>dump -L</code> sichern, wird zunächst ein Snapshot des Dateisystems erstellt, was einige Zeit dauern kann.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/usr</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/data1</span>
<span class=c># mount /dev/mirror/gm0s1g /mnt/data2</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Starten Sie das System neu und booten Sie von <span class=filename>ada1</span>. Wenn alles funktioniert, wird das System von <span class=filename>mirror/gm0</span> booten, welches jetzt die gleichen Daten enthält wie <span class=filename>ada0</span>. Lesen Sie <a href=#gmirror-troubleshooting>Fehlerbehebung</a>, falls es Probleme beim Booten gibt.</p></div><div class=paragraph><p>An dieser Stelle besteht der Spiegel immer noch aus der einzelnen Platte <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Nachdem erfolgreich von <span class=filename>mirror/gm0</span> gebootet wurde, besteht der letzte Schritt darin, <span class=filename>ada0</span> in den Spiegel einzufügen.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Wenn Sie <span class=filename>ada0</span> in den Spiegel einfügen, wird der Inhalt der Platte mit den Daten aus dem Spiegel überschrieben. Sie müssen sicherstellen, das <span class=filename>mirror/gm0</span> den gleichen Inhalt wie <span class=filename>ada0</span> hat, bevor Sie <span class=filename>ada0</span> zum Spiegel hinzufügen. Falls der zuvor mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> kopierte Inhalt nicht mit dem von <span class=filename>ada0</span> identisch ist, machen Sie die Änderungen an <span class=filename>/etc/fstab</span> rückgängig, starten Sie das System neu und beginnen Sie die Prozedur von vorn.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 ada0</span>
GEOM_MIRROR: Device gm0: rebuilding provider ada0</code></pre></div></div><div class=paragraph><p>Die Synchronisation zwischen den beiden Platten wird direkt gestartet. Verwenden Sie <code>gmirror status</code> um den Fortschritt zu beobachten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror status</span>
      Name    Status  Components
girror/gm0  DEGRADED  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>SYNCHRONIZING, 64%<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Nach einer Weile wird die Wiederherstellung abgeschlossen sein.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
<span class=c># gmirror status</span>
      Name    Status  Components
mirror/gm0  COMPLETE  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>ACTIVE<span class=o>)</span></code></pre></div></div><div class=paragraph><p><span class=filename>mirror/gm0</span> besteht nun aus den beiden Platten <span class=filename>ada0</span> und <span class=filename>ada1</span>. Der Inhalt der beiden Platten wird automatisch miteinander synchronisiert. Im laufenden Betrieb verhält sich <span class=filename>mirror/gm0</span> wie eine einzelne Festplatte.</p></div></div><div class=sect2><h3 id=gmirror-troubleshooting>18.3.4. Fehlerbehebung<a class=anchor href=#gmirror-troubleshooting></a></h3><div class=paragraph><p>Falls das System nicht mehr startet, müssen möglicherweise die BIOS-Einstellungen geändert werden, um von dem neuen gespiegelten Laufwerk zu booten. Beide Platten des Spiegels können zum Booten verwendet werden, da sie als Komponenten des Spiegels identische Daten enthalten.</p></div><div class=paragraph><p>Wenn der Bootvorgang mit der folgenden Meldung abbricht, ist irgendwas mit dem Spiegel nicht in Ordnung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

Loader variables:
  vfs.root.mountfrom<span class=o>=</span>ufs:/dev/mirror/gm0s1a
  vfs.root.mountfrom.options<span class=o>=</span>rw

Manual root filesystem specification:
  &lt;fstype&gt;:&lt;device&gt; <span class=o>[</span>options]
      Mount &lt;device&gt; using filesystem &lt;fstype&gt;
      and with the specified <span class=o>(</span>optional<span class=o>)</span> option list.

    eg. ufs:/dev/da0s1a
        zfs:tank
        cd9660:/dev/acd0 ro
          <span class=o>(</span>which is equivalent to: mount <span class=nt>-t</span> cd9660 <span class=nt>-o</span> ro /dev/acd0 /<span class=o>)</span>

  ?               List valid disk boot devices
  <span class=nb>.</span>               Yield 1 second <span class=o>(</span><span class=k>for </span>background tasks<span class=o>)</span>
  &lt;empty line&gt;    Abort manual input

mountroot&gt;</code></pre></div></div><div class=paragraph><p>Dieses Problem kann durch ein nicht geladenes Kernelmodul <span class=filename>geom_mirror.ko</span> in <span class=filename>/boot/loader.conf</span> verursacht werden. Um das Problem zu beheben, booten Sie von einem FreeBSD-Installationsmedium und wählen Sie <code>Shell</code> an der Eingabeaufforderung. Laden Sie dann das Modul und hängen Sie den Spiegel ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span>
<span class=c># mount /dev/mirror/gm0s1a /mnt</span></code></pre></div></div><div class=paragraph><p>Bearbeiten Sie dann <span class=filename>/mnt/boot/loader.conf</span> und fügen Sie eine Zeile für das Kernelmodul hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Speichern Sie die Datei und starten Sie das System neu.</p></div><div class=paragraph><p>Andere Probleme, die <code>error 19</code> verursachen können, sind nur mit mehr Aufwand zu beheben. Obwohl das System von <span class=filename>ada0</span> booten sollte, wird ein weiterer Prompt erscheinen, wenn <span class=filename>/etc/fstab</span> fehlerhaft ist. Geben Sie am Loader-Prompt <code>ufs:/dev/ada0s1a</code> ein und drücken Sie <kbd>Enter</kbd>. Machen Sie die Änderungen an <span class=filename>/etc/fstab</span> rückgängig und hängen Sie anstelle des Spiegels die originale Festplatte (<span class=filename>ada0</span>) ein. Starten Sie dann das System neu und versuchen Sie den Vorgang erneut.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter full pathname of shell or RETURN <span class=k>for</span> /bin/sh:
<span class=c># cp /etc/fstab.orig /etc/fstab</span>
<span class=c># reboot</span></code></pre></div></div></div><div class=sect2><h3 id=_wiederherstellung_des_systems_nach_einem_plattenausfall>18.3.5. Wiederherstellung des Systems nach einem Plattenausfall<a class=anchor href=#_wiederherstellung_des_systems_nach_einem_plattenausfall></a></h3><div class=paragraph><p>Der Vorteil der Plattenspiegelung ist, dass eine Platte ausfallen kann, ohne dass Sie dabei Daten verlieren. Falls <span class=filename>ada0</span> aus dem obigen Beispiel ausfällt, steht der Spiegel weiterhin zur Verfügung und bietet die Daten von der verbleibenden Platte <span class=filename>ada1</span> an.</p></div><div class=paragraph><p>Um das ausgefallene Laufwerk zu ersetzen, muss das System heruntergefahren werden und das ausgefallene Laufwerk durch ein neues Laufwerk von gleicher oder größerer Kapazität ersetzt werden. Hersteller verwenden oft etwas willkürliche Werte für die Kapazität. Der einzige Weg, um wirklich sicher zu sein, ist die Gesamtzahl der Sektoren von <code>diskinfo -V</code> zu vergleichen. Ein Laufwerk mit größerer Kapazität wird funktionieren, allerdings wird der zusätzliche Platz ungenutzt bleiben.</p></div><div class=paragraph><p>Nachdem der Rechner wieder eingeschaltet ist, wird der Spiegel im "degraded" Modus ausgeführt werden. Der Spiegel wird angewiesen, Laufwerke zu vergessen, die noch nicht verbunden sind:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Alte Metadaten sollten von der Ersatzfestplatte nach den Anweisungen in <a href=#geom-mirror-metadata>Probleme mit Metadaten</a> gelöscht werden. Anschließend kann die Ersatzfestplatte, in diesem Beispiel <span class=filename>ada4</span>, in den Spiegel eingefügt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 /dev/ada4</span></code></pre></div></div><div class=paragraph><p>Die Wiederherstellung beginnt, sobald das neue Laufwerk in den Spiegel eingesetzt wird. Das Kopieren der Daten vom Spiegel auf das neue Laufwerk kann eine Weile dauern. Die Leistung des Spiegels ist während dieser Zeit stark reduziert, deswegen sollten neue Laufwerke idealerweise dann eingefügt werden, wenn der Rechner nicht benötigt wird.</p></div><div class=paragraph><p>Der Fortschritt der Wiederherstellung kann mit <code>gmirror status</code> überwacht werden. Während der Wiederherstellung ist der Status <code>DEGRADED</code>. Wenn der Vorgang abgeschlossen ist, wechselt der Status zu <code>COMPLETE</code>.</p></div></div></div></div><div class=sect1><h2 id=geom-raid3>18.4. RAID3 - Byte-Level Striping mit dedizierter Parität<a class=anchor href=#geom-raid3></a></h2><div class=sectionbody><div class=paragraph><p>RAID3 ist eine Methode, die mehrere Festplatten zu einem einzigen Volume mit einer dedizierten Paritätsfestplatte kombiniert. In einem RAID3-System werden die Daten in einzelne Bytes aufgeteilt und dann über alle Laufwerke, mit Ausnahme der Paritätsfestplatte, geschrieben. Beim Lesen von Daten in einer RAID3 Implementierung werden alle Festplatten im Array parallel genutzt. Die Leistung kann durch den Einsatz von mehreren Controllern weiter erhöht werden. Ein RAID3-Array hat eine Fehlertoleranz von 1 Laufwerk und bietet dabei eine Kapazität von 1 - 1/n der Gesamtkapazität der Laufwerke im Array, wobei n die Anzahl der Festplatten im Array darstellt. So eine Konfiguration ist meistens für die Speicherung von größeren Dateien geeignet, wie beispielsweise Multimediadateien.</p></div><div class=paragraph><p>Mindestens 3 Festplatten sind erforderlich, um ein RAID3 zu erstellen. Jede Festplatte muss von der gleichen Größe sein, da die I/O-Anfragen für Lesen oder Schreiben auf mehreren Festplatten parallel stattfinden. Aufgrund der Beschaffenheit von RAID3, muss die Anzahl der Laufwerke 3, 5, 9, 17 bzw. 2^n + 1 sein.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie ein Software RAID3 auf einem FreeBSD-System erstellt wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Obwohl es theoretisch möglich ist FreeBSD von einem RAID3-Array zu booten, wird von solch einer ungewöhnlichen Konfiguration dringend abgeraten.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_ein_dediziertes_raid3_array_erstellen>18.4.1. Ein dediziertes RAID3-Array erstellen<a class=anchor href=#_ein_dediziertes_raid3_array_erstellen></a></h3><div class=paragraph><p>In FreeBSD wird die Unterstützung für RAID3 über die GEOM-Klasse <a href="https://man.freebsd.org/cgi/man.cgi?query=graid3&amp;sektion=8&amp;format=html">graid3(8)</a> implementiert. Zum Erstellen eines dedizierten RAID3-Arrays sind folgende Schritte erforderlich.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Laden Sie zunächst das Modul <span class=filename>geom_raid3.ko</span> mit einem der folgenden Befehle:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 load</span></code></pre></div></div><div class=paragraph><p>oder:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_raid3</span></code></pre></div></div></li><li><p>Stellen Sie sicher, dass ein geeigneter Mountpunkt existiert. Dieser Befehl erstellt ein neues Verzeichnis, welches als Mountpunkt verwendet werden kann:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /multimedia</span></code></pre></div></div></li><li><p>Bestimmen Sie die Gerätenamen der Festplatten, die dem Array hinzugefügt werden und erstellen Sie ein neues RAID3 Gerät. Das letzte aufgeführte Gerät wird als dediziertes Paritätslaufwerk verwendet. Dieses Beispiel verwendet drei unpartionierte ATA-Platten: <span class=filename>ada1</span> und <span class=filename>ada2</span> für die Daten, sowie <span class=filename>ada3</span> für die Parität.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</span>
Metadata value stored on /dev/ada1.
Metadata value stored on /dev/ada2.
Metadata value stored on /dev/ada3.
Done.</code></pre></div></div></li><li><p>Partitionieren Sie das neu erstelle Gerät <span class=filename>gr0</span> und erstellen Sie darauf ein UFS-Dateisystem:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT /dev/raid3/gr0</span>
<span class=c># gpart add -t freebsd-ufs /dev/raid3/gr0</span>
<span class=c># newfs -j /dev/raid3/gr0p1</span></code></pre></div></div><div class=paragraph><p>Viele Zahlen rauschen nun über den Bildschirm und nach einer gewissen Zeit ist der Vorgang abgeschlossen. Das Volume wurde erstellt und kann jetzt in den Verzeichnisbaum eingehangen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/raid3/gr0p1 /multimedia/</span></code></pre></div></div><div class=paragraph><p>Das RAID3-Array ist nun einsatzbereit.</p></div></li></ol></div><div class=paragraph><p>Weitere Konfigurationsschritte sind erforderlich, um die Einstellungen nach einem Systemneustart zu erhalten.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Das Modul <span class=filename>geom_raid3.ko</span> muss geladen werden, bevor das Array eingehangen werden kann. Damit das Kernelmodul automatisch beim Systemstart geladen wird, muss die folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzugefügt werden:</p><div class="literalblock programlisting"><div class=content><pre>geom_raid3_load=&#34;YES&#34;</pre></div></div></li><li><p>Die folgenden Informationen über das Volume müssen in <span class=filename>/etc/fstab</span> hinzugefügt werden, um das Dateisystem des Arrays automatisch beim Systemstart zu aktivieren:</p><div class="literalblock programlisting"><div class=content><pre>/dev/raid3/gr0p1	/multimedia	ufs	rw	2	2</pre></div></div></li></ol></div></div></div></div><div class=sect1><h2 id=geom-graid>18.5. Software RAID<a class=anchor href=#geom-graid></a></h2><div class=sectionbody><div class=paragraph><p>Einige Motherboards und Erweiterungskarten besitzen ein ROM, das dem Rechner erlaubt von einem RAID-Array zu booten. Nach dem Booten wird der Zugriff auf das RAID-Array durch die Software auf dem Prozessor des Rechners abgewickelt. Dieses "Hardware-unterstützte Software-RAID" ist nicht abhängig von einem bestimmten Betriebssystem. Sie funktionieren bereits, noch bevor das Betriebssystem geladen wird.</p></div><div class=paragraph><p>Abhängig von der verwendeten Hardware werden mehrere Arten von RAID unterstützt. Eine vollständige Liste finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a>.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> benötigt das <span class=filename>geom_raid.ko</span> Kernelmodul, welches beginnend mit FreeBSD 9.1 im <span class=filename>GENERIC</span>-Kernel enthalten ist. Bei Bedarf kann es manuell mit <code>graid load</code> geladen werden.</p></div><div class=sect2><h3 id=geom-raid-creating>18.5.1. Ein Array erstellen<a class=anchor href=#geom-raid-creating></a></h3><div class=paragraph><p>Geräte mit Software-RAID haben oft ein Menü, das über eine bestimmte Tastenkombination beim Booten aufgerufen werden kann. Das Menü kann verwendet werden, um RAID-Arrays zu erstellen und zu löschen. Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> können Arrays auch direkt von der Kommandozeile erstellt werden.</p></div><div class=paragraph><p><code>graid label</code> wird verwendet, um ein neues Array zu erstellen. Das Motherboard in diesem Beispiel besitzt einen Intel® Software-RAID Chipsatz, so dass das Metadatenformat von Intel® angegeben wird. Das neue Array bekommt den Namen (Label) <span class=filename>gm0</span>, verhält sich als Spiegel (RAID1) und verwendet die Laufwerke <span class=filename>ada0</span> und <span class=filename>ada1</span>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Bei der Erstellung des Arrays wird etwas Platz auf den Laufwerken überschrieben. Sichern Sie zuvor alle vorhandenen Daten!</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 ada1</span>
GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.
GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Array started.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.
Intel-a29ea104 created<span class=err>$</span>
GEOM_RAID: Intel-a29ea104: Provider raid/r0 <span class=k>for </span>volume gm0 created.</code></pre></div></div><div class=paragraph><p>Eine Statusabfrage zeigt, dass der neue Spiegel einsatzbereit ist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Das Array-Gerät erscheint in <span class=filename>/dev/raid/</span>. Das erste Gerät heißt <span class=filename>r0</span>. Falls weitere Geräte vorhanden sind heißen diese <span class=filename>r1</span>, <span class=filename>r2</span> und so weiter.</p></div><div class=paragraph><p>Das BIOS-Menü einiger Geräte erstellt Arrays mit Sonderzeichen im Namen. Um Probleme mit diesen Sonderzeichen zu vermeiden, werden einfache numerische Namen wie <span class=filename>r0</span> vergeben. Um das tatsächliche Label anzuzeigen, wie <span class=filename>gm0</span> im obigen Beispiel, benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.raid.name_format=1</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-volumes>18.5.2. Mehrere Volumes<a class=anchor href=#geom-graid-volumes></a></h3><div class=paragraph><p>Einige Software-RAID Geräte unterstützen mehr als ein <em>Volume</em> pro Array. Volumes funktionieren wie Festplatten, dass heißt der Platz auf den Laufwerken kann auf unterschiedliche Weise geteilt und genutzt werden. Intels Software-RAID Geräte unterstützen beispielsweise zwei Volumes. In diesem Beispiel wird ein 40 GB Spiegel verwendet um das Betriebssystem zu speichern, gefolgt von einem 20 GB RAID0 (Stripe) Volume für die schnelle Speicherung von temporären Daten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label -S 40G Intel gm0 RAID1 ada0 ada1</span>
<span class=c># graid add -S 20G gm0 RAID0</span></code></pre></div></div><div class=paragraph><p>Volumes erscheinen unter <span class=filename>/dev/raid/</span> als zusätzliche Einträge <span class=filename>rX</span>. Ein Array mit Volumes wird als <span class=filename>r0</span> und <span class=filename>r1</span>.</p></div><div class=paragraph><p>Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> um die Anzahl der Volumes zu ermitteln, die von den verschiedenen Software-RAID Geräten unterstützt wird.</p></div></div><div class=sect2><h3 id=geom-graid-converting>18.5.3. Ein einzelnes Laufwerk zu einem Spiegel konvertieren<a class=anchor href=#geom-graid-converting></a></h3><div class=paragraph><p>Unter bestimmten Umständen ist es möglich, ein bestehendes Laufwerk ohne Neuformatierung zu einem <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> Array zu konvertieren. Um Datenverlust bei der Konvertierung zu vermeiden, müssen die vorhandenen Laufwerke folgende Mindestanforderungen erfüllen:</p></div><div class=ulist><ul><li><p>Das Laufwerk muss mit MBR partitioniert werden. GPT oder andere Partitionierungsschemata funktionieren nicht, da durch <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> die Metadaten am Ende des Laufwerks überschieben und beschädigt werden.</p></li><li><p>Am Ende des Laufwerks muss genügend freier Platz zur Verfügung stehen, um die <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> Metadaten zu speichern. Die Metadaten variieren in der Größe, es werden jedoch mindestens 64 MB freier Speicherplatz empfohlen.</p></li></ul></div><div class=paragraph><p>Wenn das Laufwerk diese Anforderungen erfüllt, erstellen Sie zuerst eine vollständige Sicherung. Erzeugen Sie dann einen Spiegel mit diesem einen Laufwerk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 NONE</span></code></pre></div></div><div class=paragraph><p>Die Metadaten von <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> werden in den ungenutzten Raum am Ende des Laufwerks geschrieben. Ein zweites Laufwerk kann nun in den Spiegel eingefügt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span></code></pre></div></div><div class=paragraph><p>Die Daten von dem ersten Laufwerk werden direkt auf das zweite Laufwerk kopiert. Der Spiegel wird im eingeschränkten Zustand laufen, bis der Kopiervorgang abgeschlossen ist.</p></div></div><div class=sect2><h3 id=geom-graid-inserting>18.5.4. Neue Laufwerke zum Array hinzufügen<a class=anchor href=#geom-graid-inserting></a></h3><div class=paragraph><p>Laufwerke in einem Array können für ausgefallene oder fehlende Laufwerke eingesetzt werden. Falls es keine ausgefallenen oder fehlenden Laufwerke gibt, wird das neue Laufwerk als Ersatz (Spare) verwendet.</p></div><div class=paragraph><p>Das Array in diesem Beispiel beginnt sofort damit, die Daten auf das neu hinzugefügte Laufwerk zu kopieren. Alle vorhandenen Daten auf dem neuen Laufwerk werden überschrieben.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.</code></pre></div></div></div><div class=sect2><h3 id=geom-graid-removing>18.5.5. Laufwerke aus dem Array entfernen<a class=anchor href=#geom-graid-removing></a></h3><div class=paragraph><p>Einzelne Laufwerke können permanent aus dem Array entfernt werden. Die Metadaten werden dabei gelöscht:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid remove raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.</code></pre></div></div></div><div class=sect2><h3 id=geom-graid-stopping>18.5.6. Das Array anhalten<a class=anchor href=#geom-graid-stopping></a></h3><div class=paragraph><p>Ein Array kann angehalten werden, ohne die Metadaten von den Laufwerken zu löschen. Das Array wird wieder anlaufen, wenn das System neu gestartet wird.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid stop raid/r0</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-status>18.5.7. Den Status des Arrays überprüfen<a class=anchor href=#geom-graid-status></a></h3><div class=paragraph><p>Der Status des Arrays kann jederzeit überprüft werden. Nachdem ein Laufwerk zum Array hinzugefügt wurde, werden die Daten vom ursprünglichen Laufwerk auf das neue Laufwerk kopiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name    Status  Components
raid/r0  DEGRADED  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                   ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>REBUILD 28%<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Andere Arten von Arrays, wie <code>RAID0</code> oder <code>CONCAT</code>, werden den Status eines fehlgeschlagenen Laufwerks vielleicht nicht anzeigen. Um diese teilweise ausgefallenen Arrays anzuzeigen, fügen Sie <code>-ga</code> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status -ga</span>
          Name  Status  Components
Intel-e2d07d9a  BROKEN  ada6 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-deleting>18.5.8. Arrays löschen<a class=anchor href=#geom-graid-deleting></a></h3><div class=paragraph><p>Arrays werden zerstört, indem alle Volumes gelöscht werden. Wenn das letzte Volume gelöscht wird, wird das Array gestoppt und die Metadaten von den Laufwerken entfernt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-unexpected>18.5.9. Unerwartete Arrays löschen<a class=anchor href=#geom-graid-unexpected></a></h3><div class=paragraph><p>Laufwerke können unerwartete <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> Metadaten enthalten, entweder aus früherer Nutzung oder aus Tests des Herstellers. <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> würde diese Metadaten erkennen und daraus ein Array erstellen, was den Zugriff auf die einzelnen Laufwerke beeinträchtigen würde. Um die unerwünschten Metadaten zu entfernen:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Booten Sie das System. Im Boot-Menü wählen Sie <code>2</code> für den Loader-Prompt. Geben Sie dann folgendes ein:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>OK <span class=nb>set </span>kern.geom.raid.enable<span class=o>=</span>0
OK boot</code></pre></div></div><div class=paragraph><p>Das System wird nun mit deaktiviertem <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> starten.</p></div></li><li><p>Sichern Sie alle Daten auf dem betroffenen Laufwerk.</p></li><li><p>Zur Abhilfe kann auch die Array-Erkennung von <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> deaktiviert werden, indem</p><div class="literalblock programlisting"><div class=content><pre>kern.geom.raid.enable=0</pre></div></div><div class=paragraph><p>in <span class=filename>/boot/loader.conf</span> hinzugefügt wird.</p></div><div class=paragraph><p>Um die <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> Metadaten von dem entsprechenden Laufwerk zu entfernen, booten Sie vom FreeBSD Installationsmedium und wählen Sie <code>Shell</code> aus. Benutzen Sie <code>status</code>, um den Namen des Arrays zu bestimmten, typischerweise <code>raid/r0</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Löschen Sie das Volume:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div><div class=paragraph><p>Wiederholen Sie den Vorgang für jedes Volume. Nachdem das letzte Volume gelöscht wurde, wird das Volume zerstört.</p></div><div class=paragraph><p>Starten Sie das System neu und prüfen die Vollständigkeit der Daten. Falls erforderlich, müssen die Daten aus der Sicherung wiederhergestellt werden. Nachdem die Metadaten entfernt wurden, kann auch der Eintrag <code>kern.geom.raid.enable=0</code> aus <span class=filename>/boot/loader.conf</span> entfernt werden.</p></div></li></ol></div></div></div></div><div class=sect1><h2 id=geom-ggate>18.6. GEOM Gate Netzwerk<a class=anchor href=#geom-ggate></a></h2><div class=sectionbody><div class=paragraph><p>GEOM unterstützt einen einfachen Mechanismus für den Zugriff auf entfernte Geräte wie Festplatten, CDs und Dateien, durch die Verwendung des GEOM Gate Netzwerk Daemons, ggated. Der Server-Dameon läuft auf dem System, welches ein Gerät anbietet und bearbeitet die ggatec-Anfragen der Clients. Die Geräte sollten keine sensiblen Daten enthalten, da die Verbindung zwischen Client und Server nicht verschlüsselt ist.</p></div><div class=paragraph><p>Ähnlich wie bei NFS, das in <a href=../network-servers/#network-nfs>Network File System (NFS)</a> beschrieben ist, wird für die Konfiguration von ggated eine Exportdatei verwendet. Diese Datei legt fest, welche Systeme auf die exportierten Ressourcen zugreifen können und in welchem Umfang der Zugriff gestattet wird. Um dem Client <code>192.168.1.5</code> Lese- und Schreibzugriff auf die vierte Slice der ersten SCSI-Platte zu geben, erstellen Sie <span class=filename>/etc/gg.exports</span> mit folgender Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.1.5 RW /dev/da0s4d</pre></div></div><div class=paragraph><p>Bevor das Gerät exportiert werden kann, müssen Sie sicherstellen, dass es nicht bereits gemountet ist. Anschließend starten Sie ggated.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggated</span></code></pre></div></div><div class=paragraph><p>Es stehen mehrere Optionen bereit, mit denen zum Beispiel ein alternativer Port oder eine alternative Exportdatei festgelegt werden kann. Weitere Einzelheiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ggated&amp;sektion=8&amp;format=html">ggated(8)</a>.</p></div><div class=paragraph><p>Damit ein Client auf das exportierte Gerät zugreifen kann, benutzten Sie ggatec zusammen mit der IP-Adresse des Servers und dem entsprechenden Gerätenamen. Wenn dies erfolgreich ist, zeigt dieser Befehl einen <code>ggate</code>-Gerätenamen. Hängen Sie dieses Gerät in einen freien Mountpunkt ein. Dieses Beispiel verbindet sich mit der Partition <span class=filename>/dev/da0s4d</span> auf <code>192.168.1.1</code> und hängt <span class=filename>/dev/ggate0</span> in <span class=filename>/mnt</span> ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggatec create -o rw 192.168.1.1 /dev/da0s4d</span>
ggate0
<span class=c># mount /dev/ggate0 /mnt</span></code></pre></div></div><div class=paragraph><p>Auf das Gerät des Servers kann jetzt über den Mountpunkt <span class=filename>/mnt</span> des Clients zugegriffen werden. Weitere Informationen über <code>ggatec</code> und einige Anwendungsbeispiele finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ggatec&amp;sektion=8&amp;format=html">ggatec(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das Einhängen des Gerätes wird scheitern, falls das Gerät momentan entweder auf dem Server oder einem Client im Netzwerk gemountet ist. Wenn ein gleichzeitiger Zugriff auf die Netzwerkressourcen benötigt wird, verwenden Sie stattdessen NFS.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn das Gerät nicht länger gebraucht wird, kann es mit <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> ausgehängt werden, so dass die Ressourcen für andere Client wieder verfügbar sind.</p></div></div></div><div class=sect1><h2 id=geom-glabel>18.7. Das Labeln von Laufwerken<a class=anchor href=#geom-glabel></a></h2><div class=sectionbody><div class=paragraph><p>Während der Initialisierung des Systems legt der FreeBSD-Kernel für jedes gefundene Gerät Knotenpunkte an. Diese Methode für die Überprüfung auf vorhandene Geräte wirft einige Fragen auf. Was passiert beispielsweise, wenn ein neues USB-Laufwerk hinzugefügt wird? Es ist sehr wahrscheinlich, dass ein Flash-Speicher-Gerät den Gerätenamen <span class=filename>da0</span> erhält, während gleichzeitig das bisherige <span class=filename>da0</span> zu <span class=filename>da1</span> wird. Dies verursacht Probleme beim Einhängen von Dateisystemen, wenn diese in <span class=filename>/etc/fstab</span> aufgeführt sind und kann dazu führen, dass das System nicht mehr startet.</p></div><div class=paragraph><p>Eine Lösung für dieses Problem ist das Aneinanderketten der SCSI-Geräte, damit ein neues Gerät, welches der SCSI-Karte hinzugefügt wird, unbenutzte Gerätenummern erhält. Aber was geschieht, wenn ein USB-Gerät möglicherweise die primäre SCSI-Platte ersetzt? Dies kann passieren, weil USB-Geräte normalerweise vor der SCSI-Karte geprüft werden. Eine Lösung ist das Hinzufügen dieser Geräte, nachdem das System gestartet ist. Eine andere Lösung könnte sein, nur ein einzelnes ATA-Laufwerk zu nutzen und die SCSI-Geräte niemals in der <span class=filename>/etc/fstab</span> aufzuführen.</p></div><div class=paragraph><p>Eine bessere Lösung ist die Verwendung von <code>glabel</code>, um die Laufwerke zu mit Labeln zu versehen und diese in <span class=filename>/etc/fstab</span> zu nutzen. Da <code>glabel</code> seine Label im letzten Sektor jedes vorhandenen Datenträgers speichert, wird das Label persistent bleiben (auch über Neustarts hinweg). Durch Nutzung dieses Labels als Gerät kann das Dateisystem immer gemountet sein, unabhängig davon, durch welchen Geräte-Knotenpunkt auf ihn zugegriffen wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>glabel</code> kann permanente (dauerhaft) und vorübergehende Label erstellen. Aber nur dauerhafte Label bleiben konsistent über Neustarts hinweg. Lesen Sie die <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> für weitere Unterschiede zwischen den Label-Typen.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_label_typen_und_beispiele>18.7.1. Label-Typen und Beispiele<a class=anchor href=#_label_typen_und_beispiele></a></h3><div class=paragraph><p>Permanente Label können generische Label oder Dateisystem-Label sein. Permanente Dateisystem-Label können mit <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> erzeugt werden. Dieser Typ von Label wird in einem Unterverzeichnis von <span class=filename>/dev</span> angelegt und wird dem Dateisystem entsprechend benannt. UFS2-Dateisystem-Label werden zum Beispiel in <span class=filename>/dev/ufs</span> angelegt. Permanente Label können außerdem durch den Befehl <code>glabel label</code> erzeugt werden. Diese Label sind nicht dateisystemspezisch und werden im Unterverzeichnis <span class=filename>/dev/label</span> erzeugt.</p></div><div class=paragraph><p>Temporäre Label werden beim nächsten Systemstart zerstört. Diese Label werden im Verzeichnis <span class=filename>/dev/label</span> erzeugt und sind ideal für Testzwecke. Ein temporäres Label kann mit <code>glabel create</code> erzeugt werden.</p></div><div class=paragraph><p>Um ein permanentes Label auf einem UFS2-Dateisystem ohne Löschung von Daten zu erzeugen, kann man folgenden Befehl verwenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -L home /dev/da3</span></code></pre></div></div><div class=paragraph><p>In <span class=filename>/dev/ufs</span> sollte nun ein Label vorhanden sein, welches zu <span class=filename>/etc/fstab</span> hinzugefügt werden kann:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufs/home		/home            ufs     rw              2      2</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das Dateisystem darf nicht gemountet sein beim Versuch, <code>tunefs</code> auszuführen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nun kann das Dateisystem eingehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /home</span></code></pre></div></div><div class=paragraph><p>Von nun an kann der Geräte-Knotenpunkt sich ohne negative Effekte auf das System ändern, solange das Kernelmodul <span class=filename>geom_label.ko</span> beim Systemstart mittels <span class=filename>/boot/loader.conf</span> geladen wird oder die <code>GEOM_LABEL</code>-Kernel-Option aktiv ist.</p></div><div class=paragraph><p>Dateisysteme können auch mit einem Standard-Label erzeugt werden (mittels des Flags <code>-L</code> in <code>newfs</code>). Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> für weitere Informationen.</p></div><div class=paragraph><p>Der folgende Befehl kann genutzt werden, um das Label zu beseitigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel destroy home</span></code></pre></div></div><div class=paragraph><p>Das folgende Beispiel zeigt Ihnen, wie Sie Label für die Partitionen einer Bootplatte erzeugen.</p></div><div class=exampleblock><div class=title>Beispiel 1. Die Partitionen einer Bootplatte labeln</div><div class=content><div class=paragraph><p>Durch das Erstellen von permanenten Labeln für die Partitionen einer Bootplatte sollte das System selbst dann noch normal starten können, wenn Sie die Platte an einen anderen Controller anschließen oder in ein anderes System installieren. In diesem Beispiel nehmen wir an, dass nur eine einzige ATA-Platte verwendet wird, die das System derzeit als <span class=filename>ad0</span> erkennt. Weiters nehmen wir an, dass Sie das Standard-Partionierungsschema von FreeBSD vewendet haben und die Platte daher die Dateisysteme <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/usr</span> sowie <span class=filename>/tmp</span> aufweist. Zusätzlich wurde eine Swap-Partition angelegt.</p></div><div class=paragraph><p>Starten Sie das System neu. Am <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>-Prompt drücken Sie die Taste <kbd>4</kbd>, um in den Single-User-Modus zu gelangen. Dort führen Sie die folgenden Befehle aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel label rootfs /dev/ad0s1a</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1a is label/rootfs
<span class=c># glabel label var /dev/ad0s1d</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1d is label/var
<span class=c># glabel label usr /dev/ad0s1f</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1f is label/usr
<span class=c># glabel label tmp /dev/ad0s1e</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1e is label/tmp
<span class=c># glabel label swap /dev/ad0s1b</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1b is label/swap
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>Das System startet daraufhin in den Multi-User-Modus. Nachdem der Startvorgang abgeschlossen ist, editieren Sie <span class=filename>/etc/fstab</span> und ersetzen die konventionellen Gerätedateien durch die entsprechenden Label. Die modifizierte <span class=filename>/etc/fstab</span> sollte wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2</pre></div></div><div class=paragraph><p>Starten Sie das System neu. Treten keine Probleme auf, wird das System normal hochfahren und Sie erhalten die folgende Ausgabe, wenn Sie den Befehl <code>mount</code> ausführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/label/rootfs on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/label/tmp on /tmp <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/usr on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/var on /var <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> unterstützt einen Labeltyp für UFS-Dateisysteme. Dieser basiert auf der eindeutigen Dateisystem-ID <code>ufsid</code>. Derartige Label finden sich in <span class=filename>/dev/ufsid</span> und werden während des Systemstarts automatisch erzeugt. Es ist möglich, diese <code>ufsid</code>-Label zum automatischen Einhängen von Partitionen in <span class=filename>/etc/fstab</span> einzusetzen. Verwenden Sie <code>glabel status</code>, um eine Liste aller Dateisysteme und ihrer <code>ufsid</code>-Label zu erhalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% glabel status
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</code></pre></div></div><div class=paragraph><p>In diesem Beispiel repräsentiert <span class=filename>ad4s1d</span> das <span class=filename>/var</span>-Dateisystem, während <span class=filename>ad4s1f</span> dem <span class=filename>/usr</span>-Dateisystem entspricht. Wenn Sie die angegebenen <code>ufsid</code>-Werte verwenden, können diese Dateisysteme durch die folgenden Einträge in der Datei <span class=filename>/etc/fstab</span> gemountet werden:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2</pre></div></div><div class=paragraph><p>Jede Partition, die ein <code>ufsid</code>-Label aufweist, kann auf diese Art gemountet werden. Dies hat den Vorteil, dass Sie die permanenten Label nicht manuell anlegen müssen, wobei sich die Platten nach wie vor über geräteunabhängige Namen ansprechen und einhängen lassen.</p></div></div></div></div><div class=sect1><h2 id=geom-gjournal>18.8. UFS Journaling in GEOM<a class=anchor href=#geom-gjournal></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD unterstützt Journaling für UFS-Dateisysteme. Diese Funktion wird über das GEOM-Subsystem realisiert und kann über das Werkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=gjournal&amp;sektion=8&amp;format=html">gjournal(8)</a> eingerichtet werden. Im Gegensatz zu anderen Journaling-Dateisystemen arbeitet <code>gjournal</code> blockbasiert und wurde nicht als Teil des Dateisystems implementiert, sondern als GEOM-Erweiterung.</p></div><div class=paragraph><p>Bei Journaling wird ein Protokoll über alle Dateisystemtransaktionen angelegt, inklusive aller Veränderungen, aus denen ein kompletter Schreibvorgang besteht, bevor diese Änderungen (Metadaten sowie tatsächliche Schreibvorgänge) physisch auf der Festplatte ausgeführt werden. Dieses Protokoll kann später erneut aufgerufen werden, um diese Vorgänge zu wiederholen, damit Systeminkonsistenzen vermieden werden.</p></div><div class=paragraph><p>Diese Technik bietet eine weitere Möglichkeit, sich vor Datenverlust und Dateisystem-Inkonsistenzen zu schützen. Im Gegensatz zu Soft Updates (die Metadaten-Aktualisierungen verfolgen und erzwingen) und Snapshots (die ein Image eines Dateisystems darstellen) wird bei Journaling ein tatsächliches Protokoll in einem speziell dafür bereitgestellten Bereich der Festplatte gespeichert. Um die Leistung zu optimieren, kann das Journal auf eine externe Platte ausgelagert werden. In einem solchen Fall geben Sie die Gerätedatei der Platte nach dem Gerät an, für das Sie Journaling aktivieren wollen.</p></div><div class=paragraph><p>Der <span class=filename>GENERIC</span>-Kernel bietet Unterstützung für <code>gjournal</code>. Damit das Kernelmodul <span class=filename>geom_journal.ko</span> beim Booten automatisch geladen wird, fügen Sie folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_journal_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Wenn ein angepasster Kernel benutzt wird, stellen Sie sicher, dass folgende Zeile in der Kernelkonfigurationsdatei enthalten ist:</p></div><div class="literalblock programlisting"><div class=content><pre>options     GEOM_JOURNAL</pre></div></div><div class=paragraph><p>Sobald das Modul geladen ist, kann ein Journal auf einem neuen Dateisystem erstellt werden. In diesem Beispiel ist <span class=filename>da4</span> die neue SCSI-Platte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gjournal load</span>
<span class=c># gjournal label /dev/da4</span></code></pre></div></div><div class=paragraph><p>Diese Befehle laden das Modul und erstellen die Gerätedatei <span class=filename>/dev/da4.journal</span> auf <span class=filename>/dev/da4</span>.</p></div><div class=paragraph><p>Nun kann auf dem neuen Gerät ein UFS-Dateisystem erstellt werden, welches dann in den Verzeichnisbaum eingehängt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -O 2 -J /dev/da4.journal</span>
<span class=c># mount /dev/da4.journal /mnt</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls auf dem System mehrere Slices angelegt sind (beispielsweise <span class=filename>ad4s1</span> sowie <span class=filename>ad4s2</span>), wird <code>gjournal</code> für jedes Slice ein Journal anlegen (also <span class=filename>ad4s1.journal</span> sowie <span class=filename>ad4s2.journal</span>).</p></div></td></tr></tbody></table></div><div class=paragraph><p>Mit <code>tunefs</code> ist es auch möglich, Journaling auf bereits existierenden Dateisystemen zu aktivieren. Machen Sie aber <em>immer</em> eine Sicherung der Daten, bevor Sie versuchen, ein existierendes Dateisystem zu ändern. <code>gjournal</code> wird zwar den Vorgang abbrechen, wenn es das Journal nicht erzeugen kann, allerdings schützt dies nicht vor Datenverlust durch einen fehlerhaften Einsatz von <code>tunefs</code>. Weitere Informationen über diese beiden Werkzeuge finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=gjournal&amp;sektion=8&amp;format=html">gjournal(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>.</p></div><div class=paragraph><p>Es ist möglich, Journale auch für die Bootplatte eines FreeBSD-Systems zu verwenden. Der Artikel <a href=https://docs.freebsd.org/en/articles/gjournal-desktop/>Implementing UFS Journaling on a Desktop PC</a> enthält eine ausführliche Anleitung zu diesem Thema.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9. März 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/de/books/handbook/disks class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/de/books/handbook/zfs class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#geom-synopsis>18.1. Übersicht</a></li><li><a href=#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=#geom-mirror>18.3. RAID1 - Spiegelung</a></li><li><a href=#geom-raid3>18.4. RAID3 - Byte-Level Striping mit dedizierter Parität</a></li><li><a href=#geom-graid>18.5. Software RAID</a></li><li><a href=#geom-ggate>18.6. GEOM Gate Netzwerk</a></li><li><a href=#geom-glabel>18.7. Das Labeln von Laufwerken</a></li><li><a href=#geom-gjournal>18.8. UFS Journaling in GEOM</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/handbook/handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/de/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>