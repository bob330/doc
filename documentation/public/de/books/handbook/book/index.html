<!doctype html><html class=theme-light lang=de><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/de/books/handbook/book/><title>FreeBSD Handbuch | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="FreeBSD Handbuch"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="http://172.16.201.134:1313/de/books/handbook/book/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/de\/books\/handbook\/book\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/de/books>Books</a></li><li><a href=http://172.16.201.134:1313/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>FreeBSD Handbuch</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2020 The FreeBSD Documentation Project</div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD ist ein eingetragenes Warenzeichen der FreeBSD Foundation.</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390 und ThinkPad sind Warenzeichen der International Business Machines Corporation in den Vereinigten Staaten, anderen Ländern oder beiden.</p><p>IEEE, POSIX und 802 sind eingetragene Warenzeichen vom Institute of Electrical and Electronics Engineers, Inc. in den Vereinigten Staaten.</p><p>Red Hat, RPM, sind Warenzeichen oder eingetragene Warenzeichen von Red Hat, Inc. in den Vereinigten Staaten und in anderen Ländern.</p><p>3Com und HomeConnect sind eingetragene Warenzeichen der 3Com Corporation.</p><p>Adobe, Acrobat, Acrobat Reader und PostScript sind entweder eingetragene Warenzeichen oder Warenzeichen von Adobe Systems Incorporated in den Vereinigten Staaten und/oder in anderen Ländern.</p><p>Apple, FireWire, Mac, Macintosh, Mac OS, Quicktime und TrueType sind eingetragene Warenzeichen von Apple Computer, Inc., in den Vereinigten Staaten und anderen Ländern.</p><p>Intel, Celeron, EtherExpress, i386, i486, Itanium, Pentium und Xeon sind Warenzeichen oder eingetragene Warenzeichen der Intel Corporation oder ihrer Gesellschaften in den Vereinigten Staaten und in anderen Ländern.</p><p>Linux ist ein eingetragenes Warenzeichen von Linus Torvalds.</p><p>Microsoft, MS-DOS, Outlook, Windows, Windows Media und Windows NT sind entweder eingetragene Warenzeichen oder Warenzeichen der Microsoft Corporation in den Vereinigten Staaten und/oder in anderen Ländern.</p><p>Motif, OSF/1 und UNIX sind eingetragene Warenzeichen und IT DialTone und The Open Group sind Warenzeichen der The Open Group in den Vereinigten Staaten und in anderen Ländern.</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JSP, JVM, Netra, Solaris, StarOffice und SunOS sind Warenzeichen oder eingetragene Warenzeichen von Sun Microsystems, Inc. in den Vereinigten Staaten und in anderen Ländern.</p><p>RealNetworks, RealPlayer und RealAudio sind eingetragene Warenzeichen von RealNetworks, Inc.</p><p>Oracle ist ein eingetragenes Warenzeichen der Oracle Corporation.</p><p>3ware und Escalade sind eingetragene Warenzeichen von 3ware Inc.</p><p>ARM ist ein eingetragenes Warenzeichen von ARM Limited.</p><p>Adaptec ist ein eingetragenes Warenzeichen von Adaptec, Inc.</p><p>Android is a trademark of Google Inc.</p><p>Heidelberg, Helvetica, Palatino und Times Roman sind Marken der Heidelberger Druckmaschinen AG in Deutschland und anderen Ländern.</p><p>Intuit und Quicken sind eingetragene Warenzeichen und/oder Dienstleistungsmarken von Intuit Inc. oder einer ihrer Geselllschaften in den Vereinigten Staaten und in anderen Ländern.</p><p>LSI Logic, AcceleRAID, eXtremeRAID, MegaRAID und Mylex sind Warenzeichen oder eingetragene Warenzeichen der LSI Logic Corp.</p><p>MATLAB ist ein eingetragenes Warenzeichen von The MathWorks, Inc.</p><p>SpeedTouch ist ein Warenzeichen von Thomson.</p><p>VMware ist ein Warenzeichen von VMware, Inc</p><p>Mathematica ist ein eingetragenes Warenzeichen von Wolfram Research, Inc.</p><p>Ogg Vorbis und Xiph.Org sind Warenzeichen von Xiph.Org.</p><p>XFree86 ist ein Warenzeichen von The XFree86 Project, Inc.</p><p>Viele Produktbezeichnungen von Herstellern und Verkäufern sind Warenzeichen. Soweit dem FreeBSD Project das Warenzeichen bekannt ist, werden die in diesem Dokument vorkommenden Bezeichnungen mit dem Symbol “™” oder dem Symbol “®” gekennzeichnet.</p></details></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#book-preface>Vorwort</a><ul><li><a href=#preface-audience>Über dieses Buch</a></li><li><a href=#preface-changes-from3>Änderungen gegenüber der dritten Auflage</a></li><li><a href=#preface-changes-from2>Änderungen gegenüber der zweiten Auflage (2004)</a></li><li><a href=#preface-changes>Änderungen gegenüber der ersten Auflage (2001)</a></li><li><a href=#preface-overview>Gliederung</a></li><li><a href=#preface-conv>Konventionen in diesem Buch</a></li><li><a href=#preface-acknowledgements>Danksagung</a></li></ul></li><li><a href=#introduction>Teil I: Einleitung</a><ul><li><a href=#introduction-synopsis>Kapitel 1. Überblick</a></li><li><a href=#nutshell>Kapitel 2. Willkommen zu FreeBSD!</a></li><li><a href=#history>Kapitel 3. Über das FreeBSD Projekt</a></li><li><a href=#bsdinstall>Kapitel 4. FreeBSD installieren</a></li><li><a href=#basics>Kapitel 5. Grundlagen des FreeBSD Betriebssystems</a></li><li><a href=#ports>Kapitel 6. Installieren von Anwendungen: Pakete und Ports</a></li><li><a href=#x11>Kapitel 7. Das X-Window-System</a></li></ul></li><li><a href=#desktop>Teil II: Desktop-Anwendungen</a><ul><li><a href=#desktop-synopsis>Kapitel 8. Übersicht</a></li><li><a href=#desktop-browsers>Kapitel 9. Browser</a></li><li><a href=#desktop-productivity>Kapitel 10. Büroanwendungen</a></li><li><a href=#desktop-viewers>Kapitel 11. Anzeigen von Dokumenten</a></li><li><a href=#desktop-finance>Kapitel 12. Finanzsoftware</a></li><li><a href=#multimedia>Kapitel 13. Multimedia</a></li><li><a href=#kernelconfig>Kapitel 14. Konfiguration des FreeBSD-Kernels</a></li><li><a href=#printing>Kapitel 15. Drucken</a></li><li><a href=#linuxemu>Kapitel 16. Linux®-Binärkompatibilität</a></li></ul></li><li><a href=#config-tuning>Teil III: Konfiguration und Tuning</a><ul><li><a href=#config-synopsis>Kapitel 17. Übersicht</a></li><li><a href=#configtuning-starting-services>Kapitel 18. Start von Diensten</a></li><li><a href=#configtuning-cron>Kapitel 19. cron(8) konfigurieren</a></li><li><a href=#configtuning-rcd>Kapitel 20. Dienste unter FreeBSD verwalten</a></li><li><a href=#config-network-setup>Kapitel 21. Einrichten von Netzwerkkarten</a></li><li><a href=#configtuning-virtual-hosts>Kapitel 22. Virtual Hosts</a></li><li><a href=#configtuning-syslog>Kapitel 23. Konfiguration der Systemprotokollierung</a></li><li><a href=#configtuning-configfiles>Kapitel 24. Konfigurationsdateien</a></li><li><a href=#configtuning-sysctl>Kapitel 25. Einstellungen mit sysctl(8)</a></li><li><a href=#configtuning-disk>Kapitel 26. Tuning von Laufwerken</a></li><li><a href=#configtuning-kernel-limits>Kapitel 27. Einstellungen von Kernel Limits</a></li><li><a href=#adding-swap-space>Kapitel 28. Hinzufügen von Swap-Bereichen</a></li><li><a href=#acpi-overview>Kapitel 29. Energie- und Ressourcenverwaltung</a></li><li><a href=#boot>Kapitel 30. FreeBSDs Bootvorgang</a></li><li><a href=#security>Kapitel 31. Sicherheit</a></li><li><a href=#jails>Kapitel 32. Jails</a></li><li><a href=#mac>Kapitel 33. Verbindliche Zugriffskontrolle</a></li><li><a href=#audit>Kapitel 34. Security Event Auditing</a></li><li><a href=#disks>Kapitel 35. Speichermedien</a></li><li><a href=#geom>Kapitel 36. GEOM: Modulares Framework zur Plattentransformation</a></li><li><a href=#zfs>Kapitel 37. Das Z-Dateisystem (ZFS)</a></li><li><a href=#filesystems>Kapitel 38. Dateisystemunterstützung</a></li><li><a href=#virtualization>Kapitel 39. Virtualisierung</a></li><li><a href=#l10n>Kapitel 40. Localization - i18n/L10n Usage and Setup</a></li><li><a href=#updating-upgrading>Kapitel 41. FreeBSD aktualisieren</a></li><li><a href=#dtrace>Kapitel 42. DTrace</a></li><li><a href=#usb-device-mode>Kapitel 43. USB Gerätemodus</a></li></ul></li><li><a href=#serialcomms>Teil IV: Serielle Datenübertragung</a><ul><li><a href=#serial-synopsis>Kapitel 44. Übersicht</a></li><li><a href=#serial>Kapitel 45. Begriffe und Hardware</a></li><li><a href=#term>Kapitel 46. Terminals</a></li><li><a href=#dialup>Kapitel 47. Einwählverbindungen</a></li><li><a href=#dialout>Kapitel 48. Verbindungen nach Außen</a></li><li><a href=#serialconsole-setup>Kapitel 49. Einrichten der seriellen Konsole</a></li><li><a href=#ppp-and-slip>Kapitel 50. PPP</a></li><li><a href=#mail>Kapitel 51. Elektronische Post (E-Mail)</a></li><li><a href=#network-servers>Kapitel 52. Netzwerkserver</a></li><li><a href=#firewalls>Kapitel 53. Firewalls</a></li><li><a href=#advanced-networking>Kapitel 54. Weiterführende Netzwerkthemen</a></li></ul></li><li><a href=#mirrors>Anhang A: Bezugsquellen für FreeBSD</a></li><li><a href=#mirrors-cdrom>Kapitel 55. CD and DVD Sets</a></li><li><a href=#mirrors-ftp>Kapitel 56. FTP-Server</a></li><li><a href=#svn>Kapitel 57. Benutzen von Subversion</a><ul><li><a href=#svn-intro>57.1. Einführung</a></li><li><a href=#svn-ssl-certificates>57.2. SSL Root-Zertifikate</a></li><li><a href=#svn-svnlite>57.3. Svnlite</a></li><li><a href=#svn-install>57.4. Installation</a></li><li><a href=#svn-usage>57.5. Subversion benutzen</a></li><li><a href=#svn-mirrors>57.6. Subversion Mirror Sites</a></li><li><a href=#_weiterführende_informationen>57.7. Weiterführende Informationen</a></li></ul></li><li><a href=#mirrors-rsync>Kapitel 58. Benutzen von rsync</a></li><li><a href=#bibliography>Anhang B: Bibliografie</a><ul><li><a href=#bibliography-freebsd>B.1. Bücher speziell für FreeBSD</a></li><li><a href=#bibliography-userguides>B.2. Handbücher</a></li><li><a href=#bibliography-adminguides>B.3. Administrations-Anleitungen</a></li><li><a href=#bibliography-programmers>B.4. Programmierhandbücher</a></li><li><a href=#bibliography-osinternals>B.5. Betriebssystem-Interna</a></li><li><a href=#bibliography-security>B.6. Sicherheits-Anleitung</a></li><li><a href=#bibliography-hardware>B.7. Hardware-Anleitung</a></li><li><a href=#bibliography-history>B.8. UNIX® Geschichte</a></li><li><a href=#bibliography-journals>B.9. Zeitschriften, Magazine und Journale</a></li></ul></li><li><a href=#eresources>Anhang C: Ressourcen im Internet</a><ul><li><a href=#eresources-www>C.1. Webseiten</a></li><li><a href=#eresources-mail>C.2. Mailinglisten</a></li><li><a href=#eresources-news>C.3. Usenet-News</a></li><li><a href=#eresources-web>C.4. Offizielle Spiegel</a></li></ul></li><li><a href=#pgpkeys>Anhang D: OpenPGP-Schlüssel</a><ul><li><a href=#pgpkeys-officers>D.1. Ansprechpartner</a></li></ul></li></ul></nav></div><div>[ <a href=../>Split HTML</a> / Single HTML ]</div><div class=book-content><div id=preamble><div class=sectionbody><div class="quoteblock abstract abstract-title"><blockquote>Zusammenfassung</blockquote></div><div class=paragraph><p>Willkommen bei FreeBSD! Dieses Handbuch beschreibt die Installation und den täglichen Umgang mit <em>FreeBSD 12.1-RELEASE</em>, <em>FreeBSD 11.3-RELEASE</em>. Das Handbuch ist das Ergebnis einer fortlaufenden Arbeit vieler Einzelpersonen. Dies kann dazu führen, dass einige Abschnitte nicht aktuell sind. Bei Unklarheiten empfiehlt es sich daher stets, die <a href=https://docs.freebsd.org/de/books/handbook/>englische Originalversion</a> des Handbuchs zu lesen.</p></div><div class=paragraph><p>Wenn Sie bei der Übersetzung des Handbuchs mithelfen möchten, senden Sie bitte eine E-Mail an die Mailingliste FreeBSD German Documentation Project &lt;<a href=mailto:de-bsd-translators@de.FreeBSD.org>de-bsd-translators@de.FreeBSD.org</a>>.</p></div><div class=paragraph><p>Die aktuelle Version des Handbuchs ist immer auf dem <a href=https://www.FreeBSD.org/>FreeBSD-Webserver</a> verfügbar und kann in verschiedenen Formaten und in komprimierter Form vom <a href=https://download.freebsd.org/doc>FreeBSD FTP-Server</a> oder einem der vielen <a href=#mirrors-ftp>Spiegel</a> herunter geladen werden (ältere Versionen finden Sie hingegen unter <a href=https://docs.FreeBSD.org/doc/>https://docs.FreeBSD.org/doc/</a>). Gedruckte Kopien können bei <a href=https://www.freebsdmall.com/>FreeBSD Mall</a> erworben werden. Vielleicht möchten Sie das Handbuch oder andere Dokumente auch <a href=https://www.FreeBSD.org/search/>durchsuchen</a>.</p></div><hr></div></div><div class=sect1><h2 id=book-preface>Vorwort<a class=anchor href=#book-preface></a></h2><div class=sectionbody><div class=sect2><h3 id=preface-audience>Über dieses Buch<a class=anchor href=#preface-audience></a></h3><div class=paragraph><p>Der erste Teil dieses Buchs führt FreeBSD-Einsteiger durch den Installationsprozess und stellt leicht verständlich Konzepte und Konventionen vor, die UNIX® zu Grunde liegen. Sie müssen nur neugierig sein und bereitwillig neue Konzepte aufnehmen, wenn diese vorgestellt werden, um diesen Teil durchzuarbeiten.</p></div><div class=paragraph><p>Wenn Sie den ersten Teil bewältigt haben, bietet der umfangreichere zweite Teil eine verständliche Darstellung vieler Themen, die für FreeBSD-Administratoren relevant sind. Wenn Kapitel auf anderen Kapiteln aufbauen, wird das in der Übersicht am Anfang eines Kapitels erläutert.</p></div><div class=paragraph><p>Weitere Informationsquellen entnehmen Sie bitte <a href=./#bibliography>Bibliografie</a>.</p></div></div><div class=sect2><h3 id=preface-changes-from3>Änderungen gegenüber der dritten Auflage<a class=anchor href=#preface-changes-from3></a></h3><div class=paragraph><p>Die aktuelle Auflage des Handbuchs ist das Ergebnis der engagierten Arbeit Hunderter Mitarbeiter des FreeBSD Documentation Projects in den vergangenen 10 Jahren. Die wichtigsten Änderungen dieser Auflage gegenüber der dritten Auflage von 2004 sind:</p></div><div class=ulist><ul><li><p><a href=./#dtrace>DTrace</a> informiert Sie über die mächtigen Funktionen zur Leistungsmessung, die dieses Werkzeug bietet.</p></li><li><p><a href=./#filesystems>Dateisystemunterstützung</a> enthält Informationen über die Unterstützung nicht-nativer Dateisysteme in FreeBSD, wie beispielsweise ZFS von Sun™.</p></li><li><p><a href=./#audit>Security Event Auditing</a> informiert über die neuen Auditing-Fähigkeitenvon FreeBSD.</p></li><li><p><a href=./#virtualization>Virtualisierung</a> enthält Informationen zur Installation von FreeBSD in verschiedenen Virtualisierungs-Programmen.</p></li><li><p><a href=./#bsdinstall>FreeBSD installieren</a> wurde hinzugefügt, um die Installation von FreeBSD mit dem neuen Installationswerkzeug, bsdinstall, zu dokumentieren.</p></li></ul></div></div><div class=sect2><h3 id=preface-changes-from2>Änderungen gegenüber der zweiten Auflage (2004)<a class=anchor href=#preface-changes-from2></a></h3><div class=paragraph><p>Die dritte Auflage des Handbuchs war das Ergebnis der über zwei Jahre dauernden engagierten Arbeit des FreeBSD Documentation Projects. Die gedruckte Ausgabe war derart umfangreich, dass es notwendig wurde, sie in zwei Bände aufzuteilen. Die wichtigsten Änderungen dieser Auflage waren:</p></div><div class=ulist><ul><li><p><a href=./#config-tuning>Konfiguration und Tuning</a> enthält neue Abschnitte über ACPI, Energie- und Ressourcenverwaltung und das Werkzeug <code>cron</code>.</p></li><li><p><a href=./#security>Sicherheit</a> erläutert nun Virtual Private Networks (VPNs), Zugriffskontrolllisten (ACLs) und Sicherheitshinweise.</p></li><li><p><a href=./#mac>Verbindliche Zugriffskontrolle</a> ist ein neues Kapitel, das vorgeschriebene Zugriffskontrollen vorstellt und erklärt, wie FreeBSD-Systeme mit MACs abgesichert werden können.</p></li><li><p><a href=./#disks>Speichermedien</a> enthält neue Informationen über USB-Speichergeräte, Dateisystem-Snapshots, Quotas, Datei- und Netzwerk-basierte Dateisysteme sowie verschlüsselte Partitionen.</p></li><li><p>Zum <a href=./#ppp-and-slip>PPP</a> wurde ein Abschnitt über Fehlersuche hinzugefügt.</p></li><li><p><a href=./#mail>Elektronische Post (E-Mail)</a> wurde um Abschnitte über alternative Transport-Agenten (MTAs), SMTP-Authentifizierung, UUCP, fetchmail, procmail und weitere Themen erweitert.</p></li><li><p><a href=./#network-servers>Netzwerkserver</a> ist ein weiteres neues Kapitel dieser Auflage. Das Kapitel beschreibt, wie der Apache HTTP-Server, ftpd und ein Samba-Server für Microsoft® Windows®-Clients eingerichtet werden. Einige Abschnitte aus dem <a href=./#advanced-networking>Weiterführende Netzwerkthemen</a> befinden sich nun, wegen des thematischen Zusammenhangs, in diesem Kapitel.</p></li><li><p>Das <a href=./#advanced-networking>Weiterführende Netzwerkthemen</a> beschreibt nun den Einsatz von Bluetooth®-Geräten unter FreeBSD und das Einrichten von drahtlosen Netzwerken sowie ATM-Netzwerken.</p></li><li><p>Neu hinzugefügt wurde ein Glossar, das die im Buch verwendeten technischen Ausdrücke definiert.</p></li><li><p>Das Erscheinungsbild der Tabellen und Abbildungen im Buch wurde verbessert.</p></li></ul></div></div><div class=sect2><h3 id=preface-changes>Änderungen gegenüber der ersten Auflage (2001)<a class=anchor href=#preface-changes></a></h3><div class=paragraph><p>Die zweite Auflage ist das Ergebnis der engagierten Arbeit der Mitglieder des FreeBSD Documentation Projects über zwei Jahre. Die wichtigsten Änderungen gegenüber der ersten Auflage sind:</p></div><div class=ulist><ul><li><p>Ein Index wurde erstellt.</p></li><li><p>Alle ASCII-Darstellungen wurden durch Grafiken ersetzt.</p></li><li><p>Jedes Kapitel wird durch eine Übersicht eingeleitet, die den Inhalt des Kapitels zusammenfasst und die Voraussetzungen für ein erfolgreiches Durcharbeiten des Kapitels darstellt.</p></li><li><p>Der Inhalt wurde in die logischen Abschnitte "Erste Schritte", "Systemadministration" und "Anhänge" unterteilt.</p></li><li><p><a href=./#basics>Grundlagen des FreeBSD Betriebssystems</a> wurde um den Abschnitt "Dämonen, Signale und Stoppen von Prozessen" erweitert.</p></li><li><p>Das <a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a> behandelt nun auch Pakete.</p></li><li><p><a href=./#x11>Das X-Window-System</a> wurde neu geschrieben. Der Schwerpunkt liegt auf modernen Benutzeroberflächen wie KDE und GNOME unter XFree86™.</p></li><li><p>Das <a href=./#boot>FreeBSDs Bootvorgang</a> wurde erweitert.</p></li><li><p><a href=./#disks>Speichermedien</a> ist aus den beiden Kapiteln "Laufwerke" und "Sicherungen" entstanden. Die in den beiden Kapiteln diskutierten Themen sind so leichter zu verstehen. Hinzugekommen ist ein Abschnitt über Software- und Hardware-RAID.</p></li><li><p>Das <a href=./#serialcomms>Serielle Datenübertragung</a> wurde reorganisiert und auf FreeBSD 4.X/5.X angepasst.</p></li><li><p>Das <a href=./#ppp-and-slip>PPP</a> wurde aktualisiert.</p></li><li><p><a href=./#advanced-networking>Weiterführende Netzwerkthemen</a> wurde um viele neue Abschnitte erweitert.</p></li><li><p><a href=./#mail>Elektronische Post (E-Mail)</a> wurde um einen Abschnitt über die Konfiguration von Sendmail erweitert.</p></li><li><p><a href=./#linuxemu>Linux®-Binärkompatibilität</a> behandelt zusätzlich die Installation von Oracle® und SAP® R/3®.</p></li><li><p>Neu hinzugekommen sind:</p><div class=ulist><ul><li><p><a href=./#config-tuning>Konfiguration und Tuning</a>.</p></li><li><p><a href=./#multimedia>Multimedia</a>.</p></li></ul></div></li></ul></div></div><div class=sect2><h3 id=preface-overview>Gliederung<a class=anchor href=#preface-overview></a></h3><div class=paragraph><p>Dieses Buch ist in fünf Abschnitte unterteilt. Der erste Abschnitt, <em>Erste Schritte</em>, behandelt die Installation und die Grundlagen von FreeBSD. Dieser Abschnitt sollte in der vorgegebenen Reihenfolge durchgearbeitet werden, schon Bekanntes darf aber übersprungen werden. Der zweite Abschnitt, <em>Oft benutzte Funktionen</em>, behandelt häufig benutzte Funktionen von FreeBSD. Dieser Abschnitt sowie alle nachfolgenden Abschnitte können in beliebiger Reihenfolge gelesen werden. Jeder Abschnitt beginnt mit einer kurzen Übersicht, die das Thema des Abschnitts und das nötige Vorwissen erläutert. Die Übersichten helfen dem Leser, interessante Kapitel zu finden und erleichtern das Stöbern im Handbuch. Der dritte Abschnitt, <em>Systemadministration</em>, behandelt die Administration eines FreeBSD-Systems. Der vierte Abschnitt, <em>Netzwerke</em>, bespricht Netzwerke und Netzwerkdienste. Der fünfte Abschnitt enthält Anhänge und Verweise auf weitere Informationen.</p></div><div class=dlist><dl><dt class=hdlist1><em><a href=./#introduction>Einleitung</a></em></dt><dd><p>Dieses Kapitel macht Einsteiger mit FreeBSD vertraut. Es behandelt die Geschichte, die Ziele und das Entwicklungsmodell des FreeBSD-Projekts.</p></dd><dt class=hdlist1><em><a href=./#bsdinstall>FreeBSD installieren</a></em></dt><dd><p>Beschreibt den Ablauf der Installation von FreeBSD 9.<em>x</em> und neuere mittels bsdinstall.</p></dd><dt class=hdlist1><em><a href=./#basics>Grundlagen des FreeBSD Betriebssystems</a></em></dt><dd><p>Erläutert die elementaren Kommandos und Funktionen von FreeBSD. Wenn Sie schon mit Linux® oder einem anderen UNIX® System vertraut sind, können Sie dieses Kapitel überspringen.</p></dd><dt class=hdlist1><em><a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a></em></dt><dd><p>Zeigt wie mit der innovativen Ports-Sammlung oder mit Paketen Software von Fremdherstellern installiert wird.</p></dd><dt class=hdlist1><em><a href=./#x11>Das X-Window-System</a></em></dt><dd><p>Beschreibt allgemein das X Window System und geht speziell auf X11 unter FreeBSD ein. Weiterhin werden graphische Benutzeroberflächen wie KDE und GNOME behandelt.</p></dd><dt class=hdlist1><em><a href=./#desktop>Desktop-Anwendungen</a></em></dt><dd><p>Enthält eine Aufstellung verbreiteter Anwendungen wie Browser, Büroanwendungen und Office-Pakete und beschreibt wie diese Anwendungen installiert werden.</p></dd><dt class=hdlist1><em><a href=./#multimedia>Multimedia</a></em></dt><dd><p>Erklärt, wie Sie auf Ihrem System Musik und Videos abspielen können. Beispielhaft werden auch Anwendungen aus dem Multimedia-Bereich beleuchtet.</p></dd><dt class=hdlist1><em><a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a></em></dt><dd><p>Erklärt, warum Sie einen angepassten Kernel erzeugen sollten und gibt ausführliche Anweisungen wie Sie einen angepassten Kernel konfigurieren, bauen und installieren.</p></dd><dt class=hdlist1><em><a href=./#printing>Drucken</a></em></dt><dd><p>Beschreibt, wie Sie Drucker unter FreeBSD verwalten. Diskutiert werden Deckblätter, das Einrichten eines Druckers und ein Abrechnungssystem für ausgedruckte Seiten.</p></dd><dt class=hdlist1><em><a href=./#linuxemu>Linux®-Binärkompatibilität</a></em></dt><dd><p>Beschreibt die binäre Kompatibilität zu Linux®. Weiterhin werden ausführliche Installationsanleitungen für Oracle® und Mathematica® gegeben.</p></dd><dt class=hdlist1><em><a href=./#config-tuning>Konfiguration und Tuning</a></em></dt><dd><p>Beschreibt die Einstellungen, die ein Systemadministrator vornehmen kann, um die Leistungsfähigkeit eines FreeBSD Systems zu verbessern. In diesem Kapitel werden auch verschiedene Konfigurationsdateien besprochen.</p></dd><dt class=hdlist1><em><a href=./#boot>FreeBSDs Bootvorgang</a></em></dt><dd><p>Erklärt den Bootprozess von FreeBSD und beschreibt die Optionen, mit denen sich der Bootprozess beeinflussen lässt.</p></dd><dt class=hdlist1><em><a href=./#security>Sicherheit</a></em></dt><dd><p>Beschreibt die Werkzeuge mit denen Sie Ihr FreeBSD-System absichern. Unter Anderem werden Kerberos, IPsec und OpenSSH besprochen.</p></dd><dt class=hdlist1><em><a href=./#jails>Jails</a></em></dt><dd><p>Dieses Kapitel beschreibt das Jails-Framework sowie die Vorteile von Jails gegenüber der traditionellen chroot-Unterstützung von FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#mac>Verbindliche Zugriffskontrolle</a></em></dt><dd><p>Erklärt vorgeschriebene Zugriffskontrollen (MACs) und wie mit ihrer Hilfe FreeBSD-Systeme gesichert werden.</p></dd><dt class=hdlist1><em><a href=./#audit>Security Event Auditing</a></em></dt><dd><p>Beschreibt, was FreeBSD Event Auditing ist, wie Sie diese Funktion installieren und konfigurieren und die damit erzeugten Audit-Trails überwachen und auswerten können.</p></dd><dt class=hdlist1><em><a href=./#disks>Speichermedien</a></em></dt><dd><p>Erläutert den Umgang mit Speichermedien und Dateisystemen. Behandelt werden Plattenlaufwerke, RAID-Systeme, optische Medien, Bandlaufwerke, speicherbasierte Laufwerke und verteilte Dateisysteme.</p></dd><dt class=hdlist1><em><a href=./#geom>GEOM: Modulares Framework zur Plattentransformation</a></em></dt><dd><p>Beschreibt das GEOM-Framework von FreeBSD sowie die Konfiguration der verschiedenen unterstützten RAID-Level.</p></dd><dt class=hdlist1><em><a href=./#filesystems>Dateisystemunterstützung</a></em></dt><dd><p>Beschreibt die Unterstützung nicht-nativer Dateisysteme (beispielsweise des Z-Dateisystems (zfs) von Sun™) durch FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#virtualization>Virtualisierung</a></em></dt><dd><p>Dieses Kapitel beschreibt verschiedene Virtualisierungslösungen und wie diese mit FreeBSD zusammenarbeiten.</p></dd><dt class=hdlist1><em><a href=./#l10n>Lokalisierung – I18N/L10N einrichten und benutzen</a></em></dt><dd><p>Zeigt wie Sie FreeBSD mit anderen Sprachen als Englisch einsetzen. Es wird sowohl die Lokalisierung auf der System-Ebene wie auch auf der Anwendungs-Ebene betrachtet.</p></dd><dt class=hdlist1><em><a href=./#updating-upgrading>FreeBSD aktualisieren</a></em></dt><dd><p>Erklärt die Unterschiede zwischen FreeBSD-STABLE, FreeBSD-CURRENT und FreeBSD-Releases. Das Kapitel enthält Kriterien anhand derer Sie entscheiden können, ob es sich lohnt, ein Entwickler-System zu installieren und aktuell zu halten. Außerdem wird beschrieben, wie Sie ein System durch das Einspielen neuer Sicherheits-Patches absichern.</p></dd><dt class=hdlist1><em><a href=./#dtrace>DTrace</a></em></dt><dd><p>Beschreibt, wie das von Sun™ entwickelte DTrace-Werkzeug unter FreeBSD konfiguriert und eingesetzt werden kann. Dynamisches Tracing kann Ihnen beim Aufspüren von Leistungsproblemen helfen, indem Sie Echtzeit-Systemanalysen durchführen.</p></dd><dt class=hdlist1><em><a href=./#serialcomms>Serielle Datenübertragung</a></em></dt><dd><p>Erläutert, wie Sie Terminals und Modems an Ihr FreeBSD-System anschließen und sich so ein- und auswählen können.</p></dd><dt class=hdlist1><em><a href=./#ppp-and-slip>PPP</a></em></dt><dd><p>Erklärt wie Sie mit PPP, SLIP oder PPP über Ethernet ein FreeBSD-System mit einem entfernten System verbinden.</p></dd><dt class=hdlist1><em><a href=./#mail>Elektronische Post (E-Mail)</a></em></dt><dd><p>Erläutert die verschiedenen Bestandteile eines E-Mail Servers und zeigt einfache Konfigurationen für sendmail, dem meist genutzten E-Mail-Server.</p></dd><dt class=hdlist1><em><a href=./#network-servers>Netzwerkserver</a></em></dt><dd><p>Bietet ausführliche Informationen und Beispielkonfigurationen, die es Ihnen ermöglichen, Ihren FreeBSD-Rechner als Network File System Server, Domain Name Server, Network Information Server, oder als Zeitsynchronisationsserver einzurichten.</p></dd><dt class=hdlist1><em><a href=./#firewalls>Firewalls</a></em></dt><dd><p>Erklärt die Philosophie hinter softwarebasierten Firewalls und bietet ausführliche Informationen zur Konfiguration der verschiedenen, für FreeBSD verfügbaren Firewalls.</p></dd><dt class=hdlist1><em><a href=./#advanced-networking>Weiterführende Netzwerkthemen</a></em></dt><dd><p>Behandelt viele Netzwerkthemen, beispielsweise das Verfügbarmachen einer Internetverbindung für andere Rechner eines LANs, Routing, drahtlose Netzwerke, Bluetooth®, IPv6, ATM und andere mehr.</p></dd><dt class=hdlist1><em><a href=./#mirrors>Bezugsquellen für FreeBSD</a></em></dt><dd><p>Enthält eine Aufstellung der Quellen von denen Sie FreeBSD beziehen können: CD-ROM, DVD sowie Internet-Sites.</p></dd><dt class=hdlist1><em><a href=./#bibliography>Bibliografie</a></em></dt><dd><p>Dieses Buch behandelt viele Themen und kann nicht alle Fragen erschöpfend beantworten. Die Bibliografie enthält weiterführende Bücher, die im Text zitiert werden.</p></dd><dt class=hdlist1><em><a href=./#eresources>Ressourcen im Internet</a></em></dt><dd><p>Enthält eine Aufstellung der Foren, die FreeBSD Benutzern für Fragen und Diskussionen zur Verfügung stehen.</p></dd><dt class=hdlist1><em><a href=./#pgpkeys>OpenPGP-Schlüssel</a></em></dt><dd><p>Enthält PGP-Fingerabdrücke von etlichen FreeBSD Entwicklern.</p></dd></dl></div></div><div class=sect2><h3 id=preface-conv>Konventionen in diesem Buch<a class=anchor href=#preface-conv></a></h3><div class=paragraph><p>Damit der Text einheitlich erscheint und leicht zu lesen ist, werden im ganzen Buch die nachstehenden Konventionen beachtet:</p></div><div class=sect3><h4 id=preface-conv-typographic>Typographie<a class=anchor href=#preface-conv-typographic></a></h4><div class=dlist><dl><dt class=hdlist1><em>Kursiv</em></dt><dd><p>Für Dateinamen, URLs, betonte Teile eines Satzes und das erste Vorkommen eines Fachbegriffs wird ein <em>kursiver</em> Zeichensatz benutzt.</p></dd><dt class=hdlist1><code>Fixschrift</code></dt><dd><p>Fehlermeldungen, Kommandos, Umgebungsvariablen, Namen von Ports, Hostnamen, Benutzernamen, Gruppennamen, Gerätenamen, Variablen und Code-Ausschnitte werden in einer <code>Fixschrift</code> dargestellt.</p></dd><dt class=hdlist1>Fett</dt><dd><p><strong>Fett</strong> kennzeichnet Anwendungen, Kommandozeilen und Tastensymbole.</p></dd></dl></div></div><div class=sect3><h4 id=preface-conv-commands>Benutzereingaben<a class=anchor href=#preface-conv-commands></a></h4><div class=paragraph><p>Tasten werden <strong>fett</strong> dargestellt, um sie von dem umgebenden Text abzuheben. Tasten, die gleichzeitig gedrückt werden müssen, werden durch ein <code>+</code> zwischen den einzelnen Tasten dargestellt:</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></span></p></div><div class=paragraph><p>Im gezeigten Beispiel soll der Benutzer die Tasten <kbd>Ctrl</kbd>, <kbd>Alt</kbd> und <kbd>Del</kbd> gleichzeitig drücken.</p></div><div class=paragraph><p>Tasten, die nacheinander gedrückt werden müssen, sind durch Kommas getrennt:</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>, <span class=keyseq><kbd>Ctrl</kbd>+<kbd>S</kbd></span></p></div><div class=paragraph><p>Das letzte Beispiel bedeutet, dass die Tasten <kbd>Ctrl</kbd> und <kbd>X</kbd> gleichzeitig betätigt werden und danach die Tasten <kbd>Ctrl</kbd> und <kbd>S</kbd> gleichzeitig gedrückt werden müssen.</p></div></div><div class=sect3><h4 id=preface-conv-examples>Beispiele<a class=anchor href=#preface-conv-examples></a></h4><div class=paragraph><p>Beispiele, die durch <span class=filename>C:\></span> eingeleitet werden, zeigen ein MS-DOS® Kommando. Wenn nichts Anderes angezeigt wird, können diese Kommandos unter neuen Versionen von Microsoft® Windows® auch in einem DOS-Fenster ausgeführt werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>E:<span class=se>\&gt;</span> tools<span class=se>\f</span>dimage floppies<span class=se>\k</span>ern.flp A:</code></pre></div></div><div class=paragraph><p>Beispiele, die mit # beginnen, müssen unter FreeBSD mit Superuser-Rechten ausgeführt werden. Dazu melden Sie sich entweder als <code>root</code> an oder Sie wechseln von Ihrem normalen Account mit <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> zu dem Benutzer <code>root</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=kern.flp of=/dev/fd0</span></code></pre></div></div><div class=paragraph><p>Beispiele, die mit % anfangen, werden unter einem normalen Benutzer-Account ausgeführt. Sofern nichts Anderes angezeigt wird, verwenden die Beispiele die Syntax der C-Shell.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top</code></pre></div></div></div></div><div class=sect2><h3 id=preface-acknowledgements>Danksagung<a class=anchor href=#preface-acknowledgements></a></h3><div class=paragraph><p>Dieses Buch ist aus Beiträgen von vielen Leuten aus allen Teilen der Welt entstanden. Alle eingegangen Beiträge, zum Beispiel Korrekturen oder vollständige Kapitel, waren wertvoll.</p></div><div class=paragraph><p>Einige Firmen haben dieses Buch dadurch unterstützt, dass Sie Autoren in Vollzeit beschäftigt und die Veröffentlichung des Buchs finanziert haben. Besonders BSDi (das später von <a href=http://www.windriver.com>Wind River Systems</a> übernommen wurde) beschäftigte Mitglieder des FreeBSD Documentation Projects, um dieses Buch zu erstellen. Dadurch wurde die erste (englische) gedruckte Auflage im März 2000 möglich (ISBN 1-57176-241-8). Wind River Systems bezahlte dann weitere Autoren, die die zum Drucken nötige Infrastruktur verbesserten und zusätzliche Kapitel beisteuerten. Das Ergebnis dieser Arbeit ist die zweite (englische) Auflage vom November 2001 (ISBN 1-57176-303-1). Zwischen 2003 und 2004 bezahlte <a href=http://www.freebsdmall.com>FreeBSD Mall, Inc</a> mehrere Mitarbeiter für die Vorbereitung der gedruckten dritten Auflage.</p></div><div class=paragraph><p>path: "/books/handbook/parti/"
---
:leveloffset: +1</p></div></div></div></div><h1 id=introduction class=sect0>Teil I: Einleitung<a class=anchor href=#introduction></a></h1><div class=sect1><h2 id=introduction-synopsis>Kapitel 1. Überblick<a class=anchor href=#introduction-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Herzlichen Dank für Ihr Interesse an FreeBSD! Das folgende Kapitel behandelt verschiedene Aspekte des FreeBSD Projekts wie dessen geschichtliche Entwicklung, seine Ziele oder das Entwicklungsmodell.</p></div><div class=paragraph><p>Nach dem Durcharbeiten des Kapitels wissen Sie über folgende Punkte Bescheid:</p></div><div class=ulist><ul><li><p>Wo FreeBSD im Vergleich zu anderen Betriebssystemen steht</p></li><li><p>Die Geschichte des FreeBSD Projekts</p></li><li><p>Die Ziele des FreeBSD Projekts</p></li><li><p>Die Grundlagen des FreeBSD-Open-Source-Entwicklungsmodells</p></li><li><p>Und natürlich woher der Name "FreeBSD" kommt.</p></li></ul></div></div></div><div class=sect1><h2 id=nutshell>Kapitel 2. Willkommen zu FreeBSD!<a class=anchor href=#nutshell></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD ist ein offenes, standardkonformes Unix-ähnliches Betriebssystem für x86 (32 und 64 Bit) ARM®, AARch64, RISC-V®, MIPS®, POWER®, PowerPC® und Sun UltraSPARC® Rechner. Es bietet alle Funktionen, die heutzutage als selbstverständlich angesehen werden, wie präemptives Multitasking, Speicherschutz, virtueller Speicher, Mehrbenutzerfunktionen, SMP-Unterstützung, Open Source Entwicklungswerkzeuge für verschiedene Sprachen und Frameworks sowie Desktop-Funktionen rund um das X Window System, KDE und GNOME. Besondere Eigenschaften sind:</p></div><div class=ulist><ul><li><p><em>Liberale Open Source Lizenz</em>, die Ihnen das Recht einräumt, den Quellcode frei zu modifizieren und zu erweitern und ihn in freien oder proprietären Produkten zu integrieren, ohne dabei den für Copyleft-Lizenzen typischen Einschränkungen zu unterliegen. Ebenso sollen mögliche Inkompatibilitätsprobleme vermieden werden.</p></li><li><p><em>Starke TCP/IP-Netzwerkfähigkeit</em> - FreeBSD implementiert Industrie-Standardprotokolle mit immer höherer Leistung und Skalierbarkeit. Dies macht FreeBSD zu einer exzellenten Lösung sowohl für Server, als auch für Routing/Firewall Aufgaben. Tatsächlich nutzen viele Unternehmen und Anbieter FreeBSD zu genau diesem Zweck.</p></li><li><p><em>Vollständig integrierte OpenZFS-Unterstützung</em>, einschließlich root-on-ZFS, ZFS Boot Environments, Fehlermanagement, administrative Delegation, Unterstützung für Jails, FreeBSD-spezifische Dokumentation und Unterstützung im System-Installationsprogramm.</p></li><li><p><em>Umfangreiche Sicherheitsfunktionen</em>, vom System für die verbindliche Zugriffskontrolle (Mandatory Access Control, MAC), bis hin zu Capsicum und Sandbox-Mechanismen.</p></li><li><p><em>Über 30.000 vorkonfigurierte Pakete</em> für alle unterstützten Architekturen und die Ports-Sammlung, die es Benutzern einfach macht, eigene, angepasste Software zu erstellen.</p></li><li><p><em>Dokumentation</em> - Zusätzlich zu diesem Handbuch und Büchern von verschiedenen Autoren, die Themen von Systemadministration bis hin zu Kernel-Interna behandeln, gibt es auch die <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> Seiten, nicht nur für Daemonen, Dienstprogramme und Konfigurationsdateien, sondern auch für Kernel-APIs (Sektion 9) und individuelle Treiber (Sektion 4).</p></li><li><p><em>Einfache und konsistente Repository-Struktur und Build-System</em> - FreeBSD benutzt ein einziges Repository für alle seine Komponenten, sowohl den Kernel als auch das Basissystem. Dies, zusammen mit einem einheitlichen und leicht anpassbaren Build-System und einem gut durchdachten Entwicklungsprozess, macht es einfach, FreeBSD in die Build-Infrastruktur für Ihr eigenes Produkt zu integrieren.</p></li><li><p><em>Der Unix-Philosophie treu bleiben</em> und Kombinierbarkeit den monolithischen "all in one"-Daemonen mit hartkodiertem Verhalten vorziehen.</p></li><li><p><em>Binärkompatibilität</em> mit Linux, die es möglich macht, viele Linux-Binärdateien ohne Virtualisierung auszuführen.</p></li></ul></div><div class=paragraph><p>FreeBSD basiert auf dem 4.4BSD-LiteRelease der Computer Systems Research Group (CSRG) der Universität von Kalifornien in Berkeley und führt die namenhafte Tradition der Entwicklung von BSD-Systemen fort. Zusätzlich zu der herausragenden Arbeit CSRG hat das FreeBSD Projekt tausende weitere Arbeitsstunden investiert, um das System zu erweitern, verfeinern und maximale Leistung und Zuverlässigkeit bei Alltagslast zu bieten. FreeBSD bietet Leistung und Zuverlässigkeit auf dem Niveau von Open Source und kommerziellen Angeboten, und kombiniert innovative Funktionen, die woanders nicht verfügbar sind.</p></div><div class=sect2><h3 id=os-overview>2.1. Was kann FreeBSD?<a class=anchor href=#os-overview></a></h3><div class=paragraph><p>Die Anwendungsmöglichkeiten von FreeBSD werden nur durch Ihre Vorstellungskraft begrenzt. Von Software-Entwicklung bis zu Produktionsautomatisierung, von Lagerverwaltung über Abweichungskorrektur bei Satelliten; Falls etwas mit kommerziellen UNIX® Produkten machbar ist, dann ist es höchstwahrscheinlich auch mit FreeBSD möglich. FreeBSD profitiert stark von tausenden hochwertigen Anwendungen aus wissenschaftlichen Instituten und Universitäten in aller Welt. Häufig sind diese für wenig Geld oder sogar kostenlos zu bekommen.</p></div><div class=paragraph><p>Durch den freien Zugang zum Quellcode von FreeBSD ist es in unvergleichbarer Weise möglich, das System für spezielle Anwendungen oder Projekte anzupassen. Dies ist mit den meisten kommerziellen Betriebssystemen einfach nicht möglich. Beispiele für Anwendungen, die unter FreeBSD laufen, sind:</p></div><div class=ulist><ul><li><p><em>Internet-Dienste:</em> Die robuste TCP/IP-Implementierung in FreeBSD macht es zu einer idealen Plattform für verschiedenste Internet-Dienste, wie zum Beispiel:</p><div class=ulist><ul><li><p>Webserver</p></li><li><p>IPv4- und IPv6-Routing</p></li><li><p>Firewall NAT ("IP-Masquerading")-Gateways</p></li><li><p>FTP-Server</p></li><li><p>E-Mail-Server</p></li><li><p>Und mehr…​</p></li></ul></div></li><li><p><em>Bildung:</em> Sind Sie Informatikstudent oder Student eines verwandten Studiengangs? Die praktischen Einblicke in FreeBSD sind die beste Möglichkeit etwas über Betriebssysteme, Rechnerarchitektur und Netzwerke zu lernen. Einige frei erhältliche CAD-, mathematische und grafische Anwendungen sind sehr nützlich, gerade für diejenigen, deren Hauptinteresse in einem Computer darin besteht, <em>andere</em> Arbeit zu erledigen!</p></li><li><p><em>Forschung:</em> Mit dem frei verfügbaren Quellcode für das gesamte System bildet FreeBSD ein exzellentes Studienobjekt in der Disziplin der Betriebssysteme, wie auch in anderen Zweigen der Informatik. Es ist beispielsweise denkbar, das räumlich getrennte Gruppen gemeinsam an einer Idee oder Entwicklung arbeiten. Das Konzept der freien Verfügbarkeit und -nutzung von FreeBSD ermöglicht so die freie Verwendung, ohne sich gross Gedanken über Lizenzbedingungen zu machen oder aufgrund von Beschränkungen evtl. in einem offenen Forum bestimmte Dinge nicht diskutieren zu dürfen.</p></li><li><p><em>Netzwerkfähigkeit:</em> Brauchen Sie einen neuen Router? Oder einen Name-Server (DNS)? Eine Firewall zum Schutze Ihres Intranets vor Fremdzugriff? FreeBSD macht aus dem in der Ecke verstaubenden 386- oder 486-PC im Handumdrehen einen leistungsfähigen Router mit anspruchsvollen Paketfilter-Funktionen.</p></li><li><p><em>Embedded:</em> FreeBSD ist eine exzellente Plattform, um auf embedded Systemen aufzubauen. Mit der Unterstützung für die ARM®-, MIPS®- und PowerPC®-Plattformen, verbunden mit dem robusten Netzwerkstack, aktuellen Neuerungen und der freizügigen <a href=https://docs.freebsd.org/de/books/faq/#bsd-license-restrictions>BSD-Lizenz</a> stellt FreeBSD eine ausgezeichnete Basis für embedded Router, Firewalls und andere Geräte dar.</p></li><li><p><em>Desktop:</em> FreeBSD ist eine gute Wahl für kostengünstige X-Terminals mit dem frei verfügbaren X11-Server. FreeBSD bietet die Auswahl aus vielen Open Source Desktop Umgebungen, dazu gehören auch die GNOME und KDE GUIs. FreeBSD kann sogar "plattenlos" booten, was einzelne Workstations sogar noch günstiger macht und die Verwaltung erleichtert.</p></li><li><p><em>Software-Entwicklung:</em> Das Standard-FreeBSD-System wird mit einem kompletten Satz an Entwicklungswerkzeugen bereitgestellt, unter anderem einem vollständigen C/C++-Compiler und -Debugger. Entwicklungswerkzeugen. Viele zusätzliche Programmiersprachen für Wissenschaft und Entwicklung sind aus der Ports- und Paket-Sammlung zu haben.</p></li></ul></div><div class=paragraph><p>FreeBSD ist sowohl in Form von Quellcode als auch in Binärform auf CD-ROM, DVD und über Anonymous FTP erhältlich. Lesen Sie dazu <a href=./#mirrors>Bezugsquellen für FreeBSD</a>, um weitere Informationen erhalten.</p></div></div><div class=sect2><h3 id=introduction-nutshell-users>2.2. Wer verwendet FreeBSD?<a class=anchor href=#introduction-nutshell-users></a></h3><div class=paragraph><p>FreeBSD ist bekannt für seine Stärken als Webserver - zu den Webseiten, die unter FreeBSD laufen, gehören <a href=https://news.ycombinator.com/>Hacker News</a>, <a href=http://www.netcraft.com/>Netcraft</a>, <a href=http://www.163.com/>NetEase</a>, <a href=https://signup.netflix.com/openconnect>Netflix</a>, <a href=http://www.sina.com/>Sina</a>, <a href=http://www.sony.co.jp/>Sony Japan</a>, <a href=http://www.rambler.ru/>Rambler</a>, <a href=http://www.yahoo.com/>Yahoo!</a>, und <a href=http://www.yandex.ru/>Yandex</a>.</p></div><div class=paragraph><p>FreeBSDs fortgeschrittene Eigenschaften, bewährte Sicherheit und vorhersehbare Release-Zyklen, genauso wie seine tolerante Lizenz haben dazu geführt, dass es als Plattform zum Aufbau vieler kommerzieller und quelloffener Geräte und Produkte verwendet wird. Viele der weltgrössten IT-Unternehmen benutzen FreeBSD:</p></div><div class=ulist><ul><li><p><a href=http://www.apache.org/>Apache</a>- Die Apache Software Foundation lässt den Grossteil seiner der Öffentlichkeit zugänglichen Infrastruktur, inklusive des möglicherweise grössten SVN-Repositories der Welt mit über 1,4 Millionen Commits, auf FreeBSD laufen.</p></li><li><p><a href=http://www.apple.com/>Apple</a>- OS X verwendet viel von FreeBSDs eigenem Netzwerkstack, virtuellem Dateisystem und den Benutzerumgebungskomponenten für sein eigenes System. Apple iOS nutzt ebenso Elemente, die es von FreeBSD übernommen hat</p></li><li><p><a href=http://www.cisco.com/>Cisco</a>- IronPort Network Sicherheits- und Anti-Spam-Appliance verwendet einen modifizierten FreeBSD-Kernel.</p></li><li><p><a href=http://www.citrix.com/>Citrix</a>- Die NetScaler Reihe von Sicherheits-Appliances bietet auf den Schichten 4-7 Load-Balancing, Content Caching, Anwendungsfirewall, gesichertes VPN und mobilen Cloud-Netzwerkzugriff, gepaart mit der Mächtigkeit der FreeBSD-Shell.</p></li><li><p><a href=https://www.emc.com/isilon>Isilon</a>- Isilons Unternehmens-Speicherappliances basieren auf FreeBSD. Die extrem liberale FreeBSD-Lizenz erlaubt Isilon ihr intellektuelles Eigentum durch den gesamten Kernel zu integrieren und kann sich so auf das Erstellen ihres Produktes und nicht des Betriebssystems fokussieren.</p></li><li><p><a href=http://www.quest.com/KACE>Quest KACE</a>- Die KACE Systemmanagement-Appliances nutzen FreeBSD wegen seiner Zuverlässigkeit, Skalierbarkeit und Gemeinschaft, welche deren zukünftige Weiterentwicklung fördert.</p></li><li><p><a href=http://www.ixsystems.com/>iXsystems</a>- Die TrueNAS-Linie von vereinheitlichten Speicherappliances beruht auf FreeBSD. Zusätzlich zu deren kommerziellen Produkten, managed iXsystems auch noch die beiden Open Source Projekte TrueOS und FreeNAS.</p></li><li><p><a href=http://www.juniper.net/>Juniper</a>- Das JunOS Betriebssystem, welches alle Juniper Netzwerkgeräte (inklusive Router, Switche, Sicherheits- und Netzwerkappliances) antreibt, verwendet FreeBSD Juniper ist einer der vielen Hersteller, welcher das symbolische Verhältnis zwischen dem Projekt und dem Hersteller von kommerziellen Produkten darstellt. Verbesserungen, die Juniper entwickelt hat, werden ebenso in FreeBSD aufgenommen, um die Komplexität der Integration neuer Eigenschaften von FreeBSD zurück in zukünftige JunOS Versionen zu vereinfachen.</p></li><li><p><a href=http://www.mcafee.com/>McAfee</a>- SecurOS, die Basis von McAfee Enterprise-Firewallprodukten inkl. Sidewinder basiert auf FreeBSD.</p></li><li><p><a href=http://www.netapp.com/>NetApp</a>- Die Data ONTAP GX Reihe von Speicherappliances basieren auf FreeBSD. Zusätzlich hat NetApp viele Neuheiten beigesteuert, inklusive des neuen BSD-lizensierten Hypervisors bhyve.</p></li><li><p><a href=http://www.netflix.com/>Netflix</a>- Die OpenConnect-Appliance, die Netflix verwendet, um Filme zu seinen Kunden zu streamen basiert auf FreeBSD. Netflix hat weitreichende Beiträge zum Quellcode von FreeBSD beigetragen und arbeitet daran, ein möglichst geringes Delta zur normalen Version beizubehalten. Netflix OpenConnect-Appliances sind für mehr als 32% vom gesamten Internetverkehr in Nordamerika verantwortlich.</p></li><li><p><a href=http://www.sandvine.com/>Sandvine</a>- Sandvine nutzt FreeBSD as die Basis für deren Echtzeit Hochgeschwindigkeits-Netzwerkplattform, welche den Kern deren intelligenter Netzwerkpolicy-Kontrollprodukte darstellt.</p></li><li><p><a href=http://www.sony.com/>Sony</a>- Die PlayStation 4 Spielekonsole verwendet eine modifizierte Version von FreeBSD.</p></li><li><p><a href=http://www.sophos.com/>Sophos</a>- Das Sophos Email-Appliance Produkt basiert auf einem abgesicherten FreeBSD und scannt eingehende E-Mail auf Spam und Viren, während es gleichzeitig ausgehende Mail auf Schadsoftware und versehentlichen Versand von vertraulichen Informationen überwacht.</p></li><li><p><a href=http://www.spectralogic.com/>Spectra Logic</a>- Die nTier Reihe von archivspeicherfähigen Appliances nutzt FreeBSD und OpenZFS.</p></li><li><p><a href=https://www.stormshield.eu>Stormshield</a> - Stormshield Network Security Appliances basieren auf einer abgesicherten Version von FreeBSD. Die BSD-Lizenz erlaubt es ihnen, ihr geistiges Eigentum in das System zu integrieren und gleichzeitig interessante Entwicklungen an die Gemeinschaft zurückzugeben.</p></li><li><p><a href=http://www.weather.com/>The Weather Channel</a>- Die IntelliStar Appliance, welche am Kopfende eines jeden Kabelversorgers installiert ist und für das Einspeisen von lokalen Wettervorhersagen in das Kabelfernsehprogramm verantwortlich ist, läuft auf FreeBSD.</p></li><li><p><a href=http://www.verisign.com/>Verisign</a>- Verisign ist für den Betrieb der .com und .net Root-Domainregistries genauso verantwortlich wie für die dazugehörige DNS-Infrastruktur. Sie verlassen sich auf einen Reihe von verschiedenen Netzwerkbetriebssystemen inklusive FreeBSD, um zu gewährleisten, dass es keine gemeinsame Fehlerstelle in deren Infrastruktur gibt.</p></li><li><p><a href=http://www.voxer.com/>Voxer</a>- Voxer verwendet ZFS auf FreeBSD für ihre mobile Voice-Messaging-Platform. Voxer wechselte von einem Solaris-Derivat zu FreeBSD, wegen der ausgezeichneten Dokumentation und wegen der größeren, aktiveren und sehr Entwickler freundlichen Gemeinschaft. Neben entscheidenen Merkmalen wie ZFS und DTrace bietet FreeBSD auch TRIM-Unterstützung für ZFS.</p></li><li><p><a href=https://fudosecurity.com/en/>Fudo Security</a>- Die FUDO Sicherheitsappliance erlaubt es Unternehmen, Vertragspartner und Administratoren, die an ihren Systemen arbeiten durchführen, zu überwachen, zu kontrollieren, aufzuzeichnen und zu begutachten. Dies basiert auf all den besten Sicherheitseigenschaften von FreeBSD, inklusive ZFS, GELI, Capsicum, HAST und auditdistd.</p></li></ul></div><div class=paragraph><p>FreeBSD hat ebenfalls eine Reihe von verwandten Open Source Projekten hervorgebracht:</p></div><div class=ulist><ul><li><p><a href=http://bsdrp.net/>BSD Router</a>- Einen FreeBSD-basierten Ersatz für grosse Unternehmensrouter, der entwickelt wurde, um auf Standard PC-Hardware zu laufen.</p></li><li><p><a href=http://www.freenas.org/>FreeNAS</a>- Ein eigens dafür entworfenes FreeBSD für den Zweck als Netzwerk-Dateiserver Appliance zu fungieren. Es enthält eine Python-basierte Webschnittstelle, um das Management von sowohl UFS- als auch ZFS-Systemen zu vereinfachen. Enthalten sind NFS, SMB/CIFS, AFP, FTP und iSCSI. Ebenfalls enthalten ist ein erweiterteres Plugin-System basierend auf FreeBSD-Jails.</p></li><li><p><a href=https://ghostbsd.org/>GhostBSD</a>- basiert auf FreeBSD und verwendet die GTK-Umgebung, um ein schönes Aussehen und eine komfortable Erfahrung auf der modernen BSD-Plattform zu liefern, die eine natürliche und native UNIX®-Arbeitsumgebung bietet.</p></li><li><p><a href=http://mfsbsd.vx.sk/>mfsBSD</a>- Eine Sammlung von Werkzeugen zum Erstellen von FreeBSD-Systemimages, welches ausschliesslich im Hauptspeicher läuft.</p></li><li><p><a href=http://www.nas4free.org/>NAS4Free</a>- Eine Dateiserverdistribution basierend auf FreeBSD mit einer von PHP-getriebenen Webschnittstelle.</p></li><li><p><a href=http://www.opnsense.org/>OPNSense</a>- OPNSense ist eine quelloffene, einfach zu benutzende und auf FreeBSD basierende Firewall- und Router-Plattform. OPNSense enthält viele Funktionen die sonst nur in kommerziellen Firewalls enthalten sind und manchmal sogar mehr. Es kombiniert die vielfältigen Funktionen kommerzieller Angebote mit den Vorteilen von offenen und nachprüfbaren Quellen.</p></li><li><p><a href=https://www.trueos.org/>TrueOS</a>- TrueOS basiert auf der legendären Sicherheit und Stabilität von FreeBSD. TrueOS basiert auf FreeBSD-CURRENT und bietet die aktuellsten Treiber, Sicherheitsaktualisierungen und Pakete.</p></li><li><p><a href=https://www.furybsd.org>FuryBSD</a> - ein brandneuer, quelloffener FreeBSD Desktop. FuryBSD ist eine Hommage an die Desktop-BSD-Projekte der Vergangenheit wie PC-BSD und TrueOS mit seiner graphischen Oberfläche und beinhaltet zusätzliche Werkzeuge wie ein hybrides USB/DVD-Abbild hinzu. FuryBSD ist vollständig frei nutzbar und wird unter der BSD-Lizenz vertrieben.</p></li><li><p><a href=https://www.midnightbsd.org>MidnightBSD</a> - ist ein auf FreeBSD basierendes Betriebssystem, das mit Blick auf Desktop-Benutzer entwickelt wurde. Es enthält die gesamte Software, die Sie für Ihre täglichen Aufgaben erwarten: Mail, Web-Browsing, Textverarbeitung, Spiele und vieles mehr.</p></li><li><p><a href=http://www.pfsense.org/>pfSense</a>- Eine Firewalldistribution basierend auf FreeBSD mit eine grossen Menge von Fähigkeiten und ausgedehnter IPv6-Unterstützung.</p></li><li><p><a href=http://zrouter.org/>ZRouter</a>- Eine Open Source Firmware-Alternative für eingebettete Geräte, die auf FreeBSD basiert. Entwickelt wurde sie, um die proprietäre Firmware von Standard-Routern zu ersetzen.</p></li></ul></div><div class=paragraph><p>Eine Liste von <a href=https://www.freebsdfoundation.org/about/testimonials/>Referenzen von Unternehmen, dessen Produkte und Dienstleistungen auf FreeBSD basieren</a>, finden Sie auf der Webseite der FreeBSD Foundation. Wikipedia pflegt eine <a href=https://en.wikipedia.org/wiki/List_of_products_based_on_FreeBSD>Liste von Produkten, die auf FreeBSD basieren.</a></p></div></div></div></div><div class=sect1><h2 id=history>Kapitel 3. Über das FreeBSD Projekt<a class=anchor href=#history></a></h2><div class=sectionbody><div class=paragraph><p>Der folgende Abschnitt bietet einige Hintergrundinformationen zum FreeBSD Projekt, einschließlich einem kurzen geschichtlichen Abriss, den Projektzielen und dem Entwicklungsmodell.</p></div><div class=sect2><h3 id=intro-history>3.1. Kurzer geschichtlicher Abriss zu FreeBSD<a class=anchor href=#intro-history></a></h3><div class=paragraph><p>Das FreeBSD Projekt wurde Anfang 1993 ins Leben gerufen, zum Teil als Ergebnis der Arbeit der letzten drei Koordinatoren des "Unofficial 386BSD Patchkit": Nate Williams, Rod Grimes und Jordan Hubbard.</p></div><div class=paragraph><p>Das ursprüngliche Ziel war es, einen zwischenzeitlichen Abzug von 386BSD zu erstellen, um ein paar Probleme zu beseitigen, die das Patchkit-Verfahren nicht lösen konnte. Der frühe Arbeitstitel für das Projekt war "386BSD 0.5" oder "386BSD Interim" als Referenz darauf.</p></div><div class=paragraph><p>386BSD war das Betriebssystem von Bill Jolitz, welches bis zu diesem Zeitpunkt heftig unter fast einjähriger Vernachlässigung litt. Als das Patchkit mit jedem Tag anschwoll und unhandlicher wurde, entschied man sich, Bill Jolitz zu helfen, indem ein übergangsweise "bereinigter" Abzug zur Verfügung gestellt wurde. Diese Pläne wurden durchkreuzt, als Bill Jolitz plötzlich seine Zustimmung zu diesem Projekt zurückzog, ohne einen Hinweis darauf, was stattdessen geschehen sollte.</p></div><div class=paragraph><p>Das Trio entschied, dass das Ziel sich weiterhin lohnen würde, selbst ohne die Unterstützung von Bill und so wurde entschieden, den Namen FreeBSD zu verwenden, der von David Greenman geprägt wurde. Die anfänglichen Ziele wurden festgelegt, nachdem man sich mit den momentanen Benutzern des Systems besprach und abzusehen war, dass das Projekt die Chance hatte, Realität zu werden, kontaktierte Jordan Walnut Creek CDROM mit dem Vorhaben, FreeBSDs Verteilung auch auf diejenigen auszuweiten, die noch keinen Internetzugang besaßen. Walnut Creek CDROM unterstützte nicht nur die Idee durch die Verbreitung von FreeBSD auf CD, sondern ging auch so weit dass es dem Projekt eine Maschine mit schneller Internetverbindung zur Verfügung stellte, um damit zu arbeiten. Ohne den von Walnut Creek bisher nie dagewesenen Grad von Vertrauen in ein, zur damaligen Zeit, komplett unbekanntes Projekt, wäre es unwahrscheinlich, dass FreeBSD so weit gekommen wäre, wie es heute ist.</p></div><div class=paragraph><p>Die erste auf CD-ROM (und netzweit) verfügbare Veröffentlichung war FreeBSD 1.0 im Dezember 1993. Diese basierte auf dem Band der 4.3BSD-Lite ("Net/2") der Universität von Kalifornien in Berkeley. Viele Teile stammten aus 386BSD und von der Free Software Foundation. Gemessen am ersten Angebot, war das ein ziemlicher Erfolg und Sie ließen dem das extrem erfolgreiche FreeBSD 1.1 im Mai 1994 folgen.</p></div><div class=paragraph><p>Zu dieser Zeit formierten sich unerwartete Gewitterwolken am Horizont, als Novell und die Universität von Kalifornien in Berkeley (UCB) ihren langen Rechtsstreit über den rechtlichen Status des Berkeley Net/2-Bandes mit einem Vergleich beilegten. Eine Bedingung dieser Einigung war es, dass die UCB große Teile des Net/2-Quellcodes als "belastet" zugestehen musste, und dass diese Besitz von Novell sind, welches den Code selbst einige Zeit vorher von AT&amp;T bezogen hatte. Im Gegenzug bekam die UCB den "Segen" von Novell, dass sich das 4.4BSD-Lite-Release bei seiner endgültigen Veröffentlichung als unbelastet bezeichnen darf. Alle Net/2-Benutzer sollten auf das neue Release wechseln. Das betraf auch FreeBSD. Dem Projekt wurde eine Frist bis Ende Juli 1994 eingeräumt, das auf Net/2-basierende Produkt nicht mehr zu vertreiben. Unter den Bedingungen dieser Übereinkunft war es dem Projekt noch erlaubt ein letztes Release vor diesem festgesetzten Zeitpunkt herauszugeben. Das war FreeBSD 1.1.5.1.</p></div><div class=paragraph><p>FreeBSD machte sich dann an die beschwerliche Aufgabe, sich Stück für Stück aus einem neuen und ziemlich unvollständigen Satz von 4.4BSD-Lite-Teilen, wieder aufzubauen. Die "Lite" -Veröffentlichungen waren deswegen leicht, weil Berkeleys CSRG große Code-Teile, die für ein start- und lauffähiges System gebraucht wurden, aufgrund diverser rechtlicher Anforderungen entfernen musste und weil die 4.4-Portierung für Intel-Rechner extrem unvollständig war. Das Projekt hat bis November 1994 gebraucht diesen Übergang zu vollziehen. Im Dezember wurde dann FreeBSD 2.0 veröffentlicht. Obwohl FreeBSD gerade die ersten Hürden genommen hatte, war dieses Release ein maßgeblicher Erfolg. Diesem folgte im Juni 1995 das robustere und einfacher zu installierende FreeBSD 2.0.5.</p></div><div class=paragraph><p>Seit dieser Zeit hat FreeBSD eine Reihe von Releases veröffentlicht, die jedes mal die Stabilität, Geschwindigkeit und Menge an verfügbaren Eigenschaften der vorherigen Version verbessert.</p></div><div class=paragraph><p>Momentan werden langfristige Entwicklungsprojekte im 10.X-CURRENT (Trunk)-Zweig durchgeführt, und Abzüge (Snapshots) der Releases von 10.X werden regelmässig auf den <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/snapshots/>Snapshot-Servern</a> zur Verfügung gestellt.</p></div></div><div class=sect2><h3 id=goals>3.2. Ziele des FreeBSD-Projekts<a class=anchor href=#goals></a></h3><div class=paragraph><p>Das FreeBSD Projekt stellt Software her, die ohne Einschränkungen für beliebige Zwecke eingesetzt werden kann. Viele von uns haben beträchtlich in Quellcode und das Projekt investiert und hätten sicher nichts dagegen, hin und wieder ein wenig finanziellen Ausgleich dafür zu bekommen. Aber in keinem Fall bestehen wir darauf. Wir glauben unsere erste und wichtigste "Mission" ist es, Software für jeden Interessierten und zu jedem Zweck zur Verfügung zu stellen, damit die Software größtmögliche Verbreitung erlangt und größtmöglichen Nutzen stiftet. Das ist, glaube ich, eines der grundlegenden Ziele freier Software, welche wir mit größter Begeisterung unterstützen.</p></div><div class=paragraph><p>Der Code in unserem Quellbaum, der unter die General Public License (GPL) oder die Library General Public License (LGPL) fällt, stellt geringfügig mehr Bedingungen. Das aber vielmehr im Sinne von eingefordertem Zugriff, als das übliche Gegenteil der Beschränkungen. Aufgrund zusätzlicher Abhängigkeiten, die sich durch die Verwendung von GPL-Software bei kommerziellem Gebrauch ergeben, bevorzugen wir daher Software unter der transparenteren BSD-Lizenz, wo immer es angebracht ist.</p></div></div><div class=sect2><h3 id=development>3.3. Das FreeBSD-Entwicklungsmodell<a class=anchor href=#development></a></h3><div class=paragraph><p>Die Entwicklung von FreeBSD ist ein offener und flexibler Prozess, der durch den Beitrag von buchstäblich tausenden Leuten rund um die Welt ermöglicht wird, wie an der <a href=https://docs.freebsd.org/en/articles/contributors/>Liste der Beitragenden</a> ersehen können. Die vielen Entwickler können aufgrund der Entwicklungs-Infrastruktur von FreeBSD über das Internet zusammenarbeiten. Wir suchen ständig nach neuen Entwicklern, Ideen und jenen, die sich in das Projekt tiefer einbringen wollen. Nehmen Sie einfach auf der Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>FreeBSD technical discussions</a> Kontakt mit uns auf. Die Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>FreeBSD announcements</a> steht für wichtige Ankündigungen, die alle FreeBSD-Benutzer betreffen, zur Verfügung.</p></div><div class=paragraph><p>Unabhängig davon ob Sie alleine oder mit anderen eng zusammen arbeiten, enthält die folgende Aufstellung nützliche Informationen über das FreeBSD Projekt und dessen Entwicklungsabläufe.</p></div><div class=dlist><dl><dt class=hdlist1>Die SVN-Repositories<a id=development-cvs-repository></a></dt><dd><p>Der Hauptquellbaum von FreeBSD wurde über viele Jahre ausschließlich mit <a href=http://www.nongnu.org/cvs/>CVS</a> (Concurrent-Versions-System) gepflegt, einem frei erhältlichen Versionskontrollsystem. Im Juni 2008 begann das FreeBSD Project mit dem Umstieg auf <a href=http://subversion.tigris.org>SVN</a> (Subversion). Dieser Schritt wurde notwendig, weil durch technische Einschränkungen von CVS aufgrund des rapide wachsenden Quellcodebaumes und dem Umfang der bereits gespeichterten Revisisionsinformationen an dessen Grenzen zu stoßen begann. Die Repositories des Dokumentationsprojekts und die Ports-Sammlung wurden ebenfalls von CVS zu SVN im Mai und Juli 2012 umgezogen. Lesen Sie dazu <a href=./#synching>Synchronisation der Quellen</a> für weitere Informationen zur Synchronisation des FreeBSD <code>src/</code>-Repositories und <a href=./#ports-using>Die Ports-Sammlung verwenden</a> für Details zum Beziehen der FreeBSD Ports-Sammlung.</p></dd><dt class=hdlist1>Die Committer-Liste<a id=development-committers></a></dt><dd><p>Die <em>Committer</em> sind diejenigen Leute, welche <em>schreibenden</em> Zugriff auf den Subversion-Baum besitzen und berechtigt sind, Änderungen an den FreeBSD-Quellen (der Begriff "Committer" stammt aus dem Versionskontrollbefehl <code>commit</code> , der dazu verwendet wird, Änderungen in das Repository zu bringen). Jeder hat die Möglichkeit über die die <a href=https://bugs.FreeBSD.org/submit/>Datenbank für Problemberichte</a> einen Fehlerreport einzureichen. Bevor Sie einen Fehlerreport einreichen, sollten Sie auf den FreeBSD Mailinglisten, den IRC-Kanälen oder in Foren überprüfen, ob das Problem tatsächlich ein Fehler ist.</p></dd><dt class=hdlist1>The FreeBSD core team<a id=development-core></a></dt><dd><p>Die <em>FreeBSD core team</em> ist mit dem Vorstand vergleichbar, wenn das FreeBSD Projekt ein Unternehmen wäre. Die Hauptaufgabe des Core Teams ist es sicherzustellen, dass sich das Projekt als Ganzes in einem guten Zustand befindet und sich in die richtige Richtung bewegt. Das Einladen von engagierten und verantwortungsvollen Entwicklern zu dem Zweck, sich der Gruppe von Committern anzuschliessen, ist eine der Funktionen des Core Teams, genauso wie neue Mitglieder des Core Teams zu rekrutieren, wenn andere ausscheiden. Das aktuelle Core Team wurde aus einer Menge von Kandidaten aus dem Kreis der Committer im Juni 2020 gewählt. Wahlen werden alle zwei Jahre abgehalten.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wie die meisten Entwickler auch, sind die Mitglieder des Core Teams Freiwillige, wenn es um die Entwicklung von FreeBSD geht und erhalten keinerlei finanziellen Vorteil aus dem Projekt, deshalb sollte "Verpflichtung" nicht fehlverstanden werden mit "garantierter Unterstützung". Die "Vorstands"-Analogie oben ist nicht sehr akkurat und kann vielleicht besser damit umschrieben werden, dass diese Leute ihr Leben für FreeBSD gegen jedwede Vernunft geopfert haben.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>Aussenstehende Beitragende</dt><dd><p>Schliesslich stellt die grösste, aber nichtsdestotrotz wichtigste Gruppe von Entwicklern die der Benutzer selbst dar, die stetig Rückmeldungen und Fehlerbehebungen liefert. Der hauptsächliche Weg mit FreeBSDs nicht-zentralisierter Entwicklung Kontakt zu halten, ist, die <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>FreeBSD technical discussions</a> Mailingliste zu abonnieren, auf der solche Dinge diskutiert werden. Lesen Sie dazu <a href=./#eresources>Ressourcen im Internet</a> für weitere Informationen über die verschiedenen FreeBSD-Mailinglisten.</p><div class=paragraph><p><a href=https://docs.freebsd.org/en/articles/contributors/>Liste der Beitragenden</a> ist eine, die lang ist und stetig wächst, also warum nicht FreeBSD beitreten und noch heute etwas zurückgeben?</p></div><div class=paragraph><p>Code ist nicht die einzige Art, zu dem Projekt etwas beizutragen. Für eine ausführlichere Liste von Dingen die getan werden müssen, lesen Sie auf der <a href=https://www.FreeBSD.org/>FreeBSD Projektwebseite</a>.</p></div></dd></dl></div><div class=paragraph><p>Zusammenfassend ist unser Entwicklungsmodell als eine lose Menge von konzentrischen Kreisen organisiert. Das zentralisierte Modell ist mit der Praktikabilität der <em>Anwender</em> von FreeBSD entworfen worden, die mit der einfachen Art einhergeht, eine zentrale Basis für den Code zu haben und keine potentiellen Beiträge auszuschliessen! Unser Ansporn ist es, ein stabiles Betriebssystem mit einer grossen Menge von kohärenten <a href=./#ports>Anwendungsprogrammen</a>, welches die Benutzer einfach installieren und verwenden können - dieses Modell funktioniert darin sehr gut, dieses Ziel zu erreichen.</p></div><div class=paragraph><p>Alles was wir von denen verlangen, die uns als FreeBSD-Entwickler beitreten ist, etwas von der gleichen Hingabe an den Erfolg, die seine momentanen Gemeinschaft inne hat, zu besitzen.</p></div></div><div class=sect2><h3 id=third-party-programs>3.4. Programme von Drittherstellern<a class=anchor href=#third-party-programs></a></h3><div class=paragraph><p>Zusätzlich zur Basisdistribution bietet FreeBSD eine Sammlung von portierter Software mit tausenden der am meisten nachgefragten Programme an. Als diese Zeilen geschrieben wurden, gab es über 36000 Ports! Die Liste der Ports reicht von HTTP-Servern, zu Spielen, Sprachen, Editoren und so ziemlich alles, was dazwischen liegt. Die gesamte Port-Sammlung ist geschätzt 3 GB gross. Um einen Port zu übersetzen, wechseln Sie einfach in das Verzeichnis des Programms, das sie installieren möchten und geben <code>make install</code> ein und das System erledigt den Rest. Die gesamte Originaldistribution für jeden Port, den Sie bauen wird dynamisch heruntergeladen, so dass sie nur genügend Plattenplatz zum bauen des Ports, den sie haben möchten, zur Verfügung stellen müssen. Fast jeder Port ist auch als vorkompiliertes"Paket", das über das folgende einfache Kommando (<code>pkg install</code>) für diejenigen, die keine kompilierten Port aus den Quellen wünschen. Weitere Informationen zu Ports und Paketen finden Sie in <a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a>.</p></div></div><div class=sect2><h3 id=_zusätzliche_dokumentation>3.5. Zusätzliche Dokumentation<a class=anchor href=#_zusätzliche_dokumentation></a></h3><div class=paragraph><p>Alle unterstützten FreeBSD Versionen bieten eine Option, um zusätzliche Dokumentation unter <span class=filename>/usr/local/shared/doc/freebsd</span> während des initialen Systemsetups zu installieren. Dokumentation kann auch zu einem späteren Zeitpunkt über Pakete installiert werden, wie es <a href=./#doc-ports-install-package>“Die Dokumentation aus den Ports aktualisieren”</a> beschreibt. Sie können ebenso die lokal installierten Anleitungen mit jedem HTML-fähigen Browser lesen, indem Sie die folgende URL verwenden:</p></div><div class=dlist><dl><dt class=hdlist1>Das FreeBSD Handbuch</dt><dd><p><a href=file://localhost/usr/local/shared/doc/freebsd/handbook/index.html>/usr/local/shared/doc/freebsd/handbook/index.html</a></p></dd><dt class=hdlist1>Die FreeBSD FAQ</dt><dd><p><a href=file://localhost/usr/local/shared/doc/freebsd/faq/index.html>/usr/local/shared/doc/freebsd/faq/index.html</a></p></dd></dl></div><div class=paragraph><p>Genauso erhalten Sie auch die Master (und am häufigsten aktualisierten) Kopien von <a href=https://www.FreeBSD.org/>https://www.FreeBSD.org/</a>.</p></div></div></div></div><div class=sect1><h2 id=bsdinstall>Kapitel 4. FreeBSD installieren<a class=anchor href=#bsdinstall></a></h2><div class=sectionbody><div class=sect2><h3 id=bsdinstall-synopsis>4.1. Übersicht<a class=anchor href=#bsdinstall-synopsis></a></h3><div class=paragraph><p>Es gibt verschiedene Möglichkeiten, FreeBSD zu installieren, abhängig von der Einsatzumgebung. Dazu gehören:</p></div><div class=ulist><ul><li><p>Abbilder von virtuellen Maschinen, die Sie herunterladen und in einer virtuellen Umgebung einsetzen können. Diese Abbilder können von der <a href=https://www.freebsd.org/where/>FreeBSD Downloadseite</a> heruntergeladen werden. Es gibt Abbilder für KVM ("qcow2"), VMWare ("vmdk"), Hyper-V ("vhd"), sowie Raw-Device Abbilder, die durchgängig unterstützt werden. Dies sind keine Installationsabbilder, sondern vorkonfigurierte ("bereits installierte") Instanzen, die sofort gestartet und konfiguriert werden können.</p></li><li><p>Abbilder von virtuellen Maschinen, die auf Amazon’s <a href=https://aws.amazon.com/marketplace/pp/B07L6QV354>AWS Marketplace</a>, <a href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps?search=freebsd&amp;page=1">Microsoft Azure Marketplace</a> und <a href=https://console.cloud.google.com/launcher/details/freebsd-cloud/freebsd-12>Google Cloud Platform</a> verfügbar sind, um auf den jeweiligen Hosting-Diensten ausgeführt zu werden. Weitere Informationen zur Bereitstellung von FreeBSD auf Azure finden Sie im entsprechenden Kapitel der <a href=https://docs.microsoft.com/en-us/azure/virtual-machines/linux/freebsd-intro-on-azure>Azure Dokumentation</a>.</p></li><li><p>SD-Karten Abbilder für eingebettete Systeme wie den Raspberry Pi oder BeagleBone Black. Diese Abbilder können von der <a href=https://www.freebsd.org/where/>FreeBSD Downloadseite</a> heruntergeladen werden. Die Dateien müssen unkomprimiert und als Raw-Image auf eine SD-Karte geschrieben werden, von der das System dann booten wird.</p></li><li><p>Installationsabbilder, um FreeBSD auf einer Festplatte für die üblichen Desktop-, Laptop- oder Serversysteme zu installieren.</p></li></ul></div><div class=paragraph><p>Der Rest dieses Kapitels beschreibt den vierten Fall und erklärt, wie man FreeBSD mit dem textbasierten Installationsprogramm bsdinstall installiert.</p></div><div class=paragraph><p>Die Installationsanweisungen in diesem Kapitel gelten für die i386™- und AMD64-Architekturen. Gegebenenfalls werden spezifische Anweisungen für andere Plattformen erwähnt. Möglicherweise gibt es auch geringfügige Unterschiede zwischen dem Installationsprogramm und dem, was hier gezeigt wird. Sie sollten dieses Kapitel daher als eine Art Wegweiser und nicht als exakte Anleitung betrachten.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Benutzer, die es vorziehen, FreeBSD mit einem graphischen Installationsprogramm zu installieren, sind vielleicht an <a href=https://www.furybsd.org>FuryBSD</a>, <a href=https://ghostbsd.org>GhostBSD</a> oder <a href=https://www.midnightbsd.org>MidnightBSD</a> interessiert.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie wissen:</p></div><div class=ulist><ul><li><p>welche Mindestanforderungen an die Hardware gestellt werden und welche Architekturen FreeBSD unterstützt.</p></li><li><p>wie man FreeBSD Installationsmedien erstellt.</p></li><li><p>wie man bsdinstall startet.</p></li><li><p>welche Fragen bsdinstall stellt, was sie bedeuten und wie man diese beantwortet.</p></li><li><p>wie Sie Fehler bei der Installation beheben.</p></li><li><p>wie Sie eine Live-Version von FreeBSD ausprobieren können, bevor Sie die Installation starten.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>Die Liste von unterstützter Hardware lesen, die mit der zu installierenden Version von FreeBSD ausgeliefert wird, um sicherzustellen, dass die Hardware auch unterstützt wird.</p></li></ul></div></div><div class=sect2><h3 id=bsdinstall-hardware>4.2. Minimale Hardwareanforderungen<a class=anchor href=#bsdinstall-hardware></a></h3><div class=paragraph><p>Die Hardwareanforderungen zur Installation von FreeBSD variieren mit der Architektur. Hardwarearchitekturen und von FreeBSD unterstützte Geräte sind auf der Seite <a href=https://www.FreeBSD.org/releases/>FreeBSD Release Informationen</a> aufgelistet. Die <a href=https://www.FreeBSD.org/where/>FreeBSD Download Seite</a> enthält Informationen zur Auswahl des richtigen Abbilds für verschiedene Architekturen.</p></div><div class=paragraph><p>Für die Installation von FreeBSD sind mindestens 96 MB RAM und 1.5 GB freier Festplattenspeicher erforderlich. Allerdings ist eine solch geringe Menge an Arbeitsspeicher und Speicherplatz nur für spezifische Anwendungen ausreichend, beispielsweise für Embedded-Geräte. Desktop-Systeme benötigen weitaus mehr Ressourcen. 2-4 GB RAM und mindestens 8 GB Speicherplatz sind ein guter Anfang.</p></div><div class=paragraph><p>Dies sind die Anforderungen an den Prozessor für jede Architektur:</p></div><div class=dlist><dl><dt class=hdlist1>amd64</dt><dd><p>Dies ist die gängigste Art von Prozessor für Desktop- und Laptop-Systeme. Andere Anbieter nennen diese Architektur auch x86-64.</p><div class=paragraph><p>Beispiele für amd64-kompatible Prozessoren umfassen: AMD Athlon™64, AMD Opteron™, multi-core Intel® Xeon™ und Intel® Core™ 2 sowie neuere Prozessoren.</p></div></dd><dt class=hdlist1>i386</dt><dd><p>Ältere Desktop- und Laptop-Systeme verwenden oft die 32-Bit x86-Architektur.</p><div class=paragraph><p>Fast alle i386-kompatiblen Prozessoren mit einer Floating-Point-Einheit werden unterstützt. Alle Intel®-Prozessoren 486 oder neuer werden unterstützt.</p></div><div class=paragraph><p>FreeBSD nutzt die Physical Adress Extensions (PAE), falls die CPU diese Funktion unterstützt. Wenn PAE im Kernel aktiviert ist, wird Speicher über 4 GB vom Kernel erkannt und kann von System verwendet werden. PAE schränkt allerdings auch die Gerätetreiber und anderen Komponenten von FreeBSD ein.</p></div></dd><dt class=hdlist1>powerpc</dt><dd><p>Alle New Word ROM Apple® Mac®-Systeme mit integriertem USB werden unterstützt. SMP wird auf Maschinen mit mehreren CPUs unterstützt.</p><div class=paragraph><p>Ein 32-Bit Kernel kann jedoch nur die ersten 2 GB RAM verwenden.</p></div></dd><dt class=hdlist1>sparc64</dt><dd><p>Systeme, die von FreeBSD/sparc64 unterstützt werden, sind auf der <a href=https://www.FreeBSD.org/platforms/sparc/>FreeBSD/sparc64-Projektseite</a> aufgelistet.</p><div class=paragraph><p>SMP wird auf allen Systemen mit mehr als einem Prozessor unterstützt. Eine dedizierte Platte wird benötigt, da es nicht möglich ist, eine Platte mit einem anderen Betriebssystem zur gleichen Zeit zu teilen.</p></div></dd></dl></div></div><div class=sect2><h3 id=bsdinstall-pre>4.3. Vor der Installation<a class=anchor href=#bsdinstall-pre></a></h3><div class=paragraph><p>Wenn das System die Mindestanforderungen für die Installation von FreeBSD erfüllt, sollte die Installationsdatei heruntergeladen und die Installationsmedien vorbereitet werden. Bevor Sie dies tun, prüfen Sie mit Hilfe dieser Checkliste, ob das System für die Installation bereit ist:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p><strong>Sichern Sie wichtige Daten</strong></p><div class=paragraph><p>Erstellen Sie <em>immer</em> eine Sicherung aller wichtigen Daten, <em>bevor</em> Sie ein Betriebssystem installieren. Speichern Sie die Daten jedoch nicht auf dem System, auf dem das Betriebssystem installiert wird, sondern nutzen Sie einen Wechseldatenträger, wie beispielsweise ein USB-Laufwerk, oder sichern Sie auf einem anderen System im Netzwerk, oder nutzen einen Online-Backup-Dienst. Überprüfen Sie die Sicherungen, bevor Sie mit der Installation beginnen. Sobald das Installationsprogramm die Festplatte des Systems formatiert, gehen alle gespeicherten Daten unwiderruflich verloren.</p></div></li><li><p><strong>Den Installationsort von FreeBSD festlegen</strong></p><div class=paragraph><p>Falls FreeBSD das einzige installierte Betriebssystem sein wird, kann dieser Schritt übersprungen werden. Sollte FreeBSD allerdings die Platte mit anderen Betriebssystemen teilen, müssen Sie entscheiden, welche Platte oder Partition für FreeBSD verwendet werden soll.</p></div><div class=paragraph><p>Für die Architekturen i386 und amd64 können die Platten in mehrere Partitionen aufgeteilt werden. Dazu stehen Ihnen zwei Partitionsschemas zur Verfügung. Traditionell enthält ein <em>Master Boot Record</em> (MBR) eine Partitionstabelle, welche bis zu vier <em>primäre Partitionen</em> aufnehmen kann. Aus historischen Gründen werden diese primären Partitionen in FreeBSD <em>slices</em> genannt. Eine Begrenzung von nur vier Partitionen ist für große Platten sehr beschränkt, so dass eine dieser primären Partitionen als <em>erweiterte Partition</em> eingesetzt wird. Mehrere <em>logische Partitionen</em> können dann innerhalb der erweiterten Partition angelegt werden. Die <em>GUID-Partitionstabelle</em> (GPT) ist eine neuere und einfachere Methode zur Partition einer Festplatte. Geläufige GPT-Implementierungen erlauben bis zu 128 Partitionen pro Platte, was die Notwendigkeit von logischen Partitionen eliminiert.</p></div><div class=paragraph><p>FreeBSDs Standard-Bootloader benötigt entweder eine primäre oder eine GPT-Partition. Wenn alle primären oder GPT-Partitionen bereits in Verwendung sind, muss eine davon für FreeBSD zur Verfügung gestellt werden. Benutzen Sie ein Werkzeug zur Veränderung der Partitionsgrößen, wenn Sie eine Partition erstellen möchten, ohne dabei vorhandene Daten zu löschen. Den freigegebenen Platz können Sie dann für die Installation verwenden.</p></div><div class=paragraph><p>Eine Vielzahl freier und kommerzieller Werkzeuge zur Veränderung der Partitionsgrößen finden Sie unter <a href=http://en.wikipedia.org/wiki/List_of_disk_partitioning_software>http://en.wikipedia.org/wiki/List_of_disk_partitioning_software</a>. GParted Live (<a href=http://gparted.sourceforge.net/livecd.php>http://gparted.sourceforge.net/livecd.php</a>) ist eine freie Live-CD, die den GParted-Partitionseditor enthält. GParted ist auch in einer Vielzahl von anderen Linux Live-CD Distributionen enthalten.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Bei richtiger Anwendung können Werkzeuge zur Veränderung von Partitionsgrößen auf sichere Art und Weise Platz für eine neue Partition schaffen. Erstellen Sie trotzdem eine Vollsicherung und überprüfen Sie deren Integrität bevor Sie die Partitionen auf der Platte verändern.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Festplattenpartitionen, die unterschiedliche Betriebssysteme enthalten, ermöglichen es, jeweils eines dieser Systeme zu verwenden. Eine alternative Möglichkeit, mehrere Betriebssysteme gleichzeitig einzusetzen, ohne dabei Partitionen ändern zu müssen, wird im <a href=./#virtualization>Virtualisierung</a> behandelt.</p></div></li><li><p><strong>Netzwerkparameter ermitteln</strong></p><div class=paragraph><p>Manche FreeBSD Installationsarten benötigen eine Netzwerkverbindung, um Installationsdateien herunter zu laden. Nach jeder Installation bietet das Installationsprogramm die Möglichkeit, die Netzwerkschnittstellen des Systems zu konfigurieren.</p></div><div class=paragraph><p>Steht im Netzwerk ein DHCP-Server zur Verfügung, wird dieser im Allgemeinen verwendet, um automatisch Netzwerkeinstellungen vorzunehmen. Falls DHCP nicht verfügbar ist, müssen die folgenden Netzwerkeinstellungen beim lokalen Netzwerkadministrator oder Provider erfragt werden:</p></div><div id=bsdinstall-collect-network-information class="olist loweralpha"><ol class=loweralpha type=a><li><p>IP-Adresse</p></li><li><p>Subnetz-Maske</p></li><li><p>IP-Adresse des Default-Gateway</p></li><li><p>Domänenname des Netzwerks</p></li><li><p>IP-Adressen der DNS-Server im Netzwerk</p></li></ol></div></li><li><p><strong>Lesen Sie die FreeBSD-Errata</strong></p><div class=paragraph><p>Obwohl das FreeBSD Projekt sich bemüht, jede veröffentlichte Version von FreeBSD so stabil wie möglich zu machen, können sich doch gelegentlich Fehler in den Veröffentlichungsprozess einschleichen. In sehr seltenen Fällen betreffen diese Fehler den Installationsvorgang. Wenn diese Probleme entdeckt und behoben sind, werden dazu Hinweise in der FreeBSD Errata (<a href=https://www.FreeBSD.org/releases/12.1r/errata/>https://www.freebsd.org/releases/12.1r/errata/</a>) auf der FreeBSD Webseite veröffentlicht. Prüfen Sie die Errata vor der Installation, um sicherzustellen, dass es keine Probleme gibt, welche die Installation betreffen.</p></div><div class=paragraph><p>Informationen und Errata für all diese Veröffentlichungen finden Sie unter den Release Informationen auf der FreeBSD Webseite (<a href=https://www.FreeBSD.org/releases/>https://www.freebsd.org/releases/</a>).</p></div></li></ol></div><div class=sect3><h4 id=bsdinstall-installation-media>4.3.1. Die Installationsmedien vorbereiten<a class=anchor href=#bsdinstall-installation-media></a></h4><div class=paragraph><p>Das FreeBSD-Installationsprogramm ist keine Anwendung, das aus einem anderen Betriebssystem heraus gestartet werden kann. Laden Sie stattdessen eine Installationsdatei für FreeBSD herunter und brennen Sie den Dateityp auf einen entsprechenden Datenträger (CD, DVD, oder USB). Starten Sie dann das System mit diesem Datenträger.</p></div><div class=paragraph><p>Die FreeBSD-Installationsmedien sind unter <a href=https://www.FreeBSD.org/where/>www.freebsd.org/where/</a> verfügbar. Der Name der Installationsdatei enthält die Version von FreeBSD, die Architektur sowie den Dateityp. Wenn Sie beispielsweise FreeBSD 12.1 auf einem amd64-System von DVD installieren wollen, laden Sie <span class=filename>FreeBSD-12.1-RELEASE-amd64-dvd1.iso</span> und brennen Sie die Datei auf eine DVD. Starten Sie dann das System mit dieser DVD.</p></div><div class=paragraph><p>Die Installationsdateien stehen in verschiedenen Formaten zur Verfügung und variieren je nach Rechnerarchitektur und Medientyp.</p></div><div id=bsdinstall-installation-media-uefi class=paragraph><p>Für Rechner, die mit UEFI (Unified Extensible Firmware Interface) booten, stehen zusätzliche Installationsdateien zur Verfügung. Die Namen dieser Dateien enthalten die Zeichenkette <span class=filename>uefi</span>.</p></div><div class=paragraph><p>Dateitypen:</p></div><div class=ulist><ul><li><p><code>-bootonly.iso</code>: Dies ist die kleinste Installation, die lediglich das Installationsprogramm enthält. Hierzu ist während der Installation eine funktionierende Internetverbindung erforderlich, da das Installationsprogramm die benötigen Dateien für die FreeBSD-Installation herunter laden muss. Diese Datei sollte mit einem CD-Brennprogramm auf CD gebrannt werden.</p></li><li><p><code>-disc1.iso</code>: Diese Datei enthält alle benötigten Dateien für eine FreeBSD-Installation, den Quellcode und die Ports-Sammlung. Die Datei sollte mit einem CD-Brennprogramm auf CD gebrannt werden.</p></li><li><p><code>-dvd1.iso</code>: Diese Datei enthält alle benötigen Dateien für eine FreeBSD-Installation, den Quellcode und die Ports-Sammlung. Darüber hinaus enthält sie eine Reihe von beliebten Binärpaketen zur Installation eines Window-Managers, sodass Sie ein komplettes System installieren können, ohne dass Sie eine Verbindung zum Internet benötigen. Die Datei sollte mit einem DVD-Brennprogramm auf eine DVD gebrannt werden.</p></li><li><p><code>-memstick.img</code>: Diese Datei enthält alle benötigten Dateien für eine FreeBSD-Installation, den Quellcode und die Ports-Sammlung. Die Datei sollte mit den nachstehenden Anweisungen auf einen USB-Stick geschrieben werden.</p></li><li><p><code>-mini-memstick.img</code>: Diese Datei enthält, wie <code>-bootonly.iso</code>, keine Installationsdateien, sondern lädt diese bei Bedarf nach. Während der Installation wird eine funktionierende Internetverbindung benötigt. Schreiben Sie die Datei, wie in <a href=#bsdinstall-usb>Eine Installationsdatei auf einen USB-Stick schreiben</a> beschrieben, auf einen USB-Stick.</p></li></ul></div><div class=paragraph><p>Nachdem Sie die Datei heruntergeladen haben, laden Sie <span class=filename>CHECKSUM.SHA256</span> aus dem gleichen Verzeichnis herunter. Berechnen Sie dann die <em>Prüfsumme</em> für die Datei. FreeBSD bietet hierfür <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a>, das Sie als <code>sha256 <em>Dateiname</em></code> aufrufen können. Andere Betriebssysteme haben ähnliche Programme.</p></div><div class=paragraph><p>Vergleichen Sie die berechnete Prüfsumme mit der in <span class=filename>CHECKSUM.SHA256</span>. Die beiden Prüfsummen müssen übereinstimmen, ansonsten ist die Datei beschädigt und muss erneut heruntergeladen werden.</p></div><div class=sect4><h5 id=bsdinstall-usb>4.3.1.1. Eine Installationsdatei auf einen USB-Stick schreiben<a class=anchor href=#bsdinstall-usb></a></h5><div class=paragraph><p>Die <span class=filename>*.img</span>-Datei ist ein komplettes <em>Abbild</em> (engl. Image) des späteren USB-Sticks. Die Datei kann <em>nicht</em> auf das Zielgerät kopiert werden. Es existieren jedoch mehrere Programme, mit denen die <span class=filename>*.img</span>-Datei auf einen USB-Stick geschrieben werden kann. In diesem Abschnitt werden zwei dieser Programme vorgestellt.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Bevor Sie fortfahren, machen Sie Sicherungskopien der Daten auf dem USB-Stick. Diese Prozedur wird alle Daten auf dem Stick löschen.</p></div></td></tr></tbody></table></div><div id=bsdinstall-usb-dd class="sidebarblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Das Image mit <code>dd</code> auf einen USB-Stick schreiben</strong></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Dieses Beispiel verwendet <span class=filename>/dev/da0</span> als das Zielgerät, auf welches das Image geschrieben werden soll. Seien Sie <em>sehr vorsichtig</em>, dass das richtige Gerät benutzt wird, da das Kommando alle vorhandenen Daten auf dem Zielgerät zerstört.</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p>Das Werkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> steht unter BSD, Linux® und Mac OS®-Systemen zur Verfügung. Um das Image zu brennen, verbinden Sie den USB-Stick mit dem System und bestimmen Sie dessen Gerätenamen. Geben Sie dann den Namen der Installationsdatei und den Gerätenamen des USB-Sticks an. Dieses Beispiel schreibt die Installation für amd64 auf das erste USB-Gerät im FreeBSD-System.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=FreeBSD-12.1-RELEASE-amd64-memstick.img of=/dev/da0 bs=1M conv=sync</span></code></pre></div></div><div class=paragraph><p>Wenn dieser Befehl fehlschlägt, stellen Sie sicher, dass der USB-Stick nicht eingehangen ist und prüfen Sie den Gerätenamen. Auf einigen Systemen muss der Befehl vielleicht mit Hilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a> ausgeführt werden. Die Syntax von <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> variiert leicht zwischen verschiedenen Plattformen. Zum Beispiel erfordert Mac OS® ein kleingeschriebenes <code>bs=1m</code>. Einige Systeme wie Linux® verwenden vielleicht einen Puffer. Verwenden Sie dann <a href="https://man.freebsd.org/cgi/man.cgi?query=sync&amp;sektion=8&amp;format=html">sync(8)</a>, um die Daten zu schreiben.</p></div></li></ol></div></div></div><div class="sidebarblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Das Image unter Windows® schreiben</strong></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Versichern Sie sich, dass Sie den korrekten Laufwerksbuchstaben angeben, da die bestehenden Daten des Laufwerks überschrieben und zerstört werden.</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p>Image Writer für Windows® herunterladen</p><div class=paragraph><p>Image Writer für Windows® ist eine frei verfügbare Anwendung, welche eine Imagedatei korrekt auf einen USB-Stick schreiben kann. Laden Sie diese von <a href=https://sourceforge.net/projects/win32diskimager/>https://sourceforge.net/projects/win32diskimager/</a> herunter und entpacken Sie sie in ein Verzeichnis.</p></div></li><li><p>Das Image mit Image Writer auf den USB-Stick schreiben</p><div class=paragraph><p>Klicken Sie doppelt auf das Win32DiskImager-Icon, um das Programm zu starten. Prüfen Sie dabei, dass der Laufwerksbuchstabe unter <code>Device</code> dem Gerät entspricht, in dem sich der USB-Stick befindet. Klicken Sie auf das Ordnersymbol und wählen Sie das Image aus, welches auf den USB-Stick geschrieben werden soll. Um den Image-Dateinamen zu akzeptieren, klicken Sie auf <b class=button>Save</b>. Überprüfen Sie erneut, ob alles stimmt und dass keine Ordner auf dem USB-Stick in anderen Fenstern geöffnet sind. Sobald alles bereit ist, klicken Sie auf <b class=button>Write</b>, um die Imagedatei auf den USB-Stick zu schreiben.</p></div></li></ol></div></div></div><div class=paragraph><p>Sie sind jetzt dazu bereit, mit der Installation von FreeBSD zu beginnen.</p></div></div></div></div><div class=sect2><h3 id=bsdinstall-start>4.4. Die Installation starten<a class=anchor href=#bsdinstall-start></a></h3><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Es werden bei Installation so lange keine Änderungen an den Festplatten durchgeführt, bis die folgende Meldung erscheint:</p></div><div class="literalblock programlisting"><div class=content><pre>Your changes will now be written to disk. If you
have chosen to overwrite existing data, it will
be PERMANENTLY ERASED. Are you sure you want to
commit your changes?</pre></div></div><div class=paragraph><p>Die Installation kann vor dieser Warnung zu jeder Zeit abgebrochen werden. Falls Zweifel bestehen, dass etwas falsch konfiguriert wurde, schalten Sie einfach den Computer vor diesem Punkt aus und es werden keine Änderungen an der Festplatte vorgenommen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie das System vom Installationsmedium, das nach den Anweisungen in <a href=#bsdinstall-installation-media>Die Installationsmedien vorbereiten</a> erstellt wurde, gebootet wird. Wenn Sie einen bootfähigen USB-Stick einsetzen, verbinden Sie diesen mit dem System, bevor Sie den Computer einschalten. Falls die Installation von einer CD startet, müssen Sie den Computer einschalten und die CD so bald wie möglich einlegen. Wie das System konfiguriert werden muss, um von dem verwendeten Installationsmedium zu booten, hängt von der Architektur ab.</p></div><div class=sect3><h4 id=bsdinstall-starting-i386>4.4.1. Systemstart von i386™ und amd64<a class=anchor href=#bsdinstall-starting-i386></a></h4><div class=paragraph><p>Diese Architekturen beinhalten ein BIOS-Menü zur Auswahl des Boot-Gerätes. Abhängig von dem verwendeten Installationsmedium können Sie CD/DVD oder USB als erstes Boot-Gerät auswählen. Die meisten Systeme erlauben es auch, das Boot-Gerät während des Startvorgangs zu wählen, typischerweise durch drücken von <kbd>F10</kbd>, <kbd>F11</kbd>, <kbd>F12</kbd> oder <kbd>Esc</kbd>.</p></div><div class=paragraph><p>Falls der Computer wie normal startet und das bestehende Betriebssystem lädt, befolgen Sie einen der hier aufgeführten Schritte:</p></div><div class="olist arabic"><ol class=arabic><li><p>Das Installationsmedium wurde während des Startvorgangs nicht früh genug eingelegt. Lassen Sie das Medium eingelegt und versuchen Sie, den Rechner neu zu starten.</p></li><li><p>Die Änderungen am BIOS waren nicht richtig oder wurden nicht gespeichert. Überprüfen Sie, dass das richtige Boot-Gerät als erstes Boot-Gerät ausgewählt ist.</p></li><li><p>Das verwendete System ist zu alt und unterstützt das starten vom gewählten Medium nicht. In diesem Fall kann der Plop Boot Manager (<a href=http://www.plop.at/de/bootmanagers.html class=bare>http://www.plop.at/de/bootmanagers.html</a>) verwendet werden, um ältere Computer von CD oder USB-Medien zu starten.</p></li></ol></div></div><div class=sect3><h4 id=_systemstart_beim_powerpc>4.4.2. Systemstart beim PowerPC®<a class=anchor href=#_systemstart_beim_powerpc></a></h4><div class=paragraph><p>Auf den meisten Maschinen können Sie <kbd>C</kbd> auf der Tastatur gedrückt halten, um von der CD zu starten. Andernfalls, halten Sie <span class=keyseq><kbd>Command</kbd>+<kbd>Option</kbd>+<kbd>O</kbd>+<kbd>F</kbd></span>, oder <span class=keyseq><kbd>Windows</kbd>+<kbd>Alt</kbd>+<kbd>O</kbd>+<kbd>F</kbd></span> auf nicht-Apple® Tastaturen gedrückt. Geben Sie an der <code>0 ></code>-Eingabeaufforderung folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nb>cd</span>:,<span class=se>\p</span>pc<span class=se>\l</span>oader <span class=nb>cd</span>:0</code></pre></div></div></div><div class=sect3><h4 id=bsdinstall-view-probe>4.4.3. FreeBSD Bootmenü<a class=anchor href=#bsdinstall-view-probe></a></h4><div class=paragraph><p>Wenn das System vom Installationsmedium gestartet wird, erscheint folgendes Menü auf dem Bildschirm:</p></div><div id=bsdinstall-newboot-loader-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-newboot-loader-menu.png alt="bsdinstall newboot loader menu"></div><div class=title>Abbildung 1. FreeBSD Boot Loader Menü</div></div><div class=paragraph><p>In der Voreinstellung wird das Menü zehn Sekunden auf Benutzereingaben warten, bevor das Installationsprogramm gestartet wird. Drücken Sie die Leertaste, um den Timer anzuhalten. Um eine Option auszuwählen, drücken Sie die entsprechende Nummer bzw. Buchstaben. Die folgenden Optionen stehen zur Verfügung.</p></div><div class=ulist><ul><li><p><code>Boot Multi User</code>: Dies wird den Boot-Prozess von FreeBSD fortsetzen. Wenn der Timer angehalten wurde, drücken Sie entweder die <kbd>1</kbd>, <kbd>B</kbd>, oder <kbd>Enter</kbd>.</p></li><li><p><code>Boot Single User</code>: Dieser Modus kann verwendet werden, um eine bestehende FreeBSD-Installation zu reparieren. Dies wird in <a href=./#boot-singleuser>“Der Single-User Modus”</a> beschrieben. Drücken Sie die <kbd>2</kbd> oder <kbd>S</kbd> um in diesen Modus zu gelangen.</p></li><li><p><code>Escape to loader prompt</code>: Dieser Modus startet einen Prompt, welcher nur eine begrenzte Anzahl an Low-Level-Befehlen enthält. Dies wird in <a href=./#boot-loader>“Phase Drei”</a> beschrieben. Drücken Sie die <kbd>3</kbd> oder <kbd>Esc</kbd> um in diesen Modus zu gelangen.</p></li><li><p><code>Reboot</code>: Startet das System neu.</p></li><li><p><code>Kernel</code>: Lädt einen anderen Kernel.</p></li><li><p><code>Configure Boot Options</code>: Öffnet das Menü, welches in <a href=#bsdinstall-boot-options-menu>FreeBSD Boot-Optionen Menü</a> beschrieben ist.</p></li></ul></div><div id=bsdinstall-boot-options-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-boot-options-menu.png alt="bsdinstall boot options menu"></div><div class=title>Abbildung 2. FreeBSD Boot-Optionen Menü</div></div><div class=paragraph><p>Das Boot-Optionen Menü ist in zwei Abschnitte unterteilt. Der erste Abschnitt wird verwendet, um zurück zum Hauptmenü zu gelangen, oder um Optionen zurück auf die Standardwerte zu setzen.</p></div><div class=paragraph><p>Im zweiten Abschnitt können verschiedene Optionen auf <code>On</code> oder <code>Off</code> gesetzt werden. Das System wird bei einem Neustart immer mit den Einstellungen für diese Optionen booten:</p></div><div class=ulist><ul><li><p><code>ACPI Support</code>: Wenn das System während des Bootens hängt, setzen Sie diese Option auf <code>Off</code>.</p></li><li><p><code>Safe Mode</code>: Wenn das System trotz deaktiviertem <code>ACPI Support</code> immer noch hängt, setzen Sie diese Option auf <code>On</code>.</p></li><li><p><code>Single User</code>: Setzen Sie die Option auf <code>On</code>, um eine bestehende FreeBSD-Installation zu reparieren. Dieser Prozess wird in <a href=./#boot-singleuser>“Der Single-User Modus”</a> beschrieben. Sobald das Problem behoben ist, setzen Sie die Option wieder auf <code>Off</code>.</p></li><li><p><code>Verbose</code>: Wenn Sie während des Bootens ausführliche Meldungen sehen möchten, zum Beispiel für die Fehlersuche bei Hardwareproblemen, setzen Sie diese Option auf <code>On</code>.</p></li></ul></div><div class=paragraph><p>Nachdem Sie die benötigten Auswahlen getroffen haben, drücken Sie die <kbd>1</kbd> oder die Rücktaste, um zum Hauptmenü zurückzukehren. Drücken Sie dann <kbd>Enter</kbd> um den FreeBSD Bootprozess fortzusetzen. Eine Reihe von Boot-Meldungen werden nun im Rahmen der Geräteerkennung von FreeBSD angezeigt. Sobald dieser Prozess abgeschlossen ist, erscheint das Menü aus <a href=#bsdinstall-choose-mode>Willkommen-Menü</a>.</p></div><div id=bsdinstall-choose-mode class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-choose-mode.png alt="bsdinstall choose mode"></div><div class=title>Abbildung 3. Willkommen-Menü</div></div><div class=paragraph><p>Wählen Sie hier <b class=button>Install</b> und drücken Sie <kbd>Enter</kbd>, um in das Installationsprogramm zu gelangen. Der Rest dieses Kapitels beschreibt das Installationsprogramm. Andernfalls verwenden Sie die Pfeiltasten um einen anderen Menüpunkt auszuwählen. <b class=button>Shell</b> kann verwendet werden, um eine Shell zu starten und Zugriff auf die Kommandozeilenprogramme zu erhalten, damit beispielsweise die Platten vor der Installation vorbereitet werden können. <b class=button>Live CD</b> kann verwendet werden um FreeBSD vor der Installation auszuprobieren. Die Live-Version wird in <a href=#using-live-cd>Verwendung der Live-CD</a> beschrieben.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Um sich die Boot-Meldungen und die Ergebnisse der Geräteerkennung erneut anzeigen zu lassen, drücken Sie <kbd>S</kbd> gefolgt von <kbd>Enter</kbd>. Dadurch wird eine Shell gestartet, in der Sie die Ereignisse seitenweise mit <code>more /var/run/dmesg.boot</code> lesen können. Geben Sie <code>exit</code> ein, um zum Willkommen-Menü zurückzukehren.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=using-bsdinstall>4.5. Verwendung von bsdinstall<a class=anchor href=#using-bsdinstall></a></h3><div class=paragraph><p>Dieser Abschnitt zeigt die Reihenfolge der Menüs von bsdinstall sowie die Informationen, die während der Installation abgefragt werden. Benutzen Sie die Pfeiltasten zur Navigation und die Leertaste, um einen Menüpunkt zu aktivieren oder zu deaktivieren. Wenn Sie fertig sind, drücken Sie <kbd>Enter</kbd>, um die Auswahl zu speichern und zum nächsten Bildschirm zu gelangen.</p></div><div class=sect3><h4 id=bsdinstall-keymap>4.5.1. Die Tastaturbelegung auswählen<a class=anchor href=#bsdinstall-keymap></a></h4><div class=paragraph><p>Bevor die Installation gestartet wird, lädt bsdinstall die Tastaturbelegung, wie in <a href=#bsdinstall-keymap-loading>Laden der Tastaturbelegung</a> gezeigt.</p></div><div id=bsdinstall-keymap-loading class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-loading.png alt="bsdinstall keymap loading"></div><div class=title>Abbildung 4. Laden der Tastaturbelegung</div></div><div class=paragraph><p>Nachdem die Tastaturbelegung geladen wurde, zeigt bsdinstall das Menü aus <a href=#bsdinstall-keymap-10>Bildschirm zur Auswahl der Tastaturbelegung</a> an. Wählen Sie die Tastenbelegung, die der am System angeschlossenen Tastatur am nächsten kommt, indem Sie die Pfeiltasten Hoch/Runter verwenden und anschließend <kbd>Enter</kbd> drücken.</p></div><div id=bsdinstall-keymap-10 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-10.png alt="bsdinstall keymap 10"></div><div class=title>Abbildung 5. Bildschirm zur Auswahl der Tastaturbelegung</div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Durch drücken von <kbd>Esc</kbd> wird das Menü verlassen und die Standardbelegung eingestellt. <span class=guimenuitem>United States of America ISO-8859-1</span> ist eine sichere Option, falls Sie sich unsicher sind, welche Auswahl Sie treffen sollen.</p></div></td></tr></tbody></table></div><div id=bsdinstall-keymap-testing class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-testing.png alt="bsdinstall keymap testing"></div><div class=title>Abbildung 6. Bildschirm zum Testen der Tastaturbelegung</div></div></div><div class=sect3><h4 id=bsdinstall-hostname>4.5.2. Den Rechnernamen festlegen<a class=anchor href=#bsdinstall-hostname></a></h4><div class=paragraph><p>Das nächste bsdinstall-Menü konfiguriert den Rechnernamen, der für das neu zu installierende System verwendet werden soll.</p></div><div id=bsdinstall-config-hostname class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-hostname.png alt="bsdinstall config hostname"></div><div class=title>Abbildung 7. Festlegen des Rechnernamens</div></div><div class=paragraph><p>Geben Sie einen für das Netzwerk eindeutigen Rechnernamen an. Der eingegebene Rechnername sollte ein voll-qualifizierter Rechnername sein, so wie z.B. <code>machine3.example.com</code>.</p></div></div><div class=sect3><h4 id=bsdinstall-components>4.5.3. Auswahl der zu installierenden Komponenten<a class=anchor href=#bsdinstall-components></a></h4><div class=paragraph><p>Im nächsten Schritt fragt Sie bsdinstall, die optionalen Komponenten für die Installation auszuwählen.</p></div><div id=bsdinstall-config-components class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-components.png alt="bsdinstall config components"></div><div class=title>Abbildung 8. Komponenten für die Installation auswählen</div></div><div class=paragraph><p>Die Entscheidung, welche Komponenten auszuwählen sind, hängt größtenteils davon ab, für was das System künftig eingesetzt werden soll und der zur Verfügung stehende Plattenplatz. Der FreeBSD-Kernel und die Systemprogramme (zusammengenommen auch als <em>Basissystem</em> bezeichnet) werden immer installiert. Abhängig vom Typ der Installation, werden manche dieser Komponenten nicht erscheinen.</p></div><div class=ulist><ul><li><p><code>base-dbg</code> - Basiswerkzeuge wie cat, ls und vielte weitere mit aktiviertem Debugging.</p></li><li><p><code>kernel-dbg</code> - Kernel und Module mit aktiviertem Debugging.</p></li><li><p><code>lib32-dbg</code> - Kompatibilitäts-Bibliotheken mit aktiviertem Debugging, für die Ausführung von 32-bit-Anwendungen auf einer 64-bit-Version von FreeBSD.</p></li><li><p><code>lib32</code> - Kompatibilitäts-Bibliotheken, um 32-bit-Anwendungen auf der 64-bit Version von FreeBSD laufen zu lassen.</p></li><li><p><code>ports</code> - Die FreeBSD Ports-Sammlung ist eine Sammlung von Dateien, die das herunterladen, erstellen und installieren von Drittanbietersoftware automatisiert. <a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a> behandelt die Verwendung der Ports-Sammlung.</p><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Das Installationsprogramm prüft nicht, ob genügend Plattenplatz zur Verfügung steht. Wählen Sie diese Option nur, wenn die Festplatte über ausreichend Speicher verfügt. Die Ports-Sammlung nimmt etwa 3 GB Plattenplatz ein.</p></div></td></tr></tbody></table></div></li><li><p><code>src</code> - Der vollständige FreeBSD Quellcode für den Kernel und die Systemprogramme. Obwohl dies für die meisten Anwendungen nicht benötigt wird, kann es doch für manche Gerätetreiber, Kernelmodule und einigen Anwendungen aus der Ports-Sammlung erforderlich sein. Der Quellcode wird auch benötigt um an FreeBSD selbst mitzuentwickeln. Der komplette Quellcodebaum benötigt 1 GB Plattenplatz und um das gesamte Betriebssystem neu zu erstellen, werden zusätzliche 5 GB Platz benötigt.</p></li><li><p><code>tests</code> - FreeBSD Test-Suite.</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-netinstall>4.5.4. Installation aus dem Netzwerk<a class=anchor href=#bsdinstall-netinstall></a></h4><div class=paragraph><p>Das Menü in <a href=#bsdinstall-netinstall-notify>Installation über das Netzwerk</a> erscheint nur bei der Installation von einer <span class=filename>-bootonly.iso</span>-CD, da dieses Installationsmedium keine Kopien der Installationsdateien enthält. Da die Installationsdateien über eine Netzwerkverbindung abgerufen werden müssen, weist dieses Menü darauf hin, dass zunächst die Netzwerkschnittstelle konfiguriert werden muss. Falls dieses Menü während der Installation angezeigt wird, befolgen Sie die Anweisungen in <a href=#bsdinstall-config-network-dev>Die Netzwerkschnittstelle konfigurieren</a>.</p></div><div id=bsdinstall-netinstall-notify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-files.png alt="bsdinstall netinstall files"></div><div class=title>Abbildung 9. Installation über das Netzwerk</div></div></div></div><div class=sect2><h3 id=bsdinstall-partitioning>4.6. Plattenplatz bereitstellen<a class=anchor href=#bsdinstall-partitioning></a></h3><div class=paragraph><p>Im nächsten Menü wird die Methode bestimmt, um den Plattenplatz zuzuweisen.</p></div><div id=bsdinstall-zfs-partmenu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-partmenu.png alt="bsdinstall zfs partmenu"></div><div class=title>Abbildung 10. Partitionierung unter FreeBSD</div></div><div class=paragraph><p>bsdinstall bietet dem Benutzer vier Methoden zur Zuweisung von Plattenplatz:</p></div><div class=ulist><ul><li><p><code>Auto (UFS)</code> richtet die Partitionen automatisch mit dem <code>UFS</code>-Dateisystems ein.</p></li><li><p><code>Manual</code> ermöglicht es fortgeschrittenen Benutzern, angepasste Partitionen über Menüoptionen zu erstellen.</p></li><li><p><code>Shell</code> öffnet eine Eingabeaufforderung, in der fortgeschrittene Benutzer angepasste Partitionen mit Werkzeugen wie <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> erstellen können.</p></li><li><p><code>Auto (ZFS)</code> erzeugt ein root-on-ZFS-System mit optionaler GELI-Verschlüsselung für Boot Environments.</p></li></ul></div><div class=paragraph><p>Dieser Abschnitt beschreibt, was bei der Partitionierung der Platten zu beachten ist und wie die einzelnen Methoden zur Partitionierung angewendet werden.</p></div><div class=sect3><h4 id=configtuning-initial>4.6.1. Ein Partitionslayout entwerfen<a class=anchor href=#configtuning-initial></a></h4><div class=paragraph><p>Wenn Sie Dateisysteme anlegen, sollten Sie beachten, dass Festplatten auf Daten in den äußeren Spuren schneller zugreifen können als auf Daten in den inneren Spuren. Daher sollten die kleineren und oft benutzten Dateisysteme an den äußeren Rand der Platte gelegt werden. Die größeren Partitionen wie <span class=filename>/usr</span> sollten in die inneren Bereiche gelegt werden. Es empfiehlt sich, die Partitionen in folgender Reihenfolge anzulegen: <span class=filename>/</span>, swap, <span class=filename>/var</span> und <span class=filename>/usr</span>.</p></div><div class=paragraph><p>Die Größe der <span class=filename>/var</span>-Partition ist abhängig vom Zweck der Maschine. Diese Partition enthält hauptsächlich Postfächer, Logdateien und Druckwarteschlangen. Abhängig von der Anzahl an Systembenutzern und der Aufbewahrungszeit für Logdateien, können Postfächer und Logdateien unerwartete Größen annehmen. Die meisten Benutzer benötigen nur selten mehr als ein Gigabyte für <span class=filename>/var</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ein paar Mal wird es vorkommen, dass viel Festplattenspeicher in <span class=filename>/var/tmp</span> benötigt wird. Wenn neue Software mit <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> installiert wird, extrahieren die Paketwerkzeuge eine vorübergehende Kopie der Pakete unter <span class=filename>/var/tmp</span>. Die Installation großer Softwarepakete wie Firefox oder LibreOffice kann sich wegen zu wenig Speicherplatz in <span class=filename>/var/tmp</span> als trickreich herausstellen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die <span class=filename>/usr</span> Partition enthält viele der Hauptbestandteile des Systems, einschließlich der FreeBSD Ports-Sammlung und den Quellcode des Systems. Für diese Partition werden mindestens zwei Gigabyte empfohlen.</p></div><div class=paragraph><p>Behalten Sie bei der Auswahl der Partitionsgrößen den Platzbedarf im Auge. Wenn Sie den Platz auf einer Partition vollständig aufgebraucht haben, eine andere Partition aber kaum benutzen, kann die Handhabung des Systems schwierig werden.</p></div><div class=paragraph><p>Als Daumenregel sollten Sie doppelt soviel Speicher für die Swap-Partition vorsehen, als Sie Hauptspeicher haben, da die VM-Paging-Algorithmen im Kernel so eingestellt sind, dass sie am besten laufen, wenn die Swap-Partition mindestens doppelt so groß wie der Hauptspeicher ist. Zu wenig Swap kann zu einer Leistungsverminderung im VM page scanning Code führen, sowie Probleme verursachen, wenn später mehr Speicher in die Maschine eingebaut wird.</p></div><div class=paragraph><p>Auf größeren Systemen mit mehreren SCSI-, oder IDE-Laufwerken an unterschiedlichen Controllern, wird empfohlen, Swap-Bereiche auf bis zu vier Laufwerken einzurichten. Diese Swap-Partitionen sollten ungefähr dieselbe Größe haben. Der Kernel kann zwar mit beliebigen Größen umgehen, aber die internen Datenstrukturen skalieren bis zur vierfachen Größe der größten Partition. Ungefähr gleich große Swap-Partitionen erlauben es dem Kernel, den Swap-Bereich optimal über die Laufwerke zu verteilen. Große Swap-Bereiche, auch wenn sie nicht oft gebraucht werden, sind nützlich, da sich ein speicherfressendes Programm unter Umständen auch ohne einen Neustart des Systems beenden lässt.</p></div><div class=paragraph><p>Indem Sie ein System richtig partitionieren, verhindern Sie, dass eine Fragmentierung in den häufig beschriebenen Partitionen auf die meist nur gelesenen Partitionen übergreift. Wenn Sie die häufig beschriebenen Partitionen an den Rand der Platte legen, dann wird die I/O-Leistung dieser Partitionen steigen. Die I/O-Leistung ist natürlich auch für große Partitionen wichtig, doch erzielen Sie eine größere Leistungssteigerung, wenn Sie <span class=filename>/var</span> an den Rand der Platte legen.</p></div></div><div class=sect3><h4 id=bsdinstall-part-guided>4.6.2. Geführte Partitionierung für UFS<a class=anchor href=#bsdinstall-part-guided></a></h4><div class=paragraph><p>Bei dieser Methode wird ein Menü die verfügbaren Platten anzeigen. Sollten mehrere Platten angeschlossen sein, wählen Sie diejenige aus, auf der FreeBSD installiert werden soll.</p></div><div id=bsdinstall-part-guided-disk class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-guided-disk.png alt="bsdinstall part guided disk"></div><div class=title>Abbildung 11. Aus mehreren Platten eine auswählen</div></div><div class=paragraph><p>Nachdem Sie die Platte ausgewählt haben, fordert das nächste Menü dazu auf, entweder die gesamte Festplatte für die Installation zu nutzen oder eine Partition aus unbenutzten Speicherplatz zu erstellen. Ein allgemeines Partitionslayout, das die gesamte Platte einnimmt wird erstellt, wenn <b class=button>Entire Disk</b> ausgewählt wird. Durch die Wahl von <b class=button>Partition</b> wird ein Partitionslayout aus dem unbenutzten Speicherplatz der Platte erstellt.</p></div><div id=bsdinstall-part-entire-part class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-entire-part.png alt="bsdinstall part entire part"></div><div class=title>Abbildung 12. Auswahl der gesamten Platte oder einer Partition</div></div><div class=paragraph><p>Wenn <b class=button>Entire Disk</b> gewählt wurde, weist bsdinstall darauf hin, dass die Festplatte gelöscht wird.</p></div><div id=bsdinstall-ufs-warning class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-ufs-warning.png alt="bsdinstall ufs warning"></div><div class=title>Abbildung 13. Bestätigung</div></div><div class=paragraph><p>Das nächste Menü zeigt eine Liste der verfügbaren Partitionsschemas. GPT ist ist normalerweise die geeignetste Wahl für amd64-Rechner. Ältere Rechner, die nicht mit GPT kompatibel sind, sollten MBR benutzen. Die anderen Partitionsschemas werden im Allgemeinen für ungewöhnliche oder ältere Rechner benutzt. Weitere Informationen finden Sie in <a href=#partition-schemes>Partitionierungsschemas</a>.</p></div><div id=bsdinstall-ufs-scheme class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png alt="bsdinstall part manual partscheme"></div></div><div class=paragraph><p>Nachdem das Partitionslayout nun erstellt wurde, sollten Sie es überprüfen, um sicherzustellen, dass es die Bedürfnisse der Installation erfüllt. Durch die Auswahl von <b class=button>Revert</b> können die Partitionen wieder auf den ursprünglichen Wert zurückgesetzt werden und durch <b class=button>Auto</b> werden die automatischen FreeBSD Partitionen wiederhergestellt. Partitionen können auch manuell erstellt, geändert oder gelöscht werden. Sollte die Partitionierung richtig sein, wählen Sie <b class=button>Finish</b> aus, um mit der Installation fortzufahren.</p></div><div id=bsdinstall-part-review class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-review.png alt="bsdinstall part review"></div><div class=title>Abbildung 14. Überprüfen der erstellten Partitionen</div></div><div class=paragraph><p>Sobald die Festplatten konfiguriert sind, bietet das nächste Menü die letzte Möglichkeit, Änderungen vorzunehmen, bevor die ausgewählten Laufwerke formatiert werden. Wenn Änderungen vorgenommen werden müssen, wählen Sie <b class=button>Back</b>, um zum Hauptmenü zurückzukehren. Mit <b class=button>Revert & Exit</b> wird das Installationsprogramm beendet, ohne Änderungen am Laufwerk vorzunehmen. Wählen Sie <b class=button>Commit</b>, um die Installation zu starten.</p></div><div id=bsdinstall-ufs-final-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-confirmation.png alt="bsdinstall final confirmation"></div><div class=title>Abbildung 15. Abschließende Konfiguration</div></div><div class=paragraph><p>Um mit der Installation fortzufahren, gehen Sie zu <a href=#bsdinstall-fetching-distribution>Abrufen der Distributionen</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-part-manual>4.6.3. Manuelle Partitionierung<a class=anchor href=#bsdinstall-part-manual></a></h4><div class=paragraph><p>Diese Methode öffnet den Partitionseditor:</p></div><div id=bsdinstall-part-manual-create class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-create.png alt="bsdinstall part manual create"></div><div class=title>Abbildung 16. Partitionen manuell erstellen</div></div><div class=paragraph><p>Durch hervorheben einer Platte (in diesem Fall <span class=filename>ada0</span>) und die Auswahl von <b class=button>Create</b>, wird ein Menü mit den verfügbaren Partitionierungsschemas angezeigt.</p></div><div id=bsdinstall-part-manual-partscheme class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png alt="bsdinstall part manual partscheme"></div><div class=title>Abbildung 17. Partitionen manuell anlegen</div></div><div class=paragraph><p>GPT ist normalerweise die beste Wahl für amd64-Computer. Ältere Computer, die nicht mit GPT kompatibel sind, sollten MBR verwenden. Die anderen Partitionsschemas werden für gewöhnlich für ältere Computersysteme benutzt.</p></div><table id=partition-schemes class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 1. Partitionierungsschemas</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Abkürzung</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>APM</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Apple Partition Map, verwendet von PowerPC®.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>BSD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BSD-Labels ohne einen MBR, manchmal auch "dangerously dedicated mode" genannt, da nicht-BSD Festplatten-Werkzeuge dies vielleicht nicht erkennen können.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GPT</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GUID Partition Table (<a href=http://de.wikipedia.org/wiki/GUID_Partition_Table>http://en.wikipedia.org/wiki/GUID_Partition_Table</a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>MBR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Master Boot Record (<a href=http://de.wikipedia.org/wiki/Master_Boot_Record>http://en.wikipedia.org/wiki/Master_boot_record</a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>VTOC8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Volume Table Of Contents, von Sun SPARC64 und UltraSPARC Computern verwendet.</p></td></tr></tbody></table><div class=paragraph><p>Nachdem das Partitionierungsschema ausgewählt und erstellt wurde, werden durch erneute Auswahl von <b class=button>Create</b> die Partitionen erzeugt. Mit der <kbd>Tab</kbd>-Taste können Sie den Cursor zwischen den Feldern bewegen.</p></div><div id=bsdinstall-part-manual-addpart class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-addpart.png alt="bsdinstall part manual addpart"></div><div class=title>Abbildung 18. Partitionen manuell erzeugen</div></div><div class=paragraph><p>Eine FreeBSD-Standardinstallation mit GPT legt mindestens die folgenden drei Partitionen an:</p></div><div class=ulist><ul><li><p><code>freebsd-boot</code> - Enthält den FreeBSD-Bootcode.</p></li><li><p><code>freebsd-ufs</code> - Ein FreeBSD UFS-Dateisystem.</p></li><li><p><code>freebsd-zfs</code> - Ein FreeBSD ZFS-Dateisystem. Weitere Informationen finden Sie in <a href=./#zfs>Das Z-Dateisystem (ZFS)</a>.</p></li><li><p><code>freebsd-swap</code> - FreeBSD Auslagerungsbereich (swap space).</p></li></ul></div><div class=paragraph><p>Die einzelnen GPT-Partitionstypen sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> dokumentiert.</p></div><div class=paragraph><p>Es können mehrere Dateisystempartitionen erzeugt werden und manche Leute ziehen es vor, ein traditionelles Layout mit getrennten Partitionen für die Dateisysteme <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span> und <span class=filename>/usr</span> zu erstellen. Lesen Sie dazu <a href=#bsdinstall-part-manual-splitfs>Ein traditionelles, partitioniertes Dateisystem erstellen</a>, um ein Beispiel zu erhalten.</p></div><div class=paragraph><p>Größenangaben (<code>Size</code>) können mit gängigen Abkürzungen eingegeben werden: <em>K</em> für Kilobytes, <em>M</em> für Megabytes oder <em>G</em> für Gigabytes.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Korrekte Sektorausrichtung ermöglicht größtmögliche Geschwindigkeit und das Anlegen von Partitionsgrößen als vielfaches von 4K-Bytes hilft, die passende Ausrichtung auf Platten mit entweder 512-Bytes oder 4K-Bytes Sektorgrößen, festzulegen. Generell sollte die Verwendung von Partitionsgrößen, die sogar vielfache von 1M oder 1G sind, den einfachsten Weg darstellen, um sicher zu stellen, dass jede Partition an einem vielfachen von 4K beginnt. Eine Ausnahme gibt es: momentan sollte die <em>freebsd-boot</em>-Partition aufgrund von Beschränkungen im Bootcode nicht größer sein als 512K.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ein Einhägepunkt (<code>Mountpoint</code>) wird benötigt, falls diese Partition ein Dateisystem enthält. Falls nur eine einzelne UFS-Partition erstellt wird, sollte der Einhängepunkt <span class=filename>/</span> lauten.</p></div><div class=paragraph><p>Ein <code>label</code> ist ein Name, durch den diese Partition angesprochen wird. Festplattennamen oder -nummern können sich ändern, falls die Platte einmal an einem anderen Controller oder Port angeschlossen sein sollte, doch das Partitionslabel ändert sich dadurch nicht. Anstatt auf Plattennamen und Partitionsnummern in Dateien wie <span class=filename>/etc/fstab</span> zu verweisen, sorgen Labels dafür, dass das System Hardwareänderungen eher toleriert. GPT-Labels erscheinen in <span class=filename>/dev/gpt/</span>, wenn eine Platte angeschlossen wird. Andere Partitionierungsschemas besitzen unterschiedliche Fähigkeiten, Labels zu verwenden und diese erscheinen in anderen <span class=filename>/dev/</span>-Verzeichnissen.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Vergeben Sie ein einzigartiges Label für jede Partition, um Konflikte mit identischen Labels zu verhindern. Ein paar Buchstaben des Computernamens, dessen Verwendungszweck oder Ortes kann dem Label hinzugefügt werden. Beispielsweise <code>labroot</code> oder <code>rootfslab</code> für die UFS Root-Partition auf einem Laborrechner namens <code>lab</code>.</p></div></td></tr></tbody></table></div><div id=bsdinstall-part-manual-splitfs class=exampleblock><div class=title>Beispiel 1. Ein traditionelles, partitioniertes Dateisystem erstellen</div><div class=content><div class=paragraph><p>Für ein traditionelles Partitionslayout, in dem sich <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span> und <span class=filename>/usr</span> in getrennten Partitionen befinden sollen, erstellen Sie ein GPT-Partitionsschema und anschließend die Partitionen selbst. Die gezeigten Partitionsgrößen sind typisch für eine Festplatte von 20 G. Falls mehr Platz verfügbar ist, sind größere Swap oder <span class=filename>/var</span>-Partitionen nützlich. Den hier gezeigten Beschreibungen sind <code>bsp</code> für "Beispiel" vorangestellt, jedoch sollten Sie andere, einzigartige Beschreibungen verwenden, wie oben beschrieben.</p></div><div class=paragraph><p>Standardmäßig erwartet FreeBSDs <span class=filename>gptboot</span>, dass die erste UFS-Partition die <span class=filename>/</span>-Partition ist.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Partitionstyp</th><th class="tableblock halign-left valign-top">Grösse</th><th class="tableblock halign-left valign-top">Eingehängt als</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-boot</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>512K</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>bsprootfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-swap</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>4G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>bspswap</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>bspvarfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>1G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>bsptmpfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Akzeptieren Sie die Standardeinstellungen (Rest der Platte)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>bspusrfs</code></p></td></tr></tbody></table></div></div><div class=paragraph><p>Nachdem die Partitionen erzeugt wurden, wählen Sie <b class=button>Finish</b>, um die Installation mit <a href=#bsdinstall-fetching-distribution>Abrufen der Distributionen</a> fortzusetzen.</p></div></div><div class=sect3><h4 id=bsdinstall-part-zfs>4.6.4. Geführte Partitionierung mit Root-on-ZFS<a class=anchor href=#bsdinstall-part-zfs></a></h4><div class=paragraph><p>Dieser Modus funktioniert nur mit ganzen Laufwerken und wird alle vorhandenen Daten auf der Platte löschen. Das Konfigurationsmenü für ZFS bietet einige Optionen, um die Erstellung des Pools zu beeinflussen.</p></div><div id=bsdinstall-zfs-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-menu.png alt="bsdinstall zfs menu"></div><div class=title>Abbildung 19. ZFS Konfigurationsmenü</div></div><div class=paragraph><p>Hier eine Zusammenfassung der Optionen, die in diesem Menü benutzt werden können:</p></div><div class=ulist><ul><li><p><code>Install</code> - Setzt die Installation mit den ausgewählten Optionen fort.</p></li><li><p><code>Pool Type/Disks</code> - Erlaubt die Konfiguration des <code>Pool Type</code> und der Festplatte(n), die den Pool bilden werden. Das ZFS-Installationsprogramm unterstützt derzeit nur die Erstellung eines einzelnen Top-Level-Vdev, außer im Stripe-Modus. Um komplexere Pools zu erstellen, folgen Sie den Anweisungen in <a href=#bsdinstall-part-shell>Shell Partitionierung</a>, um den Pool zu erstellen.</p></li><li><p><code>Rescan Devices</code> - Aktualisiert die Liste der verfügbaren Festplatten.</p></li><li><p><code>Disk Info</code> - Dieses Menü wird verwendet, um Datenträger zu inspizieren, einschließlich ihrer Partitionstabelle und weitere Informationen wie die Modell- und Seriennummer des Geräts.</p></li><li><p><code>Pool Name</code> - Legt den Namen des Pools fest. Der Standard ist <em>zroot</em>.</p></li><li><p><code>Force 4K Sectors?</code> - Erzwingt die Verwendung von 4K-Sektoren. Im Standard erstellt die Installation automatisch Partitionen, die an 4K-Grenzen ausgerichtet sind. Bei ZFS wird die Verwendung von 4K-Sektoren erzwungen. Dies ist selbst bei Festplatten mit 512-Byte-Sektoren sicher und hat den zusätzlichen Vorteil, dass Pools, die auf solchen Festplatten mit erstellt werden, auch in Zukunft 4K-Sektoren haben können, entweder als zusätzlicher Speicherplatz oder als Ersatz für ausgefallene Platten. Drücken Sie <kbd>Enter</kbd>, um die Verwendung von 4K-Sektoren zu konfigurieren.</p></li><li><p><code>Encrypt Disks?</code> - Das Verschlüsseln der Datenträger mit GELI. Weitere Informationen zur Datenträgerverschlüsselung finden Sie in <a href=./#disks-encrypting-geli>“Plattenverschlüsselung mit geli”</a>. Drücken Sie <kbd>Enter</kbd> um eine Auswahl zu treffen.</p></li><li><p><code>Partition Scheme</code> - Erlaubt die Auswahl des Partitionsschemas. GPT ist die empfohlene Option. Drücken Sie <kbd>Enter</kbd>, um zwischen den verschiedenen Optionen zu wählen.</p></li><li><p><code>Swap Size</code> - Legt die Größe des Swap-Speichers fest.</p></li><li><p><code>Mirror Swap?</code> - Erlaubt es, den Swap-Speicher zwischen den Platten zu spiegeln. Beachten Sie jedoch, dass die Aktivierung dazu führt, dass Crash Dumps nicht mehr funktionieren. Drücken Sie <kbd>Enter</kbd>, um diese Option zu aktivieren/deaktivieren.</p></li><li><p><code>Encrypt Swap?</code> - Erlaubt es, den Swap-Speicher zu verschlüsseln. Der Swap-Speicher wird bei jedem Systemstart mit einem temporären Schlüssel verschlüsselt, der bei einem Neustart des Systems verworfen wird. Drücken Sie <kbd>Enter</kbd>, diese Option zu aktivieren/deaktivieren. Weitere Informationen zur Verschlüsselung des Swap-Speichers finden Sie in <a href=./#swap-encrypting>“Den Auslagerungsspeicher verschlüsseln”</a>.</p></li></ul></div><div class=paragraph><p>Wählen Sie <kbd>T</kbd> um den Pool Typ und die Festplatte(n) zu konfigurieren, die den Pool bilden werden.</p></div><div id=bsdinstall-zfs-vdev_type class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_type.png alt="bsdinstall zfs vdev type"></div><div class=title>Abbildung 20. ZFS Pool Typen</div></div><div class=paragraph><p>Hier eine Zusammenfassung der Pool-Typen, die in diesem Menü ausgewählt werden können:</p></div><div class=ulist><ul><li><p><code>stripe</code> - Striping bietet maximalen Speicherplatz für alle angeschlossenen Geräte, aber keine Redundanz. Fällt eine Platte aus, sind die Daten im Pool unwiderruflich verloren.</p></li><li><p><code>mirror</code> - Bei der Spiegelung wird eine vollständige Kopie aller Daten auf jeder Platte gespeichert. Die Spiegelung bietet eine gute Leistung beim Lesen, da die Daten von allen Platten parallel gelesen werden. Die Leistung beim Schreiben ist langsamer, da die Daten auf alle Platten im Pool geschrieben werden müssen. Hiermit können alle Platten bis auf eine ausfallen. Diese Option erfordert mindestens zwei Platten.</p></li><li><p><code>raid10</code> - Striped Mirrors. Bieten die beste Leistung, aber den geringsten Speicherplatz. Diese Option erfordert mindestens eine gerade Anzahl von Platten und mindestens vier Platten.</p></li><li><p><code>raidz1</code> - Einzelnes redundantes RAID. Ermöglicht den Ausfall einer Platte. Für diese Option sind mindestens drei Festplatten erforderlich.</p></li><li><p><code>raidz2</code> - Doppeltes redundantes RAID. Ermöglicht den Ausfall von zwei Platten. Für diese Option sind mindestens vier Festplatten erforderlich.</p></li><li><p><code>raidz3</code> - Dreifaches redundantes RAID. Ermöglicht den Ausfall von drei Platten. Für diese Option sind mindestens fünf Festplatten erforderlich.</p></li></ul></div><div class=paragraph><p>Sobald ein Pool-Typ (<code>Pool Type</code>) ausgewählt wurde, wird eine Liste der verfügbaren Laufwerke angezeigt und der Benutzer wird aufgefordert, eine oder mehrere Laufwerke für die Erstellung des Pools auszuwählen. Anschließend wie die Konfiguration geprüft um zu gewährleisten, dass genug Laufwerke ausgewählt wurden. Wählen Sie <b class=button>&lt;Change Selection></b> um zur Auswahl der Laufwerke zurückzukehren, oder <b class=button>&lt;Back></b> um den <code>Pool Type</code> zu ändern.</p></div><div id=bsdinstall-zfs-disk_select class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_select.png alt="bsdinstall zfs disk select"></div><div class=title>Abbildung 21. Auswahl der Laufwerke</div></div><div id=bsdinstall-zfs-vdev_invalid class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_invalid.png alt="bsdinstall zfs vdev invalid"></div><div class=title>Abbildung 22. Ungültige Auswahl</div></div><div class=paragraph><p>Wenn eine oder mehrere Platten in der Liste fehlen, oder wenn Festplatten angebunden wurden, nachdem das Installationsprogramm gestartet wurde, wählen Sie <b class=button>- Rescan Devices</b> um die Laufwerke nochmals zu suchen und anzuzeigen.</p></div><div id=bsdinstall-zfs-rescan-devices class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-rescan-devices.png alt="bsdinstall zfs rescan devices"></div><div class=title>Abbildung 23. Rescan Devices</div></div><div class=paragraph><p>Um zu vermeiden, dass versehentlich die falsche Platte gelöscht wird, können Sie das <b class=button>- Disk-Info</b>-Menü verwenden. Dieses Menü zeigt verschiedene Informationen, einschließlich der Partitionstabelle, der Modellnummer und der Seriennummer, falls verfügbar.</p></div><div id=bsdinstall-zfs-disk_info class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_info.png alt="bsdinstall zfs disk info"></div><div class=title>Abbildung 24. Informationen zum Laufwerk</div></div><div class=paragraph><p>Wählen Sie <kbd>N</kbd>, um den Pool-Namen zu konfigurieren. Geben Sie den gewünschten Namen ein und wählen Sie dann <b class=button>OK</b>, um den Namen zu speichern, oder <b class=button>&lt;Cancel></b>, um zum Hauptmenü zurückzukehren und den Standard zu belassen.</p></div><div id=bsdinstall-zfs-pool-name class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-pool-name.png alt="bsdinstall zfs pool name"></div><div class=title>Abbildung 25. Pool-Name</div></div><div class=paragraph><p>Wählen Sie <kbd>S</kbd>, um die Größe des Swap-Speichers festzulegen. Geben Sie die gewünschte Größe ein und wählen Sie dann <b class=button>OK</b>, um die Einstellung zu speichern, oder <b class=button>&lt;Cancel></b>, um zum Hauptmenü zurückzukehren und den Standard zu belassen.</p></div><div id=bsdinstall-zfs-swap-amount class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-swap-amount.png alt="bsdinstall zfs swap amount"></div><div class=title>Abbildung 26. Größe des Swap-Speichers</div></div><div class=paragraph><p>Wenn alle Optionen wie gewünscht konfiguriert sind, wählen Sie oben im Menü die Option <b class=button>>>> Install</b>. Das Installationsprogramm bietet dann eine letzte Chance zum Abbrechen, bevor der Inhalt der ausgewählten Laufwerke zerstört wird, um den ZFS-Pool zu erstellen.</p></div><div id=bsdinstall-zfs-warning class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-warning.png alt="bsdinstall zfs warning"></div><div class=title>Abbildung 27. Letzte Chance!</div></div><div class=paragraph><p>Wenn die GELI Plattenverschlüsselung aktiviert wurde, fordert das Installationsprogramm zweimal zur Eingabe der Passphrase auf. Anschließend beginnt die Initialisierung der Verschlüsselung.</p></div><div id=bsdinstall-zfs-geli_password class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-geli_password.png alt="bsdinstall zfs geli password"></div><div class=title>Abbildung 28. Passwort für die Verschlüsselung der Platte</div></div><div id=bsdinstall-zfs-init-encryption class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-init-encription.png alt="bsdinstall zfs init encription"></div><div class=title>Abbildung 29. Initialisierung der Verschlüsselung</div></div><div class=paragraph><p>Danach wird die Installation normal weitergeführt. Um mit der Installation fortzufahren, lesen Sie <a href=#bsdinstall-fetching-distribution>Abrufen der Distributionen</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-part-shell>4.6.5. Shell Partitionierung<a class=anchor href=#bsdinstall-part-shell></a></h4><div class=paragraph><p>bsdinstall bietet bei fortgeschrittenen Installationen womöglich nicht die benötigte Flexibilität. Erfahrene Benutzer können die Option <b class=button>Shell</b> im Menü auswählen, um die Laufwerke manuell zu partitionieren, Dateisysteme zu erstellen, <span class=filename>/tmp/bsdinstall_etc/fstab</span> zu befüllen und Dateisysteme unter <span class=filename>/mnt</span> einzuhängen. Geben Sie anschließend <code>exit</code> ein, um zu bsdinstall zurückzukehren und die Installation fortzusetzen.</p></div></div></div><div class=sect2><h3 id=bsdinstall-fetching-distribution>4.7. Abrufen der Distributionen<a class=anchor href=#bsdinstall-fetching-distribution></a></h3><div class=paragraph><p>Die Installationsdauer hängt von den gewählten Distributionen, dem Installationsmedium und der Geschwindigkeit des Computers ab. Eine Reihe von Nachrichten werden angezeigt, um den Fortschritt darzustellen.</p></div><div class=paragraph><p>Zunächst formatiert das Installationsprogramm die ausgewählten Platten und initialisiert die Partitionen. Bei <code>bootonly media</code> oder <code>mini memstick</code> werden als nächstes die benötigten Komponenten heruntergeladen:</p></div><div id=bsdinstall-distfile-fetching class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-fetching.png alt="bsdinstall distfile fetching"></div><div class=title>Abbildung 30. Herunterladen der Distributionsdateien</div></div><div class=paragraph><p>Als nächstes wird die Integrität der Distributionsdateien überprüft, um sicherzustellen, dass diese während des Ladevorgangs nicht beschädigt oder unsauber vom Installationsmedium gelesen wurden:</p></div><div id=bsdinstall-distfile-verify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-verifying.png alt="bsdinstall distfile verifying"></div><div class=title>Abbildung 31. Überprüfen der Distributionsdateien</div></div><div class=paragraph><p>Zum Schluss werden die überprüften Distributionsdateien auf die Festplatte entpackt:</p></div><div id=bsdinstall-distfile-extract class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-extracting.png alt="bsdinstall distfile extracting"></div><div class=title>Abbildung 32. Entpacken der Distributionsdateien</div></div><div class=paragraph><p>Sobald alle benötigten Distributionsdateien entpackt wurden, wird bsdinstall das erste Menü für die Arbeiten nach der Installation anzeigen. Die zur Verfügung stehenden Konfigurationsoptionen werden im nächsten Abschnitt beschrieben.</p></div></div><div class=sect2><h3 id=bsdinstall-post>4.8. Benutzerkonten, Zeitzone, Dienste und Sicherheitsoptionen<a class=anchor href=#bsdinstall-post></a></h3><div class=sect3><h4 id=bsdinstall-post-root>4.8.1. Setzen des <code>root</code>-Passworts<a class=anchor href=#bsdinstall-post-root></a></h4><div class=paragraph><p>Zuerst muss das <code>root</code>-Passwort gesetzt werden. Die eingegebenen Zeichen werden dabei nicht auf dem Bildschirm angezeigt. Nachdem das Passwort eingegeben wurde, muss es zur Bestätigung erneut eingetippt werden. Damit werden auch Tippfehler verhindert.</p></div><div id=bsdinstall-post-set-root-passwd class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-post-root-passwd.png alt="bsdinstall post root passwd"></div><div class=title>Abbildung 33. Das <code>root</code>-Passwort setzen</div></div></div><div class=sect3><h4 id=bsdinstall-timezone>4.8.2. Setzen der Zeitzone<a class=anchor href=#bsdinstall-timezone></a></h4><div class=paragraph><p>Die nächsten Menüs werden verwendet, um die korrekte Ortszeit zu ermitteln. Dazu muss die gewünschte geographische Region, das Land und die Zeitzone ausgewählt werden. Das Setzen der Zeitzone erlaubt es dem System automatische Korrekturen vorzunehmen, beispielsweise beim Wechsel von Sommer- auf Winterzeit.</p></div><div class=paragraph><p>Das hier gezeigte Beispiel bezieht sich auf einen Rechner in der Zeitzone des spanischen Festlands. Die Auswahl ist je nach geographischer Lage unterschiedlich.</p></div><div id=bsdinstall-timezone-region class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-region.png alt="bsdinstall timezone region"></div><div class=title>Abbildung 34. Auswahl der geographischen Region</div></div><div id=bsdinstall-timezone-country class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-country.png alt="bsdinstall timezone country"></div><div class=title>Abbildung 35. Das Land auswählen</div></div><div class=paragraph><p>Wählen Sie das zutreffende Land mit den Pfeiltasten und durch anschließendes drücken von <kbd>Enter</kbd> aus.</p></div><div id=bsdinstall-timezone-zone class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-zone.png alt="bsdinstall timezone zone"></div><div class=title>Abbildung 36. Wählen einer Zeitzone</div></div><div class=paragraph><p>Die passende Zeitzone wird durch die Pfeiltasten und anschließendes drücken von <kbd>Enter</kbd> ausgewählt.</p></div><div id=bsdinstall-timezone-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-confirm.png alt="bsdinstall timezone confirm"></div><div class=title>Abbildung 37. Bestätigen der Zeitzone</div></div><div class=paragraph><p>Bestätigen Sie, dass die Abkürzung für die Zeitzone korrekt ist.</p></div><div id=bsdinstall-timezone-date class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-date.png alt="bsdinstall timezone date"></div><div class=title>Abbildung 38. Datum auswählen</div></div><div class=paragraph><p>Das entsprechende Datum wird mit den Pfeiltasten und das anschließende Drücken von <b class=button>Set Date</b> gewählt. Andernfalls kann die Auswahl durch Drücken von <b class=button>Skip</b> übersprungen werden.</p></div><div id=bsdinstall-timezone-time class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-time.png alt="bsdinstall timezone time"></div><div class=title>Abbildung 39. Uhrzeit auswählen</div></div><div class=paragraph><p>Die entsprechende Uhrzeit wird mit den Pfeiltasten und das anschließende Drücken von <b class=button>Set Time</b> gewählt. Andernfalls kann die Auswahl durch Drücken von <b class=button>Skip</b> übersprungen werden.</p></div></div><div class=sect3><h4 id=bsdinstall-sysconf>4.8.3. Dienste aktivieren<a class=anchor href=#bsdinstall-sysconf></a></h4><div class=paragraph><p>Zusätzliche Systemdienste, die zur Startzeit aktiviert werden sollen, können im folgenden Menü eingeschaltet werden. All diese Dienste sind optional. Starten Sie nur die Dienste, die zur korrekten Funktion des Systems benötigt werden.</p></div><div id=bsdinstall-config-serv class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-services.png alt="bsdinstall config services"></div><div class=title>Abbildung 40. Auswahl zusätzlicher Dienste</div></div><div class=paragraph><p>Die folgenden Dienste können über dieses Menü aktiviert werden:</p></div><div class=ulist><ul><li><p><code>local_unbound</code> - Aktiviert den lokalen unbound DNS-Cache. Bedenken Sie, dass dies der Unbound des Basissystems ist und nur als lokaler Cache-Forwarding-Resolver gedacht ist. Möchten Sie einen DNS-Server für das gesamte Netzwerk einrichten, installieren Sie bitte <a class=package href=https://cgit.freebsd.org/ports/tree/dns/unbound/>dns/unbound</a>.</p></li><li><p><code>sshd</code> - Der Secure Shell (SSH)-Daemon für Fernzugriff über eine verschlüsselte Verbindung. Aktivieren Sie diesen Dienst nur dann, wenn das System für Fernzugriff zur Verfügung stehen soll.</p></li><li><p><code>moused</code> - Aktivieren Sie diesen Dienst, wenn Sie Mausunterstützung auf der Systemkonsole benötigen.</p></li><li><p><code>ntpdate</code> - Aktiviert die automatische Synchronisation der Uhrzeit beim booten. Diese Funktionalität ist ebenfalls im <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>-Daemon verfügbar. In naher Zukunft soll das Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> entfernt werden.</p></li><li><p><code>ntpd</code> - Der Network Time Protocol (NTP)-Daemon zur automatischen Uhrzeitsynchronisation. Aktivieren Sie diesen Dienst, wenn es im Netzwerk einen Windows®-, Kerberos- oder LDAP-Server gibt.</p></li><li><p><code>powerd</code> - Systemwerkzeug zur Leistungsregelung und für Stromsparfunktionen.</p></li><li><p><code>dumpdev</code> - Aktiviert die Absturzaufzeichnung, welche sehr nützlich sein kann, um Systemfehler aufzuspüren. Daher wird Anwendern empfohlen, diese Option zu aktivieren.</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-hardening>4.8.4. Aktivieren von Sicherheitsoptionen<a class=anchor href=#bsdinstall-hardening></a></h4><div class=paragraph><p>Im nächsten Menü können Sicherheitsoptionen aktiviert werden. Alle diese Optionen sind optional. Es wird jedoch empfohlen, sie zu aktivieren.</p></div><div id=bsdinstall-hardening-options class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-hardening.png alt="bsdinstall hardening"></div><div class=title>Abbildung 41. Auswahl der Sicherheitsoptionen</div></div><div class=paragraph><p>Folgende Optionen können in diesem Menü aktiviert werden:</p></div><div class=ulist><ul><li><p><code>hide_uids</code> - Versteckt die Prozesse von anderen Benutzern, um zu verhindern, dass unprivilegierte Benutzer laufende Prozesse von anderen Benutzern (UID) sehen können.</p></li><li><p><code>hide_gids</code> - Versteckt die Prozesse anderer Gruppen, um zu verhindern, dass unprivilegierte Benutzer laufende Prozesse von anderen Gruppen (GID) sehen können.</p></li><li><p><code>hide_jails</code> - Versteckt Jail-Prozesse, um zu verhindern, dass unprivilegierte Benutzer die in den Jails laufenden Prozesse sehen können.</p></li><li><p><code>read_msgbuf</code> - Deaktiviert den Lesezugriff auf den Nachrichtenpuffer des Kernels für nicht privilegierte Benutzer. Dadurch wird verhindert, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> zum Anzeigen von Nachrichten aus dem Nachrichtenpuffer des Kernels verwendet wird.</p></li><li><p><code>proc_debug</code> - Die Deaktivierung von Prozess-Debugging-Funktionen für unprivilegierte Benutzer deaktiviert einige IPC-Dienste und procfs-Funktionen, ptrace() und ktrace(). Beachten Sie, dass dadurch auch die Nutzung von Werkzeugen wie <a href="https://man.freebsd.org/cgi/man.cgi?query=lldb&amp;sektion=1&amp;format=html">lldb(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=truss&amp;sektion=1&amp;format=html">truss(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=procstat&amp;sektion=1&amp;format=html">procstat(1)</a> und einige Debugging-Funktionen von Skriptsprachen wie PHP, für unprivilegierte Benutzer unterbunden wird.</p></li><li><p><code>random_pid</code> - Zufällig generierte PID für neu erstellte Prozesse.</p></li><li><p><code>clear_tmp</code> - Bereinigt das Verzeichnis <span class=filename>/tmp</span> beim Systemstart.</p></li><li><p><code>disable_syslogd</code> - Diese Option verhindert, dass syslogd einen Netzwerk-Socket öffnet. In der Voreinstellung startet FreeBSD syslogd auf sichere Weise mit <code>-s</code>. Das verhindert, dass der Daemon auf Port 514 auf UDP-Anfragen lauscht. Wenn diese Option aktiviert ist, läuft syslogd mit dem Schalter <code>-ss</code>, dass syslogd daran hindert, einen Port zu öffnen. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>.</p></li><li><p><code>disable_sendmail</code> - Deaktiviert den sendmail MTA.</p></li><li><p><code>secure_console</code> - Wenn diese Option aktiviert ist, fragt das System im Single-User-Modus nach dem <code>root"</code>-Passwort.</p></li><li><p><code>disable_ddtrace</code> - DTrace kann in einem Modus laufen, der sich tatsächlich auf den laufenden Kernel auswirkt. Destruktive Aktionen dürfen nicht benutzt werden, es sei denn, sie wurden explizit aktiviert. Um diese Option bei der Verwendung von DTrace zu aktivieren, benutzen Sie <code>-w</code>. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=dtrace&amp;sektion=1&amp;format=html">dtrace(1)</a>.</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-addusers>4.8.5. Benutzer hinzufügen<a class=anchor href=#bsdinstall-addusers></a></h4><div class=paragraph><p>Das nächste Menü fordert Sie dazu auf, mindestens ein Benutzerkonto zu erstellen. Es wird empfohlen, sich als normaler Benutzer am System anzumelden und nicht als <code>root</code>-Benutzer. Wenn man als <code>root</code> angemeldet ist, gibt es so gut wie keine Beschränkungen oder Schutz vor dem, was man tun kann. Die Anmeldung als normaler Benutzer ist daher sicherer und bietet mehr Schutz.</p></div><div class=paragraph><p>Wählen Sie <b class=button>Yes</b>, um neue Benutzer hinzuzufügen.</p></div><div id=bsdinstall-add-user1 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser1.png alt="bsdinstall adduser1"></div><div class=title>Abbildung 42. Benutzerkonten hinzufügen</div></div><div class=paragraph><p>Folgen Sie den Anweisungen und geben Sie die angeforderten Informationen für das Benutzerkonto ein. Das Beispiel in <a href=#bsdinstall-add-user2>Benutzerinformationen eingeben</a> erstellt ein Konto für den Benutzer <code>asample</code>.</p></div><div id=bsdinstall-add-user2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser2.png alt="bsdinstall adduser2"></div><div class=title>Abbildung 43. Benutzerinformationen eingeben</div></div><div class=paragraph><p>Die folgenden Informationen müssen eingegeben werden:</p></div><div class=ulist><ul><li><p><code>Username</code> - Der Name des Benutzers, den man zur Anmeldung eingeben muss. Es ist üblich, den ersten Buchstaben des Vornamens zusammen mit dem Nachnamen zu kombinieren. Jeder Benutzername ist möglich, solange er für das System einzigartig ist. Es wird zwischen Groß- und Kleinschreibung unterschieden und der Benutzername sollte keine Leerzeichen enthalten.</p></li><li><p><code>Full name</code> - Der volle Name des Benutzers. Dieser darf auch Leerzeichen enthalten und dient als Beschreibung für das Benutzerkonto.</p></li><li><p><code>Uid</code> - User ID. Normalerweise wird dieses Feld leer gelassen, so dass das System einen Wert vergibt.</p></li><li><p><code>Login group</code> - Die Benutzergruppe. Normalerweise bleibt dieses Feld leer, um die Standardgruppe zu akzeptieren.</p></li><li><p><code>Invite <em>user</em> into other groups?</code> - Zusätzliche Gruppen zu denen der Benutzer als Mitglied hinzugefügt werden soll. Falls der Benutzer administrativen Zugriff benötigt, tragen Sie hier <code>wheel</code> ein.</p></li><li><p><code>Login class</code> - In der Regel bleibt dieses Feld leer.</p></li><li><p><code>Shell</code> - Die interaktive Shell für diesen Benutzer. Tragen Sie hier eine der aufgeführten Shells ein. Weitere Informationen über Shells finden Sie im <a href=./#shells>“Shells”</a>.</p></li><li><p><code>Home directory</code> - Das Heimatverzeichnis des Benutzers. Die Vorgabe ist für gewöhnlich richtig.</p></li><li><p><code>Home directory permissions</code> - Zugriffsrechte auf das Heimatverzeichnis des Benutzers. Die Vorgabe ist normalerweise die passende.</p></li><li><p><code>Use password-based authentication?</code> - Normalerweise <code>yes</code>, damit der Benutzer bei der Anmeldung sein Passwort eingeben muss.</p></li><li><p><code>Use an empty password?</code> - Normalerweise <code>no</code>, da ein leeres Passwort unsicher ist.</p></li><li><p><code>Use a random password?</code> - Normalerweise <code>no</code>, damit der Benutzer sein Passwort am nächsten Prompt selber vergeben kann.</p></li><li><p><code>Enter password</code> - Das Passwort für diesen Benutzer. Eingegebene Zeichen werden nicht am Bildschirm angezeigt.</p></li><li><p><code>Enter password again</code> - Das Passwort muss zur Überprüfung erneut eingegeben werden.</p></li><li><p><code>Lock out the account after creation?</code> - Normalerweise <code>no</code>, damit sich der Benutzer anmelden kann.</p></li></ul></div><div class=paragraph><p>Nachdem alles eingegeben wurde, wird eine Zusammenfassung angezeigt und das System fragt Sie, dies so korrekt ist. Falls ein Eingabefehler gemacht wurde, geben Sie <code>no</code> ein und versuchen es erneut. Falls alles in Ordnung ist, geben Sie <code>yes</code> ein, um den neuen Benutzer anzulegen.</p></div><div id=bsdinstall-add-user3 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser3.png alt="bsdinstall adduser3"></div><div class=title>Abbildung 44. Verlassen der Benutzer- und Gruppenverwaltung</div></div><div class=paragraph><p>Falls es mehr Benutzer hinzuzufügen gibt, beantworten Sie die Frage <code>Add another user?</code> mit <code>yes</code>. Geben Sie <code>no</code> ein, wird das hinzufügen von Benutzern beendet und die Installation fortgesetzt.</p></div><div class=paragraph><p>Für weitere Informationen zum hinzufügen von Benutzern und deren Verwaltung, lesen Sie <a href=./#users-synopsis>“Benutzer und grundlegende Account-Verwaltung”</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-final-conf>4.8.6. Letzte Konfigurationsschritte<a class=anchor href=#bsdinstall-final-conf></a></h4><div class=paragraph><p>Nachdem alles installiert und konfiguriert wurde, bekommen Sie noch eine letzte Chance, um Einstellungen zu verändern.</p></div><div id=bsdinstall-final-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-finalconfiguration.png alt="bsdinstall finalconfiguration"></div><div class=title>Abbildung 45. Letzte Schritte der Konfiguration</div></div><div class=paragraph><p>Verwenden Sie dieses Menü, um noch letzte Änderungen oder zusätzliche Konfigurationen vor dem Abschließen der Installation zu tätigen.</p></div><div class=ulist><ul><li><p><code>Add User</code> - Beschrieben in <a href=#bsdinstall-addusers>Benutzer hinzufügen</a>.</p></li><li><p><code>Root Password</code> - Beschrieben in <a href=#bsdinstall-post-root>Setzen des <code>root</code>-Passworts</a>.</p></li><li><p><code>Hostname</code> - Beschrieben in <a href=#bsdinstall-hostname>Den Rechnernamen festlegen</a>.</p></li><li><p><code>Network</code> - Beschrieben in <a href=#bsdinstall-config-network-dev>Die Netzwerkschnittstelle konfigurieren</a>.</p></li><li><p><code>Services</code> - Beschrieben in <a href=#bsdinstall-sysconf>Dienste aktivieren</a>.</p></li><li><p><code>Time Zone</code> - Beschrieben in <a href=#bsdinstall-timezone>Setzen der Zeitzone</a>.</p></li><li><p><code>Handbook</code> - Herunterladen und installieren des FreeBSD Handbuchs.</p></li></ul></div><div class=paragraph><p>Nachdem die letzten Konfigurationsschritte beendet sind, wählen Sie <b class=button>Exit</b>.</p></div><div id=bsdinstall-final-modification-shell class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-modification-shell.png alt="bsdinstall final modification shell"></div><div class=title>Abbildung 46. Manuelle Konfiguration</div></div><div class=paragraph><p>bsdinstall wird nach zusätzlichen Konfigurationen, die noch zu tätigen sind, fragen, bevor in das neue System gebootet wird. Wählen Sie <b class=button>Yes</b>, um in eine Shell innerhalb des neuen Systems zu wechseln oder <b class=button>No</b>, um mit dem letzten Schritt der Installation zu beginnen.</p></div><div id=bsdinstall-final-main class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-mainexit.png alt="bsdinstall mainexit"></div><div class=title>Abbildung 47. Die Installation vervollständigen</div></div><div class=paragraph><p>Wenn weitere Konfigurationen oder besondere Einstellungen benötigt werden, wählen Sie <b class=button>Live CD</b>, um das Installationsmedium im Live-CD Modus zu starten.</p></div><div class=paragraph><p>Wenn die Installation vollständig ist, wählen Sie <b class=button>Reboot</b>, um den Computer neu zu starten und das neu installierte FreeBSD-System zu booten. Vergessen Sie nicht, das FreeBSD Installationsmedium zu entfernen, oder der Computer wird erneut davon starten.</p></div><div class=paragraph><p>Wenn FreeBSD startet, werden viele Informationsmeldungen ausgegeben. Nachdem das System den Startvorgang abgeschlossen hat, wird eine Anmeldeaufforderung angezeigt. Geben Sie am <code>login:</code> den Benutzernamen ein, den Sie während der Installation hinzugefügt haben. Vermeiden Sie es, sich als <code>root</code> anzumelden. Lesen Sie <a href=./#users-superuser>“Der Superuser-Account”</a>, wenn Sie administrativen Zugriff benötigen.</p></div><div class=paragraph><p>Um Nachrichten, die während des Bootens angezeigt wurden, zu sehen, aktivieren Sie durch drücken von <kbd>Scroll-Lock</kbd> den <em>scroll-back buffer</em>. Die Tasten <kbd>PgUp</kbd>, <kbd>PgDn</kbd> und die Pfeiltasten dienen zur Navigation durch die Nachrichten. Durch erneutes drücken von <kbd>Scroll-Lock</kbd> wird der Bildschirm wieder entsperrt und kehrt zur normalen Anzeige zurück. Mit <code>less /var/run/dmesg.boot</code> können Sie sich diese Nachrichten im laufenden Betrieb ansehen. Durch drücken von <kbd>q</kbd> kehren Sie wieder zur Kommandozeile zurück.</p></div><div class=paragraph><p>Wenn sshd in <a href=#bsdinstall-config-serv>Auswahl zusätzlicher Dienste</a> aktiviert wurde, ist der erste Start ein bisschen langsamer, weil das System die RSA- und DSA-Schlüssel erzeugen muss. Die nachfolgenden Startvorgänge werden dann wieder schneller sein. Wie in diesem Beispiel zu sehen ist, werden die Fingerabdrücke der Schlüssel am Bildschirm ausgegeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Generating public/private rsa1 key pair.
Your identification has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.
Your public key has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.pub.
The key fingerprint is:
10:a0:f5:af:93:ae:a3:1a:b2:bb:3c:35:d9:5a:b3:f3 root@machine3.example.com
The key<span class=s1>&#39;s randomart image is:
+--[RSA1 1024]----+
|    o..          |
|   o . .         |
|  .   o          |
|       o         |
|    o   S        |
|   + + o         |
|o . + *          |
|o+ ..+ .         |
|==o..o+E         |
+-----------------+
Generating public/private dsa key pair.
Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
The key fingerprint is:
7e:1c:ce:dc:8a:3a:18:13:5b:34:b5:cf:d9:d1:47:b2 root@machine3.example.com
The key&#39;</span>s randomart image is:
+--[ DSA 1024]----+
|       ..     <span class=nb>.</span> .|
|      o  <span class=nb>.</span>   <span class=nb>.</span> + |
|     <span class=nb>.</span> ..   <span class=nb>.</span> E .|
|    <span class=nb>.</span> <span class=nb>.</span>  o o <span class=nb>.</span> <span class=nb>.</span> |
|     +  S <span class=o>=</span> <span class=nb>.</span>    |
|    +  <span class=nb>.</span> <span class=o>=</span> o     |
|     +  <span class=nb>.</span> <span class=k>*</span> <span class=nb>.</span>    |
|    <span class=nb>.</span> <span class=nb>.</span>  o <span class=nb>.</span>     |
|      .o. <span class=nb>.</span>      |
+-----------------+
Starting sshd.</code></pre></div></div><div class=paragraph><p>Lesen Sie <a href=./#openssh>OpenSSH</a> für weitere Informationen zu Fingerabdrücken und SSH.</p></div><div class=paragraph><p>FreeBSD installiert standardmäßig keine graphische Umgebung. <a href=./#x11>Das X-Window-System</a> enthält Informationen zur Installation und Konfiguration eines graphischen Window Managers.</p></div><div class=paragraph><p>Das korrekte herunterfahren eines FreeBSD-Computers hilft, beugt dem Datenverlust vor und schützt sogar die Hardware vor Schäden. <em>Schalten Sie nicht den Strom ab, bevor das System ordnungsgemäß heruntergefahren wurde!</em> Wenn der Benutzer ein Mitglied der <code>wheel</code>-Gruppe ist, können Sie zum Superuser durch die Eingabe von <code>su</code> und der anschließenden Eingabe des Passworts von <code>root</code> werden. Geben Sie dann <code>shutdown -p now</code> ein. Das System wird jetzt sauber heruntergefahren und, falls die Hardware es unterstützt, den Rechner ausschalten.</p></div></div></div><div class=sect2><h3 id=bsdinstall-network>4.9. Netzwerkschnittstellen<a class=anchor href=#bsdinstall-network></a></h3><div class=sect3><h4 id=bsdinstall-config-network-dev>4.9.1. Die Netzwerkschnittstelle konfigurieren<a class=anchor href=#bsdinstall-config-network-dev></a></h4><div class=paragraph><p>Als nächstes wird eine Liste der gefundenen Netzwerkschnittstellen gezeigt. Wählen Sie die Schnittstelle aus, die Sie konfigurieren möchten.</p></div><div id=bsdinstall-configure-net-interface class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface.png alt="bsdinstall configure network interface"></div><div class=title>Abbildung 48. Eine zu konfigurierende Netzwerkschnittstelle auswählen</div></div><div class=paragraph><p>Wenn Sie eine Ethernet-Schnittstelle ausgewählt haben, fährt das Installationsprogramm mit dem Menü aus <a href=#bsdinstall-configure-net-ipv4>Auswahl von IPv4</a> fort. Wenn Sie eine drahtlose Netzwerkschnittstelle ausgewählt haben, wird das System nach drahtlosen Zugriffspunkten (Access Points) suchen:</p></div><div id=bsdinstall-wireless-scan class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-scan.png alt="bsdinstall configure wireless scan"></div><div class=title>Abbildung 49. Nach drahtlosen Access Points scannen</div></div><div class=paragraph><p>Drahtlose Netzwerke werden durch einen Service Set Identifier (SSID) identifiziert. Der SSID ist ein kurzer, eindeutiger Name, der für jedes Netzwerk vergeben wird. SSIDs, die während des Scans gefunden wurden, werden aufgelistet, gefolgt von einer Beschreibung der Verschlüsselungsarten, die für dieses Netzwerk verfügbar sind. Falls die gewünschte SSID nicht in der Liste auftaucht, wählen Sie <b class=button>Rescan</b>, um erneut einen Scanvorgang durchzuführen. Falls dann das gewünschte Netzwerk immer noch nicht erscheint, überprüfen Sie die Antenne auf Verbindungsprobleme oder versuchen Sie, näher an den Access point zu gelangen. Scannen Sie erneut nach jeder vorgenommenen Änderung.</p></div><div id=bsdinstall-wireless-accesspoints class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-accesspoints.png alt="bsdinstall configure wireless accesspoints"></div><div class=title>Abbildung 50. Ein drahtloses Netzwerk auswählen</div></div><div class=paragraph><p>Geben Sie nun die Verschlüsselungsinformationen ein, um sich mit dem drahtlosen Netzwerk zu verbinden. WPA2 wird als Verschlüsselung dringend empfohlen, da ältere Verschlüsselungsmethoden, wie WEP, nur wenig Sicherheit bieten. Wenn das Netzwerk WPA2 verwendet, geben Sie das Passwort (auch bekannt als Pre-Shared Key PSK) ein. Aus Sicherheitsgründen werden die in das Eingabefeld eingegeben Zeichen nur als Sternchen angezeigt.</p></div><div id=bsdinstall-wireless-wpa2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-wpa2setup.png alt="bsdinstall configure wireless wpa2setup"></div><div class=title>Abbildung 51. Verbindungsaufbau mit WPA2</div></div><div class=paragraph><p>Wählen Sie, ob eine IPv4-Adresse auf der Ethernet-Schnittstelle oder der drahtlosen Schnittstelle konfiguriert werden soll.</p></div><div id=bsdinstall-configure-net-ipv4 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4.png alt="bsdinstall configure network interface ipv4"></div><div class=title>Abbildung 52. Auswahl von IPv4</div></div><div class=paragraph><p>Es gibt zwei Arten, ein IPv4-Netzwerk zu konfigurieren. DHCP wird automatisch die Netzwerkschnittstelle richtig konfigurieren und sollte verwendet werden, wenn das Netzwerk über einen DHCP-Server verfügt. Eine <em>statische</em> IP-Konfiguration erfordert die manuelle Eingabe von Netzwerkinformationen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Geben Sie keine zufällig gewählten Netzwerkinformationen ein, da dies nicht funktionieren wird. Holen Sie sich die in <a href=#bsdinstall-collect-network-information>Erforderliche Informationen zum Netzwerk</a> gezeigten Informationen vom Netzwerkadministrator oder Serviceprovider, falls kein DHCP-Server verfügbar ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Falls ein DHCP-Server zur Verfügung steht, wählen Sie im nächsten Menü <b class=button>Yes</b>, um die Netzwerkschnittstelle automatisch einrichten zu lassen. Dieser Vorgang kann einige Sekunden dauern.</p></div><div id=bsdinstall-net-ipv4-dhcp class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-dhcp.png alt="bsdinstall configure network interface ipv4 dhcp"></div><div class=title>Abbildung 53. Auswählen der IPv4-Konfiguration über DHCP</div></div><div class=paragraph><p>Wenn kein DHCP-Server zur Verfügung steht, wählen Sie <b class=button>No</b> und tragen Sie die folgenden Informationen in das Menü ein:</p></div><div id=bsdinstall-net-ipv4-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-static.png alt="bsdinstall configure network interface ipv4 static"></div><div class=title>Abbildung 54. Statische IPv4-Konfiguration</div></div><div class=ulist><ul><li><p><code>IP Address</code> - Die IPv4-Adresse, welche diesem Computer zugewiesen werden soll. Diese Adresse muss eindeutig sein und darf nicht bereits von einem anderen Gerät im lokalen Netzwerk verwendet werden.</p></li><li><p><code>Subnet Mask</code> - Die Subnetzmaske des Netzwerks.</p></li><li><p><code>Default Router</code> - Die IP-Adresse des Defaultrouters im Netzwerk.</p></li></ul></div><div class=paragraph><p>Das nächste Menü fragt, ob die Schnittstelle für IPv6 konfiguriert werden soll. Falls IPv6 verfügbar ist und verwendet werden soll, wählen Sie <b class=button>Yes</b> aus.</p></div><div id=bsdinstall-net-ipv6 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6.png alt="bsdinstall configure network interface ipv6"></div><div class=title>Abbildung 55. Auswahl von IPv6</div></div><div class=paragraph><p>IPv6 besitzt ebenfalls zwei Arten der Konfiguration. <em>StateLess Address AutoConfiguration</em>, (SLAAC) wird automatisch die richtigen Informationen von einem lokalen Router abfragen. Lesen Sie <a href=http://tools.ietf.org/html/rfc4862>http://tools.ietf.org/html/rfc4862</a> für weitere Informationen. Eine <em>statische</em> Konfiguration verlangt die manuelle Eingabe von Netzwerkinformationen.</p></div><div class=paragraph><p>Wenn ein IPv6-Router verfügbar ist, wählen Sie im nächsten Menü <b class=button>Yes</b>, um die Netzwerkschnittstelle automatisch konfigurieren zu lassen.</p></div><div id=bsdinstall-net-ipv6-slaac class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-slaac.png alt="bsdinstall configure network interface slaac"></div><div class=title>Abbildung 56. Auswahl der IPv6SLAAC-Konfiguration</div></div><div class=paragraph><p>Wenn kein IPv6-Router zur Verfügung steht, wählen Sie <b class=button>No</b> und tragen Sie die folgenden Adressinformationen in dieses Menü ein:</p></div><div id=bsdinstall-net-ipv6-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6-static.png alt="bsdinstall configure network interface ipv6 static"></div><div class=title>Abbildung 57. Statische IPv6-Konfiguration</div></div><div class=ulist><ul><li><p><code>IPv6 Address</code> - Die zugewiesene IPv6-Adresse, welche dem Computer zugeteilt werden soll. Diese Adresse muss eindeutig sein und nicht bereits von einer anderen Netzwerkkomponente im lokalen Netzwerk verwendet werden.</p></li><li><p><code>Default Router</code> - Die IPv6-Adresse des Defaultrouters im Netzwerk.</p></li></ul></div><div class=paragraph><p>Das letzte Menü der Netzwerkkonfiguration konfiguriert den <em>Domain Name System</em> (DNS) Resolver, welcher Hostnamen von und zu Netzwerkadressen umwandelt. Falls DHCP oder SLAAC verwendet wurde, um die Netzwerkschnittstelle zu konfigurieren, ist die Konfiguration für den Resolver möglicherweise bereits eingetragen. Andernfalls geben Sie den lokalen Netzwerkdomänennamen in das Feld <code>Search</code> ein. <code>DNS #1</code> und <code>DNS #2</code> sind die IPv4- und/oder IPv6-Adressen der lokalen DNS-Server. Zumindest ein DNS-Server wird benötigt.</p></div><div id=bsdinstall-net-dns-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-ipv4-dns.png alt="bsdinstall configure network ipv4 dns"></div><div class=title>Abbildung 58. DNS-Konfiguration</div></div><div class=paragraph><p>Sobald die Schnittstelle konfiguriert ist, bestimmen Sie einen Spiegelserver, welcher in der gleichen Region auf der Welt beheimatet ist, wie der Computer, auf dem FreeBSD installiert wird. Dateien können so viel schneller übertragen werden, wenn der Spiegelserver sich näher am Zielcomputer befindet und die Installationszeit wird somit reduziert.</p></div><div id=bsdinstall-netinstall-mirror class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-mirrorselect.png alt="bsdinstall netinstall mirrorselect"></div><div class=title>Abbildung 59. Einen Spiegelserver wählen</div></div></div></div><div class=sect2><h3 id=bsdinstall-install-trouble>4.10. Fehlerbehebung<a class=anchor href=#bsdinstall-install-trouble></a></h3><div class=paragraph><p>Dieser Abschnitt behandelt einfache Fehlerbehebungen für die Installation, wie beispielsweise häufig auftretende Fehler, die von Anwendern berichtet wurden.</p></div><div class=paragraph><p>Überprüfen Sie die Hardware Notes (<a href=https://www.FreeBSD.org/releases/>https://www.freebsd.org/releases/</a>) nach der Version von FreeBSD, um sicher zu stellen, dass die Hardware auch unterstützt wird. Wenn die Hardware unterstützt wird und Sie immer noch Abstürze oder andere Probleme erleben, müssen Sie einen eigenen Kernel bauen. Diese Prozedur wird in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> beschrieben. Das erlaubt es, Unterstützung für Geräte, die im <span class=filename>GENERIC</span>-Kernel nicht vorhanden sind, hinzuzufügen. Der Kernel ist mit der Annahme konfiguriert, dass die Hardwaregeräte sich in ihren Fabrikeinstellungen in Bezug auf IRQs, I/O-Adressen und DMA-Kanälen befinden. Wenn die Hardware neu konfiguriert wurde, werden Sie möglicherweise die Konfiguration des Kernels bearbeiten und diesen neu erstellen müssen, um FreeBSD mitzuteilen, wo es gewisse Dinge finden kann.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Manche Installationsprobleme können Aktualisierung der Firmware auf verschiedenen Hardwarekomponenten verhindert oder verringert werden, meistens am Mainboard. Mit Mainboard-Firmware ist für gewöhnlich das BIOS gemeint. Die meisten Mainboard- und Computerhersteller haben eine Webseite mit Aktualisierungen und Informationen zur Durchführung.</p></div><div class=paragraph><p>Hersteller raten meist von einer Aktualisierung des Mainboard-BIOS ab, außer es gibt einen guten Grund dafür, wie beispielsweise eine kritische Aktualisierung. Der Aktualisierungsvorgang <em>kann</em> schiefgehen, was das BIOS unvollständig macht und den Computer nicht mehr starten lässt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn das System während der Geräteerkennung beim Starten hängt oder sich während der Installation merkwürdig verhält, ist ACPI vielleicht der Übeltäter. FreeBSD macht auf i386- und amd64-Plattformen starken Gebrauch vom ACPI-Dienst, um dem System bei der Konfiguration während des Startvorgangs zu helfen. Leider existieren immer noch Fehler im ACPI-Treiber, in den Mainboards und der BIOS-Firmware. ACPI kann durch setzen der Einstellung <code>hint.acpi.0.disabled</code> im dritten Teil des Bootloaders deaktiviert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set </span>hint.acpi.0.disabled<span class=o>=</span><span class=s2>&#34;1&#34;</span></code></pre></div></div><div class=paragraph><p>Dies wird nach jedem Neustart des Systems wieder zurückgesetzt, also ist es notwendig, die Zeile <code>hint.acpi.0.disabled="1"</code> zu der Datei <span class=filename>/boot/loader.conf</span> hinzuzufügen. Weitere Informationen über den Bootloader lassen sich in <a href=./#boot-synopsis>“Übersicht”</a> nachlesen.</p></div></div><div class=sect2><h3 id=using-live-cd>4.11. Verwendung der Live-CD<a class=anchor href=#using-live-cd></a></h3><div class=paragraph><p>Das Willkommensmenü von bsdinstall, welches in <a href=#bsdinstall-choose-mode>Willkommen-Menü</a> gezeigt wird, enthält eine <b class=button>Live CD</b> Option. Die Live-CD ist für Benutzer, die sich fragen, ob FreeBSD das richtige Betriebssystem für sie ist und die vor der Installation noch einige Merkmale und Eigenschaften testen wollen.</p></div><div class=paragraph><p>Die folgenden Punkte sollten beachtet werden, bevor die <b class=button>Live CD</b> benutzt wird:</p></div><div class=ulist><ul><li><p>Um Zugriff auf das System zu bekommen, wird eine Authentifizierung benötigt. Der Benutzername ist <code>root</code> und das Kennwort bleibt leer.</p></li><li><p>Da das System direkt von dem Installationsmedium ausgeführt wird, ist die Geschwindigkeit deutlich langsamer als bei einem System, das auf einer Festplatte installiert ist.</p></li><li><p>Diese Option enthält nur eine Eingabeaufforderung und keine graphische Oberfläche.</p></li></ul></div></div></div></div><div class=sect1><h2 id=basics>Kapitel 5. Grundlagen des FreeBSD Betriebssystems<a class=anchor href=#basics></a></h2><div class=sectionbody><div class=sect2><h3 id=basics-synopsis>5.1. Übersicht<a class=anchor href=#basics-synopsis></a></h3><div class=paragraph><p>Dieses Kapitel umfasst die grundlegenden Kommandos und Funktionsweisen des FreeBSD-Betriebssystems. Viel von diesem Material gilt auch für jedes andere UNIX®-artige System. Neue Benutzer von FreeBSD sollten dieses Kapitel aufmerksam lesen.</p></div><div class=paragraph><p>Dieser Abschnitt behandelt die folgenden Themen:</p></div><div class=ulist><ul><li><p>virtuelle Konsolen,</p></li><li><p>Erstellung und Verwaltung von Benutzern und Gruppen in FreeBSD,</p></li><li><p>Zugriffsrechte unter UNIX® sowie Datei-Flags unter FreeBSD,</p></li><li><p>Zugriffskontrolllisten für Dateisysteme,</p></li><li><p>die Verzeichnisstruktur von FreeBSD,</p></li><li><p>Organisation von Dateisystemen unter FreeBSD,</p></li><li><p>Ein- und Abhängen von Dateisystemen,</p></li><li><p>Prozesse, Dämonen und Signale,</p></li><li><p>Shells und die Login-Umgebung,</p></li><li><p>Texteditoren,</p></li><li><p>Geräte und Gerätedateien,</p></li><li><p>wie Sie in den Manualpages nach weiteren Informationen suchen können.</p></li></ul></div></div><div class=sect2><h3 id=consoles>5.2. Virtuelle Konsolen und Terminals<a class=anchor href=#consoles></a></h3><div class=paragraph><p>Wenn das FreeBSD-System so konfiguriert wurde, dass es ohne eine grafische Benutzeroberfläche startet, wird das System nach dem Start einen Anmeldeprompt ausgeben, wie in diesem Beispiel zu sehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>FreeBSD/amd64 <span class=o>(</span>pc3.example.org<span class=o>)</span> <span class=o>(</span>ttyv0<span class=o>)</span>

login:</code></pre></div></div><div class=paragraph><p>Die erste Zeile enthält einige Informationen über das System. <code>amd64</code> zeigt an, dass auf dem System in diesem Beispiel eine 64-Bit Version von FreeBSD läuft. Der Hostname ist <code>pc3.example.org</code> und <span class=filename>ttyv0</span> gibt an, dass dies die "Systemkonsole" ist. Die zweite Zeile zeigt den Anmeldeprompt.</p></div><div class=paragraph><p>Da FreeBSD ein Mehrbenutzersystem ist, muss es die verschiedenen Benutzer voneinander unterscheiden können. Dies wird dadurch erreicht, dass sich jeder Benutzer zuerst am System anmelden muss, um Zugriff auf die Programme zu bekommen. Jeder Benutzer hat einen eindeutigen "Benutzernamen" und ein persönliches "Kennwort".</p></div><div class=paragraph><p>Um sich auf der Systemkonsole anzumelden, geben Sie den Benutzernamen ein, der während der Systeminstallation, wie in <a href=./#bsdinstall-addusers>Benutzer hinzufügen</a> beschrieben, konfiguriert wurde und drücken Sie <kbd>Enter</kbd>. Geben Sie dann das zum Benutzernamen zugeordnete Passwort ein und drücken <kbd>Enter</kbd>. Das Passwort wird aus Sicherheitsgründen <em>nicht angezeigt</em>.</p></div><div class=paragraph><p>Sobald das richtige Passwort eingegeben wird, wird die Nachricht des Tages (MOTD) gefolgt von einer Eingabeaufforderung ausgegeben. In Abhängigkeit der verwendeten Shell des Benutzers wird der Prompt mit dem Zeichen <code>#</code>, <code>$</code> oder <code>%</code> dargestellt. Der Prompt zeigt an, dass der Benutzer jetzt an der FreeBSD Systemkonsole angemeldet ist und nun alle verfügbaren Befehle probieren kann.</p></div><div class=sect3><h4 id=consoles-virtual>5.2.1. Virtuelle Konsolen<a class=anchor href=#consoles-virtual></a></h4><div class=paragraph><p>Obwohl die Systemkonsole dazu verwendet werden kann, um mit dem System zu interagieren, wird sich ein Benutzer in der Regel an einer virtuellen Konsole im FreeBSD-System anmelden. Das liegt daran, dass die Systemmeldungen standardmäßig auf der Systemkonsole angezeigt werden und somit die Meldungen des Befehls oder einer Datei, die der Benutzer gerade bearbeitet, überschrieben werden.</p></div><div class=paragraph><p>In der Voreinstellung ist FreeBSD so konfiguriert, dass viele virtuelle Konsolen zur Eingabe von Befehlen zur Verfügung stehen. Jede virtuelle Konsole verfügt über einen eigenen Anmeldeprompt und eine Shell. Sie können ganz einfach zwischen den virtuellen Konsolen umschalten. Dies ist vergleichbar mit mehreren geöffneten Fenstern in einer graphischen Umgebung.</p></div><div class=paragraph><p>Die Tastenkombinationen <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span> bis <span class=keyseq><kbd>Alt</kbd>+<kbd>F8</kbd></span> sind in FreeBSD zum Umschalten zwischen virtuellen Konsolen reserviert. Verwenden Sie <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span> um auf die Systemkonsole (<span class=filename>ttyv0</span>) zu wechseln, <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span> für die erste virtuelle Konsole (<span class=filename>ttyv1</span>, <span class=keyseq><kbd>Alt</kbd>+<kbd>F3</kbd></span> für die zweite virtuelle Konsole (<span class=filename>ttyv2</span>, und so weiter. Wenn Sie Xorg als graphische Oberfläche benutzen, können Sie mit <kbd>Strg</kbd><kbd>Alt</kbd><kbd>F1</kbd> zur virtuellen Konsole zurückkehren.</p></div><div class=paragraph><p>Beim Wechsel von einer Konsole zur nächsten wird die Bildschirmausgabe von FreeBSD verwaltet. Dies erzeugt die Illusion mehrerer Bildschirme und Tastaturen, an denen Kommandos abgesetzt werden können. Die Programme, die in einer virtuellen Konsole gestartet werden, laufen auch dann weiter, wenn der Benutzer auf eine andere virtuelle Konsole wechselt.</p></div><div class=paragraph><p>Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdcontrol&amp;sektion=1&amp;format=html">kbdcontrol(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=atkbd:&amp;sektion=4&amp;format=html">atkbd:(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> für eine recht technische Beschreibung der FreeBSD-Konsole und der Tastatur-Treiber.</p></div><div class=paragraph><p>In FreeBSD wird die Anzahl der verfügbaren virtuellen Konsolen in diesem Abschnitt von <span class=filename>/etc/ttys</span> konfiguriert:</p></div><div class="literalblock programlisting"><div class=content><pre># name    getty                         type  status comments
#
ttyv0   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
# Virtual terminals
ttyv1   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv2   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv3   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv4   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv5   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv6   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv7   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv8   &#34;/usr/X11R6/bin/xdm -nodaemon&#34;  xterm   off secure</pre></div></div><div class=paragraph><p>Um eine virtuelle Konsole zu deaktivieren, setzen Sie ein Kommentarzeichen (<code><mark></mark></code> an den Anfang der Zeile für die entsprechende Konsole. Um bspw. die Anzahl der verfügbaren virtuellen Konsolen von acht auf vier zu reduzieren, setzen Sie ein <code></code> an den Anfang der letzten vier Zeilen, den virtuellen Konsolen <span class=filename>ttyv5</span> bis <span class=filename>ttyv8</span>. Kommentieren Sie nicht die Zeile für die Systemkonsole <span class=filename>ttyv0</span> aus! Beachten Sie, dass die letzte virtuelle Konsole (<span class=filename>ttyv8</span>) zum Wechsel auf die graphische Oberfläche gedacht ist, wenn Xorg wie im <a href=./#x11>Das X-Window-System</a> installiert und konfiguriert ist.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> enthält eine ausführliche Beschreibung der Spalten dieser Datei und der verfügbaren Optionen für virtuelle Konsolen.</p></div></div><div class=sect3><h4 id=consoles-singleuser>5.2.2. Single-User-Modus<a class=anchor href=#consoles-singleuser></a></h4><div class=paragraph><p>Das FreeBSD Boot-Menü verfügt über eine Option "Boot Single User". Wird diese Option gewählt, bootet das System in einen speziellen Modus, der als "Single-User-Modus" bekannt ist. Dieser Modus wird normalerweise zur Reparatur des Systems verwendet, bspw. wenn das System nicht mehr startet, oder das <code>root</code>-Passwort zurückgesetzt werden muss. Im Single-User-Modus haben Sie keinen Zugriff auf das Netzwerk und es stehen Ihnen keine weiteren virtuellen Konsolen zur Verfügung. Allerdings haben Sie vollen Zugriff auf das System und in der Voreinstellung wird das <code>root</code>-Passwort nicht benötigt. Aus diesem Grund wird ein physischer Zugriff auf die Tastatur benötigt, um in diesem Modus zu booten. Zur Absicherung eines FreeBSD-Systems sollte ermittelt werden, welche Personen physischen Zugriff auf die Tastatur bekommen sollen.</p></div><div class=paragraph><p>Die Einstellungen für den Single-User-Modus befinden sich diesem Abschnitt von <span class=filename>/etc/ttys</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># name  getty                           type  status  comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure</pre></div></div><div class=paragraph><p>In der Voreinstellung ist der Status auf <code>secure</code> eingestellt. Das setzt voraus, dass der physische Zugriff auf die Tastatur entweder unwichtig ist, oder über eine Sicherheitsrichtlinie geregelt wird. Wenn der Status auf <code>insecure</code> eingestellt wird, wird davon ausgegangen, dass die Umgebung selbst unsicher ist, da jeder Zugriff auf die Tastatur hat. FreeBSD wird dann nach dem <code>root</code>-Passwort fragen, wenn ein Benutzer versucht in den Single-User-Modus zu booten.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>Setzen Sie <code>insecure</code> nicht leichtfertig ein</em>! Wenn das <code>root</code>-Passwort vergessen wird, wird es schwierig in den Single-User-Modus zu gelangen, wenn man den Bootprozess von FreeBSD nicht genau versteht.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=consoles-vidcontrol>5.2.3. Den Videomodus der Konsole anpassen<a class=anchor href=#consoles-vidcontrol></a></h4><div class=paragraph><p>Der Standard-Videomodus der FreeBSD-Konsole kann auf jeden Modus eingestellt werden, der von der Grafikkarte und dem Monitor unterstützt wird (beispielsweise 1024x768 oder 1280x1024). Um eine andere Einstellung zu verwenden, muss das <code>VESA</code>-Modul geladen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vesa</span></code></pre></div></div><div class=paragraph><p>Um festzustellen, welche Video-Modi von der Hardware unterstützt werden, nutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a>. Um eine Liste aller unterstützten Modi zu sehen, verwenden Sie diesen Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol -i mode</span></code></pre></div></div><div class=paragraph><p>Die Ausgabe dieses Befehls listet alle Videomodi, die von der Hardware unterstützt werden. Um einen neuen Video-Modi zu wählen, wird der entsprechende Modus als <code>root</code>-Benutzer an <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> übergeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol MODE_279</span></code></pre></div></div><div class=paragraph><p>Um diese Einstellung dauerhaft zu speichern, muss folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>allscreens_flags=&#34;MODE_279&#34;</pre></div></div></div></div><div class=sect2><h3 id=users-synopsis>5.3. Benutzer und grundlegende Account-Verwaltung<a class=anchor href=#users-synopsis></a></h3><div class=paragraph><p>FreeBSD ermöglicht es mehreren Benutzern, den Computer zur selben Zeit zu benutzen. Es kann immer nur ein Benutzer vor der Konsole sitzen, aber es können sich beliebig viele Benutzer über das Netzwerk am System anmelden. Jeder Benutzer muss einen Account haben, um das System benutzen zu können.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</p></div><div class=ulist><ul><li><p>die verschiedenen Account-Typen von FreeBSD kennen,</p></li><li><p>wissen, wie Sie Accounts angelegen, verändern oder löschen,</p></li><li><p>wissen, wie Sie Limits für einen Benutzer oder eine Gruppe setzen, um beispielsweise Ressourcen, wie Speicher oder CPU-Zeit einzuschränken,</p></li><li><p>wissen, wie Sie Gruppen erstellen und Benutzer zu diesen Gruppen hinzufügen.</p></li></ul></div><div class=sect3><h4 id=users-introduction>5.3.1. Account-Typen<a class=anchor href=#users-introduction></a></h4><div class=paragraph><p>Jeder Zugriff auf das FreeBSD-System geschieht über Accounts und alle Prozesse werden von Benutzern gestartet, also sind Benutzer- und Account-Verwaltung von wesentlicher Bedeutung.</p></div><div class=paragraph><p>Es gibt drei Haupttypen von Accounts: Systembenutzer, Benutzer-Accounts und der Superuser-Account.</p></div><div class=sect4><h5 id=users-system>5.3.1.1. Systembenutzer<a class=anchor href=#users-system></a></h5><div class=paragraph><p>Systembenutzer starten Dienste wie DNS, Mail-Server und Web-Server. Der Grund dafür ist die Sicherheit; wenn die Programme von dem Superuser gestartet werden, können Sie ohne Einschränkungen handeln.</p></div><div class=paragraph><p>Beispiele von Systembenutzern sind <code>daemon</code>, <code>operator</code>, <code>bind</code>, <code>news</code> und <code>www</code>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Bei der Verwendung der Gruppe <code>operator</code> ist Vorsicht geboten, da dem Benutzer unbeabsichtigt Privilegien gewährt werden könnten, beispielsweise zum Herunterfahren oder Neustarten des Systems, oder der Zugriff auf alle Geräte in <span class=filename>/dev</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>nobody</code> ist der generische unprivilegierte Systembenutzer. Bedenken Sie aber, dass je mehr Dienste <code>nobody</code> benutzen, desto mehr Dateien und Prozesse diesem Benutzer gehören und dieser Benutzer damit umso privilegierter wird.</p></div></div><div class=sect4><h5 id=users-user>5.3.1.2. Benutzer-Accounts<a class=anchor href=#users-user></a></h5><div class=paragraph><p>Benutzer-Accounts sind realen Personen zugeordnet und sind das primäre Mittel des Zugriffs das System. Jede Person, die Zugriff auf das System bekommt, sollte einen eindeutigen Benutzer-Account besitzen. Dies erlaubt es dem Administrator herauszufinden, wer was macht. Gleichzeitig werden die Benutzer daran gehindert, die Einstellungen anderer Benutzer zu zerstören.</p></div><div class=paragraph><p>Jeder Benutzer kann die eigene Umgebung anpassen, bspw. seine voreingestellte Shell, Editor, Tastenbelegungen und Spracheinstellungen.</p></div><div class=paragraph><p>Mit jedem Account eines FreeBSD-Systems sind bestimmte Informationen verknüpft:</p></div><div class=dlist><dl><dt class=hdlist1>Loginnamen</dt><dd><p>Der Loginname wird am <code>login:</code> Prompt eingegeben. Jeder Benutzer muss einen eindeutigen Benutzernamen haben. Es gibt eine Reihe von Regeln für die Erstellung von gültigen Loginnamen, die in <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=5&amp;format=html">passwd(5)</a> dokumentiert sind. Es wird aus Kompatibilitätsgründen empfohlen, Benutzernamen zu verwenden, die aus Kleinbuchstaben bestehen und bis zu acht Zeichen lang sind.</p></dd><dt class=hdlist1>Passwort</dt><dd><p>Jeder Account ist mit einem Passwort verknüpft.</p></dd><dt class=hdlist1>User ID (UID)</dt><dd><p>Die User ID (UID) ist eine Zahl, die verwendet wird, um die Benutzer auf dem FreeBSD-System eindeutig zu identifizieren. Programme, die einen Loginnamen akzeptieren, wandeln diesen zuerst in eine UID um. Es wird empfohlen, nur UIDs kleiner 65535 zu verwenden, da höhere Werte Kompatibilitätsprobleme mit einigen Anwendungen verursachen können.</p></dd><dt class=hdlist1>Group ID (GID)</dt><dd><p>Die Group ID (GID) ist eine Zahl, die verwendet wird, um die primäre Gruppe eines Benutzers eindeutig zu identifizieren. Gruppen sind ein Mechanismus zur Steuerung des Zugriffs auf Ressourcen über die GID eines Benutzers anstelle der UID. Dies kann die Größe einiger Konfigurationsdateien signifikant reduzieren und ermöglicht es Benutzern, Mitglied mehreren Gruppen zu sein. Es wird empfohlen, GIDs kleiner 65535 zu verwenden, da höhere Werte bei einigen Anwendungen große Probleme verursachen können.</p></dd><dt class=hdlist1>Login-Klasse</dt><dd><p>Login-Klassen erweitern das Gruppenkonzept. Sie erhöhen die Flexibilität des Systems in der Handhabung der verschiedenen Accounts. Login-Klassen werden auch im <a href=./#users-limiting>Login-Klassen konfigurieren</a> diskutiert.</p></dd><dt class=hdlist1>Gültigkeit von Passwörtern</dt><dd><p>In der Voreinstellung verfallen Passwörter nicht. Allerdings können Passwortwechsel nach einer gewissen Zeit auf Basis einzelner Accounts erzwungen werden.</p></dd><dt class=hdlist1>Verfallszeit eines Accounts</dt><dd><p>In der Voreinstellung verfallen unter FreeBSD keine Accounts. Wenn Sie Accounts einrichten, die nur für eine bestimmte Zeit gültig sein sollen, beispielsweise Accounts für Teilnehmer eines Praktikums, können Sie mit <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> die Gültigkeitsdauer des Accounts angeben. Nachdem die angegebene Zeitspanne verstrichen ist, kann dieser Account nicht mehr zum Anmelden verwendet werden, obwohl alle Verzeichnisse und Dateien, die diesem Account gehören, noch vorhanden sind.</p></dd><dt class=hdlist1>vollständiger Benutzername</dt><dd><p>FreeBSD identifiziert einen Account eindeutig über den Loginnamen, der aber keine Ähnlichkeit mit dem richtigen Namen des Benutzers haben muss. Ähnlich wie bei einem Kommentar, kann diese Information Leerzeichen, Großbuchstaben und mehr als 8 Zeichen enthalten.</p></dd><dt class=hdlist1>Heimatverzeichnis</dt><dd><p>Das Heimatverzeichnis gibt den vollständigen Pfad zu dem Verzeichnis an, in dem sich der Benutzer nach erfolgreicher Anmeldung befindet. Es ist üblich, alle Heimatverzeichnisse unter <span class=filename>/home/Loginname</span> oder <span class=filename>/usr/home/Loginname</span> anzulegen. Im Heimatverzeichnis oder in dort angelegten Verzeichnissen werden die Dateien eines Benutzers gespeichert.</p></dd><dt class=hdlist1>Login-Shell</dt><dd><p>Grundsätzlich ist die Shell, von denen es viele unterschiedliche gibt, eine Schnittstelle zum System. Die bevorzugte Shell eines Benutzers kann seinem Account zugeordnet werden.</p></dd></dl></div></div><div class=sect4><h5 id=users-superuser>5.3.1.3. Der Superuser-Account<a class=anchor href=#users-superuser></a></h5><div class=paragraph><p>Der Superuser-Account, normalerweise <code>root</code> genannt, ist vorkonfiguriert und erleichtert die Systemverwaltung, sollte aber nicht für alltägliche Aufgaben wie das Verschicken und Empfangen von Mails, Erforschen des Systems oder Programmierung benutzt werden.</p></div><div class=paragraph><p>Der Superuser kann, im Gegensatz zu normalen Benutzer-Accounts, ohne Beschränkungen operieren und die falsche Anwendung des Superuser-Accounts kann in spektakulären Katastrophen resultieren. Benutzer-Accounts sind nicht in der Lage, das System versehentlich zu zerstören, deswegen wird empfohlen, normale Benutzer-Accounts zu verwenden, solange nicht zusätzliche Privilegien benötigt werden.</p></div><div class=paragraph><p>Kommandos, die Sie als Superuser eingeben, sollten Sie immer doppelt und dreifach überprüfen, da ein zusätzliches Leerzeichen oder ein fehlender Buchstabe irreparablen Datenverlust bedeuten kann.</p></div><div class=paragraph><p>Es gibt mehrere Möglichkeiten Superuser-Rechte zu bekommen. Obwohl man sich direkt als <code>root</code> anmelden kann, wird von dieser Methode dringend abgeraten.</p></div><div class=paragraph><p>Verwenden Sie stattdessen <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> um zum Superuser zu werden. Wenn Sie noch ein <code>-</code> eingeben, wird der Benutzer auch die Umgebung des Root-Benutzers erben. Der Benutzer, der diesen Befehl ausführt muss Mitglied der Gruppe <code>wheel</code> sein, oder der Befehl schlägt fehl. Zudem muss der Benutzer das Kennwort für den Benutzer-Account <code>root</code> kennen.</p></div><div class=paragraph><p>In diesem Beispiel wird der Benutzer nur zum Superuser, um <code>make install</code> auszuführen, da dieser Befehl Superuser-Rechte erfordert. Nachdem der Befehl ausgeführt wurde, kann der Benutzer <code>exit</code> eingeben, um den Superuser-Account zu verlassen und zu den Privilegien des Benutzer-Accounts zurückkehren.</p></div><div class=exampleblock><div class=title>Beispiel 2. Ein Programm als Superuser installieren</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% configure
% make
% su -
Password:
<span class=c># make install</span>
<span class=c># exit</span>
%</code></pre></div></div></div></div><div class=paragraph><p>Das in FreeBSD enthaltene <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> funktioniert gut für einzelne Systeme oder in kleineren Netzwerken, mit nur einem Administrator. Eine Alternative ist es, das Paket oder den Port <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> zu installieren. Diese Software bietet eine Protokollierung von Aktivitäten und ermöglicht es dem Administrator zu bestimmen, welche Benutzer welche Befehle als Superuser ausführen dürfen.</p></div></div></div><div class=sect3><h4 id=users-modifying>5.3.2. Accounts verändern<a class=anchor href=#users-modifying></a></h4><div class=paragraph><p>FreeBSD stellt eine Vielzahl an Programmen bereit, um Accounts zu verändern. Die gebräuchlichsten Kommandos sind in <a href=#users-modifying-utilities>Programme zur Verwaltung von Benutzer-Accounts</a> gefolgt von einer detaillierten Beschreibung, zusammengefasst. Weitere Informationen und Anwendungsbeispiele finden Sie in der Manualpage des jeweiligen Programms.</p></div><table id=users-modifying-utilities class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 2. Programme zur Verwaltung von Benutzer-Accounts</caption><col style=width:10%><col style=width:90%><thead><tr><th class="tableblock halign-left valign-top">Programm</th><th class="tableblock halign-left valign-top">Zusammenfassung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das empfohlene Werkzeug, um neue Accounts zu erstellen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das empfohlene Werkzeug, um Accounts zu löschen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein flexibles Werkzeug, um Informationen in der Account-Datenbank zu verändern.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein Werkzeug, um Passwörter von Accounts zu ändern.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein mächtiges und flexibles Werkzeug um alle Informationen über Accounts zu ändern.</p></td></tr></tbody></table><div class=sect4><h5 id=users-adduser>5.3.2.1. <code>adduser</code><a class=anchor href=#users-adduser></a></h5><div class=paragraph><p>Das empfohlene Programm zum Hinzufügen neuer Benutzer ist <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a>. Wenn ein neuer Benutzer hinzugefügt wird, aktualisiert das Programm automatisch <span class=filename>/etc/passwd</span> und <span class=filename>/etc/group</span>. Es erstellt auch das Heimatverzeichnis für den Benutzer, kopiert die Standardkonfigurationsdateien aus <span class=filename>/usr/shared/skel</span> und kann optional eine ,,Willkommen``-Nachricht an den neuen Benutzer versenden. Das Programm muss als Superuser ausgeführt werden.</p></div><div class=paragraph><p>Das Werkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> arbeitet interaktiv und führt durch die einzelnen Schritte, wenn ein neues Benutzerkonto erstellt wird. Wie in <a href=#users-modifying-adduser>Einen Benutzer unter FreeBSD anlegen</a> zu sehen ist, müssen Sie entweder die benötigte Information eingeben oder <kbd>Return</kbd> drücken, um den Vorgabewert in eckigen Klammern zu akzeptieren. In diesem Beispiel wird der Benutzer in die Gruppe <code>wheel</code> aufgenommen, was es ihm erlaubt mit <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> zum Superuser zu werden. Wenn Sie fertig sind, können Sie entweder einen weiteren Benutzer erstellen oder das Programm beenden.</p></div><div id=users-modifying-adduser class=exampleblock><div class=title>Beispiel 3. Einen Benutzer unter FreeBSD anlegen</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser</span>
Username: jru
Full name: J. Random User
Uid <span class=o>(</span>Leave empty <span class=k>for </span>default<span class=o>)</span>:
Login group <span class=o>[</span>jru]:
Login group is jru. Invite jru into other <span class=nb>groups</span>? <span class=o>[]</span>: wheel
Login class <span class=o>[</span>default]:
Shell <span class=o>(</span>sh csh tcsh zsh nologin<span class=o>)</span> <span class=o>[</span>sh]: zsh
Home directory <span class=o>[</span>/home/jru]:
Home directory permissions <span class=o>(</span>Leave empty <span class=k>for </span>default<span class=o>)</span>:
Use password-based authentication? <span class=o>[</span><span class=nb>yes</span><span class=o>]</span>:
Use an empty password? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span> <span class=o>[</span>no]:
Use a random password? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span> <span class=o>[</span>no]:
Enter password:
Enter password again:
Lock out the account after creation? <span class=o>[</span>no]:
Username   : jru
Password   : <span class=k>****</span>
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>: <span class=nb>yes
</span>adduser: INFO: Successfully added <span class=o>(</span>jru<span class=o>)</span> to the user database.
Add another user? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>: no
Goodbye!
<span class=c>#</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie das Passwort eingeben, werden weder Passwort noch Sternchen angezeigt. Passen Sie auf, dass Sie das Passwort korrekt eingeben.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-rmuser>5.3.2.2. <code>rmuser</code><a class=anchor href=#users-rmuser></a></h5><div class=paragraph><p>Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> als Superuser, um einen Account vollständig aus dem System zu entfernen. Dieses Programm führt die folgenden Schritte durch:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Entfernt den <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> Eintrag des Benutzers, wenn dieser existiert.</p></li><li><p>Entfernt alle <a href="https://man.freebsd.org/cgi/man.cgi?query=at&amp;sektion=1&amp;format=html">at(1)</a> jobs, die dem Benutzer gehören.</p></li><li><p>Schließt alle Prozesse des Benutzers.</p></li><li><p>Entfernt den Benutzer aus der lokalen Passwort-Datei des Systems.</p></li><li><p>Entfernt optional das Heimatverzeichnis des Benutzers, falls es dem Benutzer gehört.</p></li><li><p>Entfernt eingegangene E-Mails des Benutzers aus <span class=filename>/var/mail</span>.</p></li><li><p>Entfernt alle Dateien des Benutzers aus temporären Dateispeicherbereichen wie <span class=filename>/tmp</span>.</p></li><li><p>Entfernt den Loginnamen von allen Gruppen, zu denen er gehört, aus <span class=filename>/etc/group</span>. Wenn eine Gruppe leer wird und der Gruppenname mit dem Loginnamen identisch ist, wird die Gruppe entfernt. Das ergänzt sich mit den einzelnen Benutzer-Gruppen, die von <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> für jeden neuen Benutzer erstellt werden.</p></li></ol></div><div class=paragraph><p>Der Superuser-Account kann nicht mit <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> entfernt werden, da dies in den meisten Fällen das System unbrauchbar macht.</p></div><div class=paragraph><p>Als Vorgabe wird ein interaktiver Modus benutzt.</p></div><div class=exampleblock><div class=title>Beispiel 4. Interaktives Löschen von Accounts mit <code>rmuser</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rmuser jru</span>
Matching password entry:
jru:<span class=k>*</span>:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user<span class=s1>&#39;s home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
#</span></code></pre></div></div></div></div></div><div class=sect4><h5 id=users-chpass>5.3.2.3. <code>chpass</code><a class=anchor href=#users-chpass></a></h5><div class=paragraph><p>Jeder Benutzer kann <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> verwenden, um die Shell und persönliche Informationen des Benutzerkontos zu verändern. Der Superuser kann dieses Werkzeug benutzen, um zusätzliche Kontoinformationen für alle Benutzer zu ändern.</p></div><div class=paragraph><p>Werden neben dem optionalen Loginnamen keine weiteren Optionen angegeben, zeigt <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> einen Editor mit Account-Informationen an. Wenn der Benutzer den Editor verlässt, wird die Account-Datenbank mit den neuen Informationen aktualisiert.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dieses Programm fragt nach dem Verlassen des Editors nach dem Passwort, es sei denn, man ist als Superuser angemeldet.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In <a href=#users-modifying-chpass-su><code>chpass</code> als Superuser verwenden</a> hat der Superuser <code>chpass jru</code> eingegeben. Es werden die Felder ausgegeben, die für diesen Benutzer geändert werden können. Wenn stattdessen <code>jru</code> diesen Befehl aufruft, werden nur die letzten sechs Felder ausgegeben. Dies ist in <a href=#users-modifying-chpass-ru><code>chpass</code> als normaler Benutzer verwenden</a> zu sehen.</p></div><div id=users-modifying-chpass-su class=exampleblock><div class=title>Beispiel 5. <code>chpass</code> als Superuser verwenden</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Login: jru
Password: <span class=k>*</span>
Uid <span class=o>[</span><span class=c>#]: 1001</span>
Gid <span class=o>[</span><span class=c># or name]: 1001</span>
Change <span class=o>[</span>month day year]:
Expire <span class=o>[</span>month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div id=users-modifying-chpass-ru class=exampleblock><div class=title>Beispiel 6. <code>chpass</code> als normaler Benutzer verwenden</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Kommandos <a href="https://man.freebsd.org/cgi/man.cgi?query=chfn&amp;sektion=1&amp;format=html">chfn(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a> sind nur Verweise auf <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a>, genauso wie <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchpass&amp;sektion=1&amp;format=html">ypchpass(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchfn&amp;sektion=1&amp;format=html">ypchfn(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchsh&amp;sektion=1&amp;format=html">ypchsh(1)</a>. Da NIS automatisch unterstützt wird, ist es nicht notwendig das <code>yp</code> vor dem Kommando einzugeben. NIS wird später im <a href=./#network-servers>Netzwerkserver</a> besprochen.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-passwd>5.3.2.4. passwd<a class=anchor href=#users-passwd></a></h5><div class=paragraph><p>Jeder Benutzer kann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> einfach sein Passwort ändern. Um eine versehentliche oder unbefugte Änderung zu verhindern, muss bei einem Passwortwechsel zunächst das ursprüngliche Passwort eingegeben werden, bevor das neue Passwort festgelegt werden kann.</p></div><div class=exampleblock><div class=title>Beispiel 7. Das eigene Passwort wechseln</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class=paragraph><p>Der Superuser kann jedes beliebige Passwort ändern, indem er den Benutzernamen an <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> übergibt. Das Programm fordert den Superuser nicht dazu auf, das aktuelle Passwort des Benutzers einzugeben. Dadurch kann das Passwort geändert werden, falls der Benutzer sein ursprüngliches Passwort vergessen hat.</p></div><div class=exampleblock><div class=title>Beispiel 8. Als Superuser das Passwort eines anderen Accounts verändern</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># passwd jru</span>
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wie bei <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> ist <a href="https://man.freebsd.org/cgi/man.cgi?query=yppasswd&amp;sektion=1&amp;format=html">yppasswd(1)</a> nur ein Verweis auf <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a>. NIS wird von jedem dieser Kommandos unterstützt.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-pw>5.3.2.5. <code>pw</code><a class=anchor href=#users-pw></a></h5><div class=paragraph><p>Mit dem Werkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> können Accounts und Gruppen erstellt, entfernt, verändert und angezeigt werden. Dieses Kommando dient als Schnittstelle zu den Benutzer- und Gruppendateien des Systems. <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> besitzt eine Reihe mächtiger Kommandozeilenschalter, die es für die Benutzung in Shell-Skripten geeignet machen, doch finden neue Benutzer die Bedienung des Kommandos komplizierter, als die der anderen hier vorgestellten Kommandos.</p></div></div></div><div class=sect3><h4 id=users-groups>5.3.3. Gruppen<a class=anchor href=#users-groups></a></h4><div class=paragraph><p>Eine Gruppe ist einfach eine Zusammenfassung von Accounts. Gruppen werden durch den Gruppennamen und die GID identifiziert. Der Kernel von FreeBSD entscheidet anhand der UID und der Gruppenmitgliedschaft eines Prozesses, ob er dem Prozess etwas erlaubt oder nicht. Wenn jemand von der GID eines Benutzers oder Prozesses spricht, meint er damit meistens die erste Gruppe der Gruppenliste.</p></div><div class=paragraph><p>Die Zuordnung von Gruppennamen zur GID steht in <span class=filename>/etc/group</span>, einer Textdatei mit vier durch Doppelpunkte getrennten Feldern. Im ersten Feld steht der Gruppenname, das zweite enthält ein verschlüsseltes Passwort, das dritte gibt die GID an und das vierte besteht aus einer Komma separierten Liste der Mitglieder der Gruppe. Eine ausführliche Beschreibung der Syntax dieser Datei finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a>.</p></div><div class=paragraph><p>Wenn Sie <span class=filename>/etc/group</span> nicht von Hand editieren möchten, können Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> zum Editieren benutzen. Das folgende Beispiel zeigt das Hinzufügen einer Gruppe mit dem Namen <code>teamtwo</code>:</p></div><div class=exampleblock><div class=title>Beispiel 9. Setzen der Mitgliederliste einer Gruppe mit <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd teamtwo</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:</code></pre></div></div></div></div><div class=paragraph><p><code>1100</code> ist die GID der Gruppe <code>teamtwo</code>. Momentan hat <code>teamtwo</code> noch keine Mitglieder. Mit dem folgenden Kommando wird der Benutzer <code>jru</code> in die Gruppe <code>teamtwo</code> aufgenommen.</p></div><div class=exampleblock><div class=title>Beispiel 10. Ein Gruppenmitglied mit <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> hinzufügen</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod teamtwo -M jru</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:jru</code></pre></div></div></div></div><div class=paragraph><p>Als Argument von <code>-M</code> geben Sie eine Komma separierte Liste von Mitgliedern an, die in die Gruppe aufgenommen werden sollen. Aus den vorherigen Abschnitten ist bekannt, dass die Passwort-Datei ebenfalls eine Gruppe für jeden Benutzer enthält. Das System teilt dem Benutzer automatisch eine Gruppe zu, die aber vom <code>groupshow</code> Kommando von <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> nicht angezeigt wird. Diese Information wird allerdings von <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> und ähnlichen Werkzeugen angezeigt. Das heißt, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> nur <span class=filename>/etc/group</span> manipuliert, es wird nicht versuchen, zusätzliche Informationen aus <span class=filename>/etc/passwd</span> zu lesen.</p></div><div class=exampleblock><div class=title>Beispiel 11. Hinzufügen eines neuen Gruppenmitglieds mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod teamtwo -m db</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:jru,db</code></pre></div></div></div></div><div class=paragraph><p>Die Argumente zur Option <code>-m</code> ist eine durch Komma getrennte Liste von Benutzern, die der Gruppe hinzugefügt werden sollen. Anders als im vorherigen Beispiel werden diese Benutzer in die Gruppe aufgenommen und ersetzen nicht die bestehenden Benutzer in der Gruppe.</p></div><div class=exampleblock><div class=title>Beispiel 12. Mit <code>id</code> die Gruppenzugehörigkeit bestimmen</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>id </span>jru
<span class=nv>uid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nb>groups</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span>, 1100<span class=o>(</span>teamtwo<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>In diesem Beispiel ist <code>jru</code> Mitglied von <code>jru</code> und <code>teamtwo</code>.</p></div><div class=paragraph><p>Weitere Informationen zu diesem Befehl und dem Format von <span class=filename>/etc/group</span> finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a>.</p></div></div></div><div class=sect2><h3 id=permissions>5.4. Zugriffsrechte<a class=anchor href=#permissions></a></h3><div class=paragraph><p>In FreeBSD besitzt jede Datei und jedes Verzeichnis einen Satz von Zugriffsrechten. Es stehen mehrere Programme zum Anzeigen und Bearbeiten dieser Rechte zur Verfügung. Ein Verständnis für die Funktionsweise von Zugriffsrechten ist notwendig, um sicherzustellen, dass Benutzer nur auf die von ihnen benötigten Dateien zugreifen können und nicht auf die Dateien des Betriebssystems oder von anderen Benutzern.</p></div><div class=paragraph><p>In diesem Abschnitt werden die traditionellen Zugriffsrechte von UNIX® beschrieben. Informationen zu feingranularen Zugriffsrechten für Dateisysteme finden Sie im <a href=./#fs-acl>Zugriffskontrolllisten für Dateisysteme (ACL)</a>.</p></div><div class=paragraph><p>In UNIX® werden die grundlegenden Zugriffsrechte in drei Typen unterteilt: Lesen, Schreiben und Ausführen. Diese Zugriffstypen werden verwendet, um den Dateizugriff für den Besitzer der Datei, die Gruppe und alle anderen zu bestimmen. Die Lese-, Schreib- und Ausführungsberechtigungen werden mit den Buchstaben <code>r</code>, <code>w</code> und <code>x</code> dargestellt. Alternativ können die Berechtigungen als binäre Zahlen dargestellt werden, da jede Berechtigung entweder aktiviert oder deaktiviert (<code>0</code>) ist. Wenn die Berechtigung als Zahl dargestellt wird, ist die Reihenfolge immer als <code>rwx</code> zu lesen, wobei <code>r</code> den Wert <code>4</code> hat, <code>w</code> den Wert <code>2</code> und <code>x</code> den Wert <code>1</code>.</p></div><div class=paragraph><p>In Tabelle 4.1 sind die einzelnen nummerischen und alphabetischen Möglichkeiten zusammengefasst. Das Zeichen <code>-</code> in der Spalte "Auflistung im Verzeichnis" besagt, dass eine Berechtigung deaktiviert ist.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 3. UNIX® Zugriffsrechte</caption><col style=width:10%><col style=width:50%><col style=width:40%><thead><tr><th class="tableblock halign-left valign-top">Wert</th><th class="tableblock halign-left valign-top">Zugriffsrechte</th><th class="tableblock halign-left valign-top">Auflistung im Verzeichnis</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kein Lesen, Kein Schreiben, Kein Ausführen</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>---</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kein Lesen, Kein Schreiben, Ausführen</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>--x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kein Lesen, Schreiben, Kein Ausführen</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-w-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kein Lesen, Schreiben, Ausführen</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-wx</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lesen, Kein Schreiben, Kein Ausführen</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r--</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lesen, Kein Schreiben, Ausführen</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r-x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lesen, Schreiben, Kein Ausführen</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rw-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lesen, Schreiben, Ausführen</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rwx</code></p></td></tr></tbody></table><div class=paragraph><p>Benutzen Sie das Argument <code>-l</code> mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a>, um eine ausführliche Verzeichnisauflistung zu sehen, die in einer Spalte die Zugriffsrechte für den Besitzer, die Gruppe und alle anderen enthält. Die Ausgabe von <code>ls -l</code> könnte wie folgt aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=nt>-l</span>
total 530
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 myfile
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 otherfile
<span class=nt>-rw-r--r--</span>  1 root  wheel    7680 Sep  5 12:31 email.txt</code></pre></div></div><div class=paragraph><p>Das erste Zeichen (ganz links) der ersten Spalte zeigt an, ob es sich um eine normale Datei, ein Verzeichnis, ein zeichenorientiertes Gerät, ein Socket oder irgendeine andere Pseudo-Datei handelt. In diesem Beispiel zeigt <code>-</code> eine normale Datei an. Die nächsten drei Zeichen, dargestellt als <code>rw-</code>, ergeben die Rechte für den Datei-Besitzer. Die drei Zeichen danach <code>r--</code> die Rechte der Gruppe, zu der die Datei gehört. Die letzten drei Zeichen, <code>r--</code>, geben die Rechte für den Rest der Welt an. Ein Minus bedeutet, dass das Recht nicht gegeben ist. In diesem Beispiel sind die Zugriffsrechte also: der Eigentümer kann die Datei lesen und schreiben, die Gruppe kann lesen und alle anderen können auch nur lesen. Entsprechend obiger Tabelle wären die Zugriffsrechte für diese Datei <code>644</code>, worin jede Ziffer die drei Teile der Zugriffsrechte dieser Datei verkörpert.</p></div><div class=paragraph><p>Wie kontrolliert das System die Rechte von Hardware-Geräten? FreeBSD behandelt die meisten Hardware-Geräte als Dateien, welche Programme öffnen, lesen und mit Daten beschreiben können. Diese speziellen Gerätedateien sind in <span class=filename>/dev</span> gespeichert.</p></div><div class=paragraph><p>Verzeichnisse werden ebenfalls wie Dateien behandelt. Sie haben Lese-, Schreib- und Ausführ-Rechte. Das Ausführungs-Bit hat eine etwas andere Bedeutung für ein Verzeichnis als für eine Datei. Die Ausführbarkeit eines Verzeichnisses bedeutet, dass in das Verzeichnis, zum Beispiel mit <a href="https://man.freebsd.org/cgi/man.cgi?query=cd&amp;sektion=1&amp;format=html">cd(1)</a>, gewechselt werden kann. Das bedeutet auch, dass in dem Verzeichnis auf Dateien, deren Namen bekannt sind, zugegriffen werden kann, vorausgesetzt die Zugriffsrechte der Dateien lassen dies zu.</p></div><div class=paragraph><p>Das Leserecht auf einem Verzeichnis erlaubt es, sich den Inhalt des Verzeichnisses anzeigen zu lassen. Um eine Datei mit bekanntem Namen in einem Verzeichnis zu löschen, müssen auf dem Verzeichnis Schreib- <em>und</em> Ausführ-Rechte gesetzt sein.</p></div><div class=paragraph><p>Es gibt noch mehr Rechte, aber die werden vor allem in speziellen Umständen benutzt, wie zum Beispiel bei SetUID-Binaries und Verzeichnissen mit gesetztem Sticky-Bit. Mehr über Zugriffsrechte von Dateien und wie sie gesetzt werden, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>.</p></div><div class=sect3><h4 id=_symbolische_zugriffsrechte>5.4.1. Symbolische Zugriffsrechte<a class=anchor href=#_symbolische_zugriffsrechte></a></h4><div class=paragraph><p>Symbolische Zugriffsrechte verwenden Zeichen anstelle von oktalen Werten, um die Berechtigungen für Dateien oder Verzeichnisse festzulegen. Zugriffsrechte verwenden die Syntax <em>Wer</em>, <em>Aktion</em> und <em>Berechtigung</em>. Die folgenden Werte stehen zur Auswahl:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Option</th><th class="tableblock halign-left valign-top">Symbol</th><th class="tableblock halign-left valign-top">Bedeutung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Wer</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>u</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Benutzer (user)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Wer</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>g</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gruppe (group)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Wer</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>o</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Andere (other)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Wer</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Aktion</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Berechtigungen hinzufügen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Aktion</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Berechtigungen entziehen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Aktion</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>=</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Berechtigungen explizit setzen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Berechtigung</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>r</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>lesen (read)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Berechtigung</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>w</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>schreiben (write)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Berechtigung</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>x</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ausführen (execute)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Berechtigung</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>t</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sticky-Bit</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Berechtigung</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>s</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Set-UID oder Set-GID</p></td></tr></tbody></table><div class=paragraph><p>Diese symbolischen Werte werden zusammen mit <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> verwendet. Beispielsweise würde der folgende Befehl den Zugriff auf <em>FILE</em> für alle anderen Benutzer verbieten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span><span class=nv>go</span><span class=o>=</span> FILE</code></pre></div></div><div class=paragraph><p>Wenn Sie mehr als eine Änderung der Rechte einer Datei vornehmen wollen, können Sie eine durch Kommata getrennte Liste der Rechte angeben. Das folgende Beispiel entzieht der Gruppe und der Welt die Schreibberechtigung auf <em>FILE</em> und fügt für jeden Ausführungsrechte hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>go-w,a+x FILE</code></pre></div></div></div><div class=sect3><h4 id=_freebsd_datei_flags>5.4.2. FreeBSD Datei-Flags<a class=anchor href=#_freebsd_datei_flags></a></h4><div class=paragraph><p>Zusätzlich zu den Zugriffsrechten unterstützt FreeBSD auch die Nutzung von "Datei-Flags". Diese erhöhen die Sicherheit des Systems, indem sie eine verbesserte Kontrolle von Dateien erlauben. Verzeichnisse werden allerdings nicht unterstützt. Mit dem Einsatz von Datei-Flags kann sogar <code>root</code> daran gehindert werden, Dateien zu löschen oder zu verändern.</p></div><div class=paragraph><p>Datei-Flags werden mit <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> verändert. Um beispielsweise auf der Datei <span class=filename>file1</span> das "unlöschbar"-Flag zu aktivieren, geben Sie folgenden Befehl ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags sunlink file1</span></code></pre></div></div><div class=paragraph><p>Um dieses Flag zu deaktivieren, setzen Sie ein "no" vor <code>sunlink</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags nosunlink file1</span></code></pre></div></div><div class=paragraph><p>Um die Flags einer Datei anzuzeigen, verwenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> zusammen mit <code>-lo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -lo file1</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</pre></div></div><div class=paragraph><p>Einige Datei-Flags können nur vom <code>root</code>-Benutzer gesetzt oder gelöscht werden. Andere wiederum können auch vom Eigentümer der Datei gesetzt werden. Weitere Informationen hierzu finden sich in <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=2&amp;format=html">chflags(2)</a>.</p></div></div><div class=sect3><h4 id=_die_berechtigungen_setuid_setgid_und_sticky>5.4.3. Die Berechtigungen <code>setuid</code>, <code>setgid</code>, und <code>sticky</code><a class=anchor href=#_die_berechtigungen_setuid_setgid_und_sticky></a></h4><div class=paragraph><p>Anders als die Berechtigungen, die bereits angesprochen wurden, existieren drei weitere Einstellungen, über die alle Administratoren Bescheid wissen sollten. Dies sind die Berechtigungen <code>setuid</code>, <code>setgid</code> und <code>sticky</code>.</p></div><div class=paragraph><p>Diese Einstellungen sind wichtig für manche UNIX®-Operationen, da sie Funktionalitäten zur Verfügung stellen, die normalerweise nicht an gewöhnliche Anwender vergeben wird. Um diese zu verstehen, muss der Unterschied zwischen der realen und der effektiven Benutzer-ID erwähnt werden.</p></div><div class=paragraph><p>Die reale Benutzer-ID ist die UID, welche den Prozess besitzt oder gestartet hat. Die effektive UID ist diejenige, als die der Prozess läuft. Beispielsweise wird <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> mit der realen ID des Benutzers ausgeführt, der sein Passwort ändert. Um jedoch die Passwortdatenbank zu bearbeiten, wird es effektiv als <code>root</code>-Benutzer ausgeführt. Das ermöglicht es normalen Benutzern, ihr Passwort zu ändern, ohne einen <code>Permission Denied</code>-Fehler angezeigt zu bekommen.</p></div><div class=paragraph><p>Die setuid-Berechtigung kann durch das Voranstellen bei einer Berechtigungsgruppe mit der Nummer Vier (4) gesetzt werden, wie im folgenden Beispiel gezeigt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 4755 suidexample.sh</span></code></pre></div></div><div class=paragraph><p>Die Berechtigungen auf <span class=filename>suidexample.sh</span> sehen jetzt wie folgt aus:</p></div><div class="literalblock programlisting"><div class=content><pre>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</pre></div></div><div class=paragraph><p>Beachten Sie, dass ein <code>s</code> jetzt Teil der Berechtigungen des Dateibesitzers geworden ist, welches das Ausführen-Bit ersetzt. Dies ermöglicht es Werkzeugen mit erhöhten Berechtigungen zu laufen, wie beispielsweise <code>passwd</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die <code>nosuid</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>-Option bewirkt, dass solche Anwendungen stillschweigend scheitern, ohne den Anwender darüber zu informieren. Diese Option ist nicht völlig zuverlässig, da ein <code>nosuid</code>-Wrapper in der Lage wäre, dies zu umgehen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um dies in Echtzeit zu beobachten, öffnen Sie zwei Terminals. Starten Sie auf einem <code>passwd</code> als normaler Benutzer. Während es auf die Passworteingabe wartet, überprüfen Sie die Prozesstabelle und sehen Sie sich die Informationen für <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> an:</p></div><div class=paragraph><p>Im Terminal A:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Changing <span class=nb>local </span>password <span class=k>for </span>trhodes
Old Password:</code></pre></div></div><div class=paragraph><p>Im Terminal B:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps aux | grep passwd</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 <span class=nb>grep </span>passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</code></pre></div></div><div class=paragraph><p>Obwohl <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> als normaler Benutzer ausgeführt wird, benutzt es die effektive UID von <code>root</code>.</p></div><div class=paragraph><p>Die <code>setgid</code>-Berechtigung führt die gleiche Aktion wie die <code>setuid</code>-Berechtigung durch, allerdings verändert sie die Gruppenberechtigungen. Wenn eine Anwendung oder ein Werkzeug mit dieser Berechtigung ausgeführt wird, erhält es die Berechtigungen basierend auf der Gruppe, welche die Datei besitzt und nicht die des Benutzers, der den Prozess gestartet hat.</p></div><div class=paragraph><p>Um die <code>setgid</code>-Berechtigung auf einer Datei zu setzen, geben Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> eine führende Zwei (2) mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 2755 sgidexample.sh</span></code></pre></div></div><div class=paragraph><p>Beachten Sie in der folgenden Auflistung, dass das <code>s</code> sich jetzt in dem Feld befindet, das für die Berechtigungen der Gruppe bestimmt ist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-rwxr-sr-x</span>   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Obwohl es sich bei dem in diesen Beispielen gezeigten Shellskript um eine ausführbare Datei handelt, wird es nicht mit einer anderen EUID oder effektiven Benutzer-ID ausgeführt. Das ist so, weil Shellskripte keinen Zugriff auf <a href="https://man.freebsd.org/cgi/man.cgi?query=setuid&amp;sektion=2&amp;format=html">setuid(2)</a>-Systemaufrufe erhalten.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die <code>setuid</code> und <code>setgid</code> Berechtigungs-Bits können die Systemsicherheit verringern, da sie erhöhte Rechte ermöglichen. Das dritte Berechtigungs-Bit, das <code>sticky bit</code> kann die Sicherheit eines Systems erhöhen.</p></div><div class=paragraph><p>Wenn das <code>sticky bit</code> auf einem Verzeichnis angewendet wird, erlaubt es das Löschen von Dateien nur durch den Besitzer der Datei. Dies ist nützlich, um die Löschung von Dateien in öffentlichen Verzeichnissen wie <span class=filename>/tmp</span>, durch Benutzer denen diese Dateien nicht gehören, zu verhindern. Um diese Berechtigung anzuwenden, stellen Sie der Berechtigung eine Eins (1) voran:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 1777 /tmp</span></code></pre></div></div><div class=paragraph><p>Das <code>sticky bit</code> kann anhand des <code>t</code> ganz am Ende der Berechtigungen abgelesen werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -al / | grep tmp</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</code></pre></div></div></div></div><div class=sect2><h3 id=dirstructure>5.5. Verzeichnis-Strukturen<a class=anchor href=#dirstructure></a></h3><div class=paragraph><p>Die FreeBSD-Verzeichnishierarchie ist die Grundlage, um ein umfassendes Verständnis des Systems zu erlangen. Das wichtigste Verzeichnis ist das Root-Verzeichnis "/". Dieses Verzeichnis ist das erste, das während des Bootens eingehangen wird. Es enthält das notwendige Basissystem, um das Betriebssystem in den Mehrbenutzerbetrieb zu bringen. Das Root-Verzeichnis enthält auch die Mountpunkte für Dateisysteme, die beim Wechsel in den Multiuser-Modus eingehängt werden.</p></div><div class=paragraph><p>Ein Mountpunkt ist ein Verzeichnis, in das zusätzliche Dateisysteme (in der Regel unterhalb des Wurzelverzeichnisses) eingehängt werden können. Dieser Vorgang wird in <a href=#disk-organization>Festplatten, Slices und Partitionen</a> ausführlich beschrieben. Standard-Mountpunkte sind <span class=filename>/usr</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span>, <span class=filename>/mnt</span> sowie <span class=filename>/cdrom</span>. Auf diese Verzeichnisse verweisen üblicherweise Einträge in <span class=filename>/etc/fstab</span>. Diese Datei ist eine Tabelle mit verschiedenen Dateisystemen und Mountpunkten, vom System gelesen werden. Die meisten der Dateisysteme in <span class=filename>/etc/fstab</span> werden beim Booten automatisch durch das Skript <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> gemountet, wenn die zugehörigen Einträge nicht mit <code>noauto</code> versehen sind. Weitere Informationen zu diesem Thema finden Sie im <a href=#disks-fstab>Die <span class=filename>fstab</span> Datei</a>.</p></div><div class=paragraph><p>Eine vollständige Beschreibung der Dateisystem-Hierarchie finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a>. Die folgende Aufstellung gibt einen kurzen Überblick über die am häufigsten verwendeten Verzeichnisse:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:20%><col style=width:80%><thead><tr><th class="tableblock halign-left valign-top">Verzeichnis</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Wurzelverzeichnis des Dateisystems.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Grundlegende Werkzeuge für den Single-User-Modus sowie den Mehrbenutzerbetrieb.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programme und Konfigurationsdateien, die während des Bootens benutzt werden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vorgaben für die Boot-Konfiguration. Weitere Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gerätedateien. Weitere Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=intro&amp;sektion=4&amp;format=html">intro(4)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Konfigurationsdateien und Skripten des Systems.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vorgaben für die System Konfigurationsdateien. Weitere Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Konfigurationsdateien von MTAs wie <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/periodic/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Täglich, wöchentlich oder monatlich laufende Skripte, die von <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> gestartet werden. Weitere Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Konfigurationsdateien von <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/mnt/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein leeres Verzeichnis, das von Systemadministratoren häufig als temporärer Mountpunkt genutzt wird.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/proc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Prozess Dateisystem. Weitere Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_procfs&amp;sektion=8&amp;format=html">mount_procfs(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/rescue/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Statisch gelinkte Programme zur Wiederherstellung des Systems, wie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rescue&amp;sektion=8&amp;format=html">rescue(8)</a> beschrieben.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/root/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Home Verzeichnis von <code>root</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Systemprogramme und administrative Werkzeuge, die grundlegend für den Single-User-Modus und den Mehrbenutzerbetrieb sind.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Temporäre Dateien, die für gewöhnlich bei einem Neustart des Systems verloren gehen. Häufig wird ein speicherbasiertes Dateisystem unter <span class=filename>/tmp</span> eingehängt. Dieser Vorgang kann automatisiert werden, wenn tmpmfs-bezogene Variablen von <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> verwendet werden, oder ein entsprechender Eintrag in <span class=filename>/etc/fstab</span> existiert. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Der Großteil der Benutzerprogramme und Anwendungen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gebräuchliche Werkzeuge, Programmierhilfen und Anwendungen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/include/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Standard C include-Dateien.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/lib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bibliotheken.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libdata/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Daten verschiedener Werkzeuge.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libexec/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>System-Dämonen und System-Werkzeuge, die von anderen Programmen ausgeführt werden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lokale Programme und Bibliotheken. Die Ports-Sammlung von FreeBSD benutzt dieses Verzeichnis als Zielverzeichnis für Anwendungen. Innerhalb von <span class=filename>/usr/local</span> sollte das von <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a> beschriebene Layout für <span class=filename>/usr</span> benutzt werden. Das <span class=filename>man</span> Verzeichnis wird direkt unter <span class=filename>/usr/local</span> anstelle unter <span class=filename>/usr/local/share</span> angelegt. Die Dokumentation der Ports findet sich in <span class=filename>share/doc/port</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/obj/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Von der Architektur abhängiger Verzeichnisbaum, der durch das Bauen von <span class=filename>/usr/src</span> entsteht.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die FreeBSD-Ports-Sammlung (optional).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>System-Dämonen und System-Werkzeuge, die von Benutzern ausgeführt werden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/shared/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Von der Architektur unabhängige Dateien.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quelldateien von BSD und/oder lokalen Ergänzungen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Wird für mehrere Zwecke genutzt und enthält Logdateien, temporäre Daten und Spooldateien. Manchmal wird ein speicherbasiertes Dateisystem unter <span class=filename>/var</span> eingehängt. Dieser Vorgang kann automatisiert werden, wenn die varmfs-bezogenen Variablen von <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> verwendet werden, oder ein entsprechender Eintrag in <span class=filename>/etc/fstab</span> existiert. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/log/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Verschiedene Logdateien des Systems.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Postfächer der Benutzer.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/spool/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Verschiedene Spool-Verzeichnisse der Drucker- und Mailsysteme.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Temporäre Dateien, die in der Regel auch bei einem Neustart des Systems erhalten bleiben, es sei denn, bei <span class=filename>/var</span> handelt es sich um ein speicherbasiertes Dateisystem.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/yp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS maps.</p></td></tr></tbody></table></div><div class=sect2><h3 id=disk-organization>5.6. Festplatten, Slices und Partitionen<a class=anchor href=#disk-organization></a></h3><div class=paragraph><p>FreeBSD identifiziert Dateien anhand eines Dateinamens. In Dateinamen wird zwischen Groß- und Kleinschreibung unterschieden: <span class=filename>readme.txt</span> und <span class=filename>README.TXT</span> bezeichnen daher zwei verschiedene Dateien. FreeBSD benutzt keine Dateiendungen, um den Typ der Datei zu bestimmen, egal ob es sich um ein Programm, ein Dokument oder um andere Daten handelt.</p></div><div class=paragraph><p>Dateien werden in Verzeichnissen gespeichert. In einem Verzeichnis können sich keine oder hunderte Dateien befinden. Ein Verzeichnis kann auch andere Verzeichnisse enthalten und so eine Hierarchie von Verzeichnissen aufbauen, die die Ablage von Daten erleichtert.</p></div><div class=paragraph><p>In Dateinamen werden Verzeichnisse durch einen Schrägstrich (<code>/</code>, Slash) getrennt. Wenn z.B. das Verzeichnis <span class=filename>foo</span> ein Verzeichnis <span class=filename>bar</span> enthält, in dem sich die Datei <span class=filename>readme.txt</span> befindet, lautet der vollständige Name der Datei (oder der <em>Pfad</em> zur Datei) <span class=filename>foo/bar/readme.txt</span>. Beachten Sie, dass sich dies von Windows® unterscheidet, wo der <code>\</code> (Backslash für die Trennung von Datei- und Verzeichnisnamen verwendet wird. FreeBSD benutzt keine Laufwerkbuchstaben oder Laufwerknamen im Pfad. Beispielsweise würde man unter FreeBSD nicht <span class=filename>c:\foo\bar\readme.txt</span> eingeben.</p></div><div class=paragraph><p>Verzeichnisse und Dateien werden in einem Dateisystem gespeichert. Jedes Dateisystem besitzt genau ein <em>Wurzelverzeichnis</em>, das so genannte Root-Directory. Dieses Wurzelverzeichnis kann weitere Verzeichnisse enthalten. Ein Dateisystem wird als Wurzeldateisystem festgelegt, und jedes weitere Dateisystem wird unter dem Wurzeldateisystem <em>eingehangen</em>. Daher scheint jedes Verzeichnis, unabhängig von der Anzahl der Platten, auf derselben Platte zu liegen.</p></div><div class=paragraph><p>Betrachten wir die drei Dateisysteme <code>A</code>, <code>B</code> und <code>C</code>. Jedes Dateisystem besitzt ein eigenes Wurzelverzeichnis, das zwei andere Verzeichnisse enthält: <span class=filename>A1</span>, <span class=filename>A2</span>, <span class=filename>B1</span>, <span class=filename>B2</span>, <span class=filename>C1</span> und <span class=filename>C2</span>.</p></div><div class=paragraph><p>Das Wurzeldateisystem soll <code>A</code> sein. <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> zeigt darin die beiden Verzeichnisse <span class=filename>A1</span> und <span class=filename>A2</span> an. Der Verzeichnisbaum sieht wie folgt aus:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir1.png alt="example dir1"></div></div><div class=paragraph><p>Ein Dateisystem wird in einem Verzeichnis eines anderen Dateisystems eingehangen. Wir hängen nun das Dateisystem <code>B</code> in das Verzeichnis <span class=filename>A1</span> ein. Das Wurzelverzeichnis von <code>B</code> ersetzt nun das Verzeichnis <span class=filename>A1</span> und die Verzeichnisse des Dateisystems <code>B</code> werden sichtbar:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir2.png alt="example dir2"></div></div><div class=paragraph><p>Jede Datei in den Verzeichnissen <span class=filename>B1</span> oder <span class=filename>B2</span> kann über den Pfad <span class=filename>/A1/B1</span> oder <span class=filename>/A1/B2</span> erreicht werden. Dateien aus dem Verzeichnis <span class=filename>/A1</span> sind jetzt verborgen. Wenn das Dateisystem <code>B</code> wieder <em>abgehangen</em> wird (umount), erscheinen die verborgenen Dateien wieder.</p></div><div class=paragraph><p>Wenn das Dateisystem <code>B</code> unter dem Verzeichnis <span class=filename>A2</span> eingehangen würde, sähe der Verzeichnisbaum so aus:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir3.png alt="example dir3"></div></div><div class=paragraph><p>Die Dateien des Dateisystems <code>B</code> wären unter den Pfaden <span class=filename>/A2/B1</span> und <span class=filename>/A2/B2</span> erreichbar.</p></div><div class=paragraph><p>Dateisysteme können übereinander eingehangen werden. Der folgende Baum entsteht, wenn im letzten Beispiel das Dateisystem <code>C</code> in das Verzeichnis <span class=filename>B1</span> des Dateisystems <code>B</code> eingehangen wird:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir4.png alt="example dir4"></div></div><div class=paragraph><p><code>C</code> könnte auch im Verzeichnis <span class=filename>A1</span> eingehangen werden:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir5.png alt="example dir5"></div></div><div class=paragraph><p>Sie können sogar mit nur einem großen Dateisystem auskommen. Dies hat mehrere Nachteile und einen Vorteil.</p></div><div class=ulist><div class=title>Vorteile mehrerer Dateisysteme</div><ul><li><p>Die Dateisysteme können mit unterschiedlichen Optionen (mount options) eingehangen werden. Beispielsweise kann das Wurzeldateisystem schreibgeschützt eingehangen werden, sodass es für Benutzer nicht möglich ist, versehentlich kritische Dateien zu editieren oder zu löschen. Von Benutzern beschreibbare Dateisysteme wie <span class=filename>/home</span> können mit der Option <em>nosuid</em> eingehangen werden, wenn sie von anderen Dateisystemen getrennt sind. Die <em>SUID</em>- und <em>GUID</em>-Bits verlieren auf solchen Dateisystemen ihre Wirkung und die Sicherheit des Systems kann dadurch erhöht werden.</p></li><li><p>Die Lage von Dateien im Dateisystem wird, abhängig vom Gebrauch des Dateisystems, automatisch von FreeBSD optimiert. Ein Dateisystem mit vielen kleinen Dateien, die häufig geschrieben werden, wird anders behandelt als ein Dateisystem mit wenigen großen Dateien. Mit nur einem Dateisystem ist diese Optimierung unmöglich.</p></li><li><p>In der Regel übersteht ein FreeBSD-Dateisystem auch einen Stromausfall. Allerdings kann ein Stromausfall zu einem kritischen Zeitpunkt das Dateisystem beschädigen. Wenn die Daten über mehrere Dateisysteme verteilt sind, lässt sich das System mit hoher Wahrscheinlichkeit noch starten. Dies erleichtert das Zurückspielen von Datensicherungen.</p></li></ul></div><div class=ulist><div class=title>Vorteil eines einzelnen Dateisystems</div><ul><li><p>Dateisysteme haben eine festgelegte Größe. Es kann passieren, dass Sie eine Partition vergrößern müssen. Dies ist nicht leicht: Sie müssen die Daten sichern, das Dateisystem vergrößert anlegen und die gesicherten Daten zurückspielen.</p><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>FreeBSD kennt den Befehl <a href="https://man.freebsd.org/cgi/man.cgi?query=growfs&amp;sektion=8&amp;format=html">growfs(8)</a>, mit dem man Dateisysteme im laufenden Betrieb vergrößern kann.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Dateisysteme befinden sich in Partitionen (damit sind nicht die normalen MS-DOS®-Partitionen gemeint). Jede Partition wird mit einem Buchstaben von <code>a</code> bis <code>h</code> bezeichnet und kann nur ein Dateisystem enthalten. Dateisysteme können daher über ihren Mount-Point, den Punkt an dem sie eingehangen sind, oder den Buchstaben der Partition, in der sie liegen, identifiziert werden.</p></div><div class=paragraph><p>FreeBSD benutzt einen Teil der Platte für den <em>Swap-Bereich</em>, um <em>virtuellen Speicher</em> zur Verfügung zu stellen. Dadurch kann der Rechner Anwendungen mehr Speicher zur Verfügung stellen als tatsächlich eingebaut ist. Wenn der Speicher knapp wird, kann FreeBSD nicht benutzte Daten in den Swap-Bereich auslagern. Die ausgelagerten Daten können später wieder in den Speicher geholt werden (dafür werden dann andere Daten ausgelagert).</p></div><div class=paragraph><p>Für einige Partitionen gelten besondere Konventionen:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:30%><col style=width:70%><thead><tr><th class="tableblock halign-left valign-top">Partition</th><th class="tableblock halign-left valign-top">Konvention</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enthält normalerweise das Wurzeldateisystem.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>b</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enthält normalerweise den Swap-Bereich.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>c</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ist normalerweise genauso groß wie die Slice in der die Partition liegt. Werkzeuge, die auf der kompletten Slice arbeiten, wie ein Bad-Block-Scanner, können so die <code>c</code>-Partition benutzen. Für gewöhnlich wird in dieser Partition kein Dateisystem angelegt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Früher hatte die <code>d</code>-Partition eine besondere Bedeutung. Heute ist dies nicht mehr der Fall und die Partition <code>d</code> kann wie jede andere Partition auch verwendet werden.</p></td></tr></tbody></table><div class=paragraph><p>In FreeBSD werden Festplatten in Slices, welche in Windows® als Partitionen bekannt sind, aufgeteilt und von 1 bis 4 durchnummeriert. Diese werden dann in Partitionen unterteilt, welche wiederum Dateisysteme enthalten und mit Buchstaben benannt werden.</p></div><div class=paragraph><p>Die Slice-Nummern werden mit vorgestelltem <code>s</code> hinter den Gerätenamen gestellt: "da0<em>s1</em>" ist die erste Slice auf dem ersten SCSI-Laufwerk. Auf einer Festplatte gibt es höchstens vier Slices. In einer Slice des passenden Typs kann es weitere logische Slices geben. Diese erweiterten Slices werden ab fünf durchnummeriert: "ada0<em>s5</em>" ist die erste erweiterte Slice auf einer SATA-Platte. Diese Geräte werden von Dateisystemen benutzt, die sich in einer kompletten Slice befinden müssen.</p></div><div class=paragraph><p>Slices, "dangerously dedicated"-Festplatten und andere Platten enthalten Partitionen, die mit Buchstaben von <code>a</code> bis <code>h</code> bezeichnet werden. Der Buchstabe wird an den Gerätenamen gehangen: "da0<em>a</em>" ist die <code>a</code>-Partition des ersten <code>da</code>-Laufwerks. Dieses Laufwerk ist "dangerously dedicated". "ada1s3<em>e</em>" ist die fünfte Partition in der dritten Slice der zweiten SATA-Platte.</p></div><div class=paragraph><p>Schließlich wird noch jede Festplatte des Systems eindeutig bezeichnet. Der Name einer Festplatte beginnt mit einem Code, der den Typ der Platte bezeichnet. Es folgt eine Nummer, die angibt, um welche Festplatte es sich handelt. Anders als bei Slices werden Festplatten von Null beginnend durchnummeriert. Gängige Festplatten-Namen sind in <a href=#disks-naming>Laufwerk-Codes</a> aufgeführt.</p></div><div class=paragraph><p>Wenn Sie eine Partition angeben, beinhaltet das den Plattennamen, <code>s</code>, die Slice-Nummer und den Buchstaben der Partition. Einige Beispiele finden Sie in <a href=#basics-disk-slice-part>Namen von Platten, Slices und Partitionen</a>.</p></div><div class=paragraph><p>Der Aufbau einer Festplatte wird in <a href=#basics-concept-disk-model>Aufteilung einer Festplatte</a> dargestellt.</p></div><div class=paragraph><p>Bei der Installation von FreeBSD legen Sie Slices auf der Festplatte an, erstellen Partitionen für FreeBSD innerhalb der Slice, erstellen ein Dateisystem oder Auslagerungsbereiche und entscheiden, welche Dateisysteme wo eingehangen werden.</p></div><table id=disks-naming class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 4. Laufwerk-Codes</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Laufwerkstyp</th><th class="tableblock halign-left valign-top">Gerätename</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SATA- und IDE-Festplatten</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ada</code> oder <code>ad</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI-Festplatten und USB-Speichermedien</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>da</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SATA- und IDE-CD-ROM-Laufwerke</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code> oder <code>acd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI-CD-ROM-Laufwerke</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Diskettenlaufwerke</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Verschiedene proprietäre CD-ROM-Laufwerke</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>mcd</code> für Mitsumi CD-ROM und <code>scd</code> für Sony CD-ROM</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI-Bandlaufwerke</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>sa</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>IDE-Bandlaufwerke</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ast</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RAID-Laufwerke</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Beispiele sind <code>aacd</code> für Adaptec® AdvancedRAID, <code>mlxd</code> für Mylex®, <code>amrd</code> für AMI MegaRAID®, <code>idad</code> für Compaq Smart RAID, <code>twed</code> für 3ware® RAID.</p></td></tr></tbody></table><div id=basics-disk-slice-part class=exampleblock><div class=title>Beispiel 13. Namen von Platten, Slices und Partitionen</div><div class=content><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Name</th><th class="tableblock halign-left valign-top">Bedeutung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>ada0s1a</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die erste Partition (<code>a</code>) in der ersten Slice (<code>s1</code>) der ersten SATA-Festplatte (<code>ada0</code>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>da1s2e</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die fünfte Partition (<code>e</code>) der zweiten Slice (<code>s2</code>) auf der zweiten SCSI-Festplatte (<code>da1</code>).</p></td></tr></tbody></table></div></div><div id=basics-concept-disk-model class=exampleblock><div class=title>Beispiel 14. Aufteilung einer Festplatte</div><div class=content><div class=paragraph><p>Das folgende Diagramm zeigt die Sicht von FreeBSD auf die erste SATA-Festplatte des Systems. Die Platte soll 250 GB groß sein und eine 80 GB große Slice (MS-DOS®-Partitionen) sowie eine 170 GB große Slice enthalten. Die erste Slice enthält ein Windows® NTFS-Dateisystem (<span class=filename>C:</span>), die zweite Slice enthält eine FreeBSD-Installation. Die FreeBSD-Installation in diesem Beispiel verwendet vier Datenpartitionen und einen Auslagerungsbereich.</p></div><div class=paragraph><p>Jede der vier Partitionen enthält ein Dateisystem. Das Wurzeldateisystem ist die <code>a</code>-Partition. In der <code>d</code>-Partition befindet sich <span class=filename>/var</span> und in der <code>f</code>-Partition befindet sich <span class=filename>/usr</span>. Die <code>c</code>-Partition bezieht sich auf die gesamte Slice und wird nicht für gewöhnliche Partitionen verwendet.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/disk-layout.png alt="disk layout"></div></div></div></div></div><div class=sect2><h3 id=mount-unmount>5.7. Anhängen und Abhängen von Dateisystemen<a class=anchor href=#mount-unmount></a></h3><div class=paragraph><p>Ein Dateisystem wird am besten als ein Baum mit der Wurzel <span class=filename>/</span> veranschaulicht. <span class=filename>/dev</span>, <span class=filename>/usr</span>, und die anderen Verzeichnisse im Rootverzeichnis sind Zweige, die wiederum eigene Zweige wie <span class=filename>/usr/local</span> haben können.</p></div><div class=paragraph><p>Es gibt verschiedene Gründe, bestimmte dieser Verzeichnisse auf eigenen Dateisystemen anzulegen. <span class=filename>/var</span> enthält <span class=filename>log/</span>, <span class=filename>spool/</span> sowie verschiedene andere temporäre Dateien und kann sich daher schnell füllen. Es empfiehlt sich, <span class=filename>/var</span> von <span class=filename>/</span> zu trennen, da es schlecht ist, wenn das Root-Dateisystem voll läuft.</p></div><div class=paragraph><p>Ein weiterer Grund bestimmte Verzeichnisbäume auf andere Dateisysteme zu legen, ist gegeben, wenn sich die Verzeichnisbäume auf gesonderten physikalischen oder virtuellen Platten, wie <a href=./#network-nfs>Network File System</a> oder CD-ROM-Laufwerken, befinden.</p></div><div class=sect3><h4 id=disks-fstab>5.7.1. Die <span class=filename>fstab</span> Datei<a class=anchor href=#disks-fstab></a></h4><div class=paragraph><p>Während des Boot-Prozesses (<a href=./#boot>FreeBSDs Bootvorgang</a>) werden in <span class=filename>/etc/fstab</span> aufgeführte Verzeichnisse, sofern sie nicht mit der Option <code>noauto</code> versehen sind, automatisch angehangen. Diese Datei enthält Einträge in folgendem Format:</p></div><div class="literalblock programlisting"><div class=content><pre>device	/mount-point	fstype	options	dumpfreq	passno</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>device</code></dt><dd><p>Ein existierender Gerätename wie in <a href=#disks-naming>Laufwerk-Codes</a> beschrieben.</p></dd><dt class=hdlist1><code>mount-point</code></dt><dd><p>Ein existierendes Verzeichnis, auf dem das Dateisystem gemountet wird.</p></dd><dt class=hdlist1><code>fstype</code></dt><dd><p>Der Typ des Dateisystems, der an <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> weitergegeben wird. FreeBSDs Standarddateisystem ist <code>ufs</code>.</p></dd><dt class=hdlist1><code>options</code></dt><dd><p>Entweder <code>rw</code> für beschreibbare Dateisysteme oder <code>ro</code> für schreibgeschützte Dateisysteme, gefolgt von weiteren benötigten Optionen. Eine häufig verwendete Option ist <code>noauto</code> für Dateisysteme, die während der normalen Bootsequenz nicht angehangen werden sollen. Weitere Optionen finden sich in <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>.</p></dd><dt class=hdlist1><code>dumpfreq</code></dt><dd><p>Wird von <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> benutzt, um bestimmen zu können, welche Dateisysteme gesichert werden müssen. Fehlt der Wert, wird <code>0</code> angenommen.</p></dd><dt class=hdlist1><code>passno</code></dt><dd><p>Bestimmt die Reihenfolge, in der die Dateisysteme überprüft werden sollen. Für Dateisysteme, die übersprungen werden sollen, ist <code>passno</code> auf <code>0</code> zu setzen. Für das Root-Dateisystem, das vor allen anderen überprüft werden muss, sollte der Wert von <code>passno``1</code> betragen. Allen anderen Dateisystemen sollten Werte größer <code>1</code> zugewiesen werden. Wenn mehrere Dateisysteme den gleichen Wert besitzen, wird <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> versuchen, diese parallel zu überprüfen.</p></dd></dl></div><div class=paragraph><p>Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> für weitere Informationen über das Format von <span class=filename>/etc/fstab</span> und dessen Optionen.</p></div></div><div class=sect3><h4 id=disks-mount>5.7.2. Verwendung von <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a><a class=anchor href=#disks-mount></a></h4><div class=paragraph><p>Dateisysteme werden mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> eingehängt. In der grundlegenden Form wird es wie folgt benutzt:</p></div><div class=exampleblock><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount device mountpoint</span></code></pre></div></div></div></div><div class=paragraph><p>Dieser Befehl bietet viele Optionen, die in <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> beschrieben werden. Die am häufigsten verwendeten Optionen sind:</p></div><div class=dlist><div class=title>Optionen von <code>mount</code></div><dl><dt class=hdlist1><code>-a</code></dt><dd><p>Hängt alle Dateisysteme aus <span class=filename>/etc/fstab</span> an. Davon ausgenommen sind Dateisysteme, die mit "noauto" markiert sind, die mit der Option <code>-t</code> ausgeschlossen wurden und Dateisysteme, die schon angehangen sind.</p></dd><dt class=hdlist1><code>-d</code></dt><dd><p>Führt alles bis auf den <code>mount</code>-Systemaufruf aus. Nützlich ist diese Option in Verbindung mit <code>-v</code>. Damit wird angezeigt, was <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> tatsächlich versuchen würde, um das Dateisystem anzuhängen.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Erzwingt das Anhängen eines unsauberen Dateisystems (riskant) oder die Rücknahme des Schreibzugriffs, wenn der Status des Dateisystems von beschreibbar auf schreibgeschützt geändert wird.</p></dd><dt class=hdlist1><code>-r</code></dt><dd><p>Hängt das Dateisystem schreibgeschützt ein. Dies kann auch durch Angabe von <code>-o ro</code> erreicht werden.</p></dd><dt class=hdlist1>`-t`<em>fstype</em></dt><dd><p>Hängt das Dateisystem mit dem angegebenen Typ an, oder hängt nur Dateisysteme mit dem angegebenen Typ an, wenn <code>-a</code> angegeben wurde. "ufs" ist das Standarddateisystem.</p></dd><dt class=hdlist1><code>-u</code></dt><dd><p>Aktualisiert die Mountoptionen des Dateisystems.</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>Geschwätzig sein.</p></dd><dt class=hdlist1><code>-w</code></dt><dd><p>Hängt das Dateisystem beschreibbar an.</p></dd></dl></div><div class=paragraph><p>Die folgenden Optionen können durch eine Kommata separierte Liste an <code>-o</code> übergeben werden:</p></div><div class=dlist><dl><dt class=hdlist1>nosuid</dt><dd><p>SetUID und SetGID Bits werden auf dem Dateisystem nicht beachtet. Dies ist eine nützliche Sicherheitsfunktion.</p></dd></dl></div></div><div class=sect3><h4 id=disks-umount>5.7.3. Verwendung von <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a><a class=anchor href=#disks-umount></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> hängt ein Dateisystem ab. Dieser Befehl akzeptiert als Parameter entweder einen Mountpoint, einen Gerätenamen, <code>-a</code> oder <code>-A</code>.</p></div><div class=paragraph><p>Jede Form akzeptiert <code>-f</code>, um das Abhängen zu erzwingen, und <code>-v</code>, um etwas geschwätziger zu sein. Seien Sie bitte vorsichtig mit <code>-f</code>, da der Computer abstürzen kann oder es können Daten auf dem Dateisystem beschädigt werden.</p></div><div class=paragraph><p>Um alle Dateisysteme abzuhängen, oder nur diejenigen, die mit <code>-t</code> gelistet werden, wird <code>-a</code> oder <code>-A</code> benutzt. Beachten Sie, dass <code>-a</code> das Root-Dateisystem nicht aushängt.</p></div></div></div><div class=sect2><h3 id=basics-processes>5.8. Prozesse und Dämonen<a class=anchor href=#basics-processes></a></h3><div class=paragraph><p>FreeBSD ist ein Multitasking-Betriebssystem. Jedes Programm, das zu irgendeiner Zeit läuft wird als <em>Prozess</em> bezeichnet. Jedes laufende Kommando startet mindestens einen neuen Prozess. Dazu gibt es eine Reihe von Systemprozessen, die von FreeBSD ausgeführt werden.</p></div><div class=paragraph><p>Jeder Prozess wird durch eine eindeutige Nummer identifiziert, die <em>Prozess-ID</em> (<em>PID</em>) genannt wird. Prozesse haben ebenso wie Dateien einen Besitzer und eine Gruppe, die festlegen, welche Dateien und Geräte der Prozess benutzen kann. Die meisten Prozesse haben auch einen Elternprozess, der sie gestartet hat. Beispielsweise ist die Shell ein Prozess. Jedes in Shell gestartete Kommando ist dann ein neuer Prozess, der die Shell als Elternprozess besitzt. Die Ausnahme hiervon ist ein spezieller Prozess namens <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, der beim booten immer als erstes gestartet wird und der immer die PID`1` hat.</p></div><div class=paragraph><p>Manche Programme erwarten keine Eingaben vom Benutzer und lösen sich bei erster Gelegenheit von ihrem Terminal. Ein Webserver zum Beispiel antwortet auf Web-Anfragen und nicht auf Benutzereingaben. Mail-Server sind ein weiteres Beispiel für diesen Typ von Anwendungen. Diese Programme sind als <em>Dämonen</em> bekannt. Der Begriff Dämon stammt aus der griechischen Mythologie und bezeichnet ein Wesen, das weder gut noch böse ist und welches unsichtbar nützliche Aufgaben verrichtet. Deshalb ist das BSD Maskottchen dieser fröhlich aussehende Dämon mit Turnschuhen und Dreizack.</p></div><div class=paragraph><p>Programme, die als Dämon laufen, werden entsprechend einer Konvention mit einem "d" am Ende benannt. BIND steht beispielsweise für Berkeley Internet Name Domain, das tatsächlich laufende Programm heißt aber <code>named</code>. Der Apache Webserver wird <code>httpd</code> genannt und der Druckerspool-Dämon heißt <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>. Dies ist allerdings nur eine Konvention. Der Dämon der Anwendung Sendmail heißt beispielsweise <code>sendmail</code> und nicht <code>maild</code>.</p></div><div class=sect3><h4 id=_prozesse_beobachten>5.8.1. Prozesse beobachten<a class=anchor href=#_prozesse_beobachten></a></h4><div class=paragraph><p>Um die Prozesse auf dem System zu sehen, benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>. Eine statische Liste der laufenden Prozesse, deren PIDs, Speicherverbrauch und die Kommandozeile, mit der sie gestartet wurden, erhalten Sie mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>. Um alle laufenden Prozesse in einer Anzeige zu sehen, die alle paar Sekunden aktualisiert wird, so dass Sie interaktiv sehen können was der Computer macht, benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>.</p></div><div class=paragraph><p>In der Voreinstellung zeigt <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> nur die laufenden Prozesse, die dem Benutzer gehören. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps</code></pre></div></div><div class=paragraph><p>Die Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> ist in einer Anzahl von Spalten organisiert. Die <code>PID</code> Spalte zeigt die Prozess-ID. PIDs werden von 1 beginnend bis 99999 zugewiesen und fangen wieder von vorne an. Ist eine PID bereits vergeben, wird diese allerdings nicht erneut vergeben. Die Spalte <code>TT</code> zeigt den Terminal, auf dem das Programm läuft. <code>STAT</code> zeigt den Status des Programms und <code>TIME</code> gibt die Zeit an, die das Programm auf der CPU gelaufen ist. Dies ist nicht unbedingt die Zeit, die seit dem Start des Programms vergangen ist, da die meisten Programme hauptsächlich auf bestimmte Dinge warten, bevor sie wirklich CPU-Zeit verbrauchen. Unter der Spalte <code>COMMAND</code> findet sich schließlich die Kommandozeile, mit der das Programm gestartet wurde.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> besitzt viele Optionen, um die angezeigten Informationen zu beeinflussen. Eine nützliche Kombination ist <code>auxww</code>. <code>a</code> zeigt Information über alle laufenden Prozesse aller Benutzer. Der Name des Besitzers des Prozesses, sowie Informationen über den Speicherverbrauch werden mit <code>u</code> angezeigt. <code>x</code> zeigt auch Dämonen-Prozesse an, und <code>ww</code> veranlasst <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> die komplette Kommandozeile für jeden Befehl anzuzeigen, anstatt sie abzuschneiden, wenn sie zu lang für die Bildschirmausgabe wird.</p></div><div class=paragraph><p>Die Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> sieht in etwa so aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top
last pid:  9609<span class=p>;</span>  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% <span class=nb>nice</span>,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 <span class=nt>-21</span>  r31   136M 42296K <span class=k>select  </span>0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K <span class=k>select  </span>3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K <span class=k>select  </span>0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M <span class=k>select  </span>0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M <span class=k>select  </span>2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K <span class=k>select  </span>3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K <span class=k>select  </span>1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K <span class=k>select  </span>1   0:05  0.00% kdeinit4</code></pre></div></div><div class=paragraph><p>Die Ausgabe ist in zwei Abschnitte geteilt. In den ersten fünf Kopfzeilen finden sich die zuletzt zugeteilte PID, die Systemauslastung (engl. load average), die Systemlaufzeit (die Zeit seit dem letzten Reboot) und die momentane Zeit. Die weiteren Zahlen im Kopf beschreiben wie viele Prozesse momentan laufen, wie viel Speicher und Swap verbraucht wurde und wie viel Zeit das System in den verschiedenen CPU-Modi verbringt. Wenn das ZFS-Kernelmodul geladen ist, dann zeigt die Zeile <code>ARC</code>, wie viele Daten aus dem Cache gelesen wurden.</p></div><div class=paragraph><p>Darunter befinden sich einige Spalten mit ähnlichen Informationen wie in der Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>, beispielsweise die PID, den Besitzer, die verbrauchte CPU-Zeit und das Kommando, das den Prozess gestartet hat. <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> zeigt in zwei Spalten den Speicherverbrauch des Prozesses an. Die erste Spalte gibt den gesamten Speicherverbrauch des Prozesses an, in der zweiten Spalte wird der aktuelle Verbrauch angegeben.</p></div><div class=paragraph><p>Die Anzeige wird von <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> automatisch alle zwei Sekunden aktualisiert. Ein anderer Intervall kann mit <code>-s</code> spezifiziert werden.</p></div></div><div class=sect3><h4 id=basics-daemons>5.8.2. Stoppen von Prozessen<a class=anchor href=#basics-daemons></a></h4><div class=paragraph><p>Eine Möglichkeit mit einem laufenden Prozess zu kommunizieren, ist über das Versenden von <em>Signalen</em> mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a>. Es gibt eine Reihe von verschiedenen Signalen. Manche haben eine feste Bedeutung, während andere in der Dokumentation der Anwendung beschrieben sind. Ein Benutzer kann ein Signal nur an einen Prozess senden, welcher ihm gehört. Wird versucht ein Signal an einen Prozess eines anderen Benutzers zu senden, resultiert dies in einem Zugriffsfehler mangels fehlender Berechtigungen. Die Ausnahme ist der <code>root</code>-Benutzer, welcher jedem Prozess Signale senden kann.</p></div><div class=paragraph><p>FreeBSD kann auch ein Signal an einen Prozess senden. Wenn eine Anwendung schlecht geschrieben ist und auf Speicher zugreift, auf den sie nicht zugreifen soll, so sendet FreeBSD dem Prozess das <em>Segmentation Violation</em> Signal (<code>SIGSEGV</code>). Wenn eine Anwendung programmiert wurde, den <a href="https://man.freebsd.org/cgi/man.cgi?query=alarm&amp;sektion=3&amp;format=html">alarm(3)</a> Systemaufruf zu benutzen, um nach einiger Zeit benachrichtigt zu werden, bekommt sie das "Alarm"-Signal (<code>SIGALRM</code>) gesendet.</p></div><div class=paragraph><p>Zwei Signale können benutzt werden, um einen Prozess zu stoppen: <code>SIGTERM</code> und <code>SIGKILL</code>. <code>SIGTERM</code> fordert den Prozess höflich zum Beenden auf. Der Prozess kann das Signal abfangen und hat dann Gelegenheit Logdateien zu schließen und die Aktion, die er durchführte, abzuschließen. In manchen Situationen kann der Prozess <code>SIGTERM</code> ignorieren, wenn er eine Aktion durchführt, die nicht unterbrochen werden darf.</p></div><div class=paragraph><p><code>SIGKILL</code> kann von keinem Prozess ignoriert werden. Wird einem Prozess <code>SIGKILL</code> geschickt, dann wird FreeBSD diesen sofort beenden.</p></div><div class=paragraph><p>Andere häufig verwendete Signale sind <code>SIGHUP</code>, <code>SIGUSR1</code> und <code>SIGUSR2</code>. Da diese Signale für allgemeine Zwecke vorgesehen sind, werden verschiedene Anwendungen unterschiedlich auf diese Signale reagieren.</p></div><div class=paragraph><p>Ändern Sie beispielsweise die Konfiguration eines Webservers, so muss dieser angewiesen werden, seine Konfiguration neu zu lesen. Ein Neustart von <code>httpd</code> würde dazu führen, dass der Server für kurze Zeit nicht erreichbar ist. Senden Sie dem Dämon stattdessen das <code>SIGHUP</code>-Signal. Es sei erwähnt, dass verschiedene Dämonen sich anders verhalten. Lesen Sie die Dokumentation des entsprechenden Dämonen um zu überprüfen, ob der Dämon bei einem <code>SIGHUP</code> die gewünschten Ergebnisse erzielt.</p></div><div class="sidebarblock procedure"><div class=content><div class=paragraph><div class=title>Procedure: Verschicken von Signalen</div><p>Das folgende Beispiel zeigt, wie Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> ein Signal schicken. Die Konfigurationsdatei von <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> ist <span class=filename>/etc/inetd.conf</span>. Diese Konfigurationsdatei liest <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> ein, wenn er <code>SIGHUP</code> empfängt.</p></div><div class="olist arabic"><ol class=arabic><li><p>Suchen Sie mit <a href="https://man.freebsd.org/cgi/man.cgi?query=pgrep&amp;sektion=1&amp;format=html">pgrep(1)</a> die PID des Prozesses, dem Sie ein Signal schicken wollen. In diesem Beispiel ist die PID von <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 198:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pgrep <span class=nt>-l</span> inetd
198 inetd <span class=nt>-wW</span></code></pre></div></div></li><li><p>Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a>, um ein Signal zu senden. Da <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> dem Benutzer <code>root</code> gehört, müssen Sie zuerst mit <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> <code>root</code> werden:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:
<span class=c># /bin/kill -s HUP 198</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> wird, wie andere UNIX® Kommandos auch, keine Ausgabe erzeugen, wenn das Kommando erfolgreich war. Wird versucht, einem Prozess der nicht dem Benutzer gehört, ein Signal zu senden, dann wird die Meldung <code>kill: <em>PID</em>: Operation not permitted</code> ausgegeben. Ein Tippfehler bei der Eingabe der PID führt dazu, dass das Signal an einen falschen Prozess gesendet wird, was zu negativen Ergebnissen führen kann, oder das Signal wird an eine PID gesendet die derzeit nicht in Gebrauch ist, was zu dem Fehler <code>kill: <em>PID</em>: No such process</code> führt.</p></div></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Warum sollte man <code>/bin/kill</code> benutzen?</div><div class=paragraph><p>Viele Shells stellen <code>kill</code> als internes Kommando zur Verfügung, das heißt die Shell sendet das Signal direkt, anstatt <span class=filename>/bin/kill</span> zu starten. Beachten Sie, dass die unterschiedlichen Shells eine andere Syntax benutzen, um die Namen der Signale anzugeben. Anstatt jede Syntax zu lernen, kann es einfacher sein, <code>/bin/kill</code> direkt aufzurufen.</p></div></td></tr></tbody></table></div></div></div><div class=paragraph><p>Beim Versenden von anderen Signalen, ersetzen Sie <code>TERM</code> oder <code>KILL</code> in der Kommandozeile mit dem Namen des Signals.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Das zufällige Beenden eines Prozesses kann gravierende Auswirkungen haben. Insbesondere <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, mit der PID 1, ist ein Spezialfall. <code>/bin/kill -s KILL 1</code> ist ein schneller, jedoch nicht empfohlener Weg, das System herunterzufahren. Überprüfen Sie die Argumente von <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> <em>immer</em> zweimal <em>bevor</em> Sie <kbd>Return</kbd> drücken.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=shells>5.9. Shells<a class=anchor href=#shells></a></h3><div class=paragraph><p>Eine <em>Shell</em> stellt eine Kommandozeilen-Schnittstelle zur Interaktion mit dem Betriebssystem zur Verfügung. Sie empfängt Befehle von einem Eingabekanal und führt diese aus. Viele Shells bieten eingebaute Funktionen, die die tägliche Arbeit erleichtern, beispielsweise eine Dateiverwaltung, die Vervollständigung von Dateinamen (Globbing), Kommandozeilen-Editor, sowie Makros und Umgebungsvariablen. FreeBSD enthält einige Shells, darunter die Bourne Shell (<a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>) und die verbesserte C-Shell (<a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>). Weitere Shells, wie <code>zsh</code> oder <code>bash</code>, befinden sich in der Ports-Sammlung.</p></div><div class=paragraph><p>Die verwendete Shell ist letztlich eine Frage des Geschmacks. Ein C-Programmierer, findet vielleicht eine C-artige Shell wie <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> angenehmer. Ein Linux®-Benutzer bevorzugt vielleicht <code>bash</code>. Jede Shell hat ihre speziellen Eigenschaften, die mit der bevorzugten Arbeitsumgebung des Benutzers harmonieren kann oder nicht. Deshalb stehen mehrere Shells zur Auswahl.</p></div><div class=paragraph><p>Ein verbreitetes Merkmal in Shells ist die Dateinamen-Vervollständigung. Nachdem der Benutzer einige Buchstaben eines Kommandos oder eines Dateinamen eingeben hat, vervollständigt die Shell den Rest durch drücken der <kbd>Tab</kbd>-Taste. Angenommen, Sie haben zwei Dateien <span class=filename>foobar</span> und <span class=filename>football</span>. Um <span class=filename>foobar</span> zu löschen, kann der Benutzer <code>rm foo</code> eingeben und <kbd>Tab</kbd> drücken um den Dateinamen zu vervollständigen.</p></div><div class=paragraph><p>Die Shell wird lediglich <code>rm foo</code> anzeigen. Sie konnte den Dateinamen nicht vervollständigen, da sowohl <span class=filename>foobar</span> als auch <span class=filename>football</span> mit <code>foo</code> anfangen. Einige Shells geben einen Signalton aus, oder zeigen alle Möglichkeiten an, wenn mehr als ein Name mit dem gegebenen Muster übereinstimmt. Der Benutzer muss dann weitere Zeichen eingeben, damit die Shell den gewünschten Dateinamen bestimmen kann. Durch Eingabe von <code>t</code> und erneutes Drücken von <kbd>Tab</kbd> ist die Shell in der Lage, den gewünschten Dateinamen zu vervollständigen.</p></div><div class=paragraph><p>Ein weiteres Merkmal der Shell ist der Gebrauch von Umgebungsvariablen. Dies sind veränderbare Schlüsselpaare im Umgebungsraum der Shell, die jedes von der Shell aufgerufene Programm lesen kann. Daher enthält der Umgebungsraum viele Konfigurationsdaten für Programme. <a href=#shell-env-vars>Gebräuchliche Umgebungsvariablen</a> zeigt verbreitete Umgebungsvariablen und deren Bedeutung. Beachten Sie, dass die Namen der Umgebungsvariablen immer in Großbuchstaben geschrieben sind:</p></div><table id=shell-env-vars class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 5. Gebräuchliche Umgebungsvariablen</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Variable</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>USER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name des angemeldeten Benutzers.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Liste mit Verzeichnissen (getrennt durch Doppelpunkt) zum Suchen nach Programmen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>DISPLAY</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Der Name des Xorg-Bildschirms, auf dem Ausgaben erfolgen sollen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>SHELL</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die aktuelle Shell.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERM</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Name des Terminaltyps des Benutzers. Benutzt, um die Fähigkeiten des Terminals zu bestimmen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERMCAP</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Datenbankeintrag der Terminal Escape Codes, benötigt um verschieden Terminalfunktionen auszuführen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>OSTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Typ des Betriebssystems.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MACHTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die CPU-Architektur des Systems.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>EDITOR</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vom Benutzer bevorzugter Text-Editor.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PAGER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vom Benutzer bevorzugter Text-Betrachter.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MANPATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Liste mit Verzeichnissen (getrennt durch Doppelpunkt) zum Suchen nach Manualpages.</p></td></tr></tbody></table><div class=paragraph><p>Das Setzen von Umgebungsvariablen unterscheidet sich von Shell zu Shell. In <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> wird dazu <code>setenv</code> benutzt. <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> und <code>bash</code> benutzen <code>export</code> um Umgebungsvariablen zu setzen. Dieses Beispiel für die <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>-Shell setzt die Variable <code>EDITOR</code> auf <span class=filename>/usr/local/bin/emacs</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv EDITOR /usr/local/bin/emacs</code></pre></div></div><div class=paragraph><p>Der entsprechende Befehl für <code>bash</code> wäre:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>export </span><span class=nv>EDITOR</span><span class=o>=</span><span class=s2>&#34;/usr/local/bin/emacs&#34;</span></code></pre></div></div><div class=paragraph><p>Um eine Umgebungsvariable zu expandieren, geben Sie in der Kommandozeile das Zeichen <code>$</code> vor dessen Namen ein. Zum Beispiel gibt <code>echo $TERM</code> den aktuellen Wert von`$TERM` aus.</p></div><div class=paragraph><p>Shells behandeln Spezialzeichen, so genannte Metazeichen, als besondere Darstellungen für Daten. Das häufigste Zeichen ist <code>*</code>, das eine beliebige Anzahl Zeichen in einem Dateinamen repräsentiert. Metazeichen können zur Vervollständigung von Dateinamen (Globbing) benutzt werden. Beispielsweise liefert <code>echo *</code> nahezu das gleiche wie <code>ls</code>, da die Shell alle Dateinamen die mit <code>*</code> übereinstimmen, an <code>echo</code> weitergibt.</p></div><div class=paragraph><p>Um zu verhindern, dass die Shell ein Sonderzeichen interpretiert, schützt man es, indem man einen Backslash (<code>\</code>) voranstellt. Zum Beispiel zeigt <code>echo $TERM</code> die Einstellung des Terminals an, wohingegen <code>echo \$TERM</code> einfach die Zeichenfolge <code>$TERM</code> ausgibt.</p></div><div class=sect3><h4 id=changing-shells>5.9.1. Ändern der Shell<a class=anchor href=#changing-shells></a></h4><div class=paragraph><p>Der einfachste Weg die Standard Shell zu ändern, ist <code>chsh</code> zu benutzen. <code>chsh</code> startet den Editor, welcher durch die Umgebungsvariable <code>EDITOR</code> gesetzt ist. Standardmäßig ist dies <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>. Tragen Sie in die Zeile die mit <code>Shell:</code> beginnt, den absoluten Pfad der neuen Shell ein.</p></div><div class=paragraph><p>Alternativ setzt <code>chsh -s</code> die Shell, ohne dabei einen Editor aufzurufen. Um die Shell zum Beispiel auf <code>bash</code> zu ändern, geben Sie folgenden Befehl ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% chsh <span class=nt>-s</span> /usr/local/bin/bash</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die neue Shell <em>muss</em> in <span class=filename>/etc/shells</span> aufgeführt sein. Wurde die Shell aus der FreeBSD Ports-Sammlung installiert, so wie in <a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a> beschrieben, sollte sie automatisch zu dieser Datei hinzugefügt worden sein. Wenn der Eintrag fehlt, nutzen Sie folgenden Befehl, und ersetzen Sie den Pfad mit dem Pfad zur gewünschten Shell:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/local/bin/bash &gt;&gt; /etc/shells</span></code></pre></div></div><div class=paragraph><p>Danach kann <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a> erneut aufgerufen werden.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_fortgeschrittene_shell_techniken>5.9.2. Fortgeschrittene Shell Techniken<a class=anchor href=#_fortgeschrittene_shell_techniken></a></h4><div class=paragraph><p>Die UNIX®-Shell ist nicht nur ein Kommandozeileninterpreter, sie ist ein leistungsfähiges Werkzeug, das Benutzern die Ausführung von Befehlen ermöglicht. Es kann die Ein- und Ausgabe umleiten und Befehle miteinander verketten, um die finale Ausgabe zu verbessern. Diese Funktionalität, gepaart mit den eingebauten Befehlen, bietet dem Benutzer eine Umgebung, welche die Effizienz erheblich steigern kann.</p></div><div class=paragraph><p>Als Redirection bezeichnet man die Umleitung der Ein- oder Ausgabe in einen anderen Befehl oder Datei. Um beispielsweise die Ausgabe des Befehls <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> in eine Datei zu schreiben, muss die Ausgabe umgeleitet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=o>&gt;</span> Verzeichnis_Ausgabe.txt</code></pre></div></div><div class=paragraph><p>Die Datei <span class=filename>Verzeichnis_Ausgabe.txt</span> enthält nun den Verzeichnisinhalt. Einige Befehle, wie beispielsweise <a href="https://man.freebsd.org/cgi/man.cgi?query=sort&amp;sektion=1&amp;format=html">sort(1)</a>, können verwendet werden um von der Eingabe zu lesen. Wenn Sie die Ausgabe sortieren möchten, müssen Sie die Eingabe umleiten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sort</span> &lt; Verzeichnis_Ausgabe.txt</code></pre></div></div><div class=paragraph><p>Die Eingabe wird sortiert und auf dem Bildschirm ausgegeben. Um diese Ausgabe wiederum in eine Datei umzuleiten, kann die Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=sort&amp;sektion=1&amp;format=html">sort(1)</a> umgeleitet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sort</span> &lt; Verzeichnis_Ausgabe.txt <span class=o>&gt;</span> Sortierte_Ausgabe.txt</code></pre></div></div><div class=paragraph><p>In den bisherigen Beispielen wurden für die Umleitung Dateideskriptoren verwendet. Jedes UNIX®-System verfügt über drei Dateideskriptoren: Standardeingabe (stdin), Standardausgabe (stdout) und Stardardfehlerausgabe (stderr). Jeder Deskriptor hat einen bestimmten Zweck. Die Eingabe könnte von einer Tastatur, einer Maus oder einem anderen Eingabegerät stammen. Die Ausgabe könnte der Bildschirm oder ein Drucker sein. Die Standardfehlerausgabe wird zur Diagnose und für Fehlermeldungen verwendet. Alle drei Deskriptoren arbeiten I/O basiert und werden häufig als Streams bezeichnet.</p></div><div class=paragraph><p>Die Verwendung von Deskriptoren erlaubt es der Shell, die Ein- und Ausgabe von verschiedenen Kommandos umzuleiten und zu teilen. Eine weitere Möglichkeit zur Umleitung bietet der Pipe-Operator.</p></div><div class=paragraph><p>Der UNIX® Pipe-Operator "|" wird verwendet, um die Ausgabe eines Kommandos an ein anderes Programm zu übergeben. Grundsätzlich bedeutet dies, dass die Standardausgabe eines Programms als Standardeingabe für ein weiteres Programm verwendet wird. Ein Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>Verzeichnis_Auflistung.txt | <span class=nb>sort</span> | less</code></pre></div></div><div class=paragraph><p>In diesem Beispiel wird der Inhalt von <span class=filename>Verzeichnis_Auflistung.txt</span> sortiert und die Ausgabe an <a href="https://man.freebsd.org/cgi/man.cgi?query=less&amp;sektion=1&amp;format=html">less(1)</a> übergeben. Dies erlaubt es dem Benutzer, die Ausgabe Schritt für Schritt und im eigenen Tempo zu betrachten.</p></div></div></div><div class=sect2><h3 id=editors>5.10. Text-Editoren<a class=anchor href=#editors></a></h3><div class=paragraph><p>Die meiste Konfiguration unter FreeBSD wird durch das Editieren von Textdateien erledigt. Deshalb ist es eine gute Idee, mit einem Texteditor vertraut zu werden. FreeBSD hat ein paar davon im Basissystem und sehr viel mehr in der Ports-Sammlung.</p></div><div class=paragraph><p>Ein einfach zu erlernender Editor ist <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a>, was für easy editor steht. Um diesen Editor zu starten, gibt man in der Kommandozeile <code>ee <em>filename</em></code> ein, wobei <em>filename</em> den Namen der zu editierenden Datei darstellt. Einmal im Editor, finden sich alle Editor-Funktionen oben im Display aufgelistet. Das Einschaltungszeichen (<code>^</code>) steht für die <kbd>Ctrl</kbd> (oder <kbd>Strg</kbd>) Taste, mit <code>^e</code> ist also die Tastenkombination <span class=keyseq><kbd>Ctrl</kbd>+<kbd>e</kbd></span> gemeint. Um <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a> zu verlassen, drücken Sie <kbd>Esc</kbd> und wählen dann im Hauptmenü <code>leave editor</code> aus. Der Editor fragt nach, ob Sie speichern möchten, wenn die Datei verändert wurde.</p></div><div class=paragraph><p>FreeBSD verfügt über leistungsfähigere Editoren wie <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> als Teil des Basissystems. Andere Editoren wie <a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/editors/vim/>editors/vim</a> sind Teil der Ports-Sammlung. Diese Editoren bieten höhere Funktionalität, jedoch auf Kosten einer etwas schwierigeren Erlernbarkeit. Das Erlernen eines leistungsfähigeren Editors, wie vim oder Emacs, kann auf lange Sicht Zeit einsparen.</p></div><div class=paragraph><p>Viele Anwendungen, die Dateien verändern oder Texteingabe erwarten, werden automatisch einen Texteditor öffnen. Um den Standardeditor zu ändern, wird die Umgebungsvariable <code>EDITOR</code> gesetzt, wie im Abschnitt <a href=#shells>Shells</a> beschrieben.</p></div></div><div class=sect2><h3 id=basics-devices>5.11. Geräte und Gerätedateien<a class=anchor href=#basics-devices></a></h3><div class=paragraph><p>Der Begriff Gerät wird meist in Verbindung mit Hardware wie Laufwerken, Druckern, Grafikkarten oder Tastaturen gebraucht. Der Großteil der Meldungen, die beim Booten von FreeBSD angezeigt werden, beziehen sich auf gefundene Geräte. Eine Kopie dieser Bootmeldungen wird in <span class=filename>/var/run/dmesg.boot</span> gespeichert.</p></div><div class=paragraph><p>Jedes Gerät verfügt über einen Gerätenamen und Gerätenummer. Zum Beispiel steht <span class=filename>ada0</span> für die erste SATA Festplatte, während <span class=filename>kbd0</span> die Tastatur repräsentiert.</p></div><div class=paragraph><p>Auf die meisten Geräte wird unter FreeBSD über spezielle Gerätedateien im <span class=filename>/dev</span> Verzeichnis zugegriffen.</p></div></div><div class=sect2><h3 id=basics-more-information>5.12. Manualpages<a class=anchor href=#basics-more-information></a></h3><div class=sect3><h4 id=basics-man>5.12.1. Manualpages<a class=anchor href=#basics-man></a></h4><div class=paragraph><p>Die umfassendste Dokumentation rund um FreeBSD gibt es in Form von Manualpages. Annähernd jedes Programm im System bringt eine kurze Referenzdokumentation mit, die die grundsätzliche Funktion und verschiedene Parameter erklärt. Diese Manuals können mit <code>man</code> eingesehen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man Kommando</code></pre></div></div><div class=paragraph><p><em>Kommando</em> ist der Name des Kommandos, über das man etwas erfahren will. Um beispielsweise mehr über das Kommando <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> zu erfahren, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>ls</span></code></pre></div></div><div class=paragraph><p>Die Manualpages sind in nummerierte Sektionen unterteilt, die jeweils ein Thema darstellen. In FreeBSD sind die folgenden Sektionen verfügbar:</p></div><div class="olist arabic"><ol class=arabic><li><p>Benutzerkommandos.</p></li><li><p>Systemaufrufe und Fehlernummern.</p></li><li><p>Funktionen der C Bibliothek.</p></li><li><p>Gerätetreiber.</p></li><li><p>Dateiformate.</p></li><li><p>Spiele und andere Unterhaltung.</p></li><li><p>Verschiedene Informationen.</p></li><li><p>Systemverwaltung und -Kommandos.</p></li><li><p>Kernel Schnittstellen.</p></li></ol></div><div class=paragraph><p>In einigen Fällen kann dasselbe Thema in mehreren Sektionen auftauchen. Es gibt zum Beispiel ein <code>chmod</code> Benutzerkommando und einen <code>chmod()</code> Systemaufruf. Um <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> mitzuteilen, aus welcher Sektion die Information angezeigt werden soll, kann die Sektionsnummer mit angeben werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man 1 <span class=nb>chmod</span></code></pre></div></div><div class=paragraph><p>Dies wird Ihnen die Manualpage für das Benutzerkommando <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> zeigen. Verweise auf eine Sektion der Manualpages werden traditionell in Klammern gesetzt. So bezieht sich <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> auf das Benutzerkommando und <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=2&amp;format=html">chmod(2)</a> auf den Systemaufruf.</p></div><div class=paragraph><p>Wenn das Kommando nicht bekannt ist, kann <code>man -k</code> benutzt werden, um nach Schlüsselbegriffen in den Kommandobeschreibungen zu suchen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nt>-k</span> mail</code></pre></div></div><div class=paragraph><p>Dieser Befehl zeigt eine Liste von Kommandos, deren Beschreibung das Schlüsselwort "mail" enthält. Die gleiche Funktionalität erhalten Sie auch, wenn Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=apropos&amp;sektion=1&amp;format=html">apropos(1)</a> benutzen.</p></div><div class=paragraph><p>Um die Beschreibungen der Kommandos in <span class=filename>/usr/bin</span> zu lesen, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% man <span class=nt>-f</span> <span class=k>*</span> | more</code></pre></div></div><div class=paragraph><p>Dasselbe erreichen Sie durch Eingabe von:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% whatis <span class=k>*</span> | more</code></pre></div></div></div><div class=sect3><h4 id=basics-info>5.12.2. GNU Info Dateien<a class=anchor href=#basics-info></a></h4><div class=paragraph><p>FreeBSD enthält verschiedene Anwendungen und Utilities der Free Software Foundation (FSF). Zusätzlich zu den Manualpages können diese Programme Hypertext-Dokumente enthalten, die <code>info</code>-Seiten genannt werden. Diese Dokumente können mit <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a> ansehen kann. Wenn <a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> installiert ist, kann auch der info-Modus von emacs benutzt werden.</p></div><div class=paragraph><p>Um <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a> zu benutzen, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% info</code></pre></div></div><div class=paragraph><p>Eine kurze Einführung gibt es mit <code>h</code>; eine Befehlsreferenz erhalten Sie durch Eingabe von: <code>?</code>.</p></div></div></div></div></div><div class=sect1><h2 id=ports>Kapitel 6. Installieren von Anwendungen: Pakete und Ports<a class=anchor href=#ports></a></h2><div class=sectionbody><div class=sect2><h3 id=ports-synopsis>6.1. Übersicht<a class=anchor href=#ports-synopsis></a></h3><div class=paragraph><p>FreeBSD enthält eine umfassende Sammlung von Systemwerkzeugen, die Teil des Basissystems sind. Darüber hinaus stellt FreeBSD zwei sich ergänzende Methoden zur Installation von Drittanbieter-Software zur Verfügung: Die Ports-Sammlung zur Installation aus dem Quellcode sowie Pakete zur Installation von vorkompilierten binären Softwarepaketen. Beide Methoden können benutzt werden, um Anwendungen von lokalen Medien oder über das Netzwerk zu installieren.</p></div><div class=paragraph><p>Dieses Kapitel behandelt die folgenden Themen:</p></div><div class=ulist><ul><li><p>Den Unterschied zwischen binären Softwarepaketen und Ports.</p></li><li><p>Wie man Drittanbieter-Software findet, die nach FreeBSD portiert wurde.</p></li><li><p>Wie Binärpakete mit pkg verwaltet werden.</p></li><li><p>Den Bau von Drittanbieter-Software aus dem Quellcode mithilfe der Ports-Sammlung.</p></li><li><p>Wie man die Dateien findet, die zusammen mit der Anwendung installiert wurden.</p></li><li><p>Was zu tun ist, wenn die Installation einer Software fehlschlägt.</p></li></ul></div></div><div class=sect2><h3 id=ports-overview>6.2. Installation von Software<a class=anchor href=#ports-overview></a></h3><div class=paragraph><p>Die typischen Schritte zur Installation von Drittanbieter-Software auf einem UNIX® System sind:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Download der Software, die als Quelltext oder im Binärformat vorliegen kann.</p></li><li><p>Auspacken der Software. Dies ist typischerweise ein mit <a href="https://man.freebsd.org/cgi/man.cgi?query=compress&amp;sektion=1&amp;format=html">compress(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=bzip2&amp;sektion=1&amp;format=html">bzip2(1)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=xz&amp;sektion=1&amp;format=html">xz(1)</a> komprimiertes Tar-Archiv.</p></li><li><p>Durchsuchen der Dokumentation, die sich in <span class=filename>INSTALL</span>, <span class=filename>README</span> oder mehreren Dateien im Verzeichnis <span class=filename>doc/</span> befindet, nach Anweisungen, wie die Software zu installieren ist.</p></li><li><p>Kompilieren der Software, wenn sie als Quelltext vorliegt. Dazu muss vielleicht das <span class=filename>Makefile</span> angepasst, oder <code>configure</code> ausgeführt werden.</p></li><li><p>Testen und installieren der Software.</p></li></ol></div><div class=paragraph><p>Ein FreeBSD-Port ist eine Sammlung von Dateien, die das Kompilieren der Quelltexte einer Anwendung automatisieren. Die Dateien, die ein Port umfasst enthalten alle notwendigen Informationen um die Anwendung herunterzuladen, zu extrahieren, anzupassen und zu installieren.</p></div><div class=paragraph><p>Wenn die Software nicht bereits für FreeBSD angepasst und getestet wurde, muss vielleicht sogar der Quelltext angepasst werden, damit die Software funktioniert.</p></div><div class=paragraph><p>Bislang wurden über <a href=https://www.FreeBSD.org/ports/>36000</a> Anwendungen von Drittanbietern nach FreeBSD portiert. Falls möglich, werden diese Anwendungen als vorkompilierte <em>Pakete</em> zur Verfügung gestellt.</p></div><div class=paragraph><p>Pakete können mit FreeBSDs Paketverwaltungswerkzeugen manipuliert werden.</p></div><div class=paragraph><p>Pakete und Ports beachten Abhängigkeiten zwischen Anwendungen. Wenn ein Paket oder die Ports-Sammlung benutzt wird, um eine Anwendung zu installieren, dann werden fehlende Bibliotheken zuerst installiert, sofern sie nicht schon vorher installiert waren.</p></div><div class=paragraph><p>Ein FreeBSD-Paket enthält vorkompilierte Kopien aller Befehle für eine Anwendung, sowie zusätzliche Konfigurationsdateien und Dokumentation. Pakete können mit den <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a>-Befehlen, wie <code>pkg install</code>, manipuliert werden.</p></div><div class=paragraph><p>Obwohl beide Technologien gleichartig sind, so haben Pakete und Ports jeweils ihre eigenen Stärken. Welche Technologie eingesetzt wird, hängt letzten Endes von den Anforderungen ab, die an eine bestimmte Anwendung gestellt werden.</p></div><div class=ulist><div class=title>Vorteile von Paketen</div><ul><li><p>Das komprimierte Paket einer Anwendung ist normalerweise kleiner als das komprimierte Archiv der Quelltexte.</p></li><li><p>Pakete müssen nicht mehr kompiliert werden. Dies ist ein Vorteil, wenn große Pakete wie Mozilla, KDE oder GNOME auf langsamen Maschinen installiert werden.</p></li><li><p>Wenn Sie Pakete verwenden, brauchen Sie nicht zu verstehen, wie Software unter FreeBSD kompiliert wird.</p></li></ul></div><div class=ulist><div class=title>Vorteile von Ports</div><ul><li><p>Da die Pakete auf möglichst vielen System laufen sollen, werden Optionen beim Übersetzen zurückhaltend gesetzt. Wird eine Anwendung über die Ports übersetzt, können die Optionen nach eigenen Bedürfnissen angepasst werden.</p></li><li><p>Die Eigenschaften einiger Anwendungen werden über Optionen zum Zeitpunkt des Übersetzens festgelegt. Apache kann zum Beispiel über eine große Auswahl an eingebauten Optionen konfiguriert werden.</p><div class=paragraph><p>Für einige Fälle existieren verschiedene Pakete einer Anwendung, die beim Übersetzen unterschiedlich konfiguriert wurden. Für Ghostscript gibt es ein <span class=filename>ghostscript</span>-Paket und ein <span class=filename>ghostscript-nox11</span>-Paket, die sich durch die Xorg Unterstützung unterscheiden. Das Erstellen von verschiedenen Paketen wird aber schnell unhandlich, wenn eine Anwendung mehr als ein oder zwei Optionen zum Zeitpunkt des Übersetzens besitzt.</p></div></li><li><p>Die Lizenzbestimmungen mancher Software verbietet ein Verbreiten in binärer Form. Diese Software muss als Quelltext, der durch den Benutzer kompiliert werden muss, ausgeliefert werden.</p></li><li><p>Einige Leute trauen binären Distributionen nicht, oder sie ziehen es vor den Quelltext zu lesen, um diesen nach möglichen Problemen zu durchsuchen.</p></li><li><p>Der Quellcode wird benötigt, um individuelle Anpassungen anzuwenden.</p></li></ul></div><div class=paragraph><p>Wenn Sie über aktualisierte Ports informiert sein wollen, lesen Sie die Mailinglisten <a href=https://lists.FreeBSD.org/subscription/freebsd-ports>FreeBSD ports</a> und <a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>FreeBSD ports bugs</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Bevor Sie eine Anwendung installieren, informieren Sie sich auf der Seite <a href=https://vuxml.FreeBSD.org/ class=bare>https://vuxml.FreeBSD.org/</a> über mögliche Sicherheitsprobleme mit der Anwendung, oder führen Sie <code>pkg audit -F</code> aus, um alle installierten Pakete auf bekannte Sicherheitslücken zu überprüfen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Der Rest dieses Kapitels beschreibt, wie man Software Dritter mit Paketen und Ports unter FreeBSD installiert und verwaltet.</p></div></div><div class=sect2><h3 id=ports-finding-applications>6.3. Suchen einer Anwendung<a class=anchor href=#ports-finding-applications></a></h3><div class=paragraph><p>Die Anzahl der nach FreeBSD portierten Anwendungen steigt ständig. Es gibt einige Wege, um nach Anwendungen zu suchen:</p></div><div class=ulist><ul><li><p>Die FreeBSD-Webseite stellt unter <a href=https://www.FreeBSD.org/ports/>https://www.FreeBSD.org/ports/</a> eine aktuelle und durchsuchbare Liste aller Anwendungen zur Verfügung. Die Ports können nach dem Namen den Anwendung, oder über die Software-Kategorie durchsucht werden.</p></li><li><p>Dan Langille verwaltet <a href=http://www.FreshPorts.org/>FreshPorts.org</a>, das eine umfassende Suchfunktion bietet und Änderungen an den Anwendungen in der Ports-Sammlung verfolgt. Registrierte Benutzer können eine Merkliste erstellen, um automatisch eine E-Mail zu erhalten, sobald ein Port von dieser Liste aktualisiert wurde.</p></li><li><p>Wenn Sie bei der Suche nach einer bestimmten Anwendung nicht weiter kommen, versuchen Sie eine Webseite wie <a href=http://www.sourceforge.net/>SourceForge.net</a> oder <a href=http://www.github.com/>GitHub.com</a>. Schauen Sie dann auf der <a href=https://www.FreeBSD.org/ports/>FreeBSD-Webseite</a> nach, ob die Anwendung portiert wurde.</p></li><li><p>Das Paket Repository nach einer Anwendung durchsuchen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg search subversion</span>
git-subversion-1.9.2
java-subversion-1.8.8_2
p5-subversion-1.8.8_2
py27-hgsubversion-1.6
py27-subversion-1.8.8_2
ruby-subversion-1.8.8_2
subversion-1.8.8_2
subversion-book-4515
subversion-static-1.8.8_2
subversion16-1.6.23_4
subversion17-1.7.16_2</code></pre></div></div><div class=paragraph><p>Die Paketnamen enthalten jeweils die Versionsnummer. Wenn ein Port von python abhängt, wird auch die Versionsnummer von python ausgegeben, mit der die Anwendung gebaut wurde. Für einige Ports stehen sogar mehrere Versionen zur Verfügung. Im Fall von Subversion gibt es drei verschiedene Versionen, mit unterschiedlichen Optionen. In diesem Fall wird die Version von Subversion statisch gelinkt. Wenn Sie ein Paket installieren, ist es am besten den Ursprung des Ports anzugeben, also den Pfad in der Ports-Sammlung. Wiederholen Sie <code>pkg search</code> mit <code>-o</code> um den Ursprung der Pakete anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg search -o subversion</span>
devel/git-subversion
java/java-subversion
devel/p5-subversion
devel/py-hgsubversion
devel/py-subversion
devel/ruby-subversion
devel/subversion16
devel/subversion17
devel/subversion
devel/subversion-book
devel/subversion-static</code></pre></div></div><div class=paragraph><p>Zudem unterstützt <code>pkg search</code> die Suche mit regulären Ausdrücken, nach exakten Treffern, nach der Beschreibung oder nach anderen Feldern in der Repository-Datenbank. Nach der Installation von <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg/>ports-mgmt/pkg</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg-devel/>ports-mgmt/pkg-devel</a>, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-search&amp;sektion=8&amp;format=html">pkg-search(8)</a> weitere Details.</p></div></li><li><p>Wenn die Ports-Sammlung bereits installiert ist, gibt es mehrere Methoden, um die lokale Version dieser Port-Sammlung abzufragen. Verwenden Sie <code>whereis <em>Datei</em></code> um herauszufinden, in welcher Kategorie ein Port ist, wobei <em>Datei</em> der Name des Programms ist, das installiert werden soll:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># whereis lsof</span>
lsof: /usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>Alternativ kann der <a href="https://man.freebsd.org/cgi/man.cgi?query=echo&amp;sektion=1&amp;format=html">echo(1)</a>-Befehl verwendet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/ports/*/*lsof*</span>
/usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>Beachten Sie aber, dass dieser Befehl auch alle Dateien im Verzeichnis <span class=filename>/usr/ports/distfiles</span> findet, auf die der angegebene Suchbegriff passt.</p></div></li><li><p>Ein weiterer Weg nach Software zu suchen besteht darin, die eingebaute Suchfunktion der Ports-Sammlung zu benutzen. Wechseln Sie dazu in das Verzeichnis <span class=filename>/usr/ports</span>, und rufen Sie <code>make search name=<em>Anwendungsname</em></code> auf, wobei <em>Anwendungsname</em> der Name der Software ist. Um zum Beispiel nach <code>lsof</code> zu suchen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make search name=lsof</span>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span>
Maint:  ler@lerctr.org
Index:  sysutils
B-deps:
R-deps:</code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Der integrierte Suchmechanismus verwendet eine Datei mit Index-Informationen. Erscheint eine Meldung, dass der <span class=filename>INDEX</span> benötigt wird, führen Sie <code>make fetchindex</code> aus, um die aktuelle Index-Datei herunterzuladen. Mit einem vorhandenen <span class=filename>INDEX</span> ist <code>make search</code> in der Lage, die gewünschte Suche durchzuführen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die "Path:"-Zeile zeigt an, wo der Port zu finden ist.</p></div><div class=paragraph><p>Um weniger Informationen zu erhalten, benutzen Sie die Funktion <code>quicksearch</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make quicksearch name=lsof</span>
Port:	lsof-4.88.d,8
Path:	/usr/ports/sysutils/lsof
Info:	Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Erweiterte Suchen führen Sie mit <code>make search key=<em>Text</em></code> oder <code>make quicksearch key=<em>Text</em></code> aus. Damit werden Portnamen, Kommentare, Beschreibungen und Abhängigkeiten nach <em>Text</em> durchsucht. Dies kann sehr nützlich sein, wenn der Name des Programms nicht bekannt ist.</p></div><div class=paragraph><p>Bei der Verwendung von <code>search</code> und <code>quicksearch</code> wird Groß- und Kleinschreibung bei der Suche ignoriert. Die Suche nach "LSOF" wird dieselben Ergebnisse wie die Suche nach "lsof" liefern.</p></div></li></ul></div></div><div class=sect2><h3 id=pkgng-intro>6.4. Benutzen von pkg zur Verwaltung von Binärpaketen<a class=anchor href=#pkgng-intro></a></h3><div class=paragraph><p>pkg ist der Nachfolger für die traditionellen Paketverwaltungswerkzeuge von FreeBSD. Es bietet viele Funktionen, die den Umgang mit Binärpaketen schneller und einfacher machen.</p></div><div class=paragraph><p>Wenn Sie lediglich vorgefertigte Binärpakete von den FreeBSD Spiegeln benutzen möchten, ist pkg für die Verwaltung von Paketen ausreichend.</p></div><div class=paragraph><p>Falls Sie jedoch die Software aus dem Quellcode bauen oder eigene Repositories verwenden, benötigen Sie ein separates <a href=#ports-upgrading-tools>Paketverwaltungswerkzeug</a>.</p></div><div class=paragraph><p>pkg ist kein Ersatz für diese Werkzeuge. Während diese Werkzeuge Drittanbieter-Software sowohl aus Binärpaketen als auch aus der Ports-Sammlung installieren können, so installiert pkg ausschließlich Binärpakete.</p></div><div class=sect3><h4 id=pkgng-initial-setup>6.4.1. Erste Schritte mit pkg<a class=anchor href=#pkgng-initial-setup></a></h4><div class=paragraph><p>FreeBSD enthält ein Bootstrap-Programm, welches pkg zusammen mit den Manualpages installiert. pkg wurde für FreeBSD Versionen ab 10.<em>X</em> entwickelt.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nicht alle FreeBSD Versionen unterstüzen den folgenden Bootstrap Prozess. Eine aktuelle Liste finden Sie unter <a href=https://pkg.FreeBSD.org/ class=bare>https://pkg.FreeBSD.org/</a>. Andernfalls muss pkg aus der Ports-Sammlung oder als Binärpaket installiert werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um das Bootstrap Programm zu starten, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/pkg</span></code></pre></div></div><div class=paragraph><p>Sie müssen eine Internetverbindung haben, damit der Bootstrap Prozess funktioniert.</p></div><div class=paragraph><p>Um den Port zu installieren, geben Sie stattdessen folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/pkg</span>
<span class=c># make</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Bei der Aktualisierung eines bestehenden Systems, welches ursprünglich die alten pkg_* Werkzeuge verwendet hat, muss die Datenbank in das neue Format konvertiert werden, damit die neuen Werkzeuge wissen, welche Pakete bereits installiert sind. Sobald pkg installiert ist, muss die Paketdatenbank mit dem folgenden Befehl vom traditionellen Format in das neue Format konvertiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg2ng</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Auf neu installieren Systemen, auf denen noch keine Software von Drittanbietern installiert wurde, kann dieser Schritt entfallen.</p></div></td></tr></tbody></table></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Die Konvertierung ist unwiderruflich. Sobald die Paketdatenbank in das Format von pkg umgewandelt wurde, sollten die traditionellen pkg_* Werkzeuge nicht mehr benutzt werden.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bei der Konvertierung der Paketdatenbank können Fehler ausgegeben werden, wenn die Inhalte auf die neue Version umgewandelt werden. Im Allgemeinen können diese Fehler ignoriert werden. Wenn pkg2ng fertig ist, wird eine Liste von Software ausgegeben, die nicht erfolgreich konvertiert werden konnte. Diese Anwendungen müssen manuell neu installiert werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um sicherzustellen, dass die Ports-Sammlung neue Pakete mit pkg und nicht mit den traditionellen Formaten registriert, muss in FreeBSD 10.<em>X</em> und früheren Versionen folgende Zeile in <span class=filename>/etc/make.conf</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>WITH_PKGNG=     yes</pre></div></div><div class=paragraph><p>In der Voreinstellung benutzt pkg die Pakete der FreeBSD-Spiegel (das <em>Repository</em>). Wenn Sie ein eigenes Paket-Repository erstellen möchten, lesen Sie <a href=#ports-poudriere>Pakete mit Poudriere bauen</a></p></div><div class=paragraph><p>Weitere Konfigurationsoptionen für pkg sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a> beschrieben.</p></div><div class=paragraph><p>Informationen zur Bedienung von pkg ist in <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> verfügbar. Alternativ kann <code>pkg</code> ohne zusätzliche Argumente aufgerufen werden.</p></div><div class=paragraph><p>Jedes Argument von pkg ist in seiner spezifischen Manualpage dokumentiert. Um beispielsweise die Manualpage von <code>pkg install</code> zu lesen, geben Sie einen der folgenden Befehle ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg help install</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># man pkg-install</span></code></pre></div></div><div class=paragraph><p>Der Rest dieses Abschnitts beschreibt die typischen Verwaltungsaufgaben für Binärpakete, die mit pkg erledigt werden können. Jedes gezeigte Kommando verfügt über Optionen, um das Verhalten anzupassen. Details und weitere Beispiele finden Sie in den Manualpages der einzelnen Kommandos.</p></div></div><div class=sect3><h4 id=quarterly-latest-branch>6.4.2. Die Port-Zweige <em>Quarterly</em> und <em>Latest</em><a class=anchor href=#quarterly-latest-branch></a></h4><div class=paragraph><p>Der vierteljährliche Zweig (Quarterly) bietet eine besser vorhersehbare und stabilere Erfahrung bei der Installation und Aktualisierung von Ports und Paketen. Dies wird im Wesentlichen dadurch erreicht, das nur Aktualisierungen zugelassen werden, die nicht zum Funktionsumfang gehören. Der vierteljährliche Zweig zielt darauf ab, Sicherheitskorrekturen (Aktualisierungen und Rückportierungen von Commits), Fehlerbehebungen und Port-Konformität oder Framework-Änderungen zu erhalten. Der vierteljährliche Zweig wird zu Beginn eines jeden Quartals im Januar, April, Juli und Oktober von HEAD abgetrennt. Die Zweige werden nach dem Jahr (YYYY) und dem Quartal (Q1 - Q4) benannt, in dem sie erstellt wurden. Zum Beispiel wird der Zweig, der im Januar 2016 erstellt wurde, 2016Q1 genannt. Der neueste Zweig (Latest) stellt die aktuellsten Versionen der Pakete zur Verfügung.</p></div><div class=paragraph><p>Um vom Quarterly auf Latest zu wechseln, führen Sie die folgenden Befehle aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/pkg/FreeBSD.conf /usr/local/etc/pkg/repos/FreeBSD.conf</span></code></pre></div></div><div class=paragraph><p>Bearbeiten Sie die Datei <span class=filename>/usr/local/etc/pkg/FreeBSD.conf</span> und ändern Sie in der <code>url:</code>-Zeile die Zeichenkette <em>quarterly</em> in <em>latest</em>.</p></div><div class=paragraph><p>Das Ergebnis sollte wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>FreeBSD: {
  url: &#34;pkg+http://pkg.FreeBSD.org/${ABI}/latest&#34;,
  mirror_type: &#34;srv&#34;,
  signature_type: &#34;fingerprints&#34;,
  fingerprints: &#34;/usr/shared/keys/pkg&#34;,
  enabled: yes
}</pre></div></div><div class=paragraph><p>Führen Sie zuletzt diesen Befehl aus, um die neuen Repository-Metadaten zu aktualisieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg update -f</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-pkg-info>6.4.3. Informationen über installierte Pakete anzeigen<a class=anchor href=#pkgng-pkg-info></a></h4><div class=paragraph><p>Informationen über bereits installierte Pakete können mit <code>pkg info</code> angezeigt werden. Dabei wird, wenn keine weiteren Optionen angegeben werden, die Version und die Beschreibung aller Pakete oder eines einzelnen Pakets ausgegeben.</p></div><div class=paragraph><p>Um zu ermitteln welche Version von pkg installiert ist, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg info pkg</span>
pkg-1.1.4_1</code></pre></div></div></div><div class=sect3><h4 id=pkgng-installing-deinstalling>6.4.4. Installation und Deinstallation von Paketen<a class=anchor href=#pkgng-installing-deinstalling></a></h4><div class=paragraph><p>Ein Binärpaket installieren Sie mit dem folgenden Befehl, wobei <em>paketname</em> der Name des zu installierenden Pakets ist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install paketname</span></code></pre></div></div><div class=paragraph><p>Dieser Befehl verwendet Daten aus dem Repository um zu bestimmen, welche Version der Software und welche Abhängigkeiten installiert werden müssen. Um beispielsweise curl zu installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install curl</span>
Updating repository catalogue
/usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

/usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

Updating repository catalogue
The following 2 packages will be installed:

        Installing ca_root_nss: 3.15.1_1
        Installing curl: 7.31.0_1

The installation will require 3 MB more space

0 MB to be downloaded

Proceed with installing packages <span class=o>[</span>y/N]: y
Checking integrity... <span class=k>done</span>
<span class=o>[</span>1/2] Installing ca_root_nss-3.15.1_1... <span class=k>done</span>
<span class=o>[</span>2/2] Installing curl-7.31.0_1... <span class=k>done
</span>Cleaning up cache files...Done</code></pre></div></div><div class=paragraph><p>Das neue Paket und jedes weitere Paket, das als Abhängigkeit installiert wurde, ist in der Liste der installierten Pakete zu sehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg info</span>
ca_root_nss-3.15.1_1     The root certificate bundle from the Mozilla Project
curl-7.31.0_1     Non-interactive tool to get files from FTP, GOPHER, HTTP<span class=o>(</span>S<span class=o>)</span> servers
pkg-1.1.4_6       New generation package manager</code></pre></div></div><div class=paragraph><p>Wird ein Paket nicht mehr benötigt, kann es mit <code>pkg delete</code> entfernt werden. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg delete curl</span>
The following packages will be deleted:

      curl-7.31.0_1

The deletion will free 3 MB

Proceed with deleting packages <span class=o>[</span>y/N]: y
<span class=o>[</span>1/1] Deleting curl-7.31.0_1... <span class=k>done</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-upgrading>6.4.5. Installierte Pakete aktualisieren<a class=anchor href=#pkgng-upgrading></a></h4><div class=paragraph><p>Installierte Pakete können mit diesem Kommando auf die neuesten Versionen aktualisiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg upgrade</span></code></pre></div></div><div class=paragraph><p>Dieses Kommando vergleicht und aktualisiert die installierten Versionen der Pakete mit denen im Repository.</p></div></div><div class=sect3><h4 id=pkgng-auditing>6.4.6. Installierte Pakete auditieren<a class=anchor href=#pkgng-auditing></a></h4><div class=paragraph><p>Regelmäßig werden Sicherheitslücken in Drittanbieter-Software entdeckt. pkg besitzt einen eingebauten Auditing-Mechanismus. Um die auf dem System installierte Software auf Sicherheitslücken zu prüfen, geben Sie folgenden Befehl ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg audit -F</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-autoremove>6.4.7. Automatisches Entfernen unbenutzter Pakete<a class=anchor href=#pkgng-autoremove></a></h4><div class=paragraph><p>Das Entfernen eines Pakets kann möglicherweise Abhängigkeiten hinterlassen, die nicht mehr benötigt werden. Unnötige Pakete, die als Abhängigkeit von anderen Paketen installiert wurden, können automatisch erfasst und entfernt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg autoremove</span>
Packages to be removed:
    ca_root_nss-3.15.1_1

The autoremoval will free 723 kB

Proceed with autoremoval of packages <span class=o>[</span>y/N]: y
Deinstalling ca_root_nss-3.15.1_1... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>Pakete, die als Abhängigkeiten installiert werden, bezeichnet man als <em>automatische</em> Pakete. Nichtautomatische Pakete, also die Pakete, die explizit nicht als Abhängigkeit von einem anderen Paket installiert wurden, können wie folgt angezeigt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg prime-list</span>
nginx
openvpn
<span class=nb>sudo</span></code></pre></div></div><div class=paragraph><p><code>pkg prime-list</code> ist ein Alias-Befehl, der in <span class=filename>/usr/local/etc/pkg.conf</span> definiert ist. Es gibt noch weitere Befehle die Sie verwenden können, um die Paketdatenbank des Systems abzufragen. Beispielsweise kann der Befehl <code>pkg prime-origins</code> benutzt werden, um das ursprüngliche Portverzeichnis der oben gezeigten Liste zu erhalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg prime-origins</span>
www/nginx
security/openvpn
security/sudo</code></pre></div></div><div class=paragraph><p>Diese Liste kann verwendet werden, um alle auf einem System installierten Pakete mit Hilfe von Werkzeugen wie <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/synth/>ports-mgmt/synth</a> neu zu erstellen.</p></div><div class=paragraph><p>Um ein bereits installiertes Paket als automatisches Paket zu kennzeichnen, können Sie folgenden Befehl benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -A 1 devel/cmake</span></code></pre></div></div><div class=paragraph><p>Sobald ein Paket nicht mehr genutzt wird und es als automatisch gekennzeichnet ist, wird es durch <code>pkg autoremove</code> erfasst.</p></div><div class=paragraph><p>Das kennzeichnen eines installierten Pakets als <em>nicht</em> automatisch kann wie folgt gemacht werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -A 0 devel/cmake</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-backup>6.4.8. Wiederherstellung der Paketdatenbank<a class=anchor href=#pkgng-backup></a></h4><div class=paragraph><p>Im Gegensatz zum alten Paketverwaltungssystem beinhaltet pkg einen eigenen Mechanismus zur Sicherung der Paketdatenbank. Diese Funktionalität ist standardmäßig aktiviert.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Um das Skript daran zu hindern, eine Sicherung der Paketdatenbank zu erstellen, muss in <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic.conf&amp;sektion=5&amp;format=html">periodic.conf(5)</a> <code>daily_backup_pkgdb_enable="NO"</code> gesetzt werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um den Inhalt einer früheren Paketdatenbank wiederherzustellen, geben Sie folgendes Kommando ein und ersetzen Sie <em>/path/to/pkg.sql</em> durch den Speicherort der gesicherten Datenbank:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg backup -r /path/to/pkg.sql</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie eine Sicherung wiederherstellen, die von einem <code>periodic</code> Skript erstellt wurde, müssen Sie diese zuerst dekomprimieren.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um eine manuelle Sicherung der pkg Paketdatenbank zu erstellen, führen Sie den folgenden Befehl aus, und ersetzen Sie <em>/path/to/pkg.sql</em> durch einen geeigneten Dateinamen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg backup -d /path/to/pkg.sql</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-clean>6.4.9. Alte Pakete entfernen<a class=anchor href=#pkgng-clean></a></h4><div class=paragraph><p>Standardmäßig speichert pkg Pakete in einem Cache-Verzeichnis, welches in <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a> in der Variablen <code>PKG_CACHEDIR</code> definiert wird. Nur Kopien der neusten installierten Pakete werden beibehalten. Ältere Versionen von pkg haben alle Pakete aufbewahrt. Um diese veralteten Pakete zu entfernen, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg clean</span></code></pre></div></div><div class=paragraph><p>Um alle Pakte aus dem Cache-Verzeichnis zu löschen, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg clean -a</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-set>6.4.10. Manipulation der Paket-Metadaten<a class=anchor href=#pkgng-set></a></h4><div class=paragraph><p>Bei Software aus der FreeBSD Ports-Sammlung kann es vorkommen, dass die Hauptversionsnummer geändert wird. Dafür hat pkg ein eingebautes Kommando, um die Quelle eines Pakets zu aktualisieren. Dies ist nützlich, wenn zum Beispiel <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a> zu <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php53/>lang/php53</a> umbenannt wurde, damit <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a> jetzt die Version <code>5.4</code> integrieren kann.</p></div><div class=paragraph><p>Um die Quelle des Pakets für das obige Beispiel zu ändern, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o lang/php5:lang/php53</span></code></pre></div></div><div class=paragraph><p>Ein weiteres Beispiel: Um <a class=package href=https://cgit.freebsd.org/ports/tree/lang/ruby18/>lang/ruby18</a> auf <a class=package href=https://cgit.freebsd.org/ports/tree/lang/ruby19/>lang/ruby19</a> zu aktualisieren, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o lang/ruby18:lang/ruby19</span></code></pre></div></div><div class=paragraph><p>In diesem letzten Beispiel wird die Quelle der Bibliotheken von <span class=filename>libglut</span> von <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/libglut/>graphics/libglut</a> auf <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/freeglut/>graphics/freeglut</a> geändert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o graphics/libglut:graphics/freeglut</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bei einem Wechsel der Paketquelle ist es notwendig, die Pakete neu zu installieren, welche von dem Paket abhängig sind, das seine Paketquelle geändert hat. Um eine Neuinstallation von abhängigen Paketen zu erzwingen, führen Sie folgenden Befehl aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install -Rf graphics/freeglut</span></code></pre></div></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=ports-using>6.5. Benutzen der Ports-Sammlung<a class=anchor href=#ports-using></a></h3><div class=paragraph><p>Die Ports-Sammlung ist eine Reihe von <span class=filename>Makefile</span>s, Patches und Beschreibungen. Die Dateien für den Bau und die Installation von einzelnen Anwendungen unter FreeBSD werden als <em>Port</em> bezeichnet.</p></div><div class=paragraph><p>In der Voreinstellung wird die Ports-Sammlung im Verzeichnis <span class=filename>/usr/ports</span> gespeichert.</p></div><div class=paragraph><p>Bevor eine Anwendung aus den Ports erstellt werden kann, muss zuerst die Ports-Sammlung installiert werden. Wenn dies nicht bereits bei der Installation von FreeBSD geschehen ist, benutzen Sie eine der beiden Methoden um sie zu installieren:</p></div><div id=ports-using-portsnap-method class="sidebarblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Installation mit Portsnap</strong></p></div><div class=paragraph><p>FreeBSDs Basissystem enthält mit Portsnap ein schnelles und benutzerfreundliches Werkzeug zur Installation der Ports-Sammlung und die bevorzugte Wahl für die meisten Benutzer, die noch nicht FreeBSD-CURRENT benutzen. Dieses Programm stellt eine Verbindung zu einem FreeBSD-Server her, überprüft den gesicherten Schlüssel und lädt eine aktuelle Kopie der Ports-Sammlung herunter. Der Schlüssel wird benötigt, um die Integrität der heruntergeladenen Dateien zu untersuchen.</p></div><div class="olist arabic"><ol class=arabic><li><p>Laden Sie einen komprimierten Snapshot der Ports-Sammlung in <span class=filename>/var/db/portsnap</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span></code></pre></div></div></li><li><p>Wenn Sie Portsnap das erste Mal verwenden, müssen Sie den Snapshot nach <span class=filename>/usr/ports</span> extrahieren:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap extract</span></code></pre></div></div></li><li><p>Nach dem ersten Einsatz von Portsnap, kann <span class=filename>/usr/ports</span> wie folgt aktualisiert werden:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span>
<span class=c># portsnap update</span></code></pre></div></div><div class=paragraph><p>Bei der Verwendung von <code>fetch</code> können die <code>extract</code> oder <code>update</code> Operationen nacheinander ausgeführt werden, etwa so:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch update</span></code></pre></div></div></li></ol></div></div></div><div id=ports-using-subversion-method class="sidebarblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Installation mit Subversion</strong></p></div><div class=paragraph><p>Wird mehr Kontrolle über die Ports-Sammlung benötigt, oder wenn die lokalen Änderungen beibehalten werden sollen, oder Sie FreeBSD-CURRENT benutzen, kann Subversion benutzt werden, um die Ports-Sammlung zu laden. Lesen Sie <a href=https://docs.freebsd.org/en/articles/committers-guide/#subversion-primer>den Subversion Primer</a> für eine detaillierte Beschreibung von Subversion.</p></div><div class="olist arabic"><ol class=arabic><li><p>Subversion muss installiert sein, bevor die Ports-Sammlung geladen werden kann. Ist eine lokale Kopie der Ports-Sammlung bereits vorhanden, installieren Sie Subversion wie folgt:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/devel/subversion</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Wenn keine lokale Kopie der Ports-Sammlung vorhanden ist, oder pkg zur Verwaltung von Paketen benutzt wird, kann Subversion als Paket installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install subversion</span></code></pre></div></div></li><li><p>Laden Sie eine Kopie der Ports-Sammlung:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/ports/head /usr/ports</span></code></pre></div></div></li><li><p>Nach dem erstmaligen checkout mit Subversion kann <span class=filename>/usr/ports</span> wie folgt aktualisiert werden:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update /usr/ports</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Die Ports-Sammlung enthält eine Reihe von Verzeichnissen, die jeweils eine Softwarekategorie repräsentieren. Jede Kategorie hat für jede einzelne Anwendung ein weiteres Unterverzeichnis. Jedes Unterverzeichnis enthält Dateien, die FreeBSD sagen, wie ein Programm kompiliert und installiert werden muss. Diese Dateien werden auch Port-"Gerüst" genannt. Jedes Port-"Gerüst" beinhaltet die folgenden Dateien und Verzeichnisse:</p></div><div class=ulist><ul><li><p><span class=filename>Makefile</span>: enthält Anweisungen, die spezifizieren, wie die Anwendung kompiliert wird und wohin die Komponenten installiert werden sollten.</p></li><li><p><span class=filename>distinfo</span>: enthält die Namen und die Prüfsummen der Dateien, die heruntergeladen werden müssen, um den Port zu bauen.</p></li><li><p><span class=filename>files</span>: dieses Verzeichnis enthält Patches, welche das Übersetzen und Installieren der Anwendung unter FreeBSD ermöglichen. Zudem können noch weitere Dateien, die für die Übersetzung des Ports verwendet werden, enthalten sein.</p></li><li><p><span class=filename>pkg-descr</span>: enthält eine ausführlichere Beschreibung der Anwendung.</p></li><li><p><span class=filename>pkg-plist</span>: eine Liste aller Dateien, die durch diesen Port installiert werden. Außerdem sind hier Informationen enthalten, die zum Entfernen des Ports benötigt werden.</p></li></ul></div><div class=paragraph><p>Einige Ports beinhalten noch <span class=filename>pkg-message</span> oder weitere Dateien, die vom Port-System benutzt werden, um spezielle Situationen zu handhaben. Wenn Sie mehr über diese Dateien oder das Port-System erfahren wollen, lesen Sie das <a href=https://docs.freebsd.org/de/porters-handbook/>FreeBSD Porter’s Handbook</a>.</p></div><div class=paragraph><p>Ein Port enthält nicht den eigentlichen Quellcode, der auch als "Distfile" bekannt ist. Der heruntergeladene Quellcode wird automatisch nach <span class=filename>/usr/ports/distfiles</span> extrahiert.</p></div><div class=sect3><h4 id=ports-skeleton>6.5.1. Ports installieren<a class=anchor href=#ports-skeleton></a></h4><div class=paragraph><p>Dieser Abschnitt beschreibt die grundlegende Benutzung der Ports-Sammlung, um Software zu installieren oder zu deinstallieren. Eine ausführliche Beschreibung der einzelnen <code>make</code>-Targets finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Stellen Sie sicher, dass die Ports-Sammlung aktuell ist, bevor Sie einen Port kompilieren. Informieren Sie sich vorher zusätzlich unter <a href=https://vuxml.FreeBSD.org/ class=bare>https://vuxml.FreeBSD.org/</a> über mögliche Sicherheitsprobleme des zu installierenden Ports. Alternativ können Sie <code>pkg audit -F</code> ausführen, bevor Sie einen neuen Port installieren. Die täglich laufende Sicherheitsprüfung des Systems aktualisiert ebenfalls die Datenbank und prüft installierte Anwendungen auf vorhandene Sicherheitsprobleme. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-audit&amp;sektion=8&amp;format=html">pkg-audit(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Benutzung der Ports-Sammlung setzt eine funktionierende Internetverbindung und Superuser-Rechte voraus.</p></div><div class=paragraph><p>Um einen Port zu installieren, wechseln Sie in das Verzeichnis des Ports, den Sie installieren möchten. Geben Sie dann <code>make install</code> am Prompt ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span>
<span class=c># make install</span>
<span class=o>&gt;&gt;</span> lsof_4.88D.freebsd.tar.gz doesn<span class=s1>&#39;t seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.88
...
[Ausgabe des Auspackens weggelassen]
...
&gt;&gt; Checksum OK for lsof_4.88D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.88.d,8
===&gt;  Applying FreeBSD patches for lsof-4.88.d,8
===&gt;  Configuring for lsof-4.88.d,8
...
[configure-Ausgabe weggelassen]
...
===&gt;  Building for lsof-4.88.d,8
...
[Ausgabe der Übersetzung weggelassen]
...
===&gt;  Installing for lsof-4.88.d,8
...
[Ausgabe der Installation weggelassen]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.57
===&gt;   Registering installation for lsof-4.57
===&gt;  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/bin/lsof
#</span></code></pre></div></div><div class=paragraph><p>Da <code>lsof</code> eine Anwendung ist, die mit erhöhten Rechten läuft, wird nach der Installation eine Sicherheitswarnung angezeigt. Sobald die Installation abgeschlossen ist, erscheint wieder der Prompt.</p></div><div class=paragraph><p>Um die Suche nach Kommandos zu beschleunigen, speichern einige Shells eine Liste der verfügbaren Kommandos in den durch die Umgebungsvariable <code>PATH</code> gegebenen Verzeichnissen. Benutzer der <code>tcsh</code> müssen eventuell <code>rehash</code> eintippen, um die neu installierten Kommandos benutzen zu können, ohne den vollständigen Pfad anzugeben. Benutzer der Shell <code>sh</code> müssen stattdessen <code>hash -r</code> eintippen. Weitere Informationen finden Sie in der Dokumentation der jeweiligen Shell.</p></div><div class=paragraph><p>Bei der Installation wird ein Arbeitsverzeichnis erstellt, das alle temporären Dateien enthält, die während des Bauvorgangs benötigt werden. Wenn dieses Verzeichnis nach der Installation entfernt wird, spart dies Plattenplatz und minimiert mögliche Probleme bei der Aktualisierung des Ports auf eine neuere Version:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make clean</span>
<span class=o>===&gt;</span>  Cleaning <span class=k>for </span>lsof-4.88.d,8
<span class=c>#</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sie können zwei Schritte sparen, wenn Sie bei der Kompilierung des Ports gleich <code>make install clean</code> eingeben.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_port_installation_anpassen>6.5.1.1. Port Installation anpassen<a class=anchor href=#_port_installation_anpassen></a></h5><div class=paragraph><p>Einige Ports bieten Optionen, mit denen zusätzliche Funktionen oder Sicherheitsoptionen eingestellt werden können. Beispiele dafür sind <a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/security/gpgme/>security/gpgme</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a>. Wenn ein Port von anderen Ports abhängig ist und diese über zusätzliche Abhängigkeiten und Optionen verfügen, wird mehrmals ein Menü ausgegeben, wo der Benutzer verschiedene Optionen wählen kann. Um dies zu vermeiden und die Konfiguration in einem Stück zu erledigen, wechseln Sie in das Verzeichnis des Ports und geben Sie <code>make config-recursive</code> ein. Führen Sie danach <code>make install [clean]</code> aus, um den Port zu kompilieren und zu installieren.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Bei der Verwendung von <code>config-recursive</code> wird eine Liste von Ports, die konfiguriert werden, vom Target <code>all-depends-list</code> erstellt. Es wird empfohlen, <code>make config-recursive</code> so lange auszuführen, bis alle Optionen der abhängigen Ports definiert sind und keine Optionen und Menüs mehr erscheinen. Damit soll sichergestellt werden, dass alle Optionen konfiguriert wurden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Es gibt diverse Möglichkeiten, dieses Menü nach dem Bau eines Ports erneut aufzurufen, um Optionen zu entfernen, hinzuzufügen oder anzupassen. Sie können beispielsweise mit <code>cd</code> in das Verzeichnis des Ports wechseln und dort <code>make config</code> eingeben. Eine andere Möglichkeit ist <code>make showconfig</code>. Eine weitere Alternative bietet <code>make rmconfig</code>, das alle ursprünglich gewählten Optionen zurücksetzt und es Ihnen dadurch ermöglicht, die Konfiguration erneut zu beginnen. Die eben erwähnten Optionen werden ausführlich in <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a> beschrieben.</p></div><div class=paragraph><p>Die Ports-Sammlung benutzt zum Herunterladen von Dateien <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a>, das diverse Umgebungsvariablen unterstützt. Die Variablen <code>FTP_PASSIVE_MODE</code>, <code>FTP_PROXY</code> und <code>FTP_PASSWORD</code> müssen unter Umständen gesetzt werden, wenn das FreeBSD-System hinter einer Firewall oder einem FTP/HTTP-Proxy arbeitet. Eine vollständige Liste der unterstützten Variablen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a>.</p></div><div class=paragraph><p>Benutzer ohne eine ständige Internet-Verbindung können <code>make fetch</code> im Verzeichnis <span class=filename>/usr/ports</span> ausführen, um die benötigten Dateien herunterzuladen. Es ist auch möglich, <code>make fetch</code> nur in einem Teil des Baums, wie <span class=filename>/usr/ports/net</span>, aufzurufen. Die Dateien von allen abhängigen Ports werden mit diesem Kommando allerdings nicht heruntergeladen. Wenn Sie diese Dateien ebenfalls herunterladen wollen, benutzen Sie stattdessen <code>make fetch-recursive</code>.</p></div><div class=paragraph><p>In einigen seltenen Fällen ist es erforderlich, die benötigten Dateien von einem anderen Ort als den im Port definierten <code>MASTER_SITES</code> herunterzuladen. Sie können <code>MASTER_SITES</code> mit dem folgenden Kommando überschreiben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/directory</span>
<span class=c># make MASTER_SITE_OVERRIDE= \</span>
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch</code></pre></div></div><div class=paragraph><p>Die Variablen <code>WRKDIRPREFIX</code> und <code>PREFIX</code> überschreiben das voreingestellte Bau- und Zielverzeichnis. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=/usr/home/example/ports install</span></code></pre></div></div><div class=paragraph><p>Dieses Kommando baut den Port unter <span class=filename>/usr/home/example/ports</span> und installiert ihn unter <span class=filename>/usr/local</span>.</p></div><div class=paragraph><p>Die Variable <code>PREFIX</code> legt das Installations-Verzeichnis fest:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make PREFIX=/usr/home/example/local install</span></code></pre></div></div><div class=paragraph><p>In diesem Beispiel wird der Port unter <span class=filename>/usr/ports</span> gebaut und nach <span class=filename>/usr/home/example/local</span> installiert.</p></div><div class=paragraph><p>Sie können beide Variablen auch zusammen benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=../ports PREFIX=../local install</span></code></pre></div></div><div class=paragraph><p>Alternativ können diese Variablen auch als Umgebungsvariablen gesetzt werden. In der Manualpage Ihrer Shell finden Sie Anweisungen, wie Umgebungsvariablen gesetzt werden.</p></div></div></div><div class=sect3><h4 id=ports-removing>6.5.2. Entfernen installierter Ports<a class=anchor href=#ports-removing></a></h4><div class=paragraph><p>Installierte Ports können mit <code>pkg delete</code> wieder deinstalliert werden. Beispiele für dieses Kommando finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-delete&amp;sektion=8&amp;format=html">pkg-delete(8)</a>.</p></div><div class=paragraph><p>Alternativ kann <code>make deinstall</code> im Verzeichnis des Ports aufgerufen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span>
<span class=c># make deinstall</span>
<span class=o>===&gt;</span>  Deinstalling <span class=k>for </span>sysutils/lsof
<span class=o>===&gt;</span>   Deinstalling
Deinstallation has been requested <span class=k>for </span>the following 1 packages:

        lsof-4.88.d,8

Thee deinstallation will free 229 kB
<span class=o>[</span>1/1] Deleting lsof-4.88.d,8... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>Es wird empfohlen die Nachrichten zu lesen, die ausgegeben werden, wenn ein Port deinstalliert wird. Wenn der Port noch Anwendungen hat, die von ihm abhängig sind, werdenn diese am Bildschirm angezeigt, aber die Deinstallation wird forgesetzt. In solchen Fällen ist es besser, die Anwendung neu zu installieren, um fehlende Abhängigkeiten zu vermeiden.</p></div></div><div class=sect3><h4 id=ports-upgrading>6.5.3. Ports aktualisieren<a class=anchor href=#ports-upgrading></a></h4><div class=paragraph><p>Im Laufe der Zeit stehen neuere Versionen der Software in der Ports-Sammlung zur Verfügung. In diesem Abschnitt wird beschrieben, wie Sie bestimmen, welche Software aktualisiert werden kann und wie das Upgrade durchzuführen ist.</p></div><div class=paragraph><p>Um festzustellen, ob neuere Versionen der installierten Ports verfügbar sind, stellen Sie sicher, dass die neueste Version der Ports-Sammlung installiert ist. Dies wird in <a href=#ports-using-portsnap-method>"Installation mit Portsnap"</a> und <a href=#ports-using-subversion-method>"Installation mit Subversion"</a> beschrieben. Führen Sie unter FreeBSD 10 und neueren Versionen, bzw. auf Systemen die bereits mit pkg arbeiten, den folgenden Befehl aus, um eine Liste der installierten Ports zu erhalten für die eine aktuelle Version existiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg version -l &#34;&lt;&#34;</span></code></pre></div></div><div class=paragraph><p>Mit FreeBSD 9.<em>X</em> und älteren Versionen kann stattdessen dieser Befehl verwendet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_version -l &#34;&lt;&#34;</span></code></pre></div></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Lesen Sie zuerst <span class=filename>/usr/ports/UPDATING</span>, bevor Sie einen Port aktualisieren. In dieser Datei werden Probleme und zusätzlich durchzuführende Schritte bei der Aktualisierung einzelner Ports beschrieben. Dazu gehören solche Dinge wie geänderte Dateiformate, verschobene Konfigurationsdateien, aber auch Inkompatibilitäten zu einer Vorgängerversion. Notieren Sie sich alle Anweisungen der Ports, die aktualisiert werden müssen. Folgen Sie den Anweisungen, wenn Sie das Upgrade durchführen.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=ports-upgrading-tools>6.5.3.1. Werkzeuge für die Aktualisierung und Verwaltung von Ports<a class=anchor href=#ports-upgrading-tools></a></h5><div class=paragraph><p>Die Ports-Sammlung enthält mehrere Werkzeuge, um die eigentliche Aktualisierung durchzuführen. Jedes hat seine Stärken und Schwächen.</p></div><div class=paragraph><p>Historisch gesehen verwenden die meisten Installationen entweder Portmaster oder Portupgrade. Synth ist eine neuere Alternative.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es bleibt dem Systemadministrator überlassen, welches dieser Werkzeuge für ein bestimmtes System am besten geeignet ist. Es wird empfohlen, die Daten zu sichern, bevor Sie eines dieser Werkzeuge verwenden.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=portmaster>6.5.3.2. Ports mit Portmaster aktualisieren<a class=anchor href=#portmaster></a></h5><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> ist ein sehr kleines Werkzeug zum Aktualisieren von Ports. Es wurde entwickelt, um mit den Werkzeugen aus dem FreeBSD Basissystem zu arbeiten, ohne dabei von anderen Ports oder Datenbanken abhängig zu sein. Sie können das Programm aus der Ports-Sammlung installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portmaster</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Portmaster teilt Ports in vier Kategorien ein:</p></div><div class=ulist><ul><li><p>Root Port: hat keine Abhängigkeiten und andere Ports sind nicht von diesem Port abhängig.</p></li><li><p>Trunk Port: hat keine Abhängigkeiten, aber andere Ports sind von diesem Port abhängig.</p></li><li><p>Branch Port: hat Abhängigkeiten und andere Ports sind von diesem Port abhängig.</p></li><li><p>Leaf Port: hat Abhängigkeiten, aber andere Ports sind nicht von diesem Port abhängig.</p></li></ul></div><div class=paragraph><p>Um eine Liste der installierten Ports anzuzeigen und nach neueren Versionen zu suchen, verwenden Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -L</span>
<span class=o>===&gt;&gt;&gt;</span> Root ports <span class=o>(</span>No dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> ispell-3.2.06_18
<span class=o>===&gt;&gt;&gt;</span> screen-4.0.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: screen-4.0.3_1
<span class=o>===&gt;&gt;&gt;</span> tcpflow-0.21_1
<span class=o>===&gt;&gt;&gt;</span> 7 root ports
...
<span class=o>===&gt;&gt;&gt;</span> Branch ports <span class=o>(</span>Have dependencies, are depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> apache22-2.2.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: apache22-2.2.8
...
<span class=o>===&gt;&gt;&gt;</span> Leaf ports <span class=o>(</span>Have dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> automake-1.9.6_2
<span class=o>===&gt;&gt;&gt;</span> bash-3.1.17
        <span class=o>===&gt;&gt;&gt;</span> New version available: bash-3.2.33
...
<span class=o>===&gt;&gt;&gt;</span> 32 leaf ports

<span class=o>===&gt;&gt;&gt;</span> 137 total installed ports
        <span class=o>===&gt;&gt;&gt;</span> 83 have new versions available</code></pre></div></div><div class=paragraph><p>Um alle installierten Ports zu aktualisieren, verwenden Sie folgenden Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -a</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In der Voreinstellung erzeugt Portmaster eine Sicherheitskopie, bevor ein installierter Port gelöscht wird. Ist die Installation der neuen Version erfolgreich, wird dieses Backup wieder gelöscht. Wollen Sie das Backup lieber manuell löschen, verwenden Sie die Option <code>-b</code> beim Aufruf von Portmaster. Durch die Verwendung von <code>-i</code> wird Portmaster im interaktiven Modus gestartet und fragt bei jedem zu aktualisierenden Port nach, wie weiter vorgegangen werden soll. Viele weitere Optionen stehen zur Verfügung. Lesen Sie die Manualpage von <a href="https://man.freebsd.org/cgi/man.cgi?query=portmaster&amp;sektion=8&amp;format=html">portmaster(8)</a> für weitere Einzelheiten in Bezug auf ihre Nutzung.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Treten während der Aktualisierung Fehler auf, verwenden Sie die Option <code>-f</code>, um alle Ports zu aktualisieren beziehungsweise neu zu bauen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>Portmaster ist auch in der Lage, neue Ports zu installieren, wobei zuvor alle abhängigen Ports aktualisiert werden. Um diese Funktion zu nutzen, geben Sie den Pfad des Ports in der Ports-Sammlung an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster shells/bash</span></code></pre></div></div><div class=paragraph><p>Weitere Informationen über <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> finden Sie in der Beschreibung <span class=filename>pkg-descr</span>.</p></div></div><div class=sect4><h5 id=portupgrade>6.5.3.3. Ports mit Portupgrade aktualisieren<a class=anchor href=#portupgrade></a></h5><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> ist ein weiteres Werkzeug zur Aktualisierung von Ports. Es installiert eine Reihe von Anwendungen, die für die Verwaltung von Ports verwendet werden können. Das Programm ist jedoch von Ruby abhängig. Um den Port zu installieren, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portupgrade</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Durchsuchen Sie vor jedem Update die Liste der installierten Ports mit <code>pkgdb -F</code> und beheben Sie alle gefundenen Probleme.</p></div><div class=paragraph><p>Benutzen Sie <code>portupgrade -a</code>, um automatisch alle veralteten Ports auf dem System zu aktualisieren. Verwenden Sie zusätzlich den Schalter <code>-i</code>, wenn Sie individuell entscheiden wollen, ob ein Port aktualisiert werden soll:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -ai</span></code></pre></div></div><div class=paragraph><p>Um nur eine spezifische Anwendung zu aktualisieren, verwenden Sie <code>portupgrade <em>Paketname</em></code>. Es ist wichtig den Schalter <code>-R</code> zu benutzen, um zuvor alle Ports zu aktualisieren, die von dem gegebenen Anwendung abhängen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -R firefox</span></code></pre></div></div><div class=paragraph><p>Um Pakete anstelle von Ports zu installieren, verwenden Sie den Schalter <code>-P</code>. Mit dieser Option durchsucht Portupgrade die in der Umgebungsvariablen <code>PKG_PATH</code> aufgeführten Verzeichnisse nach Paketen. Sind lokal keine Pakete vorhanden, versucht Portupgrade die Pakete über das Netz herunterzuladen. Gibt es die Pakete weder lokal noch auf entfernten Rechnern, werden die Ports verwendet. Um die Nutzung von Ports gänzlich zu verhindern, benutzen Sie die Option <code>-PP</code>. Portupgrade würde dann abbrechen, falls keine Pakete zur Verfügung stehen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -PP gnome3</span></code></pre></div></div><div class=paragraph><p>Wenn Sie nur die Quelldateien des Ports, oder die Pakete mit <code>-P</code> herunterladen möchten, ohne die Anwendung zu bauen oder zu installieren, geben Sie den Schalter <code>-F</code> an. Weitere Informationen zu den verfügbaren Schaltern finden Sie in der Manualpage von <a href="https://man.freebsd.org/cgi/man.cgi?query=portupgrade&amp;sektion=1&amp;format=html">portupgrade(1)</a>.</p></div><div class=paragraph><p>Weitere Informationen über <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> finden Sie in der Beschreibung <span class=filename>pkg-descr</span>.</p></div></div></div><div class=sect3><h4 id=ports-disk-space>6.5.4. Platzbedarf von Ports<a class=anchor href=#ports-disk-space></a></h4><div class=paragraph><p>Die Nutzung der Ports-Sammlung wird im Laufe der Zeit viel Plattenplatz verschlingen. Nach dem Bau und der Installation eines Ports, wird <code>make clean</code> die temporären Arbeitsverzeichnisse <span class=filename>work</span> aufräumen. Portmaster wird dieses Verzeichnis nach der Installation eines Ports automatisch entfernen (es sei denn, die Option <code>-K</code> wird verwendet). Wenn Portupgrade installiert ist, wird der folgende Befehl alle Arbeitsverzeichnisse der lokalen Ports-Sammlung entfernen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -C</span></code></pre></div></div><div class=paragraph><p>Zusätzlich werden sich im Laufe der Zeit zahlreiche veraltete Distfiles in <span class=filename>/usr/ports/distfiles</span> ansammeln. Mit Portupgrade können alle Distfiles gelöscht werden, die vom keinem Port mehr benötigt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -D</span></code></pre></div></div><div class=paragraph><p>Portupgrade kann alle Distfiles löschen, die von keinem derzeit installierten Port benötigt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -DD</span></code></pre></div></div><div class=paragraph><p>Wenn Portmaster installiert ist, benutzen Sie diesen Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster --clean-distfiles</span></code></pre></div></div><div class=paragraph><p>In der Voreinstellung arbeitet dieses Programm interaktiv und fragt den Benutzer um Bestätigung, bevor ein Distfile gelöscht wird.</p></div><div class=paragraph><p>Zusätzlich zu diesen Kommandos gibt es noch <a class=package href=https://cgit.freebsd.org/ports/tree/port-mgmt/pkg_cutleaves/>port-mgmt/pkg_cutleaves</a>. Dieses Werkzeug automatisiert die Deinstallation von installierten Ports, die nicht weiter benötigt werden.</p></div></div></div><div class=sect2><h3 id=ports-poudriere>6.6. Pakete mit Poudriere bauen<a class=anchor href=#ports-poudriere></a></h3><div class=paragraph><p>Poudriere ist ein unter der BSD-Lizenz stehendes Werkzeug zum Erstellen und Testen von FreeBSD-Paketen. Dieses Programm nutzt FreeBSD Jails, um die Pakete in einer isolierten Umgebung zu bauen. Diese Jails können verwendet werden, um Pakete für andere Versionen von FreeBSD zu bauen, oder um auf einem amd64-System Pakete für i386 zu bauen. Sobald die Pakete gebaut sind, haben sie das gleiche Format wie auf den offiziellen Spiegeln. Die Pakete können dann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> oder anderen Paketverwaltungswerkzeugen benutzt werden.</p></div><div class=paragraph><p>Poudriere wird über das Paket oder den Port <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a> installiert. Die Installation beinhaltet eine Beispielkonfiguration in <span class=filename>/usr/local/etc/poudriere.conf.sample</span>. Kopieren Sie diese Datei nach <span class=filename>/usr/local/etc/poudriere.conf</span>. Bearbeiten Sie dann die kopierte Datei, um die Konfiguration anzupassen.</p></div><div class=paragraph><p>Obwohl ZFS für poudriere nicht zwingend erforderlich ist, so hat die Nutzung doch einige Vorteile. Wird ZFS eingesetzt, muss in <span class=filename>/usr/local/etc/poudriere.conf</span> die Variable <code>ZPOOL</code> definiert, und die Variable <code>FREEBSD_HOST</code> auf einen nahe gelegenen Spiegel gesetzt werden. Die Definition von <code>CCACHE_DIR</code> erlaubt die Verwendung von <a class=package href=https://cgit.freebsd.org/ports/tree/devel/ccache/>devel/ccache</a>, um die Bauzeit für häufig kompilierten Code verkürzen. Es kann vorteilhaft sein, die poudriere-Datasets in einem separaten Verzeichnis auf <span class=filename>/poudriere</span> einzuhängen. Die Werte der anderen Konfigurationsvariablen sind in der Regel angemessen und brauchen nicht geändert werden.</p></div><div class=paragraph><p>Die Anzahl der Kerne im Prozessor wird verwendet um zu bestimmen, wie viele Bauprozesse parallel ausgeführt werden. Stellen Sie ausreichend virtuellen Speicher bereit, entweder in Form von RAM oder als Swap-Speicher. Ist der virtuelle Speicher aufgebraucht, bricht der Bauprozess ab und die Jails stürzen ab, was zu seltsamen Fehlermeldungen führt.</p></div><div class=sect3><h4 id=poudriere-initialization>6.6.1. Jails und Ports-Sammlung initialisieren<a class=anchor href=#poudriere-initialization></a></h4><div class=paragraph><p>Nach der Konfiguration muss poudriere initialisiert werden, damit es eine Jail mit der benötigten Ports-Sammlung startet. Geben Sie mit <code>-j</code> den Namen der Jail und mit <code>-v</code> die gewünschte FreeBSD-Version an. Auf FreeBSD/amd64-Systemen kann die Architektur mit dem Schalter <code>-a</code> und <code>i386</code> oder <code>amd64</code> gesetzt werden. Der voreingestellte Wert für die Architektur können Sie sich mit <code>uname</code> anzeigen lassen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere jail -c -j 11amd64 -v 11.4-RELEASE</span>
<span class=o>[</span>00:00:00] Creating 11amd64 fs at /poudriere/jails/11amd64... <span class=k>done</span>
<span class=o>[</span>00:00:00] Using pre-distributed MANIFEST <span class=k>for </span>FreeBSD 11.4-RELEASE amd64
<span class=o>[</span>00:00:00] Fetching base <span class=k>for </span>FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/base.txz              125 MB 4110 kBps    31s
<span class=o>[</span>00:00:33] Extracting base... <span class=k>done</span>
<span class=o>[</span>00:00:54] Fetching src <span class=k>for </span>FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/src.txz               154 MB 4178 kBps    38s
<span class=o>[</span>00:01:33] Extracting src... <span class=k>done</span>
<span class=o>[</span>00:02:31] Fetching lib32 <span class=k>for </span>FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/lib32.txz              24 MB 3969 kBps    06s
<span class=o>[</span>00:02:38] Extracting lib32... <span class=k>done</span>
<span class=o>[</span>00:02:42] Cleaning up... <span class=k>done</span>
<span class=o>[</span>00:02:42] Recording filesystem state <span class=k>for </span>clean... <span class=k>done</span>
<span class=o>[</span>00:02:42] Upgrading using ftp
/etc/resolv.conf -&gt; /poudriere/jails/11amd64/etc/resolv.conf
Looking up update.FreeBSD.org mirrors... 3 mirrors found.
Fetching public key from update4.freebsd.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata signature <span class=k>for </span>11.4-RELEASE from update4.freebsd.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata index... <span class=k>done</span><span class=nb>.</span>
Fetching 2 metadata files... <span class=k>done</span><span class=nb>.</span>
Inspecting system... <span class=k>done</span><span class=nb>.</span>
Preparing to download files... <span class=k>done</span><span class=nb>.</span>
Fetching 124 patches.....10....20....30....40....50....60....70....80....90....100....110....120.. <span class=k>done</span><span class=nb>.</span>
Applying patches... <span class=k>done</span><span class=nb>.</span>
Fetching 6 files... <span class=k>done</span><span class=nb>.</span>
The following files will be added as part of updating to
11.4-RELEASE-p1:
/usr/src/contrib/unbound/.github
/usr/src/contrib/unbound/.github/FUNDING.yml
/usr/src/contrib/unbound/contrib/drop2rpz
/usr/src/contrib/unbound/contrib/unbound_portable.service.in
/usr/src/contrib/unbound/services/rpz.c
/usr/src/contrib/unbound/services/rpz.h
/usr/src/lib/libc/tests/gen/spawnp_enoexec.sh
The following files will be updated as part of updating to
11.4-RELEASE-p1:
<span class=o>[</span>…]
Installing updates...Scanning //usr/shared/certs/blacklisted <span class=k>for </span>certificates...
Scanning //usr/shared/certs/trusted <span class=k>for </span>certificates...
 <span class=k>done</span><span class=nb>.</span>
11.4-RELEASE-p1
<span class=o>[</span>00:04:06] Recording filesystem state <span class=k>for </span>clean... <span class=k>done</span>
<span class=o>[</span>00:04:07] Jail 11amd64 11.4-RELEASE-p1 amd64 is ready to be used</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere ports -c -p local -m svn+https</span>
<span class=o>[</span>00:00:00] Creating <span class=nb>local </span>fs at /poudriere/ports/local... <span class=k>done</span>
<span class=o>[</span>00:00:00] Checking out the ports tree... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>poudriere kann auf einem einzelnen Rechner Ports mit mehreren Konfigurationen bauen, in mehreren Jails und aus unterschiedlichen Ports-Sammlungen. Spezifische Konfigurationen für diese Kombinationen werden <em>Sets</em> genannt. Lesen Sie den Abschnitt CUSTOMIZATION in <a href="https://man.freebsd.org/cgi/man.cgi?query=poudriere&amp;sektion=8&amp;format=html">poudriere(8)</a> für weitere Einzelheiten nach der Installation von <a class=package href=https://cgit.freebsd.org/ports/tree/port-mgmt/poudriere/>port-mgmt/poudriere</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere-devel/>ports-mgmt/poudriere-devel</a>.</p></div><div class=paragraph><p>Die hier gezeigte Konfiguration verwendet eine einzelne Jail-, Port- und Set-spezifische <span class=filename>make.conf</span> in <span class=filename>/usr/local/etc/poudriere.d</span>. Der verwendete Dateiname in diesem Beispiel wird aus einer Kombination von Jailnamen, Portnamen und Setnamen zusammen gesetzt: <span class=filename>11amd64-local-workstation-make.conf</span>. Die <span class=filename>make.conf</span> des Systems und diese neue Datei werden verwendet, um die <span class=filename>make.conf</span> für die Jail zu erzeugen.</p></div><div class=paragraph><p>Die zu bauenden Pakete werden in <span class=filename>11amd64-local-workstation-pkglist</span> eingetragen:</p></div><div class="literalblock programlisting"><div class=content><pre>editors/emacs
devel/git
ports-mgmt/pkg
...</pre></div></div><div class=paragraph><p>Die Optionen und Abhängigkeiten für die Ports werden wie folgt konfiguriert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere options -j 11amd64 -p local -z workstation -f 11amd64-local-workstation-pkglist</span></code></pre></div></div><div class=paragraph><p>Schließlich werden die Pakete gebaut und ein Paket-Repository erstellt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere bulk -j 11amd64 -p local -z workstation -f 11amd64-local-workstation-pkglist</span></code></pre></div></div><div class=paragraph><p>Während der Ausführung zeigt <span class=keyseq><kbd>Ctrl</kbd>+<kbd>t</kbd></span> den aktuellen Status des Baus an. Poudriere speichert zudem Dateien in <span class=filename>/poudriere/logs/bulk/jailname</span>. Diese Dateien kann ein Webserver nutzen, um Informationen über den Bau anzuzeigen.</p></div><div class=paragraph><p>Nach der Fertigstellung stehen die Pakete im poudriere Repository für die Installation zur Verfügung.</p></div><div class=paragraph><p>Weitere Informationen zu poudriere finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=poudriere&amp;sektion=8&amp;format=html">poudriere(8)</a> und unter <a href=https://github.com/freebsd/poudriere/wiki class=bare>https://github.com/freebsd/poudriere/wiki</a>.</p></div></div><div class=sect3><h4 id=_konfiguration_des_pkg_clients_für_das_poudriere_repository>6.6.2. Konfiguration des pkg-Clients für das Poudriere Repository<a class=anchor href=#_konfiguration_des_pkg_clients_für_das_poudriere_repository></a></h4><div class=paragraph><p>Obwohl es möglich ist ein eigenes Repository zusammen mit dem offiziellen Repository zu nutzen, ist es manchmal sinnvoll das offizielle Repository zu deaktivieren. Dazu wird eine Konfigurationsdatei erstellt, welche die offizielle Konfigurationsdatei überschreibt. Erzeugen Sie dazu <span class=filename>/usr/local/etc/pkg/repos/FreeBSD.conf</span> mit dem folgenden Inhalt:</p></div><div class="literalblock programlisting"><div class=content><pre>FreeBSD: {
        enabled: no
}</pre></div></div><div class=paragraph><p>Am einfachsten ist es, das poudriere Repository über HTTP zur Verfügung zu stellen. Setzen Sie einen Webserver auf, der die Dateien des Paketverzeichnisses ausliefert, zum Beispiel <span class=filename>/usr/local/poudriere/data/packages/11amd64</span>. <span class=filename>11amd64</span> bezeichnet dabei den Namen des Baus.</p></div><div class=paragraph><p>Wenn die URL des Paket Repositories <code><a href=http://pkg.example.com/11amd64 class=bare>http://pkg.example.com/11amd64</a></code> ist, dann sollte die Konfiguration des Repositories in <span class=filename>/usr/local/etc/pkg/repos/custom.conf</span> wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>custom: {
	url: &#34;http://pkg.example.com/11amd64&#34;,
	enabled: yes,
}</pre></div></div></div></div><div class=sect2><h3 id=ports-nextsteps>6.7. Nach der Installation<a class=anchor href=#ports-nextsteps></a></h3><div class=paragraph><p>Unabhängig davon, ob die Software aus einem binären Paket oder aus einem Port installiert wird, benötigen die meisten Anwendungen von Drittanbietern ein gewisses Maß an Konfiguration, nachdem sie installiert wurden. Die folgenden Kommandos und Speicherorte helfen Ihnen dabei festzustellen, was mit der Anwendung zusammen installiert wurde.</p></div><div class=ulist><ul><li><p>Die meisten Anwendungen installieren mindestens eine Konfigurationsdatei nach <span class=filename>/usr/local/etc</span>. Falls die Anwendung viele Konfigurationsdateien enthält, wird ein Unterverzeichnis erstellt um die Dateien zu speichern. Oft werden die Konfigurationsdateien mit einem Suffix wie beispielsweise <span class=filename>.sample</span> installiert. Die Konfigurationsdateien sollten überprüft und ggf. bearbeitet werden, um die Anforderungen des Systems zu erfüllen. Um eine Konfigurationsdatei zu bearbeiten, kopieren Sie diese zunächst ohne die Erweiterung <span class=filename>.sample</span>.</p></li><li><p>Wenn die Anwendung Dokumentation zur Verfügung stellt, wird diese nach <span class=filename>/usr/local/shared/doc</span> installiert. Viele Anwendungen installieren auch Manualpages. Diese Dokumentation sollten Sie lesen, bevor Sie fortfahren.</p></li><li><p>Einige Anwendungen laufen als Dienst und müssen vor dem ersten Start in <span class=filename>/etc/rc.conf</span> eingetragen werden. Diese Anwendungen installieren meist ein Skript in <span class=filename>/usr/local/etc/rc.d</span>. Weitere Informationen finden Sie im <a href=./#configtuning-starting-services>Start von Diensten</a>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In der Voreinstellung führen Anwendungen weder ihr Startskript bei der Installation aus, noch führen sie ihr Stopskript während der Deinstallation aus. Diese Entscheidung bleibt dem einzelnen Systemadministrator überlassen.</p></div></td></tr></tbody></table></div></li><li><p>Benutzer der <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> sollten <code>rehash</code> ausführen, um die neu installierten Programme nutzen zu können.</p></li><li><p>Benutzen Sie <code>pkg info</code>, um die Dateien, Manualpages und Binaries zu ermitteln, die mit der Anwendung installiert wurden.</p></li></ul></div></div><div class=sect2><h3 id=ports-broken>6.8. Kaputte Ports<a class=anchor href=#ports-broken></a></h3><div class=paragraph><p>Wenn sich ein Port nicht bauen oder installieren lässt, versuchen Sie folgendes:</p></div><div class="olist arabic"><ol class=arabic><li><p>Stellen Sie fest, ob die <a href=https://www.FreeBSD.org/de/support/>Datenbank mit den Problemberichten</a> bereits einen Lösungsvorschlag enthält. Ist dies der Fall, kann die vorgeschlagene Lösung getestet werden.</p></li><li><p>Bitten Sie den Betreuer des Ports um Hilfe. Geben Sie dazu <code>make maintainer</code> ein oder lesen Sie das <span class=filename>Makefile</span> im Verzeichnis des Ports, um an die E-Mail-Adresse zu kommen. Vergessen Sie nicht die Zeile mit <code>$FreeBSD:</code> aus dem <span class=filename>Makefile</span> und die Ausgabe bis zur Fehlermeldung mitzuschicken.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Einige Ports werden nicht von einer Einzelperson, sondern von einer <a href=https://docs.freebsd.org/en/articles/mailing-list-faq/>Mailingliste</a> betreut. Viele (aber nicht alle) dieser Adressen haben die Form <a href=mailto:freebsd-NameDerListe@FreeBSD.org>freebsd-NameDerListe@FreeBSD.org</a>. Denken Sie daran, wenn Sie Ihre Fragen formulieren.</p></div><div class=paragraph><p>Dies gilt insbesondere für Ports, die von <a href=mailto:ports@FreeBSD.org>ports@FreeBSD.org</a> betreut werden. Derartige Ports haben überhaupt keinen Betreuer. Korrekturen und Unterstützung kommen daher nur von Personen, die diese Mailingliste abonniert haben. Gerade in diesem Bereich werden jederzeit zusätzliche freiwillige Helfer benötigt!</p></div></td></tr></tbody></table></div><div class=paragraph><p>Erhalten Sie auf Ihre Anfrage keine Antwort, benutzen Sie Bugzilla, um einen Problembericht zu erstellen. Bevor Sie einen solchen Bericht erstellen, lesen Sie den Artikel <a href=https://docs.freebsd.org/en/articles/problem-reports/>Writing FreeBSD Problem Reports</a>.</p></div></li><li><p>Reparieren Sie ihn! Das <a href=https://docs.freebsd.org/de/porters-handbook/>FreeBSD Porter’s Handbook</a> enthält eine detaillierte Beschreibung des Portsystems. Damit sind Sie in der Lage, einen zeitweilig kaputten Port zu reparieren oder einen eigenen Port zu erstellen.</p></li><li><p>Installieren Sie das Paket anstelle des Ports. Anweisungen hierzu finden Sie in <a href=#pkgng-intro>Benutzen von pkg zur Verwaltung von Binärpaketen</a>.</p></li></ol></div></div></div></div><div class=sect1><h2 id=x11>Kapitel 7. Das X-Window-System<a class=anchor href=#x11></a></h2><div class=sectionbody><div class=sect2><h3 id=x11-synopsis>7.1. Übersicht<a class=anchor href=#x11-synopsis></a></h3><div class=paragraph><p>Bei einer Installation von FreeBSD mit bsdinstall wird nicht automatisch eine grafische Benutzeroberfläche installiert. Dieses Kapitel beschreibt die Installation und Konfiguration von Xorg, das eine grafische Umgebung über das quelloffene X-Window-System zur Verfügung stellt. Weiterhin wird beschrieben, wie Sie eine Desktop-Umgebung oder einen Window Manager finden und installieren können.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Benutzer die eine Installationsmethode bevorzugen, welche automatisch Xorg konfiguriert, sollten sich <a href=https://www.furybsd.org>FuryBSD</a>, <a href=https://ghostbsd.org>GhostBSD</a> oder <a href=https://www.midnightbsd.org>MidnightBSD</a> ansehen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Weitere Informationen über Video-Hardware, die von Xorg unterstützt wird, finden Sie auf der <a href=http://www.x.org/>x.org</a> Webseite.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</p></div><div class=ulist><ul><li><p>Die Komponenten des X-Window-Systems und ihr Zusammenspiel kennen.</p></li><li><p>Wissen, wie Xorg installiert und konfiguriert wird.</p></li><li><p>Wissen, wie verschiedene Window-Manager und Desktop-Umgebungen installiert und konfiguriert werden.</p></li><li><p>Wissen, wie TrueType®-Schriftarten mit Xorg benutzt werden.</p></li><li><p>Wissen, wie Sie die grafische Anmeldung (XDM) einrichten.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie</p></div><div class=ulist><ul><li><p>Wissen, wie Sie Software Dritter, wie in <a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a> beschrieben, installieren.</p></li></ul></div></div><div class=sect2><h3 id=x-understanding>7.2. Terminologie<a class=anchor href=#x-understanding></a></h3><div class=paragraph><p>Obwohl es nicht nötig ist, alle Details der verschiedenen Komponenten des X Window Systems und deren Zusammenspiel zu kennen, kann es trotzdem nützlich sein die Grundlagen dieser Komponenten zu verstehen:</p></div><div class=dlist><dl><dt class=hdlist1>X-Server</dt><dd><p>X wurde von Anfang an netzwerktransparent entworfen und verwendet ein "Client-Server-Modell". In diesem Modell läuft der "X-Server" auf dem Rechner, an dem die Tastatur, der Bildschirm und die Maus angeschlossen ist. Der Server ist für Dinge wie die Verwaltung des Bildschirms und die Verarbeitung von Tastatur- und Maus-Eingaben sowie anderer Ein- und Ausgabegeräte, wie beispielsweise ein Tablet oder ein Videoprojektor, verantwortlich. Dieses Modell verwirrt viele Leute, die erwarten, dass der "X-Server" der leistungsstarke Rechner im Maschinenraum und der "X-Client" ihr Arbeitsplatzrechner ist.</p></dd><dt class=hdlist1>X-Client</dt><dd><p>Jede X-Anwendung, wie beispielsweise XTerm oder Firefox ist ein "X-Client". Der Client sendet dem Server Nachrichten wie "Zeichne an diesen Koordinaten ein Fenster" und der Server sendet dem Client Nachrichten der Art "Der Benutzer hat gerade den Ok-Knopf gedrückt".</p><div class=paragraph><p>In kleinen Umgebungen laufen der X-Server und die X-Clients auf demselben Rechner. Es ist auch möglich, den X-Server auf einem weniger leistungsfähigen Rechner laufen zu lassen und die X-Anwendungen auf einem leistungsfähigeren Rechner zu betreiben. In diesem Fall kommunizieren der X-Server und die X-Clients über das Netzwerk.</p></div></dd><dt class=hdlist1>Window-Manager</dt><dd><p>X schreibt nicht vor, wie Fenster auf dem Bildschirm auszusehen haben, wie sie mit der Maus zu verschieben sind, welche Tastenkombinationen benutzt werden sollen um zwischen den Fenstern zu wechseln, wie die Fensterrahmen aussehen, oder ob diese Schaltflächen zum schließen haben. Stattdessen gibt X die Verantwortung für all diese Sachen an eine separate <em>Window-Manager</em> Anwendung ab. Es stehen <a href=http://www.xwinman.org/>zahlreiche Window-Manager</a> zur Verfügung. Jeder Window-Manager bietet ein anderes Erscheinungsbild: einige unterstützen virtuelle Bildschirme, andere erlauben Tastenkombinationen zur Verwaltung des Bildschirms. Einige besitzen eine "Start" Schaltfläche und in manchen lässt sich das Aussehen und Verhalten der Anwendung über Themes beliebig einstellen. Window-Manager stehen in der Kategorie <span class=filename>x11-wm</span> der Ports-Sammlung zur Verfügung.</p><div class=paragraph><p>Jeder Window-Manager wird unterschiedlich konfiguriert. Einige erwarten eine manuell erstellte Konfigurationsdatei, während andere ein grafisches Werkzeug für die meisten Konfigurationsarbeiten anbieten.</p></div></dd><dt class=hdlist1>Desktop-Umgebungen</dt><dd><p>KDE und GNOME werden als Desktop-Umgebungen bezeichnet, da sie eine ganze Reihe von Anwendungen für typische Desktop-Aufgaben enthalten. Dazu zählen beispielsweise Office-Pakete, Webbrowser und Spiele.</p></dd><dt class=hdlist1>Fokus</dt><dd><p>Der Window-Manager ist für die Methode verantwortlich, mit der ein Fenster den Fokus bekommt. Jedes System, das Fenster verwendet muss entscheiden, wie ein Fenster aktiviert wird, damit es Eingaben empfangen kann. Das aktive Fenster sollte zudem sichtbar gekennzeichnet werden.</p><div class=paragraph><p>Eine Methode wird "click-to-focus" genannt. Ein Fenster wird aktiv, wenn es mit der Maus angeklickt wird. Eine weitere Methode ist "focus-follows-mouse". Hier hat liegt der Fokus auf dem Fenster, auf dem sich der Mauszeiger befindet. Wird der Mauszeiger in ein anderes Fenster bewegt, so erhält dieses Fenster den Fokus. Eine dritte Methode ist "sloppy-focus". Hier wechselt der Fokus nur dann, wenn sich der Mauszeiger in ein neues Fenster bewegt und nicht, wenn er das aktive Fenster verlässt. Ist der Mauszeiger auf der Desktop Oberfläche, so bleibt der Fokus auf dem zuletzt verwendeten Fenster. Bei der Methode "click-to-focus" wird das aktive Fenster durch einen Mausklick festgelegt. Dabei kann das Fenster vor alle anderen Fenster gesetzt werden. Alle Eingaben werden dann, unabhängig von der Position des Mauszeigers, dem aktiven Fenster zugeordnet.</p></div><div class=paragraph><p>Die verschiedenen Window-Manager unterstützen noch andere Methoden. Alle unterstützen jedoch "click-to-focus" und die meisten von ihnen auch die anderen Methoden. Lesen Sie die Dokumentation des Window-Managers um festzustellen, welche Methoden zur Verfügung stehen.</p></div></dd><dt class=hdlist1>Widgets</dt><dd><p><em>Widget</em> bezeichnet Objekte, die in irgendeiner Weise geklickt oder manipuliert werden können. Dazu gehören buttons (Schaltflächen), check buttons (Schaltfläche für Mehrfachauswahlen), radio buttions (Schaltfläche für Einfachauswahlen), Icons und Auswahllisten. Eine Widget-Sammlung ist eine Reihe von Widgets, die verwendet werden um grafische Anwendungen zu erstellen. Es gibt mehrere populäre Widget-Sammlungen, einschließlich Qt, das von KDE benutzt wird, und GTK+, das von GNOME benutzt wird. Als Folge dessen, haben Anwendungen einen bestimmten look and feel, je nachdem welche Widget-Sammlung benutzt wurde, um die Anwendung zu erstellen.</p></dd></dl></div></div><div class=sect2><h3 id=x-install>7.3. Xorg installieren<a class=anchor href=#x-install></a></h3><div class=paragraph><p>In FreeBSD kann Xorg als Paket oder Port installiert werden.</p></div><div class=paragraph><p>Die Installation des Pakets ist zwar schneller, dafür können weniger Optionen angepasst werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xorg</span></code></pre></div></div><div class=paragraph><p>Die nachstehenden Kommandos bauen und installieren Xorg aus der Ports-Sammlung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/xorg</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Bei beiden Vorgehensweisen wird ein vollständiges Xorg-System installiert. Für die meisten Anwender ist die Installation des Binärpakets die bessere Option.</p></div><div class=paragraph><p>Eine kleinere Version des Xorg-Systems für erfahrene Anwender ist mit <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg-minimal/>x11/xorg-minimal</a> verfügbar. Die meisten Dokumente, Bibliotheken und Anwendungen werden hierbei nicht installiert. Einige Anwendungen erfordern jedoch diese zusätzlichen Komponenten, um ordnungsgemäß zu funktionieren.</p></div></div><div class=sect2><h3 id=x-config>7.4. Xorg konfigurieren<a class=anchor href=#x-config></a></h3><div class=sect3><h4 id=x-config-quick-start>7.4.1. Schnellstartanleitung<a class=anchor href=#x-config-quick-start></a></h4><div class=paragraph><p>Xorg unterstützt die meisten gängigen Grafikkarten, Tastaturen und Zeigegeräte.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Grafikkarten, Monitore und Eingabegeräte werden automatisch erkannt und müssen nicht manuell konfiguriert werden. Erstellen Sie keine <span class=filename>xorg.conf</span> und führen Sie nicht <code>-configure</code> aus, es sei denn, die automatische Konfiguration schlägt fehl.</p></div></td></tr></tbody></table></div><div class="olist arabic procedure"><ol class=arabic><li><p>Wenn Xorg bereits zuvor auf diesem Computer verwendet wurde, verschieben oder entfernen Sie alle vorhandenen Konfigurationsdateien:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /etc/X11/xorg.conf ~/xorg.conf.etc</span>
<span class=c># mv /usr/local/etc/X11/xorg.conf ~/xorg.conf.localetc</span></code></pre></div></div></li><li><p>Fügen Sie die Benutzer, die Xorg verwenden, zur Gruppe <code>video</code> oder <code>wheel</code> hinzu, um die 3D-Beschleunigung zu aktivieren. Um den Benutzer <em>jru</em> in eine der verfügbaren Gruppen hinzuzufügen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod video -m jru || pw groupmod wheel -m jru</span></code></pre></div></div></li><li><p>Der Window-Manager <code>twm</code> ist standardmäßig enthalten und wird auch gestartet, wenn Xorg startet:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% startx</code></pre></div></div></li><li><p>Auf einigen älteren Versionen von FreeBSD muss die Systemkonsole auf <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> eingestellt sein, damit der Wechsel auf die Konsole ordnungsgemäß funktioniert. Informationen dazu finden Sie im <a href=#x-config-kms>Kernel Mode Setting (KMS)</a>.</p></li></ol></div></div><div class=sect3><h4 id=x-config-user-group>7.4.2. Benutzergruppen für Grafikbeschleunigung<a class=anchor href=#x-config-user-group></a></h4><div class=paragraph><p>Um die 3D-Beschleunigung für Grafikkarten zu ermöglichen, ist der Zugriff auf <span class=filename>/dev/dri</span> notwendig. In der Regel ist es am einfachsten, die Benutzer zur Gruppe <code>video</code> oder <code>wheel</code> hinzuzufügen. In diesem Beispiel wird <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> verwendet, um den Benutzer <em>slurms</em> zu der Gruppe <code>video</code> hinzuzufügen, bzw. zur Gruppe <code>wheel</code>, falls die Gruppe <code>video</code> nicht existiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod video -m slurms || pw groupmod wheel -m slurms</span></code></pre></div></div></div><div class=sect3><h4 id=x-config-kms>7.4.3. Kernel Mode Setting (KMS)<a class=anchor href=#x-config-kms></a></h4><div class=paragraph><p>Wenn der Computer die Anzeige von der Konsole auf eine höhere Bildschirmauflösung für X umstellt, muss der Videoausgabe-Modus eingestellt werden. Neuere Versionen von Xorg verwenden dazu ein System innerhalb des Kernels, um diesen Modus effizienter zu ändern. Ältere Versionen von FreeBSD verwenden dafür <a href="https://man.freebsd.org/cgi/man.cgi?query=sc&amp;sektion=4&amp;format=html">sc(4)</a>, welches jedoch nicht mit dem KMS-System umgehen kann. Das führt dazu, dass nach dem Schließen von X die Konsole leer bleibt, obwohl sie weiterhin funktioniert. Die neuere <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> Konsole vermeidet dieses Problem.</p></div><div class=paragraph><p>Fügen Sie diese Zeile in <span class=filename>/boot/loader.conf</span> ein um <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> zu aktivieren:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.vty=vt</pre></div></div></div><div class=sect3><h4 id=x-config-files>7.4.4. Konfigurationsdateien<a class=anchor href=#x-config-files></a></h4><div class=paragraph><p>Eine manuelle Konfiguration ist in der Regel nicht erforderlich. Bitte erstellen Sie keine manuellen Konfigurationsdateien, es sei denn, die automatische Konfiguration funktioniert nicht.</p></div><div class=sect4><h5 id=x-config-files-directory>7.4.4.1. Verzeichnis<a class=anchor href=#x-config-files-directory></a></h5><div class=paragraph><p>Xorg sucht in verschiedenen Verzeichnissen nach Konfigurationsdateien. Unter FreeBSD ist <span class=filename>/usr/local/etc/X11/</span> das bevorzugte Verzeichnis für diese Dateien. Die Verwendung dieses Verzeichnisses hilft dabei, Anwendungsdateien vom Betriebssystem getrennt zu halten.</p></div><div class=paragraph><p>Das Speichern von Konfigurationsdateien unter <span class=filename>/etc/X11/</span> funktioniert immer noch, allerdings vermischt diese Methode Anwendungsdateien mit Dateien des Basissystems und wird daher nicht empfohlen.</p></div></div><div class=sect4><h5 id=x-config-files-single-or-multiple>7.4.4.2. Einzelne oder mehrere Dateien<a class=anchor href=#x-config-files-single-or-multiple></a></h5><div class=paragraph><p>Anstatt die traditionelle <span class=filename>xorg.conf</span> zu verwenden, ist es einfacher, mehrere Dateien, die jeweils eine bestimmte Einstellung konfigurieren, zu verwenden. Diese Dateien werden im Unterverzeichnis <span class=filename>xorg.conf.d/</span> des Hauptverzeichnisses gespeichert. Der vollständige Pfad ist normalerweise <span class=filename>/usr/local/etc/X11/xorg.conf.d/</span>.</p></div><div class=paragraph><p>Beispiele für diese Dateien werden später in diesem Abschnitt vorgestellt.</p></div><div class=paragraph><p>Die traditionelle, einzelne <span class=filename>xorg.conf</span> funktioniert weiterhin, ist jedoch nicht so übersichtlich und flexibel wie die Verwendung von mehreren Dateien im Unterverzeichnis <span class=filename>xorg.conf.d/</span>.</p></div></div></div><div class=sect3><h4 id=x-config-video-cards>7.4.5. Grafikkarten<a class=anchor href=#x-config-video-cards></a></h4><div class=paragraph><p>Aufgrund von Änderungen in neueren Versionen von FreeBSD ist es nun möglich, Grafiktreiber zu benutzen, die aus der Ports-Sammlung oder als Pakete bereitgestellt werden. Die folgenden Treiber sind mit <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/drm-kmod/>graphics/drm-kmod</a> verfügbar:</p></div><div id=x-config-video-cards-ports class=dlist><dl><dt class=hdlist1>Intel KMS driver</dt><dd><p>2D- und 3D-Beschleunigung wird auf den meisten Intel KMS driver Grafikkarten von Intel® unterstützt.</p><div class=paragraph><p>Name des Treibers: <code>i915kms</code></p></div><div class=paragraph><p>2D- und 3D-Beschleunigung wird auf den meisten älteren Radeon KMS driver Grafikkarten von AMD® unterstützt.</p></div><div class=paragraph><p>Name des Treibers: <code>radeonkms</code></p></div><div class=paragraph><p>2D- und 3D-Beschleunigung wird auf den meisten neueren AMD KMS driver Grafikkarten von AMD® unterstützt.</p></div><div class=paragraph><p>Name des Treibers: <code>amdgpu</code></p></div><div class=paragraph><p>Eine Liste der unterstützten GPUs finden Sie unter <a href=https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units</a> und <a href=https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units</a>.</p></div></dd></dl></div><div id=x-config-video-cards-intel class=dlist><dl><dt class=hdlist1>Intel®</dt><dd><p>3D-Beschleunigung wird von den meisten Intel®-Grafikkarten unterstützt, einschließlich Ivy Bridge (HD Graphics 2500, 4000 und P4000), Iron Lake (HD Graphics) und Sandy Bridge (HD Graphics 2000).</p><div class=paragraph><p>Treibername: <code>intel</code></p></div><div class=paragraph><p>Weitere Informationen finden Sie unter <a href=https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units</a>.</p></div></dd></dl></div><div id=x-config-video-cards-radeon class=dlist><dl><dt class=hdlist1>AMD® Radeon</dt><dd><p>2D- und 3D-Beschleunigung wird von den meisten Radeon-Karten bis zur HD6000-Serie unterstützt.</p><div class=paragraph><p>Treibername: <code>radeon</code></p></div><div class=paragraph><p>Weitere Informationen finden Sie unter <a href=https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units</a>.</p></div></dd></dl></div><div id=x-config-video-cards-nvidia class=dlist><dl><dt class=hdlist1>NVIDIA</dt><dd><p>Verschiedene NVIDIA Treiber sind in der Kategorie <span class=filename>x11</span> der Ports-Sammlung enthalten. Installieren Sie den Treiber, der für die Grafikkarte benötigt wird.</p><div class=paragraph><p>Weitere Informationen finden Sie unter <a href=https://en.wikipedia.org/wiki/List_of_Nvidia_graphics/processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Nvidia_graphics/processing_units</a>.</p></div></dd></dl></div><div id=x-config-video-cards-hybrid class=dlist><dl><dt class=hdlist1>Hybride Kombinationen</dt><dd><p>Einige Notebooks besitzen zusätzlich zum Chipsatz oder Prozessor einen Grafikprozessor. <em>Optimus</em> kombiniert Intel® und NVIDIA Hardware. <em>Umschaltbare Grafik</em> bzw. <em>Hybride Grafik</em> ist eine Kombination aus Intel®, oder AMD® Prozessor mit AMD® Radeon GPU.</p><div class=paragraph><p>Die Implementierungen dieser Hybrid-Grafik-Systeme variieren und Xorg in FreeBSD ist nicht in der Lage, alle Versionen der Hardware zu betreiben.</p></div><div class=paragraph><p>Einige Computer bieten jedoch eine BIOS-Option, um eine der beiden Grafikkarten zu deaktivieren oder den <em>diskreten</em> Modus einzuschalten. Zum Beispiel ist es manchmal möglich, die NVIDIA GPU in einem Optimus-System zu deaktivieren. Intel® Video kann dann mit einem Intel® Treiber verwendet werden.</p></div><div class=paragraph><p>Die BIOS-Einstellungen sind abhängig vom Modell des Computers. In manchen Situationen können beide GPUs aktiviert bleiben. Um solch ein System lauffähig zu machen genügt es bereits, nur die Haupt-GPU im Abschnitt <code>Device</code> der Konfigurationsdatei zu setzen.</p></div></dd></dl></div><div id=x-config-video-cards-other class=dlist><dl><dt class=hdlist1>Andere Grafikkarten</dt><dd><p>Treiber für weniger gebräuchliche Grafikkarten finden Sie in der Kategorie <span class=filename>x11-drivers</span> der Ports-Sammlung.</p><div class=paragraph><p>Karten, die nicht durch einen speziellen Treiber unterstützt werden, sind vielleicht noch mit dem Treiber <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-vesa/>x11-drivers/xf86-video-vesa</a> nutzbar. Dieser Treiber wird von <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg/>x11/xorg</a> installiert. Der Treiber kann auch manuell als <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-vesa/>x11-drivers/xf86-video-vesa</a> installiert werden. Xorg versucht immer diesen Treiber zu verwenden, wenn für die Grafikkarte kein passender Treiber gefunden wird.</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-scfb/>x11-drivers/xf86-video-scfb</a> ist ein ähnlicher Treiber, der mit vielen UEFI und ARM® Computern funktioniert.</p></div></dd></dl></div><div id=x-config-video-cards-file class=dlist><dl><dt class=hdlist1>Video-Treiber über eine Datei einstellen</dt><dd><p>Den Intel® Treiber in einer Konfigurationsdatei einstellen:</p><div id=x-config-video-cards-file-intel class=exampleblock><div class=title>Beispiel 15. Den Intel® Treiber über eine Datei auswählen</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-intel.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier  &#34;Card0&#34;
	Driver	    &#34;intel&#34;
	# BusID	    &#34;PCI:1:0:0&#34;
EndSection</pre></div></div><div class=paragraph><p>Wenn mehr als eine Grafikkarte vorhanden ist, kann der Eintrag <code>BusID</code> verwendet werden, um die gewünschte Karte auszuwählen. Eine Liste der <code>BusID`s der Grafikkarten kann mit `pciconf -lv | grep -B3 display</code> ausgegeben werden.</p></div></div></div><div class=paragraph><p>Den Radeon Treiber in einer Konfigurationsdatei einstellen:</p></div><div id=x-config-video-cards-file-radeon class=exampleblock><div class=title>Beispiel 16. Den Radeon Treiber über eine Datei auswählen</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-radeon.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier  &#34;Card0&#34;
	Driver	    &#34;radeon&#34;
EndSection</pre></div></div></div></div><div class=paragraph><p>Den VESA Treiber in einer Konfigurationsdatei einstellen:</p></div><div id=x-config-video-cards-file-vesa class=exampleblock><div class=title>Beispiel 17. Den VESA Treiber über eine Datei auswählen</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-vesa.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier  &#34;Card0&#34;
	Driver	    &#34;vesa&#34;
EndSection</pre></div></div></div></div><div class=paragraph><p>Den Treiber <code>scfb</code> für UEFI- oder ARM®-Computer auswählen:</p></div><div id=x-config-video-cards-file-scfb class=exampleblock><div class=title>Beispiel 18. Den <code>scfb</code> Treiber über eine Datei auswählen</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-scfb.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier  &#34;Card0&#34;
	Driver	    &#34;scfb&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect3><h4 id=x-config-monitors>7.4.6. Monitore<a class=anchor href=#x-config-monitors></a></h4><div class=paragraph><p>Fast alle Monitore unterstützen den Extended Display Identification Data Standard (EDID). Xorg verwendet EDID um mit dem Monitor zu kommunizieren und die unterstützten Auflösungen und Bildwiederholfrequenzen zu erkennen. Xorg wählt dann die für den Monitor am besten geeignete Kombination von Einstellungen.</p></div><div class=paragraph><p>Weitere vom Monitor unterstützte Auflösungen, können in der Konfigurationsdatei, oder nach dem Start des X-Servers mit <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> gesetzt werden.</p></div><div id=x-config-monitors-xrandr class=dlist><dl><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> benutzen</dt><dd><p>Führen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> ohne Parameter aus, um eine Liste von Video-Ausgängen und erkannten Monitor-Modi zu sehen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr
Screen 0: minimum 320 x 200, current 3000 x 1920, maximum 8192 x 8192
DVI-0 connected primary 1920x1200+1080+0 <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span> 495mm x 310mm
   1920x1200     59.95<span class=k>*</span>+
   1600x1200     60.00
   1280x1024     85.02    75.02    60.02
   1280x960      60.00
   1152x864      75.00
   1024x768      85.00    75.08    70.07    60.00
   832x624       74.55
   800x600       75.00    60.32
   640x480       75.00    60.00
   720x400       70.08
DisplayPort-0 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
HDMI-0 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Die Auflistung zeigt, dass der <code>DVI-0</code> Ausgang benutzt wird, um eine Bildschirmauflösung von 1920x1200 bei einer Bildwiederholrate von 60 Hz anzuzeigen. An den Anschlüssen <code>DisplayPort-0</code> und <code>HDMI-0</code> sind keine Monitore angeschlossen.</p></div><div class=paragraph><p>Die anderen Anzeigemodi können mit <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> ausgewählt werden. Um beispielsweise auf 1280x1024 bei 60 Hz umzuschalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr <span class=nt>--mode</span> 1280x1024 <span class=nt>--rate</span> 60</code></pre></div></div><div class=paragraph><p>Häufig wird für einen Videoprojektor der externe Videoausgang eines Notebooks verwendet.</p></div><div class=paragraph><p>Die Typen und Anzahl der Videoanschlüsse variiert zwischen den Geräten und auch die Ausgabe variiert von Treiber zu Treiber. Was für den einen Treiber <code>HDMI-1</code> ist, nennt ein anderer Treiber vielleicht <code>HDMI1</code>. Führen Sie daher zunächst <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> aus, um alle verfügbaren Anschlüsse aufzulisten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr
Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192
LVDS1 connected 1366x768+0+0 <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span> 344mm x 193mm
   1366x768      60.04<span class=k>*</span>+
   1024x768      60.00
   800x600       60.32    56.25
   640x480       59.94
VGA1 connected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
   1280x1024     60.02 +  75.02
   1280x960      60.00
   1152x864      75.00
   1024x768      75.08    70.07    60.00
   832x624       74.55
   800x600       72.19    75.00    60.32    56.25
   640x480       75.00    72.81    66.67    60.00
   720x400       70.08
HDMI1 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
DP1 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Vier Ausgänge wurden gefunden: das integrierte Panel <code>LVDS1</code>, sowie die externen Anschlüsse <code>VGA1</code>, <code>HDMI1</code> und <code>DP1</code>.</p></div><div class=paragraph><p>Der Videoprojektor wurde am Ausgang <code>VGA1</code> angeschlossen. <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> wird nun verwendet, um diese Ausgabe auf die native Auflösung des Projektors einzustellen und den zusätzlichen Platz auf der rechten Seite des Desktops hinzuzufügen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr <span class=nt>--output</span> VGA1 <span class=nt>--auto</span> <span class=nt>--right-of</span> LVDS1</code></pre></div></div><div class=paragraph><p><code>--auto</code> wählt die Auflösung und Aktualisierungsrate die von EDID ermittelt wurden. Wenn die Auflösung nicht richtig ermittelt wurde, kann ein fester Wert mit <code>--mode</code> anstelle von <code>--auto</code> angegeben werden. Beispielsweise können die meisten Projektoren mit einer Auflösung von 1024x768 betrieben werden, die mit <code>--mode 1024x768</code> gesetzt wird.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> wird häufig aus <span class=filename>.xinitrc</span> ausgeführt, um den entsprechenden Modus zu setzen wenn X startet.</p></div></dd></dl></div><div id=x-config-monitors-files class=dlist><dl><dt class=hdlist1>Bildschirmauflösung über eine Datei einstellen</dt><dd><p>Eine Bildschirmauflösung von 1024x768 in einer Konfigurationsdatei einstellen:</p><div class=exampleblock><div class=title>Beispiel 19. Die Bildschirmauflösung in eine Datei schreiben</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/screen-resolution.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
	Identifier &#34;Screen0&#34;
	Device     &#34;Card0&#34;
	SubSection &#34;Display&#34;
	Modes      &#34;1024x768&#34;
	EndSubSection
EndSection</pre></div></div></div></div><div class=paragraph><p>Die wenigen Monitore, die EDID nicht beherrschen, können durch setzen von <code>HorizSync</code> und <code>VertRefresh</code> auf den Bereich der vom Monitor unterstützten Frequenzen konfiguriert werden.</p></div><div class=exampleblock><div class=title>Beispiel 20. Manuelles Einstellen der Monitorfrequenzen</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/monitor0-freq.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
	Identifier   &#34;Monitor0&#34;
	HorizSync    30-83  # kHz
	VertRefresh  50-76  # Hz
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect3><h4 id=x-config-input>7.4.7. Eingabegeräte<a class=anchor href=#x-config-input></a></h4><div class=sect4><h5 id=x-config-input-keyboard>7.4.7.1. Tastaturen<a class=anchor href=#x-config-input-keyboard></a></h5><div id=x-config-input-keyboard-layout class=dlist><dl><dt class=hdlist1>Tastaturlayout</dt><dd><p>Die standardisierte Position von Tasten auf einer Tastatur wird als <em>Layout</em> bezeichnet. Layouts und andere einstellbare Parameter werden in <a href="https://man.freebsd.org/cgi/man.cgi?query=xkeyboard-config&amp;sektion=7&amp;format=html">xkeyboard-config(7)</a> beschrieben.</p><div class=paragraph><p>In der Voreinstellung ist ein US-amerikanisches Layout aktiv. Um ein alternatives Layout zu wählen, setzen Sie die Optionen <code>XkbLayout</code> und <code>XkbVariant</code> in der Klasse <code>InputClass</code>. Dies wird für alle Eingabegeräte der entsprechenden Klasse angewendet werden.</p></div><div class=paragraph><p>Dieses Beispiel konfiguriert ein deutsches Tastaturlayout.</p></div><div class=exampleblock><div class=title>Beispiel 21. Konfiguration eines Tastaturlayouts</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/keyboard-de.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputClass&#34;
	Identifier	&#34;KeyboardDefaults&#34;
	MatchIsKeyboard	&#34;on&#34;
	Option		&#34;XkbLayout&#34; &#34;de&#34;
EndSection</pre></div></div></div></div><div class=exampleblock><div class=title>Beispiel 22. Konfiguration mehrerer Tastaturlayouts</div><div class=content><div class=paragraph><p>Hier werden die Tastaturlayouts für Vereinigte Staaten, Spanien und Ukraine gesetzt. Mit <span class=keyseq><kbd>Alt</kbd>+<kbd>Shift</kbd></span> können Sie zwischen den einzelnen Layouts wechseln. Für eine verbesserte Steuerung des Layouts kann <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xxkb/>x11/xxkb</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/x11/sbxkb/>x11/sbxkb</a> benutzt werden.</p></div><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/kbd-layout-multi.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputClass&#34;
	Identifier	&#34;All Keyboards&#34;
	MatchIsKeyboard	&#34;yes&#34;
	Option		&#34;XkbLayout&#34; &#34;us,es,ua&#34;
EndSection</pre></div></div></div></div></dd></dl></div><div id=x-config-input-keyboard-zap class=dlist><dl><dt class=hdlist1>Xorg über die Tastatur beenden</dt><dd><p>X kann über eine Tastenkombination geschlossen werden. Standardmäßig ist die Tastenkombination jedoch nicht gesetzt, da sie mit Tastaturbefehlen für einige Anwendungen in Konflikt steht. Die Aktivierung dieser Option erfordert Änderungen in der Sektion <code>InputDevice</code> für die Tastatur:</p><div class=exampleblock><div class=title>Beispiel 23. X über die Tastatur beenden</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/keyboard-zap.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputClass&#34;
	Identifier	&#34;KeyboardDefaults&#34;
	MatchIsKeyboard	&#34;on&#34;
	Option		&#34;XkbOptions&#34; &#34;terminate:ctrl_alt_bksp&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect4><h5 id=x11-input-mice>7.4.7.2. Mäuse und Zeigegeräte<a class=anchor href=#x11-input-mice></a></h5><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Wenn Sie unter FreeBSD 12.1 das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/xorg-server/>xorg-server</a> 1.20.8 oder eine neuere Version installiert haben, und Sie auch nicht den <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a>-Daemon verwenden, fügen Sie <code>kern.evdev.rcpt_mask=12</code> in <span class=filename>/etc/sysctl.conf</span> ein.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Viele Parameter für die Maus können über Konfigurationseinstellungen eingestellt werden. <a href="https://man.freebsd.org/cgi/man.cgi?query=mousedrv&amp;sektion=4&amp;format=html">mousedrv(4)</a> enthält eine vollständige Liste.</p></div><div id=x11-input-mice-buttons class=dlist><dl><dt class=hdlist1>Mauszeiger</dt><dd><p>Die Anzahl der Maustasten wird in <span class=filename>xorg.conf</span> im Abschnitt <code>InputDevice</code> für die Maus festgelegt. Um die Anzahl der Tasten auf 7 zu setzen:</p><div class=exampleblock><div class=title>Beispiel 24. Die Anzahl der Maustasten festlegen</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/X11/xorg.conf.d/mouse0-buttons.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
	Identifier  &#34;Mouse0&#34;
	Option	    &#34;Buttons&#34; &#34;7&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div></div><div class=sect3><h4 id=x-config-manual-configuration>7.4.8. Manuelle Konfiguration<a class=anchor href=#x-config-manual-configuration></a></h4><div class=paragraph><p>In einigen Fällen funktioniert die Autokonfiguration nicht mit bestimmter Hardware, oder es wird eine andere Konfiguration benötigt. Für diese Fälle kann eine benutzerdefinierte Konfigurationsdatei erstellt werden.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Erstellen Sie keine manuellen Konfigurationsdateien, sofern dies nicht erforderlich ist. Eine unnötige manuelle Konfiguration kann den ordnungsgemäßen Betrieb verhindern.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Eine Konfigurationsdatei kann, basierend auf der von Xorg erfassten Hardware erzeugt werden. Diese Konfigurationsdatei ist ein guter Ausgangspunkt für angepasste Konfigurationen.</p></div><div class=paragraph><p>Erzeugung einer <span class=filename>xorg.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -configure</span></code></pre></div></div><div class=paragraph><p>Die Konfigurationsdatei wird in <span class=filename>/root/xorg.conf.new</span> gespeichert. Machen Sie alle gewünschten Änderungen an dieser Datei. Danach testen Sie die Datei mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -retro -config /root/xorg.conf.new</span></code></pre></div></div><div class=paragraph><p>Nachdem die neue Konfiguration angepasst und getestet wurde, kann die Konfiguration in kleinere Dateien unter <span class=filename>/usr/local/etc/X11/xorg.conf.d/</span> aufgeteilt werden.</p></div></div></div><div class=sect2><h3 id=x-fonts>7.5. Schriftarten in Xorg benutzen<a class=anchor href=#x-fonts></a></h3><div class=sect3><h4 id=type1>7.5.1. Type 1 Schriftarten<a class=anchor href=#type1></a></h4><div class=paragraph><p>Die Schriftarten, die mit Xorg ausgeliefert werden, eignen sich ganz und gar nicht für Desktop-Publishing-Anwendungen. Große Schriftarten zeigen bei Präsentationen deutliche Treppenstufen und kleine Schriftarten sind fast unleserlich. Es gibt allerdings mehrere hochwertige Type 1 Schriftarten (PostScript®), die mit Xorg benutzt werden können. Beispielsweise enthalten die URW-Schriftarten (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/urwfonts/>x11-fonts/urwfonts</a>) hochwertige Versionen gängiger Type 1 Schriftarten (unter anderem Times Roman™, Helvetica™, Palatino™). Die Sammlung Freefonts (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/freefonts/>x11-fonts/freefonts</a>) enthält viele weitere Schriftarten, doch sind diese für den Einsatz in Grafikprogrammen wie Gimp gedacht und nicht für den alltäglichen Gebrauch. Weiterhin kann Xorg mit einem Minimum an Aufwand konfiguriert werden, damit TrueType®-Schriftarten benutzt werden können. Mehr dazu erfahren Sie in der Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=X&amp;sektion=7&amp;format=html">X(7)</a> und im <a href=#truetype>TrueType®-Schriftarten</a>.</p></div><div class=paragraph><p>Die Type 1 Schriftarten lassen sich als Paket wie folgt installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install urwfonts</span></code></pre></div></div><div class=paragraph><p>Alternativ können die Schriftarten aus der Ports-Sammlung gebaut und installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-fonts/urwfonts</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Analog lassen sich Freefont und andere Sammlungen installieren. Damit der X-Server diese Schriftarten erkennt, fügen Sie eine entsprechende Zeile in die Konfigurationsdatei des X-Servers (<span class=filename>/etc/X11/xorg.conf</span>) hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath &#34;/usr/local/shared/fonts/urwfonts/&#34;</pre></div></div><div class=paragraph><p>Alternativ kann in der X-Sitzung das folgende Kommando abgesetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/shared/fonts/urwfonts
% xset fp rehash</code></pre></div></div><div class=paragraph><p>Jetzt kennt der X-Server die neuen Schriftarten, jedoch nur bis zu Ende der Sitzung. Soll die Änderung dauerhaft sein, müssen die Befehle in <span class=filename>~/.xinitrc</span> eingetragen werden, wenn X mittels <code>startx</code> gestartet wird, beziehungsweise in <span class=filename>~/.xsession</span>, wenn ein grafischer Login-Manager, wie XDM verwendet wird. Eine dritte Möglichkeit besteht darin, <span class=filename>/usr/local/etc/fonts/local.conf</span> zu verwenden, was im <a href=#antialias>Anti-aliasing</a> demonstriert wird.</p></div></div><div class=sect3><h4 id=truetype>7.5.2. TrueType®-Schriftarten<a class=anchor href=#truetype></a></h4><div class=paragraph><p>Xorg besitzt eine eingebaute Unterstützung zur Darstellung von TrueType®-Schriftarten. Hierzu existieren zwei verschiedene Module, die diese Funktionalität aktivieren können. In diesem Beispiel wird das Freetype-Modul benutzt, da es besser mit anderen Werkzeugen, die TrueType®-Schriftarten darstellen, übereinstimmt. Um das Freetype-Modul zu aktivieren, muss die folgende Zeile zum Abschnitt <code>"Module"</code> in <span class=filename>/etc/X11/xorg.conf</span> hinzugefügt werden.</p></div><div class="literalblock programlisting"><div class=content><pre>Load &#34;freetype&#34;</pre></div></div><div class=paragraph><p>Erstellen Sie ein Verzeichnis für die TrueType®-Schriftarten (beispielsweise <span class=filename>/usr/local/shared/fonts/TrueType</span>) und kopieren Sie alle Schriftarten dorthin. Beachten Sie, dass die Schriftarten für Xorg im UNIX®/MS-DOS®/Windows®-Format vorliegen müssen und nicht direkt von einem Apple® Mac® übernommen werden können. Sobald die Dateien in das Verzeichnis kopiert wurden, verwenden Sie mkfontscale um <span class=filename>fonts.dir</span> zu erstellen, damit X weiß, dass diese neuen Dateien installiert wurden. <code>mkfontscale</code> kann als Paket installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mkfontscale</span></code></pre></div></div><div class=paragraph><p>Erstellen Sie dann einen Index der Schriftarten für X:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/shared/fonts/TrueType</span>
<span class=c># mkfontscale</span></code></pre></div></div><div class=paragraph><p>Geben Sie dem System das TrueType®-Verzeichnis, wie im <a href=#type1>Type 1 Schriftarten</a> beschrieben, bekannt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xset fp+ /usr/local/shared/fonts/TrueType</span>
<span class=c># xset fp rehash</span></code></pre></div></div><div class=paragraph><p>Oder fügen Sie eine <code>FontPath</code>-Zeile in <span class=filename>xorg.conf</span> ein.</p></div><div class=paragraph><p>Jetzt sollten Gimp, Apache OpenOffice und alle anderen X-Anwendungen die TrueType®-Schritarten erkennen. Extrem kleine Schriftarten (Webseiten, die mit hoher Auflösung betrachtet werden) und sehr große Schriftarten (in StarOffice™) werden jetzt viel besser aussehen.</p></div></div><div class=sect3><h4 id=antialias>7.5.3. Anti-aliasing<a class=anchor href=#antialias></a></h4><div class=paragraph><p>Alle Schriftarten in Xorg, die in den Verzeichnissen <span class=filename>/usr/local/shared/fonts/</span> und <span class=filename>~/.fonts/</span> gefunden werden, werden automatisch für Anti-aliasing an Anwendungen zur Verfügung gestellt, die Xft beherrschen. Die meisten aktuellen Anwendungen beherrschen Xft, dazu gehören auch KDE, GNOME und Firefox.</p></div><div class=paragraph><p>In <span class=filename>/usr/local/etc/fonts/local.conf</span> werden die Schriftarten, die mit dem Anti-aliasing-Verfahren benutzt werden sollen und die Eigenschaften des Verfahrens festgelegt. In diesem Abschnitt wird nur die grundlegende Konfiguration von Xft beschrieben. Weitere Details entnehmen Sie bitte der Hilfeseite <a href="https://man.freebsd.org/cgi/man.cgi?query=fonts-conf&amp;sektion=5&amp;format=html">fonts-conf(5)</a>.</p></div><div class=paragraph><p>Die Datei <span class=filename>local.conf</span> ist ein XML-Dokument. Achten Sie beim Editieren der Datei daher auf die richtige Groß- und Kleinschreibung und darauf, dass alle Tags geschlossen sind. Die Datei beginnt mit der üblichen XML-Deklaration gefolgt von einer DOCTYPE-Definition und dem <code>&lt;fontconfig></code>-Tag:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34;?&gt;
        &lt;!DOCTYPE fontconfig SYSTEM &#34;fonts.dtd&#34;&gt;
        &lt;fontconfig&gt;</pre></div></div><div class=paragraph><p>Wie vorher erwähnt, stehen schon alle Schriftarten in <span class=filename>/usr/local/shared/fonts/</span> und <span class=filename>~/.fonts/</span> für Anwendungen, die Xft unterstützen, zur Verfügung. Um ein Verzeichnis außerhalb dieser beiden Bäume zu benutzen, fügen Sie eine Zeile wie die nachstehende in <span class=filename>/usr/local/etc/fonts/local.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;dir&gt;/path/to/my/fonts&lt;/dir&gt;</pre></div></div><div class=paragraph><p>Wenn Sie neue Schriftarten hinzugefügt haben, müssen Sie den Schriftarten-Cache neu aufbauen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fc-cache -f</span></code></pre></div></div><div class=paragraph><p>Das Anti-aliasing-Verfahren zeichnet Ränder leicht unscharf, dadurch werden kleine Schriften besser lesbar und der Treppenstufen-Effekt bei wird großen Schriften vermieden. Auf normale Schriftgrößen sollte das Verfahren aber nicht angewendet werden, da dies die Augen zu sehr anstrengt. Um kleinere Schriftgrößen als 14 Punkt von dem Verfahren auszuschließen, fügen Sie in <span class=filename>local.conf</span> die nachstehenden Zeilen ein:</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;match target=&#34;font&#34;&gt;
	   &lt;test name=&#34;size&#34; compare=&#34;less&#34;&gt;
	       &lt;double&gt;14&lt;/double&gt;
	   &lt;/test&gt;
	   &lt;edit name=&#34;antialias&#34; mode=&#34;assign&#34;&gt;
	       &lt;bool&gt;false&lt;/bool&gt;
	   &lt;/edit&gt;
	 &lt;/match&gt;
	 &lt;match target=&#34;font&#34;&gt;
	   &lt;test name=&#34;pixelsize&#34; compare=&#34;less&#34; qual=&#34;any&#34;&gt;
	       &lt;double&gt;14&lt;/double&gt;
	   &lt;/test&gt;
	   &lt;edit mode=&#34;assign&#34; name=&#34;antialias&#34;&gt;
	       &lt;bool&gt;false&lt;/bool&gt;
	   &lt;/edit&gt;
	 &lt;/match&gt;</pre></div></div><div class=paragraph><p>Das Anti-aliasing-Verfahren kann die Abstände einiger Fixschriften falsch darstellen, dies fällt besonders unter KDE auf. Sie können das Problem umgehen, indem Sie die Abstände dieser Schriften auf den Wert <code>100</code> festsetzen. Fügen Sie die nachstehenden Zeilen hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
           &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
               &lt;string&gt;fixed&lt;/string&gt;
           &lt;/test&gt;
           &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
               &lt;string&gt;mono&lt;/string&gt;
           &lt;/edit&gt;
        &lt;/match&gt;
        &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
            &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                &lt;string&gt;console&lt;/string&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
                &lt;string&gt;mono&lt;/string&gt;
            &lt;/edit&gt;
        &lt;/match&gt;</pre></div></div><div class=paragraph><p>Damit werden die Namen der gebräuchlichen Fixschriften auf <code>"mono"</code> abgebildet. Für diese Schriften setzen Sie dann den Abstand fest:</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
             &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                 &lt;string&gt;mono&lt;/string&gt;
             &lt;/test&gt;
             &lt;edit name=&#34;spacing&#34; mode=&#34;assign&#34;&gt;
                 &lt;int&gt;100&lt;/int&gt;
             &lt;/edit&gt;
         &lt;/match&gt;</pre></div></div><div class=paragraph><p>Bestimmte Schriftarten, wie Helvetica, können Probleme mit dem Anti-Aliasing-Verfahren verursachen. In der Regel erscheinen diese Schriftarten dann vertikal halbiert. Im schlimmsten Fall stürzen Anwendungen als Folge davon ab. Sie vermeiden dies, indem Sie betroffene Schriftarten in <span class=filename>local.conf</span> von dem Verfahren ausnehmen:</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
             &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                 &lt;string&gt;Helvetica&lt;/string&gt;
             &lt;/test&gt;
             &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
                 &lt;string&gt;sans-serif&lt;/string&gt;
             &lt;/edit&gt;
         &lt;/match&gt;</pre></div></div><div class=paragraph><p>Nachdem Sie <span class=filename>local.conf</span> editiert haben, müssen Sie sicherstellen, dass die Datei mit dem Tag <code>&lt;/fontconfig></code> endet. Ist das nicht der Fall, werden die Änderungen nicht berücksichtigt.</p></div><div class=paragraph><p>Benutzer können personalisierte Einstellungen in <span class=filename>~/.fonts.conf</span> vornehmen. Diese Datei verwendet die gleiche XML-Syntax wie im obigen Beispiel.</p></div><div class=paragraph><p>Mit einem LCD können Sie sub-pixel sampling anstelle von Anti-aliasing einsetzen. Dieses Verfahren behandelt die horizontal getrennten Rot-, Grün- und Blau-Komponenten eines Pixels gesondert und verbessert damit (teilweise sehr wirksam) die horizontale Auflösung. Die nachstehende Zeile in <span class=filename>local.conf</span> aktiviert diese Funktion:</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;font&#34;&gt;
             &lt;test qual=&#34;all&#34; name=&#34;rgba&#34;&gt;
                 &lt;const&gt;unknown&lt;/const&gt;
             &lt;/test&gt;
             &lt;edit name=&#34;rgba&#34; mode=&#34;assign&#34;&gt;
                 &lt;const&gt;rgb&lt;/const&gt;
             &lt;/edit&gt;
         &lt;/match&gt;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Abhängig von der Art Ihres Bildschirms müssen Sie anstelle von <code>rgb</code> eines der folgenden verwenden: <code>bgr</code>, <code>vrgb</code> oder <code>vbgr</code>. Experimentieren Sie und vergleichen, was besser aussieht.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x-xdm>7.6. Der X-Display-Manager<a class=anchor href=#x-xdm></a></h3><div class=paragraph><p>Xorg enthält den X-Display-Manager XDM, um Sitzungen zu verwalten. XDM stellt eine graphische Anmeldemaske zur Verfügung, in der Sie den Server, auf dem eine Sitzung laufen soll, auswählen können und in der Sie die Autorisierungs-Informationen, wie Benutzername und Passwort, eingeben können.</p></div><div class=paragraph><p>Dieser Abschnitt zeigt, wie der X-Displaymanager konfiguriert wird. Einige grafische Oberflächen enthalten ihre eigenen graphischen Login-Manager. Eine Anleitung zur Konfiguration des GNOME Display-Managers finden Sie im <a href=#x11-wm-gnome>GNOME</a>. Eine Anleitung zur Konfiguration des KDE Display Managers finden Sie im <a href=#x11-wm-kde>KDE</a>.</p></div><div class=sect3><h4 id=_xdm_einrichten>7.6.1. XDM einrichten<a class=anchor href=#_xdm_einrichten></a></h4><div class=paragraph><p>XDM kann über das Paket oder den Port <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xdm/>x11/xdm</a> installiert werden. Nach der Installation lässt sich XDM durch einen Eintrag in <span class=filename>/etc/ttys</span> bei jedem Start des Rechners aktivieren:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyv8   &#34;/usr/local/bin/xdm -nodaemon&#34;  xterm   off secure</pre></div></div><div class=paragraph><p>Ändern Sie den Wert <code>off</code> zu <code>on</code> und speichern Sie die Datei. <code>ttyv8</code> zeigt an, dass XDM auf dem neunten virtuellen Terminal ausgeführt wird.</p></div><div class=paragraph><p>Die Konfigurationsdateien von XDM befinden sich in <span class=filename>/usr/local/etc/X11/xdm</span>. Dieses Verzeichnis enthält einige Dateien, mit denen das Verhalten und Aussehen von XDM beeinflusst werden kann, sowie ein paar Skripte und Programme zur Einrichtung des Desktops. Eine Zusammenfassung der Aufgaben dieser Dateien beschreibt die <a href=#xdm-config-files>Die Konfigurationsdateien von XDM</a>. Die genaue Syntax und Verwendung wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> beschrieben.</p></div><table id=xdm-config-files class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 6. Die Konfigurationsdateien von XDM</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Datei</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xaccess</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Verbindungen zu XDM werden über das "X Display Manager Connection Protocol" (XDMCP) hergestellt. <span class=filename>Xaccess</span> enthält die Client-Berechtigungen zur Steuerung der XDMCP-Verbindungen entfernter Maschinen. In der Voreinstellung erlaubt diese Datei keine Verbindungen von entfernten Maschinen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xresources</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diese Datei steuert das Erscheinungsbild der Bildschirmauswahl und Anmeldemasken von XDM. In der Voreinstellung erscheint ein rechteckiges Anmeldefenster, dass den Hostnamen und einen Anmeldeprompt mit "Login:" und "Password" anzeigt. Das Format dieser Datei entspricht den Dateien im Verzeichnis <span class=filename>app-defaults</span>, die in der Dokumentation von Xorg beschrieben sind.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xservers</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diese Datei enthält eine Liste entfernter Rechner, die in der Bildschirmauswahl angeboten werden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsession</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dieses Skript wird von XDM aufgerufen, nachdem sich ein Benutzer erfolgreich angemeldet hat. Es verweist auf ein angepasstes Skript in <span class=filename>~/.xsession</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsetup_*</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diese Skripten werden automatisch ausgeführt, bevor die Bildschirmauswahl oder die Anmeldemasken angezeigt werden. Für jeden lokalen Bildschirm gibt es ein Skript namens <span class=filename>Xsetup_*</span>, wobei <code>*</code> die lokale Bildschirmnummer ist. Normalerweise werden damit ein oder zwei Programme, wie <code>xconsole</code>, im Hindergrund gestartet.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-config</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Konfiguration für alle auf der Maschine verwalteten Bildschirme.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-errors</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enthält Fehler, die vom Server generiert werden. Wenn ein von XDM verwalteter Bildschirm hängen bleibt, suchen Sie in dieser Datei nach Fehlermeldungen. Für jede Sitzung werden die Meldungen auch in die Datei <span class=filename>~/.xsession-errors</span> des Benutzers geschrieben.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-pid</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die Prozess-ID des gerade laufenden XDM-Prozesses.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_fernzugriff_einrichten>7.6.2. Fernzugriff einrichten<a class=anchor href=#_fernzugriff_einrichten></a></h4><div class=paragraph><p>In der Voreinstellung können sich nur Benutzer auf dem selben System über XDM anmelden. Um es Benutzern anderer Systeme zu ermöglichen, sich mit dem Bildschirm-Server zu verbinden, muss der Zugriffsregelsatz bearbeitet und der Listener aktiviert werden.</p></div><div class=paragraph><p>Um XDM so zu konfigurieren, dass jede Verbindung angenommen wird, kommentieren Sie die Zeile <code>DisplayManager.requestPort</code> in <span class=filename>/usr/local/etc/X11/xdm/xdm-config</span> aus, indem Sie der Zeile ein <code>!</code> voranstellen.</p></div><div class="literalblock programlisting"><div class=content><pre>! SECURITY: do not listen for XDMCP or Chooser requests
! Comment out this line if you want to manage X terminals with xdm
DisplayManager.requestPort:     0</pre></div></div><div class=paragraph><p>Speichern Sie die Änderungen und starten Sie XDM neu. Um den Fernzugriff zu beschränken, sehen Sie sich die Beispiele in <span class=filename>/usr/local/etc/X11/xdm/Xaccess</span> an. Zusätzliche Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a></p></div></div></div><div class=sect2><h3 id=x11-wm>7.7. Grafische Oberflächen<a class=anchor href=#x11-wm></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt die Installation der drei beliebtesten grafischen Oberflächen unter FreeBSD. Eine Oberfläche kann alles von einem einfachen Window-Manager bis hin zu kompletten Anwendungen sein. Mehr als einhundert grafische Oberflächen stehen in der Kategorie <span class=filename>x11-wm</span> der Ports-Sammlung zur Verfügung.</p></div><div class=sect3><h4 id=x11-wm-gnome>7.7.1. GNOME<a class=anchor href=#x11-wm-gnome></a></h4><div class=paragraph><p>GNOME ist eine benutzerfreundliche Oberfläche. Es besitzt eine Leiste, mit der Anwendungen gestartet werden und die Statusinformationen anzeigen kann. Programme und Daten können auf der Oberfläche abgelegt werden und Standardwerkzeuge stehen zur Verfügung. Es gibt Konventionen, die es Anwendungen leicht machen, zusammenzuarbeiten und ein konsistentes Erscheinungsbild garantieren. Weitere Informationen zu GNOME unter FreeBSD finden Sie unter <a href=https://www.FreeBSD.org/gnome>https://www.FreeBSD.org/gnome</a>. Die Webseite enthält zusätzliche Informationen über die Installation, Konfiguration und Verwaltung von GNOME unter FreeBSD.</p></div><div class=paragraph><p>Diese grafische Oberfläche kann als Paket installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnome3</span></code></pre></div></div><div class=paragraph><p>Um GNOME stattdessen aus der Ports-Sammlung zu übersetzen, nutzen Sie das folgende Kommando. GNOME ist eine große Anwendung, die sogar auf einem schnellen Computer einige Zeit zum Übersetzten benötigt.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/gnome3</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>GNOME benötigt ein eingehängtes <span class=filename>/proc</span> Dateisystem. Fügen Sie daher die folgende Zeile in <span class=filename>/etc/fstab</span> ein, damit <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a> beim Systemstart automatisch eingehängt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>GNOME benötigt D-Bus und HAL für einen Nachrichtenbus und Hardware Abstraktion. Diese Anwendungen werden automatisch als Abhängigkeiten von GNOME installiert. Aktivieren Sie die Dienste in <span class=filename>/etc/rc.conf</span>, sodass sie automatisch gestartet werden wenn das System bootet:</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;
hald_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Nach der Installation weisen Sie Xorg an, GNOME zu starten. Der einfachste Weg, dies zu tun, ist über den GNOME Display Manager GDM, der als Teil des GNOME-Desktops installiert wird. Um GDM zu aktivieren, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>gdm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>In der Regel ist es ratsam, alle GNOME-Dienste zu starten. Um dies zu erreichen, fügen Sie die folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>gnome_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>GDM wird nun automatisch gestartet, wenn das System hochfährt.</p></div><div class=paragraph><p>GNOME kann alternativ auch von der Kommandozeile gestartet werden, wenn eine entsprechend konfigurierte <span class=filename>~/.xinitrc</span> vorliegt. Existiert diese Datei bereits, ersetzen Sie den Aufruf des Window-Managers durch /usr/local/bin/gnome-session. Wenn <span class=filename>.xinitrc</span> nicht existiert, erstellen Sie die Datei mit folgendem Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Eine dritte Methode ist, XDM als Display-Manager zu verwenden. In diesem Fall erstellen Sie eine ausführbare <span class=filename>~/.xsession</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div></div><div class=sect3><h4 id=x11-wm-kde>7.7.2. KDE<a class=anchor href=#x11-wm-kde></a></h4><div class=paragraph><p>KDE ist eine weitere, leicht zu benutzende Desktop-Umgebung. Dieser Desktop bietet eine Sammlung von Anwendungen mit einheitlichem Erscheinungsbild (look and feel), einheitlichen Menüs, Werkzeugleisten, Tastenkombinationen, Farbschemata, Internationalisierung und einer zentralen, dialoggesteuerten Desktop-Konfiguration. Weitere Informationen zu KDE finden Sie unter <a href=http://www.kde.org/>http://www.kde.org/</a>. Spezifische Informationen für FreeBSD finden Sie unter <a href=http://freebsd.kde.org/>http://freebsd.kde.org</a>.</p></div><div class=paragraph><p>Um KDE als Paket zu installieren, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/kde5</span></code></pre></div></div><div class=paragraph><p>Um KDE stattdessen aus dem Quellcode zu übersetzen, verwenden Sie das folgende Kommando. Bei der Installation wird ein Menü zur Auswahl der Komponenten angezeigt. KDE ist eine große Anwendung, die sogar auf einem schnellen Computer einige Zeit zum Übersetzen benötigt.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/kde5</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>KDE benötigt ein eingehängtes <span class=filename>/proc</span>. Fügen Sie diese Zeile in <span class=filename>/etc/fstab</span> ein, um das Dateisystem automatisch beim Systemstart einzuhängen:</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>KDE benötigt D-Bus und HAL für einen Nachrichtenbus und Hardware Abstraktion. Diese Anwendungen werden automatisch als Abhängigkeiten von KDE installiert. Aktivieren Sie die Dienste in <span class=filename>/etc/rc.conf</span>, sodass sie automatisch gestartet werden wenn das System bootet:</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;
hald_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Seit KDE Plasma 5 wird der KDE Display-Manager KDM nicht weiterentwickelt. Eine mögliche Alternative ist SDDM. Sie können das Paket wie folgt installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/sddm</span></code></pre></div></div><div class=paragraph><p>Fügen Sie anschließend folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>sddm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Eine zweite Möglichkeit KDE zu starten, ist <code>startx</code> in der Kommandozeile einzugeben. Damit dies funktioniert, wird folgende Zeile in <span class=filename>~/.xinitrc</span> benötigt:</p></div><div class="literalblock programlisting"><div class=content><pre>exec ck-launch-session startplasma-x11</pre></div></div><div class=paragraph><p>Eine dritte Möglichkeit ist KDE über XDM zu starten. Um dies zu tun, erstellen Sie eine ausführbare <span class=filename>~/.xsession</span> wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec ck-launch-session startkde&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div><div class=paragraph><p>Sobald KDE gestartet wird, finden Sie im integrierten Hilfesystem weitere Informationen zur Benutzung der verschiedenen Menüs und Anwendungen.</p></div></div><div class=sect3><h4 id=x11-wm-xfce>7.7.3. Xfce<a class=anchor href=#x11-wm-xfce></a></h4><div class=paragraph><p>Xfce ist eine Desktop-Umgebung, basierend auf den von GNOME verwendeten GTK+-Bibliotheken. Es hat einen geringeren Speicherbedarf und stellt dabei einen schlichten, effizienten und einfach zu benutzenden Desktop zur Verfügung. Xfce ist vollständig konfigurierbar, verfügt über eine Programmleiste mit Menüs, Applets und einen Programmstarter. Zudem sind ein Datei-Manager und ein Sound-Manager enthalten und das Programm ist über Themes anpassbar. Da es schnell, leicht und effizient ist, eignet sich Xfce ideal für ältere oder langsamere Rechner mit wenig Speicher. Weitere Informationen zu Xfce finden Sie unter <a href=http://www.xfce.org/>http://www.xfce.org</a>.</p></div><div class=paragraph><p>Um das Paket Xfce zu installieren, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xfce</span></code></pre></div></div><div class=paragraph><p>Um stattdessen den Port zu übersetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-wm/xfce4</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Xfce benutzt D-Bus als Nachrichtenbus. Die Komponente wird automatisch als Abhängigkeit von Xfce installiert. Um D-Bus beim Hochfahren des Systems zu starten, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Im Gegensatz zu GNOME oder KDE, besitzt Xfce keinen eigenen Login-Manager. Damit Xfce von der Kommandozeile mit <code>startx</code> gestartet werden kann, muss zunächst <span class=filename>~/.xinitrc</span> mit diesem Befehl erstellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;. /usr/local/etc/xdg/xfce4/xinitrc&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Alternativ dazu kann XDM verwendet werden. Um diese Methode zu konfigurieren, erstellen Sie eine ausführbare <span class=filename>~/.xsession</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;. /usr/local/etc/xdg/xfce4/xinitrc&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div></div></div><div class=sect2><h3 id=x-compiz-fusion>7.8. Compiz Fusion installieren<a class=anchor href=#x-compiz-fusion></a></h3><div class=paragraph><p>Der Einsatz von hübschen 3D-Effekten ist eine Möglichkeit, die Benutzerfreundlichkeit eines Desktop-Rechners zu erhöhen.</p></div><div class=paragraph><p>Die Installation des Compiz Fusion Pakets ist einfach, aber bei der Konfiguration sind ein paar Schritte notwendig, die nicht in der Dokumentation des Ports beschrieben werden.</p></div><div class=sect3><h4 id=x-compiz-video-card>7.8.1. Konfiguration des FreeBSD nVidia-Treibers<a class=anchor href=#x-compiz-video-card></a></h4><div class=paragraph><p>Desktop-Effekte erzeugen eine hohe Last auf der Grafikkarte. Für nVidia-basierte Grafikkarten sind die proprietären Treiber für eine gute Leistung erforderlich. Benutzer anderer Grafikkarten können diesen Abschnitt überspringen und mit der Konfiguration von Xorg fortfahren.</p></div><div class=paragraph><p>Lesen Sie die <a href=https://docs.freebsd.org/de/books/faq/#x>FAQ zu diesem Thema</a>, um herauszufinden, wie der richtige nVidia-Treiber ermittelt werden kann.</p></div><div class=paragraph><p>Nachdem der richtige Treiber für die Karte ermittelt wurde, kann er wie jedes andere Paket installiert werden.</p></div><div class=paragraph><p>Um beispielsweise den aktuellsten Treiber zu installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/nvidia-driver</span></code></pre></div></div><div class=paragraph><p>Der Treiber erstellt ein Kernelmodul, welches beim Systemstart geladen werden muss. Fügen folgende Zeile in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>nvidia_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um das Kernelmodul direkt in den laufenden Kernel zu laden, kann der Befehl <code>kldload nvidia</code> eingeben werden. Allerdings wurde festgestellt, dass einige Versionen von Xorg nicht richtig funktionieren, wenn der Treiber nicht beim Systemstart geladen wurde. Nach der Änderung in <span class=filename>/boot/loader.conf</span> wird daher ein Neustart des Systems empfohlen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn das Kernelmodul geladen ist, muss in der Regel nur noch eine einzige Zeile in <span class=filename>xorg.conf</span> geändert werden, um den proprietären Treiber zu aktivieren:</p></div><div class=paragraph><p>Suchen Sie folgende Zeile in <span class=filename>/etc/X11/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Driver      &#34;nv&#34;</pre></div></div><div class=paragraph><p>und ändern Sie die Zeile zu:</p></div><div class="literalblock programlisting"><div class=content><pre>Driver      &#34;nvidia&#34;</pre></div></div><div class=paragraph><p>Wenn Sie nun die grafische Oberfläche starten, sollten Sie vom nVidia Startbildschirm begrüßt werden. Alles sollte wie gewohnt funktionieren.</p></div></div><div class=sect3><h4 id=xorg-configuration>7.8.2. Konfiguration von Desktop-Effekten in xorg.conf<a class=anchor href=#xorg-configuration></a></h4><div class=paragraph><p>Um Compiz Fusion zu aktivieren, muss <span class=filename>/etc/X11/xorg.conf</span> angepasst werden:</p></div><div class=paragraph><p>Fügen Sie diesen Abschnitt hinzu, um Composite-Effekte zu aktivieren:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Extensions&#34;
    Option         &#34;Composite&#34; &#34;Enable&#34;
EndSection</pre></div></div><div class=paragraph><p>Suchen Sie den Abschnitt "Screen", der ähnlich wie hier gezeigt aussehen sollte:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
    Identifier     &#34;Screen0&#34;
    Device         &#34;Card0&#34;
    Monitor        &#34;Monitor0&#34;
    ...</pre></div></div><div class=paragraph><p>und fügen Sie die beiden folgenden Zeilen hinzu (z.B. nach "Monitor"):</p></div><div class="literalblock programlisting"><div class=content><pre>DefaultDepth    24
Option         &#34;AddARGBGLXVisuals&#34; &#34;True&#34;</pre></div></div><div class=paragraph><p>Suchen Sie den Abschnitt "Subsection", der sich auf die gewünschte Bildschirmauflösung bezieht. Wenn Sie z.B. 1280x1024 verwenden möchten, suchen Sie den folgenden Abschnitt. Sollte die gewünschte Auflösung nicht in allen Unterabschnitten vorhanden sein, können Sie den entsprechenden Eintrag manuell hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>SubSection     &#34;Display&#34;
    Viewport    0 0
    Modes      &#34;1280x1024&#34;
EndSubSection</pre></div></div><div class=paragraph><p>Für Composite-Effekte wird eine Farbtiefe von 24 Bit benötigt. Ändern Sie dazu den obigen Abschnitt wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>SubSection     &#34;Display&#34;
    Viewport    0 0
    Depth       24
    Modes      &#34;1280x1024&#34;
EndSubSection</pre></div></div><div class=paragraph><p>Zuletzt muss noch sichergestellt werden, dass die Module "glx" und "extmod" im Abschnitt "Module" geladen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Module&#34;
    Load           &#34;extmod&#34;
    Load           &#34;glx&#34;
    ...</pre></div></div><div class=paragraph><p>Die vorangegangenen Einstellungen können automatisch mit <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-xconfig/>x11/nvidia-xconfig</a> erledigt werden, indem Sie folgende Kommandos als root ausführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nvidia-xconfig --add-argb-glx-visuals</span>
<span class=c># nvidia-xconfig --composite</span>
<span class=c># nvidia-xconfig --depth=24</span></code></pre></div></div></div><div class=sect3><h4 id=compiz-fusion>7.8.3. Installation und Konfiguration von Compiz Fusion<a class=anchor href=#compiz-fusion></a></h4><div class=paragraph><p>Die Installation von Compiz Fusion ist so einfach wie die Installation jedes anderen Pakets:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11-wm/compiz-fusion</span></code></pre></div></div><div class=paragraph><p>Wenn die Installation abgeschlossen ist, starten Sie (als normaler Benutzer) den grafischen Desktop mit folgendem Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% compiz <span class=nt>--replace</span> <span class=nt>--sm-disable</span> <span class=nt>--ignore-desktop-hints</span> ccp &amp;
% emerald <span class=nt>--replace</span> &amp;</code></pre></div></div><div class=paragraph><p>Der Bildschirm wird für einige Sekunden flackern, da der Window Manager (z.B. Metacity, wenn Sie GNOME benutzen) von Compiz Fusion ersetzt wird. Emerald kümmert sich um die Fensterdekoration (z.B. die Schatzflächenn schließen, minimieren und maximieren, Titelleisten, usw.).</p></div><div class=paragraph><p>Sie können dieses einfache Skript anpassen und es dann beim Start automatisch ausführen lassen (z.B. durch Hinzufügen von "Sessions" beim GNOME-Desktop):</p></div><div class="literalblock programlisting"><div class=content><pre>#! /bin/sh
compiz --replace --sm-disable --ignore-desktop-hints ccp &amp;
emerald --replace &amp;</pre></div></div><div class=paragraph><p>Speichern Sie die Datei in Ihrem Heimatverzeichnis, beispielsweise als <span class=filename>start-compiz</span> und machen Sie die Datei ausführbar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod</span> +x ~/start-compiz</code></pre></div></div><div class=paragraph><p>Benutzen Sie dann die grafische Oberfläche, um das Skript zu <span class=guimenuitem>Autostart-Programme</span> hinzuzufügen (beim GNOME-Desktop unter <span class=guimenuitem>Systemwerkzeuge</span>, <span class=guimenuitem>Einstellungen</span>, <span class=guimenuitem>Sessions</span>).</p></div><div class=paragraph><p>Um die gewünschten Effekte und Einstellungen zu konfigurieren, starten Sie (wieder als normaler Benutzer) den Compiz Config Einstellungs-Manager:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ccsm</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In GNOME finden Sie diese Einstellungen wieder im Menü unter <span class=guimenuitem>Systemwerkzeuge</span>, <span class=guimenuitem>Einstellungen</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn Sie "gconf support" während der Installation ausgewählt haben, können Sie diese Einstellungen auch im <code>gconf-editor</code> unter <code>apps/compiz</code> finden.</p></div></div></div><div class=sect2><h3 id=x11-troubleshooting>7.9. Fehlersuche<a class=anchor href=#x11-troubleshooting></a></h3><div class=paragraph><p>Wenn die Maus nicht funktioniert, müssen Sie diese zuerst konfigurieren. In neueren Versionen von Xorg werden die <code>InputDevice</code>-Abschnitte in <span class=filename>xorg.conf</span> ignoriert, um stattdessen die automatisch erkannten Geräte zu verwenden. Um das alte Verhalten wiederherzustellen, fügen Sie folgende Zeile zum Abschnitt <code>ServerLayout</code> oder <code>ServerFlags</code> dieser Datei hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;AutoAddDevices&#34; &#34;false&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wie zuvor erwähnt, wird standardmäßig der hald-Dienst automatisch die Tastatur erkennen. Es kann jedoch passieren, dass das Tastaturlayout oder das Modell nicht korrekt erkannt wird. Grafische Oberflächen wie GNOME, KDE oder Xfce stellen Werkzeuge für die Konfiguration der Tastatur bereit. Es ist allerdings auch möglich, die Tastatureigenschaften direkt zu setzen, entweder mit Hilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=setxkbmap&amp;sektion=1&amp;format=html">setxkbmap(1)</a> oder mit einer Konfigurationsregel von hald.</p></div><div class=paragraph><p>Wenn Sie zum Beispiel eine PC 102-Tasten Tastatur mit französischem Layout verwenden möchten, müssen sie eine Tastaturkonfigurationsdatei <span class=filename>x11-input.fdi</span> für hald im Verzeichnis <span class=filename>/usr/local/etc/hal/fdi/policy</span> anlegen. Diese Datei sollte die folgenden Zeilen enthalten:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;deviceinfo version=&#34;0.2&#34;&gt;
  &lt;device&gt;
    &lt;match key=&#34;info.capabilities&#34; contains=&#34;input.keyboard&#34;&gt;
      &lt;merge key=&#34;input.x11_options.XkbModel&#34; type=&#34;string&#34;&gt;pc102&lt;/merge&gt;
      &lt;merge key=&#34;input.x11_options.XkbLayout&#34; type=&#34;string&#34;&gt;fr&lt;/merge&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;</pre></div></div><div class=paragraph><p>Wenn diese Datei bereits existiert, kopieren Sie nur die Zeilen in die Datei, welche die Tastaturkonfiguration betreffen.</p></div><div class=paragraph><p>Sie müssen Ihren Computer neu starten, um hald zu zwingen, diese Datei einzulesen.</p></div><div class=paragraph><p>Es ist auch möglich, die gleiche Konfiguration von einem X-Terminal oder einem Skript über den folgenden Befehl heraus zu tätigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setxkbmap <span class=nt>-model</span> pc102 <span class=nt>-layout</span> fr</code></pre></div></div><div class=paragraph><p><span class=filename>/usr/local/shared/X11/xkb/rules/base.lst</span> enthält die zur Verfügung stehenden Tastatur- und Layoutoptionen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Konfigurationsdatei <span class=filename>xorg.conf.new</span> kann nun an bestimmte Bedürfnisse angepasst werden. Öffnen Sie die Datei in einem Editor, wie <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a>. Falls der Monitor ein älteres oder ungewöhnliches Modell ist und keine automatische Erkennung unterstützt, können die Synchronisationsfrequenzen im Abschnitt <code>"Monitor"</code> der <span class=filename>xorg.conf.new</span> eingetragen werden.</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
      Identifier   &#34;Monitor0&#34;
      VendorName   &#34;Monitor Vendor&#34;
      ModelName    &#34;Monitor Model&#34;
      HorizSync    30-107
      VertRefresh  48-120
EndSection</pre></div></div><div class=paragraph><p>Die meisten Monitore unterstützen die automatische Erkennung der Synchronisationsfrequenzen, so dass eine manuelle Eingabe der Werte nicht erforderlich ist. Für die wenigen Monitore, die keine automatische Erkennung unterstützen, sollten nur die vom Hersteller zur Verfügung gestellten Werte eingegeben werden, um einen möglichen Schaden zu vermeiden.</p></div><div class=paragraph><p>X unterstützt die Energiesparfunktionen (DPMS, Energy Star) für Monitore. Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=xset&amp;sektion=1&amp;format=html">xset(1)</a> können die Zeitlimits für die DPMS-Modi standby, suspend, off vorgeben, oder zwingend aktiviert werden. Die DPMS-Funktionen können mit der folgenden Zeile im Abschnitt <code>"Monitor"</code> aktiviert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>Option         &#34;DPMS&#34;</pre></div></div><div class=paragraph><p>Die gewünschte Auflösung und Farbtiefe stellen sie im Abschnitt <code>"Screen"</code> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
      Identifier &#34;Screen0&#34;
      Device     &#34;Card0&#34;
      Monitor    &#34;Monitor0&#34;
      DefaultDepth 24
      SubSection &#34;Display&#34;
	      Viewport  0 0
	      Depth     24
	      Modes     &#34;1024x768&#34;
      EndSubSection
EndSection</pre></div></div><div class=paragraph><p>Mit <code>DefaultDepth</code> wird die standardmäßige Farbtiefe angegeben. Mit der Option <code>-depth</code> von <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a> lässt sich die vorgegebene Farbtiefe überschreiben. <code>Modes</code> gibt die Auflösung für die angegebene Farbtiefe an. Die Farbtiefe im Beispiel beträgt 24 Bits pro Pixel, die zugehörige Auflösung ist 1024x768 Pixel. Beachten Sie, dass in der Voreinstellung nur Standard-VESA-Modi der Grafikkarte angegeben werden können.</p></div><div class=paragraph><p>Sichern Sie die Konfigurationsdatei. Testen Sie anschließend die Konfiguration, wie oben beschrieben.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bei der Fehlersuche stehen Ihnen die Protokolldateien von Xorg zur Verfügung. Die Protokolle enthalten Informationen über alle Geräte, die mit dem Xorg-Server verbunden ist. Die Namen der Xorg-Protkolldateien haben das Format <span class=filename>/var/log/Xorg.0.log</span>. Der exakte Name der Datei variiert dabei von <span class=filename>Xorg.0.log</span> bis <span class=filename>Xorg.8.log</span>, und so weiter.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn alles funktioniert, installieren Sie die Datei an einen Ort, an dem <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a> sie finden kann. Typischerweise ist dies <span class=filename>/etc/X11/xorg.conf</span> oder <span class=filename>/usr/local/etc/X11/xorg.conf</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp xorg.conf.new /etc/X11/xorg.conf</span></code></pre></div></div><div class=paragraph><p>Damit ist die Konfiguration von Xorg abgeschlossesn. Xorg kann nun mit dem Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a> gestartet werden. Alternativ kann der Xorg-Server auch mithilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> gestartet werden.</p></div><div class=sect3><h4 id=_konfiguration_des_intel_i810_graphics_chipsets>7.9.1. Konfiguration des Intel® <code>i810</code> Graphics Chipsets<a class=anchor href=#_konfiguration_des_intel_i810_graphics_chipsets></a></h4><div class=paragraph><p>Der Intel® i810-Chipset benötigt den Treiber <span class=filename>agpgart</span>, die AGP-Schnittstelle für Xorg. Die Manualpage für den Treiber <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> enthält weitere Informationen.</p></div><div class=paragraph><p>Ab jetzt kann die Hardware wie jede andere Grafikkarte auch konfiguriert werden. Beachten Sie, dass der Treiber <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> nicht nachträglich in einen laufenden Kernel geladen werden kann. Er muss entweder fest im Kernel eingebunden sein, oder beim Systemstart über <span class=filename>/boot/loader.conf</span> geladen werden.</p></div></div><div class=sect3><h4 id=_einen_widescreen_monitor_einsetzen>7.9.2. Einen Widescreen-Monitor einsetzen<a class=anchor href=#_einen_widescreen_monitor_einsetzen></a></h4><div class=paragraph><p>Dieser Abschnitt geht über die normalen Konfigurationsarbeiten hinaus und setzt ein wenig Vorwissen voraus. Selbst wenn die Standardwerkzeuge zur X-Konfiguration bei diesen Geräten nicht zum Erfolg führen, gibt es in den Protokolldateien genug Informationen, mit denen Sie letztlich doch einen funktionierenden X-Server konfigurieren können. Alles, was Sie dazu benötigen, ist ein Texteditor.</p></div><div class=paragraph><p>Aktuelle Widescreen-Formate (wie WSXGA, WSXGA+, WUXGA, WXGA, WXGA+, und andere mehr) unterstützen Seitenverhältnisse wie 16:10 oder 10:9, die unter X Probleme verursachen können. Bei einem Seitenverhältnis von 16:10 sind beispielsweise folgende Auflösungen möglich:</p></div><div class=ulist><ul><li><p>2560x1600</p></li><li><p>1920x1200</p></li><li><p>1680x1050</p></li><li><p>1440x900</p></li><li><p>1280x800</p></li></ul></div><div class=paragraph><p>Irgendwann wird die Konfiguration vereinfacht werden, dass nur noch die Auflösung als <code>Mode</code> in <code>Section "Screen"</code> eingtragen wird, so wie hier:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
Identifier  &#34;Screen 0&#34;
Device	    &#34;Card 0&#34;
Monitor	    &#34;Monitor0&#34;
Default Depth 24
SubSection  &#34;Display&#34;
	ViewPort  0 0
	Depth	  24
	Modes	  &#34;1680x1050&#34;
EndSubSection
EndSection</pre></div></div><div class=paragraph><p>Xorg ist intelligent genug, um die Informationen zu den Auflösungen über I2C/DDC zu beziehen, und weiß daher, welche Auflösungen und Frequenzen der Widescreen-Monitor unterstützt.</p></div><div class=paragraph><p>Wenn diese <code>ModeLines</code> in den Treiberdateien nicht vorhanden sind, kann es sein, dass Sie Xorg beim Finden der korrekten Werte unterstützen müssen. Dazu extrahieren Sie die benötigten Informationen aus <span class=filename>/var/log/Xorg.0.log</span> und erzeugen daraus eine funktionierende <code>ModeLine</code>. Suchen Sie nach Zeilen ähnlich den folgenden:</p></div><div class="literalblock programlisting"><div class=content><pre>(II) MGA(0): Supported additional Video Mode:
(II) MGA(0): clock: 146.2 MHz   Image Size:  433 x 271 mm
(II) MGA(0): h_active: 1680  h_sync: 1784  h_sync_end 1960 h_blank_end 2240 h_border: 0
(II) MGA(0): v_active: 1050  v_sync: 1053  v_sync_end 1059 v_blanking: 1089 v_border: 0
(II) MGA(0): Ranges: V min: 48  V max: 85 Hz, H min: 30  H max: 94 kHz, PixClock max 170 MHz</pre></div></div><div class=paragraph><p>Diese Informationen werden auch als EDID-Informationen bezeichnet. Um daraus eine funktionierende <code>ModeLine</code> zu erzeugen, müssen lediglich die Zahlen in die korrekte Reihenfolge gebracht werden:</p></div><div class="literalblock programlisting"><div class=content><pre>ModeLine &lt;name&gt; &lt;clock&gt; &lt;4 horiz. timings&gt; &lt;4 vert. timings&gt;</pre></div></div><div class=paragraph><p>Die korrekte <code>ModeLine</code> in <code>Section "Monitor"</code> würde für dieses Beispiel folgendermaßen aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
Identifier      &#34;Monitor1&#34;
VendorName      &#34;Bigname&#34;
ModelName       &#34;BestModel&#34;
ModeLine        &#34;1680x1050&#34; 146.2 1680 1784 1960 2240 1050 1053 1059 1089
Option          &#34;DPMS&#34;
EndSection</pre></div></div><div class=paragraph><p>Nachdem diese Äderungen durchgeführt sind, sollte X auch auf Ihrem neuen Widescreen-Monitor starten.</p></div></div><div class=sect3><h4 id=compiz-troubleshooting>7.9.3. Fehersuche in Compiz Fusion<a class=anchor href=#compiz-troubleshooting></a></h4><div class=sect4><h5 id=_ich_habe_compiz_fusion_installiert_und_anschließend_die_hier_erwähnten_kommandos_eingegeben_nun_fehlen_den_fenstern_die_titelleisten_und_schaltflächen_was_kann_ich_tun>7.9.3.1. Ich habe Compiz Fusion installiert und anschließend die hier erwähnten Kommandos eingegeben. Nun fehlen den Fenstern die Titelleisten und Schaltflächen. Was kann ich tun?<a class=anchor href=#_ich_habe_compiz_fusion_installiert_und_anschließend_die_hier_erwähnten_kommandos_eingegeben_nun_fehlen_den_fenstern_die_titelleisten_und_schaltflächen_was_kann_ich_tun></a></h5><div class=paragraph><p>Wahrscheinlich fehlt eine Einstellung in <span class=filename>/etc/X11/xorg.conf</span>. Überprüfen Sie diese Datei gründlich, und überprüfen Sie insbesondere die Richtlinien <code>DefaultDepth</code> und <code>AddARGBGLXVisuals</code>.</p></div></div><div class=sect4><h5 id=_wenn_ich_compiz_fusion_starte_bringt_dass_den_x_server_zum_absturz_was_kann_ich_tun>7.9.3.2. Wenn ich Compiz Fusion starte, bringt dass den X-Server zum Absturz. Was kann ich tun?<a class=anchor href=#_wenn_ich_compiz_fusion_starte_bringt_dass_den_x_server_zum_absturz_was_kann_ich_tun></a></h5><div class=paragraph><p>Wenn Sie <span class=filename>/var/log/Xorg.0.log</span> durchsuchen, finden Sie wahrscheinlich Fehlermeldungen, die während des Starts von X ausgegeben werden. Die häufigste Meldung ist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     Failed to initialize the GLX module<span class=p>;</span> please check <span class=k>in </span>your X
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     log file that the GLX module has been loaded <span class=k>in </span>your X
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     server, and that the module is the NVIDIA GLX module.  If
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     you <span class=k>continue </span>to encounter problems, Please try
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     reinstalling the NVIDIA driver.</code></pre></div></div><div class=paragraph><p>Dies ist für gewöhnlich der Fall, wenn Sie Xorg aktualisieren. Sie müssen das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-driver/>x11/nvidia-driver</a> neu installieren, damit GLX neu gebaut wird.</p></div><div class=paragraph><p>path: "/books/handbook/partii/"
---
:leveloffset: +1</p></div></div></div></div></div></div><h1 id=desktop class=sect0>Teil II: Desktop-Anwendungen<a class=anchor href=#desktop></a></h1><div class=sect1><h2 id=desktop-synopsis>Kapitel 8. Übersicht<a class=anchor href=#desktop-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Obwohl FreeBSD wegen seiner Leistung und Stabilität vor allem auf Serversystemen sehr beliebt ist, so ist es auch für den täglichen Einsatz als Desktop geeignet. Mit über 36000 Anwendungen, die als Pakete oder Ports vorliegen, ist es leicht einen individuellen Desktop zu bauen, auf dem eine Vielzahl von Desktop-Anwendungen laufen. Dieses Kapitel zeigt, wie Sie die zahlreichen Desktop-Anwendungen, wie Web-Browser, Office-Pakete, Dokumentbetrachter und Finanzsoftware, installieren können.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Benutzer die es vorziehen eine vorkonfigurierte Desktop-Version von FreeBSD zu installieren, anstatt das System von Grund auf zu konfigurieren, sollten sich <a href=https://www.furybsd.org>FuryBSD</a>, <a href=https://ghostbsd.org>GhostBSD</a> oder <a href=https://www.midnightbsd.org>MidnightBSD</a> ansehen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie wissen:</p></div><div class=ulist><ul><li><p>wie zusätzliche Anwendungen als Paket oder aus der Ports-Sammlung installiert werden. Dies wird in <a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a> beschrieben.</p></li><li><p>wie X und ein Window-Manager installiert wird. Dies wird in <a href=./#x11>Das X-Window-System</a> beschrieben.</p></li></ul></div><div class=paragraph><p>Informationen zur Konfiguration von Multimedia-Anwendungen finden Sie in <a href=./#multimedia>Multimedia</a>.</p></div></div></div><div class=sect1><h2 id=desktop-browsers>Kapitel 9. Browser<a class=anchor href=#desktop-browsers></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD besitzt keinen vorinstallierten Browser, stattdessen enthält das <a href=https://www.FreeBSD.org/ports/>www</a>-Verzeichnis der Ports-Sammlung viele Browser, die als Paket oder aus der Ports-Sammlung installiert werden können.</p></div><div class=paragraph><p>Die Desktop-Umgebungen KDE und GNOME verfügen über eigene HTML-Browser. Weitere Informationen zur Einrichtung dieser Umgebungen finden Sie in <a href=./#x11-wm>“Grafische Oberflächen”</a>.</p></div><div class=paragraph><p>Besonders schlanke Browser sind <a class=package href=https://cgit.freebsd.org/ports/tree/www/dillo2/>www/dillo2</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/www/links/>www/links</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/www/w3m/>www/w3m</a>.</p></div><div class=paragraph><p>Dieser Abschnitt demonstriert, wie die folgenden gängigen Webbrowser installiert werden, sowie den Ressourcenbedarf, den Installationsaufwand beim Übersetzen des Ports, oder ob die Anwendung wichtige Abhängigkeiten benötigt.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Anwendung</th><th class="tableblock halign-left valign-top">Ressourcenbedarf</th><th class="tableblock halign-left valign-top">Installationsaufwand aus den Ports</th><th class="tableblock halign-left valign-top">Anmerkungen</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>mittel</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD, Linux® und lokalisierte Versionen sind verfügbar</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Konqueror</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>mittel</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Benötigt KDE-Biliotheken</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chromium</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>mittel</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Benötigt Gtk+</p></td></tr></tbody></table><div class=sect2><h3 id=_firefox>9.1. Firefox<a class=anchor href=#_firefox></a></h3><div class=paragraph><p>Firefox ist ein Open-Source Browser. Er bietet eine dem HTML-Standard konforme Anzeige, Browserfenster als Tabs, Blockierung von Pop-up-Fenstern, Erweiterungen, verbesserte Sicherheit und mehr. Firefox basiert auf der Mozilla Codebasis.</p></div><div class=paragraph><p>Installieren Sie das Paket der aktuellen Release-Version von Firefox:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install firefox</span></code></pre></div></div><div class=paragraph><p>Um stattdessen die Extended Support Release (ESR) Version zu installieren, benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install firefox-esr</span></code></pre></div></div><div class=paragraph><p>Alternativ kann auch die Ports-Sammlung verwendet werden, um die gewünschte Version von Firefox aus dem Quellcode zu installieren. Dieses Beispiel baut <a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a>, wobei sich <code>firefox</code> durch die ESR oder die lokalisierte Version ersetzen lässt.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/firefox</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_konqueror>9.2. Konqueror<a class=anchor href=#_konqueror></a></h3><div class=paragraph><p>Konqueror ist mehr als nur ein Webbrowser, da es ebenfalls Dateimanager und Multimedia-Betrachter ist. Es unterstützt sowohl WebKit als auch sein eigenes KHTML. WebKit wird von vielen modernen Browsern verwendet, einschließlich Chromium.</p></div><div class=paragraph><p>Das Konqueror-Paket wird wie folgt installiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install konqueror</span></code></pre></div></div><div class=paragraph><p>Alternativ können Sie den Port installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/konqueror</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_chromium>9.3. Chromium<a class=anchor href=#_chromium></a></h3><div class=paragraph><p>Chromium ist ein quelloffenes Browserprojekt mit dem Ziel ein sicheres, schnelleres und stabileres Surferlebnis im Web zu ermöglichen. Chromium ermöglicht surfen mit Tabs, Blockieren von Pop-Ups, Erweiterungen und vieles mehr. Chromium ist das Open Source Projekt, welches auf dem Google Chrome Webbrowser basiert.</p></div><div class=paragraph><p>Chromium kann als Paket durch die Eingabe des folgenden Befehls installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install chromium</span></code></pre></div></div><div class=paragraph><p>Als Alternative kann Chromium aus dem Quellcode durch die Ports Collection übersetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/chromium</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die ausführbare Datei für Chromium ist <span class=filename>/usr/local/bin/chrome</span> und nicht <span class=filename>/usr/local/bin/chromium</span>.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=desktop-productivity>Kapitel 10. Büroanwendungen<a class=anchor href=#desktop-productivity></a></h2><div class=sectionbody><div class=paragraph><p>Neue Benutzer suchen oft ein komplettes Office-Paket oder eine leicht zu bedienende Textverarbeitung. Einige <a href=./#x11-wm>graphische Oberflächen</a> wie KDE enthalten zwar ein Office-Paket, diese werden unter FreeBSD jedoch nicht standardmäßig installiert. Unabhängig von der installierten graphischen Oberfläche können diverse Office-Pakete jederzeit installiert werden.</p></div><div class=paragraph><p>Dieser Abschnitt demonstriert, wie die folgenden gängigen Büroanwendungen installiert werden, sowie den Ressourcenbedarf, den Installationsaufwand beim Übersetzen des Ports, oder ob die Anwendung wichtige Abhängigkeiten benötigt.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Anwendung</th><th class="tableblock halign-left valign-top">Ressourcenbedarf</th><th class="tableblock halign-left valign-top">Installationsaufwand aus den Ports</th><th class="tableblock halign-left valign-top">wichtige Abhängigkeiten</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Calligra</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AbiWord</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ oder GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>The Gimp</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Apache OpenOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>enorm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>JDK™ und Mozilla</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>LibreOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>etwas hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>enorm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+, KDE/ GNOME oder JDK™</p></td></tr></tbody></table><div class=sect2><h3 id=_calligra>10.1. Calligra<a class=anchor href=#_calligra></a></h3><div class=paragraph><p>Die KDE-Gemeinschaft stellt ein Office-Paket bereit, das auch separat von KDE eingesetzt werden kann. Calligra umfasst Standardkomponenten, die auch in anderen Office-Paketen enthalten sind. Words ist die Textverarbeitung, Sheets die Tabellenkalkulation, mit Stage werden Präsentationen erstellt und Karbon ist ein Zeichenprogramm.</p></div><div class=paragraph><p>In FreeBSD kann <a class=package href=https://cgit.freebsd.org/ports/tree/editors/calligra/>editors/calligra</a> als Paket oder Port installiert werden. Um das Paket zu installieren, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install calligra</span></code></pre></div></div><div class=paragraph><p>Wenn das Paket nicht verfügbar ist, benutzen Sie stattdessen die Ports-Sammlung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/calligra</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_abiword>10.2. AbiWord<a class=anchor href=#_abiword></a></h3><div class=paragraph><p>AbiWord ist eine freie Textverarbeitung, die dem Erscheinungsbild von Microsoft® Word ähnlich ist. Das Programm ist schnell, besitzt viele Funktionen und ist benutzerfreundlich.</p></div><div class=paragraph><p>AbiWord kann viele Dateiformate importieren oder exportieren, unter anderem auch propietäre wie Microsoft® <span class=filename>.rtf</span>.</p></div><div class=paragraph><p>Das AbiWord-Paket installieren Sie wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install abiword</span></code></pre></div></div><div class=paragraph><p>Sollte das Paket nicht zur Verfügung stehen, kann es über die Ports-Sammlung installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/abiword</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_the_gimp>10.3. The GIMP<a class=anchor href=#_the_gimp></a></h3><div class=paragraph><p>The GIMP ist ein ausgereiftes Bildverarbeitungsprogramm mit dem Bilder erstellt oder retuschiert werden können. Es kann sowohl als einfaches Zeichenprogramm oder zum retuschieren von Fotografien benutzt werden. Das Programm besitzt eine eingebaute Skriptsprache und es existieren sehr viele Plugins. The GIMP kann zahlreiche Formate lesen und speichern und stellt Schnittstellen zu Scannern und Tablets zur Verfügung.</p></div><div class=paragraph><p>Um das Paket zu installieren, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gimp</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie alternativ die Ports-Sammlung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/gimp</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Die Kategorie <em>graphics</em> (<a href=https://www.FreeBSD.org/ports/graphics.html>freebsd.org/ports/graphics.html</a>) der Ports-Sammlung enthält für The Gimp verschiedene Plugins, Hilfedateien und Handbücher.</p></div></div><div class=sect2><h3 id=_apache_openoffice>10.4. Apache OpenOffice<a class=anchor href=#_apache_openoffice></a></h3><div class=paragraph><p>Apache OpenOffice ist eine Open Source Büroanwendung, die unter Leitung der Apache Software Foundation weiterentwickelt wird. Es enthält die typischen Anwendungen eines Office-Pakets: Textverarbeitung, Tabellenkalkulation, Präsentation und ein Zeichenprogramm. Die Bedienung gleicht anderen Office-Paketen und das Programm kann zahlreiche Dateiformate importieren und exportieren. Es gibt lokalisierte Versionen mit angepassten Menüs, Rechtschreibkontrollen und Wörterbüchern.</p></div><div class=paragraph><p>Die Textverarbeitung von Apache OpenOffice speichert Dateien im XML-Format. Dadurch wird die Verwendbarkeit der Dateien auf anderen Systemen erhöht und die Handhabung der Daten vereinfacht. Die Tabellenkalkulation besitzt eine Makrosprache und eine Schnittstelle zu Datenbanken. Apache OpenOffice läuft stabil auf Windows®, Solaris™, Linux®, FreeBSD und Mac OS® X. Weitere Informationen über Apache OpenOffice finden Sie auf <a href=http://www.openoffice.org/>openoffice.org</a>. Spezifische Informationen für FreeBSD finden Sie auf <a href=http://porting.openoffice.org/freebsd/>porting.openoffice.org/freebsd/</a>.</p></div><div class=paragraph><p>Apache OpenOffice installieren Sie wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install apache-openoffice</span></code></pre></div></div><div class=paragraph><p>Nachdem das Paket installiert ist, geben Sie folgenden ein, um Apache OpenOffice zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% openoffice-X.Y.Z</code></pre></div></div><div class=paragraph><p>wobei <em>X.Y.Z</em> die Versionsnummer von Apache OpenOffice darstellt. Nach dem ersten Start werden einige Fragen gestellt. Außerdem wird im Heimatverzeichnis des Benutzers ein Verzeichnis <span class=filename>.openoffice.org</span> angelegt.</p></div><div class=paragraph><p>Falls das gewünschte Apache OpenOffice-Paket nicht verfügbar ist, kann immer noch der Port übersetzt werden. Es erfordert jedoch eine Menge Plattenplatz und ziemlich viel Zeit um die Quellen zu übersetzten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/openoffice-4</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um eine lokalisierte Version zu bauen, ersetzen Sie den letzten Befehl durch:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make LOCALIZED_LANG=Ihre_Sprache install clean</span></code></pre></div></div><div class=paragraph><p>Ersetzen Sie <em>Ihre_Sprache</em> durch den korrekten ISO-Code. Eine Liste der unterstützten Codes steht in <span class=filename>files/Makefile.localized</span>, die sich im Portsverzeichnis befindet.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_libreoffice>10.5. LibreOffice<a class=anchor href=#_libreoffice></a></h3><div class=paragraph><p>LibreOffice ist ein frei verfügbares Office-Paket, welches von <a href=http://www.documentfoundation.org/>documentfoundation.org</a> entwickelt wird. Es mit anderen großen Office-Paketen kompatibel und für eine Vielzahl von Plattformen erhältlich. Es ist ein Fork von Apache OpenOffice unter neuem Namen, das alle Anwendungen in einem kompletten Office-Paket enthält: Textverarbeitung, Tabellenkalkulation, Präsentationsmanager, Zeichenprogramm, Datenbankmanagementprogramm und ein Werkzeug zum Erstellen und Bearbeiten von mathematischen Formeln. Das Programm steht in verschiedenen Sprachen zur Verfügung, und die Internationalisierung wurde auf die Oberfläche, Rechtschreibkorrektur und die Wörterbücher ausgeweitet.</p></div><div class=paragraph><p>Das Textverarbeitungsprogramm von LibreOffice benutzt ein natives XML-Dateiformat für erhöhte Portabilität und Flexibilität. Die Tabellenkalkulation enthält eine Makrosprache und kann mit externen Datenbanken Verbindungen herstellen. LibreOffice ist stabil und läuft nativ auf Windows®, Linux®, FreeBSD und Mac OS® X. Weitere Informationen zu LibreOffice finden Sie unter <a href=http://www.libreoffice.org/>libreoffice.org</a>.</p></div><div class=paragraph><p>Um die englische Version von LibreOffice als Paket zu installieren, geben Sie folgenden Befehl ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install libreoffice</span></code></pre></div></div><div class=paragraph><p>Die Kategorie <em>editors</em> (<a href=https://www.FreeBSD.org/ports/>freebsd.org/ports/</a>) der Ports-Sammlung enthält viele Lokalisierungen für LibreOffice. Wenn Sie ein lokalisiertes Paket installieren, ersetzen Sie <code>libreoffice</code> durch den Namen des lokalisierten Pakets.</p></div><div class=paragraph><p>Wenn das Paket installiert ist, geben Sie folgendes Kommando ein, um LibreOffice zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% libreoffice</code></pre></div></div><div class=paragraph><p>Während des ersten Starts werden einige Fragen gestellt. Außerdem wird im Heimatverzeichinis des Benutzers ein Verzeichnis <span class=filename>.libreoffice</span> angelegt.</p></div><div class=paragraph><p>Falls das gewünschte LibreOffice-Paket nicht verfügbar ist, kann immer noch der Port übersetzt werden. Es erfordert jedoch eine Menge Plattenplatz und ziemlich viel Zeit um die Quellen zu übersetzten. Dieses Beispiel übersetzt die englische Version:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/libreoffice</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um eine lokalisierte Version zu bauen, wechseln Sie mit <code>cd</code> in das Portverzeichnis der gewünschten Sprache. Unterstützte Sprachen finden Sie in der Kategorie <em>editors</em> (<a href=https://www.FreeBSD.org/ports/> freebsd.org/ports/</a>) der Ports-Sammlung.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=desktop-viewers>Kapitel 11. Anzeigen von Dokumenten<a class=anchor href=#desktop-viewers></a></h2><div class=sectionbody><div class=paragraph><p>Einige neuere Dokumentformate, die sich aktuell großer Beliebtheit erfreuen, können Sie sich mit den im Basissystem enthaltenen Programmen möglicherweise nicht ansehen. Dieser Abschnitt zeigt, wie Sie die folgenden Dokumentbetrachter installieren können:</p></div><div class=paragraph><p>Die nachstehenden Anwendungen werden behandelt:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Anwendung</th><th class="tableblock halign-left valign-top">Ressourcenbedarf</th><th class="tableblock halign-left valign-top">Installationsaufwand aus den Ports</th><th class="tableblock halign-left valign-top">wichtige Abhängigkeiten</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Xpdf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeType</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Xaw3d</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Geeqie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ oder GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ePDFView</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Okular</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect2><h3 id=_xpdf>11.1. Xpdf<a class=anchor href=#_xpdf></a></h3><div class=paragraph><p>Für Benutzer, die einen schnellen PDF-Betrachter bevorzugen, bietet Xpdf eine schlanke und effiziente Alternative, die wenig Ressourcen benötigt. Da das Programm die Standard X-Zeichensätze benutzt, ist es nicht auf andere Toolkits angewiesen.</p></div><div class=paragraph><p>Um das Xpdf-Paket zu installieren, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xpdf</span></code></pre></div></div><div class=paragraph><p>Wenn das Paket nicht verfügbar ist, benutzen Sie die Ports-Sammlung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/xpdf</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Starten Sie nach der Installation <code>xpdf</code> und aktivieren Sie das Menü mit der rechten Maustaste.</p></div></div><div class=sect2><h3 id=_gv>11.2. gv<a class=anchor href=#_gv></a></h3><div class=paragraph><p>gv kann PostScript®- und PDF-Dokumente anzeigen. Es stammt von ghostview ab, hat aber wegen der Xaw3d-Bibliothek eine schönere Benutzeroberfläche. gv besitzt viele konfigurierbare Funktionen, wie z. B. Ausrichtung, Papiergröße, Skalierung und Kantenglättung (Anti-Aliasing). Fast jede Operation kann sowohl mit der Tastatur als auch mit der Maus durchgeführt werden.</p></div><div class=paragraph><p>Installieren Sie das gv-Paket wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gv</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie die Ports-Sammlung, wenn das Paket nicht zur Verfügung steht:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/print/gv</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_geeqie>11.3. Geeqie<a class=anchor href=#_geeqie></a></h3><div class=paragraph><p>Geeqie ist ein Fork des nicht mehr betreuten GQview Projekts, mit dem Ziel die Entwicklung weiter voranzutreiben und bestehende Fehlerkorrekturen zu integrieren. Mit Geeqie lassen sich Bilder verwalten. Es kann unter anderem Bilder anzeigen, einen externen Editor starten und eine Vorschau (thumbnail) erzeugen. Zudem beherrscht Geeqie einen Diashow-Modus und einige grundlegende Dateioperationen, was die Verwaltung von Bildern und das auffinden von doppelten Dateien erleichtert. Geeqie unterstützt Vollbild-Ansicht und Internationalisierung.</p></div><div class=paragraph><p>Um das Geeqie-Paket zu installieren, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install geeqie</span></code></pre></div></div><div class=paragraph><p>Wenn das Paket nicht verfügbar ist, benutzen Sie die Ports-Sammlung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/geeqie</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_epdfview>11.4. ePDFView<a class=anchor href=#_epdfview></a></h3><div class=paragraph><p>ePDFView ist ein leichtgewichtiger PDF-Betrachter, der nur die Gtk+- und Poppler-Bibliotheken benötigt. Es befindet sich derzeit noch in Entwicklung, kann aber bereits die meisten PDF-Dateien (auch verschlüsselte) öffnen, speichern und über CUPS drucken.</p></div><div class=paragraph><p>Um das Paket ePDFView zu installieren, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install epdfview</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie die Ports-Sammlung, falls das Paket nicht verfügbar ist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/epdfview</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_okular>11.5. Okular<a class=anchor href=#_okular></a></h3><div class=paragraph><p>Okular ist ein universeller Dokumentbetrachter der auf KPDF für KDE basiert. Es kann die meisten Formate öffnen, einschließlich PDF, PostScript®, DjVu, CHM, XPS und ePub.</p></div><div class=paragraph><p>Um das Paket Okular zu installieren, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install okular</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie die Ports-Sammlung, falls das Paket nicht verfügbar ist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/okular</span>
<span class=c># make install clean</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=desktop-finance>Kapitel 12. Finanzsoftware<a class=anchor href=#desktop-finance></a></h2><div class=sectionbody><div class=paragraph><p>Zur Verwaltung der persönlichen Finanzen können einige leistungsfähige und einfach zu bedienende Anwendungen installiert werden. Einige von ihnen unterstützen verbreitete Formate, darunter Dateiformate, die von Quicken und Excel verwendet werden.</p></div><div class=paragraph><p>Dieser Abschnitt behandelt die folgenden Anwendungen:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Anwendung</th><th class="tableblock halign-left valign-top">Ressourcenbedarf</th><th class="tableblock halign-left valign-top">Installationsaufwand aus den Ports</th><th class="tableblock halign-left valign-top">wichtige Abhängigkeiten</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GnuCash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnumeric</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KMyMoney</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>niedrig</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>hoch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect2><h3 id=_gnucash>12.1. GnuCash<a class=anchor href=#_gnucash></a></h3><div class=paragraph><p>GnuCash ist Teil des GNOME-Projekts, mit dem Ziel, leicht zu bedienende und leistungsfähige Anwendungen bereitzustellen. Mit GnuCash können Einnahmen und Ausgaben, Bankkonten und Wertpapiere verwaltet werden. Das Programm ist leicht zu bedienen und genügt dennoch hohen Ansprüchen.</p></div><div class=paragraph><p>GnuCash stellt ein Register, ähnlich dem in einem Scheckheft und ein hierarchisches System von Konten zur Verfügung. Eine Transaktion kann in einzelne Teile aufgespaltet werden. GnuCash kann Quicken-Dateien (QIF) importieren und einbinden. Weiterhin unterstützt das Programm die meisten internationalen Formate für Zeitangaben und Währungen. Die Bedienung des Programms kann durch zahlreiche Tastenkombinationen und dem automatischen Vervollständigen von Eingaben beschleunigt werden.</p></div><div class=paragraph><p>Das GnuCash-Paket installieren Sie wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnucash</span></code></pre></div></div><div class=paragraph><p>Wenn das Paket nicht zur Verfügung steht, benutzen Sie die Ports-Sammlung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/gnucash</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_gnumeric>12.2. Gnumeric<a class=anchor href=#_gnumeric></a></h3><div class=paragraph><p>Gnumeric ist eine Tabellenkalkulation, die von der GNOME-Gemeinschaft entwickelt wird. Das Programm kann Eingaben anhand des Zellenformats oder einer Folge von Eingaben vervollständigen. Dateien verbreiteter Formate, wie die von Excel, Lotus 1-2-3 oder Quattro Pro lassen sich importieren. Es besitzt viele eingebaute Funktionen und Zellenformate, darunter die üblichen wie Zahl, Währung, Datum, Zeit, und viele weitere.</p></div><div class=paragraph><p>Installieren Sie das Gnumeric-Paket mit folgendem Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnumeric</span></code></pre></div></div><div class=paragraph><p>Wenn das Paket nicht zur Verfügung steht, benutzen Sie die Ports-Sammlung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/math/gnumeric</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect2><h3 id=_kmymoney>12.3. KMyMoney<a class=anchor href=#_kmymoney></a></h3><div class=paragraph><p>KMyMoney ist ein Programm zur Verwaltung der persönlichen Finanzen, das von der KDE-Gemeinschaft entwickelt wird. KMyMoney hat das Ziel, wichtige Funktionen zu bieten, die auch von kommerziellen Programmen zur Verwaltung der persönlichen Finanzen unterstützt werden. Zudem zählen eine einfache Bedienung sowie korrekte doppelte Buchführung zu den herausragenden Fähigkeiten dieses Programms. KMyMoney unterstützt den Import von Datendateien im Format Quicken (QIF), kann Investionen verfolgen, unterstützt verschiedene Währungen und bietet umfangreiche Reportmöglichkeiten.</p></div><div class=paragraph><p>Um das Paket KMyMoney zu installieren, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install kmymoney-kde4</span></code></pre></div></div><div class=paragraph><p>Sollte das Paket nicht verfügbar sein, benutzen Sie die Ports-Sammlung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/kmymoney2-kde4</span>
<span class=c># make install clean</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=multimedia>Kapitel 13. Multimedia<a class=anchor href=#multimedia></a></h2><div class=sectionbody><div class=sect2><h3 id=multimedia-synopsis>13.1. Übersicht<a class=anchor href=#multimedia-synopsis></a></h3><div class=paragraph><p>FreeBSD unterstützt viele unterschiedliche Soundkarten, die Benutzern den Genuss von Highfidelity-Klängen auf dem Computer ermöglichen. Dazu gehört unter anderem die Möglichkeit, Tonquellen in den Formaten MPEG Audio Layer 3 (MP3), Waveform Audio File (WAV), Ogg Vorbis und vielen weiteren Formaten aufzunehmen und wiederzugeben. Darüber hinaus enthält die FreeBSD Ports-Sammlung Anwendungen, die das Bearbeiten von aufgenommenen Tonspuren, das Hinzufügen von Klangeffekten und die Kontrolle der angeschlossenen MIDI-Geräte erlauben.</p></div><div class=paragraph><p>FreeBSD unterstützt auch die Wiedergabe von Videos und DVDs. Die FreeBSD Ports-Sammlung enthält Anwendungen, um verschiedene Video-Medien wiederzugeben, zu kodieren und zu konvertieren.</p></div><div class=paragraph><p>Dieses Kapitel beschreibt die Einrichtung von Soundkarten, Video-Wiedergabe, TV-Tuner Karten und Scannern unter FreeBSD. Es werden auch einige Anwendungen beschrieben, die für die Verwendung dieser Geräte zur Verfügung stehen.</p></div><div class=paragraph><p>Dieses Kapitel behandelt die folgenden Punkte:</p></div><div class=ulist><ul><li><p>Konfiguration einer Soundkarte in FreeBSD.</p></li><li><p>Fehlersuche bei Sound Einstellungen.</p></li><li><p>Wiedergabe und Kodierung von MP3s und anderen Audio-Formaten.</p></li><li><p>Vorbereitung des Systems für die Wiedergabe von Videos.</p></li><li><p>Wiedergabe von DVDs, <span class=filename>.mpg</span>- und <span class=filename>.avi</span>-Dateien.</p></li><li><p>Rippen von CDs und DVDs.</p></li><li><p>Konfiguration von TV-Karten.</p></li><li><p>Installation und Konfiguration von MythTV.</p></li><li><p>Konfiguration von Scannern</p></li><li><p>Konfiguration von Bluetooth-Kopfhörern</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>Wissen, wie Sie Anwendungen installieren (<a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=sound-setup>13.2. Soundkarten einrichten<a class=anchor href=#sound-setup></a></h3><div class=paragraph><p>Bevor Sie die Konfiguration beginnen, sollten Sie in Erfahrung bringen welches Soundkartenmodell und welcher Chip benutzt wird. FreeBSD unterstützt eine Reihe Soundkarten. Die <a href=https://www.FreeBSD.org/releases/12.0R/hardware/>Hardware-Notes</a> zählen alle unterstützten Karten und deren Treiber für FreeBSD auf.</p></div><div class=paragraph><p>Um die Soundkarte benutzen zu können, muss der richtige Gerätetreiber geladen werden. Am einfachsten ist es, das Kernelmodul für die Soundkarte mit <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> zu laden. Dieses Beispiel lädt den Treiber für einen integrierten Chipsatz, basierend auf der Intel Spezifikation:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_hda</span></code></pre></div></div><div class=paragraph><p>Um den Treiber automatisch beim Systemstart zu laden, fügen Sie folgende Zeile in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>snd_hda_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Weitere ladbare Soundmodule sind in <span class=filename>/boot/defaults/loader.conf</span> aufgeführt. Wenn Sie nicht sicher sind, welchen Gerätetreiber Sie laden müssen, laden Sie das Modul <span class=filename>snd_driver</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_driver</span></code></pre></div></div><div class=paragraph><p>Der Treiber <span class=filename>snd_driver</span> ist ein Meta-Treiber, der alle gebräuchlichen Treiber lädt und die Suche nach dem richtigen Treiber vereinfacht. Durch Hinzufügen des Meta-Treibers in <span class=filename>/boot/loader.conf</span> können alternativ alle Audio-Treiber geladen werden.</p></div><div class=paragraph><p>Um zu ermitteln, welcher Treiber für die Soundkarte vom Meta-Treiber <span class=filename>snd_driver</span> geladen wurde, geben Sie <code>cat /dev/sndstat</code> ein.</p></div><div class=sect3><h4 id=_soundkarten_in_der_kernelkonfiguration_einrichten>13.2.1. Soundkarten in der Kernelkonfiguration einrichten<a class=anchor href=#_soundkarten_in_der_kernelkonfiguration_einrichten></a></h4><div class=paragraph><p>Die Unterstützung für die Soundkarte kann auch direkt in den Kernel kompiliert werden. Weitere Informationen über den Bau eines Kernels finden Sie im <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a>.</p></div><div class=paragraph><p>Bei der Verwendung eines eigenen Kernels müssen Sie sicherstellen, dass der Treiber für das Audio-Framework in der Kernelkonfigurationsdatei vorhanden ist:</p></div><div class="literalblock programlisting"><div class=content><pre>device sound</pre></div></div><div class=paragraph><p>Als Nächstes muss die Unterstützung für die Soundkarte hinzugefügt werden. Um das Beispiel mit dem integrierten Intel Audio-Chipsatz aus dem vorherigen Abschnitt fortzusetzen, verwenden Sie die folgende Zeile in der Kernelkonfigurationsdatei:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_hda</pre></div></div><div class=paragraph><p>Lesen Sie die Manualpage des Treibers, um den entsprechenden Gerätenamen herauszufinden.</p></div><div class=paragraph><p>Nicht PnP-fähige ISA-Soundkarten benötigen eventuell Einstellungen, wie IRQ und I/O-Port in <span class=filename>/boot/device.hints</span>. Während des Systemstarts liest der <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> diese Datei und reicht die Einstellungen an den Kernel weiter. Für eine alte Creative SoundBlaster® 16 ISA-Karte, die sowohl den <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a>- als auch den <code>snd_sb16</code>-Treiber benötigt, müssen die folgenden Zeilen in die Kernelkonfigurationsdatei eingetragen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_sbc
device snd_sb16</pre></div></div><div class=paragraph><p>Wenn die Karte den I/O-Port <code>0x220</code> und IRQ <code>5</code> benutzt, müssen folgende Zeilen zusätzlich in <span class=filename>/boot/device.hints</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.sbc.0.at=&#34;isa&#34;
hint.sbc.0.port=&#34;0x220&#34;
hint.sbc.0.irq=&#34;5&#34;
hint.sbc.0.drq=&#34;1&#34;
hint.sbc.0.flags=&#34;0x15&#34;</pre></div></div><div class=paragraph><p>Die Syntax für <span class=filename>/boot/device.hints</span> wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a>, sowie in der Manualpage des jeweiligen Treibers beschrieben.</p></div><div class=paragraph><p>Das Beispiel verwendet die vorgegebenen Werte. Falls die Karteneinstellungen andere Werte vorgeben, müssen die Werte in der Kernelkonfiguration angepasst werden. Weitere Informationen zu dieser Soundkarte finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a>.</p></div></div><div class=sect3><h4 id=sound-testing>13.2.2. Die Soundkarte testen<a class=anchor href=#sound-testing></a></h4><div class=paragraph><p>Nachdem Sie den neuen Kernel gestartet oder das erforderliche Modul geladen haben, sollte die Soundkarte erkannt werden. Führen Sie <code>dmesg | grep pcm</code> aus, um dies zu überprüfen. Diese Ausgabe stammt von einem System mit einem integrierten Conexant CX20590 Chipsatz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pcm0: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> at nid 5 on hdaa0
pcm1: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> at nid 6 on hdaa0
pcm2: &lt;Conexant CX20590 <span class=o>(</span>Analog 2.0+HP/2.0<span class=o>)&gt;</span> at nid 31,25 and 35,27 on hdaa1</code></pre></div></div><div class=paragraph><p>Der Status der Karte kann auch mit diesem Kommando geprüft werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /dev/sndstat</span>
FreeBSD Audio Driver <span class=o>(</span>newpcm: 64bit 2009061500/amd64<span class=o>)</span>
Installed devices:
pcm0: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> <span class=o>(</span>play<span class=o>)</span>
pcm1: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> <span class=o>(</span>play<span class=o>)</span>
pcm2: &lt;Conexant CX20590 <span class=o>(</span>Analog 2.0+HP/2.0<span class=o>)&gt;</span> <span class=o>(</span>play/rec<span class=o>)</span> default</code></pre></div></div><div class=paragraph><p>Die Ausgabe kann für jede Soundkarte anders aussehen. Wenn das Gerät <span class=filename>pcm</span> nicht erscheint, prüfen Sie die Kernelkonfigurationsdatei und stellen Sie sicher, dass der richtige Treiber geladen oder in den Kernel kompiliert wurde. Im nächsten Abschnitt werden häufig auftretende Probleme sowie deren Lösungen besprochen.</p></div><div class=paragraph><p>Jetzt sollte die Soundkarte unter FreeBSD funktionieren. Wenn ein CD- oder DVD-Laufwerk an die Soundkarte angeschlossen ist, können Sie jetzt mit <a href="https://man.freebsd.org/cgi/man.cgi?query=cdcontrol&amp;sektion=1&amp;format=html">cdcontrol(1)</a> eine CD abspielen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdcontrol <span class=nt>-f</span> /dev/acd0 play 1</code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Audio CDs besitzen eine spezielle Kodierung. Daher sollten sie nicht mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> in das Dateisystem eingehangen werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Es gibt viele Anwendungen, wie <a class=package href=https://cgit.freebsd.org/ports/tree/audio/workman/>audio/workman</a>, die eine bessere Benutzerschnittstelle besitzen. Zur Wiedergabe von MP3-Audiodateien kann <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> installiert werden.</p></div><div class=paragraph><p>Eine weitere schnelle Möglichkeit die Karte zu prüfen, ist es, Daten an das Gerät <span class=filename>/dev/dsp</span> zu senden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>Datei <span class=o>&gt;</span> /dev/dsp</code></pre></div></div><div class=paragraph><p>Für <span class=filename>Datei</span> kann eine beliebige Datei verwendet werden. Wenn Sie einige Geräusche hören, funktioniert die Soundkarte.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Gerätedateien <span class=filename>/dev/dsp*</span> werden automatisch erzeugt, wenn sie das erste Mal benötigt werden. Werden sie nicht verwendet, sind sie hingegen nicht vorhanden und tauchen daher auch nicht in der Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> auf.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=bluetooth-headset>13.2.3. Konfiguration von Bluetooth-Soundgeräten<a class=anchor href=#bluetooth-headset></a></h4><div class=paragraph><p>Die Verbindung zu einem Bluetooth-Gerät wird in diesem Abschnitt nicht erläutert. Dazu finden Sie weitere Informationen in <a href=./#network-bluetooth>“Bluetooth”</a>.</p></div><div class=paragraph><p>Damit Bluetooth zusammen mit dem Soundsystem von FreeBSD funktioniert, müssen Benutzer zuerst <a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a> installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install virtual_oss</span></code></pre></div></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a> setzt voraus, dass <code>cuse</code> in den Kernel geladen wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload cuse</span></code></pre></div></div><div class=paragraph><p>Führen Sie folgenden Befehl aus, damit <code>cuse</code> beim Systemstart automatisch geladen wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf cuse_load=yes</span></code></pre></div></div><div class=paragraph><p>Um Kopfhörer mit <a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a> zu benutzten, muss nach der Verbindung mit einem Bluetooth-Audiogerät ein virtuelles Gerät erstellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># virtual_oss -C 2 -c 2 -r 48000 -b 16 -s 768 -R /dev/null -P /dev/bluetooth/headphones -d dsp</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code><em>headphones</em></code> ist in diesem Beispiel ein Hostname aus <span class=filename>/etc/bluetooth/hosts</span>. Stattdessen kann auch <code>BT_ADDR</code> verwendet werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=virtual_oss&amp;sektion=8&amp;format=html">virtual_oss(8)</a>.</p></div></div><div class=sect3><h4 id=troubleshooting>13.2.4. Fehlerbehebung<a class=anchor href=#troubleshooting></a></h4><div class=paragraph><p><a href=#multimedia-sound-common-error-messages>Typische Fehlermeldungen</a> zeigt typische Fehlermeldungen sowie deren Lösungen:</p></div><table id=multimedia-sound-common-error-messages class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 7. Typische Fehlermeldungen</caption><col style=width:30%><col style=width:70%><thead><tr><th class="tableblock halign-left valign-top">Fehler</th><th class="tableblock halign-left valign-top">Lösung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb_dspwr(XX) timed out</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Der I/O-Port ist nicht korrekt angegeben.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bad irq XX</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Der IRQ ist falsch angegeben. Stellen Sie sicher, dass der angegebene IRQ mit dem Sound IRQ übereinstimmt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: gus pcm not attached, out of memory</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Es ist nicht genug Speicher verfügbar, um das Gerät zu betreiben.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: can’t open /dev/dsp!</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Überprüfen Sie mit <code>fstat | grep dsp</code> ob eine andere Anwendung das Gerät geöffnet hat. Häufige Störenfriede sind esound oder die Sound-Unterstützung von KDE.</p></td></tr></tbody></table><div class=paragraph><p>Moderne Grafikkarten beinhalten oft auch ihre eigenen Soundtreiber, um HDMI zu verwenden. Diese Audiogeräte werden manchmal vor der eigentlichen, separaten Soundkarte aufgeführt und dadurch nicht als das Standardgerät zum Abspielen von Tönen benutzt. Um zu prüfen, ob das der Fall ist, führen Sie dmesg aus und suchen Sie nach der Zeichenfolge <code>pcm</code>. Die Ausgabe sieht in etwa so aus:</p></div><div class="literalblock programlisting"><div class=content><pre>...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 0 nid 1 on hdac0
pcm1: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 1 nid 1 on hdac0
pcm2: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 2 nid 1 on hdac0
pcm3: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: &lt;HDA Realtek ALC889 PCM #0 Analog&gt; at cad 2 nid 1 on hdac1
pcm5: &lt;HDA Realtek ALC889 PCM #1 Analog&gt; at cad 2 nid 1 on hdac1
pcm6: &lt;HDA Realtek ALC889 PCM #2 Digital&gt; at cad 2 nid 1 on hdac1
pcm7: &lt;HDA Realtek ALC889 PCM #3 Digital&gt; at cad 2 nid 1 on hdac1
...</pre></div></div><div class=paragraph><p>In diesem Beispiel wurde die Grafikkarte (<code>NVidia</code>) vor der Soundkarte (<code>Realtek ALC889</code>) aufgeführt. Um die Soundkarte als Standardabspielgerät einzusetzen, ändern Sie <code>hw.snd.default_unit</code> auf die Einheit, welche für das Abspielen benutzt werden soll:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.snd.default_unit=n</span></code></pre></div></div><div class=paragraph><p>Hier repräsentiert <code>n</code> die Nummer der Soundkarte, die verwendet werden soll, in diesem Beispiel also <code>4</code>. Sie können diese Änderung dauerhaft machen, indem Sie die folgende Zeile in <span class=filename>/etc/sysctl.conf</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.snd.default_unit=4</pre></div></div></div><div class=sect3><h4 id=sound-multiple-sources>13.2.5. Mehrere Tonquellen abspielen<a class=anchor href=#sound-multiple-sources></a></h4><div class=paragraph><p>Oft sollen mehrere Tonquellen gleichzeitig abgespielt werden. FreeBSD verwendet dazu <em>virtuelle Tonkanäle</em>. Virtuelle Kanäle mischen die Tonquellen im Kernel, sodass mehrere Kanäle benutzt werden können, als von der Hardware unterstützt werden.</p></div><div class=paragraph><p>Drei <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> Optionen stehen zur Konfiguration der virtuellen Kanäle zur Verfügung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl dev.pcm.0.play.vchans=4</span>
<span class=c># sysctl dev.pcm.0.rec.vchans=4</span>
<span class=c># sysctl hw.snd.maxautovchans=4</span></code></pre></div></div><div class=paragraph><p>Im Beispiel werden vier virtuelle Kanäle eingerichtet, eine im Normalfall ausreichende Anzahl. Sowohl <code>dev.pcm.0.play.vchans=4</code> und <code>dev.pcm.0.rec.vchans=4</code> sind die Anzahl der virtuellen Kanäle des Geräts <span class=filename>pcm0</span>, die fürs Abspielen und Aufnehmen verwendet werden und sie können konfiguriert werden, sobald das Gerät existiert. Da das Modul <span class=filename>pcm</span> unabhängig von den Hardware-Treibern geladen werden kann, gibt <code>hw.snd.maxautovchans</code> die Anzahl der virtuellen Kanäle an, die später eingerichtete Audiogeräte erhalten. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> für weitere Informationen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Anzahl der virtuellen Kanäle kann nicht geändert werden, solange das Gerät genutzt wird. Schließen Sie daher zuerst alle Programme wie Musikabspielprogramme oder Sound-Daemonen, die auf dieses Gerät zugreifen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die korrekte <span class=filename>pcm</span>-Gerätedatei wird automatisch zugeteilt, wenn ein Programm das Gerät <span class=filename>/dev/dsp0</span> anfordert.</p></div></div><div class=sect3><h4 id=_den_mixer_einstellen>13.2.6. Den Mixer einstellen<a class=anchor href=#_den_mixer_einstellen></a></h4><div class=paragraph><p>Die Voreinstellungen des Mixers sind im Treiber <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> fest kodiert. Es gibt zwar viele Anwendungen und Dienste, die den Mixer einstellen können und die eingestellten Werte bei jedem Start wieder setzen, am einfachsten ist es allerdings, die Standardwerte für den Mixer direkt im Treiber einzustellen. Der Mixer kann mit den entsprechenden Werten in <span class=filename>/boot/device.hints</span> eingestellt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.pcm.0.vol=&#34;50&#34;</pre></div></div><div class=paragraph><p>Die Zeile setzt die Lautstärke des Mixers beim Laden des Moduls <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> auf den Wert <code>50</code>.</p></div></div></div><div class=sect2><h3 id=sound-mp3>13.3. MP3-Audio<a class=anchor href=#sound-mp3></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt einige unter FreeBSD verfügbare MP3-Player. Zudem wird beschrieben, wie Audio-CDs gerippt und MP3s kodiert und dekodiert werden.</p></div><div class=sect3><h4 id=mp3-players>13.3.1. MP3-Player<a class=anchor href=#mp3-players></a></h4><div class=paragraph><p>Ein beliebter graphischer MP3-Player ist Audacious, welcher WinAmp-Skins und zusätzliche Plugins unterstützt. Die Benutzerschnittstelle ist leicht zu erlernen und enthält eine Playlist, einen graphischen Equalizer und vieles mehr. Diejenigen, die bereits mit WinAmp vertraut sind, werden Audacious sehr leicht zu benutzen finden. Unter FreeBSD kann Audacious als Port oder Paket <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/audacious/>multimedia/audacious</a> installiert werden. Audacious ist ein Ableger von XMMS.</p></div><div class=paragraph><p>Das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> ist ein alternativer, kommandozeilenorientierter MP3-Player. Nach der Installation kann die abzuspielende MP3-Datei auf der Kommandozeile angegeben werden. Geben Sie auch das entsprechende Soundkarte an, falls das System über mehrere Audiogeräte verfügt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3</span>
High Performance MPEG 1.0/2.0/2.5 Audio Player <span class=k>for </span>Layer 1, 2 and 3
        version 1.18.1<span class=p>;</span> written and copyright by Michael Hipp and others
        free software <span class=o>(</span>LGPL<span class=o>)</span> without any warranty but with best wishes

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo</code></pre></div></div><div class=paragraph><p>Weitere MP3-Player stehen in der FreeBSD Ports-Sammlung zur Verfügung.</p></div></div><div class=sect3><h4 id=rip-cd>13.3.2. CD-Audio Tracks rippen<a class=anchor href=#rip-cd></a></h4><div class=paragraph><p>Bevor eine ganze CD oder einen CD-Track in das MP3-Format umgewandelt werden kann, müssen die Audiodaten von der CD auf die Festplatte gerippt werden. Dabei werden die CDDA (CD Digital Audio) Rohdaten in WAV-Dateien kopiert.</p></div><div class=paragraph><p>Die Anwendung <code>cdda2wav</code>, die im <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> Paket enthalten ist, kann zum Rippen der Audiodaten von CDs genutzt werden.</p></div><div class=paragraph><p>Wenn die Audio CD in dem Laufwerk liegt, kann der folgende Befehl als <code>root</code> ausgeführt werden, um eine ganze CD in einzelne WAV-Dateien zu rippen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -B</span></code></pre></div></div><div class=paragraph><p>In diesem Beispiel bezieht sich der Schalter <code>-D <em>0,1,0</em></code> auf das SCSI-Gerät <span class=filename>0,1,0</span>, das die zu rippende CD enthält. Benutzen Sie <code>cdrecord -scanbus</code> um die richtigen Geräteparameter für das System zu bestimmen.</p></div><div class=paragraph><p>Um einzelne Tracks zu rippen, benutzen Sie <code>-t</code> wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 7</span></code></pre></div></div><div class=paragraph><p>Um mehrere Tracks zu rippen, zum Beispiel die Tracks eins bis sieben, können Sie wie folgt einen Bereich angeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 1+7</span></code></pre></div></div><div class=paragraph><p>Wenn Sie von einem ATAPI (IDE) CD-ROM-Laufwerk rippen, geben Sie den Gerätenamen anstelle der SCSI-Gerätenummer an. Dieses Beispiel rippt Track 7 von einem IDE-Laufwerk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D /dev/acd0 -t 7</span></code></pre></div></div><div class=paragraph><p>Alternativ können mit <code>dd</code> ebenfalls Audio-Stücke von ATAPI-Laufwerken kopiert werden. Dies wird in <a href=./#duplicating-audiocds>“Kopieren von Audio-CDs”</a> erläutert.</p></div></div><div class=sect3><h4 id=mp3-encoding>13.3.3. MP3-Dateien kodieren und dekodieren<a class=anchor href=#mp3-encoding></a></h4><div class=paragraph><p>Lame ist ein weitverbreiteter MP3-Encoder, der als Port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a> installiert werden kann. Wegen Patentproblemen ist kein Paket verfügbar.</p></div><div class=paragraph><p>Der folgende Befehl konvertiert die gerippte WAV-Datei <span class=filename>audio01.wav</span> in <span class=filename>audio01.mp3</span> um:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lame -h -b 128 --tt &#34;Foo Liedtietel&#34; --ta &#34;FooBar Künstler&#34; --tl &#34;FooBar Album&#34; \</span>
<span class=nt>--ty</span> <span class=s2>&#34;2014&#34;</span> <span class=nt>--tc</span> <span class=s2>&#34;Gerippt und kodiert von Foo&#34;</span> <span class=nt>--tg</span> <span class=s2>&#34;Musikrichtung&#34;</span> audio01.wav audio01.mp3</code></pre></div></div><div class=paragraph><p>128 kbits ist die gewöhnliche MP3-Bitrate, wohingegen die Bitraten 160 und 192 kbits eine höhere Qualität bieten. Je höher die Bitrate ist, desto mehr Speicherplatz benötigt die resultierende MP3-Datei. Die Option <code>-h</code> verwendet den "higher quality but a little slower" (höhere Qualität, aber etwas langsamer) Modus. Die Schalter, die mit <code>--t</code> beginnen, sind ID3-Tags, die in der Regel Informationen über das Lied enthalten und in die MP3-Datei eingebettet sind. Weitere Optionen können in der Manualpage von lame nachgelesen werden.</p></div><div class=paragraph><p>Um aus MP3-Dateien eine Audio CD zu erstellen, müssen diese zuerst in ein nicht komprimiertes Format umgewandelt werden. Verwenden Sie XMMS um die Datei im WAV-Format zu schreiben und mpg123, um die MP3-Datei in rohe PCM-Audiodaten umzuwandeln.</p></div><div class=paragraph><p>Um <span class=filename>audio01.mp3</span> mit mpg123 umzuwandeln, geben Sie den Namen der PCM-Datei an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -s audio01.mp3 &gt; audio01.pcm</span></code></pre></div></div><div class=paragraph><p>So verwenden Sie XMMS um eine MP3-Datei in das WAV-Format zu konvertieren:</p></div><div class="paragraph procedure"><p><strong>Procedure: Mit XMMS in das WAV-Format konvertieren</strong>
. Starten Sie XMMS.
. Klicken Sie mit der rechten Maustaste, um das XMMS-Menu zu öffnen.
. Wählen Sie <code>Preferences</code> im Untermenü <code>Options</code>.
. Ändern Sie das Output-Plugin in "Disk Writer Plugin".
. Drücken Sie <code>Configure</code>.
. Geben Sie ein Verzeichnis ein, in das Sie die unkomprimierte Datei schreiben wollen.
. Laden Sie die MP3-Datei wie gewohnt in XMMS mit einer Lautstärke von 100% und einem abgeschalteten EQ.
. Drücken Sie <code>Play</code> und es wird so aussehen, als spiele XMMS die MP3-Datei ab, aber keine Musik ist zu hören. Der Player überspielt die MP3-Datei in eine Datei.
. Vergessen Sie nicht, das Output-Plugin wieder in den Ausgangszustand zurückzusetzen um wieder MP3-Dateien anhören zu können.</p></div><div class=paragraph><p>cdrecord kann mit beiden Formaten Audio-CDs erstellen. Der Dateikopf von WAV-Dateien erzeugt am Anfang des Stücks ein Knacken. Der Dateikopf mit dem Port oder Paket <a class=package href=https://cgit.freebsd.org/ports/tree/audio/sox/>audio/sox</a> entfernt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sox <span class=nt>-t</span> wav <span class=nt>-r</span> 44100 <span class=nt>-s</span> <span class=nt>-w</span> <span class=nt>-c</span> 2 track.wav track.raw</code></pre></div></div><div class=paragraph><p>Lesen Sie <a href=./#creating-cds>“Erstellen und Verwenden von CDs”</a>, um mehr Informationen zur Benutzung von CD-Brennern mit FreeBSD zu erhalten.</p></div></div></div><div class=sect2><h3 id=video-playback>13.4. Videos wiedergeben<a class=anchor href=#video-playback></a></h3><div class=paragraph><p>Bevor Sie beginnen, sollten Sie das Modell und den benutzten Chip der Videokarte kennen. Obwohl Xorg viele Videokarten unterstützt, können nicht alle Karten Videos schnell genug wiedergeben. Eine Liste der Erweiterungen, die der Xorg-Server für eine Videokarte unterstützt, erhalten Sie unter laufendem Xorg mit <code>xdpyinfo</code>.</p></div><div class=paragraph><p>Halten Sie eine kurze MPEG-Datei bereit, mit der Sie Wiedergabeprogramme und deren Optionen testen können. Da einige DVD-Spieler in der Voreinstellung das DVD-Gerät mit <span class=filename>/dev/dvd</span> ansprechen oder diesen Namen fest einkodiert haben, ist es vielleicht hilfreich symbolische Links auf die richtigen Geräte anzulegen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -sf /dev/acd0 /dev/dvd</span></code></pre></div></div><div class=paragraph><p>Aufgrund der Beschaffenheit <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> gehen gesondert angelegte Links wie diese bei einem Neustart des Systems verloren. Damit die symbolischen Links automatisch beim Neustart des Systems angelegt werden, fügen Sie die folgende Zeile in <span class=filename>/etc/devfs.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>link acd0 dvd</pre></div></div><div class=paragraph><p>Das Entschlüsseln von DVDs erfordert den Aufruf bestimmter Funktionen, sowie Schreibzugriff auf das DVD-Gerät.</p></div><div class=paragraph><p>Xorg benutzt Shared-Memory und es wird empfohlen, die nachstehenden <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variablen auf die gezeigten Werte zu erhöhen:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</pre></div></div><div class=sect3><h4 id=video-interface>13.4.1. Video-Schnittstellen<a class=anchor href=#video-interface></a></h4><div class=paragraph><p>Es gibt einige Möglichkeiten, Videos unter Xorg abzuspielen. Welche Möglichkeit funktioniert, hängt stark von der verwendeten Hardware ab.</p></div><div class=paragraph><p>Gebräuchliche Video-Schnittstellen sind:</p></div><div class="olist arabic"><ol class=arabic><li><p>Xorg: normale Ausgabe über Shared-Memory.</p></li><li><p>XVideo: Eine Erweiterung der Xorg-Schnittstelle, die Videos in jedem X11-Drawable anzeigen kann. Diese Erweiterung bietet auch auf leistungsschwachen Maschinen eine gute Qualität der Wiedergabe. Der nächste Abschnitt beschreibt, wie Sie feststellen, ob diese Erweiterung ausgeführt wird.</p></li><li><p>SDL: Simple DirectMedia Layer ist eine portable Schnittstelle für verschiedene Betriebssysteme, mit denen Anwendungen plattformunabhängig und effizient Ton und Grafik benutzen können. SDL bietet eine hardwarenahe Schnittstelle, die manchmal schneller ist als die Xorg-Schnittstelle. Unter FreeBSD kann SDL über das Paket oder den Port <a class=package href=https://cgit.freebsd.org/ports/tree/devel/sdl20/>devel/sdl20</a> installiert werden.</p></li><li><p>DGA: Direct Graphics Access ist eine Xorg-Erweiterung die es Anwendungen erlaubt, am Xorg-Server vorbei direkt in den Framebuffer zu schreiben. Da die Anwendung und der Xorg-Server auf gemeinsame Speicherbereiche zugreifen, müssen die Anwendungen unter dem Benutzer <code>root</code> laufen. Die DGA-Erweiterung kann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dga&amp;sektion=1&amp;format=html">dga(1)</a> getestet werden. Wenn DGA ausgeführt wird, ändert sich die Farbe des Bildschrims, wenn eine Taste gedrückt wird. Drücken Sie zum Beenden <kbd>q</kbd>.</p></li><li><p>SVGAlib: Eine Schnittstelle zur Grafikausgabe auf der Konsole.</p></li></ol></div><div class=sect4><h5 id=video-interface-xvideo>13.4.1.1. XVideo<a class=anchor href=#video-interface-xvideo></a></h5><div class=paragraph><p>Ob die Erweiterung läuft, entnehmen Sie der Ausgabe von <code>xvinfo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xvinfo</code></pre></div></div><div class=paragraph><p>XVideo wird untertsützt, wenn die Ausgabe in etwa wie folgt aussieht:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen <span class=c>#0</span>
  Adaptor <span class=c>#0: &#34;Savage Streams Engine&#34;</span>
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      <span class=s2>&#34;XV_COLORKEY&#34;</span> <span class=o>(</span>range 0 to 16777215<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 2110<span class=o>)</span>
      <span class=s2>&#34;XV_BRIGHTNESS&#34;</span> <span class=o>(</span>range <span class=nt>-128</span> to 127<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
      <span class=s2>&#34;XV_CONTRAST&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_SATURATION&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_HUE&#34;</span> <span class=o>(</span>range <span class=nt>-180</span> to 180<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      <span class=nb>id</span>: 0x32595559 <span class=o>(</span>YUY2<span class=o>)</span>
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x32315659 <span class=o>(</span>YV12<span class=o>)</span>
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x30323449 <span class=o>(</span>I420<span class=o>)</span>
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x36315652 <span class=o>(</span>RV16<span class=o>)</span>
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      <span class=nb>id</span>: 0x35315652 <span class=o>(</span>RV15<span class=o>)</span>
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      <span class=nb>id</span>: 0x31313259 <span class=o>(</span>Y211<span class=o>)</span>
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</code></pre></div></div><div class=paragraph><p>Einige der aufgeführten Formate, wie YUV2 oder YUV12 existieren in machen XVideo-Implementierungen nicht. Dies kann zu Problemen mit einigen Spielern führen.</p></div><div class=paragraph><p>XVideo wird wahrscheinlich von der Karte nicht unterstützt, wenn die Ausgabe wie folgt aussieht:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen <span class=c>#0</span>
no adaptors present</code></pre></div></div><div class=paragraph><p>Wenn die XVideo-Erweiterung auf der Karte nicht läuft, wird es nur etwas schwieriger, die Anforderungen für die Wiedergabe von Videos zu erfüllen.</p></div></div></div><div class=sect3><h4 id=video-ports>13.4.2. Video-Anwendungen<a class=anchor href=#video-ports></a></h4><div class=paragraph><p>Dieser Abschnitt behandelt Anwendungen aus der FreeBSD-Ports-Sammlung, die für die Wiedergabe von Videos genutzt werden können.</p></div><div class=sect4><h5 id=video-mplayer>13.4.2.1. MPlayer und MEncoder<a class=anchor href=#video-mplayer></a></h5><div class=paragraph><p>MPlayer ist ein auf Geschwindigkeit und Flexibilität ausgelegter Video-Spieler für die Kommandozeile mit optionaler graphischer Oberfläche. Weitere graphische Oberflächen für MPlayer stehen in der FreeBSD Ports-Sammlung zur Verfügung.</p></div><div class=paragraph><p>MPlayer kann als Paket oder Port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mplayer/>multimedia/mplayer</a> installiert werden. Der Bau von MPlayer berücksichtigt die vorhandene Hardware und es können zahlreiche Optionen ausgewählt werden. Aus diesen Gründen ziehen es manche Benutzer vor, den Port zu übersetzen, anstatt das Paket zu installieren.</p></div><div class=paragraph><p>Die Optionen sollten beim Bau des Ports überprüft werden, um dem Umfang der Unterstützung, mit dem der Port gebaut wird, zu bestimmen. Wenn eine Option nicht ausgewählt wird, ist MPlayer nicht in der Lage, diese Art von Video-Format wiederzugeben. Mit den Pfeiltasten und der Leertaste können die erforderlichen Formate ausgewählt werden. Wenn Sie fertig sind, drücken Sie <kbd>Enter</kbd>, um den Bau und die Installation fortzusetzen.</p></div><div class=paragraph><p>In der Voreinstellung wird das Paket oder der Port das <code>mplayer</code>-Kommandozeilenprogramm und das graphische Programm <code>gmplayer</code> bauen. Um Videos zu dekodieren, installieren Sie den Port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mencoder/>multimedia/mencoder</a>. Aus lizenzrechtlichen Gründen steht ein Paket von MEncoder nicht zur Verfügung.</p></div><div class=paragraph><p>MPlayer erstellt beim ersten Start <span class=filename>~/.mplayer</span> im Heimatverzeichnis des Benutzers. Dieses Verzeichnis enthält die voreingestellten Konfigurationseinstellungen für den Benutzer.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt nur ein paar wenige Anwendungsmöglichkeiten. Eine vollständige Beschreibung der zahlreichen Möglichkeiten finden Sie in der Manualpage von mplayer(1).</p></div><div class=paragraph><p>Um die Datei <span class=filename>testfile.avi</span> abzuspielen, geben Sie die Video-Schnittstelle mit <code>-vo</code> an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> xv testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> sdl testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> x11 testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo dga testfile.avi</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo &#39;sdl:dga&#39; testfile.avi</span></code></pre></div></div><div class=paragraph><p>Es lohnt sich, alle Option zu testen. Die erzielte Geschwindigkeit hängt von vielen Faktoren ab und variiert beträchtlich je nach eingesetzter Hardware.</p></div><div class=paragraph><p>Wenn Sie eine DVD abspielen wollen, ersetzen Sie <span class=filename>testfile.avi</span> durch <code>-dvd://<em>N Gerät</em></code>. <code><em>N</em></code> ist die Nummer des Stücks, das Sie abspielen wollen und <span class=filename>Gerät</span> gibt den Gerätenamen der DVD an. Das nachstehende Kommando spielt das dritte Stück von <span class=filename>/dev/dvd</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo dga -dvd://3 /dev/dvd</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das standardmäßig verwendete DVD-Laufwerk kann beim Bau des MPlayer-Ports mit der Option <code>WITH_DVD_DEVICE=/pfad/zum/gerät</code> festgelegt werden. Die Voreinstellung verwendet das Gerät <span class=filename>/dev/cd0</span>. Weitere Details finden Sie in <span class=filename>Makefile.options</span> des Ports.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Tastenkombinationen zum Abbrechen, Anhalten und Weiterführen der Wiedergabe entnehmen Sie der Ausgabe von <code>mplayer -h</code> oder der mplayer(1) Manualpage.</p></div><div class=paragraph><p>Weitere nützliche Optionen für die Wiedergabe sind <code>-fs -zoom</code> zur Wiedergabe im Vollbild-Modus und <code>-framedrop</code> zur Steigerung der Geschwindigkeit.</p></div><div class=paragraph><p>Jeder Benutzer kann häufig verwendete Optionen in seine <span class=filename>~/.mplayer/config</span> eintragen:</p></div><div class="literalblock programlisting"><div class=content><pre>vo=xv
fs=yes
zoom=yes</pre></div></div><div class=paragraph><p><code>mplayer</code> kann verwendet werden, um DVD-Stücke in <span class=filename>.vob</span>-Dateien zu rippen. Das zweite Stück einer DVD wandeln Sie wie folgt in eine Datei um:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -dumpstream -dumpfile out.vob -dvd://2 /dev/dvd</span></code></pre></div></div><div class=paragraph><p>Die Ausgabedatei <span class=filename>out.vob</span> wird im MPEG-Format abgespeichert.</p></div><div class=paragraph><p>Jeder Benutzer, der mehr Informationen über Video unter UNIX® sammeln möchte, sollte <a href=http://www.mplayerhq.hu/DOCS/>mplayerhq.hu/DOCS</a> konsultieren, da es technisch sehr informativ ist. Diese Dokumentation sollte ebenfalls studiert werden, bevor Fehlerberichte eingereicht werden.</p></div><div class=paragraph><p>Vor der Verwendung von <code>mencoder</code> ist es hilfreich, sich mit den auf <a href=http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html>mplayerhq.hu/DOCS/HTML/en/mencoder.html</a> beschriebenen Optionen vertraut zu machen. Es gibt unzählige Möglichkeiten die Qualität zu verbessern, die Bitrate zu verringern und Formate zu konvertieren. Einige davon haben erhebliche Auswirkungen auf die Geschwindigkeit. Falsche Kombinationen von Kommandozeilenparametern ergeben eventuell Dateien, die selbst <code>mplayer</code> nicht mehr wiedergeben kann.</p></div><div class=paragraph><p>Hier ist ein Beispiel für eine einfache Kopie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> copy <span class=nt>-ovc</span> copy <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>Wenn Sie in eine Datei rippen, benutzen Sie die Option <code>-dumpfile</code> von <code>mplayer</code>.</p></div><div class=paragraph><p>Um <span class=filename>input.avi</span> nach MPEG4 mit MPEG3 für den Ton zu konvertieren, muss zunächst der Port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a> installiert werden. Aus lizenzrechtlichen Gründen ist ein Paket nicht verfügbar. Wenn der Port installiert ist, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> mp3lame <span class=nt>-lameopts</span> <span class=nv>br</span><span class=o>=</span>192 <span class=se>\</span>
	  <span class=nt>-ovc</span> lavc <span class=nt>-lavcopts</span> <span class=nv>vcodec</span><span class=o>=</span>mpeg4:vhq <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>Die Ausgabedatei lässt sich mit Anwendungen wie <code>mplayer</code> oder <code>xine</code> abspielen.</p></div><div class=paragraph><p><span class=filename>input.avi</span> kann durch <code>-dvd://1 /dev/dvd</code> ersetzt und das Kommando als <code>root</code> ausgeführt werden, um ein DVD-Stück direkt zu konvertieren. Da vielleicht ein paar Versuche nötig sind, um das gewünschte Ergebnis zu erhalten, empfiehlt es sich das Stück zuerst in eine Datei zu schreiben und anschließend die Datei weiter zu bearbeiten.</p></div></div><div class=sect4><h5 id=video-xine>13.4.2.2. Der Video-Spieler xine<a class=anchor href=#video-xine></a></h5><div class=paragraph><p>xine ist ein Video-Spieler mit einer wiederverwendbaren Bibliothek und ein Programm, das durch Plugins erweitert werden kann. Es kann als Paket oder Port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xine/>multimedia/xine</a> installiert werden.</p></div><div class=paragraph><p>Für einen reibungslosen Betrieb benötigt xine entweder eine schnelle CPU mit einer schnellen Grafikkarte, oder die XVideo-Erweiterung. Am schnellsten läuft xine mit der XVideo-Erweiterung.</p></div><div class=paragraph><p>In der Voreinstellung startet xine eine grafische Benutzeroberfläche. Über die Menüs können dann bestimmte Dateien geöffnet werden.</p></div><div class=paragraph><p>Alternativ kann xine auch über die Kommandozeile aufgerufen werden, um Dateien direkt wiederzugeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xine <span class=nt>-g</span> <span class=nt>-p</span> mymovie.avi</code></pre></div></div><div class=paragraph><p>Weitere Informationen und Tipps zur Fehlerbehebung finden Sie unter <a href=http://www.xine-project.org/faq>xine-project.org/faq</a>.</p></div></div><div class=sect4><h5 id=video-ports-transcode>13.4.2.3. Die Transcode-Werkzeuge<a class=anchor href=#video-ports-transcode></a></h5><div class=paragraph><p>Transcode ist eine Sammlung von Werkzeugen zur Umwandlung von Video- und Audio-Dateien. Transcode mischt Video-Dateien und kann kaputte Video-Dateien reparieren. Die Werkzeuge werden als Filter verwendet, das heißt die Ein- und Ausgaben verwenden stdin/stdout.</p></div><div class=paragraph><p>Unter FreeBSD kann Transcode als Paket oder Port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/transcode/>multimedia/transcode</a> installiert werden. Viele Benutzer bevorzugen es den Port zu bauen, da er ein Menü bereitstellt, wo die entsprechenden Formate für den Bau ausgewählt werden können. Mit den Pfeiltasten und der Leertaste können die erforderlichen Formate ausgewählt werden. Wenn Sie fertig sind, drücken Sie <kbd>Enter</kbd>, um den Bau und die Installation fortzusetzen.</p></div><div class=paragraph><p>Dieses Beispiel zeigt, wie eine DivX-Datei in eine PAL MPEG-1-Datei konvertiert wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% transcode <span class=nt>-i</span> input.avi <span class=nt>-V</span> <span class=nt>--export_prof</span> vcd-pal <span class=nt>-o</span> output_vcd
% mplex <span class=nt>-f</span> 1 <span class=nt>-o</span> output_vcd.mpg output_vcd.m1v output_vcd.mpa</code></pre></div></div><div class=paragraph><p>Die daraus resultierende MPEG-Datei, <span class=filename>output_vcd.mpg</span>, kann beispielsweise mit MPlayer abgespielt werden. Die Datei kann auch mit einem Programm wie <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/vcdimager/>multimedia/vcdimager</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a> als Video-CD auf eine CD-R gebrannt werden.</p></div><div class=paragraph><p>Zusätzlich zu der Manualpage von <code>transcode</code>, sollten Sie auch die Informationen und Beispiele im <a href=http://www.transcoding.org/cgi-bin/transcode>transcoding.org/cgi-bin/transcode</a> lesen.</p></div></div></div></div><div class=sect2><h3 id=tvcard>13.5. TV-Karten<a class=anchor href=#tvcard></a></h3><div class=paragraph><p>Mit TV-Karten können Sie mit dem Rechner über Kabel oder Antenne fernsehen. Die meisten Karten besitzen einen RCA- oder S-Video-Eingang. Einige Karten haben auch einen FM-Radio-Empfänger.</p></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>-Treiber von FreeBSD unterstützt PCI-TV-Karten mit einem Brooktree Bt848/849/878/879 Chip. Dieser Teiber unterstützt die meisten Pinnacle PCTV Karten. Die Karte sollte einen der unterstützten Empfänger besitzen, die in <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> aufgeführt sind.</p></div><div class=sect3><h4 id=_den_treiber_laden>13.5.1. Den Treiber laden<a class=anchor href=#_den_treiber_laden></a></h4><div class=paragraph><p>Um die Karte benutzen zu können, muss der <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>-Treiber geladen werden. Damit dies beim Systemstart automatisch erfolgt, muss die folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>bktr_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Alternativ kann der Treiber für die TV-Karte auch fest in den Kernel kompiliert werden. In diesem Fall müssen folgende Zeilen in die Kernelkonfigurationsdatei aufgenommen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>device	 bktr
device	iicbus
device	iicbb
device	smbus</pre></div></div><div class=paragraph><p>Die zusätzlichen Treiber werden benötigt, da die Komponenten der Karte über einen I2C-Bus verbunden sind. Bauen und installieren Sie dann den neuen Kernel.</p></div><div class=paragraph><p>Um den Treiber zu testen, muss das System neu gestartet werden. Während des Neustarts sollte die TV-Karte erkannt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</pre></div></div><div class=paragraph><p>Abhängig von der verwendeten Hardware können die Meldungen natürlich anders aussehen. Die entdeckten Geräte lassen sich mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> oder in der Kernelkonfigurationsdatei überschreiben. Wenn Sie beispielsweise einen Philips-SECAM-Empfänger erzwingen wollen, fügen Sie die folgende Zeile zur Kernelkonfigurationsdatei hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>options OVERRIDE_TUNER=6</pre></div></div><div class=paragraph><p>Alternativ können Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.bt848.tuner=6</span></code></pre></div></div><div class=paragraph><p>Weitere Informationen zu den verschiedenen Kerneloptionen und <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Parametern finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>.</p></div></div><div class=sect3><h4 id=_nützliche_anwendungen>13.5.2. Nützliche Anwendungen<a class=anchor href=#_nützliche_anwendungen></a></h4><div class=paragraph><p>Um die TV-Karte zu benutzen, installieren Sie eine der nachstehenden Anwendungen:</p></div><div class=ulist><ul><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/fxtv/>multimedia/fxtv</a> lässt das Fernsehprogramm in einem Fenster laufen und kann Bilder, Audio und Video aufzeichnen.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xawtv/>multimedia/xawtv</a> eine weitere TV-Anwendung mit vergleichbaren Funktionen.</p></li><li><p>Mit <a class=package href=https://cgit.freebsd.org/ports/tree/audio/xmradio/>audio/xmradio</a> lässt sich der FM-Radio-Empfänger, der sich auf TV-Karten befindet, benutzen.</p></li></ul></div><div class=paragraph><p>Weitere Anwendungen finden Sie in der FreeBSD Ports-Sammlung.</p></div></div><div class=sect3><h4 id=_fehlersuche>13.5.3. Fehlersuche<a class=anchor href=#_fehlersuche></a></h4><div class=paragraph><p>Wenn Sie Probleme mit der TV-Karte haben, prüfen Sie zuerst, ob der Video-Capture-Chip und der Empfänger vom <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>-Treiber unterstützt werden und ob Sie die richtigen Optionen verwenden. Weitere Hilfe zu unterstützten TV-Karten finden Sie auf der Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-multimedia>FreeBSD multimedia</a>.</p></div></div></div><div class=sect2><h3 id=mythtv>13.6. MythTV<a class=anchor href=#mythtv></a></h3><div class=paragraph><p>MythTV ist eine beliebte Open Source PVR-Anwendung. Dieser Abschnitt beschreibt die Installation und Konfiguration von MythTV unter FreeBSD. Weitere Informationen zur Benutzung von MythTV finden Sie unter <a href=http://www.mythtv.org/wiki/>mythtv.org/wiki</a>.</p></div><div class=paragraph><p>MythTV benötigt ein Frontend und ein Backend. Diese Komponenten können entweder auf dem gleichen System, oder auf unterschiedlichen Maschinen installiert werden.</p></div><div class=paragraph><p>Das Frontend kann unter FreeBSD über den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv-frontend/>multimedia/mythtv-frontend</a> installiert werden. Zudem muss Xorg, wie in <a href=./#x11>Das X-Window-System</a> beschrieben, installiert und konfiguriert sein. Idealerweise besitzt das System auch eine Videokarte, die X-Video Motion Compensation (XvMC) unterstützt, sowie optional eine LIRC-kompatible Fernbedienung.</p></div><div class=paragraph><p>Benutzen Sie <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv/>multimedia/mythtv</a>, um sowohl das Frontend als auch das Backend zu installieren. Ein MySQL™ Datenbank-Server ist ebenfalls erforderlich und sollte automatisch als Abhängigkeit installiert werden. Optional sollte das System einen Empfänger und ausreichend Speicherplatz haben, um die aufgezeichneten Daten speichern zu können.</p></div><div class=sect3><h4 id=_hardware>13.6.1. Hardware<a class=anchor href=#_hardware></a></h4><div class=paragraph><p>MythTV verwendet V4L um auf Videoeingabegeräte, wie Kodierer und Empfänger zuzugreifen. Unter FreeBSD funktioniert MythTV am besten mit USB DVB-S/C/T Karten, die von <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/webcamd/>multimedia/webcamd</a> unterstützt werden, da dies eine V4L-Anwendung zur Verfügung stellt, die als Benutzerprogramm läuft. Jede DVB-Karte, die von webcamd unterstützt wird, sollte mit MythTV funktionieren, jedoch gibt es eine Liste von Karten, die unter <a href=https://wiki.freebsd.org/WebcamCompat>wiki.freebsd.org/WebcamCompat</a> abgerufen werden kann. Es existieren auch Treiber für Hauppauge-Karten in den folgenden Paketen: <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/pvr250/>multimedia/pvr250</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/pvrxxx/>multimedia/pvrxxx</a>, allerdings liefern diese nur eine Treiberschnittstelle, die nicht dem Standard entspricht und die nicht mit MythTV-Versionen grösser als 0.23 funktionieren. Aus lizenzrechtlichen Gründen ist ein Paket nicht verfügbar, sodass die beiden Ports übersetzt werden müssen.</p></div><div class=paragraph><p>Die <a href=https://wiki.freebsd.org/HTPC>wiki.freebsd.org/HTPC</a> enthält eine Liste von allen verfügbaren DVB-Treibern.</p></div></div><div class=sect3><h4 id=_mythtv_backend_einrichten>13.6.2. MythTV Backend einrichten<a class=anchor href=#_mythtv_backend_einrichten></a></h4><div class=paragraph><p>Geben Sie folgendes ein, um MythTV als Binärpaket zu installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mythtv</span></code></pre></div></div><div class=paragraph><p>Alternativ können Sie den Port installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/multimedia/mythtv</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>Richten Sie anschließend die MythTV-Datenbank ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mysql -uroot -p &lt; /usr/local/shared/mythtv/database/mc.sql</span></code></pre></div></div><div class=paragraph><p>Konfigurieren Sie dann das Backend:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mythtv-setup</span></code></pre></div></div><div class=paragraph><p>Zum Schluss starten Sie das Backend:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc mythbackend_enable=yes</span>
<span class=c># service mythbackend start</span></code></pre></div></div></div></div><div class=sect2><h3 id=scanners>13.7. Scanner<a class=anchor href=#scanners></a></h3><div class=paragraph><p>Unter FreeBSD stellt SANE (Scanner Access Now Easy) aus der Ports-Sammlung eine einheitliche Schnittstelle (API) für den Zugriff auf Scanner bereit. SANE wiederum greift auf Scanner mithilfe einiger FreeBSD-Treiber zu.</p></div><div class=paragraph><p>FreeBSD unterstützt sowohl SCSI- als auch USB-Scanner. Abhängig von der Schnittstelle des Scanners, werden unterschiedliche Treiber benötigt. Prüfen Sie vor der Konfiguration mithilfe der <a href=http://www.sane-project.org/sane-supported-devices.html>Liste der unterstützten Geräte</a> ob der Scanner von SANE unterstützt wird.</p></div><div class=paragraph><p>Dieses Kapitel beschreibt, wie Sie feststellen können, ob der Scanner von FreeBSD erkannt wurde. Zudem enthält es einen Überblick über die Konfiguration und Verwendung von SANE unter FreeBSD.</p></div><div class=sect3><h4 id=scanners-kernel-usb>13.7.1. Den Scanner überprüfen<a class=anchor href=#scanners-kernel-usb></a></h4><div class=paragraph><p>Im <span class=filename>GENERIC</span>-Kernel sind schon alle, für einen USB-Scanner notwendigen Treiber enthalten. Benutzer mit einem angepassten Kernel sollten sicherstellen, dass die Kernelkonfiguration die nachstehenden Zeilen enthält:</p></div><div class="literalblock programlisting"><div class=content><pre>device usb
device uhci
device ohci
device ehci
device xhci</pre></div></div><div class=paragraph><p>Um zu überprüfen ob der Scanner erkannt wird, schließen Sie den USB-Scanner an. Prüfen Sie dann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>, ob der Scanner in den Systemmeldungen erscheint:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ugen0.2: &lt;EPSON&gt; at usbus0</code></pre></div></div><div class=paragraph><p>In diesem Beispiel wurde ein EPSON Perfection® 1650 USB-Scanner an <span class=filename>/dev/ugen0.2</span> erkannt.</p></div><div class=paragraph><p>Wenn der Scanner eine SCSI-Schnittstelle besitzt, ist die Kernelkonfiguration abhängig vom verwendeten SCSI-Controller. Der <span class=filename>GENERIC</span>-Kernel unterstützt die gebräuchlichen SCSI-Controller. Den richtigen Treiber finden Sie in <span class=filename>/usr/src/sys/conf/NOTES</span>. Neben dem SCSI-Treiber muss die Kernelkonfiguration noch die nachstehenden Zeilen enthalten:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus
device pass</pre></div></div><div class=paragraph><p>Nachdem Sie einen Kernel gebaut und installiert haben, sollte der Scanner beim Neustart in den Systemmeldungen erscheinen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</code></pre></div></div><div class=paragraph><p>Wenn der Scanner während des Systemstarts ausgeschaltet war, können Sie die Geräteerkennung erzwingen, indem Sie den SCSI-Bus erneut absuchen. Verwenden Sie dazu <code>camcontrol</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol rescan all</span>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</code></pre></div></div><div class=paragraph><p>Der Scanner sollte jetzt in der SCSI-Geräteliste erscheinen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 <span class=o>(</span>pass0,da0<span class=o>)</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 <span class=o>(</span>pass1,da1<span class=o>)</span>
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 <span class=o>(</span>pass3<span class=o>)</span>
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 <span class=o>(</span>pass2,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Weitere Informationen über SCSI-Geräte unter FreeBSD finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=scsi&amp;sektion=4&amp;format=html">scsi(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a>.</p></div></div><div class=sect3><h4 id=_sane_konfigurieren>13.7.2. SANE konfigurieren<a class=anchor href=#_sane_konfigurieren></a></h4><div class=paragraph><p>Das SANE-System ermöglicht den Zugriff auf den Scanner über Backends (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a>). Lesen Sie <a href=http://www.sane-project.org/sane-supported-devices.html>http://www.sane-project.org/sane-supported-devices.html</a> um herauszufinden, welches Backend welchen Scanner unterstützt. Eine graphische Oberfläche wird über Anwendungen von Drittanbietern wie Kooka (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/kooka/>graphics/kooka</a>) oder XSane (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xsane/>graphics/xsane</a>) bereitgestellt. Die Backends von SANE reichen aus, um den Scanner zu testen.</p></div><div class=paragraph><p>Installieren Sie die Backends als Paket:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install sane-backends</span></code></pre></div></div><div class=paragraph><p>Alternativ können Sie die Backends aus der Ports-Sammlung installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/sane-backends</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Nachdem Sie den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a> installiert haben, können Sie mit dem Befehl <code>sane-find-scanner</code> prüfen, ob SANE den Scanner erkennt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sane-find-scanner -q</span>
found SCSI scanner <span class=s2>&#34;AGFA SNAPSCAN 600 1.10&#34;</span> at /dev/pass3</code></pre></div></div><div class=paragraph><p>Die Ausgabe zeigt die Schnittstelle und die verwendete Gerätedatei des Scanners. Der Hersteller und das Modell können in der Ausgabe fehlen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bei einigen USB-Scannern muss die Firmware geladen werden. Lesen Sie sane-find-scanner(1) und sane(7) für weitere Details.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Als nächstes müssen Sie prüfen, ob der Scanner vom Frontend erkannt wird. Die SANE-Backends werden mit dem Kommandozeilenwerkzeug <code>scanimage</code> geliefert. Mit diesem Werkzeug können Sie sich Scanner anzeigen lassen und den Scan-Prozess von der Kommandozeile starten. Die Option <code>-L</code> zeigt die Scanner an. Das erste Beispiel ist für einen SCSI-Scanner, das zweite ist für einen USB-Scanner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=sb>`</span>snapscan:/dev/pass3<span class=s1>&#39; is a AGFA SNAPSCAN 600 flatbed scanner
# scanimage -L
device &#39;</span>epson2:libusb:000:002<span class=s1>&#39; is a Epson GT-8200 flatbed scanner</span></code></pre></div></div><div class=paragraph><p>Im zweiten Beispiel ist <code>epson2</code> der Backend-Name. <code>libusb:000:002</code> bedeutet, dass <span class=filename>/dev/ugen0.2</span> die vom Scanner verwendete Gerätedatei ist.</p></div><div class=paragraph><p>Wenn <code>scanimage</code> den Scanner nicht erkennen kann, erscheint folgende Meldung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged <span class=k>in</span>, turned on and detected by the
sane-find-scanner tool <span class=o>(</span><span class=k>if </span>appropriate<span class=o>)</span><span class=nb>.</span> Please <span class=nb>read </span>the documentation
which came with this software <span class=o>(</span>README, FAQ, manpages<span class=o>)</span>.</code></pre></div></div><div class=paragraph><p>Wenn das passiert, müssen Sie in der Konfigurationsdatei des Backends unterhalb von <span class=filename>/usr/local/etc/sane.d/</span> den verwendeten Scanner eintragen. Wenn der Scanner EPSON Perfection® 1650, der das Backend <code>epson2</code> benutzt, nicht erkannt wurde, muss <span class=filename>/usr/local/etc/sane.d/epson2.conf</span> angepasst werden. Fügen Sie eine Zeile mit der Schnittstelle und dem Gerätenamen in die Datei ein. In diesem Beispiel wurde die nachstehende Zeile eingefügt:</p></div><div class="literalblock programlisting"><div class=content><pre>usb /dev/ugen0.2</pre></div></div><div class=paragraph><p>Speichern Sie die Änderungen und prüfen Sie, ob der Scanner mit dem richtigen Backend und Gerätenamen erkannt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=s1>&#39;epson2:libusb:000:002&#39;</span> is a Epson GT-8200 flatbed scanner</code></pre></div></div><div class=paragraph><p>Wenn <code>scanimage -L</code> den Scanner erkannt hat, ist der Scanner eingerichtet und bereit, zu scannen.</p></div><div class=paragraph><p>Obwohl <code>scanimage</code> von der Kommandozeile scannen kann, ist eine graphische Anwendung zum Scannen besser geeignet. Bekannte Programme sind Koka oder XSane. Diese Frontends besitzten erweiterte Funktionen wie den Scan-Modus, Farbkorrektur und Batch-Scans. XSane lässt sich auch als GIMP-Plugin verwenden.</p></div></div><div class=sect3><h4 id=_berechtigungen_für_den_scanner>13.7.3. Berechtigungen für den Scanner<a class=anchor href=#_berechtigungen_für_den_scanner></a></h4><div class=paragraph><p>Wenn andere Benutzer den Scanner benutzen sollen, müssen sie Lese- und Schreibrechte auf die Gerätedatei des Scanners besitzen. Im vorherigen Beispiel wird die Datei <span class=filename>/dev/ugen0.2</span> verwendet, die faktisch nur ein Symlink auf die echte Gerätedatei, <span class=filename>/dev/usb/0.2.0</span> genannt, darstellt. Sowohl der Symlink als auch die Gerätedatei sind jeweils im Besitz der Gruppen <code>wheel</code> und <code>operator</code>. Damit ein Benutzer den Scanner benutzen kann, muss er Mitglied in einer der beiden Gruppen sein. Allerdings sollte aus Sicherheitsgründen genau überlegt werden, welche Benutzer zu welcher Gruppe hinzugefügt werden, besonders bei der Gruppe <code>wheel</code>. Eine bessere Lösung ist es, eine spezielle Gruppe für den Zugriff anzulegen und den Scanner für Mitglieder dieser Gruppe zugänglich zu machen.</p></div><div class=paragraph><p>Dieses Beispiel erstellt eine Gruppe namens <code><em>usb</em></code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd usb</span></code></pre></div></div><div class=paragraph><p>Anschließend muss der <span class=filename>/dev/ugen0.2</span>-Symlink und der Gerätename <span class=filename>/dev/usb/0.2.0</span> für die Gruppe <code>usb</code> mit den Schreibrechten <code>0660</code> oder <code>0664</code> ausgestattet werden. All dies kann durch das Hinzufügen der folgenden Zeilen in <span class=filename>/etc/devfs.rules</span> erreicht werden:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es kommt vor, dass sich der Gerätename mit dem Hinzufügen oder Entfernen von Geräten ändert, so dass man stattdessen vielleicht allen USB-Geräten mit diesem Regelsatz Zugriff gewähren möchte:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path &#39;ugen*&#39; mode 0660 group usb
add path &#39;usb/*&#39; mode 0666 group usb</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Weitere Informationen zu dieser Datei finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a>.</p></div><div class=paragraph><p>Als nächstes aktivieren Sie den Regelsatz in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;system&#34;</pre></div></div><div class=paragraph><p>Starten Sie anschließend das <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a>-System neu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div><div class=paragraph><p>Jetzt müssen nur noch Benutzer zur Gruppe <code><em>usb</em></code> hinzugefügt werden, um ihnen den Zugriff auf den Scanner zu erlauben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod usb -m joe</span></code></pre></div></div><div class=paragraph><p>Weitere Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=kernelconfig>Kapitel 14. Konfiguration des FreeBSD-Kernels<a class=anchor href=#kernelconfig></a></h2><div class=sectionbody><div class=sect2><h3 id=kernelconfig-synopsis>14.1. Übersicht<a class=anchor href=#kernelconfig-synopsis></a></h3><div class=paragraph><p>Der Kernel ist das Herz des FreeBSD-Betriebssystems. Er ist verantwortlich für die Speicherverwaltung, das Durchsetzen von Sicherheitsdirektiven, Netzwerkfähigkeit, Festplattenzugriffen und vieles mehr. Obwohl FreeBSD es ermöglicht, dynamisch konfiguriert zu werden, ist es ab und an notwendig, einen angepassten Kernel zu konfigurieren und zu kompilieren.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes wissen:</p></div><div class=ulist><ul><li><p>Wann Sie einen angepassten Kernel kompilieren sollten.</p></li><li><p>Wie Sie eine Hardware-Inventur durchführen.</p></li><li><p>Wie Sie eine Kernelkonfigurationsdatei verändern.</p></li><li><p>Wie Sie mit der Konfigurationsdatei einen neuen Kernel kompilieren.</p></li><li><p>Wie Sie den neuen Kernel installieren.</p></li><li><p>Was zu tun ist, falls etwas schiefgeht.</p></li></ul></div><div class=paragraph><p>Alle Kommandos, aus den Beispielen dieses Kapitels, müssen mit <code>root</code>-Rechten ausgeführt werden.</p></div></div><div class=sect2><h3 id=kernelconfig-custom-kernel>14.2. Wieso einen eigenen Kernel bauen?<a class=anchor href=#kernelconfig-custom-kernel></a></h3><div class=paragraph><p>Traditionell besaß FreeBSD einen monolithischen Kernel. Der Kernel war ein einziges großes Programm, das eine bestimmte Auswahl an Hardware unterstützte. Um das Kernelverhalten zu ändern, musste man einen neuen Kernel kompilieren und dann den neuen Kernel booten.</p></div><div class=paragraph><p>Heutzutage befinden sich die meisten Funktionen des FreeBSD-Kernels in Modulen, die je nach Bedarf dynamisch geladen und entladen werden können. Dies erlaubt es, einen laufenden Kernel anzupassen, um sofort neue Hardware und neue Funktionen zu unterstützen. Dies ist als modularer Kernel bekannt.</p></div><div class=paragraph><p>Gelegentlich ist es noch notwendig, eine statische Kernelkonfigurationen durchzuführen. In einigen Fällen ist die Funktion zu systemnah, um durch ein Modul realisiert zu werden. Andere Umgebungen verhindern vielleicht das Laden und Entladen von Kernelmodulen und erfordern, dass nur die benötigte Funktionalität statisch in den Kernel kompiliert wird.</p></div><div class=paragraph><p>Das Erstellen eines angepassten Kernels ist eines der Rituale für erfahrene BSD-Benutzer. Obwohl dieser Prozess recht viel Zeit in Anspruch nimmt, kann er doch viele Vorteile für das FreeBSD-System bringen. Im Gegensatz zum <span class=filename>GENERIC</span>-Kernel, der eine Vielzahl von Hardware unterstützen muss, kann ein angepasster Kernel so eingeschränkt werden, dass er nur noch die Hardware des Rechners unterstützt. Dies hat einige Vorteile:</p></div><div class=ulist><ul><li><p>Schnellerer Bootvorgang. Da der Kernel nur nach der Hardware des Systems sucht, kann sich die Zeit für einen Systemstart verkürzen.</p></li><li><p>Geringerer Speicherbedarf. Ein eigener Kernel benötigt in der Regel weniger Speicher als ein <span class=filename>GENERIC</span>-Kernel durch das Entfernen von Funktionen und Gerätetreibern. Das ist vorteilhaft, denn der Kernel verweilt immer im RAM und verhindert dadurch, dass dieser Speicher von Anwendungen genutzt wird. Deshalb ist ein angepasster Kernel auf einem System mit wenig RAM sinnvoll.</p></li><li><p>Zusätzliche Hardwareunterstützung. Ein angepasster Kernel kann Unterstützung für Geräte bieten, die im <span class=filename>GENERIC</span>-Kernel nicht enthalten sind.</p></li></ul></div><div class=paragraph><p>Bevor Sie einen angepassten Kernel erstellen, überlegen Sie sich bitte, warum Sie dies tun wollen. Wenn Sie lediglich eine bestimmte Hardwareunterstützung benötigen, existiert diese vielleicht schon als Kernelmodul.</p></div><div class=paragraph><p>Kernelmodule existieren in <span class=filename>/boot/kernel</span> und können mit <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> dynamisch in den laufenden Kernel geladen werden. Die meisten Kerneltreiber verfügen über ein ladbares Modul und eine Manualpage. Der drahtlose Ethernet-Treiber <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> hat die folgenden Informationen in seiner Manualpage:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Alternatively, to load the driver as a module at boot time, place the
following line in loader.conf(5):

    if_ath_load=&#34;YES&#34;</code></pre></div></div><div class=paragraph><p>Durch das Hinzufügen von <code>if_ath_load="YES"</code> in <span class=filename>/boot/loader.conf</span> wird das Modul dynamisch beim Systemstart geladen.</p></div><div class=paragraph><p>In manchen Fällen gibt es kein entsprechendes Modul in <span class=filename>/boot/kernel</span>. Dies gilt insbesondere für bestimmte Subsysteme.</p></div></div><div class=sect2><h3 id=kernelconfig-devices>14.3. Informationen über die vorhandene Hardware beschaffen<a class=anchor href=#kernelconfig-devices></a></h3><div class=paragraph><p>Bevor die Kernelkonfigurationsdatei bearbeitet wird, ist es empfehlenswert eine Bestandsaufnahme der Hardware des Systems durchzuführen. Auf einem Dual-Boot-System können diese Informationen aus dem anderen Betriebssystem ermittelt werden. Microsoft®s Gerätemanager enthält beispielsweise Informationen über die installierte Hardware.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Einige Versionen von Microsoft® Windows® verfügen über ein System-Icon auf dem Desktop, über das Sie den Gerätemanager direkt aufrufen können.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn FreeBSD das einzige installierte Betriebssystem ist, dann listet <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> die Hardware auf, die während des Systemstarts gefunden wurde. Die meisten FreeBSD-Gerätetreiber haben eine eigene Manualpage, die Informationen über die unterstützte Hardware enthält. Die folgenden Zeilen zeigen beispielsweise an, dass der <a href="https://man.freebsd.org/cgi/man.cgi?query=psm&amp;sektion=4&amp;format=html">psm(4)</a>-Treiber eine angeschlossene Maus gefunden hat:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: <span class=o>[</span>GIANT-LOCKED]
psm0: <span class=o>[</span>ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</code></pre></div></div><div class=paragraph><p>Da diese Hardware vorhanden ist, sollte dieser Treiber nicht aus einer angepassten Kernelkonfigurationsdatei entfernt werden.</p></div><div class=paragraph><p>Wenn <code>dmesg</code> keine Informationen zur gefundenen Hardware anzeigt, können diese Informationen auch aus <span class=filename>/var/run/dmesg.boot</span> entnommen werden.</p></div><div class=paragraph><p>Ein weiteres Werkzeug für die Suche nach Hardware ist <a href="https://man.freebsd.org/cgi/man.cgi?query=pciconf&amp;sektion=8&amp;format=html">pciconf(8)</a>, das ausführliche Informationen bereitstellt. Ein Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pciconf <span class=nt>-lv</span>
ath0@pci0:3:0:0:        <span class=nv>class</span><span class=o>=</span>0x020000 <span class=nv>card</span><span class=o>=</span>0x058a1014 <span class=nv>chip</span><span class=o>=</span>0x1014168c <span class=nv>rev</span><span class=o>=</span>0x01 <span class=nv>hdr</span><span class=o>=</span>0x00
    vendor     <span class=o>=</span> <span class=s1>&#39;Atheros Communications Inc.&#39;</span>
    device     <span class=o>=</span> <span class=s1>&#39;AR5212 Atheros AR5212 802.11abg wireless&#39;</span>
    class      <span class=o>=</span> network
    subclass   <span class=o>=</span> ethernet</code></pre></div></div><div class=paragraph><p>Die Ausgabe zeigt, dass der Treiber <span class=filename>ath</span> eine drahtlose Ethernetkarte gefunden hat.</p></div><div class=paragraph><p>Die Option <code>-k</code> von <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> kann verwendet werden, um nützliche Informationen zu erhalten. Um beispielsweise eine Liste von Manualpages zu erhalten, welche ein spezifisches Wort enthalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># man -k Atheros</span>
ath<span class=o>(</span>4<span class=o>)</span>                   - Atheros IEEE 802.11 wireless network driver
ath_hal<span class=o>(</span>4<span class=o>)</span>               - Atheros Hardware Access Layer <span class=o>(</span>HAL<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Mit einer Inventarliste der Hardware können Sie dann sicherstellen, dass Sie die Treiber der installierten Hardware nicht versehentlich entfernen, wenn Sie die Kernelkonfigurationsdatei bearbeiten.</p></div></div><div class=sect2><h3 id=kernelconfig-config>14.4. Die Kernelkonfigurationsdatei<a class=anchor href=#kernelconfig-config></a></h3><div class=paragraph><p>Bevor eine angepasste Kernelkonfigurationsdatei erstellt werden kann, muss zuerst der vollständige FreeBSD Quellcodebaum installiert werden.</p></div><div class=paragraph><p>Falls <span class=filename>/usr/src/</span> nicht existiert oder leer ist, sind die Kernelquellen nicht installiert. Die Quellen können mit Subversion und der Anleitung im <a href=./#svn>“Benutzen von Subversion”</a> installiert werden.</p></div><div class=paragraph><p>Sobald die Quellen installiert sind, können Sie sich einen Überblick über <span class=filename>/usr/src/sys</span> verschaffen. Dieses Verzeichnis enthält eine Reihe von Unterverzeichnissen, einschließlich Verzeichnisse für die unterstützten Architekturen <span class=filename>amd64</span>, <span class=filename>i386</span>, <span class=filename>powerpc</span> und <span class=filename>sparc64</span>. Alles in diesen Verzeichnissen ist nur für die jeweilige Architektur relevant. Der Rest des Codes ist maschinenunabhängig und für alle Architekturen gleich. Jede unterstützte Architektur hat ein Unterverzeichnis <span class=filename>conf</span>, das die <span class=filename>GENERIC</span> Kernelkonfigurationsdatei für diese Architektur enthält.</p></div><div class=paragraph><p>Bearbeiten Sie <span class=filename>GENERIC</span> nicht direkt. Kopieren Sie stattdessen die Datei unter einem anderen Namen und machen dann die Änderungen an dieser Kopie. Traditionell besteht der Name des Kernels immer aus Großbuchstaben. Wenn Sie mehrere FreeBSD-Maschinen mit unterschiedlicher Hardware betreuen, ist es eine gute Idee, die Konfigurationsdatei nach den Hostnamen der Maschinen zu benennen. In diesem Beispiel wird eine Kopie der <span class=filename>GENERIC</span> Kernelkonfigurationsdatei, namens <span class=filename>MYKERNEL</span>, für die <span class=filename>amd64</span>-Architektur erstellt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># cp GENERIC MYKERNEL</span></code></pre></div></div><div class=paragraph><p><span class=filename>MYKERNEL</span> kann jetzt mit einem Texteditor bearbeitet werden. Der Standard-Editor ist vi, jedoch steht mit ee ein weiterer, einfach zu bedienender Editor bereit.</p></div><div class=paragraph><p>Das Format der Konfigurationsdatei ist einfach. Jede Zeile enthält ein Schlüsselwort, das ein Gerät oder ein Subsystem repräsentiert, ein Argument und eine kurze Beschreibung. Jeder Text, der hinter einem <code><mark></mark></code> steht, gilt als Kommentar und wird ignoriert. Um die Kernel-Unterstützung für ein Gerät oder Subsystem zu entfernen, muss ein <code></code> an den Anfang der Zeile, die dieses Gerät oder Subsystem repräsentiert, gesetzt werden. Verändern Sie keine Zeilen, die Sie nicht genau verstehen.</p></div><div class=paragraph><p>Neben den Kurzbeschreibungen in dieser Datei, finden Sie zusätzliche Erklärungen in <span class=filename>NOTES</span>, die sich in demselben Verzeichnis wie <span class=filename>GENERIC</span> für die jeweilige Architektur befindet. Von der Architektur unabhängige Optionen sind in <span class=filename>/usr/src/sys/conf/NOTES</span> aufgeführt.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Wenn Sie die Kernelkonfigurationsdatei fertig bearbeitet haben, sollten Sie eine Sicherungskopie außerhalb von <span class=filename>/usr/src</span> speichern</p></div><div class=paragraph><p>Alternativ kann die Kernelkonfigurationsdatei an anderer Stelle gespeichert, und ein symbolischer Link auf die Datei erstellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># mkdir /root/kernels</span>
<span class=c># cp GENERIC /root/kernels/MYKERNEL</span>
<span class=c># ln -s /root/kernels/MYKERNEL</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Es ist möglich, eine <code>include</code>-Anweisung in die Kernelkonfigurationsdatei aufzunehmen. Diese erlaubt das lokale Einfügen von anderen Konfigurationsdateien in die aktuelle, was es einfacher macht, kleinere Änderungen an einer existierenden Datei zu vollziehen. Wenn Sie einen <span class=filename>GENERIC</span>-Kernel mit nur einer kleinen Anzahl von zusätzlichen Optionen und Treibern benötigen, brauchen Sie mit den folgenden Zeilen nur ein kleines Delta im Vergleich zu GENERIC anpassen, wie in diesem Beispiel zu sehen:</p></div><div class="literalblock programlisting"><div class=content><pre>include GENERIC
ident MYKERNEL

options         IPFIREWALL
options         DUMMYNET
options         IPFIREWALL_DEFAULT_TO_ACCEPT
options         IPDIVERT</pre></div></div><div class=paragraph><p>Diese Methode zeigt die Unterschiede der lokalen Konfigurationsdatei zu einem <span class=filename>GENERIC</span>-Kernel an. Sobald Aktualisierungen durchgeführt werden, können neue Eigenschaften, die zu <span class=filename>GENERIC</span> hinzugefügt werden, auch dem lokalen Kernel angehängt werden, es sei denn, es wird durch <code>nooptions</code> oder <code>nodevice</code> unterbunden. Eine umfassende Liste von Konfigurationseinstellungen und deren Beschreibungen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um einen Kernel mit allen möglichen Optionen zu bauen, führen Sie als <code>root</code> die folgenden Befehle aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/arch/conf &amp;&amp; make LINT</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kernelconfig-building>14.5. Einen angepassten Kernel bauen und installieren<a class=anchor href=#kernelconfig-building></a></h3><div class=paragraph><p>Nachdem die Änderungen an der angepassten Kernelkonfigurationsdatei gespeichert sind, kann der Quellcode für den Kernel mit den folgenden Schritten übersetzt werden:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Einen Kernel bauen</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Wechseln Sie das Verzeichnis:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div></li><li><p>Bauen Sie den Kernel, indem Sie den Namen der Kernelkonfigurationsdatei angeben:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=MYKERNEL</span></code></pre></div></div></li><li><p>Installieren Sie den neuen Kernel. Dieser Befehl wird den neuen Kernel nach <span class=filename>/boot/kernel/kernel</span> kopieren, und den alten Kernel nach <span class=filename>/boot/kernel.old/kernel</span> speichern:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make installkernel KERNCONF=MYKERNEL</span></code></pre></div></div></li><li><p>Fahren Sie das System herunter und starten Sie den neuen Kernel. Wenn etwas nicht funktioniert, lesen Sie <a href=#kernelconfig-noboot>Der Kernel bootet nicht</a>.</p></li></ol></div></div></div><div class=paragraph><p>In der Voreinstellung werden beim Bau eines angepassten Kernels stets alle Kernelmodule neu gebaut. Um einen Kernel schneller zu bauen, oder um nur bestimmte Module zu bauen, bearbeiten Sie <span class=filename>/etc/make.conf</span>, bevor Sie den Kernel neu bauen.</p></div><div class=paragraph><p>In diesem Beispiel werden über eine Variable nur die Kernelmodule definiert, die auch tatsächlich gebaut werden sollen. In der Voreinstellung werden alle Module gebaut:</p></div><div class="literalblock programlisting"><div class=content><pre>MODULES_OVERRIDE = linux acpi</pre></div></div><div class=paragraph><p>Alternativ kann auch eine Variable verwendet werden, die bestimmte Kernelmodule vom Bauprozess ausschließt:</p></div><div class="literalblock programlisting"><div class=content><pre>WITHOUT_MODULES = linux acpi sound</pre></div></div><div class=paragraph><p>Weitere Variablen und deren Beschreibung finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a>.</p></div></div><div class=sect2><h3 id=kernelconfig-trouble>14.6. Wenn etwas schiefgeht<a class=anchor href=#kernelconfig-trouble></a></h3><div class=paragraph><p>Es gibt vier Hauptfehlerquellen beim Erstellen eines angepassten Kernels:</p></div><div class=dlist><dl><dt class=hdlist1><code>config</code> verursacht Fehler</dt><dd><p>Wenn <code>config</code> fehlschlägt, zeigt es die Nummer der Zeile an, die das Problem verursacht. Bei der folgenden Fehlermeldung sollten Sie die angegebene Zeile mit <span class=filename>GENERIC</span> oder <span class=filename>NOTES</span> vergleichen und sicherstellen, dass das Schlüsselwort in Zeile 17 richtig geschrieben ist:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>config: line 17: syntax error</code></pre></div></div></dd><dt class=hdlist1><code>make</code> verursacht Fehler</dt><dd><p>Wenn <code>make</code> fehlschlägt, liegen meistens Fehler in der Konfigurationsdatei vor, die aber nicht schwerwiegend genug für <code>config</code> waren. Überprüfen Sie die Konfiguration und wenn Sie keinen Fehler entdecken können, schicken Sie eine E-Mail mit der Kernelkonfigurationsdatei an die Mailingliste Fragen und Antworten zu FreeBSD &lt;<a href=mailto:de-bsd-questions@de.FreeBSD.org>de-bsd-questions@de.FreeBSD.org</a>>.</p></dd></dl></div><div id=kernelconfig-noboot class=dlist><dl><dt class=hdlist1>Der Kernel bootet nicht</dt><dd><p>Wenn der neue Kernel nicht bootet oder die Geräte nicht erkannt werden, ist das noch kein Grund zur Panik. Glücklicherweise besitzt FreeBSD einen exzellenten Mechanismus zur Wiederherstellung nach dem Einsatz inkompatibler Kernel. Wählen Sie einfach den zu bootenden Kernel im FreeBSD Bootloader aus. Dazu wählen Sie im Bootmenü die Option "Escape to a loader prompt". Danach geben Sie am Prompt <code>boot <em>kernel.old</em></code> oder den Namen eines anderen Kernels ein, der sauber bootet.</p><div class=paragraph><p>Nun kann die Konfiguration noch einmal überprüft und der Kernel neu kompiliert werden. Dazu ist <span class=filename>/var/log/messages</span> sehr nützlich, da hier sämtliche Kernelmeldungen von jedem erfolgreichen Bootvorgang gespeichert werden. <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> gibt die Kernelmeldungen vom letzten Bootvorgang aus.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie Probleme beim Kernelbau bekommen, heben Sie sich immer eine Kopie von <span class=filename>GENERIC</span> oder einen anderen Kernel, der garantiert bootet, auf. Dies ist sehr wichtig, weil jedes Mal, wenn ein neuer Kernel installiert wird, <span class=filename>kernel.old</span> mit dem zuletzt installierten Kernel überschrieben wird und dieser möglicherweise nicht bootfähig ist. Verschieben Sie daher den funktionierenden Kernel so schnell wie möglich, indem Sie das Verzeichnis mit dem funktionierenden Kernel umbenennen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /boot/kernel /boot/kernel.bad</span>
<span class=c># mv /boot/kernel.good /boot/kernel</span></code></pre></div></div></td></tr></tbody></table></div><div class=dlist><dl><dt class=hdlist1>Der Kernel funktioniert, aber <code>ps</code> nicht</dt><dd><p>Wenn Sie eine andere Version des Kernels installiert haben als die, mit der Ihre Systemwerkzeuge gebaut wurden, beispielsweise einen Kernel aus den -CURRENT-Quellen auf einem -RELEASE-System, werden Programme wie <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=vmstat&amp;sektion=8&amp;format=html">vmstat(8)</a> nicht mehr funktionieren. Um dies zu beheben, sollten Sie das <a href=./#makeworld>komplette System neu bauen und installieren</a>. Achten Sie darauf, dass die Quellen, aus denen das System gebaut wird, zum installierten Kernel passt. Man sollte niemals einen Kernel benutzen, der nicht zur Systemversion passt.</p></dd></dl></div></dd></dl></div></div></div></div><div class=sect1><h2 id=printing>Kapitel 15. Drucken<a class=anchor href=#printing></a></h2><div class=sectionbody><div class=paragraph><p>Trotz vieler Versuche es zu vermeiden, ist der Druck von Informationen auf Papier immer noch eine wichtige Funktion. Drucken hat zwei grundlegende Komponenten. Die Daten müssen an den Drucker gesendet werden, und zwar in einer Form, die der Drucker verstehen kann.</p></div><div class=sect2><h3 id=printing-quick-start>15.1. Schnellstart<a class=anchor href=#printing-quick-start></a></h3><div class=paragraph><p>Die grundlegende Druckfunktion kann schnell eingerichtet werden. Der Drucker muss lediglich fähig sein, normalen ASCII-Text zu drucken. Informationen zum Druck von anderen Dateien finden Sie in <a href=#printing-lpd-filters>Filter</a>.</p></div><div class="sidebarblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Erstellen Sie ein Verzeichnis zur Speicherung der Druckaufträge:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /var/spool/lpd/lp</span>
<span class=c># chown daemon:daemon /var/spool/lpd/lp</span>
<span class=c># chmod 770 /var/spool/lpd/lp</span></code></pre></div></div></li><li><p>Erstellen Sie als <code>root</code> die Datei <span class=filename>/etc/printcap</span> mit folgendem Inhalt:</p><div class="literalblock programlisting"><div class=content><pre>lp:\
	:lp=/dev/unlpt0:\  <i class=conum data-value=1></i><b>(1)</b>
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/lp:\
	:lf=/var/log/lpd-errs:</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Diese Zeile ist für einen Drucker, der an einem USB-Port angeschlossen ist.Für einen Drucker, der am parallelen oder "Drucker"-Port angeschlossen ist, verwenden Sie:Für einen Netzwerkdrucker verwenden Sie:Ersetzen Sie <em>network-printer-name</em> durch den DNS-Namen des Netzwerkdruckers.</td></tr></tbody></table></div></li><li><p>Aktivieren Sie <code>lpd</code> beim Systemstart, indem Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzufügen:</p><div class="literalblock programlisting"><div class=content><pre>lpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten Sie den Dienst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service lpd start</span>
Starting lpd.</code></pre></div></div><div class=paragraph><p>Drucken Sie eine Testseite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># printf &#34;1. Der Drucker kann drucken.\n2. Dies ist die zweite Zeile.\n&#34; | lpr</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Wenn die beiden Zeilen nicht am linken Rand starten und Sie einen "Treppeneffekt" beobachten, lesen Sie <a href=#printing-lpd-filters-stairstep>Den Treppeneffekt verhindern</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Mit <code>lpr</code> können nun Textdateien gedruckt werden. Geben Sie den Dateinamen auf der Kommandozeile an oder lassen Sie <code>lpr</code> von einer Pipe lesen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr textfile.txt
% <span class=nb>ls</span> <span class=nt>-lh</span> | lpr</code></pre></div></div></li></ol></div></div></div></div><div class=sect2><h3 id=printing-connections>15.2. Druckerverbindungen<a class=anchor href=#printing-connections></a></h3><div class=paragraph><p>Es gibt eine Vielzahl von Möglichkeiten, einen Drucker mit einem Rechner zu verbinden. Kleine Desktop-Drucker werden in der Regel mit dem USB-Anschluss verbunden, ältere Modelle nutzen oft die parallele Schnittstelle. Einige Drucker sind direkt mit einem Netzwerk verbunden, damit sie leichter von mehreren Rechnern benutzt werden können. Nur noch wenige Drucker verwenden einen seriellen Anschluss.</p></div><div class=paragraph><p>FreeBSD unterstützt die folgenden Arten von Druckern:</p></div><div id=printing-connections-usb class=dlist><dl><dt class=hdlist1>USB</dt><dd><p>USB-Drucker können mit einem freien USB-Anschluss des Rechners verbunden werden.</p><div class=paragraph><p>Wenn FreeBSD einen USB-Drucker erkennt, werden zwei Gerätenamen erstellt: <span class=filename>/dev/ulpt0</span> und <span class=filename>/dev/unlpt0</span>. Beide Geräte leiten die Daten an den Drucker weiter. Nach jedem Druckauftrag wird der USB-Anschluss von <span class=filename>ultp0</span> zurückgesetzt. Das Zurücksetzen kann bei einigen Druckern Probleme verursachen, daher wird in der Regel stattdessen <span class=filename>unlpt0</span> verwendet, das den Anschluss nicht zurücksetzt.</p></div></dd></dl></div><div id=printing-connections-parallel class=dlist><dl><dt class=hdlist1>Prallel (IEEE-1284)</dt><dd><p>Die parallele Schnittstelle ist <span class=filename>/dev/lpt0</span>. Der Gerätename erscheint unabhängig davon, ob ein Drucker angeschlossen ist oder nicht. Eine automatische Erkennung findet nicht statt.</p><div class=paragraph><p>Die Hersteller haben sich weitgehend von diesem älteren Anschluss verabschiedet und auch viele Rechner haben keine parallele Schnittstelle mehr. Es existieren jedoch Adapter, um einen parallelen Drucker an einem USB-Port anzuschließen. Der Drucker wird dann wie ein USB-Drucker behandelt. Es können auch <em>Printserver</em> verwendet werden, um parallele Drucker direkt mit einem Netzwerk zu verbinden.</p></div></dd></dl></div><div id=printing-connections-serial class=dlist><dl><dt class=hdlist1>Seriell (RS-232)</dt><dd><p>Serielle Anschlüsse sind veraltet und werden außer in Nischenanwendungen nur noch selten verwendet. Die Kabel, Stecker und die erforderliche Verkabelung sind oft sehr unterschiedlich.</p><div class=paragraph><p>Der Gerätename für einen seriellen Anschlüsse ist <span class=filename>/dev/cuau0</span> oder <span class=filename>/dev/cuau1</span>. Es können auch USB-Adapter verwendet werden. Diese erscheinen als <span class=filename>/dev/cuaU0</span>.</p></div><div class=paragraph><p>Damit mit dem Drucker kommuniziert werden kann, müssen einige Kommunikationsparameter bekannt sein. Zu den wichtigsten zählen die <em>Baudrate</em> (BPS - Bits pro Sekunde) und die <em>Parität</em>. Diese Werte variieren, aber typische serielle Drucker verwenden eine Baudrate von 9600 und keine Parität.</p></div></dd></dl></div><div id=printing-connections-network class=dlist><dl><dt class=hdlist1>Netzwerk</dt><dd><p>Netzwerkdrucker werden direkt mit dem lokalen Netzwerk verbunden.</p><div class=paragraph><p>Der DNS-Name des Druckers muss bekannt sein. Wenn dem Drucker eine dynamische Adresse per DHCP zugeteilt wird, sollte das DNS automatisch aktualisiert werden, so dass der Drucker immer die richtige IP-Adresse hat. Um dieses Problem zu vermeiden, werden Netzwerkdruckern häufig statische IP-Adressen zugeteilt.</p></div><div class=paragraph><p>Die meisten Netzwerkdrucker verstehen Druckaufträge, die über das LPD-Protokoll empfangen werden. Sie können auch den Namen der Druckwarteschlange angeben. Einige Drucker verarbeiten die Daten unterschiedlich, je nachdem welche Warteschlange verwendet wird. Zum Beispiel druckt eine <code>Raw</code>-Warteschlange die Daten unverändert, während eine <code>Text</code>-Warteschlange den Text um Wagenrückläufe ergänzt.</p></div><div class=paragraph><p>Viele Netzwerkdrucker können auch Daten drucken, die direkt an Port 9100 gesendet werden.</p></div></dd></dl></div><div class=sect3><h4 id=printing-connections-summary>15.2.1. Zusammenfassung<a class=anchor href=#printing-connections-summary></a></h4><div class=paragraph><p>Verkabelte Netzwerkdrucker drucken in der Regel am schnellsten und sind einfach einzurichten. Für den direkten Anschluss am Rechner wird USB wegen seiner Geschwindigkeit und Einfachheit bevorzugt. Parallele Verbindungen funktionieren, haben jedoch ihre Begrenzung in Bezug auf Kabellänge und Geschwindigkeit. Serielle Verbindungen sind schwieriger zu konfigurieren und die Verdrahtung unterscheidet sich zwischen den Modellen. Zudem müssen Baudrate und Parität bekannt sein. Glücklicherweise sind serielle Drucker selten geworden.</p></div></div></div><div class=sect2><h3 id=printing-pdls>15.3. Gebräuchliche Seitenbeschreibungssprachen<a class=anchor href=#printing-pdls></a></h3><div class=paragraph><p>Daten, die an einen Drucker gesendet werden, müssen in einer Sprache verfasst sein, die der Drucker verstehen kann. Diese Sprachen werden Seitenbeschreibungssprachen oder Page Description Languages (PDL) genannt.</p></div><div id=print-pdls-ascii class=dlist><dl><dt class=hdlist1>ASCII</dt><dd><p>Schlichter ASCII-Text ist die einfachste Möglichkeit, um Daten an einen Drucker zu senden. Die Zeichen werden eins zu eins gedruckt: ein <code>A</code> in den Daten erscheint beim Druck als <code>A</code> auf dem Papier. Eine Formatierung ist nur bedingt verfügbar und es gibt keine Möglichkeit, eine Schriftart oder eine bestimmte Laufweite zu wählen. Die Einfachheit von schlichtem ASCII-Text bedeutet, dass Text ohne bzw. wenig Codierung oder Übersetzung gedruckt werden kann. Die gedruckte Ausgabe entspricht dem, was an den Drucker gesendet wurde.</p><div class=paragraph><p>Einige kostengünstige Drucker können keinen einfachen ASCII-Text drucken. Das macht sie in der Regel schwieriger einzurichten.</p></div></dd></dl></div><div id=print-pdls-postscript class=dlist><dl><dt class=hdlist1>PostScript®</dt><dd><p>PostScript® ist fast das Gegenteil von ASCII. Anstelle von einfachem Text, besteht ein PostScript®-Programm aus einer Reihe von Anweisungen, die das endgültige Dokument generieren. Es können auch verschiedene Schriften und Grafiken benutzt werden. Diese Fähigkeiten haben jedoch ihren Preis. Das Programm, das die Seite generiert, muss zunächst erzeugt werden. Normalerweise wird dieses Programm durch die Anwendung erzeugt, so dass der Prozess für den Benutzer transparent bleibt.</p><div class=paragraph><p>Kostengünstige Drucker sind manchmal nicht kompatibel mit PostScript®.</p></div></dd></dl></div><div id=print-pdls-pcl class=dlist><dl><dt class=hdlist1>PCL (Printer Command Language)</dt><dd><p>PCL ist eine Erweiterung von ASCII. Es enthält Escape-Sequenzen für die Formatierung, Schriftauswahl und das Drucken von Grafiken. Viele Drucker bieten Unterstützung für PCL5, einige unterstützen auch das neuere PCL6 oder PCLXL. Die neueren Versionen sind Kombinationen von PCL5 und bieten eine schnellere Druckgeschwindigkeit.</p></dd></dl></div><div id=print-pdls-host-based class=dlist><dl><dt class=hdlist1>Host-basiert</dt><dd><p>Hersteller können die Kosten eines Druckers reduzieren, indem sie einen einfachen Prozessor und etwas Speicher verbauen. Diese Drucker sind nicht in der Lage normalen Text zu drucken. Stattdessen werden die Texte und Grafiken von einem Treiber auf dem Host-Rechner generiert und dann an den Drucker gesendet. Diese Drucker werden Host-basierte Drucker genannt.</p><div class=paragraph><p>Die Kommunikation zwischen dem Treiber und dem Drucker wird oft durch proprietäre oder nicht dokumentierte Protokolle realisiert, weshalb sie nur mit den gängigsten Betriebssystemen funktionieren.</p></div></dd></dl></div><div class=sect3><h4 id=print-pdls-table>15.3.1. PostScript® in eine andere Sprache konvertieren<a class=anchor href=#print-pdls-table></a></h4><div class=paragraph><p>Viele Anwendungen aus der Ports-Sammlung und FreeBSD Werkzeuge können PostScript® erzeugen. Die folgende Tabelle listet die verfügbaren Programme, um PostScript® in andere PDLs zu konvertieren:</p></div><table id=printing-pdls-ps-to-other-tbl class="tableblock frame-all grid-all stretch"><caption class=title>Tabelle 8. Ausgabe PDLs</caption><col style=width:20%><col style=width:20%><col style=width:60%><thead><tr><th class="tableblock halign-left valign-top">Ausgabe PDL</th><th class="tableblock halign-left valign-top">Generiert von</th><th class="tableblock halign-left valign-top">Hinweis</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>PCL oder PCL5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-sDEVICE=ljet4</code> für Schwarzweiß, <code>-sDEVICE=cljet5</code> für Farbe</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>PCLXL oder PCL6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-sDEVICE=pxlmono</code> für Schwarzweiß, <code>-sDEVICE=pxlcolor</code> für Farbe</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ESC/P2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-sDEVICE=uniprint</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>XQX</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/foo2zjs/>print/foo2zjs</a></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table></div><div class=sect3><h4 id=print-pdls-summary>15.3.2. Zusammenfassung<a class=anchor href=#print-pdls-summary></a></h4><div class=paragraph><p>Um die Konfiguration einfach zu halten, wählen Sie einen Drucker, der PostScript® oder auch PCL unterstützt. Mit <a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a> können diese Drucker PostScript® nativ verstehen. Wenn der Drucker PostScript® oder PCL direkt unterstützt, können Sie auch sofort einfache ASCII-Textdateien drucken.</p></div><div class=paragraph><p>Zeilenbasierte Drucker wie Tintenstrahldrucker unterstützen in der Regel kein PostScript® oder PCL. Dennoch können Sie ASCII-Textdateien drucken. <a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a> unterstützt die Sprachen dieser Drucker. Jedoch ist der Druck von Grafiken auf diesen Druckern oft sehr langsam, da aufgrund der großen Menge an Daten übertragen und ausgedruckt werden müssen.</p></div><div class=paragraph><p>Host-basierte Drucker sind oft schwieriger einzurichten. Einige Drucker können überhaupt nicht benutzt werden, da sie proprieräte PDLs verwerden. Solche Drucker sollten Sie nach Möglichkeit vermeiden.</p></div><div class=paragraph><p>Die Beschreibungen vieler PDLs finden Sie auf <a href=http://www.undocprint.org/formats/page_description_languages class=bare>http://www.undocprint.org/formats/page_description_languages</a>. Spezielle PDLs, die von einigen Druckern verwendet werden finden Sie auf <a href=http://www.openprinting.org/printers class=bare>http://www.openprinting.org/printers</a>.</p></div></div></div><div class=sect2><h3 id=printing-direct>15.4. Direktes Drucken<a class=anchor href=#printing-direct></a></h3><div class=paragraph><p>Für den gelegentlichen Druck können die Dateien auch direkt, ohne zusätzliche Einstellungen, an den Drucker gesendet werden. Zum Beispiel kann die Datei <span class=filename>sample.txt</span> direkt an einen USB-Drucker gesendet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp sample.txt /dev/unlpt0</span></code></pre></div></div><div class=paragraph><p>Ob Sie direkt auf einen Netzwerkdrucker drucken können, hängt von den Fähigkeiten des Druckers ab. Die meisten akzeptieren jedoch Druckaufträge auf Port 9100, die Sie mit <a href="https://man.freebsd.org/cgi/man.cgi?query=nc&amp;sektion=1&amp;format=html">nc(1)</a> an den Drucker senden können. So drucken Sie die gleiche Datei auf einem Drucker mit dem DNS-Namen <em>netlaser</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nc netlaser 9100 &lt; sample.txt</span></code></pre></div></div></div><div class=sect2><h3 id=printing-lpd>15.5. LPD (Line Printer Daemon)<a class=anchor href=#printing-lpd></a></h3><div class=paragraph><p>Drucken im Hintergrund wird <em>Spooling</em> genannt. Ein Spooler (Warteschlange) ermöglicht es dem Benutzer die Programme auf dem Rechner fortzusetzen, ohne warten zu müssen bis der Druckauftrag abgeschlossen ist.</p></div><div class=paragraph><p>FreeBSD enthält den Spooler namens <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>. Druckaufträge werden mit <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> übermittelt.</p></div><div class=sect3><h4 id=printing-lpd-setup>15.5.1. Konfiguration<a class=anchor href=#printing-lpd-setup></a></h4><div class=paragraph><p>Erstellen Sie ein Verzeichnis zur Speicherung der Druckaufträge und setzen Sie die Berechtigungen auf diesem Verzeichnis, damit der Inhalt der Druckaufträge nicht von anderen Benutzern eingesehen werden kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /var/spool/lpd/lp</span>
<span class=c># chown daemon:daemon /var/spool/lpd/lp</span>
<span class=c># chmod 770 /var/spool/lpd/lp</span></code></pre></div></div><div class=paragraph><p>Drucker werden in <span class=filename>/etc/printcap</span> angelegt. Ein Eintrag für einen Drucker enthält dessen Name, Anschluss sowie weitere Einstellungen. Erstellen Sie <span class=filename>/etc/printcap</span> mit folgendem Inhalt:</p></div><div class="literalblock programlisting"><div class=content><pre>lp:\				<i class=conum data-value=1></i><b>(1)</b>
	:lp=/dev/unlpt0:\	<i class=conum data-value=2></i><b>(2)</b>
	:sh:\			<i class=conum data-value=3></i><b>(3)</b>
	:mx#0:\			<i class=conum data-value=4></i><b>(4)</b>
	:sd=/var/spool/lpd/lp:\	<i class=conum data-value=5></i><b>(5)</b>
	:lf=/var/log/lpd-errs:	<i class=conum data-value=6></i><b>(6)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Der Name des Druckers. <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> sendet Druckaufträge an den Drucker <code>lp</code>, es sei denn, ein anderer Drucker wird mit der Option <code>-P</code> angegeben. Der Standarddrucker sollte also <code>lp</code> genannt werden.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Der Anschluss, über den der Drucker verbunden ist. Ersetzen Sie diese Zeile mit dem entsprechenden, hier aufgeführten Verbindungstyp.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Unterdrückt das Drucken eines Deckblattes zu Beginn des Druckauftrags.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Die maximale Größe des Druckauftrags wird nicht begrenzt.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Das Verzeichnis zur Speicherung der Druckdaten. Jeder Drucker verwendet ein eigenes Verzeichnis.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Die Logdatei, in welche die Fehler des Druckers geschrieben werden.</td></tr></tbody></table></div><div class=paragraph><p>Nachdem Sie <span class=filename>/etc/printcap</span> erstellt haben, verwenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=chkprintcap&amp;sektion=8&amp;format=html">chkprintcap(8)</a> um die Datei auf Fehler zu testen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chkprintcap</span></code></pre></div></div><div class=paragraph><p>Beheben Sie alle gemeldeten Fehler, bevor Sie fortfahren.</p></div><div class=paragraph><p>Aktivieren Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>lpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten Sie den Dienst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service lpd start</span></code></pre></div></div></div><div class=sect3><h4 id=printing-lpd-lpr>15.5.2. Drucken mit <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a><a class=anchor href=#printing-lpd-lpr></a></h4><div class=paragraph><p>Mit <code>lpr</code> werden Dokumente an den Drucker geschickt. Die Datei können Sie auf der Kommandozeile angeben, oder über eine Pipe an <code>lpr</code> schicken. Die beiden folgenden Kommandos sind gleichwertig, sie schicken den Inhalt von <span class=filename>doc.txt</span> an den Standarddrucker:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr doc.txt
% <span class=nb>cat </span>doc.txt | lpr</code></pre></div></div><div class=paragraph><p>Drucker können auch mit <code>-P</code> ausgewählt werden. Um auf einen Drucker namens <em>laser</em> zu drucken:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-Plaser</span> doc.txt</code></pre></div></div></div><div class=sect3><h4 id=printing-lpd-filters>15.5.3. Filter<a class=anchor href=#printing-lpd-filters></a></h4><div class=paragraph><p>In den bisher gezeigten Beispielen wurde lediglich eine Textdatei an den Drucker gesendet. Solange der Drucker den Inhalt dieser Dateien versteht, wird die Ausgabe korrekt gedruckt werden.</p></div><div class=paragraph><p>Einige Drucker sind nicht in der Lage einfachen Text zu drucken. Es kann sogar sein, das die Eingabedatei gar keinen Text enthält.</p></div><div class=paragraph><p>Mit Hilfe von <em>Filtern</em> können Dateien übersetzt oder verarbeitet werden. Ein typischer Anwendungsfall ist die Umwandlung der Eingabedaten in ein Format, das der Drucker verstehen kann, wie bspw. PostScript® oder PCL. Filter können auch verwendet werden um zusätzliche Funktionen hinzuzufügen, wie bspw. Seitenzahlen oder das Hervorheben von Quellcode, um die Lesbarkeit zu verbessern.</p></div><div class=paragraph><p>Die hier beschriebenen Filter werden <em>Eingabefilter</em> oder auch <em>Textfilter</em> genannt. Diese Filter übersetzen die eingehende Datei in verschiedene Formen. Werden Sie mit <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> zu <code>root</code>, bevor Sie die Dateien erstellen.</p></div><div class=paragraph><p>Filter werden in <span class=filename>/etc/printcap</span> mit der Kennung <code>if=</code> festgelegt. Um <span class=filename>/usr/local/libexec/lf2crlf</span> als Filter einzusetzen, bearbeiten Sie <span class=filename>/etc/printcap</span> wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>lp:\
	:lp=/dev/unlpt0:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/lp:\
	:if=/usr/local/libexec/lf2crlf:\   <i class=conum data-value=1></i><b>(1)</b>
	:lf=/var/log/lpd-errs:</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>if=</code> identifiziert den Eingangsfilter, der auf den eingehenden Text angewendet werden soll.</td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Der Backslash am Ende der Zeilen zeigt an, das ein Eintrag für einen Drucker wirklich nur eine Zeile ist, in der die einzelnen Einträge durch einen Doppelpunkt getrennt sind. Das Beispiel hätte man auch wie folgt schreiben können:</p></div><div class="literalblock programlisting"><div class=content><pre>lp:lp=/dev/unlpt0:sh:mx#0:sd=/var/spool/lpd/lp:if=/usr/local/libexec/lf2crlf:lf=/var/log/lpd-errs:</pre></div></div></td></tr></tbody></table></div><div class=sect4><h5 id=printing-lpd-filters-stairstep>15.5.3.1. Den Treppeneffekt verhindern<a class=anchor href=#printing-lpd-filters-stairstep></a></h5><div class=paragraph><p>Typische Textdateien enthalten einen Zeilenvorschub am Ende jeder Zeile. Diese Zeilen erzeugen auf dem Drucker einen "Treppeneffekt":</p></div><div class="literalblock programlisting"><div class=content><pre>A printed file looks
                    like the steps of a staircase
                                                 scattered by the wind</pre></div></div><div class=paragraph><p>Ein Filter kann Zeilenumbrüche in Wagenrückläufe und Zeilenumbrüche konvertieren. Erstellen Sie <span class=filename>/usr/local/libexec/lf2crlf</span> mit folgendem Inhalt:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
CR=$&#39;\r&#39;
/usr/bin/sed -e &#34;s/$/${CR}/g&#34;</pre></div></div><div class=paragraph><p>Setzen Sie die Berechtigungen und machen Sie die Datei ausführbar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/lf2crlf</span></code></pre></div></div><div class=paragraph><p>Passen Sie <span class=filename>/etc/printcap</span> an, so dass der neue Filter verwendet wird:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/lf2crlf:\</pre></div></div><div class=paragraph><p>Drucken Sie nochmal die gleiche Datei, um den Filter zu testen.</p></div></div><div class=sect4><h5 id=printing-lpd-filters-enscript>15.5.3.2. Mit <a class=package href=https://cgit.freebsd.org/ports/tree/print/enscript/>print/enscript</a> normalen Text auf PostScript®-Druckern drucken<a class=anchor href=#printing-lpd-filters-enscript></a></h5><div class=paragraph><p>GNUEnscript wandelt Textdateien in formatiertes PostScript® um, die dann auf PostScript®-Druckern gedruckt werden können. Das Programm fügt auch Seitenzahlen und Zeilenumbrüche hinzu und stellt andere Funktionen bereit, um gedruckte Textdateien besser lesbar zu machen. Abhängig vom Papierformat können Sie entweder <a class=package href=https://cgit.freebsd.org/ports/tree/print/enscript-letter/>print/enscript-letter</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/print/enscript-a4/>print/enscript-a4</a> aus der Ports-Sammlung installieren.</p></div><div class=paragraph><p>Erstellen Sie <span class=filename>/usr/local/libexec/enscript</span> mit diesem Inhalt:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
/usr/local/bin/enscript -o -</pre></div></div><div class=paragraph><p>Setzen Sie die Berechtigungen und machen Sie die Datei ausführbar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/enscript</span></code></pre></div></div><div class=paragraph><p>Bearbeiten Sie <span class=filename>/etc/printcap</span> um den neuen Filter zu verwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/enscript:\</pre></div></div><div class=paragraph><p>Testen Sie den Filter, indem Sie eine einfache Textdatei drucken.</p></div></div><div class=sect4><h5 id=printing-lpd-filters-ps2pcl>15.5.3.3. PostScript® auf PCL-Druckern drucken<a class=anchor href=#printing-lpd-filters-ps2pcl></a></h5><div class=paragraph><p>Viele Programme erzeugen PostScript®-Dokumente. Allerdings können kostengünstige Drucker oft nur Textdateien oder PCL verstehen. Dieser Filter wandelt PostScript®-Dateien in PCL um, bevor die Datei an den Drucker geschickt wird. Installieren Sie den Ghostscript PostScript® Interpreter <a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/>print/ghostscript9-base</a> aus der Ports-Sammlung.</p></div><div class=paragraph><p>Erstellen Sie <span class=filename>/usr/local/libexec/ps2pcl</span> mit diesem Inhalt:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
/usr/local/bin/gs -dSAFER -dNOPAUSE -dBATCH -q -sDEVICE=ljet4 -sOutputFile=- -</pre></div></div><div class=paragraph><p>Setzen Sie die Berechtigungen und machen Sie die Datei ausführbar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/ps2pcl</span></code></pre></div></div><div class=paragraph><p>Die PostScript®-Eingabe wird von dem Skript erst in PCL umgewandelt, bevor es an den Drucker geschickt wird.</p></div><div class=paragraph><p>Bearbeiten Sie <span class=filename>/etc/printcap</span> um den neuen Filter zu verwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/ps2pcl:\</pre></div></div><div class=paragraph><p>Testen Sie den Filter mit einem kleinen PostScript®-Programm.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>printf</span> <span class=s2>&#34;%%</span><span class=se>\!</span><span class=s2>PS </span><span class=se>\n</span><span class=s2> /Helvetica findfont 18 scalefont setfont </span><span class=se>\</span><span class=s2>
72 432 moveto (PostScript printing successful.) show showpage </span><span class=se>\0</span><span class=s2>04&#34;</span> | lpr</code></pre></div></div></div><div class=sect4><h5 id=printing-lpd-filters-smart>15.5.3.4. Intelligente Filter<a class=anchor href=#printing-lpd-filters-smart></a></h5><div class=paragraph><p>Ein Filter kann sehr nützlich sein, wenn er die Eingabe erkennt und sie automatisch in ein für den Drucker verständliches Format umwandelt. Die ersten beiden Zeichen in einer PostScript®-Datei sind in der Regel <code>%!</code>. Ein Filter ist in der Lage diese beiden Zeichen zu erkennen. PostScript®-Dateien können unverändert an einen PostScript®-Drucker geschickt werden. Textdateien können, wie eben gezeigt, mit Enscript in PostScript® umgewandelt werden. Erstellen Sie <span class=filename>/usr/local/libexec/psif</span> mit diesem Inhalt:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psif - Print PostScript or plain text on a PostScript printer
#
IFS=&#34;&#34; read -r first_line
first_two_chars=`expr &#34;$first_line&#34; : &#39;\(..\)&#39;`

case &#34;$first_two_chars&#34; in
%!)
    # %! : PostScript job, print it.
    echo &#34;$first_line&#34; &amp;&amp; cat &amp;&amp; exit 0
    exit 2
    ;;
*)
    # otherwise, format with enscript
    ( echo &#34;$first_line&#34;; cat ) | /usr/local/bin/enscript -o - &amp;&amp; exit 0
    exit 2
    ;;
esac</pre></div></div><div class=paragraph><p>Setzen Sie die Berechtigungen und machen Sie die Datei ausführbar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/psif</span></code></pre></div></div><div class=paragraph><p>Bearbeiten Sie <span class=filename>/etc/printcap</span> um den neuen Filter zu verwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/psif:\</pre></div></div><div class=paragraph><p>Um den Filter zu testen, drucken Sie PostScript®- und einfache Textdateien.</p></div></div></div><div class=sect3><h4 id=printing-lpd-queues>15.5.4. Mehrere Warteschlangen<a class=anchor href=#printing-lpd-queues></a></h4><div class=paragraph><p>Die Einträge in <span class=filename>/etc/printcap</span> sind nichts anderes als Definitionen von Warteschlangen. Für jeden Drucker können eine oder mehrere Warteschlangen definiert werden. Kombiniert mit Filtern bieten mehrere Warteschlangen eine bessere Kontrolle über die Druckaufträge.</p></div><div class=paragraph><p>Als Beispiel dient ein vernetzter PostScript®-Laserdrucker in einem Büro. Die meisten Benutzer möchten einfache Textdateien drucken, aber ein paar fortgeschrittene Anwender sollen in der Lage sein, PostScript®-Dateien direkt zu drucken. Hierfür werden zwei Einträge für den Drucker in <span class=filename>/etc/printcap</span> erstellt:</p></div><div class="literalblock programlisting"><div class=content><pre>textprinter:\
	:lp=9100@officelaser:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/textprinter:\
	:if=/usr/local/libexec/enscript:\
	:lf=/var/log/lpd-errs:

psprinter:\
	:lp=9100@officelaser:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/psprinter:\
	:lf=/var/log/lpd-errs:</pre></div></div><div class=paragraph><p>Dokumente, die zum <code>textprinter</code> geschickt werden, werden wie im vorherigen Beispiel durch den Filter <span class=filename>/usr/local/libexec/enscript</span> formatiert. Fortgeschrittene Anwender können PostScript®-Dateien direkt auf dem Drucker <code>psprinter</code> drucken, wo keine Filterung stattfindet.</p></div><div class=paragraph><p>Mit mehreren Warteschlangen können Sie einen direkten Zugriff auf alle Arten von Druckerfunktionen zur Verfügung stellen. Ein Duplex-Drucker könnte zwei Warteschlangen verwenden, eine für den gewöhnlichen Druck und eine für den Duplexdruck.</p></div></div><div class=sect3><h4 id=printing-lpd-monitor>15.5.5. Druckaufträge steuern und überwachen<a class=anchor href=#printing-lpd-monitor></a></h4><div class=paragraph><p>Es stehen verschiedene Programme zur Verfügung um Druckaufträge zu überwachen und den Druckbetrieb zu steuern.</p></div><div class=sect4><h5 id=printing-lpd-monitor-lpq>15.5.5.1. <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a><a class=anchor href=#printing-lpd-monitor-lpq></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> zeigt den Status der Druckaufträge des Benutzers an. Druckaufträge anderer Benutzer werden nicht angezeigt.</p></div><div class=paragraph><p>Dieser Befehl zeigt die anstehenden Druckaufträge eines Benutzers für einen Drucker an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq <span class=nt>-Plp</span>
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     0    <span class=o>(</span>standard input<span class=o>)</span>                      12792 bytes</code></pre></div></div><div class=paragraph><p>Der folgende Befehl zeigt die anstehenden Druckaufträge eines Benutzers für alle Drucker an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq <span class=nt>-a</span>
lp:
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     1    <span class=o>(</span>standard input<span class=o>)</span>                      27320 bytes

laser:
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     287  <span class=o>(</span>standard input<span class=o>)</span>                      22443 bytes</code></pre></div></div></div><div class=sect4><h5 id=printing-lpd-monitor-lprm>15.5.5.2. <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a><a class=anchor href=#printing-lpd-monitor-lprm></a></h5><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> können Druckaufträge gelöscht werden. Normale Benutzer dürfen lediglich ihre eigenen Aufträge löschen. <code>root</code> kann hingegen jeden beliebigen Auftrag löschen.</p></div><div class=paragraph><p>Dieser Befehl löscht alle anstehenden Druckaufträge eines Druckers:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lprm -Plp -</span>
dfA002smithy dequeued
cfA002smithy dequeued
dfA003smithy dequeued
cfA003smithy dequeued
dfA004smithy dequeued
cfA004smithy dequeued</code></pre></div></div><div class=paragraph><p>Mit dem folgenden Befehl löschen Sie einen bestimmten Druckauftrag. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a>, um die Nummer des Auftrags zu finden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     5    <span class=o>(</span>standard input<span class=o>)</span>                      12188 bytes
% lprm <span class=nt>-Plp</span> 5
dfA005smithy dequeued
cfA005smithy dequeued</code></pre></div></div></div><div class=sect4><h5 id=printing-lpd-monitor-lpc>15.5.5.3. <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a><a class=anchor href=#printing-lpd-monitor-lpc></a></h5><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> kann der Druckerstatus überprüft und verändert werden. <code>lpc</code> wird zusammen mit einem Kommando und optional mit einem Druckernamen aufgerufen. Mit <code>all</code> können alle Drucker angesprochen werden, auf denen das Kommando ausgeführt werden soll. Normale Benutzer können sich den Status mit <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> ansehen. Nur <code>root</code> darf Kommandos ausführen, die den Status des Druckers verändern.</p></div><div class=paragraph><p>Dieser Befehl zeigt den Status von allen Druckern an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpc status all
lp:
	queuing is enabled
	printing is enabled
	1 entry <span class=k>in </span>spool area
	printer idle
laser:
	queuing is enabled
	printing is enabled
	1 entry <span class=k>in </span>spool area
	waiting <span class=k>for </span>laser to come up</code></pre></div></div><div class=paragraph><p>Der Drucker kann die Annahme neuer Druckaufträge verweigern. Anschließend sollen Aufträge wieder akzeptiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc stop lp</span>
lp:
	printing disabled
<span class=c># lpc start lp</span>
lp:
	printing enabled
	daemon started</code></pre></div></div><div class=paragraph><p>Starten Sie den Drucker nach einem Fehler neu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc restart lp</span>
lp:
	no daemon to abort
	printing enabled
	daemon restarted</code></pre></div></div><div class=paragraph><p>Schalten Sie die Warteschlange aus und deaktivieren Sie den Druck. Sie können den Benutzern gleichzeitig eine Nachricht hinterlassen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc down lp Ersatzteile werden am Montag ankommen</span>
lp:
	printer and queuing disabled
	status message is now: Ersatzteile werden am Montag ankommen</code></pre></div></div><div class=paragraph><p>Reaktivieren Sie den Drucker:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc up lp</span>
lp:
	printing enabled
	daemon started</code></pre></div></div><div class=paragraph><p>Weitere Kommandos und Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>.</p></div></div></div><div class=sect3><h4 id=printing-lpd-shared>15.5.6. Gemeinsam genutzte Drucker<a class=anchor href=#printing-lpd-shared></a></h4><div class=paragraph><p>In Unternehmen und Schulen werden Drucker häufig von mehreren Benutzern genutzt. Es werden zusätzliche Funktionen angeboten, um die gemeinsame Nutzung von Druckern zu erleichtern.</p></div><div class=sect4><h5 id=printing-shared-aliases>15.5.6.1. Aliase<a class=anchor href=#printing-shared-aliases></a></h5><div class=paragraph><p>Der Druckername wird in der ersten Zeile von <span class=filename>/etc/printcap</span> festgelegt. Weitere Namen oder <em>Aliase</em> können nach dem Druckernamen hinzugefügt werden. Aliase werden vom Namen durch das Pipe-Zeichen <code>|</code> getrennt:</p></div><div class="literalblock programlisting"><div class=content><pre>lp|repairsprinter|salesprinter:\</pre></div></div><div class=paragraph><p>Anstelle des Druckernamens können Aliase verwendet werden. Zum Beispiel können Mitarbeiter der Verkaufsabteilung wie folgt auf ihren Drucker drucken:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-Psalesprinter</span> sales-report.txt</code></pre></div></div><div class=paragraph><p>Mitarbeiter der Reparaturabteilung drucken auf dem Drucker mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-Prepairsprinter</span> repairs-report.txt</code></pre></div></div><div class=paragraph><p>Alle Dokumente werden auf diesem einen Drucker gedruckt. Wenn die Verkaufsabteilung größer wird und die Abteilung einen eigenen Drucker benötigt, kann der Alias entfernt und für einen neuen Drucker verwendet werden. Die Mitarbeiter in beiden Abteilungen benutzen zum Drucken weiterhin die gleichen Befehle, nur dass die Aufträge der Verkaufsabteilung jetzt zum neuen Drucker gesendet werden.</p></div></div><div class=sect4><h5 id=printing-shared-headers>15.5.6.2. Deckblätter<a class=anchor href=#printing-shared-headers></a></h5><div class=paragraph><p>Bei einem viel benutzten Drucker kann es für die Anwender schwierig sein, ihre Dokumente in einem großen Papierstapel wiederzufinden. Um dieses Problem zu lösen, können <em>Deckblätter</em> verwendet werden. Dabei wird vor jedem Druckauftrag ein Deckblatt mit dem Benutzernamen und dem Dokumentnamen gedruckt. Deckblätter werden manchmal auch als <em>Banner</em> oder <em>Trennseite</em> bezeichnet.</p></div><div class=paragraph><p>Das Aktivieren der Deckblätter hängt davon ab, ob der Drucker direkt über ein USB, paralleles oder serielles Kabel, oder über ein Netzwerk mit dem Rechner verbunden ist.</p></div><div class=paragraph><p>Wenn der Drucker direkt verbunden ist, aktivieren Sie die Deckblätter durch Entfernen der Zeile <code>:sh:\</code> (Supress Header) in <span class=filename>/etc/printcap</span>. Diese Deckblätter verwenden lediglich einen Zeilenvorschub für neue Zeilen. Einige Drucker benötigen den Filter <span class=filename>/usr/shared/examples/printing/hpif</span> um den Treppeneffekt zu vermeiden. Der Filter konfiguriert PCL-Drucker so, dass sowohl Zeilenumbrüche als auch Zeilenvorschübe verwendet werden, wenn ein Zeilenvorschub empfangen wird.</p></div><div class=paragraph><p>Für Netzwerkdrucker müssen Deckblätter auf dem Drucker selbst konfiguriert werden, da Einträge für Deckblätter in <span class=filename>/etc/printcap</span> ignoriert werden. Die Einstellungen sind über einen Webbrowser zugänglich und stehen in der Regel auf der Hauptseite der Konfigurations-Webseite zur Verfügung.</p></div></div></div><div class=sect3><h4 id=printing-lpd-references>15.5.7. Referenzen<a class=anchor href=#printing-lpd-references></a></h4><div class=paragraph><p>Beispieldateien: <span class=filename>/usr/shared/examples/printing/</span>.</p></div><div class=paragraph><p>Das <em>4.3BSD Line Printer Spooler Manual</em>, <span class=filename>/usr/shared/doc/smm/07.lpd/paper.ascii.gz</span>.</p></div><div class=paragraph><p>Manualpages: <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a>.</p></div></div></div><div class=sect2><h3 id=printing-other>15.6. Andere Drucksysteme<a class=anchor href=#printing-other></a></h3><div class=paragraph><p>Neben dem in FreeBSD enthaltenen <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> existieren noch weitere Drucksysteme. Diese Systeme bieten zusätzliche Funktionen und Unterstützung für andere Protokolle.</p></div><div class=sect3><h4 id=printing-other-cups>15.6.1. CUPS (Common UNIX® Printing System)<a class=anchor href=#printing-other-cups></a></h4><div class=paragraph><p>CUPS ist ein beliebtes Drucksystem, das für viele Betriebssysteme erhältlich ist. CUPS unter FreeBSD wird in einem separaten Artikel beschrieben: <a href=https://docs.freebsd.org/en/articles/cups/>CUPS on FreeBSD</a>.</p></div></div><div class=sect3><h4 id=printing-other-hplip>15.6.2. HPLIP<a class=anchor href=#printing-other-hplip></a></h4><div class=paragraph><p>Hewlett Packard stellt ein Drucksystem zur Verfügung, das viele ihrer Drucker unterstützt. Der Port heißt <a class=package href=https://cgit.freebsd.org/ports/tree/print/hplip/>print/hplip</a>. Die Webseite befindet sich unter <a href=http://hplipopensource.com/hplip-web/index.html class=bare>http://hplipopensource.com/hplip-web/index.html</a>. Der FreeBSD-Port kümmert sich um alle Details während der Installation. Informationen zur Konfiguration finden Sie unter <a href=http://hplipopensource.com/hplip-web/install/manual/hp_setup.html class=bare>http://hplipopensource.com/hplip-web/install/manual/hp_setup.html</a>.</p></div></div><div class=sect3><h4 id=printing-other-lprng>15.6.3. LPRng<a class=anchor href=#printing-other-lprng></a></h4><div class=paragraph><p>LPRng wurde als eine verbesserte Alternative zu <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> entwickelt. Der Port heißt <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/LPRng/>sysutils/LPRng</a>. Weitere Informationen und Dokumentation finden Sie unter <a href=https://lprng.sourceforge.net/ class=bare>https://lprng.sourceforge.net/</a>.</p></div></div></div></div></div><div class=sect1><h2 id=linuxemu>Kapitel 16. Linux®-Binärkompatibilität<a class=anchor href=#linuxemu></a></h2><div class=sectionbody><div class=sect2><h3 id=linuxemu-synopsis>16.1. Übersicht<a class=anchor href=#linuxemu-synopsis></a></h3><div class=paragraph><p>FreeBSD bietet Binärkompatibilität zu Linux®, so dass Benutzer Linux® Anwendungen auf einem FreeBSD-System installieren und ausführen können, ohne die Binärdatei ändern zu müssen. Es wurde sogar berichtet, dass in einigen Situationen Linux® Anwendungen auf FreeBSD besser laufen als unter Linux®.</p></div><div class=paragraph><p>Allerdings werden einige Linux®-spezifischen Merkmale nicht von FreeBSD unterstützt. Linux®-Anwendungen, die i386™-spezifische Aufrufe, wie bspw. die Aktivierung des virtuellen 8086-Modus verwenden, werden derzeit nicht unterstützt.</p></div><div class=paragraph><p>Die Unterstützung für 64-Bit-Binärkompatibilität für Linux® wurde in FreeBSD 10.3 hinzugefügt.</p></div><div class=paragraph><p>Nach dem Lesen dieses Kapitels werden Sie wissen:</p></div><div class=ulist><ul><li><p>Wie Sie die Linux®-Binärkompatibilität aktivieren.</p></li><li><p>Wie zusätzliche Linux®-Systembibliotheken installiert werden.</p></li><li><p>Wie Sie Linux®-Anwendungen unter FreeBSD installieren.</p></li><li><p>Wie die Linux®-Binärkompatibilität unter FreeBSD implementiert ist.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie wissen:</p></div><div class=ulist><ul><li><p>Wie Sie <a href=./#ports>Software von Drittanbietern installieren</a>.</p></li></ul></div></div><div class=sect2><h3 id=linuxemu-lbc-install>16.2. Konfiguration der Linux®-Binärkompatibilität<a class=anchor href=#linuxemu-lbc-install></a></h3><div class=paragraph><p>Die Linux®-Binärkompatibilität ist per Voreinstellung nicht aktiviert und auch Linux®-Bibliotheken werden nicht installiert. Linux®-Bibliotheken können entweder manuell, oder aus der FreeBSD Ports-Sammlung installiert werden.</p></div><div class=paragraph><p>Bevor Sie versuchen den Port zu bauen, laden Sie das Linux®-Kernelmodul, da ansonsten der Bau fehlschlägt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload linux</span></code></pre></div></div><div class=paragraph><p>Für 64-Bit Kompatibilität:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload linux64</span></code></pre></div></div><div class=paragraph><p>Prüfen Sie, ob das Modul geladen wurde:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kldstat
Id Refs Address    Size     Name
 1    2 0xc0100000 16bdb8   kernel
 7    1 0xc24db000 d000     linux.ko</code></pre></div></div><div class=paragraph><p>Der einfachste Weg um einen Basissatz von Linux®-Bibliotheken und Binärdateien auf einem FreeBSD-System zu installieren, ist über den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base-c7/>emulators/linux_base-c7</a>. So installieren Sie das Paket:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install emulators/linux_base-c7</span></code></pre></div></div><div class=paragraph><p>Wollen Sie die Linux®-Binärkompatibilität beim Systemstart aktivieren, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>linux_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Auf 64-Bit Maschinen wird das Modul für die 64-Bit Emulation automatisch von <span class=filename>/etc/rc.d/abi</span> geladen.</p></div><div class=paragraph><p>Seitdem die Linux®-Binärkompatibilität Unterstützung für die Ausführung von 32- und 64-Bit-Linux®-Binärdateien erhalten hat, ist es nicht mehr möglich, die Emulationsfähigkeit in einen angepassten Kernel zu integrieren.</p></div><div class=sect3><h4 id=linuxemu-libs-manually>16.2.1. Manuelle Installation zusätzlicher Bibliotheken<a class=anchor href=#linuxemu-libs-manually></a></h4><div class=paragraph><p>Wenn sich eine Linux®-Anwendung über fehlende Bibliotheken beschwert nachdem die Linux®-Binärkompatibilität installiert wurde, finden Sie heraus welche Bibliothken die Anwendung benötigt und installieren Sie diese manuell.</p></div><div class=paragraph><p>Mit <code>ldd</code> können Sie unter Linux® bestimmen, welche gemeinsam benutzten Bibliotheken eine Anwendung benötigt. Wenn Sie herausfinden wollen, welche Bibliotheken <code>linuxdoom</code> benötigt, können Sie folgenden Befehl auf einem Linux®-System ausführen, welches Doom installiert hat:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ldd linuxdoom
libXt.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libX11.so.3.1.0
libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> <span class=o>=&gt;</span> /lib/libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Kopieren Sie alle Dateien aus der letzten Spalte der Ausgabe von einem Linux®-System auf das FreeBSD-System in das Verzeichnis <span class=filename>/compat/linux</span>. Nach dem Kopieren erstellen Sie symbolische Links auf die Namen in der ersten Spalte. In diesem Beispiel werden folgende Dateien auf dem FreeBSD-System installiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Wenn Sie bereits eine Linux®-Bibliothek einer zur ersten Spalte passenden Hauptversionsnummer besitzen, muss sie nicht mehr kopiert werden, da die bereits vorhandene Version funktionieren sollte. Hat die Bibliothek jedoch eine neuere Versionsnummer, sollten Sie sie dennoch kopieren. Sie können die alte Version löschen, solange Sie einen symbolischen Link auf die neue Version anlegen.</p></div><div class=paragraph><p>Folgende Bibliotheken existieren bereits auf dem FreeBSD-System:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.27<span class=err>$</span>
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</code></pre></div></div><div class=paragraph><p><code>ldd</code> zeigt an, dass eine Anwendung eine neuere Version benötigt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Wenn diese Bibliotheken sich nur um ein oder zwei Stellen in der Unterversionsnummer unterscheiden, sollte das Programm dennoch mit der älteren Version funktionieren. Wenn Sie wollen, können Sie die bestehende <span class=filename>libc.so</span> durch die neuere Version ersetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Der Mechanismus der symbolischen Links wird nur für Linux®-Binärdateien benötigt. Nach einer Weile wird es eine ausreichende Menge an Linux®-Bibliotheken auf dem System geben, sodass Sie neu installierte Linux®-Anwendungen ohne zusätzlichen Aufwand auf dem System laufen lassen können.</p></div></div><div class=sect3><h4 id=_linux_elf_binärdateien_installieren>16.2.2. Linux® ELF-Binärdateien installieren<a class=anchor href=#_linux_elf_binärdateien_installieren></a></h4><div class=paragraph><p>ELF-Binärdateien benötigen manchmal eine zusätzliche "Kennzeichnung". Wenn Sie versuchen, eine nicht gekennzeichnete ELF-Binärdatei auszuführen, werden Sie eine Fehlermeldung ähnlich der folgenden erhalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./my-linux-elf-binary
ELF binary <span class=nb>type </span>not known
Abort</code></pre></div></div><div class=paragraph><p>Damit der FreeBSD-Kernel eine Linux®-ELF-Datei von einer FreeBSD-ELF-Datei unterscheiden kann, gibt es das Werkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% brandelf <span class=nt>-t</span> Linux my-linux-elf-binary</code></pre></div></div><div class=paragraph><p>Die GNU Werkzeuge schreiben nun automatisch die passende Kennzeichnungsinformation in die ELF-Binärdateien, so dass Sie diesen Schritt in Zukunft nur noch selten benötigen.</p></div></div><div class=sect3><h4 id=_installieren_einer_rpm_basierten_linux_anwendung>16.2.3. Installieren einer RPM-basierten Linux®-Anwendung<a class=anchor href=#_installieren_einer_rpm_basierten_linux_anwendung></a></h4><div class=paragraph><p>Wenn Sie eine Linux® RPM-basierte Anwendung installieren möchten, installieren Sie zunächst den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/archivers/rpm4/>archivers/rpm4</a>. Anschließend kann der Superuser das folgende Kommando benutzen, um ein <span class=filename>.rpm</span> zu installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /compat/linux</span>
<span class=c># rpm2cpio &lt; /pfad/zum/linux.archiv.rpm | cpio -id</span></code></pre></div></div><div class=paragraph><p>Fall notwendig, benutzen Sie <code>brandelf</code> auf den installierten ELF-Binärdateien. Beachten Sie, dass dies eine saubere Deinstallation verhindert.</p></div></div><div class=sect3><h4 id=_namensauflösung_konfigurieren>16.2.4. Namensauflösung konfigurieren<a class=anchor href=#_namensauflösung_konfigurieren></a></h4><div class=paragraph><p>Wenn DNS nicht funktioniert, oder die folgende Fehlermeldung erscheint:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>resolv+: <span class=s2>&#34;bind&#34;</span> is an invalid keyword resolv+:
<span class=s2>&#34;hosts&#34;</span> is an invalid keyword</code></pre></div></div><div class=paragraph><p>müssen Sie <span class=filename>/compat/linux/etc/host.conf</span> wie folgt bearbeiten:</p></div><div class="literalblock programlisting"><div class=content><pre>order hosts, bind
multi on</pre></div></div><div class=paragraph><p>Diese Reihenfolge legt fest, dass zuerst <span class=filename>/etc/hosts</span> und anschließend DNS durchsucht werden. Wenn <span class=filename>/compat/linux/etc/host.conf</span> nicht vorhanden ist, nutzen Linux®-Anwendungen <span class=filename>/etc/host.conf</span> und beschweren sich über die inkompatible FreeBSD-Syntax. Wenn Sie in <span class=filename>/etc/resolv.conf</span> keinen Nameserver konfiguriert haben, sollten Sie den Eintrag <code>bind</code> entfernen.</p></div></div></div><div class=sect2><h3 id=linuxemu-advanced>16.3. Weiterführende Themen<a class=anchor href=#linuxemu-advanced></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt wie die Linux®-Binärkompatibilität funktioniert. Die folgenden Informationen stammen aus einer E-Mail, die von Terry Lambert (<a href=mailto:tlambert@primenet.com>tlambert@primenet.com</a>) an <a href=https://lists.FreeBSD.org/subscription/freebsd-chat>FreeBSD chat</a> geschrieben wurde (Message ID: <code>&lt;<a href=mailto:199906020108.SAA07001@usr09.primenet.com>199906020108.SAA07001@usr09.primenet.com</a>></code>).</p></div><div class=paragraph><p>FreeBSD verfügt über eine "execution class loader" genannte Abstraktion. Dabei handelt es sich um einen Eingriff in den <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> Systemaufruf.</p></div><div class=paragraph><p>Historisch gesehen untersuchte der einzige, auf UNIX®-Plattformen vorhandene Lader die "magische Zahl" (in der Regel die ersten 4 oder 8 Bytes der Datei), um festzustellen, ob der Binärtyp dem System bekannt war. War dies der Fall, wurde der Binärlader aufgerufen.</p></div><div class=paragraph><p>Wenn es sich nicht um den zum System gehörigen Binärtyp handelte, gab <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> einen Fehler zurück, und die Shell versuchte stattdessen, die Datei als Shell-Befehl auszuführen. Dabei wurde als Standardeinstellung "was auch immer die aktuelle Shell ist" festgelegt.</p></div><div class=paragraph><p>Später wurde ein Hack in <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> eingefügt, der die zwei ersten Zeichen untersuchte. Wenn diese <code>:\n</code> entsprachen, wurde stattdessen die <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>-Shell aufgerufen.</p></div><div class=paragraph><p>FreeBSD verfügt über eine Liste von Ladern, anstelle eines einzigen, auf <code>#!</code> zurückgreifenden Laders, um Shell-Interpreter oder Shell-Skripte auszuführen.</p></div><div class=paragraph><p>Für die Linux® ABI-Unterstützung erkennt FreeBSD die magische Zahl als ELF-Binärdatei. Der ELF-Lader sucht nach einer speziellen <em>Kennzeichnung</em>, die aus einem Kommentarabschnitt in der ELF-Datei besteht, und die in SVR4/Solaris™ ELF Binärdateien nicht vorhanden ist.</p></div><div class=paragraph><p>Damit Linux®-Binärdateien unter FreeBSD funktionieren, müssen sie mit <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a> als <code>Linux</code> <em>gekennzeichnet</em> werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># brandelf -t Linux file</span></code></pre></div></div><div class=paragraph><p>Wenn der ELF-Lader die <code>Linux</code>-Kennzeichnung sieht, wird ein Zeiger in der <code>proc</code>-Struktur ersetzt. Alle Systemaufrufe werden durch diesen Zeiger indiziert. Der Prozess wird weiterhin speziell gekennzeichnet, so dass der Trap-vector im Signal-trampoline-code eine spezielle Behandlung erfährt und das Linux®-Kernelmodul verschiedene kleinere Korrekturen vornehmen kann.</p></div><div class=paragraph><p>Der Linux®-Systemaufrufvektor enthält neben anderen Dingen eine Liste der <code>sysent[]</code>-Einträge, deren Adressen sich im Kernelmodul befinden.</p></div><div class=paragraph><p>Wenn ein Linux®-Programm einen Systemaufruf ausführt, dereferenziert die Trap-Behandlungsroutine den Zeiger für den Systemaufruf aus der <code>proc</code>-Struktur und erhält damit die Linux®-Eintrittspunkte für den Systemaufruf.</p></div><div class=paragraph><p>Zusätzlich <em>verändert</em> der Linux®-Modus die Systempfade dynamisch; genauso, wie dies die Option <code>union</code> beim Einbinden von Dateisystemen macht. Zuerst wird die Datei im Verzeichnis <span class=filename>/compat/linux/Originalpfad</span> gesucht, wenn sie dort nicht gefunden wurde, wird sie im Verzeichnis <span class=filename>/Originalpfad</span> gesucht. Dadurch wird sichergestellt, dass Binärdateien, die zur Ausführung andere Binärdateien benötigen, ausgeführt werden können (so dass alle Linux®-Werkzeuge unter der ABI laufen). Dies bedeutet auch, dass Linux®-Binärdateien FreeBSD-Binärdateien laden und ausführen können, wenn keine passenden Linux®-Binärdateien vorhanden sind. Ein in <span class=filename>/compat/linux</span> plaziertes <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> kann damit Linux®-Programmen vorgaukeln, dass sie auf einem Linux®-System laufen.</p></div><div class=paragraph><p>Im Endeffekt gibt es einen Linux®-Kernel innerhalb des FreeBSD-Kernels. Die Sprungtabellen für Linux®- beziehungsweise FreeBSD-Systemaufrufe verweisen allerdings auf dieselben Funktionen, die Kerneldienste wie Dateisystemoperationen, Operationen für den virtuellen Speicher, Signalübermittlung und System V IPC bereitstellen. Der einzige Unterschied ist, dass Binärdateien unter FreeBSD FreeBSD-<em>glue</em>-Funktionen verwendet werden. Linux®-Binärdateien hingegen verwenden die Linux®-<em>glue</em>-Funktionen. FreeBSD-<em>glue</em>-Funktionen sind statisch in den Kernel gelinkt, Linux®-<em>glue</em>-Funktionen sind statisch gelinkt oder können über ein ladbares Kernelmodul eingebunden werden.</p></div><div class=paragraph><p>Technisch gesehen ist dies nicht wirklich eine Emulation, sondern eine ABI-Implementation. Es wird manchmal "Linux® Emulation" genannt, da es zu einer Zeit implementiert wurde, in der es kein anderes Wort gab, das beschrieb, was vor sich ging. Es war falsch zu behaupten, FreeBSD würde Linux®-Binärprogramme ausführen, da der Code nicht unter FreeBSD übersetzt wurde.</p></div><div class=paragraph><p>path: "/books/handbook/partiii/"
---
:leveloffset: +1</p></div></div></div></div><h1 id=config-tuning class=sect0>Teil III: Konfiguration und Tuning<a class=anchor href=#config-tuning></a></h1><div class=sect1><h2 id=config-synopsis>Kapitel 17. Übersicht<a class=anchor href=#config-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Die richtige Systemkonfiguration ist einer der wichtigsten Aspekte unter FreeBSD. Dieses Kapitel beschreibt die Konfiguration von FreeBSD sowie Maßnahmen zur Leistungssteigerung von FreeBSD-Systemen.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel durchgearbeitet haben, werden Sie Folgendes wissen:</p></div><div class=ulist><ul><li><p>Die Grundlagen der Konfiguration von <span class=filename>rc.conf</span> und die Skripte zum Starten von Anwendungen in <span class=filename>/usr/local/etc/rc.d</span>.</p></li><li><p>Wie Sie Netzwerkkarten konfigurieren und testen.</p></li><li><p>Wie Sie virtuelle Hosts und Netzwerkgeräte konfigurieren.</p></li><li><p>Wie Sie die verschiedenen Konfigurationsdateien in <span class=filename>/etc</span> benutzen.</p></li><li><p>Wie Sie mit FreeBSD mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variablen einstellen können.</p></li><li><p>Wie Sie die Platten-Performance einstellen und Kernel-Parameter modifizieren können.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie</p></div><div class=ulist><ul><li><p>die Grundlagen von UNIX® und FreeBSD (<a href=./#basics>Grundlagen des FreeBSD Betriebssystems</a>) verstehen.</p></li><li><p>Damit vertraut sein, wie Sie einen Kernel konfigurieren und kompilieren (<a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=configtuning-starting-services>Kapitel 18. Start von Diensten<a class=anchor href=#configtuning-starting-services></a></h2><div class=sectionbody><div class=paragraph><p>Viele Benutzer installieren Software Dritter auf FreeBSD mithilfe der Ports-Sammlung. Häufig soll die Software bei einem Systemstart mitgestartet werden. Beispielsweise sollen die Dienste <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> nach einem Systemstart laufen. Dieser Abschnitt stellt die Startprozeduren für Software Dritter vor.</p></div><div class=paragraph><p>Unter FreeBSD werden die meisten der im System enthaltenen Dienste wie <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> mithilfe von Systemskripten gestartet.</p></div><div class=sect2><h3 id=_dienste_über_das_rc_d_system_starten>18.1. Dienste über das <span class=filename>rc.d</span>-System starten<a class=anchor href=#_dienste_über_das_rc_d_system_starten></a></h3><div class=paragraph><p>Mit <span class=filename>rc.d</span> lässt sich der Start von Anwendungen besser steuern und es sind mehr Funktionen verfügbar. Mit den in <a href=#configtuning-rcd>Dienste unter FreeBSD verwalten</a> besprochenen Schlüsselwörtern können Anwendungen in einer bestimmten Reihenfolge gestartet werden und Optionen können in <span class=filename>rc.conf</span> statt fest im Startskript der Anwendung festgelegt werden. Ein einfaches Startskript sieht wie folgt aus:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Dieses Skript stellt sicher, dass <code>utility</code> nach den <code>DAEMON</code>-Pseudodiensten gestartet wird. Es stellt auch eine Methode bereit, die Prozess-ID (PID) der Anwendung in einer Datei zu speichern.</p></div><div class=paragraph><p>In <span class=filename>/etc/rc.conf</span> könnte für diese Anwendung die folgende Zeile stehen:</p></div><div class="literalblock programlisting"><div class=content><pre>utility_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Die Methode erleichtert den Umgang mit Kommandozeilenargumenten, bindet Funktionen aus <span class=filename>/etc/rc.subr</span> ein, ist kompatibel zu <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> und lässt sich über <span class=filename>rc.conf</span> leichter konfigurieren.</p></div></div><div class=sect2><h3 id=_andere_arten_um_dienste_zu_starten>18.2. Andere Arten, um Dienste zu starten<a class=anchor href=#_andere_arten_um_dienste_zu_starten></a></h3><div class=paragraph><p>Andere Dienste können über <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> gestartet werden. Die Konfiguration von <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> wird in <a href=./#network-inetd>“Der inetd Super-Server”</a> ausführlich beschrieben.</p></div><div class=paragraph><p>Systemdienste können auch mit <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> gestartet werden. Dieser Ansatz hat einige Vorteile; nicht zuletzt, weil <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> die Prozesse unter dem Eigentümer der <span class=filename>crontab</span> startet, ist es möglich, dass Dienste von normalen Benutzern gestartet und gepflegt werden können.</p></div><div class=paragraph><p>Für die Zeitangabe in <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> kann <code>@reboot</code> eingesetzt werden. Damit wird das Kommando gestartet, wenn <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> kurz nach dem Systemboot gestartet wird.</p></div></div></div></div><div class=sect1><h2 id=configtuning-cron>Kapitel 19. <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> konfigurieren<a class=anchor href=#configtuning-cron></a></h2><div class=sectionbody><div class=paragraph><p>Ein sehr nützliches Werkzeug von FreeBSD ist cron. Dieses Programm läuft im Hintergrund und überprüft fortlaufend <span class=filename>/etc/crontab</span> und <span class=filename>/var/cron/tabs</span>. In diesen Dateien wird festgelegt, welche Programme zu welchem Zeitpunkt von cron ausgeführt werden sollen. Jede Zeile in diesen Dateien definiert eine auszuführende Aufgabe, die auch als <em>Cronjob</em> bezeichnet wird.</p></div><div class=paragraph><p>Das Werkzeug verwendet zwei verschiedene Konfigurationsdateien: die System-crontab, welche nicht verändert werden sollte und die Benutzer-crontabs, die nach Bedarf erstellt und geändert werden können. Das Format, dass von diesen beiden Dateien verwendet wird, ist in <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> dokumentiert. Das Format der System-crontab in <span class=filename>/etc/crontab</span> enthält das Feld <code>who</code>, das in der Benutzer-crontab nicht existiert. Dieses Feld gibt den Benutzer an, mit dem die Aufgabe ausgeführt wird. Die Aufgaben in den Benutzer-crontabs laufen unter dem Benutzer, der die crontab erstellt hat.</p></div><div class=paragraph><p>Benutzer-crontabs erlauben es den Benutzern, ihre eigenen Aufgaben zu planen. Der Benutzer <code>root</code> kann auch seine eigene Benutzer-crontab haben, um Aufgaben zu planen, die nicht in der System-crontab existieren.</p></div><div class=paragraph><p>Hier ist ein Beispieleintrag aus der System-crontab, <span class=filename>/etc/crontab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/crontab - root&#39;s crontab for FreeBSD
#
# $FreeBSD$
<i class=conum data-value=1></i><b>(1)</b>
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <i class=conum data-value=2></i><b>(2)</b>
#
#minute	hour	mday	month	wday	who	command <i class=conum data-value=3></i><b>(3)</b>
#
*/5	*	*	*	*	root	/usr/libexec/atrun <i class=conum data-value=4></i><b>(4)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Das Zeichen <code>#</code> am Zeilenanfang leitet einen Kommentar ein. Benutzen Sie Kommentare, um die Funktion eines Eintrags zu erläutern. Kommentare müssen in einer extra Zeile stehen. Sie können nicht in derselben Zeile wie ein Kommando stehen, da sie sonst Teil des Kommandos wären. Leerzeilen in dieser Datei werden ignoriert.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Umgebungsvariablen werden mit dem Gleichheits-Zeichen (<code>=</code>) festgelegt. Im Beispiel werden die Variablen <code>SHELL</code>, <code>PATH</code> und <code>HOME</code> definiert. Wenn die Variable <code>SHELL</code> nicht definiert wird, benutzt cron die Bourne Shell. Wird die Variable <code>PATH</code> nicht gesetzt, müssen alle Pfadangaben absolut sein, da es keinen Vorgabewert für <code>PATH</code> gibt.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>In dieser Zeile werden sieben Felder der System-crontab beschrieben: <code>minute</code>, <code>hour</code>, <code>mday</code>, <code>month</code>, <code>wday</code>, <code>who</code> und <code>command</code>. Das Feld <code>minute</code> legt die Minute fest in der die Aufgabe ausgeführt wird, das Feld <code>hour</code> die Stunde, das Feld <code>mday</code> den Tag des Monats. Im Feld <code>month</code> wird der Monat und im Feld <code>wday</code> der Wochentag festgelegt. Alle Felder müssen numerische Werte enthalten und die Zeitangaben sind im 24-Stunden-Format. Das Zeichen <code>*</code> repräsentiert dabei alle möglichen Werte für dieses Feld. Das Feld <code>who</code> gibt es nur in der System-crontab und gibt den Account an, unter dem das Kommando laufen soll. Im letzten Feld wird schließlich das auszuführende Kommando angegeben.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Diese Zeile definiert die Werte für den Cronjob. Die Zeichenfolge <code>*/5</code> gefolgt von mehreren <code>*</code>-Zeichen bedeutet, dass <code>/usr/libexec/atrun</code> von <code>root</code> alle fünf Minuten aufgerufen wird.Bei den Kommandos können beliebig viele Optionen angegeben werden. Wenn das Kommando zu lang ist und auf der nächsten Zeile fortgesetzt werden soll, muss am Ende der Zeile das Fortsetzungszeichen (<code>\</code>) angegeben werden.</td></tr></tbody></table></div><div class=sect2><h3 id=configtuning-installcrontab>19.1. Eine Benutzer-crontab erstellen<a class=anchor href=#configtuning-installcrontab></a></h3><div class=paragraph><p>Rufen Sie <code>crontab</code> im Editor-Modus auf, um eine Benutzer-crontab zu erstellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-e</span></code></pre></div></div><div class=paragraph><p>Dies wird die crontab des Benutzers mit dem voreingestellten Editor öffnen. Wenn der Benutzer diesen Befehl zum ersten Mal ausführt, wird eine leere Datei geöffnet. Nachdem der Benutzer eine crontab erstellt hat, wird die Datei mit diesem Kommando zur Bearbeitung geöffnet.</p></div><div class=paragraph><p>Es empfiehlt sich, die folgenden Zeilen an den Anfang der crontab-Datei hinzuzufügen, um die Umgebungsvariablen zu setzen und die einzelnen Felder zu beschreiben:</p></div><div class="literalblock programlisting"><div class=content><pre>SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin
# Order of crontab fields
# minute	hour	mday	month	wday	command</pre></div></div><div class=paragraph><p>Fügen Sie dann für jedes Kommando oder Skript eine Zeile hinzu, mit der Angabe wann das Kommando ausgeführt werden soll. In diesem Beispiel wird ein Bourne Shell Skript täglich um 14:00 Uhr ausgeführt. Da der Pfad zum Skript nicht in <code>PATH</code> enthalten ist, wird der vollständige Pfad zum Skript angegeben:</p></div><div class="literalblock programlisting"><div class=content><pre>0	14	*	*	*	/usr/home/dru/bin/mycustomscript.sh</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Bevor Sie ein eigenes Skript verwenden, stellen Sie sicher, dass es ausführbar ist und dass es mit den wenigen Umgebungsvariablen von cron funktioniert. Um die Umgebung nachzubilden, die der obige cron-Eintrag bei der Ausführung verwenden würde, benutzen Sie dieses Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>env</span> <span class=nt>-i</span> <span class=nv>SHELL</span><span class=o>=</span>/bin/sh <span class=nv>PATH</span><span class=o>=</span>/etc:/bin:/sbin:/usr/bin:/usr/sbin <span class=nv>HOME</span><span class=o>=</span>/home/dru <span class=nv>LOGNAME</span><span class=o>=</span>dru /usr/home/dru/bin/mycustomscript.sh</code></pre></div></div><div class=paragraph><p>Die Umgebung von cron wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> beschrieben. Es ist wichtig, dass sichergestellt wird, dass die Skripte in der Umgebung von cron korrekt arbeiten, besonders wenn Befehle enthalten sind, welche Dateien mit Wildcards löschen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn Sie mit der Bearbeitung der crontab fertig sind, speichern Sie die Datei. Sie wird automatisch installiert und cron wird die darin enthalten Cronjobs zu den angegebenen Zeiten ausführen. Um die Cronjobs in einer crontab aufzulisten, verwenden Sie diesen Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-l</span>
0	14	<span class=k>*</span>	<span class=k>*</span>	<span class=k>*</span>	/usr/home/dru/bin/mycustomscript.sh</code></pre></div></div><div class=paragraph><p>Um alle Cronjobs einer Benutzer-crontab zu löschen, verwenden Sie diesen Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-r</span>
remove crontab <span class=k>for </span>dru? y</code></pre></div></div></div></div></div><div class=sect1><h2 id=configtuning-rcd>Kapitel 20. Dienste unter FreeBSD verwalten<a class=anchor href=#configtuning-rcd></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD verwendet die vom <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-System bereit gestellten Startskripten beim Systemstart und für die Verwaltung von Diensten. Die Skripte sind in <span class=filename>/etc/rc.d</span> abgelegt und bieten grundlegende Dienste an, die über die Optionen <code>start</code>, <code>stop</code> und <code>restart</code> des <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> Kommandos kontrolliert werden können. Beispielsweise kann <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> mit dem nachstehenden Kommando neu gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd restart</span></code></pre></div></div><div class=paragraph><p>Analog können Sie andere Dienste starten und stoppen. Normalerweise werden die Dienste beim Systemstart über Einträge in der Datei <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> automatisch gestartet. <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> wird zum Beispiel mit dem folgenden Eintrag in <span class=filename>/etc/rc.conf</span> aktiviert:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Wenn dort bereits die Zeile <code>natd_enable="NO"</code> existiert, ändern Sie <code>NO</code> in <code>YES</code>. Die <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-Skripten starten, wie unten beschrieben, auch abhängige Dienste.</p></div><div class=paragraph><p>Da das <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-System primär zum automatischen Starten und Stoppen von Systemdiensten dient, funktionieren die Optionen <code>start</code>, <code>stop</code> und <code>restart</code> nur, wenn die entsprechenden Variablen in <span class=filename>/etc/rc.conf</span> gesetzt sind. Beispielsweise funktioniert <code>sshd restart</code> nur dann, wenn in <span class=filename>/etc/rc.conf</span> die Variable <code>sshd_enable</code> auf <code>YES</code> gesetzt wurde. Wenn Sie die Optionen <code>start</code>, <code>stop</code> oder <code>restart</code> unabhängig von den Einstellungen in <span class=filename>/etc/rc.conf</span> benutzen wollen, müssen Sie den Optionen mit dem Präfix "one" verwenden. Um beispielsweise <code>sshd</code> unabhängig von den Einstellungen in <span class=filename>/etc/rc.conf</span> neu zu starten, benutzen Sie das nachstehende Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd onerestart</span></code></pre></div></div><div class=paragraph><p>Ob ein Dienst in <span class=filename>/etc/rc.conf</span> aktiviert ist, können Sie herausfinden, indem Sie das entsprechende <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-Skript mit der Option <code>rcvar</code> aufrufen. Dieses Beispiel prüft, ob der <code>sshd</code>-Dienst in <span class=filename>/etc/rc.conf</span> aktiviert ist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd rcvar</span>
<span class=c># sshd</span>
<span class=c>#</span>
<span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=c>#   (default: &#34;&#34;)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Zeile <code># sshd</code> wird von dem Kommando ausgegeben; sie kennzeichnet nicht die Eingabeaufforderung von <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ob ein Dienst läuft, kann mit <code>status</code> abgefragt werden. Das folgende Kommando überprüft, ob <code>sshd</code> auch wirklich gestartet wurde:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd status</span>
sshd is running as pid 433.</code></pre></div></div><div class=paragraph><p>Einige Dienste können über die Option <code>reload</code> neu initialisiert werden. Dazu wird dem Dienst über ein Signal mitgeteilt, dass er seine Konfigurationsdateien neu einlesen soll. Oft wird dazu das Signal <code>SIGHUP</code> verwendet. Beachten Sie aber, dass nicht alle Dienste diese Option unterstützen.</p></div><div class=paragraph><p>Die meisten Systemdienste werden beim Systemstart vom <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-System gestartet. Zum Beispiel aktiviert das Skript <span class=filename>/etc/rc.d/bgfsck</span> die Prüfung von Dateisystemen im Hintergrund. Das Skript gibt die folgende Meldung aus, wenn es gestartet wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Starting background file system checks <span class=k>in </span>60 seconds.</code></pre></div></div><div class=paragraph><p>Dieses Skript wird während des Systemstarts ausgeführt und führt eine Überprüfung der Dateisysteme im Hintergrund durch.</p></div><div class=paragraph><p>Viele Systemdienste hängen von anderen Diensten ab. <a href="https://man.freebsd.org/cgi/man.cgi?query=yp&amp;sektion=8&amp;format=html">yp(8)</a> und andere RPC-basierende Systeme hängen beispielsweise von dem <code>rpcbind</code>-Dienst ab. Im Kopf der Startskripten befinden sich die Informationen über Abhängigkeiten von anderen Diensten und weitere Metadaten. Mithilfe dieser Daten bestimmt das Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> beim Systemstart die Startreihenfolge der Dienste.</p></div><div class=paragraph><p>Folgende Schlüsselwörter müssen im Kopf aller Startskripten verwendet werden, da sie von <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> zum "Aktivieren" des Startskripts benötigt werden:</p></div><div class=ulist><ul><li><p><code>PROVIDE</code>: Gibt die Namen der Dienste an, die mit dieser Datei zur Verfügung gestellt werden.</p></li></ul></div><div class=paragraph><p>Die folgenden Schlüsselwörter können im Kopf des Startskripts angegeben werden. Sie sind zwar nicht unbedingt notwendig, sind aber hilfreich beim Umgang mit <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>:</p></div><div class=ulist><ul><li><p><code>REQUIRE</code>: Gibt die Namen der Dienste an, von denen dieser Dienst abhängt. Ein Skript, das dieses Schlüsselwort enthält wird <em>nach</em> den angegebenen Diensten ausgeführt.</p></li><li><p><code>BEFORE</code>: Zählt Dienste auf, die auf diesen Dienst angewiesen sind. Ein Skript, dass dieses Schlüsselwort enthält wird <em>vor</em> den angegebenen Diensten ausgeführt.</p></li></ul></div><div class=paragraph><p>Durch das Verwenden dieser Schlüsselwörter kann ein Administrator die Startreihenfolge von Systemdiensten feingranuliert steuern, ohne mit den Schwierigkeiten des "runlevel"-Systems anderer UNIX® Systeme kämpfen zu müssen.</p></div><div class=paragraph><p>Weitere Informationen über das <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-System finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Wenn Sie eigene <span class=filename>rc.d</span>-Skripte schreiben wollen, sollten Sie <a href=https://docs.freebsd.org/en/articles/rc-scripting/>diesen Artikel</a> lesen.</p></div><div class=sect2><h3 id=configtuning-core-configuration>20.1. Systemspezifische Konfiguration<a class=anchor href=#configtuning-core-configuration></a></h3><div class=paragraph><p>Informationen zur Systemkonfiguration sind hauptsächlich in <span class=filename>/etc/rc.conf</span>, die meist beim Start des Systems verwendet wird, abgelegt. Sie enthält die Konfigurationen für die <span class=filename>rc*</span> Dateien.</p></div><div class=paragraph><p>In <span class=filename>rc.conf</span> werden die Vorgabewerte aus <span class=filename>/etc/defaults/rc.conf</span> überschrieben. Die Vorgabedatei sollte nicht editiert werden. Stattdessen sollten alle systemspezifischen Änderungen in <span class=filename>rc.conf</span> vorgenommen werden.</p></div><div class=paragraph><p>Um den administrativen Aufwand gering zu halten, existieren in geclusterten Anwendungen mehrere Strategien, globale Konfigurationen von systemspezifischen Konfigurationen zu trennen. Der empfohlene Weg hält die globale Konfiguration in einer separaten Datei z.B. <span class=filename>/etc/rc.conf.local</span>. Zum Beispiel so:</p></div><div class=ulist><ul><li><p><span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;
keyrate=&#34;fast&#34;
defaultrouter=&#34;10.1.1.254&#34;</pre></div></div></li><li><p><span class=filename>/etc/rc.conf.local</span>:</p><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;node1.example.org&#34;
ifconfig_fxp0=&#34;inet 10.1.1.1/8&#34;</pre></div></div></li></ul></div><div class=paragraph><p><span class=filename>/etc/rc.conf</span> kann dann auf jedes System mit rsync oder puppet verteilt werden, während <span class=filename>/etc/rc.conf.local</span> dabei systemspezifisch bleibt.</p></div><div class=paragraph><p>Bei einem Upgrade des Systems wird <span class=filename>/etc/rc.conf</span> nicht überschrieben, so dass die Systemkonfiguration erhalten bleibt.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/rc.conf</span> und <span class=filename>/etc/rc.conf.local</span> werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> gelesen. Dies erlaubt es dem Systemadministrator, komplexe Konfigurationsszenarien zu erstellen. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, um weitere Informationen zu diesem Thema zu erhalten.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=config-network-setup>Kapitel 21. Einrichten von Netzwerkkarten<a class=anchor href=#config-network-setup></a></h2><div class=sectionbody><div class=paragraph><p>Die Konfiguration einer Netzwerkkarte gehört zu den alltäglichen Aufgaben eines FreeBSD Administrators.</p></div><div class=sect2><h3 id=_bestimmen_des_richtigen_treibers>21.1. Bestimmen des richtigen Treibers<a class=anchor href=#_bestimmen_des_richtigen_treibers></a></h3><div class=paragraph><p>Ermitteln Sie zunächst das Modell der Netzwerkkarte und den darin verwendeten Chip. FreeBSD unterstützt eine Vielzahl von Netzwerkkarten. Prüfen Sie die Hardware-Kompatibilitätsliste für das FreeBSD Release, um zu sehen ob die Karte unterstützt wird.</p></div><div class=paragraph><p>Wenn die Karte unterstützt wird, müssen Sie den Treiber für die Karte bestimmen. <span class=filename>/usr/src/sys/conf/NOTES</span> und <span class=filename>/usr/src/sys/arch/conf/NOTES</span> enthalten eine Liste der verfügbaren Treiber mit Informationen zu den unterstützten Chipsätzen. Wenn Sie sich nicht sicher sind, ob Sie den richtigen Treiber ausgewählt haben, lesen Sie die Hilfeseite des Treibers. Sie enthält weitere Informationen über die unterstützten Geräte und bekannte Einschränkungen des Treibers.</p></div><div class=paragraph><p>Die Treiber für gebräuchliche Netzwerkkarten sind schon im <span class=filename>GENERIC</span>-Kernel enthalten, so dass die Karte während des Systemstarts erkannt werden sollte. Die Systemmeldungen können Sie sich mit <code>more /var/run/dmesg.boot</code> ansehen. Mit der Leertaste können Sie durch den Text blättern. In diesem Beispiel findet das System zwei Karten, die den <a href="https://man.freebsd.org/cgi/man.cgi?query=dc&amp;sektion=4&amp;format=html">dc(4)</a>-Treiber benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: <span class=o>[</span>ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: <span class=o>[</span>ITHREAD]</code></pre></div></div><div class=paragraph><p>Ist der Treiber für die Netzwerkkarte nicht in <span class=filename>GENERIC</span> enthalten, muss zunächst ein Treiber geladen werden, um die Karte konfigurieren und benutzen zu können. Dafür gibt es zwei Methoden:</p></div><div class=ulist><ul><li><p>Am einfachsten ist es, das Kernelmodul für die Karte mit <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> zu laden. Um den Treiber automatisch beim Systemstart zu laden, fügen Sie die entsprechende Zeile in <span class=filename>/boot/loader.conf</span> ein. Es gibt nicht für alle Karten Kernelmodule.</p></li><li><p>Alternativ kann der Treiber für die Karte fest in den Kernel eingebunden werden. Lesen Sie dazu <span class=filename>/usr/src/sys/conf/NOTES</span>, <span class=filename>/usr/src/sys/arch/conf/NOTES</span> und die Hilfeseite des Treibers, den Sie in den Kernel einbinden möchten, an. Die Übersetzung des Kernels wird in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> beschrieben. Wenn die Karte während des Systemstarts vom Kernel erkannt wurde, muss der Kernel nicht neu übersetzt werden.</p></li></ul></div><div class=sect3><h4 id=config-network-ndis>21.1.1. Windows®-NDIS-Treiber einsetzen<a class=anchor href=#config-network-ndis></a></h4><div class=paragraph><p>Leider stellen nach wie vor viele Unternehmen die Spezifikationen ihrer Treiber der Open Source Gemeinde nicht zur Verfügung, weil sie diese Informationen als Geschäftsgeheimnisse betrachten. Daher haben die Entwickler von FreeBSD und anderen Betriebssystemen nur zwei Möglichkeiten. Entweder versuchen sie in einem aufwändigen Prozess den Treiber durch Reverse Engineering nachzubauen, oder sie versuchen, die vorhandenen Binärtreiber der Microsoft® Windows®-Plattform zu verwenden.</p></div><div class=paragraph><p>FreeBSD bietet "native" Unterstützung für die Network Driver Interface Specification (NDIS). <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> wird benutzt, um einen Windows® XP-Treiber in ein Format zu konvertieren, das von FreeBSD verwendet werden kann. Da der <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>-Treiber einen Windows® XP-Binärtreiber nutzt, kann er nur auf i386™- und amd64-Systemen verwendet werden. Unterstützt werden PCI, CardBus, PCMCIA und USB-Geräte.</p></div><div class=paragraph><p>Um den NDISulator zu verwenden, benötigen Sie drei Dinge:</p></div><div class="olist arabic"><ol class=arabic><li><p>Die FreeBSD Kernelquellen</p></li><li><p>Den Windows® XP-Binärtreiber mit der Erweiterung <span class=filename>.SYS</span></p></li><li><p>Die Konfigurationsdatei des Windows® XP-Treibers mit der Erweiterung <span class=filename>.INF</span></p></li></ol></div><div class=paragraph><p>Laden Sie die <span class=filename>.SYS</span>- und <span class=filename>.INF</span>-Dateien für die Karte. Diese befinden sich meistens auf einer beigelegten CD-ROM, oder können von der Internetseite des Herstellers heruntergeladen werden. In den folgenden Beispielen werden die Dateien <span class=filename>W32DRIVER.SYS</span> und <span class=filename>W32DRIVER.INF</span> verwendet.</p></div><div class=paragraph><p>Die Architektur des Treibers muss zur jeweiligen Version von FreeBSD passen. Benutzen Sie einen Windows® 32-bit Treiber für FreeBSD/i386. Für FreeBSD/amd64 wird ein Windows® 64-bit Treiber benötigt.</p></div><div class=paragraph><p>Als Nächstes kompilieren Sie den binären Treiber, um ein Kernelmodul zu erzeugen. Dazu rufen Sie als <code>root</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> auf:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</span></code></pre></div></div><div class=paragraph><p>Dieses Kommando arbeitet interaktiv, benötigt es weitere Informationen, so fragt es Sie danach. Das Ergebnis ist ein neu erzeugtes Kernelmodul im aktuellen Verzeichnis. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> um das neue Modul zu laden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ./W32DRIVER.ko</span></code></pre></div></div><div class=paragraph><p>Neben dem erzeugten Kernelmodul müssen auch die Kernelmodule <span class=filename>ndis.ko</span> und <span class=filename>if_ndis.ko</span> geladen werden. Dies passiert automatisch, wenn Sie ein von <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> abhängiges Modul laden. Andernfalls können die Module mit den folgenden Kommandos manuell geladen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>Der erste Befehl lädt den <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>-Miniport-Treiber, der zweite das tatsächliche Netzwerkgerät.</p></div><div class=paragraph><p>Überprüfen Sie die Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> auf eventuelle Fehler während des Ladevorgangs. Gab es dabei keine Probleme, sollte die Ausgabe wie folgt aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>Ab jetzt kann das Gerät <span class=filename>ndis0</span> wie jede andere Netzwerkkarte konfiguriert werden.</p></div><div class=paragraph><p>Um die <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>-Module automatisch beim Systemstart zu laden, kopieren Sie das erzeugte Modul <span class=filename>W32DRIVER_SYS.ko</span> nach <span class=filename>/boot/modules</span>. Danach fügen Sie die folgende Zeile in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>W32DRIVER_SYS_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect2><h3 id=_konfiguration_von_netzwerkkarten>21.2. Konfiguration von Netzwerkkarten<a class=anchor href=#_konfiguration_von_netzwerkkarten></a></h3><div class=paragraph><p>Nachdem der richtige Treiber für die Karte geladen ist, muss die Karte konfiguriert werden. Unter Umständen ist die Karte schon während der Installation mit <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a> konfiguriert worden.</p></div><div class=paragraph><p>Das nachstehende Kommando zeigt die Konfiguration der Netzwerkkarten an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig
dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active
dc1: <span class=nv>flags</span><span class=o>=</span>8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        <span class=nv>options</span><span class=o>=</span>3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 <span class=nv>options</span><span class=o>=</span>3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</code></pre></div></div><div class=paragraph><p>Im Beispiel werden Informationen zu den folgenden Geräten angezeigt:</p></div><div class=ulist><ul><li><p><span class=filename>dc0</span>: Der erste Ethernet-Adapter.</p></li><li><p><span class=filename>dc1</span>: Der zweite Ethernet-Adapter.</p></li><li><p><span class=filename>lo0</span>: Das Loopback-Gerät.</p></li></ul></div><div class=paragraph><p>Der Name der Netzwerkkarte wird aus dem Namen des Treibers und einer Zahl zusammengesetzt. Die Zahl gibt die Reihenfolge an, in der die Geräte beim Systemstart erkannt wurden. Die dritte Karte, die den <a href="https://man.freebsd.org/cgi/man.cgi?query=sis&amp;sektion=4&amp;format=html">sis(4)</a> Treiber benutzt, würde beispielsweise <span class=filename>sis2</span> heißen.</p></div><div class=paragraph><p>Der Adapter <span class=filename>dc0</span> aus dem Beispiel ist aktiv. Sie erkennen das an den folgenden Hinweisen:</p></div><div class="olist arabic"><ol class=arabic><li><p><code>UP</code> bedeutet, dass die Karte konfiguriert und aktiv ist.</p></li><li><p>Der Karte wurde die Internet-Adresse (<code>inet</code>) <code>192.168.1.3</code> zugewiesen.</p></li><li><p>Die Subnetzmaske ist richtig (<code>0xffffff00</code> entspricht <code>255.255.255.0</code>).</p></li><li><p>Die Broadcast-Adresse <code>192.168.1.255</code> ist richtig.</p></li><li><p>Die MAC-Adresse der Karte (<code>ether</code>) lautet <code>00:a0:cc:da:da:da</code>.</p></li><li><p>Die automatische Medienerkennung ist aktiviert (<code>media: Ethernet autoselect (100baseTX &lt;full-duplex>)</code>). Der Adapter <span class=filename>dc1</span> benutzt das Medium <code>10baseT/UTP</code>. Weitere Informationen über die einstellbaren Medien entnehmen Sie der Hilfeseite des Treibers.</p></li><li><p>Der Verbindungsstatus (<code>status</code>) ist <code>active</code>, das heißt es wurde ein Trägersignal entdeckt. Für <span class=filename>dc1</span> wird <code>status: no carrier</code> angezeigt. Das ist normal, wenn kein Kabel an der Karte angeschlossen ist.</p></li></ol></div><div class=paragraph><p>Wäre die Karte nicht konfiguriert, würde die Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> so aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active</code></pre></div></div><div class=paragraph><p>Die Karte muss als Benutzer <code>root</code> konfiguriert werden. Die Konfiguration kann auf der Kommandozeile mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> erfolgen. Allerdings gehen diese Informationen bei einem Neustart verloren. Tragen Sie stattdessen die Konfiguration in <span class=filename>/etc/rc.conf</span> ein. Wenn es im LAN einen DHCP-Server gibt, fügen Sie einfach folgende Zeile hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Ersetzen Sie <em>>dc0</em> durch die richtigen Werte für das System.</p></div><div class=paragraph><p>Nachdem Sie die Zeile hinzugefügt haben, folgen Sie den Anweisungen in <a href=#config-network-testing>Test und Fehlersuche</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn das Netzwerk während der Installation konfiguriert wurde, existieren vielleicht schon Einträge für die Netzwerkkarte(n). Überprüfen Sie <span class=filename>/etc/rc.conf</span> bevor Sie weitere Zeilen hinzufügen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Falls kein DHCP-Server zur Verfügung steht, müssen die Netzwerkkarten manuell konfiguriert werden. Fügen Sie für jede Karte im System eine Zeile hinzu, wie in diesem Beispiel zu sehen:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_dc1=&#34;inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP&#34;</pre></div></div><div class=paragraph><p>Ersetzen Sie <span class=filename>dc0</span> und <span class=filename>dc1</span> und die IP-Adressen durch die richtigen Werte für das System. Die Manualpages des Treibers, <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> enthalten weitere Einzelheiten über verfügbare Optionen und die Syntax von <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Wenn das Netzwerk kein DNS benutzt, können Sie in <span class=filename>/etc/hosts</span> die Namen und IP-Adressen der Rechner des LANs eintragen. Weitere Informationen entnehmen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> und <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls kein DHCP-Server zur Verfügung steht, Sie aber Zugang zum Internet benötigen, müssen Sie das Standard-Gateway und die Nameserver manuell konfigurieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;defaultrouter=&#34;Ihr_Default_Gateway&#34;&#39; &gt;&gt; /etc/rc.conf</span>
<span class=c># echo &#39;nameserver Ihr_DNS_Server&#39; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=config-network-testing>21.3. Test und Fehlersuche<a class=anchor href=#config-network-testing></a></h3><div class=paragraph><p>Nachdem die notwendigen Änderungen in <span class=filename>/etc/rc.conf</span> gespeichert wurden, kann das System neu gestartet werden, um die Konfiguration zu testen und zu überprüfen, ob das System ohne Fehler neu gestartet wurde. Alternativ können Sie mit folgenden Befehl die Netzwerkeinstellungen neu initialisieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls in <span class=filename>/etc/rc.conf</span> ein Default-Gateway definiert wurde, müssen Sie auch den folgenden Befehl ausführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service routing restart</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn das System gestartet ist, sollten Sie die Netzwerkkarten testen.</p></div><div class=sect3><h4 id=_test_der_ethernet_karte>21.3.1. Test der Ethernet-Karte<a class=anchor href=#_test_der_ethernet_karte></a></h4><div class=paragraph><p>Um zu prüfen, ob die Ethernet-Karte richtig konfiguriert ist, testen Sie zunächst mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> den Adapter selbst und sprechen Sie dann eine andere Maschine im LAN an.</p></div><div class=paragraph><p>Zuerst, der Test des Adapters:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.3
PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.082 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.074 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.108 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms

<span class=nt>---</span> 192.168.1.3 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.074/0.083/0.108/0.013 ms</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.2
PING 192.168.1.2 <span class=o>(</span>192.168.1.2<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.726 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.766 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.700 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.747 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.704 ms

<span class=nt>---</span> 192.168.1.2 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.700/0.729/0.766/0.025 ms</code></pre></div></div><div class=paragraph><p>Um die Namensauflösung zu testen, verwenden Sie den Namen der Maschine anstelle der IP-Adresse. Wenn kein DNS-Server im Netzwerk vorhanden ist, muss <span class=filename>/etc/hosts</span> entsprechend eingerichtet sein. Fügen Sie dazu die Namen und IP-Adressen der Rechner im LAN in <span class=filename>/etc/hosts</span> hinzu, falls sie nicht bereits vorhanden sind. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> und <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div></div><div class=sect3><h4 id=_fehlersuche_2>21.3.2. Fehlersuche<a class=anchor href=#_fehlersuche_2></a></h4><div class=paragraph><p>Fehler zu beheben, ist immer sehr mühsam. Indem Sie die einfachen Sachen zuerst prüfen, erleichtern Sie sich die Aufgabe. Steckt das Netzwerkkabel? Sind die Netzwerkdienste richtig konfiguriert? Funktioniert die Firewall? Wird die Netzwerkkarte von FreeBSD unterstützt? Lesen Sie immer die Hardware-Informationen des Releases, bevor Sie einen Fehlerbericht einsenden. Aktualisieren Sie die FreeBSD-Version auf die neueste -STABLE Version. Suchen Sie in den Archiven der Mailinglisten und im Internet nach bekannten Lösungen.</p></div><div class=paragraph><p>Wenn die Karte funktioniert, die Verbindungen aber zu langsam sind, sollten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a> lesen. Prüfen Sie auch die Netzwerkkonfiguration, da falsche Einstellungen die Ursache für langsame Verbindungen sein können.</p></div><div class=paragraph><p>Wenn Sie viele <code>device timeout</code> Meldungen in den Systemprotokollen finden, prüfen Sie, dass es keinen Konflikt zwischen der Netzwerkkarte und anderen Geräten des Systems gibt. Überprüfen Sie nochmals die Verkabelung. Unter Umständen benötigen Sie eine andere Netzwerkkarte.</p></div><div class=paragraph><p>Bei <code>watchdog timeout</code> Fehlermeldungen, kontrollieren Sie zuerst die Verkabelung. Überprüfen Sie dann, ob der PCI-Steckplatz der Karte Bus Mastering unterstützt. Auf einigen älteren Motherboards ist das nur für einen Steckplatz (meistens Steckplatz 0) der Fall. Lesen Sie in der Dokumentation der Karte und des Motherboards nach, ob das vielleicht die Ursache des Problems sein könnte.</p></div><div class=paragraph><p>Die Meldung <code>No route to host</code> erscheint, wenn das System ein Paket nicht zustellen kann. Das kann vorkommen weil beispielsweise keine Default-Route gesetzt wurde oder das Netzwerkkabel nicht richtig steckt. Schauen Sie in der Ausgabe von <code>netstat -rn</code> nach, ob eine gültige Route zu dem Zielsystem existiert. Wenn nicht, lesen Sie <a href=./#network-routing>“Gateways und Routen”</a>.</p></div><div class=paragraph><p>Die Meldung <code>ping: sendto: Permission denied</code> wird oft von einer falsch konfigurierten Firewall verursacht. Wenn keine Regeln definiert wurden, blockiert eine aktivierte Firewall alle Pakete, selbst einfache <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>-Pakete. Weitere Informationen erhalten Sie in <a href=./#firewalls>Firewalls</a>.</p></div><div class=paragraph><p>Falls die Leistung der Karte schlecht ist, setzen Sie die Medienerkennung von <code>autoselect</code> (automatisch) auf das richtige Medium. In vielen Fällen löst diese Maßnahme Leistungsprobleme. Wenn nicht, prüfen Sie nochmal die Netzwerkeinstellungen und lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-virtual-hosts>Kapitel 22. Virtual Hosts<a class=anchor href=#configtuning-virtual-hosts></a></h2><div class=sectionbody><div class=paragraph><p>Ein gebräuchlicher Zweck von FreeBSD ist das virtuelle Hosting, bei dem ein Server im Netzwerk wie mehrere Server aussieht. Dies wird dadurch erreicht, dass einem Netzwerkinterface mehrere Netzwerk-Adressen zugewiesen werden.</p></div><div class=paragraph><p>Ein Netzwerkinterface hat eine "echte" Adresse und kann beliebig viele "alias" Adressen haben. Die Aliase werden durch entsprechende alias Einträge in <span class=filename>/etc/rc.conf</span> festgelegt, wie in diesem Beispiel zu sehen ist:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>Beachten Sie, dass die Alias-Einträge mit <code>alias_0_</code> anfangen müssen und weiter hochgezählt werden, das heißt <code>alias1</code>, <code>alias2</code>, und so weiter. Die Konfiguration der Aliase hört bei der ersten fehlenden Zahl auf.</p></div><div class=paragraph><p>Die Berechnung der Alias-Netzwerkmasken ist wichtig. Für jedes Interface muss es eine Adresse geben, die die Netzwerkmaske des Netzwerkes richtig beschreibt. Alle anderen Adressen in diesem Netzwerk haben dann eine Netzwerkmaske, die mit <code>1</code> gefüllt ist, also <code>255.255.255.255</code> oder hexadezimal <code>0xffffffff</code>.</p></div><div class=paragraph><p>Als Beispiel betrachten wir den Fall, in dem <span class=filename>fxp0</span> mit zwei Netzwerken verbunden ist: dem Netzwerk <code>10.1.1.0</code> mit der Netzwerkmaske <code>255.255.255.0</code> und dem Netzwerk <code>202.0.75.16</code> mit der Netzwerkmaske <code>255.255.255.240</code>. Das System soll die Adressen <code>10.1.1.1</code> bis <code>10.1.1.5</code> und <code>202.0.75.17</code> bis <code>202.0.75.20</code> belegen. Nur die erste Adresse in einem Netzwerk sollte die richtige Netzwerkmaske haben. Alle anderen Adressen (<code>10.1.1.2</code> bis <code>10.1.1.5</code> und <code>202.0.75.18</code> bis <code>202.0.75.20</code>) müssen die Maske <code>255.255.255.255</code> erhalten.</p></div><div class=paragraph><p>Die folgenden Einträge in <span class=filename>/etc/rc.conf</span> konfigurieren den Adapter entsprechend dem Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div><div class=paragraph><p>Dies kann mit einer durch Leerzeichen getrennten Liste von IP-Adressbereichen auch einfacher ausgedrückt werden. Die erste Adresse hat wieder die angegebene Netzwerkmaske und die zusätzlichen Adressen haben die Netzwerkmaske <code>255.255.255.255</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_aliases=&#34;inet 10.1.1.1-5/24 inet 202.0.75.17-20/28&#34;</pre></div></div></div></div><div class=sect1><h2 id=configtuning-syslog>Kapitel 23. Konfiguration der Systemprotokollierung<a class=anchor href=#configtuning-syslog></a></h2><div class=sectionbody><div class=paragraph><p>Die Aufzeichnung und Kontrolle von Log-Meldungen ist ein wichtiger Aspekt der Systemadministration. Die Informationen werden nicht nur verwendet um Hard- und Softwarefehler ausfindig zu machen, auch zur Überwachung der Sicherheit und der Reaktion bei einem Zwischenfall spielen diese Aufzeichnungen eine wichtige Rolle. Die meisten Systemdienste und Anwendungen erzeugen Log-Meldungen.</p></div><div class=paragraph><p>FreeBSD stellt mit syslogd ein Werkzeug zur Verwaltung von Protokollen bereit. In der Voreinstellung wird syslogd beim Booten automatisch gestartet. Dieses Verhalten wird über die Variable <code>syslogd_enable</code> in <span class=filename>/etc/rc.conf</span> gesteuert. Dazu gibt es noch zahlreiche Argumente, die in der Variable <code>syslogd_flags</code> in <span class=filename>/etc/rc.conf</span> gesetzt werden können. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> für weitere Informationen über die verfügbaren Argumente.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt die Konfiguration und Verwendung des FreeBSD Protokollservers, und diskutiert auch die Log-Rotation und das Management von Logdateien.</p></div><div class=sect2><h3 id=_konfiguration_der_lokalen_protokollierung>23.1. Konfiguration der lokalen Protokollierung<a class=anchor href=#_konfiguration_der_lokalen_protokollierung></a></h3><div class=paragraph><p>Die Konfigurationsdatei <span class=filename>/etc/syslog.conf</span> steuert, was syslogd mit Log-Meldungen macht, sobald sie empfangen werden. Es gibt verschiedene Parameter, die das Verhalten bei eingehenden Ereignissen kontrollieren. facility beschreibt das Subsystem, welches das Ereignis generiert hat. Beispielsweise der Kernel, oder ein Daemon. level hingegen beschreibt den Schweregrad des aufgetretenen Ereignisses. Dies macht es möglich, Meldungen in verschiedenen Logdateien zu protokollieren, oder Meldungen zu verwerfen, je nach Konfiguration von facility und level. Ebenfalls besteht die Möglichkeit auf Meldungen zu reagieren, die von einer bestimmten Anwendung stammen, oder von einem spezifischen Host erzeugt wurden.</p></div><div class=paragraph><p>Die Konfigurationsdatei von <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> enthält für jede Aktion eine Zeile. Die Syntax besteht aus einem Auswahlfeld, gefolgt von einem Aktionsfeld. Die Syntax für das Auswahlfeld ist <em>facility.level</em>. Dies entspricht Log-Meldungen von <em>facility</em> mit einem Level von <em>level</em> oder höher. Um noch präziser festzulegen was protokolliert wird, kann dem Level optional ein Vergleichsflag vorangestellt werden. Mehrere Auswahlen können, durch Semikolon (<code>;</code>) getrennt, für die gleiche Aktion verwendet werden. <code>*</code> wählt dabei alles aus. Das Aktionsfeld definiert, wohin die Log-Meldungen gesendet werden, beispielsweise in eine Datei oder zu einem entfernten Log-Server. Als Beispiel dient hier <span class=filename>/etc/syslog.conf</span> aus FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you$
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit                /dev/console
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
security.*                                      /var/log/security
auth.info;authpriv.info                         /var/log/auth.log
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
ftp.info                                        /var/log/xferlog
cron.*                                          /var/log/cron
!-devd
*.=debug                                        /var/log/debug.log
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
# Uncomment this if you wish to see messages produced by devd
# !devd
# *.&gt;=info
!ppp
*.*                                             /var/log/ppp.log
!*</pre></div></div><div class=paragraph><p>In diesem Beispiel:</p></div><div class=ulist><ul><li><p>Zeile 8 selektiert alle Meldungen vom Level <code>err</code>, sowie <code>kern.warning</code>, <code>auth.notice</code> und <code>mail.crit</code> und schickt diese zur Konsole (<span class=filename>/dev/console</span>).</p></li><li><p>Zeile 12 selektiert alle Meldungen von <code>mail</code> ab dem Level <code>info</code> oder höher und schreibt diese in <span class=filename>/var/log/maillog</span>.</p></li><li><p>Zeile 17 benutzt ein Vergleichsflag (<code>=</code>), um nur Meldungen vom Level <code>debug</code> zu selektieren und schreibt diese in <span class=filename>/var/log/debug.log</span>.</p></li><li><p>Zeile 33 zeigt ein Beispiel für die Nutzung einer Programmspezifikation. Die nachfolgenden Regeln sind dann nur für Programme gültig, welche der Programmspezifikation stehen. In diesem Fall werden alle Meldungen von ppp (und keinem anderen Programm) in <span class=filename>/var/log/ppp.log</span> geschrieben.</p></li></ul></div><div class=paragraph><p>Die verfügbaren level, beginnend mit den höchst kritischen, hin zu den weniger kritischen, sind: <code>emerg</code>, <code>alert</code>, <code>crit</code>, <code>err</code>, <code>warning</code>, <code>notice</code>, <code>info</code> und <code>debug</code>.</p></div><div class=paragraph><p>Die facilities, in beliebiger Reihenfolge, sind: <code>auth</code>, <code>authpriv</code>, <code>console</code>, <code>cron</code>, <code>daemon</code>, <code>ftp</code>, <code>kern</code>, <code>lpr</code>, <code>mail</code>, <code>mark</code>, <code>news</code>, <code>security</code>, <code>syslog</code>, <code>user</code>, <code>uucp</code>, sowie <code>local0</code> bis <code>local7</code>. Beachten Sie, dass andere Betriebssysteme hiervon abweichende facilities haben können.</p></div><div class=paragraph><p>Um alle Meldungen vom Level <code>notice</code> und höher in <span class=filename>/var/log/daemon.log</span> zu protokollieren, fügen Sie folgenden Eintrag hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>daemon.notice                                        /var/log/daemon.log</pre></div></div><div class=paragraph><p>Für weitere Informationen zu verschiedenen Level und faclilities, lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>. Weitere Informationen zu <span class=filename>/etc/syslog.conf</span>, dessen Syntax und erweiterten Anwendungsbeispielen, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>.</p></div></div><div class=sect2><h3 id=_management_und_rotation_von_logdateien>23.2. Management und Rotation von Logdateien<a class=anchor href=#_management_und_rotation_von_logdateien></a></h3><div class=paragraph><p>Logdateien können schnell wachsen und viel Speicherplatz belegen, was es schwieriger macht, nützliche Informationen zu finden. Log-Management versucht, diesen Effekt zu mildern. FreeBSD verwendet newsyslog für die Verwaltung von Logdateien. Dieses in FreeBSD integrierte Programm rotiert und komprimiert in regelmäßigen Abständen Logdateien. Optional kann es auch fehlende Logdateien erstellen und Programme benachrichtigen, wenn Logdateien verschoben wurden. Die Logdateien können von syslogd oder einem anderen Programm generiert werden. Obwohl newsyslog normalerweise von <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> aufgerufen wird, ist es kein Systemdämon. In der Standardkonfiguration wird dieser Job jede Stunde ausgeführt.</p></div><div class=paragraph><p>Um zu wissen, welche Maßnahmen zu ergreifen sind, liest newsyslog seine Konfigurationsdatei <span class=filename>/etc/newsyslog.conf</span>. Diese Konfigurationsdatei enthält eine Zeile für jede Datei, die von newsyslog verwaltet wird. Jede Zeile enthält Informationen über den Besitzer der Datei, die Dateiberechtigungen, wann die Datei rotiert wird, optionale Flags, welche die Log-Rotation beeinflussen (bspw. Komprimierung) und Programme, denen ein Signal geschickt wird, wenn Logdateien rotiert werden. Hier folgt die Standardkonfiguration in FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre># configuration file for newsyslog
# $FreeBSD$
#
# Entries which do not specify the &#39;/pid_file&#39; field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the &#39;N&#39; flag.
#
# The &#39;flags&#39; field is one or more of the letters: BCDGJNUXZ or a &#39;-&#39;.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/amd.log                        644  7     100  *     J
/var/log/auth.log                       600  7     100  @0101T JC
/var/log/console.log                    600  5     100  *     J
/var/log/cron                           600  3     100  *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     100  *     JC
/var/log/kerberos.log                   600  7     100  *     J
/var/log/lpd-errs                       644  7     100  *     JC
/var/log/maillog                        640  7     *    @T00  JC
/var/log/messages                       644  5     100  @0101T JC
/var/log/monthly.log                    640  12    *    $M1D0 JN
/var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log        root:network    640  3     100  *     JC
/var/log/devd.log                       644  3     100  *     JC
/var/log/security                       600  10    100  *     JC
/var/log/sendmail.st                    640  10    *    168   B
/var/log/utx.log                        644  3     *    @01T05 B
/var/log/weekly.log                     640  5     1    $W6D0 JN
/var/log/xferlog                        600  7     100  *     JC</pre></div></div><div class=paragraph><p>Jede Zeile beginnt mit dem Namen der Protokolldatei, die rotiert werden soll, optional gefolgt von Besitzer und Gruppe für rotierende, als auch für neu erstellte Dateien. Das Feld <code>mode</code> definiert die Zugriffsrechte der Datei. <code>count</code> gibt an, wie viele rotierte Dateien aufbewahrt werden sollen. Anhand der <code>size</code>- und <code>when</code>-Flags erkennt newsyslog, wann die Datei rotiert werden muss. Eine Logdatei wird rotiert, wenn ihre Größe den Wert von <code>size</code> überschreitet, oder wenn die Zeit im <code>when</code>-Feld abgelaufen ist. Ein <code>*</code> bedeutet, dass dieses Feld ignoriert wird. Das <em>flags</em>-Feld gibt newsyslog weitere Instruktionen, zum Beispiel wie eine Datei zu rotieren ist, oder eine Datei zu erstellen falls diese nicht existiert. Die letzten beiden Felder sind optional und bestimmen die PID-Datei und wann die Datei rotiert wird.</p></div><div class=paragraph><p>Weitere Informationen zu allen Feldern, gültigen Flags und wie Sie die Rotationszeit angeben können, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a>. Denken Sie daran, dass newsyslog von <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> aufgerufen wird und somit Dateien auch nur dann rotiert, wenn es von <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> aufgerufen wird, und nicht häufiger.</p></div></div><div class=sect2><h3 id=network-syslogd>23.3. Protokollierung von anderen Hosts<a class=anchor href=#network-syslogd></a></h3><div class=paragraph><p>Die Überwachung der Protokolldateien kann bei steigender Anzahl von Rechnern sehr unhandlich werden. Eine zentrale Protokollierung kann manche administrativen Belastungen bei der Verwaltung von Protokolldateien reduzieren.</p></div><div class=paragraph><p>Die Aggregation, Zusammenführung und Rotation von Protokolldateien kann in FreeBSD mit syslogd und newsyslog konfiguriert werden. In der folgenden Beispielkonfiguration sammelt Host <code>A</code>, genannt <code>logserv.example.com</code>, Protokollinformationen für das lokale Netzwerk. Host <code>B</code>, genannt <code>logclient.example.com</code> wird seine Protokollinformationen an den Server weiterleiten.</p></div><div class=sect3><h4 id=_konfiguration_des_protokollservers>23.3.1. Konfiguration des Protokollservers<a class=anchor href=#_konfiguration_des_protokollservers></a></h4><div class=paragraph><p>Ein Protokollserver ist ein System, welches Protokollinformationen von anderen Hosts akzeptiert. Bevor Sie diesen Server konfigurieren, prüfen Sie folgendes:</p></div><div class=ulist><ul><li><p>Falls eine Firewall zwischen dem Protokollserver und den -Clients steht, muss das Regelwerk der Firewall UDP auf Port 514 sowohl auf Client- als auch auf Serverseite freigegeben werden.</p></li><li><p>Der <code>syslogd</code>-Server und alle Clientrechner müssen gültige Einträge für sowohl Vorwärts- als auch Umkehr-DNS besitzen. Falls im Netzwerk kein DNS-Server vorhanden ist, muss auf jedem System die Datei <span class=filename>/etc/hosts</span> mit den richtigen Einträgen gepflegt werden. Eine funktionierende Namensauflösung ist zwingend erforderlich, ansonsten würde der Server die Protokollnachrichten ablehnen.</p></li></ul></div><div class=paragraph><p>Bearbeiten Sie <span class=filename>/etc/syslog.conf</span> auf dem Server. Tragen Sie den Namen des Clients ein, den Verbindungsweg und den Namen der Protokolldatei. Dieses Beispiel verwendet den Rechnernamen <code>B</code>, alle Verbindungswege, und die Protokolle werden in <span class=filename>/var/log/logclient.log</span> gespeichert.</p></div><div class=exampleblock><div class=title>Beispiel 25. Einfache Server Konfiguration</div><div class=content><div class="literalblock programlisting"><div class=content><pre>+logclient.example.com
*.*     /var/log/logclient.log</pre></div></div></div></div><div class=paragraph><p>Fügen Sie für jeden Client zwei Zeilen hinzu, falls Sie mehrere Clients in diese Datei aufnehmen. Weitere Informationen über die verfügbaren Verbindungswege finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>.</p></div><div class=paragraph><p>Konfigurieren Sie als nächstes <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-a logclient.example.com -v -v&#34;</pre></div></div><div class=paragraph><p>Der erste Eintrag startet <code>syslogd</code> während des Bootens. Der zweite Eintrag erlaubt es, Daten von dem spezifizierten Client auf diesem Server zu akzeptieren. Die Verwendung von <code>-v -v</code> erhöht die Anzahl von Protokollnachrichten. Dies ist hilfreich für die Feineinstellung der Verbindungswege, da Administratoren auf diese Weise erkennen, welche Arten von Nachrichten von welchen Verbindungswegen protokolliert werden.</p></div><div class=paragraph><p>Mehrere <code>-a</code>-Optionen können angegeben werden, um die Protokollierung von mehreren Clients zu erlauben. IP-Adressen und ganze Netzblöcke können ebenfalls spezifiziert werden. Eine vollständige Liste der Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>.</p></div><div class=paragraph><p>Zum Schluss muss die Protokolldatei erstellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/logclient.log</span></code></pre></div></div><div class=paragraph><p>Zu diesem Zeitpunkt sollte <code>syslogd</code> neu gestartet und überprüft werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
<span class=c># pgrep syslog</span></code></pre></div></div><div class=paragraph><p>Wenn eine PID zurückgegeben wird, wurde der Server erfolgreich neu gestartet und die Clientkonfiguration kann beginnen. Wenn der Server nicht neu gestartet wurde, suchen Sie in <span class=filename>/var/log/messages</span> nach dem Fehler.</p></div></div><div class=sect3><h4 id=_konfiguration_des_protokollclients>23.3.2. Konfiguration des Protokollclients<a class=anchor href=#_konfiguration_des_protokollclients></a></h4><div class=paragraph><p>Ein Protokollclient sendet Protokollinformationen an einen Protokollserver. Zusätzlich behält er eine lokale Kopie seiner eigenen Protokolle.</p></div><div class=paragraph><p>Sobald der Server konfiguriert ist, bearbeiten Sie <span class=filename>/etc/rc.conf</span> auf dem Client:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-s -v -v&#34;</pre></div></div><div class=paragraph><p>Der erste Eintrag aktiviert den <code>syslogd</code>-Dienst während des Systemstarts. Der zweite Eintrag erhöht die Anzahl der Protokollnachrichten. Die Option <code>-s</code> verhindert, dass dieser Client Protokolle von anderen Hosts akzeptiert.</p></div><div class=paragraph><p>Als nächstes muss der Protokollserver in der <span class=filename>/etc/syslog.conf</span> des Clients eingetragen werden. In diesem Beispiel wird das <code>@</code>-Symbol benutzt, um sämtliche Protokolldaten an einen bestimmten Server zu senden:</p></div><div class="literalblock programlisting"><div class=content><pre>*.*               @logserv.example.com</pre></div></div><div class=paragraph><p>Nachdem die Änderungs gespeichert wurden, muss <code>syslogd</code> neu gestartet werden, damit die Änderungen wirksam werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>Um zu testen, ob Protokollnachrichten über das Netzwerk gesendet werden, kann <a href="https://man.freebsd.org/cgi/man.cgi?query=logger&amp;sektion=1&amp;format=html">logger(1)</a> auf dem Client benutzt werden, um eine Nachricht an syslogd zu schicken:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># logger &#34;Test message from logclient&#34;</span></code></pre></div></div><div class=paragraph><p>Diese Nachricht sollte jetzt sowohl in <span class=filename>/var/log/messages</span> auf dem Client, als auch in <span class=filename>/var/log/logclient.log</span> auf dem Server vorhanden sein.</p></div></div><div class=sect3><h4 id=_fehlerbehebung_beim_protokollserver>23.3.3. Fehlerbehebung beim Protokollserver<a class=anchor href=#_fehlerbehebung_beim_protokollserver></a></h4><div class=paragraph><p>Wenn der Server keine Nachrichten empfängt, ist die Ursache wahrscheinlich ein Netzwerkproblem, ein Problem bei der Namensauflösung oder ein Tippfehler in einer Konfigurationsdatei. Um die Ursache zu isolieren, müssen Sie sicherstellen, dass sich Server und Client über den in <span class=filename>/etc/rc.conf</span> konfigurierten Hostnamen mit <code>ping</code> erreichen lässt. Falls dies nicht gelingt sollten Sie die Netzwerkverkabelung überprüfen, außerdem Firewallregeln sowie die Einträge für Hosts im DNS und <span class=filename>/etc/hosts</span>. Überprüfen Sie diese Dinge auf dem Server und dem Client, bis der <code>ping</code> von beiden Hosts erfolgreich ist.</p></div><div class=paragraph><p>Wenn sich die Hosts gegenseitig mit <code>ping</code> erreichen können, der Server aber immer noch keine Nachrichten empfängt, können Sie vorübergehend die Ausführlichkeit der Protokollierung erhöhen, um die Ursache für das Problem weiter einzugrenzen. In dem folgenden Beispiel ist auf dem Server die Datei <span class=filename>/var/log/logclient.log</span> leer und in der Datei <span class=filename>/var/log/messages</span> auf dem Client ist keine Ursache für das Problem erkennbar. Um nun die Ausführlichkeit der Protokollierung zu erhöhen, passen Sie auf dem Server den Eintrag <code>syslogd_flags</code> an. Anschließend starten Sie den Dienst neu:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_flags=&#34;-d -a logclient.example.com -v -v&#34;</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>Informationen wie diese werden sofort nach dem Neustart auf der Konsole erscheinen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
Logging to FILE /var/log/messages
syslogd: kernel boot file is /boot/kernel/kernel
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
rejected <span class=k>in </span>rule 0 due to name mismatch.</code></pre></div></div><div class=paragraph><p>In diesem Beispiel werden die Nachrichten aufgrund eines fehlerhaften Namens abgewiesen. Der Hostname sollte <code>logclient</code> und nicht <code>logclien</code> sein. Beheben Sie den Tippfehler, starten Sie den Dienst neu und überprüfen Sie das Ergebnis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel
logmsg: pri 166, flags 17, from logserv.example.com,
msg Dec 10 20:55:02 &lt;syslog.err&gt; logserv.example.com syslogd: exiting on signal 2
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
accepted <span class=k>in </span>rule 0.
logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
Logging to FILE /var/log/logclient.log
Logging to FILE /var/log/messages</code></pre></div></div><div class=paragraph><p>Zu diesem Zeitpunkt werden die Nachrichten korrekt empfangen und in die richtige Datei geschrieben.</p></div></div><div class=sect3><h4 id=_sicherheitsbedenken>23.3.4. Sicherheitsbedenken<a class=anchor href=#_sicherheitsbedenken></a></h4><div class=paragraph><p>Wie mit jedem Netzwerkdienst, müssen Sicherheitsanforderungen in Betracht gezogen werden, bevor ein Protokollserver eingesetzt wird. Manchmal enthalten Protokolldateien sensitive Daten über aktivierte Dienste auf dem lokalen Rechner, Benutzerkonten und Konfigurationsdaten. Daten, die vom Client an den Server geschickt werden, sind weder verschlüsselt noch mit einem Passwort geschützt. Wenn ein Bedarf für Verschlüsselung besteht, ist es möglich <a class=package href=https://cgit.freebsd.org/ports/tree/security/stunnel/>security/stunnel</a> zu verwenden, welches die Protokolldateien über einen verschlüsselten Tunnel versendet.</p></div><div class=paragraph><p>Lokale Sicherheit ist ebenfalls ein Thema. Protokolldateien sind während der Verwendung oder nach ihrer Rotation nicht verschlüsselt. Lokale Benutzer versuchen vielleicht, auf diese Dateien zuzugreifen, um zusätzliche Einsichten in die Systemkonfiguration zu erlangen. Es ist absolut notwendig, die richtigen Berechtigungen auf diesen Dateien zu setzen. Das Werkzeug newsyslog unterstützt das Setzen von Berechtigungen auf gerade erstellte oder rotierte Protokolldateien. Protokolldateien mit Zugriffsmodus <code>600</code> sollten verhindern, dass lokale Benutzer darin herumschnüffeln. Zusätzliche Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-configfiles>Kapitel 24. Konfigurationsdateien<a class=anchor href=#configtuning-configfiles></a></h2><div class=sectionbody><div class=sect2><h3 id=_etc_layout>24.1. <span class=filename>/etc</span> Layout<a class=anchor href=#_etc_layout></a></h3><div class=paragraph><p>Konfigurationsdateien finden sich in einigen Verzeichnissen unter anderem in:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enthält generelle systemspezifische Konfigurationsinformationen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Default Versionen der Konfigurationsdateien.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enthält die <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> Konfiguration und weitere MTA Konfigurationsdateien.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Hier findet sich die Konfiguration für die User- und Kernel-ppp Programme.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Installierte Anwendungen legen hier ihre Konfigurationsdateien ab. Dieses Verzeichnis kann Unterverzeichnisse für bestimmte Anwendungen enthalten.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-Skripten installierter Anwendungen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Automatisch generierte systemspezifische Datenbanken, wie die Paket-Datenbank oder die <a href="https://man.freebsd.org/cgi/man.cgi?query=locate&amp;sektion=1&amp;format=html">locate(1)</a>-Datenbank.</p></td></tr></tbody></table></div><div class=sect2><h3 id=_hostnamen>24.2. Hostnamen<a class=anchor href=#_hostnamen></a></h3><div class=sect3><h4 id=_etcresolv_conf>24.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h4><div class=paragraph><p>Wie ein FreeBSD-System auf das Internet Domain Name System (DNS) zugreift, wird in <span class=filename>/etc/resolv.conf</span> festgelegt.</p></div><div class=paragraph><p>Die gebräuchlichsten Einträge in <span class=filename>/etc/resolv.conf</span> sind:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die IP-Adresse eines Nameservers, den der Resolver abfragen soll. Bis zu drei Server werden in der Reihenfolge, in der sie aufgezählt sind, abgefragt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Suchliste mit Domain-Namen zum Auflösen von Hostnamen. Die Liste wird normalerweise durch den Domain-Teil des lokalen Hostnamens festgelegt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Der lokale Domain-Name.</p></td></tr></tbody></table><div class=paragraph><p>Beispiel für eine typische <span class=filename>/etc/resolv.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nur eine der Anweisungen <code>search</code> oder <code>domain</code> sollte benutzt werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn Sie DHCP benutzen, überschreibt <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> für gewöhnlich <span class=filename>/etc/resolv.conf</span> mit den Informationen vom DHCP-Server.</p></div></div><div class=sect3><h4 id=_etchosts>24.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h4><div class=paragraph><p><span class=filename>/etc/hosts</span> ist eine einfache textbasierte Datenbank. Zusammen mit DNS und NIS stellt sie eine Abbildung zwischen Namen und IP-Adressen zur Verfügung. Anstatt <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> zu konfigurieren, können hier lokale Rechner, die über ein LAN verbunden sind, eingetragen werden. Lokale Einträge für gebräuchliche Internet-Adressen in <span class=filename>/etc/hosts</span> verhindern die Abfrage eines externen Servers und beschleunigen die Namensauflösung.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace &#39;my.domain&#39; below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1         localhost localhost.my.domain
127.0.0.1       localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2       myname.my.domain myname
#10.0.0.3       myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#   10.0.0.0    -   10.255.255.255
#   172.16.0.0  -   172.31.255.255
#   192.168.0.0 -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</pre></div></div><div class=paragraph><p><span class=filename>/etc/hosts</span> hat das folgende Format:</p></div><div class="literalblock programlisting"><div class=content><pre>[Internet Adresse] [Offizieller Hostname] [Alias1] [Alias2] ...</pre></div></div><div class=paragraph><p>Zum Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>Weitere Informationen entnehmen Sie bitte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-sysctl>Kapitel 25. Einstellungen mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><a class=anchor href=#configtuning-sysctl></a></h2><div class=sectionbody><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> können Sie Änderungen an einem laufenden FreeBSD-System vornehmen. Unter anderem können Optionen des TCP/IP-Stacks oder des virtuellen Speichermanagements verändert werden. Unter der Hand eines erfahrenen Systemadministrators kann dies die Systemperformance erheblich verbessern. Über 500 Variablen können mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> gelesen und gesetzt werden.</p></div><div class=paragraph><p>Der Hauptzweck von <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> besteht darin, Systemeinstellungen zu lesen und zu verändern.</p></div><div class=paragraph><p>Alle auslesbaren Variablen werden wie folgt angezeigt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>Um eine spezielle Variable zu lesen, geben Sie den Namen an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>Um eine Variable zu setzen, benutzen Sie die Syntax <em>Variable</em>= <em>Wert</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>Mit sysctl können Strings, Zahlen oder Boolean-Werte gesetzt werden. Bei Boolean-Werten steht <code>1</code> für wahr und <code>0</code> für falsch.</p></div><div class=paragraph><p>Um die Variablen automatisch während des Systemstarts zu setzen, fügen Sie sie in <span class=filename>/etc/sysctl.conf</span> ein. Weitere Informationen finden Sie in der Hilfeseite <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> und in <a href=#configtuning-sysctlconf><span class=filename>sysctl.conf</span></a>.</p></div><div class=sect2><h3 id=configtuning-sysctlconf>25.1. <span class=filename>sysctl.conf</span><a class=anchor href=#configtuning-sysctlconf></a></h3><div class=paragraph><p><span class=filename>/etc/sysctl.conf</span> sieht ähnlich wie <span class=filename>/etc/rc.conf</span> aus. Werte werden in der Form <code>Variable=Wert</code> gesetzt. Die angegebenen Werte werden gesetzt, nachdem sich das System bereits im Mehrbenutzermodus befindet. Allerdings lassen sich im Mehrbenutzermodus nicht alle Werte setzen.</p></div><div class=paragraph><p>Um das Protokollieren von fatalen Signalen abzustellen und Benutzer daran zu hindern, von anderen Benutzern gestartete Prozesse zu sehen, können Sie in <span class=filename>/etc/sysctl.conf</span> die folgenden Variablen setzen:</p></div><div class="literalblock programlisting"><div class=content><pre># Do not log fatal signal exits (e.g. sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre></div></div></div><div class=sect2><h3 id=sysctl-readonly>25.2. Schreibgeschützte Variablen<a class=anchor href=#sysctl-readonly></a></h3><div class=paragraph><p>Wenn schreibgeschützte <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variablen verändert werden, ist ein Neustart des Systems erforderlich.</p></div><div class=paragraph><p>Beispielsweise hat <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> auf einigen Laptops Schwierigkeiten, Speicherbereiche zu erkennen. Es treten dann Fehlermeldungen wie die folgende auf:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</code></pre></div></div><div class=paragraph><p>Um dieses Problem zu lösen, muss eine schreibgeschützte <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable verändert werden. Fügen Sie <code>hw.pci.allow_unsupported_io_range=1</code> in <span class=filename>/boot/loader.conf</span> hinzu und starten Sie das System neu. Danach sollte <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> fehlerfrei funktionieren.</p></div></div></div></div><div class=sect1><h2 id=configtuning-disk>Kapitel 26. Tuning von Laufwerken<a class=anchor href=#configtuning-disk></a></h2><div class=sectionbody><div class=paragraph><p>Der folgende Abschnitt beschreibt die verschiedenen Methoden zur Feinabstimmung der Laufwerke. Oft sind mechanische Teile in Laufwerken, wie SCSI-Laufwerke, verbaut. Diese können einen Flaschenhals bei der Gesamtleistung des Systems darstellen. Sie können zwar auch ein Laufwerk ohne mechanische Teile einbauen, wie z.B. ein Solid-State-Drive, aber Laufwerke mit mechanischen Teilen werden auch in naher Zukunft nicht vom Markt verschwinden. Bei der Feinabstimmung ist es ratsam, die Funktionen von <a href="https://man.freebsd.org/cgi/man.cgi?query=iostat&amp;sektion=8&amp;format=html">iostat(8)</a> zu verwenden, um verschiedene Änderungen zu testen und um nützliche IO-Informationen des Systems zu erhalten.</p></div><div class=sect2><h3 id=_sysctl_variablen>26.1. Sysctl Variablen<a class=anchor href=#_sysctl_variablen></a></h3><div class=sect3><h4 id=_vfs_vmiodirenable>26.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h4><div class=paragraph><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>vfs.vmiodirenable</code> besitzt in der Voreinstellung den Wert <code>1</code>. Die Variable kann auf den Wert <code>0</code> (deaktiviert) oder <code>1</code> (aktiviert) gesetzt werden. Sie steuert, wie Verzeichnisse vom System zwischengespeichert werden. Die meisten Verzeichnisse sind klein und benutzen nur ein einzelnes Fragment, typischerweise 1 kB, im Dateisystem und 512 Bytes im Buffer-Cache. Ist die Variable deaktiviert, wird der Buffer-Cache nur eine limitierte Anzahl Verzeichnisse zwischenspeichern, auch wenn das System über sehr viel Speicher verfügt. Ist die Variable aktiviert, kann der Buffer-Cache den VM-Page-Cache benutzen, um Verzeichnisse zwischenzuspeichern. Der ganze Speicher steht damit zum Zwischenspeichern von Verzeichnissen zur Verfügung. Der Nachteil bei dieser Vorgehensweise ist, dass zum Zwischenspeichern eines Verzeichnisses mindestens eine physikalische Seite im Speicher, die normalerweise 4 kB groß ist, anstelle von 512 Bytes gebraucht wird. Es wird empfohlen, diese Option aktiviert zu lassen, wenn Sie Dienste zur Verfügung stellen, die viele Dateien manipulieren. Beispiele für solche Dienste sind Web-Caches, große Mail-Systeme oder Netnews. Die aktivierte Variable vermindert, trotz des verschwendeten Speichers, in aller Regel nicht die Leistung des Systems, obwohl Sie das nachprüfen sollten.</p></div></div><div class=sect3><h4 id=_vfs_write_behind>26.1.2. <code>vfs.write_behind</code><a class=anchor href=#_vfs_write_behind></a></h4><div class=paragraph><p>In der Voreinstellung besitzt die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>vfs.write_behind</code> den Wert <code>1</code> (aktiviert). Mit dieser Einstellung schreibt das Dateisystem anfallende vollständige Cluster, die besonders beim sequentiellen Schreiben großer Dateien auftreten, direkt auf das Medium aus. Dies verhindert, dass sich im Buffer-Cache veränderte Puffer (dirty buffers) ansammeln, die die I/O-Verarbeitung nicht mehr beschleunigen würden. Unter bestimmten Umständen blockiert diese Funktion allerdings Prozesse. Setzen Sie in diesem Fall die Variable <code>vfs.write_behind</code> auf den Wert <code>0</code>.</p></div></div><div class=sect3><h4 id=_vfs_hirunningspace>26.1.3. <code>vfs.hirunningspace</code><a class=anchor href=#_vfs_hirunningspace></a></h4><div class=paragraph><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>vfs.hirunningspace</code> bestimmt systemweit die Menge ausstehender Schreiboperationen, die dem Platten-Controller zu jedem beliebigen Zeitpunkt übergeben werden können. Normalerweise können Sie den Vorgabewert verwenden. Auf Systemen mit vielen Platten kann der Wert aber auf 4 bis 5 <em>Megabyte</em> erhöht werden. Ein zu hoher Wert (größer als der Schreib-Schwellwert des Buffer-Caches) kann zu Leistungsverlusten führen. Setzen Sie den Wert daher nicht zu hoch! Hohe Werte können auch Leseoperationen verzögern, die gleichzeitig mit Schreiboperationen ausgeführt werden.</p></div><div class=paragraph><p>Es gibt weitere <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variablen, mit denen Sie den Buffer-Cache und den VM-Page-Cache beeinflussen können. Es wird nicht empfohlen, diese Variablen zu verändern, da das VM-System den virtuellen Speicher selbst sehr gut verwaltet.</p></div></div><div class=sect3><h4 id=_vm_swap_idle_enabled>26.1.4. <code>vm.swap_idle_enabled</code><a class=anchor href=#_vm_swap_idle_enabled></a></h4><div class=paragraph><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>vm.swap_idle_enabled</code> ist für große Mehrbenutzer-Systeme gedacht, auf denen sich viele Benutzer an- und abmelden und auf denen es viele Prozesse im Leerlauf (idle) gibt. Solche Systeme fragen kontinuierlich freien Speicher an. Wenn Sie die Variable <code>vm.swap_idle_enabled</code> aktivieren, können Sie die Auslagerungs-Hysterese von Seiten mit den Variablen <code>vm.swap_idle_threshold1</code> und <code>vm.swap_idle_threshold2</code> einstellen. Die Schwellwerte beider Variablen geben die Zeit in Sekunden an, in denen sich ein Prozess im Leerlauf befinden muss. Wenn die Werte so eingestellt sind, dass Seiten früher als nach dem normalen Algorithmus ausgelagert werden, verschafft das dem Auslagerungs-Prozess mehr Luft. Aktivieren Sie diese Funktion nur, wenn Sie sie wirklich benötigen: Die Speicherseiten werden eher früher als später ausgelagert. Der Platz im Swap-Bereich wird dadurch schneller verbraucht und die Plattenaktivitäten steigen an. Auf kleinen Systemen hat diese Funktion spürbare Auswirkungen. Auf großen Systemen, die sowieso schon Seiten auslagern müssen, können ganze Prozesse leichter in den Speicher geladen oder ausgelagert werden.</p></div></div><div class=sect3><h4 id=_hw_ata_wc>26.1.5. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h4><div class=paragraph><p>Obwohl das Abstellen des IDE-Schreib-Zwischenspeichers die Bandbreite zum Schreiben auf die IDE-Festplatte verringert, kann es aus Gründen der Datenkonsistenz als notwendig angesehen werden. Das Problem ist, dass IDE-Platten keine zuverlässige Aussage über das Ende eines Schreibvorgangs treffen. Wenn der Schreib-Zwischenspeicher aktiviert ist, werden die Daten nicht in der Reihenfolge ihres Eintreffens geschrieben. Es kann sogar passieren, dass das Schreiben mancher Blöcke im Fall von starker Plattenaktivität auf unbefristete Zeit verzögert wird. Ein Absturz oder Stromausfall zu dieser Zeit kann die Dateisysteme erheblich beschädigen. Sie sollten den Wert der <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>hw.ata.wc</code> auf dem System überprüfen. Wenn der Schreib-Zwischenspeicher abgestellt ist, können Sie ihn beim Systemstart aktivieren, indem Sie die Variable in <span class=filename>/boot/loader.conf</span> auf den Wert <code>1</code> setzen.</p></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a>.</p></div></div><div class=sect3><h4 id=_scsi_delay_kern_cam_scsi_delay>26.1.6. <code>SCSI_DELAY</code> (<code>kern.cam.scsi_delay</code>)<a class=anchor href=#_scsi_delay_kern_cam_scsi_delay></a></h4><div class=paragraph><p>Mit der Kerneloption <code>SCSI_DELAY</code> kann die Dauer des Systemstarts verringert werden. Der Vorgabewert ist recht hoch und er verzögert den Systemstart um <code>15</code> oder mehr Sekunden. Normalerweise kann dieser Wert, insbesondere mit modernen Laufwerken, mit der <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>kern.cam.scsi_delay</code> auf <code>5</code> Sekunden heruntergesetzt werden. Die Variable sowie die Kerneloption verwenden für die Zeitangabe Millisekunden und <em>nicht</em> Sekunden.</p></div></div></div><div class=sect2><h3 id=soft-updates>26.2. Soft Updates<a class=anchor href=#soft-updates></a></h3><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> lassen sich Feineinstellungen an Dateisystemen vornehmen. Das Programm hat verschiedene Optionen. Soft Updates werden wie folgt ein- und ausgeschaltet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>Ein eingehängtes Dateisystem kann nicht mit <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> modifiziert werden. Soft Updates werden am besten im Single-User Modus aktiviert, bevor Partitionen eingehangen sind.</p></div><div class=paragraph><p>Durch Einsatz eines Zwischenspeichers wird die Performance im Bereich der Metadaten, vorwiegend beim Anlegen und Löschen von Dateien, gesteigert. Es wird empfohlen, Soft Updates auf allen UFS-Dateisystemen zu aktivieren. Allerdings sollten Sie sich über die zwei Nachteile von Soft Updates bewusst sein: Erstens garantieren Soft Updates zwar die Konsistenz der Daten im Fall eines Absturzes, aber es kann passieren, dass das Dateisystem über mehrere Sekunden oder gar eine Minute nicht synchronisiert wurde. Nicht geschriebene Daten gehen dann vielleicht verloren. Zweitens verzögern Soft Updates die Freigabe von Datenblöcken. Eine größere Aktualisierung eines fast vollen Dateisystems, wie dem Root-Dateisystem, z.B. während eines <code>make installworld</code>, kann das Dateisystem vollaufen lassen. Dadurch würde die Aktualisierung fehlschlagen.</p></div><div class=sect3><h4 id=_details_über_soft_updates>26.2.1. Details über Soft Updates<a class=anchor href=#_details_über_soft_updates></a></h4><div class=paragraph><p>Bei einem Metadaten-Update werden die Inodes und Verzeichniseinträge aktualisiert auf die Platte zurückgeschrieben. Es gibt zwei klassische Ansätze, um die Metadaten des Dateisystems auf die Platte zu schreiben.</p></div><div class=paragraph><p>Das historisch übliche Verfahren waren synchrone Updates der Metadaten, d. h. wenn eine Änderung an einem Verzeichnis nötig war, wurde anschließend gewartet, bis diese Änderung tatsächlich auf die Platte zurückgeschrieben worden war. Der <em>Inhalt</em> der Dateien wurde im "Buffer Cache" zwischengespeichert und später asynchron auf die Platte geschrieben. Der Vorteil dieser Implementierung ist, dass sie sicher funktioniert. Wenn während eines Updates ein Ausfall erfolgt, haben die Metadaten immer einen konsistenten Zustand. Eine Datei ist entweder komplett angelegt oder gar nicht. Wenn die Datenblöcke einer Datei im Fall eines Absturzes noch nicht den Weg aus dem "Buffer Cache" auf die Platte gefunden haben, kann <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> das Dateisystem reparieren, indem es die Dateilänge einfach auf <code>0</code> setzt. Außerdem ist die Implementierung einfach und überschaubar. Der Nachteil ist, dass Änderungen der Metadaten sehr langsam vor sich gehen. Ein <code>rm -r</code> beispielsweise fasst alle Dateien eines Verzeichnisses der Reihe nach an, aber jede dieser Änderungen am Verzeichnis (Löschen einer Datei) wird einzeln synchron auf die Platte geschrieben. Gleiches beim Auspacken großer Hierarchien mit <code>tar -x</code>.</p></div><div class=paragraph><p>Der zweite Ansatz sind asynchrone Metadaten-Updates. Das ist der Standard, wenn UFS-Dateisysteme mit <code>mount -o async</code> eingehängt werden. Man schickt die Updates der Metadaten einfach auch noch über den "Buffer Cache", sie werden also zwischen die Updates der normalen Daten eingeschoben. Vorteil ist, dass man nun nicht mehr auf jeden Update warten muss, Operationen, die zahlreiche Metadaten ändern, werden also viel schneller. Auch hier ist die Implementierung sehr einfach und wenig anfällig für Fehler. Nachteil ist, dass keinerlei Konsistenz des Dateisystems mehr gesichert ist. Wenn mitten in einer Operation, die viele Metadaten ändert, ein Ausfall erfolgt (Stromausfall, drücken des Reset-Schalters), dann ist das Dateisystem anschließend in einem unbestimmten Zustand. Niemand kann genau sagen, was noch geschrieben worden ist und was nicht mehr; die Datenblöcke einer Datei können schon auf der Platte stehen, während die inode Tabelle oder das zugehörige Verzeichnis nicht mehr aktualisiert worden ist. Man kann praktisch kein <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> mehr implementieren, das diesen Zustand wieder reparieren kann, da die dazu nötigen Informationen einfach auf der Platte fehlen. Wenn ein Dateisystem irreparabel beschädigt wurde, hat man nur noch die Möglichkeit es neu zu erzeugen und die Daten vom Backup zurückspielen.</p></div><div class=paragraph><p>Der Ausweg aus diesem Dilemma ist ein <em>dirty region logging</em>, was auch als <em>Journalling</em> bezeichnet wird. Man schreibt die Metadaten-Updates zwar synchron, aber nur in einen kleinen Plattenbereich, die <em>logging area</em>. Von da aus werden sie dann asynchron auf ihre eigentlichen Bereiche verteilt. Da die <em>logging area</em> ein kleines zusammenhängendes Stückchen ist, haben die Schreibköpfe der Platte bei massiven Operationen auf Metadaten keine allzu großen Wege zurückzulegen, so dass alles ein ganzes Stück schneller geht als bei klassischen synchronen Updates. Die Komplexität der Implementierung hält sich ebenfalls in Grenzen, somit auch die Anfälligkeit für Fehler. Als Nachteil ergibt sich, dass Metadaten zweimal auf die Platte geschrieben werden müssen (einmal in die <em>logging area</em>, einmal an die richtige Stelle), so dass das im Falle regulärer Arbeit (also keine gehäuften Metadatenoperationen) eine "Pessimisierung" des Falls der synchronen Updates eintritt, es wird alles langsamer. Dafür hat man als Vorteil, dass im Falle eines Absturzes der konsistente Zustand dadurch erzielbar ist, dass die angefangenen Operationen aus dem <em>dirty region log</em> entweder zu Ende ausgeführt oder komplett verworfen werden, wodurch das Dateisystem schnell wieder zur Verfügung steht.</p></div><div class=paragraph><p>Die Lösung von Kirk McKusick, dem Schöpfer von Berkeley FFS, waren <em>Soft Updates</em>: die notwendigen Updates der Metadaten werden im Speicher gehalten und dann sortiert auf die Platte geschrieben ("ordered metadata updates"). Dadurch hat man den Effekt, dass im Falle massiver Metadaten-Änderungen spätere Operationen die vorhergehenden, noch nicht auf die Platte geschriebenen Updates desselben Elements im Speicher "einholen". Alle Operationen, auf ein Verzeichnis beispielsweise, werden also in der Regel noch im Speicher abgewickelt, bevor der Update überhaupt auf die Platte geschrieben wird (die dazugehörigen Datenblöcke werden natürlich auch so sortiert, dass sie nicht vor ihren Metadaten auf der Platte sind). Im Fall eines Absturzes hat man ein implizites "log rewind": alle Operationen, die noch nicht den Weg auf die Platte gefunden haben, sehen danach so aus, als hätten sie nie stattgefunden. Man hat so also den konsistenten Zustand von ca. 30 bis 60 Sekunden früher sichergestellt. Der verwendete Algorithmus garantiert dabei, dass alle tatsächlich benutzten Ressourcen auch in den entsprechenden Bitmaps (Block- und inode Tabellen) als belegt markiert sind. Der einzige Fehler, der auftreten kann, ist, dass Ressourcen noch als "belegt" markiert sind, die tatsächlich "frei" sind. <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> erkennt dies und korrigiert diese nicht mehr belegten Ressourcen. Die Notwendigkeit eines Dateisystem-Checks darf aus diesem Grunde auch ignoriert und das Dateisystem mittels <code>mount -f</code> zwangsweise eingebunden werden. Um noch allozierte Ressourcen freizugeben muss später ein <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> nachgeholt werden. Das ist dann auch die Idee des <em>background fsck</em>: beim Starten des Systems wird lediglich ein <em>Schnappschuss</em> des Dateisystems gemacht, mit dem <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> dann später arbeiten kann. Alle Dateisysteme dürfen "unsauber" eingebunden werden und das System kann sofort in den Multiuser-Modus gehen. Danach wird ein Hintergrund-<a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> für die Dateisysteme gestartet, die dies benötigen, um möglicherweise irrtümlich belegte Ressourcen freizugeben. Dateisysteme ohne <em>Soft Updates</em> benötigen natürlich immer noch den üblichen Vordergrund-<a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, bevor sie eingebunden werden können.</p></div><div class=paragraph><p>Der Vorteil ist, dass die Metadaten-Operationen beinahe so schnell ablaufen wie im asynchronen Fall, also auch schneller als beim <em>logging</em>, das die Metadaten immer zweimal schreiben muss. Als Nachteil stehen dem die Komplexität des Codes, ein erhöhter Speicherverbrauch und einige spezielle Eigenheiten entgegen. Nach einem Absturz ist ein etwas "älterer" Stand auf der Platte - statt einer leeren, aber bereits angelegten Datei, wie nach einem herkömmlichen <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> Lauf, ist auf einem Dateisystem mit <em>Soft Updates</em> keine Spur der entsprechenden Datei mehr zu sehen, da weder die Metadaten noch der Dateiinhalt je auf die Platte geschrieben wurden. Weiterhin kann der Platz nach einem <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a> nicht sofort wieder als verfügbar markiert werden, sondern erst dann, wenn der Update auch auf die Platte vermittelt worden ist. Dies kann besonders dann Probleme bereiten, wenn große Datenmengen in einem Dateisystem installiert werden, das nicht genügend Platz hat, um alle Dateien zweimal unterzubringen.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-kernel-limits>Kapitel 27. Einstellungen von Kernel Limits<a class=anchor href=#configtuning-kernel-limits></a></h2><div class=sectionbody><div class=sect2><h3 id=file-process-limits>27.1. Datei und Prozeß Limits<a class=anchor href=#file-process-limits></a></h3><div class=sect3><h4 id=kern-maxfiles>27.1.1. <code>kern.maxfiles</code><a class=anchor href=#kern-maxfiles></a></h4><div class=paragraph><p>Abhängig von den Anforderungen an das System kann die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>kern.maxfiles</code> erhöht oder gesenkt werden. Die Variable legt die maximale Anzahl von Dateideskriptoren auf dem System fest. Wenn die Dateideskriptoren aufgebraucht sind, werden Sie die Meldung <code>file: table is full</code> wiederholt im Puffer für Systemmeldungen sehen. Den Inhalt des Puffers können Sie sich mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> anzeigen lassen.</p></div><div class=paragraph><p>Jede offene Datei, jedes Socket und jede FIFO verbraucht einen Dateideskriptor. Auf "dicken" Produktionsservern können leicht Tausende Dateideskriptoren benötigt werden, abhängig von der Art und Anzahl der gleichzeitig laufenden Dienste.</p></div><div class=paragraph><p>In älteren FreeBSD-Versionen wurde die Voreinstellung von <code>kern.maxfile</code> aus der Kernelkonfigurationsoption <code>maxusers</code> bestimmt. <code>kern.maxfiles</code> wächst proportional mit dem Wert von <code>maxusers</code>. Wenn Sie einen angepassten Kernel kompilieren, empfiehlt es sich diese Option entsprechend der maximalen Benutzerzahl des Systems einzustellen. Obwohl auf einer Produktionsmaschine vielleicht nicht 256 Benutzer gleichzeitig angemeldet sind, können die benötigten Ressourcen ähnlich hoch wie bei einem großen Webserver sein.</p></div><div class=paragraph><p>Die nur lesbare <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>kern.maxusers</code> wird beim Systemstart automatisch aus dem zur Verfügung stehenden Hauptspeicher bestimmt. Im laufenden Betrieb kann dieser Wert aus <code>kern.maxusers</code> ermittelt werden. Einige Systeme benötigen für diese Variable einen anderen Wert, wobei <code>64</code>, <code>128</code> und <code>256</code> gewöhnliche Werte darstellen. Es wird nicht empfohlen, die Anzahl der Dateideskriptoren auf einen Wert größer <code>256</code> zu setzen, es sei denn, Sie benötigen wirklich eine riesige Anzahl von ihnen. Viele der von <code>kern.maxusers</code> auf einen Standardwert gesetzten Parameter können beim Systemstart oder im laufenden Betrieb in <span class=filename>/boot/loader.conf</span> angepasst werden. In <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> und <span class=filename>/boot/defaults/loader.conf</span> finden Sie weitere Details und Hinweise.</p></div><div class=paragraph><p>Ältere FreeBSD-Versionen setzen diesen Wert selbst, wenn Sie in der Konfigurationsdatei den Wert <code>0</code> angeben. Wenn Sie den Wert selbst bestimmen wollen, sollten Sie <code>maxusers</code> mindestens auf <code>4</code> setzen. Dies gilt insbesondere dann, wenn Sie beabsichtigen, Xorg zu benutzen oder Software zu kompilieren. Der wichtigste Wert, der durch <code>maxusers</code> bestimmt wird, die maximale Anzahl an Prozessen ist, die auf <code>20 + 16 * maxusers</code> gesetzt wird. Wird <code>maxusers</code> auf <code>1</code> setzen, können gleichzeitig nur <code>36</code> Prozesse laufen, von denen ungefähr <code>18</code> schon beim Booten des Systems gestartet werden. Dazu kommen nochmals etwa <code>15</code> Prozesse beim Start von Xorg. Selbst eine einfache Aufgabe wie das Lesen einer Manualpage benötigt neun Prozesse zum Filtern, Dekomprimieren und Betrachten der Datei. Für die meisten Benutzer sollte es ausreichen, <code>maxusers</code> auf <code>64</code> zu setzen, womit <code>1044</code> gleichzeitige Prozesse zur Verfügung stehen. Wenn Sie allerdings den Fehler beim Start eines Programms oder auf einem Server mit einer großen Benutzerzahl sehen, dann sollten Sie den Wert nochmals erhöhen und den Kernel neu bauen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Anzahl der Benutzer, die sich auf einem Rechner anmelden kann, wird durch <code>maxusers</code> <em>nicht</em> begrenzt. Der Wert dieser Variablen legt neben der möglichen Anzahl der Prozesse eines Benutzers weitere sinnvolle Größen für bestimmte Systemtabellen fest.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_kern_ipc_soacceptqueue>27.1.2. <code>kern.ipc.soacceptqueue</code><a class=anchor href=#_kern_ipc_soacceptqueue></a></h4><div class=paragraph><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>kern.ipc.soacceptqueue</code> beschränkt die Größe der Warteschlange (Listen-Queue) für neue TCP-Verbindungen. Der Vorgabewert von <code>128</code> ist normalerweise zu klein, um neue Verbindungen auf einem stark ausgelasteten Webserver zuverlässig zu handhaben. Auf solchen Servern sollte der Wert auf <code>1024</code> oder höher gesetzt werden. Dienste wie <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> oder Apache können die Größe der Queue selbst einschränken. Oft gibt es die Möglichkeit, die Größe der Listen-Queue in einer Konfigurationsdatei einzustellen. Eine große Listen-Queue übersteht vielleicht auch einen Denial of Service Angriff ().</p></div></div></div><div class=sect2><h3 id=nmbclusters>27.2. Netzwerk Limits<a class=anchor href=#nmbclusters></a></h3><div class=paragraph><p>Die Kerneloption <code>NMBCLUSTERS</code> schreibt die Anzahl der Netzwerkpuffer (Mbufs) fest, die das System besitzt. Eine zu geringe Anzahl Mbufs auf einem Server mit viel Netzwerkverkehr verringert die Leistung von FreeBSD. Jeder Mbuf-Cluster nimmt ungefähr 2 kB Speicher in Anspruch, so dass ein Wert von <code>1024</code> insgesamt 2 Megabyte Speicher für Netzwerkpuffer im System reserviert. Wie viele Cluster benötigt werden, lässt sich durch eine einfache Berechnung herausfinden. Ein Webserver, der maximal <code>1000</code> gleichzeitige Verbindungen servieren soll, wobei jede der Verbindungen einen 6 kB großen Sendepuffer und einen 16 kB großen Empfangspuffer benötigt, braucht ungefähr 32 MB Speicher für Netzwerkpuffer. Als Daumenregel verdoppeln Sie diese Zahl, so dass sich für <code>NMBCLUSTERS</code> der Wert 2x32 MB / 2 kB= 64 MB / 2 kB= <code>32768</code> ergibt. Für Maschinen mit viel Speicher werden Werte zwischen <code>4096</code> und <code>32768</code> empfohlen. Unter keinen Umständen sollten Sie diesen Wert willkürlich erhöhen, da dies zu einem Absturz beim Systemstart führen kann. Verwenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> mit <code>-m</code> um den Gebrauch der Netzwerkpuffer zu kontrollieren.</p></div><div class=paragraph><p>Die Netzwerkpuffer können beim Systemstart mit der Loader-Variablen <code>kern.ipc.nmbclusters</code> eingestellt werden. Nur auf älteren FreeBSD-Systemen müssen Sie die Kerneloption <code>NMBCLUSTERS</code> verwenden.</p></div><div class=paragraph><p>Die Anzahl der <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> Puffer muss auf ausgelasteten Servern, die den Systemaufruf <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> oft verwenden, vielleicht erhöht werden. Dazu können Sie die Kerneloption <code>NSFBUFS</code> verwenden oder die Anzahl der Puffer in <span class=filename>/boot/loader.conf</span> (siehe <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>) setzen. Die Puffer sollten erhöht werden, wenn Sie Prozesse im Zustand <code>sfbufa</code> sehen. Die schreibgeschützte <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>kern.ipc.nsfbufs</code> zeigt die Anzahl eingerichteten Puffer im Kernel. Der Wert dieser Variablen wird normalerweise von <code>kern.maxusers</code> bestimmt. Manchmal muss die Pufferanzahl jedoch manuell eingestellt werden.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Auch wenn ein Socket nicht blockierend angelegt wurde, kann der Aufruf von <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> blockieren, um auf freie <code>struct sf_buf</code> Puffer zu warten.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_net_inet_ip_portrange>27.2.1. <code>net.inet.ip.portrange.*</code><a class=anchor href=#_net_inet_ip_portrange></a></h4><div class=paragraph><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>net.inet.ip.portrange.*</code> legt die Portnummern für TCP- und UDP-Sockets fest. Es gibt drei Bereiche: den niedrigen Bereich, den normalen Bereich und den hohen Bereich. Die meisten Netzprogramme benutzen den normalen Bereich. Dieser Bereich umfasst in der Voreinstellung die Portnummern <code>1024</code> bis <code>5000</code> und wird durch die Variablen <code>net.inet.ip.portrange.first</code> und <code>net.inet.ip.portrange.last</code> festgelegt. Die festgelegten Bereiche für Portnummern werden von ausgehenden Verbindungen benutzt. Unter bestimmten Umständen, beispielsweise auf stark ausgelasteten Proxy-Servern, sind alle Portnummern für ausgehende Verbindungen belegt. Bereiche für Portnummern spielen auf Servern keine Rolle, die hauptsächlich eingehende Verbindungen verarbeiten (wie ein normaler Webserver) oder nur eine begrenzte Anzahl ausgehender Verbindungen öffnen (beispielsweise ein Mail-Relay). Wenn keine freien Portnummern mehr vorhanden sind, sollte die Variable <code>net.inet.ip.portrange.last</code> langsam erhöht werden. Ein Wert von <code>10000</code>, <code>20000</code> oder <code>30000</code> ist angemessen. Beachten Sie auch eine vorhandene Firewall, wenn Sie die Bereiche für Portnummern ändern. Einige Firewalls sperren große Bereiche (normalerweise aus den kleinen Portnummern) und erwarten, dass hohe Portnummern für ausgehende Verbindungen verwendet werden. Daher kann es erforderlich sein, den Wert von <code>net.inet.ip.portrange.first</code> zu erhöhen.</p></div></div><div class=sect3><h4 id=_tcp_bandwidth_delay_product_begrenzung>27.2.2. <code>TCP</code> Bandwidth Delay Product Begrenzung<a class=anchor href=#_tcp_bandwidth_delay_product_begrenzung></a></h4><div class=paragraph><p>Die <code>TCP</code> Bandwidth Delay Product Begrenzung wird aktiviert, indem die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>net.inet.tcp.inflight.enable</code> auf den Wert <code>1</code> gesetzt wird. Das System wird dadurch angewiesen, für jede Verbindung, das Produkt aus der Übertragungsrate und der Verzögerungszeit zu bestimmen. Dieses Produkt begrenzt die Datenmenge, die für einen optimalen Durchsatz zwischengespeichert werden muss.</p></div><div class=paragraph><p>Diese Begrenzung ist nützlich, wenn Sie Daten über Verbindungen mit einem hohen Produkt aus Übertragungsrate und Verzögerungszeit wie Modems, Gigabit-Ethernet oder schnellen WANs, zur Verfügung stellen. Insbesondere wirkt sich die Begrenzung aus, wenn die Verbindung die Option Window-scaling verwendet oder große Sende-Fenster (send window) benutzt. Schalten Sie die Debug-Meldungen aus, wenn Sie die Begrenzung aktiviert haben. Dazu setzen Sie die Variable <code>net.inet.tcp.inflight.debug</code> auf <code>0</code>. Auf Produktions-Systemen sollten Sie zudem die Variable <code>net.inet.tcp.inflight.min</code> mindestens auf den Wert <code>6144</code> setzen. Allerdings kann ein zu hoher Wert, abhängig von der Verbindung, die Begrenzungsfunktion unwirksam machen. Die Begrenzung reduziert die Datenmenge in den Queues von Routern und Switches, sowie die Datenmenge in der Queue der lokalen Netzwerkkarte. Die Verzögerungszeit (Round Trip Time) für interaktive Anwendungen sinkt, da weniger Pakete zwischengespeichert werden. Dies gilt besonders für Verbindungen über langsame Modems. Die Begrenzung wirkt sich allerdings nur auf das Versenden von Daten aus (Uploads, Server). Auf den Empfang von Daten (Downloads) hat die Begrenzung keine Auswirkungen.</p></div><div class=paragraph><p>Die Variable <code>net.inet.tcp.inflight.stab</code> sollte <em>nicht</em> angepasst werden. Der Vorgabewert der Variablen beträgt <code>20</code>, das heißt es werden maximal zwei Pakete zu dem Produkt aus Übertragungsrate und Verzögerungszeit addiert. Dies stabilisiert den Algorithmus und verbessert die Reaktionszeit auf Veränderungen. Bei langsamen Verbindungen können sich aber die Laufzeiten der Pakete erhöhen (ohne diesen Algorithmus wären sie allerdings noch höher). In solchen Fällen können Sie versuchen, den Wert der Variablen auf <code>15</code>, <code>10</code> oder <code>5</code> herabzusetzen. Gleichzeitig müssen Sie vielleicht auch <code>net.inet.tcp.inflight.min</code> auf einen kleineren Wert (beispielsweise <code>3500</code>) setzen. Ändern Sie diese Variablen nur ab, wenn Sie keine anderen Möglichkeiten mehr haben.</p></div></div></div><div class=sect2><h3 id=_virtueller_speicher_virtual_memory>27.3. Virtueller Speicher (Virtual Memory)<a class=anchor href=#_virtueller_speicher_virtual_memory></a></h3><div class=sect3><h4 id=_kern_maxvnodes>27.3.1. <code>kern.maxvnodes</code><a class=anchor href=#_kern_maxvnodes></a></h4><div class=paragraph><p>Ein vnode ist die interne Darstellung einer Datei oder eines Verzeichnisses. Die Erhöhung der Anzahl der für das Betriebssystem verfügbaren vnodes verringert also die Schreib- und Lesezugriffe auf der Festplatte. vnodes werden im Normalfall vom Betriebssystem automatisch vergeben und müssen nicht manuell angepasst werden. In einigen Fällen stellt der Zugriff auf eine Platte allerdings einen Flaschenhals dar, daher sollten Sie in diesem Fall die Anzahl der möglichen vnodes erhöhen, um dieses Problem zu beheben. Beachten Sie dabei aber die Größe des inaktiven und freien Hauptspeichers.</p></div><div class=paragraph><p>Um die Anzahl der derzeit verwendeten vnodes zu sehen, geben Sie Folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.numvnodes</span>
vfs.numvnodes: 91349</code></pre></div></div><div class=paragraph><p>Die maximal mögliche Anzahl der vnodes erhalten Sie durch die Eingabe von:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxvnodes</span>
kern.maxvnodes: 100000</code></pre></div></div><div class=paragraph><p>Wenn sich die Anzahl der genutzten vnodes dem maximal möglichen Wert nähert, sollten Sie den Wert <code>kern.maxvnodes</code> zuerst um etwa <code>1000</code> erhöhen. Beobachten Sie danach die Anzahl der vom System genutzten <code>vfs.numvnodes</code>. Nähert sich der Wert wiederum dem definierten Maximum, müssen Sie <code>kern.maxvnodes</code> nochmals erhöhen. Sie sollten nun eine Änderung des Speicherverbrauches über <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> registrieren können und über mehr aktiven Speicher verfügen.</p></div></div></div></div></div><div class=sect1><h2 id=adding-swap-space>Kapitel 28. Hinzufügen von Swap-Bereichen<a class=anchor href=#adding-swap-space></a></h2><div class=sectionbody><div class=paragraph><p>Manchmal benötigt ein System mehr Swap-Bereiche. Dieser Abschnitt beschreibt zwei Methoden, um Swap-Bereiche hinzuzufügen: auf einer bestehenden Partition oder auf einem neuen Laufwerk, und das Hinzufügen einer Swap-Datei auf einer existierenden Partition.</p></div><div class=paragraph><p>Für Informationen zur Verschlüsselung von Swap-Partitionen, zu den dabei möglichen Optionen sowie zu den Gründen für eine Verschlüsselung des Auslagerungsspeichers lesen Sie <a href=./#swap-encrypting>“Den Auslagerungsspeicher verschlüsseln”</a>.</p></div><div class=sect2><h3 id=new-drive-swap>28.1. Swap auf einer neuen Festplatte oder einer existierenden Partition<a class=anchor href=#new-drive-swap></a></h3><div class=paragraph><p>Das Hinzufügen einer neuen Festplatte für den Swap-Bereich bietet eine bessere Leistung, als die Verwendung einer Partition auf einem vorhandenem Laufwerk. Die Einrichtung von Partitionen und Laufwerken wird in <a href=./#disks-adding>“Hinzufügen von Laufwerken“</a> beschrieben. <a href=./#configtuning-initial>“Ein Partitionslayout entwerfen“</a> diskutiert Aspekte über die Anordnung und Größe von Swap-Bereichen.</p></div><div class=paragraph><p>Benutzen Sie <code>swapon</code> um eine Swap-Partition zum System hinzuzufügen. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon /dev/ada1s1b</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Sie können jede Partition verwenden, sofern sie nicht schon eingehangen ist. Das gilt auch dann, wenn die Partition bereits Daten enthält. Wird <code>swapon</code> auf einer Partition ausgeführt die Daten enthält, werden die vorhandenen Daten überschrieben und sind unweigerlich verloren. Stellen Sie sicher, dass die Partition, die Sie als Swap-Bereich hinzufügen möchten, wirklich die gewünschte Partition ist, bevor Sie <code>swapon</code> ausführen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um diese Swap-Partition automatisch beim Systemstart hinzuzufügen, fügen Sie einen Eintrag in <span class=filename>/etc/fstab</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1s1b	none	swap	sw	0	0</pre></div></div><div class=paragraph><p>Die einzelnen Einträge von <span class=filename>/etc/fstab</span> werden in <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> erläutert. Weitere Informationen zu <code>swapon</code> finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>.</p></div></div><div class=sect2><h3 id=create-swapfile>28.2. Swap-Dateien erstellen<a class=anchor href=#create-swapfile></a></h3><div class=paragraph><p>Anstatt eine Partition zu verwenden, erstellen diese Beispiele eine 512 MB große Swap-Datei mit dem Namen <span class=filename>/usr/swap0</span>.</p></div><div class=paragraph><p>Die Verwendung von Swap-Dateien macht es erforderlich, dass das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> entweder im Kernel vorhanden oder geladen wird, bevor Swap aktiviert ist. <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> enthält Informationen zum Bau eines angepassten Kernels.</p></div><div id=swapfile-10-and-later class=exampleblock><div class=title>Beispiel 26. Erstellen einer Swap-Datei</div><div class=content><div class="olist arabic procedure"><ol class=arabic><li><p>Erstellen Sie die Swap-Datei:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1024k count=512</span></code></pre></div></div></li><li><p>Setzen Sie die richtigen Berechtigungen für die neue Datei:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>Fügen Sie einen Eintrag in <span class=filename>/etc/fstab</span> hinzu:</p><div class="literalblock programlisting"><div class=content><pre>md99	none	swap	sw,file=/usr/swap0,late	0	0</pre></div></div><div class=paragraph><p>Das <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> Gerät <span class=filename>md99</span> wird verwendet, damit die niedrigeren Gerätenummer für die interaktive Benutzung frei bleiben.</p></div></li><li><p>Der Swap-Speicher wird nun automatisch beim Systemstart hinzugefügt. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a> um den Swap-Speicher direkt zu aktivieren:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon -aL</span></code></pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=acpi-overview>Kapitel 29. Energie- und Ressourcenverwaltung<a class=anchor href=#acpi-overview></a></h2><div class=sectionbody><div class=paragraph><p>Es ist wichtig, Hardware effizient einzusetzen. Energie- und Ressourcenverwaltung ermöglicht es dem System auf verschiedene Ereignisse, beispielsweise einen unerwarteten Temperaturanstieg, reagieren zu können. Eine frühe Spezifikation für die Energieverwaltung war das Advanced Power Management (APM). APM steuert den Energieverbrauch eines Systems auf Basis der Systemaktivität. Ursprünglich konnten Stromverbrauch und Wärmeabgabe eines Systems nur schlecht von Betriebssystemen gesteuert werden. Die Hardware wurde vom BIOS gesteuert, was die Kontrolle der Energieverwaltung für den Anwender erschwerte. Das APM-BIOS wird von dem Hersteller des Systems zur Verfügung gestellt und ist auf die spezielle Hardware angepasst. Der APM-Treiber des Betriebssystems greift auf das <em>APM Software Interface</em> zu, das den Energieverbrauch regelt.</p></div><div class=paragraph><p>APM hat hauptsächlich vier Probleme. Erstens läuft die Energieverwaltung unabhängig vom Betriebssystem in einem herstellerspezifischen BIOS. Beispielsweise kann das APM-BIOS die Festplatten nach einer konfigurierbaren Zeit ohne die Zustimmung des Betriebssystems herunterfahren. Zweitens befindet sich die ganze APM-Logik im BIOS; das Betriebssystem hat gar keine APM-Komponenten. Bei Problemen mit dem APM-BIOS muss das Flash-ROM aktualisiert werden. Diese Prozedur ist gefährlich, da sie im Fehlerfall das System unbrauchbar machen kann. Zum Dritten ist APM eine Technik, die herstellerspezifisch ist und nicht koordiniert wird. Fehler im BIOS eines Herstellers werden nicht unbedingt im BIOS anderer Hersteller korrigiert. Das letzte Problem ist, dass im APM-BIOS nicht genügend Platz vorhanden ist, um eine durchdachte oder eine auf den Zweck der Maschine zugeschnittene Energieverwaltung zu implementieren.</p></div><div class=paragraph><p>Das <em>Plug and Play BIOS (PNPBIOS)</em> war in vielen Situationen ebenfalls unzureichend. Das PNPBIOS verwendet eine 16-Bit-Technik. Damit das Betriebssystem das PNPBIOS ansprechen kann, muss es in einer 16-Bit-Emulation laufen. FreeBSD stellt einen APM-Treiber zur Verfügung, welcher für Systeme benutzt werden sollte, die vor dem Jahr 2000 hergestellt wurden. Der Treiber wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a> beschrieben.</p></div><div class=paragraph><p>Der Nachfolger von APM ist das <em>Advanced Configuration and Power Interface</em> (ACPI). ACPI ist ein Standard verschiedener Hersteller, welcher die Verwaltung von Hardware und Energiesparfunktionen festlegt. Die ACPI-Funktionen, die mehr Kontrolle und Flexibilität bieten, können vom Betriebssystem gesteuert werden.</p></div><div class=paragraph><p>Dieser Abschnitt zeigt die Konfiguration von ACPI unter FreeBSD. Zudem werden einige Tipps zur Fehlersuche vorgestellt und wie Sie Problemberichte einreichen können, sodass Entwickler ACPI-Probleme erfassen und beheben können.</p></div><div class=sect2><h3 id=acpi-config>29.1. Konfiguration des ACPI<a class=anchor href=#acpi-config></a></h3><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>-Treiber wird standardmäßig beim Systemstart vom <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> geladen und sollte daher <em>nicht</em> fest in den Kernel eingebunden werden. Der Treiber kann im laufenden Betrieb nicht entfernt werden, da er zur Kommunikation mit der Hardware verwendet wird. Falls jedoch Probleme auftreten, kann ACPI auch komplett deaktiviert werden. Dazu muss <code>hint.acpi.0.disabled="1"</code> in <span class=filename>/boot/loader.conf</span> gesetzt und anschließend das System neu gestartet werden. Alternativ können Sie diese Variable auch am <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>-Prompt eingeben, wie in <a href=./#boot-loader>“Phase Drei”</a> beschrieben.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ACPI und APM können nicht zusammen verwendet werden. Das zuletzt geladene Modul beendet sich, sobald es bemerkt, dass das andere Modul geladen ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Mit <code>acpiconf</code> können Sie das System in einen Ruhemodus (sleep mode) versetzen. Es gibt verschiedene Modi (von <code>1</code> bis <code>5</code>), die Sie auf der Kommandozeile mit <code>-s</code> angeben können. Für die meisten Anwender sind die Modi <code>1</code> und <code>3</code> völlig ausreichend. Der Modus <code>5</code> schaltet das System aus (Soft-off) und entspricht dem Befehl <code>halt -p</code>.</p></div><div class=paragraph><p>Verschiedene Optionen können mit <code>sysctl</code> gesetzt werden. Lesen Sie dazu <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a>.</p></div></div><div class=sect2><h3 id=ACPI-comprob>29.2. Häufige Probleme<a class=anchor href=#ACPI-comprob></a></h3><div class=paragraph><p>ACPI gibt es in allen modernen Rechnern der ia32- (x86) und amd64- (AMD) Architektur. Der vollständige Standard bietet Funktionen zur Steuerung und Verwaltung der CPU-Leistung, der Stromversorgung, von Wärmebereichen, Batterien, eingebetteten Controllern und Bussen. Auf den meisten Systemen wird nicht der vollständige Standard implementiert. Arbeitsplatzrechner besitzen meist nur Funktionen zur Verwaltung der Busse, während Notebooks Funktionen zur Temperaturkontrolle und Ruhezustände besitzen.</p></div><div class=paragraph><p>Ein ACPI konformes System besitzt verschiedene Komponenten. Die BIOS- und Chipsatz-Hersteller stellen mehrere statische Tabellen bereit, zum Beispiel die Fixed-ACPI-Description-Table (FADT). Die Tabellen enthalten beispielsweise die mit SMP-Systemen benutzte APIC-Map, Konfigurationsregister und einfache Konfigurationen. Zusätzlich gibt es die <em>Differentiated-System-Description-Table</em> (DSDT), die Bytecode enthält. Die Tabelle ordnet Geräte und Methoden in einem baumartigen Namensraum an.</p></div><div class=paragraph><p>Ein ACPI-Treiber muss die statischen Tabellen einlesen, einen Interpreter für den Bytecode bereitstellen und die Gerätetreiber im Kernel so modifizieren, dass sie mit dem ACPI-Subsystem kommunizieren. Für FreeBSD, Linux® und NetBSD hat Intel® den Interpreter ACPI-CA, zur Verfügung gestellt. Der Quelltext zu ACPI-CA befindet sich im Verzeichnis <span class=filename>src/sys/contrib/dev/acpica</span>. Die Schnittstelle von ACPI-CA zu FreeBSD befindet sich unter <span class=filename>src/sys/dev/acpica/Osd</span>. Treiber, die verschiedene ACPI-Geräte implementieren, befinden sich im Verzeichnis <span class=filename>src/sys/dev/acpica</span>.</p></div><div class=paragraph><p>Damit ACPI richtig funktioniert, müssen alle Teile funktionieren. Im Folgenden finden Sie eine Liste mit Problemen und möglichen Abhilfen oder Korrekturen. Die Liste ist nach der Häufigkeit, mit der die Probleme auftreten, sortiert. Wenn eine Korrektur das Problem nicht behebt, finden Sie in <a href=#ACPI-submitdebug>Abrufen und Einreichen von Informationen zur Fehlersuche</a> Anweisungen, wie Sie einen Problembericht einreichen können.</p></div><div class=sect3><h4 id=_mausprobleme>29.2.1. Mausprobleme<a class=anchor href=#_mausprobleme></a></h4><div class=paragraph><p>Es kann vorkommen, dass die Maus nicht mehr funktioniert, wenn Sie nach einem Suspend weiterarbeiten wollen. Ist dies bei Ihnen der Fall, reicht es meistens aus, den Eintrag <code>hint.psm.0.flags="0x3000"</code> in <span class=filename>/boot/loader.conf</span> aufzunehmen.</p></div></div><div class=sect3><h4 id=_suspendresume>29.2.2. Suspend/Resume<a class=anchor href=#_suspendresume></a></h4><div class=paragraph><p>ACPI kennt drei Suspend-to-RAM-Zustände (STR), <code>S1</code>-<code>S3</code> sowie einen Suspend-to-Disk-Zustand (STD) <code>S4</code>. STD kann auf zwei Arten implementiert werden: <code>S4</code>BIOS und <code>S4</code>OS. Im ersten Fall wird der Suspend-to-Disk-Zustand durch das BIOS hergestellt im zweiten Fall alleine durch das Betriebssystem. Der Zustand <code>S5</code> wird "Soft off" genannt. In diesem Zustand befindet sich ein Rechner, wenn die Stromversorgung angeschlossen ist, der Rechner aber nicht hochgefahren ist.</p></div><div class=paragraph><p>Benutzen Sie <code>sysctl hw.acpi</code> um die Suspend-Zustände zu ermitteln. Diese Beispielausgabe stammt von einem Thinkpad:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</code></pre></div></div><div class=paragraph><p>Diese Ausgabe besagt, dass mit dem Befehl <code>acpiconf -s</code> die Zustände <code>S3</code>, <code>S4</code> und <code>S5</code> eingestellt werden können. Hätte <code>s4bios</code> den Wert <code>1</code>, gäbe es den Zustand <code>S4</code>BIOS anstelle von <code>S4</code>.</p></div><div class=paragraph><p>Wenn Sie die Suspend- und Resume-Funktionen testen, fangen Sie mit dem <code>S1</code>-Zustand an, wenn er angeboten wird. Dieser Zustand wird am ehesten funktionieren, da der Zustand wenig Treiber-Unterstützung benötigt. Der Zustand <code>S2</code> ist ähnlich wie <code>S1</code>, allerdings hat ihn noch niemand implementiert. Als nächstes sollten Sie den Zustand <code>S3</code> ausprobieren. Dies ist der tiefste STR-Schlafzustand. Dieser Zustand ist auf massive Treiber-Unterstützung angewiesen, um die Geräte wieder richtig zu initialisieren.</p></div><div class=paragraph><p>Ein häufiges Problem mit Suspend/Resume ist, dass viele Gerätetreiber ihre Firmware, Register und Gerätespeicher nicht korrekt speichern, wiederherstellen und/oder reinitialisieren. Um dieses Problem zu lösen, sollten Sie zuerst die folgenden Befehle ausführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.bootverbose=1</span>
<span class=c># sysctl debug.acpi.suspend_bounce=1</span>
<span class=c># acpiconf -s 3</span></code></pre></div></div><div class=paragraph><p>Dieser Test emuliert einen Suspend/Resume-Zyklus für alle Geräte (ohne dass diese dabei wirklich in den Status <code>S3</code> wechseln). In vielen Fällen reicht dies bereits aus, um Probleme (beispielsweise verlorener Firmware-Status, Timeouts, hängende Geräte) zu entdecken. Beachten Sie dabei, dass das Gerät bei diesem Test nicht wirklich in den Status <code>S3</code> wechseln. Es kann also vorkommen, dass manche Geräte weiterhin mit Strom versorgt werden (dies wäre bei einem wirklichen Wechsel in den Status <code>S3</code> NICHT möglich. Andere Geräte werden normal weiterarbeiten, weil sie über keine Suspend/Resume-Funktionen verfügen.</p></div><div class=paragraph><p>Schwierigere Fälle können den Einsatz zusätzlicher Hardware (beispielsweise serielle Ports/Kabel für die Verbindung über eine serielle Konsole oder Firewire-Ports/Kabel für <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a>) sowie Kenntnisse im Bereich Kerneldebugging erforderlich machen.</p></div><div class=paragraph><p>Um das Problem einzugrenzen, entladen Sie soviele Treiber wie möglich. Wenn das funktioniert, laden Sie einen Treiber nach dem anderen, bis der Fehler wieder auftritt. Typischerweise verursachen binäre Treiber wie <span class=filename>nvidia.ko</span>, Grafiktreiber und USB-Treiber die meisten Fehler, hingegen laufen Ethernet-Treiber für gewöhnlich sehr zuverlässig. Wenn ein Treiber zuverlässig geladen und entfernt werden kann, können Sie den Vorgang automatisieren, indem Sie die entsprechenden Kommandos in <span class=filename>/etc/rc.suspend</span> und <span class=filename>/etc/rc.resume</span> einfügen. In den Dateien finden Sie ein deaktiviertes Beispiel, das einen Treiber lädt und wieder entfernt. Ist die Bildschirmanzeige bei der Wiederaufnahme des Betriebs gestört, setzen Sie die Variable <code>hw.acpi.reset_video</code> auf <code>1</code>. Versuchen Sie auch, die Variable <code>hw.acpi.sleep_delay</code> auf kürzere Zeitspannen zu setzen.</p></div><div class=paragraph><p>Die Suspend- und Resume-Funktionen können Sie auch auf einer neuen Linux®-Distribution mit ACPI testen. Wenn es mit Linux® funktioniert, liegt das Problem wahrscheinlich bei einem FreeBSD-Treiber. Es hilft uns, das Problem zu lösen, wenn Sie feststellen können, welcher Treiber das Problem verursacht. Beachten Sie bitte, dass die ACPI-Entwickler normalerweise keine anderen Treiber pflegen (beispielsweise Sound- oder ATA-Treiber). Es ist wohl das beste, die Ergebnisse der Fehlersuche an die Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT</a> und den Entwickler des Treibers zu schicken. Erfahrene Benutzer können versuchen, den Fehler in der Resume-Funktion zu finden, indem sie einige <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a>-Anweisungen in den Code des fehlerhaften Treibers einfügen.</p></div><div class=paragraph><p>Schließlich können Sie ACPI noch abschalten und stattdessen APM verwenden. Wenn die Suspend- und Resume-Funktionen mit APM funktionieren, sollten Sie besser APM verwenden (insbesondere mit alter Hardware von vor dem Jahr 2000). Die Hersteller benötigten einige Zeit, um ACPI korrekt zu implementieren, daher gibt es mit älterer Hardware oft ACPI-Probleme.</p></div></div><div class=sect3><h4 id=_systemhänger>29.2.3. Systemhänger<a class=anchor href=#_systemhänger></a></h4><div class=paragraph><p>Die meisten Systemhänger entstehen durch verlorene Interrupts oder einen Interrupt-Sturm. Probleme werden verursacht durch die Art, in der das BIOS Interrupts vor dem Systemstart konfiguriert, durch eine fehlerhafte APIC-Tabelle und durch die Zustellung des System-Control-Interrupts (SCI).</p></div><div class=paragraph><p>Anhand der Ausgabe des Befehls <code>vmstat -i</code> können Sie verlorene Interrupts von einem Interrupt-Sturm unterscheiden. Untersuchen Sie die Ausgabezeile, die <code>acpi0</code> enthält. Ein Interrupt-Sturm liegt vor, wenn der Zähler öfter als ein paar Mal pro Sekunde hochgezählt wird. Wenn sich das System aufgehangen hat, versuchen Sie mit der Tastenkombination <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Esc</kbd></span> in den Debugger DDB zu gelangen. Geben Sie dort den Befehl <code>show interrupts</code> ein.</p></div><div class=paragraph><p>Wenn Sie Interrupt-Probleme haben, ist es vorerst wohl am besten, APIC zu deaktivieren. Tragen Sie dazu die Zeile <code>hint.apic.0.disabled="1"</code> in <span class=filename>/boot/loader.conf</span> ein.</p></div></div><div class=sect3><h4 id=_abstürze_panics>29.2.4. Abstürze (Panics)<a class=anchor href=#_abstürze_panics></a></h4><div class=paragraph><p>Panics werden so schnell wie möglich behoben; mit ACPI kommt es aber selten dazu. Zuerst sollten Sie die Panic reproduzieren und dann versuchen einen backtrace (eine Rückverfolgung der Funktionsaufrufe) zu erstellen. Richten Sie dazu den DDB über die serielle Schnittstelle (siehe <a href=./#serialconsole-ddb>“DDB Debugger über die serielle Schnittstelle”</a>) oder eine gesonderte <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>-Partition ein. In DDB können Sie den backtrace mit dem Kommando <code>tr</code> erstellen. Falls Sie den backtrace vom Bildschirm abschreiben müssen, schreiben Sie bitte mindestens die fünf ersten und die fünf letzten Zeile der Ausgabe auf.</p></div><div class=paragraph><p>Versuchen Sie anschließend, das Problem durch einen Neustart ohne ACPI zu beseitigen. Wenn das funktioniert hat, können Sie versuchen, das verantwortliche ACPI-Subsystem durch Setzen der Variablen <code>debug.acpi.disable</code> herauszufinden. Die Hilfeseite <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> enthält dazu einige Beispiele.</p></div></div><div class=sect3><h4 id=_nach_einem_suspend_oder_einem_stopp_startet_das_system_wieder>29.2.5. Nach einem Suspend oder einem Stopp startet das System wieder<a class=anchor href=#_nach_einem_suspend_oder_einem_stopp_startet_das_system_wieder></a></h4><div class=paragraph><p>Setzen Sie zuerst <code>hw.acpi.disable_on_poweroff="0"</code> in <span class=filename>/boot/loader.conf</span>. Damit wird verhindert, dass ACPI während des Systemabschlusses die Bearbeitung verschiedener Ereignisse deaktiviert. Auf manchen Systemen muss die Variable den Wert <code>1</code> besitzen (die Voreinstellung). Normalerweise wird der unerwünschte Neustart des Systems durch Setzen dieser Variablen behoben.</p></div></div><div class=sect3><h4 id=ACPI-aslanddump>29.2.6. BIOS mit fehlerhaftem Bytecode<a class=anchor href=#ACPI-aslanddump></a></h4><div class=paragraph><p>Einige BIOS-Hersteller liefern einen fehlerhaften Bytecode aus. Dies erkennen Sie an Kernelmeldungen wie diesen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ACPI-1287: <span class=k>***</span> Error: Method execution failed <span class=o>[</span><span class=se>\\</span>_SB_.PCI0.LPC0.FIGD._STA] <span class=se>\\</span>
<span class=o>(</span>Node 0xc3f6d160<span class=o>)</span>, AE_NOT_FOUND</code></pre></div></div><div class=paragraph><p>Oft können Sie das Problem dadurch lösen, dass Sie eine aktuelle BIOS-Version einspielen. Die meisten Meldungen auf der Konsole sind harmlos, wenn aber beispielsweise der Batteriestatus falsch angezeigt wird, können Sie in den Meldungen nach Problemen suchen.</p></div></div></div><div class=sect2><h3 id=_die_voreingestellte_asl_überschreiben>29.3. Die voreingestellte ASL überschreiben<a class=anchor href=#_die_voreingestellte_asl_überschreiben></a></h3><div class=paragraph><p>Der BIOS-Bytecode, bekannt als ACPI Maschine Language (AML) wird aus der Sprache namens ACPI Source Language (ASL) übersetzt. Die AML ist in einer Tabelle, bekannt als Differentiated System Description Table (DSDT), abgelegt.</p></div><div class=paragraph><p>Es ist das Ziel von FreeBSD, dass ACPI ohne Eingriffe des Benutzers läuft. Zurzeit werden allerdings noch Abhilfen für Fehler der BIOS-Hersteller entwickelt. Der Microsoft®-Interpreter (<span class=filename>acpi.sys</span> und <span class=filename>acpiec.sys</span>) prüft die ASL nicht streng gegen den Standard. Daher reparieren BIOS-Hersteller, die ACPI nur unter Windows® testen, ihre ASL nicht. Die FreeBSD Entwickler hoffen, dass sie das vom Standard abweichende Verhalten des Microsoft®-Interpreters dokumentieren und in FreeBSD replizieren können. Dadurch müssen Benutzer ihre ASL nicht selbst reparieren.</p></div><div class=paragraph><p>Um bei der Fehlersuche zu helfen und das Problem möglicherweise zu beheben, kann eine Kopie der ASL gemacht werden. Dazu nutzen Sie <code>acpidump</code> zusammen mit <code>-t</code>, um den Inhalt der Tabelle anzuzeigen und <code>-d</code>, um die AML zu zerlegen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -td &gt; my.asl</span></code></pre></div></div><div class=paragraph><p>Einige AMLs gehen davon aus, dass der Anwender eine Windows®-Versionen benutzt. Versuchen Sie das Betriebssystem, das Sie in der ASL finden, in <span class=filename>/boot/loader.conf</span> anzugeben: <code>hw.acpi.osname=<em>"Windows 2009"</em></code>.</p></div><div class=paragraph><p>Manche Abhilfen erfordern eine Anpassung von <span class=filename>my.asl</span>. Wenn diese Datei bearbeitet wird, erstellen Sie die neue ASL mit dem folgenden Befehl. Warnung können meistens ignoriert werden, aber Fehler verhindern die ordnungsgemäße Funktion von ACPI.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl -f my.asl</span></code></pre></div></div><div class=paragraph><p>Die Option <code>-f</code> erzwingt das Erstellen der AML auch dann, wenn während der Übersetzung Fehler auftreten. Einige Fehler, wie fehlende Return-Anweisungen, werden automatisch vom FreeBSD Interpreter umgangen.</p></div><div class=paragraph><p>Die voreingestellte Ausgabedatei von <code>iasl</code> ist <span class=filename>DSDT.aml</span>. Wenn Sie diese Datei anstelle der fehlerhaften Kopie des BIOS laden wollen, editieren Sie <span class=filename>/boot/loader.conf</span> wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>acpi_dsdt_load=&#34;YES&#34;
acpi_dsdt_name=&#34;/boot/DSDT.aml&#34;</pre></div></div><div class=paragraph><p>Stellen Sie bitte sicher, dass sich <span class=filename>DSDT.aml</span> in <span class=filename>/boot</span> befindet und starten Sie das System neu. Wenn dadurch das Problem behoben wird, schicken Sie einen <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> der alten und der neuen ASL an <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI</a>, damit die Entwickler das Problem in <span class=filename>acpica</span> umgehen können.</p></div></div><div class=sect2><h3 id=ACPI-submitdebug>29.4. Abrufen und Einreichen von Informationen zur Fehlersuche<a class=anchor href=#ACPI-submitdebug></a></h3><div class=paragraph><p>Der ACPI-Treiber besitzt flexible Möglichkeiten zur Fehlersuche. Sie können sowohl die zu untersuchenden Subsysteme als auch die zu erzeugenden Ausgaben festlegen. Die zu untersuchenden Subsysteme werden als "layer" angegeben und in Komponenten (<code>ACPI_ALL_COMPONENTS</code>) und ACPI-Hardware (<code>ACPI_ALL_DRIVERS</code>) aufgeteilt. Welche Meldungen ausgegeben werden, wird über "level" gesteuert. Die Level reichen von von <code>ACPI_LV_ERROR</code> (es werden nur Fehler ausgegeben) bis zu <code>ACPI_LV_VERBOSE</code> (alles wird ausgegeben). Das Level ist eine Bitmaske, sodass verschiedene Stufen auf einmal (durch Leerzeichen getrennt) angegeben werden können. Die erzeugte Ausgabemenge passt vielleicht nicht in den Konsolenpuffer. In diesem Fall sollte die Ausgabe mithilfe einer seriellen Konsole gesichert werden. Die möglichen Werte für "layers" und "level" werden in <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> beschrieben.</p></div><div class=paragraph><p>Die Ausgaben zur Fehlersuche sind in der Voreinstellung nicht aktiviert. Wenn ACPI im Kernel enthalten ist, fügen Sie <code>options ACPI_DEBUG</code> zur Kernelkonfigurationsdatei hinzu. Sie können die Ausgaben zur Fehlersuche global aktivieren, indem Sie in der Datei <span class=filename>/etc/make.conf</span> die Zeile <code>ACPI_DEBUG=1</code> einfügen. Das Modul <span class=filename>acpi.ko</span> können Sie wie folgt neu übersetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/modules/acpi/acpi &amp;&amp; make clean &amp;&amp; make ACPI_DEBUG=1</span></code></pre></div></div><div class=paragraph><p>Kopieren Sie anschließend <span class=filename>acpi.ko</span> ins Verzeichnis <span class=filename>/boot/kernel</span>. In <span class=filename>/boot/loader.conf</span> stellen Sie "level" und "layer" ein. Das folgende Beispiel aktiviert die Ausgabe von Fehlern für alle ACPI-Komponenten und alle Hardwaretreiber:</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.layer=&#34;ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS&#34;
debug.acpi.level=&#34;ACPI_LV_ERROR&#34;</pre></div></div><div class=paragraph><p>Wenn ein Problem durch ein bestimmtes Ereignis, beispielsweise den Start nach einem Ruhezustand, hervorgerufen wird, können Sie die Einstellungen für "level" und "layer" auch mit dem Kommando <code>sysctl</code> vornehmen. In diesem Fall müssen Sie <span class=filename>/boot/loader.conf</span> nicht editieren. Auf der Kommandozeile geben Sie über <code>sysctl</code> dieselben Variablennamen wie in <span class=filename>/boot/loader.conf</span> an.</p></div><div class=paragraph><p>Sobald Sie die Fehlerinformationen gesammelt haben, schicken Sie diese an <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI</a>, sodass die Betreuer des FreeBSD-ACPI-Subsystems diese Informationen zur Analyse und für die Entwicklung einer Lösung verwenden können.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bevor Sie einen Fehlerbericht an diese Mailingliste einreichen, stellen Sie bitte sicher, dass das BIOS und die Firmware des Controllers aktuell sind.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn Sie einen Fehlerbericht einsenden, fügen Sie bitte die folgenden Informationen ein:</p></div><div class=ulist><ul><li><p>Beschreiben Sie den Fehler und alle Umstände, unter denen der Fehler auftritt. Geben Sie ebenfalls den Typ und das Modell Ihres Systems an. Wenn Sie einen neuen Fehler entdeckt haben, versuchen Sie möglichst genau zu beschreiben, wann der Fehler das erste Mal aufgetreten ist.</p></li><li><p>Die Ausgabe von <code>dmesg</code> nach der Eingabe von <code>boot -v</code>. Geben Sie auch alle Fehlermeldungen an, die erscheinen, wenn Sie den Fehler provozieren.</p></li><li><p>Die Ausgabe von <code>dmesg</code> nach der Eingabe von <code>boot -v</code> und mit deaktiviertem ACPI, wenn das Problem ohne ACPI nicht auftritt.</p></li><li><p>Die Ausgabe von <code>sysctl hw.acpi</code>. Dieses Kommando zeigt die vom System unterstützten ACPI-Funktionen an.</p></li><li><p>Die URL, unter der die ASL liegt. Schicken Sie bitte <em>nicht</em> die ASL an die Mailingliste, da die ASL sehr groß sein kann. Eine Kopie der ASL erstellen Sie mit dem nachstehenden Befehl:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -td &gt; name-system.asl</span></code></pre></div></div><div class=paragraph><p>Setzen Sie für <em>name</em> den Namen des Kontos und für <em>system</em> den Hersteller und das Modell des Systems ein. Zum Beispiel: <span class=filename>njl-FooCo6000.asl</span>.</p></div></li></ul></div><div class=paragraph><p>Obwohl die meisten Entwickler die Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT</a> lesen, sollten Sie Fehlerberichte an die Liste <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI</a> schicken. Seien Sie bitte geduldig; wir haben alle Arbeit außerhalb des Projekts. Wenn der Fehler nicht offensichtlich ist, bitten wir Sie vielleicht, einen offiziellen Fehlerbericht (PR) einzusenden. Geben Sie im Fehlerbericht bitte dieselben Informationen wie oben an. Mithilfe der PRs verfolgen und lösen wir Probleme. Senden Sie bitte keinen PR ein, ohne vorher den Fehlerbericht an die Liste <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI</a> zu senden. Es kann sein, dass der Fehler schon von jemand anderem gemeldet wurde.</p></div></div><div class=sect2><h3 id=ACPI-References>29.5. Referenzen<a class=anchor href=#ACPI-References></a></h3><div class=paragraph><p>Weitere Informationen über ACPI finden Sie hier:</p></div><div class=ulist><ul><li><p>Die FreeBSD ACPI Mailingliste (<a href=https://lists.freebsd.org/pipermail/freebsd-acpi/>https://lists.freebsd.org/pipermail/freebsd-acpi/</a>)</p></li><li><p>Die <a href=https://uefi.org/specifications#ACPI>ACPI Spezifikation</a></p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_thermal&amp;sektion=4&amp;format=html">acpi_thermal(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=iasl&amp;sektion=8&amp;format=html">iasl(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidb&amp;sektion=8&amp;format=html">acpidb(8)</a></p></li></ul></div></div></div></div><div class=sect1><h2 id=boot>Kapitel 30. FreeBSDs Bootvorgang<a class=anchor href=#boot></a></h2><div class=sectionbody><div class=sect2><h3 id=boot-synopsis>30.1. Übersicht<a class=anchor href=#boot-synopsis></a></h3><div class=paragraph><p>Das Starten des Computers und das Laden des Betriebssystems wird im Allgemeinen als "Bootstrap-Vorgang", oder als "Booten" bezeichnet. FreeBSDs Bootvorgang ermöglicht große Flexibilität, was das Anpassen dessen anbelangt, was passiert, wenn das System gestartet wird. Es kann zwischen verschiedenen Betriebssystemen, die auf demselben Computer installiert sind oder verschiedenen Versionen desselben Betriebssystems oder installierten Kernels gewählt werden.</p></div><div class=paragraph><p>Dieses Kapitel zeigt die zur Verfügung stehenden Konfigurationsmöglichkeiten und wie man den Bootvorgang anpasst. Dies schließt alles ein, bis der Kernel gestartet worden ist, der dann alle Geräte gefunden hat und <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> gestartet hat. Dies passiert, wenn die Farbe des Textes während des Bootvorgangs von weiß zu grau wechselt.</p></div><div class=paragraph><p>Dieses Kapitel informiert über folgende Punkte:</p></div><div class=ulist><ul><li><p>Die Komponenten des FreeBSD-Bootvorgangs und deren Interaktion.</p></li><li><p>Die Optionen, mit denen der FreeBSD-Bootvorgang gesteuert werden kann.</p></li><li><p>Wie ein angepasster Willkommensbildschirm beim Booten konfiguriert wird.</p></li><li><p>Wie Geräte mit <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a> konfiguriert werden.</p></li><li><p>Wie das System in den Single-User-Modus und in den Mehrbenutzer-Modus gestartet wird und wie ein FreeBSD-System ordnungsgemäß heruntergefahren wird.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dieses Kapitel erklärt den Bootvorgang von FreeBSD auf Intel x86- und amd64-Plattformen.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=boot-introduction>30.2. FreeBSDs Bootvorgang<a class=anchor href=#boot-introduction></a></h3><div class=paragraph><p>Wenn der Computer eingeschaltet wird und das Betriebssystem gestartet werden soll, entsteht ein interessantes Dilemma, denn der Computer weiß per Definition nicht, wie er irgendetwas tut, bis das Betriebssystem gestartet wurde. Das schließt das Starten von Programmen, die sich auf der Festplatte befinden, ein. Wenn der Computer kein Programm von der Festplatte starten kann, sich das Betriebssystem aber genau dort befindet, wie wird es dann gestartet?</p></div><div class=paragraph><p>Dieses Problem ähnelt einer Geschichte des Barons von Münchhausen. Dort war eine Person in einen Sumpf gefallen und hat sich selbst an den Riemen seiner Stiefel (engl. bootstrap) herausgezogen. In den jungen Jahren des Computerzeitalters wurde mit dem Begriff Bootstrap dann die Technik das Betriebssystem zu laden bezeichnet. Seither wurde es mit "booten" abgekürzt.</p></div><div class=paragraph><p>Auf x86-Plattformen ist das Basic Input/Output System (BIOS) dafür verantwortlich, das Betriebssystem zu laden. Das BIOS liest den Master Boot Record (MBR) aus, der sich an einer bestimmten Stelle auf der Festplatte befinden muss. Das BIOS kann den MBR selbstständig laden und ausführen und geht davon aus, dass dieser die restlichen Dinge, die für das Laden des Betriebssystems notwendig sind, selbst oder mit Hilfe des BIOS erledigen kann.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD ermöglicht das Booten sowohl über den alten MBR-Standard, als auch über die neuere GUID-Partitionstabelle (GPT). GPT-Partitionen finden sich häufig auf Systemen mit dem <em>Unified Extensible Firmware Interface</em> (UEFI). FreeBSD kann allerdings mit Hilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=gptboot&amp;sektion=8&amp;format=html">gptboot(8)</a> auch GPT-Partitionen über das alte BIOS booten. An der Unterstützung für ein direktes Booten über UEFI wird derzeit gearbeitet.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Der Code innerhalb des MBRs wird für gewöhnlich als <em>Boot-Manager</em> bezeichnet, insbesondere, wenn eine Interaktion mit dem Anwender stattfindet. Der Boot-Manager verwaltet zusätzlichen Code im ersten <em>Track</em> der Platte oder des Dateisystems. Zu den bekanntesten Boot-Managern gehören boot0, der auch als Boot Easy bekannte Standard-Boot-Manager von FreeBSD, sowie Grub, welches in vielen Linux®-Distributionen verwendet wird.</p></div><div class=paragraph><p>Falls nur ein Betriebssystem installiert ist, sucht der MBR nach dem ersten bootbaren Slice (das dabei als <em>active</em> gekennzeichnet ist) auf dem Laufwerk und führt den dort vorhandenen Code aus, um das restliche Betriebssystem zu laden. Wenn mehrere Betriebssysteme installiert sind, kann ein anderer Boot-Manager installiert werden, der eine Liste der verfügbaren Betriebssysteme anzeigt, so dass der Benutzer wählen kann, welches Betriebssystem er booten möchte.</p></div><div class=paragraph><p>Das restliche FreeBSD-Bootstrap-System ist in drei Phasen unterteilt. Die erste Phase besitzt gerade genug Funktionalität um den Computer in einen bestimmten Status zu verhelfen und die zweite Phase zu starten. Die zweite Phase führt ein wenig mehr Operationen durch und startet schließlich die dritte Phase, die das Laden des Betriebssystems abschließt. Der ganze Prozess wird in drei Phasen durchgeführt, weil der MBR die Größe der Programme, die in Phase eins und zwei ausgeführt werden, limitiert. Das Verketten der durchzuführenden Aufgaben ermöglicht es FreeBSD, ein sehr flexibles Ladeprogramm zu besitzen.</p></div><div class=paragraph><p>Als nächstes wird der Kernel gestartet, der zunächst nach Geräten sucht und sie für den Gebrauch initialisiert. Nach dem Booten des Kernels übergibt dieser die Kontrolle an den Benutzer Prozess <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, der erst sicherstellt, dass alle Laufwerke benutzbar sind und die Ressourcen Konfiguration auf Benutzer Ebene startet. Diese wiederum mountet Dateisysteme, macht die Netzwerkkarten für die Kommunikation mit dem Netzwerk bereit und startet alle Prozesse, die konfiguriert wurden, um beim Hochfahren gestartet zu werden.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt die einzelnen Phasen und wie sie mit dem FreeBSD-Bootvorgang interagieren.</p></div><div class=sect3><h4 id=boot-boot0>30.2.1. Der Boot-Manager<a class=anchor href=#boot-boot0></a></h4><div class=paragraph><p>Der Boot-Manager Code im MBR wird manchmal auch als <em>stage zero</em> des Boot-Prozesses bezeichnet. In der Voreinstellung verwendet FreeBSD den boot0 Boot-Manager.</p></div><div class=paragraph><p>Der vom FreeBSD-Installationsprogramm in der Voreinstelung installierte MBR basiert auf <span class=filename>/boot/boot0</span>. Die Größe und Leistungsfähigkeit von boot0 ist auf 446 Bytes beschränkt, weil der restliche Platz für die Partitionstabelle sowie den <code>0x55AA</code>-Identifier am Ende des MBRs benötigt wird. Wenn boot0 und mehrere Betriebssysteme installiert sind, wird beim Starten des Computers eine Anzeige ähnlich der folgenden zu sehen sein:</p></div><div id=boot-boot0-example class=exampleblock><div class=title>Beispiel 27. <span class=filename>boot0</span>-Screenshot</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>F1 Win
F2 FreeBSD

Default: F2</code></pre></div></div></div></div><div class=paragraph><p>Diverse Betriebssysteme überschreiben den existierenden MBR, wenn sie nach FreeBSD installiert werden. Falls dies passiert, kann mit folgendem Kommando der momentane MBR durch den FreeBSD-MBR ersetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdisk -B -b /boot/boot0 Gerät</span></code></pre></div></div><div class=paragraph><p>Bei <em>Gerät</em> handelt es sich um das Gerät, von dem gebootet wird, also beispielsweise <span class=filename>ad0</span> für die erste IDE-Festplatte, <span class=filename>ad2</span> für die erste IDE-Festplatte am zweiten IDE-Controller, <span class=filename>da0</span> für die erste SCSI-Festplatte. Um eine angepasste Konfiguration des MBR zu erstellen, lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a>.</p></div></div><div class=sect3><h4 id=boot-boot1>30.2.2. Phase Eins und Phase Zwei<a class=anchor href=#boot-boot1></a></h4><div class=paragraph><p>Im Prinzip sind die erste und die zweite Phase Teile desselben Programms, im selben Bereich auf der Festplatte. Aufgrund von Speicherplatz-Beschränkungen wurden sie in zwei Teile aufgeteilt, welche jedoch immer zusammen installiert werden. Beide werden entweder vom FreeBSD-Installationsprogramm oder <code>bsdlabel</code> aus der kombinierten <span class=filename>/boot/boot</span> kopiert.</p></div><div class=paragraph><p>Beide Phasen befinden sich außerhalb des Dateisystems im Bootsektor des Boot-Slices, wo boot0 oder ein anderer Boot-Manager ein Programm erwarten, das den weiteren Bootvorgang durchführen kann.</p></div><div class=paragraph><p>Die erste Phase, <span class=filename>boot1</span>, ist ein sehr einfaches Programm, da es nur 512 Bytes groß sein darf. Es besitzt gerade genug Funktionalität, um FreeBSDs <em>bsdlabel</em>, das Informationen über den Slice enthält, auszulesen, und um <span class=filename>boot2</span> zu finden und auszuführen.</p></div><div class=paragraph><p>Die zweite Phase, <span class=filename>boot2</span>, ist schon ein wenig umfangreicher und besitzt genügend Funktionalität, um Dateien in FreeBSDs Dateisystem zu finden. Es kann eine einfache Schnittstelle bereitstellen, die es ermöglicht, den zu ladenden Kernel oder Loader auszuwählen. Es lädt den loader, der einen weitaus größeren Funktionsumfang bietet und eine Konfigurationsdatei zur Verfügung stellt. Wenn der Boot-Prozess während der zweiten Phase unterbrochen wird, erscheint der folgende Bildschrim:</p></div><div id=boot-boot2-example class=exampleblock><div class=title>Beispiel 28. <span class=filename>boot2</span>-Screenshot</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div></div></div><div class=paragraph><p>Um das installierte <span class=filename>boot1</span> und <span class=filename>boot2</span> zu ersetzen, benutzen Sie <code>bsdlabel</code>, wobei <em>diskslice</em> das Laufwerk und die Slice darstellt, von dem gebootet wird, beispielsweise <span class=filename>ad0s1</span> für die erste Slice auf der ersten IDE-Festplatte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -B diskslice</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Wenn man nur den Festplatten-Namen benutzt, beispielsweise <span class=filename>ad0</span>, wird <code>bsdlabel</code> eine "dangerously dedicated disk" erstellen, ohne Slices. Das ist ein Zustand, den man meistens nicht hervorrufen möchte. Aus diesem Grund sollte man das <em>diskslice</em> noch einmal prüfen, bevor <kbd>Return</kbd> gedrückt wird.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-loader>30.2.3. Phase Drei<a class=anchor href=#boot-loader></a></h4><div class=paragraph><p>Der loader ist der letzte von drei Schritten im Bootstrap-Prozess. Er kann im Dateisystem normalerweise als <span class=filename>/boot/loader</span> gefunden werden.</p></div><div class=paragraph><p>Der loader soll eine interaktive Konfigurations-Schnittstelle mit eingebauten Befehlssatz sein, ergänzt durch einen umfangreichen Interpreter mit einem komplexeren Befehlssatz.</p></div><div class=paragraph><p>Der loader sucht während seiner Initialisierung nach Konsolen und Laufwerken, findet heraus, von welchem Laufwerk er gerade bootet, und setzt dementsprechend bestimmte Variablen. Dann wird ein Interpreter gestartet, der Befehle interaktiv oder von einem Skript empfangen kann.</p></div><div class=paragraph><p>Danach liest der loader <span class=filename>/boot/loader.rc</span>, welche ihn standardmäßig anweist <span class=filename>/boot/defaults/loader.conf</span> zu lesen, wo sinnvolle Standardeinstellungen für diverse Variablen festgelegt werden und wiederum <span class=filename>/boot/loader.conf</span> für lokale Änderungen an diesen Variablen ausgelesen wird. Anschließend arbeitet dann <span class=filename>loader.rc</span> entsprechend dieser Variablen und lädt die ausgewählten Module und den gewünschten Kernel.</p></div><div class=paragraph><p>In der Voreinstellung wartet der loader 10 Sekunden lang auf eine Tastatureingabe und bootet den Kernel, falls keine Taste betätigt wurde. Falls doch eine Taste betätigt wurde wird dem Benutzer eine Eingabeaufforderung angezeigt. Sie nimmt einen Befehlssatz entgegen, der es dem Benutzer erlaubt, Änderungen an Variablen vorzunehmen, Module zu laden, alle Module zu entladen oder schließlich zu booten oder neu zu booten.</p></div><table id=boot-loader-commands class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 9. Die eingebauten Befehle des Loaders</caption><col style=width:20%><col style=width:80%><thead><tr><th class="tableblock halign-left valign-top">Variable</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>autoboot <code><em>Sekunden</em></code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Es wird mit dem Booten des Kernels fortgefahren, falls keine Taste in der gegebenen Zeitspanne betätigt wurde. In der gegebenen Zeitspanne, Vorgabe sind 10 Sekunden, wird ein Countdown angezeigt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>boot [<code>-Optionen</code>] [<code>Kernelname</code>]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bewirkt das sofortige Booten des Kernels mit allen gegebenen Optionen, oder dem angegebenen Kernelnamen. Das übergeben eines Kernelnamens ist nur nach einem <code>unload</code> anwendbar, andernfalls wird der zuvor verwendete Kernel benutzt. Wenn nicht der vollständige Pfad für <em>Kernelname</em> angegeben wird, dann sucht der Loader den Kernel unter <span class=filename>/boot/kernel</span> und <span class=filename>/boot/modules</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>boot-conf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bewirkt die automatische Konfiguration der Module, abhängig von den entsprechenden Variablen (üblicherweise <code>kernel</code>). Dies nur dann sinnvoll, wenn zuvor <code>unload</code> benutzt wurde.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>help [<code><em>Thema</em></code>]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zeigt die Hilfe an, die zuvor aus der Datei <span class=filename>/boot/loader.help</span> gelesen wird. Falls <code>index</code> als Thema angegeben wird, wird die Liste der zur Verfügung stehenden Hilfe-Themen angezeigt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>include <code><em>Dateiname</em></code> …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das Einlesen und Interpretieren der angegebenen Datei geschieht Zeile für Zeile und wird im Falle eines Fehlers umgehend unterbrochen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>load [<code>-t <em>Typ</em></code>] <em>Dateiname</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lädt den Kernel, das Kernel-Modul, oder die Datei des angegebenen Typs. Argumente, die auf <em>Dateiname</em> folgen, werden der Datei übergeben. Wenn nicht der vollständige Pfad für <em>Dateiname</em> angegeben wird, dann sucht der Loader die Datei unter <span class=filename>/boot/kernel</span> und <span class=filename>/boot/modules</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ls [<code>-l</code>] [<code><em>Pfad</em></code>]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Listet die Dateien im angegebenen Pfad auf, oder das Root-Verzeichnis, falls kein Pfad angegeben wurde. Die Option <code>-l</code> bewirkt, dass die Dateigrößen ebenfalls angezeigt werden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lsdev [<code>-v</code>]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Listet alle Geräte auf, für die Module geladen werden können. Die Option <code>-v</code> bewirkt eine ausführliche Ausgabe.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lsmod [<code>-v</code>]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Listet alle geladenen Module auf. Die Option <code>-v</code> bewirkt eine ausführliche Ausgabe.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>more <code><em>Dateiname</em></code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zeigt den Dateinhalt der angegebenen Datei an, wobei eine Pause alle <code>LINES</code> Zeilen gemacht wird.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>reboot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bewirkt einen umgehenden Neustart des Systems.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>set <code><em>Variable</em></code>, set <code><em>Variable=Wert</em></code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Setzt die angegebenen Umgebungsvariablen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>unload</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Entlädt sämtliche geladenen Module.</p></td></tr></tbody></table><div class=paragraph><p>Hier ein paar praktische Beispiele für die Bedienung des Loaders. Um den gewöhnlichen Kernel im Single-User Modus zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nt>-s</span></code></pre></div></div><div class=paragraph><p>Um alle gewöhnlichen Kernelmodule zu entladen und dann den alten, oder einen anderen Kernel zu laden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>unload
/pfad/zur/kerneldatei</code></pre></div></div><div class=paragraph><p>Verwenden Sie <span class=filename>/boot/GENERIC/kernel</span>, um auf den allgemeinen Kernel zu verweisen, der bei jeder Installation dabei ist. <span class=filename>/boot/kernel.old/kernel</span> hingegen bezeichnet den Kernel, der vor dem System-Upgrade installiert war.</p></div><div class=paragraph><p>Der folgende Befehl lädt die gewöhnlichen Module mit einem anderen Kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>unload
<span class=nb>set </span><span class=nv>kernel</span><span class=o>=</span><span class=s2>&#34;meinkernel&#34;</span>
boot-conf</code></pre></div></div><div class=paragraph><p>Um ein automatisiertes Kernelkonfigurations-Skript zu laden, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> load <span class=nt>-t</span> userconfig_script /boot/kernel.conf</code></pre></div></div></div><div class=sect3><h4 id=boot-init>30.2.4. Die letzte Phase<a class=anchor href=#boot-init></a></h4><div class=paragraph><p>Sobald der Kernel einmal geladen ist, entweder durch den loader oder durch boot2, welches den Loader umgeht, dann überprüft er vorhandene Boot-Flags und passt sein Verhalten nach Bedarf an. In <a href=#boot-kernel>Interaktion mit dem Kernel während des Bootens</a> sind die gebräuchlichsten Boot-Flags aufgelistet. Informationen zu den anderen Boot-Flags finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a>.</p></div><table id=boot-kernel class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 10. Interaktion mit dem Kernel während des Bootens</caption><col style=width:20%><col style=width:80%><thead><tr><th class="tableblock halign-left valign-top">Option</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bewirkt, dass während der Kernel-Initialisierung gefragt wird, welches Gerät als Root-Dateisystem eingehängt werden soll.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-C</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das Root-Dateisystem wird von CD-ROM gebootet.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-s</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bootet in den Single-User Modus</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-v</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zeigt mehr Informationen während des Starten des Kernels an.</p></td></tr></tbody></table><div class=paragraph><p>Nachdem der Kernel den Bootprozess abgeschlossen hat, übergibt er die Kontrolle an den Benutzer-Prozess <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>. Dieses Programm befindet sich in <span class=filename>/sbin/init</span>, oder dem Pfad, der durch die Variable <code>init_path</code> im <code>loader</code> spezifiziert wird.</p></div><div class=paragraph><p>Der automatische Reboot-Vorgang stellt sicher, dass alle Dateisysteme des Systems konsistent sind. Falls dies nicht der Fall ist und die Inkonsistenz des UFS-Dateisystems nicht durch <code>fsck</code> behebbar ist, schaltet <code>init</code> das System in den Single-User-Modus, damit der Systemadministrator sich des Problems annehmen kann. Andernfalls startet das System in den Mehrbenutzermodus.</p></div><div class=sect4><h5 id=boot-singleuser>30.2.4.1. Der Single-User Modus<a class=anchor href=#boot-singleuser></a></h5><div class=paragraph><p>Der Wechsel in den Single-User Modus kann beim Booten durch die Option <code>-s</code>, oder das Setzen der Variable <code>boot_single</code> in loader erreicht werden. Zudem kann er auch im Mehrbenutzermodus über den Befehl <code>shutdown now</code> erreicht werden. Der Single-User Modus beginnt mit dieser Meldung:</p></div><div class="literalblock programlisting"><div class=content><pre>Enter full path of shell or RETURN for /bin/sh:</pre></div></div><div class=paragraph><p>Wenn Sie die Eingabetaste drücken, wird das System die Bourne Shell starten. Falls Sie eine andere Shell starten möchten, geben Sie den vollständigen Pfad zur Shell ein.</p></div><div class=paragraph><p>Der Single-User Modus wird normalerweise zur Reparatur verwendet, beispielsweise wenn das System aufgrund eines inkonsistenten Dateisystems oder einem Fehler in einer Konfigurationsdatei nicht bootet. Der Modus wird auch verwendet, um das Passwort von <code>root</code> zurückzusetzen, falls dieses nicht mehr bekannt ist. Dies alles ist möglich, da der Single-User Modus vollen Zugriff auf das lokale System und die Konfigurationsdateien gewährt. Einen Zugang zum Netzwerk bietet dieser Modus allerdings nicht.</p></div><div class=paragraph><p>Obwohl der Single-User Modus für Reparaturen am System sehr nützlich ist, stellt es ein Sicherheitsrisiko dar, wenn sich das System an einem physisch unsicheren Standort befindet. In der Voreinstellung hat jeder Benutzer, der physischen Zugriff auf ein System erlangen kann, volle Kontrolle über das System, nachdem in den Single-User Modus gebootet wurde.</p></div><div class=paragraph><p>Falls die System-Konsole (<code>console</code>) in <span class=filename>/etc/ttys</span> auf <code>insecure</code> (dt.: unsicher) gesetzt ist, fordert das System zur Eingabe des <code>root</code> Passworts auf, bevor es den Single-User Modus aktiviert. Dadurch gewinnen Sie zwar ein gewisses Maß an Sicherheit, aber Sie können dann nicht mehr das Passwort von <code>root</code> zurücksetzen, falls es nicht bekannt ist.</p></div><div id=boot-insecure-console class=exampleblock><div class=title>Beispiel 29. Auf insecure gesetzte Konsole in <span class=filename>/etc/ttys</span></div><div class=content><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</pre></div></div></div></div><div class=paragraph><p>Eine Konsole sollte auf <code>insecure</code> gesetzt sein, wenn die physikalische Sicherheit der Konsole nicht gegeben ist und sichergestellt werden soll, dass nur Personen, die das Passwort von <code>root</code> kennen, den Single-User Modus benutzen können.</p></div></div><div class=sect4><h5 id=boot-multiuser>30.2.4.2. Mehrbenutzermodus<a class=anchor href=#boot-multiuser></a></h5><div class=paragraph><p>Stellt init fest, dass das Dateisystem in Ordnung ist, oder der Benutzer den Single-User-Modus mit <code>exit</code> beendet, schaltet das System in den Mehrbenutzermodus, in dem dann die Ressourcen Konfiguration des Systems gestartet wird.</p></div><div class=paragraph><p>Das Ressourcen Konfigurationssystem (engl. resource configuration, rc) liest seine Standardkonfiguration von <span class=filename>/etc/defaults/rc.conf</span> und System-spezifische Details von <span class=filename>/etc/rc.conf</span>. Dann mountet es die Dateisysteme gemäß <span class=filename>/etc/fstab</span>, startet die Netzwerkdienste, diverse System Daemons und führt schließlich die Start-Skripten der lokal installierten Anwendungen aus.</p></div><div class=paragraph><p>Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> und ebenso die Skripte in <span class=filename>/etc/rc.d</span>, um mehr über das Ressourcen Konfigurationssystem zu erfahren.</p></div></div></div></div><div class=sect2><h3 id=boot-splash>30.3. Willkommensbildschirme während des Bootvorgangs konfigurieren<a class=anchor href=#boot-splash></a></h3><div class=paragraph><p>Wenn ein FreeBSD-System startet, gibt es normalerweise eine Reihe von Meldungen auf der Konsole aus. Ein Willkommensbildschirm erzeugt einen alternativen Boot-Bildschirm, der alle Bootmeldungen und Meldungen über startende Dienste versteckt. Ein paar Meldungen des Bootloaders, einschließlich das Menü mit den Bootoptionen und dem Warte-Countdown werden dennoch zur Bootzeit angezeigt, auch wenn der Willkommensbildschirm aktiviert ist. Der Willkommensbildschirm kann während des Bootvorgangs mit einem beliebigen Tastendruck ausgeschaltet werden.</p></div><div class=paragraph><p>Es existieren zwei grundlegende Umgebungen in FreeBSD. Die erste ist die altbekannte, auf virtuellen Konsolen basierte Kommandozeile. Nachdem das System den Bootvorgang abgeschlossen hat, wird ein Anmeldebildschirm auf der Konsole anzeigt. Die zweite Umgebung ist eine konfigurierte, graphische Umgebung. <a href=./#x11>Das X-Window-System</a> enthält weitere Informationen zur Installation und Konfiguration eines graphischen Display-Managers und Login-Managers.</p></div><div class=paragraph><p>Der Willkommensbildschirm ist standardmäßig so eingestellt, dass er als Bildschirmschoner verwendet wird. Nach einer bestimmten Zeit der Untätigkeit wird der Willkommensbildschirm angezeigt und wechselt durch verschiedene Stufen der Intensität von hell zu einem sehr dunklen Bild und wieder zurück. Das Verhalten des Willkommensbildschirms kann durch hinzufügen einer <code>saver=</code>-Zeile in <span class=filename>/etc/rc.conf</span> geändert werden. Es gibt mehrere eingebaute Bildschirmschoner, die in <a href="https://man.freebsd.org/cgi/man.cgi?query=splash&amp;sektion=4&amp;format=html">splash(4)</a> beschrieben werden. Die <code>saver=</code>-Option bezieht sich nur auf virtuelle Konsolen und hat keinen Effekt bei grafischen Display-Managern.</p></div><div class=paragraph><p>Durch die Installation des Ports oder Pakets <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bsd-splash-changer/>sysutils/bsd-splash-changer</a> werden Willkommensbildschirme von einer zufällig ausgewählten Sammlung von Bildern bei jedem Neustart angezeigt. Die Willkommensbildschirm-Funktionalität unterstützt 256-Farben in den Formaten Bitmap (<span class=filename>.bmp</span>), ZSoft PCX (<span class=filename>.pcx</span>) oder TheDraw (<span class=filename>.bin</span>). Die Willkommensbildschirm-Datei <span class=filename>.bmp</span>, <span class=filename>.pcx</span> oder <span class=filename>.bin</span> muss in der Root-Partition, beispielsweise unterhalb von <span class=filename>/boot</span> abgelegt werden. Willkommensbildschirm-Dateien dürfen eine Auflösung von 320 mal 200 Pixeln oder weniger besitzen, damit Standard-VGA Geräte damit arbeiten können. Für eine Standard-Auflösung von 256-Farben, 320 mal 200 Pixel oder weniger, fügen Sie folgende Zeilen in <span class=filename>/boot/loader.conf</span> ein und ersetzen Sie <em>splash.bmp</em> mit dem Namen der Bitmap-Datei:</p></div><div class="literalblock programlisting"><div class=content><pre>splash_bmp_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.bmp&#34;</pre></div></div><div class=paragraph><p>Wenn Sie anstelle der Bitmap-Datei eine PCX-Datei verwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>splash_pcx_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.pcx&#34;</pre></div></div><div class=paragraph><p>Für ASCII-Art im <a href=https://en.wikipedia.org/wiki/TheDraw>TheDraw</a>-Format schreiben Sie:</p></div><div class="literalblock programlisting"><div class=content><pre>splash_txt=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.bin&#34;</pre></div></div><div class=paragraph><p>Weitere interessante Optionen für <span class=filename>loader.conf</span> sind:</p></div><div class=dlist><dl><dt class=hdlist1><code>beastie_disable="YES"</code></dt><dd><p>Diese Option verhindert die Anzeige des Menüs mit den Bootoptionen, aber der Countdown ist immer noch aktiv. Selbst wenn das Bootmenü deaktiviert ist, kann während des Countdowns eine der korrespondierenden Optionen ausgewählt werden.</p></dd><dt class=hdlist1><code>loader_logo="beastie"</code></dt><dd><p>Dies ersetzt die Standardanzeige des Wortes "FreeBSD". Stattdessen wird auf der rechten Seite des Bootmenüs das bunte Beastie-Logo angezeigt.</p></dd></dl></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=splash&amp;sektion=4&amp;format=html">splash(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=vga&amp;sektion=4&amp;format=html">vga(4)</a>.</p></div></div><div class=sect2><h3 id=device-hints>30.4. Konfiguration von Geräten<a class=anchor href=#device-hints></a></h3><div class=paragraph><p>Der Boot-Loader liest während des Systemstarts die Datei <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>, die Variablen, auch "device hints" genannt, zur Konfiguration von Geräten enthält.</p></div><div class=paragraph><p>Die Variablen können auch mit Kommandos in Phase 3 des Boot-Loaders, wie in <a href=#boot-loader>Phase Drei</a> beschrieben, bearbeitet werden. Neue Variablen werden mit <code>set</code> gesetzt, <code>unset</code> löscht schon definierte Variablen und <code>show</code> zeigt Variablen an. Variablen aus <span class=filename>/boot/device.hints</span> können zu diesem Zeitpunkt überschrieben werden. Die hier durchgeführten Änderungen sind nicht permanent und beim nächsten Systemstart nicht mehr gültig.</p></div><div class=paragraph><p>Nach dem Systemstart können alle Variablen mit <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a> angezeigt werden.</p></div><div class=paragraph><p>Pro Zeile enthält <span class=filename>/boot/device.hints</span> eine Variable. Kommentare werden durch <code>#</code> eingeleitet. Die verwendete Syntax lautet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> hint.driver.unit.keyword<span class=o>=</span><span class=s2>&#34;value&#34;</span></code></pre></div></div><div class=paragraph><p>Der Boot-Loader verwendet die nachstehende Syntax:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set </span>hint.driver.unit.keyword<span class=o>=</span>value</code></pre></div></div><div class=paragraph><p>Der Gerätetreiber wird mit <code>driver</code>, die Nummer des Geräts mit <code>unit</code> angegeben. <code>keyword</code> ist eine Option aus der folgenden Liste:</p></div><div class=ulist><ul><li><p><code>at</code>: Gibt den Bus, auf dem sich das Gerät befindet, an.</p></li><li><p><code>port</code>: Die Startadresse des I/O-Bereichs.</p></li><li><p><code>irq</code>: Gibt die zu verwendende Unterbrechungsanforderung (IRQ) an.</p></li><li><p><code>drq</code>: Die Nummer des DMA Kanals.</p></li><li><p><code>maddr</code>: Die physikalische Speicheradresse des Geräts.</p></li><li><p><code>flags</code>: Setzt verschiedene gerätespezifische Optionen.</p></li><li><p><code>disabled</code>: Deaktiviert das Gerät, wenn der Wert auf <code>1</code> gesetzt wird.</p></li></ul></div><div class=paragraph><p>Ein Gerätetreiber kann mehr Optionen, als die hier beschriebenen, besitzen oder benötigen. Es wird empfohlen, die Optionen in der Manualpage des Treibers nachzuschlagen. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>.</p></div></div><div class=sect2><h3 id=boot-shutdown>30.5. Der Shutdown-Vorgang<a class=anchor href=#boot-shutdown></a></h3><div class=paragraph><p>Im Falle eines regulären Herunterfahrens durch <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> führt <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> <span class=filename>/etc/rc.shutdown</span> aus, sendet dann sämtlichen Prozessen ein <code>TERM</code> Signal und schließlich ein <code>KILL</code> Signal an alle Prozesse, die sich nicht rechtzeitig beendet haben.</p></div><div class=paragraph><p>FreeBSD-Systeme, die Energieverwaltungsfunktionen unterstützen, können mit <code>shutdown -p now</code> ausgeschaltet werden. Zum Neustart des Systems wird <code>shutdown -r now</code> benutzt. Das Kommando <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> kann nur von <code>root</code> oder Mitgliedern der Gruppe <code>operator</code> benutzt werden. Man kann auch <a href="https://man.freebsd.org/cgi/man.cgi?query=halt&amp;sektion=8&amp;format=html">halt(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=reboot&amp;sektion=8&amp;format=html">reboot(8)</a> verwenden. Weitere Informationen finden Sie in den Hilfeseiten der drei Kommandos.</p></div><div class=paragraph><p>Das Ändern der Gruppenmitgliedschaft wird in <a href=./#users-synopsis>“Benutzer und grundlegende Account-Verwaltung”</a> beschrieben.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Energieverwaltungsfunktionen erfordern, dass die Unterstützung für <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> als Modul geladen, oder statisch in einen angepassten Kernel kompiliert wird.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=security>Kapitel 31. Sicherheit<a class=anchor href=#security></a></h2><div class=sectionbody><div class=sect2><h3 id=security-synopsis>31.1. Übersicht<a class=anchor href=#security-synopsis></a></h3><div class=paragraph><p>Sicherheit, ob nun physisch oder virtuell, ist ein so breit gefächertes Thema, dass sich eine ganze Industrie darum gebildet hat. Es wurden bereits hunderte Verfahren zur Sicherung von Systemen und Netzwerken verfasst, und als Benutzer von FreeBSD ist es unumgänglich zu verstehen, wie Sie sich gegen Angreifer und Eindringlinge schützen können.</p></div><div class=paragraph><p>In diesem Kapitel werden einige Grundlagen und Techniken diskutiert. Ein FreeBSD-System implementiert Sicherheit in mehreren Schichten, und viele weitere Programme von Drittanbietern können zur Verbesserung der Sicherheit beitragen.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie:</p></div><div class=ulist><ul><li><p>Grundlegende auf FreeBSD bezogene Sicherheitsaspekte kennen.</p></li><li><p>Die verschiedenen Verschlüsselungsmechanismen von FreeBSD kennen.</p></li><li><p>Wissen, wie Sie ein Einmalpasswörter zur Authentifizierung verwenden.</p></li><li><p>TCP Wrapper für <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> einrichten können.</p></li><li><p>Wissen, wie Sie Kerberos unter FreeBSD einrichten.</p></li><li><p>Wissen, wie Sie IPsec konfigurieren und ein VPN einrichten.</p></li><li><p>Wissen, wie Sie OpenSSH unter FreeBSD konfigurieren und benutzen.</p></li><li><p>Wissen, wie Sie ACLs für Dateisysteme benutzen.</p></li><li><p>pkg anwenden können, um Softwarepakete aus der Ports-Sammlung auf bekannte Sicherheitslücken hin zu überprüfen.</p></li><li><p>Mit FreeBSD-Sicherheitshinweisen umgehen können.</p></li><li><p>Eine Vorstellung davon haben, was Prozessüberwachung (Process Accounting) ist und wie Sie diese Funktion unter FreeBSD aktivieren können.</p></li><li><p>Wissen, wie Sie Login-Klassen oder die Ressourcen-Datenbank benutzen, um die Ressourcen für Benutzer zu steuern.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie</p></div><div class=ulist><ul><li><p>Grundlegende Konzepte von FreeBSD und dem Internet verstehen.</p></li></ul></div><div class=paragraph><p>Dieses Buch behandelt weitere Sicherheitsthemen. Beispielsweise werden verbindliche Zugriffskontrollen im <a href=./#mac>Verbindliche Zugriffskontrolle</a> und Firewalls im <a href=./#firewalls>Firewalls</a> besprochen.</p></div></div><div class=sect2><h3 id=security-intro>31.2. Einführung<a class=anchor href=#security-intro></a></h3><div class=paragraph><p>Sicherheit ist die Verantwortung eines jeden Einzelnen. Ein schwacher Einstiegspunkt in einem System kann einem Eindringling Zugriff auf wichtige Informationen verschaffen, was sich verheerend auf das gesamte Netzwerk auswirken kann. Eines der Grundprinzipien der Informationssicherheit sind die Vertraulichkeit, Integrität und Verfügbarkeit von Informationssystemen.</p></div><div class=paragraph><p>Diese Grundprinzipien sind ein fundamentales Konzept der Computer-Sicherheit, da Kunden und Benutzer erwarten, dass ihre Daten geschützt sind. Zum Beispiel erwartet ein Kunde, dass seine Kreditkarteninformationen sicher gespeichert werden (Vertraulichkeit), dass seine Aufträge nicht hinter den Kulissen geändert werden (Integrität) und dass er zu jeder Zeit Zugang zu seinen Informationen hat (Verfügbarkeit).</p></div><div class=paragraph><p>Um diese Grundprinzipien zu implementieren, wenden Sicherheitsexperten das sogenannte Defense-in-Depth-Konzept an. Die Idee dahinter ist, mehrere Sicherheitsschichten zu addieren, so dass nicht die gesamte Systemsicherheit gefährdet ist, wenn eine einzelne Sicherheitsschicht kompromittiert wird. Beispielsweise ist es nicht ausreichend, ein Netzwerk oder ein System nur mit einer Firewall zu sichern. Der Systemadministrator muss auch Benutzerkonten überwachen, die Integrität von Binärdateien prüfen und sicherstellen, dass keine bösartigen Programme installiert sind. Um eine effektive Sicherheitsstrategie zu implementieren, muss man Bedrohungen verstehen und wissen, wie man sich dagegen verteidigen kann.</p></div><div class=paragraph><p>Was ist eine Bedrohung, wenn es um Computer-Sicherheit geht? Bedrohungen beschränken sich nicht nur auf entfernte Angreifer, die sich unerlaubten Zugriff auf ein System verschaffen wollen. Zu den Bedrohungen zählen auch Mitarbeiter, bösartige Software, nicht autorisierte Netzwerkgeräte, Naturkatastrophen, Sicherheitslücken und sogar konkurrierende Unternehmen.</p></div><div class=paragraph><p>Der Zugriff auf Netzwerke und Systeme erfolgt ohne Erlaubnis, manchmal durch Zufall, oder von entfernten Angreifern, und in einigen Fällen durch Industriespionage oder ehemalige Mitarbeiter. Als Anwender müssen Sie vorbereitet sein und auch zugeben, wenn ein Fehler zu einer Sicherheitsverletzung geführt hat. Melden Sie Probleme umgehend dem verantwortlichen Sicherheitspersonal. Als Administrator ist es wichtig, Bedrohungen zu kennen und darauf vorbereitet zu sein, mögliche Schäden zu mildern.</p></div><div class=paragraph><p>Wenn Sicherheit auf Systeme angewendet wird, empfiehlt es sich mit der Sicherung der Benutzerkonten zu beginnen und dann die Netzwerkschicht zu sichern. Dabei ist zu beachten, dass die Sicherheitsrichtlinien des Systems und des Unternehmens eingehalten werden. Viele Unternehmen haben bereits eine Sicherheitsrichtlinie, welche die Konfiguration von technischen Geräten abdeckt. Die Richtlinie sollte die Konfiguration von Arbeitsplatzrechnern, Desktops, mobilen Geräten, Mobiltelefonen, Produktions- und Entwicklungsservern umfassen. In einigen Fällen ist bereits eine Standardvorgehensweise vorhanden. Fragen Sie im Zweifelsfall das Sicherheitspersonal.</p></div><div class=paragraph><p>Der übrige Teil dieser Einführung beschreibt, wie einige grundlegende Sicherheitskonfigurationen auf einem FreeBSD-System durchgeführt werden. Der Rest des Kapitels zeigt einige spezifische Werkzeuge, die verwendet werden können, um eine Sicherheitsrichtlinie auf einem FreeBSD-System zu implementieren.</p></div><div class=sect3><h4 id=security-accounts>31.2.1. Anmeldungen am System verhindern<a class=anchor href=#security-accounts></a></h4><div class=paragraph><p>Ein guter Ausgangspunkt für die Absicherung des Systems ist die Prüfung der Benutzerkonten. Stellen Sie sicher, dass <code>root</code> ein starkes Passwort besitzt und dass dieses Passwort nicht weitergegeben wird. Deaktivieren Sie alle Konten, die keinen Zugang zum System benötigen.</p></div><div class=paragraph><p>Es existieren zwei Methoden, um die Anmeldung über ein Benutzerkonto zu verweigern. Die erste Methode ist, das Konto zu sperren. Dieses Beispiel sperrt das Benutzerkonto <code>toor</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw lock toor</span></code></pre></div></div><div class=paragraph><p>Bei der zweiten Methode wird der Anmeldevorgang verhindert, indem die Shell auf <span class=filename>/usr/sbin/nologin</span> gesetzt wird. Nur der Superuser kann die Shell für andere Benutzer ändern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chsh -s /usr/sbin/nologin toor</span></code></pre></div></div><div class=paragraph><p>Die Shell <span class=filename>/usr/sbin/nologin</span> verhindert, dass dem Benutzer bei der Anmeldung am System eine Shell zugeordnet wird.</p></div></div><div class=sect3><h4 id=security-accountmgmt>31.2.2. Gemeinsame Nutzung von Benutzerkonten<a class=anchor href=#security-accountmgmt></a></h4><div class=paragraph><p>In manchen Fällen wird die Systemadministration auf mehrere Benutzer aufgeteilt. FreeBSD bietet zwei Methoden, um solche Situationen zu handhaben. Bei der ersten und nicht empfohlenen Methode wird ein gemeinsames root Passwort der Mitglieder der Gruppe <code>wheel</code> verwendet. Hier gibt der Benutzer <code>su</code> und das Passwort für <code>wheel</code> ein, wenn er die Rechte des Superusers benötigt. Der Benutzer sollte dann nach der Beendigung der administrativen Aufgaben <code>exit</code> eingeben. Um einen Benutzer zu dieser Gruppe hinzuzufügen, bearbeiten Sie <span class=filename>/etc/group</span> und fügen Sie den Benutzer an das Ende des Eintrags <code>wheel</code> hinzu. Die Benutzer müssen durch Komma und ohne Leerzeichen getrennt werden.</p></div><div class=paragraph><p>Die zweite und empfohlene Methode ein Benutzerkonto zu teilen wird über den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> realisiert. Dieses Programm bietet zusätzliche Prüfungen, bessere Benutzerkontrolle und es kann auch konfiguriert werden, einzelnen Benutzern Zugriff auf bestimme, privilegierte Befehle zu gestatten.</p></div><div class=paragraph><p>Benutzen Sie nach der Installation <code>visudo</code>, um <span class=filename>/usr/local/etc/sudoers</span> zu bearbeiten. Dieses Beispiel erstellt eine neue Gruppe <code>webadmin</code> und fügt das Benutzerkonto <code>trhodes</code> dieser Gruppe hinzu. Anschließend wird die Gruppe so konfiguriert, dass es Gruppenmitgliedern gestattet wird <a class=package href=https://cgit.freebsd.org/ports/tree/apache24/>apache24</a> neu zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd webadmin -M trhodes -g 6000</span>
<span class=c># visudo</span>
%webadmin <span class=nv>ALL</span><span class=o>=(</span>ALL<span class=o>)</span> /usr/sbin/service apache24 <span class=k>*</span></code></pre></div></div></div><div class=sect3><h4 id=security-passwords>31.2.3. Passwort-Hashes<a class=anchor href=#security-passwords></a></h4><div class=paragraph><p>Passwörter sind ein notwendiges Übel. Wenn sie verwendet werden müssen, sollten sie sehr komplex sein und dazu sollte eine leistungsfähige Hash-Funktion gewählt werden, um die Version des Passworts zu verschlüsseln, die in der Passwortdatenbank gespeichert wird. FreeBSD unterstützt die Hash-Funktionen DES, MD5, SHA256, SHA512, sowie Blowfish Hash-Funktionen in seiner <code>crypt()</code>-Bibliothek. Das in der Voreinstellung verwendete SHA512 sollte nicht durch eine weniger sichere Hash-Funktion getauscht werden. Es kann jedoch durch den besseren Blowfish-Algorithmus ersetzt werden.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Blowfish ist nicht Bestandteil von AES und ist nicht kompatibel mit allen Federal Information Processing Standards (FIPS). Die Verwendung wird in einigen Umgebungen vielleicht nicht gestattet.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um zu bestimmen, welche Hash-Funktion das Passwort eines Benutzers verschlüsselt, kann der Superuser den Hash für den Benutzer in der Passwortdatenbank von FreeBSD nachsehen. Jeder Hash beginnt mit einem Zeichen, mit dem die verwendete Hash-Funktion identifiziert werden kann. Bei DES gibt es allerdings kein führendes Zeichen. MD5 benutzt das Zeichen <code>$</code>. SHA256 und SHA512 verwenden das Zeichen <code>$6$</code>. Blowfish benutzt das Zeichen <code>$2a$</code>. In diesem Beispiel wird das Passwort von <code>dru</code> mit dem Hash-Algorithmus SHA512 verschlüsselt, da der Hash mit <code>$6$</code> beginnt. Beachten Sie, dass der verschlüsselte Hash und nicht das Passwort selbst, in der Passwortdatenbank gespeichert wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep dru /etc/master.passwd</span>
dru:<span class=nv>$6$pzIjSvCAn</span>.PBYQBA<span class=nv>$PXpSeWPx3g5kscj3IMiM7tUEUSPmGexxta</span>.8Lt9TGSi2lNQqYGKszsBPuGME0:1001:1001::0:0:dru:/usr/home/dru:/bin/csh</code></pre></div></div><div class=paragraph><p>Der Hash-Mechanismus wird in der Login-Klasse des Benutzers festgelegt. In diesem Beispiel wird die voreingestellte Login-Klasse für den Benutzer verwendet. Der Hash-Algorithmus wird mit dieser Zeile in <span class=filename>/etc/login.conf</span> gesetzt:</p></div><div class="literalblock programlisting"><div class=content><pre>        :passwd_format=sha512:\</pre></div></div><div class=paragraph><p>Um den Algorithmus auf Blowfish zu ändern, passen Sie die Zeile wie folgt an:</p></div><div class="literalblock programlisting"><div class=content><pre>        :passwd_format=blf:\</pre></div></div><div class=paragraph><p>Führen Sie anschließend <code>cap_mkdb /etc/login.conf</code> aus, wie in <a href=#users-limiting>Login-Klassen konfigurieren</a> beschrieben. Beachten Sie, dass vorhandene Passwort-Hashes durch diese Änderung nicht beeinträchtigt werden. Das bedeutet, dass alle Passwörter neu gehasht werden sollten, indem die Benutzer mit <code>passwd</code> ihr Passwort ändern.</p></div><div class=paragraph><p>Für die Anmeldung auf entfernten Rechnern sollte eine Zwei-Faktor-Authentifizierung verwendet werden. Ein Beispiel für eine Zwei-Faktor-Authentifizierung ist "etwas, was Sie besitzen" (bspw. einen Schlüssel) und "etwas, was Sie wissen" (bspw. das Passwort für diesen Schlüssel). Da OpenSSH Teil des FreeBSD-Basissystems ist, sollten alle Anmeldungen über das Netzwerk über eine verschlüsselte Verbindung mit einer schlüsselbasierten Authentifizierung stattfinden. Passwörter sollten hier nicht verwendet werden. Weitere Informationen finden Sie in <a href=#openssh>OpenSSH</a>. Kerberos-Benutzer müssen eventuell zusätzliche Änderungen vornehmen, um OpenSSH in Ihrem Netzwerk zu implementieren. Diese Änderungen sind in <a href=#kerberos5>Kerberos</a> beschrieben.</p></div></div><div class=sect3><h4 id=security-pwpolicy>31.2.4. Durchsetzung einer Passwort-Richtlinie<a class=anchor href=#security-pwpolicy></a></h4><div class=paragraph><p>Die Durchsetzung einer starken Passwort-Richtlinie für lokale Benutzerkonten ist ein wesentlicher Aspekt der Systemsicherheit. In FreeBSD kann die Länge, Stärke und Komplexität des Passworts mit den Pluggable Authentication Modules (PAM) implementiert werden.</p></div><div class=paragraph><p>In diesem Abschnitt wird gezeigt, wie Sie die minimale und maximale Passwortlänge und die Durchsetzung von gemischten Zeichen mit dem Modul <span class=filename>pam_passwdqc.so</span> konfigurieren. Dieses Modul wird aufgerufen, wenn ein Benutzer sein Passwort ändert.</p></div><div class=paragraph><p>Um dieses Modul zu konfigurieren, müssen Sie als Superuser die Zeile mit <code>pam_passwdqc.so</code> in <span class=filename>/etc/pam.d/passwd</span> auskommentieren. Anschließend bearbeiten Sie die Zeile, so dass sie den vorliegenden Passwort-Richtlinien entspricht:</p></div><div class="literalblock programlisting"><div class=content><pre>password        requisite       pam_passwdqc.so min=disabled,disabled,disabled,12,10 similar=deny retry=3 enforce=users</pre></div></div><div class=paragraph><p>Dieses Beispiel legt gleich mehrere Anforderungen für neue Passwörter fest. Die Einstellung <code>min</code> kontrolliert die Passwortlänge. Es verfügt über fünf Werte, weil dieses Modul fünf verschiedene Arten von Passwörtern definiert, basierend auf der Komplexität. Die Komplexität wird durch die Art von Zeichen definiert, die in einem Passwort vorhanden sind, wie zum Beispiel Buchstaben, Zahlen und Sonderzeichen. Die verschiedenen Arten von Passwörtern werden in <a href="https://man.freebsd.org/cgi/man.cgi?query=pam_passwdqc&amp;sektion=8&amp;format=html">pam_passwdqc(8)</a> beschrieben. In diesem Beispiel sind die ersten drei Arten von Passwörtern deaktiviert, was bedeutet, dass Passwörter, die dieser Komplexitätsstufe entsprechen, nicht akzeptiert werden, unabhängig von der Länge des Passworts. Die <code>12</code> legt eine Richtlinie von mindestens zwölf Zeichen fest, wenn das Passwort auch drei Arten von Komplexität aufweist. Die <code>10</code> legt eine Richtlinie fest, die auch Passwörter mit mindestens zehn Zeichen zulassen, wenn das Passwort Zeichen mit vier Arten von Komplexität aufweist.</p></div><div class=paragraph><p>Die Einstellung <code>similar</code> verbietet Passwörter, die dem vorherigen Passwort des Benutzers ähnlich sind. Die Einstellung <code>retry</code> bietet dem Benutzer drei Möglichkeiten, ein neues Passwort einzugeben.</p></div><div class=paragraph><p>Sobald diese Datei gespeichert wird, sehen Benutzer bei der Änderung ihres Passworts die folgende Meldung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
Changing <span class=nb>local </span>password <span class=k>for </span>trhodes
Old Password:

You can now choose the new password.
A valid password should be a mix of upper and lower <span class=k>case</span> letters,
digits and other characters.  You can use a 12 character long
password with characters from at least 3 of these 4 classes, or
a 10 character long password containing characters from all the
classes.  Characters that form a common pattern are discarded by
the check.
Alternatively, <span class=k>if </span>noone <span class=k>else </span>can see your terminal now, you can
pick this as your password: <span class=s2>&#34;trait-useful&amp;knob&#34;</span><span class=nb>.</span>
Enter new password:</code></pre></div></div><div class=paragraph><p>Wenn ein Passwort nicht den Richtlinien entspricht, wird es mit einer Warnung abgelehnt und der Benutzer bekommt die Möglichkeit, es erneut zu versuchen, bis die Anzahl an Wiederholungen erreicht ist.</p></div><div class=paragraph><p>Die meisten Passwort-Richtlinien erzwingen, dass Passwörter nach einer bestimmten Anzahl von Tagen ablaufen. Um dieses Limit in FreeBSD zu konfigurieren, setzen Sie es für die Login-Klasse des Benutzers in <span class=filename>/etc/login.conf</span>. Die voreingestellte Login-Klasse enthält dazu ein Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>#       :passwordtime=90d:\</pre></div></div><div class=paragraph><p>Um für diese Login-Klasse das Passwort nach 90 Tagen ablaufen zu lassen, entfernen Sie das Kommentarzeichen (<code>#</code>), speichern Sie die Änderungen und führen Sie <code>cap_mkdb /etc/login.conf</code> aus.</p></div><div class=paragraph><p>Um das Passwort für einzelne Benutzer ablaufen zu lassen, geben Sie <code>pw</code> ein Ablaufdatum oder die Anzahl von Tagen, zusammen mit dem Benutzer an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod -p 30-apr-2015 -n trhodes</span></code></pre></div></div><div class=paragraph><p>Wie zu sehen ist, wird das Ablaufdatum in der Form von Tag, Monat und Jahr angegeben. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>.</p></div></div><div class=sect3><h4 id=security-rkhunter>31.2.5. Erkennen von Rootkits<a class=anchor href=#security-rkhunter></a></h4><div class=paragraph><p>Ein <em>Rootkit</em> ist eine nicht autorisierte Software die versucht, Root-Zugriff auf ein System zu erlangen. Einmal installiert, wird diese bösartige Software normalerweise eine Hintertür für den Angreifer installieren. Realistisch betrachtet sollte ein durch ein Rootkit kompromittiertes System nach der Untersuchung von Grund auf neu installiert werden. Es besteht jedoch die enorme Gefahr, dass sogar das Sicherheitspersonal oder Systemingenieure etwas übersehen, was ein Angreifer dort platziert hat.</p></div><div class=paragraph><p>Wird ein Rootkit erkannt, ist dies bereits ein Zeichen dafür, dass das System an einem bestimmten Zeitpunkt kompromittiert wurde. Meist neigen diese Art von Anwendungen dazu, sehr gut versteckt zu sein. Dieser Abschnitt zeigt das Werkzeug <a class=package href=https://cgit.freebsd.org/ports/tree/security/rkhunter/>security/rkhunter</a>, mit dem Rootkits erkannt werden können.</p></div><div class=paragraph><p>Nach der Installation dieses Ports oder Pakets kann das System mit dem folgenden Kommando überprüft werden. Das Programm generiert eine ganze Menge Informationen und Sie werden diverse Male <kbd>ENTER</kbd> drücken müssen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rkhunter -c</span></code></pre></div></div><div class=paragraph><p>Nachdem der Prozess abgeschlossen ist, wird eine Statusmeldung auf dem Bildschirm ausgegeben. Die Meldung enthält die Anzahl der überprüften Dateien, verdächtige Dateien, mögliche Rootkits und weitere Informationen. Während der Überprüfung erscheinen allgemeine Sicherheitswarnungen, zum Beispiel über versteckte Dateien, die Auswahl von OpenSSH-Protokollen und bekannte, anfällige Versionen installierter Anwendungen. Diese können nun direkt, oder nach detaillierter Analyse untersucht werden.</p></div><div class=paragraph><p>Jeder Administrator sollte wissen, was auf den Systemen läuft, für die er verantwortlich ist. Werkzeuge von Drittanbietern, wie rkhunter oder <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/lsof/>sysutils/lsof</a>, sowie native Befehle wie <code>netstat</code> oder <code>ps</code>, können eine große Menge an Informationen über das System anzeigen. Machen Sie sich Notizen darüber, was "normal" ist, und fragen Sie nach, wenn Ihnen etwas suspekt erscheint. Eine Beeinträchtigung zu verhindern ist ideal, aber die Erkennung einer Beeinträchtigung ist ein Muss.</p></div></div><div class=sect3><h4 id=security-ids>31.2.6. Überprüfung von Binärdateien<a class=anchor href=#security-ids></a></h4><div class=paragraph><p>Die Überprüfung von System- und Binärdateien ist wichtig, da sie Systemadministratoren Informationen über Systemänderungen zur Verfügung stellt. Eine Software, die das System auf Änderungen überwacht wird Intrustion Detection System (IDS) genannt.</p></div><div class=paragraph><p>FreeBSD bietet native Unterstützung für ein einfaches IDS-System. Obwohl die täglichen Sicherheits-E-Mails den Administrator über Änderungen in Kenntnis setzen, werden diese Informationen lokal gespeichert und es besteht die Möglichkeit, dass ein Angreifer diese Informationen manipulieren kann, um Änderungen am System zu verbergen. Daher ist es empfehlenswert, einen eigenen Satz an Signaturen zu erstellen und diese dann in einem schreibgeschützten Verzeichnis, oder vorzugsweise auf einem USB-Stick oder auf einem entfernten Server zu speichern.</p></div><div class=paragraph><p>Das im Basissystem enthaltene Werkzeug mtree kann verwendet werden, um eine Spezifikation des Inhalts eines Verzeichnisses zu erzeugen. Hierbei wird ein Startwert (Seed) oder eine numerische Konstante benutzt, um die Spezifikation zu erstellen und um sicherzustellen, dass sich die Spezifikation nicht geändert hat. Dadurch kann festgestellt werden, ob eine Datei oder eine Binärdatei verändert wurde. Da ein Angreifer den Seed nicht kennt, ist es ihm fast unmöglich die Prüfsummen von Dateien zu manipulieren. Das folgende Beispiel generiert einen Satz mit SHA256-Prüfsummen für jede Binärdatei unterhalb von <span class=filename>/bin</span> und speichert diese Werte in einer versteckten Datei im Heimatverzeichnis von <code>root</code> unter dem Namen <span class=filename>/root/.bin_chksum_mtree</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mtree -s 3483151339707503 -c -K cksum,sha256digest -p /bin &gt; /root/.bin_chksum_mtree</span>
<span class=c># mtree: /bin checksum: 3427012225</span></code></pre></div></div><div class=paragraph><p><em>3483151339707503</em> stellt den Seed dar. Diesen Wert sollten Sie sich merken, aber nicht mit anderen Personen teilen.</p></div><div class=paragraph><p>Die Ausgabe von <span class=filename>/root/.bin_chksum_mtree</span> sollte ähnlich der folgenden sein:</p></div><div class="literalblock programlisting"><div class=content><pre>#          user: root
#       machine: dreadnaught
#          tree: /bin
#          date: Mon Feb  3 10:19:53 2014

# .
/set type=file uid=0 gid=0 mode=0555 nlink=1 flags=none
.               type=dir mode=0755 nlink=2 size=1024 \
                time=1380277977.000000000
    \133        nlink=2 size=1170 time=1380277977.000000000 \
                cksum=484492447 \
                sha256digest=6207490fbdb5ed1904441fbfa941279055c3e24d3a4049aeb45094596400662a
    cat         size=12096 time=1380277975.000000000 cksum=3909216944 \
                sha256digest=65ea347b9418760b247ab10244f47a7ca2a569c9836d77f074e7a306900c1e69
    chflags     size=8168 time=1380277975.000000000 cksum=3949425175 \
                sha256digest=c99eb6fc1c92cac335c08be004a0a5b4c24a0c0ef3712017b12c89a978b2dac3
    chio        size=18520 time=1380277975.000000000 cksum=2208263309 \
                sha256digest=ddf7c8cb92a58750a675328345560d8cc7fe14fb3ccd3690c34954cbe69fc964
    chmod       size=8640 time=1380277975.000000000 cksum=2214429708 \
                sha256digest=a435972263bf814ad8df082c0752aa2a7bdd8b74ff01431ccbd52ed1e490bbe7</pre></div></div><div class=paragraph><p>Der Report enthält den Rechnernamen, das Datum und die Uhrzeit der Spezifikation, sowie den Namen des Benutzers, der die Spezifikation erstellt hat. Für jede Binärdatei im Verzeichnis gibt es eine Prüfsumme, Größe, Uhrzeit und einen SHA256-Hashwert.</p></div><div class=paragraph><p>Um sicherzustellen, dass die binären Signaturen nicht verändert wurden, vergleichen Sie den Inhalt des aktuellen Verzeichnisses mit der zuvor erstellen Spezifikation. Speichern Sie die Ergebnisse in einer Datei. Dieses Kommando benötigt den Seed, der verwendet wurde um die ursprüngliche Spezifikation zu erstellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mtree -s 3483151339707503 -p /bin &lt; /root/.bin_chksum_mtree &gt;&gt; /root/.bin_chksum_output</span>
<span class=c># mtree: /bin checksum: 3427012225</span></code></pre></div></div><div class=paragraph><p>Dies sollte die gleiche Prüfsumme für <span class=filename>/bin</span> produzieren, wie die ursprüngliche Spezifikation. Wenn keine Änderungen an den Binärdateien in diesem Verzeichnis aufgetreten sind, wird die Ausgabedatei <span class=filename>/root/.bin_chksum_output</span> leer sein. Um eine Änderung zu simulieren, ändern Sie mit <code>touch</code> das Datum von <span class=filename>/bin/cat</span> und führen Sie die Verifikation erneut aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /bin/cat</span>
<span class=c># mtree -s 3483151339707503 -p /bin &lt; /root/.bin_chksum_mtree &gt;&gt; /root/.bin_chksum_output</span>
<span class=c># more /root/.bin_chksum_output</span>
<span class=nb>cat </span>changed
	modification <span class=nb>time </span>expected Fri Sep 27 06:32:55 2013 found Mon Feb  3 10:28:43 2014</code></pre></div></div><div class=paragraph><p>Es wird empfohlen, Spezifikationen für Verzeichnisse zu erstellen, welche Binärdateien, Konfigurationsdateien und sensible Daten enthalten. In der Regel werden Spezifikationen für <span class=filename>/bin</span>, <span class=filename>/sbin</span>, <span class=filename>/usr/bin</span>, <span class=filename>/usr/sbin</span>, <span class=filename>/usr/local/bin</span>, <span class=filename>/usr/local/sbin</span>, <span class=filename>/etc</span> und <span class=filename>/usr/local/etc</span> erstellt.</p></div><div class=paragraph><p>Mit <a class=package href=https://cgit.freebsd.org/ports/tree/security/aide/>security/aide</a> steht ein fortgeschrittenes IDS-System zur Verfügung, aber in den meisten Fällen bietet <code>mtree</code> die Funktionalität, die von Administratoren benötigt wird. Es ist jedoch sehr wichtig den Seed und die Prüfsummen in der Ausgabe vor böswilligen Benutzern verborgen zu halten. Weitere Informationen zu <code>mtree</code> finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mtree&amp;sektion=8&amp;format=html">mtree(8)</a>.</p></div></div><div class=sect3><h4 id=security-tuning>31.2.7. System-Tuning für Sicherheit<a class=anchor href=#security-tuning></a></h4><div class=paragraph><p>Unter FreeBSD können viele Systemfunktionen mit <code>sysctl</code> konfiguriert werden. Dieser Abschnitt behandelt ein paar Sicherheitsmerkmale mit denen Denial of Service (DoS) verhindert werden sollen. Weitere Informationen über die Benutzung von <code>sysctl</code> und wie Werte vorübergehend oder auch permanent geändert werden können, finden Sie in <a href=./#configtuning-sysctl>“Einstellungen mit sysctl(8)”</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Jedes Mal wenn eine Einstellung mit <code>sysctl</code> geändert wird, vergrößert sich die Wahrscheinlichkeit eines unerwünschten Schadens, was die Verfügbarkeit des Systems beeinflusst. Alle Änderungen sollten überwacht und wenn möglich, vorher auf einem Testsystem ausprobiert werden, bevor sie auf einem Produktivsystem verwendet werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In der Voreinstellung startet FreeBSD in der Sicherheitsstufe (Securelevel) <code>-1</code>. Dieser Modus wird "unsicherer Modus" genannt, da die unveränderlichen Datei-Flags ausgeschaltet werden können und dadurch von allen Geräten gelesen und geschrieben werden kann. Solange die Einstellung nicht über <code>sysctl</code> oder in den Startskripten geändert wird, verbleibt die Sicherheitsstufe auf <code>-1</code>. Die Sicherheitsstufe kann während des Systemstarts erhöht werden. Dazu muss in <span class=filename>/etc/rc.conf</span><code>kern_securelevel_enable</code> auf <code>YES</code> und <code>kern_securelevel</code> auf den gewünschten Wert gesetzt werden. Weitere Informationen zu diesen Einstellungen und den verfügbaren Sicherheitsstufen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=security&amp;sektion=7&amp;format=html">security(7)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Das Erhöhen der Sicherheitsstufe kann zu Problemen mit Xorg führen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Einstellungen <code>net.inet.tcp.blackhole</code> und <code>net.inet.udp.blackhole</code> können benutzt werden, um eingehende SYN-Pakete an geschlossenen Ports zu blockieren, ohne ein RST-Paket als Antwort zu senden. Standardmäßig wird jedoch ein RST-Paket gesendet, um zu zeigen, dass der Port geschlossen ist. Das ändern dieser Voreinstellung bietet einen gewissen Schutz gegen Portscans. Diese Portscans versuchen herauszufinden, welche Anwendungen auf einem System ausgeführt werden. Setzen Sie <code>net.inet.tcp.blackhole</code> auf <code>2</code> und <code>net.inet.udp.blackhole</code> auf <code>1</code>. Weitere Informationen zu diesen Einstellungen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=blackhole&amp;sektion=4&amp;format=html">blackhole(4)</a>.</p></div><div class=paragraph><p>Die Einstellung <code>net.inet.icmp.drop_redirect</code> hilft dabei, sogenannte Redirect-Angriffe zu verhindern. Ein Redirect-Angriff ist eine Art von DoS, die massenhaft ICMP-Pakete Typ 5 versendet. Da solche Pakete nicht benötigt werden, setzen Sie <code>net.inet.icmp.drop_redirect</code> auf <code>1</code> und <code>net.inet.ip.redirect</code> auf <code>0</code>.</p></div><div class=paragraph><p>Source Routing zur Erfassung und zum Zugriff auf nicht-routbare Adressen im internen Netzwerk. Dies sollte deaktiviert werden, da nicht-routbare Adressen in der Regel nicht absichtlich geroutet werden. Um diese Funktion zu deaktivieren, setzen Sie <code>net.inet.ip.sourceroute</code> und <code>net.inet.accept_sourceroute</code> auf <code>0</code>.</p></div><div class=paragraph><p>Wenn ein Netzwerkgerät Nachrichten an alle Rechner in einem Subnetz senden muss, wird eine ICMP-Echo-Request Nachricht an die Broadcast-Adresse gesendet. Allerdings gibt es keinen guten Grund für externe Rechner, solche Nachrichten zu verschicken. Um alle externen Broadcast-Anfragen abzulehnen, setzen Sie <code>net.inet.icmp.bmcastecho</code> auf <code>0</code>.</p></div><div class=paragraph><p>Einige zusätzliche Einstellungen sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=security&amp;sektion=7&amp;format=html">security(7)</a> dokumentiert.</p></div></div></div><div class=sect2><h3 id=one-time-passwords>31.3. Einmalpasswörter<a class=anchor href=#one-time-passwords></a></h3><div class=paragraph><p>In der Voreinstellung unterstützt FreeBSD One-time Passwords in Everything (OPIE). OPIE wurde konzipiert um Replay-Angriffe zu verhindern, bei dem ein Angreifer das Passwort eines Benutzers ausspäht und es benutzt, um Zugriff auf ein System zu erlangen. Da ein Passwort unter OPIE nur einmal benutzt wird, ist ein ausgespähtes Passwort für einen Angreifer nur von geringem Nutzen. OPIE verwendet eine sichere Hash-Funktion und ein Challenge/Response-System, um Passwörter zu verwalten. Die FreeBSD-Implementation verwendet in der Voreinstellung die MD5-Hash-Funktion.</p></div><div class=paragraph><p>OPIE verwendet drei verschiedene Arten von Passwörtern. Das erste ist das normale UNIX®- oder Kerberos-Passwort. Das zweite ist das Einmalpasswort, das von <code>opiekey</code> generiert wird. Das dritte Passwort ist das "geheime Passwort", das zum Erstellen der Einmalpasswörter verwendet wird. Das geheime Passwort steht in keiner Beziehung zum UNIX®-Passwort und beide Passwörter sollten unterschiedlich sein.</p></div><div class=paragraph><p>Es gibt noch zwei weitere Werte, die für OPIE wichtig sind. Der erste ist der "Initialwert" (engl. seed oder key), der aus zwei Buchstaben und fünf Ziffern besteht. Der zweite Wert ist der "Iterationszähler", eine Zahl zwischen 1 und 100. OPIE generiert das Einmalpasswort, indem es den Initialwert und das geheime Passwort aneinander hängt und dann die MD5-Hash-Funktion so oft, wie durch den Iterationszähler gegeben, anwendet. Das Ergebnis wird in sechs englische Wörter umgewandelt, die das Einmalpasswort ergeben. Das Authentifizierungssystem (meistens PAM) merkt sich das zuletzt benutzte Einmalpasswort und der Benutzer ist authentifiziert, wenn die Hash-Funktion des Passworts dem vorigen Passwort entspricht. Da nicht umkehrbare Hash-Funktionen benutzt werden, ist es unmöglich, aus einem bekannten Passwort weitere gültige Einmalpasswörter zu berechnen. Der Iterationszähler wird nach jeder erfolgreichen Anmeldung um eins verringert und stellt so die Synchronisation zwischen Benutzer und Login-Programm sicher. Wenn der Iterationszähler den Wert <code>1</code> erreicht, muss OPIE neu initialisiert werden.</p></div><div class=paragraph><p>Es gibt ein paar Programme, die in diesen Prozess einbezogen werden. Ein Einmalpasswort oder eine Liste von Einmalpasswörtern, die von <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> durch Angabe eines Iterationszählers, eines Initalwertes und einem geheimen Passwort generiert wird. <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> wird benutzt, um Passwörter, Iterationszähler oder Initialwerte zu ändern. <a href="https://man.freebsd.org/cgi/man.cgi?query=opieinfo&amp;sektion=1&amp;format=html">opieinfo(1)</a> hingegen gibt den momentanen Iterationszähler und Initialwert eines Benutzers aus, den es aus <span class=filename>/etc/opiekeys</span> ermittelt.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt vier verschiedene Arten von Tätigkeiten. Zuerst wird erläutert, wie Einmalpasswörter über eine gesicherte Verbindung konfiguriert werden. Als nächstes wird erklärt, wie <code>opiepasswd</code> über eine nicht gesicherte Verbindung eingesetzt wird. Als drittes wird beschrieben, wie man sich über eine nicht gesicherte Verbindung anmeldet. Die vierte Tätigkeit beschreibt, wie man eine Reihe von Schlüsseln generiert, die man sich aufschreiben oder ausdrucken kann, um sich von Orten anzumelden, die über keine gesicherten Verbindungen verfügen.</p></div><div class=sect3><h4 id=_opie_initialisieren>31.3.1. OPIE initialisieren<a class=anchor href=#_opie_initialisieren></a></h4><div class=paragraph><p>Um OPIE erstmals zu initialisieren, rufen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> über eine gesicherte Verbindung auf:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd <span class=nt>-c</span>
<span class=o>[</span>grimreaper] ~ <span class=nv>$ </span>opiepasswd <span class=nt>-f</span> <span class=nt>-c</span>
Adding unfurl:
Only use this method from the console<span class=p>;</span> NEVER from remote. If you are using
telnet, xterm, or a dial-in, <span class=nb>type</span> ^C now or <span class=nb>exit </span>with no password.
Then run opiepasswd without the <span class=nt>-c</span> parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:

ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</code></pre></div></div><div class=paragraph><p>Die Option <code>-c</code> startet den Konsolen-Modus, der davon ausgeht, dass der Befehl von einem sicherem Ort ausgeführt wird. Dies kann beispielsweise der eigene Rechner sein, oder über eine mit SSH gesicherte Verbindung zum eigenen Rechner.</p></div><div class=paragraph><p>Geben Sie das geheime Passwort ein, wenn Sie danach gefragt werden. Damit werden die Einmalpasswörter generiert. Dieses Passwort sollte schwer zu erraten sein und sich ebenfalls vom Passwort des Bentuzerkontos unterscheiden. Es muss zwischen 10 und 127 Zeichen lang sein. Prägen Sie sich dieses Passwort gut ein!</p></div><div class=paragraph><p>Die Zeile, die mit "ID" beginnt, enthält den Login-Namen (<code>unfrul</code>), den voreingestellten Iterationszähler (<code>499</code>) und den Initialwert (<code>to4268</code>). Das System erinnert sich an diese Parameter und wird sie bei einem Anmeldeversuch anzeigen. Sie brauchen sich diese Dinge also nicht merken. Die letzte Zeile enthält das generierte Einmalpasswort, das aus den Parametern und dem geheimen Passwort ermittelt wurde. Bei der nächsten Anmeldung muss dann diese Einmalpasswort benutzt werden.</p></div></div><div class=sect3><h4 id=_initialisierung_über_eine_nicht_gesicherte_verbindung>31.3.2. Initialisierung über eine nicht gesicherte Verbindung<a class=anchor href=#_initialisierung_über_eine_nicht_gesicherte_verbindung></a></h4><div class=paragraph><p>Um Einmalpasswörter über eine nicht gesicherte Verbindung zu initialisieren, oder das geheime Passwort zu ändern, müssen Sie über eine gesicherte Verbindung zu einer Stelle verfügen, an der Sie <code>opiekey</code> ausführen können. Dies kann etwa die Eingabeaufforderung auf einer Maschine sein, der Sie vertrauen. Zudem müssen Sie einen Iterationszähler vorgeben (100 ist ein guter Wert) und einen Initialwert wählen, wobei Sie auch einen zufällig generierten benutzen können. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> über die ungesicherte Verbindung zu der Maschine, die Sie einrichten wollen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</code></pre></div></div><div class=paragraph><p>Drücken Sie <kbd>Return</kbd>, um die Vorgabe für den Initialwert zu akzeptieren. Bevor Sie nun das Zugriffspasswort (engl. access password) eingeben, rufen Sie über die gesicherte Verbindung <code>opikey</code> mit denselben Parametern auf:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</code></pre></div></div><div class=paragraph><p>Gehen Sie zurück zu der nicht gesicherten Verbindung und geben dort das eben generierte Einmalpasswort ein.</p></div></div><div class=sect3><h4 id=_erzeugen_eines_einzelnen_einmalpasswortes>31.3.3. Erzeugen eines einzelnen Einmalpasswortes<a class=anchor href=#_erzeugen_eines_einzelnen_einmalpasswortes></a></h4><div class=paragraph><p>Nachdem Sie OPIE eingerichtet haben, werden Sie beim nächsten Anmelden wie folgt begrüßt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>example.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;username&gt;
otp-md5 498 gr4269 ext
Password:</code></pre></div></div><div class=paragraph><p>OPIE besitzt eine nützliche Eigenschaft. Wenn Sie an der Eingabeaufforderung <kbd>Return</kbd> drücken, wird die echo-Funktion eingeschaltet, das heißt Sie sehen, was Sie tippen. Dies ist besonders nützlich, wenn Sie ein generiertes Passwort von einem Ausdruck abtippen müssen.</p></div><div class=paragraph><p>Jetzt müssen Sie das Einmalpasswort generieren, um der Anmeldeaufforderung nachzukommen. Dies muss auf einem gesicherten System geschehen, auf dem Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> ausführen können. Dieses Programm gibt es auch für Windows®, Mac OS® und FreeBSD. Es benötigt den Iterationszähler sowie den Initialwert als Parameter, die Sie mittels "cut-and-paste" direkt von der Login-Aufforderung nehmen können.</p></div><div class=paragraph><p>Auf dem sicheren System:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</code></pre></div></div><div class=paragraph><p>Sobald das Einmalpasswort generiert wurde, können Sie die Anmeldeprozedur fortsetzen.</p></div></div><div class=sect3><h4 id=_erzeugen_von_mehreren_einmalpasswörtern>31.3.4. Erzeugen von mehreren Einmalpasswörtern<a class=anchor href=#_erzeugen_von_mehreren_einmalpasswörtern></a></h4><div class=paragraph><p>Manchmal haben Sie keinen Zugriff auf eine sichere Maschine oder eine sichere Verbindung. In diesem Fall können Sie vorher mit <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> einige Einmalpasswörter generieren. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey <span class=nt>-n</span> 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: &lt;secret password&gt;
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</code></pre></div></div><div class=paragraph><p>Mit <code>-n 5</code> fordern Sie fünf Passwörter der Reihe nach an. Der letzte Iterationszähler wird durch <code>30</code> gegeben. Beachten Sie bitte, dass die Passwörter in der <em>umgekehrten</em> Reihenfolge, in der sie zu benutzen sind, ausgeben werden. Wirklich paranoide Benutzer können sich jetzt die Passwörter aufschreiben oder ausdrucken. Sie sollten die Passwörter nach Gebrauch durchstreichen.</p></div></div><div class=sect3><h4 id=_einschränken_der_benutzung_von_system_passwörtern>31.3.5. Einschränken der Benutzung von System-Passwörtern<a class=anchor href=#_einschränken_der_benutzung_von_system_passwörtern></a></h4><div class=paragraph><p>OPIE kann die Verwendung von UNIX®-Passwörtern abhängig von der IP-Adresse einschränken. Die dazu nötigen Einstellungen werden in <span class=filename>/etc/opieaccess</span> vorgenommen, die bei der Installation des Systems automatisch erzeugt wird. Weitere Informationen über diese Datei und Sicherheitshinweise zu ihrer Verwendung finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=opieaccess&amp;sektion=5&amp;format=html">opieaccess(5)</a>.</p></div><div class=paragraph><p><span class=filename>opieaccess</span> könnte beispielsweise die folgende Zeile enthalten:</p></div><div class="literalblock programlisting"><div class=content><pre>permit 192.168.0.0 255.255.0.0</pre></div></div><div class=paragraph><p>Diese Zeile erlaubt es Benutzern, die sich von einer der angegebenen IP-Adressen anmelden, ihr UNIX®-Passwort zu verwenden. Beachten Sie bitte, dass eine IP-Adresse leicht gefälscht werden kann.</p></div><div class=paragraph><p>Findet sich in <span class=filename>opieaccess</span> kein passender Eintrag, muss die Anmeldung mit OPIE erfolgen.</p></div></div></div><div class=sect2><h3 id=tcpwrappers>31.4. TCP Wrapper<a class=anchor href=#tcpwrappers></a></h3><div class=paragraph><p>TCP Wrapper ist ein rechnerbasiertes Zugriffskontrollsystem, das die Fähigkeiten von <a href=./#network-inetd>“Der inetd Super-Server”</a> erweitert. Beispielsweise können Verbindungen protokolliert, Nachrichten zurückgesandt oder nur interne Verbindungen angenommen werden. Weitere Informationen über TCP Wrapper und dessen Funktionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpd&amp;sektion=8&amp;format=html">tcpd(8)</a>.</p></div><div class=paragraph><p>TCP Wrapper sollten nicht als Ersatz für eine ordentlich konfigurierte Firewall angesehen werden. Stattdessen sollten TCP Wrapper in Verbindung mit einer Firewall und anderen Sicherheitsmechanismen eingesetzt werden, um bei der Umsetzung einer Sicherheitsrichtlinie eine weitere Sicherheitsschicht zu bieten.</p></div><div class=sect3><h4 id=_konfiguration>31.4.1. Konfiguration<a class=anchor href=#_konfiguration></a></h4><div class=paragraph><p>Um TCP Wrapper unter FreeBSD zu aktivieren, fügen Sie die folgenden Zeilen in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;
inetd_flags=&#34;-Ww&#34;</pre></div></div><div class=paragraph><p>Anschließend muss <span class=filename>/etc/hosts.allow</span> richtig konfiguriert werden.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Im Gegensatz zu anderen Implementierungen der TCP Wrapper wird unter FreeBSD vom Gebrauch der Datei <span class=filename>hosts.deny</span> abgeraten. Die Konfiguration sollte sich vollständig in <span class=filename>/etc/hosts.allow</span> befinden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In der einfachsten Konfiguration werden Dienste abhängig von den Optionen in <span class=filename>/etc/hosts.allow</span> erlaubt oder gesperrt. Unter FreeBSD wird in der Voreinstellung jeder von inetd gestartete Dienst erlaubt.</p></div><div class=paragraph><p>Eine Konfigurationszeile ist wie folgt aufgebaut: <code>Dienst : Adresse : Aktion</code>. <code>Dienst</code> ist der von inetd gestartete Dienst (auch Daemon genannt). Die <code>Adresse</code> ist ein gültiger Rechnername, eine IP-Adresse oder eine IPv6-Adresse in Klammern (<code>[ ]</code>). Der Wert <code>allow</code> im Feld <code>Aktion</code> erlaubt Zugriffe, der Wert <code>deny</code> verbietet Zugriffe. Die Zeilen in <span class=filename>hosts.allow</span> werden für jede Verbindung der Reihe nach abgearbeitet. Trifft eine Zeile auf eine Verbindung zu, wird die entsprechende Aktion ausgeführt und die Abarbeitung ist beendet.</p></div><div class=paragraph><p>Um beispielsweise einkommende POP3-Verbindungen für den Dienst <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a> zu erlauben, sollte <span class=filename>hosts.allow</span> um die nachstehende Zeile erweitert werden:</p></div><div class="literalblock programlisting"><div class=content><pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre></div></div><div class=paragraph><p>Jedes Mal, wenn diese Datei bearbeitet wird, muss inetd neu gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd restart</span></code></pre></div></div></div><div class=sect3><h4 id=_erweiterte_konfiguration>31.4.2. Erweiterte Konfiguration<a class=anchor href=#_erweiterte_konfiguration></a></h4><div class=paragraph><p>TCP Wrapper besitzen weitere Optionen, die bestimmen, wie Verbindungen behandelt werden. In einigen Fällen ist es gut, wenn bestimmten Rechnern oder Diensten eine Nachricht geschickt wird. In anderen Fällen soll vielleicht der Verbindungsaufbau protokolliert oder eine E-Mail an einen Administrator versandt werden. Oder ein Dienst soll nur für das lokale Netz bereitstehen. Dies alles ist mit so genannten Wildcards, Metazeichen und der Ausführung externer Programme möglich.</p></div><div class=paragraph><p>Stellen Sie sich vor, eine Verbindung soll verhindert werden und gleichzeitig soll dem Rechner, der die Verbindung aufgebaut hat, eine Nachricht geschickt werden. Solch eine Aktion ist mit <code>twist</code> möglich. <code>twist</code> führt beim Verbindungsaufbau ein Kommando oder ein Skript aus. Ein Beispiel ist in <span class=filename>hosts.allow</span> enthalten:</p></div><div class="literalblock programlisting"><div class=content><pre># Alle anderen Dienste sind geschützt
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo &#34;You are not welcome to use %d from %h.&#34;</pre></div></div><div class=paragraph><p>Für jeden Dienst, der nicht vorher in <span class=filename>hosts.allow</span> konfiguriert wurde, wird die Meldung "You are not allowed to use <em>daemon name</em> from <em>hostname</em>." zurückgegeben. Dies ist nützlich, wenn die Gegenstelle sofort benachrichtigt werden soll, nachdem die Verbindung getrennt wurde. Der Text der Meldung <em>muss</em> in Anführungszeichen (<code>"</code>) stehen.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Ein so konfigurierter Server ist anfällig für Denial-of-Service-Angriffe. Ein Angreifer kann die gesperrten Dienste mit Verbindungsanfragen überfluten.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Eine weitere Möglichkeit bietet <code>spawn</code>. Wie <code>twist</code> verbietet <code>spawn</code> die Verbindung und führt externe Kommandos aus. Allerdings sendet <code>spawn</code> dem Rechner keine Rückmeldung. Sehen Sie sich die nachstehende Konfigurationsdatei an:</p></div><div class="literalblock programlisting"><div class=content><pre># Verbindungen von example.com sind gesperrt:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</pre></div></div><div class=paragraph><p>Damit sind Verbindungen von der Domain <code>*.example.com</code> gesperrt. Jeder Verbindungsaufbau wird zudem in <span class=filename>/var/log/connections.log</span> protokolliert. Das Protokoll enthält den Rechnernamen, die IP-Adresse und den Dienst, der angesprochen wurde. In diesem Beispiel wurden die Metazeichen <code>%a</code> und <code>%h</code> verwendet. Eine vollständige Liste der Metazeichen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a>.</p></div><div class=paragraph><p>Die Wildcard <code>ALL</code> passt auf jeden Dienst, jede Domain oder jede IP-Adresse. Eine andere Wildcard ist <code>PARANOID</code>. Sie passt auf jeden Rechner, dessen IP-Adresse möglicherweise gefälscht ist. Dies ist beispielsweise der Fall, wenn der Verbindungsaufbau von einer IP-Adresse erfolgt, die nicht zu dem übermittelten Rechnernamen passt. In diesem Beispiel werden alle Verbindungsanfragen zu Sendmail abgelehnt, wenn die IP-Adresse nicht zum Rechnernamen passt:</p></div><div class="literalblock programlisting"><div class=content><pre># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</pre></div></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Die Wildcard <code>PARANOID</code> wird Verbindungen ablehnen, wenn der Client oder der Server eine fehlerhafte DNS-Konfiguration besitzt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Weitere Informationen über Wildcards und deren Funktion finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie neue Einträge zur Konfiguration hinzufügen, sollten Sie sicherstellen, dass nicht benötigte Einträge in <span class=filename>hosts.allow</span> auskommentiert werden.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=kerberos5>31.5. Kerberos<a class=anchor href=#kerberos5></a></h3><div class=paragraph><p>Kerberos ist ein Netzwerk-Authentifizierungsprotokoll, das ursprünglich am Massachusetts Institute of Technology (MIT) entwickelt wurde. Es bietet die Möglichkeit zur sicheren Authentifizierung über ein potentiell unsicheres Netzwerk. Das Kerberos-Protokoll benutzt eine starke Kryptographie, um die Identität von Clients und Servern nachweisen zu können. Dabei werden keine unverschlüsselten Daten über das Netzewrk gesendet. Kerberos kann als eine Art Proxy zur Identitätsprüfung, oder als vertrauenswürdiges Authentifizierungssystem betrachtet werden.</p></div><div class=paragraph><p>Kerberos hat nur eine Aufgabe: Die sichere Prüfung der Identität eines Benutzers (Authentifizierung) über das Netzwerk. Das System überprüft weder die Berechtigungen der Benutzer (Autorisierung), noch verfolgt es die durchgeführten Aktionen (Audit). Daher sollte Kerberos zusammen mit anderen Sicherheits-Systemen eingesetzt werden, die diese Funktionen bereitstellen.</p></div><div class=paragraph><p>Die aktuelle Version des Protokolls ist Version 5, die in RFC 4120 beschrieben ist. Es existieren mehrere freie Implementierungen dieses Protokolls für eine Reihe von Betriebssystemen. Das MIT entwickelt auch weiterhin seine Kerberos-Version weiter. Es wird in den vereinigten Staaten als Kryptographie-Produkt eingesetzt und unterlag in der Vergangenheit US-Exportbeschränkungen. In FreeBSD ist MIT-Kerberos als Port oder Paket <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a> verfügbar. Die Kerberos-Implementation von Heimdal wurde außerhalb der USA entwickelt und unterliegt daher keinen Export-Beschränkungen. Heimdal-Kerberos ist im Basissystem von FreeBSD enthalten. Mit <a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a> aus der Ports-Sammlung steht eine weitere Distribution, mit mehr konfigurierbaren Optionen zur Verfügung.</p></div><div class=paragraph><p>Unter Kerberos werden Benutzer und Dienste als "Prinzipale" bezeichnet, die innerhalb einer administrativen Domäne, dem sogenannten "Realm" enthalten sind. Ein typisches Benutzer-Prinzipal hätte das Format <code><em>user</em>@<em>REALM</em></code> (Realms sind traditionell in Großbuchstaben).</p></div><div class=paragraph><p>Die folgenden Anweisungen beschreiben, wie Sie das mit FreeBSD gelieferte Heimdal-Kerberos einrichten.</p></div><div class=paragraph><p>Die Beschreibung der Kerberos-Installation benutzt folgende Namensräume:</p></div><div class=ulist><ul><li><p>Die DNS-Domain ("Zone") heißt <code>example.org</code>.</p></li><li><p>Das Kerberos-Realm heißt <code>EXAMPLE.ORG</code>.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Benutzen Sie echte Domain-Namen, wenn Sie Kerberos einrichten. Damit vermeiden Sie DNS-Probleme und stellen die Zusammenarbeit mit anderen Kerberos-Realms sicher.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_das_heimdal_kdc_einrichten>31.5.1. Das Heimdal KDC einrichten<a class=anchor href=#_das_heimdal_kdc_einrichten></a></h4><div class=paragraph><p>Kerberos authentifiziert Benutzer an einer zentralen Stelle: dem Key Distribution Center (KDC). Das KDC verteilt <em>Tickets</em>, mit denen ein Dienst die Identität eines Benutzers feststellen kann. Weil alle Mitglieder eines Kerberos-Realms dem KDC vertrauen, gelten für das KDC erhöhte Sicherheitsanforderungen. Der direkte Zugriff auf das KDC sollte daher eingeschränkt sein.</p></div><div class=paragraph><p>Obwohl der Kerberos-Server wenig Ressourcen benötigt, sollte das KDC wegen der Sicherheitsanforderungen auf einem separaten Rechner installiert werden.</p></div><div class=paragraph><p>Installieren Sie zunächst das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a> wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install heimdal</span></code></pre></div></div><div class=paragraph><p>Als nächstes aktualisieren Sie <span class=filename>/etc/rc.conf</span> mittels <code>sysrc</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc kdc_enable=yes</span>
<span class=c># sysrc kadmind_enable=yes</span></code></pre></div></div><div class=paragraph><p>Danach wird <span class=filename>/etc/krb5.conf</span> wie folgt bearbeitet:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
	kdc = kerberos.example.org
	admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>Diese Einstellungen setzen voraus, dass der voll qualifizierte Name des KDCs <code>kerberos.example.org</code> ist. Der Rechnername des KDC muss im DNS auflösbar sein.</p></div><div class=paragraph><p>In großen Netzwerken mit einem ordentlich konfigurierten DNS-Server kann die Datei aus dem obigen Beispiel verkürzt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
      default_realm = EXAMPLE.ORG
[domain_realm]
    .example.org = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>Die Zonendatei von <code>example.org</code> muss dann die folgenden Zeilen enthalten:</p></div><div class="literalblock programlisting"><div class=content><pre>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Damit die Clients die Kerberos-Dienste benutzen können, <em>muss</em> sie entweder eine vollständig konfigurierte <span class=filename>/etc/krb5.conf</span> enthalten, oder eine minimale Konfiguration <em>und</em> zusätzlich ein richtig konfigurierter DNS-Server.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Im nächsten Schritt wird die Kerberos-Datenbank eingerichtet. Die Datenbank enthält die Schlüssel aller Prinzipale und ist mit einem Passwort geschützt. Dieses Passwort brauchen Sie sich nicht merken, da ein davon abgeleiteter Schlüssel in <span class=filename>/var/heimdal/m-key</span> gespeichert wird. Es wäre durchaus sinnvoll, ein 45-stelliges Zufallspasswort für diesen Zweck zu benutzten. Um den Schlüssel zu erstellen, rufen Sie <code>kstash</code> auf und geben Sie ein Passwort ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>
Master key: xxxxxxxxxxxxxxxxxxxxxxx
Verifying password - Master key: xxxxxxxxxxxxxxxxxxxxxxx</code></pre></div></div><div class=paragraph><p>Nachdem der Schlüssel erstellt wurde, sollte die Datenbank initialisiert werden. Das Kerberos-Werkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> kann die Datenbank mit <code>kadmin -l</code> direkt bearbeiten, ohne dabei den Netzwerkdienst <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmind&amp;sektion=8&amp;format=html">kadmind(8)</a> zu benutzen. An der Eingabeaufforderung von <code>kadmin</code> kann mit <code>init</code> die Datenbank des Realms initialisiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin -l</span>
kadmin&gt; init EXAMPLE.ORG
Realm max ticket life <span class=o>[</span>unlimited]:</code></pre></div></div><div class=paragraph><p>Zuletzt wird in <code>kadmin</code> mit <code>add</code> das erste Prinzipal erstellt. Benutzen Sie vorerst die voreingestellten Optionen für das Prinzipal. Die Optionen können später mit <code>modify</code> verändert werden. An der Eingabeaufforderung von <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> zeigt <code>?</code> die verfügbaren Optionen an.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>kadmin&gt; add tillman
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Principal expiration <span class=nb>time</span> <span class=o>[</span>never]:
Password expiration <span class=nb>time</span> <span class=o>[</span>never]:
Attributes <span class=o>[]</span>:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx</code></pre></div></div><div class=paragraph><p>Jetzt können die KDC-Dienste wie folgt gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service kdc start</span>
<span class=c># service kadmind start</span></code></pre></div></div><div class=paragraph><p>Obwohl zu diesem Zeitpunkt noch keine kerberisierten Dienste laufen, kann die Funktion des KDC schon überprüft werden, indem Sie für den eben angelegten Benutzer ein Ticket anfordern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit tillman
tillman@EXAMPLE.ORG<span class=s1>&#39;s Password:</span></code></pre></div></div><div class=paragraph><p>Überprüfen Sie, ob das Ticket erfolgreich ausgestellt wurde:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% klist
Credentials cache: FILE: /tmp/krb5cc_1001
        Principal: tillman@EXAMPLE.ORG

  Issued                Expires               Principal
Aug 27 15:37:58 2013  Aug 28 01:37:58 2013  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</code></pre></div></div><div class=paragraph><p>Nachdem der Test abgeschlossen ist, kann das temporäre Ticket zurückgezogen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kdestroy</code></pre></div></div></div><div class=sect3><h4 id=_kerberos_dienste_auf_dem_server_einrichten>31.5.2. Kerberos-Dienste auf dem Server einrichten<a class=anchor href=#_kerberos_dienste_auf_dem_server_einrichten></a></h4><div class=paragraph><p>Bei der Konfiguration eines Servers für die Kerberos-Authentifizierung muss zuerst sichergestellt werden, dass <span class=filename>/etc/krb5.conf</span> richtig konfiguriert ist. Die Datei kann entweder vom KDC kopiert, oder auf dem neuen System generiert werden.</p></div><div class=paragraph><p>Als nächstes muss auf dem Server die <span class=filename>/etc/krb5.keytab</span> erzeugt werden. Dies ist der Hauptbestandteil um Dienste zu "kerberisieren" und entspricht der Erzeugung eines geheimen Schlüssels zwischen dem Dienst und dem KDC. Das Geheimnis ist ein kryptographischer Schlüssel, der in einem <span class=filename>keytab</span>> abgelegt wird. Diese Datei enthält den Schlüssel des Servers, mit dem sich der Server und das KDC gegenseitig authentifizieren können. Sie muss in einer sicheren Art und Weise an den Server übertragen werden, da ansonsten die Sicherheit des Servers gefährdet ist, wenn z.B. die Schlüssel öffentlich werden. In der Regel wird die <span class=filename>keytab</span> auf einem vertrauenswürdigen Rechner mit <code>kadmin</code> erzeugt und anschließend sicher auf den Server übertragen, beispielsweise mit <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>. Wenn die Sicherheitsrichtlinien es erlauben, kann die Datei auch direkt auf dem Server erzeugt werden. Es ist sehr wichtig, dass die <span class=filename>keytab</span> auf sichere Weise auf den Server übertragen wird. Wenn der Schlüssel einer anderen Partei bekannt wird, kann sich diese Partei den Benutzern als Server ausgeben! Da der Eintrag für das Host-Prinzipal für die KDC-Datenbank auch mit <code>kadmin</code> erstellt wird, ist es praktisch, <code>kadmin</code> direkt auf dem Server zu benutzen.</p></div><div class=paragraph><p>Natürlich ist auch <code>kadmin</code> ein kerberisierter Dienst: ein Kerberos-Ticket ist erforderlich, um sich gegenüber dem Netzwerkdienst zu authentifizieren und um sicherzustellen, dass der Benutzer, der <code>kadmin</code> ausführt, tatsächlich vorhanden ist. <code>kadmin</code> wird nach dem Passwort fragen, um ein neues Ticket zu generieren. Das Prinzipal, das sich mit dem kadmin-Dienst authentifiziert, muss über die Zugriffskontrollliste <span class=filename>/var/heimdal/kadmin.acl</span> dazu berechtigt sein. Weitere Informationen über Zugriffskontrolllisten finden Sie in den Heimdal-Info-Seiten (<code>info heimdal</code>) im Abschnitt "Remote administration". Wenn der Zugriff auf <code>kadmin</code> von entfernten Rechnern verboten ist, kann sich der Administrator entweder über die lokale Konsole oder über <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> mit dem KDC verbinden, um die lokale Administration mit <code>kadmin -l</code> durchzuführen.</p></div><div class=paragraph><p>Nach der Installation von <span class=filename>/etc/krb5.conf</span>, können Sie das Kommando <code>add --random-key</code> in <code>kadmin</code> ausführen, um das Host-Prinzipal in die Datenbank zu schreiben. Das Kommando <code>ext</code> extrahiert den Schlüssel des Prinzipals in eine eigene keytab:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; add <span class=nt>--random-key</span> host/myserver.example.org
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Principal expiration <span class=nb>time</span> <span class=o>[</span>never]:
Password expiration <span class=nb>time</span> <span class=o>[</span>never]:
Attributes <span class=o>[]</span>:
kadmin&gt; ext_keytab host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Beachten Sie, dass <code>ext_keytab</code> den extrahierten Schlüssel standardmäßig in <span class=filename>/etc/krb5.keytab</span> speichert. Das ist gut, wenn das Kommando auf dem kerberisierten Server ausgeführt wird, ansonsten sollte das Argument <code>--keytab <em>pfad/zur/datei</em></code> benutzt werden, wenn die keytab an einen anderen Ort extrahiert wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; ext_keytab <span class=nt>--keytab</span><span class=o>=</span>/tmp/example.keytab host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Anschließend kann die erzeugte keytab sicher mit <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> auf Server oder auf einen Wechseldatenträger kopiert werden. Geben Sie auf jeden Fall einen anderen Namen für die keytab an, um unnötige Schlüssel in der keytab des Systems zu vermeiden.</p></div><div class=paragraph><p>Mit Hilfe der Datei <span class=filename>krb5.conf</span> kann der Server nun mit dem KDC kommunizieren und seine Identität mithilfe der Datei <span class=filename>krb5.keytab</span> nachweisen. Jetzt können die kerberisierten Dienste aktiviert werden. Einer der gebräuchlichsten Dienste ist <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>, der Kerberos über GSS-API unterstützt. Fügen Sie folgende Zeile in <span class=filename>/etc/ssh/sshd_config</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>GSSAPIAuthentication yes</pre></div></div><div class=paragraph><p>Nach dieser Änderung muss <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> mit <code>service sshd restart</code> neu gestartet werden, damit die neue Konfiguration wirksam wird.</p></div></div><div class=sect3><h4 id=_kerberos_auf_dem_client_einrichten>31.5.3. Kerberos auf dem Client einrichten<a class=anchor href=#_kerberos_auf_dem_client_einrichten></a></h4><div class=paragraph><p>Genau wie der Server, benötigt auch der Client eine Konfiguration in <span class=filename>/etc/krb5.conf</span>. Kopien Sie die Datei (sicher) vom KDC auf den Client, oder schreiben Sie die Datei bei Bedarf einfach neu.</p></div><div class=paragraph><p>Testen Sie den Client, indem Sie mit <code>kinit</code> Tickets anfordern, mit <code>klist</code> Tickets anzeigen und mit <code>kdestroy</code> Tickets löschen. Kerberos-Anwendungen sollten auch kerberisierte Server ansprechen können. Wenn das nicht funktioniert, Sie aber Tickets anfordern können, hat wahrscheinlich der kerberisierte Server ein Problem und nicht der Client oder das KDC. Im Falle eines kerberisierten <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> ist GSS-API in der Voreinstellung deaktiviert. Testen Sie daher mit <code>ssh -o GSSAPIAuthentication=yes <em>hostname</em></code>.</p></div><div class=paragraph><p>Wenn Sie die kerberisierten Anwendungen testen, können Sie einen Paket-Sniffer wie <code>tcpdump</code> benutzen, um sicherzustellen, dass keine sensiblen Informationen im Klartext übertragen werden.</p></div><div class=paragraph><p>Es stehen verschiedene Kerberos-Anwendungen zur Verfügung. Die Anwendungen, die SASL benutzen, können dann auch GSS-API benutzen. Viele Arten von Anwendungen können Kerberos zur Authentifizierung verwenden, vom Jabber-Client bis zum IMAP-Client.</p></div><div class=paragraph><p>Normalerweise wird ein Kerberos-Prinzipal auf ein lokales Benutzerkonto abgebildet. Manchmal wird aber Zugriff auf ein lokales Benutzerkonto benötigt, zu dem es keinen passenden Kerberos-Prinzipal gibt. Der Prinzipal <code>tillman@EXAMPLE.ORG</code> bräuchte beispielsweise Zugriff auf das Konto <code>webdevelopers</code>. Ebenso könnten andere Prinzipale auf dieses Konto zugreifen wollen.</p></div><div class=paragraph><p>Die Dateien <span class=filename>.k5login</span> und <span class=filename>.k5users</span> im Heimatverzeichnis eines Benutzers können verwendet werden, um dieses Problem zu lösen. Mit der folgenden <span class=filename>.k5login</span> im Heimatverzeichnis des Benutzers <code>webdevelopers</code> haben beide Prinzipale auch ohne das gemeinsame Passwort Zugriff auf das Konto:</p></div><div class="literalblock programlisting"><div class=content><pre>tillmann@example.org
jdoe@example.org</pre></div></div><div class=paragraph><p>Weitere Informationen zu <span class=filename>.k5users</span> finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a>.</p></div></div><div class=sect3><h4 id=_unterschiede_zur_mit_implementation>31.5.4. Unterschiede zur MIT-Implementation<a class=anchor href=#_unterschiede_zur_mit_implementation></a></h4><div class=paragraph><p>Der Hauptunterschied zwischen der MIT- und der Heimdal-Implementation ist das Kommando <code>kadmin</code>. Die Befehlssätze des Kommandos (obwohl funktional gleichwertig) und das verwendete Protokoll unterscheiden sich in beiden Varianten. Das KDC lässt sich nur mit dem <code>kadmin</code> Kommando der passenden Kerberos-Variante verwalten.</p></div><div class=paragraph><p>Für dieselbe Funktion können auch die Client-Anwendungen leicht geänderte Kommandozeilenoptionen besitzen. Folgen Sie der Anleitung auf <a href=http://web.mit.edu/Kerberos/www/>http://web.mit.edu/Kerberos/www/</a>. Achten Sie besonders auf den Suchpfad für Anwendungen. Der MIT-Port wird unter FreeBSD standardmäßig in <span class=filename>/usr/local/</span> installiert. Wenn die Umgebungsvariable <code>PATH</code> zuerst die Systemverzeichnisse enthält, werden die Systemprogramme anstelle der MIT-Programme ausgeführt.</p></div><div class=paragraph><p>Wenn Sie MIT-Kerberos verwenden, sollten Sie außerdem folgende Änderungen an <span class=filename>/etc/rc.conf</span> vornehmen:</p></div><div class="literalblock programlisting"><div class=content><pre>kdc_program=&#34;/usr/local/sbin/kdc&#34;
kadmind_program=&#34;/usr/local/sbin/kadmind&#34;
kdc_flags=&#34;&#34;
kdc_enable=&#34;YES&#34;
kadmind_enable=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=_tipps_und_fehlersuche>31.5.5. Tipps und Fehlersuche<a class=anchor href=#_tipps_und_fehlersuche></a></h4><div class=paragraph><p>Während der Konfiguration und bei der Fehlersuche sollten die folgenden Punkte beachtet werden:</p></div><div class=ulist><ul><li><p>Wenn Sie Heimdal- oder MIT-Kerberos benutzen, muss in der Umgebungsvariable <code>PATH</code> der Pfad zu den Kerberos-Programmen vor dem Pfad zu den Programmen des Systems stehen.</p></li><li><p>Wenn die Clients im Realm ihre Uhrzeit nicht synchronisieren, schlägt vielleicht die Authentifizierung fehl. <a href=./#network-ntp>“Die Uhrzeit mit NTP synchronisieren”</a> beschreibt, wie Sie mithilfe von NTP die Uhrzeiten synchronisieren.</p></li><li><p>Wenn Sie den Namen eines Rechners ändern, müssen Sie auch den <code>host/</code>-Prinzipal ändern und die keytab aktualisieren. Dies betrifft auch spezielle Einträge wie den <code>HTTP/</code>-Prinzipal für Apaches <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_auth_kerb/>www/mod_auth_kerb</a>.</p></li><li><p>Alle Rechner in einem Realm müssen vor- und rückwärts aufgelöst werden können. Entweder über DNS, zumindest aber über <span class=filename>/etc/hosts</span>. CNAME-Einträge im DNS funktionieren, aber die entsprechenden A- und PTR-Einträge müssen vorhanden und richtig sein. Wenn sich Namen nicht auflösen lassen, ist die Fehlermeldung nicht gerade selbstsprechend: <code>Kerberos5 refuses authentication because Read req failed: Key table entry not found</code>.</p></li><li><p>Einige Betriebssysteme installieren <code>ksu</code> mit falschen Zugriffsrechten; es fehlt das Set-UID-Bit für <code>root</code>. Das hat zur Folge, dass <code>ksu</code> nicht funktioniert. Dies ist ein Fehler in den Zugriffsrechten und kein Fehler des KDCs.</p></li><li><p>Wenn Sie für einen Prinzipal unter MIT-Kerberos Tickets mit einer längeren Gültigkeit als der vorgegebenen zehn Stunden einrichten wollen, müssen Sie zwei Sachen ändern. Benutzen Sie <code>modify_principal</code> am Prompt von <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a>, um die maximale Gültigkeitsdauer für den Prinzipal selbst und den Prinzipal <code>krbtgt</code> zu erhöhen. Das Prinzipal kann dann mit <code>kinit -l</code> ein Ticket mit einer längeren Gültigkeit beantragen.</p></li><li><p>Mit einem Packet-Sniffer können Sie feststellen, dass Sie sofort nach dem Aufruf von <code>kinit</code> eine Antwort vom KDC bekommen - noch bevor Sie überhaupt ein Passwort eingegeben haben! Das ist in Ordnung: Das KDC händigt ein Ticket-Granting-Ticket (TGT) auf Anfrage aus, da es durch einen vom Passwort des Benutzers abgeleiteten Schlüssel geschützt ist. Wenn das Passwort eingegeben wird, wird es nicht zum KDC gesendet, sondern zum Entschlüsseln der Antwort des KDCs benutzt, die <code>kinit</code> schon erhalten hat. Wird die Antwort erfolgreich entschlüsselt, erhält der Benutzer einen Sitzungs-Schlüssel für die künftige verschlüsselte Kommunikation mit dem KDC und das TGT. Das TGT wiederum ist mit dem Schlüssel des KDCs verschlüsselt. Diese Verschlüsselung ist für den Benutzer völlig transparent und erlaubt dem KDC, die Echtheit jedes einzelnen TGT zu prüfen.</p></li><li><p>Host-Prinzipale können Tickets mit längerer Gültigkeit besitzen. Wenn der Prinzipal eines Benutzers über ein Ticket verfügt, das eine Woche gültig ist, das Ticket des Host-Prinzipals aber nur neun Stunden gültig ist, funktioniert der Ticket-Cache nicht wie erwartet. Im Cache befindet sich dann ein abgelaufenes Ticket des Host-Prinzipals.</p></li><li><p>Wenn Sie mit <span class=filename>krb5.dict</span> die Verwendung schlechter Passwörter verhindern wollen, wie in <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> beschrieben, geht das nur mit Prinzipalen, denen eine Passwort-Policy zugewiesen wurde. Das Format von <span class=filename>krb5.dict</span> enthält pro Zeile ein Wort. Sie können daher einen symbolischen Link auf <span class=filename>/usr/shared/dict/words</span> erstellen.</p></li></ul></div></div><div class=sect3><h4 id=_beschränkungen_von_kerberos>31.5.6. Beschränkungen von Kerberos<a class=anchor href=#_beschränkungen_von_kerberos></a></h4><div class=paragraph><p>Kerberos muss ganzheitlich verwendet werden. Jeder über das Netzwerk angebotene Dienst muss mit Kerberos zusammenarbeiten oder auf anderen Wegen gegen Angriffe aus dem Netzwerk geschützt sein. Andernfalls können Berechtigungen gestohlen und wiederverwendet werden. Es ist beispielsweise nicht sinnvoll, für Remote-Shells Kerberos zu benutzen, dagegen aber POP3-Zugriff auf einem Mail-Server zu erlauben, da POP3 Passwörter im Klartext versendet.</p></div><div class=paragraph><p>Das KDC ist verwundbar und muss daher genauso abgesichert werden, wie die auf ihm befindliche Passwort-Datenbank. Auf dem KDC sollten absolut keine anderen Dienste laufen und der Rechner sollte physikalisch gesichert sein. Die Gefahr ist groß, da Kerberos alle Passwörter mit einem Schlüssel, dem Haupt-Schlüssel, verschlüsselt. Der Haupt-Schlüssel wiederum wird in einer Datei auf dem KDC gespeichert.</p></div><div class=paragraph><p>Ein kompromittierter Haupt-Schlüssel ist nicht ganz so schlimm wie allgemein angenommen. Der Haupt-Schlüssel wird nur zum Verschlüsseln der Passwort-Datenbank und zum Initialisieren des Zufallsgenerators verwendet. Solange der Zugriff auf das KDC abgesichert ist, kann ein Angreifer wenig mit dem Haupt-Schlüssel anfangen.</p></div><div class=paragraph><p>Wenn das KDC nicht zur Verfügung steht, sind auch die Netzwerkdienste nicht benutzbar, da eine Authentifizierung nicht durchgeführt werden kann. Das KDC ist also ein optimales Ziel für einen Denial-of-Service Angriff. Sie können diesem Angriff entgegenwirken, indem Sie einen KDC-Master und einen oder mehrere Slaves verwenden. Der Rückfall auf ein sekundäres KDC mittels PAM-Authentifizierung muss sorgfältig eingerichtet werden.</p></div><div class=paragraph><p>Mit Kerberos können sich Benutzer, Rechner und Dienste gegenseitig authentifizieren. Allerdings existiert kein Mechanismus, der das KDC gegenüber Benutzern, Rechnern oder Diensten authentifiziert. Ein verändertes <code>kinit</code> könnte beispielsweise alle Benutzernamen und Passwörter abfangen. Die von veränderten Programmen ausgehende Gefahr können Sie lindern, indem Sie die Integrität von Dateien mit Werkzeugen wie <a class=package href=https://cgit.freebsd.org/ports/tree/security/tripwire/>security/tripwire</a> prüfen.</p></div></div><div class=sect3><h4 id=_weiterführende_dokumentation>31.5.7. Weiterführende Dokumentation<a class=anchor href=#_weiterführende_dokumentation></a></h4><div class=ulist><ul><li><p><a href=http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html>The Kerberos FAQ</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/dialogue.html>Designing an Authentication System: a Dialogue in Four Scenes</a></p></li><li><p><a href=https://www.ietf.org/rfc/rfc4120.txt>RFC 4120, The Kerberos Network Authentication Service (V5)</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/>MIT Kerberos-Seite</a></p></li><li><p><a href=https://github.com/heimdal/heimdal/wiki>Heimdal Kerberos-Wiki</a></p></li></ul></div></div></div><div class=sect2><h3 id=openssl>31.6. OpenSSL<a class=anchor href=#openssl></a></h3><div class=paragraph><p>OpenSSL ist eine Open Source Implementierung der SSL und TLS-Protokolle. Es bietet eine verschlüsselte Transportschicht oberhalb der normalen Kommunikationsschicht und kann daher zusammen mit vielen Netzdiensten benutzt werden.</p></div><div class=paragraph><p>Das in FreeBSD integrierte OpenSSL stellt die Protokolle Secure Sockets Layer 3.0 (SSLv3) und Transport Layer Security 1.0/1.1/1.2 (TLSv1/TLSv1.1/TLSv1.2) zur Verfügung. Die OpenSSL-Bibliotheken stellen kryptographische Funktionen bereit. FreeBSD 12.0-RELEASE und neuere Versionen enthalten OpenSSL mit Unterstützung für Transport Layer Security 1.3 (TLSv1.3).</p></div><div class=paragraph><p>Anwendungsbeispiele für OpenSSL sind die verschlüsselte Authentifizierung von E-Mail-Clients oder Web-Transaktionen wie das Bezahlen mit Kreditkarte. Einige Ports, wie <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache24/>www/apache24</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/databases/postgresql11-server/>databases/postgresql11-server</a>, haben eine Option für den Bau mit OpenSSL. Bei Auswahl dieser Option, wird OpenSSL aus dem Basissystem benutzt. Wenn Sie für den Bau der Anwendung stattdessen OpenSSL aus dem Port <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssl/>security/openssl</a> benutzten wollen, fügen Sie folgende Zeile in <span class=filename>/etc/make.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>DEFAULT_VERSIONS+= ssl=openssl</pre></div></div><div class=paragraph><p>OpenSSL wird auch eingesetzt, um Zertifikate für Anwendungen bereitzustellen. Die Zertifikate stellen die Identität einer Firma oder eines Einzelnen sicher. Wenn ein Zertifikat nicht von einer Zertifizierungsstelle (Certificate Authority, CA) gegengezeichnet wurde, erhalten Sie normalerweise eine Warnung. Eine Zertifizierungsstelle ist eine Firma wie <a href=http://www.verisign.com/>VeriSign</a>, die Zertifikate von Personen oder Firmen gegenzeichnet und damit die Korrektheit der Zertifikate bestätigt. Diese Prozedur kostet Geld, ist aber keine Voraussetzung für den Einsatz von Zertifikaten, beruhigt aber sicherheitsbewusste Benutzer.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie auf einem FreeBSD-System Zertifikate erstellen und benutzen. <a href=./#ldap-config>“Konfiguration eines LDAP-Servers”</a> beschreibt, wie Sie eine CA erstellen um die eigenen Zertifikate zu signieren.</p></div><div class=paragraph><p>Weitere Informationen über SSL finden Sie im kostenlosen <a href=https://www.feistyduck.com/books/openssl-cookbook/>OpenSSL Cookbook</a>.</p></div><div class=sect3><h4 id=_zertifikate_erzeugen>31.6.1. Zertifikate erzeugen<a class=anchor href=#_zertifikate_erzeugen></a></h4><div class=paragraph><p>Um ein Zertifikat zu erzeugen, das von einer externen CA signiert werden soll, geben Sie folgenden Befehl und die angeforderten Informationen ein. Diese Informationen werden in das Zertifikat geschrieben. Für <code>Common Name</code> geben Sie den vollqualifizierten Namen des Systems ein, auf dem das Zertifikat später installiert wird. Wenn der Name nicht übereinstimmt, wird die Anwendung, die das Zertifikat überprüft, dem Benuzter eine Warnung anzeigen. Die Überprüfung würde fehlschlagen und das Zertifikat damit unbrauchbar machen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -nodes -out req.pem -keyout cert.key -sha256 -newkey rsa:2048</span>
Generating a 2048 bit RSA private key
..................+++
.............................................................+++
writing new private key to <span class=s1>&#39;cert.key&#39;</span>
<span class=nt>-----</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>eg, YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org

Please enter the following <span class=s1>&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class=o>[]</span>:
An optional company name <span class=o>[]</span>:Another Name</code></pre></div></div><div class=paragraph><p>Bei der Erzeugung des Zertifikates können noch weitere Optionen, wie die Gültigkeitsdauer und alternative Verschlüsselungsalgorithmen, angegeben werden. <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a> beschreibt die zur Verfügung stehenden Optionen.</p></div><div class=paragraph><p>Das folgende Kommando erstellt zwei Dateien im aktuellen Verzeichnis: Die Anforderung für ein neues Zertifikat wird in <span class=filename>req.pem</span> gespeichert. Diese Datei können Sie an eine CA senden, wo die Angaben geprüft werden. Nach erfolgreicher Prüfung wird das Zertifikat signiert und an Sie zurückgesandt. <span class=filename>cert.key</span>, enthält den privaten Schlüssel für das Zertifikat und darf auch keine Fall in fremde Hände geraten, da ein Angreifer sonst in der Lage ist, anderen Personen oder Rechnern vorzugaukeln, dass es sich bei ihm um Sie handelt.</p></div><div class=paragraph><p>Wenn Sie keine Signatur einer Zertifizierungsstelle benötigen, können Sie ein selbst signiertes Zertifikat erstellen. Erzeugen Sie dazu zuerst einen RSA-Schlüssel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl genrsa -rand -genkey -out cert.key 2048</span>
0 semi-random bytes loaded
Generating RSA private key, 2048 bit long modulus
.............................................+++
.................................................................................................................+++
e is 65537 <span class=o>(</span>0x10001<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie diesen Schlüssel, um ein selbst signiertes Zertifikat zu erzeugen. Folgen Sie wieder den Anweisungen am Prompt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -x509 -days 365 -key cert.key -out cert.crt -sha256</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>e.g. server FQDN or YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org</code></pre></div></div><div class=paragraph><p>Dieses Kommando erstellt zwei neue Dateien im aktuellen Verzeichnis: Der Schlüssel der Zertifizierungsstelle <span class=filename>cert.key</span> und das Zertifikat selbst, <span class=filename>cert.crt</span>. Sie sollten in einem Verzeichnis, vorzugsweise unterhalb von <span class=filename>/etc/ssl/</span> abgelegt werden, das nur von <code>root</code> lesbar ist. Die Zugriffsrechte der Dateien können mit <code>chmod</code> auf <code>0700</code> gesetzt werden.</p></div></div><div class=sect3><h4 id=_zertifikate_benutzen>31.6.2. Zertifikate benutzen<a class=anchor href=#_zertifikate_benutzen></a></h4><div class=paragraph><p>Mit einem Zertifikat können beispielsweise die Verbindungen zu Sendmail verschlüsselt werden, um eine Klartext-Authentifizierung zu verhindern.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Einige E-Mail-Programme geben Warnungen aus, wenn ein Zertifikat nicht lokal installiert ist. Weitere Informationen zur Installation von Zertifikaten finden Sie in der Dokumentation der entsprechenden Software.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Unter FreeBSD 10.0-RELEASE und neueren Versionen ist es möglich, ein selbst signiertes Zertifikat für Sendmail automatisch erzeugen zu lassen. Um diese Funktionalität zu aktivieren, fügen Sie die folgenden Zeilen in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;YES&#34;
sendmail_cert_enable=&#34;YES&#34;
sendmail_cert_cn=&#34;localhost.example.org&#34;</pre></div></div><div class=paragraph><p>Dadurch wird automatisch ein selbst signiertes Zertifikat (<span class=filename>/etc/mail/certs/host.cert</span>), der Schlüssel für die CA (<span class=filename>/etc/mail/certs/host.key</span> und das Zertifikat der CA (<span class=filename>/etc/mail/certs/cacert.pem</span> erzeugt. Das Zertifikat wird den in <code>sendmail_cert_cn</code> festgelegten <code>Common Name</code> verwenden. Nachdem Sie die Änderungen gespeichert haben, starten Sie Sendmail neu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sendmail restart</span></code></pre></div></div><div class=paragraph><p>Wenn alles gut ging, erscheinen keine Fehlermeldungen in <span class=filename>/var/log/maillog</span>. Für einen einfachen Test, bauen Sie mit Hilfe von <code>telnet</code> eine Verbindung zum Mailserver auf:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># telnet example.com 25</span>
Trying 192.0.34.166...
Connected to example.com.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
220 example.com ESMTP Sendmail 8.14.7/8.14.7<span class=p>;</span> Fri, 18 Apr 2014 11:50:32 <span class=nt>-0400</span> <span class=o>(</span>EDT<span class=o>)</span>
ehlo example.com
250-example.com Hello example.com <span class=o>[</span>192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 example.com closing connection
Connection closed by foreign host.</code></pre></div></div><div class=paragraph><p>Wenn die Zeile <code>STARTTLS</code> erscheint, hat alles funktioniert.</p></div></div></div><div class=sect2><h3 id=ipsec>31.7. VPN mit IPsec<a class=anchor href=#ipsec></a></h3><div class=paragraph><p>Internet Protocol Security (IPsec) ist ein Satz von Protokollen, die auf dem Internet-Protokoll (IP) aufbauen. Durch Authentifizierung und Verschlüsselung jedes einzelnen IP-Pakets, können mehrere Systeme geschützt miteinander kommunizieren. FreeBSDs IPSsec Netzwerk-Stack basiert auf der <a href=http://www.kame.net>http://www.kame.net</a> Implementierung und unterstützt sowohl IPv4 als auch IPv6.</p></div><div class=paragraph><p>IPsec besteht aus den folgenden Protokollen:</p></div><div class=ulist><ul><li><p><em>Encapsulated Security Payload (ESP)</em>: dieses Protokoll verschlüsselt IP-Pakete mit einem symmetrischen Verfahren wie Blowfish oder 3DES. Damit werden die Pakete vor Manipulationen Dritter geschützt.</p></li><li><p><em>Authentication Header (AH)</em>: dieses Protokoll enthält eine kryptographische Prüfsumme, die sicher stellt, dass ein IP-Paket nicht verändert wurde. Der Authentication-Header folgt nach dem normalen IP-Header und erlaubt dem Empfänger eines IP-Paketes, dessen Integrität zu prüfen.</p></li><li><p><em>IP Payload Compression Protocol (IPComp)</em>: dieses Protokoll versucht durch Komprimierung der IP-Nutzdaten die Menge der gesendeten Daten zu reduzieren und somit die Kommunikationsleistung zu verbessern.</p></li></ul></div><div class=paragraph><p>Diese Protokolle können, je nach Situation, zusammen oder einzeln verwendet werden.</p></div><div class=paragraph><p>IPsec unterstützt zwei Modi: Der <em>Transport-Modus</em> verschlüsselt die Daten zwischen zwei Systemen. Der <em>Tunnel-Modus</em> verbindet zwei Subnetze miteinander. Durch einen Tunnel können dann verschlüsselte Daten übertragen werden. Ein Tunnel wird auch als Virtual-Private-Network (VPN) bezeichnet. Detaillierte Informationen über das IPsec-Subsystem von FreeBSD finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a>.</p></div><div class=paragraph><p>Seit FreeBSD 11 ist IPsec in der Voreinstellung aktiviert. Um die Unterstützung für IPsec in älteren Versionen zu aktivieren, fügen Sie folgenden Optionen in die Kernelkonfigurationsdatei ein und erstellen Sie einen neuen Kernel, wie in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> beschrieben.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC        IP security
device    crypto</code></pre></div></div><div class=paragraph><p>Wenn Sie zur Fehlersuche im IPsec-Subsystem Unterstützung wünschen, sollten Sie die folgende Option ebenfalls aktivieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_DEBUG  debug <span class=k>for </span>IP security</code></pre></div></div><div class=paragraph><p>Der Rest dieses Kapitels beschreibt die Einrichtung eines IPsec-VPN zwischen einem Heimnetzwerk und einem Firmennetzwerk. Für das folgende Beispiel gilt:</p></div><div class=ulist><ul><li><p>Beide Netzwerke sind über ein FreeBSD-Gateway mit dem Internet verbunden.</p></li><li><p>Der Gateway jedes Netzwerks besitzt mindestens eine externe IP-Adresse. In diesem Beispiel ist die externe IP-Adresse des Firmennetzwerks (LAN) <code>172.16.5.4</code> und das Heimnetzwerk (LAN) hat die externe IP-Adresse <code>192.168.1.12</code>.</p></li><li><p>Die intern verwendeten IP-Adressen können private oder öffentliche Adressen sein. Sie dürfen sich jedoch nicht überschneiden. Zum Beispiel sollten nicht beide Netze <code>192.168.1.x</code> benutzen. In diesem Beispiel ist die interne IP-Adresse des Firmennetzwerks (LAN) <code>10.246.38.1</code> und das Heimnetzwerk (LAN) hat die interne IP-Adresse <code>10.0.0.5</code>.</p></li></ul></div><div class=sect3><h4 id=_konfiguration_eines_vpn_unter_freebsd>31.7.1. Konfiguration eines VPN unter FreeBSD<a class=anchor href=#_konfiguration_eines_vpn_unter_freebsd></a></h4><div class=paragraph><p>Als erstes muss <a class=package href=https://cgit.freebsd.org/ports/tree/security/ipsec-tools/>security/ipsec-tools</a> aus der Ports-Sammlung installiert werden. Diese Software enthält einige Anwendungen, die bei der Konfiguration von IPsec hilfreich sind.</p></div><div class=paragraph><p>Als nächstes müssen zwei <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a>-Pseudogeräte angelegt werden, um die Pakete zu tunneln und dafür zu sorgen, dass beide Netzwerke richtig miteinander kommunizieren können. Geben Sie als <code>root</code> die folgenden Befehle ein, wobei Sie <em>intern</em> und <em>extern</em> durch die realen internen und externen IP-Adressen der Gateways ersetzen müssen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0 intern1 intern2</span>
<span class=c># ifconfig gif0 tunnel extern1 extern2</span></code></pre></div></div><div class=paragraph><p>Überprüfen Sie mit <code>ifconfig</code> die Konfiguration auf beiden Gateways. Hier folgt die Ausgabe von Gateway 1:</p></div><div class="literalblock programlisting"><div class=content><pre>gif0: flags=8051 mtu 1280
tunnel inet 172.16.5.4 --&gt; 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
inet 10.246.38.1 --&gt; 10.0.0.5 netmask 0xffffff00</pre></div></div><div class=paragraph><p>Hier folgt die Ausgabe von Gateway 2:</p></div><div class="literalblock programlisting"><div class=content><pre>gif0: flags=8051 mtu 1280
tunnel inet 192.168.1.12 --&gt; 172.16.5.4
inet 10.0.0.5 --&gt; 10.246.38.1 netmask 0xffffff00
inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4</pre></div></div><div class=paragraph><p>Wenn Sie fertig sind, sollten beide internen Adressen über <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> erreichbar sein:</p></div><div class="literalblock programlisting"><div class=content><pre>priv-net# ping 10.0.0.5
PING 10.0.0.5 (10.0.0.5): 56 data bytes
64 bytes from 10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms
64 bytes from 10.0.0.5: icmp_seq=1 ttl=64 time=19.255 ms
64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms
--- 10.0.0.5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms

corp-net# ping 10.246.38.1
PING 10.246.38.1 (10.246.38.1): 56 data bytes
64 bytes from 10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms
64 bytes from 10.246.38.1: icmp_seq=1 ttl=64 time=42.917 ms
64 bytes from 10.246.38.1: icmp_seq=2 ttl=64 time=127.525 ms
64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms
64 bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms
--- 10.246.38.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms</pre></div></div><div class=paragraph><p>Wie erwartet, können nun beiden Seiten ICMP-Pakete von ihren privaten Adressen senden und empfangen. Als nächstes müssen beide Gateways so konfiguriert werden, dass sie die Pakete des anderen Netzwerkes richtig routen. Dazu werden folgende Befehle verwendet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>corp-net# route add 10.0.0.0 10.0.0.5 255.255.255.0
corp-net# route add net 10.0.0.0: gateway 10.0.0.5
priv-net# route add 10.246.38.0 10.246.38.1 255.255.255.0
priv-net# route add host 10.246.38.0: gateway 10.246.38.1</code></pre></div></div><div class=paragraph><p>Ab jetzt sollten die Rechner von den Gateways sowie von den Rechnern hinter den Gateways erreichbar sein. Dies können Sie wieder mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> überprüfen:</p></div><div class="literalblock programlisting"><div class=content><pre>corp-net# ping 10.0.0.8
PING 10.0.0.8 (10.0.0.8): 56 data bytes
64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
--- 10.0.0.8 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

priv-net# ping 10.246.38.107
PING 10.246.38.1 (10.246.38.107): 56 data bytes
64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
--- 10.246.38.107 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms</pre></div></div><div class=paragraph><p>Das Konfigurieren der Tunnel ist der einfache Teil. Die Konfiguration einer sicheren Verbindung geht viel mehr in die Tiefe. Die folgende Konfiguration benutzt pre-shared (PSK) RSA-Schlüssel. Abgesehen von den IP-Adressen, sind beide <span class=filename>/usr/local/etc/racoon/racoon.conf</span> identisch und sehen ähnlich aus:</p></div><div class="literalblock programlisting"><div class=content><pre>path    pre_shared_key  &#34;/usr/local/etc/racoon/psk.txt&#34;; #location of pre-shared key file
log     debug;  #log verbosity setting: set to &#39;notify&#39; when testing and debugging is complete

padding # options are not to be changed
{
        maximum_length  20;
        randomize       off;
        strict_check    off;
        exclusive_tail  off;
}

timer   # timing options. change as needed
{
        counter         5;
        interval        20 sec;
        persend         1;
#       natt_keepalive  15 sec;
        phase1          30 sec;
        phase2          15 sec;
}

listen  # address [port] that racoon will listen on
{
        isakmp          172.16.5.4 [500];
        isakmp_natt     172.16.5.4 [4500];
}

remote  192.168.1.12 [500]
{
        exchange_mode   main,aggressive;
        doi             ipsec_doi;
        situation       identity_only;
        my_identifier   address 172.16.5.4;
        peers_identifier        address 192.168.1.12;
        lifetime        time 8 hour;
        passive         off;
        proposal_check  obey;
#       nat_traversal   off;
        generate_policy off;

                        proposal {
                                encryption_algorithm    blowfish;
                                hash_algorithm          md5;
                                authentication_method   pre_shared_key;
                                lifetime time           30 sec;
                                dh_group                1;
                        }
}

sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)    # address $network/$netmask $type address $network/$netmask $type ( $type being any or esp)
{                                                               # $network must be the two internal networks you are joining.
        pfs_group       1;
        lifetime        time    36000 sec;
        encryption_algorithm    blowfish,3des;
        authentication_algorithm        hmac_md5,hmac_sha1;
        compression_algorithm   deflate;
}</pre></div></div><div class=paragraph><p>Eine Beschreibung der verfügbaren Optionen finden Sie in der Manualpage von <span class=filename>racoon.conf</span>.</p></div><div class=paragraph><p>Die Security Policy Database (SPD) muss noch konfiguriert werden, so dass FreeBSD und racoon in der Lage sind den Netzwerkverkehr zwischen den Hosts zu ver- und entschlüsseln.</p></div><div class=paragraph><p>Dies wird durch ein Shellskript ähnlich wie das folgende, das auf dem Firmennetzwerk-Gateway liegt, ausgeführt. Diese Datei wird während der Systeminitialisierung ausgeführt und sollte unter <span class=filename>/usr/local/etc/racoon/setkey.conf</span> gespeichert werden.</p></div><div class="literalblock programlisting"><div class=content><pre>flush;
spdflush;

# To the home network
spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
spdadd 10.0.0.0/24 10.246.38.0/24 any -P in ipsec esp/tunnel/192.168.1.12-172.16.5.4/use;</pre></div></div><div class=paragraph><p>Nachdem die Datei gespeichert wurde, kann racoon durch das folgende Kommando auf beiden Gateways gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log</span></code></pre></div></div><div class=paragraph><p>Die Ausgabe sollte so ähnlich aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
Foreground mode.
2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=28496098(0x1b2d0e2)
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=47784998(0x2d92426)
2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=124397467(0x76a279b)
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=175852902(0xa7b4d66)</pre></div></div><div class=paragraph><p>Um sicherzustellen, dass der Tunnel richtig funktioniert, wechseln Sie auf eine andere Konsole und benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> mit dem folgenden Befehl, um sich den Netzwerkverkehr anzusehen. Tauschen Sie <code>em0</code> durch die richtige Netzwerkkarte aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tcpdump -i em0 host 172.16.5.4 and dst 192.168.1.12</span></code></pre></div></div><div class=paragraph><p>Die Ausgabe der Konsole sollte dem hier ähneln. Wenn nicht, gibt es ein Problem und ein Debuggen der ausgegebenen Daten ist notwendig.</p></div><div class="literalblock programlisting"><div class=content><pre>01:47:32.021683 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
01:47:33.022442 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
01:47:34.024218 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)</pre></div></div><div class=paragraph><p>An diesem Punkt sollten beide Netzwerke verfügbar sein und den Anschein haben, dass sie zum selben Netzwerk gehören. Meistens sind beide Netzwerke durch eine Firewall geschützt. Um den Netzwerkverkehr zwischen den beiden Netzwerken zu erlauben, ist es notwendig Regeln zu erstellen. Für die <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> Firewall fügen Sie folgende Zeilen in die Firewall-Konfigurationsdatei ein:</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 00201 allow log esp from any to any
ipfw add 00202 allow log ah from any to any
ipfw add 00203 allow log ipencap from any to any
ipfw add 00204 allow log udp from any 500 to any</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Regelnummern müssen eventuell, je nach Hostkonfiguration, angepasst werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Für Benutzer der <a href="https://man.freebsd.org/cgi/man.cgi?query=pf&amp;sektion=4&amp;format=html">pf(4)</a>- oder <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a>-Firewall sollte folgendes funktionieren:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in quick proto esp from any to any
pass in quick proto ah from any to any
pass in quick proto ipencap from any to any
pass in quick proto udp from any port = 500 to any port = 500
pass in quick on gif0 from any to any
pass out quick proto esp from any to any
pass out quick proto ah from any to any
pass out quick proto ipencap from any to any
pass out quick proto udp from any port = 500 to any port = 500
pass out quick on gif0 from any to any</pre></div></div><div class=paragraph><p>Zum Ende, um dem Computer den Start vom VPN während der Systeminitialisierung zu erlauben, fügen Sie folgende Zeilen in ihre <span class=filename>/etc/rc.conf</span>: ein</p></div><div class="literalblock programlisting"><div class=content><pre>ipsec_enable=&#34;YES&#34;
ipsec_program=&#34;/usr/local/sbin/setkey&#34;
ipsec_file=&#34;/usr/local/etc/racoon/setkey.conf&#34; # allows setting up spd policies on boot
racoon_enable=&#34;yes&#34;</pre></div></div></div></div><div class=sect2><h3 id=openssh>31.8. OpenSSH<a class=anchor href=#openssh></a></h3><div class=paragraph><p>OpenSSH stellt Werkzeuge bereit, um sicher auf entfernte Maschinen zuzugreifen. Zusätzlich können TCP/IP-Verbindungen sicher durch SSH getunnelt oder weitergeleitet werden. OpenSSH verschlüsselt alle Verbindungen. Dadurch wird beispielsweise verhindert, dass die Verbindung abgehört oder übernommen (Hijacking) werden kann. Weitere Informationen zu OpenSSH finden Sie auf <a href=http://www.openssh.com/>http://www.openssh.com/</a>.</p></div><div class=paragraph><p>Dieser Abschnitt enthält einen Überblick über die integrierten Client-Werkzeuge, mit denen Sie sicher auf entfernte Systeme zugreifen können, oder mit denen Sie sicher Dateien austauschen können. Der Abschnitt beschreibt auch die Konfiguration eines SSH-Servers auf einem FreeBSD-System. Weitere Informationen finden Sie in den hier erwähnten Manualpages.</p></div><div class=sect3><h4 id=_die_ssh_client_werkzeuge_benutzen>31.8.1. Die SSH Client-Werkzeuge benutzen<a class=anchor href=#_die_ssh_client_werkzeuge_benutzen></a></h4><div class=paragraph><p>Benutzen Sie <code>ssh</code> zusammen mit einem Benutzernamen und einer IP-Adresse oder dem Hostnamen, um sich an einem SSH-Server anzumelden. Ist dies das erste Mal, dass eine Verbindung mit dem angegebenen Server hergestellt wird, wird der Benutzer aufgefordert, zuerst den Fingerabdruck des Servers zu prüfen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ssh user@example.com</span>
The authenticity of host <span class=s1>&#39;example.com (10.0.0.1)&#39;</span> can<span class=s1>&#39;t be established.
ECDSA key fingerprint is 25:cc:73:b5:b3:96:75:3d:56:19:49:d2:5c:1f:91:3b.
Are you sure you want to continue connecting (yes/no)? yes
Permanently added &#39;</span>example.com<span class=s1>&#39; (ECDSA) to the list of known hosts.
Password for user@example.com: user_password</span></code></pre></div></div><div class=paragraph><p>SSH speichert einen Fingerabdruck des Serverschlüssels um die Echtheit des Servers zu überprüfen, wenn der Client eine Verbindung herstellt. Wenn der Benutzer den Fingerabdruck mit <code>yes</code> bestätigt, wird eine Kopie des Schlüssels in <span class=filename>.ssh/known_hosts</span> im Heimatverzeichnis des Benutzers gespeichert. Zukünftige Verbindungen zu dem Server werden gegen den gespeicherten Fingerabdruck des Schlüssels geprüft und der Client gibt eine Warnung aus, wenn sich der empfangene Fingerabdruck von dem gespeicherten unterscheidet. Wenn dies passiert, sollte zunächst geprüft werden, ob sich der Schlüssel geändert hat, bevor die Verbindung hergestellt wird.</p></div><div class=paragraph><p>In der Voreinstellung akzeptieren aktuelle Versionen von OpenSSH nur SSHv2 Verbindungen. Wenn möglich, wird der Client versuchen Version 2 zu verwenden, ist dies nicht möglich, fällt er auf Version 1 zurück. Der Client kann gezwungen werden, nur eine der beiden Versionen zu verwenden, indem die Option <code>-1</code> oder <code>-2</code> übergeben wird. Weitere Optionen sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> beschrieben.</p></div><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> lassen sich Dateien in einer sicheren Weise auf entfernte Maschinen übertragen. Dieses Beispiel kopiert die Datei <span class=filename>COPYRIGHT</span> von einem entfernten System in eine Datei mit dem gleichen Namen auf das lokale System:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  scp user@example.com:/COPYRIGHT COPYRIGHT</span>
Password <span class=k>for </span>user@example.com: <span class=k>*******</span>
COPYRIGHT            100% |<span class=k>*****************************</span>|  4735
00:00
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>Da der Fingerabdruck für diesen Rechner bereits bestätigt wurde, wird er automatisch überprüft, bevor der Benutzer zur Eingabe des Passworts aufgefordert wird.</p></div><div class=paragraph><p>Die Argumente, die <code>scp</code> übergeben werden, gleichen denen von <code>cp</code> in der Beziehung, dass die ersten Argumente die zu kopierenden Dateien sind und das letzte Argument den Bestimmungsort angibt. Da die Dateien über das Netzwerk kopiert werden, können ein oder mehrere Argumente die Form <code>user@host:&lt;path_to_remote_file></code> besitzen. Beachten Sie, das <code>scp</code> die Option <code>-r</code> verwendet um Dateien rekursiv zu kopieren, während <code>cp -R</code> benutzt.</p></div><div class=paragraph><p>Mit <code>sftp</code> können Dateien über eine interaktive Sitzung kopiert werden. <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> beschreibt die verfügbaren Befehle, die während einer <code>sftp</code>-Sitzung zur Verfügung stehen.</p></div><div class=sect4><h5 id=security-ssh-keygen>31.8.1.1. Schlüsselbasierte Authentifizierung<a class=anchor href=#security-ssh-keygen></a></h5><div class=paragraph><p>Ein Client kann bei der Verbindung auch Schlüssel anstelle von Passwörtern verwenden. Benutzen Sie <code>ssh-keygen</code> um RSA-Schlüssel erzeugen. Geben Sie das entsprechende Protokoll an, wenn Sie einen öffentlichen und einen privaten Schlüssel erzeugen. Folgen Sie anschließend den Anweisungen des Programms. Es wird empfohlen, die Schlüssel mit einer einprägsamen, aber schwer zu erratenen Passphrase zu schützen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-keygen <span class=nt>-t</span> rsa
Generating public/private rsa key pair.
Enter file <span class=k>in </span>which to save the key <span class=o>(</span>/home/user/.ssh/id_rsa<span class=o>)</span>:
Enter passphrase <span class=o>(</span>empty <span class=k>for </span>no passphrase<span class=o>)</span>:  <i class=conum data-value=1></i><b>(1)</b>
Enter same passphrase again:                 <i class=conum data-value=2></i><b>(2)</b>
Your identification has been saved <span class=k>in</span> /home/user/.ssh/id_rsa.
Your public key has been saved <span class=k>in</span> /home/user/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:54Xm9Uvtv6H4NOo6yjP/YCfODryvUU7yWHzMqeXwhq8 user@host.example.com
The key<span class=s1>&#39;s randomart image is:
+---[RSA 2048]----+
|                 |
|                 |
|                 |
|        . o..    |
|       .S*+*o    |
|      . O=Oo . . |
|       = Oo= oo..|
|      .oB.* +.oo.|
|       =OE**.o..=|
+----[SHA256]-----+</span></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Geben Sie hier die Passphrase ein. Diese darf auch Leer- und Sonderzeichen enthalten.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Geben Sie die Passphrase zur Überprüfung erneut ein.</td></tr></tbody></table></div><div class=paragraph><p>Der private Schlüssel wird in <span class=filename>~/.ssh/id_rsa</span> und der öffentliche Schlüssel in <span class=filename>~/.ssh/id_rsa.pub</span> gespeichert. Der <em>öffentliche</em> Schlüssel muss zuerst auf den entfernten Rechner nach <span class=filename>~/.ssh/authorized_keys</span> kopiert werden, damit die schlüsselbasierte Authentifizierung funktioniert.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Viele Benutzer denken, dass die Verwendung von Schlüsseln generell sicher ist. Sie verwenden dann einen Schlüssel ohne eine Passphrase. Dies ist jedoch sehr <em>gefährlich</em>. Ein Administrator kann überprüfen, ob ein Schlüsselpaar mit einer Passphrase geschützt ist. Wenn die Datei mit dem privaten Schlüssel den Text <code>ENCRYPTED</code> enthält, dann hat der Benutzer eine Passphrase verwendet. Um die Benutzer zusätzlich zu schützen, kann ein <code>from</code>-Feld in der Datei des öffentlichen Schlüssels hinzugefügt werden. Zum Beispiel würde das Hinzufügen von <code>from="192.168.10.5"</code> vor dem <code>ssh-rsa</code>-Präfix dafür sorgen, dass sich ein bestimmter Benutzer nur noch von dieser IP-Adresse anmelden darf.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Optionen und Dateinamen sind abhängig von der eingesetzten Version von OpenSSH. Die für das System gültigen Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>.</p></div><div class=paragraph><p>Wenn bei der Erzeugung des Schlüssels eine Passphrase angegeben wurde, wird der Benutzer bei jeder Anmeldung am Server zur Eingabe der Passphrase aufgefordert. Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> ist es möglich, SSH-Schlüssel in den Speicher zu laden, damit die Passphrase nicht jedes Mal eingegeben werden muss.</p></div><div class=paragraph><p><code>ssh-agent</code> übernimmt die Authentifizierung mit den geladenen privaten Schlüsseln. <code>ssh-agent</code> kann dazu verwendet werden, ein anderes Programm zu starten, beispielsweise eine Shell oder einen Window-Manager.</p></div><div class=paragraph><p>Um <code>ssh-agent</code> in einer Shell zu verwenden, muss es mit einer Shell als Argument aufgerufen werden. Die zu verwaltende Identität muss mit <code>ssh-add</code> sowie der Passphrase für den privaten Schlüssel übergeben werden. Danach kann sich der Benutzer mit <code>ssh</code> auf jedem Rechner anmelden, der einen entsprechenden öffentlichen Schlüssel besitzt. Dazu ein Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-agent csh
% ssh-add
Enter passphrase <span class=k>for</span> /usr/home/user/.ssh/id_rsa:  <i class=conum data-value=1></i><b>(1)</b>
Identity added: /usr/home/user/.ssh/id_rsa <span class=o>(</span>/home/user/.ssh/id_rsa<span class=o>)</span>
%</code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Geben Sie hier die Passphrase für den Schlüssel ein.</td></tr></tbody></table></div><div class=paragraph><p>Um <code>ssh-agent</code> unter Xorg zu verwenden, muss ein Eintrag für das Programm in <span class=filename>~/.xinitrc</span> aufgenommen werden. Dadurch können alle unter Xorg gestarteten Programme die Dienste von <code>ssh-agent</code> nutzen. <span class=filename>~/.xinitrc</span> könnte etwa so aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>exec ssh-agent startxfce4</pre></div></div><div class=paragraph><p>Dadurch wird bei jedem Start von Xorg zuerst <code>ssh-agent</code> aufgerufen, das wiederum XFCE startet. Nachdem diese Änderung durchgeführt wurde, muss Xorg neu gestartet werden. Danach können Sie mit <code>ssh-add</code> die SSH-Schlüssel laden.</p></div></div><div class=sect4><h5 id=security-ssh-tunneling>31.8.1.2. SSH-Tunnel<a class=anchor href=#security-ssh-tunneling></a></h5><div class=paragraph><p>Mit OpenSSH ist es möglich, einen Tunnel zu erstellen, in dem ein anderes Protokoll verschlüsselt übertragen wird.</p></div><div class=paragraph><p>Im folgenden Kommando erzeugt <code>ssh</code> einen Tunnel für <code>telnet</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5023:localhost:23 user@foo.example.com
%</code></pre></div></div><div class=paragraph><p>Dieses Beispiel verwendet die folgenden Optionen:</p></div><div class=dlist><dl><dt class=hdlist1><code>-2</code></dt><dd><p>Zwingt <code>ssh</code> dazu, die Version 2 des Protokolls zu verwenden, um sich mit dem Server zu verbinden.</p></dd><dt class=hdlist1><code>-N</code></dt><dd><p>Zeigt an, dass ein Tunnel erstellt werden soll. Ohne diese Option würde <code>ssh</code> eine normale Sitzung öffnen.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Zwingt <code>ssh</code> im Hintergrund zu laufen.</p></dd><dt class=hdlist1><code>-L</code></dt><dd><p>Ein lokaler Tunnel wird in der Form <em>localport:remotehost:remoteport</em> angegeben. Die Verbindung wird dabei von dem lokalen Port <em>localport</em> auf einen entfernten Rechner weitergeleitet.</p></dd><dt class=hdlist1><code>user@foo.example.com</code></dt><dd><p>Gibt den Anmeldenamen auf dem entfernten SSH-Server an.</p></dd></dl></div><div class=paragraph><p>Ein SSH-Tunnel erzeugt einen Socket auf <code>localhost</code> und dem angegebenen lokalen Port. Jede Verbindung, die auf dem angegebenen Socket aufgemacht wird, wird dann auf den spezifizierten entfernten Rechner und Port weitergeleitet. Im Beispiel wird der lokale Port <code>5023</code> an die entfernte Maschine auf Port <code>23</code> weitergeleitet. Da der Port 23 für <code>telnet</code> reserviert ist, erzeugt das eine sichere <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>-Verbindung durch einen SSH-Tunnel.</p></div><div class=paragraph><p>Wie in den folgenden Beispielen zu sehen ist, kann diese Vorgehensweise genutzt werden, um jedes unsichere TCP-Protokoll, wie SMTP, POP3 und FTP, weiterzuleiten.</p></div><div class=exampleblock><div class=title>Beispiel 30. Einen sicheren Tunnel für SMTP erstellen</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com<span class=s1>&#39;s password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;</span>^]<span class=s1>&#39;.
220 mailserver.example.com ESMTP</span></code></pre></div></div><div class=paragraph><p>Zusammen mit <code>ssh-keygen</code> und zusätzlichen Benutzer-Accounts können leicht benutzbare SSH-Tunnel aufgebaut werden. Anstelle von Passwörtern können Schlüssel benutzt werden und jeder Tunnel kann unter einem eigenen Benutzer laufen.</p></div></div></div><div class=exampleblock><div class=title>Beispiel 31. Sicherer Zugriff auf einen POP3-Server</div><div class=content><div class=paragraph><p>In diesem Beispiel gibt es einen SSH-Server, der Verbindungen von außen akzeptiert. Im selben Netzwerk befindet sich zudem noch ein Mail-Server, der POP3 spricht. Um E-Mails auf sichere Weise abzurufen, bauen Sie eine SSH-Verbindung zu dem SSH-Server im Netzwerk auf und tunneln von dort zum Mail-Server weiter.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com<span class=s1>&#39;s password: ******</span></code></pre></div></div><div class=paragraph><p>Wenn Sie den Tunnel eingerichtet haben, konfigurieren Sie den Mail-Client so, dass er POP3 Anfragen zu <code>localhost</code> auf Port 2110 sendet. Diese Verbindung wird dann über den gesicherten Tunnel zu <code>mail.example.com</code> weitergeleitet.</p></div></div></div><div class=exampleblock><div class=title>Beispiel 32. Umgehen einer Firewall</div><div class=content><div class=paragraph><p>Einige Firewalls filtern sowohl eingehende als auch ausgehende Verbindungen. Zum Beispiel könnte eine Firewall den Zugriff auf entfernte Rechner auf die Ports 22 und 80 beschränken, um lediglich SSH und Web-Inhalte zu erlauben. Dies würde den Zugriff auf Dienste verhindern, die nicht die Ports 22 oder 80 benutzen.</p></div><div class=paragraph><p>Die Lösung hier ist es, eine SSH-Verbindung zu einer Maschine außerhalb der Firewall aufzumachen und durch diese zum gewünschten Dienst zu tunneln:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 8888:music.example.com:8000 user@unfirewalled-system.example.org
user@unfirewalled-system.example.org<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>In diesem Beispiel benutzt ein Ogg Vorbis Client <code>localhost</code> und Port 8888. Die Verbindung wird dann zu <code>music.example.com</code> Port 8000 weitergeleitet. Die Firewall wurde somit erfolgreich umgangen.</p></div></div></div></div></div><div class=sect3><h4 id=_den_ssh_server_aktivieren>31.8.2. Den SSH-Server aktivieren<a class=anchor href=#_den_ssh_server_aktivieren></a></h4><div class=paragraph><p>Neben den integrierten SSH Client-Werkzeugen, die zur Verfügung stehen, kann ein FreeBSD-System auch als SSH-Server konfiguriert werden, um Verbindungen von anderen SSH-Clients zu akzeptieren.</p></div><div class=paragraph><p>Benutzen Sie den Kommando <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a>, um zu prüfen ob der sshd ausgeführt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd status</span></code></pre></div></div><div class=paragraph><p>Wenn der Dienst nicht ausgeführt wird, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Diese Zeile startet <code>sshd</code>, den OpenSSH-Daemon, beim nächsten Systemstart. Geben Sie folgendes ein, um den Dienst jetzt zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd start</span></code></pre></div></div><div class=paragraph><p>Wenn <code>sshd</code> erstmalig gestartet wird, werden die Host-Schlüssel des Systems erzeugt und der Fingerabdruck wird auf der Konsole angezeigt. Stellen Sie den Fingerabdruck den Benutzern zur Verfügung, sodass sie ihn überprüfen können, wenn sie das erste Mal eine Verbindung mit dem Server herstellen.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> enthält die verfügbaren Optionen für den Start von <code>sshd</code> und weitere Informationen zur Authentifizierung, den Anmeldeprozess und die verschiedenen Konfigurationsdateien.</p></div><div class=paragraph><p>Ab jetzt sollte sshd für alle Benutzer mit einem Benutzernamen und Kennwort zur Verfügung stehen.</p></div></div><div class=sect3><h4 id=_ssh_server_sicherheit>31.8.3. SSH Server Sicherheit<a class=anchor href=#_ssh_server_sicherheit></a></h4><div class=paragraph><p>Obwohl sshd das am weitesten verbreitete Remote-Administrations-Werkzeug ist, sind Brute-Force- und Drive-by-Angriffe auf öffentliche Netzwerke weit verbreitet. Daher stehen mehrere Optionen zur Verfügung, um diese Art von Angriffen zu verhindern. Diese Optionen werden in diesem Abschnitt beschrieben.</p></div><div class=paragraph><p>Es ist in der Regel ein gute Idee, festzulegen, welche Benutzer sich von welchem Rechner aus anmelden können. Dies lässt sich beispielsweise über die Option <code>AllowUsers</code> festlegen. Soll sich etwa nur <code>root</code> vom Rechner mit der IP-Adresse <code>192.168.1.32</code> aus einwählen dürfen, würden Sie folgenden Eintrag in <span class=filename>/etc/ssh/sshd_config</span> aufnehmen:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32</pre></div></div><div class=paragraph><p>Damit sich <code>admin</code> von jedem Rechner aus anmelden kann, geben Sie nur den Benutzernamen an:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers admin</pre></div></div><div class=paragraph><p>Sie können auch mehrere Benutzer in einer Zeile aufführen:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32 admin</pre></div></div><div class=paragraph><p>Nachdem Sie <span class=filename>/etc/ssh/sshd_config</span> angepasst haben, muss <code>sshd</code> seine Konfigurationsdateien neu einlesen. Dazu geben Sie Folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd reload</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn die Option <code>AllowUsers</code> verwendet wird, ist es wichtig, jeden Benutzer aufzulisten, der sich an diesem Rechner anmelden muss. Benutzer, die nicht in dieser Liste aufgeführt sind, dürfen sich nicht anmelden. Die Optionen für die Konfigurationsdatei von OpenSSH unterscheiden zwischen Groß- und Kleinschreibung. Wenn Sie eine Option falsch schreiben, so wird sie ingnoriert. Testen Sie immer die Änderungen, um sicherzustellen, dass sie wie erwartet funktionieren. Weitere Informationen zu den verfügbaren Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Darüber hinaus können Benutzer gezwungen werden, eine Zwei-Faktor-Authentifizierung mit einem öffentlichen und einem privaten Schlüssel zu benutzen. Bei Bedarf kann der Benutzer ein Schlüsselpaar mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> erzeugen und dem Administrator den öffentlichen Schlüssel zukommen lassen. Der Schlüssel wird, wie weiter oben beschrieben, in <span class=filename>authorized_keys</span> platziert. Um den Benutzer zu zwingen, ausschließlich Schlüssel zu benutzen, kann die folgende Option konfiguriert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>AuthenticationMethods publickey</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Verwechseln Sie nicht <span class=filename>/etc/ssh/sshd_config</span> mit <span class=filename>/etc/ssh/ssh_config</span> (beachten Sie das zusätzliche <code>d</code> im ersten Dateinamen). Die erste Datei konfiguriert den Server und die zweite Datei konfiguriert den Client. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh_config&amp;sektion=5&amp;format=html">ssh_config(5)</a> enthält eine Auflistung der verfügbaren Client-Einstellungen.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=fs-acl>31.9. Zugriffskontrolllisten für Dateisysteme (ACL)<a class=anchor href=#fs-acl></a></h3><div class=paragraph><p><em>Zugriffskontrolllisten</em> (Access Control Lists, ACL) erweitern die normalen Zugriffsrechte von UNIX® Systemen auf eine kompatible (POSIX®.1e) Weise und bieten feiner granulierte Sicherheitsmechanismen.</p></div><div class=paragraph><p>Der <span class=filename>GENERIC</span>-Kernel von FreeBSD bietet ACL-Unterstützung für UFS-Dateisysteme. Benutzer, die es vorziehen einen eigenen Kernel zu übersetzen, müssen die folgende Option in die Kernelkonfigurationsdatei aufnehmen:</p></div><div class="literalblock programlisting"><div class=content><pre>options UFS_ACL</pre></div></div><div class=paragraph><p>Das System gibt eine Warnung aus, wenn ein Dateisystem mit ACLs eingehangen werden soll und die Unterstützung für ACLs nicht im Kernel aktiviert ist. ACLs bauen auf den erweiterten Attributen auf, die von UFS2 standardmäßig unterstützt werden.</p></div><div class=paragraph><p>Dieses Kapitel beschreibt, wie ACL-Unterstützung aktiviert wird. Zudem werden einige Anwendungsbeispiele vorgestellt.</p></div><div class=sect3><h4 id=_acl_unterstützung_aktivieren>31.9.1. ACL-Unterstützung aktivieren<a class=anchor href=#_acl_unterstützung_aktivieren></a></h4><div class=paragraph><p>Die Option <code>acl</code> in <span class=filename>/etc/fstab</span> aktiviert Zugriffskontrolllisten für ein Dateisystem. Die bevorzugte Möglichkeit ist die Verwendung von Zugriffskontrolllisten mit <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> (Option <code>-a</code>), im Superblock des Dateisystems festzuschreiben. Diese Möglichkeit hat mehrere Vorteile:</p></div><div class=ulist><ul><li><p>Nochmaliges Einhängen eines Dateisystems (Option <code>-u</code> von <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>) verändert den Status der Zugriffskontrolllisten nicht. Die Verwendung von Zugriffskontrolllisten kann nur durch Abhängen und erneutes Einhängen eines Dateisystems verändert werden. Das heißt auch, dass Zugriffskontrolllisten nicht nachträglich auf dem Root-Dateisystem aktiviert werden können.</p></li><li><p>Die Zugriffskontrolllisten auf den Dateisystemen sind, unabhängig von den Optionen in <span class=filename>/etc/fstab</span> oder Namensänderungen der Geräte, immer aktiv. Dies verhindert auch, dass Zugriffskontrolllisten aus Versehen auf Dateisystemen ohne Zugriffskontrolllisten aktiviert werden.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es kann sein, dass sich der Status von Zugriffskontrolllisten später durch nochmaliges Einhängen des Dateisystems (Option <code>-u</code> von <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>) ändern lässt. Die momentane Variante ist aber sicherer, da der Status der Zugriffskontrolllisten nicht versehentlich geändert werden kann. Allgemein sollten Zugriffskontrolllisten auf einem Dateisystem, auf dem sie einmal verwendet wurden, nicht deaktiviert werden, da danach die Zugriffsrechte falsch sein können. Werden Zugriffskontrolllisten auf einem solchen Dateisystem wieder aktiviert, werden die Zugriffsrechte von Dateien, die sich zwischenzeitlich geändert haben, überschrieben, was zu erneuten Problemen führt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Zugriffsrechte einer Datei werden durch ein <code>+</code> (Plus) gekennzeichnet, wenn die Datei durch Zugriffskontrolllisten geschützt ist:</p></div><div class="literalblock programlisting"><div class=content><pre>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</pre></div></div><div class=paragraph><p>In diesem Beispiel sind die Verzeichnisse <span class=filename>directory1</span>, <span class=filename>directory2</span> und <span class=filename>directory3</span> durch Zugriffskontrolllisten geschützt, wohingegen das Verzeichnis <span class=filename>public_html</span> nicht geschützt ist.</p></div></div><div class=sect3><h4 id=_zugriffskontrolllisten_benutzen>31.9.2. Zugriffskontrolllisten benutzen<a class=anchor href=#_zugriffskontrolllisten_benutzen></a></h4><div class=paragraph><p><code>getfacl</code> zeigt Zugriffskontrolllisten an. Das folgende Kommando zeigt die ACLs auf der Datei <span class=filename>test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% getfacl <span class=nb>test</span>
	<span class=c>#file:test</span>
	<span class=c>#owner:1001</span>
	<span class=c>#group:1001</span>
	user::rw-
	group::r--
	other::r--</code></pre></div></div><div class=paragraph><p><code>setfacl</code> ändert oder entfernt ACLs auf Dateien. Um alle ACLs einer Datei zu entfernen, können Sie die Option <code>-k</code> benutzen. Es ist jedoch empfehlenswert die Option <code>-b</code> zu verwenden, da sie die erforderlichen Felder, die für ACLs benötigt werden, beibehält.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfacl -k test</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie <code>-m</code> um die Einträge der ACL zu verändern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-m</span> u:trhodes:rwx,g:web:r--,o::--- <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>In diesem Beispiel gab es keine vordefinierten Einträge, da sie durch den vorhergehenden Befehl entfernt wurden. Mit diesem Kommando werden die eben entfernten Zugriffskontrolllisten wiederhergestellt. Der Befehl gibt die Fehlermeldung <code>Invalid argument</code> aus, wenn Sie nicht existierende Benutzer oder Gruppen als Parameter angeben.</p></div><div class=paragraph><p>Weitere Informationen zu den Optionen dieser Kommandos finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a>.</p></div></div></div><div class=sect2><h3 id=security-pkg>31.10. Sicherheitsprobleme in Software von Drittanbietern überwachen<a class=anchor href=#security-pkg></a></h3><div class=paragraph><p>In den letzten Jahren wurden zahlreiche Verbesserungen in der Einschätzung und dem Umgang mit Sicherheitsproblemen erzielt. Die Gefahr von Einbrüchen in ein System wird aber immer größer, da Softwarepakete von Dritten auf nahezu jedem Betriebssystem installiert und konfiguriert werden.</p></div><div class=paragraph><p>Die Einschätzung der Verletzlichkeit eines Systems ist ein Schlüsselfaktor für dessen Sicherheit. FreeBSD veröffentlicht zwar Sicherheitshinweise (security advisories) für das Basissystem, das Projekt ist allerdings nicht dazu in der Lage, dies auch für die zahlreichen Softwarepakete von Dritten zu tun. Dennoch gibt es einen Weg, auch diese Programmpakete zu überwachen. Das FreeBSD Dienstprogramm pkg enthält Optionen für genau diesen Anwendungsfall.</p></div><div class=paragraph><p>pkg fragt dazu eine Datenbank auf bekannte Sicherheitsprobleme ab. Diese Datenbank wird vom FreeBSD Security Team sowie den Ports-Entwicklern aktualisiert und gewartet.</p></div><div class=paragraph><p>Anweisungen zur Installation von pkg finden Sie im <a href=./#pkgng-intro>Benutzen von pkg zur Verwaltung von Binärpaketen</a>.</p></div><div class=paragraph><p>Die Installation enthält Konfigurationsdateien für <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>, welche die Datenbank von pkg verwaltet und aktualisiert. Diese Funktionalität wird aktiviert, wenn in <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic.conf&amp;sektion=5&amp;format=html">periodic.conf(5)</a> die Variable <code>daily_status_security_pkgaudit_enable</code> auf <code>YES</code> gesetzt wird. Stellen Sie auf jeden Fall sicher, dass diese (an das E-Mail-Konto von <code>root</code> gesendeten) Sicherheitsberichte auch gelesen werden.</p></div><div class=paragraph><p>Nach der Installation kann ein Administrator mit dem folgenden Kommando die Datenbank aktualisieren und sich die Sicherheitslücken in installierten Paketen anzeigen lassen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg audit -F</span></code></pre></div></div><div class=paragraph><p>pkg zeigt dann die Schwachstellen in installierten Pakete an:</p></div><div class="literalblock programlisting"><div class=content><pre>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;https://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</pre></div></div><div class=paragraph><p>Wenn Sie die angegebene URL über einen Internetbrowser aufrufen, erhalten Sie weitere Informationen über die bestehende Sicherheitslücke, wie die betroffenen Versionen, die Version des FreeBSD-Ports sowie Hinweise auf weitere Seiten, die ebenfalls Sicherheitshinweise zu diesem Problem bieten.</p></div><div class=paragraph><p>pkg ist ein mächtiges Werkzeug und insbesondere in Zusammenarbeit mit <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> äußerst hilfreich.</p></div></div><div class=sect2><h3 id=security-advisories>31.11. FreeBSD Sicherheitshinweise<a class=anchor href=#security-advisories></a></h3><div class=paragraph><p>Wie viele andere Hersteller von hochwertigen Betriebssystemen, hat auch das FreeBSD-Projekt ein Sicherheitsteam, das für die Bestimmung des End-of-Life (EoL) Datum verantwortlich ist. Das Sicherheitsteam stellt zudem sicher, dass Sicherheitsupdates für unterstützte Versionen, welche noch nicht ihr EoL erreicht haben, zur Verfügung gestellt werden. Weitere Informationen über das FreeBSD Sicherheitsteam und den unterstützten Versionen finden Sie auf der Webseite <a href=https://www.FreeBSD.org/security>FreeBSD Security</a>.</p></div><div class=paragraph><p>Zu den Aufgaben des Sicherheitsteams zählt es, auf gemeldete Sicherheitslücken im FreeBSD-Betriebssystem zu reagieren. Sobald eine Sicherheitslücke bestätigt wird, überprüft das Sicherheitsteam die notwendigen Schritte, um die Schwachstelle zu beheben und den Quellcode mit der Korrektur zu aktualisieren. Anschließend veröffentlicht es die Details in einem Sicherheitshinweis (Security Advisory). Die Sicherheitshinweise werden auf der <a href=https://www.FreeBSD.org/security/advisories/>FreeBSD Webseite</a> und auf den Mailinglisten <a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>FreeBSD security notifications</a>, <a href=https://lists.FreeBSD.org/subscription/freebsd-security>FreeBSD security</a> und <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>FreeBSD announcements</a> veröffentlicht.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt das Format eines FreeBSD Sicherheitshinweises.</p></div><div class=sect3><h4 id=_format_eines_sicherheitshinweis>31.11.1. Format eines Sicherheitshinweis<a class=anchor href=#_format_eines_sicherheitshinweis></a></h4><div class=paragraph><p>Hier ist ein Beispiel für einen FreeBSD Sicherheitshinweis:</p></div><div class="literalblock programlisting"><div class=content><pre>=============================================================================
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

=============================================================================
FreeBSD-SA-14:04.bind                                       Security Advisory
                                                          The FreeBSD Project

Topic:          BIND remote denial of service vulnerability

Category:       contrib
Module:         bind
Announced:      2014-01-14
Credits:        ISC
Affects:        FreeBSD 8.x and FreeBSD 9.x
Corrected:      2014-01-14 19:38:37 UTC (stable/9, 9.2-STABLE)
                2014-01-14 19:42:28 UTC (releng/9.2, 9.2-RELEASE-p3)
                2014-01-14 19:42:28 UTC (releng/9.1, 9.1-RELEASE-p10)
                2014-01-14 19:38:37 UTC (stable/8, 8.4-STABLE)
                2014-01-14 19:42:28 UTC (releng/8.4, 8.4-RELEASE-p7)
                2014-01-14 19:42:28 UTC (releng/8.3, 8.3-RELEASE-p14)
CVE Name:       CVE-2014-0591

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit &lt;URL:http://security.FreeBSD.org/&gt;.

I.   Background

BIND 9 is an implementation of the Domain Name System (DNS) protocols.
The named(8) daemon is an Internet Domain Name Server.

II.  Problem Description

Because of a defect in handling queries for NSEC3-signed zones, BIND can
crash with an &#34;INSIST&#34; failure in name.c when processing queries possessing
certain properties.  This issue only affects authoritative nameservers with
at least one NSEC3-signed zone.  Recursive-only servers are not at risk.

III. Impact

An attacker who can send a specially crafted query could cause named(8)
to crash, resulting in a denial of service.

IV.  Workaround

No workaround is available, but systems not running authoritative DNS service
with at least one NSEC3-signed zone using named(8) are not vulnerable.

V.   Solution

Perform one of the following:

1) Upgrade your vulnerable system to a supported FreeBSD stable or
release / security branch (releng) dated after the correction date.

2) To update your vulnerable system via a source code patch:

The following patches have been verified to apply to the applicable
FreeBSD release branches.

a) Download the relevant patch from the location below, and verify the
detached PGP signature using your PGP utility.

[FreeBSD 8.3, 8.4, 9.1, 9.2-RELEASE and 8.4-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch.asc
# gpg --verify bind-release.patch.asc

[FreeBSD 9.2-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch.asc
# gpg --verify bind-stable-9.patch.asc

b) Execute the following commands as root:

# cd /usr/src
# patch &lt; /path/to/patch

Recompile the operating system using buildworld and installworld as
described in &lt;URL:https://www.FreeBSD.org/handbook/makeworld.html&gt;.

Restart the applicable daemons, or reboot the system.

3) To update your vulnerable system via a binary patch:

Systems running a RELEASE version of FreeBSD on the i386 or amd64
platforms can be updated via the freebsd-update(8) utility:

# freebsd-update fetch
# freebsd-update install

VI.  Correction details

The following list contains the correction revision numbers for each
affected branch.

Branch/path                                                      Revision
- -------------------------------------------------------------------------
stable/8/                                                         r260646
releng/8.3/                                                       r260647
releng/8.4/                                                       r260647
stable/9/                                                         r260646
releng/9.1/                                                       r260647
releng/9.2/                                                       r260647
- -------------------------------------------------------------------------

To see which files were modified by a particular revision, run the
following command, replacing NNNNNN with the revision number, on a
machine with Subversion installed:

# svn diff -cNNNNNN --summarize svn://svn.freebsd.org/base

Or visit the following URL, replacing NNNNNN with the revision number:

&lt;URL:https://svnweb.freebsd.org/base?view=revision&amp;revision=NNNNNN&gt;

VII. References

&lt;URL:https://kb.isc.org/article/AA-01078&gt;

&lt;URL:http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0591&gt;

The latest revision of this advisory is available at
&lt;URL:http://security.FreeBSD.org/advisories/FreeBSD-SA-14:04.bind.asc&gt;
-----BEGIN PGP SIGNATURE-----

iQIcBAEBCgAGBQJS1ZTYAAoJEO1n7NZdz2rnOvQP/2/68/s9Cu35PmqNtSZVVxVG
ZSQP5EGWx/lramNf9566iKxOrLRMq/h3XWcC4goVd+gZFrvITJSVOWSa7ntDQ7TO
XcinfRZ/iyiJbs/Rg2wLHc/t5oVSyeouyccqODYFbOwOlk35JjOTMUG1YcX+Zasg
ax8RV+7Zt1QSBkMlOz/myBLXUjlTZ3Xg2FXVsfFQW5/g2CjuHpRSFx1bVNX6ysoG
9DT58EQcYxIS8WfkHRbbXKh9I1nSfZ7/Hky/kTafRdRMrjAgbqFgHkYTYsBZeav5
fYWKGQRJulYfeZQ90yMTvlpF42DjCC3uJYamJnwDIu8OhS1WRBI8fQfr9DRzmRua
OK3BK9hUiScDZOJB6OqeVzUTfe7MAA4/UwrDtTYQ+PqAenv1PK8DZqwXyxA9ThHb
zKO3OwuKOVHJnKvpOcr+eNwo7jbnHlis0oBksj/mrq2P9m2ueF9gzCiq5Ri5Syag
Wssb1HUoMGwqU0roS8+pRpNC8YgsWpsttvUWSZ8u6Vj/FLeHpiV3mYXPVMaKRhVm
067BA2uj4Th1JKtGleox+Em0R7OFbCc/9aWC67wiqI6KRyit9pYiF3npph+7D5Eq
7zPsUdDd+qc+UTiLp3liCRp5w6484wWdhZO6wRtmUgxGjNkxFoNnX8CitzF8AaqO
UWWemqWuz3lAZuORQ9KX
=OQzQ
-----END PGP SIGNATURE-----</pre></div></div><div class=paragraph><p>Jeder Sicherheitshinweis verwendet das folgende Format:</p></div><div class=ulist><ul><li><p>Jeder Sicherheitshinweis wird mit dem PGP-Schlüssel des Sicherheitsbeauftragten unterzeichnet. Der öffentliche Schlüssel des Sicherheitsbeauftragten kann in <a href=./#pgpkeys>OpenPGP-Schlüssel</a> überprüft werden.</p></li><li><p>Der Name des Sicherheitshinweises beginnt immer mit <code>FreeBSD-SA-</code> (für FreeBSD Security Advisory), gefolgt vom Jahr im zweistelligen Format (<code>14:</code>), gefolgt von der Anzahl von Sicherheitshinweisen für dieses Jahr (<code>04.</code>), gefolgt vom Namen der Anwendung oder des betroffenen Subsystems (<code>bind</code>). Der hier gezeigte Sicherheitshinweis ist der vierte Hinweis für das Jahr 2014 und betrifft die Anwendung BIND.</p></li><li><p>Das Feld <code>Topic</code> enthält eine Beschreibung der Schwachstelle.</p></li><li><p>Das Feld <code>Category</code> beschreibt den betroffenen Systemteil. Mögliche Werte für dieses Feld sind <code>core</code>, <code>contrib</code> oder <code>ports</code>. Die Kategorie <code>core</code> gilt für Komponenten des FreeBSD-Betriebssystems, die Kategorie <code>contrib</code> beschreibt zum Basissystem gehörende Software Dritter, beispielsweise BIND. Die Kategorie <code>ports</code> beschreibt Software, die Teil der Ports-Sammlung ist.</p></li><li><p>Das Feld <code>Module</code> beschreibt die betroffene Komponente. Im diesem Beispiel ist das <code>bind</code>-Modul betroffen, dass heißt dieses Problem betrifft eine Anwendung aus dem Betriebssystem.</p></li><li><p>Das Feld <code>Announced</code> gibt den Zeitpunkt der Bekanntgabe des Sicherheitshinweises an. Das bedeutet, dass das Sicherheitsteam das Problem bestätigt hat und das eine entsprechende Korrektur bereits im FreeBSD Quellcode-Repository zur Verfügung steht .</p></li><li><p>Das Feld <code>Credits</code> gibt die Person oder Organisation an, die das Sicherheitsproblem bemerkt und gemeldet hat.</p></li><li><p>Das Feld <code>Affects</code> listet die FreeBSD-Releases auf, die von dem Problem betroffen sind.</p></li><li><p>Das Feld <code>Corrected</code> zeigt an, wann das Problem in welchem Release behoben wurde. Der Teil in Klammern zeigt an, in welchem Zweig die Aktualisierung eingeflossen ist und die entsprechende Versionsnummer und Patch-Level des Release. Der Patch-Level besteht aus dem Buchstaben <code>p</code>, gefolgt von einer Nummer. Dies erlaubt es dem Benutzer festzustellen, welche Korrekturen bereits auf dem System eingespielt wurden.</p></li><li><p>Reserviert für Informationen, über die auf <a href=http://cve.mitre.org>cve.mitre.org</a> nach Sicherheitslücken gesucht werden kann.</p></li><li><p>Im Feld <code>Background</code> wird das betroffene Modul beschrieben.</p></li><li><p>Im Feld <code>Problem Description</code> wird das Sicherheitsproblem beschrieben. Hier wird fehlerhafter Code beschrieben oder geschildert, wie ein Werkzeug ausgenutzt werden könnte.</p></li><li><p>Das Feld <code>Impact</code> beschreibt die Auswirkungen des Sicherheitsproblems auf ein System.</p></li><li><p>Im Feld <code>Workaround</code> wird eine Umgehung des Sicherheitsproblems beschrieben. Die Umgehung ist für Administratoren gedacht, die das System aus Zeitnot, Netzwerk-technischen oder anderen Gründen nicht aktualisieren können.</p></li><li><p>Das Feld <code>Solution</code> enthält eine getestete Schritt-für-Schritt Anleitung, die das Sicherheitsproblem behebt.</p></li><li><p>Das Feld <code>Correction Details</code> enthält die Subversion-Tags der betroffenen Dateien zusammen mit zugehörigen Revisionsnummern, in denen das Problem behoben wurde.</p></li><li><p>Im Feld <code>References</code> finden sich Verweise auf weitere Informationsquellen.</p></li></ul></div></div></div><div class=sect2><h3 id=security-accounting>31.12. Prozess-Überwachung<a class=anchor href=#security-accounting></a></h3><div class=paragraph><p>Prozess-Überwachung (Process accounting) ist ein Sicherheitsverfahren, bei dem ein Administrator verfolgt, welche Systemressourcen verwendet werden und wie sich diese auf die einzelnen Anwender verteilen. Dadurch kann das System überwacht werden und es ist sogar möglich, zu kontrollieren, welche Befehle ein Anwender eingibt.</p></div><div class=paragraph><p>Die Überwachung von Prozessen hat sowohl Vor- als auch Nachteile. Positiv ist, dass man einen Einbruchsversuch bis an den Anfang zurückverfolgen kann. Von Nachteil ist allerdings, dass durch diesen Prozess Unmengen an Protokolldateien erzeugt werden, die auch dementsprechenden Plattenplatz benötigen. Dieser Abschnitt beschreibt die Grundlagen der Prozess-Überwachung.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie eine differenzierte Prozess-Überwachung benötigen, lesen Sie <a href=./#audit>Security Event Auditing</a>.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_die_prozess_überwachung_aktivieren_und_konfigurieren>31.12.1. Die Prozess-Überwachung aktivieren und konfigurieren<a class=anchor href=#_die_prozess_überwachung_aktivieren_und_konfigurieren></a></h4><div class=paragraph><p>Bevor Sie die Prozess-Überwachung verwenden können, müssen Sie diese über die folgenden Befehle aktivieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc accounting_enable=yes</span>
<span class=c># service accounting start</span></code></pre></div></div><div class=paragraph><p>Die Informationen werden unterhalb von <span class=filename>/var/account</span> gespeichert. Das Verzeichnis wird beim ersten Start des Dienstes automatisch erstellt. Die Dateien enthalten sensible Informationen, einschließlich aller Befehle, die von allen Benutzern ausgeführt wurden. Der Schreibzugriff auf diese Dateien ist auf <code>root</code> beschränkt, der Lesezugriff auf <code>root</code> und Mitgliedern der Gruppe <code>wheel</code>. Um zu verhindern, dass die Mitglieder der Gruppe <code>wheel</code> die Dateien lesen können, ändern Sie den Modus des Verzeichnisses <span class=filename>/var/account</span> so, dass der Zugriff nur durch <code>root</code> möglich ist.</p></div><div class=paragraph><p>Einmal aktiviert, wird sofort mit der Überwachung von CPU-Statistiken, Befehlen und anderen Vorgängen begonnen. Protokolldateien werden in einem nur von Maschinen lesbaren Format gespeichert und können mit <code>sa</code> aufgerufen werden. Ohne Optionen gibt <code>sa</code> Informationen wie die Anzahl der Aufrufe pro Anwender, die abgelaufene Zeit in Minuten, die gesamte CPU- und Anwenderzeit in Minuten und die durchschnittliche Anzahl der Ein- und Ausgabeoperationen aus. <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> enthält eine Liste der Optionen, welche die Ausgabe steuern.</p></div><div class=paragraph><p>Benutzen Sie <code>lastcomm</code>, um die von den Benutzern ausgeführten Befehle anzuzeigen. Dieses Beispiel zeigt die Nutzung von <code>ls</code> durch <code>trhodes</code> auf dem Terminal <code>ttyp1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lastcomm ls trhodes ttyp1</span></code></pre></div></div><div class=paragraph><p>Zahlreiche weitere nützliche Optionen finden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>.</p></div></div></div><div class=sect2><h3 id=security-resourcelimits>31.13. Einschränkung von Ressourcen<a class=anchor href=#security-resourcelimits></a></h3><div class=paragraph><p>FreeBSD bietet dem Systemadministrator mehrere Möglichkeiten die System-Ressourcen, die ein einzelner Benutzer verwenden kann, einzuschränken. Festplatten-Kontingente schränken den Plattenplatz, der einem Benutzer zur Verfügung steht, ein. Kontingente werden im <a href=./#quotas>Disk Quotas</a> diskutiert.</p></div><div class=paragraph><p>Einschränkungen auf andere Ressourcen, wie CPU und Speicher, können über eine Konfigurationsdatei oder über die Kommandozeile konfiguriert werden. Traditionell werden Login-Klassen in <span class=filename>/etc/login.conf</span> definiert. Obwohl diese Methode immer noch untersützt wird, muss nach jeder Änderung an dieser Datei die Ressourcen-Datenbank neu gebaut werden. Zudem müssen Sie die notwendigen Änderungen in <span class=filename>/etc/master.passwd</span> vornehmen und die Passwort-Datenbnak neu bauen. Dieser Prozess kann, abhängig davon, wie viele Benutzer bearbeitet werden müssen, sehr zeitaufwändig sein.</p></div><div class=paragraph><p>Mit <code>rctl</code> Ressourcen für Benutzer sehr detailliert gesteuert werden. Dieser Befehl unterstützt nicht nur die Kontrolle der Ressourcen für Benutzer, sondern auch die Beschränkung auf Prozesse und Jails.</p></div><div class=paragraph><p>In diesem Abschnitt werden beide Methoden vorgestellt. Angefangen wird mit der traditionellen Methode.</p></div><div class=sect3><h4 id=users-limiting>31.13.1. Login-Klassen konfigurieren<a class=anchor href=#users-limiting></a></h4><div class=paragraph><p>Bei der traditionellen Methode werden Login-Klassen und Ressourcenbeschränkungen in <span class=filename>/etc/login.conf</span> definiert. Jeder Benutzer kann einer Login-Klasse zugewiesen werden (standardmäßig <code>default</code>) und jede Login-Klasse ist mit einem Satz von Login-Fähigkeiten verbunden. Eine Login-Fähigkeit ist ein <code><em>Name</em>=<em>Wert</em></code> Paar, in dem <em>Name</em> die Fähigkeit bezeichnet und <em>Wert</em> ein beliebiger Text ist, der in Abhänigkeit von <em>Name</em> entsprechend verarbeitet wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Immer wenn <span class=filename>/etc/login.conf</span> verändert wurde, muss die <span class=filename>/etc/login.conf.db</span> mit dem folgenden Kommando aktualisiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Ressourcenbeschränkungen unterscheiden sich von normalen Login-Fähigkeiten zweifach. Erstens gibt es für jede Beschränkung ein aktuelles und ein maximales Limit. Das aktuelle Limit kann vom Benutzer oder einer Anwendung beliebig bis zum maximalen Limit verändert werden. Letzteres kann der Benutzer nur heruntersetzen. Zweitens gelten die meisten Ressourcenbeschränkungen für jeden vom Benutzer gestarteten Prozess.</p></div><div class=paragraph><p><a href=#resource-limits>Ressourcenbeschränkungen für Login-Klassen</a> listet die gebräuchlichen Ressourcenbeschränkungen auf. Alle verfügbaren Ressourcenbeschränkungen und Fähigkeiten sind im Detail in <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> beschrieben.</p></div><table id=resource-limits class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 11. Ressourcenbeschränkungen für Login-Klassen</caption><col style=width:30%><col style=width:70%><thead><tr><th class="tableblock halign-left valign-top">Ressourcenbeschränkung</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>coredumpsize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das Limit der Größe einer core-Datei, die von einem Programm generiert wird, unterliegt aus offensichtlichen Gründen anderen Limits der Festplattenbenutzung, zum Beispiel <code>filesize</code> oder Festplattenkontingenten. Es wird oft als weniger harte Methode zur Kontrolle des Festplattenplatz-Verbrauchs verwendet. Da Benutzer die core-Dateien selbst nicht erstellen und sie oft nicht löschen, kann diese Option davor schützen, dass kein Festplattenspeicher mehr zur Verfügung steht, sollte ein großes Programm abstürzen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cputime</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die maximale Rechenzeit, die ein Prozess eines Benutzers verbrauchen darf. Überschreitet ein Prozess diesen Wert, wird er vom Kernel beendet. Beachten Sie, dass die Rechen<em>zeit</em> limitiert wird, nicht die prozentuale Prozessorenbenutzung, wie es in einigen Feldern von <code>top</code> und <code>ps</code> dargestellt wird.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>filesize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Hiermit lässt sich die maximale Größe einer Datei bestimmen, die der Benutzer besitzen darf. Im Gegensatz zu <a href=./#quotas>Festplattenkontingenten</a> ist diese Beschränkung nur für jede einzelne Datei gültig und nicht für den Platz, den alle Dateien eines Benutzers verwenden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>maxproc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das ist die maximale Anzahl von Prozessen, die ein Benutzer starten darf, und beinhaltet sowohl Vordergrund- als auch Hintergrundprozesse. Dieser Wert nicht höher sein als das System-Limit, das in <code>kern.maxproc</code> angegeben ist. Vergessen Sie nicht, dass ein zu kleiner Wert den Benutzer in seiner Produktivität einschränken könnte, wenn beispielsweise ein großes Programm übersetzt wird oder viele Prozesse gestartet sind.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>memorylocked</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dieses Limit gibt an, wie viel virtueller Speicher von einem Prozess maximal im Arbeitsspeicher festgesetzt werden kann (siehe auch <a href="https://man.freebsd.org/cgi/man.cgi?query=mlock&amp;sektion=2&amp;format=html">mlock(2)</a>). Ein paar systemkritische Programme, wie <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a>, verhindern damit einen Systemzusammenbruch, der auftreten könnte, wenn sie aus dem Speicher genommen werden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>memoryuse</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bezeichnet den maximalen Speicher, den ein Prozess benutzen darf und beinhaltet sowohl Arbeitsspeicher-, als auch Swap-Benutzung. Es ist kein allübergreifendes Limit für den Speicherverbrauch, aber ein guter Anfang.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>openfiles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mit diesem Limit lässt sich die maximale Anzahl der von einem Prozess des Benutzers geöffneten Dateien festlegen. In FreeBSD werden Dateien auch verwendet, um Sockets und >IPC>-Kanäle darzustellen. Setzen Sie es deshalb nicht zu niedrig. Das System-Limit ist in <code>kern.maxfiles</code> definiert.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>sbsize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dieses Limit beschränkt den Netzwerk-Speicher, den ein Benutzer verbrauchen darf. Es kann generell dazu benutzt werden Netzwerk-Verbindungen zu beschränken.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>stacksize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das ist die maximale Größe, auf die der Stack eines Prozesses heranwachsen darf. Das allein ist natürlich nicht genug, um den Speicher zu beschränken, den ein Programm verwenden darf. Es sollte deshalb in Verbindung mit anderen Limits verwendet werden.</p></td></tr></tbody></table><div class=paragraph><p>Beim Setzen von Ressourcenbeschränkungen sind noch andere Dinge zu beachten:</p></div><div class=ulist><ul><li><p>Von <span class=filename>/etc/rc</span> beim Hochfahren des Systems gestartete Prozesse werden der <code>daemon</code> Login-Klasse zugewiesen.</p></li><li><p>Obwohl die voreingestellte <span class=filename>/etc/login.conf</span> sinnvolle Limits enthält, sind sie evtl. nicht für jedes System geeignet. Ein zu hohes Limit kann das System für Missbrauch anfällig machen, und ein zu niedriges Limit kann der Produktivität schaden.</p></li><li><p>Xorg beansprucht selbst eine Menge Ressourcen und verleitet die Benutzer dazu, mehrere Programme gleichzeitig laufen zu lassen.</p></li><li><p>Bedenken Sie, dass viele Limits für einzelne Prozesse gelten und nicht für den Benutzer selbst. Setzt man zum Beispiel <code>openfiles</code> auf <code>50</code>, kann jeder Prozess des Benutzers bis zu <code>50</code> Dateien öffnen. Dadurch ist die maximale Anzahl von Dateien, die von einem Benutzer geöffnet werden können, <code>openfiles</code> mal <code>maxproc</code>. Das gilt auch für den Speicherverbrauch.</p></li></ul></div><div class=paragraph><p>Weitere Informationen über Ressourcenbeschränkungen, Login-Klassen und -Fähigkeiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=cap.mkdb&amp;sektion=1&amp;format=html">cap.mkdb(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getrlimit&amp;sektion=2&amp;format=html">getrlimit(2)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.</p></div></div><div class=sect3><h4 id=_einschränkung_von_ressourcen_aktivieren_und_konfigurieren>31.13.2. Einschränkung von Ressourcen aktivieren und konfigurieren<a class=anchor href=#_einschränkung_von_ressourcen_aktivieren_und_konfigurieren></a></h4><div class=paragraph><p>Die Variable <code>kern.racct.enable</code> muss auf einen Wert ungleich Null eingestellt sein. Angepasste Kernel benötigen eine spezielle Konfiguration:</p></div><div class="literalblock programlisting"><div class=content><pre>options           RACCT
options         RCTL</pre></div></div><div class=paragraph><p>Sobald das System mit dem neuen Kernel gestartet wird, kann <code>rctl</code> benutzt werden, um die Regeln für das System festzulegen.</p></div><div class=paragraph><p>Die Syntax der Regeln wird durch <em>subject</em>, <em>subject-id</em>, <em>resource</em> und <em>action</em> gesteuert, wie in diesem Beispiel zu sehen ist:</p></div><div class="literalblock programlisting"><div class=content><pre>user:trhodes:maxproc:deny=10/user</pre></div></div><div class=paragraph><p>Diese Regel zeigt den grundlegenden Aufbau, hier mit dem Subjekt <code>user</code> und der Subjekt-ID <code>trhodes</code>. <code>maxproc</code> definiert die Anzahl der Prozesse. Die "Aktion" <code>deny</code> verhindert, dass neue Prozesse erstellt werden. Im vorherigen Beispiel wurde für den Benutzer <code>trhodes</code> eine Beschränkung von <code>10</code> Prozessen konfiguriert. Zu den weiteren Aktionen zählen beispielsweise die Protokollierung auf der Konsole, Benachrichtigungen an <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> oder das Senden eines <code>SIGTERM</code> an einen Prozess.</p></div><div class=paragraph><p>Beim hinzufügen von Regeln müssen einige Dinge beachtet werden. Das obige Beispiel würde den Benutzer sogar daran hindern, einfachste Dinge zu tun, nachdem er sich anmeldet und eine <code>screen</code> Sitzung gestartet hat. Sobald die Begrenzung für eine Ressource erreicht ist, wird folgende Fehlermeldung ausgegeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># man test</span>
/usr/bin/man: Cannot fork: Resource temporarily unavailable
<span class=nb>eval</span>: Cannot fork: Resource temporarily unavailable</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> kann auch benutzt werden, um einer Jail eine Speichergrenze zuzuweisen. Eine solche Regel könnte wie folgt festgelegt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -a jail:httpd:memoryuse:deny=2G/jail</span></code></pre></div></div><div class=paragraph><p>Damit die Regeln auch nach einem Neustart erhalten bleiben, müssen sie in <span class=filename>/etc/rctl.conf</span> hinzugefügt werden. Dazu schreiben Sie einfach die Regel, ohne das vorhergehende Kommando. Zum Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre># Block jail from using more than 2G memory:
jail:httpd:memoryuse:deny=2G/jail</pre></div></div><div class=paragraph><p>Mit <code>rctl</code> können auch Regeln entfernt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -r user:trhodes:maxproc:deny=10/user</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> zeigt auch eine Möglichkeit, alle Regeln zu entfernen. Falls es erforderlich ist alle Regeln für einen einzelnen Benutzer zu entfernen, kann dieser Befehl verwendet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -r user:trhodes</span></code></pre></div></div><div class=paragraph><p>Es gibt noch viele weitere Ressourcen, die verwendet werden können, um zusätzliche <code>subjects</code> zu kontrollieren. Weitere Informationen zu diesem Thema finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a>.</p></div></div></div><div class=sect2><h3 id=security-sudo>31.14. Gemeinsame Administration mit Sudo<a class=anchor href=#security-sudo></a></h3><div class=paragraph><p>Systemadministratoren benötigen häufig die Möglichkeit, Benutzern erweiterte Berechtigungen zu gewähren, damit diese privilegierte Aufgaben ausführen können. Die Idee, dass Teammitglieder einen Zugang zu einem FreeBSD-System zur Verfügung gestellt bekommen, um ihre spezifischen Aufgaben erledigen zu können, stellt den Administrator vor eine große Herausforderung. Diese Teammitglieder benötigen in der Regel nur einen eingeschränkten Zugang. Für manche Aufgaben werden jedoch die Rechte des Superusers benötigt. Zum Glück gibt es keinen Grund, diesen Mitgliedern einen solchen Zugang zu geben, da es Werkzeuge für genau diesen Anwendungsfall gibt.</p></div><div class=paragraph><p>Bislang wurde in diesem Kapitel immer versucht, den Zugriff für autorisierte Benutzer zu gewähren und den Zugriff für nicht autorisierte Benutzer zu verhindern. Ein weiteres Problem entsteht, sobald autorisierte Benutzer Zugriff auf die Ressourcen des Systems haben. In vielen Fällen benötigen einige Benutzer Zugriff auf Startskripte von Anwendungen. In anderen Fällen muss eine Gruppe von Administratoren das System verwalten. Traditionell wird der Zugriff über Benutzer, Gruppen, Dateiberechtigungen und manchmal sogar <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> verwaltet. Und da immer mehr Anwendungen einen Zugriff brauchen und immer mehr Benutzer Zugriff auf die Systemressourcen benötigen, ist ein besserer Lösungsansatz erforderlich. Die am häufigsten verwendete Anwendung in solchen Fällen ist derzeit Sudo.</p></div><div class=paragraph><p>Sudo erlaubt dem Administrator eine rigide Konfiguration des Zugriffs auf bestimmte Kommandos und stellt einige erweiterte Protokollfunktionen zur Verfügung. Dieses Werkzeug kann als Port oder Paket <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> installiert werden. Das Paket wird wie folgt installiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install sudo</span></code></pre></div></div><div class=paragraph><p>Nach der Installation können Sie <code>visudo</code> benutzen, um die Konfiguration in einem Texteditor zu öffnen. Es wird ausdrücklich <code>visudo</code> empfohlen, da dieses Programm die Syntax auf Fehler überprüft, bevor die Konfigurationsdatei gespeichert wird.</p></div><div class=paragraph><p>Die Konfigurationsdatei besteht aus mehreren kleinen Abschnitten, die eine umfangreiche Konfiguration ermöglichen. Im folgenden Beispiel soll der Webentwickler (<code>user1</code>) den Dienst <em>webservice</em> starten und stoppen dürfen. Um ihm dieses Recht zu gewähren, fügen Sie folgende Zeile an das Ende von <span class=filename>/usr/local/etc/sudoers</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>user1   ALL=(ALL)       /usr/sbin/service webservice *</pre></div></div><div class=paragraph><p>Der Benutzer kann jetzt <em>webservice</em> über dieses Kommando starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sudo</span> /usr/sbin/service webservice start</code></pre></div></div><div class=paragraph><p>Diese Konfiguration gestattet den Zugriff auf den webservice für einen einzelnen Benutzer. Jedoch ist in den meisten Organisationen ein ganzes Team für die Verwaltung eines solchen Dienstes verantwortlich. Mit einer weiteren Zeile ist es möglich, einer ganzen Gruppe diesen Zugriff zu geben. Die folgenden Schritte erstellen eine Gruppe mit den entsprechenden Benutzern. Der Gruppe wird es dann ermöglicht, diesen Dienst zu verwalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd -g 6001 -n webteam</span></code></pre></div></div><div class=paragraph><p>Nun werden die Benutzer mit Hilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> in die Gruppe <em>webteam</em> hinzugefügt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod -m user1 -n webteam</span></code></pre></div></div><div class=paragraph><p>Zuletzt wird folgende Zeile in <span class=filename>/usr/local/etc/sudoers</span> hinzugefügt, damit jedes Mitglied von <em>webteam</em> den Dienst <em>webservice</em> verwalten kann:</p></div><div class="literalblock programlisting"><div class=content><pre>%webteam   ALL=(ALL)       /usr/sbin/service webservice *</pre></div></div><div class=paragraph><p>Im Gegensatz zu <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>, benötigt Sudo nur das Passwort des Benutzers.</p></div><div class=paragraph><p>Benutzer, die mit Hilfe von Sudo Programme ausführen, müssen lediglich ihr eigenes Passwort eingeben. Dies ist sicherer und bietet eine bessere Kontrolle als <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>, wo der Benutzer das <code>root</code>-Passwort eingibt und damit alle Rechte von <code>root</code> erlangt.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Viele Organisationen haben bereits auf eine Zwei-Faktor-Authentifizierung umgestellt. In diesen Fällen hat der Benutzer möglicherweise gar kein Passwort, welches er eingeben könnte. Sudo bietet für solche Fälle die Variable <code>NOPASSWD</code>. Wenn die Variable in die obige Konfiguration hinzugefügt wird, dürfen die Mitglieder der Gruppe <em>webteam</em> den Dienst verwalten, ohne ein Passwort eingeben zu müssen:</p></div><div class="literalblock programlisting"><div class=content><pre>%webteam   ALL=(ALL)       NOPASSWD: /usr/sbin/service webservice *</pre></div></div></td></tr></tbody></table></div><div class=sect3><h4 id=security-sudo-loggin>31.14.1. Protokollierung<a class=anchor href=#security-sudo-loggin></a></h4><div class=paragraph><p>Ein Vorteil von Sudo ist, dass Sitzungen protokolliert werden können. Mit den integrierten Protokollmechanismen und dem Befehl sudoreplay können alle über Sudo ausgelösten Befehle protokolliert und zu einem späteren Zeitpunkt überprüft werden. Um diese Funktion zu aktivieren, fügen Sie einen Eintrag für das Verzeichnis der Protokolle hinzu. Dieses Beispiel verwendet eine Benutzervariable. Weitere Informationen finden Sie in der Manualpage von sudoreplay.</p></div><div class="literalblock programlisting"><div class=content><pre>Defaults iolog_dir=/var/log/sudo-io/%{user}</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Dieses Verzeichnis wird automatisch nach der Konfiguration erstellt. Um auf der sicheren Seite zu sein, ist es am besten, das System die Verzeichnisse mit Standardberechtigungen erstellen zu lassen. Dieser Eintrag wird auch ein Protokoll für Administratoren erstellen, wenn diese den Befehl sudoreplay benutzen. Um dieses Verhalten zu ändern, kommentieren Sie die entsprechenden Zeilen in <span class=filename>sudoers</span> aus.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nachdem dieser Eintrag in die Datei <span class=filename>sudoers</span> hinzugefügt wurde, kann die Konfiguration der Benutzer für die Protokollierung aktualisiert werden. In dem gezeigten Beispiel würde der aktualisierte Eintrag für das <em>webteam</em> zusätzlich folgende Änderung benötigen:</p></div><div class="literalblock programlisting"><div class=content><pre>%webteam ALL=(ALL) NOPASSWD: LOG_INPUT: LOG_OUTPUT: /usr/sbin/service webservice *</pre></div></div><div class=paragraph><p>Von nun an wird jede Änderung am <em>webservice</em> protokolliert, wenn sie von einem Mitglied der Gruppe <em>webteam</em> initiiert wurde. Eine Liste der Sitzungen kann wie folgt angezeigt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sudoreplay -l</span></code></pre></div></div><div class=paragraph><p>Wenn Sie eine bestimmte Sitzung wiedergeben möchten, suchen Sie in der Ausgabe nach dem Eintrag <code>TSID=</code> und übergeben Sie den Wert ohne weitere Optionen an sudoreplay. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sudoreplay user1/00/00/02</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Obwohl die Sitzungen protokolliert werden, kann ein böswilliger Administrator wahllos die Sitzungsprotokolle löschen. Daher ist es eine gute Idee, eine tägliche Kontrolle mit einem Intrusion Detection System (IDS) oder einer ähnlichen Software durchzuführen, so dass andere Administratoren auf manuelle Änderungen aufmerksam gemacht werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>sudoreplay ist extrem erweiterbar. Lesen Sie die Dokumentation für weitere Informationen.</p></div></div></div></div></div><div class=sect1><h2 id=jails>Kapitel 32. Jails<a class=anchor href=#jails></a></h2><div class=sectionbody><div class=sect2><h3 id=jails-synopsis>32.1. Übersicht<a class=anchor href=#jails-synopsis></a></h3><div class=paragraph><p>Da die Systemadministration eine schwierige Aufgabe ist, wurden viele Werkzeuge entwickelt, die Administratoren bei der Installation, Konfiguration und Wartung ihrer Systeme unterstützen sollen. Eines dieser Werkzeuge, die verwendet werden können um die Sicherheit eines FreeBSD-Systems zu erhöhen, sind <em>Jails</em>. Jails sind seit FreeBSD 4.X verfügbar und werden ständig in ihrer Nützlichkeit, Leistung, Zuverlässigkeit und Sicherheit verbessert. Jails können als eine Art von Betriebssystem-Virtualisierung angesehen werden.</p></div><div class=paragraph><p>Jails setzen auf dem <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a>-Konzept auf, das dazu verwendet wird das root-Verzeichnis einer Reihe von Prozessen zu ändern, um so eine separate, sichere Umgebung zu schaffen. Prozesse, die in einer chroot-Umgebung erstellt wurden, können nicht auf Dateien oder Ressourcen zugreifen, die sich außerhalb dieser Umgebung befinden. Dadurch ist es einem kompromittierten Dienst nicht möglich, das gesamte System zu kompromittieren. Im Laufe der Zeit wurden viele Wege gefunden, um aus einer chroot-Umgebung auszubrechen, so dass es für die Sicherung von Diensten nicht die ideale Lösung ist.</p></div><div class=paragraph><p>Jails verbessern das traditionelle chroot-Konzept auf unterschiedlichste Art und Weise. In einer traditionellen chroot-Umgebung sind Prozesse auf den Bereich des Dateisystems beschränkt, auf den sie zugreifen können. Der Rest der Systemressourcen (wie zum Beispiel eine Reihe von Systembenutzern, die laufenden Prozesse oder das Netzwerk-Subsystem) teilen sich die chroot-Prozesse mit dem Host-System. Jails erweitern dieses Modell nicht nur auf die Virtualisierung des Zugriffs auf das Dateisystem, sondern auch auf eine Reihe von Benutzern und das Netzwerk-Subsystem. Zudem stehen weitere Möglichkeiten zur Verfügung, den Zugriff auf eine Jail-Umgebung zu kontrollieren.</p></div><div class=paragraph><p>Eine Jail zeichnet sich durch folgende Merkmale aus:</p></div><div class=ulist><ul><li><p>Ein Unterverzeichnisbaum: dies ist der Ausgangspunkt der Jail. Einem Prozess, der innerhalb der Jail läuft, ist es nicht mehr möglich, aus diesem Unterverzeichnis auszubrechen.</p></li><li><p>Ein Hostname: dieser Name wird für die Jail verwendet.</p></li><li><p>Eine IP Adresse: diese Adresse wird der Jail zugewiesen. Die IP-Adresse einer Jails ist üblicherweise ein Adress-Alias auf eine existierende Netzwerkschnittstelle.</p></li><li><p>Ein Kommando: der Pfad einer ausführbaren Datei, die innerhalb der Jail ausgeführt werden soll. Dieser Pfad wird relativ zum root-Verzeichnis der Jail-Umgebung angegeben.</p></li></ul></div><div class=paragraph><p>Jails haben einen eigenen Satz von Benutzern und ihren eigenen <code>root</code>-Konto. Die Rechte dieser Benutzer sind nur auf die Jail-Umgebung beschränkt. Der Benutzer <code>root</code> der Jail-Umgebung ist nicht dazu berechtigt, kritische Operationen am System außerhalb der angebundenen Jail-Umgebung durchzuführen.</p></div><div class=paragraph><p>Dieses Kapitel bietet einen Überblick über die Terminologie und die Kommandos zur Verwaltung von FreeBSD Jails. Jails sind ein sehr mächtiges Werkzeug für Administratoren und fortgeschrittene Anwender.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</p></div><div class=ulist><ul><li><p>Wissen, was eine Jail ist und welche Verwendungszwecke es dafür unter FreeBSD gibt.</p></li><li><p>Wissen, wie man eine Jail erstellt, startet und anhält.</p></li><li><p>Die Grundlagen der Jail-Administration (sowohl innerhalb als auch außerhalb des Jails) kennen.</p></li></ul></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Jails sind ein mächtiges Werkzeug, aber sie sind kein Sicherheits-"Allheilmittel". Es ist wichtig zu beachten, dass es für einen Prozess in der Jail nicht möglich ist, von selbst auszubrechen. Es gibt jedoch Möglichkeiten, in denen ein unprivilegierter Benutzer außerhalb der Jail, mit einem privilegierten Benutzer innerhalb der Jail kooperiert, und somit erhöhte Rechte in der Host-Umgebung erlangt.</p></div><div class=paragraph><p>Den meisten dieser Angriffe kann vorgebeugt werden, indem sichergestellt wird, dass das Rootverzeichnis der Jail für unprivilegierte Benutzer der Host-Umgebung nicht zugänglich ist.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=jails-terms>32.2. Jails - Definitionen<a class=anchor href=#jails-terms></a></h3><div class=paragraph><p>Um die für den Einsatz von Jails benötigten os;-Funktionen, deren Interna sowie die Art und Weise, mit der diese mit anderen Teilen des Betriebssystems interagieren, zu erläutern, werden in diesem Kapitel folgende Definitionen verwendet:</p></div><div class=dlist><dl><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> (-Befehl)</dt><dd><p>Ein Werkzeug, das den FreeBSD-Systemaufruf <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> verwendet, um das Wurzelverzeichnis eines Prozesses und all seiner Nachkömmlinge zu ändern.</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> (-Umgebung)</dt><dd><p>Die Umgebung eines Prozesses, der in einem "chroot" läuft. Diese beinhaltet Ressourcen, wie zum Beispiel sichtbare Abschnitte des Dateisystems, verfügbare Benutzer- und Gruppenkennungen, Netzwerkschnittstellen und weitere IPC-Mechanismen und so weiter.</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> (-Befehl)</dt><dd><p>Das Systemadministrationswerkzeug, welches es erlaubt, Prozesse innerhalb der Jail-Umgebung zu starten.</p></dd><dt class=hdlist1>Host (-Benutzer, -Prozess, -System)</dt><dd><p>Das verwaltende System einer Jail-Umgebung. Das Host-System hat Zugriff auf alle verfügbaren Hardwareressourcen und kann sowohl innerhalb als auch außerhalb der Jail-Umgebung Prozesse steuern. Einer der wichtigsten Unterschiede des Host-System einer Jails ist, dass die Einschränkungen, welche für die Superuser-Prozesse innerhalb eines Jails gelten, nicht für die Prozesse des Host-Systems gelten.</p></dd><dt class=hdlist1>Gast (-Benutzer, -Prozess, -System)</dt><dd><p>Ein Prozess, ein Benutzer oder eine andere Instanz, deren Zugriff durch eine FreeBSD-Jail eingeschränkt ist.</p></dd></dl></div></div><div class=sect2><h3 id=jails-build>32.3. Einrichtung und Verwaltung von Jails<a class=anchor href=#jails-build></a></h3><div class=paragraph><p>Einige Administratoren unterscheiden zwei verschiedene Jail-Arten: "Komplette" Jails, die ein echtes FreeBSD darstellen und Jails für einen bestimmten "Dienst", die nur einer bestimmten Anwendung oder einem Dienst (der möglicherweise mit besonderen Privilegien laufen soll) gewidmet sind. Dies ist aber nur eine konzeptuelle Unterscheidung, die Einrichtung einer Jail bleibt davon gänzlich unberührt. Bei der Erstellung einer kompletten Jail gibt es zwei Optionen für die Quelle des Userlands: vorkompilierte Binärpakete (im Lieferumfang der Installationsmedien enthalten) oder die Kompilierung aus dem Quelltext.</p></div><div class=sect3><h4 id=_eine_jail_installieren>32.3.1. Eine Jail installieren<a class=anchor href=#_eine_jail_installieren></a></h4><div class=sect4><h5 id=jails-install-internet>32.3.1.1. Eine Jail aus dem Internet installieren<a class=anchor href=#jails-install-internet></a></h5><div class=paragraph><p>Der Werkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a> kann verwendet werden, um die für eine Jail benötigten Binärdateien zu holen und zu installieren. Dies geht durch die Auswahl eines Spiegelservers, welche Distributionen in das Zielverzeichnis installiert werden sollen, sowie die grundlegende Konfiguration einer Jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdinstall jail /pfad/zur/jail</span></code></pre></div></div><div class=paragraph><p>Nachdem der Befehl ausgeführt wurde, wird der Host für den Betrieb der Jail konfiguriert.</p></div></div><div class=sect4><h5 id=jails-install-iso>32.3.1.2. Eine Jail aus einer ISO-Datei installieren<a class=anchor href=#jails-install-iso></a></h5><div class=paragraph><p>Um das Basissystem von Installationsmedien zu installieren, erstellen Sie zunächst das Rootverzeichnis für die Jail. Dazu setzen Sie <code>DESTDIR</code> auf das entsprechende Verzeichnis.</p></div><div class=paragraph><p>Starten Sie eine Shell und legen Sie <code>DESTDIR</code> fest:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh</span>
<span class=c># export DESTDIR=/hier/ist/die/jail</span></code></pre></div></div><div class=paragraph><p>Hängen Sie das Installationsmedium wie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> beschrieben ein, wenn Sie von einem ISO-Abbild installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/`mdconfig -f cdimage.iso` /mnt</span>
<span class=c># cd /mnt/usr/freebsd-dist/</span></code></pre></div></div><div class=paragraph><p>Extrahieren Sie die Binärdateien aus den Archiven des Installationsmediums in das entsprechende Verzeichnis. Es wird mindestens das "base"-Set benötigt, aber Sie können auch eine komplette Installation durchführen, wenn Sie dies bevorzugen.</p></div><div class=paragraph><p>Um lediglich das Basissystem zu installieren, führen Sie dieses Kommando aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar -xf base.txz -C $DESTDIR</span></code></pre></div></div><div class=paragraph><p>Führen Sie folgendes Kommando aus, um alles außer den Kernel zu installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for set in base ports; do tar -xf $set.txz -C $DESTDIR ; done</span></code></pre></div></div></div><div class=sect4><h5 id=jails-install-source>32.3.1.3. Eine Jail aus den Quellen bauen und installieren<a class=anchor href=#jails-install-source></a></h5><div class=paragraph><p>Die Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> beschreibt die Erstellung einer Jail wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setenv D /hier/ist/die/jail</span>
<span class=c># mkdir -p $D      </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># cd /usr/src</span>
<span class=c># make buildworld  </span><i class=conum data-value=2></i><b>(2)</b>
<span class=c># make installworld DESTDIR=$D  </span><i class=conum data-value=3></i><b>(3)</b>
<span class=c># make distribution DESTDIR=$D  </span><i class=conum data-value=4></i><b>(4)</b>
<span class=c># mount -t devfs devfs $D/dev   </span><i class=conum data-value=5></i><b>(5)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Das Festlegen des Installationsorts für das Jail eignet sich am besten als Startpunkt. Hier wird sich die Jail innerhalb des Host-Dateisystems befinden. Eine gute Möglichkeit wäre etwa <span class=filename>/usr/jail/name_der_jail</span>, wobei <code><em>name_der_jail</em></code> den Hostname darstellt, über den die Jail identifiziert werden soll. <span class=filename>/usr/</span> stellt normalerweise ausreichend Platz für eine Jail zur Verfügung. Bedenken Sie, dass eine "komplette" Jail ein Replikat einer jeden Datei der Standardinstallation des FreeBSD-Basissystems enthält.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Wenn Sie bereits ihre Systemanwendungen mittels <code>make world</code> oder <code>make buildworld</code> neu erstellt haben, können Sie diesen Schritt überspringen und die Systemanwendungen in die neue Jail installieren.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Dieser Befehl wird den Verzeichnisbaum mit allen notwendigen Binärdateien, Bibliotheken, Manualpages usw. erstellen.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Der <code>distribution</code>-Befehl lässt make alle benötigten Konfigurationsdateien installieren, es werden also alle installierbaren Dateien aus <span class=filename>/usr/src/etc/</span> in das Verzeichnis <span class=filename>/etc</span> der Jail installiert (also nach <span class=filename>$D/etc/</span>).</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Das Einhängen des <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a>-Dateisystems innerhalb der Jail ist nicht unbedingt notwendig. Allerdings benötigt fast jede Anwendung Zugriff auf wenigstens ein Gerät. Es ist daher sehr wichtig, den Zugriff auf Devices aus der Jail heraus zu kontrollieren, da unsaubere Einstellungen es einem Angreifer erlauben könnten, in das System einzudringen. Die Kontrolle über <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> erfolgt durch die in den Manualpages <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.conf&amp;sektion=5&amp;format=html">devfs.conf(5)</a> beschriebenen Regeln.</td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_den_host_konfigurieren>32.3.2. Den Host konfigurieren<a class=anchor href=#_den_host_konfigurieren></a></h4><div class=paragraph><p>Ist die Jail erst einmal erstellt, kann sie durch <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> gestartet werden. <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> benötigt zwingend mindestens vier Argumente, die in <a href=#jails-synopsis>Übersicht</a> des Handbuchs beschrieben sind. Weitere Argumente sind möglich, um beispielsweise die Jail mit den Berechtigungen eines bestimmten Benutzers laufen zu lassen. Das Argument <code><em>command</em></code> hängt vom Typ der Jail ab; für ein <em>virtuelles System</em> ist <span class=filename>/etc/rc</span> eine gute Wahl, da dies dem Startvorgang eines echten FreeBSD-Systems entspricht. Bei einer <em>Service</em>-Jail hängt dieses von der Art des Dienstes ab, der in der Jail laufen soll.</p></div><div class=paragraph><p>Jails werden häufig mit dem Betriebssystem gestartet, da der <span class=filename>rc</span>-Mechanismus von FreeBSD dafür eine einfach zu realisierende Möglichkeit bietet.</p></div><div class="ulist procedure"><ul><li><p>Konfigurieren Sie die Jail in <span class=filename>/etc/jail.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>www {
    host.hostname = www.example.org;           # Hostname
    ip4.addr = 192.168.0.10;                   # IP address of the jail
    path = &#34;/usr/jail/www&#34;;                    # Path to the jail
    devfs_ruleset = &#34;www_ruleset&#34;;             # devfs ruleset
    mount.devfs;                               # Mount devfs inside the jail
    exec.start = &#34;/bin/sh /etc/rc&#34;;            # Start command
    exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;    # Stop command
}</pre></div></div><div class=paragraph><p>Um die Jails mit dem Betriebssystem zu starten, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;   # Set to NO to disable starting of any jails</pre></div></div><div class=paragraph><p>Beim Start einer in <a href="https://man.freebsd.org/cgi/man.cgi?query=jail.conf&amp;sektion=5&amp;format=html">jail.conf(5)</a> konfigurierten Jail wird das <span class=filename>/etc/rc</span>-Skript der Jail (das "annimmt", dass es sich in einem kompletten System befindet) aufgerufen. Für Service-Jails sollten die Startskripte der Jail durch das Setzen der Option <code>exec.start</code> entsprechend angepasst werden.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Eine vollständige Liste der Optionen findet sich in der Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=jail.conf&amp;sektion=5&amp;format=html">jail.conf(5)</a>.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> kann zum manuellen Starten und Stoppen der Jail genutzt werden, wenn ein Eintrag in <span class=filename>jail.conf</span> angelegt wurde:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service jail start www</span>
<span class=c># service jail stop www</span></code></pre></div></div><div class=paragraph><p>Jails können mit <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> heruntergefahren werden. Führen Sie zunächst <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> aus, um die <code>JID</code> der Jail ausfindig zu machen. Anschließend können Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> benutzen, um das Shutdown-Skript in der Jail auszuführen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jls</span>
   JID  IP Address      Hostname                      Path
     3  192.168.0.10    www                           /usr/jail/www
<span class=c># jexec 3 /etc/rc.shutdown</span></code></pre></div></div><div class=paragraph><p>Weitere Informationen zu diesem Thema finden Sie in der Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>.</p></div></div></div><div class=sect2><h3 id=jails-tuning>32.4. Feinabstimmung und Administration<a class=anchor href=#jails-tuning></a></h3><div class=paragraph><p>Es gibt verschiedene Optionen, die für jede Jail gesetzt werden können und verschiedene Wege, ein FreeBSD-Host-System mit Jails zu kombinieren. Dieser Abschnitt zeigt Ihnen:</p></div><div class=ulist><ul><li><p>Einige zur Verfügung stehende Optionen zur Abstimmung des Verhaltens und der Sicherheitseinstellungen, die mit einer Jail-Installation ausgeführt werden können.</p></li><li><p>Einige der Anwendungsprogramme für das Jail-Management, die über die FreeBSD Ports-Sammlung verfügbar sind und genutzt werden können, um Jail-basierte Lösungen allumfassend umzusetzen.</p></li></ul></div><div class=sect3><h4 id=jails-tuning-utilities>32.4.1. Systemwerkzeuge zur Feinabstimmung von Jails in FreeBSD<a class=anchor href=#jails-tuning-utilities></a></h4><div class=paragraph><p>Die Feinabstimmung einer Jail-Konfiguration erfolgt zum Großteil durch das Setzen von <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variablen. Es gibt einen speziellen sysctl-Zweig, der als Basis für die Organisation aller relevanten Optionen dient: Die <code>security.jail.*</code>-Hierarchie der FreeBSD-Kerneloptionen. Die folgende Liste enthält alle jail-bezogenen sysctls (inklusiver ihrer Voreinstellungen). Die Namen sollten selbsterklärend sein, für weitergehende Informationen lesen Sie bitte die Manualpages <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=ulist><ul><li><p><code>security.jail.set_hostname_allowed: 1</code></p></li><li><p><code>security.jail.socket_unixiproute_only: 1</code></p></li><li><p><code>security.jail.sysvipc_allowed: 0</code></p></li><li><p><code>security.jail.enforce_statfs: 2</code></p></li><li><p><code>security.jail.allow_raw_sockets: 0</code></p></li><li><p><code>security.jail.chflags_allowed: 0</code></p></li><li><p><code>security.jail.jailed: 0</code></p></li></ul></div><div class=paragraph><p>Diese Variablen können vom Administrator des <em>Host-Systems</em> genutzt werden, um Beschränkungen hinzuzufügen oder aufzuheben, die dem Benutzer <code>root</code> als Vorgabe auferlegt sind. Beachten Sie, dass es einige Beschränkungen gibt, die nicht verändert werden können. Der Benutzer <code>root</code> darf innerhalb der <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> keine Dateisysteme mounten und unmounten. Ebenso ist es ihm untersagt, das <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a>-Regelwerk zu laden oder zu entladen. Er darf weder Firewallregeln setzen, noch administrative Aufgaben erledigen, die Modifikationen am Kernel selbst erfordern (wie beispielsweise das Setzen des <code>Securelevels</code> für den Kernel).</p></div><div class=paragraph><p>Das FreeBSD-Basissystem enthält einen Basissatz an Werkzeugen, um Informationen über aktive Jails zu erlangen und einer Jail administrative Befehle zuzuordnen. Die Befehle <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> sind Teil des FreeBSD-Basissystems und können für folgende Aufgaben verwendet werden:</p></div><div class=ulist><ul><li><p>Das Anzeigen einer Liste der aktiven Jails und ihrer zugehörigen Jail Identifier (JID), ihrer IP-Adresse, ihres Hostnames und ihres Pfades.</p></li><li><p>Das Herstellen einer Verbindung mit einer laufenden Jail, das Starten eines Befehls aus dem Gastsystem heraus oder das Ausführen einer administrativen Aufgabe innerhalb der Jail selbst. Dies ist insbesondere dann nützlich, wenn der Benutzer <code>root</code> die Jail sauber herunterfahren möchte. <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> kann auch zum Starten einer Shell innerhalb der Jail genutzt werden, um administrative Aufgaben durchzuführen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 1 tcsh</span></code></pre></div></div></li></ul></div></div><div class=sect3><h4 id=jails-tuning-admintools>32.4.2. High-Level-Werkzeuge zur Jail-Administration in der FreeBSD Ports-Sammlung<a class=anchor href=#jails-tuning-admintools></a></h4><div class=paragraph><p>Unter den zahlreichen Werkzeugen für die Administration von Jails ist <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/ezjail/>sysutils/ezjail</a> am vollständigsten und brauchbarsten. Dabei handelt es sich um eine Sammlung von Skripten, die das <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>-Management vereinfachen. Weitere Informationen zu diesem Werkzeug finden Sie im <a href=#jails-ezjail>Abschnitt über ezjail</a>.</p></div></div><div class=sect3><h4 id=jails-updating>32.4.3. Jails auf dem aktuellen Stand halten<a class=anchor href=#jails-updating></a></h4><div class=paragraph><p>Jails sollten immer vom Host-System auf dem neuesten Stand gehalten werden, da eine Aktualisierung aus einer Jail heraus wahrscheinlich fehlschlägt, da in der Voreinstellung von FreeBSD die Verwendung von <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> in einem Jail nicht erlaubt ist und somit der Austausch einiger Dateien verhindert wird. Es ist zwar möglich, dieses Verhalten zu ändern, aber es wird empfohlen, <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> zu benutzen, um die Jails zu aktualisieren. Verwenden Sie <code>-b</code> mit dem Pfad der Jail, die Sie aktualisieren möchten.</p></div><div class=paragraph><p>Um die Jail auf das neueste Patch-Release der bereits installierten FreeBSD-Version zu aktualisieren, führen Sie auf dem Host die folgenden Befehle aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -b /hier/ist/die/jail fetch</span>
<span class=c># freebsd-update -b /hier/ist/die/jail install</span></code></pre></div></div><div class=paragraph><p>Um die Jail auf eine neue Haupt- oder Unterversion zu aktualisieren, wird zunächst eine Aktualisierung des Host-Systems durchgeführt, wie in <a href=./#freebsdupdate-upgrade>“Aktualisierungen an Haupt- und Unterversionen”</a> beschrieben. Nachdem der Host aktualisiert und neu gestartet wurde, kann die Jail aktualisiert werden. Führen Sie folgende Befehle auf dem Host aus, um von 12.0-RELEASE auf 12.1-RELEASE zu aktualisieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -b /hier/ist/die/jail --currently-running 12.0-RELEASE -r 12.1-RELEASE upgrade</span>
<span class=c># freebsd-update -b /hier/ist/die/jail install</span>
<span class=c># service jail restart myjail</span>
<span class=c># freebsd-update -b /hier/ist/die/jail install</span></code></pre></div></div><div class=paragraph><p>Wenn es sich um eine Aktualisierung einer Hauptversion handelte, installieren Sie alle installierten Pakete neu und starten Sie die Jail erneut. Dies ist notwendig, da sich die ABI-Version bei einer Aktualisierung zwischen Hauptversionen von FreeBSD ändert. Führen Sie folgende Befehle auf dem Host-System aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg -j mymail upgrade -f</span>
<span class=c># service jail restart myjail</span></code></pre></div></div></div></div><div class=sect2><h3 id=jails-application>32.5. Mehrere Jails aktualisieren<a class=anchor href=#jails-application></a></h3><div class=paragraph><p>Die Verwaltung von mehreren Jails kann problematisch sein, da jede Jail bei jedem Upgrade komplett neu gebaut werden muss. Dieser Prozess kann sehr zeitaufwändig sein, wenn eine große Anzahl von Jails erstellt oder manuell aktualisiert werden müssen.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt eine Methode zur Lösung dieses Problems, indem so viel wie möglich zwischen Jails, auf sichere Art und Weise, durch den Einsatz von <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nullfs&amp;sektion=8&amp;format=html">mount_nullfs(8)</a>-Mounts geteilt wird. Dadurch werden Aktualisierungen erleichtert und das Verteilen von verschiedenen Diensten, wie HTTP, DNS und SMTP, auf verschiedene Jails wird attraktiver. Außerdem bietet dieses Verfahren einen einfachen Weg, Jails zu erstellen, zu entfernen und zu aktualisieren.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es existieren auch einfachere Lösungen, wie zum Beispiel ezjail, das einfachere Methoden zur Administration von Jails verwendet und daher nicht so anspruchsvoll ist, wie der hier beschriebene Aufbau. ezjail wird in <a href=#jails-ezjail>Verwaltung von Jails mit ezjail</a> ausführlich behandelt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Ziele des in diesem Abschnitt beschriebenen Aufbaus sind:</p></div><div class=ulist><ul><li><p>Das Erstellen einer einfachen und gut verständlichen Jail Struktur, die es nicht erfordert für jede Jail ein vollständiges installworld laufen lassen zu müssen.</p></li><li><p>Es einfach zu machen, neue Jails zu erstellen oder alte zu entfernen.</p></li><li><p>Es einfach zu machen, bestehende Jails zu aktualisieren.</p></li><li><p>Es einfach zu machen, einen angepassten FreeBSD-Zweig zu nutzen.</p></li><li><p>Paranoid bezüglich Sicherheit zu sein und Angriffsmöglichkeiten weitgehend zu reduzieren.</p></li><li><p>Soviel Platz und Inodes wie möglich einzusparen.</p></li></ul></div><div class=paragraph><p>Dieses Design ist darauf angewiesen, dass eine read-only-Hauptvorlage in jede Jail hinein gemountet wird und dass jede Jail über wenigstens ein beschreibbares Gerät verfügt. Das Gerät kann hierbei eine separate physikalische Platte oder ein vnode unterstütztes Speichergerät sein. Im folgenden Beispiel wird ein read/write nullfs-Mount genutzt.</p></div><div class=paragraph><p>Das Layout des Dateisystems ist wie folgt:</p></div><div class=ulist><ul><li><p>Die Jails befinden sich unterhalb der <span class=filename>/home</span> Partition.</p></li><li><p>Jede Jail wird unterhalb des <span class=filename>/home/j</span>-Verzeichnisses gemountet.</p></li><li><p><span class=filename>/home/j/mroot</span> ist die Vorlage für jede Jail und die nur lesbare Partition für alle Jails.</p></li><li><p>Unterhalb von <span class=filename>/home/j</span> wird für jede Jail ein leeres Verzeichnis angelegt.</p></li><li><p>Jede Jail bekommt ein <span class=filename>/s</span>-Verzeichnis, das zum read/write-Teilbereich des Systems verlinkt wird.</p></li><li><p>Jede Jail bekommt ihr eigenes read/write-System, das auf <span class=filename>/home/j/skel</span> basiert.</p></li><li><p>Der read/write-Teilbereich jeder Jail wird in <span class=filename>/home/js</span> erstellt.</p></li></ul></div><div class=sect3><h4 id=jails-service-jails-template>32.5.1. Erstellen der Vorlage<a class=anchor href=#jails-service-jails-template></a></h4><div class=paragraph><p>Dieser Abschnitt beschreibt die Schritte, die zum Erstellen der Hauptvorlage notwendig sind.</p></div><div class=paragraph><p>Es wird empfohlen, zunächst das FreeBSD Host-System nach den Anweisungen in <a href=./#makeworld>“FreeBSD aus den Quellen aktualisieren”</a> auf den aktuellen -RELEASE-Zweig zu aktualisieren. Darüber hinaus verwendet diese Vorlage <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cpdup/>sysutils/cpdup</a>, sowie portsnap zum herunterladen der FreeBSD Ports-Sammlung.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Zuerst erstellen wir eine Verzeichnisstruktur für das read-only-Dateisystem, das die FreeBSD-Binärdateien für die Jails enthalten wird. Anschließend wechseln wir in den FreeBSD-Quellcodebaum und installieren das read-only-Dateisystem in die (Vorlage-)Jail.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j /home/j/mroot</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld DESTDIR=/home/j/mroot</span></code></pre></div></div></li><li><p>Als nächstes bereiten wir die Ports-Sammlung für die Jails vor und kopieren den FreeBSD Quellcodebaum in die Jail, da dieser für mergemaster benötigt wird:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j/mroot</span>
<span class=c># mkdir usr/ports</span>
<span class=c># portsnap -p /home/j/mroot/usr/ports fetch extract</span>
<span class=c># cpdup /usr/src /home/j/mroot/usr/src</span></code></pre></div></div></li><li><p>Danach wird die Struktur für den read/write-Bereich des Systems erstellt:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/skel /home/j/skel/home /home/j/skel/usr-X11R6 /home/j/skel/distfiles</span>
<span class=c># mv etc /home/j/skel</span>
<span class=c># mv usr/local /home/j/skel/usr-local</span>
<span class=c># mv tmp /home/j/skel</span>
<span class=c># mv var /home/j/skel</span>
<span class=c># mv root /home/j/skel</span></code></pre></div></div></li><li><p>Nutzen Sie mergemaster, um fehlende Konfigurationsdateien zu installieren. Anschließend werden die von mergemaster erstellten Extra-Verzeichnisse entfernt:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -t /home/j/skel/var/tmp/temproot -D /home/j/skel -i</span>
<span class=c># cd /home/j/skel</span>
<span class=c># rm -R bin boot lib libexec mnt proc rescue sbin sys usr dev</span></code></pre></div></div></li><li><p>Nun wird das read/write-Dateisystem mit dem read-only-Dateisystem verlinkt. Vergewissern Sie sich, dass die symbolischen Links an den korrekten <span class=filename>s/</span> Positionen erstellt werden, weil echte Verzeichnisse oder an falschen Positionen erstellte Verzeichnisse die Installation fehlschlagen lassen.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j/mroot</span>
<span class=c># mkdir s</span>
<span class=c># ln -s s/etc etc</span>
<span class=c># ln -s s/home home</span>
<span class=c># ln -s s/root root</span>
<span class=c># ln -s s/usr-local usr/local</span>
<span class=c># ln -s s/usr-X11R6 usr/X11R6</span>
<span class=c># ln -s s/distfiles usr/ports/distfiles</span>
<span class=c># ln -s s/tmp tmp</span>
<span class=c># ln -s s/var var</span></code></pre></div></div></li><li><p>Zuletzt erstellen Sie eine allgemeine <span class=filename>/home/j/skel/etc/make.conf</span> mit folgendem Inhalt:</p><div class="literalblock programlisting"><div class=content><pre>WRKDIRPREFIX?=  /s/portbuild</pre></div></div><div class=paragraph><p>Dies erlaubt es, die FreeBSD-Ports innerhalb jeder Jail zu kompilieren. Das Ports-Verzeichnis ist Teil des read-only System. Der angepasste Pfad des <code>WRKDIRPREFIX</code> macht es möglich, innerhalb des read/write-Bereichs der Jail Ports zu bauen.</p></div></li></ol></div></div><div class=sect3><h4 id=jails-service-jails-creating>32.5.2. Jails erstellen<a class=anchor href=#jails-service-jails-creating></a></h4><div class=paragraph><p>Die Jailvorlage kann nun verwendet werden, um die Jails einzurichten und in <span class=filename>/etc/rc.conf</span> zu konfigurieren. In diesem Beispiel werden drei Jails erstellt: <code>NS</code>, <code>MAIL</code> und <code>WWW</code>.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Fügen Sie die folgenden Zeilen in <span class=filename>/etc/fstab</span> ein, damit die read-only-Vorlage und der read/write-Bereich für alle Jails verfügbar sind:</p><div class="literalblock programlisting"><div class=content><pre>/home/j/mroot   /home/j/ns     nullfs  ro  0   0
/home/j/mroot   /home/j/mail   nullfs  ro  0   0
/home/j/mroot   /home/j/www    nullfs  ro  0   0
/home/js/ns     /home/j/ns/s   nullfs  rw  0   0
/home/js/mail   /home/j/mail/s nullfs  rw  0   0
/home/js/www    /home/j/www/s  nullfs  rw  0   0</pre></div></div><div class=paragraph><p>Um zu verhindern, dass fsck die nullfs-Mounts während des Bootens überprüft oder dass dump die Mounts sichert, müssen die letzten beiden Spalten auf <code>0</code> gesetzt werden.</p></div></li><li><p>Konfigurieren Sie die Jails in <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;
jail_set_hostname_allow=&#34;NO&#34;
jail_list=&#34;ns mail www&#34;
jail_ns_hostname=&#34;ns.example.org&#34;
jail_ns_ip=&#34;192.168.3.17&#34;
jail_ns_rootdir=&#34;/usr/home/j/ns&#34;
jail_ns_devfs_enable=&#34;YES&#34;
jail_mail_hostname=&#34;mail.example.org&#34;
jail_mail_ip=&#34;192.168.3.18&#34;
jail_mail_rootdir=&#34;/usr/home/j/mail&#34;
jail_mail_devfs_enable=&#34;YES&#34;
jail_www_hostname=&#34;www.example.org&#34;
jail_www_ip=&#34;62.123.43.14&#34;
jail_www_rootdir=&#34;/usr/home/j/www&#34;
jail_www_devfs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Die Variable <code>jail<em>name</em>rootdir</code> zeigt nach <span class=filename>/usr/home</span> statt nach <span class=filename>/home</span>, da der physikalische Pfad von <span class=filename>/home</span> unter FreeBSD <span class=filename>/usr/home</span> lautet. Die Variable <code>jail<em>name</em>rootdir</code> darf im Pfad aber <em>keinen symbolischen Link</em> enthalten, weil die Jail ansonsten nicht gestartet werden kann.</p></div></li><li><p>Erstellen Sie die notwendigen Mountpunkte für die nur lesbaren Bereiche jeder Jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/ns /home/j/mail /home/j/www</span></code></pre></div></div></li><li><p>Installieren Sie mit <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cpdup/>sysutils/cpdup</a> die read/write-Vorlage in jede Jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/js</span>
<span class=c># cpdup /home/j/skel /home/js/ns</span>
<span class=c># cpdup /home/j/skel /home/js/mail</span>
<span class=c># cpdup /home/j/skel /home/js/www</span></code></pre></div></div></li><li><p>An dieser Stelle werden die Jails erstellt und für den Betrieb vorbereitet. Mounten Sie zuerst die notwendigen Dateisysteme für jede Jail. Danach starten Sie die Jails:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a</span>
<span class=c># service jail start</span></code></pre></div></div></li></ol></div><div class=paragraph><p>Die Jails sollten nun laufen. Um zu prüfen, ob sie korrekt gestartet wurden, verwenden Sie <code>jls</code>. Die Ausgabe sollte ähnlich der folgenden sein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jls</span>
   JID  IP Address      Hostname                      Path
     3  192.168.3.17    ns.example.org                /home/j/ns
     2  192.168.3.18    mail.example.org              /home/j/mail
     1  62.123.43.14    www.example.org               /home/j/www</code></pre></div></div><div class=paragraph><p>An diesem Punkt sollte es möglich sein, sich an jeder Jail anzumelden, Benutzer anzulegen und Dienste zu konfigurieren. Die Spalte <code>JID</code> gibt die Jail-Identifikationsnummer jeder laufenden Jail an. Nutzen Sie den folgenden Befehl, um administrative Aufgaben in der Jail mit der <code>JID``3</code> durchzuführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 3 tcsh</span></code></pre></div></div></div><div class=sect3><h4 id=jails-service-jails-upgrading>32.5.3. Jails aktualisieren<a class=anchor href=#jails-service-jails-upgrading></a></h4><div class=paragraph><p>Das Design dieses Aufbaus bietet einen einfachen Weg, bestehende Jails zu aktualisieren, während die Ausfallzeiten minimiert werden. Außerdem bietet es die Möglichkeit, zu älteren Versionen zurückzukehren, falls irgendwelche Probleme auftreten.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Im ersten Schritt wird das Host-System aktualisiert. Anschließend wird eine temporäre neue read-only Vorlage <span class=filename>/home/j/mroot2</span> erstellt.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/mroot2</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld DESTDIR=/home/j/mroot2</span>
<span class=c># cd /home/j/mroot2</span>
<span class=c># cpdup /usr/src usr/src</span>
<span class=c># mkdir s</span></code></pre></div></div><div class=paragraph><p><code>installworld</code> erzeugt einige unnötige Verzeichnisse, die nun entfernt werden sollten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags -R 0 var</span>
<span class=c># rm -R etc var root usr/local tmp</span></code></pre></div></div></li><li><p>Erzeugen Sie neue symbolische Links für das Hauptdateisystem:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s s/etc etc</span>
<span class=c># ln -s s/root root</span>
<span class=c># ln -s s/home home</span>
<span class=c># ln -s ../s/usr-local usr/local</span>
<span class=c># ln -s ../s/usr-X11R6 usr/X11R6</span>
<span class=c># ln -s s/tmp tmp</span>
<span class=c># ln -s s/var var</span></code></pre></div></div></li><li><p>Nun können die Jails gestoppt werden:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service jail stop</span></code></pre></div></div></li><li><p>Hängen Sie die originalen Dateisysteme aus, da die read/write-Systeme an das read-only System (<span class=filename>/s</span>) angeschlossen sind:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /home/j/ns/s</span>
<span class=c># umount /home/j/ns</span>
<span class=c># umount /home/j/mail/s</span>
<span class=c># umount /home/j/mail</span>
<span class=c># umount /home/j/www/s</span>
<span class=c># umount /home/j/www</span></code></pre></div></div></li><li><p>Verschieben Sie das alte read-only-Dateisystem und ersetzen Sie es durch das neue Dateisystem. Das alte Dateisystem kann so als Backup dienen, falls etwas schief geht. Die Namensgebung entspricht hier derjenigen bei der Erstellung eines neuen read-only-Dateisystems. Verschieben Sie die originale FreeBSD Ports-Sammlung in das neue Dateisystem, um Platz und Inodes zu sparen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j</span>
<span class=c># mv mroot mroot.20060601</span>
<span class=c># mv mroot2 mroot</span>
<span class=c># mv mroot.20060601/usr/ports mroot/usr</span></code></pre></div></div></li><li><p>Nun ist die neue read-only-Vorlage fertig. Sie müssen daher nur noch die Dateisysteme erneut mounten und die Jails starten:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a</span>
<span class=c># service jail start</span></code></pre></div></div></li></ol></div><div class=paragraph><p>Nutzen Sie <code>jls</code> um zu prüfen, ob die Jails korrekt gestartet wurden. Führen Sie innerhalb jeder Jail <code>mergemaster</code> aus, damit die Konfigurationsdateien aktualisiert werden.</p></div></div></div><div class=sect2><h3 id=jails-ezjail>32.6. Verwaltung von Jails mit ezjail<a class=anchor href=#jails-ezjail></a></h3><div class=paragraph><p>Das Erstellen und Verwalten von mehreren Jails kann schnell zeitaufwändig und fehleranfällig werden. Dirk Engling’s ezjail automatisiert und vereinfacht viele dieser Aufgaben. Als Vorlage wird ein <em>Basejail</em> erzeugt. Zusätzliche Jails nutzen <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nullfs&amp;sektion=8&amp;format=html">mount_nullfs(8)</a> um viele Verzeichnisse aus der Basejail zu teilen, ohne dabei zusätzlichen Speicherplatz zu belegen. Jedes weitere Jail benötigt daher nur wenige Megabyte an Speicherplatz, bevor die Anwendungen installiert werden.</p></div><div class=paragraph><p>Weitere Vorteile und Merkmale werden im Detail auf der Webseite von ezjail beschrieben: <a href=https://erdgeist.org/arts/software/ezjail/ class=bare>https://erdgeist.org/arts/software/ezjail/</a>.</p></div><div class=sect3><h4 id=jails-ezjail-install>32.6.1. ezjail installieren<a class=anchor href=#jails-ezjail-install></a></h4><div class=paragraph><p>Für die Installation von ezjail wird zunächst eine Loopback-Schnittstelle für die Jails benötigt. Anschließend kann ezjail installiert und der dazugehörige Dienst aktiviert werden.</p></div><div id=jails-ezjail-install-procedure class="olist arabic procedure"><ol class=arabic><li><p>Damit der Verkehr auf der Loopback-Schnittstelle des Jails vom Host-System separiert ist, wird eine zweite Loopback-Schnittstelle in <span class=filename>/etc/rc.conf</span> erstellt:</p><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;lo1&#34;</pre></div></div><div class=paragraph><p>Die zusätzliche Schnittstelle <code>lo1</code> wird erstellt, wenn das System neu gestartet wird. Die Schnittstelle kann auch ohne Neustart manuell erstellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif cloneup</span>
Created clone interfaces: lo1.</code></pre></div></div><div class=paragraph><p>Jails können die Aliase dieser sekundären Schnittstelle verwenden, ohne dabei das Host-System zu stören.</p></div><div class=paragraph><p>Der Zugang zur Loopback-Adresse <code>127.0.0.1</code> wird an die erste IP-Adresse umgeleitet, die dem Jail zugewiesen ist. Damit die Loopback-Schnittstelle des Jails der neuen <code>lo1</code>-Schnittstelle zugeordnet werden kann, muss beim Erstellen der Jail diese Schnittstelle als erstes in der Liste der IP-Adressen angegeben werden.</p></div><div class=paragraph><p>Teilen Sie jedem Jail eine Loopback-Adresse aus dem Netzblock <code>127.0.0.0`</code>/8` zu.</p></div></li><li><p>Installieren Sie <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/ezjail/>sysutils/ezjail</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/ezjail</span>
<span class=c># make install clean</span></code></pre></div></div></li><li><p>Aktivieren Sie ezjail, indem Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzufügen:</p><div class="literalblock programlisting"><div class=content><pre>ezjail_enable=&#34;YES&#34;</pre></div></div></li><li><p>Der Dienst wird automatisch gestartet, wenn das System bootet. Er kann auch direkt für die aktuelle Sitzung gestartet werden:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ezjail start</span></code></pre></div></div></li></ol></div></div><div class=sect3><h4 id=jails-ezjail-initialsetup>32.6.2. Einrichtung<a class=anchor href=#jails-ezjail-initialsetup></a></h4><div class=paragraph><p>Nach erfolgreicher Installation von ezjail kann die Verzeichnisstruktur für die Basejail erstellt und befüllt werden. Dieser Schritt wird einmalig auf dem Host-System ausgeführt.</p></div><div class=paragraph><p>In diesen beiden Beispielen wird <code>-p</code> verwendet, um die Ports-Sammlung mit <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> in die Basejail herunterzuladen. Diese Kopie kann dann von allen Jails gemeinsam genutzt werden. Eine separate Kopie der Ports-Sammlung für die Jails ermöglicht die Isolierung der Ports vom Host-System. Die FAQ von ezjail erklärt dies im Detail: <a href=https://erdgeist.org/arts/software/ezjail/#FAQ class=bare>https://erdgeist.org/arts/software/ezjail/#FAQ</a>.</p></div><div id=jails-ezjail-initialsetup-procedure class="olist arabic procedure"><ol class=arabic><li><p>Die Jail mit FreeBSD-RELEASE installieren</p><div class=paragraph><p>Benutzen Sie <code>install</code>, wenn das FreeBSD-RELEASE für die Jail der Version auf dem Host-System entspricht. Wenn beispielsweise auf dem Host-System FreeBSD 10-STABLE installiert ist, wird in der Jail das neueste RELEASE von FreeBSD-10 installiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin install -p</span></code></pre></div></div></li><li><p>Die Jail mit <code>installworld</code> installieren</p><div class=paragraph><p>Mit <code>ezjail-admin update</code> kann die Basejail mit den Binärdateien aus dem Host-System befüllt werden. Diese Dateien wurden auf dem Host-System mittels <code>buildworld</code> erzeugt.</p></div><div class=paragraph><p>In diesem Beispiel wird FreeBSD 10-STABLE aus den Quellen gebaut. Die Verzeichnisse für die Jail wurden bereits erstellt. Anschließend wird <code>installworld</code> ausgeführt, das <span class=filename>/usr/obj</span> aus dem Host-System in die Basejail installiert.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -i -p</span></code></pre></div></div><div class=paragraph><p>In der Voreinstellung wird <span class=filename>/usr/src</span> des Host-Systems verwendet. Ein anderes Quellverzeichnis kann durch die Angabe von <code>-s</code>, oder durch Setzen der Variable <code>ezjail_sourcetree</code> in <span class=filename>/usr/local/etc/ezjail.conf</span> definiert werden.</p></div></li></ol></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Die Ports-Sammlung der Basejail wird mit den anderen Jails geteilt, jedoch werden die heruntergeladenen Distfiles im jeweiligen Jail gespeichert. In der Voreinstellung werden diese Dateien in <span class=filename>/var/ports/distfiles</span> der Jail gespeichert. Wenn die Ports gebaut werden, wird <span class=filename>/var/ports</span> im Jail als Arbeitsverzeichnis genutzt.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Zum herunterladen der Pakete, für die Installation in der Basejail, wird in der Voreinstellung das FTP-Protokoll verwendet. Firewalls und Proxies können jedoch bei der FTP-Übertragung Probleme verursachen. Das HTTP-Protokoll arbeitet anderes und vermeidet diese Probleme. Sie können eine URL für einen bestimmten Spiegel in <span class=filename>/usr/local/etc/ezjail.conf</span> eintragen:</p></div><div class="literalblock programlisting"><div class=content><pre>ezjail_ftphost=http://ftp.FreeBSD.org</pre></div></div><div class=paragraph><p>Im <a href=./#mirrors-ftp>“FTP-Server”</a> finden Sie eine Liste mit Spiegeln.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=jails-ezjail-create>32.6.3. Eine neue Jail erstellen und starten<a class=anchor href=#jails-ezjail-create></a></h4><div class=paragraph><p>Neue Jails werden mit <code>ezjail-admin create</code> erstellt. In diesen Beispielen wird die <code>lo1</code> Loopback-Schnittstelle, wie oben beschrieben, verwendet.</p></div><div id=jails-ezjail-create-steps class="olist arabic procedure"><div class=title>Procedure: Eine neue Jail erstellen und starten</div><ol class=arabic><li><p>Geben Sie bei der Erstellung der Jail einen Namen und die verwendeten Loopback- und Netzwerk-Schnittstellen mit den IP-Adressen an. In diesem Beispiel trägt die Jail den Namen <code>dnsjail</code>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin create dnsjail &#39;lo1|127.0.1.1,em0|192.168.1.50&#39;</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Die meisten Netzwerkdienste laufen problemlos in einer Jail. Ein paar wenige Netzwerkdienste, vor allem <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> verwenden Netzwerk-Sockets. Aus Sicherheitsgründen werden Netzwerk-Sockets innerhalb der Jails deaktiviert, so dass Dienste, die diese Sockets benötigten, nicht funktionieren werden. Gelegentlich benötigt ein Jail jedoch den Zugriff auf Raw-Sockets. Beispielsweise verwenden Netzwerk-Monitoring-Anwendungen <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>, um die Verfügbarkeit von anderen Rechnern zu überprüfen. Sollten diese Sockets tatsächlich benötigt werden, können sie durch einen Eintrag in der Konfigurationsdatei von ezjail, <span class=filename>/usr/local/etc/jailname</span>, für einzelne Jails aktiviert werden. Bearbeiten Sie den Eintrag <code>parameters</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>export jail_jailname_parameters=&#34;allow.raw_sockets=1&#34;</pre></div></div><div class=paragraph><p>Aktivieren Sie keine Netzwerk-Sockets, solange die Dienste im Jail sie nicht tatsächlich benötigen.</p></div></td></tr></tbody></table></div></li><li><p>Starten Sie die Jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin start dnsjail</span></code></pre></div></div></li><li><p>Starten Sie eine Konsole in der Jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin console dnsjail</span></code></pre></div></div></li></ol></div><div class=paragraph><p>Die Jail ist jetzt in Betrieb und die zusätzliche Konfiguration kann nun abgeschlossen werden. Typische Einstellungen an dieser Stelle sind:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Das <code>root</code>-Passwort setzen</p><div class=paragraph><p>Verbinden Sie sich mit der Jail und setzen Sie das Passwort für den Benutzer <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin console dnsjail</span>
<span class=c># passwd</span>
Changing <span class=nb>local </span>password <span class=k>for </span>root
New Password:
Retype New Password:</code></pre></div></div></li><li><p>Konfiguration der Zeitzone</p><div class=paragraph><p>Die Zeitzone kann innerhalb der Jail mit <a href="https://man.freebsd.org/cgi/man.cgi?query=tzsetup&amp;sektion=8&amp;format=html">tzsetup(8)</a> gesetzt werden. Um störende Fehlermeldungen zu vermeiden, kann der Eintrag <a href="https://man.freebsd.org/cgi/man.cgi?query=adjkerntz&amp;sektion=8&amp;format=html">adjkerntz(8)</a> in <span class=filename>/etc/crontab</span> auskommentiert werden. Dieser Job versucht die Uhr des Rechners zu aktualisieren, was jedoch in einem Jail fehlschlägt, da die Jail nicht auf diese Hardware zugreifen darf.</p></div></li><li><p>DNS-Server</p><div class=paragraph><p>Tragen Sie die Zeilen für die Nameserver der Domäne in <span class=filename>/etc/resolv.conf</span> ein, damit die Namensauflösung in der Jail funktioniert.</p></div></li><li><p><span class=filename>/etc/hosts</span> anpassen</p><div class=paragraph><p>Ändern Sie die Adresse und fügen Sie den Namen der Jail zu den <code>localhost</code>-Einträgen in <span class=filename>/etc/hosts</span> hinzu.</p></div></li><li><p><span class=filename>/etc/rc.conf</span> konfigurieren</p><div class=paragraph><p>Tragen Sie Konfigurationseinstellungen in <span class=filename>/etc/rc.conf</span> ein. Der Rechnername und die IP-Adresse werden nicht eingestellt, da diese Werte bereits durch die Jail-Konfiguration zur Verfügung gestellt werden.</p></div></li></ol></div><div class=paragraph><p>Nach der Konfiguration der Jail können die Anwendungen, für die die Jail erstellt wurde, installiert werden.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Einige Ports müssen mit speziellen Optionen gebaut werden, damit sie in der Jail verwendet werden können. Zum Beispiel haben die Netzwerk-Monitoring-Pakete <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/nagios-plugins/>net-mgmt/nagios-plugins</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/monitoring-plugins/>net-mgmt/monitoring-plugins</a> eine Option <code>JAIL</code>, die aktiviert werden muss, damit diese Werkzeuge innerhalb einer Jail funktionieren.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=jails-ezjail-update>32.6.4. Jails aktualisieren<a class=anchor href=#jails-ezjail-update></a></h4><div class=sect4><h5 id=jails-ezjail-update-os>32.6.4.1. Das Betriebssystem aktualisieren<a class=anchor href=#jails-ezjail-update-os></a></h5><div class=paragraph><p>Da das Basissystem der Basejail von den anderen Jails gemeinsam genutzt wird, werden bei einem Update der Basejail automatisch alle anderen Jails aktualisiert. Die Aktualisierung kann entweder über den Quellcode oder über binäre Updates erfolgen.</p></div><div class=paragraph><p>Um das Basissystem auf dem Host-System zu bauen und in der Basejail zu installieren, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -b</span></code></pre></div></div><div class=paragraph><p>Wenn das Basissystem bereits auf dem Host-System gebaut wurde, kann es in der Basejail installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -i</span></code></pre></div></div><div class=paragraph><p>Binär-Updates verwenden <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a>. Das Update unterliegt dabei den gleichen Einschränkungen, als wenn <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> direkt ausgeführt würde. Vor allem stehen mit dieser Methode nur -RELEASE Versionen von FreeBSD zur Verfügung.</p></div><div class=paragraph><p>Aktualisieren Sie die Basejail auf die neueste FreeBSD-Version des Host-Systems. Zum Beispiel von RELEASE-p1 auf RELEASE-p2.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -u</span></code></pre></div></div><div class=paragraph><p>Damit das Basejail aktualisiert werden kann, muss zunächst das Host-System, wie in <a href=./#freebsdupdate-upgrade>“Aktualisierungen an Haupt- und Unterversionen”</a> beschrieben, aktualisiert werden. Sobald das Host-System aktualisiert und neu gestartet wurde, kann die Basejail aktualisiert werden. Da <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> keine Möglichkeit besitzt, die derzeit installierte Version der Basejail zu bestimmen, muss die ursprüngliche Version beim Aufruf mit angegeben werden. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=file&amp;sektion=1&amp;format=html">file(1)</a> um die ursprüngliche Version der Basejail zu bestimmen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># file /usr/jails/basejail/bin/sh</span>
/usr/jails/basejail/bin/sh: ELF 64-bit LSB executable, x86-64, version 1 <span class=o>(</span>FreeBSD<span class=o>)</span>, dynamically linked <span class=o>(</span>uses shared libs<span class=o>)</span>, <span class=k>for </span>FreeBSD 9.3, stripped</code></pre></div></div><div class=paragraph><p>Nutzen Sie diese Information, um die Aktualisierung von <code>9.3-RELEASE</code> auf die aktuelle Version des Host-Systems durchzuführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -U -s 9.3-RELEASE</span></code></pre></div></div><div class=paragraph><p>Nachdem die Basejail aktualisiert ist, muss in jeder Jail <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> ausgeführt werden, um die Konfigurationsdateien zu aktualisieren.</p></div><div class=paragraph><p>Wie <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> verwendet wird, hängt stark vom Zweck und Vertrauenswürdigkeit der Jail ab. Wenn die Dienste oder Benutzer nicht vertrauenswürdig sind, dann sollte <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> nur innerhalb der Jail ausgeführt werden:</p></div><div id=jails-ezjail-update-mergemaster-untrusted class=exampleblock><div class=title>Beispiel 33. <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> in einer nicht vertrauenswürdigen Jail ausführen</div><div class=content><div class=paragraph><p>Entfernen Sie die Verknüpfung von <span class=filename>/usr/src</span> des Jails zur Basejail und erstellen Sie ein neues <span class=filename>/usr/src</span> als Mountpunkt für die Jail. Hängen Sie <span class=filename>/usr/src</span> vom Host-System schreibgeschützt in den Mountpunkt für die Jail ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm /usr/jails/jailname/usr/src</span>
<span class=c># mkdir /usr/jails/jailname/usr/src</span>
<span class=c># mount -t nullfs -o ro /usr/src /usr/jails/jailname/usr/src</span></code></pre></div></div><div class=paragraph><p>Öffnen Sie eine Konsole in der Jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin console jailname</span></code></pre></div></div><div class=paragraph><p>Innerhalb der Jail führen Sie dann <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> aus. Danach verlassen Sie die Konsole:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># mergemaster -U</span>
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>Abschließend können Sie <span class=filename>/usr/src</span> aus der Jail aushängen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /usr/jails/jailname/usr/src</span></code></pre></div></div></div></div><div id=jails-ezjail-update-mergemaster-trusted class=exampleblock><div class=title>Beispiel 34. <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> in einer vertrauenswürdigen Jail ausführen</div><div class=content><div class=paragraph><p>Wenn den Benutzern und den Diensten in der Jail vertraut wird, kann <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> auf dem Host-System ausgeführt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -U -D /usr/jails/jailname</span></code></pre></div></div></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Nach einem größeren Versionsupdate empfiehlt <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/ezjail/>sysutils/ezjail</a>, sicherzustellen, dass <code>pkg</code> die richtige Version hat. Geben Sie dazu den folgenden Befehl ein, um auf die entsprechende Version zu aktualisieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg-static upgrade -f pkg</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=jails-ezjail-update-ports>32.6.4.2. Ports aktualisieren<a class=anchor href=#jails-ezjail-update-ports></a></h5><div class=paragraph><p>Die Ports-Sammlung der Basejail wird von den anderen Jails gemeinsam genutzt. Somit genügt es, die Ports-Sammlung in der Basejail zu aktualisieren.</p></div><div class=paragraph><p>Die Ports-Sammlung der Basejail wird mit <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> aktualisiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -P</span></code></pre></div></div></div></div><div class=sect3><h4 id=jails-ezjail-control>32.6.5. Jails verwalten<a class=anchor href=#jails-ezjail-control></a></h4><div class=sect4><h5 id=jail-ezjail-control-stop-start>32.6.5.1. Jails starten und stoppen<a class=anchor href=#jail-ezjail-control-stop-start></a></h5><div class=paragraph><p>ezjail startet automatisch alle Jails, wenn das System hochfährt. Jails können auch manuell mit <code>stop</code> und <code>start</code> gestoppt und neu gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin stop sambajail</span>
Stopping jails: sambajail</code></pre></div></div><div class=paragraph><p>In der Voreinstellung werden die Jails automatisch gestartet, wenn das Host-System hochfährt. Der automatische Start kann mit <code>config</code> deaktiviert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin config -r norun seldomjail</span></code></pre></div></div><div class=paragraph><p>Diese Einstellung wird nach einem Neustart des Host-Systems aktiviert. Eine Jail, die bereits läuft, wird hiermit nicht gestoppt.</p></div><div class=paragraph><p>Der automatische Start kann auch aktiviert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin config -r run oftenjail</span></code></pre></div></div></div><div class=sect4><h5 id=jails-ezjail-control-backup>32.6.5.2. Jails archivieren und wiederherstellen<a class=anchor href=#jails-ezjail-control-backup></a></h5><div class=paragraph><p>Benutzen Sie <code>archive</code> um ein <span class=filename>.tar.gz</span>-Archiv einer Jail zu erstellen. Der Dateiname wird aus dem Namen der Jail und dem aktuellen Datum zusammengesetzt. Archivdateien werden in <span class=filename>/usr/jails/ezjail_archives</span> abgelegt. Ein alternatives Verzeichnis für die Ablage kann in der Variable <code>ezjail_archivedir</code> der Konfigurationsdatei definiert werden.</p></div><div class=paragraph><p>Die Archivdatei kann an anderer Stelle als Sicherung gespeichert werden, oder eine andere Jail kann daraus mit <code>restore</code> wiederhergestellt werden. Eine neue Jail kann auch aus dem Archiv erstellt werden, was eine bequeme Möglichkeit bietet, bestehende Jails zu klonen.</p></div><div class=paragraph><p>Die Jail <code>wwwserver</code> stoppen und archivieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin stop wwwserver</span>
Stopping jails: wwwserver.
<span class=c># ezjail-admin archive wwwserver</span>
<span class=c># ls /usr/jails/ezjail-archives/</span>
wwwserver-201407271153.13.tar.gz</code></pre></div></div><div class=paragraph><p>Erstellen Sie aus dem eben erzeugten Archiv eine neue Jail namens <code>wwwserver-clone</code>. Verwenden Sie die Schnittstelle <span class=filename>em1</span> und weisen Sie eine neue IP-Adresse zu, um einen Konflikt mit dem Original zu vermeiden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin create -a /usr/jails/ezjail_archives/wwwserver-201407271153.13.tar.gz wwwserver-clone &#39;lo1|127.0.3.1,em1|192.168.1.51&#39;</span></code></pre></div></div></div></div><div class=sect3><h4 id=jails-ezjail-example-bind>32.6.6. Vollständiges Beispiel: BIND in einer Jail<a class=anchor href=#jails-ezjail-example-bind></a></h4><div class=paragraph><p>Einen BINDDNS-Server innerhalb einer Jail zu betreiben erhöht die Sicherheit, da der Dienst isoliert wird. Dieses Beispiel erstellt einen einfachen caching-only Nameserver.</p></div><div class=ulist><ul><li><p>Die Jail bekommt den Namen <code>dns1</code>.</p></li><li><p>Die Jail erhält die IP-Adresse <code>192.168.1.240</code> auf der Schnittstelle <code>re0</code> des Host-Systems.</p></li><li><p>Die Upstream-DNS-Server des ISPs lauten <code>10.0.0.62</code> und <code>10.0.0.61</code>.</p></li><li><p>Die Basejail wurde bereits erstellt und die Ports-Sammlung installiert, wie in <a href=#jails-ezjail-initialsetup>Einrichtung</a> beschrieben.</p></li></ul></div><div id=jails-ezjail-example-bind-steps class=exampleblock><div class=title>Beispiel 35. BIND in einer Jail laufen lassen</div><div class=content><div class=paragraph><p>Erstellen Sie eine geklonte Loopback-Schnittstelle durch einen Eintrag in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;lo1&#34;</pre></div></div><div class=paragraph><p>Erzeugen Sie jetzt die Loopback-Schnittstelle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif cloneup</span>
Created clone interface: lo1</code></pre></div></div><div class=paragraph><p>Erstellen Sie die Jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin create dns1 &#39;lo1|127.0.2.1,re0|192.168.1.240&#39;</span></code></pre></div></div><div class=paragraph><p>Starten Sie die Jail, verbinden Sie sich mit der Konsole und führen Sie die grundlegende Konfiguration durch:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin start dns1</span>
<span class=c># ezjail-admin console dns1</span>
<span class=c># passwd</span>
Changing <span class=nb>local </span>password <span class=k>for </span>root
New Password:
Retype New Password:
<span class=c># tzsetup</span>
<span class=c># sed -i .bak -e &#39;/adjkerntz/ s/^/#/&#39; /etc/crontab</span>
<span class=c># sed -i .bak -e &#39;s/127.0.0.1/127.0.2.1/g; s/localhost.my.domain/dns1.my.domain dns1/&#39; /etc/hosts</span></code></pre></div></div><div class=paragraph><p>Setzen Sie vorübergehend die Upstream-DNS-Server in <span class=filename>/etc/resolv.conf</span>, damit die Ports-Sammlung heruntergeladen werden kann:</p></div><div class="literalblock programlisting"><div class=content><pre>nameserver 10.0.0.62
nameserver 10.0.0.62</pre></div></div><div class=paragraph><p>Immer noch in der Konsole der Jail, installieren Sie <a class=package href=https://cgit.freebsd.org/ports/tree/dns/bind99/>dns/bind99</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -C /usr/ports/dns/bind99 install clean</span></code></pre></div></div><div class=paragraph><p>Konfigurieren Sie den Nameserver in <span class=filename>/usr/local/etc/namedb/named.conf</span>.</p></div><div class=paragraph><p>Erstellen Sie eine Zugriffskontrollliste (ACL) der Adressen und Netzwerke, die DNS-Anfragen an diesen Nameserver senden dürfen. Diese Sektion wird vor der Sektion <code>options</code> hinzugefügt, die sich bereits in der Datei befindet:</p></div><div class="literalblock programlisting"><div class=content><pre>...
// or cause huge amounts of useless Internet traffic.

acl &#34;trusted&#34; {
	192.168.1.0/24;
	localhost;
	localnets;
};

options {
...</pre></div></div><div class=paragraph><p>Verwenden Sie die IP-Adresse der Jail in der Direktive <code>listen-on</code>, um DNS-Anfragen von anderen Rechnern aus dem Netzwerk zu akzeptieren:</p></div><div class="literalblock programlisting"><div class=content><pre>	listen-on	{ 192.168.1.240; };</pre></div></div><div class=paragraph><p>Entfernen Sie die Kommentarzeichen <code>/<strong></strong></code><strong> und <code></code></strong><code>/</code>. Tragen Sie die IP-Adressen der Upstream-DNS-Server ein. Unmittelbar nach der Sektion <code>forwarders</code> fügen Sie Verweise auf die bereits definierten ACLs ein:</p></div><div class="literalblock programlisting"><div class=content><pre>	forwarders {
		10.0.0.62;
		10.0.0.61;
	};

	allow-query       { any; };
	allow-recursion   { trusted; };
	allow-query-cache { trusted; };</pre></div></div><div class=paragraph><p>Aktivieren Sie den Dienst in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>named_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten und testen Sie den Nameserver:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service named start</span>
wrote key file <span class=s2>&#34;/usr/local/etc/namedb/rndc.key&#34;</span>
Starting named.
<span class=c># /usr/local/bin/dig @192.168.1.240 freebsd.org</span></code></pre></div></div><div class=paragraph><p>Beinhaltet die Antwort</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=p>;;</span> Got answer<span class=p>;</span></code></pre></div></div><div class=paragraph><p>dann funktioniert der Nameserver. Eine längere Verzögerung, gefolgt von der Antwort</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=p>;;</span> connection timed out<span class=p>;</span> no servers could be reached</code></pre></div></div><div class=paragraph><p>weist auf ein Problem hin. Überprüfen Sie die Konfigurationseinstellungen und stellen Sie sicher, dass alle lokalen Firewalls den DNS-Zugriff auf die Upstream-DNS-Server erlauben.</p></div><div class=paragraph><p>Wie auch jeder andere lokale Rechner, kann der DNS-Server Anfragen für Namensauflösung an sich selbst stellen. Tragen Sie die Adresse des DNS-Servers in die <span class=filename>/etc/resolv.conf</span> der Client-Rechner:</p></div><div class="literalblock programlisting"><div class=content><pre>nameserver 192.168.1.240</pre></div></div><div class=paragraph><p>Ein lokaler DHCP-Server kann die Adresse eines lokalen DNS-Servers automatisch für alle DHCP-Clients zur Verfügung stellen.</p></div></div></div></div></div></div></div><div class=sect1><h2 id=mac>Kapitel 33. Verbindliche Zugriffskontrolle<a class=anchor href=#mac></a></h2><div class=sectionbody><div class=sect2><h3 id=mac-synopsis>33.1. Übersicht<a class=anchor href=#mac-synopsis></a></h3><div class=paragraph><p>In FreeBSD 5.X wurden neue Sicherheits-Erweiterungen verfügbar, die aus dem TrustedBSD-Projekt übernommen wurden und auf dem Entwurf POSIX®.1e basieren. Die beiden bedeutendsten neuen Sicherheits-Mechanismen sind Berechtigungslisten (Access Control Lists, ACL) und die verbindliche Zugriffskontrolle (Mandatory Access Control, MAC). Durch die MAC können Module geladen werden, die neue Sicherheitsrichtlinien bereitstellen. Mit Hilfe einiger Module kann beispielsweise ein eng umgrenzter Bereich des Betriebssystems gesichert werden, indem die Sicherheitsfunktionen spezieller Dienste unterstützt bzw. verstärkt werden. Andere Module wiederum betreffen in ihrer Funktion das gesamte System - alle vorhandenen Subjekte und Objekte. Das "Verbindliche" in der Namensgebung erwächst aus dem Fakt, dass die Kontrolle allein Administratoren und dem System obliegt und nicht dem Ermessen der Nutzer, wie es mit Hilfe der benutzerbestimmbaren Zugriffskontrolle (Discrectionary Access Control / DAC), dem Zugriffstandard für Dateien, gar der System V IPC in FreeBSD, normalerweise umgesetzt wird.</p></div><div class=paragraph><p>Dieses Kapitel wird sich auf die Grundstruktur der Verbindlichen Zugriffskontrolle und eine Auswahl der Module, die verschiedenste Sicherheitsfunktionen zur Verfügung stellen, konzentrieren.</p></div><div class=paragraph><p>Beim Durcharbeiten dieses Kapitels erfahren Sie:</p></div><div class=ulist><ul><li><p>Welche MAC Module für Sicherheitsrichtlinien derzeit in FreeBSD eingebettet sind und wie die entsprechenden Mechanismen funktionieren.</p></li><li><p>Was die einzelnen MAC Module an Funktionen realisieren und auch, was der Unterschied zwischen einer Richtlinie, die <em>mit</em> Labels arbeitet, und einer, die <em>ohne</em> Labels arbeitet, ist.</p></li><li><p>Wie Sie die MAC in ein System einbetten und effizient einrichten.</p></li><li><p>Wie die verschiedenen Richtlinienmodule einer MAC konfiguriert werden.</p></li><li><p>Wie mit einer MAC und den gezeigten Beispielen eine sicherere Umgebung erstellt werden kann.</p></li><li><p>Wie die Konfiguration einer MAC auf korrekte Einrichtung getestet wird.</p></li></ul></div><div class=paragraph><p>Vor dem Lesen dieses Kapitels sollten Sie bereits:</p></div><div class=ulist><ul><li><p>Grundzüge von UNIX® und FreeBSD verstanden haben. (<a href=./#basics>Grundlagen des FreeBSD Betriebssystems</a>).</p></li><li><p>Mit den Grundzügen der Kernelkonfiguration und -kompilierung vertraut sein (<a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a>).</p></li><li><p>Einige Vorkenntnisse über Sicherheitskonzepte im Allgemeinen und deren Umsetzung in FreeBSD im Besonderen mitbringen (<a href=./#security>Sicherheit)</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Der unsachgemäße Gebrauch der in diesem Kapitel enthaltenen Informationen kann den Verlust des Systemzugriffs, Ärger mit Nutzern oder die Unfähigkeit, grundlegende Funktionen des X-Windows-Systems zu nutzen, verursachen. Wichtiger noch ist, dass man sich nicht allein auf die MAC verlassen sollte, um ein System zu sichern. Die MAC verbessert und ergänzt lediglich die schon existierenden Sicherheits-Richtlinien - ohne eine gründliche und fundierte Sicherheitspraxis und regelmäßige Sicherheitsprüfungen wird Ihr System nie vollständig sicher sein.</p></div><div class=paragraph><p>Außerdem sollte angemerkt werden, dass die Beispiele in diesem Kapitel auch genau dasselbe sein sollen, nämlich Beispiele. Es wird nicht empfohlen, diese bestimmten Beispiele auf einem Arbeitssystem umzusetzen. Das Einarbeiten der verschiedenen Sicherheitsmodule erfordert eine Menge Denkarbeit und viele Tests. Jemand, der nicht versteht, wie diese Module funktionieren, kann sich schnell darin wiederfinden, dass er (oder sie) das ganze System durchforsten und viele Dateien und Verzeichnisse neu konfigurieren muß.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_was_in_diesem_kapitel_nicht_behandelt_wird>33.1.1. Was in diesem Kapitel nicht behandelt wird<a class=anchor href=#_was_in_diesem_kapitel_nicht_behandelt_wird></a></h4><div class=paragraph><p>Dieses Kapitel behandelt einen großen Teil sicherheitsrelevanter Themen, bezogen auf die Verbindliche Zugriffskontrolle (MAC). Die gegenwärtige Entwicklung neuer MAC Module ist nicht abgedeckt. Einige weitere Module, die im MAC Framework enthalten sind, haben besondere Charakteristika, die zum Testen und Entwickeln neuer Module gedacht sind. Dies sind unter anderem <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_test&amp;sektion=4&amp;format=html">mac_test(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_stub&amp;sektion=4&amp;format=html">mac_stub(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_none&amp;sektion=4&amp;format=html">mac_none(4)</a>. Für weitere Informationen zu diesen Modulen und den entsprechend angebotenen Funktionen lesen Sie bitte die Manpages.</p></div></div></div><div class=sect2><h3 id=mac-inline-glossary>33.2. Schlüsselbegriffe<a class=anchor href=#mac-inline-glossary></a></h3><div class=paragraph><p>Bevor Sie weiterlesen, müssen noch einige Schlüsselbegriffe geklärt werden. Dadurch soll jegliche auftretende Verwirrung von vornherein beseitigt und die plötzliche Einführung neuer Begriffe und Informationen vermieden werden.</p></div><div class=ulist><ul><li><p><em>Verbund</em>: Ein Verbund ist ist ein Satz von Programmen und Daten, die speziell und zusammen abgeschottet wurden, um Nutzern Zugriff auf diese ausgewiesenen Systembereiche zu gewähren. Man kann sagen, ein solcher Verbund ist eine Gruppierung, ähnlich einer Arbeitsgruppe, einer Abteilung, einem Projekt oder einem Thema. Durch die Nutzung von Verbünden (<em>compartments</em>) kann man Sicherheitsrichtlinien erstellen, die alles notwendige Wissen und alle Werkzeuge zusammenfassen.</p></li><li><p><em>Hochwassermarkierung</em>: Eine solche Richtlinie erlaubt die Erhöhung der Sicherheitsstufe in Abhängigkeit der Klassifikation der gesuchten bzw. bereitzustellenden Information. Normalerweise wird nach Abschluss des Prozesses die ursprüngliche Sicherheitsstufe wieder hergestellt. Derzeit enthält die MAC Grundstruktur keine Möglichkeit, eine solche Richtlinie umzusetzen, der Vollständigkeit halber ist die Definition hier jedoch aufgeführt.</p></li><li><p><em>Integrität</em>: Das Schlüsselkonzept zur Klassifizierung der Vertraulichkeit von Daten nennt man Integrität. Je weiter die Integrität erhöht wird, umso mehr kann man den entsprechenden Daten vertrauen.</p></li><li><p><em>Label</em>: Ein Label ist ein Sicherheitsmerkmal, welches mit Dateien, Verzeichnissen oder anderen Elementen im System verbunden wird. Man sollte es wie einen Vertraulichkeitsstempel auffassen, der Dateien angehört wie beispielsweise die Zugriffszeit, das Erstellungsdatum oder auch der Name; sobald Dateien derart gekennzeichnet werden, bezeichnen diese Label die sicherheitsrelevanten Eigenschaften. Zugriff ist nur noch dann möglich, wenn das zugreifende Subjekt eine korrespondierende Kennzeichnung trägt. Die Bedeutung und Verarbeitung der Label-Werte ist von der Einrichtung der Richtlinie abhängig: Während einige Richtlinien das Label zum Kennzeichnen der Vertraulichkeit oder Geheimhaltungsstufe eines Objekts nutzen, können andere Richtlinien an derselben Stelle Zugriffsregeln festschreiben.</p></li><li><p><em>Level</em>: Eine erhöhte oder verminderte Einstellung eines Sicherheitsmerkmals. Wenn das Level erhöht wird, wird auch die ensprechende Sicherheitsstufe angehoben.</p></li><li><p><em>Niedrigwassermarkierung</em>: Eine solche Richtlinie erlaubt das Herabstufen des Sicherheitslevels, um weniger sensible Daten verfügbar zu machen. In die meisten Fällen wird das ursprüngliche Sicherheitslevel des Nutzers wiederhergestellt, sobald der Vorgang abgeschlossen ist. Das einzige Modul in FreeBSD, welches von dieser Richtlinie Gebrauch macht, ist <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a>.</p></li><li><p><em>Multilabel</em>: Die Eigenschaft <code>multilabel</code> ist eine Dateisystemoption, die entweder im Einzelbenutzermodus mit Hilfe des Werkzeugs <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>, während des Bootvorgangs in der Datei <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> oder aber beim Erstellen einen neues Dateisystems aktiviert werden kann. Diese Option erlaubt einem Administrator, verschiedenen Objekten unterschiedliche Labels zuzuordnen - kann jedoch nur zusammen mit Modulen angewendet werden, die auch tatsächlich mit Labels arbeiten.</p></li><li><p><em>Objekt</em>: Ein Objekt oder auch Systemobjekt ist theoretisch eine Einheit, durch welche Information fließt, und zwar unter der Lenkung eines <em>Subjektes</em>. Praktisch schliesst diese Definition Verzeichnisse, Dateien, Felder, Bildschirme, Tastaturen, Speicher, Bandlaufwerke, Drucker und jegliche anderen Datenspeicher- oder -verarbeitungsgeräte ein. Im Prinzip ist ein Objekt ein Datenkontainer oder eine Systemressource - Zugriff auf ein <em>Objekt</em> bedeutet, auf Daten zuzugreifen.</p></li><li><p><em>Richtlinie</em>: Eine Sammlung von Regeln, die definiert, wie Zielvorgaben umgesetzt werden, nennt man Richtlinie. Eine <em>Richtlinie</em> dokumentiert normalerweise, wie mit bestimmten Elementen umgegangen wird. Dieses Kapitel faßt den Begriff in diesem Kontext als <em>Sicherheitsrichtlinie</em> auf; als eine Sammlung von Regeln, die den Fluß von Daten und Informationen kontrolliert und die gleichzeitig definiert, wer auf diese Daten und Informationen zugreifen darf.</p></li><li><p><em>Anfälligkeit</em>: Dieser Begriff wird normalerweise verwendet, wenn man über MLS (Multi Level Security) spricht. Das Anfälligkeits-Level beschreibt, wie wichtig oder geheim die Daten sein sollen. Um so höher das Anfälligkeits-Level, um so wichtiger die Geheimhaltung bzw. Vertraulichkeit der Daten.</p></li><li><p><em>Einzel-Label</em>: Von einem Einzel-Label spricht man, wenn für ein ganzes Dateisystem lediglich ein einziges Label verwendet wird, um Zugriffskontrolle über den gesamten Datenfluss zu erzwingen. Sobald diese Option verwendet wird - und das ist zu jeder Zeit, wenn die Option <code>multilabel</code> nicht explizit gesetzt wurde - sind alle Dateien und Verzeichnisse mit dem gleichen Label gekennzeichnet.</p></li><li><p><em>Subjekt</em>: Ein Subjekt ist jedwede Einheit, die Information in Fluss zwischen Objekten bringt: Zum Beispiel ein Nutzer, ein Nutzerprozessor, ein Systemprozeß usw. In FreeBSD handelt es sich meistens um einen Thread, der als Prozeß im Namen eines Nutzers arbeitet.</p></li></ul></div></div><div class=sect2><h3 id=mac-initial>33.3. Erläuterung<a class=anchor href=#mac-initial></a></h3><div class=paragraph><p>Mit all diesen neuen Begriffen im Kopf können wir nun überlegen, wie die Möglichkeiten der verbindlichen Zugriffskontrolle (MAC) die Sicherheit eines Betriebssystems als Ganzes erweitern. Die verschiedenen Module, die durch die MAC bereitgestellt werden, können verwendet werden, um das Netzwerk oder Dateisysteme zu schützen, Nutzern den Zugang zu bestimmten Ports oder Sockets zu verbieten und vieles mehr. Die vielleicht beste Weise, die Module zu verwenden, ist, sie miteinander zu kombinieren, indem mehrere Sicherheitsrichtlinienmodule gleichzeitig eine mehrschichtige Sicherheitsumgebung schaffen. Das ist etwas anderes als singuläre Richtlinien wie zum Beispiel die Firewall, die typischerweise Elemente eines Systems stabilisiert, das nur für einen speziellen Zweck verwendet wird. Der Verwaltungsmehraufwand ist jedoch von Nachteil, zum Beispiel durch die Verwendung von mehreren Labels oder dem eigenhändigen Erlauben von Netzwerkzugriffen für jeden einzelnen Nutzer.</p></div><div class=paragraph><p>Solche Nachteile sind allerdings gering im Vergleich zum bleibenden Effekt der erstellten Struktur. Die Möglichkeit zum Beispiel, für konkrete Anwendungen genau die passenden Richtlinien auszuwählen und einzurichten, senkt gleichzeitig die Arbeitskosten. Wenn man unnötige Richtlinien aussortiert, kann man die Gesamtleistung des Systems genauso steigern wie auch eine höhere Anpassungsfähigkeit gewährleisten. Eine gute Umsetzung der MAC beinhaltet eine Prüfung der gesamten Sicherheitsanforderungen und einen wirksamen Einsatz der verschiedenen Module.</p></div><div class=paragraph><p>Ein System, auf dem eine MAC verwendet wird, muß zumindest garantieren, dass einem Nutzer nicht gestattet wird, Sicherheitsmerkmale nach eigenem Ermessen zu verändern; dass Arbeitswerkzeuge, Programme und Skripte, innerhalb der Beschränkungen arbeiten können, welche die Zugriffsregeln der ausgewählten Module dem System auferlegen; und dass die volle Kontrolle über die Regeln der MAC beim Administrator ist und bleibt.</p></div><div class=paragraph><p>Es ist die einsame Pflicht des zuständigen Administrators, die richtigen Module sorgfältig auszuwählen. Einige Umgebungen könnten eine Beschränkung der Zugriffe über die Netzwerkschnittstellen benötigen - hier wären die Module <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> und sogar <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> ein guter Anfang. In anderen Fällen muß man sehr strenge Vertraulichkeit von Dateisystemobjekten gewährleisten - dafür könnte man <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> einsetzen.</p></div><div class=paragraph><p>Die Entscheidung, welche Richtlinien angewandt werden, kann auch anhand der Netzwerk-Konfiguration getroffen werden. Nur bestimmten Benutzern soll erlaubt werden, via <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> auf das Netzwerk oder Internet zuzugreifen - <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> wäre eine gute Wahl. Aber für was entscheidet man sich im Falle eines Dateisystems? Soll der Zugriff auf bestimmte Verzeichnisse von spezifischen Nutzern oder Nutzergruppen separiert werden? Oder wollen wir den Zugriff durch Nutzer oder Programme auf spezielle Dateien einschränken, indem wir gewisse Objekte als geheim einstufen?</p></div><div class=paragraph><p>Der Zugriff auf Objekte kann einigen vertraulichen Nutzern gestattet werden, anderen wiederum verwehrt. Als Beispiel sei hierzu ein großes Entwicklerteam angeführt, das in kleine Gruppen von Mitarbeitern aufgeteilt wurde. Die Entwickler von Projekt A dürfen nicht auf Objekte zugreifen, die von den Entwicklern von Projekt B geschrieben wurden. Sie müssen aber trotzdem auf Objekte zugreifen können, die von einem dritten Entwicklerteam geschaffen wurden - alles in allem eine verzwickte Situation. Wenn man die verschiedenen Module der MAC richtig verwendet, können Anwender in solche Gruppen getrennt und ihnen der Zugriff zu den gewünschten Systemobjekten gestattet werden - ohne Angst haben zu müssen, dass Informationen in die falschen Hände geraten.</p></div><div class=paragraph><p>So hat jedes Modul, das eine Sicherheitsrichtlinie verfügbar macht, einen eigenen Weg, die Sicherheit des Systems zu verstärken. Die Auswahl der Module sollte auf einem gut durchdachten Sicherheitskonzept gründen. In vielen Fällen muß das gesamte Konzept eines Systems überarbeitet und neu eingepflegt werden. Ein guter Überblick über die Möglichkeiten der verschiedenen von der MAC angebotenen Module hilft einem Administrator, die besten Richtlinien für seine spezielle Situation auszuwählen.</p></div><div class=paragraph><p>Im FreeBSD-Standardkernel ist die Option zur Verwendung der MAC nicht enthalten. Daher muß die Zeile</p></div><div class="literalblock programlisting"><div class=content><pre>options      MAC</pre></div></div><div class=paragraph><p>der Kernelkonfiguration hinzugefügt und der Kernel neu übersetzt und installiert werden.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Verschiedenen Anleitungen für die MAC empfehlen, die einzelnen Module direkt in den Kernel einzuarbeiten. Dabei ist es jedoch möglich, das System aus dem Netzwerk auszusperren oder gar schlimmeres. Die Arbeit mit der MAC ist ähnlich der Arbeit mit einer Firewall - man muß, wenn man sich nicht selbst aus dem System aussperren will, genau aufpassen. Man sollte sich eine Möglichkeit zurechtlegen, wie man eine Implementation einer MAC rückgängig machen kann - genauso wie eine Ferninstallation über das Netzwerk nur mit äußerster Vorsicht vorgenommen werden sollte. Es wird daher empfohlen, die Module nicht in den Kernel einzubinden, sondern sie beim Systemstart via <span class=filename>/boot/loader.conf</span> zu laden.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mac-understandlabel>33.4. MAC Labels verstehen<a class=anchor href=#mac-understandlabel></a></h3><div class=paragraph><p>MAC Label sind Sicherheitsmerkmale, die, wenn sie zum Einsatz kommen, allen Subjekten und Objekten im System zugeordnet werden.</p></div><div class=paragraph><p>Wenn ein Administrator ein solches Merkmal bzw. Attribut setzen will, muß er/sie verstehen können, was da genau passiert. Die Attribute, die im speziellen Fall zu vergeben sind, hängen vom geladenen Modul und den darin jeweils implementierten Richtlinien ab. Jedes dieser Richtlinienmodule setzt die Arbeit mit seinen entsprechenden Attributen in individueller Weise um. Falls der Nutzer nicht versteht, was er da konfiguriert, oder auch, was seine Konfiguration für Begleiterscheinungen mit sich bringt, ergibt sich meist als Resultat ein unerwartetes, ja sogar unerwünschtes Verhalten des gesamten Systems.</p></div><div class=paragraph><p>Ein Label, einem Objekt verliehen, wird verwendet, um anhand einer Richtlinie eine sicherheitsrelevante Entscheidung über Zugriffsrechte zu fällen. In einigen Richtlinien enthält bereits das Label selbst alle dafür nötigen Informationen. Andere Richtlinien verwenden diese Informationen, um zunächst ein komplexes Regelwerk abzuarbeiten.</p></div><div class=paragraph><p>Wenn man zum Beispiel einer Datei das Attribut <code>biba/low</code> zuordnet, wird dieses durch das Biba Sicherheitsrichtlinienmodul, und zwar mit dem Wert "low", verarbeitet.</p></div><div class=paragraph><p>Einige der Richtlinienmodule, die die Möglichkeit zum Vergeben von Labels unter FreeBSD unterstützen, bieten drei vordefinierte Labels an. Dieses nennen sich "high", "low" und "equal". Obwohl die verschiedenen Module die Zugriffskontrolle auf verschiedene Weisen regeln, kann man sich sicher sein, das das "low"-Label der untersten, unsichersten Einstellung entspricht, das "equal"-Label die Verwendung des Moduls für das jeweilige Objekt oder Subjekt deaktiviert - und das "high"-Label die höchstmögliche Einstellung erzwingt. Im Speziellen gilt diese Aussage für die Richtlinien(-module) MLS und Biba.</p></div><div class=paragraph><p>In den meisten Umgebungen, sogenannten Single Label Environments, wird Objekten nur ein einzelnes Label zugewiesen. Dadurch wird nur ein Regelsatz für die Zugriffskontrolle auf das gesamte System verwendet - und das ist meistens auch tatsächlich ausreichend. Es gibt wenige Fälle, in denen mehrere Labels auf Dateisystemobjekte oder -subjekte verwendet werden. In einem solchen Fall muß das Dateisystem mit der <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>-Option <code>multilabel</code> angepaßt werden, da <code>single label</code> die Standardeinstellung ist.</p></div><div class=paragraph><p>Bei der Verwendung von Biba oder MLS kann man numerische Labels vergeben, die genau das Level angeben, an welcher Stelle in der Hierarchie das Subjekt oder Objekt einzuordnen ist. Dieses numerische Level wird verwendet, um Informationen in verschiedene Gruppen aufzuteilen oder zu sortieren - damit zum Beispiel nur Subjekte, die zu einer gewissen Vertraulichkeitsstufe gehören, Zugang zu einer Gruppe von Objekten erhalten.</p></div><div class=paragraph><p>In den meisten Fällen wird ein Administrator nur ein einzelnes Label für das gesamte Dateisystem verwenden.</p></div><div class=paragraph><p><em>Moment mal, dass ist doch dasselbe wie DAC! Ich dachte, MAC würde die Kontrolle strengstens an den Administrator binden!</em> Diese Aussage hält immer noch stand - <code>root</code> ist derjenige, der die Kontrolle ausübt und die Richtlinie konfiguriert, so dass Nutzer in die entsprechenden, angemessenen Kategorien / Zugriffsklassen eingeordnet werden. Nunja, einige Module schränken <code>root</code> selbst ein. Die Kontrolle über Objekte wird dann einer Gruppe zugewiesen, jedoch hat <code>root</code> die Möglichkeit, die Einstellungen jederzeit zu widerrufen oder zu ändern. Dies ist das Hierarchie/Freigabe-Modell, das durch Richtlinien wie MLS oder Biba bereitgestellt wird.</p></div><div class=sect3><h4 id=_konfigurieren_der_labels>33.4.1. Konfigurieren der Labels<a class=anchor href=#_konfigurieren_der_labels></a></h4><div class=paragraph><p>Gewissermaßen alle Aspekte der Labelkonfiguration werden durch Werkzeuge das Basissystems umgesetzt. Die entsprechenden Kommandos bieten eine einfache Schnittstelle zum Konfigurieren, Manipulieren und auch Verifizieren der gekennzeichneten Objekte.</p></div><div class=paragraph><p>Mit den beiden Kommandos <a href="https://man.freebsd.org/cgi/man.cgi?query=setfmac&amp;sektion=8&amp;format=html">setfmac(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a> kann man eigentlich schon alles machen. Das Kommando <code>setfmac</code> wird verwendet, um ein MAC-Label auf einem Systemobjekt zu setzen, <code>setpmac</code> hingegen zum Setzen von Labels auf Systemsubjekte. Als Beispiel soll hier dienen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/high test</span></code></pre></div></div><div class=paragraph><p>Wenn bei der Ausführung dieses Kommandos keine Fehler aufgetreten sind, gelangt man zur Eingabeaufforderung zurück. Nur wenn ein Fehler auftritt, verhalten sich diese Kommandos nicht still, ganz wie auch die Kommandos <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a>. In einigen Fällen wird dieser Fehler <code>Permission denied</code> lauten und gewöhnlich dann auftreten, wenn ein Label an einem Objekt angebracht oder verändert werden soll, das bereits (Zugriffs-)Beschränkungen unterliegt. Der Systemadministrator kann so eine Situation mit Hilfe der folgenden Kommandos überwinden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/high test</span>
Permission denied
<span class=c># setpmac biba/low setfmac biba/high test</span>
<span class=c># getfmac test</span>
<span class=nb>test</span>: biba/high</code></pre></div></div><div class=paragraph><p>Wie wir hier sehen, kann <code>setpmac</code> verwendet werden, um die vorhandene Einstellungen zu umgehen, indem dem gestarteten Prozeß ein anderes, valides Label zugeordnet wird. Das Werkzeug <code>getpmac</code> wird normalerweise auf gerade laufende Prozesse angewendet. Ähnlich sendmail: Als Argument wird statt eines Kommandos eine eine Prozeß-ID übergeben, es verbirgt sich doch dieselbe Logik dahinter. Wenn ein Nutzer versucht, eine Datei zu verändern, auf die er keinen Zugriff hat, entsprechend der Regeln eines geladenen Richtlinienmoduls, wird der Fehler <code>Operation not permitted</code> durch die Funktion <code>mac_set_link</code> angezeigt.</p></div><div class=sect4><h5 id=_übliche_typen_von_labeln>33.4.1.1. Übliche Typen von Labeln<a class=anchor href=#_übliche_typen_von_labeln></a></h5><div class=paragraph><p>Wenn man die Module <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a> verwendet, hat man die Möglichkeit, einfache Label zu vergeben. Diese nennen sich <code>high</code>, <code>low</code> und <code>equal</code>. Es folgt eine kurze Beschreibung, was diese Labels bedeuten:</p></div><div class=ulist><ul><li><p>Das Label <code>low</code> ist definitionsgemäß das niedrigeste Label, das einem Objekt oder Subjekt verliehen werden kann. Wird es gesetzt, kann die entsprechende Entität nicht mehr auf Entitäten zugreifen, die das Label <code>high</code> tragen.</p></li><li><p>Das Label <code>equal</code> wird Entitäten verliehen, die von der Richtlinie ausgenommen sein sollen.</p></li><li><p>Das Label <code>high</code> verleiht einer Entität die höchstmögliche Einstellung.</p></li></ul></div><div class=paragraph><p>Unter Beachtung jedes einzelnen Richtlinienmoduls moduliert und beschränkt jede dieser Einstellungen den Informationsfluß unterschiedlich. Genaue Erklärungen zu den Charakteristika der einfachen Labels in den verschiedenen Modulen finden sich im entsprechenden Unterabschnitt dieses Kapitels oder in den Manpages.</p></div><div class=sect5><h6 id=_fortgeschrittene_label_konfiguration>33.4.1.1.1. Fortgeschrittene Label-Konfiguration<a class=anchor href=#_fortgeschrittene_label_konfiguration></a></h6><div class=paragraph><p>Numerische klassifizierte Labels werden verwendet in der Form <code>Klasse:Verbund+Verbund</code>. Demnach ist das Label</p></div><div class="literalblock programlisting"><div class=content><pre>biba/10:2+3+6(5:2+3-15:2+3+4+5+6)</pre></div></div><div class=paragraph><p>folgendermaßen zu lesen:</p></div><div class=paragraph><p>"Biba Policy Label"/"effektive Klasse 10" :"Verbund 2,3 und 6": ("Low-Klasse 5:…​"- "High-Klasse 15:…​")</p></div><div class=paragraph><p>In diesem Beispiel ist die erstgenannte Klasse als "effektive Klasse" zu bezeichnen. Ihr werden die "effektiven Verbünde" zugeordnet. Die zweite Klasse ist die "Low"-Klasse und die letzte die "high"-Klasse. Die allermeisten Konfigurationen kommen ohne die Verwendungen von solchen Klassen aus, nichtsdestotrotz kann man sie für erweiterte Konfigurationen verwenden.</p></div><div class=paragraph><p>Sobald sie auf <em>Systemsubjekte</em> angewendet werden, haben diese eine gegenwärtige Klasse/Verbund- Konfiguration und diese muß im definierten Rahmen gegebenenfalls angepaßt (erhöht oder gesenkt) werden. Im Gegensatz dazu haben <em>Systemobjekte</em> alle eingestellten (effektive, High- und Low-Klasse) gleichzeitig. Dies ist notwendig, damit auf Sie von den <em>Systemsubjekten</em> in den verschiedenen Klassen gleichzeitig zugegriffen werden kann.</p></div><div class=paragraph><p>Die Klasse und und die Verbünde in einem Subjekt-Objekt-Paar werden zum Erstellen einer sogenannten Dominanz-Relation verwendet, in welcher entweder das Subjekt das Objekt, das Objekt das Subjekt, keines das andere dominiert oder sich beide gegenseitig dominieren. Der Fall, dass sich beide dominieren, tritt dann ein, wenn die beiden Labels gleich sind. Wegen der Natur des Informationsflusses in Biba kann man einem Nutzer Rechte für einen Reihe von Abteilungen zuordnen, die zum Beispiel mit entsprechenden Projekten korrespondieren. Genauso können aber auch Objekten mehrere Abteilungen zugeordnet sein. Die Nutzer müssen eventuell ihre gegenwärtigen Rechte mithilfe von <code>su</code> or <code>setpmac</code> anpassen um auf Objekte in einer Abteilung zuzugreifen, zu der sie laut ihrer effektiven Klasse nicht berechtigt sind.</p></div></div></div><div class=sect4><h5 id=_nutzer_und_label_einstellungen>33.4.1.2. Nutzer- und Label-Einstellungen<a class=anchor href=#_nutzer_und_label_einstellungen></a></h5><div class=paragraph><p>Nutzer selbst brauchen Labels damit ihre Dateien und Prozesse korrekt mit der Sicherheitsrichtlinie zusammenarbeitet, die für das System definiert wurde. Diese werden in der Datei <span class=filename>login.conf</span> durch die Verwendung von Login- Klassen zugeordnet. Jedes Richtlinienmodul, das Label verwendet, arbeitet mit diesen Login-Klassen.</p></div><div class=paragraph><p>Beispielhaft wird der folgende Eintrag, der für jede Richtlinie eine Einstellung enthält, gezeigt:</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
:copyright=/etc/COPYRIGHT:\
:welcome=/etc/motd:\
:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
:manpath=/usr/shared/man /usr/local/man:\
:nologin=/usr/sbin/nologin:\
:cputime=1h30m:\
:datasize=8M:\
:vmemoryuse=100M:\
:stacksize=2M:\
:memorylocked=4M:\
:memoryuse=8M:\
:filesize=8M:\
:coredumpsize=8M:\
:openfiles=24:\
:maxproc=32:\
:priority=0:\
:requirehome:\
:passwordtime=91d:\
:umask=022:\
:ignoretime@:\
:label=partition/13,mls/5,biba/10(5-15),lomac/10[2]:</pre></div></div><div class=paragraph><p>Die Label-Option in der letzten Zeile legt fest, welches Standard-Label für einen Nutzer erzwungen wird. Nutzern darf niemals gestattet werden, diese Werte selbst zu verändern, demnach haben Nutzer in dieser Beziehung auch keine Wahlfreiheit. In einer richtigen Konfiguration jedoch wird kein Administrator alle Richtlinienmodule aktivieren wollen. Es wird an dieser Stelle ausdrücklich empfohlen, dieses Kapitel zu Ende zu lesen, bevor irgendein Teil dieser Konfiguration ausprobiert wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nutzer können ihr eigenes Label nach dem Loginvorgang durchaus ändern. Jedoch kann diese Änderung nur unter den Auflagen der gerade gültigen Richtlinie geschehen. Im Beispiel oben wird für die Biba-Richtlinie eine minimale Prozeßintegrität von 5, eine maximale von 15 angegeben, aber die Voreinstellung des tatsächlichen Labels ist 10. Der Nutzerprozeß läuft also mit einer Integrität von 10 bis das Label verändert wird, zum Beispiel durch eine Anwendung des Kommandos <code>setpmac</code>, welches jedoch auf den Bereich eingeschränkt wird, der zum Zeitpunkt des Logins angegeben wurde, in diesem Fall von 5 bis 15.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nach einer Änderung der Datei <span class=filename>login.conf</span> muß in jedem Fall die Befähigungsdatenbank mit dem Kommando <code>cap_mkdb</code> neu erstellt werden - und das gilt für alle im weiteren Verlauf gezeigten Beispiele und Diskussionspunkte.</p></div><div class=paragraph><p>Es ist nützlich anzumerken, dass viele Einsatzorte eine große Anzahl von Nutzern haben, die wiederum viele verschiedenen Nutzerklassen angehören sollen. Hier ist eine Menge Planungsarbeit notwendig, da die Verwaltung sehr unübersichtlich und schwierig ist.</p></div></div><div class=sect4><h5 id=_netzwerkschnittstellen_und_die_zugehörigen_label>33.4.1.3. Netzwerkschnittstellen und die zugehörigen Label<a class=anchor href=#_netzwerkschnittstellen_und_die_zugehörigen_label></a></h5><div class=paragraph><p>Labels können auch, wenn man sie an Netzwerkschittstellen vergibt, helfen, den Datenfluß durch das Netzwerk zu kontrollieren. Das funktioniert in allen Fällen genau so wie mit Objekten. Nutzer, die in der Biba-Richtlinie das Label <code>high</code> tragen, dürfen nicht auf Schnittstellen zugreifen, die <code>low</code> markiert sind usw.</p></div><div class=paragraph><p>Die Option <code>maclabel</code> wird via <code>ifconfig</code> übergeben. Zum Beispiel</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bge0 maclabel biba/equal</span></code></pre></div></div><div class=paragraph><p>belegt die Schnittstelle mit dem MAC Label <code>biba/equal</code>. Wenn eine komplexe Einstellung wie <code>biba/high(low-high)</code> verwendet wird, muß das gesamte Label in Anführungszeichen geschrieben werden, da sonst eine Fehlermeldung zurückgegeben wird.</p></div><div class=paragraph><p>Jedes Richtlinienmodul, das die Vergabe von Labels unterstützt, stellt einen Parameter bereit, mit dem das MAC Label für Netzwerkschnittstellen deaktiviert werden kann. Das Label der Netzwerkschnittstelle auf <code>equal</code> zu setzen, führt zum selben Ergebnis. Beachten Sie die Ausgabe von <code>sysctl</code>, die Manpages der verschiedenen Richtlinien oder eben die Informationen, die im weiteren Verlauf dieses Kapitels angeboten werden, um mehr zu diesen Parametern zu erfahren.</p></div></div></div><div class=sect3><h4 id=_single_oder_multilabel>33.4.2. Single- oder Multilabel?<a class=anchor href=#_single_oder_multilabel></a></h4><div class=paragraph><p>Als Standardeinstellung verwendet das System die Option <code>single label</code>. Was bedeutet das für den Administrator? Es gibt einige Unterschiede zwischen <code>single label</code> und <code>multilabel</code>. In ihrer ureigenen Weise bieten beide Vor- und Nachteile bezogen auf die Flexibilität bei der Modellierung der Systemsicherheit.</p></div><div class=paragraph><p>Die Option <code>single label</code> gibt jedem Subjekt oder Objekt genau ein einziges Label, zum Beispiel <code>biba/high</code>. Mit dieser Option hat man einen geringeren Verwaltungsaufwand, aber die Flexibilität beim Einsatzes von Richtlinien ist ebenso gering. Viele Administratoren wählen daher auch die Option <code>multilabel</code> im Sicherheitsmodell, wenn die Umstände es erfordern.</p></div><div class=paragraph><p>Die Option <code>multilabel</code> gestattet, jedem einzelnen Subjekt oder Objekt seine eigenen unabhängigen Label zu zuzuordnen. Die Optionen <code>multilabel</code> und <code>singlelabel</code> betreffen jedoch nur die Richtlinien, die Labels als Leistungsmerkmal verwenden, einschließlich der Richtlinien Biba, Lomac, MLS und SEBSD.</p></div><div class=paragraph><p>Wenn Richtlinien benutzt werden sollen, die ohne Labels auskommen, wird die Option <code>multilabel</code> nicht benötigt. Dies betrifft die Richtlinien <code>seeotheruids</code>, <code>portacl</code> und <code>partition</code>.</p></div><div class=paragraph><p>Man sollte sich dessen bewußt sein, dass die Verwendung der Option <code>multilabel</code> auf einer Partition und die Erstellung eines Sicherheitsmodells auf der Basis der FreeBSD <code>multilevel</code> Funktionalität einen hohen Verwaltungsaufwand bedeutet, da alles im Dateisystem ein Label bekommt. Jedes Verzeichnis, jede Datei und genauso jede Schnittstelle.</p></div><div class=paragraph><p>Das folgende Kommando aktiviert <code>multilabel</code> für ein Dateisystem. Dies funktioniert nur im Einzelbenutzermodus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -l enable /</span></code></pre></div></div><div class=paragraph><p>In einer Swap-Partition wird dies nicht benötigt.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls Sie Probleme beim Setzen der Option <code>multilabel</code> auf der Root-Partition bemerken, lesen Sie bitte <a href=#mac-troubleshoot>Fehler im MAC beheben</a> dieses Kapitels.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=mac-planning>33.5. Planung eines Sicherheitsmodells<a class=anchor href=#mac-planning></a></h3><div class=paragraph><p>Wann immer eine neue Technologie eingepflegt werden soll, ist es wichtig, vorher einen Plan zu erstellen. In den verschiedenen Etappen der Planung sollte der Administrator nie das "Große Ganze" aus den Augen verlieren und mindestens die folgenden Punkte beachten:</p></div><div class=ulist><ul><li><p>Die Anforderungen</p></li><li><p>Die Ziele</p></li></ul></div><div class=paragraph><p>Wenn Sie MAC verwenden möchten, sind das im Besonderen folgende Punkte:</p></div><div class=ulist><ul><li><p>Wie werden Informationen und Ressourcen auf den Zielsystemen klassifiziert?</p></li><li><p>Welche Arten von Informationen bzw. Ressourcen sollen im Zugang beschränkt sein und welche Art Einschränkung soll verwendet werden?</p></li><li><p>Welche(s) MAC Modul(e) wählt man, um sein Ziel zu erreichen?</p></li></ul></div><div class=paragraph><p>Es ist immer möglich, die Einstellungen des Systems und der Systemressourcen im Nachhinein zu "optimieren". Es ist aber wirklich lästig, das gesamte Dateisystem zu durchsuchen, um Dateien oder Benutzerkonten zu reparieren. Eine gute Planung hilft dem Administrator, sich einer sorgenfreien und effizienten Umsetzung eines Sicherheitsmodells zu versichern. Testlauf des Sicherheitsmodells <em>vor</em> dem Einsatz in seiner richtigen Arbeitsumgebung ist auf jeden Fall empfehlenswert. Die Idee, ein System mit einer MAC einfach loslaufen zu lassen, ist wie direkt auf einen Fehlschlag hinzuarbeiten.</p></div><div class=paragraph><p>Jede Umgebung hat ihre eigenen Anforderungen. Ein tiefgreifendes und vollständiges Sicherheitsprofil zu erstellen spart weitere Änderungen, nachdem das System in Betrieb genommen wurde. Also werden die folgenden Abschnitte die verschiedenen Module vorstellen, die den Administratoren zur Verfügung gestellt werden, die Nutzung und Konfiguration der einzelnen Module beschreiben; und in einigen Fällen Einblicke gewähren, für welche Situationen welche Module besonders geeignet sind. Zum Beispiel ein Webserver kann von der Verwendung der <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> oder der <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> Richtlinie profitieren. In anderen Fällen, an einem Rechner mit nur wenigen lokalen Benutzern, ist die <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_partition&amp;sektion=4&amp;format=html">mac_partition(4)</a> die Richtlinie der Wahl.</p></div></div><div class=sect2><h3 id=mac-modules>33.6. Modulkonfiguration<a class=anchor href=#mac-modules></a></h3><div class=paragraph><p>Jedes Modul, das in der MAC enthalten ist, kann entweder direkt in den Kernel eingefügt werden oder als Kernelmodul in der Laufzeit des Systems geladen werden. Empfohlen wird, den Modulnamen in der Datei <span class=filename>/boot/loader.conf</span> anzufügen, so dass das Modul am Anfang des Bootvorgangs eingebunden wird.</p></div><div class=paragraph><p>Die folgenden Abschnitte werden verschiedene MAC Module und ihre jeweiligen Vor- und Nachteile vorstellen. Außerdem wird erklärt, wie sie in bestimmte Umgebungen eingearbeitet werden können. Einige Module unterstützen die Verwendung von <code>Labels</code>, das heißt Zugriffskontrolle durch hinzufügen einer Kennzeichnung in der Art von "dieses ist erlaubt, jenes aber nicht". Eine Label-Konfigurationdatei kontrolliert unter anderem, wie auf Dateien zugegriffen oder wie über das Netzwerk kommuniziert werden darf. Im vorangehenden Abschnitt wurde bereits erläutert, wie die Option <code>multilabel</code> auf Dateisysteme angewendet wird, um eine Zugriffskontrolle auf einzelne Dateien oder ganze Dateisysteme zu konfigurieren.</p></div><div class=paragraph><p>Eine <code>single label</code> Konfiguration erzwingt ein einzelnes Label für das gesamte System. Daher wird die <code>tunefs</code>-Option <code>multilabel</code> genannt.</p></div></div><div class=sect2><h3 id=mac-seeotheruids>33.7. Das MAC Modul seeotheruids<a class=anchor href=#mac-seeotheruids></a></h3><div class=paragraph><p>Modulename: <span class=filename>mac_seeotheruids.ko</span></p></div><div class=paragraph><p>Parameter in der Kernelkonfiguration: <code>options MAC_SEEOTHERUIDS</code></p></div><div class=paragraph><p>Bootparameter: <code>mac_seeotheruids_load="YES"</code></p></div><div class=paragraph><p>Das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> erweitert die <code>sysctl</code>-Variablen <code>security.bsd.see_other_uids</code> und <code>security.bsd.see_other_gids</code>. Diese Optionen benötigen keine im Vorhinein zu setzenden Labels und können leicht durchschaubar mit den anderen MAC-Modulen zusammenarbeiten.</p></div><div class=paragraph><p>Nachdem das Modul geladen wurde, können die folgenden <code>sysctl</code> Variablen verwendet werden.</p></div><div class=ulist><ul><li><p><code>security.mac.seeotheruids.enabled</code> dient zur Aktivierung des Moduls, zunächst mit den Standardeinstellungen. Diese verhindern, dass Nutzer Prozesse und Sockets sehen können, die ihnen nicht selbst gehöen.</p></li><li><p><code>security.mac.seeotheruids.specificgid_enabled</code> kann eine spezifizierte Nutzergruppe von dieser Richtlinie ausnehmen. Die entsprechende Gruppe muß an den Parameter <code>security.mac.seeotheruids.specificgid=XXX</code> übergeben werden, wobei <em>XXX</em> die ID der Gruppe ist, die von der Richtlinie ausgenommen werden soll.</p></li><li><p><code>security.mac.seeotheruids.primarygroup_enabled</code> kann verwendet werden, um eine spezifische, <em>primäre</em> Nutzergruppe von der Richtlinie auszuschliessen. Dieser Parameter und <code>security.mac.seeotheruids.specificgid_enabled</code> schließen einander aus.</p></li></ul></div></div><div class=sect2><h3 id=mac-bsdextended>33.8. Das MAC Modul bsdextended<a class=anchor href=#mac-bsdextended></a></h3><div class=paragraph><p>Modulname: <span class=filename>mac_bsdextended.ko</span></p></div><div class=paragraph><p>Parameter in der Kernelkonfiguration: <code>options MAC_BSDEXTENDED</code></p></div><div class=paragraph><p>Bootparameter: <code>mac_bsdextended_load="YES"</code></p></div><div class=paragraph><p>Das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> erstellt eine Firewall für das Dateisystem und ist eine Erweiterung des sonst üblichen Rechtemodells. Es erlaubt einem Administrator einen Regelsatz zum Schutz von Dateien, Werkzeugen und Verzeichnissen in der Dateisystemhierarchie zu erstellen, der einer Firewall ähnelt. Sobald auf ein Objekt im Dateisystem zugegriffen werden soll, wird eine Liste von Regel abgearbeitet, bis eine passende Regel gefunden wird oder die Liste zu Ende ist. Das Verhalten kann durch die Änderung des <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> Parameters <code>security.mac.bsdextended.firstmatch_enabled</code> eingestellt werden. Ähnlich wie bei den anderen Firewallmodulen in FreeBSD wird eine Datei erstellt, welche die Zugriffsregeln enthält. Diese wird beim Systemstart durch eine Variable in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> eingebunden.</p></div><div class=paragraph><p>Der Regelsatz kann mit dem Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=ugidfw&amp;sektion=8&amp;format=html">ugidfw(8)</a> eingepflegt werden, welches eine Syntax bereitstellt, die der von <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> gleicht. Weitere Werkzeuge können auch selbst erstellt werden, indem die Funktionen der Bibliothek <a href="https://man.freebsd.org/cgi/man.cgi?query=libugidfw&amp;sektion=3&amp;format=html">libugidfw(3)</a> verwendet werden.</p></div><div class=paragraph><p>Bei der Arbeit mit diesem Modul ist äußerste Vorsicht geboten - falscher Gebrauch kann den Zugriff auf Teile des Dateisystems komplett unterbinden.</p></div><div class=sect3><h4 id=_beispiele>33.8.1. Beispiele<a class=anchor href=#_beispiele></a></h4><div class=paragraph><p>Nachdem das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> erfolgreich geladen wurde, zeigt das folgende Kommando die gegenwärtig aktiven Regeln an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw list 0 slots, 0 rules</span></code></pre></div></div><div class=paragraph><p>Wie erwartet, sind keine Regeln definiert. Das bedeutet, das auf alle Teile des Dateisystems zugegriffen werden kann. Um eine Regel zu definieren, die jeden Zugriff durch Nutzer blockiert und nur die Rechte von <code>root</code> unangetastet läßt, muß lediglich dieses Kommando ausgeführt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw add subject not uid root new object not uid root mode n</span></code></pre></div></div><div class=paragraph><p>Das ist allerdings keine gute Idee, da nun allen Nutzern der Zugriff auf selbst die einfachsten Programme wie <code>ls</code> untersagt wird. Angemessener wäre etwas wie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw set 2 subject uid user1 object uid user2 mode n</span>
<span class=c># ugidfw set 3 subject uid user1 object gid user2 mode n</span></code></pre></div></div><div class=paragraph><p>Diese Befehle bewirken, dass <code>user1</code> keinen Zugriff mehr auf Dateien und Programme hat, die <code><em>user2</em></code> gehören. Dies schließt das Auslesen von Verzeichniseinträgen ein.</p></div><div class=paragraph><p>Anstelle <code>uid user1</code> könnte auch <code>not uid <em>user2</em></code> als Parameter übergeben werden. Dies würde diesselben Einschränkungen für alle Nutzer bewirken anstatt nur einen einzigen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>root</code> ist von diesen Einstellungen nicht betroffen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dies sollte als Überblick ausreichen, um zu verstehen, wie das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> helfen kann, das Dateisystem abzuschotten. Weitere Informationen bieten die Manpages <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=ugidfw&amp;sektion=8&amp;format=html">ugidfw(8)</a>.</p></div></div></div><div class=sect2><h3 id=mac-ifoff>33.9. Das MAC Modul ifoff<a class=anchor href=#mac-ifoff></a></h3><div class=paragraph><p>Modulname: <span class=filename>mac_ifoff.ko</span></p></div><div class=paragraph><p>Parameter für die Kernelkonfiguration: <code>options MAC_IFOFF</code></p></div><div class=paragraph><p>Bootparameter: <code>mac_ifoff_load="YES"</code></p></div><div class=paragraph><p>Das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> ist einzig dazu da, Netzwerkschnittstellen im laufenden Betrieb zu deaktivieren oder zu verhindern, das Netzwerkschnittstellen während der Bootphase gestartet werden. Dieses Modul benötigt für seinen Betrieb weder Labels, die auf dem System eingerichtet werden müssen, noch hat es Abhängigkeiten zu anderen MAC Modulen.</p></div><div class=paragraph><p>Der größte Teil der Kontrolle geschieht über die im folgenden aufgelisteten <code>sysctl</code>-Parameter:</p></div><div class=ulist><ul><li><p><code>security.mac.ifoff.lo_enabled</code> schaltet den gesamten Netzwerkverkehr auf der Loopback-Schnittstelle <a href="https://man.freebsd.org/cgi/man.cgi?query=lo&amp;sektion=4&amp;format=html">lo(4)</a> an bzw. aus.</p></li><li><p><code>security.mac.ifoff.bpfrecv_enabled</code> macht das Gleiche für den Berkeley Paket Filter <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>.</p></li><li><p><code>security.mac.ifoff.other_enabled</code> schaltet den Verkehr für alle anderen Netzwerkschnittstellen.</p></li></ul></div><div class=paragraph><p>Die wahrscheinlich häufigste Nutzung von <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> ist die Überwachung des Netzwerks in einer Umgebung, in der kein Netzwerkverkehr während des Bootvorgangs erlaubt werden soll. Eine andere mögliche Anwendung wäre ein Script, das mit Hilfe von <a class=package href=https://cgit.freebsd.org/ports/tree/security/aide/>security/aide</a> automatisch alle Schnittstellen blockiert, sobald Dateien in geschützten Verzeichnissen angelegt oder verändert werden.</p></div></div><div class=sect2><h3 id=mac-portacl>33.10. Das MAC Modul portacl<a class=anchor href=#mac-portacl></a></h3><div class=paragraph><p>Modulname: <span class=filename>mac_portacl.ko</span></p></div><div class=paragraph><p>Parameter für die Kernelkonfiguration: <code>options MAC_PORTACL</code></p></div><div class=paragraph><p>Bootparameter: <code>mac_portacl_load="YES"</code></p></div><div class=paragraph><p>Mit Hilfe des Moduls <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> können die Anbindungen an die lokalen TCP und UDP Ports durch eine Vielzahl von <code>sysctl</code> Variablen beschränkt werden. Genauer gesagt ermöglicht <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> Nutzern ohne <code>root</code>-Rechten den Zugriff auf zu bestimmende privilegierte Ports, also denen innerhalb der ersten 1024.</p></div><div class=paragraph><p>Sobald das Modul geladen wurde, ist die Richtlinie für alle Sockets verfügbar. Die folgenden Variablen können für die Konfiguration verwendet werden:</p></div><div class=ulist><ul><li><p><code>security.mac.portacl.enabled</code> schaltet die Anwendung der Richtlinie ein oder aus.</p></li><li><p><code>security.mac.portacl.port_high</code> gibt den höchsten Port an, der von der Richtlinie <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> betroffen sein soll.</p></li><li><p><code>security.mac.portacl.suser_exempt</code> nimmt, wenn es einen Wert ungleich Null zugewiesen bekommt, <code>root</code> von der Richtlinie aus.</p></li><li><p><code>security.mac.portacl.rules</code> enthält als Wert die eigentliche <code>mac_portacl</code> Richtlinie.</p></li></ul></div><div class=paragraph><p>Die eigentliche Konfiguration der <code>mac_portacl</code> Richtlinie wird der <code>sysctl</code>-Variablen <code>security.mac.portacl.rules</code> als Zeichenkette der Form <code>rule[,rule,…​]</code> übergeben. Jede einzelne Regel hat die Form <code>idtype:id:protocol:port</code>. Der Parameter <span class=parameter>idtype</span> ist entweder <code>uid</code> oder <code>gid</code> und wird verwendet, um den Parameter <span class=parameter>id</span> als Nutzer-ID oder Gruppen-ID zu kennzeichnen. Der Parameter <span class=parameter>protocol</span> gibt an, ob die Regel ür TCP oder UDP gelten soll (indem man den Wert auf <code>tcp</code> oder <code>udp</code> setzt). Und der letzte Parameter, <span class=parameter>port</span>, enthält die Nummer des Ports, auf den der angegebene Nutzer bzw. die angegebene Gruppe Zugriff erhalten soll.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Da der Regelsatz direkt vom Kernel ausgewertet wird, können nur Zahlenwerte übergeben werden. Das heißt, Namen von Nutzern, Gruppen oder Dienstnamen aus der Datei <span class=filename>/etc/services</span> funktionieren nicht.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Auf UNIX®-artigen Betriebssystemen sind die Ports kleiner 1024 privilegierten Prozessen vorbehalten, müssen also mit als/von <code>root</code> gestartet werden und weiterhin laufen. Damit <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> die Vergabe von Ports kleiner als 1024 an nicht privilegierte Prozesse übernehmen kann, muß die UNIX® Standardeinstellung deaktiviert werden. Dazu ändert man die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> Variablen <code>net.inet.ip.portrange.reservedlow</code> und <code>net.inet.ip.portrange.reservedhigh</code> auf den Wert "0".</p></div><div class=paragraph><p>Weiterführende Informationen entnehmen Sie bitte den unten aufgeführten Beispielen oder der Man-Page <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a>!</p></div><div class=sect3><h4 id=_beispiele_2>33.10.1. Beispiele<a class=anchor href=#_beispiele_2></a></h4><div class=paragraph><p>Die folgenden Beispiele sollten ein wenig Licht in die obige Diskussion bringen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.port_high=1023</span>
<span class=c># sysctl net.inet.ip.portrange.reservedlow=0 net.inet.ip.portrange.reservedhigh=0</span></code></pre></div></div><div class=paragraph><p>Zunächst bestimmen wir, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> für alle privilegierten Ports gelten soll und deaktivieren die normale UNIX®-Beschränkung.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.suser_exempt=1</span></code></pre></div></div><div class=paragraph><p>Da <code>root</code> von dieser Richtlinie nicht beeinträchtigt werden soll, setzen wir hier <code>security.mac.portacl.suser_exempt</code> auf einen Wert ungleich Null. Das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> ist nun so eingerichtet, wie es UNIX®-artige Betriebssysteme normal ebenfalls tun.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.rules=uid:80:tcp:80</span></code></pre></div></div><div class=paragraph><p>Nun erlauben wir dem Nutzer mit der UID 80, normalerweise dem Nutzer <code>www</code>, den Port 80 zu verwenden. Dadurch kann der Nutzer <code>www</code> einen Webserver betreiben, ohne dafür mit <code>root</code>-Privilegien ausgestattet zu sein.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995</span></code></pre></div></div><div class=paragraph><p>Hier wird dem Nutzer mit der UID 1001 erlaubt, die TCP Ports 110 ("pop3") und 995 ("pop3s") zu verwenden. Dadurch kann dieser Nutzer einen Server starten, der Verbindungen an diesen beiden Ports annehmen kann.</p></div></div></div><div class=sect2><h3 id=mac-partition>33.11. Das MAC Modul partition<a class=anchor href=#mac-partition></a></h3><div class=paragraph><p>Modulname: <span class=filename>mac_partition.ko</span></p></div><div class=paragraph><p>Parameter für die Kernelkonfiguration: <code>options MAC_PARTITION</code></p></div><div class=paragraph><p>Bootparameter <code>mac_partition_load="YES"</code></p></div><div class=paragraph><p>Die Richtlinie <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_partition&amp;sektion=4&amp;format=html">mac_partition(4)</a> setzt Prozesse in spezielle "Partitionen", entsprechend dem zugewiesenen MAC Label. Man kann sich das vorstellen wie eine spezielle Art <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>, auch wenn das noch kein wirklich guter Vergleich ist.</p></div><div class=paragraph><p>Es wird empfohlen, dieses Modul durch einen Eintrag in <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> zu aktivieren, so dass die Richtlinie während des Bootvorganges eingebunden wird.</p></div><div class=paragraph><p>Der Großteil der Konfiguration geschieht mit dem Kommando <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a>, wie gleich erklärt wird. Außerdem gibt es folgenden <code>sysctl</code> Parameter für diese Richtlinie.</p></div><div class=ulist><ul><li><p><code>security.mac.partition.enabled</code> erzwingt die Verwendung von MAC Prozeß-Partitionen.</p></li></ul></div><div class=paragraph><p>Sobald diese Richtlinie aktiv ist, sehen Nutzer nur noch ihre eigenen Prozesse, und alle anderen Prozesse, die ebenfalls derselben Prozeß-Partition zugeordnet sind. Sie können jedoch nicht auf Prozesse oder Werkzeuge außerhalb des Anwendungsbereich dieser Partition zugreifen. Das bedeutet unter anderem, das ein Nutzer, der einer Klasse <code>insecure</code> zugeordnet ist, nicht auf das Kommando <code>top</code> zugreifen kann - wie auch auf viele anderen Befehle, die einen eigenen Prozeß erzeugen.</p></div><div class=paragraph><p>Um einen Befehl einer Prozeß-Partition zuzuordnen, muß dieser durch das Kommando <code>setpmac</code> mit einem Label versehen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setpmac partition/13 top</span></code></pre></div></div><div class=paragraph><p>Diese Zeile fügt das Kommando <code>top</code> dem Labelsatz für Nutzer der Klasse <code>insecure</code> hinzu, sofern die Partition 13 mit der Klasse <code>insecure</code> übereinstimmt. Beachten Sie, dass alle Prozesse, die von Nutzern dieser Klasse erzeugt werden, das Label <code>partition/13</code> erhalten, und dieses auch nicht durch den Nutzer geändert werden kann.</p></div><div class=sect3><h4 id=_beispiele_3>33.11.1. Beispiele<a class=anchor href=#_beispiele_3></a></h4><div class=paragraph><p>Der folgende Befehl listet die vergebenen Label für Prozeß-Partitionen und die laufenden Prozesse auf.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps Zax</span></code></pre></div></div><div class=paragraph><p>Das nächste Kommando liefert das Label der Prozeß-Partition eines anderen Nutzers <code>trhodes</code> und dessen gegenwärtig laufenden Prozesse zurück.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps -ZU trhodes</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Jeder Nutzer kann die Prozesse in der Prozeß-Partition von <code>root</code> betrachten, solange nicht die Richtlinie <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> geladen wurde.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Eine ausgefeilte Umsetzung dieser Richtlinie deaktiviert alle Dienste in <span class=filename>/etc/rc.conf</span> und startet diese dann später durch ein Skript, das jedem Dienst das passende Label zuordnet.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die folgenden Richtlinien verwenden Zahlenwerte anstatt der drei Standardlabels. Diese Optionen, und ihre Grenzen, werden in den zugehörigen Manpages genauer erklärt.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=mac-mls>33.12. Das MAC Modul Multi-Level Security<a class=anchor href=#mac-mls></a></h3><div class=paragraph><p>Modulname: <span class=filename>mac_mls.ko</span></p></div><div class=paragraph><p>Parameter für die Kernelkonfiguration: <code>options MAC_MLS</code></p></div><div class=paragraph><p>Bootparameter: <code>mac_mls_load="YES"</code></p></div><div class=paragraph><p>Die Richtlinie <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> kontrolliert die Zugriffe zwischen Subjekten und Objekten, indem sie den Informationsfluß strengen Regeln unterwirft.</p></div><div class=paragraph><p>In MLS Umgebungen wird jedem Subjekt oder Objekt ein "Freigabe"-Level zugeordnet, und diese werden wiederum zu einzelnen Verbünden zusammengefaßt. Da diese Freigabe- oder Anfälligkeits-Level Zahlen größer 6000 erreichen können, ist es für jeden Systemadministrator eine undankbare Aufgabe, jede Entität von Grund auf zu konfigurieren. Zum Glück gibt es 3 "instant" Labels, die in der Richtlinie zur Anwendung bereit stehen.</p></div><div class=paragraph><p>Diese drei Labels heißen <code>mls/low</code>, <code>mls/equal</code> und <code>mls/high</code>. Da sie in den Manpages <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> ausführlich beschrieben werden, gibt es hier nur einen kurzen Abriß:</p></div><div class=ulist><ul><li><p>Das Label <code>mls/low</code> ist eine niedrige Einstellung, die von allen anderen dominiert werden darf. Alles, was mit <code>mls/low</code> versehen wird, hat ein niedriges Freigabe-Level und darf auf keine Informationen zugreifen, denen ein höheres Freigabe-Level zugeordnet wurde. Einem Objekt mit diesem Label kann außerdem keine Information durch ein Objekt höherer Freigabe übergeben werden, es kann also auch nicht durch solche Objekte editiert oder überschrieben werden.</p></li><li><p>Das Label <code>mls/equal</code> wird an Objekte vergeben, die von dieser Richtlinie ausgenommen werden sollen.</p></li><li><p>Das Label <code>mls/high</code> verkörpert das höchstmögliche Freigabe-Level. Objekte, denen dieses Label zugeordnet wird, dominieren alle anderen Objekte des Systems. Trotzdem können sie Objekten mit einem niedrigeren Freigabe-Level keine Informationen zuspielen.</p></li></ul></div><div class=paragraph><p>MLS bietet:</p></div><div class=ulist><ul><li><p>Eine hierarchische Sicherheitsschicht und Zuordnung nichthierarchischer Kategorien;</p></li><li><p>Feste Regeln: kein "Read-Up", kein "Write-Down" (ein Subjekt kann nur Objekte gleicher oder <em>niedrigerer</em> Stufe lesen, und es kann nur Objekte gleicher oder <em>höherer</em> Stufe schreiben);</p></li><li><p>Geheimhaltung (indem unangemessene Offenlegung von Daten verhindert wird);</p></li><li><p>Eine Basis zum Entwerfen von Systemen, die Daten verschiedener Vertraulichkeitsebenen gleichzeitig handhaben sollen (ohne das geheime und vertrauliche Informationen untereinander ausgetauscht werden können).</p></li></ul></div><div class=paragraph><p>Nachfolgend werden die <code>sysctl</code>-Variablen vorgestellt, die für die Einrichtung spezieller Dienste und Schnittstellen vorhanden sind.</p></div><div class=ulist><ul><li><p><code>security.mac.mls.enabled</code> schaltet die Richtlinie MLS ein (oder aus).</p></li><li><p><code>security.mac.mls.ptys_equal</code> sorgt dafür, dass während der Initialisierung alle <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a>-Geräte als <code>mls/equal</code> gekennzeichnet werden.</p></li><li><p><code>security.mac.mls.revocation_enabled</code> sorgt dafür, dass die Zugriffsrechte von Objekten wieder zurückgesetzt werden, nachdem deren Label vorübergehend auf ein niedrigeres Freigabe-Level geändert wurde.</p></li><li><p><code>security.mac.mls.max_compartments</code> gibt die maximale Anzahl von Verbünden an. Im Prinzip ist es die höchste Nummer eines Verbundes auf dem System.</p></li></ul></div><div class=paragraph><p>Um die Labels der MLS Richtlinie zu bearbeiten verwendet man <a href="https://man.freebsd.org/cgi/man.cgi?query=setfmac&amp;sektion=8&amp;format=html">setfmac(8)</a>. Um ein Objekt zu kennzeichnen, benutzen Sie folgendes Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac mls/5 test</span></code></pre></div></div><div class=paragraph><p>Um das MLS-Label der Datei <span class=filename>test</span> auszulesen, verwenden Sie dieses Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># getfmac test</span></code></pre></div></div><div class=paragraph><p>Dies ist eine Zusammenstellung der Merkmale von <span class=filename>test</span>. Ein anderer Ansatz ist, für diese Richtlinie eine Konfigurationsdatei in <span class=filename>/etc</span> abzulegen, die alle Informationen enthält und mit der dann das Kommando <code>setfmac</code> gefüttert wird. Diese Vorgehensweise wird erklärt, nachdem alle Richtlinien vorgestellt wurden.</p></div><div class=sect3><h4 id=_verbindlicher_vertraulichkeit_in_der_planungsphase>33.12.1. Verbindlicher Vertraulichkeit in der Planungsphase<a class=anchor href=#_verbindlicher_vertraulichkeit_in_der_planungsphase></a></h4><div class=paragraph><p>Mit dem Richtlinienmodul <code>Multi-Level Security</code> bereitet sich ein Administrator darauf vor, den Fluß vertraulicher Informationen zu kontrollieren. Beim Starten der Richtlinie ist immer <code>mls/low</code> voreingestellt - alles kann auf alles zugreifen. Der Administrator ändert dies während der eigentlichen Konfiguration, indem er die Vertraulichkeit bestimmter Objekte erhöht.</p></div><div class=paragraph><p>Jenseits der drei Grundeinstellungen des Labels kann der Administrator einzelne Nutzer oder Nutzergruppen nach Bedarf zusammenschließen und den Informationsaustausch zwischen diesen gestatten oder unterbinden. Es ist sicher eine Vereinfachung, die Freigabe-Level mit Begriffen wie <code>vertraulich</code>, <code>geheim</code> oder <code>streng geheim</code> zu bezeichnen. Einige Administratoren erstellen einfach verschiedene Gruppen auf der Ebene von gegenwärtigen Projekten. Ungeachtet der Herangehensweise bei der Klassifizierung muß ein gut durchdachter Plan existieren, bevor eine derart einengende Richtlinie umgesetzt wird.</p></div><div class=paragraph><p>Exemplarisch für die Anwendung dieses Moduls bzw. dieser Richtlinie seien angeführt:</p></div><div class=ulist><ul><li><p>Ein E-Commerce Webserver</p></li><li><p>Ein Dateiserver, der vertrauliche Informationen einer Firma oder eines Konzerns speichert</p></li><li><p>Umgebungen in Finanzeinrichtungen</p></li></ul></div><div class=paragraph><p>Der unsinnigste Einsatzort für diese Richtlinie wäre ein Arbeitsplatzrechner mit nur zwei oder drei Benutzern.</p></div></div></div><div class=sect2><h3 id=mac-biba>33.13. Das MAC Modul Biba<a class=anchor href=#mac-biba></a></h3><div class=paragraph><p>Modulname: <span class=filename>mac_biba.ko</span></p></div><div class=paragraph><p>Parameter für die Kernelkonfiguration: <code>options MAC_BIBA</code></p></div><div class=paragraph><p>Bootparameter: <code>mac_biba_load="YES"</code></p></div><div class=paragraph><p>Das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> lädt die MAC Biba Richtlinie. Diese ähnelt stark der MLS Richtlinie, nur das die Regeln für den Informationsfluß ein wenig vertauscht sind. Es wird in diesem Fall der absteigende Fluß sicherheitskritischer Information geregelt, während die MLS Richtlinie den aufsteigenden Fluß regelt. In gewissen Sinne treffen dieses und das vorangegangene Unterkapitel also auf beide Richtlinien zu.</p></div><div class=paragraph><p>In einer Biba-Umgebung wird jedem Subjekt und jedem Objekt ein "Integritäts"-Label zugeordnet. Diese Labels sind in hierarchischen Klassen und nicht-hierarchischen Komponenten geordnet. Je höher die Klasse, um so höher die Integrität.</p></div><div class=paragraph><p>Die unterstützten Labels heißen <code>biba/low</code>, <code>biba/equal</code> und <code>biba/high</code>. Sie werden im Folgenden erklärt:</p></div><div class=ulist><ul><li><p><code>biba/low</code> ist die niedrigste Stufe der Integrität, die einem Objekt verliehen werden kann. Wenn sie einem Objekt oder Subjekt zugeordnet wird, kann dieses auf Objekte oder Subjekte, die biba/high markiert wurden, zwar lesend zugreifen, nicht jedoch schreibend.</p></li><li><p>Das Label <code>biba/equal</code> ist, wie der aufmerksame Leser sicherlich schon ahnt, für die Ausnahmen dieser Richtlinie gedacht und sollte nur diesen Ausnahmen entsprechenden Objekten verliehen werden.</p></li><li><p><code>biba/high</code> markierte Subjekte und Objekte können Objekte niedrigerer Stufe schreiben , nicht jedoch lesen. Es wird empfohlen, dass dieses Label an Objekte vergeben wird, die sich auf Integrität des gesamten Systems auswirken.</p></li></ul></div><div class=paragraph><p>Biba stellt bereit:</p></div><div class=ulist><ul><li><p>Hierarchische Integritätsstufen mit einem Satz nichthierarchischer Integritätskategorien;</p></li><li><p>Festgeschriebene Regeln: kein "Write-Up", kein "Read-Down" (der Gegensatz zu MLS - ein Subjekt erhält schreibenden Zugriff auf Objekte gleicher oder geringerer Stufe, aber nicht bei höherer, und lesenden Zugriff bei gleicher Stufe oder höerer, aber nicht bei niedrigerer);</p></li><li><p>Integrität (es wird die Echtheit der Daten gewährleistet, indem unangemessene Veränderungen verhindert werden);</p></li><li><p>Eine Abstufung der Gewährleistung (im Gegensatz zu MLS, bei der eine Abstufung der Vertraulichkeit vorgenommen wird).</p></li></ul></div><div class=paragraph><p>Folgende <code>sysctl</code> Parameter werden zur Nutzung der Biba-Richtlinie angeboten:</p></div><div class=ulist><ul><li><p><code>security.mac.biba.enabled</code> zum Aktivieren/Deaktivieren der Richtlinie auf dem Zielsystem.</p></li><li><p><code>security.mac.biba.ptys_equal</code> wird verwendet, um die Biba-Richtlinie auf der <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a>-Schnittstelle zu deaktivieren.</p></li><li><p><code>security.mac.biba.revocation_enabled</code> erzwingt das Zurücksetzen des Labels, falls dieses zeitweise geändert wurde um ein Subjekt zu dominieren.</p></li></ul></div><div class=paragraph><p>Um Einstellungen der Biba Richtlinie für Systemobjekte zu verändern werden die Befehle <code>setfmac</code> und <code>getfmac</code> verwendet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/low test</span>
<span class=c># getfmac test</span>
<span class=nb>test</span>: biba/low</code></pre></div></div><div class=sect3><h4 id=_verbindliche_integrität_in_der_planungsphase>33.13.1. Verbindliche Integrität in der Planungsphase<a class=anchor href=#_verbindliche_integrität_in_der_planungsphase></a></h4><div class=paragraph><p>Integrität garantiert, im Unterschied zu Sensitivität, dass Informationen nur durch vertraute Parteien verändert werden können. Dies schließt Informationen ein, die zwischen Subjekten ausgetauscht werden, zwischen Objekt, oder auch zwischen den beiden. Durch Integrität wird gesichert, das Nutzer nur Informationen verändern, oder gar nur lesen können, die sie explizit benötigen.</p></div><div class=paragraph><p>Das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> eröffnet einem Administrator die Möglichkeit zu bestimmen, welche Dateien oder Programme ein Nutzer oder eine Nutzergruppe sehen bzw. aufrufen darf. Gleichzeitig kann er zusichern, dass dieselben Programme und Dateien frei von Bedrohungen sind und das System die Echtheit gewährleistet - für diesen Nutzer oder die Nutzergruppe.</p></div><div class=paragraph><p>Während der anfänglichen Phase der Planung muß der Administrator vorbereitet sein, Nutzer in Klassen, Stufen und Bereiche einzuteilen. Der Zugriff auf Dateien und insbesondere auch Programme wird verhindert sowohl vor als auch nachdem sie gestartet wurden. Das System selbst erhält als Voreinstellung das Label <code>biba/high</code> sobald das Modul aktiviert wird - und es liegt allein am Administrator, die verschiedenen Klassen und Stufen für die einzelnen Nutzer zu konfigurieren. Anstatt mit Freigaben zu arbeiten, wie weiter oben gezeigt wurde, könnte man auch Überbegriffe für Projekte oder Systemkomponenten entwerfen. Zum Beispiel, ausschließlich Entwicklern den Vollzugriff auf Quellcode, Compiler und Entwicklungswerkzeuge gewähren, während man andere Nutzer in Kategorien wie Tester, Designer oder einfach nur "allgemeiner Nutzer" zusammenfaßt, die für diese Bereiche lediglich lesenden Zugriff erhalten sollen.</p></div><div class=paragraph><p>Mit seinem ursprünglichen Sicherheits-Standpunkt ist ein Subjekt niedrigerer Integrität unfähig, ein Subjekt höherer Integrität zu verändern. Ein Subjekt höherer Integrität kann ein Subjekt niedrigerer Integrität weder beobachten noch lesen. Wenn man ein Label für die niedrigstmögliche Klasse erstellt, kann man diese allen Subjekten verwehren. Einige weitsichtig eingerichtete Umgebungen, die diese Richtlinie verwenden, sind eingeschränkte Webserver, Entwicklungs- oder Test-Rechner oder Quellcode-Sammlungen. Wenig sinnvoll ist diese Richtlinie auf einer Arbeitsstation, oder auf Rechnern die als Router oder Firewall verwendet werden.</p></div></div></div><div class=sect2><h3 id=mac-lomac>33.14. Das MAC Modul LOMAC<a class=anchor href=#mac-lomac></a></h3><div class=paragraph><p>Modulname: <span class=filename>mac_lomac.ko</span></p></div><div class=paragraph><p>Parameter für die Kernelkonfiguration: <code>options MAC_LOMAC</code></p></div><div class=paragraph><p>Bootparameter: <code>mac_lomac_load="YES"</code></p></div><div class=paragraph><p>Anders als die Biba Richtlinie erlaubt die <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a> Richtlinie den Zugriff auf Objekte niedrigerer Integrität nur, nachdem das Integritätslevel gesenkt wurde. Dadurch wird eine Störung derIntegritätsregeln verhindert.</p></div><div class=paragraph><p>Die MAC Version der "Low-Watermark" Richtlinie, die nicht mit der älteren -Implementierung verwechselt werden darf, arbeitet fast genauso wie Biba. Anders ist, dass hier "schwebende" Label verwendet werden, die ein Herunterstufen von Subjekten durch Hilfsverbünde ermöglichen. Dieser zweite Verbund wird in der Form <code>[auxgrade]</code> angegeben und sollte in etwa aussehen wie <code>lomac/10[2]</code>, wobei die Ziffer zwei (2) hier den Hilfsverbund abbildet.</p></div><div class=paragraph><p>Die MAC Richtlinie <code>LOMAC</code> beruht auf einer durchgängigen Etikettierung aller Systemobjekte mit Integritätslabeln, die Subjekten das Lesen von Objekten niedriger Integrität gestatten und dann das Label des Subjektes herunterstufen - um zukünftige Schreibvorgänge auf Objekte hoher Integrität zu unterbinden. Dies ist die Funktion der Option <code>[auxgrade]</code>, die eben vorgestellt wurde. Durch sie erhält diese Richtlinie eine bessere Kompatibilität und die Initialisierung ist weniger aufwändig als bei der Richtlinie Biba.</p></div><div class=sect3><h4 id=_beispiele_4>33.14.1. Beispiele<a class=anchor href=#_beispiele_4></a></h4><div class=paragraph><p>Wie schon bei den Richtlinien Biba und MLS werden die Befehle <code>setfmac</code> und <code>setpmac</code> verwendet, um die Labels an den Systemobjekten zu setzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac /usr/home/trhodes lomac/high[low]</span>
<span class=c># getfmac /usr/home/trhodes lomac/high[low]</span></code></pre></div></div><div class=paragraph><p>Beachten Sie, dass hier der Hilfswert auf <code>low</code> gesetzt wurde - dieses Leistungsmerkmal ist nur in der MAC <code>LOMAC</code> Richtlinie enthalten.</p></div></div></div><div class=sect2><h3 id=mac-implementing>33.15. Beispiel 1: Nagios in einer MAC Jail<a class=anchor href=#mac-implementing></a></h3><div class=paragraph><p>Die folgende Demonstration setzt eine sichere Umgebung mithilfe verschiedener MAC Module und sorgfältig konfigurierter Richtlinien um. Es handelt sich jedoch nur um einen Test und sollte nicht als Antwort auf jedes Problem in Fragen Sicherheit gesehen werden. Eine Richtlinie nur umzusetzen und dann einfach laufen zu lassen, funktioniert nie und kann eine echte Arbeitsumgebung in eine Katastrophe stürzen.</p></div><div class=paragraph><p>Bevor es losgeht, muß jedes Dateisystem mit der Option <code>multilabel</code>, wie weiter oben beschrieben, markiert werden. Dies nicht zu tun, führt zu Fehlern. Außerdem müssen die Ports <a class=package href=https://cgit.freebsd.org/ports/tree/net-mngt/nagios-plugins/>net-mngt/nagios-plugins</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/net-mngt/nagios/>net-mngt/nagios</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> installiert und konfiguriert sein, so dass sie ordentlich laufen.</p></div><div class=sect3><h4 id=_erstellen_einer_nutzerklasse_insecure>33.15.1. Erstellen einer Nutzerklasse <code>insecure</code><a class=anchor href=#_erstellen_einer_nutzerklasse_insecure></a></h4><div class=paragraph><p>Beginnen wir die Prozedur mit dem Hinzufügen einer Nutzerklasse in der Datei <span class=filename>/etc/login.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>insecure:\
:copyright=/etc/COPYRIGHT:\
:welcome=/etc/motd:\
:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin--
:manpath=/usr/shared/man /usr/local/man:\
:nologin=/usr/sbin/nologin:\
:cputime=1h30m:\
:datasize=8M:\
:vmemoryuse=100M:\
:stacksize=2M:\
:memorylocked=4M:\
:memoryuse=8M:\
:filesize=8M:\
:coredumpsize=8M:\
:openfiles=24:\
:maxproc=32:\
:priority=0:\
:requirehome:\
:passwordtime=91d:\
:umask=022:\
:ignoretime@:\
:label=biba/10(10-10):</pre></div></div><div class=paragraph><p>Zusätzlich fügen wir beim Standardnutzer folgende Zeile hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>:label=biba/high:</pre></div></div><div class=paragraph><p>Anschließend muß die Datenbank neu erstellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div></div><div class=sect3><h4 id=_boot_konfiguration>33.15.2. Boot-Konfiguration<a class=anchor href=#_boot_konfiguration></a></h4><div class=paragraph><p>Starten Sie den Rechner noch nicht neu. Fügen Sie zunächst noch die folgenden Zeilen in die Datei <span class=filename>/boot/loader.conf</span> ein, damit die benötigten Module während des Systemstarts geladen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>mac_biba_load=&#34;YES&#34;
mac_seeotheruids_load=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=_nutzer_einrichten>33.15.3. Nutzer einrichten<a class=anchor href=#_nutzer_einrichten></a></h4><div class=paragraph><p>Ordnen Sie den Superuser <code>root</code> der Klasse <code>default</code> zu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod root -L default</span></code></pre></div></div><div class=paragraph><p>Alle Nutzerkonten, die weder <code>root</code> noch Systemkonten sind, brauchen nun eine Loginklasse, da sie sonst keinen Zugriff auf sonst übliche Befehle erhalten, wie bspw. <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>. Das folgende <code>sh</code> Skript wird diese Aufgabe erledigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for x in `awk -F: &#39;($3 &gt;= 1001) &amp;&amp; ($3 != 65534) { print $1 }&#39; \</span>
      /etc/passwd<span class=sb>`</span><span class=p>;</span> <span class=k>do </span>pw usermod <span class=nv>$x</span> <span class=nt>-L</span> default<span class=p>;</span> <span class=k>done</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Verschieben Sie die Nutzer <code>nagios</code> und <code>www</code> in die <code>insecure</code> Klasse:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod nagios -L insecure</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod www -L insecure</span></code></pre></div></div></div><div class=sect3><h4 id=_die_kontextdatei_erstellen>33.15.4. Die Kontextdatei erstellen<a class=anchor href=#_die_kontextdatei_erstellen></a></h4><div class=paragraph><p>Nun muß eine Kontextdatei erstellt werden. Die folgende Beispieldatei soll dazu in <span class=filename>/etc/policy.contexts</span> gespeichert werden:</p></div><div class="literalblock programlisting"><div class=content><pre># This is the default BIBA policy for this system.

# System:
/var/run                        biba/equal
/var/run/*                      biba/equal

/dev                            biba/equal
/dev/*                          biba/equal

/var      			biba/equal
/var/spool                      biba/equal
/var/spool/*                    biba/equal

/var/log                        biba/equal
/var/log/*                      biba/equal

/tmp      			biba/equal
/tmp/*      			biba/equal
/var/tmp   	    		biba/equal
/var/tmp/*      		biba/equal

/var/spool/mqueue      	        biba/equal
/var/spool/clientmqueue     	biba/equal

# For Nagios:
/usr/local/etc/nagios
/usr/local/etc/nagios/*         biba/10

/var/spool/nagios               biba/10
/var/spool/nagios/*             biba/10

# For apache
/usr/local/etc/apache           biba/10
/usr/local/etc/apache/*         biba/10</pre></div></div><div class=paragraph><p>Die Richtlinie erzwingt Sicherheit, indem der Informationsfluß Einschränkungen unterworfen wird. In der vorliegenden Konfiguration kann kein Nutzer, weder <code>root</code> noch andere, auf Nagios zugreifen. Konfigurationsdateien und die Prozesse, die Teil von Nagios sind, werden durch unsere MAC vollständig abgegrenzt.</p></div><div class=paragraph><p>Die Kontextdatei kann nun vom System eingelesen werden, indem folgender Befehl ausgeführt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac -ef /etc/policy.contexts /</span>
<span class=c># setfmac -ef /etc/policy.contexts /</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das obenstehende Dateisystem-Layout kann, je nach Umgebung, sehr unterschiedlich aussehen. Außerdem muß es auf jedem einzelnen Dateisystem ausgeführt werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In die Datei <span class=filename>/etc/mac.conf</span> müssen nun noch diese Änderungen eingetragen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>default_labels file ?biba
default_labels ifnet ?biba
default_labels process ?biba
default_labels socket ?biba</pre></div></div></div><div class=sect3><h4 id=_netzwerke_einbinden>33.15.5. Netzwerke einbinden<a class=anchor href=#_netzwerke_einbinden></a></h4><div class=paragraph><p>Tragen Sie die folgende Zeile in die Datei <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>security.mac.biba.trust_all_interfaces=1</pre></div></div><div class=paragraph><p>Und das Folgende gehört in Datei <span class=filename>rc.conf</span> zu den Optionen für die Netzwerkkarte. Falls die Netzwerkverbindung(-en) via DHCP konfiguriert werden, muß man dies nach jedem Systemstart eigenhändig nachtragen:</p></div><div class="literalblock programlisting"><div class=content><pre>maclabel biba/equal</pre></div></div></div><div class=sect3><h4 id=_testen_der_konfiguration>33.15.6. Testen der Konfiguration<a class=anchor href=#_testen_der_konfiguration></a></h4><div class=paragraph><p>Versichern Sie sich, dass der Webserver und Nagios nicht automatisch geladen werden und starten Sie den Rechner neu. Prüfen Sie nun, ob <code>root</code> wirklich keinen Zugriff auf die Dateien im Konfigurationsverzeichnis von Nagios hat. Wenn <code>root</code> den Befehl <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> auf <span class=filename>/var/spool/nagios</span> ausführen kann, ist irgendwas schief gelaufen. Es sollte ein <code>permission denied</code> Fehler ausgegeben werden.</p></div><div class=paragraph><p>Wenn alles gut aussieht, können Nagios, Apache und Sendmail gestartet werden - allerdings auf eine Weise, die unserer Richtlinie gerecht wird. Zum Beispiel durch die folgenden Kommandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/mail &amp;&amp; make stop &amp;&amp; \</span>
setpmac biba/equal make start <span class=o>&amp;&amp;</span> setpmac biba/10<span class=se>\(</span>10-10<span class=se>\)</span> apachectl start <span class=o>&amp;&amp;</span> <span class=se>\</span>
setpmac biba/10<span class=se>\(</span>10-10<span class=se>\)</span> /usr/local/etc/rc.d/nagios.sh forcestart</code></pre></div></div><div class=paragraph><p>Versichern Sie sich lieber doppelt, dass alles ordentlich läuft. Wenn nicht, prüfen Sie die Logs und Fehlermeldungen. Verwenden Sie das <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> Werkzeug um die Sicherheitsrichtlinie <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> zu deaktivieren und versuchen Sie dann alles noch einmal zu starten.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Der Superuser kann den Vollzug der Richtlinie schalten und die Konfiguration ohne Furcht verändern. Folgender Befehl stuft eine neu gestartete Shell herunter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setpmac biba/10 csh</span></code></pre></div></div><div class=paragraph><p>Um dies zu vermeiden, werden die Nutzer durch <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> eingeschränkt. Wenn <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a> einen Befehl außerhalb der definierten Schranken ausführen soll, wird ein Fehler zurückgeliefert. In so einem Fall muß <code>root</code> auf <code>biba/high(high-high)</code> gesetzt werden.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=mac-userlocked>33.16. Beispiel 2: User Lock Down<a class=anchor href=#mac-userlocked></a></h3><div class=paragraph><p>Grundlage dieses Beispiels ist ein relativ kleines System zur Datenspeicherung mit weniger als 50 Benutzern. Diese haben die Möglichkeit, sich einzuloggen und dürfen nicht nur Daten speichern, sondern auch auf andere Ressourcen zugreifen.</p></div><div class=paragraph><p>Die Richtlinien <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> können gleichzeitig eingesetzt werden. Zusammen kann man mit ihnen nicht nur den Zugriff auf Systemobjekte einschränken, sondern auch Nutzerprozesse verstecken.</p></div><div class=paragraph><p>Beginnen Sie, indem Sie die folgende Zeile in die Datei <span class=filename>/boot/loader.conf</span> eintragen:</p></div><div class="literalblock programlisting"><div class=content><pre>mac_seeotheruids_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Die Richtlinie <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> wird durch den anschließenden Eintrag in <span class=filename>/etc/rc.conf</span> hinzugefügt:</p></div><div class="literalblock programlisting"><div class=content><pre>ugidfw_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Die Standardregeln, welche in <span class=filename>/etc/rc.bsdextended</span> gespeichert sind, werden zum Systemstart geladen. Sie müssen aber noch angepaßt werden. Da dieser Computer nur Nutzern dienen soll und weitere Dienste gestartet werden, kann alles bis auf die beiden letzten Zeilen auskommentiert werden. Das sorgt dafür dass jeder Nutzer seine eigenen Systemobjekte erhält.</p></div><div class=paragraph><p>Nun fügen wir alle benötigten Nutzer auf der Maschine hinzu und starten neu. Zum Testen der Einstellungen loggen Sie sich parallel zwei mal mit unterschiedlichen Nutzernamen ein und starten Sie das Kommando <code>ps aux</code>. Dort sehen Sie, dass Sie die Prozesse des anderen Nutzers nicht sehen können. Versuchen Sie, <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> auf das Heimatverzeichnis eines anderen Nutzers auszuführen. Auch dieser Versuch wird fehlschlagen.</p></div><div class=paragraph><p>Solange nicht die speziellen <code>sysctl</code>-Variablen geändert wurden, hat der Superuser noch vollen Zugriff. Sobald auch diese Einstellungen angepaßt wurden, führen Sie ruhig auch den obigen Test als <code>root</code> aus.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn ein neuer Benutzer hinzugefügt wird, ist für diesen zunächst keine <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> Regel im Regelsatz vorhanden. Schnelle Abhilfe schafft hier, einfach das Kernelmodul mit <a href="https://man.freebsd.org/cgi/man.cgi?query=kldunload&amp;sektion=8&amp;format=html">kldunload(8)</a> zu entladen und mit <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> erneut einzubinden.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mac-troubleshoot>33.17. Fehler im MAC beheben<a class=anchor href=#mac-troubleshoot></a></h3><div class=paragraph><p>Während der Entwicklung des Frameworks haben einige Nutzer auf Probleme hingewiesen. Einige davon werden hier aufgeführt:</p></div><div class=sect3><h4 id=_die_option_multilabel_greift_nicht_auf_der_partition>33.17.1. Die Option <code>multilabel</code> greift nicht auf der <span class=filename>/</span>-Partition<a class=anchor href=#_die_option_multilabel_greift_nicht_auf_der_partition></a></h4><div class=paragraph><p>Es scheint, dass etwa jedem fünfzigsten Nutzer dieses Problem widerfährt. Und in der Tat - auch wir kennen es aus der Entwicklung. Genauere Untersuchungen dieses "Bugs" machten uns glauben, dass es sich entweder um einen Fehler in oder eine fehlerhafte Interpretation der Dokumentation handelt. Warum auch immer dieser Fehler auftritt - er kann mit folgender Prozedur behoben werden:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Öffnen Sie die Datei <span class=filename>/etc/fstab</span> und setzen Sie die Rootpartition auf <code>ro</code> wie "read-only".</p></li><li><p>Starten Sie in den Einzelnutzermodus.</p></li><li><p>Rufen Sie <code>tunefs -l enable</code> für <span class=filename>/</span> auf.</p></li><li><p>Starten Sie in den Mehrbenutzermodus.</p></li><li><p>Führen Sie <code>mount -urw</code><span class=filename>/</span> aus und ändern Sie anschließend in der Datei <span class=filename>/etc/fstab</span> die Option <code>ro</code> zurück in <code>rw</code>. Starten Sie das System noch einmal neu.</p></li><li><p>Achten Sie besonders auf die Ausgabe von <code>mount</code> um sich zu versichern, dass die <code>multilabel</code> korrekt für das root-Dateisystem gesetzt wurde.</p></li></ol></div></div><div class=sect3><h4 id=_mit_der_aktivierten_mac_kann_ich_keinen_x11_server_starten>33.17.2. Mit der aktivierten MAC kann ich keinen X11 Server starten<a class=anchor href=#_mit_der_aktivierten_mac_kann_ich_keinen_x11_server_starten></a></h4><div class=paragraph><p>Dies kann durch die Richtlinie <code>partition</code> oder einer fehlerhaften Verwendung einer Richtlinie, die mit Labels arbeitet, auftreten. Zum debuggen versuchen Sie folgendes:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Schauen Sie sich die Fehlermeldungen genau an. Wenn der Nutzer einer <code>insecure</code> Klasse angehört, ist wahrscheinlich die Richtlinie <code>partition</code> die Ursache. Versuchen Sie, die Nutzerklasse auf <code>default</code> zu stellen und danach die Datenbank mit <code>cap_mkdb</code> zu erneuern. Wenn das Problem dadurch nicht gelöst wird, gehen Sie weiter zu Schritt 2.</p></li><li><p>Gehen Sie die Label-Richtlinien Schritt für Schritt nocheinmal durch. Achten Sie darauf, dass für den Nutzer, bei dem das Problem auftritt, für X11 und das Verzeichnis <span class=filename>/dev</span> alle Einstellungen korrekt sind.</p></li><li><p>Falls all dies nicht helfen sollte, senden Sie die Fehlermeldung und eine Beschreibung ihrer Arbeitsumgebung an die (englisch-sprachige) TrustedBSD Diskussionsliste auf der <a href=http://www.TrustedBSD.org>TrustedBSD</a> Webseite oder an die <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>FreeBSD general questions</a> Mailingliste.</p></li></ol></div></div><div class=sect3><h4 id=_error_cannot_stat_login_conf>33.17.3. Error: cannot stat <span class=filename>.login_conf</span><a class=anchor href=#_error_cannot_stat_login_conf></a></h4><div class=paragraph><p>Wenn ich versuche, von <code>root</code> zu einem anderen Nutzer des Systems zu wechseln, erhalte ich die Fehlermeldung <code>_secure_path: unable to state .login_conf</code>.</p></div><div class=paragraph><p>Diese Meldung wird gewöhnlich ausgegeben, wenn der Nutzer ein höhere Label-Einstellung hat als der, dessen Identität man annehmen möchte. Ausführlich: Wenn ein Nutzer <code>joe</code> als <code>biba/low</code> gelabelt wurde, kann <code>root</code>, der <code>biba/high</code> als Voreinstellung trägt, das Heimatverzeichnis von <code>joe</code> nicht einsehen. Das passiert unabhänig davon, ob <code>root</code> vorher mit <code>su</code> die Identität von <code>joe</code> angenommen hat oder nicht, da das Label sich nicht ändert. Hier haben wir also einen Fall, in dem das Gewährleistungsmodell von Biba verhindert, das der Superuser Objekte einer niedrigeren Integrität betrachten kann.</p></div></div><div class=sect3><h4 id=_der_nutzer_root_ist_kaputt>33.17.4. Der Nutzer <code>root</code> ist kaputt!<a class=anchor href=#_der_nutzer_root_ist_kaputt></a></h4><div class=paragraph><p>Im normalen oder sogar im Einzelbenutzermodus wird <code>root</code> nicht anerkannt. Das Kommando <code>whoami</code> liefert 0 (null) und <code>su</code> liefert <code>who are you?</code> zurück. Was geht da vor?</p></div><div class=paragraph><p>Das kann passieren, wenn eine Label-Richtlinie ausgeschaltet wird - entweder durch <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> oder wenn das Richtlinienmodul entladen wurde. Wenn eine Richtlinie deaktiviert oder auch nur vorübergehen deaktiviert wird, muß die Befähigungsdatenbank neu konfiguriert werden, d.h. die <code>label</code> Option muß entfernt werden. Überprüfen Sie, ob alle <code>label</code> Einträge aus der Datei <span class=filename>/etc/login.conf</span> entfernt wurden und bauen Sie die Datenbank mit <code>cap_mkdb</code> neu.</p></div><div class=paragraph><p>Dieser Fehler kann auch auftreten, wenn eine Richtlinie den Zugriff auf die Datei <span class=filename>master.passwd</span> einschränkt. Normalerweise passiert das nur, wenn ein Administrator ein Label an diese Datei vergibt, das mit der allgemeingültigen Richtlinie, die das System verwendet, in Konflikt steht. In solchen Fällen werden die Nutzerinformationen vom System ausgelesen und jeder weitere Zugriff wird blockiert, sobald das neue Label greift. Wenn man die Richtlinie via <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> ausschaltet, sollte es erstmal wieder gehen.</p></div></div></div></div></div><div class=sect1><h2 id=audit>Kapitel 34. Security Event Auditing<a class=anchor href=#audit></a></h2><div class=sectionbody><div class=sect2><h3 id=audit-synopsis>34.1. Einleitung<a class=anchor href=#audit-synopsis></a></h3><div class=paragraph><p>FreeBSD bietet Unterstützung für Sicherheits-Auditing. Ereignis-Auditing bietet zuverlässige, feingranulierte und konfigurierbare Aufzeichnung einer Vielzahl von sicherheitsrelevanten Systemereignissen einschließlich Benutzereingaben, Konfigurationsänderungen sowie Datei- und Netzwerkzugriffen. Diese Log-Datensätze können unschätzbar wertvoll sein für direkte Systemüberwachung, Einbruchserkennung und Post-Mortem-Analyse. FreeBSD implementiert Sun™s öffentlich zugängliches Basic Security Module (BSM) Application Programming Interface (API) und Dateiformat, und kann mit den Audit-Implementierungen von Sun™ Solaris™ und Apple® Mac OS® X zusammenarbeiten.</p></div><div class=paragraph><p>Dieses Kapitel konzentriert sich auf die Installation und Konfiguration des Ereignis-Auditings. Es erklärt Audit-Richtlinien und stellt ein Beispiel einer Audit-Konfiguration vor.</p></div><div class=paragraph><p>Nach dem Lesen dieses Kapitels werden Sie Folgendes wissen:</p></div><div class=ulist><ul><li><p>Was Ereignis-Auditing ist und wie es funktioniert.</p></li><li><p>Wie man Ereignis-Auditing in FreeBSD für Benutzer und Prozesse konfiguriert.</p></li><li><p>Wie man den Audit-Pfad mittels Audit-Reduktion und Revisionswerkzeugen überprüft.</p></li></ul></div><div class=paragraph><p>Vor dem Lesen dieses Kapitels sollten Sie:</p></div><div class=ulist><ul><li><p>Sowohl UNIX® als auch FreeBSD-Basismechanismen beherrschen (<a href=./#basics>Grundlagen des FreeBSD Betriebssystems</a>).</p></li><li><p>Mit den grundlegenden Mechanismen der Kernel-Konfiguration und -Kompilierung vertraut sein (<a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a>).</p></li><li><p>Mit den Maßnahmen zur Sicherung von FreeBSD vertraut sein (<a href=./#security>Sicherheit</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Die Audit-Funktionalität in FreeBSD hat einige bekannte Einschränkungen. Nicht alle sicherheitsrelevanten System-Ereignisse sind auditierbar, und einige Anmelde-Mechanismen, wie beispielsweise Xorg-basierte Bildschirm-Manager und Dienste von Drittanbietern, konfigurieren das Auditing für Benutzeranmeldungen nicht korrekt.</p></div><div class=paragraph><p>Das Sicherheits-Auditing ist in der Lage, sehr detaillierte Log-Dateien von Systemaktivitäten zu erzeugen. Auf einem ausgelasteten System kann die Pfad-Datei sehr groß werden, wenn sie für hohe Auflösung konfiguriert ist, und im Extremfall pro Woche um mehrere Gigabyte anwachsen. Administratoren sollten daher den benötigten Plattenplatz in Verbindung mit umfangreichen Audit-Konfigurationen berücksichtigen. So kann es wünschenswert sein, ein eigenes Dateisystem für <span class=filename>/var/audit</span> einzusetzen, damit andere Dateisysteme nicht betroffen sind, wenn das Dateisystem des Audit voll läuft.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=audit-inline-glossary>34.2. Schlüsselbegriffe<a class=anchor href=#audit-inline-glossary></a></h3><div class=paragraph><p>Die folgenden Begriffe stehen im Zusammenhang mit Ereignis-Auditing:</p></div><div class=ulist><ul><li><p><em>event</em>: ein auditierbares Ereignis ist jedes Ereignis, das mit dem Audit-Subsystem aufgezeichnet werden kann. Beispiele für sicherheitsrelevante Systemereignisse sind etwa das Anlegen von Dateien, das Erstellen einer Netzwerkverbindung oder eine Benutzeranmeldung. Ereignisse sind entweder "attributierbar", können also zu einen authentifizierten Benutzer zurückverfolgt werden, oder sind "nicht-attributierbar". Nicht-attributierbare Ereignisse erfolgen daher vor der Authentifizierung im Anmeldeprozess (beispielsweise die Eingabe eines falschen Passworts).</p></li><li><p><em>class</em>: benannte Zusammenstellungen von zusammengehörenden Ereignissen, die in Auswahl-Ausdrücken benutzt werden. Häufig genutzte Klassen von Ereignissen schließen "file creation" (fc, Anlegen von Dateien), "exec" (ex, Ausführung) und "login_logout" (lo, Anmeldung-Abmeldung) ein.</p></li><li><p><em>record</em>: ein Audit-Logeintrag, der ein Sicherheitsereignis enthält. Jeder Datensatz enthält einen Ereignistyp, Informationen über den Gegenstand (Benutzer), welcher die Aktion durchführt, Datums- und Zeitinformationen, Informationen über jedes Objekt oder Argument sowie den Zustand hinsichtlich Erfolg oder Scheitern der Operation.</p></li><li><p><em>trail</em>: eine Log-Datei bestehend aus einer Reihe von Audit-Datensätzen, die Sicherheitsereignisse beschreiben. Pfade sind in grober zeitlicher Reihenfolge bezüglich des Zeitpunktes, an welchem ein Ereignis beendet wurde. Nur autorisierte Prozesse dürfen Datensätze zum Audit-Pfad hinzufügen.</p></li><li><p><em>selection expression</em>: eine Zeichenkette, welche eine Liste von Präfixen und Audit-Ereignisklassennamen enthält, um Ereignisse abzugleichen.</p></li><li><p><em>preselection</em>: der Prozess, durch den das System erkennt, welche Ereignisse von Interesse für den Administrator sind, um die Erzeugung von Datensätze zu verhindern, welche nicht von Belang sind. Die Konfiguration der Vorauswahl benutzt eine Reihe von Auswahl-Ausdrücken, um zu erkennen, welche Klassen von Ereignissen für welche Benutzer aufgezeichnet werden sollen sowie globale Einstellungen, welche sowohl auf autorisierte als auch unautorisierte Prozesse angewendet werden.</p></li><li><p><em>reduction</em>: Die Reduzierung ist der Prozess, durch den Datensätze von bestehenden Audit-Pfaden ausgewählt werden für Speicherung, Ausdruck oder Analyse. Ebenso der Prozess, durch den unerwünschte Datensätze aus dem Audit-Pfad entfernt werden. Mittels Reduzierung können Administratoren Richtlinien für die Speicherung von Audit-Daten vorgeben. Zum Beispiel können ausführliche Audit-Pfade für einen Monat gespeichert werden, um danach den Pfad für archivarische Zwecke auf die Anmeldeinformationen zu reduzieren.</p></li></ul></div></div><div class=sect2><h3 id=audit-config>34.3. Audit Konfiguration<a class=anchor href=#audit-config></a></h3><div class=paragraph><p>Userspace-Unterstützung für Ereignis-Auditing ist Bestandteil des FreeBSD-Betriebssystems. Kernel-Unterstützung ist in der Voreinstellung im <span class=filename>GENERIC</span>-Kernel enthalten und <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> kann durch Hinzufügen der folgenden Zeile in <span class=filename>/etc/rc.conf</span> aktiviert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>auditd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten Sie anschließend den Audit-Daemon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service auditd start</span></code></pre></div></div><div class=paragraph><p>Benutzer, die es bevorzugen einen angepassten Kernel zu kompilieren, müssen folgende Zeile in die Kernelkonfigurationsdatei aufnehmen:</p></div><div class="literalblock programlisting"><div class=content><pre>options   AUDIT</pre></div></div><div class=sect3><h4 id=_ereignis_auswahlausdrücke>34.3.1. Ereignis-Auswahlausdrücke<a class=anchor href=#_ereignis_auswahlausdrücke></a></h4><div class=paragraph><p>Auswahlausdrücke werden an einigen Stellen der Audit-Konfiguration benützt, um zu bestimmen, welche Ereignisse auditiert werden sollen. Die Ausdrücke enthalten eine Liste der Ereignisklassen, welche verglichen werden sollen. Auswahlausdrücke werden von links nach rechts ausgewertet und zwei Ausdrücke werden durch Aneinanderhängen miteinander kombiniert.</p></div><div class=paragraph><p><a href=#event-selection>Audit-Ereignisklassen</a> fasst die Audit-Ereignisklassen zusammen:</p></div><table id=event-selection class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 12. Audit-Ereignisklassen</caption><col style=width:20%><col style=width:20%><col style=width:60%><thead><tr><th class="tableblock halign-left valign-top">Name der Klasse</th><th class="tableblock halign-left valign-top">Beschreibung</th><th class="tableblock halign-left valign-top">Aktion</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>all</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>all</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vergleicht alle Ereigsnisklassen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>aa</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>authentication and authorization</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ad</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>administrative</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Administrative Aktionen, ausgeführt auf dem System als Ganzes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ap</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>application</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Aktionen definiert für Applikationen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cl</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file close</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit-Aufrufe für den Systemaufruf <code>close</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ex</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>exec</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ausführung des Audit-Programms. Auditierung von Befehlszeilen-Argumenten und Umgebungsvariablen wird gesteuert durch <a href="https://man.freebsd.org/cgi/man.cgi?query=audit_control&amp;sektion=5&amp;format=html">audit_control(5)</a> mittels der <code>argv</code> und <code>envv</code>-Parameter gemäß der <code>Richtlinien</code>-Einstellungen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fa</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file attribute access</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditierung des Zugriffs auf Objektattribute wie <a href="https://man.freebsd.org/cgi/man.cgi?query=stat&amp;sektion=1&amp;format=html">stat(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=pathconf&amp;sektion=2&amp;format=html">pathconf(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file create</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit-Ereignisse, bei denen eine Datei als Ergebnis angelegt wird.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file delete</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit-Ereignisse, bei denen Dateilöschungen vorkommen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file attribute modify</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit-Ereignisse, bei denen Dateiattribute geändert werden, wie <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=flock&amp;sektion=2&amp;format=html">flock(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fr</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file read</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit-Ereignisse, bei denen Daten gelesen oder Dateien zum lesen geöffnet werden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fw</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file write</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit-Ereignisse, bei denen Daten geschrieben oder Dateien geschrieben oder verändert werden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>io</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ioctl</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nutzung des Systemaufrufes <code>ioctl</code> durch Audit.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ip</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ipc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditierung verschiedener Formen von Inter-Prozess-Kommunikation einschließlich POSIX-Pipes und System V IPC-Operationen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lo</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>login_logout</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit-Ereignisse von <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=logout&amp;sektion=1&amp;format=html">logout(1)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>na</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>non attributable</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditierung nicht-attributierbarer Ereignisse.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>no</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>invalid class</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kein Abgleich von Audit-Ereignissen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nt</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>network</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audit-Ereignisse in Zusammenhang mit Netzwerkaktivitäten wie <a href="https://man.freebsd.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;format=html">connect(2)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;format=html">accept(2)</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>other</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditierung verschiedener Ereignisse.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>pc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>process</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditierung von Prozess-Operationen wie <a href="https://man.freebsd.org/cgi/man.cgi?query=exec&amp;sektion=3&amp;format=html">exec(3)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=3&amp;format=html">exit(3)</a>.</p></td></tr></tbody></table><div class=paragraph><p>Diese Ereignisklassen können angepasst werden durch Modifizierung der Konfigurationsdateien <span class=filename>audit_class</span> und <span class=filename>audit_event</span>.</p></div><div class=paragraph><p>Jede Audit-Klasse kann mit einem Präfix kombiniert werden, welches anzeigt, ob erfolgreiche/gescheiterte Operationen abgebildet werden, und ob der Eintrag den Abgleich hinzufügt oder entfernt für die Klasse und den Typ. <a href=#event-prefixes>Präfixe für Audit-Ereignisklassen</a> fasst die verfügbaren Präfixe zusammen.</p></div><table id=event-prefixes class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 13. Präfixe für Audit-Ereignisklassen</caption><col style=width:20%><col style=width:80%><thead><tr><th class="tableblock halign-left valign-top">Präfix</th><th class="tableblock halign-left valign-top">Aktion</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditiert erfolgreiche Ereignisse in dieser Klasse.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditiert fehlgeschlagene Ereignisse in dieser Klasse.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditiert weder erfolgreiche noch fehlgeschlagene Ereignisse.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditiert keine erfolgreichen Ereignisse in dieser Klasse.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditiert keine fehlgeschlagenen Ereignisse in dieser Klasse.</p></td></tr></tbody></table><div class=paragraph><p>Wenn kein Präfix vorhanden ist, werden sowohl erfolgreiche als auch fehlgeschlagene Ereignisse auditiert.</p></div><div class=paragraph><p>Das folgende Beispiel einer Auswahl-Zeichenkette wählt erfolgreiche und gescheiterte Anmelde/Abmelde-Ereignisse aus, aber nur erfolgreich beendete Ausführungs-Ereignisse:</p></div><div class="literalblock programlisting"><div class=content><pre>lo,+ex</pre></div></div></div><div class=sect3><h4 id=_konfigurationsdateien>34.3.2. Konfigurationsdateien<a class=anchor href=#_konfigurationsdateien></a></h4><div class=paragraph><p>Die folgenden Konfigurationsdateien für Sicherheits-Auditing befinden sich in <span class=filename>/etc/security</span>.</p></div><div class=ulist><ul><li><p><span class=filename>audit_class</span>: enthält die Definitionen der Audit-Klassen.</p></li><li><p><span class=filename>audit_control</span>: steuert die Eigenschaften des Audit-Subsystems, wie Standard-Audit-Klassen, Mindestfestplattenspeicher auf dem Audit-Log-Volume und die maximale Größe des Audit-Trails.</p></li><li><p><span class=filename>audit_event</span>: Namen und Beschreibungen der Audit-Ereignisse, und eine Liste von Klassen mit den dazugehörigen Ereignissen.</p></li><li><p><span class=filename>audit_user</span>: benutzerspezifische Audit-Anforderungen, kombinierbar mit den globalen Standardeinstellungen bei der Anmeldung.</p></li><li><p><span class=filename>audit_warn</span>: ein anpassbares Skript, das von <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> verwendet wird, um in bestimmten Situationen Warnmeldungen zu generieren, z.B. wenn der Platz für Audit-Protokolle knapp wird, oder wenn die Datei des Audit-Trails rotiert wurde.</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Konfigurationsdateien von Audit sollten sorgfältig bearbeitet und gepflegt werden, da Fehler in der Konfiguration zu einer fehlerhaften Protokollierung der Ereignisse führen können.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In den meisten Fällen wird der Administrator nur <span class=filename>audit_control</span> und <span class=filename>audit_user</span> anpassen müssen. Die erste Datei steuert systemweite Audit-Eigenschaften, sowie Richtlinien. Die zweite Datei kann für die Feinabstimmung bei der Auditierung von Benutzern verwendet werden.</p></div><div class=sect4><h5 id=audit-auditcontrol>34.3.2.1. Die <span class=filename>audit_control</span>-Datei<a class=anchor href=#audit-auditcontrol></a></h5><div class=paragraph><p>Die <span class=filename>audit_control</span>-Datei legt eine Anzahl Vorgabewerte fest:</p></div><div class="literalblock programlisting"><div class=content><pre>dir:/var/audit
dist:off
flags:lo,aa
minfree:5
naflags:lo,aa
policy:cnt,argv
filesz:2M
expire-after:10M</pre></div></div><div class=paragraph><p>Die Option <code>dir</code> wird genutzt, um eines oder mehrere Verzeichnisse festzulegen, in welchen Audit-Protokolle gespeichert werden. Gibt es mehrere Verzeichniseinträge, werden diese in der angegebenen Reihenfolge genutzt, bis sie jeweils gefüllt sind. Es ist üblich, Audit so zu konfigurieren, dass die Audit-Logs auf einem dedizierten Dateisystem abgelegt werden, um Wechselwirkungen zwischen dem Audit-Subsystem und anderen Subsystemen zu verhindern, falls das Dateisystem voll läuft.</p></div><div class=paragraph><p>Ist die Option <code>dist</code> auf <code>on</code> oder <code>yes</code> gesetzt, wird ein Link der Dateien des Audit-Trails in <span class=filename>/var/audit/dist</span> erstellt.</p></div><div class=paragraph><p>Das <code>flags</code>-Feld legt die systemweite Standard-Vorauswahl-Maske für attributierbare (direkt einem Benutzer zuordenbare) Ereignisse fest. Im obigen Beispiel werden alle gescheiterten und erfolgreichen Anmelde- und Abmelde-Ereignisse für alle Benutzer aufgezeichnet.</p></div><div class=paragraph><p>Die Option <code>minfree</code> definiert den minimalen Prozentsatz an freiem Plattenplatz für das Dateisystem, in welchem der Audit-Pfad abgespeichert wird. Wenn diese Schwelle überschritten ist, wird ein Warnhinweis erzeugt.</p></div><div class=paragraph><p>Die <code>naflags</code>-Option bestimmt diejenigen Audit-Klassen, für die nicht-attributierbare Ereignisse aufgezeichnet werden sollen, wie beispielsweise Anmeldeprozesse, Authentifizierung und Autorisierung.</p></div><div class=paragraph><p>Die Option <code>policy</code> legt eine durch Kommata getrennte Liste von policy-Flags fest, welche verschiedene Aspekte des Audit-Verhaltens steuern. Der Flag <code>cnt</code> zeigt an, dass das System trotz eines Audit-Fehlers weiterlaufen soll (dieses Flag wird dringend empfohlen). Ein anderes, häufig genutztes Flag ist <code>argv</code>, welches dazu führt, dass Befehlszeilen-Argumente für den Systemaufruf <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> als Teil der Befehlsausführung aufgezeichnet werden.</p></div><div class=paragraph><p>Die <code>filesz</code>-Option spezifiziert die maximale Größe der Audit-Datei, bevor sie automatisch beendet und rotiert wird. Der Wert <code>0</code> setzt die automatische Log-Rotation außer Kraft. Falls die angeforderte Dateigröße unterhalb des Minimums von 512K ist, dann wird die Angabe verworfen und ein Log-Hinweis wird erzeugt.</p></div><div class=paragraph><p>Die Option <code>expire-after</code> legt fest, wann die Audit-Dateien verfallen und entfernt werden.</p></div></div><div class=sect4><h5 id=audit-audituser>34.3.2.2. Die Datei <span class=filename>audit_user</span><a class=anchor href=#audit-audituser></a></h5><div class=paragraph><p>Die <span class=filename>audit_user</span>-Datei erlaubt es dem Administrator, weitere Audit-Erfordernisse für bestimmte Benutzer festzulegen. Jede Zeile konfiguriert das Auditing für einen Benutzer über zwei Felder: <code>alwaysaudit</code> gibt eine Ansammlung von Ereignissen vor, welche immer für diesen Benutzer aufgezeichnet werden. <code>neveraudit</code> legt Ereignisse fest, die niemals für diesen Benutzer auditiert werden sollen.</p></div><div class=paragraph><p>Das folgende Beispiel einer <span class=filename>audit_user</span>-Datei zeichnet Anmelde/Abmelde-Ereignisse, erfolgreiche Befehlsausführungen für den Benutzer <code>root</code>, Anlegen von Dateien und erfolgreiche Befehlsausführungen für den Benutzer <code>www</code> auf. Falls die voreingestellte <span class=filename>audit_control</span> benutzt wird, dann ist der Eintrag <code>lo</code> für <code>root</code> überflüssig und Anmelde/Abmelde-Ereignisse werden für <code>www</code> ebenfalls aufgezeichnet.</p></div><div class="literalblock programlisting"><div class=content><pre>root:lo,+ex:no
www:fc,+ex:no</pre></div></div></div></div></div><div class=sect2><h3 id=audit-administration>34.4. Audit-Trails<a class=anchor href=#audit-administration></a></h3><div class=paragraph><p>Weil Audit-Trails werden im binären BSM-Format gespeichert werden, gibt es verschiedene Werkzeuge, um derartige Dateien zu ändern oder sie in Textdateien zu konvertieren. Der Befehl <code>praudit</code> wandelt alle Pfad-Dateien in ein einfaches Textformat um. Der Befehl <code>auditreduce</code> kann genutzt werden, um die Pfad-Dateien für Analyse, Ausdruck, Archivierung oder andere Zwecke zu reduzieren. Eine Reihe von Auswahl-Parametern werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=auditreduce&amp;sektion=1&amp;format=html">auditreduce(1)</a> unterstützt, einschließlich Ereignistyp, Ereignisklasse, Benutzer, Datum und Uhrzeit des Ereignisses und den Dateipfad oder das Objekt, mit dem gearbeitet wurde.</p></div><div class=paragraph><p>Der folgende Befehl schreibt den gesamten Inhalt einer angegebenen Audit-Protokolldatei in eine Textdatei:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># praudit /var/audit/AUDITFILE</span></code></pre></div></div><div class=paragraph><p><em>AUDITFILE</em> ist hier die zu schreibende Protokolldatei.</p></div><div class=paragraph><p>Audit-Pfade bestehen aus einer Reihe von Datensätzen, die wiederum aus Kürzeln (token) gebildet werden, die von <a href="https://man.freebsd.org/cgi/man.cgi?query=praudit&amp;sektion=1&amp;format=html">praudit(1)</a> fortlaufend zeilenweise ausgegeben werden. Jedes Kürzel ist von einem bestimmten Typ, z.B. enthält <code>header</code> einen audit-Datensatz-Header oder <code>path</code> enthält einen Dateipfad von einer Suche. Hier ein Beispiel eines <code>execve</code>-Ereignisses:</p></div><div class="literalblock programlisting"><div class=content><pre>header,133,10,execve(2),0,Mon Sep 25 15:58:03 2006, + 384 msec
exec arg,finger,doug
path,/usr/bin/finger
attribute,555,root,wheel,90,24918,104944
subject,robert,root,wheel,root,wheel,38439,38032,42086,128.232.9.100
return,success,0
trailer,133</pre></div></div><div class=paragraph><p>Dieser Audit stellt einen erfolgreichen <code>execve</code>-Aufruf dar, in welchem der Befehl <code>finger doug</code> ausgeführt wurde. <code>exec arg</code> enthält die Befehlszeile, welche die Shell an den Kernel weiterleitet. Das Kürzel <code>path</code> enthält den Pfad zur ausführbaren Datei (wie vom Kernel wahrgenommen). Das Kürzel <code>attribute</code> beschreibt die Binärdatei und enthält den Datei-Modus, der genutzt werden kann, um zu bestimmen, ob setuid auf die Applikation angewendet wurde. Das Kürzel <code>subject</code> speichert die Audit-Benutzer-ID, effektive Benutzer-ID und Gruppen-ID, wirkliche Benutzer-ID und Gruppen-ID, Prozess-ID, Session- ID, Port-ID und Anmelde-Adresse. Beachten Sie, dass Audit-Benutzer-ID und wirkliche Benutzer-ID abweichen, da der Benutzer <code>robert</code> zum Benutzer <code>root</code> wurde, bevor er diesen Befehl ausführte, aber er wird auditiert mit dem ursprünglich authentifizierten Benutzer. Das Kürzel <code>return</code> zeigt die erfolgreiche Ausführung an und <code>trailer</code> schließt den Datensatz ab.</p></div><div class=paragraph><p>Die Ausgabe im XML-Format wird ebenfalls unterstützt und kann über die Option <code>-x</code> ausgewählt werden.</p></div><div class=paragraph><p>Da Audit-Protokolldateien sehr groß sein können, kann mit Hilfe von <code>auditreduce</code> auch nur eine Teilmenge der Datensätze ausgewählt werden. Dieses Beispiel selektiert alle Datensätze des Benutzers <code>trhodes</code> aus der Datei <span class=filename>AUDITFILE</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># auditreduce -u trhodes /var/audit/AUDITFILE | praudit</span></code></pre></div></div><div class=paragraph><p>Mitglieder der Gruppe <code>audit</code> sind berechtigt, Audit-Pfade in <span class=filename>/var/audit</span> zu lesen. In der Voreinstellung ist diese Gruppe leer, daher kann nur der Benutzer <code>root</code> die Audit-Pfade lesen. Benutzer können der Gruppe <code>audit</code> hinzugefügt werden, um Rechte für Audit-Reviews zu gewähren. Da die Fähigkeit, Inhalte von Audit-Protokolldateien zu verfolgen, tiefgreifende Einblicke in das Verhalten von Benutzern und Prozessen erlaubt, wird empfohlen, dass die Gewährung von Rechten für Audit-Reviews mit Bedacht erfolgt.</p></div><div class=sect3><h4 id=_aktive_überwachung_mittels_audit_pipes>34.4.1. Aktive Überwachung mittels Audit-Pipes<a class=anchor href=#_aktive_überwachung_mittels_audit_pipes></a></h4><div class=paragraph><p>Audit-Pipes sind nachgebildete (geklonte) Pseudo-Geräte, welche es Applikationen erlauben, die laufenden Audit-Datensätze anzuzapfen. Dies ist vorrangig für Autoren von Intrusion Detection Software und Systemüberwachungsprogrammen von Bedeutung. Allerdings ist das Audit-Pipe-Gerät ein angenehmer Weg für den Administrator, aktive Überwachung zu gestatten, ohne Gefahr von Problemen durch Besitzerrechte der Audit-Pfad-Datei oder Unterbrechung des Stroms von Ereignissen durch Log-Rotation. Um den laufenden Audit-Ereignisstrom zu verfolgen, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># praudit /dev/auditpipe</span></code></pre></div></div><div class=paragraph><p>In der Voreinstellung kann nur der Benutzer <code>root</code> auf die Audit-Pipe-Geräte-Knotenpunkte zugreifen. Um sie allen Mitgliedern der Gruppe <code>audit</code> zugänglich zu machen, fügen Sie eine <code>devfs</code>-Regel in <span class=filename>/etc/devfs.rules</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;auditpipe*&#39; mode 0440 group audit</pre></div></div><div class=paragraph><p>Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> für weitere Informationen, wie das devfs-Dateisystem konfiguriert wird.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Es ist sehr leicht, Rückmeldungszyklen von Audit-Ereignissen hervorzurufen, in welcher das Betrachten des Resultates eines Audit-Ereignisses in die Erzeugung von mehr Audit-Ereignissen mündet. Wenn zum Beispiel der gesamte Netzwerk-I/O auditiert wird, während <code>praudit</code> in einer SSH-Sitzung gestartet wurde, dann wird ein kontinuierlicher, mächtiger Strom von Audit-Ereignissen erzeugt, da jedes ausgegebene Ereignis wiederum neue Ereignisse erzeugt. Daher ist anzuraten, <code>praudit</code> an einem Audit-Pipe-Gerät nur von Sitzungen anzuwenden (ohne feingranuliertes I/O-Auditing), um dies zu vermeiden.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_rotation_und_komprimierung_von_audit_pfad_dateien>34.4.2. Rotation und Komprimierung von Audit-Pfad-Dateien<a class=anchor href=#_rotation_und_komprimierung_von_audit_pfad_dateien></a></h4><div class=paragraph><p>Audit-Pfade werden vom Kernel geschrieben und vom Audit-Daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> verwaltet. Administratoren sollten nicht versuchen, <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> oder andere Werkzeuge zu benutzen, um Audit-Protokolldateien direkt zu rotieren. Stattdessen sollte <code>audit</code> benutzt werden, um die Auditierung zu beenden, das Audit-System neu zu konfigurieren und eine Log-Rotation durchzuführen. Der folgende Befehl veranlasst den Audit-Daemon, eine neue Protokolldatei anzulegen und dem Kernel zu signalisieren, die neue Datei zu nutzen. Die alte Datei wird beendet und umbenannt. Ab diesem Zeitpunkt kann sie vom Administrator bearbeitet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># audit -n</span></code></pre></div></div><div class=paragraph><p>Falls der <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a>-Daemon gegenwärtig nicht läuft, wird dieser Befehl scheitern und eine Fehlermeldung wird ausgegeben.</p></div><div class=paragraph><p>Durch das Hinzufügen der folgenden Zeile in <span class=filename>/etc/crontab</span> wird die Log-Rotation alle zwölf Stunden durchgeführt:</p></div><div class="literalblock programlisting"><div class=content><pre>0     */12       *       *       *       root    /usr/sbin/audit -n</pre></div></div><div class=paragraph><p>Die Änderung wird wirksam, sobald <span class=filename>/etc/crontab</span> gespeichert wird.</p></div><div class=paragraph><p>Die automatische Rotation der Audit-Pfad-Datei in Abhängigkeit von der Dateigröße ist möglich durch die Angabe der Option <code>filesz</code> in <span class=filename>audit_control</span>. Dieser Vorgang ist in <a href=#audit-auditcontrol>Die <span class=filename>audit_control</span>-Datei</a> beschrieben.</p></div><div class=paragraph><p>Da Audit-Pfad-Dateien sehr groß werden können, ist es oft wünschenswert, Pfade zu komprimieren oder anderweitig zu archivieren, sobald sie vom Audit-Daemon geschlossen wurden. Das Skript <span class=filename>audit_warn</span> kann genutzt werden, um angepasste Aktionen für eine Vielzahl von audit-bezogenen Ereignissen auszuführen, einschließlich der sauberen Beendigung von Audit-Pfaden, wenn diese geschlossen werden. Zum Beispiel kann man die folgenden Zeilen in <span class=filename>/etc/security/audit_warn</span> aufnehmen, um Audit-Pfade beim Beenden zu komprimieren:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Compress audit trail files on close.
#
if [ &#34;$1&#34; = closefile ]; then
        gzip -9 $2
fi</pre></div></div><div class=paragraph><p>Andere Archivierungsaktivitäten können das Kopieren zu einem zentralen Server, die Löschung der alten Pfad-Dateien oder die Reduzierung des alten Audit-Pfades durch Entfernung nicht benötigter Datensätze einschließen. Dieses Skript wird nur dann ausgeführt, wenn die Audit-Pfad-Dateien sauber beendet wurden, daher wird es nicht auf Pfaden laufen, welche durch ein unsauberes Herunterfahren des Systems nicht beendet wurden.</p></div></div></div></div></div><div class=sect1><h2 id=disks>Kapitel 35. Speichermedien<a class=anchor href=#disks></a></h2><div class=sectionbody><div class=sect2><h3 id=disks-synopsis>35.1. Übersicht<a class=anchor href=#disks-synopsis></a></h3><div class=paragraph><p>Dieses Kapitel behandelt die Benutzung von Laufwerken unter FreeBSD. Hierzu zählen SCSI- und IDE-Geräte, CD- und DVD-Medien, speicherbasierte Laufwerke und USB-Geräte.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes wissen:</p></div><div class=ulist><ul><li><p>Wie Sie zusätzliche Laufwerke zu einem FreeBSD-System hinzufügen.</p></li><li><p>Wie Sie unter FreeBSD die Partition einer Festplatte vergrößern.</p></li><li><p>Wie Sie FreeBSD zur Verwendung von USB-Speichermedien konfigurieren.</p></li><li><p>Wie Sie CD- und DVD-Medien unter FreeBSD benutzen.</p></li><li><p>Wie Sie die unter FreeBSD erhältlichen Backup-Programme benutzen.</p></li><li><p>Wie Sie RAM-Disks einrichten.</p></li><li><p>Was Dateisystem-Schnappschüsse sind und wie sie effizient eingesetzt werden.</p></li><li><p>Wie Sie mit Quotas die Benutzung von Laufwerken einschränken.</p></li><li><p>Wie Sie Festplatten und Swap verschlüsseln, um Daten vor Angreifern zu schützen.</p></li><li><p>Wie Sie ein hochverfügbares Speichernetzwerk konfigurieren.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen,</p></div><div class=ulist><ul><li><p>sollten Sie wissen, wie Sie einen <a href=./#kernelconfig>neuen FreeBSD-Kernel konfigurieren und installieren</a>.</p></li></ul></div></div><div class=sect2><h3 id=disks-adding>35.2. Hinzufügen von Laufwerken<a class=anchor href=#disks-adding></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie ein neues SATA-Laufwerk zu einer Maschine hinzufügen, die momentan nur ein Laufwerk hat. Dazu schalten Sie zuerst den Rechner aus und installieren das Laufwerk entsprechend der Anleitungen Ihres Rechners, Ihres Controllers und des Laufwerkherstellers. Starten Sie das System neu und melden Sie sich als Benutzer <code>root</code> an.</p></div><div class=paragraph><p>Kontrollieren Sie <span class=filename>/var/run/dmesg.boot</span>, um sicherzustellen, dass das neue Laufwerk gefunden wurde. In diesem Beispiel erscheint das neu hinzugefügte SATA-Laufwerk als <span class=filename>ada1</span>.</p></div><div class=paragraph><p>In diesem Beispiel wird eine einzige große Partition auf der Festplatte erstellt. Verwendet wird das <a href=https://de.wikipedia.org/wiki/GUID_Partition_Table>GPT</a>-Partitionsschema, welches gegenüber dem älteren und weniger vielseitigen MBR-Schema bevorzug wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn die hinzugefügte Festplatte nicht leer ist, können alte Partitionsinformationen mit <code>gpart delete</code> entfernt werden. Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Zuerst wird das Partitionsschema erstellt und dann eine einzelne Partition angefügt. Zur Verbesserung der Leistung auf neueren Festplatten mit größeren Blockgrößen, wird die Partition an einer Megabyte-Grenze ausgerichtet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT ada1</span>
<span class=c># gpart add -t freebsd-ufs -a 1M ada1</span></code></pre></div></div><div class=paragraph><p>Je nach Anwendung kann es wünschenswert sein, mehrere kleinere Partitionen zu haben. In <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> finden Sie Optionen zum Erstellen von kleineren Partitionen.</p></div><div class=paragraph><p>Informationen über die Partitionen der Festplatte werden mit <code>gpart show</code> angezeigt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gpart show ada1
<span class=o>=&gt;</span>        34  1465146988  ada1  GPT  <span class=o>(</span>699G<span class=o>)</span>
          34        2014        - free -  <span class=o>(</span>1.0M<span class=o>)</span>
        2048  1465143296     1  freebsd-ufs  <span class=o>(</span>699G<span class=o>)</span>
  1465145344        1678        - free -  <span class=o>(</span>839K<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Ein Dateisystem wird in der neuen Partition erstellt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/ada1p1</span></code></pre></div></div><div class=paragraph><p>Ein leeres Verzeichnis wird als Mountpunkt erstellt, also ein Speicherort für die Montage der neuen Festplatte im originalen Dateisystem:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /newdisk</span></code></pre></div></div><div class=paragraph><p>Abschließend wird ein Eintrag in <span class=filename>/etc/fstab</span> hinzugefügt, damit die neue Festplatte automatisch beim Start eingehängt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1p1	/newdisk      ufs   rw	    2	  2</pre></div></div><div class=paragraph><p>Die neue Festplatte kann manuell montiert werden, ohne das System neu zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /newdisk</span></code></pre></div></div></div><div class=sect2><h3 id=disks-growing>35.3. Partitionen vergrößern<a class=anchor href=#disks-growing></a></h3><div class=paragraph><p>Die Kapazität einer Festplatte kann sich ohne Änderungen an bereits vorhandenen Daten erhöhen. Dies geschieht üblicherweise mit virtuellen Maschinen, wenn sich herausstellt, dass die virtuelle Festplatte zu klein ist und vergrößert werden soll. Zuweilen wird auch ein Abbild einer Platte auf einen USB-Stick geschrieben, ohne dabei die volle Kapazität zu nutzen. Dieser Abschnitt beschreibt, wie man Platten vergrößert, bzw. <em>erweitert</em>, um die Vorteile der erhöhten Kapazität zu nutzen.</p></div><div class=paragraph><p>Überprüfen Sie <span class=filename>/var/run/dmesg.boot</span>, um den Gerätenamen der Festplatte zu bestimmen, die vergrößert werden soll. In diesem Beispiel gibt es nur eine SATA-Festplatte im System, so dass die Platte als <span class=filename>ada0</span> angezeigt wird.</p></div><div class=paragraph><p>Um die aktuelle Konfiguration der Partitionen auf der Festplatte anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>      34  83886013  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span> <span class=o>[</span>CORRUPT]
        34       128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
       162  79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
  79691810   4194236     3  freebsd-swap  <span class=o>(</span>2G<span class=o>)</span>
  83886046         1        - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn die Festplatte mit dem <a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>GPT</a>-Partitionsschema formatiert wurde kann es vorkommen, dass sie als "corrupted" angezeigt wird, weil sich die Sicherung der GPT-Partitionstabellen nicht mehr am Ende des Laufwerks befinden. Reparieren Sie in so einem Fall die Partitionstabelle mit <code>gpart</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart recover ada0</span>
ada0 recovered</code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Nun steht der zusätzliche Speicherplatz zur Verfügung und kann verwendet werden, um eine neue Partition anzulegen oder eine bestehende Partition zu erweitern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
   79691810    4194236     3  freebsd-swap  <span class=o>(</span>2G<span class=o>)</span>
   83886046   18513921        - free -  <span class=o>(</span>8.8G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Partitionen können nur auf zusammenhängenden, freien Speicherplatz vergrößert werden. In diesem Beispiel wird die letzte Partition der Platte als Swap-Speicher genutzt, aber die zweite Partition ist die, dessen Größe verändert werden soll. Weil der Swap-Speicher nur temporäre Daten enthält, kann er gefahrlos ausgehangen, gelöscht und nachdem die zweite Partition vergrößert wurde, als dritte Partition neu erstellt werden.</p></div><div class=paragraph><p>Deaktivieren Sie Swap-Speicher Partition:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapoff /dev/ada0p3</span></code></pre></div></div><div class=paragraph><p>Löschen Sie die dritte Partition, angegeben mit dem Schalter <code>-i</code>, der Festplatte <em>ada0</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart delete -i 3 ada0</span>
ada0p3 deleted
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
	79691810   22708157        - free -  <span class=o>(</span>10G<span class=o>)</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Es besteht die Gefahr von Datenverlust, wenn die Partitionstabelle eines eingehangenen Dateisystems verändert wird. Es empfiehlt sich daher, die folgenden Schritte auf einem ausgehangenen Dateisystem durchzuführen, während die Umsetzung über eine Live-CD-ROM oder von einem USB-Gerät erfolgt. Wenn es jedoch absolut notwendig ist, kann ein eingehangenes Dateisystem auch vergrößert werden, nachdem die Sicherheitsfunktionen von GEOM deaktiviert wurden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.debugflags=16</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Vergrößern Sie die Partition und lassen Sie Platz, um die Swap-Partition in der gewünschten Größe neu erstellen zu können. Die zu ändernde Partition wird mit <code>-i</code> und die neue gewünschte Größe mit <code>-s</code> angegeben. Optional wird die Ausrichtung der Partition mit <code>-a</code> festgelegt. Dieser Schritt ändert nur die Größe der Partition. Das Dateisystem innerhalb der Partition wird in einem separaten Schritt erweitert.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart resize -i 2 -s 47G -a 4k ada0</span>
ada0p2 resized
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   98566144     2  freebsd-ufs  <span class=o>(</span>47G<span class=o>)</span>
   98566306    3833661        - free -  <span class=o>(</span>1.8G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Erstellen Sie die Swap-Partition neu und aktivieren Sie sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart add -t freebsd-swap -a 4k ada0</span>
ada0p3 added
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   98566144     2  freebsd-ufs  <span class=o>(</span>47G<span class=o>)</span>
   98566306    3833661     3  freebsd-swap  <span class=o>(</span>1.8G<span class=o>)</span>
<span class=c># swapon /dev/ada0p3</span></code></pre></div></div><div class=paragraph><p>Erweitern Sie das UFS-Dateisystem, um die Kapazität der vergrößerten Partition zu nutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growfs /dev/ada0p2</span>
Device is mounted read-write<span class=p>;</span> resizing will result <span class=k>in </span>temporary write suspension <span class=k>for</span> /.
It<span class=s1>&#39;s strongly recommended to make a backup before growing the file system.
OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes
super-block backups (for fsck -b #) at:
 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432</span></code></pre></div></div><div class=paragraph><p>Wenn das Dateisystem ZFS ist, wird die Größenänderung mit dem Unterkommando <code>online</code> und <code>-e</code> ausgelöst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs online -e zroot /dev/ada0p2</span></code></pre></div></div><div class=paragraph><p>Sowohl die Partition als auch das Dateisystem wurden jetzt vergrößert, um den neu zur Verfügung stehenden Speicherplatz zu nutzen.</p></div></div><div class=sect2><h3 id=usb-disks>35.4. USB Speichermedien<a class=anchor href=#usb-disks></a></h3><div class=paragraph><p>Der Universal Serial Bus (USB) wird von vielen externen Speichern benutzt: Festplatten, USB-Thumbdrives sowie von CD- und DVD-Brennern. FreeBSD bietet Unterstützung für Geräte mit USB 1.x, 2.0 und 3.0.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Unterstützung für USB 3.0 ist mit einiger Hardware, einschließlich Haswell (Lynx Point) Chipsätzen, nicht kompatibel. Wenn FreeBSD beim Booten mit dem Fehler <code>failed with error 19</code> abbricht, müssen Sie xHCI/USB3 im BIOS deaktivieren.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Unterstützung für USB-Massenspeicher ist im <span class=filename>GENERIC</span>-Kernel enthalten. Für einen angepassten Kernel müssen die nachstehenden Zeilen in der Kernelkonfigurationsdatei enthalten sein:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus    # SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da
device cd	# needed for CD and DVD burners</pre></div></div><div class=paragraph><p>FreeBSD benutzt den <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a>-Treiber, der das SCSI-Subsystem verwendet um auf USB-Geräte zuzugreifen. Da alle USB-Geräte vom System als SCSI-Geräte erkannt werden, dürfen Sie <em>nicht</em> <code>device atapicam</code> in die Kernelkonfigurationsdatei aufnehmen, wenn es sich bei dem Gerät um einen CD- oder DVD-Brenner handelt.</p></div><div class=paragraph><p>Der übrige Abschnitt beschreibt, wie Sie überprüfen können ob ein USB-Gerät von FreeBSD erkannt wird und wie Sie das Gerät so konfigurieren, dass es verwendet werden kann.</p></div><div class=sect3><h4 id=_konfiguration_von_geräten>35.4.1. Konfiguration von Geräten<a class=anchor href=#_konfiguration_von_geräten></a></h4><div class=paragraph><p>Um die USB-Konfiguration zu testen, schließen Sie das USB-Gerät an. Verwenden Sie <code>dmesg</code> um zu überprüfen, ob das Gerät in den Systemmeldungen erscheint. Dies sollte in etwa so aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: &lt;STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3&gt; on usbus0
umass0:  SCSI over Bulk-Only<span class=p>;</span> quirks <span class=o>=</span> 0x0100
umass0:4:0:-1: Attached to scbus4
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; Fixed Direct Access SCSI-4 device
da0: Serial Number WD-WXE508CAN263
da0: 40.000MB/s transfers
da0: 152627MB <span class=o>(</span>312581808 512 byte sectors: 255H 63S/T 19457C<span class=o>)</span>
da0: <span class=nv>quirks</span><span class=o>=</span>0x2&lt;NO_6_BYTE&gt;</code></pre></div></div><div class=paragraph><p>Fabrikat, Gerätedatei (<span class=filename>da0</span>), Geschwindigkeit und Kapazität werden je nach Gerät unterschiedlich sein.</p></div><div class=paragraph><p>Da ein USB-Gerät als SCSI-Gerät erkannt wird, kann <code>camcontrol</code> benutzt werden, um die mit dem System verbundenen USB-Massenspeicher anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;STECH Simple Drive 1.04&gt;          at scbus4 target 0 lun 0 <span class=o>(</span>pass3,da0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Alternativ kann <code>usbconfig</code> benutzt werden, um die Geräte aufzulisten. Weitere Informationen zu diesem Kommando finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># usbconfig</span>
ugen0.3: &lt;Simple Drive STECH&gt; at usbus0, <span class=nv>cfg</span><span class=o>=</span>0 <span class=nv>md</span><span class=o>=</span>HOST <span class=nv>spd</span><span class=o>=</span>HIGH <span class=o>(</span>480Mbps<span class=o>)</span> <span class=nv>pwr</span><span class=o>=</span>ON <span class=o>(</span>2mA<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Wenn das Gerät noch nicht formatiert ist, finden Sie in <a href=#disks-adding>Hinzufügen von Laufwerken</a> Informationen, wie Sie USB-Laufwerke formatieren und Partitionen einrichten. Wenn das Laufwerk bereits ein Dateisystem enthält, kann es von <code>root</code> nach den Anweisungen in <a href=./#mount-unmount>“Anhängen und Abhängen von Dateisystemen”</a> eingehängt werden.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Aus Sicherheitsgründen sollten Sie Benutzern, denen Sie nicht vertrauen, das Einhängen (z.B. durch die unten beschriebene Aktivierung von <code>vfs.usermount</code>) beliebiger Medien verbieten. Die meisten Dateisysteme wurden nicht entwickelt, um sich vor böswilligen Geräten zu schützen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um auch normalen Anwendern das Einhängen des Laufwerks zu gestatten, könnten Sie beispielsweise mit <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> alle potentiellen Benutzer dieser Gerätedateien in die Gruppe <code>operator</code> aufnehmen. Außerdem muss sichergestellt werden, dass <code>operator</code> Schreib- und Lesezugriff auf diese Gerätedateien haben. Hierfür werden die folgenden Zeilen in <span class=filename>/etc/devfs.rules</span> hinzugefügt:</p></div><div class="literalblock programlisting"><div class=content><pre>[localrules=5]
add path &#39;da*&#39; mode 0660 group operator</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Verfügt das System über interne SCSI-Laufwerke, so verändern Sie die zweite Zeile wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;da[3-9]*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>Dies wird die ersten drei SCSI-Laufwerke (<span class=filename>da0</span> bis <span class=filename>da2</span>) davon ausschließen, in die Gruppe <code>operator</code> aufgenommen zu werden. Ersetzen Sie <code>3</code> durch die Anzahl der SCSI-Laufwerke. Weitere Informationen zu dieser Datei finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Aktivieren Sie nun die Regeln in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;localrules&#34;</pre></div></div><div class=paragraph><p>Als nächstes müssen Sie das System anweisen, auch normalen Benutzern das mounten von Dateisystemen zu erlauben, indem Sie die folgende Zeile in <span class=filename>/etc/sysctl.conf</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>vfs.usermount=1</pre></div></div><div class=paragraph><p>Da diese Einstellung erst nach einem Neustart wirksam wird, können Sie diese Variable mit <code>sysctl</code> auch direkt setzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1</code></pre></div></div><div class=paragraph><p>Zuletzt müssen Sie noch ein Verzeichnis anlegen, in das das USB-Laufwerk eingehängt werden soll. Dieses Verzeichnis muss dem Benutzer gehören, der das USB-Laufwerk in den Verzeichnisbaum einhängen will. Dazu legen Sie als <code>root</code> ein Unterverzeichnis <span class=filename>/mnt/username</span> an, wobei Sie <em>username</em> durch den Login des jeweiligen Benutzers sowie <em>usergroup</em> durch die primäre Gruppe des Benutzers ersetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /mnt/username</span>
<span class=c># chown username:usergroup /mnt/username</span></code></pre></div></div><div class=paragraph><p>Wenn Sie nun beispielsweise einen USB-Stick anschließen, wird automatisch die Gerätedatei <span class=filename>/dev/da0s1</span> erzeugt. Ist das Gerät mit einem FAT-Dateisystem formatiert, kann es der Benutzer mit dem folgenden Befehl in den Verzeichnisbaum einhängen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mount <span class=nt>-t</span> msdosfs <span class=nt>-o</span> <span class=nt>-m</span><span class=o>=</span>644,-M<span class=o>=</span>755 /dev/da0s1 /mnt/username</code></pre></div></div><div class=paragraph><p>Bevor das Gerät entfernt werden kann, <em>muss</em> es abgehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt/username</span></code></pre></div></div><div class=paragraph><p>Nach Entfernen des Geräts stehen in den Systemmeldungen Einträge, ähnlich der folgenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: at uhub3, port 2, addr 3 <span class=o>(</span>disconnected<span class=o>)</span>
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; s/n WD-WXE508CAN263          detached
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: Periph destroyed</code></pre></div></div></div><div class=sect3><h4 id=_automatisches_einhängen_von_wechselmedien>35.4.2. Automatisches Einhängen von Wechselmedien<a class=anchor href=#_automatisches_einhängen_von_wechselmedien></a></h4><div class=paragraph><p>Damit USB-Geräte automatisch eingehängt werden, muss der Kommentar für folgende Zeile in <span class=filename>/etc/auto_master</span> entfernt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/media		<span class=nt>-media</span>		<span class=nt>-nosuid</span></code></pre></div></div><div class=paragraph><p>Anschließend fügen Sie folgende Zeilen in <span class=filename>/etc/devd.conf</span> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>notify 100 <span class=o>{</span>
	match <span class=s2>&#34;system&#34;</span> <span class=s2>&#34;GEOM&#34;</span><span class=p>;</span>
	match <span class=s2>&#34;subsystem&#34;</span> <span class=s2>&#34;DEV&#34;</span><span class=p>;</span>
	action <span class=s2>&#34;/usr/sbin/automount -c&#34;</span><span class=p>;</span>
<span class=o>}</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Falls <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> bereits ausgeführt werden, müssen Sie die Konfiguration neu einlesen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount restart</span>
<span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> wird beim Booten automatisch gestartet, wenn Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>autofs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Damit <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> funktioniert, muss <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> aktiviert sein, was aber in der Voreinstellung der Fall ist.</p></div><div class=paragraph><p>Starten Sie jetzt die Dienste:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount start</span>
<span class=c># service automountd start</span>
<span class=c># service autounmountd start</span>
<span class=c># service devd start</span></code></pre></div></div><div class=paragraph><p>Jedes Dateisystem, das automatisch eingehängt werden kann, erscheint als ein Verzeichnis unterhalb von <span class=filename>media</span>. Das Verzeichnis wird nach dem Dateisystemlabel benannt, bzw. nach dem Gerätenamen, falls kein Label existiert.</p></div><div class=paragraph><p>Das Dateisystem wird transparent beim ersten Zugriff in den Verzeichnisbaum eingehängt und auch nach gewisser Zeit der Inaktivität wieder ausgehängt. Laufwerke können auch manuell ausgehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># automount -fu</span></code></pre></div></div><div class=paragraph><p>Diese Methode wird in der Regel bei Speicherkarten und USB-Sticks verwendet. Sie funktioniert aber mit allen Blockgeräten, einschließlich optischen Laufwerken und iSCSI-LUNs.</p></div></div></div><div class=sect2><h3 id=creating-cds>35.5. Erstellen und Verwenden von CDs<a class=anchor href=#creating-cds></a></h3><div class=paragraph><p>CDs besitzen einige Eigenschaften, die sie von konventionellen Laufwerken unterscheiden. Sie wurden so entworfen, dass sie ununterbrochen, ohne Verzögerungen durch Kopfbewegungen zwischen den Spuren, gelesen werden können. CDs besitzen Spuren, aber damit ist der Teil Daten gemeint, der ununterbrochen gelesen wird, und nicht eine physikalische Eigenschaft der CD. Das ISO 9660-Dateisystem wurde entworfen, um mit diesen Unterschieden umzugehen.</p></div><div class=paragraph><p>Die FreeBSD Ports-Sammlung bietet einige Werkzeuge zum Brennen und Kopieren von Audio- und Daten-CDs. Dieses Kapitel beschreibt die Verwendung von mehreren Kommandozeilen-Werkzeugen. Wenn Sie eine graphische Oberfläche zum Brennen von CDs benutzen, können Sie <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xcdroast/>sysutils/xcdroast</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a> installieren.</p></div><div class=sect3><h4 id=atapicam>35.5.1. Unterstützte Geräte<a class=anchor href=#atapicam></a></h4><div class=paragraph><p>Der <span class=filename>GENERIC</span>-Kernel enthält Unterstützung für SCSI, USB und ATAPICD Lesegeräte und Brenner. Wird ein angepasster Kernel erstellt, unterscheiden sich die Optionen für die Kernelkonfigurationsdatei je nach Art des Geräts.</p></div><div class=paragraph><p>Für einen SCSI-Brenner müssen folgende Optionen vorhanden sein:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	  # SCSI bus (required for ATA/SCSI)
device da	  # Direct Access (disks)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd	  # needed for CD and DVD burners</pre></div></div><div class=paragraph><p>Für einen USB-Brenner müssen folgende Optionen vorhanden sein:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	  # SCSI bus (required for ATA/SCSI)
device da	  # Direct Access (disks)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd&gt;	  # needed for CD and DVD burners
device uhci	  # provides USB 1.x support
device ohci	  # provides USB 1.x support
device ehci	  # provides USB 2.0 support
device xhci	  # provides USB 3.0 support
device usb	  # USB Bus (required)
device umass	  # Disks/Mass storage - Requires scbus and da</pre></div></div><div class=paragraph><p>Für einen ATAPI-Brenner müssen folgende Optionen vorhanden sein:</p></div><div class="literalblock programlisting"><div class=content><pre>device ata	  # Legacy ATA/SATA controllers
device scbus	  # SCSI bus (required for ATA/SCSI)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd	  # needed for CD and DVD burners</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Unter FreeBSD Versionen kleiner 10.x wird auch diese Option in der Kernelkonfigurationsdatei benötigt, falls der Brenner ein ATAPI-Gerät ist:</p></div><div class="literalblock programlisting"><div class=content><pre>device atapicam</pre></div></div><div class=paragraph><p>Alternativ kann folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzugefügt werden, um den Treiber beim Booten automatisch zu laden:</p></div><div class="literalblock programlisting"><div class=content><pre>atapicam_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Hierzu ist ein Neustart des Systems erforderlich, da dieser Treiber nur beim Booten geladen werden kann.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Mit <code>dmesg</code> können Sie prüfen, ob das Gerät von FreeBSD erkannt wurde. Unter FreeBSD Versionen kleiner 10.x lautet der Gerätename <span class=filename>acd0</span> anstelle von <span class=filename>cd0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% dmesg | <span class=nb>grep cd
</span>cd0 at ahcich1 bus 0 scbus1 target 0 lun 0
cd0: &lt;HL-DT-ST DVDRAM GU70N LT20&gt; Removable CD-ROM SCSI-0 device
cd0: Serial Number M3OD3S34152
cd0: 150.000MB/s transfers <span class=o>(</span>SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes<span class=o>)</span>
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</code></pre></div></div></div><div class=sect3><h4 id=cdrecord>35.5.2. Eine CD brennen<a class=anchor href=#cdrecord></a></h4><div class=paragraph><p>Unter FreeBSD kann <code>cdrecord</code> zum Brennen von CDs benutzt werden. Dieses Programm wird aus dem Port oder Paket <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> installiert.</p></div><div class=paragraph><p>Obwohl <code>cdrecord</code> viele Optionen besitzt, ist die grundlegende Benutzung sehr einfach. Geben Sie den Namen der zu brennenden ISO-Datei an. Wenn das System über mehrere Brenner verfügt, müssen Sie auch den Namen des Gerätes angeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord dev=device imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie <code>-scanbus</code> um den Gerätenamen des Brenners zu bestimmen. Die Ausgabe könnte wie folgt aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord -scanbus</span>
ProDVD-ProBD-Clone 3.00 <span class=o>(</span>amd64-unknown-freebsd10.0<span class=o>)</span> Copyright <span class=o>(</span>C<span class=o>)</span> 1995-2010 Jörg Schilling
Using libscg version <span class=s1>&#39;schily-0.9&#39;</span>
scsibus0:
        0,0,0     0<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39236LW       &#39;</span> <span class=s1>&#39;0004&#39;</span> Disk
        0,1,0     1<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39173W        &#39;</span> <span class=s1>&#39;5958&#39;</span> Disk
        0,2,0     2<span class=o>)</span> <span class=k>*</span>
        0,3,0     3<span class=o>)</span> <span class=s1>&#39;iomega  &#39;</span> <span class=s1>&#39;jaz 1GB         &#39;</span> <span class=s1>&#39;J.86&#39;</span> Removable Disk
        0,4,0     4<span class=o>)</span> <span class=s1>&#39;NEC     &#39;</span> <span class=s1>&#39;CD-ROM DRIVE:466&#39;</span> <span class=s1>&#39;1.26&#39;</span> Removable CD-ROM
        0,5,0     5<span class=o>)</span> <span class=k>*</span>
        0,6,0     6<span class=o>)</span> <span class=k>*</span>
        0,7,0     7<span class=o>)</span> <span class=k>*</span>
scsibus1:
        1,0,0   100<span class=o>)</span> <span class=k>*</span>
        1,1,0   101<span class=o>)</span> <span class=k>*</span>
        1,2,0   102<span class=o>)</span> <span class=k>*</span>
        1,3,0   103<span class=o>)</span> <span class=k>*</span>
        1,4,0   104<span class=o>)</span> <span class=k>*</span>
        1,5,0   105<span class=o>)</span> <span class=s1>&#39;YAMAHA  &#39;</span> <span class=s1>&#39;CRW4260         &#39;</span> <span class=s1>&#39;1.0q&#39;</span> Removable CD-ROM
        1,6,0   106<span class=o>)</span> <span class=s1>&#39;ARTEC   &#39;</span> <span class=s1>&#39;AM12S           &#39;</span> <span class=s1>&#39;1.06&#39;</span> Scanner
        1,7,0   107<span class=o>)</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie die drei durch Kommas separierten Zahlen, die für den CD-Brenner angegeben sind, als Argument für <code>dev</code>. Im Beispiel ist das Yamaha-Gerät <code>1,5,0</code>, so dass die passende Eingabe <code>dev=1,5,0</code> ist. Einfachere Wege das Argument anzugeben, sowie Informationen über Audiospuren und das Einstellen der Geschwindigkeit, sind in der Manualpage von <code>cdrecord</code> beschrieben.</p></div><div class=paragraph><p>Alternativ können Sie den folgenden Befehl ausführen, um die Geräteadresse des Brenners zu ermitteln:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 <span class=o>(</span>cd0,pass0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Verwenden Sie die numerischen Werte für <code>scbus</code>, <code>target</code> und <code>lun</code>. Für dieses Beispiel wäre <code>1,0,0</code> als Gerätename zu verwenden.</p></div></div><div class=sect3><h4 id=mkisofs>35.5.3. Daten auf ISO-Dateisystem schreiben<a class=anchor href=#mkisofs></a></h4><div class=paragraph><p>Die Datendateien müssen vorbereitet sein, bevor sie auf eine CD gebrannt werden. In FreeBSD wird <code>mkisofs</code> vom Paket oder Port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> installiert. Dieses Programm kann aus einem UNIX® Verzeichnisbaum ein ISO 9660-Dateisystem erzeugen. Im einfachsten Fall müssen Sie lediglich den Namen der zu erzeugenden ISO-Datei und den Pfad zu den Dateien angeben, die auf dem ISO 9660-Dateisystem platziert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -o imagefile.iso /path/to/tree</span></code></pre></div></div><div class=paragraph><p>Bei diesem Kommando werden die Dateinamen auf Namen abgebildet, die den Restriktionen des ISO 9660-Dateisystem entsprechen. Dateien, die diesem Standard nicht entsprechen bleiben unberücksichtigt.</p></div><div class=paragraph><p>Es gibt einige Optionen, um die Beschränkungen dieses Standards zu überwinden. Die unter UNIX® Systemen üblichen Rock-Ridge-Erweiterungen werden durch <code>-R</code> aktiviert und <code>-J</code> aktiviert die von Microsoft® Systemen benutzten Joliet-Erweiterungen.</p></div><div class=paragraph><p>Für CDs, die nur auf FreeBSD-Systemen verwendet werden sollen, kann <code>-U</code> genutzt werden, um alle Beschränkungen für Dateinamen aufzuheben. Zusammen mit <code>-R</code> wird ein Abbild des Dateisystems, identisch zu angegebenen FreeBSD-Dateibaum erstellt, selbst wenn dies den ISO 9660 Standard verletzt.</p></div><div class=paragraph><p>Die letzte übliche Option ist <code>-b</code>. Sie wird benutzt, um den Ort eines Bootimages einer "El Torito" bootbaren CD anzugeben. Das Argument zu dieser Option ist der Pfad zu einem Bootimage ausgehend von der Wurzel des Baumes, der auf die CD geschrieben werden soll. In der Voreinstellung erzeugt <code>mkisofs</code> ein ISO-Image im "Diskettenemulations"-Modus. Dabei muss das Image genau 1200, 1440 oder 2880 KB groß sein. Einige Bootloader, darunter der auf den FreeBSD Installationsmedien verwendete, kennen keinen Emulationsmodus. Daher sollte in diesen Fällen <code>-no-emul-boot</code> verwendet werden. Wenn <span class=filename>/tmp/myboot</span> ein bootbares FreeBSD-System enthält, dessen Bootimage sich in <span class=filename>/tmp/myboot/boot/cdboot</span> befindet, dann würde folgendes Kommando <span class=filename>/tmp/bootable.iso</span> erstellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</span></code></pre></div></div><div class=paragraph><p>Das resultierende ISO-Abbild kann als speicherbasiertes Laufwerk eingehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Jetzt können Sie überprüfen, dass <span class=filename>/mnt</span> und <span class=filename>/tmp/myboot</span> identisch sind.</p></div><div class=paragraph><p>Sie können das Verhalten von <code>mkisofs</code> mit einer Vielzahl von Optionen beeinflussen. Details dazu entnehmen Sie bitte <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es ist möglich eine Daten-CD in eine Datei zu kopieren, die einem Image entspricht, das mit <code>mkisofs</code> erstellt wurde. Verwenden Sie dazu <code>dd</code> mit dem Gerätenamen als Eingabedatei und den Namen der ISO als Ausgabedatei:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/cd0 of=file.iso bs=2048</span></code></pre></div></div><div class=paragraph><p>Das resultierende Abbild kann auf eine CD gebrannt werden, wie in <a href=#cdrecord>Eine CD brennen</a> beschrieben.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mounting-cd>35.5.4. Einhängen von Daten-CDs<a class=anchor href=#mounting-cd></a></h4><div class=paragraph><p>Sobald ein Abbild auf eine CD gebrannt wurde, kann es durch Angabe des Dateisystemtyp, des CD-Laufwerks und des Mountpunktes eingehangen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Da <code>mount</code> davon ausgeht, dass ein Dateisystem vom Typ <code>ufs</code> ist, würde die Fehlermeldung <code>Incorrect super block</code> erscheinen, wenn Sie beim Einhängen einer Daten-CD auf die Angabe <code>-t cd9660</code> verzichten.</p></div><div class=paragraph><p>Auf diese Weise können Daten-CDs von jedem Hersteller verwendet werden. Es kann allerdings zu Problemen mit CDs kommen, die verschiedene ISO 9660-Erweiterungen benutzen. So speichern Joliet-CDs alle Dateinamen unter Verwendung von zwei Byte langen Unicode-Zeichen. Tauchen statt bestimmter Zeichen nur Fragezeichen auf, so muss über die Option <code>-C</code> der benötigte Zeichensatz angegeben werden. Weitere Informationen zu diesem Problem finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Damit der Kernel diese Zeichenkonvertierung (festgelegt durch die Option <code>-C</code>) erkennt, müssen Sie das Kernelmodul <span class=filename>cd9660_iconv.ko</span> laden. Dazu fügen Sie folgende Zeile in <span class=filename>loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>cd9660_iconv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Danach müssen Sie allerdings Ihr System neu starten. Alternativ können Sie das Kernelmodul auch direkt über <code>kldload</code> laden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Manchmal werden Sie die Meldung <code>Device not configured</code> erhalten, wenn Sie versuchen, eine Daten-CD einzuhängen. Für gewöhnlich liegt das daran, dass das Laufwerk keine CD erkannt hat, oder dass das Laufwerk auf dem Bus nicht erkannt wird. Es kann einige Sekunden dauern, bevor das Laufwerk die CD erkennt. Seien Sie also geduldig.</p></div><div class=paragraph><p>Manchmal wird ein SCSI-CD nicht erkannt, weil es keine Zeit hatte, auf das Zurücksetzen des Busses zu antworten. Um dieses Problem zu lösen, fügen Sie die folgende Zeile in die Kernelkonfiguration ein und erstellen Sie einen angepassten Kernel nach den Anweisungen in <a href=./#kernelconfig-building>“Einen angepassten Kernel bauen und installieren”</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options SCSI_DELAY=15000</pre></div></div><div class=paragraph><p>Die Zeile bewirkt, dass nach dem Zurücksetzen des SCSI-Busses beim Booten 15 Sekunden gewartet wird, um dem CD-Laufwerk genügend Zeit zu geben, darauf zu antworten.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es ist möglich eine Datei auch direkt auf eine CD zu brennen, ohne vorher auf ihr ein ISO 9660-Dateisystem einzurichten. Man sagt auch, Daten werden roh auf die CD gebrannt. Einige Leute nutzen dies, um Datensicherungen durchzuführen.</p></div><div class=paragraph><p>Eine auf diese Weise gefertigte Daten-CD kann nicht in das Dateisystem eingehangen werden. Um auf die Daten einer solchen CD zuzugreifen, müssen die Daten vom rohen Gerät gelesen werden. Beispielsweise würde dieser Befehl eine komprimierte tar-Datei auf dem zweiten CD-Laufwerk in das aktuelle Verzeichnis extrahieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /dev/cd1</span></code></pre></div></div><div class=paragraph><p>Um eine Daten-CD in das System einzuhängen, müssen die Daten mit <code>mkisofs</code> geschrieben werden.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=duplicating-audiocds>35.5.5. Kopieren von Audio-CDs<a class=anchor href=#duplicating-audiocds></a></h4><div class=paragraph><p>Um eine Kopie einer Audio-CD zu erstellen, kopieren Sie die Stücke der CD in einzelne Dateien und brennen diese Dateien dann auf eine leere CD.</p></div><div class=paragraph><p><a href=#using-cdrecord>Procedure: Eine Audio-CD kopieren</a> beschreibt, wie eine Audio-CD kopiert und gebrannt wird. Wenn die Version älter als FreeBSD 10.0 ist und ein ATAPI-Gerät verwendet wird, muss zunächst das Modul <code>atapicam</code> nach den Anweisungen in <a href=#atapicam>Unterstützte Geräte</a> geladen werden.</p></div><div id=using-cdrecord class="olist arabic procedure"><div class=title>Procedure: Eine Audio-CD kopieren</div><ol class=arabic><li><p>Der Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> installiert <code>cdda2wav</code>. Mit diesem Kommando können Audiodaten in das aktuelle Verzeichnis extrahiert werden, wobei jede Datei in eine separate WAV-Datei geschrieben wird:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdda2wav <span class=nt>-vall</span> <span class=nt>-B</span> <span class=nt>-Owav</span></code></pre></div></div><div class=paragraph><p>Wenn das System nur über ein CD-Laufwerk verfügt, muss der Gerätename nicht angegeben werden. Lesen Sie die Manualpage von <code>cdda2wav</code> für Anweisungen, wie ein Gerät spezifiziert wird und weitere verfügbare Optionen für dieses Kommando.</p></div></li><li><p>Die erzeugten <span class=filename>.wav</span> Dateien schreiben Sie mit <code>cdrecord</code> auf eine leere CD:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdrecord <span class=nt>-v</span> <span class=nv>dev</span><span class=o>=</span>2,0 <span class=nt>-dao</span> <span class=nt>-useinfo</span> <span class=k>*</span>.wav</code></pre></div></div><div class=paragraph><p>Das Argument von <code>dev</code> gibt das verwendete Gerät an, das wie in <a href=#cdrecord>Eine CD brennen</a> ermittelt werden kann.</p></div></li></ol></div></div></div><div class=sect2><h3 id=creating-dvds>35.6. DVDs benutzen<a class=anchor href=#creating-dvds></a></h3><div class=paragraph><p>Nach der CD ist die DVD die nächste Generation optischer Speichermedien. Auf einer DVD können mehr Daten als auf einer CD gespeichert werden. DVDs werden als Standardmedium für Videos verwendet.</p></div><div class=paragraph><p>Für beschreibbare DVDs existieren fünf Medienformate:</p></div><div class=ulist><ul><li><p>DVD-R: Dies war das erste verfügbare Format. Das Format wurde vom <a href=http://www.dvdforum.org/forum.shtml>DVD-Forum</a> festgelegt. Die Medien sind nur einmal beschreibbar.</p></li><li><p>DVD-RW: Dies ist die wiederbeschreibbare Version des DVD-R Standards. Eine DVD-RW kann ungefähr 1000 Mal beschrieben werden.</p></li><li><p>DVD-RAM: Dies ist ein wiederbeschreibbares Format, das wie ein Wechsellaufwerk betrachtet werden kann. Allerdings sind die Medien nicht kompatibel zu den meisten DVD-ROM-Laufwerken und DVD-Video-Spielern, da das DVD-RAM-Format nur von wenigen Brennern unterstützt wird. Informationen zur Nutzung von DVD-RAM finden Sie in <a href=#creating-dvd-ram>DVD-RAM</a>.</p></li><li><p>DVD+RW: Ist ein wiederbeschreibbares Format, das von der <a href=https://de.wikipedia.org/wiki/DVD%2BRW_Alliance>DVD+RW Alliance</a> festgelegt wurde. Eine DVD+RW kann ungefähr 1000 Mal beschrieben werden.</p></li><li><p>DVD+R: Dieses Format ist die nur einmal beschreibbare Variante des DVD+RW Formats.</p></li></ul></div><div class=paragraph><p>Auf einer einfach beschichteten DVD können 4.700.000.000 Bytes gespeichert werden. Das sind 4,38 GB oder 4485 MB (1 Kilobyte sind 1024 Bytes).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die physischen Medien sind unabhängig von der Anwendung. Ein DVD-Video ist eine spezielle Anordnung von Dateien, die auf irgendein Medium, beispielsweise DVD-R, DVD+R oder DVD-RW geschrieben werden kann. Bevor Sie ein Medium auswählen, müssen Sie sicherstellen, dass der Brenner und der DVD-Spieler mit dem Medium umgehen können.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_konfiguration_2>35.6.1. Konfiguration<a class=anchor href=#_konfiguration_2></a></h4><div class=paragraph><p>Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>, um DVDs zu beschreiben. Das Kommando ist Bestandteil von <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dvd+rw-tools/>sysutils/dvd+rw-tools</a>, und kann mit allen DVD-Medien umgehen.</p></div><div class=paragraph><p>Diese Werkzeuge verwenden das SCSI-Subsystem, um auf die Geräte zuzugreifen. Daher muss <a href=#atapicam>ATAPI/CAM-Unterstützung</a> geladen, oder statisch in den Kernel kompiliert werden. Sollte der Brenner jedoch die USB-Schnittstelle nutzen, wird diese Unterstützung nicht benötigt. Weitere Informationen zur Konfiguration von USB-Geräten finden Sie in <a href=#usb-disks>USB Speichermedien</a>.</p></div><div class=paragraph><p>Für ATAPI-Geräte müssen ebenfalls DMA-Zugriffe aktiviert werden. Dazu wird die folgende Zeile in <span class=filename>/boot/loader.conf</span> eingefügt:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Bevor Sie dvd+rw-tools benutzen, lesen Sie bitte die Hardware-Informationen auf der Seite <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html>Hardware Compatibility Notes</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Für eine grafische Oberfläche sollten Sie sich <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a> ansehen, das eine benutzerfreundliche Schnittstelle zu <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> und vielen anderen Werkzeugen bietet.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_daten_dvds_brennen>35.6.2. Daten-DVDs brennen<a class=anchor href=#_daten_dvds_brennen></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> erstellt mit dem Programm <a href=#mkisofs>mkisofs</a> das Dateisystem und brennt anschließend die DVD. Vor dem Brennen braucht daher kein Abbild der Daten erstellt zu werden.</p></div><div class=paragraph><p>Wenn Sie von den Daten im Verzeichnis <span class=filename>/path/to/data</span> eine DVD+R oder eine DVD-R brennen wollen, benutzen Sie das nachstehende Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>In diesem Beispiel wird <code>-J -R</code> an <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> durchgereicht und dient zum Erstellen des Dateisystems (hier: ein ISO-9660-Dateisystem mit Joliet- und Rock-Ridge-Erweiterungen). Weiteres entnehmen Sie bitte der Hilfeseite <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div><div class=paragraph><p>Die Option <code>-Z</code> wird für die erste Aufnahme einer Single- oder Multisession benötigt. Ersetzen Sie <em>/dev/cd0</em> mit dem Gerätenamen des DVD-Gerätes. Die Nutzung von <code>-dvd-compat</code> schließt das Medium, weitere Daten können danach nicht mehr angehängt werden. Dies sollte auch eine bessere Kompatibilität mit anderen DVD-ROM-Laufwerken bieten.</p></div><div class=paragraph><p>Um ein vorher erstelltes Abbild der Daten zu brennen, beispielsweise <em>imagefile.iso</em>, verwenden Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Die Schreibgeschwindigkeit hängt von den verwendeten Medium sowie dem verwendeten Gerät ab und sollte automatisch gesetzt werden. Um die Schreibgeschwindigkeit vorzugeben, verwenden Sie <code>-speed=</code>. Beispiele finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um größere Dateien als 4.38GB zu unterstützen, ist es notwendig ein UDF/ISO-9660 Hybrid-Dateisystem zu erstellen. Dieses Dateisystem muss mit zusätzlichen Parametern <code>-udf -iso-level 3</code> bei <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> und allen relevanten Programmen, wie beispielsweise <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>) erzeugt werden. Dies ist nur notwendig, wenn Sie ein ISO-Image erstellen oder direkt auf eine DVD schreiben wollen. DVDs, die in dieser Weise hergestellt worden sind, müssen als UDF-Dateisystem mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_udf&amp;sektion=8&amp;format=html">mount_udf(8)</a> eingehangen werden. Sie sind nur auf Betriebssystemen, die UDF unterstützen brauchbar, ansonsten sieht es so aus, als ob sie kaputte Dateien enthalten würden.</p></div><div class=paragraph><p>Um diese Art von ISO-Datei zu erstellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mkisofs <span class=nt>-R</span> <span class=nt>-J</span> <span class=nt>-udf</span> <span class=nt>-iso-level</span> 3 <span class=nt>-o</span> imagefile.iso /path/to/data</code></pre></div></div><div class=paragraph><p>Um Daten direkt auf eine DVD zu brennen, geben Sie den folgenden Befehl ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Wenn ein ISO-Abbild bereits große Dateien enthält, sind keine weiteren Optionen für <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> notwendig, um das Abbild auf die DVD zu brennen.</p></div><div class=paragraph><p>Achten Sie darauf, eine aktuelle Version von <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> zu verwenden, welche <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> enthält, da ältere Versionen keinen Support für große Dateien enthalten. Falls die neueste Version nicht funktioniert, installieren Sie <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools-devel/>sysutils/cdrtools-devel</a> und lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_dvd_videos_brennen>35.6.3. DVD-Videos brennen<a class=anchor href=#_dvd_videos_brennen></a></h4><div class=paragraph><p>Ein DVD-Video ist eine spezielle Anordnung von Dateien, die auf den ISO-9660 und den micro-UDF (M-UDF) Spezifikationen beruht. Da DVD-Video auf eine bestimmte Datei-Hierarchie angewiesen ist, müssen DVDs mit speziellen Programmen wie <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a> erstellt werden.</p></div><div class=paragraph><p>Ist bereits ein Abbild des Dateisystems eines DVD-Videos vorhanden, kann es auf die gleiche Weise wie jedes andere Abbild gebrannt werden. Wenn <code>dvdauthor</code> verwendet wurde, um die DVD zu erstellen und die Resultate in <span class=filename>/path/to/video</span> liegen, kann das folgende Kommando verwendet werden, um ein DVD-Video zu brennen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -dvd-video /path/to/video</span></code></pre></div></div><div class=paragraph><p><code>-dvd-video</code> wird an <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> weitergereicht, um die Datei-Hierarchie für ein DVD-Video zu erstellen. Weiterhin bewirkt diese Option, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> mit <code>-dvd-compat</code> aufgerufen wird.</p></div></div><div class=sect3><h4 id=_dvdrw_medien_benutzen>35.6.4. DVD+RW-Medien benutzen<a class=anchor href=#_dvdrw_medien_benutzen></a></h4><div class=paragraph><p>Im Gegensatz zu CD-RW-Medien müssen DVD+RW-Medien erst formatiert werden, bevor sie benutzt werden können. Es wird <em>empfohlen</em> <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> einzusetzen, da das Programm Medien automatisch formatiert, wenn es erforderlich ist. Es ist jedoch möglich, auch <code>dvd+rw-format</code> zu nutzen, um die DVD+RW zu formatieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Dieser Vorgang muss nur einmal durchgeführt werden. Denken Sie daran, dass nur neue DVD+RWs formatiert werden müssen. Anschließend können DVD+RWs, wie gewohnt gebrannt werden.</p></div><div class=paragraph><p>Wenn Sie auf einer DVD+RW ein neues Dateisystem erstellen wollen, brauchen Sie die DVD+RW vorher nicht zu löschen. Überschreiben Sie einfach das vorige Dateisystem indem Sie eine neue Session anlegen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/newdata</span></code></pre></div></div><div class=paragraph><p>Das DVD+RW-Format erlaubt es, Daten an eine vorherige Aufnahme anzuhängen. Dazu wird eine neue Session mit der schon bestehenden zusammengeführt. Es wird keine Multi-Session geschrieben, sondern <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> <em>vergrößert</em> das ISO-9660-Dateisystem auf dem Medium.</p></div><div class=paragraph><p>Das folgende Kommando fügt weitere Daten zu einer vorher erstellten DVD+RW hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>Wenn Sie eine DVD+RW erweitern, verwenden Sie dieselben <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>-Optionen wie beim Erstellen der DVD+RW.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Verwenden Sie <code>-dvd-compat</code>, um bessere Kompatibilität mit DVD-ROM-Laufwerken zu gewährleisten. Zu einem DVD+RW-Medium können Sie mit dieser Option auch weiterhin Daten hinzufügen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um das Medium zu löschen, verwenden Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0=/dev/zero</span></code></pre></div></div></div><div class=sect3><h4 id=_dvd_rw_medien_benutzen>35.6.5. DVD-RW-Medien benutzen<a class=anchor href=#_dvd_rw_medien_benutzen></a></h4><div class=paragraph><p>Eine DVD-RW kann mit zwei Methoden beschrieben werden: <em>Sequential-Recording</em> oder <em>Restricted-Overwrite</em>. Voreingestellt ist Sequential-Recording.</p></div><div class=paragraph><p>Eine neue DVD-RW kann direkt beschrieben werden; sie muss nicht vorher formatiert werden. Allerdings muss eine DVD-RW, die mit Sequential-Recording aufgenommen wurde, zuerst gelöscht werden, bevor eine neue Session aufgenommen werden kann.</p></div><div class=paragraph><p>Der folgende Befehl löscht eine DVD-RW im Sequential-Recording-Modus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das vollständige Löschen mit <code>-blank=full</code> dauert mit einem 1x Medium ungefähr eine Stunde. Wenn die DVD-RW im Disk-At-Once-Modus (DAO) aufgenommen wurde, kann sie mit <code>-blank</code> schneller gelöscht werden. Um eine DVD-RW im DAO-Modus zu brennen, benutzen Sie das folgende Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Die Option <code>-use-the-force-luke=dao</code> sollte nicht erforderlich sein, da <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> den DAO-Modus automatisch erkennt.</p></div><div class=paragraph><p>Der Restricted-Overwrite-Modus sollte mit jeder DVD-RW verwendet werden, da er flexibler als der voreingestellte Sequential-Recording-Modus ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um Daten auf eine DVD-RW im Sequential-Recording-Modus zu schreiben, benutzen Sie dasselbe Kommando wie für die anderen DVD-Formate:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Um weitere Daten zu einer Aufnahme hinzuzufügen, benutzen Sie <code>-M</code> mit <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. Werden die Daten im Sequential-Recording-Modus hinzugefügt, wird eine neue Session erstellt. Das Ergebnis ist ein Multi-Session-Medium.</p></div><div class=paragraph><p>Eine DVD-RW im Restricted-Overwrite-Modus muss nicht gelöscht werden, um eine neue Session aufzunehmen. Das Medium kann einfach mit <code>-Z</code> überschrieben werden. Mit <code>-M</code> kann das ISO-9660-Dateisystem, wie mit einer DVD+RW, vergrößert werden. Die DVD enthält danach eine Session.</p></div><div class=paragraph><p>Benutzen sie das nachstehende Kommando, um den Restricted-Overwrite-Modus einzustellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Das folgende Kommando stellt den Modus wieder auf Sequential-Recording zurück:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div></div><div class=sect3><h4 id=_multi_session>35.6.6. Multi-Session<a class=anchor href=#_multi_session></a></h4><div class=paragraph><p>Nur wenige DVD-ROM-Laufwerke unterstützen Multi-Session-DVDs und lesen meist nur die erste Session. Mehrere Sessions werden von DVD+R, DVD-R und DVD-RW im Sequential-Recording-Modus unterstützt. Im Modus Restricted-Overwrite gibt nur eine Session.</p></div><div class=paragraph><p>Wenn das Medium noch nicht geschlossen ist, erstellt das nachstehende Kommando eine neue Session auf einer DVD+R, DVD-R oder DVD-RW im Sequential-Recording-Modus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>Wird dieses Kommando mit DVD+RW- oder DVD-RW-Medien im Restricted-Overwrite-Modus benutzt, werden die neuen Daten mit den Daten der bestehenden Session zusammengeführt. Das Medium enthält danach eine Session. Nutzen Sie diese Methode, um neue Daten zu einer bestehenden Session hinzuzufügen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Für den Anfang und das Ende einer Session wird auf dem Medium zusätzlicher Platz verbraucht. Um den Speicherplatz auf dem Medium optimal auszunutzen, sollten Sie daher Sessions mit vielen Daten hinzufügen. Auf ein DVD+R-Medium passen maximal 154 Sessions, 2000 Sessions auf ein DVD-R-Medium und 127 Sessions auf eine DVD+R Double Layer.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_weiterführendes>35.6.7. Weiterführendes<a class=anchor href=#_weiterführendes></a></h4><div class=paragraph><p><code>dvd+rw-mediainfo <em>/dev/cd0</em></code> zeigt Informationen über eine im Laufwerk liegende DVD an.</p></div><div class=paragraph><p>Weiteres zu dvd+rw-tools finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>, auf der <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/>dvd+rw-tools Web-Seite</a> und in den Archiven der <a href=http://lists.debian.org/cdwrite/>cdwrite-Mailingliste</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn Sie einen Problembericht zur Nutzung der dvd+rw-tools erstellen, fügen Sie immer die Ausgabe von <code>dvd+rw-mediainfo</code> hinzu.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=creating-dvd-ram>35.6.8. DVD-RAM<a class=anchor href=#creating-dvd-ram></a></h4><div class=paragraph><p>DVD-RAM-fähige Brenner nutzten die SCSI- oder ATAPI-Schnittstelle. Für ATAPI-Geräte muss der DMA-Modus aktiviert werden, indem die folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzugefügt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Eine DVD-RAM kann mit einer Wechselplatte verglichen werden. Wie diese, muss auch eine DVD-RAM vor dem ersten Einsatz formatiert werden. In diesem Beispiel wird das gesamte Medium mit dem Standard-UFS2-Dateisystem formatiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/acd0 bs=2k count=1</span>
<span class=c># bsdlabel -Bw acd0</span>
<span class=c># newfs /dev/acd0</span></code></pre></div></div><div class=paragraph><p>Denken Sie dabei daran, dass Sie gegebenenfalls die Gerätedatei (hier <span class=filename>acd0</span>) an Ihre Konfiguration anpassen müssen.</p></div><div class=paragraph><p>Nachdem die DVD-RAM formatiert ist, kann sie wie eine normale Festplatte gemountet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/acd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Danach kann schreibend und lesend auf das DVD-RAM Medium zugegriffen werden.</p></div></div></div><div class=sect2><h3 id=floppies>35.7. Disketten benutzen<a class=anchor href=#floppies></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt die Formatierung von 3,5 Zoll Disketten in FreeBSD.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><div class=title>Procedure: Disketten formatieren</div><p>Bevor eine Diskette benutzt werden kann, muss sie (low-level) formatiert werden, was normalerweise der Hersteller schon gemacht hat. Sie können die Diskette allerdings noch einmal formatieren, um das Medium zu überprüfen. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a>, um Disketten unter FreeBSD zu formatieren. Achten Sie dabei auf Fehlermeldungen, die schlechte Speichermedien anzeigen.</p></div><div class="olist arabic"><ol class=arabic><li><p>Um eine Diskette zu formatieren, legen Sie eine 3,5 Zoll Diskette in das erste Diskettenlaufwerk ein und führen das folgende Kommando aus:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat -f 1440 /dev/fd0</span></code></pre></div></div></li><li><p>Nach dem Formatieren muss auf der Diskette ein Disklabel erstellt werden, um die Größe und Geometrie der Diskette zu erkennen. Eine Liste der unterstützten Geometrien finden Sie in <span class=filename>/etc/disktab</span>.</p><div class=paragraph><p>Erstellen Sie nun das Label mit <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/bsdlabel -B -w /dev/fd0 fd1440</span></code></pre></div></div></li><li><p>Auf der Diskette kann nun ein Dateisystem erstellt werden (high-level Formatierung). Das Dateisystem der Diskette kann entweder UFS oder FAT sein, wobei FAT für Disketten in der Regel die bessere Wahl ist.</p><div class=paragraph><p>Um die Diskette mit FAT zu formatieren, geben Sie folgendes Kommando ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/newfs_msdos /dev/fd0</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Die Diskette kann nun benutzt werden. Um die Diskette zu verwenden, kann sie mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> eingehängt werden. Man kann auch <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> aus der Ports-Sammlung installieren, um mit der Diskette zu arbeiten.</p></div></div><div class=sect2><h3 id=backup-basics>35.8. Datensicherung<a class=anchor href=#backup-basics></a></h3><div class=paragraph><p>Die Planung und Umsetzung einer Backup-Strategie ist unerlässlich, um Daten in bestimmten Situationen wiederherstellen zu können, zum Beispiel bei Plattendefekten, versehentlichem Löschen von Dateien, willkürlicher Korrumpierung von Dateien oder der vollständigen Zerstörung des Systems und der Backups, die am gleichen Ort aufbewahrt werden.</p></div><div class=paragraph><p>Die Art und der Zeitplan des Backups kann variieren, abhängig von der Wichtigkeit der Daten, der benötigten Granularität zur Wiederherstellung von Dateien und der Dauer einer akzeptablen Ausfallzeit. Zu den möglichen Backup-Strategien gehören unter anderem:</p></div><div class=ulist><ul><li><p>Die Archivierung des kompletten Systems auf externen Datenträgern. Dieser Ansatz schützt zwar vor allen oben aufgeführten Problemen, ist aber zeitaufwändig und unbequem bei der Wiederherstellung, insbesondere für nicht privilegierte Benutzer.</p></li><li><p>Dateisystem-Snapshots sind nützlich bei der Wiederherstellung von gelöschten Dateien, bzw. früheren Versionen von Dateien.</p></li><li><p>Kopien ganzer Dateisysteme oder Festplatten, die mit einem anderen System im Netzwerk mittels <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> synchronisiert werden.</p></li><li><p>Hardware oder Software RAID, was im Falle von Plattendefekten die Ausfallzeit minimiert oder vermeidet.</p></li></ul></div><div class=paragraph><p>Üblicherweise wird eine Mischung aus verschiedenen Strategien verwendet. Es kann zum Beispiel ein Sicherungsplan erstellt und automatisiert werden, um eine wöchentliche, vollständige Systemsicherung, ergänzt mit stündlichen ZFS-Snapshots, zu erstellen. Darüber hinaus könnte man eine manuelle Sicherung einzelner Verzeichnisse oder Dateien machen, bevor diese bearbeitet oder gelöscht werden.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt einige Programme, die zur Erstellung und Verwaltung von Sicherungen unter FreeBSD verwendet werden können.</p></div><div class=sect3><h4 id=_sicherung_von_dateisystemen>35.8.1. Sicherung von Dateisystemen<a class=anchor href=#_sicherung_von_dateisystemen></a></h4><div class=paragraph><p>Die traditionellen UNIX®-Programme zum Sichern und Wiederherstellen von Dateisystemen sind <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>. Diese Programme arbeiten auf der Block-Ebene der Festplatte, also unterhalb des Abstraktionslevels von Dateien, Links und Verzeichnissen, die die Grundlage des Dateisystemkonzepts bilden. Im Gegensatz zu anderen Backup-Programmen sichert <code>dump</code> ein ganzes Dateisystem und nicht nur einen Teil des Dateisystems, oder einen Verzeichnisbaum, der mehr als ein Dateisystem umfasst. Anstatt Dateien oder Verzeichnisse zu schreiben, schreibt <code>dump</code> die Blöcke, aus denen die Dateien und Verzeichnisse bestehen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wird <code>dump</code> benutzt, um das Root-Verzeichnis zu sichern, werden <span class=filename>/home</span>, <span class=filename>/usr</span> und viele andere Verzeichnisse nicht gesichert, da dies normalerweise Mountpunkte für andere Dateisysteme oder symbolische Links zu diesen Dateisystemen sind.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn <code>restore</code> zum Extrahieren von Daten verwendet wird, werden temporäre Dateien standardmäßig in <span class=filename>/tmp</span> abgelegt. Wenn Sie von einer Platte mit einem kleinen <span class=filename>/tmp</span>-Verzeichnis zurücksichern, setzen Sie die Umgebungsvariable <code>TMPDIR</code> auf ein Verzeichnis mit mehr freiem Speicherplatz, damit die Wiederherstellung gelingt.</p></div><div class=paragraph><p>Beachten Sie bei der Verwendung von <code>dump</code>, dass es einige Eigenarten aus den frühen Tagen der Version 6 von AT&amp;T UNIX® (ca. 1975) beibehalten hat. Die Standardparameter gehen davon aus, dass auf einem 9-Spur-Band gesichert wird, und nicht auf ein anderes Medium oder auf Sicherungsbänder mit hoher Dichte. Diese Standardwerte müssen auf der Kommandozeile überschrieben werden.</p></div><div class=paragraph><p>Es ist möglich, das Dateisystem über das Netzwerk auf einem anderen Rechner zu sichern, oder auf einem Bandlaufwerk eines anderen Rechners. Obwohl die Programme <a href="https://man.freebsd.org/cgi/man.cgi?query=rdump&amp;sektion=8&amp;format=html">rdump(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=rrestore&amp;sektion=8&amp;format=html">rrestore(8)</a> für diese Zwecke benutzt werden können, gelten sie als nicht sicher.</p></div><div class=paragraph><p>Verwenden Sie stattdessen <code>dump</code> und <code>restore</code> in einer sichereren Weise über eine SSH-Verbindung. In diesem Beispiel wird eine vollständige, komprimierte Sicherung von <span class=filename>/usr</span> erstellt, das anschließend an einen bestimmten Host über eine SSH-Verbindung gesendet wird.</p></div><div class=exampleblock><div class=title>Beispiel 36. <code>dump</code> mit ssh benutzen</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \</span>
	  targetuser@targetmachine.example.com <span class=nb>dd </span><span class=nv>of</span><span class=o>=</span>/mybigfiles/dump-usr-l0.gz</code></pre></div></div></div></div><div class=paragraph><p>In diesem Beispiel wird <code>RSH</code> gesetzt, um über eine SSH-Verbindung eine Sicherung auf ein Bandlaufwerk eines entfernten Systems zu schreiben:</p></div><div class=exampleblock><div class=title>Beispiel 37. <code>dump</code> über ssh mit gesetzter <code>RSH</code> benutzen</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># env RSH=/usr/bin/ssh /sbin/dump -0uan -f tatargetuser@targetmachine.example.com:/dev/sa0 /usr</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_sicherung_von_verzeichnissen>35.8.2. Sicherung von Verzeichnissen<a class=anchor href=#_sicherung_von_verzeichnissen></a></h4><div class=paragraph><p>Einige integrierte Werkzeuge stehen zur Sicherung und Wiederherstellung von bestimmten Dateien und Verzeichnissen bei Bedarf zur Verfügung.</p></div><div class=paragraph><p>Wenn es um die Sicherung von Dateien in einem Verzeichnis geht, ist <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> eine gute Wahl. Dieses Werkzeug stammt aus Version 6 von AT&amp;T UNIX® und erwartet standardmäßig eine rekursive Sicherung auf ein lokales Band. Es können jedoch Optionen angegeben werden, um den Namen einer Sicherungsdatei zu bestimmen.</p></div><div class=paragraph><p>In diesem Beispiel wird eine komprimierte Sicherung des aktuellen Verzeichnisses nach <span class=filename>/tmp/mybackup.tgz</span> gespeichert. Achten Sie bei der Sicherungsdatei darauf, dass sie nicht in dem Verzeichnis gespeichert wird, welches gesichert werden soll.</p></div><div class=exampleblock><div class=title>Beispiel 38. Das aktuelle Verzeichnis mit <code>tar</code> sichern</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar czvf /tmp/mybackup.tgz .</span></code></pre></div></div></div></div><div class=paragraph><p>Um eine komplette Sicherung wiederherzustellen, wechseln Sie mit <code>cd</code> in das Verzeichnis, in dem Sie die Daten wiederherstellen möchten und geben Sie den Namen der Sicherungsdatei an. Beachten Sie, dass dabei alle Dateien in dem Verzeichnis überschrieben werden. Im Zweifel sichern Sie besser in einem temporären Verzeichnis, oder geben Sie den Verzeichnisnamen bei der Wiederherstellung an.</p></div><div class=exampleblock><div class=title>Beispiel 39. Wiederherstellung mit <code>tar</code> in das aktuelle Verzeichnis</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /tmp/mybackup.tgz</span></code></pre></div></div></div></div><div class=paragraph><p>Es gibt dutzende Optionen, die in <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> beschrieben werden. Das Programm unterstützt auch die Verwendung von Ausschlußmustern, um bestimmte Dateien von der Sicherung oder Wiederherstellung von Verzeichnissen auszuschließen.</p></div><div class=paragraph><p>Um bestimmte, aufgelistete Dateien und Verzeichnisse zu sichern, ist <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> eine gute Wahl. Im Gegensatz zu <code>tar</code> weiß <code>cpio</code> nicht wie ein Verzeichnisbaum durchlaufen wird. Daher ist es auf eine Liste von zu sichernden Dateien angewiesen.</p></div><div class=paragraph><p>So kann beispielsweise eine Liste von Dateien mit <code>ls</code> oder <code>find</code> erzeugt werden. Dieses Beispiel erstellt eine rekursive Liste des aktuellen Verzeichnisses, die dann über eine Pipe an <code>cpio</code> übergeben wird, um eine Sicherung namens <span class=filename>/tmp/mybackup.cpio</span> zu erstellen.</p></div><div class=exampleblock><div class=title>Beispiel 40. Rekursive Sicherung des aktuellen Verzeichnisses mit <code>ls</code> und <code>cpio</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -R | cpio -ovF /tmp/mybackup.cpio</span></code></pre></div></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a> ist ein Programm, welches versucht die Funktionen von <code>tar</code> und <code>cpio</code> zu kombinieren. Über die Jahre hinweg sind die verschiedenen Versionen von <code>tar</code> und <code>cpio</code> leicht inkompatibel geworden. Daher hat POSIX® <code>pax</code> geschaffen, welches versucht viele der unterschiedlichen <code>cpio</code>- und <code>tar</code>-Formate zu lesen und zu schreiben, außerdem einige neue, eigene Formate.</p></div><div class=paragraph><p>Für die vorangegangenen Beispiele wäre ein äquivalenter Aufruf von <code>pax</code>:</p></div><div class=exampleblock><div class=title>Beispiel 41. Das aktuelle Verzeichnis mit <code>pax</code> sichern</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pax -wf /tmp/mybackup.pax .</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=backups-tapebackups>35.8.3. Bandmedien benutzen<a class=anchor href=#backups-tapebackups></a></h4><div class=paragraph><p>Obwohl sich Bandmedien mit der Zeit weiterentwickelt haben, verwenden moderne Backup-Systeme in der Regel Offsite-Backups in Verbindung mit lokalen Wechseldatenträgern. FreeBSD unterstützt alle SCSI-Bandlaufwerke, wie etwa LTO und DAT. Zusätzlich gibt es begrenzte Unterstützung für SATA- und USB-Bandlaufwerke.</p></div><div class=paragraph><p>Für SCSI-Bandlaufwerke nutzt FreeBSD den <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=4&amp;format=html">sa(4)</a> Treiber, der die Schnittstellen <span class=filename>/dev/sa0</span>, <span class=filename>/dev/nsa0</span> und <span class=filename>/dev/esa0</span> bereitstellt. Der Name des physikalischen Geräts ist <span class=filename>/dev/sa0</span>. Wird <span class=filename>/dev/nsa0</span> benutzt, dann wird die Backup-Anwendung nach dem Schreibvorgang das Band nicht zurückspulen, was es ermöglicht, mehr als eine Datei auf das Band zu schreiben. Die Verwendung von <span class=filename>/dev/esa0</span> wirft das Band aus, nachdem das Gerät geschlossen wurde.</p></div><div class=paragraph><p>FreeBSD nutzt <code>mt</code> für die Steuerung der Operationen des Bandlaufwerks, wie die Suche nach Dateien auf einem Band, oder um Kontrollmarkierungen auf ein Band zu schreiben. Beispielsweise können die ersten drei Dateien auf einem Band erhalten bleiben, indem sie übersprungen werden, bevor eine neue Datei auf das Band geschrieben wird</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mt -f /dev/nsa0 fsf 3</span></code></pre></div></div><div class=paragraph><p>Dieses Werkzeug unterstützt viele Operationen. Weitere Einzelheiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mt&amp;sektion=1&amp;format=html">mt(1)</a>.</p></div><div class=paragraph><p>Um eine Datei mit <code>tar</code> auf ein Band zu schreiben, geben Sie den Namen des Bandlaufwerks und den Dateinamen an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar cvf /dev/sa0 file</span></code></pre></div></div><div class=paragraph><p>Wiederherstellung von Dateien aus dem <code>tar</code>-Archiv von Band in das aktuelle Verzeichnis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xvf /dev/sa0</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie <code>dump</code>, um ein UFS-Dateisystem zu sichern. Dieses Beispiel sichert <span class=filename>/usr</span>, ohne danach das Band zurückzuspulen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dump -0aL -b64 -f /dev/nsa0 /usr</span></code></pre></div></div><div class=paragraph><p>Interaktive Wiederherstellung von Dateien aus einer <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>-Datei von Band in das aktuelle Verzeichnis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># restore -i -f /dev/nsa0</span></code></pre></div></div></div><div class=sect3><h4 id=backups-programs-amanda>35.8.4. Backup-Software von Drittanbietern<a class=anchor href=#backups-programs-amanda></a></h4><div class=paragraph><p>Die FreeBSD Ports-Sammlung enthält viele Programme von Drittanbietern, die verwendet werden können um die zeitliche Erstellung von Sicherungen zu planen, zu vereinfachen und bequemer zu machen. Viele dieser Programme basieren auf dem Client-Server-Modell und können benutzt werden, um die Sicherung von einzelnen Systemen oder allen Rechnern in einem Netzwerk zu automatisieren.</p></div><div class=paragraph><p>Zu den bekannten Programmen gehören Amanda, Bacula, rsync und duplicity.</p></div></div><div class=sect3><h4 id=_die_wiederherstellung_in_einem_notfall>35.8.5. Die Wiederherstellung in einem Notfall<a class=anchor href=#_die_wiederherstellung_in_einem_notfall></a></h4><div class=paragraph><p>Zusätzlich zu den regelmäßigen Sicherungen empfiehlt es sich, die folgenden Schritte im Rahmen eines Notfallplans durchzuführen.</p></div><div class=paragraph><p>Erstellen Sie einen Ausdruck der Ausgabe der folgenden Kommandos:</p></div><div class=ulist><ul><li><p><code>gpart show</code></p></li><li><p><code>more /etc/fstab</code></p></li><li><p><code>dmesg</code></p></li></ul></div><div class=paragraph><p>Bewahren Sie diesen Ausdruck und eine Kopie des Installationsmediums an einem sicheren Ort auf. Im Falle einer Wiederherstellung im Notfall, starten Sie von dem Installationsmedium und wählen Sie <code>Live CD</code>, um eine Rettungs-Shell zu starten. Dieser Rettungsmodus kann verwendet werden, um den aktuellen Stand des Systems anzuzeigen, und wenn nötig, Festplatten zu formatieren und Daten aus den Sicherungen wiederherzustellen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das Installationsmedium für FreeBSD/i386 11.2-RELEASE enthält keine Rettungs-Shell. Laden Sie für diese Version ein Abbild der Livefs CD von <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Als nächstes testen Sie die Rettungs-Shell und die Sicherungen. Dokumentieren Sie diesen Ablauf. Bewahren Sie diese Notizen zusammen mit den Medien, den Ausdrucken und den Sicherungen auf. Diese Notizen können Ihnen im Notfall helfen eine versehentliche Zerstörung der Sicherungen zu verhindern, während Sie unter Stress eine Wiederherstellung durchführen.</p></div><div class=paragraph><p>Als zusätzliche Sicherheitsvorkehrung kann jeweils die letzte Sicherung an einem entfernten Standort aufbewahrt werden. Dieser Standort sollte räumlich von den Computern und Festplatten durch eine erhebliche Entfernung getrennt sein.</p></div></div></div><div class=sect2><h3 id=disks-virtual>35.9. Speicherbasierte Laufwerke<a class=anchor href=#disks-virtual></a></h3><div class=paragraph><p>Neben physikalischen Laufwerken unterstützt FreeBSD auch speicherbasierte Laufwerke. Eine mögliche Verwendung für ein speicherbasiertes Laufwerk ist der Zugriff auf ein ISO-Dateisystem, jedoch ohne vorher die Daten auf eine CD oder DVD zu brennen und dann das Medium einzuhängen.</p></div><div class=paragraph><p>FreeBSD verwendet den <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> Treiber um Unterstützung für speicherbasierte Laufwerke bereitzustellen. Dieser Treiber ist bereits im <span class=filename>GENERIC</span>-Kernel enthalten. Wenn Sie eine angepasste Kernelkonfigurationsdatei verwenden, stellen Sie sicher, dass folgende Zeile enthalten ist:</p></div><div class="literalblock programlisting"><div class=content><pre>device md</pre></div></div><div class=sect3><h4 id=disks-mdconfig>35.9.1. Ein- und Aushängen von bestehenden Abbildern<a class=anchor href=#disks-mdconfig></a></h4><div class=paragraph><p>Um ein bestehendes Abbild eines Dateisystems einzuhängen, verwenden Sie <code>mdconfig</code> zusammen mit dem Namen der ISO-Datei und einer freien Gerätenummer. Benutzen Sie dann diese Gerätenummer, um das Abbild in einen existierenden Mountpunkt einzuhängen. Sobald dies erledigt ist, erscheinen die Dateien des Abbildes unterhalb des Mountpunktes. Dieses Beispiel wird <span class=filename>diskimage.iso</span> an das speicherbasierte Laufwerk <span class=filename>/dev/md0</span> binden und dann in <span class=filename>/mnt</span> einhängen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -f diskimage.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Beachten Sie, dass <code>-t cd9660</code> benutzt wurde, um ein ISO-Format einzuhängen. Wenn keine Gerätenummer mit <code>-u</code> angegeben ist, wird von <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> automatisch eine ungenutzte Gerätenummer zugewiesen. Das zugewiesene Gerät wird auf der Standardausgabe ausgegeben (zum Beispiel <span class=filename>md4</span>). Weitere Informationen zu diesem Kommando und dessen Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>.</p></div><div class=paragraph><p>Wenn ein speicherbasiertes Laufwerk nicht mehr in Gebrauch ist, sollten seine belegten Ressourcen wieder an das System zurückgegeben werden. Hängen Sie zuerst das Dateisystem aus, dann verwenden Sie <code>mdconfig</code>, um die Platte vom System zu trennen und die Ressourcen freizugeben.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 0</span></code></pre></div></div><div class=paragraph><p>Um festzustellen, ob noch irgendwelche speicherbasierten Laufwerke am System angeschlossen sind, benutzen Sie <code>mdconfig -l</code>.</p></div></div><div class=sect3><h4 id=disks-md-freebsd5>35.9.2. Ein datei- oder speicherbasiertes Laufwerk erzeugen<a class=anchor href=#disks-md-freebsd5></a></h4><div class=paragraph><p>FreeBSD unterstützt auch speicherbasierte Laufwerke, bei denen der verwendete Speicher entweder einer Festplatte, oder einem Bereich im Arbeitsspeicher zugewiesen wird. Die erste Methode ist gemeinhin als dateibasiertes Dateisystem, die zweite als speicherbasiertes Dateisystem bekannt. Beide Typen können mit <code>mdconfig</code> erzeugt werden.</p></div><div class=paragraph><p>Um ein speicherbasiertes Dateisystem zu erstellen, geben Sie den Typ <code>swap</code> sowie die gewünschte Größe des Laufwerks an. Dieses Beispiel erzeugt ein 5 MB großes Laufwerk an der Gerätenummer <code>1</code>. Das Laufwerk wird mit dem UFS-Dateisystem formatiert, bevor es eingehängt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t swap -s 5m -u 1</span>
<span class=c># newfs -U md1</span>
/dev/md1: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2752, 5344, 7936
<span class=c># mount /dev/md1 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</code></pre></div></div><div class=paragraph><p>Um ein dateibasiertes Dateisystem zu erstellen, muss zunächst ein Stück Speicher auf der Festplatte reserviert werden. Dieses Beispiel erzeugt eine 5 MB große Datei namens <span class=filename>newimage</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out</code></pre></div></div><div class=paragraph><p>Als nächstes muss diese Datei an ein speicherbasiertes Laufwerk gebunden, gelabelt und mit dem UFS-Dateisystem formatiert werden. Danach können Sie das Laufwerk einhängen und die Größe überprüfen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -f newimage -u 0</span>
<span class=c># bsdlabel -w md0 auto</span>
<span class=c># newfs -U md0a</span>
/dev/md0a: 5.0MB <span class=o>(</span>10224 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.25MB, 80 blks, 192 inodes.
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2720, 5280, 7840
<span class=c># mount /dev/md0a /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</code></pre></div></div><div class=paragraph><p>Es benötigt mehrere Befehle, um ein datei- oder speicherbasiertes Dateisystem mit <code>mdconfig</code> zu erstellen. FreeBSD enthält auch <code>mdmfs</code>, das ein speicherbasiertes Laufwerk automatisch konfigurieren, formatieren und einhängen kann. Nachdem beispielsweise <span class=filename>newimage</span> mit <code>dd</code> erstellt wurde, hätte auch der folgende Befehl benutzt werden können, anstelle der oben verwendeten Kommandos <code>bsdlabel</code>, <code>newfs</code> und <code>mount</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -F newimage -s 5m md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Um hingegen ein speicherbasiertes Laufwerk mit <code>mdmfs</code> zu erstellen, wird dieser Befehl benutzt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -s 5m md1 /mnt</span></code></pre></div></div><div class=paragraph><p>Wenn die Gerätenummer nicht angegeben wird, wählt <code>mdmfs</code> automatisch ein ungenutztes Gerät aus. Weitere Einzelheiten über <code>mdmfs</code> finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>.</p></div></div></div><div class=sect2><h3 id=snapshots>35.10. Schnappschüsse von Dateisystemen<a class=anchor href=#snapshots></a></h3><div class=paragraph><p>Zusammen mit <a href=./#soft-updates>Soft Updates</a> bietet FreeBSD eine weitere Funktion: Schnappschüsse von Dateisystemen.</p></div><div class=paragraph><p>UFS-Schnappschüsse sind Dateien, die ein Abbild eines Dateisystems enthalten und müssen auf dem jeweiligen Dateisystem erstellt werden. Pro Dateisystem darf es maximal 20 Schnappschüsse, die im Superblock vermerkt werden, geben. Schnappschüsse bleiben erhalten, wenn das Dateisystem abgehangen, neu eingehangen oder das System neu gestartet wird. Wenn ein Schnappschuss nicht mehr benötigt wird, kann er mit <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a> gelöscht werden. Es ist egal, in welcher Reihenfolge Schnappschüsse gelöscht werden. Es kann allerdings vorkommen, dass nicht der gesamte Speicherplatz wieder freigegeben wird, da ein anderer Schnappschuss einen Teil der entfernten Blöcke für sich beanspruchen kann.</p></div><div class=paragraph><p>Das unveränderliche <code>Snapshot</code>-Dateiflag wird nach der Erstellung des Snapshots von <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> gesetzt. Durch die Verwendung von <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=1&amp;format=html">unlink(1)</a> ist es allerdings möglich, einen Schnappschuss zu löschen.</p></div><div class=paragraph><p>Schnappschüsse werden mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> erstellt. Das folgende Kommando legt einen Schnappschuss von <span class=filename>/var</span> in <span class=filename>/var/snapshot/snap</span> ab:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o snapshot /var/snapshot/snap /var</span></code></pre></div></div><div class=paragraph><p>Alternativ kann der Schnappschuss auch mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> erstellt werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mksnap_ffs /var /var/snapshot/snap</span></code></pre></div></div><div class=paragraph><p>Um Schnappschüsse auf einem Dateisystem, beispielsweise <span class=filename>/var</span> zu finden, kann man <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a> verwenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># find /var -flags snapshot</span></code></pre></div></div><div class=paragraph><p>Nachdem ein Schnappschuss erstellt wurde, können Sie ihn für verschiedene Zwecke benutzen:</p></div><div class=ulist><ul><li><p>Sie können den Schnappschuss für die Datensicherung benutzen und ihn auf eine CD oder ein Band schreiben.</p></li><li><p>Die Integrität des Schnappschusses kann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> geprüft werden. Wenn das Dateisystem zum Zeitpunkt der Erstellung des Schnappschusses in Ordnung war, sollte <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> immer erfolgreich durchlaufen.</p></li><li><p>Sie können den Schnappschuss mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> sichern. Sie erhalten dann eine konsistente Sicherung des Dateisystems zu dem Zeitpunkt, der durch den Zeitstempel des Schnappschusses gegeben ist. Der Schalter <code>-L</code> von <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> erstellt für die Sicherung einen Schnappschuss und entfernt diesen am Ende der Sicherung wieder.</p></li><li><p>Sie können einen Schnappschuss in den Verzeichnisbaum einhängen und sich dann den Zustand des Dateisystems zu dem Zeitpunkt ansehen, an dem der Schnappschuss erstellt wurde. Der folgende Befehl hängt den Schnappschuss <span class=filename>/var/snapshot/snap</span> ein:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4</span>
<span class=c># mount -r /dev/md4 /mnt</span></code></pre></div></div></li></ul></div><div class=paragraph><p>Der eingefrorene Stand des <span class=filename>/var</span>-Dateisystems ist nun unterhalb von <span class=filename>/mnt</span> verfügbar. Mit Ausnahme der früheren Schnappschüsse, die als leere Dateien auftauchen, wird zu Beginn alles so aussehen, wie zum Zeitpunkt der Erstellung des Schnappschusses. Der Schnappschuss kann wie folgt abgehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>Weitere Informationen über Soft Updates und Schnappschüsse von Dateisystemen sowie technische Artikel finden Sie auf der <a href=http://www.mckusick.com/>Webseite von Marshall Kirk McKusick</a>.</p></div></div><div class=sect2><h3 id=quotas>35.11. Disk Quotas<a class=anchor href=#quotas></a></h3><div class=paragraph><p>Disk Quotas erlauben dem Administrator, den Plattenplatz und/oder die Anzahl der Dateien eines Benutzers oder der Mitglieder einer Gruppe, auf Dateisystemebene zu beschränken. Dadurch wird verhindert, dass ein Benutzer oder eine Gruppe von Benutzern den ganzen verfügbaren Plattenplatz belegt.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt die Konfiguration von Disk Quotas für UFS-Dateisysteme. Lesen Sie <a href=./#zfs-zfs-quota>Dataset-, Benutzer- und Gruppenquotas</a>, wenn Sie Disk Quotas auf einem ZFS-Dateisystem einrichten möchten.</p></div><div class=sect3><h4 id=_disk_quotas_aktivieren>35.11.1. Disk Quotas aktivieren<a class=anchor href=#_disk_quotas_aktivieren></a></h4><div class=paragraph><p>Prüfen Sie zunächst, ob der FreeBSD-Kernel Disk Quotas unterstützt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.features.ufs_quota
kern.features.ufs_quota: 1</code></pre></div></div><div class=paragraph><p>In diesem Beispiel zeigt die <code>1</code> an, das Quotas unterstützt werden. Falls <code>0</code> ausgegeben wird, fügen Sie folgende Zeile in die Kernelkonfigurationsdatei ein, und folgen Sie den Anweisungen in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> um den Kernel zu aktualisieren:</p></div><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>Als nächstes aktivieren Sie Disk Quotas in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>quota_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Normalerweise wird beim Booten die Integrität der Quotas auf allen Dateisystemen mit <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a> überprüft. Dieses Programm stellt sicher, dass die Quota-Datenbank mit den Daten auf einem Dateisystem übereinstimmt. Dies ist allerdings ein zeitraubender Prozess, der die Zeit, die das System zum Booten braucht, signifikant beeinflusst. Eine Variable in <span class=filename>/etc/rc.config</span> erlaubt es, diesen Schritt zu überspringen:</p></div><div class="literalblock programlisting"><div class=content><pre>check_quotas=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Zuletzt muss noch <span class=filename>/etc/fstab</span> bearbeitet werden, um die Plattenquotas auf Dateisystemebene zu aktivieren. Um Quotas pro Benutzer für ein Dateisystem zu aktivieren, geben Sie für dieses Dateisystem <code>userquota</code> im Feld Optionen von <span class=filename>/etc/fstab</span> an. Zum Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g   /home    ufs rw,userquota 1 2</pre></div></div><div class=paragraph><p>Um Quotas für Gruppen einzurichten, verwenden Sie <code>groupquota</code>. Um Quotas für Benutzer und Gruppen einzurichten, trennen Sie die Optionen durch Kommata:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</pre></div></div><div class=paragraph><p>Quota-Dateien werden standardmäßig im Rootverzeichnis des Dateisystems unter <span class=filename>quota.user</span> und <span class=filename>quota.group</span> abgelegt. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a>. Es wird nicht empfohlen, Quota-Dateien an anderen Stellen zu speichern.</p></div><div class=paragraph><p>Sobald die Konfiguration abgeschlossen ist, starten Sie das System neu. <span class=filename>/etc/rc</span> wird dann automatisch die richtigen Kommandos aufrufen, um die Quota-Dateien für alle in <span class=filename>/etc/rc.conf</span> definierten Quotas anzulegen.</p></div><div class=paragraph><p>Normalerweise brauchen die Kommandos <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaon&amp;sektion=8&amp;format=html">quotaon(8)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaoff&amp;sektion=8&amp;format=html">quotaoff(8)</a> nicht von Hand aufgerufen werden, obwohl man die entsprechenden Seiten im Manual lesen sollte, um sich mit ihnen vertraut zu machen.</p></div></div><div class=sect3><h4 id=_setzen_von_quota_limits>35.11.2. Setzen von Quota-Limits<a class=anchor href=#_setzen_von_quota_limits></a></h4><div class=paragraph><p>Stellen Sie sicher, dass Quotas auch tatsächlich aktiviert sind:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># quota -v</span></code></pre></div></div><div class=paragraph><p>Für jedes Dateisystem, auf dem Quotas aktiviert sind, sollte eine Zeile mit der Plattenauslastung und den aktuellen Quota-Limits zu sehen sein.</p></div><div class=paragraph><p>Mit <code>edquota</code> können nun Quota-Limits zugewiesen werden.</p></div><div class=paragraph><p>Mehrere Möglichkeiten stehen zur Verfügung, um Limits für den Plattenplatz, den ein Benutzer oder eine Gruppe verbrauchen kann, oder die Anzahl der Dateien, die angelegt werden dürfen, festzulegen. Die Limits können auf dem Plattenplatz (Block-Quotas), der Anzahl der Dateien (Inode-Quotas) oder einer Kombination von beiden basieren. Jedes Limit wird weiterhin in zwei Kategorien geteilt: Hardlimits und Softlimits.</p></div><div class=paragraph><p>Ein Hardlimit kann nicht überschritten werden. Hat der Benutzer einmal ein Hardlimit erreicht, so kann er auf dem betreffenden Dateisystem keinen weiteren Platz mehr beanspruchen. Hat ein Benutzer beispielsweise ein Hardlimit von 500 Kilobytes auf einem Dateisystem und benutzt davon 490 Kilobyte, so kann er nur noch 10 weitere Kilobytes beanspruchen. Der Versuch, weitere 11 Kilobytes zu beanspruchen, wird fehlschlagen.</p></div><div class=paragraph><p>Softlimits können für eine befristete Zeit überschritten werden. Diese Frist beträgt in der Grundeinstellung eine Woche. Hat der Benutzer das Softlimit über die Frist hinaus überschritten, so wird das Softlimit in ein Hardlimit umgewandelt und der Benutzer kann keinen weiteren Platz mehr beanspruchen. Wenn er einmal das Softlimit unterschreitet, wird die Frist wieder zurückgesetzt.</p></div><div class=paragraph><p>Im folgenden Beispiel wird das Quota des Benutzerkonto <code>test</code> bearbeitet. Wenn <code>edquota</code> aufgerufen wird, wird der in <code>EDITOR</code> definierte Editor aufgerufen, um die Quota-Limts zu konfigurieren. Der Standard-Editor ist vi.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -u test</span>

Quotas <span class=k>for </span>user <span class=nb>test</span>:

/usr: kbytes <span class=k>in </span>use: 65, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 75<span class=o>)</span>
        inodes <span class=k>in </span>use: 7, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 60<span class=o>)</span>
/usr/var: kbytes <span class=k>in </span>use: 0, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 75<span class=o>)</span>
        inodes <span class=k>in </span>use: 0, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 60<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Für jedes Dateisystem, auf dem Quotas aktiv sind, sind zwei Zeilen zu sehen. Eine repräsentiert die Block-Quotas und die andere die Inode-Quotas. Um ein Limit zu modifizieren, ändern Sie einfach den angezeigten Wert. Um beispielsweise das Blocklimit von <span class=filename>/usr</span> auf ein Softlimit von <code>500</code> und ein Hardlimit von <code>600</code> zu erhöhen, ändern Sie die Zeile wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</pre></div></div><div class=paragraph><p>Die neuen Limits sind wirksam, sobald der Editor verlassen wird.</p></div><div class=paragraph><p>Manchmal ist es wünschenswert, die Limits für eine Reihe von Benutzern zu setzen. Dazu weisen Sie zunächst einem Benutzer das gewünschte Quota-Limit zu. Anschließend benutzen Sie <code>-p</code>, um das Quota auf einen bestimmten Bereich von Benutzer-IDs (UID) zu duplizieren. Der folgende Befehl dupliziert die Quota-Limits auf die UIDs <code>10000</code> bis <code>19999</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -p test 10000-19999</span></code></pre></div></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>.</p></div></div><div class=sect3><h4 id=_überprüfen_von_quota_limits_und_plattennutzung>35.11.3. Überprüfen von Quota-Limits und Plattennutzung<a class=anchor href=#_überprüfen_von_quota_limits_und_plattennutzung></a></h4><div class=paragraph><p>Um die Limits oder die Plattennutzung individueller Benutzer und Gruppen zu überprüfen, kann <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> benutzt werden. Ein Benutzer kann nur die eigenen Quotas und die Quotas der Gruppe, der er angehört untersuchen. Nur der Superuser darf sich alle Limits ansehen. Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a> erhalten Sie eine Zusammenfassung von allen Limits und der Plattenausnutzung für alle Dateisysteme, auf denen Quotas aktiv sind.</p></div><div class=paragraph><p>In der Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> werden Dateisysteme, auf denen ein Benutzer keinen Platz verbraucht, nicht angezeigt, auch wenn diesem Quotas zugewiesen wurden. Benutzen Sie <code>-v</code> um solche Dateisysteme ebenfalls anzuzeigen. Das folgende Beispiel zeigt die Ausgabe von <code>quota -v</code> für einen Benutzer, der Quota-Limits auf zwei Dateisystemen besitzt:</p></div><div class="literalblock programlisting"><div class=content><pre>Disk quotas for user test (uid 1002):
     Filesystem  usage   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</pre></div></div><div class=paragraph><p>Im Dateisystem <span class=filename>/usr</span> liegt der Benutzer momentan 15 Kilobytes über dem Softlimit von 50 Kilobytes und hat noch 5 Tage seiner Frist übrig. Der Stern <code>*</code> zeigt an, dass der Benutzer sein Limit überschritten hat.</p></div></div><div class=sect3><h4 id=_quotas_über_nfs>35.11.4. Quotas über NFS<a class=anchor href=#_quotas_über_nfs></a></h4><div class=paragraph><p>Quotas werden von dem Quota-Subsystem auf dem NFS-Server erzwungen. Der <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.rquotad&amp;sektion=8&amp;format=html">rpc.rquotad(8)</a> Daemon stellt <code>quota</code> die Quota Informationen auf dem NFS-Client zur Verfügung, so dass Benutzer auf diesen Systemen ihre Quotas abfragen können.</p></div><div class=paragraph><p>Sie aktivieren <code>rpc.rquotad</code> auf dem NFS-Server, indem Sie das Zeichen <code>#</code> auf folgender Zeile in <span class=filename>/etc/inetd.conf</span> entfernen:</p></div><div class="literalblock programlisting"><div class=content><pre>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</pre></div></div><div class=paragraph><p>Anschließend starten Sie <code>inetd</code> neu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd restart</span></code></pre></div></div></div></div><div class=sect2><h3 id=disks-encrypting>35.12. Partitionen verschlüsseln<a class=anchor href=#disks-encrypting></a></h3><div class=paragraph><p>FreeBSD bietet ausgezeichnete Möglichkeiten, Daten vor unberechtigten Zugriffen zu schützen. Wenn das Betriebssystem läuft, schützen Zugriffsrechte und vorgeschriebene Zugriffskontrollen (MAC) (siehe <a href=./#mac>Verbindliche Zugriffskontrolle</a>) die Daten. Die Zugriffskontrollen des Betriebssystems schützen allerdings nicht vor einem Angreifer, der Zugriff auf den Rechner hat. Der Angreifer kann eine Festplatte in ein anderes System einbauen und dort die Daten analysieren.</p></div><div class=paragraph><p>Die für FreeBSD verfügbaren kryptografischen Subsysteme, GEOM Based Disk Encryption (<code>gbde</code>) und <code>geli</code> sind in der Lage, Daten auf Dateisystemen auch vor hoch motivierten Angreifern zu schützen, die über erhebliche Mittel verfügen. Dieser Schutz ist unabhängig von der Art und Weise, durch die ein Angreifer Zugang zu einer Festplatte oder zu einem Rechner erlangt hat. Im Gegensatz zu anderen Verschlüsselungsmethoden, bei denen einzelne Dateien verschlüsselt werden, verschlüsseln gbde und <code>geli</code> transparent ganze Dateisysteme. Auf der Festplatte werden dabei keine Daten im Klartext gespeichert.</p></div><div class=paragraph><p>Dieses Kapitel zeigt, wie ein verschlüsseltes Dateisystem unter FreeBSD erstellt wird. Zunächst wird der Ablauf für gbde beschrieben und anschließend das gleiche Beispiel für geli.</p></div><div class=sect3><h4 id=_plattenverschlüsselung_mit_gbde>35.12.1. Plattenverschlüsselung mit gbde<a class=anchor href=#_plattenverschlüsselung_mit_gbde></a></h4><div class=paragraph><p>Das Ziel von <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> ist es, einen Angreifer vor eine große Herausforderung zu stellen, um an die Daten einer Festplatte zu gelangen. Falls jedoch der Rechner kompromittiert wurde, während er im Betrieb war und das Speichergerät aktiv verbunden war, oder wenn der Angreifer eine gültige Passphrase kennt, bietet dieses System keinen Schutz für die Daten der Festplatte. Daher ist es wichtig, für die physische Sicherheit zu sorgen, während das System im Betrieb ist. Außerdem muss die Passphrase für den Verschlüsselungsmechanismus geschützt werden.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> besitzt einige Funktionen um die Daten, die in einem Sektor gespeichert sind, zu schützen. Es benutzt 128-Bit AES im CBC-Modus, um die Daten eines Sektors zu verschlüsseln. Jeder Sektor einer Festplatte wird mit einem anderen AES-Schlüssel verschlüsselt. Weitere Informationen zum kryptographischen Design und wie die Schlüssel für einen Sektor aus der gegebenen Passphrase ermittelt werden, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a>.</p></div><div class=paragraph><p>FreeBSD enthält ein Kernelmodul für gbde, das wie folgt geladen werden kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_bde</span></code></pre></div></div><div class=paragraph><p>Wenn Sie einen angepassten Kernel verwenden, stellen Sie sicher, dass folgende Zeile in der Kernelkonfigurationsdatei enthalten ist:</p></div><div class=paragraph><p><code>options GEOM_BDE</code></p></div><div class=paragraph><p>Das folgende Beispiel beschreibt, wie eine Partition auf einer neuen Festplatte verschlüsselt wird. Die Partition wird in <span class=filename>/private</span> eingehangen.</p></div><div class="olist arabic procedure"><div class=title>Procedure: Eine Partition mit gbde verschlüsseln</div><ol class=arabic><li><p>Installieren der Festplatte</p><div class=paragraph><p>Installieren Sie die Festplatte wie in <a href=#disks-adding>Hinzufügen von Laufwerken</a> beschrieben. Im Beispiel wird die Partition <span class=filename>/dev/ad4s1c</span> verwendet. Die Gerätedateien <span class=filename>/dev/ad0s1*</span> sind Standard-Partitionen des FreeBSD-Systems.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</code></pre></div></div></li><li><p>Verzeichnis für gbde-Lock-Dateien anlegen</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /etc/gbde</span></code></pre></div></div><div class=paragraph><p>Die Lock-Dateien sind für den Zugriff von gbde auf verschlüsselte Partitionen notwendig. Ohne die Lock-Dateien können die Daten nur mit erheblichem manuellen Aufwand wieder entschlüsselt werden (dies wird auch von der Software nicht unterstützt). Jede verschlüsselte Partition benötigt eine gesonderte Lock-Datei.</p></div></li><li><p>Vorbereiten der gbde-Partition</p><div class=paragraph><p>Eine von gbde benutzte Partition muss einmalig initialisiert werden, bevor sie benutzt werden kann. Das Programm öffnet eine Vorlage im Standard-Editor, um verschiedene Optionen zu konfigurieren. Setzen Sie <code>sector_size</code> auf <code>2048</code>, wenn Sie UFS benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</span>
<span class=nv>$FreeBSD</span>: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp <span class=err>$</span>
<span class=c>#</span>
<span class=c># Sector size is the smallest unit of data which can be read or written.</span>
<span class=c># Making it too small decreases performance and decreases available space.</span>
<span class=c># Making it too large may prevent filesystems from working.  512 is the</span>
<span class=c># minimum and always safe.  For UFS, use the fragment size</span>
<span class=c>#</span>
sector_size     <span class=o>=</span>       2048
<span class=o>[</span>...]</code></pre></div></div><div class=paragraph><p>Sobald die Änderungen gespeichert werden, wird der Benutzer zweimal aufgefordert, die zum Schutz der Daten verwendete Passphrase einzugeben. Die Passphrase muss beide Mal gleich eingegeben werden. Die Sicherheit der Daten hängt allein von der Qualität der gewählten Passphrase ab. Die Auswahl einer sicheren und leicht zu merkenden Passphrase wird auf der Webseite <a href=http://world.std.com/~reinhold/diceware.html>http://world.std.com/~reinhold/diceware.html</a> beschrieben.</p></div><div class=paragraph><p>Bei der Initialisierung wird eine Lock-Datei für die gbde-Partition erstellt. In diesem Beispiel <span class=filename>/etc/gbde/ad4s1c.lock</span>. Lock-Dateien müssen die Dateiendung ".lock" aufweisen, damit sie von <span class=filename>/etc/rc.d/gbde</span>, dem Startskript von gbde, erkannt werden.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Lock-Dateien müssen immer zusammen mit den verschlüsselten Dateisystemen gesichert werden. Ohne die Lock-Datei können Sie allerdings nicht auf die verschlüsselten Daten zugreifen.</p></div></td></tr></tbody></table></div></li><li><p>Einbinden der verschlüsselten Partition in den Kernel</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</span></code></pre></div></div><div class=paragraph><p>Dieses Kommando fragt die Passphrase ab, die bei der Initialisierung der verschlüsselten Partition eingegeben wurde. Das neue verschlüsselte Gerät erscheint danach in <span class=filename>/dev</span> als <span class=filename>/dev/device_name.bde</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</code></pre></div></div></li><li><p>Dateisystem auf dem verschlüsselten Gerät anlegen</p><div class=paragraph><p>Nachdem die verschlüsselte Partition im Kernel eingebunden ist, kann ein Dateisystem erstellt werden. Dieses Beispiel erstellt ein UFS-Dateisystem mit aktivierten Soft Updates. Achten Sie darauf, die Partition mit der Erweiterung <span class=filename>*.bde</span> zu benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U -O2 /dev/ad4s1c.bde</span></code></pre></div></div></li><li><p>Einhängen der verschlüsselten Partition</p><div class=paragraph><p>Legen Sie einen Mountpunkt für das verschlüsselte Dateisystem an. Hängen Sie anschließend das Dateisystem ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /private</span>
<span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div></li><li><p>Überprüfen des verschlüsselten Dateisystems</p><div class=paragraph><p>Das verschlüsselte Dateisystem sollte jetzt erkannt und benutzt werden können:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>df</span> <span class=nt>-H</span>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div><div class=paragraph><p>Nach jedem Neustart müssen verschlüsselte Dateisysteme dem Kernel wieder bekannt gemacht werden, auf Fehler überprüft werden und eingehangen werden. Für die dazu nötigen Schritte fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>gbde_autoattach_all=&#34;YES&#34;
gbde_devices=&#34;ad4s1c&#34;
gbde_lockdir=&#34;/etc/gbde&#34;</pre></div></div><div class=paragraph><p>Durch diese Argumente muss beim Systemstart auf der Konsole die Passphrase eingegeben werden. Erst nach Eingabe der korrekten Passphrase wird die verschlüsselte Partition automatisch in den Verzeichnisbaum eingehängt. Weitere Bootoptionen von gbde finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>sysinstall ist nicht kompatibel mit gbde-verschlüsselten Geräten. Bevor sysinstall gestartet wird, müssen alle <span class=filename>*.bde</span> Geräte vom Kernel getrennt werden, da sonst der Kernel bei der ersten Suche nach Geräten abstürzt. Um das verschlüsselte Gerät aus dem Beispiel zu trennen, benutzen Sie das folgende Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde detach /dev/ad4s1c</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=disks-encrypting-geli>35.12.2. Plattenverschlüsselung mit <code>geli</code><a class=anchor href=#disks-encrypting-geli></a></h4><div class=paragraph><p>Mit <code>geli</code> steht eine alternative kryptografische GEOM-Klasse zur Verfügung. Dieses Werkzeug unterstützt unterschiedliche Fähigkeiten und verfolgt einen anderen Ansatz für die Verschlüsselung. geli bietet die folgenden Funktionen:</p></div><div class=ulist><ul><li><p>Die Nutzung des <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=9&amp;format=html">crypto(9)</a>-Frameworks. Wenn das System über kryptografische Hardware verfügt, wird diese von <code>geli</code> automatisch verwendet.</p></li><li><p>Die Unterstützung verschiedener kryptografischer Algorithmen, wie AES, Blowfish, und 3DES.</p></li><li><p>Die Möglichkeit, die root-Partition zu verschlüsseln. Um auf die verschlüsselte root-Partition zugreifen zu können, muss beim Systemstart die Passphrase eingegeben werden.</p></li><li><p>Erlaubt den Einsatz von zwei voneinander unabhängigen Schlüsseln.</p></li><li><p>Es ist durch einfache Sektor-zu-Sektor-Verschlüsselung sehr schnell.</p></li><li><p>Die Möglichkeit, Master-Keys zu sichern und wiederherzustellen. Wenn ein Benutzer seinen Schlüssel zerstört, kann er über seinen zuvor gesicherten Schlüssel wieder auf seine Daten zugreifen.</p></li><li><p><code>geli</code> erlaubt es, Platten mit einem zufälligen Einmal-Schlüssel einzusetzen, was für Swap-Partitionen und temporäre Dateisysteme interessant ist.</p></li></ul></div><div class=paragraph><p>Weitere Funktionen und Anwendungsbeispiele finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></div><div class=paragraph><p>Das folgende Beispiel beschreibt, wie eine Schlüsseldatei erzeugt wird, die als Teil des Master-Keys für den Verschlüsselungs-Provider verwendet wird, der unter <span class=filename>/private</span> in den Verzeichnisbaum eingehängt wird. Die Schlüsseldatei liefert zufällige Daten, die für die Verschlüsselung des Master-Keys benutzt werden. Zusätzlich wird der Master-Key durch eine Passphrase geschützt. Die Sektorgröße des Providers beträgt 4 KB. Das Beispiel beschreibt, wie Sie einen <code>geli</code>-Provider aktivieren, ein vom ihm verwaltetes Dateisystem erzeugen, es mounten, mit ihm arbeiten und wie Sie es schließlich wieder unmounten und den Provider deaktivieren.</p></div><div class="olist arabic procedure"><div class=title>Procedure: Eine Partition mit <code>geli</code> verschlüsseln</div><ol class=arabic><li><p>Laden der <code>geli</code>-Unterstützung</p><div class=paragraph><p>Die Unterstützung für <code>geli</code> wird über ein ladbares Kernelmodul zur Verfügung gestellt. Damit das Modul automatisch beim Booten geladen wird, fügen Sie folgende Zeile in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_eli_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Um das Modul direkt zu laden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_eli</span></code></pre></div></div><div class=paragraph><p>Stellen Sie bei einer angepassten Kernelkonfigurationsdatei sicher, dass diese Zeilen enthalten sind:</p></div><div class="literalblock programlisting"><div class=content><pre>options GEOM_ELI
device crypto</pre></div></div></li><li><p>Erzeugen des Master-Keys</p><div class=paragraph><p>Die folgenden Befehle erzeugen einen Master-Key, mit dem alle Daten verschlüsselt werden. Dieser Schlüssel kann niemals geändert werden. Anstatt ihn direkt zu benutzen, wird er mit einem oder mehrere Schlüsseln verschlüsselt. Die Schlüssel bestehen aus einer optionalen Kombination von zufälligen Bytes aus einer Datei, <span class=filename>/root/da2.key</span>, und/oder einer Passphrase. In diesem Fall ist die Datenquelle der Schlüsseldatei <span class=filename>/dev/random</span>. Dieser Befehl konfiguriert auch die Sektorgröße des Providers (<span class=filename>/dev/da2.eli</span>) mit 4 KB, um eine bessere Leistung zu erzielen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/root/da2.key bs=64 count=1</span>
<span class=c># geli init -K /root/da2.key -s 4096 /dev/da2</span>
Enter new passphrase:
Reenter new passphrase:</code></pre></div></div><div class=paragraph><p>Es ist nicht zwingend nötig, sowohl eine Passphrase als auch eine Schlüsseldatei zu verwenden. Die einzelnen Methoden können auch unabhängig voneinander eingesetzt werden.</p></div><div class=paragraph><p>Wird für die Schlüsseldatei "-" angegeben, wird dafür die Standardeingabe verwendet. Das folgende Kommando erzeugt beispielsweise drei Schlüsseldateien:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</span></code></pre></div></div></li><li><p>Aktivieren des Providers mit dem erzeugten Schlüssel</p><div class=paragraph><p>Um den Provider zu aktivieren, geben Sie die Schlüsseldatei, den Namen des Laufwerks und die Passphrase an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geli attach -k /root/da2.key /dev/da2</span>
Enter passphrase:</code></pre></div></div><div class=paragraph><p>Dadurch wird ein neues Gerät mit der Erweiterung <span class=filename>.eli</span> angelegt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/da2*</span>
/dev/da2  /dev/da2.eli</code></pre></div></div></li><li><p>Das neue Dateisystem erzeugen</p><div class=paragraph><p>Als nächstes muss das Gerät mit dem UFS-Dateisystem formatiert und an einen vorhandenen Mountpunkt eingehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/da2.eli bs=1m</span>
<span class=c># newfs /dev/da2.eli</span>
<span class=c># mount /dev/da2.eli /private</span></code></pre></div></div><div class=paragraph><p>Das verschlüsselte Dateisystem sollte jetzt erkannt und benutzt werden können:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df -H</span>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div><div class=paragraph><p>Wenn Sie nicht mehr mit dem verschlüsselten Dateisystem arbeiten und die unter <span class=filename>/private</span> eingehängte Partition daher nicht mehr benötigen, sollten Sie diese unmounten und den <code>geli</code>-Verschlüsselungs-Provider wieder deaktivieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /private</span>
<span class=c># geli detach da2.eli</span></code></pre></div></div><div class=paragraph><p>FreeBSD verfügt über ein <span class=filename>rc.d</span>-Skript, das dass Einhängen von verschlüsselten Geräten beim Booten deutlich vereinfacht. Für dieses Beispiel, fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>geli_devices=&#34;da2&#34;
geli_da2_flags=&#34;-p -k /root/da2.key&#34;</pre></div></div><div class=paragraph><p>Dies konfiguriert <span class=filename>/dev/da2</span> als <code>geli</code>-Provider mit dem Master-Key <span class=filename>/root/da2.key</span>. Das System wird den Provider automatisch deaktivieren, bevor es heruntergefahren wird. Während des Startvorgangs fordert das Skript die Passphrase an, bevor der Provider aktiviert wird. Vor und nach der Eingabeaufforderung für die Passphrase werden noch weitere Kernelmeldungen angezeigt. Achten Sie sorgfältig auf die Eingabeaufforderung zwischen den anderen Meldungen, falls es zu Problemen beim Startvorgang kommt. Sobald die richtige Passphrase eingegeben wurde, wird der Provider aktiviert. Anschließend werden die Dateisysteme gemäß <span class=filename>/etc/fstab</span> eingehängt. Lesen Sie <a href=./#mount-unmount>“Anhängen und Abhängen von Dateisystemen”</a> wenn Sie wissen möchten, wie Sie ein Dateisystem konfigurieren, sodass es beim booten automatisch gestartet wird.</p></div></div></div><div class=sect2><h3 id=swap-encrypting>35.13. Den Auslagerungsspeicher verschlüsseln<a class=anchor href=#swap-encrypting></a></h3><div class=paragraph><p>Wie die Verschlüsselung von Partitionen, wird auch der Auslagerungsspeicher verschlüsselt, um sensible Informationen zu schützen. Stellen Sie sich eine Anwendung vor, die mit Passwörtern umgeht. Solange sich diese Passwörter im Arbeitsspeicher befinden, werden sie nicht auf die Festplatte geschrieben und nach einem Neustart gelöscht. Falls FreeBSD jedoch damit beginnt Speicher auszulagern, um Platz für andere Anwendungen zu schaffen, können die Passwörter unverschlüsselt auf die Festplatte geschrieben werden. Die Verschlüsselung des Auslagerungsspeichers kann in solchen Situationen Abhilfe schaffen.</p></div><div class=paragraph><p>Dieser Abschnitt zeigt die Konfiguration eines verschlüsselten Auslagerungsspeichers mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>. In den Beispielen repräsentiert <span class=filename>/dev/ada0s1b</span> die Swap-Partition.</p></div><div class=sect3><h4 id=_konfiguration_eines_verschlüsselten_auslagerungsspeichers>35.13.1. Konfiguration eines verschlüsselten Auslagerungsspeichers<a class=anchor href=#_konfiguration_eines_verschlüsselten_auslagerungsspeichers></a></h4><div class=paragraph><p>Swap-Partitionen werden standardmäßig nicht verschlüsselt. Sie sollten daher alle sensiblen Daten im Auslagerungsspeicher löschen, bevor Sie fortfahren. Führen Sie folgenden Befehl aus, um die Swap-Partition mit Zufallsdaten zu überschreiben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/ada0s1b bs=1m</span></code></pre></div></div><div class=paragraph><p>Um den Auslagerungsspeicher mit <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> zu verschlüsseln, fügen Sie in <span class=filename>/etc/fstab</span> das Suffix <code>.bde</code> an den Gerätenamen der Swap-Partition hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ada0s1b.bde         none            swap    sw              0       0</pre></div></div><div class=paragraph><p>Wenn Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> benutzen, verwenden Sie stattdessen das Suffix <code>.eli</code>, um den Auslagerungsspeicher zu verschlüsseln:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ada0s1b.eli         none            swap    sw              0       0</pre></div></div><div class=paragraph><p>In der Voreinstellung verschlüsselt <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> mit dem AES-Algorithmus und einer Schlüssellänge von 128 Bit. Diese Voreinstellungen sind in der Regel ausreichend, können jedoch im Options-Feld in <span class=filename>/etc/fstab</span> angepasst werden. Mögliche Optionen sind:</p></div><div class=dlist><dl><dt class=hdlist1>aalgo</dt><dd><p>Der Algorithmus für die Prüfung der Datenintegrität. Dieser wird benutzt um sicherzustellen, dass die verschlüsselten Daten nicht manipuliert wurden. Eine Liste der unterstützten Algorithmen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></dd><dt class=hdlist1>ealgo</dt><dd><p>Der Verschlüsselungsalgorithmus, der verwendet wird um die Daten zu schützen. Eine Liste der unterstützten Algorithmen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></dd><dt class=hdlist1>keylen</dt><dd><p>Die Länge des Schlüssels für den Verschlüsselungsalgorithmus. In <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> können Sie lesen, welche Schlüssellängen von welchem Algorithmus unterstützt werden.</p></dd><dt class=hdlist1>sectorsize</dt><dd><p>Die Größe, in der die Datenblöcke aufgeteilt werden, bevor sie verschlüsselt werden. Größere Blöcke erhöhen die Leistung auf Kosten des Speicherverbrauchs. Die empfohlene Größe beträgt 4096 Byte.</p></dd></dl></div><div class=paragraph><p>Dieses Beispiel konfiguriert eine verschlüsselte Swap-Partition mit dem Blowfish-Algorithmus, einer Schlüssellänge von 128 Bit und einer Sektorgröße von 4 KB:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options				Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw,ealgo=blowfish,keylen=128,sectorsize=4096	0	0</pre></div></div></div><div class=sect3><h4 id=_überprüfung_des_verschlüsselten_auslagerungsspeichers>35.13.2. Überprüfung des verschlüsselten Auslagerungsspeichers<a class=anchor href=#_überprüfung_des_verschlüsselten_auslagerungsspeichers></a></h4><div class=paragraph><p>Nachdem das System neu gestartet wurde, kann die korrekte Funktion des verschlüsselten Auslagerungsspeichers mit <code>swapinfo</code> geprüft werden.</p></div><div class=paragraph><p>Wenn Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> einsetzen, erhalten Sie eine Meldung ähnlich der folgenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.bde    542720        0   542720     0%</code></pre></div></div><div class=paragraph><p>Wenn Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> einsetzen, erhalten Sie hingegen eine Ausgabe ähnlich der folgenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.eli    542720        0   542720     0%</code></pre></div></div></div></div><div class=sect2><h3 id=disks-hast>35.14. Highly Available Storage (HAST)<a class=anchor href=#disks-hast></a></h3><div class=paragraph><p>Hochverfügbarkeit ist eine der Hauptanforderungen von ernsthaften Geschäftsanwendungen und hochverfügbarer Speicher ist eine Schlüsselkomponente in solchen Umgebungen. Highly Available STorage (HAST) ist ein Framework in FreeBSD, welches die transparente Speicherung der gleichen Daten über mehrere physikalisch getrennte Maschinen ermöglicht, die über ein TCP/IP-Netzwerk verbunden sind. HAST kann als ein netzbasiertes RAID1 (Spiegel) verstanden werden und ist dem DRBD®-Speichersystem der GNU/Linux®-Plattform ähnlich. In Kombination mit anderen Hochverfügbarkeitseigenschaften von FreeBSD wie CARP, ermöglicht es HAST, hochverfügbare Speichercluster zu bauen, die in der Lage sind, Hardwareausfällen zu widerstehen.</p></div><div class=paragraph><p>Die Hauptmerkmale von HAST sind:</p></div><div class=ulist><ul><li><p>Es kann zur Maskierung von I/O-Fehlern auf lokalen Festplatten eingesetzt werden.</p></li><li><p>Dateisystem-unabhängig, was es erlaubt, jedes von FreeBSD unterstützte Dateisystem zu verwenden.</p></li><li><p>Effiziente und schnelle Resynchronisation: es werden nur die Blöcke synchronisiert, die während der Ausfallzeit eines Knotens geändert wurden.</p></li><li><p>Es kann in einer bereits bestehenden Umgebung eingesetzt werden, um zusätzliche Redundanz zu erreichen.</p></li><li><p>Zusammen mit CARP, Heartbeat, oder anderen Werkzeugen, ist es möglich, ein robustes und dauerhaftes Speichersystem zu bauen.</p></li></ul></div><div class=paragraph><p>Nachdem Sie diesen Abschnitt gelesen haben, werden Sie folgendes wissen:</p></div><div class=ulist><ul><li><p>Was HAST ist, wie es funktioniert und welche Eigenschaften es besitzt.</p></li><li><p>Wie man HAST unter FreeBSD aufsetzt und verwendet.</p></li><li><p>Wie man CARP und <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> kombiniert, um ein robustes Speichersystem zu bauen.</p></li></ul></div><div class=paragraph><p>Bevor Sie diesen Abschnitt lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>die Grundlagen von UNIX® und FreeBSD verstanden haben (<a href=./#basics>Grundlagen des FreeBSD Betriebssystems</a>).</p></li><li><p>wissen, wie man Netzwerkschnittstellen und andere Kernsysteme von FreeBSD konfiguriert (<a href=./#config-tuning>Konfiguration und Tuning</a>).</p></li><li><p>ein gutes Verständnis der FreeBSD-Netzwerkfunktionalität besitzen (<a href=./#network-communication>Netzwerke</a>).</p></li></ul></div><div class=paragraph><p>Das HAST-Projekt wurde von der FreeBSD Foundation mit Unterstützung der <a href=http://www.omc.net/>OMCnet Internet Service GmbH</a> und <a href=http://www.transip.nl/>TransIP BV</a> gesponsert.</p></div><div class=sect3><h4 id=_hast_im_einsatz>35.14.1. HAST im Einsatz<a class=anchor href=#_hast_im_einsatz></a></h4><div class=paragraph><p>HAST bietet eine synchrone Replikation auf Blockebene zwischen zwei Maschinen: einem <code>primary</code>, auch bekannt als <code>master</code> Knoten, sowie dem <code>secondary</code>, oder <code>slave</code> Knoten. Diese beiden Maschinen zusammen werden als Cluster bezeichnet.</p></div><div class=paragraph><p>Da HAST in einer primär-sekundär-Konfiguration funktioniert, ist immer nur ein Knoten des Clusters zu jeder Zeit aktiv. Der primäre Knoten, auch <em>active</em> genannt, ist derjenige, der alle I/O-Anfragen verarbeitet, die an die HAST-Schnittstelle gesendet werden. Der sekundäre Knoten wird automatisch vom primären Knoten aus synchronisiert.</p></div><div class=paragraph><p>Die physischen Komponenten des HAST-Systems sind die lokale Platte am Primärknoten und die entfernte Platte am Sekundärknoten.</p></div><div class=paragraph><p>HAST arbeitet synchron auf Blockebene, was es für Dateisysteme und Anwendungen transparent macht. HAST stellt gewöhnliche GEOM-Provider in <span class=filename>/dev/hast/</span> für die Verwendung durch andere Werkzeuge oder Anwendungen zur Verfügung. Es gibt keinen Unterschied zwischen dem Einsatz von HAST bereitgestellten Geräten und herkömmlichen Platten oder Partitionen.</p></div><div class=paragraph><p>Jede Schreib-, Lösch- oder Entleerungsoperation wird an die lokale und über TCP/IP zu der entfernt liegenden Platte gesendet. Jede Leseoperation wird von der lokalen Platte durchgeführt, es sei denn, die lokale Platte ist nicht aktuell oder es tritt ein I/O-Fehler auf. In solchen Fällen wird die Leseoperation an den Sekundärknoten geschickt.</p></div><div class=paragraph><p>HAST versucht, eine schnelle Fehlerbereinigung zu gewährleisten. Aus diesem Grund ist es wichtig, die Synchronisationszeit nach dem Ausfall eines Knotens zu reduzieren. Um eine schnelle Synchronisation zu ermöglichen, verwaltet HAST eine Bitmap von unsauberen Bereichen auf der Platte und synchronisiert nur diese während einer regulären Synchronisation (mit Ausnahme der initialen Synchronisation).</p></div><div class=paragraph><p>Es gibt viele Wege, diese Synchronisation zu behandeln. HAST implementiert mehrere Replikationsarten, um unterschiedliche Methoden der Synchronisation zu realisieren:</p></div><div class=ulist><ul><li><p><em>memsync</em>: Dieser Modus meldet Schreiboperationen als vollständig, wenn die lokale Schreiboperation beendet ist und der entfernt liegende Knoten die Ankunft der Daten bestätigt hat, jedoch bevor die Daten wirklich gespeichert wurden. Die Daten werden auf dem entfernt liegenden Knoten direkt nach dem Senden der Bestätigung gespeichert. Dieser Modus ist dafür gedacht, Latenzen zu verringern und zusätzlich eine gute Verlässlichkeit zu bieten. In der Voreinstellung wird dieser Modus benutzt.</p></li><li><p><em>fullsync</em>: Dieser Modus meldet Schreiboperationen als vollständig, wenn sowohl die lokale, als auch die entfernte Schreiboperation abgeschlossen wurde. Dies ist der sicherste und zugleich der langsamste Replikationsmodus.</p></li><li><p><em>async</em>: Dieser Modus meldet Schreiboperationen als vollständig, wenn lokale Schreibvorgänge abgeschlossen wurden. Dies ist der schnellste und gefährlichste Replikationsmodus. Er sollte nur verwendet werden, wenn die Latenz zu einem entfernten Knoten bei einer Replikation zu hoch ist für andere Modi.</p></li></ul></div></div><div class=sect3><h4 id=_hast_konfiguration>35.14.2. HAST-Konfiguration<a class=anchor href=#_hast_konfiguration></a></h4><div class=paragraph><p>Das HAST-Framework besteht aus mehreren Komponenten:</p></div><div class=ulist><ul><li><p>Dem <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a>-Daemon, welcher für Datensynchronisation verantwortlich ist. Wenn dieser Daemon gestartet wird, wird automatisch <code>geom_gate.ko</code> geladen.</p></li><li><p>Dem <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a> Management-Werkzeug.</p></li><li><p>Der Konfigurationsdatei <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a>. Diese Datei muss vorhanden sein, bevor hastd gestartet wird.</p></li></ul></div><div class=paragraph><p>Alternativ lässt sich die <code>GEOM_GATE</code>-Unterstützung in den Kernel statisch einbauen, indem folgende Zeile zur Kernelkonfigurationsdatei hinzugefügt wird. Anschließend muss der Kernel, wie in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> beschrieben, neu gebaut werden:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_GATE</pre></div></div><div class=paragraph><p>Das folgende Beispiel beschreibt, wie man zwei Knoten als master-slave / primary-secondary mittels HAST konfiguriert, um Daten zwischen diesen beiden auszutauschen. Die Knoten werden als <code>hasta</code> mit der IP-Adresse <code>172.16.0.1</code> und <code>hastb</code> mit der IP-Adresse <code>172.16.0.2</code> bezeichnet. Beide Knoten besitzen eine dedizierte Festplatte <span class=filename>/dev/ad6</span> mit der gleichen Größe für den HAST-Betrieb. Der HAST-Pool, manchmal auch Ressource genannt, oder der GEOM-Provider in <span class=filename>/dev/hast/</span> wird als <span class=filename>test</span> bezeichnet.</p></div><div class=paragraph><p>Die Konfiguration von HAST wird in <span class=filename>/etc/hast.conf</span> vorgenommen. Diese Datei sollte auf beiden Knoten gleich sein. Die einfachste Konfiguration ist folgende:</p></div><div class="literalblock programlisting"><div class=content><pre>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</pre></div></div><div class=paragraph><p>Fortgeschrittene Konfigurationsmöglichkeiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Es ist ebenfalls möglich, den Hostnamen in den <code>remote</code>-Anweisungen zu verwenden, falls die Rechner aufgelöst werden können und in <span class=filename>/etc/hosts</span>, oder im lokalen DNS definiert sind.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald die Konfiguration auf beiden Rechnern vorhanden ist, kann ein HAST-Pool erstellt werden. Lassen Sie diese Kommandos auf beiden Knoten ablaufen, um die initialen Metadaten auf die lokale Platte zu schreiben und starten Sie anschließend <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl create test</span>
<span class=c># service hastd onestart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es ist <em>nicht</em> möglich, GEOM-Provider mit einem bereits bestehenden Dateisystem zu verwenden, um beispielsweise einen bestehenden Speicher in einen von HAST verwalteten Pool zu konvertieren. Dieses Verfahren muss einige Metadaten auf den Provider schreiben und dafür würde nicht genug freier Platz zur Verfügung stehen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Rolle eines HAST Knotens, <code>primary</code> oder <code>secondary</code>, wird vom einem Administrator, oder einer Software wie Heartbeat, mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a> festgelegt. Auf dem primären Knoten <code>hasta</code> geben Sie diesen Befehl ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role primary test</span></code></pre></div></div><div class=paragraph><p>Geben Sie folgendes Kommando auf dem sekundären Knoten <code>hastb</code> ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role secondary test</span></code></pre></div></div><div class=paragraph><p>Überprüfen Sie das Ergebnis mit <code>hastctl</code> auf beiden Knoten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl status test</span></code></pre></div></div><div class=paragraph><p>Überprüfen Sie die <code>status</code>-Zeile. Wird hier <code>degraded</code> angezeigt, dann ist etwas mit der Konfigurationsdatei nicht in Ordnung. Auf jedem Konten sollte <code>complete</code> angezeigt werden, was bedeutet, dass die Synchronisation zwischen den beiden Knoten gestartet wurde. Die Synchronisierung ist abgeschlossen, wenn <code>hastctl status</code> meldet, dass die <code>dirty</code>-Bereiche 0 Bytes betragen.</p></div><div class=paragraph><p>Der nächste Schritt ist, ein Dateisystem auf dem GEOM-Provider anzulegen und dieses ins System einzuhängen. Dies muss auf dem <code>primary</code>-Knoten durchgeführt werden. Die Erstellung des Dateisystems kann ein paar Minuten dauern, abhängig von der Größe der Festplatte. Dieses Beispiel erstellt ein UFS-Dateisystem auf <span class=filename>/dev/hast/test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/hast/test</span>
<span class=c># mkdir /hast/test</span>
<span class=c># mount /dev/hast/test /hast/test</span></code></pre></div></div><div class=paragraph><p>Sobald das HAST-Framework richtig konfiguriert wurde, besteht der letzte Schritt nun darin, sicherzustellen, dass HAST während des Systemstarts automatisch gestartet wird. Fügen Sie diese Zeile in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>hastd_enable=&#34;YES&#34;</pre></div></div><div class=sect4><h5 id=_failover_konfiguration>35.14.2.1. Failover-Konfiguration<a class=anchor href=#_failover_konfiguration></a></h5><div class=paragraph><p>Das Ziel dieses Beispiels ist, ein robustes Speichersystem zu bauen, welches Fehlern auf einem beliebigen Knoten widerstehen kann. Wenn der <code>primary</code>-Knoten ausfällt, ist der <code>secondary</code>-Knoten da, um nahtlos einzuspringen, das Dateisystem zu prüfen, einzuhängen und mit der Arbeit fortzufahren, ohne dass auch nur ein einzelnes Bit an Daten verloren geht.</p></div><div class=paragraph><p>Um diese Aufgabe zu bewerkstelligen, wird das Common Address Redundancy Protocol (CARP) benutzt, welches ein automatisches Failover auf der IP-Schicht ermöglicht. CARP erlaubt es mehreren Rechnern im gleichen Netzsegment, die gleiche IP-Adresse zu verwenden. Setzen Sie CARP auf beiden Knoten des Clusters anhand der Dokumentation in <a href=./#carp>“Common Address Redundancy Protocol (CARP)”</a> auf. In diesem Beispiel hat jeder Knoten seine eigene Management IP-Adresse und die geteilte IP-Adresse <em>172.16.0.254</em>. Der primäre HAST-Knoten des Clusters muss der CARP-Masterknoten sein.</p></div><div class=paragraph><p>Der HAST-Pool, welcher im vorherigen Abschnitt erstellt wurde, ist nun bereit für den Export über das Netzwerk auf den anderen Rechner. Dies kann durch den Export über NFS oder Samba erreicht werden, indem die geteilte IP-Adresse <em>172.16.0.254</em> verwendet wird. Das einzige ungelöste Problem ist der automatische Failover, sollte der primäre Knoten einmal ausfallen.</p></div><div class=paragraph><p>Falls die CARP-Schnittstelle aktiviert oder deaktiviert wird, generiert das FreeBSD-Betriebssystem ein <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>-Ereignis, was es ermöglicht, Zustandsänderungen auf den CARP-Schnittstellen zu überwachen. Eine Zustandsänderung auf der CARP-Schnittstelle ist ein Indiz dafür, dass einer der Knoten gerade ausgefallen oder wieder verfügbar ist. Diese Zustandsänderungen machen es möglich, ein Skript zu starten, welches automatisch den HAST-Failover durchführt.</p></div><div class=paragraph><p>Um Zustandsänderungen auf der CARP-Schnittstelle abzufangen, müssen diese Zeilen in <span class=filename>/etc/devd.conf</span> auf jedem Knoten hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_UP&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch master&#34;;
};

notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_DOWN&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch slave&#34;;
};</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn auf dem System FreeBSD 10 oder höher eingesetzt wird, ersetzen Sie <span class=filename>carp0</span> durch den Namen der konfigurierten Schnittstelle für CARP.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Starten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> auf beiden Knoten neu, um die neue Konfiguration wirksam werden zu lassen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p>Wenn die Schnittstelle aktiviert oder deaktiviert wird, erzeugt das System eine Meldung, was es dem <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>-Subsystem ermöglicht, ein automatisches Failover-Skript zu starten, <span class=filename>/usr/local/sbin/carp-hast-switch</span>. Weitere Informationen zu dieser Konfiguration finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=devd.conf&amp;sektion=5&amp;format=html">devd.conf(5)</a>.</p></div><div class=paragraph><p>Es folgt ein Beispiel für ein automatisches Failover-Skript:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources=&#34;test&#34;

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log=&#34;local0.debug&#34;
name=&#34;carp-hast&#34;

# end of user configurable stuff

case &#34;$1&#34; in
	master)
		logger -p $log -t $name &#34;Switching to primary provider for ${resources}.&#34;
		sleep ${delay}

		# Wait for any &#34;hastd secondary&#34; processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf &#34;hastd: ${disk} \(secondary\)&#34; &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to change role to primary for resource ${disk}.&#34;
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c &#34;/dev/hast/${disk}&#34; ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c &#34;/dev/hast/${disk}&#34; ]; then
				logger -p $log -t $name &#34;GEOM provider /dev/hast/${disk} did not appear.&#34;
				exit 1
			fi
		done

		logger -p $log -t $name &#34;Role for HAST resources ${resources} switched to primary.&#34;

		logger -p $log -t $name &#34;Mounting disks.&#34;
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name &#34;Switching to secondary provider for ${resources}.&#34;

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q &#34;^/dev/hast/${disk} on &#34;
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to switch role to secondary for resource ${disk}.&#34;
				exit 1
			fi
			logger -p $log -t $name &#34;Role switched to secondary for resource ${disk}.&#34;
		done
	;;
esac</pre></div></div><div class=paragraph><p>Im Kern führt das Skript die folgenden Aktionen durch, sobald ein Knoten zum Master wird:</p></div><div class=ulist><ul><li><p>Es ernennt den HAST-Pool als den primären für einen gegebenen Knoten.</p></li><li><p>Es prüft das Dateisystem, dass auf dem HAST-Pool erstellt wurde.</p></li><li><p>Es hängt den Pool ins System ein.</p></li></ul></div><div class=paragraph><p>Wenn ein Knoten zum Sekundären ernannt wird:</p></div><div class=ulist><ul><li><p>Hängt es den HAST-Pool aus dem Dateisystem aus.</p></li><li><p>Degradiert es den HAST-Pool zum sekundären.</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Dieses Skript ist nur ein Beispiel für eine mögliche Lösung. Es behandelt nicht alle möglichen Szenarien, die auftreten können und sollte erweitert bzw. abgeändert werden, so dass z.B. benötigte Dienste gestartet oder gestoppt werden.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Für dieses Beispiel wurde ein UFS-Dateisystem verwendet. Um die Zeit für die Wiederherstellung zu verringern, kann ein UFS mit Journal oder ein ZFS-Dateisystem benutzt werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Weitere detaillierte Informationen mit zusätzlichen Beispielen können unter <a href=http://wiki.FreeBSD.org/HAST>http://wiki.FreeBSD.org/HAST</a> abgerufen werden.</p></div></div></div><div class=sect3><h4 id=_fehlerbehebung>35.14.3. Fehlerbehebung<a class=anchor href=#_fehlerbehebung></a></h4><div class=paragraph><p>HAST sollte generell ohne Probleme funktionieren. Jedoch kann es, wie bei jeder anderen Software auch, zu gewissen Zeiten sein, dass sie sich nicht so verhält wie angegeben. Die Quelle dieser Probleme kann unterschiedlich sein, jedoch sollte als Faustregel gewährleistet werden, dass die Zeit für alle Knoten im Cluster synchron läuft.</p></div><div class=paragraph><p>Für die Fehlersuche bei HAST sollte die Anzahl an Debugging-Meldungen von <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> erhöht werden. Dies kann durch das Starten von <code>hastd</code> mit <code>-d</code> erreicht werden. Diese Option kann mehrfach angegeben werden, um die Anzahl an Meldungen weiter zu erhöhen. Sie sollten ebenfalls die Verwendung von <code>-F</code> in Erwägung ziehen, was <code>hastd</code> im Vordergrund startet.</p></div><div class=sect4><h5 id=disks-hast-sb>35.14.3.1. Auflösung des Split-brain-Zustands<a class=anchor href=#disks-hast-sb></a></h5><div class=paragraph><p><code>split-brain</code> bezeichnet eine Situation, in der beide Knoten des Clusters nicht in der Lage sind, miteinander zu kommunizieren und dadurch beide als primäre Knoten fungieren. Dies ist ein gefährlicher Zustand, weil es beiden Knoten erlaubt ist, Änderungen an den Daten vorzunehmen, die miteinander nicht in Einklang gebracht werden können. Diese Situation muss vom Systemadministrator manuell bereinigt werden.</p></div><div class=paragraph><p>Der Administrator muss entscheiden, welcher Knoten die wichtigeren Änderungen besitzt, oder die Zusammenführung manuell durchführen. Anschließend kann HAST die volle Synchronisation mit dem Knoten durchführen, der die beschädigten Daten enthält. Um dies zu tun, geben Sie folgende Befehle auf dem Knoten ein, der neu synchronisiert werden muss:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role init test</span>
<span class=c># hastctl create test</span>
<span class=c># hastctl role secondary test</span></code></pre></div></div></div></div></div></div></div><div class=sect1><h2 id=geom>Kapitel 36. GEOM: Modulares Framework zur Plattentransformation<a class=anchor href=#geom></a></h2><div class=sectionbody><div class=sect2><h3 id=geom-synopsis>36.1. Übersicht<a class=anchor href=#geom-synopsis></a></h3><div class=paragraph><p>GEOM erlaubt den Zugriff und die Kontrolle von Klassen, wie beispielsweise Master Boot Records und BSD-Label, durch die Nutzung von Datenträgern (Providern) oder den besonderen Dateien in <span class=filename>/dev</span>. Verschiedene Software RAID-Konfigurationen unterstützend, gewährt GEOM transparenten Zugriff auf das Betriebssystem und die System-Dienstprogramme.</p></div><div class=paragraph><p>Dieses Kapitel behandelt den Einsatz von Laufwerken mit dem GEOM-Framework in FreeBSD. Dies beinhaltet auch die wichtigen RAID-Überwachungswerkzeuge, welche das Framework zur Konfiguration nutzen. Dieses Kapitel ist kein ausführlicher Leitfaden für RAID-Konfigurationen. Nur die von GEOM unterstützten RAID-Klassen werden erörtert.</p></div><div class=paragraph><p>Nach Lesen dieses Kapitels werden Sie folgendes wissen:</p></div><div class=ulist><ul><li><p>Welche Art von RAID-Unterstützung durch GEOM verfügbar ist.</p></li><li><p>Wie man die Basis-Dienstprogramme nutzt, um verschiedene RAID-Stufen zu konfigurieren, zu manipulieren und zu warten.</p></li><li><p>Wie man mittels GEOM spiegelt, striped, verschlüsselt und entfernte Laufwerke verbindet.</p></li><li><p>Wie man an Laufwerken, welche an das GEOM-Framework angeschlossen sind, Fehler behebt.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>Verstehen, wie FreeBSD Laufwerke behandelt (<a href=./#disks>Speichermedien</a>).</p></li><li><p>Wissen wie man einen neuen FreeBSD-Kernel konfiguriert und installiert (<a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a>).</p></li></ul></div></div><div class=sect2><h3 id=geom-striping>36.2. RAID0 - Striping<a class=anchor href=#geom-striping></a></h3><div class=paragraph><p>Striping (stripe = Streifen) fasst verschiedene Laufwerke in einem einzigen Datenträger zusammen. Dies wird durch die Nutzung von Hardware-Controllern bewerkstelligt. Das GEOM-Subsystem unterstützt Software-RAID0, welches auch als Striping bekannt ist. Bei dieser Technik wird kein RAID-Controller benötigt.</p></div><div class=paragraph><p>In einem RAID0-System werden die Daten in einzelne Blöcke aufgeteilt, welche über alle angeschlossenen Laufwerke in einem Datenfeld (Array) geschrieben werden. Anstatt darauf warten zu müssen, dass 256K auf ein einzelnes Laufwerk geschrieben werden, kann ein RAID0-System gleichzeitig 64K auf jedes von vier Laufwerken schreiben mit entsprechend besserer I/O-Leistung. Dieser Durchsatz kann durch die Verwendung mehrerer Controller noch zusätzlich gesteigert werden.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/geom/striping.png alt="Disk Striping Illustration"></div></div><div class=paragraph><p>Jedes Laufwerk in einem RAID0-Stripe muss die gleiche Größe haben, da I/O-Anforderungen für das Lesen und Schreiben abwechselnd auf mehrere Laufwerke parallel erfolgen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>RAID0 bietet keine Redundanz. Das bedeutet, dass wenn eine Platte im Array ausfällt, die gesamten Daten auf den Platten verloren gehen. Wenn es sich um wichtige Daten handelt, sollten Sie eine Backup-Strategie entwickeln, die regelmäßig Sicherungen auf einem entferntem System speichert.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Erstellung eines GEOM-basierten RAID0 auf einem FreeBSD-System wird im folgenden beschrieben. Nachdem das Stripe erzeugt wurde, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=gstripe&amp;sektion=8&amp;format=html">gstripe(8)</a> weitere Informationen zur Verwaltung der vorhandenen Stripes.</p></div><div class="sidebarblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Ein Stripe aus unformatierten ATA-Platten erzeugen</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Laden Sie das <span class=filename>geom_stripe.ko</span>-Modul:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_stripe</span></code></pre></div></div></li><li><p>Stellen Sie sicher, dass ein geeigneter Mountpunkt existiert. Falls dieser Datenträger eine Root-Partition werden soll, dann nutzen Sie zeitweise einen anderen Mountpunkt, beispielsweise <span class=filename>/mnt</span>.</p></li><li><p>Bestimmen Sie die Gerätenamen derjenigen Platten, welche gestriped werden sollen, und erzeugen Sie ein neues Stripe-Gerät. Das folgende Beispiel verwendet zwei unbenutzte und unpartitionierte ATA-Platten, die gestriped werden sollen. Die Gerätenamen lauten <span class=filename>/dev/ad2</span> und <span class=filename>/dev/ad3</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gstripe label -v st0 /dev/ad2 /dev/ad3</span>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</code></pre></div></div></li><li><p>Schreiben Sie einen Standard-Label (auch als Partitions-Tabelle bekannt) auf den neuen Datenträger und installieren Sie den normalen Bootstrap-Code:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/stripe/st0</span></code></pre></div></div></li><li><p>Dieser Prozess sollte zwei weitere Geräte im Verzeichnis <span class=filename>/dev/stripe</span> (zusätzlich zum Gerät <span class=filename>st0</span>) erzeugt haben. Diese schliessen <span class=filename>st0a</span> und <span class=filename>st0c</span> ein. Nun kann mit <code>newfs</code> ein UFS-Dateisystem auf dem Gerät <span class=filename>st0a</span> erzeugt werden:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/stripe/st0a</span></code></pre></div></div><div class=paragraph><p>Viele Zahlen rauschen nun über den Bildschirm und nach ein paar Sekunden wird der Prozess abgeschlossen sein. Der Datenträger wurde erzeugt und kann in den Verzeichnisbaum eingehängt werden.</p></div></li><li><p>Um das erzeugte Stripe manuell zu mounten:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/stripe/st0a /mnt</span></code></pre></div></div></li><li><p>Um das erzeugte Dateisystem automatisch während des Startvorgangs zu mounten, muss die Datenträgerinformation in <span class=filename>/etc/fstab</span> eingetragen werden. In diesem Beispiel wird ein permanenter Mountpunkt namens <span class=filename>stripe</span> erstellt:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /stripe</span>
<span class=c># echo &#34;/dev/stripe/st0a /stripe ufs rw 2 2&#34; \</span>
<span class=o>&gt;&gt;</span> /etc/fstab</code></pre></div></div></li><li><p>Das <span class=filename>geom_stripe.ko</span>-Modul muss ebenfalls automatisch beim Systemstart geladen werden (durch die Aufnahme der folgenden Zeile in die Datei <span class=filename>/boot/loader.conf</span>):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;geom_stripe_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect2><h3 id=geom-mirror>36.3. RAID1 - Spiegelung<a class=anchor href=#geom-mirror></a></h3><div class=paragraph><p>Spiegelung (RAID1 / <em>Mirroring</em>) ist eine Technik, bei der identische Daten auf mehr als ein Laufwerk geschrieben werden. Spiegel werden in der Regel zum Schutz vor Datenverlust aufgrund von Festplattenausfällen verwendet. Jedes Laufwerk in einem Spiegel enthält eine identische Kopie der Daten. Wenn ein einzelnes Laufwerk ausfällt, funktioniert der Spiegel weiterhin und die Daten werden von den restlichen Festplatten bereit gestellt. Der Rechner läuft einfach weiter und der Administrator hat die Gelegentheit, das defekte Laufwerk auszutauschen.</p></div><div class=paragraph><p>Zwei häufige Situationen werden in diesem Beispiel erläutert. Im ersten Beispiel wird ein Spiegel aus zwei neuen Laufwerken erstellt, der die existierende Platte ersetzt. Das zweite Beispiel erzeugt ein Spiegel mit einem einzigen Laufwerk, kopiert dann die Daten von der alten Platte und fügt die alte Platte zum Spiegel hinzu. Obwohl dieses Verfahren etwas komplizierter ist, wird nur ein neues Laufwerk benötigt.</p></div><div class=paragraph><p>Traditionell sind die Laufwerke in einem Spiegel vom gleichen Modell und besitzen die gleiche Kapazität. Dies ist jedoch keine Voraussetzung für <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a>. Hier können Spiegel mit unterschiedlichen Kapazitäten verwendet werden. Die Kapazität richtet sich dann nach dem kleinsten Laufwerk im Spiegel. Zusätzlicher Speicherplatz auf größeren Laufwerken bleibt dann ungenutzt. Werden später weitere Laufwerke zum Spiegel hinzugefügt, müssen diese mindestens so viel Kapazität haben wie das kleinste Laufwerk im Spiegel.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Die hier gezeigten Verfahren löschen keine Daten. Dennoch sollte, wie bei jeder größeren Operation, zuerst eine vollständige Sicherung erstellt werden.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Obwohl in diesem Abschnitt <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> zum Kopieren der Dateisysteme verwendet wird, funktioniert es nicht auf Dateisystemen mit aktiviertem Soft-Updates Journaling. In <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> finden Sie Informationen, wie Sie Soft-Updates Journaling erkennen und deaktivieren.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=geom-mirror-metadata>36.3.1. Probleme mit Metadaten<a class=anchor href=#geom-mirror-metadata></a></h4><div class=paragraph><p>Viele Plattensysteme speichern Metadaten am Ende der Platte. Alte Metadaten sollten vor der Wiederverwendung in einem Spiegel gelöscht werden, da die meisten Probleme aus zwei Arten von übrig gebliebenen Metadaten resultieren: GPT-Partitionstabellen und alte Metadaten aus einem vorherigen Spiegel.</p></div><div class=paragraph><p>GPT-Metadaten können mit <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> gelöscht werden. Dieses Beispiel löscht sowohl die primären, als auch die GPT-Partitionstabelle von der Festplatte <span class=filename>ada8</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart destroy -F ada8</span></code></pre></div></div><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> kann eine Platte aus einem aktiven Spiegel entfernt und gleichzeitig die Metadaten gelöscht werden. In diesem Beispiel wird die Platte <span class=filename>ada8</span> aus dem aktiven Spiegel <span class=filename>gm4</span> entfernt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror remove gm4 ada8</span></code></pre></div></div><div class=paragraph><p>Wenn der Spiegel nicht aktiv ist, sich jedoch noch alte Metadaten auf der Festplatte befinden, benutzen Sie <code>gmirror clear</code>, um die Metadaten zu entfernen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror clear ada8</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> speichert einen Datenblock an Metadaten am Ende der Festplatte. Da das GPT-Partitionschema die Metadaten auch am Ende der Platte speichert, wird es nicht empfohlen, mit <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> einen Spiegel aus einem gesamten GPT-Datenträger zu erstellen. In diesen Fällen sollte eine MBR-Partitionierung benutzt werden, weil hier nur eine Partitionstabelle am Anfang der Platte gespeichert wird und somit nicht mit den Metadaten des Spiegels im Konflikt steht.</p></div></div><div class=sect3><h4 id=geom-mirror-two-new-disks>36.3.2. Einen Spiegel mit zwei neuen Festplatten erstellen<a class=anchor href=#geom-mirror-two-new-disks></a></h4><div class=paragraph><p>In diesem Beispiel wurde FreeBSD bereits auf der vorhandenen Festplatte <span class=filename>ada0</span> installiert. Zwei neue Platten, <span class=filename>ada1</span> und <span class=filename>ada2</span>, wurden bereits mit dem System verbunden. Ein neuer Spiegel soll mit diesen beiden Platten erzeugt und verwendet werden, um die alte vorhandene Platte zu ersetzen.</p></div><div class=paragraph><p>Das Kernelmodul <span class=filename>geom_mirror.ko</span> muss entweder in den Kernel eingebaut, oder zur Laufzeit geladen werden. Sie können das Modul manuell laden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Erstellen Sie den Spiegel mit den beiden neuen Festplatten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror label -v gm0 /dev/ada1 /dev/ada2</span></code></pre></div></div><div class=paragraph><p><span class=filename>gm0</span> ist ein vom Benutzer gewählter Name, der dem neuen Spiegel zugeordnet wird. Nachdem der Spiegel gestartet wurde, erscheint dieser Gerätename in <span class=filename>/dev/mirror/</span>.</p></div><div class=paragraph><p>MBR- und bsdlabel-Partitionstabellen können jetzt auf dem neuen Spiegel erzeugt werden. Dieses Beispiel verwendet das herkömmliche Dateisystem-Layout für <span class=filename>/</span>, swap, <span class=filename>/var</span>, <span class=filename>/tmp</span> und <span class=filename>/usr</span>. Eine einzelne Root- und Swap-Partition würde ebenfalls funktionieren.</p></div><div class=paragraph><p>Die Partitionen auf dem Spiegel müssen nicht zwingend die gleiche Größe wie die auf der Festplatte haben, aber sie müssen groß genug sein, um alle Daten aufnehmen zu können, die bereits auf <span class=filename>ada0</span> gespeichert sind.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s MBR mirror/gm0</span>
<span class=c># gpart add -t freebsd -a 4k mirror/gm0</span>
<span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>       63  156301423  mirror/gm0  MBR  <span class=o>(</span>74G<span class=o>)</span>
         63         63                    - free -  <span class=o>(</span>31k<span class=o>)</span>
        126  156301299                 1  freebsd  <span class=o>(</span>74G<span class=o>)</span>
  156301425         61                    - free -  <span class=o>(</span>30k<span class=o>)</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s BSD mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k mirror/gm0s1</span>
<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>        0  156301299  mirror/gm0s1  BSD  <span class=o>(</span>74G<span class=o>)</span>
          0          2                      - free -  <span class=o>(</span>1.0k<span class=o>)</span>
          2    4194304                   1  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
    4194306    8388608                   2  freebsd-swap <span class=o>(</span>4.0G<span class=o>)</span>
   12582914    4194304                   4  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
   16777218    2097152                   5  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
   18874370  137426928                   6  freebsd-ufs  <span class=o>(</span>65G<span class=o>)</span>
  156301298          1                      - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Damit von dem Spiegel gebootet werden kann, muss der Bootcode in den MBR installiert, ein bsdlabel erstellt und die aktive Partition gesetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Erstellen Sie die Dateisysteme auf dem neuen Spiegel und aktivieren Sie Soft-Updates:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span></code></pre></div></div><div class=paragraph><p>Die Dateisysteme der vorhandenen Platte <span class=filename>ada0</span> können jetzt mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> auf den Spiegel kopiert werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/tmp</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/usr</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Fügen Sie die Dateisysteme für den Spiegel in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre># Device          Mountpoint       FStype  Options Dump    Pass#
/dev/mirror/gm0s1a      /               ufs     rw       1       1
/dev/mirror/gm0s1b      none            swap    sw       0       0
/dev/mirror/gm0s1d      /var            ufs     rw       2       2
/dev/mirror/gm0s1e      /tmp            ufs     rw       2       2
/dev/mirror/gm0s1f      /usr            ufs     rw       2       2</pre></div></div><div class=paragraph><p>Wenn das Modul <span class=filename>geom_mirror.ko</span> nicht im Kernel enthalten ist, können Sie <span class=filename>/mnt/boot/loader.conf</span> bearbeiten, damit das Modul beim Systemstart geladen wird:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten Sie das System neu und überprüfen Sie, ob alle Daten erfolgreich kopiert wurden. Das BIOS wird den Spiegel vermutlich als zwei einzelne Laufwerke erkennen. Da beide Laufwerke jedoch identisch sind, spielt es keine Rolle, welches Laufwerk zum Booten ausgewählt wird.</p></div><div class=paragraph><p>Falls es Probleme beim Booten gibt, lesen Sie den <a href=#gmirror-troubleshooting>Fehlerbehebung</a>. Die alte Festplatte <span class=filename>ada0</span> kann vom System getrennt und als Offline-Sicherung aufbewahrt werden.</p></div><div class=paragraph><p>Im laufenden Betrieb verhält sich der Spiegel genau wie ein einzelnes Laufwerk.</p></div></div><div class=sect3><h4 id=geom-mirror-existing-drive>36.3.3. Einen Spiegel mit einem vorhandenen Laufwerk erstellen<a class=anchor href=#geom-mirror-existing-drive></a></h4><div class=paragraph><p>In diesem Beispiel wurde FreeBSD bereits auf der Festplatte <span class=filename>ada0</span> installiert und eine weitere Platte, <span class=filename>ada1</span>, wurde an das System angeschlossen. Zunächst wird ein Spiegel mit einer Festplatte erstellt, dann das vorhandene System auf den Spiegel kopiert. Zuletzt wird die alte Festplatte in den Spiegel eingefügt. Diese etwas komplexere Vorgehensweise ist erforderlich, da <code>gmirror</code> 512 Byte an Metadaten am Ende der Festplatte speichert, und die bestehende Platte, <span class=filename>ada0</span>, in der Regel den Platz bereits belegt hat.</p></div><div class=paragraph><p>Laden Sie das Kernelmodul <span class=filename>geom_mirror.ko</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Prüfen Sie mit <code>diskinfo</code> die Mediengröße der vorhandenen Festplatte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># diskinfo -v ada0 | head -n3</span>
/dev/ada0
        512             <span class=c># sectorsize</span>
        1000204821504   <span class=c># mediasize in bytes (931G)</span></code></pre></div></div><div class=paragraph><p>Jetzt können Sie den Spiegel auf der neuen Festplatte erzeugen. Um sicherzustellen, dass die Kapazität nicht größer ist, als die Kapazität der vorhandenen Platte <span class=filename>ada0</span>, benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=gnop&amp;sektion=8&amp;format=html">gnop(8)</a> um eine Platte mit der exakt gleichen Größe zu imitieren. Diese Platte speichert keine Daten und wird nur verwendet, um die Größe des Spiegels zu begrenzen. <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> wird die Kapazität des Spiegels auf die Größe von <span class=filename>gzero.nop</span> beschränken, auch wenn die neue Festplatte <span class=filename>ada1</span> mehr Platz zur Verfügung hätte. Beachten Sie, dass <em>1000204821504</em> in der zweiten Zeile der ermittelten Mediengröße von <code>diskinfo</code> entspricht.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geom zero load</span>
<span class=c># gnop create -s 1000204821504 gzero</span>
<span class=c># gmirror label -v gm0 gzero.nop ada1</span>
<span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Da <span class=filename>gzero.nop</span> keine Daten speichert, sieht der Spiegel sie als nicht verbunden an. Der Spiegel ist so konfiguriert, dass er nicht verbundene Komponenten einfach "vergisst". Das Ergebnis ist ein Spiegel mit nur einer einzigen Platte, <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Sehen Sie sich nach der Erstellung von <span class=filename>gm0</span> die Partitionstabelle von <span class=filename>ada0</span> an. Diese Ausgabe stammt von einer 1 TB Festplatte. Falls am Ende der Platte noch freier Speicherplatz ist, kann der Inhalt von <span class=filename>ada0</span> direkt auf den Spiegel kopiert werden.</p></div><div class=paragraph><p>Falls jedoch der gesamte Speicherplatz auf der Platte zugeordnet ist, dann gibt es keinen Platz mehr für die 512 Byte Metadaten für den Spiegel am Ende der Platte, wie in dieser Auflistung zu sehen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>        63  1953525105        ada0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525105           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>In diesem Fall muss die Partitionstabelle bearbeitet werden, um die Kapazität von <span class=filename>mirror/gm0</span> um einen Sektor zu reduzieren. Dieses Verfahren wird später erläutert.</p></div><div class=paragraph><p>In beiden Fällen sollte die Partitionstabelle der primären Platte mit <code>gpart backup</code> gesichert werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart backup ada0 &gt; table.ada0</span>
<span class=c># gpart backup ada0s1 &gt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>Diese Kommandos erstellen zwei Dateien, <span class=filename>table.ada0</span> und <span class=filename>table.ada0s1</span>. Das Beispiel verwendet eine 1 TB Festplatte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525105   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640881</code></pre></div></div><div class=paragraph><p>Wenn am Ende der Platte kein Platz vorhanden ist, muss die Größe des Slice und der letzten Partition verringert werden. Bearbeiten Sie die beiden Dateien, und verringern Sie die Größe der Slice und der Partition jeweils um eins. Dies bezieht sich auf die letzten Zahlen in der Liste.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525104   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640880</code></pre></div></div><div class=paragraph><p>Wenn mindestens ein Sektor der Platte nicht zugewiesen wurde, kann die Platte ohne Modifikation verwendet werden.</p></div><div class=paragraph><p>Jetzt kann die Partitionstabelle auf <span class=filename>mirror/gm0</span> wiederhergestellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart restore mirror/gm0 &lt; table.ada0</span>
<span class=c># gpart restore mirror/gm0s1 &lt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>Prüfen Sie die Partitionstabellen mit <code>gpart show</code>. Dieses Beispiel nutzt <span class=filename>gm0s1a</span> für <span class=filename>/</span>, <span class=filename>gm0s1d</span> für <span class=filename>/var</span>, <span class=filename>gm0s1e</span> für <span class=filename>/usr</span>, <span class=filename>gm0s1f</span> für <span class=filename>/data1</span> und <span class=filename>gm0s1g</span> für <span class=filename>/data2</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>        63  1953525104  mirror/gm0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525042           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span>
  1953525105          62              - free -  <span class=o>(</span>31k<span class=o>)</span>

<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>         0  1953525042  mirror/gm0s1  BSD  <span class=o>(</span>931G<span class=o>)</span>
           0     2097152             1  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
     2097152    16777216             2  freebsd-swap  <span class=o>(</span>8.0G<span class=o>)</span>
    18874368    41943040             4  freebsd-ufs  <span class=o>(</span>20G<span class=o>)</span>
    60817408    20971520             5  freebsd-ufs  <span class=o>(</span>10G<span class=o>)</span>
    81788928   629145600             6  freebsd-ufs  <span class=o>(</span>300G<span class=o>)</span>
   710934528  1242590514             7  freebsd-ufs  <span class=o>(</span>592G<span class=o>)</span>
  1953525042          63                - free -  <span class=o>(</span>31k<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Sowohl die Slice, als auch die letzte Partition, muss mindestens einen freien Block am Ende der Platte haben.</p></div><div class=paragraph><p>Erstellen Sie Dateisysteme auf diesen neuen Partitionen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span>
<span class=c># newfs -U /dev/mirror/gm0s1g</span></code></pre></div></div><div class=paragraph><p>Damit Sie von dem Spiegel booten können, müssen Sie den Bootcode in den MBR installieren, ein bsdlabel anlegen und das aktive Slice setzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Bearbeiten Sie <span class=filename>/etc/fstab</span>, um die neuen Partitionen auf dem Spiegel nutzen zu können. Speichern Sie zunächst eine Kopie der Datei unter <span class=filename>/etc/fstab.orig</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/fstab /etc/fstab.orig</span></code></pre></div></div><div class=paragraph><p>Ersetzen Sie in <span class=filename>/etc/fstab</span> <span class=filename>/dev/ada0</span> durch <span class=filename>mirror/gm0</span>.</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/usr		ufs	rw	2	2
/dev/mirror/gm0s1f	/data1		ufs	rw	2	2
/dev/mirror/gm0s1g	/data2		ufs	rw	2	2</pre></div></div><div class=paragraph><p>Wenn das Modul <span class=filename>geom_mirror.ko</span> nicht im Kernel enthalten ist, können Sie <span class=filename>/boot/loader.conf</span> bearbeiten, damit das Modul beim Systemstart geladen wird:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Die Dateisysteme der ursprünglichen Platte können jetzt mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> auf den Spiegel kopiert werden. Wenn Sie das Dateisystem mit <code>dump -L</code> sichern, wird zunächst ein Snapshot des Dateisystems erstellt, was einige Zeit dauern kann.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/usr</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/data1</span>
<span class=c># mount /dev/mirror/gm0s1g /mnt/data2</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Starten Sie das System neu und booten Sie von <span class=filename>ada1</span>. Wenn alles funktioniert, wird das System von <span class=filename>mirror/gm0</span> booten, welches jetzt die gleichen Daten enthält wie <span class=filename>ada0</span>. Lesen Sie <a href=#gmirror-troubleshooting>Fehlerbehebung</a>, falls es Probleme beim Booten gibt.</p></div><div class=paragraph><p>An dieser Stelle besteht der Spiegel immer noch aus der einzelnen Platte <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Nachdem erfolgreich von <span class=filename>mirror/gm0</span> gebootet wurde, besteht der letzte Schritt darin, <span class=filename>ada0</span> in den Spiegel einzufügen.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Wenn Sie <span class=filename>ada0</span> in den Spiegel einfügen, wird der Inhalt der Platte mit den Daten aus dem Spiegel überschrieben. Sie müssen sicherstellen, das <span class=filename>mirror/gm0</span> den gleichen Inhalt wie <span class=filename>ada0</span> hat, bevor Sie <span class=filename>ada0</span> zum Spiegel hinzufügen. Falls der zuvor mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> kopierte Inhalt nicht mit dem von <span class=filename>ada0</span> identisch ist, machen Sie die Änderungen an <span class=filename>/etc/fstab</span> rückgängig, starten Sie das System neu und beginnen Sie die Prozedur von vorn.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 ada0</span>
GEOM_MIRROR: Device gm0: rebuilding provider ada0</code></pre></div></div><div class=paragraph><p>Die Synchronisation zwischen den beiden Platten wird direkt gestartet. Verwenden Sie <code>gmirror status</code> um den Fortschritt zu beobachten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror status</span>
      Name    Status  Components
girror/gm0  DEGRADED  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>SYNCHRONIZING, 64%<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Nach einer Weile wird die Wiederherstellung abgeschlossen sein.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
<span class=c># gmirror status</span>
      Name    Status  Components
mirror/gm0  COMPLETE  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>ACTIVE<span class=o>)</span></code></pre></div></div><div class=paragraph><p><span class=filename>mirror/gm0</span> besteht nun aus den beiden Platten <span class=filename>ada0</span> und <span class=filename>ada1</span>. Der Inhalt der beiden Platten wird automatisch miteinander synchronisiert. Im laufenden Betrieb verhält sich <span class=filename>mirror/gm0</span> wie eine einzelne Festplatte.</p></div></div><div class=sect3><h4 id=gmirror-troubleshooting>36.3.4. Fehlerbehebung<a class=anchor href=#gmirror-troubleshooting></a></h4><div class=paragraph><p>Falls das System nicht mehr startet, müssen möglicherweise die BIOS-Einstellungen geändert werden, um von dem neuen gespiegelten Laufwerk zu booten. Beide Platten des Spiegels können zum Booten verwendet werden, da sie als Komponenten des Spiegels identische Daten enthalten.</p></div><div class=paragraph><p>Wenn der Bootvorgang mit der folgenden Meldung abbricht, ist irgendwas mit dem Spiegel nicht in Ordnung:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

Loader variables:
  vfs.root.mountfrom<span class=o>=</span>ufs:/dev/mirror/gm0s1a
  vfs.root.mountfrom.options<span class=o>=</span>rw

Manual root filesystem specification:
  &lt;fstype&gt;:&lt;device&gt; <span class=o>[</span>options]
      Mount &lt;device&gt; using filesystem &lt;fstype&gt;
      and with the specified <span class=o>(</span>optional<span class=o>)</span> option list.

    eg. ufs:/dev/da0s1a
        zfs:tank
        cd9660:/dev/acd0 ro
          <span class=o>(</span>which is equivalent to: mount <span class=nt>-t</span> cd9660 <span class=nt>-o</span> ro /dev/acd0 /<span class=o>)</span>

  ?               List valid disk boot devices
  <span class=nb>.</span>               Yield 1 second <span class=o>(</span><span class=k>for </span>background tasks<span class=o>)</span>
  &lt;empty line&gt;    Abort manual input

mountroot&gt;</code></pre></div></div><div class=paragraph><p>Dieses Problem kann durch ein nicht geladenes Kernelmodul <span class=filename>geom_mirror.ko</span> in <span class=filename>/boot/loader.conf</span> verursacht werden. Um das Problem zu beheben, booten Sie von einem FreeBSD-Installationsmedium und wählen Sie <code>Shell</code> an der Eingabeaufforderung. Laden Sie dann das Modul und hängen Sie den Spiegel ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span>
<span class=c># mount /dev/mirror/gm0s1a /mnt</span></code></pre></div></div><div class=paragraph><p>Bearbeiten Sie dann <span class=filename>/mnt/boot/loader.conf</span> und fügen Sie eine Zeile für das Kernelmodul hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Speichern Sie die Datei und starten Sie das System neu.</p></div><div class=paragraph><p>Andere Probleme, die <code>error 19</code> verursachen können, sind nur mit mehr Aufwand zu beheben. Obwohl das System von <span class=filename>ada0</span> booten sollte, wird ein weiterer Prompt erscheinen, wenn <span class=filename>/etc/fstab</span> fehlerhaft ist. Geben Sie am Loader-Prompt <code>ufs:/dev/ada0s1a</code> ein und drücken Sie <kbd>Enter</kbd>. Machen Sie die Änderungen an <span class=filename>/etc/fstab</span> rückgängig und hängen Sie anstelle des Spiegels die originale Festplatte (<span class=filename>ada0</span>) ein. Starten Sie dann das System neu und versuchen Sie den Vorgang erneut.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter full pathname of shell or RETURN <span class=k>for</span> /bin/sh:
<span class=c># cp /etc/fstab.orig /etc/fstab</span>
<span class=c># reboot</span></code></pre></div></div></div><div class=sect3><h4 id=_wiederherstellung_des_systems_nach_einem_plattenausfall>36.3.5. Wiederherstellung des Systems nach einem Plattenausfall<a class=anchor href=#_wiederherstellung_des_systems_nach_einem_plattenausfall></a></h4><div class=paragraph><p>Der Vorteil der Plattenspiegelung ist, dass eine Platte ausfallen kann, ohne dass Sie dabei Daten verlieren. Falls <span class=filename>ada0</span> aus dem obigen Beispiel ausfällt, steht der Spiegel weiterhin zur Verfügung und bietet die Daten von der verbleibenden Platte <span class=filename>ada1</span> an.</p></div><div class=paragraph><p>Um das ausgefallene Laufwerk zu ersetzen, muss das System heruntergefahren werden und das ausgefallene Laufwerk durch ein neues Laufwerk von gleicher oder größerer Kapazität ersetzt werden. Hersteller verwenden oft etwas willkürliche Werte für die Kapazität. Der einzige Weg, um wirklich sicher zu sein, ist die Gesamtzahl der Sektoren von <code>diskinfo -V</code> zu vergleichen. Ein Laufwerk mit größerer Kapazität wird funktionieren, allerdings wird der zusätzliche Platz ungenutzt bleiben.</p></div><div class=paragraph><p>Nachdem der Rechner wieder eingeschaltet ist, wird der Spiegel im "degraded" Modus ausgeführt werden. Der Spiegel wird angewiesen, Laufwerke zu vergessen, die noch nicht verbunden sind:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Alte Metadaten sollten von der Ersatzfestplatte nach den Anweisungen in <a href=#geom-mirror-metadata>Probleme mit Metadaten</a> gelöscht werden. Anschließend kann die Ersatzfestplatte, in diesem Beispiel <span class=filename>ada4</span>, in den Spiegel eingefügt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 /dev/ada4</span></code></pre></div></div><div class=paragraph><p>Die Wiederherstellung beginnt, sobald das neue Laufwerk in den Spiegel eingesetzt wird. Das Kopieren der Daten vom Spiegel auf das neue Laufwerk kann eine Weile dauern. Die Leistung des Spiegels ist während dieser Zeit stark reduziert, deswegen sollten neue Laufwerke idealerweise dann eingefügt werden, wenn der Rechner nicht benötigt wird.</p></div><div class=paragraph><p>Der Fortschritt der Wiederherstellung kann mit <code>gmirror status</code> überwacht werden. Während der Wiederherstellung ist der Status <code>DEGRADED</code>. Wenn der Vorgang abgeschlossen ist, wechselt der Status zu <code>COMPLETE</code>.</p></div></div></div><div class=sect2><h3 id=geom-raid3>36.4. RAID3 - Byte-Level Striping mit dedizierter Parität<a class=anchor href=#geom-raid3></a></h3><div class=paragraph><p>RAID3 ist eine Methode, die mehrere Festplatten zu einem einzigen Volume mit einer dedizierten Paritätsfestplatte kombiniert. In einem RAID3-System werden die Daten in einzelne Bytes aufgeteilt und dann über alle Laufwerke, mit Ausnahme der Paritätsfestplatte, geschrieben. Beim Lesen von Daten in einer RAID3 Implementierung werden alle Festplatten im Array parallel genutzt. Die Leistung kann durch den Einsatz von mehreren Controllern weiter erhöht werden. Ein RAID3-Array hat eine Fehlertoleranz von 1 Laufwerk und bietet dabei eine Kapazität von 1 - 1/n der Gesamtkapazität der Laufwerke im Array, wobei n die Anzahl der Festplatten im Array darstellt. So eine Konfiguration ist meistens für die Speicherung von größeren Dateien geeignet, wie beispielsweise Multimediadateien.</p></div><div class=paragraph><p>Mindestens 3 Festplatten sind erforderlich, um ein RAID3 zu erstellen. Jede Festplatte muss von der gleichen Größe sein, da die I/O-Anfragen für Lesen oder Schreiben auf mehreren Festplatten parallel stattfinden. Aufgrund der Beschaffenheit von RAID3, muss die Anzahl der Laufwerke 3, 5, 9, 17 bzw. 2^n + 1 sein.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie ein Software RAID3 auf einem FreeBSD-System erstellt wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Obwohl es theoretisch möglich ist FreeBSD von einem RAID3-Array zu booten, wird von solch einer ungewöhnlichen Konfiguration dringend abgeraten.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_ein_dediziertes_raid3_array_erstellen>36.4.1. Ein dediziertes RAID3-Array erstellen<a class=anchor href=#_ein_dediziertes_raid3_array_erstellen></a></h4><div class=paragraph><p>In FreeBSD wird die Unterstützung für RAID3 über die GEOM-Klasse <a href="https://man.freebsd.org/cgi/man.cgi?query=graid3&amp;sektion=8&amp;format=html">graid3(8)</a> implementiert. Zum Erstellen eines dedizierten RAID3-Arrays sind folgende Schritte erforderlich.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Laden Sie zunächst das Modul <span class=filename>geom_raid3.ko</span> mit einem der folgenden Befehle:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 load</span></code></pre></div></div><div class=paragraph><p>oder:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_raid3</span></code></pre></div></div></li><li><p>Stellen Sie sicher, dass ein geeigneter Mountpunkt existiert. Dieser Befehl erstellt ein neues Verzeichnis, welches als Mountpunkt verwendet werden kann:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /multimedia</span></code></pre></div></div></li><li><p>Bestimmen Sie die Gerätenamen der Festplatten, die dem Array hinzugefügt werden und erstellen Sie ein neues RAID3 Gerät. Das letzte aufgeführte Gerät wird als dediziertes Paritätslaufwerk verwendet. Dieses Beispiel verwendet drei unpartionierte ATA-Platten: <span class=filename>ada1</span> und <span class=filename>ada2</span> für die Daten, sowie <span class=filename>ada3</span> für die Parität.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</span>
Metadata value stored on /dev/ada1.
Metadata value stored on /dev/ada2.
Metadata value stored on /dev/ada3.
Done.</code></pre></div></div></li><li><p>Partitionieren Sie das neu erstelle Gerät <span class=filename>gr0</span> und erstellen Sie darauf ein UFS-Dateisystem:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT /dev/raid3/gr0</span>
<span class=c># gpart add -t freebsd-ufs /dev/raid3/gr0</span>
<span class=c># newfs -j /dev/raid3/gr0p1</span></code></pre></div></div><div class=paragraph><p>Viele Zahlen rauschen nun über den Bildschirm und nach einer gewissen Zeit ist der Vorgang abgeschlossen. Das Volume wurde erstellt und kann jetzt in den Verzeichnisbaum eingehangen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/raid3/gr0p1 /multimedia/</span></code></pre></div></div><div class=paragraph><p>Das RAID3-Array ist nun einsatzbereit.</p></div></li></ol></div><div class=paragraph><p>Weitere Konfigurationsschritte sind erforderlich, um die Einstellungen nach einem Systemneustart zu erhalten.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Das Modul <span class=filename>geom_raid3.ko</span> muss geladen werden, bevor das Array eingehangen werden kann. Damit das Kernelmodul automatisch beim Systemstart geladen wird, muss die folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzugefügt werden:</p><div class="literalblock programlisting"><div class=content><pre>geom_raid3_load=&#34;YES&#34;</pre></div></div></li><li><p>Die folgenden Informationen über das Volume müssen in <span class=filename>/etc/fstab</span> hinzugefügt werden, um das Dateisystem des Arrays automatisch beim Systemstart zu aktivieren:</p><div class="literalblock programlisting"><div class=content><pre>/dev/raid3/gr0p1	/multimedia	ufs	rw	2	2</pre></div></div></li></ol></div></div></div><div class=sect2><h3 id=geom-graid>36.5. Software RAID<a class=anchor href=#geom-graid></a></h3><div class=paragraph><p>Einige Motherboards und Erweiterungskarten besitzen ein ROM, das dem Rechner erlaubt von einem RAID-Array zu booten. Nach dem Booten wird der Zugriff auf das RAID-Array durch die Software auf dem Prozessor des Rechners abgewickelt. Dieses "Hardware-unterstützte Software-RAID" ist nicht abhängig von einem bestimmten Betriebssystem. Sie funktionieren bereits, noch bevor das Betriebssystem geladen wird.</p></div><div class=paragraph><p>Abhängig von der verwendeten Hardware werden mehrere Arten von RAID unterstützt. Eine vollständige Liste finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a>.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> benötigt das <span class=filename>geom_raid.ko</span> Kernelmodul, welches beginnend mit FreeBSD 9.1 im <span class=filename>GENERIC</span>-Kernel enthalten ist. Bei Bedarf kann es manuell mit <code>graid load</code> geladen werden.</p></div><div class=sect3><h4 id=geom-raid-creating>36.5.1. Ein Array erstellen<a class=anchor href=#geom-raid-creating></a></h4><div class=paragraph><p>Geräte mit Software-RAID haben oft ein Menü, das über eine bestimmte Tastenkombination beim Booten aufgerufen werden kann. Das Menü kann verwendet werden, um RAID-Arrays zu erstellen und zu löschen. Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> können Arrays auch direkt von der Kommandozeile erstellt werden.</p></div><div class=paragraph><p><code>graid label</code> wird verwendet, um ein neues Array zu erstellen. Das Motherboard in diesem Beispiel besitzt einen Intel® Software-RAID Chipsatz, so dass das Metadatenformat von Intel® angegeben wird. Das neue Array bekommt den Namen (Label) <span class=filename>gm0</span>, verhält sich als Spiegel (RAID1) und verwendet die Laufwerke <span class=filename>ada0</span> und <span class=filename>ada1</span>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Bei der Erstellung des Arrays wird etwas Platz auf den Laufwerken überschrieben. Sichern Sie zuvor alle vorhandenen Daten!</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 ada1</span>
GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.
GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Array started.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.
Intel-a29ea104 created<span class=err>$</span>
GEOM_RAID: Intel-a29ea104: Provider raid/r0 <span class=k>for </span>volume gm0 created.</code></pre></div></div><div class=paragraph><p>Eine Statusabfrage zeigt, dass der neue Spiegel einsatzbereit ist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Das Array-Gerät erscheint in <span class=filename>/dev/raid/</span>. Das erste Gerät heißt <span class=filename>r0</span>. Falls weitere Geräte vorhanden sind heißen diese <span class=filename>r1</span>, <span class=filename>r2</span> und so weiter.</p></div><div class=paragraph><p>Das BIOS-Menü einiger Geräte erstellt Arrays mit Sonderzeichen im Namen. Um Probleme mit diesen Sonderzeichen zu vermeiden, werden einfache numerische Namen wie <span class=filename>r0</span> vergeben. Um das tatsächliche Label anzuzeigen, wie <span class=filename>gm0</span> im obigen Beispiel, benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.raid.name_format=1</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-volumes>36.5.2. Mehrere Volumes<a class=anchor href=#geom-graid-volumes></a></h4><div class=paragraph><p>Einige Software-RAID Geräte unterstützen mehr als ein <em>Volume</em> pro Array. Volumes funktionieren wie Festplatten, dass heißt der Platz auf den Laufwerken kann auf unterschiedliche Weise geteilt und genutzt werden. Intels Software-RAID Geräte unterstützen beispielsweise zwei Volumes. In diesem Beispiel wird ein 40 GB Spiegel verwendet um das Betriebssystem zu speichern, gefolgt von einem 20 GB RAID0 (Stripe) Volume für die schnelle Speicherung von temporären Daten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label -S 40G Intel gm0 RAID1 ada0 ada1</span>
<span class=c># graid add -S 20G gm0 RAID0</span></code></pre></div></div><div class=paragraph><p>Volumes erscheinen unter <span class=filename>/dev/raid/</span> als zusätzliche Einträge <span class=filename>rX</span>. Ein Array mit Volumes wird als <span class=filename>r0</span> und <span class=filename>r1</span>.</p></div><div class=paragraph><p>Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> um die Anzahl der Volumes zu ermitteln, die von den verschiedenen Software-RAID Geräten unterstützt wird.</p></div></div><div class=sect3><h4 id=geom-graid-converting>36.5.3. Ein einzelnes Laufwerk zu einem Spiegel konvertieren<a class=anchor href=#geom-graid-converting></a></h4><div class=paragraph><p>Unter bestimmten Umständen ist es möglich, ein bestehendes Laufwerk ohne Neuformatierung zu einem <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> Array zu konvertieren. Um Datenverlust bei der Konvertierung zu vermeiden, müssen die vorhandenen Laufwerke folgende Mindestanforderungen erfüllen:</p></div><div class=ulist><ul><li><p>Das Laufwerk muss mit MBR partitioniert werden. GPT oder andere Partitionierungsschemata funktionieren nicht, da durch <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> die Metadaten am Ende des Laufwerks überschieben und beschädigt werden.</p></li><li><p>Am Ende des Laufwerks muss genügend freier Platz zur Verfügung stehen, um die <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> Metadaten zu speichern. Die Metadaten variieren in der Größe, es werden jedoch mindestens 64 MB freier Speicherplatz empfohlen.</p></li></ul></div><div class=paragraph><p>Wenn das Laufwerk diese Anforderungen erfüllt, erstellen Sie zuerst eine vollständige Sicherung. Erzeugen Sie dann einen Spiegel mit diesem einen Laufwerk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 NONE</span></code></pre></div></div><div class=paragraph><p>Die Metadaten von <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> werden in den ungenutzten Raum am Ende des Laufwerks geschrieben. Ein zweites Laufwerk kann nun in den Spiegel eingefügt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span></code></pre></div></div><div class=paragraph><p>Die Daten von dem ersten Laufwerk werden direkt auf das zweite Laufwerk kopiert. Der Spiegel wird im eingeschränkten Zustand laufen, bis der Kopiervorgang abgeschlossen ist.</p></div></div><div class=sect3><h4 id=geom-graid-inserting>36.5.4. Neue Laufwerke zum Array hinzufügen<a class=anchor href=#geom-graid-inserting></a></h4><div class=paragraph><p>Laufwerke in einem Array können für ausgefallene oder fehlende Laufwerke eingesetzt werden. Falls es keine ausgefallenen oder fehlenden Laufwerke gibt, wird das neue Laufwerk als Ersatz (Spare) verwendet.</p></div><div class=paragraph><p>Das Array in diesem Beispiel beginnt sofort damit, die Daten auf das neu hinzugefügte Laufwerk zu kopieren. Alle vorhandenen Daten auf dem neuen Laufwerk werden überschrieben.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.</code></pre></div></div></div><div class=sect3><h4 id=geom-graid-removing>36.5.5. Laufwerke aus dem Array entfernen<a class=anchor href=#geom-graid-removing></a></h4><div class=paragraph><p>Einzelne Laufwerke können permanent aus dem Array entfernt werden. Die Metadaten werden dabei gelöscht:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid remove raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.</code></pre></div></div></div><div class=sect3><h4 id=geom-graid-stopping>36.5.6. Das Array anhalten<a class=anchor href=#geom-graid-stopping></a></h4><div class=paragraph><p>Ein Array kann angehalten werden, ohne die Metadaten von den Laufwerken zu löschen. Das Array wird wieder anlaufen, wenn das System neu gestartet wird.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid stop raid/r0</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-status>36.5.7. Den Status des Arrays überprüfen<a class=anchor href=#geom-graid-status></a></h4><div class=paragraph><p>Der Status des Arrays kann jederzeit überprüft werden. Nachdem ein Laufwerk zum Array hinzugefügt wurde, werden die Daten vom ursprünglichen Laufwerk auf das neue Laufwerk kopiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name    Status  Components
raid/r0  DEGRADED  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                   ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>REBUILD 28%<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Andere Arten von Arrays, wie <code>RAID0</code> oder <code>CONCAT</code>, werden den Status eines fehlgeschlagenen Laufwerks vielleicht nicht anzeigen. Um diese teilweise ausgefallenen Arrays anzuzeigen, fügen Sie <code>-ga</code> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status -ga</span>
          Name  Status  Components
Intel-e2d07d9a  BROKEN  ada6 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-deleting>36.5.8. Arrays löschen<a class=anchor href=#geom-graid-deleting></a></h4><div class=paragraph><p>Arrays werden zerstört, indem alle Volumes gelöscht werden. Wenn das letzte Volume gelöscht wird, wird das Array gestoppt und die Metadaten von den Laufwerken entfernt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-unexpected>36.5.9. Unerwartete Arrays löschen<a class=anchor href=#geom-graid-unexpected></a></h4><div class=paragraph><p>Laufwerke können unerwartete <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> Metadaten enthalten, entweder aus früherer Nutzung oder aus Tests des Herstellers. <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> würde diese Metadaten erkennen und daraus ein Array erstellen, was den Zugriff auf die einzelnen Laufwerke beeinträchtigen würde. Um die unerwünschten Metadaten zu entfernen:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Booten Sie das System. Im Boot-Menü wählen Sie <code>2</code> für den Loader-Prompt. Geben Sie dann folgendes ein:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>OK <span class=nb>set </span>kern.geom.raid.enable<span class=o>=</span>0
OK boot</code></pre></div></div><div class=paragraph><p>Das System wird nun mit deaktiviertem <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> starten.</p></div></li><li><p>Sichern Sie alle Daten auf dem betroffenen Laufwerk.</p></li><li><p>Zur Abhilfe kann auch die Array-Erkennung von <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> deaktiviert werden, indem</p><div class="literalblock programlisting"><div class=content><pre>kern.geom.raid.enable=0</pre></div></div><div class=paragraph><p>in <span class=filename>/boot/loader.conf</span> hinzugefügt wird.</p></div><div class=paragraph><p>Um die <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> Metadaten von dem entsprechenden Laufwerk zu entfernen, booten Sie vom FreeBSD Installationsmedium und wählen Sie <code>Shell</code> aus. Benutzen Sie <code>status</code>, um den Namen des Arrays zu bestimmten, typischerweise <code>raid/r0</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Löschen Sie das Volume:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div><div class=paragraph><p>Wiederholen Sie den Vorgang für jedes Volume. Nachdem das letzte Volume gelöscht wurde, wird das Volume zerstört.</p></div><div class=paragraph><p>Starten Sie das System neu und prüfen die Vollständigkeit der Daten. Falls erforderlich, müssen die Daten aus der Sicherung wiederhergestellt werden. Nachdem die Metadaten entfernt wurden, kann auch der Eintrag <code>kern.geom.raid.enable=0</code> aus <span class=filename>/boot/loader.conf</span> entfernt werden.</p></div></li></ol></div></div></div><div class=sect2><h3 id=geom-ggate>36.6. GEOM Gate Netzwerk<a class=anchor href=#geom-ggate></a></h3><div class=paragraph><p>GEOM unterstützt einen einfachen Mechanismus für den Zugriff auf entfernte Geräte wie Festplatten, CDs und Dateien, durch die Verwendung des GEOM Gate Netzwerk Daemons, ggated. Der Server-Dameon läuft auf dem System, welches ein Gerät anbietet und bearbeitet die ggatec-Anfragen der Clients. Die Geräte sollten keine sensiblen Daten enthalten, da die Verbindung zwischen Client und Server nicht verschlüsselt ist.</p></div><div class=paragraph><p>Ähnlich wie bei NFS, das in <a href=./#network-nfs>Network File System (NFS)</a> beschrieben ist, wird für die Konfiguration von ggated eine Exportdatei verwendet. Diese Datei legt fest, welche Systeme auf die exportierten Ressourcen zugreifen können und in welchem Umfang der Zugriff gestattet wird. Um dem Client <code>192.168.1.5</code> Lese- und Schreibzugriff auf die vierte Slice der ersten SCSI-Platte zu geben, erstellen Sie <span class=filename>/etc/gg.exports</span> mit folgender Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.1.5 RW /dev/da0s4d</pre></div></div><div class=paragraph><p>Bevor das Gerät exportiert werden kann, müssen Sie sicherstellen, dass es nicht bereits gemountet ist. Anschließend starten Sie ggated.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggated</span></code></pre></div></div><div class=paragraph><p>Es stehen mehrere Optionen bereit, mit denen zum Beispiel ein alternativer Port oder eine alternative Exportdatei festgelegt werden kann. Weitere Einzelheiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ggated&amp;sektion=8&amp;format=html">ggated(8)</a>.</p></div><div class=paragraph><p>Damit ein Client auf das exportierte Gerät zugreifen kann, benutzten Sie ggatec zusammen mit der IP-Adresse des Servers und dem entsprechenden Gerätenamen. Wenn dies erfolgreich ist, zeigt dieser Befehl einen <code>ggate</code>-Gerätenamen. Hängen Sie dieses Gerät in einen freien Mountpunkt ein. Dieses Beispiel verbindet sich mit der Partition <span class=filename>/dev/da0s4d</span> auf <code>192.168.1.1</code> und hängt <span class=filename>/dev/ggate0</span> in <span class=filename>/mnt</span> ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggatec create -o rw 192.168.1.1 /dev/da0s4d</span>
ggate0
<span class=c># mount /dev/ggate0 /mnt</span></code></pre></div></div><div class=paragraph><p>Auf das Gerät des Servers kann jetzt über den Mountpunkt <span class=filename>/mnt</span> des Clients zugegriffen werden. Weitere Informationen über <code>ggatec</code> und einige Anwendungsbeispiele finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ggatec&amp;sektion=8&amp;format=html">ggatec(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das Einhängen des Gerätes wird scheitern, falls das Gerät momentan entweder auf dem Server oder einem Client im Netzwerk gemountet ist. Wenn ein gleichzeitiger Zugriff auf die Netzwerkressourcen benötigt wird, verwenden Sie stattdessen NFS.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn das Gerät nicht länger gebraucht wird, kann es mit <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> ausgehängt werden, so dass die Ressourcen für andere Client wieder verfügbar sind.</p></div></div><div class=sect2><h3 id=geom-glabel>36.7. Das Labeln von Laufwerken<a class=anchor href=#geom-glabel></a></h3><div class=paragraph><p>Während der Initialisierung des Systems legt der FreeBSD-Kernel für jedes gefundene Gerät Knotenpunkte an. Diese Methode für die Überprüfung auf vorhandene Geräte wirft einige Fragen auf. Was passiert beispielsweise, wenn ein neues USB-Laufwerk hinzugefügt wird? Es ist sehr wahrscheinlich, dass ein Flash-Speicher-Gerät den Gerätenamen <span class=filename>da0</span> erhält, während gleichzeitig das bisherige <span class=filename>da0</span> zu <span class=filename>da1</span> wird. Dies verursacht Probleme beim Einhängen von Dateisystemen, wenn diese in <span class=filename>/etc/fstab</span> aufgeführt sind und kann dazu führen, dass das System nicht mehr startet.</p></div><div class=paragraph><p>Eine Lösung für dieses Problem ist das Aneinanderketten der SCSI-Geräte, damit ein neues Gerät, welches der SCSI-Karte hinzugefügt wird, unbenutzte Gerätenummern erhält. Aber was geschieht, wenn ein USB-Gerät möglicherweise die primäre SCSI-Platte ersetzt? Dies kann passieren, weil USB-Geräte normalerweise vor der SCSI-Karte geprüft werden. Eine Lösung ist das Hinzufügen dieser Geräte, nachdem das System gestartet ist. Eine andere Lösung könnte sein, nur ein einzelnes ATA-Laufwerk zu nutzen und die SCSI-Geräte niemals in der <span class=filename>/etc/fstab</span> aufzuführen.</p></div><div class=paragraph><p>Eine bessere Lösung ist die Verwendung von <code>glabel</code>, um die Laufwerke zu mit Labeln zu versehen und diese in <span class=filename>/etc/fstab</span> zu nutzen. Da <code>glabel</code> seine Label im letzten Sektor jedes vorhandenen Datenträgers speichert, wird das Label persistent bleiben (auch über Neustarts hinweg). Durch Nutzung dieses Labels als Gerät kann das Dateisystem immer gemountet sein, unabhängig davon, durch welchen Geräte-Knotenpunkt auf ihn zugegriffen wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>glabel</code> kann permanente (dauerhaft) und vorübergehende Label erstellen. Aber nur dauerhafte Label bleiben konsistent über Neustarts hinweg. Lesen Sie die <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> für weitere Unterschiede zwischen den Label-Typen.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_label_typen_und_beispiele>36.7.1. Label-Typen und Beispiele<a class=anchor href=#_label_typen_und_beispiele></a></h4><div class=paragraph><p>Permanente Label können generische Label oder Dateisystem-Label sein. Permanente Dateisystem-Label können mit <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> erzeugt werden. Dieser Typ von Label wird in einem Unterverzeichnis von <span class=filename>/dev</span> angelegt und wird dem Dateisystem entsprechend benannt. UFS2-Dateisystem-Label werden zum Beispiel in <span class=filename>/dev/ufs</span> angelegt. Permanente Label können außerdem durch den Befehl <code>glabel label</code> erzeugt werden. Diese Label sind nicht dateisystemspezisch und werden im Unterverzeichnis <span class=filename>/dev/label</span> erzeugt.</p></div><div class=paragraph><p>Temporäre Label werden beim nächsten Systemstart zerstört. Diese Label werden im Verzeichnis <span class=filename>/dev/label</span> erzeugt und sind ideal für Testzwecke. Ein temporäres Label kann mit <code>glabel create</code> erzeugt werden.</p></div><div class=paragraph><p>Um ein permanentes Label auf einem UFS2-Dateisystem ohne Löschung von Daten zu erzeugen, kann man folgenden Befehl verwenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -L home /dev/da3</span></code></pre></div></div><div class=paragraph><p>In <span class=filename>/dev/ufs</span> sollte nun ein Label vorhanden sein, welches zu <span class=filename>/etc/fstab</span> hinzugefügt werden kann:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufs/home		/home            ufs     rw              2      2</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das Dateisystem darf nicht gemountet sein beim Versuch, <code>tunefs</code> auszuführen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nun kann das Dateisystem eingehängt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /home</span></code></pre></div></div><div class=paragraph><p>Von nun an kann der Geräte-Knotenpunkt sich ohne negative Effekte auf das System ändern, solange das Kernelmodul <span class=filename>geom_label.ko</span> beim Systemstart mittels <span class=filename>/boot/loader.conf</span> geladen wird oder die <code>GEOM_LABEL</code>-Kernel-Option aktiv ist.</p></div><div class=paragraph><p>Dateisysteme können auch mit einem Standard-Label erzeugt werden (mittels des Flags <code>-L</code> in <code>newfs</code>). Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> für weitere Informationen.</p></div><div class=paragraph><p>Der folgende Befehl kann genutzt werden, um das Label zu beseitigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel destroy home</span></code></pre></div></div><div class=paragraph><p>Das folgende Beispiel zeigt Ihnen, wie Sie Label für die Partitionen einer Bootplatte erzeugen.</p></div><div class=exampleblock><div class=title>Beispiel 42. Die Partitionen einer Bootplatte labeln</div><div class=content><div class=paragraph><p>Durch das Erstellen von permanenten Labeln für die Partitionen einer Bootplatte sollte das System selbst dann noch normal starten können, wenn Sie die Platte an einen anderen Controller anschließen oder in ein anderes System installieren. In diesem Beispiel nehmen wir an, dass nur eine einzige ATA-Platte verwendet wird, die das System derzeit als <span class=filename>ad0</span> erkennt. Weiters nehmen wir an, dass Sie das Standard-Partionierungsschema von FreeBSD vewendet haben und die Platte daher die Dateisysteme <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/usr</span> sowie <span class=filename>/tmp</span> aufweist. Zusätzlich wurde eine Swap-Partition angelegt.</p></div><div class=paragraph><p>Starten Sie das System neu. Am <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>-Prompt drücken Sie die Taste <kbd>4</kbd>, um in den Single-User-Modus zu gelangen. Dort führen Sie die folgenden Befehle aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel label rootfs /dev/ad0s1a</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1a is label/rootfs
<span class=c># glabel label var /dev/ad0s1d</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1d is label/var
<span class=c># glabel label usr /dev/ad0s1f</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1f is label/usr
<span class=c># glabel label tmp /dev/ad0s1e</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1e is label/tmp
<span class=c># glabel label swap /dev/ad0s1b</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1b is label/swap
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>Das System startet daraufhin in den Multi-User-Modus. Nachdem der Startvorgang abgeschlossen ist, editieren Sie <span class=filename>/etc/fstab</span> und ersetzen die konventionellen Gerätedateien durch die entsprechenden Label. Die modifizierte <span class=filename>/etc/fstab</span> sollte wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2</pre></div></div><div class=paragraph><p>Starten Sie das System neu. Treten keine Probleme auf, wird das System normal hochfahren und Sie erhalten die folgende Ausgabe, wenn Sie den Befehl <code>mount</code> ausführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/label/rootfs on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/label/tmp on /tmp <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/usr on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/var on /var <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> unterstützt einen Labeltyp für UFS-Dateisysteme. Dieser basiert auf der eindeutigen Dateisystem-ID <code>ufsid</code>. Derartige Label finden sich in <span class=filename>/dev/ufsid</span> und werden während des Systemstarts automatisch erzeugt. Es ist möglich, diese <code>ufsid</code>-Label zum automatischen Einhängen von Partitionen in <span class=filename>/etc/fstab</span> einzusetzen. Verwenden Sie <code>glabel status</code>, um eine Liste aller Dateisysteme und ihrer <code>ufsid</code>-Label zu erhalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% glabel status
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</code></pre></div></div><div class=paragraph><p>In diesem Beispiel repräsentiert <span class=filename>ad4s1d</span> das <span class=filename>/var</span>-Dateisystem, während <span class=filename>ad4s1f</span> dem <span class=filename>/usr</span>-Dateisystem entspricht. Wenn Sie die angegebenen <code>ufsid</code>-Werte verwenden, können diese Dateisysteme durch die folgenden Einträge in der Datei <span class=filename>/etc/fstab</span> gemountet werden:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2</pre></div></div><div class=paragraph><p>Jede Partition, die ein <code>ufsid</code>-Label aufweist, kann auf diese Art gemountet werden. Dies hat den Vorteil, dass Sie die permanenten Label nicht manuell anlegen müssen, wobei sich die Platten nach wie vor über geräteunabhängige Namen ansprechen und einhängen lassen.</p></div></div></div><div class=sect2><h3 id=geom-gjournal>36.8. UFS Journaling in GEOM<a class=anchor href=#geom-gjournal></a></h3><div class=paragraph><p>FreeBSD unterstützt Journaling für UFS-Dateisysteme. Diese Funktion wird über das GEOM-Subsystem realisiert und kann über das Werkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=gjournal&amp;sektion=8&amp;format=html">gjournal(8)</a> eingerichtet werden. Im Gegensatz zu anderen Journaling-Dateisystemen arbeitet <code>gjournal</code> blockbasiert und wurde nicht als Teil des Dateisystems implementiert, sondern als GEOM-Erweiterung.</p></div><div class=paragraph><p>Bei Journaling wird ein Protokoll über alle Dateisystemtransaktionen angelegt, inklusive aller Veränderungen, aus denen ein kompletter Schreibvorgang besteht, bevor diese Änderungen (Metadaten sowie tatsächliche Schreibvorgänge) physisch auf der Festplatte ausgeführt werden. Dieses Protokoll kann später erneut aufgerufen werden, um diese Vorgänge zu wiederholen, damit Systeminkonsistenzen vermieden werden.</p></div><div class=paragraph><p>Diese Technik bietet eine weitere Möglichkeit, sich vor Datenverlust und Dateisystem-Inkonsistenzen zu schützen. Im Gegensatz zu Soft Updates (die Metadaten-Aktualisierungen verfolgen und erzwingen) und Snapshots (die ein Image eines Dateisystems darstellen) wird bei Journaling ein tatsächliches Protokoll in einem speziell dafür bereitgestellten Bereich der Festplatte gespeichert. Um die Leistung zu optimieren, kann das Journal auf eine externe Platte ausgelagert werden. In einem solchen Fall geben Sie die Gerätedatei der Platte nach dem Gerät an, für das Sie Journaling aktivieren wollen.</p></div><div class=paragraph><p>Der <span class=filename>GENERIC</span>-Kernel bietet Unterstützung für <code>gjournal</code>. Damit das Kernelmodul <span class=filename>geom_journal.ko</span> beim Booten automatisch geladen wird, fügen Sie folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_journal_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Wenn ein angepasster Kernel benutzt wird, stellen Sie sicher, dass folgende Zeile in der Kernelkonfigurationsdatei enthalten ist:</p></div><div class="literalblock programlisting"><div class=content><pre>options     GEOM_JOURNAL</pre></div></div><div class=paragraph><p>Sobald das Modul geladen ist, kann ein Journal auf einem neuen Dateisystem erstellt werden. In diesem Beispiel ist <span class=filename>da4</span> die neue SCSI-Platte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gjournal load</span>
<span class=c># gjournal label /dev/da4</span></code></pre></div></div><div class=paragraph><p>Diese Befehle laden das Modul und erstellen die Gerätedatei <span class=filename>/dev/da4.journal</span> auf <span class=filename>/dev/da4</span>.</p></div><div class=paragraph><p>Nun kann auf dem neuen Gerät ein UFS-Dateisystem erstellt werden, welches dann in den Verzeichnisbaum eingehängt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -O 2 -J /dev/da4.journal</span>
<span class=c># mount /dev/da4.journal /mnt</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls auf dem System mehrere Slices angelegt sind (beispielsweise <span class=filename>ad4s1</span> sowie <span class=filename>ad4s2</span>), wird <code>gjournal</code> für jedes Slice ein Journal anlegen (also <span class=filename>ad4s1.journal</span> sowie <span class=filename>ad4s2.journal</span>).</p></div></td></tr></tbody></table></div><div class=paragraph><p>Mit <code>tunefs</code> ist es auch möglich, Journaling auf bereits existierenden Dateisystemen zu aktivieren. Machen Sie aber <em>immer</em> eine Sicherung der Daten, bevor Sie versuchen, ein existierendes Dateisystem zu ändern. <code>gjournal</code> wird zwar den Vorgang abbrechen, wenn es das Journal nicht erzeugen kann, allerdings schützt dies nicht vor Datenverlust durch einen fehlerhaften Einsatz von <code>tunefs</code>. Weitere Informationen über diese beiden Werkzeuge finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=gjournal&amp;sektion=8&amp;format=html">gjournal(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>.</p></div><div class=paragraph><p>Es ist möglich, Journale auch für die Bootplatte eines FreeBSD-Systems zu verwenden. Der Artikel <a href=https://docs.freebsd.org/en/articles/gjournal-desktop/>Implementing UFS Journaling on a Desktop PC</a> enthält eine ausführliche Anleitung zu diesem Thema.</p></div></div></div></div><div class=sect1><h2 id=zfs>Kapitel 37. Das Z-Dateisystem (ZFS)<a class=anchor href=#zfs></a></h2><div class=sectionbody><div class=paragraph><p>Das <em>Z-Dateisystem</em>, oder kurz ZFS, ist ein fortgeschrittenes Dateisystem, das entwickelt wurde, um viele der großen Probleme in vorherigen Entwicklungen zu überwinden.</p></div><div class=paragraph><p>Ursprünglich von Sun™ entworfen, wird die weitere Entwicklung von ZFS heutzutage als Open Source vom <a href=http://open-zfs.org>OpenZFS Projekt</a> vorangetrieben.</p></div><div class=paragraph><p>ZFS hat drei große Entwurfsziele:</p></div><div class=ulist><ul><li><p>Datenintegrität: Alle Daten enthalten eine Prüfsumme (<a href=#zfs-term-checksum>checksum</a>) der Daten. Wenn Daten geschrieben werden, wird die Prüfsumme berechnet und zusammen mit den Daten gespeichert. Wenn diese Daten später wieder eingelesen werden, wird diese Prüfsumme erneut berechnet. Falls die Prüfsummen nicht übereinstimmen, wurde ein Datenfehler festgestellt. ZFS wird versuchen, diesen Fehler automatisch zu korrigieren, falls genug Datenredundanz vorhanden ist.</p></li><li><p>Gepoolter Speicher: physikalische Speichermedien werden zu einem Pool zusammengefasst und der Speicherplatz wird von diesem gemeinsam genutzten Pool allokiert. Der Speicherplatz steht allen Dateisystemen zur Verfügung und kann durch das Hinzufügen von neuen Speichermedien vergrößert werden.</p></li><li><p>Geschwindigkeit: mehrere Zwischenspeichermechanismen sorgen für erhöhte Geschwindigkeit. Der <a href=#zfs-term-arc>ARC</a> ist ein weiterentwickelter, hauptspeicherbasierter Zwischenspeicher für Leseanfragen. Auf einer zweiten Stufe kann ein plattenbasierter <a href=#zfs-term-l2arc>L2ARC</a>-Lesezwischenspeicher hinzugefügt werden. Zusätzlich ist auch noch ein plattenbasierter, synchroner Schreibzwischenspeicher verfügbar, der sog. <a href=#zfs-term-zil>ZIL</a>.</p></li></ul></div><div class=paragraph><p>Eine vollständige Liste aller Eigenschaften und der dazugehörigen Terminologie ist in <a href=#zfs-term>ZFS-Eigenschaften und Terminologie</a> zu sehen.</p></div><div class=sect2><h3 id=zfs-differences>37.1. Was ZFS anders macht<a class=anchor href=#zfs-differences></a></h3><div class=paragraph><p>ZFS ist signifikant unterschiedlich zu allen bisherigen Dateisystemen, weil es mehr als nur ein Dateisystem ist. Durch die Kombination von traditionell getrennten Rollen von Volumenmanager und Dateisystem ist ZFS mit einzigartigen Vorteilen ausgestattet. Das Dateisystem besitzt jetzt Kenntnis von der zugrundeliegenden Struktur der Speichermedien. Traditionelle Dateisysteme konnten nur auf einer einzigen Platte gleichzeitig angelegt werden. Falls es zwei Festplatten gab, mussten auch zwei getrennte Dateisysteme erstellt werden. In einer traditionellen Hardware-RAID-Konfiguration wurde dieses Problem umgangen, indem dem Betriebssystem nur eine einzige logische Platte angezeigt wurde, die sich aus dem Speicherplatz von der Anzahl an physischen Platten zusammensetzte, auf dem dann das Betriebssystem ein Dateisystem erstellte. Sogar im Fall von Software-RAID-Lösungen, wie die, die von GEOM bereitgestellt werden, war das UFS-Dateisystem der Ansicht, dass es auf nur einem einzigen Gerät angelegt wurde. ZFS’s Kombination eines Volumenmanagers und eines Dateisystems löst dies und erlaubt das Erstellen von vielen Dateisystemen, die sich alle den darunterliegenden Pool aus verfügbarem Speicher teilen. Einer der größten Vorteile von ZFS’s Kenntnis des physikalischen Layouts der Platten ist, dass existierende Dateisysteme automatisch wachsen können, wenn zusätzliche Platten zum Pool hinzugefügt werden. Dieser neue Speicherplatz wird dann allen Dateisystemen zur Verfügung gestellt. ZFS besitzt ebenfalls eine Menge an unterschiedlichen Eigenschaften, die für jedes Dateisystem angepasst werden können, was viele Vorteile bringt, wenn man unterschiedliche Dateisysteme und Datasets anlegt, anstatt ein einziges, monolithisches Dateisystem zu erzeugen.</p></div></div><div class=sect2><h3 id=zfs-quickstart>37.2. Schnellstartanleitung<a class=anchor href=#zfs-quickstart></a></h3><div class=paragraph><p>Es existiert ein Startmechanismus, der es FreeBSD erlaubt, ZFS-Pools während der Systeminitialisierung einzubinden. Um diesen zu aktivieren, fügen Sie diese Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>zfs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten Sie dann den Dienst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service zfs start</span></code></pre></div></div><div class=paragraph><p>Die Beispiele in diesem Abschnitt gehen von drei SCSI-Platten mit den Gerätenamen <span class=filename>da0</span>, <span class=filename>da1</span> und <span class=filename>da2</span> aus. Nutzer von SATA-Hardware sollten stattdessen die Bezeichnung <span class=filename>ada</span> als Gerätenamen verwenden.</p></div><div class=sect3><h4 id=zfs-quickstart-single-disk-pool>37.2.1. Pools mit einer Platte<a class=anchor href=#zfs-quickstart-single-disk-pool></a></h4><div class=paragraph><p>Um einen einfachen, nicht-redundanten Pool mit einem einzigen Gerät anzulegen, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create example /dev/da0</span></code></pre></div></div><div class=paragraph><p>Um den neuen Pool anzuzeigen, prüfen Sie die Ausgabe von <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example</code></pre></div></div><div class=paragraph><p>Diese Ausgabe zeigt, dass der <code>example</code>-Pool erstellt und eingehängt wurde. Er ist nun als Dateisystem verfügbar. Dateien können darauf angelegt werden und Anwender können sich den Inhalt ansehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /example</span>
<span class=c># ls</span>
<span class=c># touch testfile</span>
<span class=c># ls -al</span>
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 <span class=nb>.</span>
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
<span class=nt>-rw-r--r--</span>   1 root  wheel    0 Aug 29 23:15 testfile</code></pre></div></div><div class=paragraph><p>Allerdings nutzt dieser Pool noch keine der Vorteile von ZFS. Um ein Dataset auf diesem Pool mit aktivierter Komprimierung zu erzeugen, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create example/compressed</span>
<span class=c># zfs set compression=gzip example/compressed</span></code></pre></div></div><div class=paragraph><p>Das <code>example/compressed</code>-Dataset ist nun ein komprimiertes ZFS-Dateisystem. Versuchen Sie, ein paar große Dateien auf <span class=filename>/example/compressed</span> zu kopieren.</p></div><div class=paragraph><p>Deaktivieren lässt sich die Komprimierung durch:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set compression=off example/compressed</span></code></pre></div></div><div class=paragraph><p>Um ein Dateisystem abzuhängen, verwenden Sie <code>zfs umount</code> und überprüfen Sie dies anschließend mit <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs umount example/compressed</span>
<span class=c># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example</code></pre></div></div><div class=paragraph><p>Um das Dateisystem wieder einzubinden und erneut verfügbar zu machen, verwenden Sie <code>zfs mount</code> und prüfen Sie erneut mit <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs mount example/compressed</span>
<span class=c># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed</code></pre></div></div><div class=paragraph><p>Den Pool und die Dateisysteme können Sie auch über die Ausgabe von <code>mount</code> prüfen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/ad0s1a on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/ad0s1d on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
example on /example <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
example/compressed on /example/compressed <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span></code></pre></div></div><div class=paragraph><p>Nach der Erstellung können ZFS-Datasets wie jedes andere Dateisystem verwendet werden. Jedoch sind jede Menge andere Besonderheiten verfügbar, die individuell auf Dataset-Basis eingestellt sein können. Im Beispiel unten wird ein neues Dateisystem namens <code>data</code> angelegt. Wichtige Dateien werden dort abgespeichert, deshalb wird es so konfiguriert, dass zwei Kopien jedes Datenblocks vorgehalten werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create example/data</span>
<span class=c># zfs set copies=2 example/data</span></code></pre></div></div><div class=paragraph><p>Es ist jetzt möglich, den Speicherplatzverbrauch der Daten durch die Eingabe von <code>df</code> zu sehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data</code></pre></div></div><div class=paragraph><p>Sie haben vermutlich bemerkt, dass jedes Dateisystem auf dem Pool die gleiche Menge an verfügbarem Speicherplatz besitzt. Das ist der Grund dafür, dass in diesen Beispielen <code>df</code> verwendet wird, um zu zeigen, dass die Dateisysteme nur die Menge an Speicher verbrauchen, den sie benötigen und alle den gleichen Pool verwenden. ZFS eliminiert Konzepte wie Volumen und Partitionen und erlaubt es mehreren Dateisystemen den gleichen Pool zu belegen.</p></div><div class=paragraph><p>Um das Dateisystem und anschließend den Pool zu zerstören, wenn dieser nicht mehr benötigt wird, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs destroy example/compressed</span>
<span class=c># zfs destroy example/data</span>
<span class=c># zpool destroy example</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-quickstart-raid-z>37.2.2. RAID-Z<a class=anchor href=#zfs-quickstart-raid-z></a></h4><div class=paragraph><p>Platten fallen aus. Eine Methode, um Datenverlust durch Festplattenausfall zu vermeiden, ist die Verwendung von RAID. ZFS unterstützt dies in seiner Poolgestaltung. Pools mit RAID-Z benötigen drei oder mehr Platten, bieten aber auch mehr nutzbaren Speicher als gespiegelte Pools.</p></div><div class=paragraph><p>Dieses Beispiel erstellt einen RAID-Z-Pool, indem es die Platten angibt, die dem Pool hinzugefügt werden sollen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create storage raidz da0 da1 da2</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sun™ empfiehlt, dass die Anzahl der Geräte in einer RAID-Z Konfiguration zwischen drei und neun beträgt. Für Umgebungen, die einen einzelnen Pool benötigen, der aus 10 oder mehr Platten besteht, sollten Sie in Erwägung ziehen, diesen in kleinere RAID-Z-Gruppen aufzuteilen. Falls nur zwei Platten verfügbar sind und Redundanz benötigt wird, ziehen Sie die Verwendung eines ZFS-Spiegels (mirror) in Betracht. Lesen Sie dazu <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a>, um weitere Details zu erhalten.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Das vorherige Beispiel erstellte einen ZPool namens <code>storage</code>. Dieses Beispiel erzeugt ein neues Dateisystem, genannt <code>home</code>, in diesem Pool:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create storage/home</span></code></pre></div></div><div class=paragraph><p>Komprimierung und das Vorhalten von mehreren Kopien von Dateien und Verzeichnissen kann aktiviert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set copies=2 storage/home</span>
<span class=c># zfs set compression=gzip storage/home</span></code></pre></div></div><div class=paragraph><p>Um dies als das neue Heimatverzeichnis für Anwender zu setzen, kopieren Sie die Benutzerdaten in dieses Verzeichnis und erstellen passende symbolische Verknüpfungen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp -rp /home/* /storage/home</span>
<span class=c># rm -rf /home /usr/home</span>
<span class=c># ln -s /storage/home /home</span>
<span class=c># ln -s /storage/home /usr/home</span></code></pre></div></div><div class=paragraph><p>Daten von Anwendern werden nun auf dem frisch erstellten <span class=filename>/storage/home</span> abgelegt. Überprüfen Sie dies durch das Anlegen eines neuen Benutzers und das anschließende Anmelden als dieser Benutzer.</p></div><div class=paragraph><p>Versuchen Sie, einen Dateisystemschnappschuss anzulegen, den Sie später wieder zurückrollen können:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>Schnappschüsse können nur auf einem Dateisystem angelegt werden, nicht auf einem einzelnen Verzeichnis oder einer Datei.</p></div><div class=paragraph><p>Das Zeichen <code>@</code> ist der Trenner zwischen dem Dateisystem- oder dem Volumennamen. Wenn ein wichtiges Verzeichnis aus Versehen gelöscht wurde, kann das Dateisystem gesichert und dann zu einem früheren Schnappschuss zurückgerollt werden, in welchem das Verzeichnis noch existiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs rollback storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>Um all verfügbaren Schnappschüsse aufzulisten, geben Sie <code>ls</code> im Verzeichnis <span class=filename>.zfs/snapshot</span> dieses Dateisystems ein. Beispielsweise lässt sich der zuvor angelegte Schnappschuss wie folgt anzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /storage/home/.zfs/snapshot</span></code></pre></div></div><div class=paragraph><p>Es ist möglich, ein Skript zu schreiben, um regelmäßig Schnappschüsse von Benutzerdaten anzufertigen. Allerdings verbrauchen Schnappschüsse über lange Zeit eine große Menge an Speicherplatz. Der zuvor angelegte Schnappschuss kann durch folgendes Kommando wieder entfernt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs destroy storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>Nach erfolgreichen Tests kann <span class=filename>/storage/home</span> zum echten <span class=filename>/home</span>-Verzeichnis werden, mittels:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set mountpoint=/home storage/home</span></code></pre></div></div><div class=paragraph><p>Prüfen Sie mit <code>df</code> und <code>mount</code>, um zu bestätigen, dass das System das Dateisystem nun als <span class=filename>/home</span> verwendet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/ad0s1a on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/ad0s1d on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
storage on /storage <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
storage/home on /home <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
<span class=c># df</span>
Filesystem   1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a    2026030  235240  1628708    13%    /
devfs                1       1        0   100%    /dev
/dev/ad0s1d   54098308 1032826 48737618     2%    /usr
storage       26320512       0 26320512     0%    /storage
storage/home  26320512       0 26320512     0%    /home</code></pre></div></div><div class=paragraph><p>Damit ist die RAID-Z Konfiguration abgeschlossen. Tägliche Informationen über den Status der erstellten Dateisysteme können als Teil des nächtlichen <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>-Berichts generiert werden. Fügen Sie dazu die folgende Zeile in <span class=filename>/etc/periodic.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>daily_status_zfs_enable=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=zfs-quickstart-recovering-raid-z>37.2.3. RAID-Z wiederherstellen<a class=anchor href=#zfs-quickstart-recovering-raid-z></a></h4><div class=paragraph><p>Jedes Software-RAID besitzt eine Methode, um den Zustand (<code>state</code>) zu überprüfen. Der Status von RAID-Z Geräten wird mit diesem Befehl angezeigt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status -x</span></code></pre></div></div><div class=paragraph><p>Wenn alle Pools <a href=#zfs-term-online>Online</a> sind und alles normal ist, zeigt die Meldung folgendes an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>all pools are healthy</code></pre></div></div><div class=paragraph><p>Wenn es ein Problem gibt, womöglich ist eine Platte im Zustand <a href=#zfs-term-offline>Offline</a>, dann wird der Poolzustand ähnlich wie dieser aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  pool: storage
 state: DEGRADED
status: One or more devices has been taken offline by the administrator.
	Sufficient replicas exist <span class=k>for </span>the pool to <span class=k>continue </span>functioning <span class=k>in </span>a
	degraded state.
action: Online the device using <span class=s1>&#39;zpool online&#39;</span> or replace the device with
	<span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
 scrub: none requested
config:

	NAME        STATE     READ WRITE CKSUM
	storage     DEGRADED     0     0     0
	  raidz1    DEGRADED     0     0     0
	    da0     ONLINE       0     0     0
	    da1     OFFLINE      0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Dies zeigt an, dass das Gerät zuvor vom Administrator mit diesem Befehl abgeschaltet wurde:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool offline storage da1</span></code></pre></div></div><div class=paragraph><p>Jetzt kann das System heruntergefahren werden, um <span class=filename>da1</span> zu ersetzen. Wenn das System wieder eingeschaltet wird, kann die fehlerhafte Platte im Pool ersetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool replace storage da1</span></code></pre></div></div><div class=paragraph><p>Von diesem Punkt an kann der Status erneut geprüft werden. Dieses Mal ohne die Option <code>-x</code>, damit alle Pools angezeigt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>In diesem Beispiel ist alles normal.</p></div></div><div class=sect3><h4 id=zfs-quickstart-data-verification>37.2.4. Daten verifizieren<a class=anchor href=#zfs-quickstart-data-verification></a></h4><div class=paragraph><p>ZFS verwendet Prüfsummen, um die Integrität der gespeicherten Daten zu gewährleisten. Dies wird automatisch beim Erstellen von Dateisystemen aktiviert.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Prüfsummen können deaktiviert werden, dies wird jedoch <em>nicht</em> empfohlen! Prüfsummen verbrauchen nur sehr wenig Speicherplatz und sichern die Integrität der Daten. Viele Eigenschaften vom ZFS werden nicht richtig funktionieren, wenn Prüfsummen deaktiviert sind. Es gibt keinen merklichen Geschwindigkeitsunterschied durch das Deaktivieren dieser Prüfsummen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Prüfsummenverifikation ist unter der Bezeichnung <em>scrubbing</em> bekannt. Verifizieren Sie die Integrität der Daten des <code>storage</code>-Pools mit diesem Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool scrub storage</span></code></pre></div></div><div class=paragraph><p>Die Laufzeit einer Überprüfung hängt ab von der Menge an Daten, die gespeichert sind. Größere Mengen an Daten benötigen proportional mehr Zeit zum überprüfen. Diese Überprüfungen sind sehr I/O-intensiv und es kann auch nur eine Überprüfung zur gleichen Zeit durchgeführt werden. Nachdem eine Prüfung beendet ist, kann der Status mit dem Unterkommando <code>status</code> angezeigt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: scrub completed with 0 errors on Sat Jan 26 19:57:37 2013
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Das Datum der letzten Prüfoperation wird angezeigt, um zu verfolgen, wann die nächste Prüfung benötigt wird. Routinemässige Überprüfungen helfen dabei, Daten vor stiller Korrumpierung zu schützen und die Integrität des Pools sicher zu stellen.</p></div><div class=paragraph><p>Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=8&amp;format=html">zfs(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a>, um über weitere ZFS-Optionen zu erfahren.</p></div></div></div><div class=sect2><h3 id=zfs-zpool>37.3. <code>zpool</code> Administration<a class=anchor href=#zfs-zpool></a></h3><div class=paragraph><p>Administration von ZFS ist unterteilt zwischen zwei Hauptkommandos. Das <code>zpool</code>-Werkzeug steuert die Operationen des Pools und kümmert sich um das Hinzufügen, entfernen, ersetzen und verwalten von Platten. Mit dem <a href=#zfs-zfs><code>zfs</code></a>-Befehl können Datasets erstellt, zerstört und verwaltet werden, sowohl <a href=#zfs-term-filesystem>Dateisysteme</a> als auch <a href=#zfs-term-volume>Volumes</a>.</p></div><div class=sect3><h4 id=zfs-zpool-create>37.3.1. Pools anlegen und zerstören<a class=anchor href=#zfs-zpool-create></a></h4><div class=paragraph><p>Einen ZFS-Pool (<em>zpool</em>) anzulegen beinhaltet das Treffen von einer Reihe von Entscheidungen, die relativ dauerhaft sind, weil die Struktur des Pools nachdem er angelegt wurde, nicht mehr geändert werden kann. Die wichtigste Entscheidung ist, welche Arten von vdevs als physische Platten zusammengefasst werden soll. Sehen Sie sich dazu die Liste von <a href=#zfs-term-vdev>vdev-Arten</a> an, um Details zu möglichen Optionen zu bekommen. Nachdem der Pool angelegt wurde, erlauben die meisten vdev-Arten es nicht mehr, weitere Geräte zu diesem vdev hinzuzufügen. Die Ausnahme sind Spiegel, die das Hinzufügen von weiteren Platten zum vdev gestatten, sowie stripes, die zu Spiegeln umgewandelt werden können, indem man zusätzliche Platten zum vdev anhängt. Obwohl weitere vdevs eingefügt werden können, um einen Pool zu vergrößern, kann das Layout des Pools nach dem Anlegen nicht mehr verändert werden. Stattdessen müssen die Daten gesichert, der Pool zerstört und danach neu erstellt werden.</p></div><div class=paragraph><p>Erstellen eines einfachen gespiegelten Pools:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create mypool mirror /dev/ada1 /dev/ada2</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Mehrere vdevs können gleichzeitig angelegt werden. Geben Sie zusätzliche Gruppen von Platten, getrennt durch das vdev-Typ Schlüsselwort, in diesem Beispiel <code>mirror</code>, an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create mypool mirror /dev/ada1 /dev/ada2 mirror /dev/ada3 /dev/ada4</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada3    ONLINE       0     0     0
            ada4    ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Pools lassen sich auch durch die Angabe von Partitionen anstatt von ganzen Platten erzeugen. Durch die Verwendung von ZFS in einer separaten Partition ist es möglich, dass die gleiche Platte andere Partitionen für andere Zwecke besitzen kann. Dies ist besonders von Interesse, wenn Partitionen mit Bootcode und Dateisysteme, die zum starten benötigt werden, hinzugefügt werden können. Das erlaubt es, von Platten zu booten, die auch Teil eines Pools sind. Es gibt keinen Geschwindigkeitsnachteil unter FreeBSD wenn eine Partition anstatt einer ganzen Platte verwendet wird. Durch den Einsatz von Partitionen kann der Administrator die Platten <em>unter provisionieren</em>, indem weniger als die volle Kapazität Verwendung findet. Wenn in Zukunft eine Ersatzfestplatte mit der gleichen Größe als die Originalplatte eine kleinere Kapazität aufweist, passt die kleinere Partition immer noch und die Ersatzplatte kann immer noch verwendet werden.</p></div><div class=paragraph><p>Erstellen eines <a href=#zfs-term-vdev-raidz>RAID-Z2</a>-Pools mit Partitionen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create mypool raidz2 /dev/ada0p3 /dev/ada1p3 /dev/ada2p3 /dev/ada3p3 /dev/ada4p3 /dev/ada5p3</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Ein Pool, der nicht länger benötigt wird, kann zerstört werden, so dass die Platten für einen anderen Einsatzzweck Verwendung finden können. Um einen Pool zu zerstören, müssen zuerst alle Datasets in diesem Pool abgehängt werden. Wenn die Datasets verwendet werden, wird das Abhängen fehlschlagen und der Pool nicht zerstört. Die Zerstörung des Pools kann erzwungen werden durch die Angabe der Option <code>-f</code>, jedoch kann dies undefiniertes Verhalten in den Anwendungen auslösen, die noch offene Dateien auf diesen Datasets hatten.</p></div></div><div class=sect3><h4 id=zfs-zpool-attach>37.3.2. Hinzufügen und Löschen von Geräten<a class=anchor href=#zfs-zpool-attach></a></h4><div class=paragraph><p>Es gibt zwei Fälle für das Hinzufügen von Platten zu einem Pool: einhängen einer Platte zu einem existierenden vdev mit <code>zpool attach</code> oder einbinden von vdevs zum Pool mit <code>zpool add</code>. Nur manche <a href=#zfs-term-vdev>vdev-Arten</a> gestatten es, Platten zum vdev hinzuzufügen, nachdem diese angelegt wurden.</p></div><div class=paragraph><p>Ein Pool mit nur einer einzigen Platte besitzt keine Redundanz. Datenverfälschung kann erkannt, aber nicht repariert werden, weil es keine weiteren Kopien der Daten gibt. Die Eigenschaft <a href=#zfs-term-copies>copies</a> kann genutzt werden, um einen geringen Fehler wie einen beschädigtem Sektor auszumerzen, enthält aber nicht die gleiche Art von Schutz, die Spiegelung oder RAID-Z bieten. Wenn man mit einem Pool startet, der nur aus einer einzigen vdev-Platte besteht, kann mit dem Kommando <code>zpool attach</code> eine zustätzliche Platte dem vdev hinzugefügt werden, um einen Spiegel zu erzeugen. Mit <code>zpool attach</code> können auch zusätzliche Platten zu einer Spiegelgruppe eingefügt werden, was die Redundanz und Lesegeschwindigkeit steigert. Wenn die Platten, aus denen der Pool besteht, partitioniert sind, replizieren Sie das Layout der ersten Platte auf die Zweite. Verwenden Sie dazu <code>gpart backup</code> und <code>gpart restore</code>, um diesen Vorgang einfacher zu gestalten.</p></div><div class=paragraph><p>Umwandeln eines (stripe) vdevs namens <em>ada0p3</em> mit einer einzelnen Platte zu einem Spiegel durch das Einhängen von <em>ada1p3</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          ada0p3    ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool attach mypool ada0p3 ada1p3</span>
Make sure to <span class=nb>wait </span><span class=k>until </span>resilver is <span class=k>done </span>before rebooting.

If you boot from pool <span class=s1>&#39;mypool&#39;</span>, you may need to update
boot code on newly attached disk <span class=s1>&#39;ada1p3&#39;</span><span class=nb>.</span>

Assuming you use GPT partitioning und <span class=s1>&#39;da0&#39;</span> is your new boot disk
you may use the following <span class=nb>command</span>:

        gpart bootcode <span class=nt>-b</span> /boot/pmbr <span class=nt>-p</span> /boot/gptzfsboot <span class=nt>-i</span> 1 da0
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1</span>
bootcode written to ada1
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        <span class=k>continue </span>to <span class=k>function</span>, possibly <span class=k>in </span>a degraded state.
action: Wait <span class=k>for </span>the resilver to complete.
  scan: resilver <span class=k>in </span>progress since Fri May 30 08:19:19 2014
        527M scanned out of 781M at 47.9M/s, 0h0m to go
        527M resilvered, 67.53% <span class=k>done
</span>config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0  <span class=o>(</span>resilvering<span class=o>)</span>

errors: No known data errors
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:15:58 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Wenn das Hinzufügen von Platten zu einem vdev keine Option wie für RAID-Z ist, gibt es eine Alternative, nämlich einen anderen vdev zum Pool hinzuzufügen. Zusätzliche vdevs bieten höhere Geschwindigkeit, indem Schreibvorgänge über die vdevs verteilt werden. Jedes vdev ist dafür verantwortlich, seine eigene Redundanz sicherzustellen. Es ist möglich, aber nicht empfehlenswert, vdev-Arten zu mischen, wie zum Beispiel <code>mirror</code> und <code>RAID-Z</code>. Durch das Einfügen eines nicht-redundanten vdev zu einem gespiegelten Pool oder einem RAID-Z vdev riskiert man die Daten des gesamten Pools. Schreibvorgänge werden verteilt, deshalb ist der Ausfall einer nicht-redundanten Platte mit dem Verlust eines Teils von jedem Block verbunden, der auf den Pool geschrieben wird.</p></div><div class=paragraph><p>Daten werden über jedes vdev gestriped. Beispielsweise sind zwei Spiegel-vdevs effektiv ein RAID 10, dass über zwei Sets von Spiegeln die Daten schreibt. Speicherplatz wird so allokiert, dass jedes vdev zur gleichen Zeit vollgeschrieben wird. Es gibt einen Geschwindigkeitsnachteil wenn die vdevs unterschiedliche Menge von freiem Speicher aufweisen, wenn eine unproportionale Menge an Daten auf das weniger volle vdev geschrieben wird.</p></div><div class=paragraph><p>Wenn zusätzliche Geräte zu einem Pool, von dem gebootet wird, hinzugefügt werden, muss der Bootcode aktualisiert werden.</p></div><div class=paragraph><p>Einbinden einer zweiten Spiegelgruppe (<span class=filename>ada2p3</span> und <span class=filename>ada3p3</span>) zu einem bestehenden Spiegel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:19:35 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool add mypool mirror ada2p3 ada3p3</span>
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2</span>
bootcode written to ada2
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada3</span>
bootcode written to ada3
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Momentan können vdevs nicht von einem Pool entfernt und Platten nur von einem Spiegel ausgehängt werden, wenn genug Redundanz übrig bleibt. Wenn auch nur eine Platte in einer Spiegelgruppe bestehen bleibt, hört der Spiegel auf zu existieren und wird zu einem stripe, was den gesamten Pool riskiert, falls diese letzte Platte ausfällt.</p></div><div class=paragraph><p>Entfernen einer Platte aus einem Spiegel mit drei Platten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool detach mypool ada2p3</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-status>37.3.3. Den Status eines Pools überprüfen<a class=anchor href=#zfs-zpool-status></a></h4><div class=paragraph><p>Der Status eines Pools ist wichtig. Wenn ein Gerät sich abschaltet oder ein Lese-, Schreib- oder Prüfsummenfehler festgestellt wird, wird der dazugehörige Fehlerzähler erhöht. Die <code>status</code>-Ausgabe zeigt die Konfiguration und den Status von jedem Gerät im Pool und den Gesamtstatus des Pools. Aktionen, die durchgeführt werden sollten und Details zum letzten <a href=#zfs-zpool-scrub><code>scrub</code></a> werden ebenfalls angezeigt.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>2h25m with 0 errors on Sat Sep 14 04:25:50 2013
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-clear>37.3.4. Fehler beseitigen<a class=anchor href=#zfs-zpool-clear></a></h4><div class=paragraph><p>Wenn ein Fehler erkannt wurde, werden die Lese-, Schreib- oder Prüfsummenzähler erhöht. Die Fehlermeldung kann beseitigt und der Zähler mit <code>zpool clear <em>mypool</em></code> zurückgesetzt werden. Den Fehlerzustand zurückzusetzen kann wichtig sein, wenn automatisierte Skripte ablaufen, die den Administrator informieren, sobald der Pool Fehler anzeigt. Weitere Fehler werden nicht gemeldet, wenn der alte Fehlerbericht nicht entfernt wurde.</p></div></div><div class=sect3><h4 id=zfs-zpool-replace>37.3.5. Ein funktionierendes Gerät ersetzen<a class=anchor href=#zfs-zpool-replace></a></h4><div class=paragraph><p>Es gibt eine Reihe von Situationen, in denen es nötig ist, eine Platte mit einer anderen auszutauschen. Wenn eine funktionierende Platte ersetzt wird, hält der Prozess die alte Platte während des Ersetzungsvorganges noch aktiv. Der Pool wird nie den Zustand <a href=#zfs-term-degraded>degraded</a> erhalten, was das Risiko eines Datenverlustes minimiert. Alle Daten der alten Platte werden durch das Kommando <code>zpool replace</code> auf die Neue übertragen. Nachdem die Operation abgeschlossen ist, wird die alte Platte vom vdev getrennt. Falls die neue Platte grösser ist als die alte Platte , ist es möglich den Pool zu vergrößern, um den neuen Platz zu nutzen. Lesen Sie dazu <a href=#zfs-zpool-online>Einen Pool vergrößern</a>.</p></div><div class=paragraph><p>Ersetzen eines funktionierenden Geräts in einem Pool:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool replace mypool ada1p3 ada2p3</span>
Make sure to <span class=nb>wait </span><span class=k>until </span>resilver is <span class=k>done </span>before rebooting.

If you boot from pool <span class=s1>&#39;zroot&#39;</span>, you may need to update
boot code on newly attached disk <span class=s1>&#39;ada2p3&#39;</span><span class=nb>.</span>

Assuming you use GPT partitioning und <span class=s1>&#39;da0&#39;</span> is your new boot disk
you may use the following <span class=nb>command</span>:

        gpart bootcode <span class=nt>-b</span> /boot/pmbr <span class=nt>-p</span> /boot/gptzfsboot <span class=nt>-i</span> 1 da0
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        <span class=k>continue </span>to <span class=k>function</span>, possibly <span class=k>in </span>a degraded state.
action: Wait <span class=k>for </span>the resilver to complete.
  scan: resilver <span class=k>in </span>progress since Mon Jun  2 14:21:35 2014
        604M scanned out of 781M at 46.5M/s, 0h0m to go
        604M resilvered, 77.39% <span class=k>done
</span>config:

        NAME             STATE     READ WRITE CKSUM
        mypool           ONLINE       0     0     0
          mirror-0       ONLINE       0     0     0
            ada0p3       ONLINE       0     0     0
            replacing-1  ONLINE       0     0     0
              ada1p3     ONLINE       0     0     0
              ada2p3     ONLINE       0     0     0  <span class=o>(</span>resilvering<span class=o>)</span>

errors: No known data errors
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Mon Jun  2 14:21:52 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-resilver>37.3.6. Behandlung von fehlerhaften Geräten<a class=anchor href=#zfs-zpool-resilver></a></h4><div class=paragraph><p>Wenn eine Platte in einem Pool ausfällt, wird das vdev zu dem diese Platte gehört, den Zustand <a href=#zfs-term-degraded>degraded</a> erhalten. Alle Daten sind immer noch verfügbar, jedoch wird die Geschwindigkeit möglicherweise reduziert, weil die fehlenden Daten aus der verfügbaren Redundanz heraus berechnet werden müssen. Um das vdev in einen funktionierenden Zustand zurück zu versetzen, muss das physikalische Gerät ersetzt werden. ZFS wird dann angewiesen, den <a href=#zfs-term-resilver>resilver</a>-Vorgang zu beginnen. Daten, die sich auf dem defekten Gerät befanden, werden neu aus der vorhandenen Prüfsumme berechnet und auf das Ersatzgerät geschrieben. Nach Beendigung dieses Prozesses kehrt das vdev zum Status <a href=#zfs-term-online>online</a> zurück.</p></div><div class=paragraph><p>Falls das vdev keine Redundanz besitzt oder wenn mehrere Geräte ausgefallen sind und es nicht genug Redundanz gibt, um dies zu kompensieren, geht der Pool in den Zustand <a href=#zfs-term-faulted>faulted</a> über. Wenn keine ausreichende Anzahl von Geräten wieder an den Pool angeschlossen wird, fällt der Pool aus und die Daten müssen von Sicherungen wieder eingespielt werden.</p></div><div class=paragraph><p>Wenn eine defekte Platte ausgewechselt wird, wird der Name dieser defekten Platte mit der GUID des Geräts ersetzt. Ein neuer Gerätename als Parameter für <code>zpool replace</code> wird nicht benötigt, falls das Ersatzgerät den gleichen Gerätenamen besitzt.</p></div><div class=paragraph><p>Ersetzen einer defekten Platte durch <code>zpool replace</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: DEGRADED
status: One or more devices could not be opened.  Sufficient replicas exist <span class=k>for
        </span>the pool to <span class=k>continue </span>functioning <span class=k>in </span>a degraded state.
action: Attach the missing device und online it using <span class=s1>&#39;zpool online&#39;</span><span class=nb>.</span>
   see: http://illumos.org/msg/ZFS-8000-2Q
  scan: none requested
config:

        NAME                    STATE     READ WRITE CKSUM
        mypool                  DEGRADED     0     0     0
          mirror-0              DEGRADED     0     0     0
            ada0p3              ONLINE       0     0     0
            316502962686821739  UNAVAIL      0     0     0  was /dev/ada1p3

errors: No known data errors
<span class=c># zpool replace mypool 316502962686821739 ada2p3</span>
<span class=c># zpool status</span>
  pool: mypool
 state: DEGRADED
status: One or more devices is currently being resilvered.  The pool will
        <span class=k>continue </span>to <span class=k>function</span>, possibly <span class=k>in </span>a degraded state.
action: Wait <span class=k>for </span>the resilver to complete.
  scan: resilver <span class=k>in </span>progress since Mon Jun  2 14:52:21 2014
        641M scanned out of 781M at 49.3M/s, 0h0m to go
        640M resilvered, 82.04% <span class=k>done
</span>config:

        NAME                        STATE     READ WRITE CKSUM
        mypool                      DEGRADED     0     0     0
          mirror-0                  DEGRADED     0     0     0
            ada0p3                  ONLINE       0     0     0
            replacing-1             UNAVAIL      0     0     0
              15732067398082357289  UNAVAIL      0     0     0  was /dev/ada1p3/old
              ada2p3                ONLINE       0     0     0  <span class=o>(</span>resilvering<span class=o>)</span>

errors: No known data errors
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Mon Jun  2 14:52:38 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-scrub>37.3.7. Einen Pool überprüfen<a class=anchor href=#zfs-zpool-scrub></a></h4><div class=paragraph><p>Es wird empfohlen, dass Pools regelmäßig geprüft (<a href=#zfs-term-scrub>scrubbed</a>) werden, idealerweise mindestens einmal pro Monat. Der <code>scrub</code>-Vorgang ist beansprucht die Platte sehr und reduziert die Geschwindigkeit während er läuft. Vermeiden Sie Zeiten, in denen großer Bedarf besteht, wenn Sie <code>scrub</code> starten oder benutzen Sie <a href=#zfs-advanced-tuning-scrub_delay><code>vfs.zfs.scrub_delay</code></a>, um die relative Priorität vom <code>scrub</code> einzustellen, um zu verhindern, dass es mit anderen Aufgaben kollidiert.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool scrub mypool</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub <span class=k>in </span>progress since Wed Feb 19 20:52:54 2014
        116G scanned out of 8.60T at 649M/s, 3h48m to go
        0 repaired, 1.32% <span class=k>done
</span>config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Falls eine Überrpüfaktion abgebrochen werden muss, geben Sie <code>zpool scrub -s <em>mypool</em></code> ein.</p></div></div><div class=sect3><h4 id=zfs-zpool-selfheal>37.3.8. Selbstheilung<a class=anchor href=#zfs-zpool-selfheal></a></h4><div class=paragraph><p>Die Prüfsummen, welche zusammen mit den Datenblöcken gespeichert werden, ermöglichen dem Dateisystem, sich <em>selbst zu heilen</em>. Diese Eigenschaft wird automatisch Daten korrigieren, deren Prüfsumme nicht mit der Gespeicherten übereinstimmt, die auf einem anderen Gerät, das Teil des Pools ist, vorhanden ist. Beispielsweise bei einem Spiegel aus zwei Platten, von denen eine anfängt, Fehler zu produzieren und nicht mehr länger Daten speichern kann. Dieser Fall ist sogar noch schlimmer, wenn auf die Daten seit einiger Zeit nicht mehr zugegriffen wurde, zum Beispiel bei einem Langzeit-Archivspeicher. Traditionelle Dateisysteme müssen dann Algorithmen wie <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> ablaufen lassen, welche die Daten überprüfen und reparieren. Diese Kommandos benötigen einige Zeit und in gravierenden Fällen muss ein Administrator manuelle Entscheidungen treffen, welche Reparaturoperation vorgenommen werden soll. Wenn ZFS einen defekten Datenblock mit einer Prüfsumme erkennt, die nicht übereinstimmt, versucht es die Daten von der gespiegelten Platte zu lesen. Wenn diese Platte die korrekten Daten liefern kann, wird nicht nur dieser Datenblock an die anfordernde Applikation geschickt, sondern auch die falschen Daten auf der Disk reparieren, welche die falsche Prüfsumme erzeugt hat. Dies passiert während des normalen Betriebs des Pools, ohne dass eine Interaktion vom Systemadministrator notwendig wäre.</p></div><div class=paragraph><p>Das nächste Beispiel demonstriert dieses Verhalten zur Selbstheilung. Ein gespiegelter Pool mit den beiden Platten <span class=filename>/dev/ada0</span> und <span class=filename>/dev/ada1</span> wird angelegt.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create healer mirror /dev/ada0 /dev/ada1</span>
<span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
  scan: none requested
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool list</span>
NAME     SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
healer   960M  92.5K   960M         -         -     0%    0%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>Ein paar wichtige Daten, die es vor Datenfehlern mittels der Selbstheilungsfunktion zu schützen gilt, werden auf den Pool kopiert. Eine Prüfsumme wird zum späteren Vergleich berechnet.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /some/important/data /healer</span>
<span class=c># zfs list</span>
NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT
healer   960M  67.7M   892M     7%  1.00x  ONLINE  -
<span class=c># sha1 /healer &gt; checksum.txt</span>
<span class=c># cat checksum.txt</span>
SHA1 <span class=o>(</span>/healer<span class=o>)</span> <span class=o>=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f</code></pre></div></div><div class=paragraph><p>Datenfehler werden durch das Schreiben von zufälligen Daten an den Anfang einer Platte des Spiegels simuliert. Um ZFS daran zu hindern, die Daten so schnell zu reparieren, wie es diese entdeckt, wird der Pool vor der Veränderung exportiert und anschließend wieder importiert.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Dies ist eine gefährliche Operation, die wichtige Daten zerstören kann. Es wird hier nur zu Demonstrationszwecken gezeigt und sollte nicht während des normalen Betriebs des Pools versucht werden. Dieses vorsätzliche Korrumpierungsbeispiel sollte auf gar keinen Fall auf einer Platte mit einem anderen Dateisystem durchgeführt werden. Verwenden Sie keine anderen Gerätenamen als diejenigen, die hier gezeigt werden, die Teil des Pools sind. Stellen Sie sicher, dass die passende Sicherungen angefertigt haben, bevor Sie dieses Kommando ausführen!</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool export healer</span>
<span class=c># dd if=/dev/random of=/dev/ada1 bs=1m count=200</span>
200+0 records <span class=k>in
</span>200+0 records out
209715200 bytes transferred <span class=k>in </span>62.992162 secs <span class=o>(</span>3329227 bytes/sec<span class=o>)</span>
<span class=c># zpool import healer</span></code></pre></div></div><div class=paragraph><p>Der Status des Pools zeigt an, dass bei einem Gerät ein Fehler aufgetreten ist. Wichtig zu wissen ist, dass Anwendungen, die Daten vom Pool lesen keine ungültigen Daten erhalten haben. ZFS lieferte Daten vom <span class=filename>ada0</span>-Gerät mit der korrekten Prüfsumme aus. Das Gerät mit der fehlerhaften Prüfsumme kann sehr einfach gefunden werden, da die Spalte <code>CKSUM</code> einen Wert ungleich Null enthält.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status healer</span>
    pool: healer
   state: ONLINE
  status: One or more devices has experienced an unrecoverable error.  An
          attempt was made to correct the error.  Applications are unaffected.
  action: Determine <span class=k>if </span>the device needs to be replaced, und clear the errors
          using <span class=s1>&#39;zpool clear&#39;</span> or replace the device with <span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
     see: http://illumos.org/msg/ZFS-8000-4J
    scan: none requested
  config:

      NAME        STATE     READ WRITE CKSUM
      healer      ONLINE       0     0     0
        mirror-0  ONLINE       0     0     0
         ada0     ONLINE       0     0     0
         ada1     ONLINE       0     0     1

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Der Fehler wurde erkannt und korrigiert durch die vorhandene Redundanz, welche aus der nicht betroffenen Platte <span class=filename>ada0</span> des Spiegels gewonnen wurde. Ein Vergleich der Prüfsumme mit dem Original wird zeigen, ob sich der Pool wieder in einem konsistenten Zustand befindet.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sha1 /healer &gt;&gt; checksum.txt</span>
<span class=c># cat checksum.txt</span>
SHA1 <span class=o>(</span>/healer<span class=o>)</span> <span class=o>=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f
SHA1 <span class=o>(</span>/healer<span class=o>)</span> <span class=o>=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f</code></pre></div></div><div class=paragraph><p>Die beiden Prüfsummen, die vor und nach der vorsätzlichen Korrumpierung der Daten des Pools angelegt wurden, stimmen immer noch überein. Dies zeigt wie ZFS in der Lage ist, Fehler automatisch zu erkennen und zu korrigieren, wenn die Prüfsummen nicht übereinstimmen. Beachten Sie, dass dies nur möglich ist, wenn genug Redundanz im Pool vorhanden ist. Ein Pool, der nur aus einer einzigen Platte besteht besitzt keine Selbstheilungsfunktion. Dies ist auch der Grund warum Prüfsummen bei ZFS so wichtig sind und deshalb aus keinem Grund deaktiviert werden sollten. Kein <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> ist nötig, um diese Fehler zu erkennen und zu korrigieren und der Pool war während der gesamten Zeit, in der das Problem bestand, verfügbar. Eine scrub-Aktion ist nun nötig, um die fehlerhaften Daten auf <span class=filename>ada1</span> zu beheben.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool scrub healer</span>
<span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
            attempt was made to correct the error.  Applications are unaffected.
action: Determine <span class=k>if </span>the device needs to be replaced, und clear the errors
            using <span class=s1>&#39;zpool clear&#39;</span> or replace the device with <span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub <span class=k>in </span>progress since Mon Dec 10 12:23:30 2012
        10.4M scanned out of 67.0M at 267K/s, 0h3m to go
        9.63M repaired, 15.56% <span class=k>done
</span>config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0   627  <span class=o>(</span>repairing<span class=o>)</span>

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Durch das scrub werden die Daten von <span class=filename>ada0</span> gelesen und alle Daten mit einer falschen durch diejenigen mit der richtigen Prüfsumme auf <span class=filename>ada1</span> ersetzt. Dies wird durch die Ausgabe <code>(repairing)</code> des Kommandos <code>zpool status</code> angezeigt. Nachdem die Operation abgeschlossen ist, ändert sich der Poolstatus zu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
        attempt was made to correct the error.  Applications are unaffected.
action: Determine <span class=k>if </span>the device needs to be replaced, und clear the errors
             using <span class=s1>&#39;zpool clear&#39;</span> or replace the device with <span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub repaired 66.5M <span class=k>in </span>0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0 2.72K

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Nach der scrub-Operation und der anschliessenden Synchronisation der Daten von <span class=filename>ada0</span> nach <span class=filename>ada1</span>, kann die Fehlermeldung vom Poolstatus durch die Eingabe von <code>zpool clear</code><a href=#zfs-zpool-clear>bereinigt</a> werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool clear healer</span>
<span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
  scan: scrub repaired 66.5M <span class=k>in </span>0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Der Pool ist jetzt wieder in einem voll funktionsfähigen Zustand versetzt worden und alle Fehler wurden beseitigt.</p></div></div><div class=sect3><h4 id=zfs-zpool-online>37.3.9. Einen Pool vergrössern<a class=anchor href=#zfs-zpool-online></a></h4><div class=paragraph><p>Die verwendbare Größe eines redundant ausgelegten Pools ist durch die Kapazität des kleinsten Geräts in jedem vdev begrenzt. Das kleinste Gerät kann durch ein größeres Gerät ersetzt werden. Nachdem eine <a href=#zfs-zpool-replace>replace</a> oder <a href=#zfs-term-resilver>resilver</a>-Operation abgeschlossen wurde, kann der Pool anwachsen, um die Kapazität des neuen Geräts zu nutzen. Nehmen wir als Beispiel einen Spiegel mit einer 1 TB und einer 2 TB Platte. Der verwendbare Plattenplatz beträgt 1 TB. Wenn die 1 TB Platte mit einer anderen 2 TB Platte ersetzt wird, kopiert der resilver-Prozess die existierenden Daten auf die neue Platte. Da beide Geräte nun 2 TB Kapazität besitzen, kann auch der verfügbare Plattenplatz auf die Größe von 2 TB anwachsen.</p></div><div class=paragraph><p>Die Erweiterung wird durch das Kommando <code>zpool online -e</code> auf jedem Gerät ausgelöst. Nachdem alle Geräte expandiert wurden, wird der Speicher im Pool zur Verfügung gestellt.</p></div></div><div class=sect3><h4 id=zfs-zpool-import>37.3.10. Importieren und Exportieren von Pools<a class=anchor href=#zfs-zpool-import></a></h4><div class=paragraph><p>Pools werden <em>exportiert</em> bevor diese an ein anderes System angeschlossen werden. Alle Datasets werden abgehängt und jedes Gerät wird als exportiert markiert, ist jedoch immer noch gesperrt, so dass es nicht von anderen Festplattensubsystemen verwendet werden kann. Dadurch können Pools auf anderen Maschinen <em>importiert</em> werden, die ZFS und sogar andere Hardwarearchitekturen (bis auf ein paar Ausnahmen, siehe <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a>) unterstützen. Besitzt ein Dataset offene Dateien, kann <code>zpool export -f</code> den Export des Pools erzwingen. Verwenden Sie dies mit Vorsicht. Die Datasets werden dadurch gewaltsam abgehängt, was bei Anwendungen, die noch offene Dateien auf diesem Dataset hatten, möglicherweise zu unerwartetem Verhalten führen kann.</p></div><div class=paragraph><p>Einen nichtverwendeten Pool exportieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool export mypool</span></code></pre></div></div><div class=paragraph><p>Beim Importieren eines Pool werden auch automatisch alle Datasets eingehängt. Dies ist möglicherweise nicht das bevorzugte Verhalten und wird durch <code>zpool import -N</code> verhindert. Durch <code>zpool import -o</code> temporäre Eigenschaften nur für diesen Import gesetzt. Mit dem Befehl <code>zpool import altroot=</code> ist es möglich, einen Pool mit einem anderen Basiseinhängepunkt anstatt der Wurzel des Dateisystems einzubinden. Wenn der Pool zuletzt auf einem anderen System verwendet und nicht korrekt exportiert wurde, muss unter Umständen ein Import erzwungen werden durch <code>zpool import -f</code>. Alle Pools, die momentan nicht durch ein anderes System verwendet werden, lassen sich mit <code>zpool import -a</code> importieren.</p></div><div class=paragraph><p>Alle zum Import verfügbaren Pools auflisten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool import</span>
   pool: mypool
     <span class=nb>id</span>: 9930174748043525076
  state: ONLINE
 action: The pool can be imported using its name or numeric identifier.
 config:

        mypool      ONLINE
          ada2p3    ONLINE</code></pre></div></div><div class=paragraph><p>Den Pool mit einem anderen Wurzelverzeichnis importieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool import -o altroot=/mnt mypool</span>
<span class=c># zfs list</span>
zfs list
NAME                 USED  AVAIL  REFER  MOUNTPOINT
mypool               110K  47.0G    31K  /mnt/mypool</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-upgrade>37.3.11. Einen Pool aktualisieren<a class=anchor href=#zfs-zpool-upgrade></a></h4><div class=paragraph><p>Nachdem FreeBSD aktualisiert wurde oder wenn der Pool von einem anderen System, das eine ältere Version von ZFS einsetzt, lässt sich der Pool manuell auf den aktuellen Stand von ZFS bringen, um die neuesten Eigenschaften zu unterstützen. Bedenken Sie, ob der Pool jemals wieder von einem älteren System eingebunden werden muss, bevor Sie die Aktualisierung durchführen. Das aktualisieren eines Pools ist ein nicht umkehrbarer Prozess. ältere Pools lassen sich aktualisieren, jedoch lassen sich Pools mit neueren Eigenschaften nicht wieder auf eine ältere Version bringen.</p></div><div class=paragraph><p>Aktualisierung eines v28-Pools, um <code>Feature Flags</code> zu unterstützen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: The pool is formatted using a legacy on-disk format.  The pool can
        still be used, but some features are unavailable.
action: Upgrade the pool using <span class=s1>&#39;zpool upgrade&#39;</span><span class=nb>.</span>  Once this is <span class=k>done</span>, the
        pool will no longer be accessible on software that does not support feat
        flags.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool upgrade</span>
This system supports ZFS pool feature flags.

The following pools are formatted with legacy version numbers und can
be upgraded to use feature flags.  After being upgraded, these pools
will no longer be accessible by software that does not support feature
flags.

VER  POOL
<span class=nt>---</span>  <span class=nt>------------</span>
28   mypool

Use <span class=s1>&#39;zpool upgrade -v&#39;</span> <span class=k>for </span>a list of available legacy versions.
Every feature flags pool has all supported features enabled.
<span class=c># zpool upgrade mypool</span>
This system supports ZFS pool feature flags.

Successfully upgraded <span class=s1>&#39;mypool&#39;</span> from version 28 to feature flags.
Enabled the following features on <span class=s1>&#39;mypool&#39;</span>:
  async_destroy
  empty_bpobj
  lz4_compress
  multi_vdev_crash_dump</code></pre></div></div><div class=paragraph><p>Die neueren Eigenschaften von ZFS werden nicht verfügbar sein, bis <code>zpool upgrade</code> abgeschlossen ist. <code>zpool upgrade -v</code> kann verwendet werden, um zu sehen, welche neuen Eigenschaften durch die Aktualisierung bereitgestellt werden, genauso wie diejenigen, die momentan schon verfügbar sind.</p></div><div class=paragraph><p>Einen Pool um zusätzliche Feature Flags erweitern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: Some supported features are not enabled on the pool. The pool can
        still be used, but some features are unavailable.
action: Enable all features using <span class=s1>&#39;zpool upgrade&#39;</span><span class=nb>.</span> Once this is <span class=k>done</span>,
        the pool may no longer be accessible by software that does not support
        the features. See zpool-features<span class=o>(</span>7<span class=o>)</span> <span class=k>for </span>details.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool upgrade</span>
This system supports ZFS pool feature flags.

All pools are formatted using feature flags.

Some supported features are not enabled on the following pools. Once a
feature is enabled the pool may become incompatible with software
that does not support the feature. See zpool-features<span class=o>(</span>7<span class=o>)</span> <span class=k>for </span>details.

POOL  FEATURE
<span class=nt>---------------</span>
zstore
      multi_vdev_crash_dump
      spacemap_histogram
      enabled_txg
      hole_birth
      extensible_dataset
      bookmarks
      filesystem_limits
<span class=c># zpool upgrade mypool</span>
This system supports ZFS pool feature flags.

Enabled the following features on <span class=s1>&#39;mypool&#39;</span>:
  spacemap_histogram
  enabled_txg
  hole_birth
  extensible_dataset
  bookmarks
  filesystem_limits</code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Der Bootcode muss auf Systemen, die von dem Pool starten, aktualisiert werden, um diese neue Version zu unterstützen. Verwenden Sie <code>gpart bootcode</code> auf der Partition, die den Bootcode enthält. Es gibt zwei Arten von Bootcode, je nachdem, wie das System bootet: GPT (die häufigste Option) und EFI (für moderne Systeme).</p></div><div class=paragraph><p>Benutzen Sie für GPT den folgenden Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1</span></code></pre></div></div><div class=paragraph><p>Für Systeme, die EFI zum Booten benutzen, führen Sie folgenden Befehl aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -p /boot/boot1.efifat -i 1 ada1</span></code></pre></div></div><div class=paragraph><p>Installieren Sie den Bootcode auf allen bootfähigen Platten im Pool. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> für weitere Informationen.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=zfs-zpool-history>37.3.12. Aufgezeichnete Historie des Pools anzeigen<a class=anchor href=#zfs-zpool-history></a></h4><div class=paragraph><p>Befehle, die den Pool in irgendeiner Form verändern, werden aufgezeichnet. Diese Befehle beinhalten das Erstellen von Datasets, verändern von Eigenschaften oder das Ersetzen einer Platte. Diese Historie ist nützlich um nachzuvollziehen, wie ein Pool aufgebaut ist und welcher Benutzer eine bestimmte Aktion wann und wie getätigt hat. Die aufgezeichnete Historie wird nicht in einer Logdatei festgehalten, sondern ist Teil des Pools selbst. Das Kommando zum darstellen dieser Historie lautet passenderweise <code>zpool history</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool history</span>
History <span class=k>for</span> <span class=s1>&#39;tank&#39;</span>:
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1
2013-02-27.18:50:58 zfs <span class=nb>set </span><span class=nv>atime</span><span class=o>=</span>off tank
2013-02-27.18:51:09 zfs <span class=nb>set </span><span class=nv>checksum</span><span class=o>=</span>fletcher4 tank
2013-02-27.18:51:18 zfs create tank/backup</code></pre></div></div><div class=paragraph><p>Die Ausgabe zeigt <code>zpool</code> und <code>zfs</code>-Befehle, die ausgeführt wurden zusammen mit einem Zeitstempel. Nur Befehle, die den Pool verändern werden aufgezeichnet. Befehle wie <code>zfs list</code> sind dabei nicht enthalten. Wenn kein Name angegeben wird, erscheint die gesamte Historie aller Pools.</p></div><div class=paragraph><p>Der Befehl <code>zpool history</code> kann sogar noch mehr Informationen ausgeben, wenn die Optionen <code>-i</code> oder <code>-l</code> angegeben werden. Durch <code>-i</code> zeigt ZFS vom Benutzer eingegebene, als auch interne Ereignisse an.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool history -i</span>
History <span class=k>for</span> <span class=s1>&#39;tank&#39;</span>:
2013-02-26.23:02:35 <span class=o>[</span>internal pool create txg:5] pool spa 28<span class=p>;</span> zfs spa 28<span class=p>;</span> zpl 5<span class=p>;</span>uts  9.1-RELEASE 901000 amd64
2013-02-27.18:50:53 <span class=o>[</span>internal property <span class=nb>set </span>txg:50] <span class=nv>atime</span><span class=o>=</span>0 dataset <span class=o>=</span> 21
2013-02-27.18:50:58 zfs <span class=nb>set </span><span class=nv>atime</span><span class=o>=</span>off tank
2013-02-27.18:51:04 <span class=o>[</span>internal property <span class=nb>set </span>txg:53] <span class=nv>checksum</span><span class=o>=</span>7 dataset <span class=o>=</span> 21
2013-02-27.18:51:09 zfs <span class=nb>set </span><span class=nv>checksum</span><span class=o>=</span>fletcher4 tank
2013-02-27.18:51:13 <span class=o>[</span>internal create txg:55] dataset <span class=o>=</span> 39
2013-02-27.18:51:18 zfs create tank/backup</code></pre></div></div><div class=paragraph><p>Weitere Details lassen sich durch die Angabe von <code>-l</code> entlocken. Historische Einträge werden in einem langen Format ausgegeben, einschließlich Informationen wie der Name des Benutzers, welcher das Kommando eingegeben hat und der Hostname, auf dem die Änderung erfolgte.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool history -l</span>
History <span class=k>for</span> <span class=s1>&#39;tank&#39;</span>:
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1 <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on :global]
2013-02-27.18:50:58 zfs <span class=nb>set </span><span class=nv>atime</span><span class=o>=</span>off tank <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on myzfsbox:global]
2013-02-27.18:51:09 zfs <span class=nb>set </span><span class=nv>checksum</span><span class=o>=</span>fletcher4 tank <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on myzfsbox:global]
2013-02-27.18:51:18 zfs create tank/backup <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on myzfsbox:global]</code></pre></div></div><div class=paragraph><p>Die Ausgabe zeigt, dass der Benutzer <code>root</code> den gespiegelten Pool mit den beiden Platten <span class=filename>/dev/ada0</span> und <span class=filename>/dev/ada1</span> angelegt hat. Der Hostname <code>myzfsbox</code> wird ebenfalls in den Kommandos angezeigt, nachdem der Pool erzeugt wurde. Die Anzeige des Hostnamens wird wichtig, sobald der Pool von einem System exportiert und auf einem anderen importiert wird. Die Befehle, welche auf dem anderen System verwendet werden, können klar durch den Hostnamen, der bei jedem Kommando mit verzeichnet wird, unterschieden werden.</p></div><div class=paragraph><p>Beide Optionen für <code>zpool history</code> lassen sich auch kombinieren, um die meisten Details zur Historie eines Pools auszugeben. Die Pool Historie liefert wertvolle Informationen, wenn Aktionen nachverfolgt werden müssen oder zur Fehlerbeseitigung mehr Informationen gebraucht werden.</p></div></div><div class=sect3><h4 id=zfs-zpool-iostat>37.3.13. Geschwindigkeitsüberwachung<a class=anchor href=#zfs-zpool-iostat></a></h4><div class=paragraph><p>Ein eingebautes Überwachungssystem kann I/O-Statistiken in Echtzeit liefern. Es zeigt die Menge von freiem und belegtem Speicherplatz auf dem Pool an, wieviele Lese- und Schreiboperationen pro Sekunde durchgeführt werden und die aktuell verwendete I/O-Bandbreite. Standardmäßig werden alle Pools in einem System überwacht und angezeigt. Ein Poolname kann angegeben werden, um die Anzeige auf diesen Pool zu beschränken. Ein einfaches Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool iostat</span>
               capacity     operations    bundwidth
pool        alloc   free   <span class=nb>read  </span>write   <span class=nb>read  </span>write
<span class=nt>----------</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>
data         288G  1.53T      2     11  11.3K  57.1K</code></pre></div></div><div class=paragraph><p>Um kontinuierlich die I/O-Aktivität zu überprüfen, kann eine Zahl als letzter Parameter angegeben werden, die ein Intervall in Sekunden angibt, die zwischen den Aktualisierungen vergehen soll. Die nächste Zeile mit Statistikinformationen wird dann nach jedem Intervall ausgegeben. Drücken Sie <span class=keyseq><kbd>Ctrl</kbd>+<kbd>C</kbd></span>, um diese kontinuierliche Überwachung zu stoppen. Alternativ lässt sich auch eine zweite Zahl nach dem Intervall auf der Kommandozeile angeben, welche die Obergrenze von Statistikausgaben darstellt, die angezeigt werden sollen.</p></div><div class=paragraph><p>Noch mehr Informationen zu I/O-Statistiken können durch Angabe der Option <code>-v</code> angezeigt werden. Jedes Gerät im Pool wird dann mit einer eigenen Statistikzeile aufgeführt. Dies ist hilfreich um zu sehen, wieviele Lese- und Schreiboperationen von jedem Gerät durchgeführt werden und kann bei der Diagnose eines langsamen Geräts, das den Pool ausbremst, hilfreich sein. Dieses Beispiel zeigt einen gespiegelten Pool mit zwei Geräten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool iostat -v</span>
                            capacity     operations    bundwidth
pool                     alloc   free   <span class=nb>read  </span>write   <span class=nb>read  </span>write
<span class=nt>-----------------------</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>
data                      288G  1.53T      2     12  9.23K  61.5K
  mirror                  288G  1.53T      2     12  9.23K  61.5K
    ada1                     -      -      0      4  5.61K  61.7K
    ada2                     -      -      1      4  5.04K  61.7K
<span class=nt>-----------------------</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-split>37.3.14. Einen Pool aufteilen<a class=anchor href=#zfs-zpool-split></a></h4><div class=paragraph><p>Ein Pool, der aus einem oder mehreren gespiegelten vdevs besteht, kann in zwei Pools aufgespalten werden. Falls nicht anders angegeben, wird das letzte Mitglied eines Spiegels abgehängt und dazu verwendet, einen neuen Pool mit den gleichen Daten zu erstellen. Die Operation sollte zuerst mit der Option <code>-n</code> versucht werden. Die Details der vorgeschlagenen Option werden dargestellt, ohne die Aktion in Wirklichkeit durchzuführen. Das hilft dabei zu bestätigen, ob die Aktion das tut, was der Benutzer damit vor hatte.</p></div></div></div><div class=sect2><h3 id=zfs-zfs>37.4. <code>zfs</code> Administration<a class=anchor href=#zfs-zfs></a></h3><div class=paragraph><p>Das <code>zfs</code>-Werkzeug ist dafür verantwortlich, alle ZFS Datasets innerhalb eines Pools zu erstellen, zerstören und zu verwalten. Der Pool selbst wird durch <a href=#zfs-zpool><code>zpool</code></a> verwaltet.</p></div><div class=sect3><h4 id=zfs-zfs-create>37.4.1. Datasets erstellen und zerstören<a class=anchor href=#zfs-zfs-create></a></h4><div class=paragraph><p>Anders als in traditionellen Festplatten- und Volumenmanagern wird der Plattenplatz in ZFS <em>nicht</em> vorher allokiert. Bei traditionellen Dateisystemen gibt es, nachdem der Plattenplatz partitioniert und zugeteilt wurde, keine Möglichkeit, ein zusätzliches Dateisystem hinzuzufügen, ohne eine neue Platte anzuschließen. Mit ZFS lassen sich neue Dateisysteme zu jeder Zeit anlegen. Jedes <a href=#zfs-term-dataset><em>Dataset</em></a> besitzt Eigenschaften wie Komprimierung, Deduplizierung, Zwischenspeicher (caching), Quotas, genauso wie andere nützliche Einstellungen wie Schreibschutz, Unterscheidung zwischen Groß- und Kleinschreibung, Netzwerkfreigaben und einen Einhängepunkt. Datasets können ineinander verschachtelt werden und Kind-Datasets erben die Eigenschaften ihrer Eltern. Jedes Dataset kann als eine Einheit verwaltet, <a href=#zfs-zfs-allow>delegiert</a>, <a href=#zfs-zfs-send>repliziert</a>, <a href=#zfs-zfs-snapshot>mit Schnappschüssen versehen</a>, <a href=#zfs-zfs-jail>in Jails gesteckt</a> und zerstört werden. Es gibt viele Vorteile, ein separates Dataset für jede Art von Dateien anzulegen. Der einzige Nachteil einer großen Menge an Datasets ist, dass manche Befehle wie <code>zfs list</code> langsamer sind und dass das Einhängen von hunderten oder hunderttausenden von Datasets den FreeBSD-Bootvorgang verzögert.</p></div><div class=paragraph><p>Erstellen eines neuen Datasets und aktivieren von <a href=#zfs-term-compression-lz4>LZ4 Komprimierung</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.20M  93.2G   608K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp
<span class=c># zfs create -o compress=lz4 mypool/usr/mydataset</span>
<span class=c># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 781M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.20M  93.2G   610K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp</code></pre></div></div><div class=paragraph><p>Ein Dataset zu zerstören ist viel schneller, als alle Dateien zu löschen, die sich in dem Dataset befindet, da es keinen Scan aller Dateien und aktualisieren der dazugehörigen Metadaten erfordert.</p></div><div class=paragraph><p>Zerstören des zuvor angelegten Datasets:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 880M  93.1G   144K  none
mypool/ROOT            777M  93.1G   144K  none
mypool/ROOT/default    777M  93.1G   777M  /
mypool/tmp             176K  93.1G   176K  /tmp
mypool/usr             101M  93.1G   144K  /usr
mypool/usr/home        184K  93.1G   184K  /usr/home
mypool/usr/mydataset   100M  93.1G   100M  /usr/mydataset
mypool/usr/ports       144K  93.1G   144K  /usr/ports
mypool/usr/src         144K  93.1G   144K  /usr/src
mypool/var            1.20M  93.1G   610K  /var
mypool/var/crash       148K  93.1G   148K  /var/crash
mypool/var/log         178K  93.1G   178K  /var/log
mypool/var/mail        144K  93.1G   144K  /var/mail
mypool/var/tmp         152K  93.1G   152K  /var/tmp
<span class=c># zfs destroy mypool/usr/mydataset</span>
<span class=c># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.21M  93.2G   612K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp</code></pre></div></div><div class=paragraph><p>In modernen Versionen von ZFS ist <code>zfs destroy</code> asynchron und der freie Speicherplatz kann erst nach ein paar Minuten im Pool auftauchen. Verwenden Sie <code>zpool get freeing <em>poolname</em></code>, um die Eigenschaft <code>freeing</code> aufzulisten, die angibt, bei wievielen Datasets die Blöcke im Hintergrund freigegeben werden. Sollte es Kind-Datasets geben, <a href=#zfs-term-snapshot>Schnappschüsse</a> oder andere Datasets, dann lässt sich der Elternknoten nicht zerstören. Um ein Dataset und all seine Kinder zu zerstören, verwenden Sie die Option <code>-r</code>, um das Dataset und all seine Kinder rekursiv zu entfernen. Benutzen Sie die Option <code>-n</code> und <code>-v</code>, um Datasets und Snapshots anzuzeigen, die durch diese Aktion zerstört werden würden, dies jedoch nur zu simulieren und nicht wirklich durchzuführen. Speicherplatz, der dadurch freigegeben würde, wird ebenfalls angezeigt.</p></div></div><div class=sect3><h4 id=zfs-zfs-volume>37.4.2. Volumes erstellen und zerstören<a class=anchor href=#zfs-zfs-volume></a></h4><div class=paragraph><p>Ein Volume ist ein spezieller Typ von Dataset. Anstatt dass es als Dateisystem eingehängt wird, stellt es ein Block-Gerät unter <span class=filename>/dev/zvol/poolname/dataset</span> dar. Dies erlaubt es, das Volume für andere Dateisysteme zu verwenden, die Festplatten einer virtuellen Maschine bereitzustellen oder über Protokolle wie iSCSI oder HAST exportiert zu werden.</p></div><div class=paragraph><p>Ein Volume kann mit einem beliebigen Dateisystem formatiert werden oder auch ohne ein Dateisystem als reiner Datenspeicher fungieren. Für den Benutzer erscheint ein Volume als eine gewöhnliche Platte. Indem gewöhnliche Dateisysteme auf diesen <em>zvols</em> angelegt werden, ist es möglich, diese mit Eigenschaften auszustatten, welche diese normalerweise nicht besitzen. Beispielsweise wird durch Verwendung der Komprimierungseigenschaft auf einem 250 MB Volume das Erstellen eines komprimierten FAT Dateisystems möglich.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V 250m -o compression=on tank/fat32</span>
<span class=c># zfs list tank</span>
NAME USED AVAIL REFER MOUNTPOINT
tank 258M  670M   31K /tank
<span class=c># newfs_msdos -F32 /dev/zvol/tank/fat32</span>
<span class=c># mount -t msdosfs /dev/zvol/tank/fat32 /mnt</span>
<span class=c># df -h /mnt | grep fat32</span>
Filesystem           Size Used Avail Capacity Mounted on
/dev/zvol/tank/fat32 249M  24k  249M     0%   /mnt
<span class=c># mount | grep fat32</span>
/dev/zvol/tank/fat32 on /mnt <span class=o>(</span>msdosfs, <span class=nb>local</span><span class=o>)</span></code></pre></div></div><div class=paragraph><p>Ein Volume zu zerstören ist sehr ähnlich wie ein herkömmliches Dataset zu entfernen. Die Operation wird beinahe sofort durchgeführt, jedoch kann es mehrere Minuten dauern, bis der freie Speicherplatz im Hintergrund wieder freigegeben ist.</p></div></div><div class=sect3><h4 id=zfs-zfs-rename>37.4.3. Umbenennen eines Datasets<a class=anchor href=#zfs-zfs-rename></a></h4><div class=paragraph><p>Der Name eines Datasets lässt sich durch <code>zfs rename</code> ändern. Das Eltern-Dataset kann ebenfalls mit diesem Kommando umbenannt werden. Ein Dataset unter einem anderen Elternteil umzubenennen wird den Wert dieser Eigenschaft verändern, die vom Elternteil vererbt wurden. Wird ein Dataset umbenannt, wird es abgehängt und dann erneut unter der neuen Stelle eingehängt (welche vom neuen Elternteil geerbt wird). Dieses Verhalten kann durch die Option <code>-u</code> verhindert werden.</p></div><div class=paragraph><p>Ein Dataset umbenennen und unter einem anderen Elterndataset verschieben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 780M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.21M  93.2G   614K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp
<span class=c># zfs rename mypool/usr/mydataset mypool/var/newname</span>
<span class=c># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                780M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.29M  93.2G   614K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/newname   87.5K  93.2G  87.5K  /var/newname
mypool/var/tmp        152K  93.2G   152K  /var/tmp</code></pre></div></div><div class=paragraph><p>Schnappschüsse können auf diese Weise ebenfalls umbenannt werden. Aufgrund der Art von Schnappschüssen können diese nicht unter einem anderen Elterndataset eingehängt werden. Um einen rekursiven Schnappschuss umzubenennen, geben Sie die Option <code>-r</code> an, um alle Schnappschüsse mit dem gleichen Namen im Kind-Dataset ebenfalls umzubenennen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -t snapshot</span>
NAME                                USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@first_snapshot      0      -  87.5K  -
<span class=c># zfs rename mypool/var/newname@first_snapshot new_snapshot_name</span>
<span class=c># zfs list -t snapshot</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@new_snapshot_name      0      -  87.5K  -</code></pre></div></div></div><div class=sect3><h4 id=zfs-zfs-set>37.4.4. Festlegen von Dataset-Eigenschaften<a class=anchor href=#zfs-zfs-set></a></h4><div class=paragraph><p>Jedes ZFS-Dataset besitzt eine Menge von Eigenschaften, die sein Verhalten beeinflussen. Die meisten Eigenschaften werden automatisch vom Eltern-Dataset vererbt, können jedoch lokal überschrieben werden. Sie legen eine Eigenschaft durch <code>zfs set <em>property=value dataset</em></code> fest. Die meisten Eigenschaften haben eine begrenzte Menge von gültigen Werten. <code>zfs get</code> stellt diese dar und zeigt jede mögliche Eigenschaft und gültige Werte an. Die meisten Eigenschaften können über <code>zfs inherit</code> wieder auf ihren Ausgangswert zurückgesetzt werden.</p></div><div class=paragraph><p>Benutzerdefinierte Eigenschaften lassen sich ebenfalls setzen. Diese werden Teil der Konfiguration des Datasets und können dazu verwendet werden, zusätzliche Informationen über das Dataset oder seine Bestandteile zu speichern. Um diese benutzerdefinierten Eigenschaften von den ZFS-eigenen zu unterscheiden, wird ein Doppelpunkt (<code>:</code>) verwendet, um einen eigenen Namensraum für diese Eigenschaft zu erstellen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set custom:costcenter=1234 tank</span>
<span class=c># zfs get custom:costcenter tank</span>
NAME PROPERTY           VALUE SOURCE
tank custom:costcenter  1234  <span class=nb>local</span></code></pre></div></div><div class=paragraph><p>Um eine selbstdefinierte Eigenschaft umzubenennen, verwenden Sie <code>zfs inherit</code> mit der Option <code>-r</code>. Wenn die benutzerdefinierte Eigenschaft nicht in einem der Eltern-Datasets definiert ist, wird diese komplett entfernt (obwohl diese Änderungen natürlich in der Historie des Pools noch aufgezeichnet sind).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs inherit -r custom:costcenter tank</span>
<span class=c># zfs get custom:costcenter tank</span>
NAME    PROPERTY           VALUE              SOURCE
tank    custom:costcenter  -                  -
<span class=c># zfs get all tank | grep custom:costcenter</span>
<span class=c>#</span></code></pre></div></div><div class=sect4><h5 id=zfs-zfs-set-share>37.4.4.1. Festlegen und Abfragen von Eigenschaften für Freigaben<a class=anchor href=#zfs-zfs-set-share></a></h5><div class=paragraph><p>Zwei häufig verwendete und nützliche Dataset-Eigenschaften sind die Freigabeoptionen von NFS und SMB. Diese Optionen legen fest, ob und wie ZFS-Datasets im Netzwerk freigegeben werden. Derzeit unterstützt FreeBSD nur Freigaben von Datasets über NFS. Um den Status einer Freigabe zu erhalten, geben Sie folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get sharenfs mypool/usr/home</span>
NAME              PROPERTY   VALUE   SOURCE
mypool/usr/home   sharenfs   on      <span class=nb>local</span>
<span class=c># zfs get sharesmb mypool/usr/home</span>
NAME              PROPERTY   VALUE   SOURCE
mypool/usr/home   sharesmb   off     <span class=nb>local</span></code></pre></div></div><div class=paragraph><p>Um ein Dataset freizugeben, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set sharenfs=on mypool/usr/home</span></code></pre></div></div><div class=paragraph><p>Es ist auch möglich, weitere Optionen für die Verwendung von Datasets über NFS zu definieren, wie etwa <code>-alldirs</code>, <code>-maproot</code> und <code>-network</code>. Um zusätzliche Optionen auf ein durch NFS freigegebenes Dataset festzulegen, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set sharenfs=&#34;-alldirs,maproot=root,-network=192.168.1.0/24&#34; mypool/usr/home</span></code></pre></div></div></div></div><div class=sect3><h4 id=zfs-zfs-snapshot>37.4.5. Verwalten von Schnappschüssen<a class=anchor href=#zfs-zfs-snapshot></a></h4><div class=paragraph><p><a href=#zfs-term-snapshot>Schnappschüsse</a> sind eine der mächtigen Eigenschaften von ZFS. Ein Schnappschuss bietet einen nur-Lese Zustand eines Datasets zu einem bestimmten Zeitpunkt. Mit Kopieren-beim-Schreiben (Copy-On-Write COW), können Schnappschüsse schnell erstellt werden durch das Aufheben der älteren Version der Daten auf der Platte. Falls kein Snapshot existiert, wird der Speicherplatz wieder für zukünftige Verwendung freigegeben wenn Daten geschrieben oder gelöscht werden. Schnappschüsse sparen Speicherplatz, indem diese nur die Unterschiede zwischen dem momentanen Dataset und der vorherigen Version aufzeichnen. Schnappschüsse sind nur auf ganzen Datasets erlaubt, nicht auf individuellen Dateien oder Verzeichnissen. Wenn ein Schnappschuss eines Datasets erstellt wird, wird alles was darin enthalten ist, dupliziert. Das beinhaltet Dateisystemeigenschaften, Dateien, Verzeichnisse, Rechte und so weiter. Schnappschüsse benötigen keinen zusätzlichen Speicherplatz wenn diese erstmals angelegt werden, nur wenn Blöcke, die diese referenzieren, geändert werden. Rekursive Schnappschüsse, die mit der Option <code>-r</code> erstellt, erzeugen einen mit dem gleichen Namen des Datasets und all seinen Kindern, was eine konsistente Momentaufnahme aller Dateisysteme darstellt. Dies kann wichtig sein, wenn eine Anwendung Dateien auf mehreren Datasets ablegt, die miteinander in Verbindung stehen oder voneinander abhängig sind. Ohne Schnappschüsse würde ein Backup Kopien dieser Dateien zu unterschiedlichen Zeitpunkten enthalten.</p></div><div class=paragraph><p>Schnappschüsse in ZFS bieten eine Vielzahl von Eigenschaften, die selbst in anderen Dateisystemen mit Schnappschussfunktion nicht vorhanden sind. Ein typisches Beispiel zur Verwendung von Schnappschüssen ist, den momentanen Stand des Dateisystems zu sichern, wenn eine riskante Aktion wie das Installieren von Software oder eine Systemaktualisierung durchgeführt wird. Wenn diese Aktion fehlschlägt, so kann der Schnappschuss zurückgerollt werden und das System befindet sich wieder in dem gleichen Zustand, wie zu dem, als der Schnappschuss erstellt wurde. Wenn die Aktualisierung jedoch erfolgreich war, kann der Schnappschuss gelöscht werden, um Speicherplatz frei zu geben. Ohne Schnappschüsse, wird durch ein fehlgeschlagenes Update eine Wiederherstellung der Sicherung fällig, was oft mühsam und zeitaufwändig ist, außerdem ist währenddessen das System nicht verwendbar. Schnappschüsse lassen sich schnell und mit wenig bis gar keiner Ausfallzeit zurückrollen, selbst wenn das System im normalen Betrieb läuft. Die Zeitersparnis ist enorm, wenn mehrere Terabyte große Speichersysteme eingesetzt werden und viel Zeit für das Kopieren der Daten vom Sicherungssystem benötigt wird. Schnappschüsse sind jedoch keine Ersatz für eine Vollsicherung des Pools, können jedoch als eine schnelle und einfache Sicherungsmethode verwendet werden, um eine Kopie eines Datasets zu einem bestimmten Zeitpunkt zu sichern.</p></div><div class=sect4><h5 id=zfs-zfs-snapshot-creation>37.4.5.1. Schnappschüsse erstellen<a class=anchor href=#zfs-zfs-snapshot-creation></a></h5><div class=paragraph><p>Schnappschüsse werden durch das Kommando <code>zfs snapshot <em>dataset</em>@<em>snapshotname</em></code> angelegt. Durch Angabe der Option <code>-r</code> werden Schnappschüsse rekursive angelegt, mit dem gleichen Namen auf allen Datasets.</p></div><div class=paragraph><p>Einen rekursiven Schnappschuss des gesamten Pools erzeugen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -t all</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool                                 780M  93.2G   144K  none
mypool/ROOT                            777M  93.2G   144K  none
mypool/ROOT/default                    777M  93.2G   777M  /
mypool/tmp                             176K  93.2G   176K  /tmp
mypool/usr                             616K  93.2G   144K  /usr
mypool/usr/home                        184K  93.2G   184K  /usr/home
mypool/usr/ports                       144K  93.2G   144K  /usr/ports
mypool/usr/src                         144K  93.2G   144K  /usr/src
mypool/var                            1.29M  93.2G   616K  /var
mypool/var/crash                       148K  93.2G   148K  /var/crash
mypool/var/log                         178K  93.2G   178K  /var/log
mypool/var/mail                        144K  93.2G   144K  /var/mail
mypool/var/newname                    87.5K  93.2G  87.5K  /var/newname
mypool/var/newname@new_snapshot_name      0      -  87.5K  -
mypool/var/tmp                         152K  93.2G   152K  /var/tmp
<span class=c># zfs snapshot -r mypool@my_recursive_snapshot</span>
<span class=c># zfs list -t snapshot</span>
NAME                                        USED  AVAIL  REFER  MOUNTPOINT
mypool@my_recursive_snapshot                   0      -   144K  -
mypool/ROOT@my_recursive_snapshot              0      -   144K  -
mypool/ROOT/default@my_recursive_snapshot      0      -   777M  -
mypool/tmp@my_recursive_snapshot               0      -   176K  -
mypool/usr@my_recursive_snapshot               0      -   144K  -
mypool/usr/home@my_recursive_snapshot          0      -   184K  -
mypool/usr/ports@my_recursive_snapshot         0      -   144K  -
mypool/usr/src@my_recursive_snapshot           0      -   144K  -
mypool/var@my_recursive_snapshot               0      -   616K  -
mypool/var/crash@my_recursive_snapshot         0      -   148K  -
mypool/var/log@my_recursive_snapshot           0      -   178K  -
mypool/var/mail@my_recursive_snapshot          0      -   144K  -
mypool/var/newname@new_snapshot_name           0      -  87.5K  -
mypool/var/newname@my_recursive_snapshot       0      -  87.5K  -
mypool/var/tmp@my_recursive_snapshot           0      -   152K  -</code></pre></div></div><div class=paragraph><p>Schnappschüsse werden nicht durch einen <code>zfs list</code>-Befehl angezeigt. Um Schnappschüsse mit aufzulisten, muss <code>-t snapshot</code> an das Kommando <code>zfs list</code> angehängt werden. Durch <code>-t all</code> werden sowohl Dateisysteme als auch Schnappschüsse nebeneinander angezeigt.</p></div><div class=paragraph><p>Schnappschüsse werden nicht direkt eingehängt, deshalb wird auch kein Pfad in der Spalte <code>MOUNTPOINT</code> angezeigt. Ebenso wird kein freier Speicherplatz in der Spalte <code>AVAIL</code> aufgelistet, da Schnappschüsse nicht mehr geschrieben werden können, nachdem diese angelegt wurden. Vergleichen Sie den Schnappschuss mit dem ursprünglichen Dataset von dem es abstammt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all mypool/usr/home</span>
NAME                                    USED  AVAIL  REFER  MOUNTPOINT
mypool/usr/home                         184K  93.2G   184K  /usr/home
mypool/usr/home@my_recursive_snapshot      0      -   184K  -</code></pre></div></div><div class=paragraph><p>Durch das Darstellen des Datasets und des Schnappschusses nebeneinander zeigt deutlich, wie Schnappschüsse in <a href=#zfs-term-cow>COW</a> Manier funktionieren. Sie zeichnen nur die Änderungen (<em>delta</em>) auf, die währenddessen entstanden sind und nicht noch einmal den gesamten Inhalt des Dateisystems. Das bedeutet, dass Schnappschüsse nur wenig Speicherplatz benötigen, wenn nur kleine Änderungen vorgenommen werden. Der Speicherverbrauch kann sogar noch deutlicher gemacht werden, wenn eine Datei auf das Dataset kopiert wird und anschließend ein zweiter Schnappschuss angelegt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/passwd /var/tmp</span>
<span class=c># zfs snapshot mypool/var/tmp@after_cp</span>
<span class=c># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -</code></pre></div></div><div class=paragraph><p>Der zweite Schnappschuss enthält nur die Änderungen am Dataset, die nach der Kopieraktion gemacht wurden. Dies bedeutet enorme Einsparungen von Speicherplatz. Beachten Sie, dass sich die Größe des Schnappschusses <code><em>mypool/var/tmp@my_recursive_snapshot</em></code> in der Spalte <code>USED</code> ebenfalls geändert hat, um die Änderungen von sich selbst und dem Schnappschuss, der im Anschluss angelegt wurde, anzuzeigen.</p></div></div><div class=sect4><h5 id=zfs-zfs-snapshot-diff>37.4.5.2. Schnappschüsse vergleichen<a class=anchor href=#zfs-zfs-snapshot-diff></a></h5><div class=paragraph><p>ZFS enthält ein eingebautes Kommando, um die Unterschiede zwischen zwei Schnappschüssen miteinander zu vergleichen. Das ist hilfreich, wenn viele Schnappschüsse über längere Zeit angelegt wurden und der Benutzer sehen will, wie sich das Dateisystem über diesen Zeitraum verändert hat. Beispielsweise kann <code>zfs diff</code> den letzten Schnappschuss finden, der noch eine Datei enthält, die aus Versehen gelöscht wurde. Wenn dies für die letzten beiden Schnappschüsse aus dem vorherigen Abschnitt durchgeführt wird, ergibt sich folgende Ausgabe:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -
<span class=c># zfs diff mypool/var/tmp@my_recursive_snapshot</span>
M       /var/tmp/
+       /var/tmp/passwd</code></pre></div></div><div class=paragraph><p>Das Kommando zeigt alle Änderungen zwischen dem angegebenen Schnappschuss (in diesem Fall <code><em>mypool/var/tmp@my_recursive_snapshot</em></code>) und dem momentan aktuellen Dateisystem. Die erste Spalte zeigt die Art der Änderung an:</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:20%><col style=width:80%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das Verzeichnis oder die Datei wurde hinzugefügt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das Verzeichnis oder die Datei wurde gelöscht.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>M</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das Verzeichnis oder die Datei wurde geändert.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>R</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das Verzeichnis oder die Datei wurde umbenannt.</p></td></tr></tbody></table><div class=paragraph><p>Vergleicht man die Ausgabe mit der Tabelle, wird klar, dass <span class=filename>passwd</span> hinzugefügt wurde, nachdem der Schnappschuss <code><em>mypool/var/tmp@my_recursive_snapshot</em></code> erstellt wurde. Das resultierte ebenfalls in einer Änderung am darüberliegenden Verzeichnis, das unter <code><em>/var/tmp</em></code> eingehängt ist.</p></div><div class=paragraph><p>Zwei Schnappschüsse zu vergleichen ist hilfreich, wenn die Replikationseigenschaft von ZFS verwendet wird, um ein Dataset auf einen anderen Host zu Sicherungszwecken übertragen.</p></div><div class=paragraph><p>Zwei Schnappschüsse durch die Angabe des kompletten Namens des Datasets und dem Namen des Schnappschusses beider Datasets vergleichen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /var/tmp/passwd /var/tmp/passwd.copy</span>
<span class=c># zfs snapshot mypool/var/tmp@diff_snapshot</span>
<span class=c># zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@diff_snapshot</span>
M       /var/tmp/
+       /var/tmp/passwd
+       /var/tmp/passwd.copy
<span class=c># zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@after_cp</span>
M       /var/tmp/
+       /var/tmp/passwd</code></pre></div></div><div class=paragraph><p>Ein Administrator, der für die Sicherung zuständig ist, kann zwei Schnappschüsse miteinander vergleichen, die vom sendenden Host empfangen wurden, um festzustellen, welche Änderungen am Dataset vorgenommen wurden. Lesen Sie dazu den Abschnitt <a href=#zfs-zfs-send>Replication</a> um weitere Informationen zu erhalten.</p></div></div><div class=sect4><h5 id=zfs-zfs-snapshot-rollback>37.4.5.3. Schnappschüsse zurückrollen<a class=anchor href=#zfs-zfs-snapshot-rollback></a></h5><div class=paragraph><p>Wenn zumindest ein Schnappschuss vorhanden ist, kann dieser zu einem beliebigen Zeitpunkt zurückgerollt werden. In den meisten Fällen passiert dies, wenn der aktuelle Zustand des Datasets nicht mehr benötigt wird und eine ältere Version bevorzugt wird. Szenarien wie lokale Entwicklungstests, die fehlgeschlagen sind, defekte Systemaktualisierungen, welche die Funktionalität des Gesamtsystems einschränken oder die Anforderung, versehentlich gelöschte Dateien oder Verzeichnisse wiederherzustellen, sind allgegenwärtig. Glücklicherweise ist das zurückrollen eines Schnappschusses so leicht wie die Eingabe von <code>zfs rollback <em>snapshotname</em></code>. Abhängig davon, wie viele Änderungen betroffen sind, wird diese Operation innerhalb einer gewissen Zeit abgeschlossen sein. Während dieser Zeit bleibt das Dataset in einem konsistenten Zustand, sehr ähnlich den ACID-Prinzipien, die eine Datenbank beim Zurückrollen entspricht. Während all dies passiert, ist das Dataset immer noch aktiv und erreichbar ohne dass eine Ausfallzeit nötig wäre. Sobald der Schnappschuss zurückgerollt wurde, besitzt das Dataset den gleichen Zustand, den es besaß, als der Schnappschuss angelegt wurde. Alle anderen Daten in diesem Dataset, die nicht Teil des Schnappschusses sind, werden verworfen. Einen Schnappschuss des aktuellen Zustandes des Datasets vor dem Zurückrollen anzulegen ist eine gute Idee, wenn hinterher noch Daten benötigt werden. Auf diese Weise kann der Benutzer vor und zurück zwischen den Schnappschüssen springen, ohne wertvolle Daten zu verlieren.</p></div><div class=paragraph><p>Im ersten Beispiel wird ein Schnappschuss aufgrund eines unvorsichtigen <code>rm</code>-Befehls zurückgerollt, der mehr Daten gelöscht hat, als vorgesehen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         262K  93.2G   120K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<span class=c># ls /var/tmp</span>
passwd          passwd.copy     vi.recover
<span class=c># rm /var/tmp/passwd*</span>
<span class=c># ls /var/tmp</span>
vi.recover
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>Zu diesem Zeitpunkt bemerkt der Benutzer, dass zuviele Dateien gelöscht wurden und möchte diese zurück haben. ZFS bietet eine einfache Möglichkeit, diese durch zurückrollen zurück zu bekommen, allerdings nur, wenn Schnappschüsse von wichtigen Daten regelmäßig angelegt werden. Um die Dateien zurückzuerhalten und vom letzten Schnappschuss wieder zu beginnen, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs rollback mypool/var/tmp@diff_snapshot</span>
<span class=c># ls /var/tmp</span>
passwd          passwd.copy     vi.recover</code></pre></div></div><div class=paragraph><p>Die Operation zum Zurückrollen versetzt das Dataset in den Zustand des letzten Schnappschusses zurück. Es ist ebenfalls möglich, zu einem Schnappschuss zurückzurollen, der viel früher angelegt wurde und es noch Schnappschüsse nach diesem gibt. Wenn Sie dies versuchen, gibt ZFS die folgende Warnung aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt snapshot mypool/var/tmp</span>
AME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<span class=c># zfs rollback mypool/var/tmp@my_recursive_snapshot</span>
cannot rollback to <span class=s1>&#39;mypool/var/tmp@my_recursive_snapshot&#39;</span>: more recent snapshots exist
use <span class=s1>&#39;-r&#39;</span> to force deletion of the following snapshots:
mypool/var/tmp@after_cp
mypool/var/tmp@diff_snapshot</code></pre></div></div><div class=paragraph><p>Diese Warnung bedeutet, dass noch Schnappschüsse zwischen dem momentanen Stand des Datasets und dem Schnappschuss, zu dem der Benutzer zurückrollen möchte, existieren. Um das Zurückrollen durchzuführen, müssen die Schnappschüsse gelöscht werden. ZFS kann nicht alle Änderungen zwischen verschiedenen Zuständen eines Datasets verfolgen, da Schnappschüsse nur gelesen werden können. ZFS wird nicht die betroffenen Schnappschüsse löschen, es sei denn, der Benutzer verwendet die Option <code>-r</code>, um anzugeben, dass dies die gewünschte Aktion ist. Falls dies der Fall ist und die Konsequenzen alle dazwischenliegenden Schnappschüsse zu verlieren verstanden wurden, kann der Befehl abgesetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs rollback -r mypool/var/tmp@my_recursive_snapshot</span>
<span class=c># zfs list -rt snapshot mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot     8K      -   152K  -
<span class=c># ls /var/tmp</span>
vi.recover</code></pre></div></div><div class=paragraph><p>Die Ausgabe von <code>zfs list -t snapshot</code> bestätigt, dass die dazwischenliegenden Schnappschüsse als Ergebnis von <code>zfs rollback -r</code> entfernt wurden.</p></div></div><div class=sect4><h5 id=zfs-zfs-snapshot-snapdir>37.4.5.4. Individuelle Dateien aus Schnappschüssen wiederherstellen<a class=anchor href=#zfs-zfs-snapshot-snapdir></a></h5><div class=paragraph><p>Schnappschüsse sind unter einem versteckten Verzeichnis unter dem Eltern-Dataset eingehängt: <span class=filename>.zfs/snapshots/snapshotname</span>. Standardmäßig werden diese Verzeichnisse nicht von einem gewöhnlichen <code>ls -a</code> angezeigt. Obwohl diese Verzeichnisse nicht angezeigt werden, sind diese trotzdem vorhanden und der Zugriff darauf erfolgt wie auf jedes andere Verzeichnis. Die Eigenschaft <code>snapdir</code> steuert, ob diese Verzeichnisse beim Auflisten eines Verzeichnisses angezeigt werden oder nicht. Das Einstellen der Eigenschaft auf den Wert <code>visible</code> erlaubt es, diese in der Ausgabe von <code>ls</code> und anderen Kommandos, die mit Verzeichnisinhalten umgehen können, anzuzeigen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get snapdir mypool/var/tmp</span>
NAME            PROPERTY  VALUE    SOURCE
mypool/var/tmp  snapdir   hidden   default
<span class=c># ls -a /var/tmp</span>
<span class=nb>.</span>               ..              passwd          vi.recover
<span class=c># zfs set snapdir=visible mypool/var/tmp</span>
<span class=c># ls -a /var/tmp</span>
<span class=nb>.</span>               ..              .zfs            passwd          vi.recover</code></pre></div></div><div class=paragraph><p>Einzelne Dateien lassen sich einfach auf einen vorherigen Stand wiederherstellen, indem diese aus dem Schnappschuss zurück in das Eltern-Dataset kopiert werden. Die Verzeichnisstruktur unterhalb von <span class=filename>.zfs/snapshot</span> enthält ein Verzeichnis, das exakt wie der Schnappschuss benannt ist, der zuvor angelegt wurde, um es einfacher zu machen, diese zu identifizieren. Im nächsten Beispiel wird angenommen, dass eine Datei aus dem versteckten <span class=filename>.zfs</span> Verzeichnis durch kopieren aus dem Schnappschuss, der die letzte Version dieser Datei enthielt, wiederhergestellt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm /var/tmp/passwd</span>
<span class=c># ls -a /var/tmp</span>
<span class=nb>.</span>               ..              .zfs            vi.recover
<span class=c># ls /var/tmp/.zfs/snapshot</span>
after_cp                my_recursive_snapshot
<span class=c># ls /var/tmp/.zfs/snapshot/after_cp</span>
passwd          vi.recover
<span class=c># cp /var/tmp/.zfs/snapshot/after_cp/passwd /var/tmp</span></code></pre></div></div><div class=paragraph><p>Als <code>ls .zfs/snapshot</code> ausgeführt wurde, war die <code>snapdir</code>-Eigenschaft möglicherweise nicht auf hidden gesetzt, trotzdem ist es immer noch möglich, den Inhalt dieses Verzeichnisses aufzulisten. Es liegt am Administrator zu entscheiden, ob diese Verzeichnisse angezeigt werden soll. Es ist möglich, diese für bestimmte Datasets anzuzeigen und für andere zu verstecken. Das Kopieren von Dateien oder Verzeichnissen aus diesem versteckten <span class=filename>.zfs/snapshot</span> Verzeichnis ist einfach genug. Jedoch führt der umgekehrte Weg zu einem Fehler:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/rc.conf /var/tmp/.zfs/snapshot/after_cp/</span>
<span class=nb>cp</span>: /var/tmp/.zfs/snapshot/after_cp/rc.conf: Read-only file system</code></pre></div></div><div class=paragraph><p>Der Fehler erinnert den Benutzer daran, dass Schnappschüsse nur gelesen aber nicht mehr geändert werden können, nachdem diese angelegt wurden. Es können keine Dateien in diese Schnappschuss-Verzeichnisse kopiert oder daraus gelöscht werden, da dies sonst den Zustand des Datasets verändern würde, den sie repräsentieren.</p></div><div class=paragraph><p>Schnappschüsse verbrauchen Speicherplatz basierend auf der Menge an Änderungen, die am Eltern-Dataset durchgeführt wurden, seit der Zeit als der Schnappschuss erstellt wurde. Die Eigenschaft <code>written</code> eines Schnappschusses verfolgt, wieviel Speicherplatz vom Schnappschuss belegt wird.</p></div><div class=paragraph><p>Schnappschüsse werden zerstört und der belegte Platz wieder freigegeben durch den Befehl <code>zfs destroy <em>dataset</em>@<em>snapshot</em></code>. Durch hinzufügen von <code>-r</code> werden alle Schnappschüsse rekursiv gelöscht, die den gleichen Namen wie das Eltern-Dataset besitzen. Mit der Option <code>-n -v</code> wird eine Liste von Schnappschüssen, die gelöscht werden würden, zusammen mit einer geschätzten Menge an zurückgewonnenem Speicherplatz angezeigt, ohne die eigentliche Zerstöroperation wirklich durchzuführen.</p></div></div></div><div class=sect3><h4 id=zfs-zfs-clones>37.4.6. Klone verwalten<a class=anchor href=#zfs-zfs-clones></a></h4><div class=paragraph><p>Ein Klon ist eine Kopie eines Schnappschusses, der mehr wie ein reguläres Dataset behandelt wird. Im Gegensatz zu Schnappschüssen kann man von einem Klon nicht nur lesen, er ist eingehängt und kann seine eigenen Eigenschaften haben. Sobald ein Klon mittels <code>zfs clone</code> erstellt wurde, lässt sich der zugrundeliegende Schnappschuss nicht mehr zerstören. Die Eltern-/Kindbeziehung zwischen dem Klon und dem Schnappschuss kann über <code>zfs promote</code> aufgelöst werden. Nachdem ein Klon auf diese Weise befördert wurde, wird der Schnappschuss zum Kind des Klons, anstatt des ursprünglichen Datasets. Dies wird die Art und Weise, wie der Speicherplatz berechnet wird, verändern, jedoch nicht den bereits belegten Speicher anpassen. Der Klon kann an einem beliebigen Punkt innerhalb der ZFS-Dateisystemhierarchie eingehängt werden, nur nicht unterhalb der ursprünglichen Stelle des Schnappschusses.</p></div><div class=paragraph><p>Um diese Klon-Funktionalität zu demonstrieren, wird dieses Beispiel-Dataset verwendet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all camino/home/joe</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
camino/home/joe         108K   1.3G    87K  /usr/home/joe
camino/home/joe@plans    21K      -  85.5K  -
camino/home/joe@backup    0K      -    87K  -</code></pre></div></div><div class=paragraph><p>Ein typischer Einsatzzweck für Klone ist das experimentieren mit einem bestimmten Dataset, während der Schnappschuss beibehalten wird für den Fall, dass etwas schiefgeht. Da Schnappschüsse nicht verändert werden können, wird ein Lese-/Schreibklon des Schnappschusses angelegt. Nachdem das gewünschte Ergebnis im Klon erreicht wurde, kann der Klon zu einem Dataset ernannt und das alte Dateisystem entfernt werden. Streng genommen ist das nicht nötig, da der Klon und das Dataset ohne Probleme miteinander koexistieren können.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs clone camino/home/joe@backup camino/home/joenew</span>
<span class=c># ls /usr/home/joe*</span>
/usr/home/joe:
backup.txz     plans.txt

/usr/home/joenew:
backup.txz     plans.txt
<span class=c># df -h /usr/home</span>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G     31k    1.3G     0%    /usr/home/joe
usr/home/joenew     1.3G     31k    1.3G     0%    /usr/home/joenew</code></pre></div></div><div class=paragraph><p>Nachdem ein Klon erstellt wurde, stellt er eine exakte Kopie des Datasets zu dem Zeitpunkt dar, als der Schnappschuss angelegt wurde. Der Klon kann nun unabhängig vom ursprünglichen Dataset geändert werden. Die einzige Verbindung zwischen den beiden ist der Schnappschuss. ZFS zeichnet diese Verbindung in der Eigenschaft namens <code>origin</code> auf. Sobald die Abhängigkeit zwischen dem Schnappschuss und dem Klon durch das Befördern des Klons mittels <code>zfs promote</code> entfernt wurde, wird auch die <code>origin</code>-Eigenschaft des Klons entfernt, da es sich nun um ein eigenständiges Dataset handelt. Dieses Beispiel demonstriert dies:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get origin camino/home/joenew</span>
NAME                  PROPERTY  VALUE                     SOURCE
camino/home/joenew    origin    camino/home/joe@backup    -
<span class=c># zfs promote camino/home/joenew</span>
<span class=c># zfs get origin camino/home/joenew</span>
NAME                  PROPERTY  VALUE   SOURCE
camino/home/joenew    origin    -       -</code></pre></div></div><div class=paragraph><p>Nachdem ein paar Änderungen, wie beispielsweise das Kopieren von <span class=filename>loader.conf</span> auf den beförderten Klon vorgenommen wurden, wird das alte Verzeichnis in diesem Fall überflüssig. Stattdessen kann der beförderte Klon diesen ersetzen. Dies kann durch zwei aufeinanderfolgende Befehl geschehen: <code>zfs destroy</code> auf dem alten Dataset und <code>zfs rename</code> auf dem Klon, um diesen genauso wie das alte Dataset zu benennen (es kann auch einen ganz anderen Namen erhalten).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /boot/defaults/loader.conf /usr/home/joenew</span>
<span class=c># zfs destroy -f camino/home/joe</span>
<span class=c># zfs rename camino/home/joenew camino/home/joe</span>
<span class=c># ls /usr/home/joe</span>
backup.txz     loader.conf     plans.txt
<span class=c># df -h /usr/home</span>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G    128k    1.3G     0%    /usr/home/joe</code></pre></div></div><div class=paragraph><p>Der geklonte Schnappschuss wird jetzt wie ein gewöhnliches Dataset behandelt. Es enthält alle Daten aus dem ursprünglichen Schnappschuss inklusive der Dateien, die anschließend hinzugefügt wurden, wie <span class=filename>loader.conf</span>. Klone können in unterschiedlichen Szenarien eingesetzt werden, um nützliche Eigenschaften für ZFS-Anwender zur Verfügung zu stellen. Zum Beispiel können Jails als Schnappschüsse bereitgestellt werden, die verschiedene Arten von installierten Anwendungen anbieten. Anwender können diese Schnappschüsse klonen und ihre eigenen Anwendungen nach Belieben hinzufügen. Sobald sie mit den Änderungen zufrieden sind, können die Klone zu vollständigen Datasets ernannt werden und dem Anwender zur Verfügung gestellt werden, als würde es sich um echte Datasets handeln. Das spart Zeit und Administrationsaufwand, wenn diese Jails auf diese Weise zur Verfügung gestellt werden.</p></div></div><div class=sect3><h4 id=zfs-zfs-send>37.4.7. Replikation<a class=anchor href=#zfs-zfs-send></a></h4><div class=paragraph><p>Daten auf einem einzigen Pool an einem Platz aufzubewahren, setzt diese dem Risiko aus, gestohlen oder Opfer von Naturgewalten zu werden, sowie menschlichem Versagen auszusetzen. Regelmäßige Sicherungen des gesamten Pools ist daher unerlässlich. ZFS bietet eine Reihe von eingebauten Serialisierungsfunktionen an, die in der Lage ist, eine Repräsentation der Daten als Datenstrom auf die Standardausgabe zu schreiben. Mit dieser Methode ist es nicht nur möglich, die Daten auf einen anderen Pool zu schicken, der an das lokale System angeschlossen ist, sondern ihn auch über ein Netzwerk an ein anderes System zu senden. Schnappschüsse stellen dafür die Replikationsbasis bereit (lesen Sie dazu den Abschnitt zu <a href=#zfs-zfs-snapshot>ZFS snapshots</a>). Die Befehle, die für die Replikation verwendet werden, sind <code>zfs send</code> und <code>zfs receive</code>.</p></div><div class=paragraph><p>Diese Beispiele demonstrieren die Replikation von ZFS anhand dieser beiden Pools:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M    77K   896M         -         -     0%    0%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%    4%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>Der Pool namens <em>mypool</em> ist der primäre Pool, auf den regelmäßig Daten geschrieben und auch wieder gelesen werden. Ein zweiter Pool, genannt <em>backup</em> wird verwendet, um als Reserve zu dienen im Falle, dass der primäre Pool nicht zur Verfügung steht. Beachten Sie, dass diese Ausfallsicherung nicht automatisch von ZFS durchgeführt wird, sondern manuell von einem Systemadministrator bei Bedarf eingerichtet werden muss. Ein Schnappschuss wird verwendet, um einen konsistenten Zustand des Dateisystems, das repliziert werden soll, zu erzeugen. Sobald ein Schnappschuss von <em>mypool</em> angelegt wurde, kann er auf den <em>backup</em>-Pool abgelegt werden. Nur Schnappschüsse lassen sich auf diese Weise replizieren. Änderungen, die seit dem letzten Schnappschuss entstanden sind, werden nicht mit repliziert.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot mypool@backup1</span>
<span class=c># zfs list -t snapshot</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@backup1             0      -  43.6M  -</code></pre></div></div><div class=paragraph><p>Da nun ein Schnappschuss existiert, kann mit <code>zfs send</code> ein Datenstrom, der den Inhalt des Schnappschusses repräsentiert, erstellt werden. Dieser Datenstrom kann als Datei gespeichert oder von einem anderen Pool empfangen werden. Der Datenstrom wird auf die Standardausgabe geschrieben, muss jedoch in eine Datei oder in eine Pipe umgeleitet werden, sonst wird ein Fehler produziert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs send mypool@backup1</span>
Error: Stream can not be written to a terminal.
You must redirect standard output.</code></pre></div></div><div class=paragraph><p>Um ein Dataset mit <code>zfs send</code> zu replizieren, leiten Sie dieses in eine Datei auf dem eingehängten Backup-Pool um. Stellen Sie sicher, dass der Pool genug freien Speicherplatz besitzt, um die Größe des gesendeten Schnappschusses aufzunehmen. Das beinhaltet alle Daten im Schnappschuss, nicht nur die Änderungen zum vorherigen Schnappschuss.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs send mypool@backup1 &gt; /backup/backup1</span>
<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>Das Kommando <code>zfs send</code> transferierte alle Daten im <em>backup1</em>-Schnappschuss auf den Pool namens <em>backup</em>. Erstellen und senden eines Schnappschusses kann automatisch von <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> durchgeführt werden.</p></div><div class=paragraph><p>Anstatt die Sicherungen als Archivdateien zu speichern, kann ZFS diese auch als aktives Dateisystem empfangen, was es erlaubt, direkt auf die gesicherten Daten zuzugreifen. Um an die eigentlichen Daten in diesem Strom zu gelangen, wird <code>zfs receive</code> benutzt, um den Strom wieder in Dateien und Verzeichnisse umzuwandeln. Das Beispiel unten kombiniert <code>zfs send</code> und <code>zfs receive</code> durch eine Pipe, um die Daten von einem Pool auf den anderen zu kopieren. Die Daten können direkt auf dem empfangenden Pool verwendet werden, nachdem der Transfer abgeschlossen ist. Ein Dataset kann nur auf ein leeres Dataset repliziert werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot mypool@replica1</span>
<span class=c># zfs send -v mypool@replica1 | zfs receive backup/mypool</span>
send from @ to mypool@replica1 estimated size is 50.1M
total estimated size is 50.1M
TIME        SENT   SNAPSHOT

<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</code></pre></div></div><div class=sect4><h5 id=zfs-send-incremental>37.4.7.1. Inkrementelle Sicherungen<a class=anchor href=#zfs-send-incremental></a></h5><div class=paragraph><p>Die Unterschiede zwischen zwei Schnappschüssen kann <code>zfs send</code> ebenfalls erkennen und nur diese übertragen. Dies spart Speicherplatz und Übertragungszeit. Beispielsweise:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot mypool@replica2</span>
<span class=c># zfs list -t snapshot</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@replica1         5.72M      -  43.6M  -
mypool@replica2             0      -  44.1M  -
<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M  61.7M   898M         -         -     0%    6%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%    5%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>Ein zweiter Schnappschuss genannt <em>replica2</em> wurde angelegt. Dieser zweite Schnappschuss enthält nur die Änderungen, die zwischen dem jetzigen Stand des Dateisystems und dem vorherigen Schnappschuss, <em>replica1</em>, vorgenommen wurden. Durch <code>zfs send -i</code> und die Angabe des Schnappschusspaares wird ein inkrementeller Replikationsstrom erzeugt, welcher nur die Daten enthält, die sich geändert haben. Das kann nur erfolgreich sein, wenn der initiale Schnappschuss bereits auf der Empfängerseite vorhanden ist.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs send -v -i mypool@replica1 mypool@replica2 | zfs receive /backup/mypool</span>
send from @replica1 to mypool@replica2 estimated size is 5.02M
total estimated size is 5.02M
TIME        SENT   SNAPSHOT

<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  80.8M   879M         -         -     0%     8%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%     5%  1.00x  ONLINE  -

<span class=c># zfs list</span>
NAME                         USED  AVAIL  REFER  MOUNTPOINT
backup                      55.4M   240G   152K  /backup
backup/mypool               55.3M   240G  55.2M  /backup/mypool
mypool                      55.6M  11.6G  55.0M  /mypool

<span class=c># zfs list -t snapshot</span>
NAME                                         USED  AVAIL  REFER  MOUNTPOINT
backup/mypool@replica1                       104K      -  50.2M  -
backup/mypool@replica2                          0      -  55.2M  -
mypool@replica1                             29.9K      -  50.0M  -
mypool@replica2                                 0      -  55.0M  -</code></pre></div></div><div class=paragraph><p>Der inkrementelle Datenstrom wurde erfolgreich übertragen. Nur die Daten, die verändert wurden, sind übertragen worden, anstatt das komplette <em>replica1</em>. Nur die Unterschiede wurden gesendet, was weniger Zeit und Speicherplatz in Anspruch genommen hat, statt jedesmal den gesamten Pool zu kopieren. Das ist hilfreich wenn langsame Netzwerke oder Kosten für die übertragene Menge Bytes in Erwägung gezogen werden müssen.</p></div><div class=paragraph><p>Ein neues Dateisystem, <em>backup/mypool</em>, ist mit allen Dateien und Daten vom Pool <em>mypool</em> verfügbar. Wenn die Option <code>-P</code> angegeben wird, werden die Eigenschaften des Datasets kopiert, einschließlich der Komprimierungseinstellungen, Quotas und Einhängepunkte. Wird die Option <code>-R</code> verwendet, so werden alle Kind-Datasets des angegebenen Datasets kopiert, zusammen mit ihren Eigenschaften. Senden und Empfangen kann automatisiert werden, so dass regelmäßig Sicherungen auf dem zweiten Pool angelegt werden.</p></div></div><div class=sect4><h5 id=zfs-send-ssh>37.4.7.2. Sicherungen verschlüsselt über SSH senden<a class=anchor href=#zfs-send-ssh></a></h5><div class=paragraph><p>Datenströme über das Netzwerk zu schicken ist eine gute Methode, um Sicherungen außerhalb des Systems anzulegen. Jedoch ist dies auch mit einem Nachteil verbunden. Daten, die über die Leitung verschickt werden, sind nicht verschlüsselt, was es jedem erlaubt, die Daten abzufangen und die Ströme wieder zurück in Daten umzuwandeln, ohne dass der sendende Benutzer davon etwas merkt. Dies ist eine unerwünschte Situation, besonders wenn die Datenströme über das Internet auf ein entferntes System gesendet werden. SSH kann benutzt werden, um durch Verschlüsselung geschützte Daten über eine Netzwerkverbindung zu übertragen. Da ZFS nur die Anforderung hat, dass der Strom von der Standardausgabe umgeleitet wird, ist es relativ einfach, diesen durch SSH zu leiten. Um den Inhalt des Dateisystems während der Übertragung und auf dem entfernten System weiterhin verschlüsselt zu lassen, denken Sie über den Einsatz von <a href=https://wiki.freebsd.org/PEFS>PEFS</a> nach.</p></div><div class=paragraph><p>Ein paar Einstellungen und Sicherheitsvorkehrungen müssen zuvor abgeschlossen sein. Es werden hier nur die nötigen Schritte für die <code>zfs send</code>-Aktion gezeigt. Weiterführende Informationen zu SSH, gibt es im Kapitel <a href=./#openssh>OpenSSH</a>.</p></div><div class=paragraph><p>Die folgende Konfiguration wird benötigt:</p></div><div class=ulist><ul><li><p>Passwortloser SSH-Zugang zwischen dem sendenden und dem empfangenden Host durch den Einsatz von SSH-Schlüsseln.</p></li><li><p>Normalerweise werden die Privilegien des <code>root</code>-Benutzers gebraucht, um Strom zu senden und zu empfangen. Das beinhaltet das Anmelden auf dem empfangenden System als <code>root</code>. Allerdings ist das Anmelden als <code>root</code> aus Sicherheitsgründen standardmäßig deaktiviert. Mit <a href=#zfs-zfs-allow>ZFS Delegation</a> lassen sich nicht-<code>root</code>-Benutzer auf jedem System einrichten, welche die nötigen Rechte besitzen, um die Sende- und Empfangsoperation durchzuführen.</p></li><li><p>Auf dem sendenden System:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs allow -u someuser send,snapshot mypool</span></code></pre></div></div></li><li><p>Um den Pool einzuhängen, muss der unprivilegierte Benutzer das Verzeichnis besitzen und gewöhnliche Benutzern muss die Erlaubnis gegeben werden, das Dateisystem einzuhängen. Auf dem empfangenden System nehmen Sie dazu die folgenden Einstellungen vor:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1
<span class=c># echo vfs.usermount=1 &gt;&gt; /etc/sysctl.conf</span>
<span class=c># zfs create recvpool/backup</span>
<span class=c># zfs allow -u someuser create,mount,receive recvpool/backup</span>
<span class=c># chown someuser /recvpool/backup</span></code></pre></div></div></li></ul></div><div class=paragraph><p>Der unprivilegierte Benutzer hat jetzt die Fähigkeit, Datasets zu empfangen und einzuhängen und das <em>home</em>-Dataset auf das entfernte System zu replizieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% zfs snapshot <span class=nt>-r</span> mypool/home@monday
% zfs send <span class=nt>-R</span> mypool/home@monday | ssh someuser@backuphost zfs recv <span class=nt>-dvu</span> recvpool/backup</code></pre></div></div><div class=paragraph><p>Ein rekursiver Schnappschuss namens <em>monday</em> wird aus dem Dataset <em>home</em> erstellt, dass auf dem Pool <em>mypool</em> liegt. Es wird dann mit <code>zfs send -R</code> gesendet, um das Dataset, alle seine Kinder, Schnappschüsse, Klone und Einstellungen in den Strom mit aufzunehmen. Die Ausgabe wird an das wartende System <em>backuphost</em> mittels <code>zfs receive</code> durch SSH umgeleitet. Die Verwendung des Fully Qulified Domänennamens oder der IP-Adresse wird empfohlen. Die empfangende Maschine schreibt die Daten auf das <em>backup</em>-Dataset im <em>recvpool</em>-Pool. Hinzufügen der Option <code>-d</code> zu <code>zfs recv</code> überschreibt den Namen des Pools auf der empfangenden Seite mit dem Namen des Schnappschusses. Durch Angabe von <code>-u</code> wird das Dateisystem nicht auf der Empfängerseite eingehängt. Wenn <code>-v</code> enthalten ist, werden mehr Details zum Transfer angezeigt werden, einschließlich der vergangenen Zeit und der Menge an übertragenen Daten.</p></div></div></div><div class=sect3><h4 id=zfs-zfs-quota>37.4.8. Dataset-, Benutzer- und Gruppenquotas<a class=anchor href=#zfs-zfs-quota></a></h4><div class=paragraph><p><a href=#zfs-term-quota>Dataset-Quotas</a> werden eingesetzt, um den Speicherplatz einzuschränken, den ein bestimmtes Dataset verbrauchen kann. <a href=#zfs-term-refquota>Referenz-Quotas</a> funktionieren auf eine ähnliche Weise, jedoch wird dabei der Speicherplatz des Datasets selbst gezählt, wobei Schnappschüsse und Kind-Datasets dabei ausgenommen sind. Ähnlich dazu werden <a href=#zfs-term-userquota>Benutzer</a>- und <a href=#zfs-term-groupquota>Gruppen</a>-Quotas dazu verwendet, um Benutzer oder Gruppen daran zu hindern, den gesamten Speicherplatz im Pool oder auf dem Dataset zu verbrauchen.</p></div><div class=paragraph><p>Die folgenden Beispiele gehen davon aus, dass die Benutzer bereits im System vorhanden sind. Bevor Sie einen Benutzer hinzufügen, stellen Sie sicher, dass Sie zuerst ein Dataset für das Heimatverzeichnis anlegen und den <code>mountpoint</code> auf <code>/home/<em>bob</em></code> festlegen. Legen Sie dann den Benutzer an und stellen Sie sicher, dass das Heimatverzeichnis auf den auf den <code>mountpoint</code> des Datasets verweist. Auf diese Weise werden die Eigentümer- und Gruppenberechtigungen richtig gesetzt, ohne dass bereits vorhandene Heimatverzeichnisse verschleiert werden.</p></div><div class=paragraph><p>Um ein 10 GB großes Quota auf dem Dataset <span class=filename>storage/home/bob</span> zu erzwingen, verwenden Sie folgenden Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set quota=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Um ein Referenzquota von 10 GB für <span class=filename>storage/home/bob</span> festzulegen, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set refquota=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Um das Quota für <span class=filename>storage/home/bob</span> wieder zu entfernen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set quota=none storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Das generelle Format ist <code>userquota@<em>user</em>=<em>size</em></code> und der Name des Benutzers muss in einem der folgenden Formate vorliegen:</p></div><div class=ulist><ul><li><p>POSIX-kompatibler Name wie <em>joe</em>.</p></li><li><p>POSIX-numerische ID wie <em>789</em>.</p></li><li><p>SID-Name wie <em>joe.bloggs@example.com</em>.</p></li><li><p>SID-numerische ID wie <em>S-1-123-456-789</em>.</p></li></ul></div><div class=paragraph><p>Um beispielsweise ein Benutzerquota von 50 GB für den Benutzer names <em>joe</em> zu erzwingen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set userquota@joe=50G</span></code></pre></div></div><div class=paragraph><p>Um jegliche Quotas zu entfernen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set userquota@joe=none</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Benutzerquota-Eigenschaften werden nicht von <code>zfs get all</code> dargestellt. Nicht-<code>root</code>-Benutzer können nur ihre eigenen Quotas sehen, ausser ihnen wurde das <code>userquota</code>-Privileg zugeteilt. Benutzer mit diesem Privileg sind in der Lage, jedermanns Quota zu sehen und zu verändern.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Das generelle Format zum Festlegen einer Gruppenquota lautet: <code>groupquota@<em>group</em>=<em>size</em></code>.</p></div><div class=paragraph><p>Um ein Quota für die Gruppe <em>firstgroup</em> von 50 GB zu setzen, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set groupquota@firstgroup=50G</span></code></pre></div></div><div class=paragraph><p>Um eine Quota für die Gruppe <em>firstgroup</em> zu setzen oder sicherzustellen, dass diese nicht gesetzt ist, verwenden Sie stattdessen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set groupquota@firstgroup=none</span></code></pre></div></div><div class=paragraph><p>Genau wie mit der Gruppenquota-Eigenschaft, werden nicht-<code>root</code>-Benutzer nur die Quotas sehen, die den Gruppen zugeordnet ist, in denen Sie Mitglied sind. Allerdings ist <code>root</code> oder ein Benutzer mit dem <code>groupquota</code>-Privileg in der Lage, die Quotas aller Gruppen zu sehen und festzusetzen.</p></div><div class=paragraph><p>Um die Menge an Speicherplatz zusammen mit der Quota anzuzeigen, die von jedem Benutzer auf dem Dateisystem oder Schnappschuss verbraucht wird, verwenden Sie <code>zfs userspace</code>. Für Gruppeninformationen, nutzen Sie <code>zfs groupspace</code>. Für weitere Informationen zu unterstützten Optionen oder wie sich nur bestimmte Optionen anzeigen lassen, lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=1&amp;format=html">zfs(1)</a>.</p></div><div class=paragraph><p>Benutzer mit ausreichenden Rechten sowie <code>root</code> können das Quota für <span class=filename>storage/home/bob</span> anzeigen lassen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get quota storage/home/bob</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-zfs-reservation>37.4.9. Reservierungen<a class=anchor href=#zfs-zfs-reservation></a></h4><div class=paragraph><p><a href=#zfs-term-reservation>Reservierungen</a> garantieren ein Minimum an Speicherplatz, der immer auf dem Dataset verfügbar sein wird. Der reservierte Platz wird nicht für andere Datasets zur Verfügung stehen. Diese Eigenschaft kann besonders nützlich sein, um zu gewährleisten, dass freier Speicherplatz für ein wichtiges Dataset oder für Logdateien bereit steht.</p></div><div class=paragraph><p>Das generelle Format der <code>reservation</code>-Eigenschaft ist <code>reservation=<em>size</em></code>. Um also eine Reservierung von 10 GB auf <span class=filename>storage/home/bob</span> festzulegen, geben Sie Folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set reservation=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Um die Reservierung zu beseitigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set reservation=none storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Das gleiche Prinzip kann auf die <code>refreservation</code>-Eigenschaft angewendet werden, um eine <a href=#zfs-term-refreservation>Referenzreservierung</a> mit dem generellen Format <code>refreservation=<em>size</em></code> festzulegen.</p></div><div class=paragraph><p>Dieser Befehl zeigt die Reservierungen oder Referenzreservierungen an, die auf <span class=filename>storage/home/bob</span> existieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get reservation storage/home/bob</span>
<span class=c># zfs get refreservation storage/home/bob</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-zfs-compression>37.4.10. Komprimierung<a class=anchor href=#zfs-zfs-compression></a></h4><div class=paragraph><p>ZFS bietet transparente Komprimierung. Datenkomprimierung auf Blockebene während diese gerade geschrieben werden, spart nicht nur Plattenplatz ein, sondern kann auch den Durchsatz der Platte steigern. Falls Daten zu 25% komprimiert sind, jedoch die komprimierten Daten im gleichen Tempo wie ihre unkomprimierte Version, resultiert das in einer effektiven Schreibgeschwindigkeit von 125%. Komprimierung kann auch eine Alternative zu <a href=#zfs-zfs-deduplication>Deduplizierung</a> darstellen, da es viel weniger zusätzlichen Hauptspeicher benötigt.</p></div><div class=paragraph><p>ZFS bietet mehrere verschiedene Kompressionsalgorithmen an, jede mit unterschiedlichen Kompromissen. Mit der Einführung von LZ4-Komprimierung in ZFS v5000, ist es möglich, Komprimierung für den gesamten Pool zu aktivieren, ohne die großen Geschwindigkeitseinbußen der anderen Algorithmen. Der größte Vorteil von LZ4 ist die Eigenschaft <em>früher Abbruch</em>. Wenn LZ4 nicht mindestens 12,5% Komprimierung im ersten Teil der Daten erreicht, wird der Block unkomprimiert geschrieben, um die Verschwendung von CPU-Zyklen zu vermeiden, weil die Daten entweder bereits komprimiert sind oder sich nicht komprimieren lassen. Für Details zu den verschiedenen verfügbaren Komprimierungsalgorithmen in ZFS, lesen Sie den Eintrag <a href=#zfs-term-compression>Komprimierung</a> im Abschnitt Terminologie</p></div><div class=paragraph><p>Der Administrator kann die Effektivität der Komprimierung über eine Reihe von Dataset-Eigenschaften überwachen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get used,compressratio,compression,logicalused mypool/compressed_dataset</span>
NAME        PROPERTY          VALUE     SOURCE
mypool/compressed_dataset  used              449G      -
mypool/compressed_dataset  compressratio     1.11x     -
mypool/compressed_dataset  compression       lz4       <span class=nb>local
</span>mypool/compressed_dataset  logicalused       496G      -</code></pre></div></div><div class=paragraph><p>Dieses Dataset verwendet gerade 449 GB Plattenplatz (used-Eigenschaft. Ohne Komprimierung würde es stattdessen 496 GB Plattenplatz belegen (<code>logicalused</code>). Das ergibt eine Kompressionsrate von 1,11:1.</p></div><div class=paragraph><p>Komprimierung kann einen unerwarteten Nebeneffekt haben, wenn diese mit <a href=#zfs-term-userquota>Benutzerquotas</a> kombiniert wird. Benutzerquotas beschränken, wieviel Speicherplatz ein Benutzer auf einem Dataset verbrauchen kann. Jedoch basieren die Berechnungen darauf, wieviel Speicherplatz <em>nach der Komprimierung</em> belegt ist. Wenn also ein Benutzer eine Quota von10 GB besitzt und 10 GB von komprimierbaren Daten schreibt, wird dieser immer noch in der Lage sein, zusätzliche Daten zu speichern. Wenn später eine Datei aktualisiert wird, beispielsweise eine Datenbank, mit mehr oder weniger komprimierbaren Daten, wird sich die Menge an verfügbarem Speicherplatz ändern. Das kann in einer merkwürdigen Situation resultieren, in welcher der Benutzer nicht die eigentliche Menge an Daten (die Eigenschaft <code>logicalused</code>) überschreitet, jedoch die Änderung in der Komprimierung dazu führt, dass das Quota-Limit erreicht ist.</p></div><div class=paragraph><p>Kompression kann ebenso unerwartet mit Sicherungen interagieren. Quotas werden oft verwendet, um einzuschränken, wieviele Daten gespeichert werden können um sicherzustellen, dass ausreichend Speicherplatz für die Sicherung vorhanden ist. Wenn jedoch Quotas Komprimierung nicht berücksichtigen, werden womöglich mehr Daten geschrieben als in der unkomprimierten Sicherung Platz ist.</p></div></div><div class=sect3><h4 id=zfs-zfs-deduplication>37.4.11. Deduplizierung<a class=anchor href=#zfs-zfs-deduplication></a></h4><div class=paragraph><p>Wenn aktiviert, verwendet <a href=#zfs-term-deduplication>Deduplizierung</a> die Prüfsumme jedes Blocks, um Duplikate dieses Blocks zu ermitteln. Sollte ein neuer Block ein Duplikat eines existierenden Blocks sein, dann schreibt ZFS eine zusätzliche Referenz auf die existierenden Daten anstatt des kompletten duplizierten Blocks. Gewaltige Speicherplatzeinsparungen sind möglich wenn die Daten viele Duplikate von Dateien oder wiederholte Informationen enthalten. Seien Sie gewarnt: Deduplizierung benötigt eine extrem große Menge an Hauptspeicher und die meistens Einsparungen können stattdessen durch das Aktivieren von Komprimierung erreicht werden.</p></div><div class=paragraph><p>Um Deduplizierung zu aktivieren, setzen Sie die <code>dedup</code>-Eigenschaft auf dem Zielpool:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set dedup=on pool</span></code></pre></div></div><div class=paragraph><p>Nur neu auf den Pool geschriebene Daten werden dedupliziert. Daten, die bereits auf den Pool geschrieben wurden, werden nicht durch das Aktivieren dieser Option dedupliziert. Ein Pool mit einer gerade aktivierten Deduplizierung wird wie in diesem Beispiel aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool list</span>
NAME  SIZE ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG   CAP DEDUP HEALTH ALTROOT
pool 2.84G 2.19M 2.83G         -         -     0%    0% 1.00x ONLINE -</code></pre></div></div><div class=paragraph><p>Die Spalte <code>DEDUP</code> zeigt das aktuelle Verhältnis der Deduplizierung für diesen Pool an. Ein Wert von <code>1.00x</code> zeigt an, dass die Daten noch nicht dedupliziert wurden. Im nächsten Beispiel wird die Ports-Sammlung dreimal in verschiedene Verzeichnisse auf dem deduplizierten Pool kopiert.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for d in dir1 dir2 dir3; do</span>
<span class=o>&gt;</span> <span class=nb>mkdir</span> <span class=nv>$d</span> <span class=o>&amp;&amp;</span> <span class=nb>cp</span> <span class=nt>-R</span> /usr/ports <span class=nv>$d</span> &amp;
<span class=o>&gt;</span> <span class=k>done</span></code></pre></div></div><div class=paragraph><p>Redundante Daten werden erkannt und dedupliziert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool list</span>
NAME SIZE  ALLOC FREE CAP DEDUP HEALTH ALTROOT
pool 2.84G 20.9M 2.82G 0% 3.00x ONLINE -</code></pre></div></div><div class=paragraph><p>Die <code>DEDUP</code>-Spalte zeigt einen Faktor von <code>3.00x</code>. Mehrere Kopien der Ports-Sammlung wurden erkannt und dedupliziert, was nur ein Drittel des Speicherplatzes benötigt. Das Potential für Einsparungen beim Speicherplatz ist enorm, wird jedoch damit erkauft, dass genügend Speicher zur Verfügung stehen muss, um die deduplizierten Blöcke zu verwalten.</p></div><div class=paragraph><p>Deduplizierung ist nicht immer gewinnbringend, besonders wenn die Daten auf dem Pool nicht redundant sind. ZFS kann potentielle Speicherplatzeinsparungen durch Deduplizierung auf einem Pool simulieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zdb -S pool</span>
Simulated DDT histogram:

bucket              allocated                       referenced
______   ______________________________   ______________________________
refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE
<span class=nt>------</span>   <span class=nt>------</span>   <span class=nt>-----</span>   <span class=nt>-----</span>   <span class=nt>-----</span>   <span class=nt>------</span>   <span class=nt>-----</span>   <span class=nt>-----</span>   <span class=nt>-----</span>
     1    2.58M    289G    264G    264G    2.58M    289G    264G    264G
     2     206K   12.6G   10.4G   10.4G     430K   26.4G   21.6G   21.6G
     4    37.6K    692M    276M    276M     170K   3.04G   1.26G   1.26G
     8    2.18K   45.2M   19.4M   19.4M    20.0K    425M    176M    176M
    16      174   2.83M   1.20M   1.20M    3.33K   48.4M   20.4M   20.4M
    32       40   2.17M    222K    222K    1.70K   97.2M   9.91M   9.91M
    64        9     56K   10.5K   10.5K      865   4.96M    948K    948K
   128        2   9.50K      2K      2K      419   2.11M    438K    438K
   256        5   61.5K     12K     12K    1.90K   23.0M   4.47M   4.47M
    1K        2      1K      1K      1K    2.98K   1.49M   1.49M   1.49M
 Total    2.82M    303G    275G    275G    3.20M    319G    287G    287G

dedup <span class=o>=</span> 1.05, compress <span class=o>=</span> 1.11, copies <span class=o>=</span> 1.00, dedup <span class=k>*</span> compress / copies <span class=o>=</span> 1.16</code></pre></div></div><div class=paragraph><p>Nachdem <code>zdb -S</code> die Analyse des Pool abgeschlossen hat, zeigt es die Speicherplatzeinsparungen, die durch aktivierte Deduplizierung erreichbar sind, an. In diesem Fall ist <code>1.16</code> ein sehr schlechter Faktor, der größtenteils von Einsparungen durch Komprimierung beeinflusst wird. Aktivierung von Deduplizierung auf diesem Pool würde also keine signifikante Menge an Speicherplatz einsparen und ist daher nicht die Menge an Speicher wert, die nötig sind, um zu deduplizieren. Über die Formel <em>ratio = dedup * compress / copies</em> kann ein Systemadministrator die Speicherplatzbelegung planen und entscheiden, ob es sich lohnt, den zusätzlichen Hauptspeicher für die Deduplizierung anhand des späteren Workloads aufzuwenden. Wenn sich die Daten verhältnismäßig gut komprimieren lassen, sind die Speicherplatzeinsparungen sehr gut. Es wird empfohlen, in dieser Situation zuerst die Komprimierung zu aktivieren, da diese auch erhöhte Geschwindigkeit mit sich bringt. Aktivieren Sie Deduplizierung nur in solchen Fällen, bei denen die Einsparungen beträchtlich sind und genug Hauptspeicher zur Verfügung steht, um die <a href=#zfs-term-deduplication>DDT</a> aufzunehmen.</p></div></div><div class=sect3><h4 id=zfs-zfs-jail>37.4.12. ZFS und Jails<a class=anchor href=#zfs-zfs-jail></a></h4><div class=paragraph><p>Um ein ZFS-Dataset einem <a href=./#jails>Jail</a> zuzuweisen, wird der Befehl <code>zfs jail</code> und die dazugehörige Eigenschaft <code>jailed</code> verwendet. Durch Angabe von <code>zfs jail <em>jailid</em></code> wird ein Dataset dem spezifizierten Jail zugewiesen und kann mit <code>zfs unjail</code> wieder abgehängt werden. Damit das Dataset innerhalb der Jail kontrolliert werden kann, muss die Eigenschaft <code>jailed</code> gesetzt sein. Sobald ein Dataset sich im Jail befindet, kann es nicht mehr länger auf dem Hostsystem eingehängt werden, da es Einhängepunkte aufweisen könnte, welche die Sicherheit des Systems gefährden.</p></div></div></div><div class=sect2><h3 id=zfs-zfs-allow>37.5. Delegierbare Administration<a class=anchor href=#zfs-zfs-allow></a></h3><div class=paragraph><p>Ein umfassendes System zur Berechtigungsübertragung erlaubt unprivilegierten Benutzern, ZFS-Administrationsaufgaben durchzuführen. Beispielsweise, wenn jedes Heimatverzeichnis eines Benutzers ein Dataset ist, können Benutzer das Recht darin erhalten, Schnappschüsse zu erstellen und zu zerstören. Einem Benutzer für die Sicherung kann die Erlaubnis eingeräumt werden, die Replikationseigenschaft zu verwenden. Einem Skript zum Sammeln von Speicherplatzverbrauch kann die Berechtigung gegeben werden, nur auf die Verbrauchsdaten aller Benutzer zuzugreifen. Es ist sogar möglich, die Möglichkeit zum Delegieren zu delegieren. Die Berechtigung zur Delegation ist für jedes Unterkommando und die meisten Eigenschaften möglich.</p></div><div class=sect3><h4 id=zfs-zfs-allow-create>37.5.1. Delegieren, ein Dataset zu erstellen<a class=anchor href=#zfs-zfs-allow-create></a></h4><div class=paragraph><p><code>zfs allow <em>someuser</em> create <em>mydataset</em></code> gibt dem angegebenen Benutzer die Berechtigung, Kind-Datasets unter dem ausgewählten Elterndataset anzulegen. Es gibt einen Haken: ein neues Dataset anzulegen beinhaltet, dass es eingehängt wird. Dies bedeutet, dass FreeBSDs <code>vfs.usermount</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> auf <code>1</code> gesetzt wird, um nicht-root Benutzern zu erlauben, Dateisysteme einzubinden. Es gibt eine weitere Einschränkung um Missbrauch zu verhindern: nicht-<code>root</code> Benutzer müssen Besitzer des Einhängepunktes sein, an dem das Dateisystem eingebunden werden soll.</p></div></div><div class=sect3><h4 id=zfs-zfs-allow-allow>37.5.2. Delegationsberechtigung delegieren<a class=anchor href=#zfs-zfs-allow-allow></a></h4><div class=paragraph><p><code>zfs allow <em>someuser</em> allow <em>mydataset</em></code> gibt dem angegebenen Benutzer die Fähigkeit, jede Berechtigung, die er selbst auf dem Dataset oder dessen Kindern besitzt, an andere Benutzer weiterzugeben. Wenn ein Benutzer die <code>snapshot</code>- und die <code>allow</code>-Berechtigung besitzt, kann dieser dann die <code>snapshot</code>-Berechtigung an andere Benutzer delegieren.</p></div></div></div><div class=sect2><h3 id=zfs-advanced>37.6. Themen für Fortgeschrittene<a class=anchor href=#zfs-advanced></a></h3><div class=sect3><h4 id=zfs-advanced-tuning>37.6.1. Anpassungen<a class=anchor href=#zfs-advanced-tuning></a></h4><div class=paragraph><p>Eine Reihe von Anpassungen können vorgenommen werden, um ZFS unter verschiedenen Belastungen während des Betriebs bestmöglich einzustellen.</p></div><div class=ulist><ul><li><p><code><em>vfs.zfs.arc_max</em></code> - Maximale Größe des <a href=#zfs-term-arc>ARC</a>. Die Voreinstellung ist der gesamte RAM weniger 1 GB oder 5/8 vom RAM, je nachdem, was mehr ist. Allerdings sollte ein niedriger Wert verwendet werden, wenn das System weitere Dienste oder Prozesse laufen lässt, welche Hauptspeicher benötigen. Dieser Wert kann zur Laufzeit mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> eingestellt und in <span class=filename>/boot/loader.conf</span> permanent gespeichert werden.</p></li><li><p><code><em>vfs.zfs.arc_meta_limit</em></code> - Schränkt die Menge des <a href=#zfs-term-arc>ARC</a> ein, welche für die Speicherung von Metadaten verwendet wird. Die Voreinstellung ist ein Viertel von <code>vfs.zfs.arc_max</code>. Diesen Wert zu erhöhen steigert die Geschwindigkeit, wenn die Arbeitslast Operationen auf einer großen Menge an Dateien und Verzeichnissen oder häufigen Metadatenoperationen beinhaltet. Jedoch bedeutet dies auch weniger Dateidaten, die in den <a href=#zfs-term-arc>ARC</a> passen. Dieser Wert kann zur Laufzeit mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> eingestellt und in <span class=filename>/boot/loader.conf</span> oder <span class=filename>/etc/sysctl.conf</span> dauerhaft gespeichert werden.</p></li><li><p><code><em>vfs.zfs.arc_min</em></code> - Minimale Größe des <a href=#zfs-term-arc>ARC</a>. Der Standard beträgt die Hälfte von <code>vfs.zfs.arc_meta_limit</code>. Passen Sie diesen Wert an, um zu verhindern, dass andere Anwendungen den gesamten <a href=#zfs-term-arc>ARC</a> verdrängen. Dieser Wert kann zur Laufzeit mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> geändert und in <span class=filename>/boot/loader.conf</span> oder <span class=filename>/etc/sysctl.conf</span> dauerhaft gespeichert werden.</p></li><li><p><code><em>vfs.zfs.vdev.cache.size</em></code> - Eine vorallokierte Menge von Speicher, die als Cache für jedes Gerät im Pool reserviert wird. Die Gesamtgröße von verwendetem Speicher ist dieser Wert multipliziert mit der Anzahl an Geräten. Nur zur Bootzeit kann dieser Wert angepasst werden und wird in <span class=filename>/boot/loader.conf</span> eingestellt.</p></li><li><p><code><em>vfs.zfs.min_auto_ashift</em></code> - Minimaler <code>ashift</code>-Wert (Sektorgröße), welche zur Erstellungszeit des Pools automatisch verwendet wird. Der Wert ist ein Vielfaches zur Basis Zwei. Der Standardwert von <code>9</code> repräsentiert <code>2^9 = 512</code>, eine Sektorgröße von 512 Bytes. Um <em>write amplification</em> zu vermeiden und die bestmögliche Geschwindigkeit zu erhalten, setzen Sie diesen Wert auf die größte Sektorgröße, die bei einem Gerät im Pool vorhanden ist.</p><div class=paragraph><p>Viele Geräte besitzen 4 KB große Sektoren. Die Verwendung der Voreinstellung <code>9</code> bei <code>ashift</code> mit diesen Geräten resultiert in einer write amplification auf diesen Geräten. Daten, welche in einem einzelnen 4 KB Schreibvorgang Platz finden würden, müssen stattdessen in acht 512-byte Schreibvorgänge aufgeteilt werden. ZFS versucht, die allen Geräten zugrundeliegende Sektorgröße während der Poolerstellung zu lesen, jedoch melden viele Geräte mit 4 KB Sektoren, dass ihre Sektoren aus Kompatibilitätsgründen 512 Bytes betragen. Durch das Setzen von <code>vfs.zfs.min_auto_ashift</code> auf <code>12</code> (<code>2^12 = 4096</code>) bevor der Pool erstellt wird, zwingt ZFS dazu, für diese Geräte 4 KB Blöcke für bessere Geschwindigkeit zu nutzen.</p></div><div class=paragraph><p>Erzwingen von 4 KB Blöcken ist ebenfalls hilfreich auf Pools bei denen Plattenaufrüstungen geplant sind. Zukünftige Platten werden wahrscheinlich 4 KB große Sektoren und der Wert von <code>ashift</code> lässt sich nach dem Erstellen des Pools nicht mehr ändern.</p></div><div class=paragraph><p>In besonderen Fällen ist die kleinere Blockgröße von 512-Byte vorzuziehen. Weniger Daten werden bei kleinen, zufälligen Leseoperationen übertragen, was besonders bei 512-Byte großen Platten für Datenbanken oder Plattenplatz für virtuelle Maschinen der Fall ist. Dies kann bessere Geschwindigkeit bringen, ganz besonders wenn eine kleinere ZFS record size verwendet wird.</p></div></li><li><p><code><em>vfs.zfs.prefetch_disable</em></code> - Prefetch deaktivieren. Ein Wert von <code>0</code> bedeutet aktiviert und <code>1</code> heißt deaktiviert. Die Voreinstellung ist <code>0</code>, außer, das System besitzt weniger als 4 GB RAM. Prefetch funktioniert durch das Lesen von grösseren Blöcken in den <a href=#zfs-term-arc>ARC</a> als angefordert wurden, in der Hoffnung, dass diese Daten ebenfalls bald benötigt werden. Wenn die I/O-Last viele große Mengen von zufälligen Leseoperationen beinhaltet, ist das Deaktivieren von prefetch eine Geschwindigkeitssteigerung durch die Reduzierung von unnötigen Leseoperationen. Dieser Wert kann zu jeder Zeit über <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> angepasst werden.</p></li><li><p><code><em>vfs.zfs.vdev.trim_on_init</em></code> - Steuert, ob neue Geräte, die dem Pool hinzugefügt werden, das <code>TRIM</code>-Kommando ausführen sollen. Das beinhaltet die beste Geschwindigkeit und Langlebigkeit für SSDs, benötigt jedoch zusätzliche Zeit. Wenn das Gerät bereits sicher gelöscht wurde, kann durch deaktivieren dieser Option das Hinzufügen neuer Geräte schneller geschehen. Über <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> lässt sich dieser Wert jederzeit einstellen.</p></li><li><p><code><em>vfs.zfs.vdev.max_pending</em></code> - Begrenzt die Menge von ausstehenden I/O-Anfragen pro Gerät. Ein größerer Wert wird die Gerätewarteschlange für Befehle gefüllt lassen und möglicherweise besseren Durchsatz erzeugen. Ein niedrigerer Wert reduziert die Latenz. Jederzeit kann dieser Wert über <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> angepasst werden.</p></li><li><p><code><em>vfs.zfs.top_maxinflight</em></code> - Maximale Anzahl von ausstehenden I/Os pro darüberliegendem <a href=#zfs-term-vdev>vdev</a>. Begrenzt die Tiefe Kommandowarteschlange, um hohe Latenzen zu vermeiden. Das Limit ist pro darüberliegendem vdev, was bedeutet, dass das Limit für jeden <a href=#zfs-term-vdev-mirror>mirror</a>, <a href=#zfs-term-vdev-raidz>RAID-Z</a>, oder anderes vdev unabhängig gilt. Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> kann dieser Wert jederzeit angepasst werden.</p></li><li><p><code><em>vfs.zfs.l2arc_write_max</em></code> - Begrenzt die Menge an Daten, die pro Sekunde in den <a href=#zfs-term-l2arc>L2ARC</a> geschrieben wird. Durch diese Einstellung lässt sich die Lebensdauer von SSDs erhöhen, indem die Menge an Daten beschränkt wird, die auf das Gerät geschrieben wird. Dieser Wert ist über <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> zu einem beliebigen Zeitpunkt änderbar.</p></li><li><p><code><em>vfs.zfs.l2arc_write_boost</em></code> - Der Wert dieser Einstellung wird zu <a href=#zfs-advanced-tuning-l2arc_write_max><code>vfs.zfs.l2arc_write_max</code></a> addiert und erhöht die Schreibgeschwindigkeit auf die SSD bis der erste Block aus dem <a href=#zfs-term-l2arc>L2ARC</a> verdrängt wurde. Diese "Turbo Warmup Phase" wurde entwickelt, um den Geschwindigkeitsverlust eines leeren <a href=#zfs-term-l2arc>L2ARC</a> nach einem Neustart zu reduzieren. Jederzeit kann dieser Wert mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> geändert werden.</p></li><li><p><code><em>vfs.zfs.scrub_delay</em></code> - Anzahl von Ticks an Verzögerung zwischen jedem I/O während eines <a href=#zfs-term-scrub><code>scrub</code></a>. Um zu gewährleisten, dass ein <code>scrub</code> nicht mit die normalen Vorgänge eines Pools beeinträchtigt. Wenn währenddessen andere I/Os durchgeführt werden, wird der <code>scrub</code> zwischen jedem Befehl verzögert. Dieser Wert regelt die Gesamtmenge von IOPS (I/Os Per Second), die von <code>scrub</code> generiert werden. Die Granularität der Einstellung ist bestimmt durch den Wert von <code>kern.hz</code>, welcher standardmäßig auf auf 1000 Ticks pro Sekunde eingestellt ist. Diese Einstellung kann geändert werden, was in einer unterschiedlich effektiven Limitierung der IOPS resultiert. Der Standardwert ist <code>4</code>, was ein Limit von 1000 ticks/sec / 4 = 250 IOPS ergibt. Ein Wert von <em>20</em> würde ein Limit von 1000 ticks/sec / 20 = 50 IOPS ergeben. Die <code>scrub</code>-Geschwindigkeit ist nur begrenzt, wenn es kürzlich Aktivität auf dem Pool gab, wie der Wert von <a href=#zfs-advanced-tuning-scan_idle><code>vfs.zfs.scan_idle</code></a> verrät. Zu einem beliebigen Zeitpunkt kann über <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> eine Änderung an diesem Wert erfolgen.</p></li><li><p><code><em>vfs.zfs.resilver_delay</em></code> - Anzahl an Millisekunden Verzögerung, die zwischen jedem I/O während eines <a href=#zfs-term-resilver>resilver</a> eingefügt wird. Um zu versichern, dass ein resilver nicht die normalen Vorgänge auf dem Pool stört, wird dieser zwischen jedem Kommando verzögert, wenn andere I/Os auf dem Pool passieren. Dieser Wert steuert das Limit der Gesamt-IOPS (I/Os Pro Sekunde), die vom resilver erzeugt werden. Die Granularität der Einstellung wird durch den Wert von <code>kern.hz</code> bestimmt, welcher standardmäßig 1000 Ticks pro Sekunde beträgt. Diese Einstellung lässt sich ändern, was in einem unterschiedlich effizienten IOPS-Limit resultiert. Die Voreinstellung ist 2, was ein Limit von 1000 ticks/sec / 2 = 500 IOPS beträgt. Einen Pool wieder in den Zustand <a href=#zfs-term-online>Online</a> zu versetzen ist möglicherweise wichtiger wenn eine andere Platte den Pool in den <a href=#zfs-term-faulted>Fault</a>-Zustand versetzt, was Datenverlust zur Folge hat. Ein Wert von 0 wird der resilver-Operation die gleiche Priorität wie anderen Operationen geben, was den Heilungsprozess beschleunigt. Die Geschwindigkeit des resilver wird nur begrenzt, wenn es kürzlich andere Aktivitäten auf dem Pool gab, wie von <a href=#zfs-advanced-tuning-scan_idle><code>vfs.zfs.scan_idle</code></a> festgestellt wird. Dieser Wert kann zu jeder Zeit über. <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> eingestellt werden.</p></li><li><p><code><em>vfs.zfs.scan_idle</em></code> - Anzahl an Millisekunden seit der letzten Operation bevor der Pool als im Leerlauf befindlich deklariert wird. Wenn sich der Pool im Leerlauf befindet, wird die Begrenzung für <a href=#zfs-term-scrub><code>scrub</code></a> und <a href=#zfs-term-resilver>resilver</a> deaktiviert. Dieser Wert kann mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> jederzeit angepasst werden.</p></li><li><p><code><em>vfs.zfs.txg.timeout</em></code> - Maximale Anzahl von Sekunden zwischen <a href=#zfs-term-txg>Transaktionsgruppen</a> (transaction group). Die momentane Transaktionsgruppe wird auf den Pool geschrieben und eine frische Transaktionsgruppe begonnen, wenn diese Menge an Zeit seit der vorherigen Transaktionsgruppe abgelaufen ist. Eine Transaktionsgruppe kann verfrüht ausgelöst werden, wenn genug Daten geschrieben werden. Der Standardwert beträgt 5 Sekunden. Ein größerer Wert kann die Lesegeschwindigkeit durch verzögern von asynchronen Schreibvorgängen verbessern, allerdings kann dies ungleiche Geschwindigkeiten hervorrufen, wenn eine Transaktionsgruppe geschrieben wird. Dieser Wert kann zu einem beliebigen Zeitpunkt mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> geändert werden.</p></li></ul></div></div><div class=sect3><h4 id=zfs-advanced-i386>37.6.2. ZFS auf i386<a class=anchor href=#zfs-advanced-i386></a></h4><div class=paragraph><p>Manche der Eigenschaften, die von ZFS bereitgestellt werden, sind speicherintensiv und benötigen Anpassungen für die maximale Effizienz auf Systemen mit begrenztem RAM.</p></div><div class=sect4><h5 id=_hauptspeicher>37.6.2.1. Hauptspeicher<a class=anchor href=#_hauptspeicher></a></h5><div class=paragraph><p>Als absolutes Minimum sollte der gesamte verfügbare Hauptspeicher mindestens ein Gigabyte betragen. Die vorgeschlagene Menge an RAM ist bedingt durch die Poolgröße und welche Eigenschaften von ZFS verwendet werden. Eine Faustregel besagt, dass 1 GB RAM für jedes 1 TB Storage vorgesehen werden sollte. Wenn Deduplizierung zum Einsatz kommt, besagt die Regel, dass 5 GB RAM pro TB an Speicher, der dedupliziert werden soll, bereitgestellt sein muss. Obwohl manche Anwender ZFS mit weniger RAM einsetzen, stürzen Systeme häufiger wegen unzureichendem Hauptspeicher ab. Weitere Anpassungen sind unter Umständen nötig für Systeme mit weniger als die vorgeschlagene Menge an RAM.</p></div></div><div class=sect4><h5 id=_kernel_konfiguration>37.6.2.2. Kernel-Konfiguration<a class=anchor href=#_kernel_konfiguration></a></h5><div class=paragraph><p>Wegen des begrenzten Addressraumes der i386™-Plattform müssen ZFS-Anwendern auf der i386™-Architektur diese Option der Kernelkonfigurationsdatei hinzufügen, den Kernel erneut bauen und das System neu starten:</p></div><div class="literalblock programlisting"><div class=content><pre>options        KVA_PAGES=512</pre></div></div><div class=paragraph><p>Dies erweitert den Addressraum des Kernels, was es erlaubt, die Einstellung <code>vm.kvm_size</code> hinter die momentan vorgegebene Grenze von 1 GB oder das Limit von 2 GB für PAE zu bringen. Um den passenden Wert für diese Option zu finden, teilen Sie den gewünschten Addressraum in Megabyte durch vier. In diesem Beispiel beträgt sie <code>512</code> für 2 GB.</p></div></div><div class=sect4><h5 id=_loader_anpassungen>37.6.2.3. Loader-Anpassungen<a class=anchor href=#_loader_anpassungen></a></h5><div class=paragraph><p>Der <span class=filename>kmem</span>-Addressraum kann auf allen FreeBSD-Architekturen erhöht werden. Auf einem Testsystem mit 1 GB physischen Speichers wurden mit diesen Optionen in <span class=filename>/boot/loader.conf</span> und einem anschließenden Systemneustart Erfolge erzielt:</p></div><div class="literalblock programlisting"><div class=content><pre>vm.kmem_size=&#34;330M&#34;
vm.kmem_size_max=&#34;330M&#34;
vfs.zfs.arc_max=&#34;40M&#34;
vfs.zfs.vdev.cache.size=&#34;5M&#34;</pre></div></div><div class=paragraph><p>Für eine detailliertere Liste an Empfehlungen für ZFS-bezogene Einstellungen, lesen Sie <a href=https://wiki.freebsd.org/ZFSTuningGuide class=bare>https://wiki.freebsd.org/ZFSTuningGuide</a>.</p></div></div></div></div><div class=sect2><h3 id=zfs-links>37.7. Zusätzliche Informationen<a class=anchor href=#zfs-links></a></h3><div class=ulist><ul><li><p><a href=http://open-zfs.org>OpenZFS</a></p></li><li><p><a href=https://wiki.freebsd.org/ZFSTuningGuide>FreeBSD Wiki - ZFS Tuning</a></p></li><li><p><a href=http://docs.oracle.com/cd/E19253-01/819-5461/index.html>Oracle Solaris ZFS Administration Guide</a></p></li><li><p><a href=https://calomel.org/zfs_raid_speed_capacity.html>Calomel Blog - ZFS Raidz Performance, Capacity und Integrity</a></p></li></ul></div></div><div class=sect2><h3 id=zfs-term>37.8. ZFS-Eigenschaften und Terminologie<a class=anchor href=#zfs-term></a></h3><div class=paragraph><p>ZFS ist ein fundamental anderes Dateisystem aufgrund der Tatsache, dass es mehr als ein Dateisystem ist. ZFS kombiniert die Rolle eines Dateisystems mit dem Volumemanager, was es ermöglicht, zusätzliche Speichermedien zu einem laufenden System hinzuzufügen und diesen neuen Speicher sofort auf allen auf dem Pool existierenden Dateisystemen zur Verfügung zu haben. Durch die Kombination von traditionell getrennten Rollen ist ZFS in der Lage, Einschränkungen, die zuvor RAID-Gruppen daran gehindert hatten, zu wachsen. Jedes Gerät auf höchster Ebene in einem Pool wird ein <em>vdev</em> genannt, was eine einfache Platte oder eine RAID-Transformation wie ein Spiegel oder RAID-Z-Verbund sein kann. ZFS-Dateisysteme (<em>datasets</em> genannt), haben jeweils Zugriff auf den gesamten freien Speicherplatz des gesamten Pools. Wenn Blöcke aus diesem Pool allokiert werden, verringert sich auch der freie Speicherplatz für jedes Dateisystem. Dieser Ansatz verhindert die allgegenwärtige Falle von umfangreichen Partitionen, bei denen freier Speicherplatz über alle Partitionen hinweg fragmentiert wird.</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:10%><col style=width:90%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-pool></a>zpool</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein Speicher-<em>Pool</em> ist der grundlegendste Baustein von ZFS. Ein Pool besteht aus einem oder mehreren vdevs, was die zugrundeliegenden Geräte repräsentiert, welche die Daten speichern. Ein Pool wird dann verwendet, um ein oder mehrere Dateisysteme (Datasets) oder Blockgeräte (Volumes) zu erstellen. Diese Datasets und Volumes teilen sich den im Pool verfügbaren Speicherplatz. Jeder Pool wird eindeutig durch einen Namen und eine GUID identifiziert. Die verfügbaren Eigenschaften werden durch die ZFS-Versionsnummer des Pools bestimmt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-vdev></a>vdev Arten</p></td><td class="tableblock halign-left valign-top"><div class=content><div class=paragraph><p>Ein Pool besteht aus einem oder mehreren vdevs, die selbst eine einfache Platte oder im Fall von RAID eine Gruppe von Platten darstellt. Wenn mehrere vdevs eingesetzt werden, verteilt ZFS die Daten über die vdevs, um die Geschwindigkeit zu steigern und den verfügbaren Platz zu maximieren.</p></div><div class=ulist><ul><li><p><a id=zfs-term-vdev-disk></a><em>Festplatte</em> - Der einfachste Typ von vdev ist ein Standard-Blockgerät. Dies kann die komplette Platte (wie <span class=filename>/dev/ada0</span> oder <span class=filename>/dev/da0</span>) oder auch eine Partition (<span class=filename>/dev/ada0p3</span>) sein. Auf FreeBSD gibt es keine Geschwindigkeitseinbußen bei der Verwendung einer Partition anstatt einer kompletten Platte. Dies unterscheidet sich von den Empfehlungen, welche in der Solaris Dokumentation gegeben werden.</p><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Es wird dringend davon abgeraten, eine ganze Platte für einen bootbaren Pool zu benutzen, da dies dazu führen kann, dass der Pool nicht mehr bootet. Ebenso sollten Sie nicht eine ganze Platte als Teil eines Spiegels oder RAID-Z vdev verwenden, weil es dann nicht mehr möglich ist, die Größe einer nicht partitionierten Platte beim Booten zuverlässig zu bestimmen. Zudem gibt es dann keinen Platz mehr, um Boot-Code einzufügen.</p></div></td></tr></tbody></table></div></li><li><p><a id=zfs-term-vdev-file></a><em>File</em> - Zusätzlich zu Festplatten können ZFS-Pools aus regulären Dateien aufgebaut sein, was besonders hilfreich ist, um zu testen und zu experimentieren. Verwenden Sie den kompletten Pfad zu der Datei als Gerätepfad im Befehl <code>zpool create</code>. Alle vdevs müssen mindestens 128 MB groß sein.</p></li><li><p><a id=zfs-term-vdev-mirror></a><em>Mirror</em> - Wenn ein Spiegel erstellt wird, verwenden Sie das Schlüsselwort <code>mirror</code>, gefolgt von der Liste an Mitgliedsgeräten für den Spiegel. Ein Spiegel besteht aus zwei oder mehr Geräten und sämtliche Daten werden auf alle Geräte, die Mitglied des Spiegels sind, geschrieben. Ein Spiegel-vdev wird nur soviele Daten speichern, wie das kleinste Gerät im Verbund aufnehmen kann. Ein Spiegel-vdev kann den Verlust von allen Mitgliedsgeräten bis auf eines verkraften, ohne irgendwelche Daten zu verlieren.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ein reguläre einzelne vdev-Platte kann jederzeit zu einem Spiegel-vdev über das Kommando <code>zpool <a href=#zfs-zpool-attach>attach</a></code> aktualisiert werden.</p></div></td></tr></tbody></table></div></li><li><p><a id=zfs-term-vdev-raidz></a><em>RAID-Z</em> - ZFS implementiert RAID-Z, eine Varianten des RAID-5-Standards, der bessere Verteilung der Parität bietet und das "RAID-5 write hole" eliminiert, bei dem die Daten und Parität nach einem unerwarteten Neustart inkonsistent werden können. ZFS unterstützt drei Stufen von RAID-Z, die unterschiedliche Arten von Redundanz im Austausch gegen niedrigere Stufen von verwendbarem Speicher. Diese Typen werden RAID-Z1 bis RAID-Z3 genannt, basierend auf der Anzahl der Paritätsgeräte im Verbund und der Anzahl an Platten, die ausfallen können, während der Pool immer noch normal funktioniert.</p><div class=paragraph><p>In einer RAID-Z1-Konfiguration mit vier Platten, bei der jede 1 TB besitzt, beträgt der verwendbare Plattenplatz 3 TB und der Pool wird immer noch im Modus degraded weiterlaufen, wenn eine Platte davon ausfällt. Wenn eine zusätzliche Platte ausfällt, bevor die defekte Platte ersetzt wird, können alle Daten im Pool verloren gehen.</p></div><div class=paragraph><p>Eine Konfiguration von acht Platten zu je 1 TB als RAID-Z3 wird 5 TB verwendbaren Speicher bieten und in der Lage sein, weiterhin zu funktionieren, wenn drei Platten ausgefallen sind. Sun™ empfiehlt nicht mehr als neun Platten in einem einzelnen vdev. Wenn die Konfiguration mehr Platten aufweist, wird empfohlen, diese in getrennten vdevs aufzuteilen, so dass die Daten des Pools zwischen diesen aufgeteilt werden.</p></div><div class=paragraph><p>Eine Konfiguration von zwei RAID-Z2-vdevs, bestehend aus jeweils 8 Platten würde etwa einem RAID-60-Verbund entsprechen. Der Speicherplatz einer RAID-Z-Gruppe ist ungefähr die Größe der kleinsten Platte multipliziert mit der Anzahl von nicht-Paritätsplatten. Vier 1 TB Platten in einem RAID-Z1 besitzt eine effektive Größe von ungefähr 3 TB und ein Verbund von acht 1 TB-Platten als RAID-Z3 enthält 5 TB verfügbarer Plattenplatz.</p></div></li><li><p><a id=zfs-term-vdev-spare></a><em>Spare</em> - ZFS besitzt einen speziellen Pseudo-vdev Typ, um einen Überblick über die verfügbaren hot spares zu behalten. Beachten Sie, dass hot spares nicht automatisch eingesetzt werden. Diese müssen manuell konfiguriert werden, um ein ausgefallenes Gerät über <code>zfs replace</code> zu ersetzen.</p></li><li><p><a id=zfs-term-vdev-log></a><em>Log</em> - ZFS Log-Geräte, auch bezeichnet als ein ZFS Intent Log (<a href=#zfs-term-zil>ZIL</a>) verschieben das Intent Log von den regulären Geräten im Pool auf ein dediziertes Gerät, typischerweise eine SSD. Ein dediziertes Log-Gerät zu besitzen kann die Geschwindigkeit von Anwendungen mit einer großen Anzahl von synchronen Schreibvorgängen, besonders Datenbanken, signifikant steigern. Log-Geräte können gespiegelt werden, jedoch wird RAID-Z nicht unterstützt. Werden mehrere Log-Geräte verwendet, so werden Schreibvorgänge gleichmäßig unter diesen aufgeteilt.</p></li><li><p><a id=zfs-term-vdev-cache></a><em>Cache</em> - Ein Cache-vdev einem Pool hinzuzufügen, erhöht den Speicher des <a href=#zfs-term-l2arc>L2ARC</a> Caches. Cache-Geräte lassen sich nicht spiegeln. Da ein Cache-Gerät nur zusätzliche Kopien von existierenden Daten speichert, gibt es kein Risiko, Daten zu verlieren.</p></li></ul></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-txg></a>Transaktionsgruppe (Transaction Group, TXG)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Transaktionsgruppen sind die Art und Weise, wie geänderte Blöcke zusammen gruppiert und letztendlich auf den Pool geschrieben werden. Transaktionsgruppen sind die atomare Einheit, welche ZFS verwendet, um Konsistenz zu gewährleisten. Jeder Transaktionsgruppe wird eine einzigartige, fortlaufende 64-Bit Identifikationsnummer zugewiesen. Es kann bis zu drei aktive Transaktionsgruppen gleichzeitig geben, wobei sich jede davon in einem der folgenden drei Zustände befinden kann:</p><p class=tableblock>* <em>Open (Offen)</em> - Wenn eine neue Transaktionsgruppe erstellt wird, befindet diese sich im Zustand offen und akzeptiert neue Schreibvorgänge. Es ist immer eine Transaktionsgruppe in diesem Zustand, jedoch kann die Transaktionsgruppe neue Schreibvorgänge ablehnen, wenn diese ein Limit erreicht hat. Sobald eine offene Transaktionsgruppe an das Limit stößt oder das <a href=#zfs-advanced-tuning-txg-timeout><code>vfs.zfs.txg.timeout</code></a> wurde erreicht, geht die Transaktionsgruppe in den nächsten Zustand über.
* <em>Quiescing (Stilllegen)</em> - Ein kurzer Zustand, der es noch ausstehenden Operationen erlaubt, zum Abschluss zu kommen, währenddessen das Erstellen einer neuen Transaktionsgruppe jedoch nicht blockiert wird. Sobald alle Transaktionen in der Gruppe abgeschlossen sind, geht die Transaktionsgruppen in den letzten Zustand über.
* <em>Syncing (Sychronisieren)</em> - Alle Daten in der Transaktionsgruppe werden auf das Speichermedium geschrieben. Dieser Prozess wird wiederum andere Daten wie Metadaten und space maps verändern, die ebenfalls auf das Speichermedium geschrieben werden müssen. Der Prozess des Synchronisierens beinhaltet mehrere Durchläufe. Der erste Prozess, welches der größte, gefolgt von den Metadaten, ist, beinhaltet alle geänderten Datenblöcke und kann mehrere Durchläufe benötigen, um zum Ende zu gelangen. Da das Allokieren von Speicher für die Datenblöcke neue Metadaten generiert, kann der Synchronisationsprozess nicht beendet werden, bis ein Durchlauf fertig ist, der keinen zusätzlichen Speicher allokiert. Der Synchronisierungszustand ist der Zustand, in dem auch <em>synctasks</em> abgeschlossen werden. Synctasks sind administrative Operationen, wie das Erstellen oder zerstören von Schnappschüssen und Datasets, welche den Überblock verändern, wenn sie abgeschlossen sind. Sobald der Synchronisationszustand abgeschlossen ist, geht die Transaktionsgruppe aus dem Stilllegungszustand über in den Synchronisationszustand.
Alle administrativen Funktionen, wie <a href=#zfs-term-snapshot><code>Schnappschüsse</code></a> werden als Teil einer Transaktionsgruppe geschrieben. Wenn ein synctask erstellt ist, wird dieser der momentan geöffneten Transaktionsgruppe hinzugefügt und diese Gruppe wird so schnell wie möglich in den Synchronisationszustand versetzt, um die Latenz von administrativen Befehlen zu reduzieren.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-arc></a>Adaptive Replacement Cache (ARC)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ZFS verwendet einen Adaptive Replacement Cache (ARC), anstatt eines traditionellen Least Recently Used (LRU) Caches. Ein LRU-Cache ist eine einfache Liste von Elementen im Cache, sortiert nach der letzten Verwendung jedes Elements in der Liste. Neue Elemente werden an den Anfang der Liste eingefügt. Wenn der Cache voll ist, werden Elemente vom Ende der Liste verdrängt, um Platz für aktivere Objekte zu schaffen. Ein ARC besteht aus vier Listen: derjenigen der Most Recently Used (MRU) und Most Frequently Used (MFU) Objekte, plus einer sogenannten ghost list für jede von beiden. Diese Ghost Lists verfolgen die kürzlich verdrängten Objekte, um zu verhindern, dass diese erneut in den Cache aufgenommen werden. Dies erhöht die Trefferrate (hit ratio) des Caches, indem verhindert wird, dass Elemente, die in der Vergangenheit nur ab und zu benutzt wurden, wieder im Cache landen. Ein weiterer Vorteil der Verwendung sowohl einer MRU und einer MFU ist, dass das Scannen eines gesamten Dateisystems normalerweise alle Daten aus einem MRU- oder LRU-Cache verdrängt, um dem gerade frisch zugegriffenem Inhalt den Vorzug zu geben. Mit ZFS gibt es also eine MFU, die nur die am häufigsten verwendeten Elemente beinhaltet und der Cache von am meisten zugegriffenen Blöcken bleibt erhalten.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-l2arc></a>L2ARC</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L2ARC ist die zweite Stufe des Caching-Systems von ZFS. Der Haupt-ARC wird im RAM abgelegt. Da die Menge an verfügbarem RAM meist begrenzt ist, kann ZFS auch <a href=#zfs-term-vdev-cache>cache vdevs</a> verwenden. Solid State Disks (SSDs) werden oft als diese Cache-Geräte eingesetzt, aufgrund ihrer höheren Geschwindigkeit und niedrigeren Latenz im Vergleich zu traditionellen drehenden Speichermedien wie Festplatten. Der Einsatz des L2ARC ist optional, jedoch wird durch die Verwendung eine signifikante Geschwindigkeitssteigerung bei Lesevorgängen bei Dateien erzielt, welche auf der SSD zwischengespeichert sind, anstatt von der regulären Platte gelesen werden zu müssen. L2ARC kann ebenfalls die <a href=#zfs-term-deduplication>Deduplizierung</a> beschleunigen, da eine DDT, welche nicht in den RAM passt, jedoch in den L2ARC wesentlich schneller sein wird als eine DDT, die von der Platte gelesen werden muss. Die Häufigkeit, in der Daten zum Cache-Gerät hinzugefügt werden, ist begrenzt, um zu verhindern, dass eine SSD frühzeitig durch zu viele Schreibvorgänge aufgebraucht ist. Bis der Cache voll ist (also der erste Block verdrängt wurde, um Platz zu schaffen), wird das Schreiben auf den L2ARC begrenzt auf die Summe der Schreibbegrenzung und das Bootlimit, sowie hinterher auf das Schreiblimit. Ein paar <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Werte steuert diese Limits. <a href=#zfs-advanced-tuning-l2arc_write_max><code>vfs.zfs.l2arc_write_max</code></a> steuert, wie viele Bytes in den Cache pro Sekunde geschrieben werden, während <a href=#zfs-advanced-tuning-l2arc_write_boost><code>vfs.zfs.l2arc_write_boost</code></a> zu diesem Limit während der "Turbo Warmup Phase" hinzuaddiert wird (Write Boost).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-zil></a>ZIL</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ZIL beschleunigt synchrone Transaktionen durch die Verwendung von Speichermedien wie SSDs, welche schneller sind als diejenigen, welche Teil des Speicherpools sind. Wenn eine Anwendung einen synchronen Schreibvorgang anfordert (eine Garantie, dass die Daten sicher auf den Platten gespeichert wurden anstatt nur zwischengespeichert zu sein, um später geschrieben zu werden), werden die Daten auf den schnelleren ZIL-Speicher geschrieben und dann später auf die regulären Festplatten. Dies reduziert die Latenz sehr und verbessert die Geschwindigkeit. Nur synchrone Vorgänge wie die von Datenbanken werden durch den Einsatz eines ZIL profitieren. Reguläre, asynchrone Schreibvorgänge wie das Kopieren von Dateien wird den ZIL überhaupt nicht verwenden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-cow></a>Copy-On-Write</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Im Gegensatz zu traditionellen Dateisystemen werden beim Überschreiben von Daten bei ZFS die neuen Daten an einen anderen Block geschrieben, anstatt die alten Daten an der gleichen Stelle zu überschreiben. Nur wenn dieser Schreibvorgang beendet wurde, werden die Metadaten aktualisiert, um auf die neue Position zu verweisen. Im Falle eines kurzen Schreibvorgangs (ein Systemabsturz oder Spannungsverlust während eine Datei geschrieben wird) sind die gesamten Inhalte der Originaldatei noch vorhanden und der unvollständige Schreibvorgang wird verworfen. Das bedeutet auch, dass ZFS nach einem unvorhergesehenen Ausfall keinen <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> benötigt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-dataset></a>Dataset</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><em>Dataset</em> ist der generische Begriff für ein ZFS-Dateisystem, Volume, Schnappschüsse oder Klone. Jedes Dataset besitzt einen eindeutigen Namen in der Form <em>poolname/path@snapshot</em> Die Wurzel des Pools ist technisch gesehen auch ein Dataset. Kind-Datasets werden hierarchisch wie Verzeichnisse benannt. Beispielsweise ist <em>mypool/home</em> das Heimatdataset, ein Kind von <em>mypool</em> und erbt die Eigenschaften von diesem. Dies kann sogar noch erweitert werden durch das Erstellen von <em>mypool/home/user</em>. Dieses Enkelkind-Dataset wird alle Eigenschaften von den Eltern und Großeltern erben. Eigenschaften auf einem Kind können die geerbten Standardwerte der Eltern und Großeltern ändern und überschreiben. Die Verwaltung von Datasets und dessen Kindern lässt sich <a href=#zfs-zfs-allow>delegieren</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-filesystem></a>Dateisystem</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein ZFS-Dataset wird meistens als ein Dateisystem verwendet. Wie jedes andere Dateisystem kann auch ein ZFS-Dateisystem irgendwo in der Verzeichnishierarchie eingehängt werden und enthält seine eigenen Dateien und Verzeichnisse mit Berechtigungen, Flags und anderen Metadaten.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-volume></a>Volume</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zusätzlich zu regulären Dateisystem-Datasets, kann ZFS auch Volumes erstellen, die Blockgeräte sind. Volumes besitzen viele der gleichen Eigenschaften, inklusive copy-on-write, Schnappschüsse, Klone und Prüfsummen. Volumes sind nützlich, um andere Dateisystemformate auf ZFS aufzusetzen, so wie UFS Virtualisierung, oder das Exportieren von iSCSI-Abschnitten.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-snapshot></a>Snapshot (Schnappschuss)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das <a href=#zfs-term-cow>copy-on-write</a> (COW)-Entwicklung von ZFS erlaubt das Erstellen von beinahe sofortigen, konsistenten Schnappschüssen mit beliebigen Namen. Nachdem ein Schnappschuss von einem Dataset angelegt oder ein rekursiver Schnappschuss eines Elterndatasets, welcher alle Kinddatasets enthält, erstellt wurde, werden neue Daten auf neue Blöcke geschrieben, jedoch die alten Blöcke nicht wieder als freier Speicher zurückgewonnen. Der Schnappschuss enthält die Originalversion des Dateisystems und das aktive Dateisystem besitzt alle Änderungen, die seit dem Schnappschuss erstellt wurden. Kein zusätzlicher Platz wird benötigt. Werden neue Daten auf das aktive Dateisystem geschrieben, werden neue Blöcke allokiert, um diese Daten zu speichern. Die scheinbare Größe des Schnappschusses wird wachsen, da die Blöcke nicht mehr länger im aktiven Dateisystem, sondern nur noch im Schnappschuss Verwendung finden. Diese Schnappschüsse können nur lesend eingehängt werden, um vorherige Versionen von Dateien wiederherzustellen. Ein <a href=#zfs-zfs-snapshot>rollback</a> eines aktiven Dateisystems auf einen bestimmten Schnappschuss ist ebenfalls möglich, was alle Änderungen, die seit dem Anlegen des Schnappschusses vorgenommen wurden, wieder Rückgängig macht. Jeder Block im Pool besitzt einen Referenzzähler, der verfolgt, wieviele Schnappschüsse, Klone, Datasets oder Volumes diesen Block nutzen. Wenn Dateien und Schnappschüsse gelöscht werden, verringert dies auch den Referenzzähler. Wenn ein Block nicht mehr länger referenziert wird, kann er als freier Speicher wieder genutzt werden. Schnappschüsse können auch mit <a href=#zfs-zfs-snapshot>hold</a> markiert werden. Wenn versucht wird, einen solchen Schnappschuss zu zerstören, wird stattdessen ein <code>EBUSY</code>-Fehler ausgegeben. Jeder Schnappschuss kann mehrere holds besitzen, jeder mit einem eindeutigen Namen. Das Kommando <a href=#zfs-zfs-snapshot>release</a> entfernt diese, damit der Schnappschuss gelöscht werden kann. Schnappschüsse lassen sich auf Volumes ebenfalls anlegen, allerdings können diese nur geklont oder zurückgerollt werden, nicht jedoch unabhängig eingehängt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-clone></a>Clone (Klone)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Schnappschüsse können auch geklont werden. Ein Klon stellt eine veränderbare Version eines Schnappschusses dar, was es ermöglicht, das Dateisystem als neues Dataset aufzuspalten. Genau wie bei einem Schnappschuss verbraucht ein Klon keinen zusätzlichen Platz. Wenn neue Daten auf einen Klon geschrieben und neue Blöcke allokiert werden, wächst auch die Größe des Klons. Wenn Blöcke im geklonten Dateisystem oder Volume überschrieben werden, verringert sich auch der Referenzzähler im vorherigen Block. Der Schnappschuss, auf dem der Klon basiert kann nicht gelöscht werden, weil der Klon darauf eine Abhängigkeit besitzt. Der Schnappschuss stellt den Elternteil dar und der Klon das Kind. Klone lassen sich <em>promoted</em> (befördern), was die Abhängigkeit auflöst und den Klon zum Elternteil macht und den vorherigen Elternteil das Kind. Diese Operation benötigt keinen zusätzlichen Plattenplatz. Da die Menge an verwendetem Speicher vom Elternteil und dem Kind vertauscht wird, betrifft dies eventuell vorhandene Quotas und Reservierungen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-checksum></a>Checksum (Prüfsumme)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Jeder Block, der allokiert wird erhält auch eine Prüfsumme. Der verwendete Prüfsummenalgorithmus ist eine Eigenschaft jedes Datasets, siehe dazu <a href=#zfs-zfs-set><code>set</code></a>. Die Prüfsumme jedes Blocks wird transparent validiert wenn er gelesen wird, was es ZFS ermöglicht, stille Verfälschung zu entdecken. Wenn die gelesenen Daten nicht mit der erwarteten Prüfsumme übereinstimmen, wird ZFS versuchen, die Daten aus jeglicher verfügbarer Redundanz (wie Spiegel oder RAID-Z) zu rekonstruieren. Eine Überprüfung aller Prüfsummen kann durch das Kommando <a href=#zfs-term-scrub><code>scrub</code></a> ausgelöst werden. Prüfsummenalgorithmen sind:</p><p class=tableblock>* <code>fletcher2</code>
* <code>fletcher4</code>
* <code>sha256</code>
Die <code>fletcher</code>-Algorithmen sind schneller, aber dafür ist <code>sha256</code> ein starker kryptographischer Hash und besitzt eine viel niedrigere Chance auf Kollisionen zu stoßen mit dem Nachteil geringerer Geschwindigkeit. Prüfsummen können deaktiviert werden, dies wird aber nicht empfohlen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-compression></a>Compression</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Jedes Dataset besitzt eine compression-Eigenschaft, die standardmäßig ausgeschaltet ist. Diese Eigenschaft kann auf eine Reihe von Kompressionsalgorithmen eingestellt werden. Dadurch werden alle neuen Daten, die auf das Dataset geschrieben werden, komprimiert. Neben einer Reduzierung von verbrauchtem Speicher wird oft der Lese- und Schreibdurchsatz erhöht, weil weniger Blöcke gelesen oder geschrieben werden müssen.</p><p class=tableblock><a id=zfs-term-compression-lz4></a>* <em>LZ4</em> - Wurde in der ZFS Poolversion 5000 (feature flags) hinzugefügt und LZ4 ist jetzt der empfohlene Kompressionsalgorithmus. LZ4 komprimiert ungefähr 50% schneller als LZJB, wenn er auf komprimierbaren Daten angewendet wird und ist über dreimal schneller, wenn unkomprimierbare Daten vorliegen. LZ4 entkomprimiert auch ungefähr 80% schneller als LZJB. Auf modernen CPUs, kann LZ4 oft über 500 MB/s komprimieren und entkomprimiert (pro einzelnem CPU-Kern) bei über 1.5 GB/s.
<a id=zfs-term-compression-lzjb></a>* <em>LZJB</em> - Der Standardkompressionsalgorithmus wurde von Jeff Bonwick, einem der ursprünglichen Entwickler von ZFS, entworfen. LZJB bietet gute Komprimierung mit weniger CPU-Überhang im Vergleich zu GZIP. In der Zukunft wird der Standardkompressionsalgorithmus wahrscheinlich auf LZ4 gewechselt.
<a id=zfs-term-compression-gzip></a>* <em>GZIP</em> - Ein populärer Stromkompressionsalgorithmus ist auch in ZFS verfügbar. Einer der Hauptvorteile von der Verwendung von GZIP ist seine konfigurierbare Komprimierungsstufe. Wenn die Eigenschaft <code>compress</code> gesetzt wird, kann der Administrator die Stufe der Komprimierung wählen, die von <code>gzip1</code>, der kleinsten Komprimierungsstufe, bis zu <code>gzip9</code>, der höchsten Komprimierungsstufe, reicht. Dies erlaubt es dem Administrator zu steuern, wieviel CPU-Zeit für eingesparten Plattenplatz eingetauscht werde soll.
<a id=zfs-term-compression-zle></a>* <em>ZLE</em> - Zero Length Encoding ist ein besonderer Kompressionsalgorithmus, welcher nur fortlaufende Aneinanderreihungen von Nullen komprimiert. Dieser Komprimierungsalgorithmus ist nur sinnvoll, wenn das Dataset viele große Blöcke von Nullen aufweist.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-copies></a>Copies</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Wenn die Eigenschaft <code>copies</code> auf einen Wert grösser als 1 gesetzt wird, weist das ZFS an, mehrere Kopien eines Blocks im <a href=#zfs-term-filesystem>Dateisystem</a> oder <a href=#zfs-term-volume>Volume</a> anzulegen. Diese Eigenschaft auf einem wichtigen Dataset einzustellen sorgt für zusätzliche Redundanz, aus der ein Block wiederhergestellt werden kann, der nicht mehr mit seiner Prüfsumme übereinstimmt. In Pools ohne Redundanz ist die copies-Eigenschaft die einzige Form von Redundanz. Die Eigenschaft kann einen einzelnen schlechten Sektor oder andere Formen von kleineren Verfälschungen wiederherstellen, schützt jedoch nicht den Pool vom Verlust einer gesamten Platte.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-deduplication></a>Deduplizierung</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Prüfsummen ermöglichen es, Duplikate von Blöcken zu erkennen, wenn diese geschrieben werden. Mit Deduplizierung erhöht sich der Referenzzähler eines existierenden, identischen Blocks, was Speicherplatz einspart. Um Blockduplikate zu erkennen, wird im Speicher eine Deduplizierungstabelle (DDT) geführt. Die Tabelle enthält eine Liste von eindeutigen Prüfsummen, die Position dieser Blöcke und einen Referenzzähler. Werden neue Daten geschrieben, wird die Prüfsumme berechnet und mit der Liste verglichen. Wird eine Übereinstimmung gefunden, wird der existierende Block verwendet. Der SHA256-Prüfsummenalgorithmus wird mit Deduplizierung benutzt, um einen sicheren kryptographischen Hash zu bieten. Deduplizierung lässt sich konfigurieren. Wenn <code>dedup</code> auf <code>on</code> steht, wird angenommen, dass eine übereinstimmende Prüfsumme bedeutet, dass die Daten identisch sind. Steht <code>dedup</code> auf <code>verify</code>, werden die Daten in den beiden Blöcken Byte für Byte geprüft, um sicherzustellen, dass diese wirklich identisch sind. Wenn die Daten nicht identisch sind, wird die Kollision im Hash vermerkt und die beiden Blöcke separat gespeichert. Da die DDT den Hash jedes einzigartigen Blocks speichern muss, benötigt sie eine große Menge an Speicher. Eine generelle Faustregel besagt, dass 5-6 GB RAM pro 1 TB deduplizierter Daten benötigt werden. In Situationen, in denen es nicht praktikabel ist, genug RAM vorzuhalten, um die gesamte DDT im Speicher zu belassen, wird die Geschwindigkeit stark darunter leiden, da die DDT von der Platte gelesen werden muss, bevor jeder neue Block geschrieben wird. Deduplizierung kann den L2ARC nutzen, um die DDT zu speichern, was einen guten Mittelweg zwischen schnellem Systemspeicher und langsameren Platten darstellt. Bedenken Sie, dass durch die Verwendung von Komprimierung meistens genauso große Platzersparnis möglich ist, ohne den zusätzlichen Hauptspeicherplatzbedarf.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-scrub></a>Scrub (Bereinigung)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Anstatt einer Konsistenzprüfung wie <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> verwendet ZFS <code>scrub</code>. <code>scrub</code> liest alle Datenblöcke, die auf dem Pool gespeichert sind und prüft deren Prüfsumme gegen die als richtig in den Metadaten gespeicherte Prüfsumme. Eine periodische Prüfung aller im Pool gespeicherten Daten versichert, dass verfälschte Blöcke rekonstruiert werden können, bevor dies nötig ist. Ein Scrub wird nicht nach einem unsauberen Herunterfahren benötigt, wird jedoch einmal alle drei Monate angeraten. Die Prüfsumme von jedem Block wird verifiziert, wenn Blöcke während des normalen Betriebs gelesen werden, jedoch stellt ein Scrub sicher, dass sogar weniger häufig verwendete Blöcke auf stille Verfälschungen hin untersucht werden. Datenintegrität wird dadurch erhöht, besonders wenn es sich um Archivspeichersituationen handelt. Die relative Priorität des <code>scrub</code> lässt sich mit <a href=#zfs-advanced-tuning-scrub_delay><code>vfs.zfs.scrub_delay</code></a> anpassen, um zu verhindern, dass der scrub die Geschwindigkeit von anderen Anfragen auf dem Pool beeinträchtigt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-quota></a>Dataset Quotas</p></td><td class="tableblock halign-left valign-top"><div class=content><div class=paragraph><p>ZFS bietet sehr schnelle und akkurate Dataset-, Benutzer- und Gruppenspeicherplatzbuchhaltung, zusätzlich zu Quotas und Speicherplatzreservierungen. Dies gibt dem Administrator feingranulare Kontrolle darüber, wie Speicherplatz allokiert und die Reservierung für kritische Dateisysteme vorgenommen wird</p></div><div class=paragraph><p>ZFS unterstützt verschiedene Arten von Quotas: die Dataset-Quota, die <a href=#zfs-term-refquota>Referenzquota (refquota)</a>, die <a href=#zfs-term-userquota>Benutzerquota</a> und die <a href=#zfs-term-groupquota>Gruppenquota</a> sind verfügbar.</p></div><div class=paragraph><p>Quotas beschränken die Menge an Speicherplatz, welche ein Dataset, seine Kinder, einschließlich Schnappschüsse des Datasets, deren Kinder und die Schnappschüsse von diesen Datasets, verbrauchen können.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quotas können nicht auf Volumes gesetzt werden, da die Eigenschaft <code>volsize</code> als eine implizite Quota agiert.</p></div></td></tr></tbody></table></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-refquota></a>Referenzquota</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein Referenzquota beschränkt die Menge an Speicherplatz, die ein Dataset verbrauchen kann durch das Erzwingen einer harten Grenze. Jedoch beinhaltet diese harte Grenze nur Speicherplatz, die das Dataset referenziert und beinhaltet nicht den Speicher, der von Kindern, wie Dateisystemen oder Schnappschüssen, verbraucht wird.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-userquota></a>Benutzerquota</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Benutzerquotas sind hilfreich, um die Menge an Speicherplatz, die ein bestimmter Benutzer verbrauchen kann, einzuschränken.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-groupquota></a>Gruppenquota</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die Gruppenquota beschränkt die Menge an Speicherplatz, die eine bestimmte Gruppe verbrauchen darf.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-reservation></a>Dataset-Reservierung</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die Eigenschaft <code>reservation</code> ermöglicht es, ein Minimum an Speicherplatz für ein bestimmtes Dataset und dessen Kinder zu garantieren. Wenn eine Reservierung von 10 GB auf <span class=filename>storage/home/bob</span> gesetzt ist und ein anderes Dataset versucht, allen freien Speicherplatz zu verwenden, bleiben zumindest noch 10 GB an Speicher reserviert. Wenn von <span class=filename>storage/home/bob</span> ein Schnappschuss angelegt wird, wird dieser von der Reservierung abgezogen und zählt damit dagegen. Die Eigenschaft <a href=#zfs-term-refreservation><code>refreservation</code></a> funktioniert auf ähnliche Weise, jedoch <em>exkludiert</em> diese Kinder wie Schnappschüsse.</p><p class=tableblock>Reservierungen jeder Art sind in vielen Situationen nützlich, so wie bei der Planung und dem Testen der richtigen Speicherplatzallokation in einem neuen System oder durch die Zusicherung, dass genug Speicherplatz auf Dateisystemen für Audio-Logs oder Systemwiederherstellungsprozeduren und Dateien verfügbar ist.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-refreservation></a>Referenzreservierung</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die Eigenschaft <code>refreservation</code> ermöglicht es, ein Minimum an Speicherplatz für die Verwendung eines bestimmten Datasets zu garantieren, <em>exklusiv</em> dessen Kinder. Das bedeutet, dass wenn eine 10 GB-Reservierung auf <span class=filename>storage/home/bob</span> vorhanden ist und ein anderes Dataset versucht, alle freien Speicherplatz aufzubrauchen, sind zumindest noch 10 GB Speicher reserviert. Im Gegensatz zu einer regulären <a href=#zfs-term-reservation>Reservierung</a> wird der Speicher von Schnappschüssen und Kinddataset nicht gegen die Reservierung gezählt. Beispielsweise, wenn ein Schnappschuss von <span class=filename>storage/home/bob</span> angelegt wird, muss genug Plattenplatz außerhalb der Menge an <code>refreservation</code> vorhanden sein, damit die Operation erfolgreich durchgeführt wird. Kinder des Hauptdatasets werden nicht in die Menge an <code>refreservation</code> gezählt und dringen auf diese Weise auch nicht in den gesetzten Speicher ein.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-resilver></a>Resilver</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Wenn eine Platte ausfällt und ersetzt wird, muss die neue Platte mit den Daten gefüllt werden, die verloren gegangen sind. Der Prozess der Verwendung der Paritätsinformationen, welche über die übrigen Platten verteilt sind, um die fehlenden Daten zu berechnen und auf die neue Platte zu übertragen, wird <em>resilvering</em> genannt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-online></a>Online</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein Pool oder vdev im Zustand <code>Online</code> besitzt alle verbundenen Mitgliedsgeräte und ist voll funktionsfähig. Individuelle Geräte im Zustand <code>Online</code> funktionieren normal.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-offline></a>Offline</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Individuelle Geräte lassen sich vom Administrator in den Zustand <code>Offline</code> versetzen, wenn es ausreichend Redundanz gibt, um zu verhindern, dass der Pool oder das vdev in den Zustand <a href=#zfs-term-faulted>Faulted</a> versetzt wird. Ein Administrator kann eine Platte vor einem Austausch offline nehmen oder um es leichter zu machen, diese zu identifizieren.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-degraded></a>Degraded</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein Pool oder vdev im Zustand <code>Degraded</code> hat eine oder mehrere Platten, welche getrennt wurden oder ausgefallen sind. Der Pool kann immer noch verwendet werden, doch wenn noch weitere Geräte ausfallen, kann der Pool nicht wiederhergestellt werden. Die fehlenden Geräte anzuschließen oder die defekten Platten zu ersetzen wird den Pool wieder in den Zustand <a href=#zfs-term-online>Online</a> versetzen, nachdem die angeschlossenen oder neuen Geräte den <a href=#zfs-term-resilver>Resilver</a>-Prozess abgeschlossen haben.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-faulted></a>Faulted</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein Pool oder vdev im Zustand <code>Faulted</code> funktioniert nicht länger. Die Daten darauf sind nicht mehr länger verfügbar. Ein Pool oder vdev geht in den Zustand <code>Faulted</code> über, wenn die Anzahl der fehlenden oder defekten Geräte die Redundanzstufe im vdev überschreiten. Wenn fehlende Geräte angeschlossen werden, geht der Pool wieder in den Zustand <a href=#zfs-term-online>Online</a>. Wenn es nicht genügend Redundanz gibt, um die Anzahl an defekten Platten zu kompensieren, sind die Inhalte des Pools verloren und müssen von der Sicherung wiederhergestellt werden.</p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=filesystems>Kapitel 38. Dateisystemunterstützung<a class=anchor href=#filesystems></a></h2><div class=sectionbody><div class=sect2><h3 id=filesystems-synopsis>38.1. Übersicht<a class=anchor href=#filesystems-synopsis></a></h3><div class=paragraph><p>Dateisysteme sind ein wesentlicher Bestandteil von Betriebssystemen. Sie erlauben es Benutzern, Dateien zu laden und zu speichern, ermöglichen den Zugriff auf Daten und machen Festplatten überhaupt erst nützlich. Betriebssysteme unterscheiden sich normalerweise bei dem mitgelieferten Dateisystem. Traditionell ist dies unter FreeBSD das Unix File System UFS, welches mit UFS2 modernisiert wurde. Seit FreeBSD 7.0 steht auch das Z-Dateisystem (ZFS) als natives Dateisystem zur Verfügung. Hierzu finden Sie in <a href=./#zfs>Das Z-Dateisystem (ZFS)</a> weitere Informationen.</p></div><div class=paragraph><p>FreeBSD unterstützt auch eine Vielzahl weiterer Dateisysteme, um auf Daten von anderen Betriebssystemen lokal zuzugreifen, beispielsweise Daten auf USB-Speichermedien, Flash-Speichern und Festplatten. Dazu gehört die Unterstützung für das Linux® Extended File System (EXT).</p></div><div class=paragraph><p>Es gibt verschiedene Stufen der Unterstützung in FreeBSD für diese unterschiedlichen Dateisysteme. Manche benötigen ein geladenes Kernelmodul, andere die Installation bestimmter Werkzeuge. Einige Dateisysteme haben volle Unterstützung für Lese- und Schreibzugriffe, während auf andere nur-lesend zugegriffen werden kann.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, wissen Sie:</p></div><div class=ulist><ul><li><p>Den Unterschied zwischen nativen und unterstützten Dateisystemen.</p></li><li><p>Welche Dateisysteme von FreeBSD unterstützt werden.</p></li><li><p>Wie man fremde Dateisysteme aktiviert, konfiguriert, darauf zugreift und diese verwendet.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>Grundlagen von UNIX® und FreeBSD verstehen (<a href=./#basics>Grundlagen des FreeBSD Betriebssystems</a>).</p></li><li><p>Mit den Grundlagen der Konfiguration und dem Bauen des Kernels vertraut sein (<a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a>).</p></li><li><p>Problemlos Software von Drittherstellern in FreeBSD installieren können (<a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a>).</p></li><li><p>Sich ein wenig mit Festplatten, Speicher und Gerätenamen in FreeBSD auskennen (<a href=./#disks>Speichermedien</a>).</p></li></ul></div></div><div class=sect2><h3 id=filesystems-linux>38.2. Linux® Dateisysteme<a class=anchor href=#filesystems-linux></a></h3><div class=paragraph><p>FreeBSD bietet integrierte Unterstützung für einige Linux®-Dateisysteme. Dieser Abschnitt demonstriert, wie der Support aktiviert und die unterstützten Linux®-Dateisysteme eingehangen werden.</p></div><div class=sect3><h4 id=_ext2>38.2.1. ext2<a class=anchor href=#_ext2></a></h4><div class=paragraph><p>Seit FreeBSD 2.2 ist eine Kernel-Unterstützung für das ext2-Dateisystem vorhanden. In FreeBSD 8.x und früheren Versionen wurde der Code noch unter der GPL lizensiert. Der Code wurde neu geschrieben und steht seit FreeBSD 9.0 unter der BSD-Lizenz.</p></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a>-Treiber erlaubt dem FreeBSD Kernel sowohl Lese-, als auch Schreibzugriffe auf ext2-Dateisysteme.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dieser Treiber kann auch für den Zugriff auf ext3 und ext4 Dateisysteme verwendet werden. Das Dateisystem <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> bietet ab FreeBSD 12.0-RELEASE volle Lese- und Schreibunterstützung für ext4. Darüber hinaus werden auch erweiterte Attribute und ACLs unterstützt, jedoch kein Journaling und Verschlüsselung. Ab FreeBSD 12.1-RELEASE ist auch ein DTrace Provider verfügbar. Frühere Versionen von FreeBSD können mit <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/fusefs-ext2/>sysutils/fusefs-ext2</a> auf ext4 im Lese- und Schreibmodus zugreifen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um auf ein ext-Dateisystem zuzugreifen, muss zuerst das entsprechende Kernelmodul geladen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ext2fs</span></code></pre></div></div><div class=paragraph><p>Mounten Sie anschließend das ext-Volume unter Angabe des FreeBSD Partitionsnamens und eines existierenden Mountpunktes. Dieses Beispiel hängt <span class=filename>/dev/ad1s1</span> nach <span class=filename>/mnt</span> ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t ext2fs /dev/ad1s1 /mnt</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=virtualization>Kapitel 39. Virtualisierung<a class=anchor href=#virtualization></a></h2><div class=sectionbody><div class=sect2><h3 id=virtualization-synopsis>39.1. Übersicht<a class=anchor href=#virtualization-synopsis></a></h3><div class=paragraph><p>Virtualisierungssoftware erlaubt es, mehrere Betriebssysteme gleichzeitig auf dem selben Computer laufen zu lassen. Derartige Softwaresysteme für PCs setzen in der Regel ein Host-Betriebssystem voraus, auf dem die Virtualisierungssoftware läuft und unterstützen eine nahezu beliebige Anzahl von Gast-Betriebssystemen.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben,</p></div><div class=ulist><ul><li><p>Kennen Sie den Unterscheid zwischen einem Host-Betriebssystem und einem Gast-Betriebssystem.</p></li><li><p>Können Sie FreeBSD auf einem Intel®-basierenden Apple® Mac® installieren.</p></li><li><p>Können Sie FreeBSD unter Microsoft® Windows® und Virtual PC installieren.</p></li><li><p>Wissen Sie, wie man ein virtualisiertes FreeBSD-System für optimale Leistung konfiguriert.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie</p></div><div class=ulist><ul><li><p>Die <a href=./#basics>Grundlagen von UNIX® und FreeBSD</a> verstehen.</p></li><li><p>Wissen, wie Sie <a href=./#bsdinstall>FreeBSD installieren</a> können.</p></li><li><p>Wissen, wie Sie eine <a href=./#advanced-networking>Netzwerkverbindung konfigurieren</a>.</p></li><li><p>Wissen, wie Sie <a href=./#ports>zusätzliche Software installieren</a> können.</p></li></ul></div></div><div class=sect2><h3 id=virtualization-guest-parallels>39.2. FreeBSD als Gast-Betriebssystem unter Parallels für Mac OS® X<a class=anchor href=#virtualization-guest-parallels></a></h3><div class=paragraph><p>Parallels Desktop für Mac® ist ein kommerzielles Softwareprodukt, welches für Intel®-basierende Apple® Mac®-Computer mit Mac OS® X 10.4.6 oder höher verfügbar ist. FreeBSD wird von diesem Softwarepaket als Gast-Betriebssystem vollständig unterstützt. Nach der Installation von Parallels auf Mac OS® X konfigurieren Sie als erstes eine virtuelle Maschine, in der Sie danach das gewünschte Gast-Betriebssystem (in diesem Fall FreeBSD) installieren.</p></div><div class=sect3><h4 id=virtualization-guest-parallels-install>39.2.1. Installation von FreeBSD unter Parallels/Mac OS® X<a class=anchor href=#virtualization-guest-parallels-install></a></h4><div class=paragraph><p>Der erste Schritt bei der Installation von FreeBSD unter Parallels ist es, eine virtuelle Maschine zu konfigurieren, in der Sie FreeBSD installieren können. Dazu wählen Sie bei der Frage nach dem <b class=menuref>Guest OS Type</b><span class=guimenuitem>FreeBSD</span> aus:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd1.png alt="parallels freebsd1"></div></div><div class=paragraph><p>Legen Sie geeignete Größen für Festplatten- und Arbeitsspeicher für die zu erstellende FreeBSD-Instanz fest. 4 GB Plattenplatz sowie 512 MB RAM sind in der Regel für die Arbeit unter Parallels ausreichend:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd2.png alt="parallels freebsd2"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd3.png alt="parallels freebsd3"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd4.png alt="parallels freebsd4"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd5.png alt="parallels freebsd5"></div></div><div class=paragraph><p>Wählen Sie den gewünschten Netzwerktyp aus und konfigurieren Sie die Netzwerkverbindung:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd6.png alt="parallels freebsd6"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd7.png alt="parallels freebsd7"></div></div><div class=paragraph><p>Speichern Sie Ihre Eingaben, um die Konfiguration abzuschließen:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd8.png alt="parallels freebsd8"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd9.png alt="parallels freebsd9"></div></div><div class=paragraph><p>Nachdem Sie die virtuelle Maschine erstellt haben, installieren Sie im nächsten Schritt FreeBSD in dieser virtuellen Maschine. Dazu verwenden Sie am besten eine offizielle FreeBSD-CD/DVD oder Sie laden von einem offiziellen FTP-Server ein ISO-Abbild auf Ihren Mac® herunter. Danach klicken Sie auf das Laufwerksymbol in der rechten unteren Ecke des Parallels-Fensters, um das virtuelles Laufwerk mit dem ISO-Abbild oder mit dem physikalischen CD-ROM-Laufwerk des Computers zu verknüpfen.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd11.png alt="parallels freebsd11"></div></div><div class=paragraph><p>Nachdem Sie diese Verknüpfung hergestellt haben, starten sie die virtuelle FreeBSD-Maschine neu, indem Sie auf das Symbol "Neustarten" klicken. Parallels startet nun ein Spezial-BIOS, das zuerst prüft, ob eine CD-ROM eingelegt wurde.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd10.png alt="parallels freebsd10"></div></div><div class=paragraph><p>In diesem Fall findet das BIOS ein FreeBSD-Installationsmedium und beginnt eine normale Installation. Versuchen Sie jetzt noch nicht Xorg zu konfigurieren.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd12.png alt="parallels freebsd12"></div></div><div class=paragraph><p>Nachdem die Installation abgeschlossen ist, können Sie die virtuelle FreeBSD-Maschine starten.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd13.png alt="parallels freebsd13"></div></div></div><div class=sect3><h4 id=virtualization-guest-parallels-configure>39.2.2. FreeBSD für den Einsatz unter Parallels konfigurieren<a class=anchor href=#virtualization-guest-parallels-configure></a></h4><div class=paragraph><p>Nachdem FreeBSD erfolgreich unter Mac OS® X mit Parallels installiert wurde, sollten Sie das virtuelle FreeBSD-System für virtualisierte Operationen optimieren:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Setzen der Bootloader-Variablen</p><div class=paragraph><p>Die wichtigste Änderung ist es, die Variable <code>kern.hz</code> zu verkleinern, um so die CPU-Auslastung in der Parallels-Umgebung zu verringern.</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Ohne diese Einstellung kann ein unbeschäftigtes FreeBSD unter Parallels trotzdem rund 15 Prozent der CPU-Leistung eines Single Prozessor iMac®'s verbrauchen. Nach dieser Änderung reduziert sich dieser Wert auf etwa 5 Prozent.</p></div></li><li><p>Erstellen einer neuen Kernelkonfigurationsdatei</p><div class=paragraph><p>Sie können alle SCSI-, FireWire- und USB-Laufwerks-Treiber entfernen. Parallels stellt einen virtuellen Netzwerkadapter bereit, der den <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a>-Treiber verwendet. Daher können alle Netzwerkgeräte bis auf <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> aus dem Kernel entfernt werden.</p></div></li><li><p>Netzwerkbetrieb einrichten</p><div class=paragraph><p>Die einfachste Netzwerkkonfiguration ist der Einsatz von DHCP, um die virtuelle Maschine mit dem gleichen lokalen Netzwerk, in dem sich der Host-Mac® befindet, zu verbinden. Dazu fügen Sie die Zeile <code>ifconfig_ed0="DHCP"</code> in <span class=filename>/etc/rc.conf</span> ein. Weitere Informationen zur Konfiguration des Netzwerks unter FreeBSD finden Sie im <a href=./#advanced-networking>Netzwerkverbindung konfigurieren</a>.</p></div></li></ol></div></div></div><div class=sect2><h3 id=virtualization-guest-virtualpc>39.3. FreeBSD als Gast-Betriebssystem unter Virtual PC für Windows®<a class=anchor href=#virtualization-guest-virtualpc></a></h3><div class=paragraph><p>Virtual PC für Windows® wird von Microsoft® kostenlos zum Download angeboten. Die Systemanforderungen für dieses Programm finden Sie <a href=http://www.microsoft.com/windows/downloads/virtualpc/sysreq.mspx>hier</a>. Nachdem Virtual PC unter Microsoft® Windows® installiert wurde, muss eine virtuelle Maschine konfiguriert und das gewünschte Betriebssystem installiert werden.</p></div><div class=sect3><h4 id=virtualization-guest-virtualpc-install>39.3.1. FreeBSD in Virtual PC installieren<a class=anchor href=#virtualization-guest-virtualpc-install></a></h4><div class=paragraph><p>Der erste Schritt zur Installation von FreeBSD in Virtual PC ist es, eine neue virtuelle Maschine zu erstellen, in die Sie FreeBSD installieren können. Dazu wählen Sie die Option <span class=guimenuitem>Create a virtual machine</span>, wenn Sie danach gefragt werden:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd1.png alt="virtualpc freebsd1"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd2.png alt="virtualpc freebsd2"></div></div><div class=paragraph><p>Bei der Frage nach dem <span class=guimenuitem>Operating system</span> wählen Sie <span class=guimenuitem>Other</span>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd3.png alt="virtualpc freebsd3"></div></div><div class=paragraph><p>Danach müssen Sie den gewünschten Plattenplatz sowie die Größe des Hauptspeichers angeben. 4 GB Plattenplatz sowie 512 MB RAM sollten für die Installation von FreeBSD in Virtual PC ausreichend sein:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd4.png alt="virtualpc freebsd4"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd5.png alt="virtualpc freebsd5"></div></div><div class=paragraph><p>Speichern Sie die Eingaben und beenden Sie die Konfiguration:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd6.png alt="virtualpc freebsd6"></div></div><div class=paragraph><p>Wählen Sie nun die für FreeBSD erstellte virtuelle Maschine aus und klicken Sie auf <b class=menuref>Settings</b>, um das Netzwerk zu konfigurieren:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd7.png alt="virtualpc freebsd7"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd8.png alt="virtualpc freebsd8"></div></div><div class=paragraph><p>Nachdem die virtuelle Maschine erstellt wurde, können Sie FreeBSD installieren. Dazu verwenden Sie am besten eine offizielle FreeBSD-CD/DVD oder ein ISO-Image, das Sie von einem offiziellen FreeBSD-FTP-Server heruntergeladen haben. Wenn Sie ein ISO-Image auf der Festplatte gespeichert haben, oder eine FreeBSD-CD/DVD in das Laufwerk eingelegt haben, doppelklicken Sie auf die virtuelle Maschine, die Sie für FreeBSD angelegt haben. Danach klicken Sie auf <b class=menuref>CD</b> und wählen die Option <b class=menuref>Capture ISO Image…​</b> im Virtual PC-Fenster. Danach können Sie im folgenden Fenster das CD-Laufwerk mit dem physikalischen CD-Laufwerk oder mit dem ISO-Image verknüpfen.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd9.png alt="virtualpc freebsd9"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd10.png alt="virtualpc freebsd10"></div></div><div class=paragraph><p>Danach starten Sie die virtuelle Maschine neu, indem Sie zuerst auf <b class=menuref>Action</b> und danach auf <b class=menuref>Reset</b> klicken. Virtual PC startet die virtuelle Maschine nun neu und prüft zuerst, ob die virtuelle Maschine über ein CD-Laufwerk verfügt.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd11.png alt="virtualpc freebsd11"></div></div><div class=paragraph><p>Da dies hier der Fall ist, beginnt nun eine normale FreeBSD-Installation. Sie können FreeBSD nun installieren, aber verzichten Sie an dieser Stelle unbedingt auf die Xorg-Konfiguration.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd12.png alt="virtualpc freebsd12"></div></div><div class=paragraph><p>Nachdem die Installation abgeschlossen ist, entfernen Sie die CD/DVD aus dem Laufwerk (oder lösen die Verknüpfung zum ISO-Image). Danach starten Sie die virtuelle Maschine neu, um FreeBSD zu starten.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd13.png alt="virtualpc freebsd13"></div></div></div><div class=sect3><h4 id=virtualization-guest-virtualpc-configure>39.3.2. FreeBSD in Virtual PC konfigurieren<a class=anchor href=#virtualization-guest-virtualpc-configure></a></h4><div class=paragraph><p>Nachdem FreeBSD auf Microsoft® Windows® mit Virtual PC erfolgreich installiert wurde, sollten Sie das virtuelle FreeBSD noch anpassen, um eine optimale Funktion zu gewährleisten.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Setzen der Bootloader-Variablen</p><div class=paragraph><p>Die wichtigste Änderung ist es, die Variable <code>kern.hz</code> zu verkleinern, um so die CPU-Auslastung in der Virtual PC-Umgebung zu verringern. Dazu fügen Sie die folgende Zeile in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Ohne diese Einstellung kann ein unbeschäftigtes FreeBSD unter Virutal PC trotzdem rund 40 Prozent der CPU-Leistung eines Ein-Prozessor-Systems verbrauchen. Nach dieser Änderung reduziert sich dieser Wert auf etwa 3 Prozent.</p></div></li><li><p>Erstellen einer neuen Kernelkonfigurationsdatei</p><div class=paragraph><p>Alle SCSI-, FireWire- und USB-Laufwerks-Treiber können aus der Kernelkonfigurationsdatei entfernt werden. Virtual PC stellt einen virtuellen Netzwerkadapter bereit, der den <a href="https://man.freebsd.org/cgi/man.cgi?query=de&amp;sektion=4&amp;format=html">de(4)</a>-Treiber verwendet. Daher können alle Netzwerkgeräte bis auf <a href="https://man.freebsd.org/cgi/man.cgi?query=de&amp;sektion=4&amp;format=html">de(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> aus dem Kernel entfernt werden.</p></div></li><li><p>Das Netzwerk einrichten</p><div class=paragraph><p>Die einfachste Netzwerkkonfiguration nutzt von DHCP, um die virtuelle Maschine mit dem gleichen lokalen Netzwerk, in dem sich der Host-Microsoft® Windows® befindet, zu verbinden. Dazu fügen Sie die Zeile <code>ifconfig_de0="DHCP"</code> in <span class=filename>/etc/rc.conf</span> ein. Weitere Informationen zur Konfiguration des Netzwerks unter FreeBSD finden Sie in <a href=./#advanced-networking>Netzwerkverbindung konfigurieren</a>.</p></div></li></ol></div></div></div><div class=sect2><h3 id=virtualization-guest-vmware>39.4. FreeBSD als Gast-Betriebssystem unter VMware Fusion für Mac OS®<a class=anchor href=#virtualization-guest-vmware></a></h3><div class=paragraph><p>VMware Fusion für Mac® ist ein kommerzielles Programm, das für Intel® basierte Apple® Mac®-Computer mit Mac OS® 10.4.9 oder neuer erhältlich ist. FreeBSD wird von diesem Produkt vollständig als Gast-Betriebssystem unterstützt. Nachdem Sie VMware Fusion unter Mac OS® X installiert haben, können Sie eine virtuelle Maschine konfigurieren und das gewünschte Gastbetriebssystem installieren.</p></div><div class=sect3><h4 id=virtualization-guest-vmware-install>39.4.1. FreeBSD in VMware Fusion installieren<a class=anchor href=#virtualization-guest-vmware-install></a></h4><div class=paragraph><p>Zuerst müssen Sie VMware Fusion starten, um eine virtuelle Maschine zu erstellen. Dazu wählen Sie die Option <span class=guimenuitem>New</span>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd01.png alt="vmware freebsd01"></div></div><div class=paragraph><p>Dadurch wird ein Assistent gestartet, der bei der Erzeugung einer neuen virtuellen Maschine behilflich ist. Klicken Sie auf <span class=guimenuitem>Continue</span>, um den Prozess zu starten:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd02.png alt="vmware freebsd02"></div></div><div class=paragraph><p>Wählen Sie <span class=guimenuitem>Other</span> als das <span class=guimenuitem>Operating System</span>, danach <span class=guimenuitem>FreeBSD</span> oder <span class=guimenuitem>FreeBSD 64-bit</span>, je nach dem, welche Version Sie installieren wollen, wenn Sie nach der zu installierenden <b class=menuref>Version</b> gefragt werden:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd03.png alt="vmware freebsd03"></div></div><div class=paragraph><p>Vergeben Sie einen Namen für die virtuelle Maschine und legen Sie den Speicherort fest:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd04.png alt="vmware freebsd04"></div></div><div class=paragraph><p>Legen Sie die Größe der virtuellen Festplatte für die virtuelle Maschine fest:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd05.png alt="vmware freebsd05"></div></div><div class=paragraph><p>Wählen Sie die Installationsmethode für die virtuelle Maschine. Entweder von einem ISO-Abbild oder von einer CD/DVD:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd06.png alt="vmware freebsd06"></div></div><div class=paragraph><p>Nachdem Sie auf <span class=guimenuitem>Finish</span> geklickt haben, wird die virtuelle Maschine gestartet:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd07.png alt="vmware freebsd07"></div></div><div class=paragraph><p>Nun können Sie FreeBSD wie gewohnt installieren:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd08.png alt="vmware freebsd08"></div></div><div class=paragraph><p>Nachdem die Installation abgeschlossen ist, können noch verschiedene Parameter der virtuellen Maschine, wie etwa der Speicherverbrauch, konfiguriert werden:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Hardware der virtuellen Maschine kann nicht geändert werden, solange die virtuelle Maschine läuft.</p></div></td></tr></tbody></table></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd09.png alt="vmware freebsd09"></div></div><div class=paragraph><p>Die Anzahl der CPUs der virtuellen Maschine:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd10.png alt="vmware freebsd10"></div></div><div class=paragraph><p>Den Status des CD-Laufwerks. Sie können die CD/DVD/ISO von der virtuellen Maschine lösen, wenn Sie es nicht benötigen.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd11.png alt="vmware freebsd11"></div></div><div class=paragraph><p>Zuletzt sollten Sie noch festlegen, wie sich die virtuelle Maschine mit dem Netzwerk verbinden soll. Sollen neben dem Gastsystem auch andere Rechner auf die virtuelle Maschine zugreifen können, muss die Option <span class=guimenuitem>Connect directly to the physical network (Bridged)</span> gewählt werden. Ist dies nicht der Fall, sollte die Option <span class=guimenuitem>Share the host’s internet connection (NAT)</span> gewählt werden. In dieser Einstellung kann die virtuelle Maschine zwar auf das Internet zugreifen, andere Rechner dürfen aber nicht auf die virtuelle Maschine zugreifen.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd12.png alt="vmware freebsd12"></div></div><div class=paragraph><p>Nachdem die Konfiguration abgeschlossen ist, kann FreeBSD gestartet werden.</p></div></div><div class=sect3><h4 id=virtualization-guest-vmware-configure>39.4.2. FreeBSD unter VMware Fusion konfigurieren<a class=anchor href=#virtualization-guest-vmware-configure></a></h4><div class=paragraph><p>Nachdem Sie FreeBSD erfolgreich unter VMware Fusion installiert haben, sollten Sie das virtuelle FreeBSD noch anpassen, um eine optimale Funktion zu gewährleisten.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Die wichtigste Änderung ist es, die Variable <code>kern.hz</code> zu verkleinern, um so die CPU-Auslastung in der VMware Fusion-Umgebung zu verringern.</p><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Ohne diese Einstellung kann ein unbeschäftigtes FreeBSD unter VMware Fusion trotzdem rund 15 Prozent der CPU-Leistung eines Single Prozessor iMac®'s verbrauchen. Nach dieser Änderung reduziert sich dieser Wert auf etwa 5 Prozent.</p></div></li><li><p>Erstellen einer neuen Kernelkonfigurationsdatei</p><div class=paragraph><p>Alle FireWire- und USB-Laufwerks-Treiber können aus der Kernelkonfigurationsdatei entfernt werden. VMware Fusion stellt einen virtuellen Netzwerkadapter bereit, der den <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a>-Treiber verwendet. Daher können alle Netzwerkgeräte bis auf <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> aus dem Kernel entfernt werden.</p></div></li><li><p>Netzwerkbetrieb einrichten</p><div class=paragraph><p>Die einfachste Netzwerkkonfiguration verwendet DHCP, um die virtuelle Maschine mit dem gleichen lokalen Netzwerk, in dem sich der Host-Mac® befindet, zu verbinden. Dazu fügen Sie die Zeile <code>ifconfig_em0="DHCP"</code> in <span class=filename>/etc/rc.conf</span> ein. Weitere Informationen zur Konfiguration des Netzwerks unter FreeBSD finden Sie im <a href=./#advanced-networking>Netzwerkverbindung konfigurieren</a>.</p></div></li></ol></div></div></div><div class=sect2><h3 id=virtualization-guest-virtualbox-guest-additions>39.5. FreeBSD als Gast mit VirtualBox™<a class=anchor href=#virtualization-guest-virtualbox-guest-additions></a></h3><div class=paragraph><p>FreeBSD funktioniert einwandfrei als Gast-Betriebssystem unter VirtualBox™. Die Virtualisierungs-Software steht für die meisten Betriebssysteme zur Verfügung, einschließlich FreeBSD.</p></div><div class=paragraph><p>Die VirtualBox™ Gasterweiterungen bieten Unterstützung für:</p></div><div class=ulist><ul><li><p>Gemeinsame Zwischenablage.</p></li><li><p>Mauszeiger-Integration.</p></li><li><p>Zeitsynchronisation mit dem Host.</p></li><li><p>Skalierung von Fenstern.</p></li><li><p>Nahtloser Modus.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Diese Kommandos werden im FreeBSD Gastsystem ausgeführt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Installieren Sie das Paket oder den Port <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose-additions/>emulators/virtualbox-ose-additions</a> in das FreeBSD Gastsystem. Dieses Beispiel installiert den Port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/virtualbox-ose-additions</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Fügen Sie folgende Einträge in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxguest_enable=&#34;YES&#34;
vboxservice_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Wenn <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> verwendet wird um die Uhrzeit zu synchronisieren, dann deaktivieren Sie die Synchronisierung mit dem Host:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxservice_flags=&#34;--disable-timesync&#34;</pre></div></div><div class=paragraph><p>Xorg wird den <code>vboxvideo</code>-Treiber automatisch erkennen. Alternativ kann auch manuell ein entsprechender Eintrag in <span class=filename>/etc/X11/xorg.conf</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver &#34;vboxvideo&#34;
	VendorName &#34;InnoTek Systemberatung GmbH&#34;
	BoardName &#34;VirtualBox Graphics Adapter&#34;
EndSection</pre></div></div><div class=paragraph><p>Um den <code>vboxmouse_drv</code>-Treiber zu verwenden, muss <span class=filename>/etc/X11/xorg.conf</span> ebenfalls angepasst werden:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
	Identifier &#34;Mouse0&#34;
	Driver &#34;vboxmouse&#34;
EndSection</pre></div></div><div class=paragraph><p>Benutzer von HAL sollten die Datei <span class=filename>/usr/local/etc/hal/fdi/policy/90-vboxguest.fdi</span> erstellen oder sie aus <span class=filename>/usr/local/shared/hal/fdi/policy/10osvendor/90-vboxguest.fdi</span> kopieren:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;!--
# Sun VirtualBox
# Hal driver description for the vboxmouse driver
# $Id: chapter.xml,v 1.33 2012-03-17 04:53:52 eadler Exp $

	Copyright (C) 2008-2009 Sun Microsystems, Inc.

	This file is part of VirtualBox Open Source Edition (OSE, as
	available from http://www.virtualbox.org. This file is free software;
	you can redistribute it and/or modify it under the terms of the GNU
	General Public License (GPL) as published by the Free Software
	Foundation, in version 2 as it comes in the &#34;COPYING&#34; file of the
	VirtualBox OSE distribution. VirtualBox OSE is distributed in the
	hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.

	Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
	Clara, CA 95054 USA or visit http://www.sun.com if you need
	additional information or have any questions.
--&gt;
&lt;deviceinfo version=&#34;0.2&#34;&gt;
  &lt;device&gt;
    &lt;match key=&#34;info.subsystem&#34; string=&#34;pci&#34;&gt;
      &lt;match key=&#34;info.product&#34; string=&#34;VirtualBox guest Service&#34;&gt;
	&lt;append key=&#34;info.capabilities&#34; type=&#34;strlist&#34;&gt;input&lt;/append&gt;
	&lt;append key=&#34;info.capabilities&#34; type=&#34;strlist&#34;&gt;input.mouse&lt;/append&gt;
	&lt;merge key=&#34;input.x11_driver&#34; type=&#34;string&#34;&gt;vboxmouse&lt;/merge&gt;
	&lt;merge key=&#34;input.device&#34; type=&#34;string&#34;&gt;/dev/vboxguest&lt;/merge&gt;
      &lt;/match&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;</pre></div></div><div class=paragraph><p>Gemeinsame Ordner für die Dateitransfer zwischen Host und VM sind verfügbar, wenn sie mit <code>mount_vboxvfs</code> eingebunden werden. Ein gemeinsamer Ordner kann auf dem Host über die graphische Oberfläche von VirtualBox oder mit <code>vboxmanage</code> erstellt werden. Um beispielsweise einen freigegebenen Ordner namens <em>myshare</em> unter <span class=filename>/mnt/bsdboxshare</span> für die VM <em>BSDBox</em> zu erstellen, führen Sie folgendes Kommando aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vboxmanage sharedfolder add &#39;BSDBox&#39; --name myshare --hostpath /mnt/bsdboxshare</span></code></pre></div></div><div class=paragraph><p>Beachten Sie, dass der Name des gemeinsamen Ordners keine Leerzeichen enthalten darf. Sie können den freigegebenen Ordner innerhalb des Gastsystems wie folgt einbinden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_vboxvfs -w myshare /mnt</span></code></pre></div></div></div><div class=sect2><h3 id=virtualization-host-virtualbox>39.6. FreeBSD als Host mit Virtualbox<a class=anchor href=#virtualization-host-virtualbox></a></h3><div class=paragraph><p>VirtualBox™ ist ein vollständigesVirtualisierungspaket, das aktiv weiterentwickelt wird und für die meisten Betriebssysteme einschließlich Windows®, Mac OS®, Linux® und FreeBSD zur Verfügung steht. Es kann sowohl Windows® als auch UNIX®-ähnliche Gastsysteme betreiben. Es wird als Open Source Software veröffentlicht, jedoch mit Closed-Source-Komponenten in einem separaten Erweiterungspaket. Zu diesen Komponenten gehört Unterstützung für USB 2.0-Geräte. Weitere Informationen finden Sie auf der <a href=http://www.virtualbox.org/wiki/Downloads>Downloads-Seite im VirtualBox™ Wiki</a>. Derzeit sind diese Erweiterungen für FreeBSD nicht verfügbar.</p></div><div class=sect3><h4 id=virtualization-virtualbox-install>39.6.1. VirtualBox™ installieren<a class=anchor href=#virtualization-virtualbox-install></a></h4><div class=paragraph><p>VirtualBox™ steht als Paket oder Port in <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose/>emulators/virtualbox-ose</a> bereit. Der Port kann mit folgendem Kommando installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/virtualbox-ose</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Eine nützliche Option im Konfigurationsdialog ist die <code>GuestAdditions</code>-Programmsammlung. Diese stellen eine Reihe von nützlichen Eigenschaften in den Gastbetriebssystemen zur Verfügung, wie beispielsweise Mauszeigerintegration (was es ermöglicht, die Maus zwischen dem Host und dem Gast zu teilen ohne eine spezielle Tastenkombination für diesen Wechsel zu drücken), sowie schnelleres Rendern von Videos, besonders in Windows® Gästen. Diese Gastzusätze sind im <b class=menuref>Devices</b>-Menü zu finden, nachdem die Installation des Gastbetriebssystem abgeschlossen ist.</p></div><div class=paragraph><p>Ein paar Konfigurationsänderungen sind notwendig, bevor VirtualBox™ das erste Mal gestartet wird. Der Port installiert ein Kernelmodul in <span class=filename>/boot/modules</span>, das in den laufenden Kernel geladen werden muss:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vboxdrv</span></code></pre></div></div><div class=paragraph><p>Um sicherzustellen, dass das Modul immer nach einem Neustart geladen wird, fügen Sie die folgende Zeile in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxdrv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Um die Kernelmodule für die Unterstützung von Netzwerkbrücken oder Host-Only Netzwerken zu laden, fügen Sie folgendes in <span class=filename>/etc/rc.conf</span> ein und starten Sie den Computer neu:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxnet_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Die Gruppe <code>vboxusers</code> wird während der Installation von VirtualBox™ angelegt. Alle Benutzer, die Zugriff auf VirtualBox™ haben sollen, müssen in diese Gruppe aufgenommen werden. <code>pw</code> kann benutzt werden, um neue Mitglieder hinzuzufügen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod vboxusers -m yourusername</span></code></pre></div></div><div class=paragraph><p>Damit Netzwerkbrücken funktionieren, müssen die in der Voreinstellung eingeschränkten Berechtigungen für <span class=filename>/dev/vboxnetctl</span> angepasst werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:vboxusers /dev/vboxnetctl</span>
<span class=c># chmod 0600 /dev/vboxnetctl</span></code></pre></div></div><div class=paragraph><p>Um diese Berechtigungen dauerhaft zu speichern, fügen Sie folgende Einträge in <span class=filename>/etc/devfs.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>own     vboxnetctl root:vboxusers
perm    vboxnetctl 0600</pre></div></div><div class=paragraph><p>Um VirtualBox™ zu starten, geben Sie folgenden Befehl in der Xorg-Sitzung ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% VirtualBox</code></pre></div></div><div class=paragraph><p>Besuchen Sie die offizielle Webseite von VirtualBox™ unter <a href=http://www.virtualbox.org>http://www.virtualbox.org</a>, um weitere Informationen zur Konfiguration und Verwendung zu erhalten. FreeBSD-spezifische Informationen und Anleitungen zur Fehlerbehebung finden Sie auf der entsprechenden Seite im FreeBSD-Wiki unter <a href=http://wiki.FreeBSD.org/VirtualBox>http://wiki.FreeBSD.org/VirtualBox</a>.</p></div></div><div class=sect3><h4 id=virtualization-virtualbox-usb-support>39.6.2. USB Unterstützung für VirtualBox™<a class=anchor href=#virtualization-virtualbox-usb-support></a></h4><div class=paragraph><p>Sie können VirtualBox™ so konfigurieren, dass USB-Geräte an das Gastsystem weitergeleitet werden. So lange das Erweiterungspaket für USB 2.0 und 3.0 auf FreeBSD nicht verfügbar ist, ist der Host-Controller der OSE-Version auf die Emulation von USB 1.1-Geräten beschränkt.</p></div><div class=paragraph><p>Damit VirtualBox™ angeschlossene USB-Geräte am Rechner erkennt, muss der Benutzer Mitglied der Gruppe <code>operator</code> sein.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod operator -m ihrbenutzername</span></code></pre></div></div><div class=paragraph><p>Anschließend fügen Sie folgenden Eintrag in <span class=filename>/etc/devfs.rules</span> ein. Wenn die Datei nicht existiert, muss sie zuvor erstellt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=10]
add path &#39;usb/*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>Um diese neuen Regeln zu laden, fügen Sie Folgendes in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;system&#34;</pre></div></div><div class=paragraph><p>Danach starten Sie devfs neu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div><div class=paragraph><p>Sie müssen die Anmeldesitzung und VirtualBox™ neu starten, damit die Änderungen wirksam werden. Danach können Sie nach Bedarf neue USB-Filter erstellen.</p></div></div><div class=sect3><h4 id=virtualbox-virtualization-host-dvd-cd-access>39.6.3. Host CD/DVD-Zugriff in VirtualBox™<a class=anchor href=#virtualbox-virtualization-host-dvd-cd-access></a></h4><div class=paragraph><p>Ein Gastsystem kann auf die DVD/CD-Laufwerke des Hosts zugreifen. Der Zugriff für die virtuellen Maschinen wird in den Einstellungen von VirtualBox™ konfiguriert. Falls erforderlich, erstellen Sie zunächst ein leeres IDEDVD/CD-Gerät und wählen Sie dann ein entsprechendes Medium für dieses Laufwerk aus. Das Kontrollkästchen <code>Passthrough</code> besagt, dass die virtuelle Maschine die Hardware direkt verwenden kann. Audio-CDs und Brenner funktionieren nur, wenn diese Option ausgewählt ist.</p></div><div class=paragraph><p>Damit die CD/DVD-Funktionen von VirtualBox™ funktionieren, muss HAL in <span class=filename>/etc/rc.conf</span> aktiviert und anschließend gestartet werden:</p></div><div class="literalblock programlisting"><div class=content><pre>hald_enable=&#34;YES&#34;</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hald start</span></code></pre></div></div><div class=paragraph><p>Damit die CD/DVD-Funktionen von Benutzern verwendet werden können, benötigen diese Zugriff auf <span class=filename>/dev/xpt0</span>, <span class=filename>/dev/cdN</span> und <span class=filename>/dev/passN</span>. Dies wird in der Regel dadurch erreicht, den Benutzer zum Mitglied der Gruppe <code>operator</code> zu machen. Die Berechtigungen für diese Geräte werden mit folgenden Zeilen in <span class=filename>/etc/devfs.conf</span> konfiguriert:</p></div><div class="literalblock programlisting"><div class=content><pre>perm cd* 0660
perm xpt0 0660
perm pass* 0660</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div></div></div><div class=sect2><h3 id=virtualization-host-bhyve>39.7. FreeBSD als Host mit bhyve<a class=anchor href=#virtualization-host-bhyve></a></h3><div class=paragraph><p>Beginnend mit FreeBSD 10.0-RELEASE ist bhyve, ein BSD-lizensierter Hypervisor, Teil des Basissystems. Dieser Hypervisor unterstützt eine Reihe von Gastbetriebssystemen, darunter FreeBSD, OpenBSD und viele Linux® Distributionen. In der Voreinstellung unterstützt bhyve eine serielle Konsole, graphische Konsolen werden nicht emuliert. bhyve verwendet Offload-Funktionen von neueren CPUs, um manuelle Speicherzuordnungen und Anweisungen zu vermeiden.</p></div><div class=paragraph><p>Das Design von bhyve erfordert einen Prozessor, der Intel® Extended Page Tables (EPT), AMD® Rapid Vitualization Indexing (RVI) oder Nested Page Tables (NPT) unterstützt. FreeBSD- oder Linux®-Gastsysteme mit mehr als einer vCPU benötigen VMX unrestricted mode support (UG). Die meisten neueren Prozessoren, speziell Intel® Core™ i3/i5/i7 und Intel® Xeon™ E3/E5/E7, unterstützen diese Funktionen. Unterstützung für UG wurde mit Intel’s Westmere Mikroarchitektur eingeführt. Eine vollständige Liste der Intel®-Prozessoren mit EPT-Unterstützung finden Sie unter <a href="https://ark.intel.com/content/www/us/en/ark/search/featurefilter.html?productType=873&amp;0_ExtendedPageTables=True" class=bare>https://ark.intel.com/content/www/us/en/ark/search/featurefilter.html?productType=873&amp;0_ExtendedPageTables=True</a>. RVI wird seit der dritten Generation der AMD Opteron™-Prozessoren (Barcelona) unterstützt. Um zu sehen ob der Prozessor bhyve unterstützt, prüfen Sie die Ausgabe von <code>dmesg</code> oder <span class=filename>/var/run/dmesg.boot</span>. Für AMD®-Prozessoren suchen Sie in der Zeile <code>Features2</code> nach <code>POPCNT</code>. Für Intel®-Prozessoren suchen Sie in der Zeile <code>VT-x</code> nach <code>EPT</code> und <code>UG</code>.</p></div><div class=sect3><h4 id=virtualization-bhyve-prep>39.7.1. Vorbereitung des Hosts<a class=anchor href=#virtualization-bhyve-prep></a></h4><div class=paragraph><p>Der erste Schritt bei der Erstellung einer virtuellen Maschine in bhyve ist die Konfiguration des Host-Systems. Laden Sie zunächst das bhyve Kernelmodul:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vmm</span></code></pre></div></div><div class=paragraph><p>Erstellen Sie ein <span class=filename>tap</span>-Gerät, um dieses mit der Netzwerk-Schnittstelle der virtuellen Maschine zu verbinden. Damit sich die Schnittstelle mit dem Netzwerk verbinden kann, müssen Sie zusätzlich eine Bridge-Schnittstelle erzeugen, bestehend aus dem <span class=filename>tap</span>-Gerät und der physikalischen Schnittstelle. In diesem Beispiel wird die physikalische Schnittstelle <span class=filename>igb0</span> verwendet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig tap0 create</span>
<span class=c># sysctl net.link.tap.up_on_open=1</span>
net.link.tap.up_on_open: 0 -&gt; 1
<span class=c># ifconfig bridge0 create</span>
<span class=c># ifconfig bridge0 addm igb0 addm tap0</span>
<span class=c># ifconfig bridge0 up</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-freebsd>39.7.2. Ein FreeBSD-Gastsystem erstellen<a class=anchor href=#virtualization-bhyve-freebsd></a></h4><div class=paragraph><p>Erzeugen Sie eine Datei, die als virtuelle Festplatte für das Gastsystem verwendet wird. Geben Sie die Größe und den Namen der virtuellen Festplatte an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># truncate -s 16G guest.img</span></code></pre></div></div><div class=paragraph><p>Laden Sie ein Installationsabbild von FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch ftp://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/10.3/FreeBSD-10.3-RELEASE-amd64-bootonly.iso</span>
FreeBSD-10.3-RELEASE-amd64-bootonly.iso       100% of  230 MB  570 kBps 06m17s</code></pre></div></div><div class=paragraph><p>FreeBSD enthält ein Beispielskript um eine virtuelle Maschine in bhyve auszuführen. Das Skript wird die virtuelle Maschine starten und sie in einer Schleife ausführen. Sollte die virtuelle Maschine abstürzen, wird sie vom Skript automatisch neu gestartet. Das Skript akzeptiert einige Optionen, um die Konfiguration der virtuellen Maschine zu kontrollieren: <code>-c</code> bestimmt die Anzahl der virtuellen CPUs, <code>-m</code> begrenzt den verfügbaren Speicher des Gastsystems, <code>-t</code> bestimmt das verwendete <span class=filename>tap</span>-Gerät, <code>-d</code> gibt das zu benutzende Festplattenabbild an, <code>-i</code> sagt bhyve dass es von CD booten soll und <code>-I</code> bestimmt das CD-Abbild. Der letzte Parameter ist der Name der virtuellen Maschine. Dieses Beispiel startet die virtuelle Maschine im Installationsmodus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /usr/shared/examples/bhyve/vmrun.sh -c 1 -m 1024M -t tap0 -d guest.img -i -I FreeBSD-10.3-RELEASE-amd64-bootonly.iso guestname</span></code></pre></div></div><div class=paragraph><p>Die virtuelle Maschine wird starten und das Installationsprogramm ausführen. Nachdem das System in der virtuellen Maschine installiert ist, werden Sie gefragt, ob eine Shell gestartet werden soll. Wählen Sie <b class=button>Yes</b>.</p></div><div class=paragraph><p>Starten Sie die virtuelle Maschine neu. Ein Neustart der virtuellen Maschine wird bhyve beenden, aber da das <span class=filename>vmrun.sh</span>-Skript in einer Schleife läuft, wird bhyve automatisch neu gestartet. Wenn dies passiert, wählen Sie die Option <code>Reboot</code> im Bootloader-Menü, um die Schleife zu unterbrechen. Anschließend kann das Gastsystem von der virtuellen Festplatte gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /usr/shared/examples/bhyve/vmrun.sh -c 4 -m 1024M -t tap0 -d guest.img guestname</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-linux>39.7.3. Ein Linux®-Gastsystem erstellen<a class=anchor href=#virtualization-bhyve-linux></a></h4><div class=paragraph><p>Um andere Betriebssysteme als FreeBSD zu booten, muss zunächst der Port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a> installiert werden.</p></div><div class=paragraph><p>Als nächstes erzeugen Sie eine Datei, die das Gastsystem als virtuelle Festplatte verwenden kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># truncate -s 16G linux.img</span></code></pre></div></div><div class=paragraph><p>Der Start einer virtuellen Maschine mit bhyve ist ein zweistufiger Prozess. Zuerst muss ein Kernel geladen werden, dann kann das Gastsystem gestartet werden. Der Linux®-Kernel wird mit <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a> geladen. Erstellen Sie eine <span class=filename>device.map</span>, damit grub die virtuellen Geräte den Dateien auf dem Hostsystem zuordnen kann:</p></div><div class="literalblock programlisting"><div class=content><pre>(hd0) ./linux.img
(cd0) ./somelinux.iso</pre></div></div><div class=paragraph><p>Benutzen Sie <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a> um den Linux®-Kernel vom ISO-Abbild zu laden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grub-bhyve -m device.map -r cd0 -M 1024M linuxguest</span></code></pre></div></div><div class=paragraph><p>Damit wird grub gestartet. Wenn die Installations-CD eine Datei namens <span class=filename>grub.cfg</span> enthält, wird ein Menü angezeigt. Wenn nicht, müssen die Dateien <span class=filename>vmlinuz</span> und <span class=filename>initrd</span> manuell geladen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>grub&gt; <span class=nb>ls</span>
<span class=o>(</span>hd0<span class=o>)</span> <span class=o>(</span>cd0<span class=o>)</span> <span class=o>(</span>cd0,msdos1<span class=o>)</span> <span class=o>(</span>host<span class=o>)</span>
grub&gt; <span class=nb>ls</span> <span class=o>(</span>cd0<span class=o>)</span>/isolinux
boot.cat boot.msg grub.conf initrd.img isolinux.bin isolinux.cfg memtest
splash.jpg TRANS.TBL vesamenu.c32 vmlinuz
grub&gt; linux <span class=o>(</span>cd0<span class=o>)</span>/isolinux/vmlinuz
grub&gt; initrd <span class=o>(</span>cd0<span class=o>)</span>/isolinux/initrd.img
grub&gt; boot</code></pre></div></div><div class=paragraph><p>Nun, da der Linux®-Kernel geladen ist, kann das Gastsystem gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \</span>
    <span class=nt>-s</span> 4:0,ahci-cd,./somelinux.iso <span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div><div class=paragraph><p>Das System wird booten und das Installtionsprogramm starten. Starten Sie die virtuelle Maschine nach der Installation des Betriebssystems neu. Dies führt auch dazu, dass bhyve beendet wird. Die Instanz der virtuellen Maschine muss zerstört werden, bevor sie erneut in Betrieb genommen werden kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=linuxguest</span></code></pre></div></div><div class=paragraph><p>Nun kann das Gastsystem direkt von der virtuellen Festplatte gestartet werden. Laden Sie den Kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grub-bhyve -m device.map -r hd0,msdos1 -M 1024M linuxguest</span>
grub&gt; <span class=nb>ls</span>
<span class=o>(</span>hd0<span class=o>)</span> <span class=o>(</span>hd0,msdos2<span class=o>)</span> <span class=o>(</span>hd0,msdos1<span class=o>)</span> <span class=o>(</span>cd0<span class=o>)</span> <span class=o>(</span>cd0,msdos1<span class=o>)</span> <span class=o>(</span>host<span class=o>)</span>
<span class=o>(</span>lvm/VolGroup-lv_swap<span class=o>)</span> <span class=o>(</span>lvm/VolGroup-lv_root<span class=o>)</span>
grub&gt; <span class=nb>ls</span> <span class=o>(</span>hd0,msdos1<span class=o>)</span>/
lost+found/ grub/ efi/ System.map-2.6.32-431.el6.x86_64 config-2.6.32-431.el6.x
86_64 symvers-2.6.32-431.el6.x86_64.gz vmlinuz-2.6.32-431.el6.x86_64
initramfs-2.6.32-431.el6.x86_64.img
grub&gt; linux <span class=o>(</span>hd0,msdos1<span class=o>)</span>/vmlinuz-2.6.32-431.el6.x86_64 <span class=nv>root</span><span class=o>=</span>/dev/mapper/VolGroup-lv_root
grub&gt; initrd <span class=o>(</span>hd0,msdos1<span class=o>)</span>/initramfs-2.6.32-431.el6.x86_64.img
grub&gt; boot</code></pre></div></div><div class=paragraph><p>Starten Sie die virtuelle Maschine:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 \$    -s 3:0,virtio-blk,./linux.img -l com1,stdio -c 4 -m 1024M linuxguest</span></code></pre></div></div><div class=paragraph><p>Linux® wird jetzt in der virtuellen Maschine gestartet und präsentiert Ihnen vielleicht einen Anmeldeprompt. Sie können sich anmelden und die virtuelle Maschine benutzen. Wenn Sie fertig sind, starten Sie die virtuelle Maschine neu, um bhyve zu verlassen. Anschließend zerstören Sie die Instanz der virtuellen Maschine:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=linuxguest</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-uefi>39.7.4. bhyve virtuelle Maschinen mit UEFI Firmware booten<a class=anchor href=#virtualization-bhyve-uefi></a></h4><div class=paragraph><p>Neben bhyveload und grub-bhyve kann der bhyve Hypervisor virtuelle Maschinen auch über die UEFI-Userspace-Firmware booten. Mit dieser Option werden Gastsysteme unterstützt, die von anderen Bootloadern nicht unterstützt werden.</p></div><div class=paragraph><p>Um die UEFI-Unterstützung in bhyve nutzen zu können, benötigen Sie zuerst die Abbilder der UEFI-Firmware. Dazu können Sie den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/>sysutils/bhyve-firmware</a> installieren.</p></div><div class=paragraph><p>Mit der Firmware an Ort und Stelle, fügen Sie die Option <code>-l bootrom,<em>/pfad/zur/firmware</em></code> zur bhyve-Befehlszeile hinzu. Der eigentliche bhyve-Befehl könnte wie folgt lauten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
<span class=nt>-l</span> bootrom,/usr/local/shared/uefi-firmware/BHYVE_UEFI.fd <span class=se>\</span>
guest</code></pre></div></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/>sysutils/bhyve-firmware</a> enthält auch eine CSM-fähige Firmware, um Gastsysteme ohne UEFI-Unterstützung im alten BIOS-Modus zu booten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
<span class=nt>-l</span> bootrom,/usr/local/shared/uefi-firmware/BHYVE_UEFI_CSM.fd <span class=se>\</span>
guest</code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-framebuffer>39.7.5. Graphische Framebuffer für bhyve-Gastsysteme<a class=anchor href=#virtualization-bhyve-framebuffer></a></h4><div class=paragraph><p>Die Unterstützung von UEFI-Firmware ist bei graphischen Betriebssystemen, wie Microsoft Windows®, besonders nützlich.</p></div><div class=paragraph><p>Unterstützung für den UEFI-GOP Framebuffer kann auch über die Option <code>-s 29,fbuf,tcp=<em>0.0.0.0:5900</em></code> aktiviert werden. Die Framebuffer-Auflösung kann mit <code>w=<em>800</em></code> und <code>h=<em>600</em></code> konfiguriert werden. Mit der Option <code>wait</code> können Sie bhyve anweisen, auf eine VNC-Verbindung zu warten, bevor das Gastsystem gebootet wird. Vom Host oder aus dem Netzwerk kann über das VNC-Protokoll auf den Framebuffer zugegriffen werden. Zusätzlich kann <code>-s 30,xhci,tablet</code> hinzugefügt werden, um eine präzise Mauszeigersynchronisation mit dem Host zu gewährleisten.</p></div><div class=paragraph><p>Der daraus resultierende Befehl würde so aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 31:0,lpc \</span>
<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
<span class=nt>-s</span> 29,fbuf,tcp<span class=o>=</span>0.0.0.0:5900,w<span class=o>=</span>800,h<span class=o>=</span>600,wait <span class=se>\</span>
<span class=nt>-l</span> bootrom,/usr/local/shared/uefi-firmware/BHYVE_UEFI.fd <span class=se>\</span>
<span class=nt>-s</span> 30,xhci,tablet <span class=se>\</span>
guest</code></pre></div></div><div class=paragraph><p>Beachten Sie, dass der Framebuffer im BIOS-Modus keine Befehle mehr empfängt, sobald die Steuerung von der Firmware an das Gastsystem übergeben wird.</p></div></div><div class=sect3><h4 id=virtualization-bhyve-zfs>39.7.6. Verwendung von ZFS mit bhyve-Gastsystemen<a class=anchor href=#virtualization-bhyve-zfs></a></h4><div class=paragraph><p>Wenn auf dem Host-Rechner ZFS eingerichtet ist, können Sie ZFS-Volumes anstelle eines Festplattenabbilds verwenden. Dies kann erhebliche Leistungsvorteile für das Gastsystem mit sich bringen. Ein ZFS-Volume kann wie folgt erstellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V16G -o volmode=dev zroot/linuxdisk0</span></code></pre></div></div><div class=paragraph><p>Geben Sie das ZFS-Volume beim Start der virtuellen Maschine an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s3:0,virtio-blk,/dev/zvol/zroot/linuxdisk0 \</span>
    <span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-nmdm>39.7.7. Konsolen in der virtuellen Maschine<a class=anchor href=#virtualization-bhyve-nmdm></a></h4><div class=paragraph><p>Es ist vorteilhaft, die bhyve-Konsole mit einem Werkzeug wie <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/tmux/>sysutils/tmux</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/screen/>sysutils/screen</a> zu bedienen. Damit ist es leicht, die Konsole zu verbinden oder zu trennen. Es ist auch möglich, die Konsole als Nullmodem-Gerät zu nutzen, auf das Sie mit <code>cu</code> zugreifen können. Laden Sie dazu das <span class=filename>nmdm</span> Kernelmodul und ersetzen Sie <code>-l com1,stdio</code> mit <code>-l com1,/dev/nmdm0A</code>. Die <span class=filename>/dev/nmdm</span>-Geräte werden bei Bedarf automatisch erstellt, jeweils paarweise, entsprechend den beiden Enden eines Nullmodemkabels (<span class=filename>/dev/nmdm0A</span> und <span class=filename>/dev/nmdm0B</span>). Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=nmdm&amp;sektion=4&amp;format=html">nmdm(4)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload nmdm</span>
<span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \</span>
    <span class=nt>-l</span> com1,/dev/nmdm0A <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest
<span class=c># cu -l /dev/nmdm0B</span>
Connected

Ubuntu 13.10 handbook ttyS0

handbook login:</code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-managing>39.7.8. Virtuelle Maschinen verwalten<a class=anchor href=#virtualization-bhyve-managing></a></h4><div class=paragraph><p>Für jede virtuelle Maschine wird unterhalb von <span class=filename>/dev/vmm</span> ein Gerätename erzeugt. Dadurch kann der Administrator einfach feststellen, welche virtuellen Maschinen zur Zeit ausgeführt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -al /dev/vmm</span>
total 1
dr-xr-xr-x   2 root  wheel    512 Mar 17 12:19 ./
dr-xr-xr-x  14 root  wheel    512 Mar 17 06:38 ../
crw-------   1 root  wheel  0x1a2 Mar 17 12:20 guestname
crw-------   1 root  wheel  0x19f Mar 17 12:19 linuxguest
crw-------   1 root  wheel  0x1a1 Mar 17 12:19 otherguest</code></pre></div></div><div class=paragraph><p>Mit Hilfe von <code>bhyvectl</code> kann eine virtuelle Maschine zerstört werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=guestname</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-onboot>39.7.9. Persistente Konfiguration<a class=anchor href=#virtualization-bhyve-onboot></a></h4><div class=paragraph><p>Um das System so zu konfigurieren, dass bhyve-Gastsysteme beim Booten gestartet werden, müssen die folgenden Konfigurationen in den jeweiligen Dateien vorgenommen werden:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p><span class=filename>/etc/sysctl.conf</span></p><div class="literalblock programlisting"><div class=content><pre>net.link.tap.up_on_open=1</pre></div></div></li><li><p><span class=filename>/etc/rc.conf</span></p><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0 tap0&#34;
ifconfig_bridge0=&#34;addm igb0 addm tap0&#34;
kld_list=&#34;vmm nmdm&#34;</pre></div></div></li></ol></div></div></div><div class=sect2><h3 id=virtualization-host-xen>39.8. FreeBSD als Xen™-Host<a class=anchor href=#virtualization-host-xen></a></h3><div class=paragraph><p>Xen ist ein GPLv2-lizensierter <a href=https://de.wikipedia.org/wiki/Hypervisor#Klassifizierung>Typ-1-Hypervisor</a> für Intel® und ARM® Architekturen. Seit FreeBSD 8.0 gibt es Unterstützung für i386™ und AMD® 64-Bit <a href=https://wiki.xenproject.org/wiki/DomU>DomU</a> sowie <a href=https://en.wikipedia.org/wiki/Amazon_Elastic_Compute_Cloud>Amazon EC2</a> unpriviligierte Domänen (virtuelle Maschinen). Dom0 priviligierte Domänen (Host) wird seit FreeBSD 11.0 unterstützt. Aus Performancegründen wurde in FreeBSD 11 die Unterstützung für paravirtualisierte Domänen (PV) zugunsten von Hardware virtualisierten Domänen (HVM) entfernt.</p></div><div class=paragraph><p>Xen™ ist ein Bare-Metal-Hypervisor, was bedeutet, dass es das erste Programm ist, welches nach dem BIOS geladen wird. Anschließend wird ein spezieller priviligierter Gast namens Domain-0 (kurz <code>Dom0</code>) gestartet. Dom0 nutzt seine speziellen Privilegien, um direkt auf die zugrunde liegende Hardware zuzugreifen, was es zu einer sehr leistungsstarken Lösung macht. Es ist in der Lage, direkt auf Festplattencontroller und Netzwerkadapter zuzugreifen. Die Xen™ Werkzeuge zum Verwalten und Steuern des Xen™ Hypervisors werden auch von Dom0 zum Erstellen, Auflisten und Zerstören von VMs verwendet. Dom0 stellt virtuelle Festplatten und Netzwerkfunktionalität für unpriviligierte Domänen bereit, die oft als DomU bezeichnet werden. Dom0 kann mit der Servicekonsole anderer Hypervisor verglichen werden, wohingegen DomU die einzelnen Gast-VMs ausführt.</p></div><div class=paragraph><p>Xen™ kann VMs zwischen verschiedenen Xen™ Servern migrieren. Wenn beide Xen-Hosts denselben zugrundeliegenden Speicher teilen, kann die Migration durchgeführt werden, ohne dass die VM zuerst heruntergefahren werden muss. Stattdessen wird die Migration live durchgeführt, während die DomU läuft. Sie brauchen daher keinen Neustart oder Ausfallzeit einplanen. Dies ist bei Wartungsarbeiten und Upgrade-Fenstern sinnvoll, um sicherzustellen, dass die von der DomU bereitgestellten Dienste weiterhin zur Verfügung stehen. Viele weitere Funktionen von Xen™ finden Sie im <a href=https://wiki.xenproject.org/wiki/Category:Overview>Xen Wiki</a>. Sie sollten jedoch beachten, dass derzeit noch nicht alle Funktionen von FreeBSD unterstützt werden.</p></div><div class=sect3><h4 id=virtualization-host-xen-requirements>39.8.1. Hardwareanforderungen für Xen™ Dom0<a class=anchor href=#virtualization-host-xen-requirements></a></h4><div class=paragraph><p>Um den Xen™ Hypervisor auf einem Host auszuführen, ist eine bestimmte Hardwarefunktionalität erforderlich. Hardware-virtualisierte Domänen benötigen Unterstützung für Extended Page Table (<a href=https://de.wikipedia.org/wiki/Extended_Page_Table> EPT</a>) und Input/Output Memory Management Unit (<a href=https://de.wikipedia.org/wiki/IOMMU>IOMMU</a>) im Host-Prozessor.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um ein FreeBSD Xen™ Dom0 betreiben zu können, muss die Maschine mit Legacy Boot (BIOS) gestartet werden.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=virtualization-host-xen-dom0-setup>39.8.2. Xen™ Dom0 Control Domain Konfiguration<a class=anchor href=#virtualization-host-xen-dom0-setup></a></h4><div class=paragraph><p>Benutzer von FreeBSD 11 sollten die Pakete <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/xen-kernel47/>emulators/xen-kernel47</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xen-tools47/>sysutils/xen-tools47</a> installieren. Diese Pakete basieren auf Xen Version 4.7. Mit FreeBSD-12.0 und neueren Versionen können die Pakete <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/xen-kernel411/>emulators/xen-kernel411</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xen-tools411/>sysutils/xen-tools411</a> für Xen 4.11 verwendet werden.</p></div><div class=paragraph><p>Nach der Installation der Xen Pakete müssen die Konfigurationsdateien angepasst werden, um den Host für die Integration von Dom0 vorzubereiten. Ein Eintrag in <span class=filename>/etc/sysctl.conf</span> deaktiviert die Begrenzung für Speicherseiten. Andernfalls lassen sich DomU VMs mit höheren Speicheranforderungen nicht ausführen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;vm.max_wired=-1&#39; &gt;&gt; /etc/sysctl.conf</span></code></pre></div></div><div class=paragraph><p>Für eine andere speicherbezogene Einstellung muss in <span class=filename>/etc/login.conf</span> die Option <code>memorylocked</code> auf <code>unlimited</code> gesetzt werden. Ansonsten kann das Erstellen von DomU-Domänen mit der Meldung <code>Cannot allocate memory</code> fehlschlagen. Nachdem Sie die Änderung in <span class=filename>/etc/login.conf</span> gemacht haben, müssen Sie <code>cap_mkdb</code> ausführen um die Datenbank zu aktualisieren. <a href=./#security-resourcelimits>Einschränkung von Ressourcen</a> enthält hierzu ausführliche Informationen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sed -i &#39;&#39; -e &#39;s/memorylocked=64K/memorylocked=unlimited/&#39; /etc/login.conf</span>
<span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class=paragraph><p>Fügen Sie einen Eintrag für die Xen™ Konsole in <span class=filename>/etc/ttys</span> ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;xc0     &#34;usr/libexec/getty Pc&#34;        xterm   onifconsole  secure&#39; &gt;&gt; /etc/ttys</span></code></pre></div></div><div class=paragraph><p>Dom0 wird durch die Auswahl eines Xen™-Kernels in <span class=filename>/boot/loader.conf</span> aktiviert. Xen™ benötigt von dem Hostsystem auch Ressourcen wie CPU und Speicher, sowohl für sich selbst als auch für andere DomU Domains. Wie viele Ressourcen benötigt werden, hängt von den individuellen Anforderungen und der eingesetzten Hardware ab. In diesem Beispiel werden der Dom0 8 GB Speicher und 4 virtuelle CPUs zur Verfügung gestellt. Die serielle Konsole und Protokollierung wird ebenfalls aktiviert.</p></div><div class=paragraph><p>Benutzen Sie die folgenden Kommandos, wenn Sie die Xen 4.7 Pakete verwenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf hw.pci.mcfg=0</span>
<span class=c># sysrc -f /boot/loader.conf if_tap_load=&#34;YES&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_kernel=&#34;/boot/xen&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_cmdline=&#34;dom0_mem=8192M dom0_max_vcpus=4 dom0pvh=1 console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all&#34;</span></code></pre></div></div><div class=paragraph><p>Für Xen Version 4.11 oder höher, benutzen Sie stattdessen diese Kommandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf if_tap_load=&#34;YES&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_kernel=&#34;/boot/xen&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_cmdline=&#34;dom0_mem=8192M dom0_max_vcpus=4 dom0=pvh console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all&#34;</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Protokolldateien, die Xen™ für die Dom0- und DomU-VMs erstellt, werden in <span class=filename>/var/log/xen</span> gespeichert. Sie sollten dieses Verzeichnis überprüfen, falls es zu Problemen kommt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Aktivieren Sie den xencommons Dienst während des Systemstarts:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc xencommons_enable=yes</span></code></pre></div></div><div class=paragraph><p>Diese Einstellungen reichen zwar aus, um ein Dom0-fähiges System zu starten, allerdings fehlt es dann an Netzwerkfunktionalität für die DomU-Rechner. Um dies zu beheben, können Sie eine Netzwerkbrücke über die Netzwerkschnittstelle des Hosts herstellen, die die DomU-VMs für die Verbindung zum Netzwerk benutzen können. Ersetzen Sie <em>em0</em> durch den Namen der Netzwerkschnittstelle des Hosts.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc cloned_interfaces=&#34;bridge0&#34;</span>
<span class=c># sysrc ifconfig_bridge0=&#34;addm em0 SYNCDHCP&#34;</span>
<span class=c># sysrc ifconfig_em0=&#34;up&#34;</span></code></pre></div></div><div class=paragraph><p>Starten Sie den Host neu, um den Xen™-Kernel zu laden und den Dom0 zu starten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># reboot</span></code></pre></div></div><div class=paragraph><p>Nach dem erfolgreichen Booten des Xen™-Kernels und der Anmeldung am System wird das Xen™-Werkzeug <code>xl</code> verwendet, um Informationen über die Domänen anzuzeigen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl list</span>
Name                                        ID   Mem VCPUs      State   Time<span class=o>(</span>s<span class=o>)</span>
Domain-0                                     0  8192     4     r-----     962.0</code></pre></div></div><div class=paragraph><p>Die Ausgabe bestätigt, dass der Dom0 (auch Domain-0 genannt) die ID <code>0</code> hat und ausgeführt wird. Der vorher in <span class=filename>/boot/loader.conf</span> definierte Speicher und die virtuellen CPUs sind ebenfalls vorhanden. Weitere Informationen finden Sie in der <a href=https://www.xenproject.org/help/documentation.html>Xen™ Dokumentation</a>. Jetzt können DomU Gast-VMs erstellt werden.</p></div></div><div class=sect3><h4 id=virtualization-host-xen-domu-setup>39.8.3. Xen™ DomU Gast-VM Konfiguration<a class=anchor href=#virtualization-host-xen-domu-setup></a></h4><div class=paragraph><p>Unpriviligierte Domänen bestehen aus einer Konfigurationsdatei und virtuellen oder physikalischen Festplatten. Der virtuelle Plattenspeicher für die DomU kann aus Dateien bestehen, die mit <a href="https://man.freebsd.org/cgi/man.cgi?query=truncate&amp;sektion=1&amp;format=html">truncate(1)</a> erstellt wurden, oder ZFS Volumes wie in <a href=./#zfs-zfs-volume>“Volumes erstellen und zerstören”</a> beschrieben. In diesem Beispiel wird ein 20 GB Volume verwendet. Eine VM wird mit dem ZFS Volume erstellt, ein FreeBSD ISO-Abbild, 1 GB RAM und zwei virtuelle CPUs. Das ISO-Abbild mit den Installationsdateien wird mit <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> heruntergeladen und lokal in der Datei <span class=filename>freebsd.iso</span> gespeichert.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch ftp://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/12.0/FreeBSD-12.0-RELEASE-amd64-bootonly.iso -o freebsd.iso</span></code></pre></div></div><div class=paragraph><p>Ein ZFS Volume von 20 GB namens <span class=filename>xendisk0</span> wird erstellt und dient der VM als Festplatte.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V20G -o volmode=dev zroot/xendisk0</span></code></pre></div></div><div class=paragraph><p>Die neue DomU Gast-VM wird in einer Datei definiert. Einige spezifische Einstellungen wie Name, Tastaturbelegung und VNC-Verbindungsdetails werden ebenfalls konfiguriert. Für dieses Beispiel enthält die folgende <span class=filename>freebsd.cfg</span> eine minimale DomU-Konfiguration:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat freebsd.cfg</span>
builder <span class=o>=</span> <span class=s2>&#34;hvm&#34;</span> <i class=conum data-value=1></i><b>(1)</b>
name <span class=o>=</span> <span class=s2>&#34;freebsd&#34;</span> <i class=conum data-value=2></i><b>(2)</b>
memory <span class=o>=</span> 1024 <i class=conum data-value=3></i><b>(3)</b>
vcpus <span class=o>=</span> 2 <i class=conum data-value=4></i><b>(4)</b>
vif <span class=o>=</span> <span class=o>[</span> <span class=s1>&#39;mac=00:16:3E:74:34:32,bridge=bridge0&#39;</span> <span class=o>]</span> <i class=conum data-value=5></i><b>(5)</b>
disk <span class=o>=</span> <span class=o>[</span>
<span class=s1>&#39;/dev/zvol/tank/xendisk0,raw,hda,rw&#39;</span>, <i class=conum data-value=6></i><b>(6)</b>
<span class=s1>&#39;/root/freebsd.iso,raw,hdc:cdrom,r&#39;</span> <i class=conum data-value=7></i><b>(7)</b>
<span class=o>]</span>
vnc <span class=o>=</span> 1 <i class=conum data-value=8></i><b>(8)</b>
vnclisten <span class=o>=</span> <span class=s2>&#34;0.0.0.0&#34;</span>
serial <span class=o>=</span> <span class=s2>&#34;pty&#34;</span>
usbdevice <span class=o>=</span> <span class=s2>&#34;tablet&#34;</span></code></pre></div></div><div class=paragraph><p>Erklärung der einzelnen Zeilen:</p></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Dies definiert, welche Art von Virtualisierung verwendet wird. <code>hvm</code> bezieht sich auf hardwaregestützte Virtualisierung oder Hardware Virtual Machine. Gastbetriebssysteme können unverändert auf der CPU mit Virtualisierungserweiterungen laufen und bieten nahezu die gleiche Leistung wie auf physikalischer Hardware. <code>generic</code> ist der voreingestellte Wert und erstellt eine PV-Domain.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Der Name dieser virtuellen Maschine. Er dient zur Unterscheidung von anderen virtuellen Maschinen auf der selben Dom0. Diese Angabe ist zwingend erforderlich.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Die Größe an RAM in Megabytes, die der VM zur Verfügung steht. Die Größe wird vom verfügbaren Speicher des Hypervisors subtrahiert, nicht vom Speicher der Dom0.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Die Anzahl der virtuellen CPUs, die dem Gast zur Verfügung stehen. Für die beste Leistung sollten Sie dem Gast nicht mehr CPUs zuteilen, als die Anzahl der CPUs auf dem physikalischen Host.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Der virtuelle Netzwerkadapter. Dies ist die Brücke, die mit der Netzwerkschnittstelle des Hosts verbunden ist. Der Parameter <code>mac</code> definiert die MAC-Adresse der virtuellen Schnittstelle. Dieser Parameter ist optional. Falls keine MAC definiert ist, wird Xen™ eine zufällige MAC generieren.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Der vollständige Pfad zur Festplatte, Datei, oder ZFS Volume für den Plattenspeicher dieser VM. Optionen und Festplattendefinitionen werden durch Kommata getrennt.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Das Boot-Medium, aus dem das initiale Betriebssystem installiert wird. In diesem Beispiel wird das zuvor heruntergeladene ISO-Abbild benutzt. Andere Geräte und weitere Optionen sind in der Xen™ Dokumentation beschrieben.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Optionen, die die VNC-Konnektivität der seriellen Konsole der DomU steuern. Dabei handelt es sich um die aktive VNC-Unterstützung, die verwendete IP-Adresse, der Gerätename der seriellen Konsole und die Eingabemethoden für Maus, Tastatur und andere Geräte. <code>keymap</code> konfiguriert die Tastaturbelegung, die in der Voreinstellung <code>english</code> ist.</td></tr></tbody></table></div><div class=paragraph><p>Nachdem die Konfigurationsdatei mit allen notwendigen Optionen erstellt wurde, wird die DomU erstellt, indem die Datei als Parameter an <code>xl</code> übergeben wird.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl create freebsd.cfg</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Jedes mal, wenn die Dom0 neu gestartet wird, muss die Konfigurationsdatei nochmals an <code>xl</code> übergeben werden, um die DomU neu zu erstellen. In der Voreinstellung wird nur die Dom0 nach einem Neustart angelegt, nicht die einzelnen VMs. Die VMs können dort fortfahren, wo sie aufgehört haben, weil sie das Betriebssystem auf der virtuellen Festplatte gespeichert haben. Die Konfiguration der virtuellen Maschine kann sich mit der Zeit ändern (bspw. beim Hinzufügen von mehr Arbeitsspeicher). Die Konfigurationsdateien der virtuellen Maschinen müssen ordnungsgemäß gesichert und vorgehalten werden, um die Gast-VM bei Bedarf neu erstellen zu können.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Ausgabe von <code>xl list</code> bestätigt, dass die DomU erstellt wurde.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl list</span>
Name                                        ID   Mem VCPUs      State   Time<span class=o>(</span>s<span class=o>)</span>
Domain-0                                     0  8192     4     r-----  1653.4
freebsd                                      1  1024     1     <span class=nt>-b----</span>   663.9</code></pre></div></div><div class=paragraph><p>Um die Installation des Basis-Betriebssystems zu beginnen, starten Sie den VNC-Client und verbinden Sie sich mit Netzwerkadresse des Hosts oder mit der IP-Adresse, die auf der Zeile <code>vnclisten</code> in <span class=filename>freebsd.cfg</span> konfiguriert wurde. Nachdem das Betriebssystem installiert ist, fahren Sie die DomU herunter und trennen den VNC-Viewer. Bearbeiten Sie dann die <span class=filename>freebsd.cfg</span>, entfernen Sie die Zeile mit der <code>cdrom</code> Definiton, oder kommentieren Sie die Zeile mit <code>#</code> aus. Um diese neue Konfiguration zu laden, ist es notwendig, die alte DomU mit <code>xl</code> zu zerstören, indem Sie entweder den Namen oder die ID als Parameter übergeben. Danach kann die DomU mit der angepassten <span class=filename>freebsd.cfg</span> neu erstellt werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl destroy freebsd</span>
<span class=c># xl create freebsd.cfg</span></code></pre></div></div><div class=paragraph><p>Auf die Maschine kann jetzt wieder mit dem VNC-Viewer zugegriffen werden. Dieses mal wird sie von einer virtuellen Festplatte booten, auf der das Betriebssystem installiert wurde. Die virtuelle Maschine kann nun verwendet werden.</p></div></div><div class=sect3><h4 id=virtualization-host-xen-troubleshooting>39.8.4. Fehlerbehebung<a class=anchor href=#virtualization-host-xen-troubleshooting></a></h4><div class=paragraph><p>Dieser Abschnitt enthält grundlegende Informationen, um Probleme zu beheben, die bei der Verwendung von FreeBSD als Host oder Gast von Xen™ auftreten können.</p></div><div class=sect4><h5 id=virtualization-host-xen-troubleshooting-host>39.8.4.1. Fehlerbehebung beim Booten des Hosts<a class=anchor href=#virtualization-host-xen-troubleshooting-host></a></h5><div class=paragraph><p>Bitte beachten Sie, dass die folgenden Tipps zur Fehlerbehebung für Xen™ 4.11 oder neuer gedacht sind. Wenn Sie noch Xen™ 4.7 benutzen und Probleme haben, sollten Sie die Migration auf eine neuere Version in Betracht ziehen.</p></div><div class=paragraph><p>Um Probleme beim Booten des Hosts zu beheben, benötigen Sie wahrscheinlich ein serielles Kabel oder ein USB-Kabel. Ausführliche Informationen während des Bootens erhalten Sie, wenn Sie die Option <code>xen_cmdline</code> in <span class=filename>loader.conf</span> hinzufügen. Einige relevante Optionen sind:</p></div><div class=ulist><ul><li><p><code>iommu=debug</code>: kann benutzt werden, um zusätzliche Informationen über das iommu auszugeben.</p></li><li><p><code>dom0=verbose</code>: kann benutzt werden, um zusätzliche Informationen über den dom0 Build Prozess auszugeben.</p></li><li><p><code>sync_console</code>: diese Option erzwingt eine synchrone Konsolenausgabe. Dies ist sehr nützlich für die Fehlersuche, um den Verlust von Nachrichten durch die Begrenzung zu vermeiden. Verwenden Sie diese Option niemals in produktiven Umgebungen, da sie es böswilligen Gästen ermöglichen kann, DoS-Angriffe gegen Xen™ über die Konsole durchzuführen.</p></li></ul></div><div class=paragraph><p>Um Probleme zu identifizieren, sollte FreeBSD beim Booten ebenfalls detaillierte Informationen anzeigen. Dies können Sie wie folgt aktivieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf boot_verbose=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Wenn keine dieser Optionen zur Lösung des Problems beiträgt, senden Sie bitte das serielle Bootprotokoll zur weiteren Analyse an <a href=mailto:freebsd-xen@FreeBSD.org>freebsd-xen@FreeBSD.org</a> und <a href=mailto:xen-devel@lists.xenproject.org>xen-devel@lists.xenproject.org</a>.</p></div></div><div class=sect4><h5 id=virtualization-host-xen-troubleshooting-guest>39.8.4.2. Fehlerbehebung beim Erstellen von Gastsystemen<a class=anchor href=#virtualization-host-xen-troubleshooting-guest></a></h5><div class=paragraph><p>Die folgenden Informationen können helfen, Probleme beim Erstellen von Gastsystemen zu diagnostizieren.</p></div><div class=paragraph><p>Die häufigste Ursache für Fehler beim Erstellen von Gastsystemen ist der <code>xl</code> Befehl, der einen Fehler generiert und mit einem Rückgabewert ungleich 0 endet. Wenn der angezeigte Fehler nicht ausreicht, um das Problem zu identifizieren, kann auch eine umfangreichere Ausgabe von <code>xl</code> erhalten werden, indem die Option <code>v</code> wiederholt verwendet wird.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl -vvv create freebsd.cfg</span>
Parsing config from freebsd.cfg
libxl: debug: libxl_create.c:1693:do_domain_create: Domain 0:ao 0x800d750a0: create: <span class=nv>how</span><span class=o>=</span>0x0 <span class=nv>callback</span><span class=o>=</span>0x0 <span class=nv>poller</span><span class=o>=</span>0x800d6f0f0
libxl: debug: libxl_device.c:397:libxl__device_disk_set_backend: Disk <span class=nv>vdev</span><span class=o>=</span>xvda spec.backend<span class=o>=</span>unknown
libxl: debug: libxl_device.c:432:libxl__device_disk_set_backend: Disk <span class=nv>vdev</span><span class=o>=</span>xvda, using backend phy
libxl: debug: libxl_create.c:1018:initiate_domain_create: Domain 1:running bootloader
libxl: debug: libxl_bootloader.c:328:libxl__bootloader_run: Domain 1:not a PV/PVH domain, skipping bootloader
libxl: debug: libxl_event.c:689:libxl__ev_xswatch_deregister: watch <span class=nv>w</span><span class=o>=</span>0x800d96b98: deregister unregistered
domainbuilder: detail: xc_dom_allocate: <span class=nv>cmdline</span><span class=o>=</span><span class=s2>&#34;&#34;</span>, <span class=nv>features</span><span class=o>=</span><span class=s2>&#34;&#34;</span>
domainbuilder: detail: xc_dom_kernel_file: <span class=nv>filename</span><span class=o>=</span><span class=s2>&#34;/usr/local/lib/xen/boot/hvmloader&#34;</span>
domainbuilder: detail: xc_dom_malloc_filemap    : 326 kB
libxl: debug: libxl_dom.c:988:libxl__load_hvm_firmware_module: Loading BIOS: /usr/local/shared/seabios/bios.bin
...</code></pre></div></div><div class=paragraph><p>Wenn die ausführliche Ausgabe nicht bei der Diagnose des Problems hilft, gibt es auch noch die Protokolle des QEMU und Xen™ Toolstacks in <span class=filename>/var/log/xen</span>. Beachten Sie, dass der Name der Domäne an den Protokollnamen angehängt wird. Wenn die Domäne also <code>freebsd</code> heißt, sollten Sie wahrscheinlich die Dateien <span class=filename>/var/log/xen/xl-freebsd.log</span> und <span class=filename>/var/log/xen/qemu-dm.freebsd.log</span> finden. Beide Dateien können nützliche Informationen zur Fehlerbehebung enthalten. Wenn nichts davon zur Lösung des Problems beiträgt, senden Sie bitte die Beschreibung des Problems und so viele Informationen wie möglich an <a href=mailto:freebsd-xen@FreeBSD.org>freebsd-xen@FreeBSD.org</a> und <a href=mailto:xen-devel@lists.xenproject.org>xen-devel@lists.xenproject.org</a>, um Hilfe zu erhalten.</p></div></div></div></div></div></div><div class=sect1><h2 id=l10n>Kapitel 40. Localization - i18n/L10n Usage and Setup<a class=anchor href=#l10n></a></h2><div class=sectionbody><div class=sect2><h3 id=l10n-synopsis>40.1. Übersicht<a class=anchor href=#l10n-synopsis></a></h3><div class=paragraph><p>FreeBSD ist ein verteiltes Projekt mit Nutzern und Mitwirkenden auf der ganzen Welt. Als solches unterstützt FreeBSD Lokalisierung für viele Sprachen, so dass Benutzer Daten in anderen Sprachen als Englisch anzeigen, eingeben und verarbeiten können. Sie können zwischen den meisten der verbreitetsten Sprachen der Welt wählen, unter anderem Chinesisch, Japanisch, Koreanisch, Französisch, Russisch, Vietnamesisch und Deutsch.</p></div><div class=paragraph><p>Der Begriff internationalization (englisch für Internationalisierung) wurde zu I18N abgekürzt, weil sich zwischen dem ersten und letzten Buchstaben des Worts 18 Buchstaben befinden. L10N benutzt die gleiche Namensgebung und ist eine Abkürzung des Wortes localization (englisch für Lokalisierung). Mit I18N/L10N-Methoden, -Protokollen und -Anwendungen können Benutzer eine Sprache ihrer Wahl verwenden.</p></div><div class=paragraph><p>Dieses Kapitel behandelt die Internationalisierung und Lokalisierung von FreeBSD. Nachdem Sie dieses Kapitel gelesen haben, werden Sie wissen:</p></div><div class=ulist><ul><li><p>wie der Name einer Locale aufgebaut ist.</p></li><li><p>wie die Locale einer Login-Shell gesetzt wird.</p></li><li><p>wie die Konsole für nicht-englische Sprachen konfiguriert wird.</p></li><li><p>wie Xorg mit verschiedenen Sprachen benutzt wird.</p></li><li><p>wie I18N-fähige Anwendungen gefunden werden können.</p></li><li><p>Wo Sie weitere Informationen über verschiedene Sprachen finden.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>Wissen, wie Sie <a href=#ports>zusätzliche Anwendungen installieren</a>.</p></li></ul></div></div><div class=sect2><h3 id=using-localization>40.2. Lokale Anpassungen benutzen<a class=anchor href=#using-localization></a></h3><div class=paragraph><p>Lokale Anpassungen werden durch die Angabe von drei Werten erreicht: dem Sprachcode, dem Ländercode und der Codierung. Die Zusammenfassung dieser Werte wird "Locale" genannt und sieht wie folgt aus:</p></div><div class="literalblock programlisting"><div class=content><pre>Sprachcode_Ländercode.Codierung</pre></div></div><div class=paragraph><p><em>Sprachcode</em> und <em>Ländercode</em> werden verwendet, um das Land und die spezifische Sprachvariation zu bestimmen. <a href=#locale-lang-country>Gebräuchliche Sprach- und Ländercodes</a> enthält dazu einige Beispiele:</p></div><table id=locale-lang-country class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 14. Gebräuchliche Sprach- und Ländercodes</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Sprachcode_Ländercode</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>en_US</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Englisch, Vereinigte Staaten</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ru_RU</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Russisch, Russland</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>zh_TW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Traditionelles Chinesisch, Taiwan</p></td></tr></tbody></table><div class=paragraph><p>Eine vollständige Liste der verfügbaren Lokalisierungen erhalten Sie durch die Eingabe von:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% locale <span class=nt>-a</span> | more</code></pre></div></div><div class=paragraph><p>Die aktuelle Ländereinstellung erhalten Sie mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% locale</code></pre></div></div><div class=paragraph><p>Sprachspezifische Zeichensätze, wie ISO8859-1, ISO8859-15, KOI8-R und CP437 werden in <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a> beschrieben. Eine Liste der Zeichensätze finden Sie in der <a href=http://www.iana.org/assignments/character-sets>IANA Registry</a>.</p></div><div class=paragraph><p>Einige Sprachen, darunter Chinesisch und Japanisch, können nicht mit ASCII-Zeichen dargestellt werden und benötigen eine erweiterte Sprachcodierung mit Wide- oder Multibyte-Zeichen. EUC und Big5 sind Beispiele für Wide- oder Multibyte-Codierungen. Ältere Anwendungen erkennen diese Zeichen nicht und halten sie fälschlicherweise für Steuerzeichen, während neure Anwendungen diese Zeichen in der Regel erkennen. Es hängt allerdings von der Implementierung ab, ob man eine Anwendung neu kompilieren muss, um lokale Zeichensätze zu bekommen, oder ob sie nur richtig konfiguriert werden muss.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD verwendet Xorg-kompatible Codierungen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Der Rest dieses Abschnitts beschreibt die verschiedenen Methoden zur Konfiguration von der Locale auf einem FreeBSD-System. Der folgende Abschnitt beschreibt den Bau von Anwendungen mit I18N-Unterstützung.</p></div><div class=sect3><h4 id=setting-locale>40.2.1. Einstellen der Locale für die Login-Shell<a class=anchor href=#setting-locale></a></h4><div class=paragraph><p>Die Einstellungen für Locale werden entweder in der <span class=filename>~/.login_conf</span> des Benutzers, oder der Startdatei der Shell (<span class=filename>~/.profile</span>, <span class=filename>~/.bashrc</span> oder <span class=filename>~/.cshrc</span>) konfiguriert.</p></div><div class=paragraph><p>Zwei Umgebungsvariablen sollten konfiguriert werden:</p></div><div class=ulist><ul><li><p><code>LANG</code>, das die Locale einstellt.</p></li><li><p><code>MM_CHARSET</code>, das den MIME Zeichensatz für Anwendungen einstellt.</p></li></ul></div><div class=paragraph><p>Neben der Shell-Konfiguration des Benutzers sollten diese Variablen auch für spezifische Anwendungen und Xorg-Konfigurationen eingestellt werden.</p></div><div class=paragraph><p>Es gibt zwei Methoden, die Locale zu setzen: die erste und empfohlene Methode ist, die Umgebungsvariablen in der <a href=#login-class>Login-Klasse</a> zu setzen, die zweite Methode ist, sie in den <a href=#startup-file>Startdateien</a> der Shell zu setzen. In den nächsten Abschnitten werden beide Methoden vorgestellt.</p></div><div class=sect4><h5 id=login-class>40.2.1.1. Lokalisierung in der Login-Klasse<a class=anchor href=#login-class></a></h5><div class=paragraph><p>Die erste Methode wird empfohlen, da sie die Umgebungsvariablen für die Login-Klasse und den MIME Zeichensatz für alle Shells zuweist. Die Lokalisierung kann von einem Benutzer selbst, oder vom Superuser für alle Benutzer eingestellt werden.</p></div><div class=paragraph><p><span class=filename>.login_conf</span> im Heimatverzeichnis eines Benutzers sollte mindestens die folgenden Einträge enthalten, damit beide Variablen für den Gebrauch der Latin-1 Codierung gesetzt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>me:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:</pre></div></div><div class=paragraph><p>Damit traditionelles Chinesisch (BIG-5 Codierung) verwendet werden kann, sind in <span class=filename>~/.login_conf</span> des Benutzers die nachstehenden Ergänzungen vorzunehmen. Einige Programme behandeln die Lokalisierung für Chinesisch, Japanisch und Koreanisch falsch, daher müssen mehr Variablen als üblich gesetzt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>#Users who do not wish to use monetary units or time formats
#of Taiwan can manually change each variable
me:\
	:lang=zh_TW.Big5:\
	:setenv=LC_ALL=zh_TW.Big5,LC_COLLATE=zh_TW.Big5,LC_CTYPE=zh_TW.Big5,LC_MESSAGES=zh_TW.Big5,LC_MONETARY=zh_TW.Big5,LC_NUMERIC=zh_TW.Big5,LC_TIME=     zh_TW.Big5:\
	:charset=big5:\
	:xmodifiers=&#34;@im=gcin&#34;: #Set gcin as the XIM Input Server</pre></div></div><div class=paragraph><p>Alternativ kann der Superuser die Lokalisierung für alle Benutzer konfigurieren. Die folgenden Variablen in <span class=filename>/etc/login.conf</span> setzen die richtige Login-Klasse und den richtigen MIME Zeichensatz:</p></div><div class="literalblock programlisting"><div class=content><pre>Sprache|Account-Typ-Beschreibung:\
	:charset=MIME_Zeichensatz:\
	:lang=Locale:\
	:tc=default:</pre></div></div><div class=paragraph><p>Die für Latin-1 erforderlichen Einträge würden wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>german|German Users Accounts:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:\
	:tc=default:</pre></div></div><div class=paragraph><p>Weitere Einzelheiten über diese Variablen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>. Beachten Sie, dass die Datei bereits vordefinierte <em>russische</em> Login-Klassen enthält.</p></div><div class=paragraph><p>Jedes Mal, wenn <span class=filename>/etc/login.conf</span> bearbeitet wurde, muss die Datenbank mit dem folgenden Kommando aktualisiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Der reguläre Benutzer muss den Befehl <code>cap_mkdb</code> auf seine <span class=filename>~/.login_conf</span> anwenden, damit die Änderungen wirksam werden.</p></div></td></tr></tbody></table></div><div class=sect5><h6 id=_werkzeuge_zum_ändern_der_login_klasse>40.2.1.1.1. Werkzeuge zum Ändern der Login-Klasse<a class=anchor href=#_werkzeuge_zum_ändern_der_login_klasse></a></h6><div class=paragraph><p>Neben der manuellen Konfiguration von <span class=filename>/etc/login.conf</span>, stehen mehrere Werkzeuge bereit, um die Login-Klasse für neue Benutzer einzustellen.</p></div><div class=paragraph><p>Wenn Sie neue Accounts mit <code>vipw</code> anlegen, setzen Sie im Feld <em>Sprache</em> die gewünschte Sprache ein:</p></div><div class="literalblock programlisting"><div class=content><pre>user:password:1111:11:Sprache:0:0:Benutzername:/home/user:/bin/sh</pre></div></div><div class=paragraph><p>Wenn Sie mit <code>adduser</code> neue Benutzer anlegen, können Sie die voreingestellte Sprache für alle Benutzer, oder für einen einzelnen Benutzer einstellen:</p></div><div class=paragraph><p>Falls alle Benutzer die gleiche Sprache benutzen, setzen Sie <code>defaultclass=<em>Sprache</em></code> in <span class=filename>/etc/adduser.conf</span>.</p></div><div class=paragraph><p>Wenn Sie diese Einstellung beim Anlegen des Benutzers überschreiben wollen, geben Sie entweder die gewünschte Login-Klasse am Prompt ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter login class: default <span class=o>[]</span>:</code></pre></div></div><div class=paragraph><p>oder übergeben Sie die Login-Klasse beim Aufruf von <code>adduser</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser -class Sprache</span></code></pre></div></div><div class=paragraph><p>Wenn Sie neue Benutzer mit <code>pw</code> anlegen, geben Sie die Login-Klasse wie folgt an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd Benutzername -L Sprache</span></code></pre></div></div><div class=paragraph><p>Um die Login-Klasse eines bestehenden Benutzers zu ändern, kann <code>chpass</code> verwendet werden. Rufen Sie das Kommando als Superuser auf und geben Sie als Argument den entsprechenden Benutzernamen mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chpass Benutzername</span></code></pre></div></div></div></div><div class=sect4><h5 id=startup-file>40.2.1.2. Lokalisierung in den Startdateien der Shells<a class=anchor href=#startup-file></a></h5><div class=paragraph><p>Diese zweite Methode wird nicht empfohlen, da jede Shell unterschiedlich eingerichtet wird, eine unterschiedliche Konfigurationsdatei und Syntax verwendet. Um beispielsweise die deutsche Sprache für die <code>sh</code> zu setzen, fügen Sie für einen Benutzer die folgende Zeilen in <span class=filename>~/.profile</span> ein. Sie können diese Zeilen auch für alle Benutzer der <code>sh</code> Shell in <span class=filename>/etc/profile</span> oder <span class=filename>/usr/shared/skel/dot.profile</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG
MM_CHARSET=ISO-8859-1; export MM_CHARSET</pre></div></div><div class=paragraph><p>Die <code>csh</code> Shell verwendet jedoch eine andere Konfigurationsdatei und eine andere Syntax. Dies sind die entsprechenden Einstellungen für <span class=filename>~/.csh.login</span>, <span class=filename>/etc/csh.login</span> oder <span class=filename>/usr/shared/skel/dot.login</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1
setenv MM_CHARSET ISO-8859-1</pre></div></div><div class=paragraph><p>Die Syntax zur Konfiguration von Xorg in <span class=filename>~/.xinitrc</span> hängt ebenfalls von der verwendeten Shell ab. Das erste Beispiel ist für die <code>sh</code> Shell, das zweite für die <code>csh</code> Shell:</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG</pre></div></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1</pre></div></div></div></div><div class=sect3><h4 id=setting-console>40.2.2. Einrichten der Konsole<a class=anchor href=#setting-console></a></h4><div class=paragraph><p>Für die Konsole stehen mehrere lokalisierte Sprachen zur Verfügung. Eine Liste der verfügbaren Schriften erhalten Sie mit <code>ls /usr/shared/syscons/fonts</code>. Um die Schriftart für die Konsole zu konfigurieren, setzen Sie den gewünschten <em>Zeichensatz</em> ohne die Endung <span class=filename>.fnt</span> in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>font8x16=Zeichensatz
font8x14=Zeichensatz
font8x8=Zeichensatz</pre></div></div><div class=paragraph><p>Die Tasten- und Bildschirmzuordnung (keymap und screenmap) kann in mit den folgenden Einträgen in <span class=filename>/etc/rc.conf</span> gesetzt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>scrnmap=screenmap_name
keymap=keymap_name
keychange=&#34;fkey_number sequence&#34;</pre></div></div><div class=paragraph><p>Eine Liste der verfügbaren Bildschirmzuordnungen erhalten Sie mit <code>ls /usr/shared/syscons/scrnmaps</code>. Spezifizieren Sie <em>screenmap_name</em> ohne die Endung <span class=filename>.scm</span>. Eine Bildschirmzuordnung und der zugehörige Zeichensatz verbreitert die Zeichenmatrix von VGA Karten von 8 Bit auf 9 Bit. Sie wird benötigt, wenn der Zeichensatz des Bildschirms 8 Bit verwendet.</p></div><div class=paragraph><p>Eine Liste der verfügbaren Tastenzuordnungen erhalten Sie mit <code>ls /usr/shared/syscons/keymaps</code>. Spezifizieren Sie <em>keymap_name</em> ohne die Endung <span class=filename>.kbd</span>. Eine Tastenzuordnung können Sie ohne einen Neustart mit <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdmap&amp;sektion=1&amp;format=html">kbdmap(1)</a> ausprobieren.</p></div><div class=paragraph><p>Der Eintrag <code>keychange</code> programmiert die Funktionstasten so, dass sie zu dem ausgesuchten Terminal passen. Die Sequenzen der Funktionstasten können nicht in Tastenzuordnungen definiert werden.</p></div><div class=paragraph><p>Setzen Sie als nächstes für alle Terminals den richtigen Terminaltyp in <span class=filename>/etc/ttys</span>. <a href=#locale-charset>Terminaltypen für Zeichensätze</a> enthält eine Zusammenfassung der verfügbaren Terminaltypen.</p></div><table id=locale-charset class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 15. Terminaltypen für Zeichensätze</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Zeichensatz</th><th class="tableblock halign-left valign-top">Terminaltyp</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-1 oder ISO8859-15</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l7</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-R</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25r</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25u</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CP437 (VGA default)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>US-ASCII</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25w</code></p></td></tr></tbody></table><div class=paragraph><p>Mit Wide- oder Multibyte-Zeichensätzen müssen Sie die entsprechende Konsole aus der FreeBSD Ports-Sammlung installieren. Die verfügbaren Ports sind in <a href=#locale-console>Konsolen aus der Ports-Sammlung</a> zusammengefasst. Nachdem Sie einen Port installiert haben, finden Sie in der Manualpage oder der <span class=filename>pkg-message</span> des Ports Anweisungen zur Konfiguration und Benutzung der Konsole.</p></div><table id=locale-console class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 16. Konsolen aus der Ports-Sammlung</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Sprache</th><th class="tableblock halign-left valign-top">Port</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>traditionelles Chinesisch (BIG-5)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/big5con/>chinese/big5con</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinesisch/Japanisch/Koreanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/cce/>chinese/cce</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinesisch/Japanisch/Koreanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/zhcon/>chinese/zhcon</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/kon2/>chinese/kon2</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-14dot/>japanese/kon2-14dot</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-16dot/>japanese/kon2-16dot</a></p></td></tr></tbody></table><div class=paragraph><p>Wenn Sie moused in <span class=filename>/etc/rc.conf</span> aktiviert haben, ist vielleicht noch weitere Konfiguration nötig. Der Mauszeiger des <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> Treibers belegt in der Voreinstellung den Bereich von <code>0xd0</code> bis <code>0xd3</code> des Zeichensatzes. Wenn dieser Bereich ebenfalls von der eingestellten Sprache benötigt wird, müssen Sie den Mauszeiger verschieben. Fügen Sie dazu die folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>mousechar_start=3</pre></div></div></div><div class=sect3><h4 id=_einrichtung_von_xorg>40.2.3. Einrichtung von Xorg<a class=anchor href=#_einrichtung_von_xorg></a></h4><div class=paragraph><p><a href=./#x11>Das X-Window-System</a> beschreibt die Installation und Konfiguration von Xorg. Wenn Xorg für die Lokalisierung eingerichtet wird, stehen zusätzliche Zeichensätze und Eingabemethoden in der FreeBSD Ports-Sammlung zur Verfügung. Anwendungsspezifische I18N-Einstellungen, wie etwa Zeichensätze und Menüs, können in <span class=filename>~/.Xresources</span> angepasst werden, damit in den graphischen Anwendungen des Benutzers die gewählte Sprache angezeigt wird.</p></div><div class=paragraph><p>Das X Input Method (XIM) Protokoll ist ein Xorg-Standard für die Eingabe von nicht-englischen Zeichen. <a href=#locale-xim>Verfügbare Eingabemethoden</a> fasst die aus der FreeBSD Ports-Sammlung verfügbaren Anwendungen für die Eingabemethoden zusammen. Zusätzliche Fcitx- und Uim-Anwendungen sind ebenfalls verfügbar.</p></div><table id=locale-xim class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 17. Verfügbare Eingabemethoden</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Sprache</th><th class="tableblock halign-left valign-top">Eingabemethode</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinesisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/gcin/>chinese/gcin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinesisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/ibus-chewing/>chinese/ibus-chewing</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinesisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/ibus-pinyin/>chinese/ibus-pinyin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinesisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/oxim/>chinese/oxim</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinesisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-fcitx/>chinese/scim-fcitx</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinesisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-pinyin/>chinese/scim-pinyin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinesisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-tables/>chinese/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-anthy/>japanese/ibus-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-mozc/>japanese/ibus-mozc</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-skk/>japanese/ibus-skk</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/im-ja/>japanese/im-ja</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kinput2/>japanese/kinput2</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-anthy/>japanese/scim-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-canna/>japanese/scim-canna</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka/>japanese/scim-honoka</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka-plugin-romkan/>japanese/scim-honoka-plugin-romkan</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka-plugin-wnn/>japanese/scim-honoka-plugin-wnn</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-prime/>japanese/scim-prime</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-skk/>japanese/scim-skk</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-tables/>japanese/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-tomoe/>japanese/scim-tomoe</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-uim/>japanese/scim-uim</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/skkinput/>japanese/skkinput</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/skkinput3/>japanese/skkinput3</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/uim-anthy/>japanese/uim-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Koreanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/ibus-hangul/>korean/ibus-hangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Koreanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/imhangul/>korean/imhangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Koreanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/nabi/>korean/nabi</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Koreanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/scim-hangul/>korean/scim-hangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Koreanisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/scim-tables/>korean/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Vietnamesisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/vietnamese/xvnkb/>vietnamese/xvnkb</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Vietnamesisch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/vietnamese/x-unikey/>vietnamese/x-unikey</a></p></td></tr></tbody></table></div></div><div class=sect2><h3 id=l10n-compiling>40.3. I18N-Programme<a class=anchor href=#l10n-compiling></a></h3><div class=paragraph><p>I18N-Anwendungen werden mit Hilfe von I18N-Bibliotheken programmiert. Diese erlauben es Entwicklern, eine einfache Sprachdatei zu schreiben und Menüs und Texte an jede Sprache anzupassen.</p></div><div class=paragraph><p>Die <a href=https://www.FreeBSD.org/ports/>FreeBSD Ports-Sammlung</a> enthält Programme mit Unterstützung für Wide- und Mulitbyte-Zeichensätze für verschiedene Sprachen. Konsultieren Sie die I18N-Dokumentation des entsprechenden Ports für Informationen, wie das Programm zu konfigurieren ist und welche Optionen beim Übersetzen anzugeben sind.</p></div><div class=paragraph><p>Viele Anwendungen aus der FreeBSD Ports-Sammlung bieten I18N-Unterstützung. Diese enthalten, zur einfachen Identifikation, <code>-i18n</code> im Namen. Es werden jedoch nicht alle Sprachen unterstützt.</p></div><div class=paragraph><p>Einige Anwendungen können mit einem bestimmten Zeichensatz konfiguriert werden. Dies erfolgt entweder im <span class=filename>Makefile</span>, oder über spezielle Parameter, die an configure übergeben werden. Lesen Sie die I18N-Dokumentation des entsprechenden Ports für Informationen, wie das Programm zu konfigurieren ist und welche Optionen beim Übersetzen anzugeben sind.</p></div></div><div class=sect2><h3 id=lang-setup>40.4. Lokalisierung für einzelne Sprachen<a class=anchor href=#lang-setup></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt die Lokalisierung eines FreeBSD-Systems für die russische Sprache. Außerdem werden einige zusätzliche Ressourcen für die Lokalisierung in anderen Sprachen zur Verfügung gestellt.</p></div><div class=sect3><h4 id=ru-localize>40.4.1. Russisch (KOI8-R Codierung)<a class=anchor href=#ru-localize></a></h4><div class=paragraph><p>Um diese Locale für die Login-Shell zu setzen, fügen Sie die folgenden Zeilen in die <span class=filename>~/.login_conf</span> des Benutzers ein:</p></div><div class="literalblock programlisting"><div class=content><pre>me:My Account:\
	:charset=KOI8-R:\
	:lang=ru_RU.KOI8-R:</pre></div></div><div class=paragraph><p>Fügen Sie folgende Zeile für die Konsole in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>keymap=&#34;ru.utf-8&#34;
scrnmap=&#34;utf-82cp866&#34;
font8x16=&#34;cp866b-8x16&#34;
font8x14=&#34;cp866-8x14&#34;
font8x8=&#34;cp866-8x8&#34;
mousechar_start=3</pre></div></div><div class=paragraph><p>Benutzen Sie <code>cons25r</code> als Terminaltyp für jeden <code>ttyv</code> Eintrag in <span class=filename>/etc/ttys</span>.</p></div><div class=paragraph><p>Damit der Druck funktioniert, wird ein spezieller Filter zur Übersetzung von KOI8-R nach CP866 benötigt, da die meisten Drucker mit russischen Zeichen die Codetabelle CP866 verwenden. FreeBSD enthält im Basissystem einen Filter zu diesem Zweck. Um diesen Filter zu benutzen, fügen Sie folgenden Eintrag in <span class=filename>/etc/printcap</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>lp|Russian local line printer:\
	:sh:of=/usr/libexec/lpr/ru/koi2alt:\
	:lp=/dev/lpt0:sd=/var/spool/output/lpd:lf=/var/log/lpd-errs:</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> enthält eine ausführlichere Erklärung.</p></div><div class=paragraph><p>Russische Dateinamen auf MS-DOS® Dateisystemen werden durch <code>-L</code> und dem Namen der Locale in <span class=filename>/etc/fstab</span> erkannt:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ad0s2      /dos/c  msdos   rw,-Lru_RU.KOI8-R 0 0</pre></div></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a>.</p></div><div class=paragraph><p>Wenn Sie Xorg verwenden, installieren Sie das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/xorg-fonts-cyrillic/>x11-fonts/xorg-fonts-cyrillic</a>. Im Abschnitt <code>"Files"</code> von <span class=filename>/etc/X11/xorg.conf</span> fügen Sie dann den folgenden Eintrag <em>vor</em> allen anderen <code>FontPath</code> Einträgen ein:</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath   &#34;/usr/local/lib/X11/fonts/cyrillic&#34;</pre></div></div><div class=paragraph><p>Zusätzliche kyrillische Schriftarten finden Sie in der Ports-Sammlung.</p></div><div class=paragraph><p>Die Unterstützung für eine russische Tastatur aktivieren Sie im Abschnitt <code>"Keyboard"</code> von <span class=filename>xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbLayout&#34;   &#34;us,ru&#34;
Option &#34;XkbOptions&#34;  &#34;grp:toggle&#34;</pre></div></div><div class=paragraph><p>Stellen Sie zudem sicher, dass <code>XkbDisable</code> auskommentiert ist.</p></div><div class=paragraph><p>Beim Einsatz von <code>grp:toggle</code> können Sie mit <kbd>Right Alt</kbd> (Alt Gr) zwischen dem RUS- und LAT-Modus wechseln, verwenden Sie hingegen <code>grp:ctrl_shift_toggle</code>, so erfolgt der Wechsel mit <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Shift</kbd></span>. Für <code>grp:caps_toggle</code> ist zum Wechseln des RUS/LAT-Modus <kbd>CapsLock</kbd> zuständig. Die alte Funktion von <kbd>CapsLock</kbd> steht nur im LAT-Modus mit der Tastenkombination <span class=keyseq><kbd>Shift</kbd>+<kbd>CapsLock</kbd></span> zur Verfügung. <code>grp:caps_toggle</code> funktioniert aus unbekannten Gründen unter Xorg nicht.</p></div><div class=paragraph><p>Wenn die Tastatur Windows®-Tasten besitzt und nicht-alphanumerische Tasten nicht funktionieren, fügen Sie die folgende Zeile in <span class=filename>xorg.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbVariant&#34; &#34;,winkeys&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die russische XKB-Tastatur funktioniert vielleicht nicht mit nicht-lokalisierten Anwendungen. Lokalisierte Anwendungen sollten mindestens die Funktion <code>XtSetLanguageProc (NULL, NULL, NULL);</code> frühzeitig aufrufen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Weitere Informationen über die Lokalisierung von Xorg-Anwendungen erhalten Sie auf der Webseite <a href=http://koi8.pp.ru/xwin.html>http://koi8.pp.ru/xwin.html</a>. Allgemeine Informatinen über die KOI8-R Codierung finden Sie auf <a href=http://koi8.pp.ru>http://koi8.pp.ru</a>.</p></div></div><div class=sect3><h4 id=_weitere_sprachspezifische_ressourcen>40.4.2. Weitere sprachspezifische Ressourcen<a class=anchor href=#_weitere_sprachspezifische_ressourcen></a></h4><div class=paragraph><p>Dieser Abschnitt enthält einige zusätzliche Ressourcen für die Konfiguration anderer Lokalisierungen.</p></div><div class=dlist><dl><dt class=hdlist1>Traditionelles Chinesisch für Taiwan</dt><dd><p>Das taiwanesische FreeBSD Projekt stellt ein Tutorium unter <a href=http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/>http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/</a> zur Verfügung.</p></dd><dt class=hdlist1>Griechische Lokalisierung</dt><dd><p>Ein Artikel über die Unterstützung für Griechisch steht unter <a href=https://www.FreeBSD.org/doc/el/articles/greek-language-support/>http://www.freebsd.org/doc/el/articles/greek-language-support/</a>. Bitte beachten Sie, dass dies <em>nur</em> für Griechisch gilt.</p></dd><dt class=hdlist1>Japanische und koreanische Lokalisierung</dt><dd><p>Informationen über die japanische Lokalisierung entnehmen Sie bitte <a href=http://www.jp.FreeBSD.org/>http://www.jp.FreeBSD.org/</a>, Informationen über die koreanische Lokalisierung erhalten Sie unter <a href=http://www.kr.FreeBSD.org/>http://www.kr.FreeBSD.org/</a>.</p></dd><dt class=hdlist1>Nicht-englische FreeBSD-Dokumentation</dt><dd><p>Teile der FreeBSD Dokumentation wurden von Beitragenden in andere Sprachen übersetzt. Folgen Sie den Links auf der <a href=https://www.FreeBSD.org/de/>FreeBSD-Webseite</a> oder schauen Sie in <span class=filename>/usr/shared/doc</span> nach.</p></dd></dl></div></div></div></div></div><div class=sect1><h2 id=updating-upgrading>Kapitel 41. FreeBSD aktualisieren<a class=anchor href=#updating-upgrading></a></h2><div class=sectionbody><div class=sect2><h3 id=updating-upgrading-synopsis>41.1. Übersicht<a class=anchor href=#updating-upgrading-synopsis></a></h3><div class=paragraph><p>FreeBSD wird zwischen einzelnen Releases ständig weiter entwickelt. Manche Leute bevorzugen die offiziellen Release-Versionen, während andere wiederum lieber auf dem aktuellen Stand der Entwicklung bleiben möchten. Wie dem auch sei, sogar offizielle Release-Versionen werden oft mit Sicherheitsaktualisierungen und anderen kritischen Fehlerbereinigungen versorgt. Unabhängig von der eingesetzten Version bringt FreeBSD alle nötigen Werkzeuge mit, um das System aktuell zu halten und es innerhalb verschiedener Versionen zu aktualisieren. Dieses Kapitel beschreibt, wie man einem Entwicklungssystem folgen kann, sowie die grundlegenden Werkzeuge um FreeBSD zu aktualisieren.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</p></div><div class=ulist><ul><li><p>wissen, wie das System mit freebsd-update oder Subversion aktualisiert wird.</p></li><li><p>wissen, wie man das aktuell installierte System mit einer ursprünglichen Version vergleicht.</p></li><li><p>wissen, wie die installierte Dokumentation mit Subversion oder Dokumentations-Ports aktualisiert wird.</p></li><li><p>den Unterschied zwischen den beiden Entwicklungszweigen FreeBSD-STABLE und FreeBSD-CURRENT kennen.</p></li><li><p>wissen, wie das komplette Basissystem neu gebaut und installiert wird.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie</p></div><div class=ulist><ul><li><p>das Netzwerk richtig konfiguriert haben (<a href=./#advanced-networking>Weiterführende Netzwerkthemen</a>).</p></li><li><p>wissen, wie Software Dritter installiert wird (<a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a>).</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In diesem Kapitel wird <code>svnlite</code> benutzt, um die FreeBSD Quellen zu beziehen und zu aktualisieren. Alternativ kann auch der Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/devel/subversion/>devel/subversion</a> installiert werden.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=updating-upgrading-freebsdupdate>41.2. FreeBSD-Update<a class=anchor href=#updating-upgrading-freebsdupdate></a></h3><div class=paragraph><p>Das zeitnahe Einspielen von Sicherheitsaktualisierungen und die Aktualisierung des Betriebssystems sind wichtige Aspekte der Systemadministration. FreeBSD enthält das Werkzeug <code>freebsd-update</code>, mit dem Sie diese beiden Aufgaben erfüllen können.</p></div><div class=paragraph><p>Dieses Werkzeug ermöglicht die Anwendung von Sicherheitsaktualisierungen im Binärformat auf das FreeBSD Basissystem, ohne dieses neu zu übersetzen und zu installieren. Die Aktualisierungen im Binärformat sind für alle Architekturen und Versionen verfügbar, welche vom FreeBSD Sicherheitsteam unterstützt werden. Eine Liste der unterstützten Versionen und der End-of-Life-Daten ist unter <a href=https://www.FreeBSD.org/security/>https://www.FreeBSD.org/security/</a> aufgeführt.</p></div><div class=paragraph><p><code>freebsd-update</code> unterstützt auch die Aktualisierung des Betriebssystems auf eine neuere Unterversion sowie eine Aktualisierung auf einen anderen Release-Zweig. Bevor Sie auf eine neue Version aktualisieren, sollten Sie die aktuellen Ankündigungen zu dem Release gelesen haben, da diese wichtige Informationen zu dem entsprechenden Release enthalten. Ankündigungen finden Sie unter <a href=https://www.FreeBSD.org/releases/>https://www.FreeBSD.org/releases/</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn eine <code>crontab</code> existiert, welche die Eigenschaften von <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> verwendet, muss diese deaktiviert werden, bevor das Betriebssystem aktualisiert wird.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dieser Abschnitt beschreibt die Verwendung der Konfigurationsdatei von <code>freebsd-update</code>. Es wird gezeigt wie Sie Sicherheitsaktualisierungen einspielen, oder wie Sie das Betriebssystem auf neuere Haupt- und Unterversionen aktualisieren können.</p></div><div class=sect3><h4 id=freebsdupdate-config-file>41.2.1. Die Konfigurationsdatei<a class=anchor href=#freebsdupdate-config-file></a></h4><div class=paragraph><p>In der Regel muss die Konfigurationsdatei von <code>freebsd-update</code> nicht bearbeitet werden. Manche Benutzer möchten die Standard-Konfigurationsdatei <span class=filename>/etc/freebsd-update.conf</span> trotzdem anpassen, um bessere Kontrolle über den gesamten Prozess zu besitzen. Die Kommentare in dieser Datei beschreiben die verfügbaren Optionen, jedoch benötigen die folgenden ein paar zusätzliche Erklärungen:</p></div><div class="literalblock programlisting"><div class=content><pre># Components of the base system which should be kept updated.
Components world kernel</pre></div></div><div class=paragraph><p>Dieser Parameter kontrolliert, welche Teile von FreeBSD auf dem aktuellen Stand gehalten werden sollen. In der Voreinstellung wird das gesamte Basissystem sowie der Kernel aktualisiert. Es können auch einzelne Komponenten, wie <code>src/base</code> oder <code>src/sys</code>, angegeben werden. Die beste Einstellung ist, diese Option so zu belassen, da eine Änderung es bedingt, dass man als Benutzer jede Komponente auflisten muss, die aktualisiert werden soll. Dies könnte katastrophale Folgen nach sich ziehen, da der Quellcode und die Binärdateien dadurch nicht mehr synchron wären.</p></div><div class="literalblock programlisting"><div class=content><pre># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths /boot/kernel/linker.hints</pre></div></div><div class=paragraph><p>Fügen Sie Pfade wie <span class=filename>/bin</span> oder <span class=filename>/sbin</span> hinzu, um diese speziellen Verzeichnisse während des Aktualisierungsprozesses unberührt zu lassen. Diese Option kann verwendet werden, um zu verhindern, dass <code>freebsd-update</code> lokale Änderungen überschreibt.</p></div><div class="literalblock programlisting"><div class=content><pre># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</pre></div></div><div class=paragraph><p>Diese Option aktualisiert nur unmodifizierte Konfigurationsdateien in den angegebenen Verzeichnissen. Jede Änderung, die der Benutzer daran vorgenommen hat, wird die automatische Aktualisierung dieser Dateien verhindern. Es gibt eine weitere Option <code>KeepModifiedMetadata</code>, die <code>freebsd-update</code> instruiert, die Änderungen während der Zusammenführung zu speichern.</p></div><div class="literalblock programlisting"><div class=content><pre># When upgrading to a new FreeBSD release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints</pre></div></div><div class=paragraph><p>Eine Liste von Verzeichnissen mit Konfigurationsdateien, in denen <code>freebsd-update</code> Zusammenführungen versuchen soll. Dieser Verschmelzungsprozess von Dateien ist eine Serie von <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a>-Korrekturen, ähnlich wie <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a>, aber mit weniger Optionen. Die Änderungen werden entweder akzeptiert, oder öffnen einen Editor, oder <code>freebsd-update</code> bricht ab. Im Zweifelsfall sichern Sie <span class=filename>/etc</span> und akzeptieren einfach die Änderungen. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a>, um Informationen über <code>mergemaster</code> zu erhalten.</p></div><div class="literalblock programlisting"><div class=content><pre># Directory in which to store downloaded updates and temporary
# files used by FreeBSD Update.
# WorkDir /var/db/freebsd-update</pre></div></div><div class=paragraph><p>In diesem Verzeichnis werden alle Korrekturen und temporären Dateien abgelegt. Im Falle einer Versionsaktualisierung sollte diesem Verzeichnis mindestens ein Gigabyte Festplattenspeicher zur Verfügung stehen.</p></div><div class="literalblock programlisting"><div class=content><pre># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which FreeBSD Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</pre></div></div><div class=paragraph><p>Wenn diese Option auf <code>yes</code> gesetzt ist, wird <code>freebsd-update</code> annehmen, dass die <code>Components</code>-Liste vollständig ist und nicht versuchen, Änderungen ausserhalb dieser Liste zu tätigen. Tatsächlich wird <code>freebsd-update</code> versuchen, jede Datei zu aktualisieren, die zu der <code>Components</code>-Liste gehört.</p></div></div><div class=sect3><h4 id=freebsdupdate-security-patches>41.2.2. Sicherheitskorrekturen anwenden<a class=anchor href=#freebsdupdate-security-patches></a></h4><div class=paragraph><p>Das Einspielen von FreeBSD Sicherheitskorrekturen wurde dahingehend vereinfacht, dass der Administrator nun das gesamte System mit <code>freebsd-update</code> auf dem aktuellen Stand halten kann. Weitere Informationen zu FreeBSD Sicherheitshinweisen finden Sie in <a href=./#security-advisories>FreeBSD Sicherheitshinweise</a>.</p></div><div class=paragraph><p>Sicherheitskorrekturen für FreeBSD können wie folgt heruntergeladen und installiert werden. Das erste Kommando prüft, ob noch ausstehende Korrekturen verfügbar sind, und wenn dass der Fall ist, zeigt es welche Dateien davon betroffen wären. Das zweite Kommando wird die Korrekturen auf das System anwenden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update fetch</span>
<span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>Wenn während der Aktualisierung Korrekturen am Kernel angewendet werden, muss das System neu gestartet werden, damit der korrigierte Kernel gebootet wird. Wenn die Korrekturen auf laufende Binärdateien angewendet werden, sollten die betroffenen Anwendungen neu gestartet werden, damit die korrigierte Version der Binärdatei geladen wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Im Regelfall muss der Benutzer darauf vorbereitet sein, das System neu zu starten. Um herauszufinden, ob ein Neustart durch eine Aktualisierung des Kernels erforderlich ist, führen Sie die Befehle <code>freebsd-version -k</code> und <code>uname -r</code> aus. Ist die Ausgabe dieser Befehle unterschiedlich, ist ein Neustart des Systems erforderlich.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Mit dem folgenden Eintrag in <span class=filename>/etc/crontab</span> wird das System einmal täglich nach Aktualisierungen suchen:</p></div><div class="literalblock programlisting"><div class=content><pre>@daily                                  root    freebsd-update cron</pre></div></div><div class=paragraph><p>Wenn Korrekturen existieren, werden diese automatisch heruntergeladen, aber nicht eingespielt. Der <code>root</code>-Benutzer bekommt eine Nachricht, damit die Korrekturen überprüft und mit <code>freebsd-update install</code> manuell installiert werden können.</p></div><div class=paragraph><p>Wenn etwas schief geht, kann <code>freebsd-update</code> den letzten Satz von Änderungen mit folgendem Befehl rückgängig machen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update rollback</span>
Uninstalling updates... <span class=k>done</span>.</code></pre></div></div><div class=paragraph><p>Wie bereits erwähnt, sollte das System neu gestartet werden, wenn der Kernel oder ein Kernelmodul verändert wurde. Betroffene Anwendungen sollten neu gestartet werden, wenn Binärdateien verändert wurden.</p></div><div class=paragraph><p>Das <code>freebsd-update</code>-Werkzeug kann nur den <span class=filename>GENERIC</span>-Kernel automatisch aktualisieren. Wenn ein angepasster Kernel verwendet wird, muss dieser neu erstellt und installiert werden, nachdem <code>freebsd-update</code> die Aktualisierungen durchgeführt hat. Der voreingestellte Kernel ist <em>GENERIC</em>. Benutzen Sie das Kommando <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> um dies zu überprüfen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Behalten Sie immer eine Kopie des <span class=filename>GENERIC</span>-Kernels in <span class=filename>/boot/GENERIC</span>. Das wird bei der Diagnose von verschiedenen Problemen sowie bei der Durchführung von Versionsaktualisierungen eine große Hilfe sein. Im <a href=#freebsd-update-custom-kernel-9x>Angepasste Kernel unter FreeBSD 9.X und später</a> wird beschrieben, wie Sie eine Kopie des <span class=filename>GENERIC</span>-Kernels bekommen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Solange die Standardkonfiguration in <span class=filename>/etc/freebsd-update.conf</span> nicht geändert wurde, wird <code>freebsd-update</code> die aktualisierten Quellcodedateien des Kernels zusammen mit dem Rest der Neuerungen installieren. Die erneute Übersetzung und Installation eines neuen, angepassten Kernels kann dann auf die übliche Art und Weise durchgeführt werden.</p></div><div class=paragraph><p>Die Aktualisierungen, die über <code>freebsd-update</code> verteilt werden, betreffen nicht immer den Kernel. Es ist nicht notwendig, den angepassten Kernel neu zu erstellen, wenn die Kernelquellen nicht durch <code>freebsd-update install</code> geändert wurden. Allerdings wird <code>freebsd-update</code> immer <span class=filename>/usr/src/sys/conf/newvers.sh</span> aktualisieren. Der aktuelle Patch-Level, der mit der <code>-p</code>-Nummer bei <code>uname -r</code> ausgegeben wird, wird aus dieser Datei ausgelesen. Die Neuinstallation des angepassten Kernels, selbst wenn sich daran nichts geändert hat, erlaubt es <code>uname</code>, den aktuellen Patch-Level des Systems korrekt wiederzugeben. Dies ist besonders hilfreich, wenn mehrere Systeme gewartet werden, da es eine schnelle Einschätzung der installierten Aktualisierungen in jedem einzelnen System ermöglicht.</p></div></div><div class=sect3><h4 id=freebsdupdate-upgrade>41.2.3. Aktualisierungen an Haupt- und Unterversionen<a class=anchor href=#freebsdupdate-upgrade></a></h4><div class=paragraph><p>Aktualisierungen einer Unterversion von FreeBSD zur nächsten Version ist beispielsweise die Aktualisierung von FreeBSD 9.0 auf FreeBSD 9.1. Die Aktualisierung einer Hauptversion ist beispielsweise von FreeBSD 9.X auf FreeBSD 10.X. Beide Arten der Aktualisierungen können durchgeführt werden, indem man <code>freebsd-update</code> eine Release-Version als Ziel übergibt.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn auf dem System ein angepasster Kernel eingesetzt wird, stellen Sie sicher, dass eine Kopie des <span class=filename>GENERIC</span>-Kernels in <span class=filename>/boot/GENERIC</span> existiert. Im <a href=#freebsd-update-custom-kernel-9x>Angepasste Kernel unter FreeBSD 9.X und später</a> wird beschrieben, wie Sie eine Kopie des <span class=filename>GENERIC</span>-Kernels bekommen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn Sie das folgende Kommando auf einem System mit FreeBSD 9.0 ausführen, wird das System auf FreeBSD 9.1 aktualisiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -r 9.1-RELEASE upgrade</span></code></pre></div></div><div class=paragraph><p>Nach der Eingabe des Kommandos überprüft <code>freebsd-update</code> die Konfigurationsdatei und das aktuelle System, um die nötigen Informationen für die Systemaktualisierung zu sammeln. Eine Bildschirmausgabe wird anzeigen, welche Komponenten erkannt und welche nicht erkannt wurden. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature <span class=k>for </span>9.0-RELEASE from update1.FreeBSD.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata index... <span class=k>done</span><span class=nb>.</span>
Inspecting system... <span class=k>done</span><span class=nb>.</span>

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD <span class=k>do </span>not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable <span class=o>(</span>y/n<span class=o>)</span>? y</code></pre></div></div><div class=paragraph><p>An diesem Punkt wird <code>freebsd-update</code> versuchen, alle notwendigen Dateien für die Aktualisierung herunter zu laden. In manchen Fällen wird der Benutzer mit Fragen konfrontiert, um festzustellen, was installiert werden soll oder auf welche Art und Weise fortgesetzt werden soll.</p></div><div class=paragraph><p>Wenn ein angepasster Kernel benutzt wird, produziert der vorherige Schritt eine Warnung ähnlich zu der folgenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>WARNING: This system is running a <span class=s2>&#34;
MYKERNEL&#34;</span> kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running <span class=s2>&#34;/usr/sbin/freebsd-update install&#34;</span></code></pre></div></div><div class=paragraph><p>Diese Warnung kann an dieser Stelle problemlos ignoriert werden. Der aktualisierte <span class=filename>GENERIC</span>-Kernel wird als ein Zwischenschritt im Aktualisierungsprozess verwendet.</p></div><div class=paragraph><p>Nachdem alle Korrekturen auf das lokale System heruntergeladen wurden, werden diese eingespielt. Dieser Prozess kann eine gewisse Zeit in Anspruch nehmen, abhängig von der Geschwindigkeit und Auslastung der Maschine. Konfigurationsdateien werden ebenfalls zusammengefügt. Dieser Teil der Prozedur verlangt einige Benutzereingaben, da eine Datei möglicherweise von Hand zusammengefasst werden muss oder ein Editor erscheint auf dem Bildschirm zum manuellen bearbeiten. Die Ergebnisse von jeder erfolgreichen Zusammenfassung werden dem Benutzer angezeigt, während der Prozess weiter läuft. Eine fehlgeschlagene oder ignorierte Zusammenfassung wird den Prozess sofort beenden. Benutzer sollten eine Sicherung von <span class=filename>/etc</span> anlegen und wichtige Dateien später manuell vereinen, beispielsweise <span class=filename>master.passwd</span> oder <span class=filename>group</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das System ist zu diesem Zeitpunkt noch nicht verändert worden, da alle Korrekturen und Vereinigungen in einem anderen Verzeichnis vorgenommen wurden. Wenn alle Korrekturen erfolgreich eingespielt, alle Konfigurationsdateien zusammengefügt wurden und es den Anschein hat, dass der Prozess problemlos verlaufen wird, müssen die Änderungen vom Anwender noch angewendet und auf die Platte geschrieben werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Der Kernel und die Module werden zuerst aktualisiert. Wenn das System einen angepassten Kernel verwendet, benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=nextboot&amp;sektion=8&amp;format=html">nextboot(8)</a>, um den Kernel für den nächsten Neustart auf <span class=filename>/boot/GENERIC</span> zu setzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nextboot -k GENERIC</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Bevor das System mit dem <span class=filename>GENERIC</span>-Kernel neu gestartet wird, vergewissern Sie sich, dass für den Neustart alle benötigten Treiber enthalten sind. Falls auf die Maschine aus der Ferne zugegriffen wird, stellen Sie sicher, dass das System ordnungsgemäß an das Netzwerk angeschlossen ist. Achten Sie besonders darauf, dass wenn der angepasste Kernel Funktionalität beinhaltet, die normalerweise von Kernelmodulen zur Verfügung gestellt werden, dass diese temporär über <span class=filename>/boot/loader.conf</span> in den <span class=filename>GENERIC</span>-Kernel übernommen werden. Zudem wird empfohlen, nicht benötigte Dienste, eingehängte Platten und verbundene Netzlaufwerke zu deaktivieren, bis der Aktualisierungsprozess abgeschlossen ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Maschine sollte nun mit dem aktualisierten Kernel neu gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>Sobald das System wieder hochgefahren ist, muss <code>freebsd-update</code> erneut gestartet werden. Da der Zustand des Prozesses zuvor gesichert wurde, wird <code>freebsd-update</code> nicht von vorne beginnen, sondern mit der nächsten Phase fortfahren und alle alten Bibliotheken und Objektdateien löschen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Abhängig davon, ob irgendwelche Bibliotheksversionen erhöht wurden, kann es sein, dass nur zwei Installationsphasen anstatt drei durchlaufen werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Aktualisierung ist nun abgeschlossen. Wenn es sich hierbei um eine Aktualisierung auf eine neue Hauptversion handelt, müssen alle Ports und Pakete neu installiert werden. Dieser Vorgang wird in <a href=#freebsdupdate-portsrebuild>Aktualisierung der Pakete nach einem Upgrade auf eine Hauptversion</a> beschrieben.</p></div><div class=sect4><h5 id=freebsd-update-custom-kernel-9x>41.2.3.1. Angepasste Kernel unter FreeBSD 9.X und später<a class=anchor href=#freebsd-update-custom-kernel-9x></a></h5><div class=paragraph><p>Stellen Sie vor der ersten Benutzung von <code>freebsd-update</code> sicher, dass eine Kopie des <span class=filename>GENERIC</span>-Kernels in <span class=filename>/boot/GENERIC</span> existiert. Wenn ein angepasster Kernel erstmalig gebaut wurde, ist der Kernel in <span class=filename>/boot/kernel.old</span> der <span class=filename>GENERIC</span>-Kernel. Benennen Sie dieses Verzeichnis einfach in <span class=filename>/boot/GENERIC</span> um.</p></div><div class=paragraph><p>Wenn bereits mehrfach ein angepasster Kernel gebaut wurde, oder nicht bekannt ist wie oft ein angepasster Kernel gebaut wurde, behalten Sie besser eine Kopie des <span class=filename>GENERIC</span>-Kernels, welcher mit der aktuellen Version des Betriebssystems übereinstimmt. Wenn ein direkter Zugriff auf die Maschine möglich ist, kann eine Kopie des <span class=filename>GENERIC</span>-Kernels von den Installationsmedien installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span>
<span class=c># cd /cdrom/usr/freebsd-dist</span>
<span class=c># tar -C/ -xvf kernel.txz boot/kernel/kernel</span></code></pre></div></div><div class=paragraph><p>Alternativ kann der <span class=filename>GENERIC</span>-Kernel aus den Quellen neu gebaut und installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</span></code></pre></div></div><div class=paragraph><p>Damit dieser Kernel als <span class=filename>GENERIC</span>-Kernel von <code>freebsd-update</code> erkannt wird, darf die <span class=filename>GENERIC</span>-Konfigurationsdatei in keiner Weise geändert worden sein. Es wird ebenfalls empfohlen, dass dieser ohne irgendwelche speziellen Optionen erstellt wird.</p></div><div class=paragraph><p>Der Neustart in den <span class=filename>GENERIC</span>-Kernel ist nicht notwendig, da <code>freebsd-update</code> lediglich <span class=filename>/boot/GENERIC</span> benötigt.</p></div></div><div class=sect4><h5 id=freebsdupdate-portsrebuild>41.2.3.2. Aktualisierung der Pakete nach einem Upgrade auf eine Hauptversion<a class=anchor href=#freebsdupdate-portsrebuild></a></h5><div class=paragraph><p>In der Regel funktionieren nach einer Aktualisierung einer Unterversion die installierten Anwendungen weiterhin problemlos. Neue Hauptversionen verwenden jedoch andere Binärschnittstellen (ABIs), was dazu führt, dass die meisten Anwendungen von Drittherstellern nicht mehr funktionieren. Nach der Aktualisierung auf eine Hauptversion, müssen alle installierten Ports und Pakete aktualisiert werden. Benutzen Sie <code>pkg upgrade</code> um Pakte zu aktualisieren. Installierte Ports können Sie mit einem Werkzeug wie <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> aktualisiert werden.</p></div><div class=paragraph><p>Bei einer erzwungenen Aktualisierung aller installierten Pakete, werden diese durch eine neue Version aus dem Repository ersetzt, sogar dann, wenn sich die Versionsnummer nicht erhöht hat. Dieser Schritt ist erforderlich, da sich die ABI bei einer Aktualisierung der Hauptversion von FreeBSD verändert hat. Eine erzwungene Aktualisierung aller installierten Pakete geschieht wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg-static upgrade -f</span></code></pre></div></div><div class=paragraph><p>Ein Neubau der installierten Ports führen Sie mit diesem Kommando durch:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>Dieser Befehl wird die Konfigurationen für jede Anwendung anzeigen, und der Benutzer hat die Möglichkeit, die Optionen anzupassen. Wenn Sie ausschließlich die voreingestellten Optionen verwenden möchten, verwenden Sie mit dem obigen Befehl den Parameter <code>-G</code>.</p></div><div class=paragraph><p>Sobald dies abgeschlossen ist, beenden Sie den Aktualisierungsprozess mit einem letzten Aufruf von <code>freebsd-update</code>. Geben Sie den folgenden Befehl ein, um alle losen Enden des Aktualisierungsprozesses miteinander zu verknüpfen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>Wenn der <span class=filename>GENERIC</span>-Kernel temporär Verwendung fand, ist dies der richtige Zeitpunkt, einen neuen, angepassten Kernel nach den Anweisungen in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> zu bauen und zu installieren.</p></div><div class=paragraph><p>Booten Sie anschließend die Maschine in die neue FreeBSD-Version. Der Aktualisierungsprozess ist damit abgeschlossen.</p></div></div></div><div class=sect3><h4 id=freebsdupdate-system-comparison>41.2.4. Vergleich des Systemzustands<a class=anchor href=#freebsdupdate-system-comparison></a></h4><div class=paragraph><p><code>freebsd-update IDS</code> kann verwendet werden, um den Zustand der installierten FreeBSD-Version gegenüber einer bekannten und funktionierenden Kopie zu vergleichen. Dieses Kommando vergleicht die aktuelle Version von Systemwerkzeugen, Bibliotheken sowie Konfigurationsdateien und kann als integriertes Intrusion Detection System (IDS) benutzt werden.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Dieses Programm ist kein Ersatz für ein echtes IDS-System wie <a class=package href=https://cgit.freebsd.org/ports/tree/security/snort/>security/snort</a>. Da <code>freebsd-update</code> Daten auf der Festplatte speichert, ist die Möglichkeit von Verfälschungen offensichtlich. Obwohl diese Möglichkeit durch die Verwendung von <code>kern.securelevel</code> oder die Speicherung von Daten auf einem Nur-Lese Dateisystem eingedämmt werden kann, besteht eine bessere Lösung darin, das System gegen ein gesichertes Medium, wie eine DVD oder einen externen, separat aufbewahrten USB-Plattenspeicher, zu vergleichen. Eine alternative Methode zur Bereitstellung von IDS-Funktionaliäten wird in <a href=./#security-ids>Überprüfung von Binärdateien</a> beschrieben.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Beginnen Sie den Vergleich, indem Sie das Programm starten und eine Ausgabedatei festlegen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update IDS &gt;&gt; outfile.ids</span></code></pre></div></div><div class=paragraph><p>Das System wird nun überprüft. Dabei wird eine lange Liste von Dateien zusammen mit den SHA256-Hashwerten der Release-Version und den Werten des aktuell installierten Systems, in die angegebene Ausgabedatei geschrieben.</p></div><div class=paragraph><p>Die Zeilen in der Ausgabe sind extrem lang, aber das Ausgabeformat kann einfach verarbeitet werden. Um beispielsweise eine Liste von allen Dateien zu erhalten, die sich vom aktuellen Release unterscheiden, geben Sie das folgende Kommando ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat outfile.ids | awk &#39;{ print $1 }&#39; | more</span>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</code></pre></div></div><div class=paragraph><p>Diese Beispielausgabe wurde abgeschnitten, da noch viele weitere Dateien vorhanden sind. Einige Dateien wurden auf natürliche Art verändert. <span class=filename>/etc/passwd</span> wurde beispielsweise geändert, wenn Benutzer zum System hinzugefügt wurden. Kernelmodule können sich unterscheiden, wenn <code>freebsd-update</code> diese aktualisiert hat. Um bestimmte Dateien oder Verzeichnisse auszuschließen, fügen Sie diese an die <code>IDSIgnorePaths</code>-Option in <span class=filename>/etc/freebsd-update.conf</span> an.</p></div></div></div><div class=sect2><h3 id=updating-upgrading-documentation>41.3. Aktualisieren der Dokumentationssammlung<a class=anchor href=#updating-upgrading-documentation></a></h3><div class=paragraph><p>Dokumentation ein wichtiger Bestandteil des FreeBSD Betriebssystems. Obwohl eine aktuelle Version der FreeBSD Dokumentation jederzeit auf der FreeBSD Webseite (<a href=https://www.FreeBSD.org/doc/> https://www.freebsd.org/doc/</a>) verfügbar ist, kann es nützlich sein, eine lokale Kopie der FreeBSD Webseite, Handbücher, FAQ und Artikel zu haben.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie die FreeBSD Dokumentation über die Quellen oder die FreeBSD Ports-Sammlung aktuell halten.</p></div><div class=paragraph><p>Informationen zum Bearbeiten und Einreichen von Korrekturen finden Sie in der <a href=/books/fdp-primer>Fibel für neue Mitarbeiter des FreeBSD-Dokumentationsprojekts</a>.</p></div><div class=sect3><h4 id=updating-installed-documentation>41.3.1. Die FreeBSD-Dokumentation aus den Quellen installieren<a class=anchor href=#updating-installed-documentation></a></h4><div class=paragraph><p>Der Bau der FreeBSD Dokumentation aus den Quellen erfordert einige Werkzeuge, die nicht Teil des Basissystems sind. Die erforderlichen Werkzeuge können über den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/textproc/docproj/>textproc/docproj</a> installiert werden.</p></div><div class=paragraph><p>Benutzen Sie nach der Installation svnlite, um eine saubere Kopie der Dokumentationsquellen zu holen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite checkout https://svn.FreeBSD.org/doc/head /usr/doc</span></code></pre></div></div><div class=paragraph><p>Es dauert eine Weile, bis die Quellen das allererste Mal heruntergeladen werden. Lassen Sie den Vorgang laufen, bis es fertig ist.</p></div><div class=paragraph><p>Zukünftige Aktualisierungen der Dokumentationsquellen können wie folgt durchgeführt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite update /usr/doc</span></code></pre></div></div><div class=paragraph><p>Sobald ein aktueller Schnappschuss der Dokumentationsquellen nach <span class=filename>/usr/doc</span> heruntergeladen wurde, ist alles bereit für eine Aktualisierung der bestehenden Dokumentation.</p></div><div class=paragraph><p>Eine komplette Aktualisierung aller Sprachen kann durch folgende Eingabe erreicht werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Wenn nur eine Aktualisierung einer bestimmten Sprache gewünscht wird, kann <code>make</code> in einem sprachspezifischen Unterverzeichnis von <span class=filename>/usr/doc</span> aufgerufen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc/en_US.ISO8859-1</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Alternativ kann der folgende Befehl in <span class=filename>/usr/doc</span> oder einem sprachspezifischen Unterverzeichnis abgesetzt werden, um die Dokumentation zu aktualisieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make update</span></code></pre></div></div><div class=paragraph><p>Die zu installierenden Ausgabeformate können durch das Setzen von <code>FORMATS</code> angegeben werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make FORMATS=&#39;html html-split&#39; install clean</span></code></pre></div></div><div class=paragraph><p>Es existieren ein paar Optionen, welche den Prozess der Aktualisierung von Teilen der Dokumentation oder einer bestimmten Übersetzung erleichtern. Diese Optionen können entweder systemweit in <span class=filename>/etc/make.conf</span> gesetzt, oder als Kommandozeilenoptionen an <code>make</code> übergeben werden.</p></div><div class=paragraph><p>Zu den Optionen gehören:</p></div><div class=dlist><dl><dt class=hdlist1><code>DOC_LANG</code></dt><dd><p>Eine Liste von Sprachen und Kodierungen, die gebaut und installiert werden sollen, z.B. <code>en_US.ISO8859-1</code>, um nur die englische Dokumentation zu erhalten.</p></dd><dt class=hdlist1><code>FORMATS</code></dt><dd><p>Ein einzelnes Format oder eine Liste von Ausgabeformaten, das gebaut werden soll. Momentan werden <code>html</code>, <code>html-split</code>, <code>txt</code>, <code>ps</code> und <code>pdf</code> unterstützt.</p></dd><dt class=hdlist1><code>DOCDIR</code></dt><dd><p>Wohin die Dokumentation installiert werden soll. Der Standardpfad ist <span class=filename>/usr/shared/doc</span>.</p></dd></dl></div><div class=paragraph><p>Für weitere <code>make</code>-Variablen, die als systemweite Optionen in FreeBSD unterstützt werden, lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a>.</p></div></div><div class=sect3><h4 id=doc-ports-install-package>41.3.2. Die Dokumentation aus den Ports aktualisieren<a class=anchor href=#doc-ports-install-package></a></h4><div class=paragraph><p>Im vorherigen Abschnitt wurde eine Methode gezeigt, wie die FreeBSD-Dokumentation aus den Quellen gebaut werden kann. Dieser Abschnitt beschreibt eine alternative Methode, in der die Ports-Sammlung verwendet wird und die es ermöglicht:</p></div><div class=ulist><ul><li><p>vorgefertigte Schnappschüsse der Dokumentation zu installieren, ohne vorher die Werkzeugsammlung der Dokumentation installieren zu müssen.</p></li><li><p>die Dokumentationsquellen durch das Ports-System erstellen zu lassen, was die Schritte zum Auschecken und Erstellen etwas erleichtert.</p></li></ul></div><div class=paragraph><p>Diese Methoden der Aktualisierung der FreeBSD-Dokumentation werden durch eine Menge von Dokumentations-Ports und Paketen unterstützt, die von Documentation Engineering Team &lt;<a href=mailto:doceng@FreeBSD.org>doceng@FreeBSD.org</a>> monatlich aktualisiert wird. Diese sind in der FreeBSD Ports-Sammlung unter der Kategorie "docs" gelistet (<a href=http://www.freshports.org/docs/> http://www.freshports.org/docs/</a>).</p></div><div class=paragraph><p>Die Dokumentations-Ports sind wie folgt organisiert:</p></div><div class=ulist><ul><li><p>Das Paket oder der Port <a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-en/>misc/freebsd-doc-en</a> installiert die englische Dokumentation.</p></li><li><p>Das Paket oder der Port <a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-all/>misc/freebsd-doc-all</a> installiert die komplette Dokumentation in allen verfügbaren Sprachen.</p></li><li><p>Es gibt noch ein Paket oder einen Port für jede Übersetzung, beispielsweise <a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-hu/>misc/freebsd-doc-hu</a> für die ungarische Dokumentation.</p></li></ul></div><div class=paragraph><p>Wenn Sie Pakete benutzen, wird die FreeBSD-Dokumentation in allen verfügbaren Formaten der jeweiligen Sprache installiert. Das folgende Beispiel wird das aktuelle Paket der ungarischen Dokumentation installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install hu-freebsd-doc</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pakete verwenden ein Format, welches sich von dem Namen des dazugehörigen Ports unterscheidet: <code><em>lang</em>-freebsd-doc</code>. <em>lang</em> entspricht hier der Kurzform des Sprachcodes, z.B. <code>hu</code> für Ungarisch, oder <code>zh_cn</code> für vereinfachtes Chinesisch.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um das Format der Dokumentation zu bestimmen, muss anstelle des Pakets der Port gebaut werden. Das folgende Beispiel baut und installiert die englische Dokumentation:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/misc/freebsd-doc-en</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Der Port enthält ein Konfigurationsmenü, in dem das Format ausgewählt werden kann. In der Voreinstellung sind <code>html-split</code> und <code>pdf</code> ausgewählt.</p></div><div class=paragraph><p>Alternativ können bei der Erstellung eines Dokumentations-Ports verschiedene <code>make</code>-Optionen angegeben werden. Dazu gehören:</p></div><div class=dlist><dl><dt class=hdlist1><code>WITH_HTML</code></dt><dd><p>Erstellt das HTML-Format mit einer einzigen HTML-Datei pro Dokument. Die formatierte Dokumentation wird als Datei mit dem Namen <span class=filename>article.html</span> oder <span class=filename>book.html</span> gespeichert.</p></dd><dt class=hdlist1><code>WITH_PDF</code></dt><dd><p>Die formatierte Dokumentation wird als Datei mit dem Namen <span class=filename>article.pdf</span> oder <span class=filename>book.pdf</span> gespeichert.</p></dd><dt class=hdlist1><code>DOCBASE</code></dt><dd><p>Legt den Pfad fest, wohin die Dokumentation installiert werden soll. Die Voreinstellung ist <span class=filename>/usr/local/shared/doc/freebsd</span>.</p></dd></dl></div><div class=paragraph><p>Dieses Beispiel verwendet Variablen, um die ungarische Dokumentation als PDF in ein bestimmtes Verzeichnis zu installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/misc/freebsd-doc-hu</span>
<span class=c># make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</span></code></pre></div></div><div class=paragraph><p>Dokumentations-Ports oder -Pakete können nach den Anweisungen in <a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a> aktualisiert werden. Beispielsweise aktualisiert das folgende Kommando die installierte ungarische Dokumentation mittels <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> unter Verwendung von Paketen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -PP hu-freebsd-doc</span></code></pre></div></div></div></div><div class=sect2><h3 id=current-stable>41.4. Einem Entwicklungszweig folgen<a class=anchor href=#current-stable></a></h3><div class=paragraph><p>FreeBSD besitzt zwei Entwicklungszweige: FreeBSD-CURRENT und FreeBSD-STABLE.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt beide Zweige sowie deren Interessengruppen und erläutert, wie ein System auf dem aktuellen Stand eines jeweiligen Zweiges gehalten wird.</p></div><div class=sect3><h4 id=current>41.4.1. FreeBSD-CURRENT<a class=anchor href=#current></a></h4><div class=paragraph><p>FreeBSD-CURRENT ist die allerneueste Entwicklung von FreeBSD. Benutzer von FreeBSD-CURRENT sollten über sehr gute technische Fähigkeiten verfügen. Benutzer mit weniger technischen Fähigkeiten sollten stattdessen FreeBSD-STABLE benutzen, wenn sie einem Entwicklungszweig folgen möchten.</p></div><div class=paragraph><p>FreeBSD-CURRENT besteht aus den neuesten Quellen des FreeBSD-Systems und enthält Sachen, an denen gerade gearbeitet wird, experimentelle Änderungen und Übergangsmechanismen, die im nächsten offiziellen Release enthalten sein können oder nicht. Obwohl FreeBSD-CURRENT täglich von vielen Entwicklern gebaut wird, gibt es Zeiträume, in denen sich das System vielleicht nicht bauen lässt. Diese Probleme werden so schnell wie möglich behoben, aber ob Sie mit FreeBSD-CURRENT eine Katastrophe erleben oder neue Funktionen erhalten, kann von dem Zeitpunkt abhängen, an dem der Quelltext synchronisiert wurde.</p></div><div class=paragraph><p>FreeBSD-CURRENT wird hauptsächlich für drei Interessengruppen zur Verfügung gestellt:</p></div><div class="olist arabic"><ol class=arabic><li><p>Mitglieder der FreeBSD Gemeinschaft, die aktiv an einem Teil des Quellbaums arbeiten.</p></li><li><p>Mitglieder der FreeBSD Gemeinschaft, die aktive Tester sind. Diese Personen sind bereit, Zeit in das Lösen von Problemen zu investieren, Vorschläge zu Änderungen oder der generellen Entwicklung von FreeBSD zu machen und Fehlerkorrekturen einzureichen.</p></li><li><p>Benutzer, die die Entwicklung im Auge behalten, oder die Quellen zu Referenzzwecken benutzen wollen. Diese Gruppe macht auch Vorschläge oder steuert Quellcode bei.</p></li></ol></div><div class=paragraph><p>FreeBSD-CURRENT ist <em>nicht</em> der schnellste Weg, neue Funktionen vor dem offiziellen Release auszuprobieren. Bedenken Sie, dass neue Funktionen noch nicht im vollen Umfang getestet wurden und daher höchstwahrscheinlich Fehler enthalten. Es ist auch nicht der schnellste Weg, um an Fehlerbehebungen (engl. bug fixes) zu kommen. Jede Fehlerbehebung führt mit gleicher Wahrscheinlichkeit neue Fehler ein, mit der sie alte behebt. FreeBSD-CURRENT wird in keiner Weise "offiziell unterstützt".</p></div><div class=paragraph><p>Um FreeBSD-CURRENT zu folgen:</p></div><div class="olist arabic"><ol class=arabic><li><p>Lesen Sie die Mailinglisten <a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT</a> und <a href=https://lists.FreeBSD.org/subscription/svn-src-head>SVN commit messages for the src tree for head/-current</a>. Dies ist <em>notwendig</em>, um die Kommentare über den akutellen Status des Systems und wichtige Mitteilungen zum aktuellen Zustand von FreeBSD-CURRENT zu erfahren.</p><div class=paragraph><p>Die <a href=https://lists.FreeBSD.org/subscription/svn-src-head>SVN commit messages for the src tree for head/-current</a> Mailingliste erfasst die Commit-Logs für jede Änderung und enthält alle relevanten Informationen zu möglichen Seiteneffekten.</p></div><div class=paragraph><p>Um diese Listen zu abonnieren, besuchen Sie <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a>, klicken Sie auf die gewünschte Liste und folgen Sie den Anweisungen. Wenn Sie die Änderungen am gesamten Quellbaum verfolgen möchten, abonnieren Sie die <a href=https://lists.FreeBSD.org/subscription/svn-src-all>SVN commit messages for the entire src tree (except for "user" and "projects")</a> Liste.</p></div></li><li><p>Synchronisieren Sie die Quellen für FreeBSD-CURRENT. In der Regel wird <a href=./#svn>svnlite</a> benutzt, um die Quellen für -CURRENT aus dem Zweig <code>head</code> zu laden. Verwenden Sie dazu einen Subversion Spiegel aus <a href=./#svn-mirrors>“Subversion Mirror Sites”</a>.</p></li><li><p>Aufgrund der Größe des Repositories ist es empfehlenswert, nur die gewünschten Teilbäume auszuchecken. Wenn Sie die Quellen einsetzen und nicht nur darin lesen wollen, laden Sie sich die <em>kompletten</em> Quellen von FreeBSD-CURRENT und nicht nur ausgesuchte Teile.</p><div class=paragraph><p>Lesen Sie <span class=filename>/usr/src/Makefile</span> sehr aufmerksam und folgen Sie den Anweisungen in <a href=#makeworld>FreeBSD aus den Quellen aktualisieren</a>. Lesen Sie die Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT</a> und <span class=filename>/usr/src/UPDATING</span>, um über Änderungen im Installationsverfahren, die manchmal vor der Einführung eines neuen Releases notwendig sind, informiert zu sein.</p></div></li><li><p>Seien Sie aktiv! Benutzer von FreeBSD-CURRENT werden aufgefordert ihre Verbesserungsvorschläge oder Fehlerbehebungen einzureichen. Verbesserungsvorschläge, die Code enthalten, sind jederzeit herzlich willkommen.</p></li></ol></div></div><div class=sect3><h4 id=stable>41.4.2. FreeBSD-STABLE<a class=anchor href=#stable></a></h4><div class=paragraph><p>FreeBSD-STABLE ist der Entwicklungszweig, auf dem Releases erstellt werden. Dieser Zweig ändert sich langsamer als FreeBSD-CURRENT und alle Änderungen sollten zuvor in FreeBSD-CURRENT ausgetestet sein. Beachten Sie, dass dies <em>immer noch</em> ein Entwicklungszweig ist und daher zu jedem Zeitpunkt die Quellen von FreeBSD-STABLE verwendbar sein können oder eben auch nicht. FreeBSD-STABLE ist Teil des Entwicklungsprozesses und nicht für Endanwender gedacht. Benutzer, die nicht über die notwendigen Ressourcen zum Testen verfügen, sollten stattdessen ein aktuelles Release von FreeBSD benutzen.</p></div><div class=paragraph><p>Wer daran interessiert ist den Entwicklungsprozess von FreeBSD zu verfolgen oder dazu beizutragen, insbesondere im Hinblick auf das nächste Release, der sollte es in Erwägung ziehen FreeBSD-STABLE zu benutzen.</p></div><div class=paragraph><p>Obwohl wir versuchen sicherzustellen, dass sich FreeBSD-STABLE jederzeit übersetzen lässt und lauffähig ist, können wir dafür keine Garantie übernehmen. Auch wenn Neuentwicklungen in FreeBSD-CURRENT stattfinden, ist es jedoch so, dass mehr Leute FreeBSD-STABLE anstelle von FreeBSD-CURRENT benutzen und es daher unvermeidlich ist, dass Fehler und Grenzfälle erst in FreeBSD-STABLE auffallen. Aus diesen Gründen empfehlen wir, FreeBSD-STABLE <em>nicht</em> blindlings zu benutzen.</p></div><div class=paragraph><p>Um FreeBSD-STABLE zu folgen:</p></div><div class="olist arabic"><ol class=arabic><li><p>Lesen Sie die Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-stable>FreeBSD-STABLE;</a>, damit Sie über Abhängigkeiten beim Bau von FreeBSD-STABLE und Dinge, die besondere Aufmerksamkeit erfordern, informiert sind. Umstrittene Fehlerbehebungen oder Änderungen werden von den Entwicklern auf dieser Liste bekannt gegeben. Dies erlaubt es den Benutzern, Einwände gegen die vorgeschlagenen Änderungen vorzubringen.</p><div class=paragraph><p>Abonnieren Sie die passende svn-Liste für den jeweiligen Zweig, den Sie verfolgen. Wenn Sie beispielsweise den Zweig 9-STABLE verfolgen, lesen Sie <a href=https://lists.FreeBSD.org/subscription/svn-src-stable-9>SVN commit messages for only the 9-stable src tree</a>. Diese Liste enthält zu jeder Änderung das Commit-Log, das Informationen zu möglichen Seiteneffekten enthält.</p></div><div class=paragraph><p>Um diese Listen zu abonnieren, besuchen Sie die Seite <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a>. Klicken Sie auf die gewünschte Liste und folgen Sie den Anweisungen. Wenn Sie daran interessiert sind, Änderungen am gesamten Quellbaum zu verfolgen, abonnieren Sie <a href=https://lists.FreeBSD.org/subscription/svn-src-all>SVN commit messages for the entire src tree (except for "user" and "projects")</a>.</p></div></li><li><p>Wenn Sie ein neues System installieren und dazu einen der monatlich aus FreeBSD-STABLE erzeugten Snapshots verwenden wollen, sollten Sie zuerst <a href=https://www.FreeBSD.org/snapshots>www.freebsd.org/snapshots"</a> auf aktuelle Informationen überprüfen. Alternativ können Sie auch das neueste FreeBSD-STABLE-Release von den <a href=./#mirrors>FreeBSD Spiegeln</a> beziehen.</p><div class=paragraph><p>Um ein bestehendes FreeBSD-System auf FreeBSD-STABLE zu aktualisieren, benutzen Sie <a href=./#svn>svn</a> um den gewünschten Entwicklungs- oder Release-Zweig auszuchecken. Die Zweige, wie beispielsweise <code>stable/9</code>, sind unter <a href=https://www.FreeBSD.org/releng/>www.freebsd.org/releng</a> aufgeführt.</p></div></li><li><p>Lesen Sie <span class=filename>/usr/src/Makefile</span> sehr aufmerksam bevor Sie FreeBSD-STABLE aktualisieren und folgen Sie den Anweisungen in <a href=#makeworld>FreeBSD aus den Quellen aktualisieren</a>. Lesen Sie die Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-stable>FreeBSD-STABLE;</a> und <span class=filename>/usr/src/UPDATING</span>, um über Änderungen im Installationsablauf, die manchmal vor der Einführung eines neuen Releases notwendig sind, informiert zu sein.</p></li></ol></div></div></div><div class=sect2><h3 id=makeworld>41.5. FreeBSD aus den Quellen aktualisieren<a class=anchor href=#makeworld></a></h3><div class=paragraph><p>Das Aktualisieren von FreeBSD aus den Quellen bietet im Vergleich zu binären Updates mehrere Vorteile. Der Quellcode kann mit Optionen gebaut werden, um die Vorteile von spezifischer Hardware zu nutzen. Teile des Basissystems können mit veränderten Einstellungen gebaut, oder falls nicht gewünscht, auch ganz ausgelassen werden. Dieser Prozess dauert zwar länger als die Aktualisierung mit binären Updates, ermöglicht aber eine vollständige Anpassung, um eine individuelle Version von FreeBSD zu erstellen.</p></div><div class=sect3><h4 id=updating-src-quick-start>41.5.1. Schnellstartanleitung<a class=anchor href=#updating-src-quick-start></a></h4><div class=paragraph><p>Diese kurze Referenz zeigt die typischen Schritte um FreeBSD aus den Quellen zu aktualisieren. Spätere Abschnitte beschreiben die Prozedur im Detail.</p></div><div class="exampleblock procedure"><div class=content><div class=ulist><ul><li><p>Aktualisierung und Bauprozess*</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite update /usr/src  </span><i class=conum data-value=1></i><b>(1)</b>
check /usr/src/UPDATING  <i class=conum data-value=2></i><b>(2)</b>
<span class=c># cd /usr/src          </span><i class=conum data-value=3></i><b>(3)</b>
<span class=c># make -j4 buildworld  </span><i class=conum data-value=4></i><b>(4)</b>
<span class=c># make -j4 kernel      </span><i class=conum data-value=5></i><b>(5)</b>
<span class=c># shutdown -r now      </span><i class=conum data-value=6></i><b>(6)</b>
<span class=c># cd /usr/src          </span><i class=conum data-value=7></i><b>(7)</b>
<span class=c># make installworld    </span><i class=conum data-value=8></i><b>(8)</b>
<span class=c># mergemaster -Ui      </span><i class=conum data-value=9></i><b>(9)</b>
<span class=c># shutdown -r now      </span><i class=conum data-value=10></i><b>(10)</b></code></pre></div></div></li></ul></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Holt die neueste Version der Quellen. <a href=#updating-src-obtaining-src>Den Quellcode aktualisieren</a> enthält weitere Informationen zum Aktualisieren und Bauen der Quellen.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td><span class=filename>/usr/src/UPDATING</span> enthält Anweisungen für alle manuellen Schritte, die vor oder nach dem Bau der Quellen erforderlich sind.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Wechsel in das Bauverzeichnis.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Bau des Basissystems, mit Ausnahme des Kernels.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Bau und Installation des Kernels. Dieser Schritt ist gleichbedeutend mit <code>make buildkernel installkernel</code>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Installation des Basissystems.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Aktualisierung und Zusammenführung der Konfigurationsdateien in <span class=filename>/etc</span>.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Neustart des Systems mit dem neu erstellten Basissystem und Kernel.</td></tr></tbody></table></div></div></div></div><div class=sect3><h4 id=updating-src-preparing>41.5.2. Vorbereitungen zum Aktualisieren aus den Quellen<a class=anchor href=#updating-src-preparing></a></h4><div class=paragraph><p>Lesen Sie <span class=filename>/usr/src/UPDATING</span>. Jeder manuelle Schritt, welcher vor oder nach der Aktualisierung erforderlich ist, wird in dieser Datei beschrieben.</p></div></div><div class=sect3><h4 id=updating-src-obtaining-src>41.5.3. Den Quellcode aktualisieren<a class=anchor href=#updating-src-obtaining-src></a></h4><div class=paragraph><p>Der Quellcode von FreeBSD befindet sich in <span class=filename>/usr/src/</span>. Die bevorzugte Methode zur Aktualisierung dieser Quellen ist über das Versionskontrollsystem Subversion. Sie sollten sicherstellen, dass der Quellcode unter Versionskontrolle steht:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite info /usr/src</span>
Path: /usr/src
Working Copy Root Path: /usr/src
...</code></pre></div></div><div class=paragraph><p>Dies ist ein Hinweis darauf, dass <span class=filename>/usr/src/</span> unter Versionskontrolle steht und mit <a href="https://man.freebsd.org/cgi/man.cgi?query=svnlite&amp;sektion=1&amp;format=html">svnlite(1)</a> aktualisiert werden kann.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite update /usr/src</span></code></pre></div></div><div class=paragraph><p>Dieser Vorgang kann einige Zeit in Anspruch nehmen, falls das Verzeichnis nicht zuletzt aktualisiert wurde. Nach Beendigung ist der Quellcode aktuell und der im nächsten Abschnitt beschriebene Bauprozess kann beginnen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><strong>Synchronisation der Quellen</strong></p></div><div class=paragraph><p>Meldet die Ausgabe <code>'/usr/src' is not a working copy</code>, dann fehlen entweder Dateien, oder das Verzeichnis wurde mit einer anderen Methode aktualisiert. Ein erneuter Checkout der Quellen ist jetzt erforderlich.</p></div><table id=updating-src-obtaining-src-repopath class="tableblock frame-all grid-all stretch"><caption class=title>Tabelle 18. FreeBSD Versionen und Repository-Pfade</caption><col style=width:10%><col style=width:10%><col style=width:80%><thead><tr><th class="tableblock halign-left valign-top">Ausgabe von uname -r</th><th class="tableblock halign-left valign-top">Repository-Pfad</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X.Y</em>-RELEASE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>base/releng/<em>X.Y</em></code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die Release-Version inklusive kritischer Sicherheits- und Bugfix-Patches. Dieser Zweig wird für die meisten Benutzer empfohlen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X.Y</em>-STABLE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>base/stable/<em>X</em></code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die Release-Version und alle weitere Versionen auf diesem Zweig. <em>STABLE</em> bezieht sich darauf, dass die Binärschnittstelle (ABI) sich nicht ändert, sodass Anwendungen welche auf älteren Versionen erstellt wurden weiterhin lauffähig sind. Eine Anwendung, welche für FreeBSD 10.1 übersetzt wurde, läuft auch auf FreeBSD 10-STABLE.</p><p class=tableblock>STABLE-Zweige haben gelegentlich Fehler und Inkompatibilitäten, welche den Benutzer beeinträchtigen könnten. In der Regel werden diese Fehler aber zügig behoben.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X</em>-CURRENT</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>base/head/</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die neueste unveröffentlichte Version von FreeBSD. Der CURRENT-Zweig kann viele Fehler und Inkompatibilitäten enthalten und wird daher nur für fortgeschrittene Benutzer empfohlen.</p></td></tr></tbody></table><div class=paragraph><p>Ermitteln Sie mit <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> die verwendete FreeBSD-Version:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># uname -r</span>
10.3-RELEASE</code></pre></div></div><div class=paragraph><p>Basierend auf <a href=#updating-src-obtaining-src-repopath>FreeBSD Versionen und Repository-Pfade</a> ist <code>base/releng/10.3</code> der Repository-Pfad zur Aktualisierung von <code>10.3-RELEASE</code>. Dieser Pfad wird beim Auschecken der Quellen benutzt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /usr/src /usr/src.bak  </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># svnlite checkout https://svn.freebsd.org/base/releng/10.3 /usr/src  </span><i class=conum data-value=2></i><b>(2)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Verschiebt das alte Verzeichnis. Wenn es keine lokalen Änderungen in diesem Verzeichnis gibt, kann es gelöscht werden.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Der Pfad aus <a href=#updating-src-obtaining-src-repopath>FreeBSD Versionen und Repository-Pfade</a> wird der Repository-URL hinzugefügt. Der dritte Parameter ist das lokale Zielverzeichnis für den Quellcode.</td></tr></tbody></table></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=updating-src-building>41.5.4. Den Quellcode bauen<a class=anchor href=#updating-src-building></a></h4><div class=paragraph><p>Die Welt, also das gesamte Basissystem mit Ausnahme des Kernels, wird zuerst übersetzt, um aktuelle Werkzeuge zum Erstellen des Kernels bereitzustellen. Anschließend wird der Kernel gebaut:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildworld</span>
<span class=c># make buildkernel</span></code></pre></div></div><div class=paragraph><p>Das Ergebnis wird in <span class=filename>/usr/obj</span> abgelegt.</p></div><div class=paragraph><p>Dies sind die grundlegenden Schritte. Weitere Optionen zur Kontrolle des Bauprozesses sind nachfolgend beschrieben.</p></div><div class=sect4><h5 id=updating-src-building-clean-build>41.5.4.1. Umgebung für den Bauprozess säubern<a class=anchor href=#updating-src-building-clean-build></a></h5><div class=paragraph><p>Einige Versionen von FreeBSD hinterlassen bereits übersetzten Code im temporären Objektverzeichnis <span class=filename>/usr/obj</span>. Dies kann nachfolgende Bauprozesse beschleunigen, da Code, der nicht verändert wurde, nicht neu übersetzt werden muss. Um eine saubere Umgebung für den Bauprozess zu schaffen, benutzen Sie <code>cleanworld</code> bevor Sie mit dem Bau beginnen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make cleanworld</span></code></pre></div></div></div><div class=sect4><h5 id=updating-src-building-jobs>41.5.4.2. Anzahl der Prozesse einstellen<a class=anchor href=#updating-src-building-jobs></a></h5><div class=paragraph><p>Eine höhere Anzahl an Prozessen kann die Geschwindigkeit auf Mehrprozessor-Systemen verbessern. Die Anzahl der Kerne lässt sich mit <code>sysctl hw.cpu</code> bestimmen. Prozessoren variieren ebenso, wie die verschiedenen Build-Systeme von FreeBSD. Sie müssen daher mehrere Versuche starten um zu sehen, wie die Anzahl der Prozesse die Geschwindigkeit beeinflusst. Als Ausgangspunkt können Sie die halbe bis doppelte Anzahl der Kerne als Wert probieren. Die Anzahl der Prozesse wird mit <code>-j</code> angegeben.</p></div><div id=updating-src-building-jobs-example class=exampleblock><div class=title>Beispiel 43. Die Anzahl der Prozesse erhöhen</div><div class=content><div class=paragraph><p>Das Basissystem und den Kernel mit vier Prozessen bauen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -j4 buildworld buildkernel</span></code></pre></div></div></div></div></div><div class=sect4><h5 id=updating-src-building-only-kernel>41.5.4.3. Nur den Kernel erstellen<a class=anchor href=#updating-src-building-only-kernel></a></h5><div class=paragraph><p>Wenn sich der Quellcode verändert hat, muss ein <code>buildworld</code> ausgeführt werden. Danach kann der Kernel mit <code>buildkernel</code> übersetzt werden. Um lediglich den Kernel zu übersetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildkernel</span></code></pre></div></div></div><div class=sect4><h5 id=updating-src-building-custom-kernel>41.5.4.4. Einen angepassten Kernel erstellen<a class=anchor href=#updating-src-building-custom-kernel></a></h5><div class=paragraph><p>Der FreeBSD Standard-Kernel basiert auf einer <em>Konfigurationsdatei</em> namens <span class=filename>GENERIC</span>. Der <span class=filename>GENERIC</span>-Kernel enthält die gängigsten Gerätetreiber und Optionen. Manchmal ist es aber sinnvoll oder gar notwendig, einen angepassten Kernel zu erstellen, um Gerätetreiber oder Optionen hinzuzufügen oder zu entfernen, um bestimmte Anforderungen zu erfüllen.</p></div><div class=paragraph><p>Zum Beispiel könnte jemand, der einen kleinen eingebetteten Rechner mit eingeschränktem RAM entwickelt, nicht benötigte Gerätetreiber oder Optionen entfernen, um den Kernel etwas kleiner zu machen.</p></div><div class=paragraph><p>Die Kernelkonfigurationsdateien befinden sich in <span class=filename>/usr/src/sys/arch/conf/</span>, wobei <em>arch</em> die Ausgabe von <code>uname -m</code> ist. Auf den meisten Rechnern ist dies <code>amd64</code>, demnach befinden sich die Konfigurationsdateien in <span class=filename>/usr/src/sys/amd64/conf/</span>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><span class=filename>/usr/src</span> kann aus Versehen gelöscht oder neu erstellt werden. Daher ist es vorzuziehen, angepasste Kernelkonfigurationsdateien in einen separaten Verzeichnis, wie bspw. <span class=filename>/root</span> zu speichern und diese in das <span class=filename>conf</span>-Verzeichnis zu verlinken. Wenn dieses Verzeichnis gelöscht oder überschrieben wird, kann die Kernelkonfigurationsdatei einfach neu verknüpft werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Eine benutzerdefinierte Konfigurationsdatei kann durch Kopieren der <span class=filename>GENERIC</span>-Konfigurationsdatei erstellt werden. In diesem Beispiel ist der neue Kernel für einen Speicherserver, heißt also <span class=filename>STORAGESERVER</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /usr/src/sys/amd64/conf/GENERIC /root/STORAGESERVER</span>
<span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># ln -s /root/STORAGESERVER .</span></code></pre></div></div><div class=paragraph><p>Jetzt kann <span class=filename>/root/STORAGESERVER</span> bearbeitet werden. Die Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a> zeigt, wie Treiber und Optionen hinzugefügt oder entfernt werden.</p></div><div class=paragraph><p>Der angepasste Kernel wird mit der Variablen <code>KERNCONF</code>, die auf die Kernelkonfigurationsdatei verweist, übersetzt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=STORAGESERVER</span></code></pre></div></div></div></div><div class=sect3><h4 id=updating-src-installing>41.5.5. Installation des Codes<a class=anchor href=#updating-src-installing></a></h4><div class=paragraph><p>Nachdem die Schritte <code>buildworld</code> und <code>buildkernel</code> abgeschlossen sind, wird der neue Kernel und die Welt installiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make installkernel</span>
<span class=c># shutdown -r now</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld</span>
<span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>Wenn ein angepasster Kernel erstellt wurde, muss zusätzlich die Variable <code>KERNCONF</code> gesetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make installkernel KERNCONF=STORAGESERVER</span>
<span class=c># shutdown -r now</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld</span>
<span class=c># shutdown -r now</span></code></pre></div></div></div><div class=sect3><h4 id=updating-src-completing>41.5.6. Die Aktualisierung abschließen<a class=anchor href=#updating-src-completing></a></h4><div class=paragraph><p>Ein paar abschließende Aufgaben beenden die Aktualisierung. Alle Konfigurationsdateien werden mit den neuen Versionen zusammengeführt, veraltete Bibliotheken werden entfernt, dann wird das System neu gestartet.</p></div><div class=sect4><h5 id=updating-src-completing-merge-mergemaster>41.5.6.1. Konfigurationsdateien mit <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> zusammenführen<a class=anchor href=#updating-src-completing-merge-mergemaster></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> bietet einen einfachen Weg, um die Konfigurationsdateien des Systems mit den neuen Versionen dieser Dateien zusammenzuführen.</p></div><div class=paragraph><p>Mit der Option <code>-Ui</code> aktualisiert <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> automatisch Dateien, welche nicht vom Benutzer verändert wurden und installiert neue Dateien, die noch nicht vorhanden sind:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -Ui</span></code></pre></div></div><div class=paragraph><p>Wenn eine Datei manuell zusammengeführt werden muss, erlaubt eine interaktive Anzeige, zu wählen, welche Teile der Dateien beibehalten werden. Die Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> enthält weitere Informationen.</p></div></div><div class=sect4><h5 id=updating-src-completing-check-old>41.5.6.2. Veraltete Dateien und Bibliotheken entfernen<a class=anchor href=#updating-src-completing-check-old></a></h5><div class=paragraph><p>Nach einer Aktualisierung können sich immer noch veraltete Dateien und Verzeichnisse im System befinden. Diese lassen sich mit folgendem Kommando auflisten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make check-old</span></code></pre></div></div><div class=paragraph><p>und löschen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make delete-old</span></code></pre></div></div><div class=paragraph><p>Einige veraltete Bibliotheken können ebenfalls noch vorhanden sein. Diese werden mit folgenden Kommando aufgelistet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make check-old-libs</span></code></pre></div></div><div class=paragraph><p>und wie folgt gelöscht:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make delete-old-libs</span></code></pre></div></div><div class=paragraph><p>Programme, die diese alten Bibliotheken noch verwenden, werden nicht mehr funktionieren, wenn die Bibliothek gelöscht wurde. Diese Programme müssen nach dem Löschen der alten Bibliotheken neu gebaut oder ersetzt werden.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Wenn Sie sich sicher sind, dass alle Dateien und Verzeichnisse gelöscht werden können, dann setzen Sie <code>BATCH_DELETE_OLD_FILES</code>, um nicht jede einzelne Datei mit <kbd>y</kbd> und <kbd>Enter</kbd> bestätigen zu müssen. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make BATCH_DELETE_OLD_FILES=yes delete-old-libs</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=updating-src-completing-restart>41.5.6.3. Neustart des Systems<a class=anchor href=#updating-src-completing-restart></a></h5><div class=paragraph><p>Zum Abschluss der Aktualisierung muss das System neu gestartet werden, damit alle Änderungen wirksam werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=small-lan>41.6. Installation mehrerer Maschinen<a class=anchor href=#small-lan></a></h3><div class=paragraph><p>Wenn Sie mehrere Maschinen auf dem gleichen Stand halten wollen, ist es eine Verschwendung von Ressourcen, die Quellen auf jeder Maschine vorzuhalten und zu übersetzen. Die Lösung dazu ist, eine Maschine den Großteil der Arbeit durchführen zu lassen und den anderen Maschinen das Ergebnis mit NFS zur Verfügung zu stellen. Dieser Abschnitt zeigt eine Methode dies zu tun. Weitere Informationen zu NFS finden Sie in <a href=./#network-nfs>Network File System (NFS)</a>.</p></div><div class=paragraph><p>Stellen Sie zuerst eine Liste der Maschinen zusammen, die auf demselben Stand sein sollen. Wir nennen diese Maschinen die <em>Baugruppe</em>. Jede dieser Maschinen kann mit einem eigenen Kernel laufen, doch sind die Programme des Userlands auf allen Maschinen gleich. Wählen Sie aus der Baugruppe eine Maschine aus, auf der der Bau durchgeführt wird, den <em>Bau-Master</em>. Dies sollte eine Maschine sein, die über die nötigen CPU-Ressourcen für <code>make buildworld</code> und <code>make installworld</code> verfügt.</p></div><div class=paragraph><p>Sie brauchen auch eine <em>Testmaschine</em>, auf der Sie die Updates testen, bevor Sie sie in Produktion installieren. Dies <em>muss</em> eine Maschine sein, die über einen längeren Zeitraum nicht zur Verfügung stehen kann.</p></div><div class=paragraph><p>Alle Maschinen der Baugruppe müssen <span class=filename>/usr/obj</span> und <span class=filename>/usr/src</span> über NFS vom Bau-Master an gleichem Ort einhängen. Wenn Sie mehrere Baugruppen haben, sollte sich <span class=filename>/usr/src</span> auf einem Bau-Master befinden und über NFS für den Rest der Maschinen zur Verfügung gestellt werden.</p></div><div class=paragraph><p>Stellen Sie sicher, dass <span class=filename>/etc/make.conf</span> und <span class=filename>/etc/src.conf</span> auf allen Maschinen einer Baugruppe mit der Datei des Bau-Masters übereinstimmt. Der Bau-Master muss jeden Teil des Systems bauen, den irgendeine Maschine der Baugruppe benötigt. Auf dem Bau-Master müssen in <span class=filename>/etc/make.conf</span> alle zu bauenden Kernel mit der Variablen <code>KERNCONF</code> bekannt gegeben werden. Geben Sie dabei den Kernel des Bau-Masters zuerst an. Für jeden zu bauenden Kernel muss auf dem Bau-Master die entsprechende Konfigurationsdatei unter <span class=filename>/usr/src/sys/arch/conf</span> abgelegt werden.</p></div><div class=paragraph><p>Bauen Sie auf dem Bau-Master, wie in <a href=#makeworld>FreeBSD aus den Quellen aktualisieren</a> beschrieben, den Kernel und die Welt, installieren Sie aber nichts. Wechseln Sie auf die Testmaschine und installieren Sie den gerade gebauten Kernel. Hängen Sie auf der Testmaschine <span class=filename>/usr/src</span> und <span class=filename>/usr/obj</span> über NFS ein. Geben Sie dann <code>shutdown now</code> ein, um in den Single-User-Modus zu gelangen, von wo aus Sie den neuen Kernel und das System installieren. Lassen Sie anschließend <code>mergemaster</code> laufen. Wenn Sie fertig sind, booten Sie die Maschine wieder in den Mehrbenutzermodus.</p></div><div class=paragraph><p>Nachdem Sie sichergestellt haben, dass die Testmaschine einwandfrei funktioniert, wiederholen Sie diese Prozedur für jede Maschine in der Baugruppe.</p></div><div class=paragraph><p>Dasselbe Verfahren können Sie auch für die Ports-Sammlung anwenden. Zuerst müssen alle Maschinen einer Baugruppe <span class=filename>/usr/ports</span> über NFS zur Verfügung gestellt bekommen. Setzen Sie ein Verzeichnis für die Quellen auf, das sich alle Maschinen teilen. Dieses Verzeichnis können Sie in <span class=filename>/etc/make.conf</span> mit der Variablen <code>DISTDIR</code> angeben. Das Verzeichnis sollte für den Benutzer beschreibbar sein, auf den der Benutzer <code>root</code> vom NFS Subsystem abgebildet wird. Jede Maschine sollte noch <code>WRKDIRPREFIX</code> auf ein lokales Bauverzeichnis setzen. Wenn Sie vorhaben, Pakete zu bauen und zu verteilen, sollten Sie <code>PACKAGES</code> auf ein Verzeichnis mit den gleichen Eigenschaften wie <code>DISTDIR</code> setzen.</p></div></div></div></div><div class=sect1><h2 id=dtrace>Kapitel 42. DTrace<a class=anchor href=#dtrace></a></h2><div class=sectionbody><div class=sect2><h3 id=dtrace-synopsis>42.1. Überblick<a class=anchor href=#dtrace-synopsis></a></h3><div class=paragraph><p>DTrace, auch bekannt als Dynamic Tracing, wurde von Sun™ als ein Werkzeug zur Analyse von Performance-Problemen in Produktiv- und Entwicklungssystemen entwickelt. Zusätzlich zur Diagnose von Performance-Problemen kann DTrace auch verwendet werden, um bei der Untersuchung und Behebung von unerwartetem Verhalten im FreeBSD-Kernel und den Anwenderprogrammen zu helfen.</p></div><div class=paragraph><p>DTrace ist ein bemerkenswertes Werkzeug zur Profilerstellung, mit einer beeindruckenden Palette von Eigenschaften zur Diagnose von Systemereignissen. Es kann auch dazu verwendet werden, bestehende Skripte ablaufen zu lassen, um einen Nutzen aus deren Möglichkeiten zu ziehen. Nutzer können mittels der Programmiersprache D von DTrace ihre eigenen Hilfsmittel schreiben, was es ermöglicht, die eigenen Profile nach Ihren Bedürfnissen anzupassen.</p></div><div class=paragraph><p>Die DTrace-Implementierung in FreeBSD bietet experimentelle Unterstützung für DTrace im Userland. Userland DTrace erlaubt es Anwendern, function boundary tracing für Anwendungsprogramme über den <code>pid</code>-Provider hinweg vorzunehmen und um statische Sonden in Anwendungsprogramme für die spätere Aufzeichnung einzufügen. Manche Ports, wie beispielsweise <a class=package href=https://cgit.freebsd.org/ports/tree/databases/postgresql12-server/>databases/postgresql12-server</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php74/>lang/php74</a> besitzen eine DTrace-Option, um statische Sonden zu aktivieren.</p></div><div class=paragraph><p>Eine offizielle Anleitung für DTrace wird vom Illumos Projekt im <a href=http://dtrace.org/guide>DTrace Guide</a> bereitgestellt.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes wissen:</p></div><div class=ulist><ul><li><p>Was DTrace ist und welche Funktionen es zur Verfügung stellt.</p></li><li><p>Unterschiede zwischen der Solaris™ DTrace Implementierung und derjenigen, die FreeBSD bereitstellt.</p></li><li><p>Wie man DTrace auf FreeBSD aktiviert und verwendet.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>UNIX® und FreeBSD Grundlagen verstehen (<a href=./#basics>Grundlagen des FreeBSD Betriebssystems</a>).</p></li><li><p>Vertraut sein mit Sicherheitsaspekten und wie diese FreeBSD betreffen (<a href=./#security>Sicherheit</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Diese Funktion ist als experimentell anzusehen. Manche Einstellungen enthalten möglicherweise nicht alle Funktionalitäten, andere Teile könnten gar nicht laufen. Mit der Zeit, wenn diese Funktion als für den Produktivbetrieb geeignet erscheint, wird auch diese Dokumentation geändert, um diesem Umstand gerecht zu werden.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=dtrace-implementation>42.2. Unterschiede in der Implementierung<a class=anchor href=#dtrace-implementation></a></h3><div class=paragraph><p>Obwohl DTrace in FreeBSD sehr ähnlich zu dem in Solaris™ ist, existieren doch Unterschiede. Der Hauptunterschied besteht darin, dass in FreeBSD DTrace als eine Menge von Kernelmodulen implementiert ist und DTrace nicht verwendet werden kann, bis diese Module geladen wurden. Um alle nötigen Module zu laden, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload dtraceall</span></code></pre></div></div><div class=paragraph><p>Beginnend mit FreeBSD 10.0-RELEASE werden die Module automatisch geladen, sobald <code>dtrace</code> aufgerufen wird.</p></div><div class=paragraph><p>FreeBSD verwendet die Kerneloption <code>DDB_CTF</code>, um die Unterstützung im Kernel für das Laden von CTF-Daten aus Kernelmodulen und dem Kernel selbst zu ermöglichen. CTF ist das Compact C Type Format von Solaris™, welches eine reduzierte Form von Debug-Informationen kapselt, ähnlich zu DWARF und den antiken Stabs. Diese CTF-Daten werden dem Binärcode von den <code>ctfconvert</code> und <code>ctfmerge</code> Befehlen den Werkzeugen zum Bauen des Systems hinzugefügt. Das <code>ctfconvert</code>-Dienstprogramm parst die vom Compiler erstellten DWARFELF Debug-Abschnitte und <code>ctfmerge</code> vereint CTFELF-Abschnitte aus Objekten, entweder in ausführbare Dateien oder Shared-Libraries.</p></div><div class=paragraph><p>Einige Provider in FreeBSD unterscheiden sich von der Solaris™-Implementierung. Am deutlichsten wird das beim <code>dtmalloc</code>-Provider, welcher das Aufzeichnen von <code>malloc()</code> nach Typen im FreeBSD-Kernel ermöglicht. Manche der Provider in Solaris™ wie <code>cpc</code> und <code>mib</code> sind in FreeBSD nicht vorhanden. Diese können in zukünftigen FreeBSD-Versionen auftauchen. Weiterhin sind manche der Provider in beiden Betriebssystemen nicht zueinander kompatibel, in dem Sinne daß deren Sonden unterschiedliche Argumenttypen aufweisen. Dadurch können D-Skripte, die unter Solaris™ geschrieben wurden, evtl. unter FreeBSD funktionieren oder auch nicht, umgekehrt ist das genauso.</p></div><div class=paragraph><p>In FreeBSD darf DTrace wegen unterschiedlicher Sicherheitskonzepte nur von <code>root</code> verwendet werden. Solaris™ besitzt ein paar Audit-Funktionen auf den unteren Ebenen, die noch nicht in FreeBSD implementiert sind. Deshalb kann nur <code>root</code> auf <span class=filename>/dev/dtrace/dtrace</span> zugreifen.</p></div><div class=paragraph><p>Zum Schluss muss noch erwähnt werden, dass die DTrace-Software unter die CDDL Lizenz fällt. Die <code>Common Development and Distribution License</code> wird von FreeBSD mitgeliefert, sehen Sie sich dazu <span class=filename>/usr/src/cddl/contrib/opensolaris/OPENSOLARIS.LICENSE</span> an, oder lesen Sie die Online-Version unter <a href=http://opensource.org/licenses/CDDL-1.0>http://opensource.org/licenses/CDDL-1.0</a>. Während der FreeBSD-Kernel mit den DTrace-Optionen immer noch BSD-lizenziert ist, tritt die CDDL in Kraft, wenn Module in Binärform vertrieben werden oder die Binärdateien geladen werden.</p></div></div><div class=sect2><h3 id=dtrace-enable>42.3. Die DTrace Unterstützung aktivieren<a class=anchor href=#dtrace-enable></a></h3><div class=paragraph><p>In FreeBSD 9.2 und 10.0 ist die Unterstützung von DTrace im <span class=filename>GENERIC</span>-Kernel bereits eingebaut. Nutzer von früheren Versionen sollten die folgenden Zeilen in eine eigene Kernelkonfigurationsdatei einfügen und den Kernel mittels der Anleitung in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> neu übersetzen:</p></div><div class="literalblock programlisting"><div class=content><pre>options         KDTRACE_HOOKS
options         DDB_CTF
makeoptions         DEBUG=-g
makeoptions         WITH_CTF=1</pre></div></div><div class=paragraph><p>Besitzer der AMD64-Architektur werden wahrscheinlich noch die folgende Zeile zur Kernelkonfigurationsdatei hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>options         KDTRACE_FRAME</pre></div></div><div class=paragraph><p>Diese Option liefert die Unterstützung für die FBT-Eigenschaft. DTrace wird auch ohne diese Option funktionieren; jedoch wird dann Function Boundary Tracing nur eingeschränkt unterstützt.</p></div><div class=paragraph><p>Sobald FreeBSD in den neuen Kernel gebootet oder die DTrace-Kernelmodule mittels <code>kldload dtraceall</code> geladen wurden, benötigt das System Unterstützung für die Korn-Shell, da DTrace mehrere Dienstprogramme enthält, die in <code>ksh</code> implementiert sind. Vergewissern Sie sich, dass das Paket oder der Port <a class=package href=https://cgit.freebsd.org/ports/tree/shells/ksh93/>shells/ksh93</a> installiert ist. Es ist auch möglich, diese Werkzeuge unter <a class=package href=https://cgit.freebsd.org/ports/tree/shells/pdksh/>shells/pdksh</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/shells/mksh/>shells/mksh</a> laufen zu lassen.</p></div><div class=paragraph><p>Zum Schluss sollten Sie noch den aktuellen DTrace-Werkzeugsatz beschaffen. Die DTrace-Werkzeugsammlung enthält gebrauchsfertige Skripte, um Systeminformationen zu sammeln. Es gibt Skripte zum Überprüfen von offenen Dateien, Speicher- und CPU-Gebrauch und noch viel mehr. FreeBSD 10 installiert ein paar dieser Skripte in <span class=filename>/usr/shared/dtrace</span>. Für andere FreeBSD-Versionen oder um die volle DTrace-Werkzeugsammlung zu installieren, verwenden Sie den <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dtrace-toolkit/>sysutils/dtrace-toolkit</a> Port oder das Paket.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Skripte in <span class=filename>/usr/shared/dtrace</span> wurden speziell für FreeBSD portiert. Nicht alle Skripte in der DTrace-Werkzeugsammlung werden in FreeBSD unverändert funktionieren und manche Skript benötigen einigen Aufwand, damit diese auf FreeBSD funktionieren.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Der DTrace-Werkzeugsatz beinhaltet viele Skripte in der speziellen Sprache von DTrace. Diese Sprache wird die D-Sprache genannt und ist sehr ähnlich zu C++. Eine detaillierte Beschreibung dieser Sprache würde den Rahmen dieses Dokuments sprengen. Im <a href=http://www.dtrace.org/guide>Illumos Dynamic Tracing Guide</a> wird diese Sprache ausführlich beschrieben.</p></div></div><div class=sect2><h3 id=dtrace-using>42.4. DTrace verwenden<a class=anchor href=#dtrace-using></a></h3><div class=paragraph><p>DTrace-Skripte bestehen aus einer Liste von einer oder mehreren <em>Sonden</em> oder Instrumentationspunkten, an denen jede Sonde mit einer Aktion verknüpft ist. Jedesmal, wenn die Bedingung für eine Sonde zutrifft, wird die verknüpfte Aktion ausgeführt. Beispielsweise könnte eine Aktion ausgeführt werden, wenn eine Datei geöffnet, ein Prozess gestartet oder eine Codezeile ausgeführt wird. Die Aktion könnte die Protokollierung von Informationen sein oder die Änderung von Kontextvariablen. Das Lesen und Schreiben von Kontextvariablen erlaubt es den Sonden, Informationen auszutauschen und kooperativ die Korrelation bestimmter Ereignisse zu analysieren.</p></div><div class=paragraph><p>Um alle Sonden anzuzeigen, kann der Administrator nun den folgenden Befehl eingeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dtrace -l | more</span></code></pre></div></div><div class=paragraph><p>Jede Sonde besitzt eine <code>ID</code>, einen <code>PROVIDER</code> (dtrace oder fbt), ein <code>MODULE</code> und einen <code>FUNCTION NAME</code>. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=dtrace&amp;sektion=1&amp;format=html">dtrace(1)</a> für weitere Informationen zu diesem Kommando.</p></div><div class=paragraph><p>Die Beispiele in diesem Abschnitt geben einen Überblick, wie man zwei dieser voll funktionsfähigen Skripte aus der DTrace-Werkzeugsammlung verwendet: die Skripte <span class=filename>hotkernel</span> und <span class=filename>procsystime</span>.</p></div><div class=paragraph><p>Das <span class=filename>hotkernel</span> Skript wurde entworfen, um zu identifizieren, welche Funktion die meiste Kernelzeit beansprucht. Es wird es Ausgaben ähnlich der Folgenden produzieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/share/dtrace-toolkit</span>
<span class=c># ./hotkernel</span>
Sampling... Hit Ctrl-C to end.</code></pre></div></div><div class=paragraph><p>Verwenden Sie wie angegeben die Tastenkombination <span class=keyseq><kbd>Ctrl</kbd>+<kbd>C</kbd></span> drücken, um den Prozess zu stoppen. Nach dem Abbruch wird das Skript eine Liste von Kernelfunktionen und Zeitmessungen ausgeben, aufsteigend sortiert nach den Zeiten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>kernel<span class=sb>`</span>_thread_lock_flags                                   2   0.0%
0xc1097063                                                  2   0.0%
kernel<span class=sb>`</span>sched_userret                                        2   0.0%
kernel<span class=sb>`</span>kern_select                                          2   0.0%
kernel<span class=sb>`</span>generic_copyin                                       3   0.0%
kernel<span class=sb>`</span>_mtx_assert                                          3   0.0%
kernel<span class=sb>`</span>vm_fault                                             3   0.0%
kernel<span class=sb>`</span>sopoll_generic                                       3   0.0%
kernel<span class=sb>`</span>fixup_filename                                       4   0.0%
kernel<span class=sb>`</span>_isitmyx                                             4   0.0%
kernel<span class=sb>`</span>find_instance                                        4   0.0%
kernel<span class=sb>`</span>_mtx_unlock_flags                                    5   0.0%
kernel<span class=sb>`</span>syscall                                              5   0.0%
kernel<span class=sb>`</span>DELAY                                                5   0.0%
0xc108a253                                                  6   0.0%
kernel<span class=sb>`</span>witness_lock                                         7   0.0%
kernel<span class=sb>`</span>read_aux_data_no_wait                                7   0.0%
kernel<span class=sb>`</span>Xint0x80_syscall                                     7   0.0%
kernel<span class=sb>`</span>witness_checkorder                                   7   0.0%
kernel<span class=sb>`</span>sse2_pagezero                                        8   0.0%
kernel<span class=sb>`</span>strncmp                                              9   0.0%
kernel<span class=sb>`</span>spinlock_exit                                       10   0.0%
kernel<span class=sb>`</span>_mtx_lock_flags                                     11   0.0%
kernel<span class=sb>`</span>witness_unlock                                      15   0.0%
kernel<span class=sb>`</span>sched_idletd                                       137   0.3%
0xc10981a5                                              42139  99.3%</code></pre></div></div><div class=paragraph><p>Dieses Skript funktioniert auch mit Kernelmodulen. Um diese Eigenschaft zu verwenden, starten Sie das Skript mit <code>-m</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./hotkernel -m</span>
Sampling... Hit Ctrl-C to end.
^C
MODULE                                                  COUNT   PCNT
0xc107882e                                                  1   0.0%
0xc10e6aa4                                                  1   0.0%
0xc1076983                                                  1   0.0%
0xc109708a                                                  1   0.0%
0xc1075a5d                                                  1   0.0%
0xc1077325                                                  1   0.0%
0xc108a245                                                  1   0.0%
0xc107730d                                                  1   0.0%
0xc1097063                                                  2   0.0%
0xc108a253                                                 73   0.0%
kernel                                                    874   0.4%
0xc10981a5                                             213781  99.6%</code></pre></div></div><div class=paragraph><p>Das <span class=filename>procsystime</span> Skript fängt die Systemaufruf-Zeiten für eine gegebene Prozess-ID (PID) oder einen Prozessnamen ab und gibt diese aus. Im folgenden Beispiel wurde eine neue Instanz von <span class=filename>/bin/csh</span> erzeugt. Dann wurde <span class=filename>procsystime</span> ausgeführt und verbleibt so, während ein paar Befehle in die andere Instanz von <code>csh</code> eingegeben werden. Dies sind die Ergebnisse dieses Versuchs:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./procsystime -n csh</span>
Tracing... Hit Ctrl-C to end...
^C

Elapsed Times <span class=k>for </span>processes csh,

         SYSCALL          TIME <span class=o>(</span>ns<span class=o>)</span>
          getpid               6131
       sigreturn               8121
           close              19127
           fcntl              19959
             dup              26955
         setpgid              28070
            <span class=nb>stat              </span>31899
       setitimer              40938
           wait4              62717
       sigaction              67372
     sigprocmask             119091
    gettimeofday             183710
           write             263242
          execve             492547
           ioctl             770073
           vfork            3258923
      sigsuspend            6985124
            <span class=nb>read         </span>3988049784</code></pre></div></div><div class=paragraph><p>Wie aus der Ausgabe ersichtlich ist, verbraucht der <code>read()</code>-Systemaufruf die meiste Zeit in Nanosekunden, während der Systemaufruf <code>getpid()</code> hingegen am schnellsten läuft.</p></div></div></div></div><div class=sect1><h2 id=usb-device-mode>Kapitel 43. USB Gerätemodus<a class=anchor href=#usb-device-mode></a></h2><div class=sectionbody><div class=sect2><h3 id=usb-device-mode-synopsis>43.1. Übersicht<a class=anchor href=#usb-device-mode-synopsis></a></h3><div class=paragraph><p>Dieses Kapitel behandelt die Verwendung des USB Gerätemodus und USB On-The-Go (USB OTG) unter FreeBSD. Dazu gehören virtuelle serielle Konsolen, virtuelle Netzwerkkarten und virtuelle USB-Laufwerke.</p></div><div class=paragraph><p>Wenn die eingesetzte Hardware den USB-Gerätemodus oder USB OTG unterstützt, kann FreeBSDs USB-Stack im Gerätemodus ausgeführt werden. Solche Hardware wird häufig in eingebetteten Systeme verbaut. Der Gerätemodus ermöglicht es dem Rechner verschiedene Arten von USB-Geräteklassen darzustellen, einschließlich serieller Schnittstellen, Netzwerkkarten und Massenspeicher oder Kombinationen davon. Ein USB-Host, beispielsweise ein Notebook oder ein Desktop-Rechner, kann wie auf ein physisches USB-Gerät darauf zugreifen.</p></div><div class=paragraph><p>Es gibt zwei grundlegende Möglichkeiten, wie die Hardware den Gerätemodus bereitstellen kann: mit einem separaten "Client Modus", der nur den Gerätemodus unterstützt, und mit einem USB-OTG-Port, der sowohl den Geräte- als auch den Hostmodus bereitstellen kann. Bei USB-OTG-Ports wechselt der USB-Stack automatisch zwischen host- und geräteseitig, je nachdem, was an dem Port angeschlossen ist. Wenn Sie ein USB-Gerät wie einen Speicherstick an den Port anschließen, wechselt FreeBSD in den Hostmodus. Wenn Sie einen USB-Host wie einen Computer anschließen, wechselt FreeBSD in den Gerätemodus. "Client Ports" arbeiten immer im Gerätemodus.</p></div><div class=paragraph><p>Was FreeBSD dem USB-Host präsentiert, hängt von der sysctl-Variable <code>hw.usb.template</code> ab. Einige Vorlagen bieten ein einzelnes Gerät, beispielsweise ein serielles Terminal, andere bieten mehrere, die alle gleichzeitig verwendet werden können. Ein Beispiel ist die Vorlage 10, die ein Massenspeichergerät, eine serielle Konsole und eine Netzwerkkarte bereitstellt. <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> enthält eine Liste der verfügbaren Werte.</p></div><div class=paragraph><p>Beachten Sie, dass in einigen Fällen, abhängig von der Hardware und dem Betriebssystem des Hosts, die Änderung an der Konfiguration nur dann bemerkt werden kann, wenn der Host entweder physisch getrennt und wieder verbunden oder gezwungen wird, den USB-Bus auf eine systemspezifische Weise neu zu scannen. Wenn FreeBSD auf dem Host läuft, kann <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a> <code>reset</code> verwendet werden. Dies muss auch nach dem Laden von <span class=filename>usb_template.ko</span> geschehen, wenn der USB-Host bereits an der USB OTG-Buchse angeschlossen war.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie wissen:</p></div><div class=ulist><ul><li><p>wie man den USB Gerätemodus unter FreeBSD einrichtet.</p></li><li><p>wie man die virtuelle serielle Schnittstelle unter FreeBSD konfiguriert.</p></li><li><p>wie man sich mit der virtuellen seriellen Schnittstelle von verschiedenen Betriebssystemen aus verbindet.</p></li></ul></div></div><div class=sect2><h3 id=usb-device-mode-terminals>43.2. Virtuelle serielle USB-Ports<a class=anchor href=#usb-device-mode-terminals></a></h3><div class=sect3><h4 id=_konfiguration_des_usb_gerätemodus_für_serielle_ports>43.2.1. Konfiguration des USB-Gerätemodus für serielle Ports<a class=anchor href=#_konfiguration_des_usb_gerätemodus_für_serielle_ports></a></h4><div class=paragraph><p>Die virtuellen seriellen Ports werden durch die Vorlagen 3, 8 und 10 unterstützt. Beachten Sie, dass Vorlage 3 mit Microsoft Windows 10 ohne spezielle Treiber und INF-Dateien funktioinert. Andere Host-Betriebssysteme arbeiten mit allen drei Vorlagen. Die beiden Kernelmodule <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=umodem&amp;sektion=4&amp;format=html">umodem(4)</a> müssen geladen werden.</p></div><div class=paragraph><p>Um die seriellen Ports im USB-Gerätemodus zu aktivieren, fügen Sie folgenden Zeilen in <span class=filename>/etc/ttys</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyU0	&#34;/usr/libexec/getty 3wire&#34;	vt100	onifconsole secure
ttyU1	&#34;/usr/libexec/getty 3wire&#34;    vt100   onifconsole secure</pre></div></div><div class=paragraph><p>Danach fügen Sie folgende Zeilen in <span class=filename>/etc/devd.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>notify 100 {
	match &#34;system&#34;		&#34;DEVFS&#34;;
	match &#34;subsystem&#34;	&#34;CDEV&#34;;
	match &#34;type&#34;		&#34;CREATE&#34;;
	match &#34;cdev&#34;		&#34;ttyU[0-9]+&#34;;
	action &#34;/sbin/init q&#34;;
};</pre></div></div><div class=paragraph><p>Laden Sie die Konfiguration neu, falls <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> bereits läuft:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p>Stellen Sie sicher, dass die notwendigen Module geladen sind und die richtige Vorlage beim Booten gesetzt ist. Fügen Sie dazu folgende Zeilen in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>umodem_load=&#34;YES&#34;
hw.usb.template=3</pre></div></div><div class=paragraph><p>Um das Modul zu laden und die Vorlage ohne Neustart zu aktivieren, verwenden Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload umodem</span>
<span class=c># sysctl hw.usb.template=3</span></code></pre></div></div></div><div class=sect3><h4 id=_freebsd_mit_der_seriellen_schnittstelle_im_usb_gerätemodus_verbinden>43.2.2. FreeBSD mit der seriellen Schnittstelle im USB-Gerätemodus verbinden<a class=anchor href=#_freebsd_mit_der_seriellen_schnittstelle_im_usb_gerätemodus_verbinden></a></h4><div class=paragraph><p>Um eine Verbindung zu einer Karte herzustellen, die so konfiguriert ist, dass sie serielle Ports im USB-Gerätemodus bereitstellt, schließen Sie den USB-Host, beispielsweise einen Laptop, an den USB OTG- oder USB-Client-Port der Karte an. Verwenden Sie <code>pstat -t</code> auf dem Host, um die Terminalzeilen aufzulisten. Am Ende der Liste sollten Sie einen seriellen USB-Anschluss sehen, zum Beispiel "ttyU0". Um die Verbindung zu öffnen, benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/ttyU0</span></code></pre></div></div><div class=paragraph><p>Nach mehrmaligem Drücken der <kbd>Enter</kbd>-Taste erscheint ein Anmeldeprompt.</p></div></div><div class=sect3><h4 id=_macos_mit_der_seriellen_schnittstelle_im_usb_gerätemodus_verbinden>43.2.3. macOS mit der seriellen Schnittstelle im USB-Gerätemodus verbinden<a class=anchor href=#_macos_mit_der_seriellen_schnittstelle_im_usb_gerätemodus_verbinden></a></h4><div class=paragraph><p>Um eine Verbindung zu einer Karte herzustellen, die so konfiguriert ist, dass sie serielle Ports im USB-Gerätemodus bereitstellt, schließen Sie den USB-Host, beispielsweise einen Laptop, an den USB OTG- oder USB-Client-Port der Karte an. Um die Verbindung zu öffnen, benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/cu.usbmodemFreeBSD1</span></code></pre></div></div></div><div class=sect3><h4 id=_linux_mit_der_seriellen_schnittstelle_im_usb_gerätemodus_verbinden>43.2.4. Linux mit der seriellen Schnittstelle im USB-Gerätemodus verbinden<a class=anchor href=#_linux_mit_der_seriellen_schnittstelle_im_usb_gerätemodus_verbinden></a></h4><div class=paragraph><p>Um eine Verbindung zu einer Karte herzustellen, die so konfiguriert ist, dass sie serielle Ports im USB-Gerätemodus bereitstellt, schließen Sie den USB-Host, beispielsweise einen Laptop, an den USB OTG- oder USB-Client-Port der Karte an. Um die Verbindung zu öffnen, benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># minicom -D /dev/ttyACM0</span></code></pre></div></div></div><div class=sect3><h4 id=_windows_10_mit_der_seriellen_schnittstelle_im_usb_gerätemodus_verbinden>43.2.5. Windows 10 mit der seriellen Schnittstelle im USB-Gerätemodus verbinden<a class=anchor href=#_windows_10_mit_der_seriellen_schnittstelle_im_usb_gerätemodus_verbinden></a></h4><div class=paragraph><p>Um eine Verbindung zu einer Karte herzustellen, die so konfiguriert ist, dass sie serielle Ports im USB-Gerätemodus bereitstellt, schließen Sie den USB-Host, beispielsweise einen Laptop, an den USB OTG- oder USB-Client-Port der Karte an. Um die Verbindung zu öffnen, benötigen Sie ein Terminalprogramm mit Unterstützung für serielle Schnittstellen, zum Beispiel PuTTY. Um den von Windows® verwendeten COM-Port zu ermitteln, starten Sie den Geräte-Manager und erweitern Sie "Ports (COM & LPT)". Dort sehen Sie einen Namen wie "USB Serial Sevice (COM4)". Starten Sie das Terminalprogramm Ihrer Wahl, zum Beispiel PuTTY. Im Dialog von PuTTY setzen Sie den "Connection type" auf "Serial" und notieren im Feld "Serial line" den ermittelten COM-Namen. Danach klicken Sie auf "Open".</p></div></div></div><div class=sect2><h3 id=usb-device-mode-network>43.3. Netzwerkkarten im USB-Gerätemodus<a class=anchor href=#usb-device-mode-network></a></h3><div class=paragraph><p>Virtuelle Netzwerkkarten werden durch die Vorlagen 1, 8 und 10 unterstützt. Beachten Sie, dass keine dieser Vorlagen mit Windows® funktioniert. Andere Host-Betriebssysteme arbeiten mit allen drei Vorlagen. Die Kernelmodule <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=if_cdce&amp;sektion=4&amp;format=html">if_cdce(4)</a> müssen geladen sein.</p></div><div class=paragraph><p>Stellen Sie sicher, dass die notwendigen Module geladen sind und die richtige Vorlage beim Booten gesetzt ist. Fügen Sie dazu folgende Zeilen in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>if_cdce_load=&#34;YES&#34;
hw.usb.template=1</pre></div></div><div class=paragraph><p>Um das Modul zu laden und die Vorlage ohne Neustart zu aktivieren, verwenden Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_cdce</span>
<span class=c># sysctl hw.usb.template=1</span></code></pre></div></div></div><div class=sect2><h3 id=usb-device-mode-storage>43.4. Virtuelle USB-Speichergeräte<a class=anchor href=#usb-device-mode-storage></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> ist ein USB-Gerätetreiber, der seit FreeBSD 12.0 verfügbar ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Virtuelle Speichergeräte werden durch die Vorlagen 0 und 10 unterstützt. Die Kernelmodule <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> müssen geladen sein. <a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> ist die Schnittstelle zum CTL-Subsystem, das auch für iSCSI- oder Fibre-Channel-Targets benutzt wird. Auf dem Host können Initiatioren von USB-Massenspeichern nur auf eine einzige LUN, LUN 0 zugreifen.</p></div><div class=sect3><h4 id=_konfiguration_von_usb_massenspeicher_targets_mit_dem_cfumass_startskript>43.4.1. Konfiguration von USB-Massenspeicher Targets mit dem cfumass-Startskript<a class=anchor href=#_konfiguration_von_usb_massenspeicher_targets_mit_dem_cfumass_startskript></a></h4><div class=paragraph><p>Der einfachste Weg, ein schreibgeschütztes USBSpeicherziel einzurichten, ist die Verwendung des <span class=filename>cfumass</span> rc-Skripts. Kopieren Sie einfach die Dateien, die dem USB-Host präsentiert werden sollen, in das Verzeichnis <span class=filename>/var/cfumass</span> und fügen Sie diese Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>cfumass_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Um das Ziel ohne Neustart zu konfigurieren, führen Sie diesen Befehl aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service cfumass start</span></code></pre></div></div><div class=paragraph><p>Im Gegensatz zur seriellen und Netzwerkfunktionalität sollte die Vorlage in <span class=filename>/boot/loader.conf</span> nicht auf 0 oder 10 gesetzt werden, da die LUN vor dem Setzen der Vorlage konfiguriert werden muss. Das <span class=filename>cfumass</span> rc-Skript setzt beim Start automatisch die richtige Vorlage.</p></div></div><div class=sect3><h4 id=_usb_massenspeicher_mit_anderen_werkzeugen_konfigurieren>43.4.2. USB-Massenspeicher mit anderen Werkzeugen konfigurieren<a class=anchor href=#_usb_massenspeicher_mit_anderen_werkzeugen_konfigurieren></a></h4><div class=paragraph><p>Der Rest dieses Kapitels enthält eine detaillierte Beschreibung der Konfiguration ohne die Verwendung des <span class=filename>cfumass</span> rc-Skripts. Dies ist beispielsweise notwendig, wenn man eine beschreibbare LUN zur Verfügung stellen will.</p></div><div class=paragraph><p>Im Gegensatz zu iSCSI ist es bei USB-Massenspeichern nicht zwingend erforderlich, dass der <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> Daemon läuft. Es gibt zwei Möglichkeiten, das Target zu konfigurieren: <a href="https://man.freebsd.org/cgi/man.cgi?query=ctladm&amp;sektion=8&amp;format=html">ctladm(8)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a>. Beide erfordern, dass das Kernelmodul <span class=filename>cfumass.ko</span> geladen ist. Das Modul kann manuell geladen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload cfumass</span></code></pre></div></div><div class=paragraph><p>Wenn <span class=filename>cfumass</span> nicht im Kernel integriert ist, kann <span class=filename>/boot/loader.conf</span> angepasst werden, damit das Modul beim Booten geladen wird:</p></div><div class="literalblock programlisting"><div class=content><pre>cfumass_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Eine LUN kann ohne den <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> Daemon erstellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ctladm create -b block -o file=/data/target0</span></code></pre></div></div><div class=paragraph><p>Dies stellt den Inhalt des Abbilds von <span class=filename>/data/target0</span> als LUN auf dem USB-Host dar. Die Datei muss vor der Ausführung des Befehls vorhanden sein. Um die LUN beim Systemstart zu konfigurieren, muss das Kommando in <span class=filename>/etc/rc.local</span> eingetragen werden.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> kann auch benutzt werden, um LUNs zu verwalten. Dazu erstellen Sie eine <span class=filename>/etc/ctl.conf</span> und fügen eine Zeile in <span class=filename>/etc/rc.conf</span> hinzu, um sicherzustellen, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> beim Booten automatisch gestartet wird. Danach kann der Daemon gestartet werden.</p></div><div class=paragraph><p>Es folgt ein Beispiel einer einfachen Konfiguration für <span class=filename>/etc/ctl.conf</span>. Eine ausführliche Beschreibung der Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ctl.conf&amp;sektion=5&amp;format=html">ctl.conf(5)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>target naa.50015178f369f092 {
	lun 0 {
		path /data/target0
		size 4G
	}
}</pre></div></div><div class=paragraph><p>Dieses Beispiel erstellt ein einzelnes Target mit einer einzigen LUN. <code>naa.50015178f369f092</code> ist eine Gerätekennung, die aus 32 zufälligen Hexadezimalziffern besteht. <code>path</code> definiert den absoluten Pfad zu einer Datei oder eines zvol, welches die LUN als Speicher nutzen kann. Diese Datei muss vor dem Start von <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> existieren. Die zweite Zeile ist optional und definiert die Größe der LUN.</p></div><div class=paragraph><p>Damit der <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> Daemon beim Booten gestartet wird, muss diese Zeile in <span class=filename>/etc/rc.conf</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>ctld_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Sie können <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> mit diesem Befehl direkt starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld start</span></code></pre></div></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> Daemon liest beim Start <span class=filename>/etc/ctl.conf</span>. Wenn diese Datei nach dem Start des Daemons bearbeitet wird, müssen die Änderungen neu geladen werden, damit sie sofort wirksam werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld reload</span></code></pre></div></div><div class=paragraph><p>path: "/books/handbook/partiv/"
---
:leveloffset: +1</p></div></div></div></div></div><h1 id=serialcomms class=sect0>Teil IV: Serielle Datenübertragung<a class=anchor href=#serialcomms></a></h1><div class=sect1><h2 id=serial-synopsis>Kapitel 44. Übersicht<a class=anchor href=#serial-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>UNIX® Systeme unterstützten schon immer die serielle Datenübertragung. Tatsächlich wurden Ein- und Ausgaben auf den ersten UNIX® Maschinen über serielle Leitungen durchgeführt. Seit der Zeit, in der ein durchschnittlicher Terminal aus einem seriellen Drucker mit 10 Zeichen/Sekunde und einer Tastatur bestand, hat sich viel verändert. Dieses Kapitel behandelt einige Möglichkeiten, serielle Datenübertragung unter FreeBSD zu verwenden.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes wissen:</p></div><div class=ulist><ul><li><p>Wie Sie Terminals an ein FreeBSD-System anschließen.</p></li><li><p>Wie Sie sich mit einem Modem auf entfernte Rechner einwählen.</p></li><li><p>Wie Sie entfernten Benutzern erlauben, sich mit einem Modem in ein FreeBSD-System einzuwählen.</p></li><li><p>Wie Sie ein FreeBSD-System über eine serielle Konsole booten.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie</p></div><div class=ulist><ul><li><p>einen <a href=./#kernelconfig>angepassten Kernel konfigurieren und installieren</a> können.</p></li><li><p><a href=./#basics>Berechtigungen und Prozesse unter FreeBSD</a> verstehen.</p></li><li><p>Zugriff auf die Handbücher der seriellen Komponenten haben, die mit FreeBSD verwendet werden sollen.</p></li></ul></div></div></div><div class=sect1><h2 id=serial>Kapitel 45. Begriffe und Hardware<a class=anchor href=#serial></a></h2><div class=sectionbody><div class=paragraph><p>Die folgenden Begriffe werden oft verwendet, wenn es um serielle Kommunikation geht:</p></div><div class=dlist><dl><dt class=hdlist1>bps</dt><dd><p>Bits pro Sekunde (bps) ist die Einheit für die Übertragungsgeschwindigkeit.</p></dd><dt class=hdlist1>DEE (DTE)</dt><dd><p>Eine Datenendeinrichtung (Data Terminal Equipment) ist einer der beiden Endpunkte bei der seriellen Kommunikation. Zum Beispiel ein Computer.</p></dd><dt class=hdlist1>DÜE (DCE)</dt><dd><p>Datenübertragungseinrichtung (Data Communications Equipment) ist der andere Endpunkt bei der seriellen Kommunikation. Typischerweise ein Modem.</p></dd><dt class=hdlist1>RS-232</dt><dd><p>Der originale Standard, der serielle Datenübertragung definiert. Er wird heutzutage als TIA-232 bezeichnet.</p></dd></dl></div><div class=paragraph><p>In diesem Abschnitt wird der Begriff "Baud" nicht für Übertragungsgeschwindigkeiten gebraucht. Baud bezeichnet elektrische Zustandswechsel pro Zeiteinheit, die Taktfrequenz, während "bps" der <em>richtige</em> Begriff für die Übertragungsgeschwindigkeit ist.</p></div><div class=paragraph><p>Um ein Modem oder einen Terminal an ein FreeBSD-System anzuschließen, muss der Computer über eine serielle Schnittstelle verfügen. Zusätzlich wird das passende Kabel benötigt, um das Gerät mit der Schnittstelle zu verbinden. Benutzer, die mit seriellen Geräten und den nötigen Kabeln schon vertraut sind, können diesen Abschnitt überspringen.</p></div><div class=sect2><h3 id=term-cables-null>45.1. Kabel und Schnittstellen<a class=anchor href=#term-cables-null></a></h3><div class=paragraph><p>Es gibt verschiedene serielle Kabel. Die zwei häufigsten sind Nullmodemkabel und Standard-RS-232-Kabel. Die Dokumentation der Hardware sollte beschreiben, welcher Kabeltyp benötigt wird.</p></div><div class=paragraph><p>Ein Nullmodemkabel verbindet einige Signale, wie die Betriebserde, eins zu eins, andere Signale werden getauscht: Die Sende- und Empfangsleitungen werden zum Beispiel gekreuzt.</p></div><div class=paragraph><p>Nullmodemkabel für die Anbindung eines Terminals können auch selbst hergestellt werden. Die folgende Tabelle enthält die <a href=#serialcomms-signal-names>Signalnamen</a> von RS-232C sowie die Pinbelegung für einen Stecker vom Typ DB-25. Obwohl der Standard eine direkte Verbindung von Pin 1 zu Pin 1 (<em>Protective Ground</em>) vorschreibt, ist diese in vielen Fällen nicht vorhanden. Einige Terminals benötigen nur die Pins 2, 3 und 7 für eine korrekte Funktion, während andere eine unterschiedliche Konfiguration als die in den folgenden Beispielen gezeigte benötigen.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 19. Nullmodemkabel vom Typ DB-25-zu-DB-25</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Signal</th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top">Signal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr></tbody></table><div class=paragraph><p>Die folgenden zwei Schemata werden heutzutage ebenfalls häufig eingesetzt:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 20. Nullmodemkabel vom Typ DB-9-zu-DB-9</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Signal</th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top">Signal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr></tbody></table><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 21. Nullmodemkabel vom Typ DB-9-zu-DB-25</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Signal</th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top">Signal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>verbunden mit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wird ein Pin eines Kabels mit zwei Pins des anderen Kabels verbunden, werden dazu in der Regel zuerst die beiden Pins mit einem kurzem Draht verbunden. Danach wird dieser Draht mit dem Pin des anderen Endes verbunden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die eben besprochenen Schemata scheinen die beliebtesten zu sein. Weitere Varianten verbinden SG mit SG, TD mit RD, RTS und CTS mit DCD, DTR mit DSR, und umgekehrt.</p></div><div class=paragraph><p>Ein Standard-RS-232C-Kabel verbindet alle Signale direkt. Das Signal "Transmitted Data" wird mit dem Signal "Transmitted Data" der Gegenstelle verbunden. Dieses Kabel wird benötigt, um ein Modem mit einem FreeBSD-System zu verbinden. Manche Terminals benötigen dieses Kabel ebenfalls.</p></div><div class=paragraph><p>Über serielle Schnittstellen werden Daten zwischen dem FreeBSD-System und dem Terminal übertragen. Dieser Abschnitt beschreibt die verschiedenen Schnittstellen und wie sie unter FreeBSD angesprochen werden.</p></div><div class=paragraph><p>Da es verschiedene Schnittstellen gibt, sollte vor dem Kauf oder Selbstbau eines Kabels sichergestellt werden, dass dieses zu den Schnittstellen des Terminals und des FreeBSD-Systems passt.</p></div><div class=paragraph><p>Die meisten Terminals besitzen DB-25-Stecker. Personal Computer haben DB-25- oder DB-9-Stecker. Eine serielle Multiportkarte hat vielleicht RJ-12- oder RJ-45-Anschlüsse.</p></div><div class=paragraph><p>Die Dokumentation der Geräte sollte Aufschluss über den Typ der benötigten Anschlüsse geben. Oft hilft es, wenn Sie sich den Anschluss einfach ansehen.</p></div><div class=paragraph><p>Unter FreeBSD wird jede serielle Schnittstelle (Port) über einen Eintrag in <span class=filename>/dev</span> angesprochen. Es gibt dort zwei verschiedene Einträge:</p></div><div class=ulist><ul><li><p>Schnittstellen für eingehende Verbindungen werden <span class=filename>/dev/ttyuN</span> genannt. Dabei ist <em>N</em> die Nummer der Schnittstelle, deren Zählung bei Null beginnt. Allgemein wird diese Schnittstelle für Terminals benutzt. Diese Schnittstelle funktioniert nur, wenn ein "Data Carrier Detect" Signal (DCD) vorliegt.</p></li><li><p>Für ausgehende Verbindungen wird in FreeBSD 8.X und neueren Versionen <span class=filename>/dev/cuauN</span> verwendet. FreeBSD 7.X und ältere Versionen verwenden <span class=filename>/dev/cuadN</span>. Dieser Port wird normalerweise nur von Modems genutzt. Er kann allerdings auch für Terminals benutzt werden, die das "Data Carrier Detect" Signal nicht unterstützen.</p></li></ul></div><div class=paragraph><p>Wenn ein Terminal an die erste serielle Schnittstelle (<span class=filename>COM1</span>) angeschlossen ist, wird er über <span class=filename>/dev/ttyu0</span> angesprochen. Wenn er an der zweiten seriellen Schnittstelle (COM2) angeschlossen ist, verwenden Sie <span class=filename>/dev/ttyu1</span>, usw.</p></div></div><div class=sect2><h3 id=_kernelkonfiguration>45.2. Kernelkonfiguration<a class=anchor href=#_kernelkonfiguration></a></h3><div class=paragraph><p>In der Voreinstellung benutzt FreeBSD vier serielle Schnittstellen, die unter MS-DOS® als <span class=filename>COM1</span>, <span class=filename>COM2</span>, <span class=filename>COM3</span> und <span class=filename>COM4</span> bekannt sind. Momentan unterstützt FreeBSD einfache Multiportkarten, wie bspw. die BocaBoard 1008 und 2016 und bessere wie die von Digiboard und Stallion Technologies. In der Voreinstellung sucht der Kernel allerdings nur nach den Standardanschlüssen.</p></div><div class=paragraph><p>Um zu überprüfen, ob der Kernel die seriellen Schnittstellen erkennt, achten Sie auf die Meldungen beim Booten, oder schauen sich diese später mit <code>/sbin/dmesg</code> an. Achten Sie auf Meldungen die mit <code>uart</code> beginnen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dmesg | grep &#39;uart&#39;</span></code></pre></div></div><div class=paragraph><p>Wenn der Kernel nicht alle seriellen Schnittstellen erkennt, müssen Sie <span class=filename>/boot/device.hints</span> konfigurieren. Wenn Sie diese Datei editieren, können Sie die Einträge für Geräte, die auf dem System nicht vorhanden sind, auskommentieren oder komplett entfernen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>port IO_COM1</code> ist ein Ersatz für <code>port 0x3f8</code>, <code>IO_COM2</code> bedeutet <code>port 0x2f8</code>, <code>IO_COM3</code> bedeutet <code>port 0x3e8</code> und <code>IO_COM4</code> steht für <code>port 0x2e8</code>. Die angegebenen IO-Adressen sind genau wie die Interrupts 4, 3, 5 und 9 üblich für serielle Schnittstellen. Beachten Sie, dass sich normale serielle Schnittstellen auf ISA-Bussen <em>keine</em> Interrupts teilen können. Multiportkarten besitzen zusätzliche Schaltkreise, die es allen 16550As auf der Karte erlauben, sich einen oder zwei Interrupts zu teilen.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_gerätedateien>45.3. Gerätedateien<a class=anchor href=#_gerätedateien></a></h3><div class=paragraph><p>Die meisten Geräte im Kernel werden durch Gerätedateien in <span class=filename>/dev</span> angesprochen. Die <span class=filename>sio</span> Geräte werden durch <span class=filename>/dev/ttyuN</span> für eingehende Verbindungen und durch <span class=filename>/dev/cuauN</span> für ausgehende Verbindungen angesprochen. Zum Initialisieren der Geräte stellt FreeBSD die Dateien <span class=filename>/dev/ttyuN.init</span> und <span class=filename>/dev/cuauN.init</span> zur Verfügung. Zusätzlich existieren Dateien für das Sperren von Gerätedateien (Locking). Dabei handelt es sich um die Dateien <span class=filename>/dev/ttyuN.lock</span> und <span class=filename>/dev/cuauN.lock</span>. Diese Dateien werden benutzt, um Kommunikationsparameter beim Öffnen eines Ports vorzugeben. Für Modems, die zur Flusskontrolle <code>RTS/CTS</code> benutzen, kann damit <code>crtscts</code> gesetzt werden. Die Geräte <span class=filename>/dev/ttyldN</span> und <span class=filename>/dev/cualaN</span> (locking devices) werden genutzt, um bestimmte Parameter festzuschreiben und vor Veränderungen zu schützen. Weitere Informationen zu Terminals finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=termios&amp;sektion=4&amp;format=html">termios(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> erklärt die Dateien zum Initialisieren und Sperren der Geräte, <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> beschreibt schließlich Terminal-Einstellungen.</p></div></div><div class=sect2><h3 id=serial-hw-config>45.4. Konfiguration der seriellen Schnittstelle<a class=anchor href=#serial-hw-config></a></h3><div class=paragraph><p>Anwendungen benutzen normalerweise die Geräte <span class=filename>ttyuN</span> oder <span class=filename>cuauN</span>. Das Gerät besitzt einige Voreinstellungen für Terminal-I/O, wenn es von einem Prozess geöffnet wird. Mit dem folgenden Kommando können Sie sich diese Einstellungen ansehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -a -f /dev/ttyu1</span></code></pre></div></div><div class=paragraph><p>Wenn diese Einstellungen verändert werden, bleiben sie nur solange wirksam, bis das Gerät geschlossen wird. Wenn das Gerät danach wieder geöffnet wird, sind die Voreinstellungen wieder wirksam. Um die Voreinstellungen dauerhaft zu ändern, öffnen Sie das Gerät, das zum Initialisieren dient und verändern dessen Einstellungen. Um beispielsweise für <span class=filename>ttyu5</span> den <code>CLOCAL</code> Modus, 8-Bit Kommunikation und <code>XON/XOFF</code> Flusssteuerung einzuschalten, setzen Sie das folgende Kommando ab:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</span></code></pre></div></div><div class=paragraph><p>In <span class=filename>/etc/rc.d/rc.serial</span> werden die systemweiten Voreinstellungen für serielle Geräte vorgenommen.</p></div><div class=paragraph><p>Um zu verhindern, dass Einstellungen von Anwendungen verändert werden, können Sie die Geräte zum Festschreiben von Einstellungen ("locking devices") benutzen. Wenn sie beispielsweise die Geschwindigkeit von <span class=filename>ttyu5</span> auf 57600 bps festlegen wollen, benutzen Sie das folgende Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyld5 57600</span></code></pre></div></div><div class=paragraph><p>Eine Anwendung, die <span class=filename>ttyu5</span> öffnet, kann nun nicht mehr die Geschwindigkeit ändern und muss 57600 bps benutzen.</p></div><div class=paragraph><p>Die Geräte zum Initialisieren und Festschreiben von Einstellungen sollten selbstverständlich nur von <code>root</code> beschreibbar sein.</p></div></div></div></div><div class=sect1><h2 id=term>Kapitel 46. Terminals<a class=anchor href=#term></a></h2><div class=sectionbody><div class=paragraph><p>Wenn Sie sich nicht an der Konsole oder über ein Netzwerk an ein FreeBSD-System anmelden können, sind Terminals ein bequemer und kostengünstiger Weg, um auf ein System zuzugreifen. Dieser Abschnitt beschreibt wie Sie Terminals mit FreeBSD benutzen.</p></div><div class=paragraph><p>Das ursprüngliche UNIX® System besaß keine Konsolen. Zum Anmelden und Starten von Programmen wurden stattdessen Terminals benutzt, die an den seriellen Schnittstellen des Rechners angeschlossen waren.</p></div><div class=paragraph><p>Die Möglichkeit, über eine serielle Schnittstelle eine Anmeldesitzung herzustellen, existiert heute noch in fast jedem UNIX®-artigen Betriebssystem, einschließlich FreeBSD. Der Einsatz eines Terminals, das an einem freien seriellen Port angeschlossen ist, ermöglicht es dem Benutzer sich anzumelden und dort jedes Textprogramm zu starten, das normalerweise an der Konsole oder in einem <code>xterm</code> Fenster ausgeführt wird.</p></div><div class=paragraph><p>Viele Terminals können an einem FreeBSD-System angeschlossen werden. Ein alter Computer kann als Terminal an ein leistungsfähiges FreeBSD-System angeschlossen werden. Damit kann ein Einzelarbeitsplatz in ein leistungsfähiges Mehrbenutzersystem verwandelt werden.</p></div><div class=paragraph><p>FreeBSD unterstützt drei Arten von Anschlüssen:</p></div><div class=dlist><dl><dt class=hdlist1>Dumb-Terminals</dt><dd><p>Dumb-Terminals (unintelligente Datenstationen) sind Geräte, die über die serielle Schnittstelle mit einem Rechner verbunden werden. Sie werden "unintelligent" genannt, weil sie nur Text senden und empfangen und keine Programme laufen lassen können. Alle benötigten Programme befinden sich auf dem Rechner, der mit dem Terminal verbunden ist.</p><div class=paragraph><p>Es gibt viele Dumb-Terminals, die von verschiedenen Herstellern produziert werden, und so gut wie jeder der verschiedenen Terminals sollte mit FreeBSD zusammenarbeiten. Manche High-End Geräte verfügen sogar über Grafikfähigkeiten, die allerdings nur von spezieller Software genutzt werden kann.</p></div><div class=paragraph><p>Dumb-Terminals sind in Umgebungen beliebt, in denen keine Grafikanwendungen benötigt werden.</p></div></dd><dt class=hdlist1>Computer, die als Terminal fungieren</dt><dd><p>Jeder Computer kann die Funktion eines Dumb-Terminals, der ja nur Text senden und empfangen kann, übernehmen. Dazu wird lediglich das richtige Kabel benötigt und eine <em>Terminalemulation</em>, die auf dem Computer läuft.</p><div class=paragraph><p>Diese Konfiguration ist sehr nützlich. Wenn ein Benutzer zum Beispiel gerade an der FreeBSD-Konsole arbeitet, kann ein anderer Benutzer einen weniger leistungsstarken Computer, der als Terminal mit dem FreeBSD-System verbunden ist, benutzen, um dort gleichzeitig im Textmodus zu arbeiten.</p></div><div class=paragraph><p>Bereits im Basissystem sind mindestens zwei Werkzeuge vorhanden, die Sie zur Arbeit über eine serielle Konsole einsetzen können: <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a>.</p></div><div class=paragraph><p>Um sich von einem FreeBSD-System aus über eine serielle Verbindung mit einem anderen System zu verbinden, geben Sie folgenden Befehl ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/cuauN</span></code></pre></div></div><div class=paragraph><p>Die Ports sind von Null beginnend nummeriert. Das bedeutet, dass <span class=filename>COM1</span> dem Gerät <span class=filename>/dev/cuau0</span> entspricht.</p></div><div class=paragraph><p>In der Ports-Sammlung finden sich weitere Programme, wie beispielsweise <a class=package href=https://cgit.freebsd.org/ports/tree/comms/minicom/>comms/minicom</a>, mit denen eine Verbindung über eine serielle Schnittstelle hergestellt werden kann.</p></div></dd><dt class=hdlist1>X-Terminals</dt><dd><p>X-Terminals sind die ausgereiftesten der verfügbaren Terminals. Sie werden nicht mit der seriellen Schnittstelle sondern mit einem Netzwerk, wie dem Ethernet, verbunden. Diese Terminals sind auch nicht auf den Textmodus beschränkt, sondern können jede Xorg-Anwendung darstellen.</p><div class=paragraph><p>Die Einrichtung und Verwendung von X-Terminals wird in diesem Abschnitt nicht beschrieben.</p></div></dd></dl></div><div class=sect2><h3 id=term-config>46.1. Konfiguration<a class=anchor href=#term-config></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie ein FreeBSD-System konfigurieren müssen, um sich an einem Terminal anzumelden. Dabei wird vorausgesetzt, dass der Kernel bereits die serielle Schnittstelle, die mit dem Terminal verbunden ist, unterstützt. Weiterhin sollte der Terminal schon angeschlossen sein.</p></div><div class=paragraph><p>Der <code>init</code> Prozess ist für das Initialisieren des Systems und den Start von Prozessen zum Zeitpunkt des Systemstarts verantwortlich. Unter anderem liest <code>init</code><span class=filename>/etc/ttys</span> ein und startet für jeden verfügbaren Terminal einen <code>getty</code> Prozess. <code>getty</code> wiederum fragt beim Anmelden den Benutzernamen ab und startet <code>login</code>.</p></div><div class=paragraph><p>Um Terminals auf einem FreeBSD-System einzurichten, führen Sie folgenden Schritte als <code>root</code> durch:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Fügen Sie einen Eintrag in <span class=filename>/etc/ttys</span> für die serielle Schnittstelle aus <span class=filename>/dev</span> ein, falls dieser nicht bereits vorhanden ist.</p></li><li><p>Geben Sie <code>/usr/libexec/getty</code> als auszuführendes Programm an. Als Parameter für <em>getty</em> geben Sie den passenden Verbindungstyp aus <span class=filename>/etc/gettytab</span> an.</p></li><li><p>Geben Sie den Terminaltyp an.</p></li><li><p>Aktivieren Sie den Anschluss.</p></li><li><p>Geben Sie die Sicherheit des Anschlusses an.</p></li><li><p>Veranlassen Sie <code>init</code><span class=filename>/etc/ttys</span> erneut zu lesen.</p></li></ol></div><div class=paragraph><p>Optional können Sie in <span class=filename>/etc/gettytab</span> auch einen auf Ihre Zwecke angepassten Terminaltyp erstellen. <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> enthalten dazu weitere Informationen.</p></div><div class=sect3><h4 id=term-etcttys>46.1.1. Hinzufügen eines Eintrags in <span class=filename>/etc/ttys</span><a class=anchor href=#term-etcttys></a></h4><div class=paragraph><p>In <span class=filename>/etc/ttys</span> werden alle Terminals aufgeführt, an denen eine Anmeldung auf dem FreeBSD-System möglich ist. Hier findet sich zum Beispiel ein Eintrag für die erste virtuelle Konsole <span class=filename>/dev/ttyv0</span>, der es Benutzern ermöglicht, sich dort anzumelden. Die Datei enthält weitere Einträge für andere virtuelle Konsolen, serielle Schnittstellen und Pseudoterminals. Um einen Terminal zu konfigurieren, fügen Sie einen Eintrag für den Namen des Gerätes aus <span class=filename>/dev</span> ohne das Präfix <span class=filename>/dev</span> hinzu. Zum Beispiel wird <span class=filename>/dev/ttyv0</span> als <code>ttyv0</code> aufgeführt.</p></div><div class=paragraph><p>In der Voreinstellung enthält <span class=filename>/etc/ttys</span> Einträge für die ersten vier seriellen Schnittstellen: <span class=filename>ttyu0</span> bis <span class=filename>ttyu3</span>. Wird an eine von diesen Schnittstellen ein Terminal angeschlossen, braucht in dieser Datei kein weiter Eintrag hinzugefügt werden.</p></div><div id=ex-etc-ttys class=exampleblock><div class=title>Beispiel 44. Einträge in <span class=filename>/etc/ttys</span> hinzufügen</div><div class=content><div class=paragraph><p>Dieses Beispiel konfiguriert zwei Terminals: Einen Wyse-50 und einen alten 286 IBM PC, der mit Procomm einen VT-100 Terminal emuliert. Der Wyse-Terminal ist mit der zweiten seriellen Schnittstelle verbunden und der 286 mit der sechsten seriellen Schnittstelle, einem Anschluss auf einer Multiportkarte. Die entsprechenden Einträge in <span class=filename>/etc/ttys</span> würden dann wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu1  &#34;/usr/libexec/getty std.38400&#34;  wy50  on  insecure
ttyu5   &#34;/usr/libexec/getty std.19200&#34;  vt100  on  insecure</pre></div></div><div class=paragraph><p>Das erste Feld gibt normalerweise den Namen der Gerätedatei aus <span class=filename>/dev</span> an.</p></div><div class=paragraph><p>Im zweiten Feld wird das auszuführende Kommando, normal ist das <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>, angegeben. <code>getty</code> initialisiert und öffnet die Verbindung, setzt die Geschwindigkeit und fragt den Benutzernamen ab. Danach führt es <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> aus.</p></div><div class=paragraph><p><code>getty</code> akzeptiert einen optionalen Parameter auf der Kommandozeile, den Verbindungstyp, der die Eigenschaften der Verbindung, wie die Geschwindigkeit und Parität, festlegt. Die Typen und die damit verbundenen Eigenschaften liest <code>getty</code> aus <span class=filename>/etc/gettytab</span>.</p></div><div class=paragraph><p><span class=filename>/etc/gettytab</span> enthält viele Einträge sowohl für neue wie auch alte Terminalverbindungen. Die meisten Einträge, die mit <code>std</code> beginnen, sollten mit einem festverdrahteten Terminal funktionieren. Für jede Geschwindigkeit zwischen 110 bps und 115200 bps gibt es einen <code>std</code> Eintrag. Weitere Informationen dazu finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a>.</p></div><div class=paragraph><p>Wenn Sie den Verbindungstyp in <span class=filename>/etc/ttys</span> eintragen, stellen Sie sicher, dass die Kommunikationseinstellungen auch mit denen des Terminals übereinstimmen.</p></div><div class=paragraph><p>In diesem Beispiel verwendet der Wyse-50 keine Parität und 38400 bps, der 286 PC benutzt ebenfalls keine Parität und arbeitet mit 19200 bps.</p></div><div class=paragraph><p>Das dritte Feld gibt den Terminaltyp an, der normalerweise mit diesem Anschluss verbunden ist. Für Einwählverbindungen wird oft <code>unknown</code> oder <code>dialup</code> benutzt, da sich die Benutzer praktisch mit beliebigen Terminals oder Emulatoren anmelden können. Bei festverdrahteten Terminals ändert sich der Typ nicht, so dass in diesem Feld ein richtiger Typ aus der <a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a> Datenbank angegeben werden kann.In diesem Beispiel benutzt der Wyse-50 den entsprechenden Typ aus <a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a>, der 286 PC wird als VT-100, den er ja emuliert, angegeben.</p></div><div class=paragraph><p>Das vierte Feld gibt an, ob der Anschluss aktiviert werden soll. Ist das Feld auf <code>on</code> gesetzt, startet <code>init</code> das Programm, das im zweiten Feld angegeben ist. Normalerweise ist dies <code>getty</code>. Wenn das Feld auf <code>off</code> gesetzt wird, wird <code>getty</code> nicht ausgeführt und folglich kann sich niemand an dem betreffenden Terminal anmelden.</p></div><div class=paragraph><p>Das letzte Feld gibt die Sicherheit des Anschlusses an. Wenn hier <code>secure</code> angegeben wird, darf sich <code>root</code>, oder jeder Account mit der UID <code>0</code> über diese Verbindung anmelden. Wenn <code>insecure</code> angegeben wird, dürfen sich nur unprivilegierte Benutzer anmelden. Diese können später mit <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> oder einem ähnlichen Mechanismus zu <code>root</code> wechseln.Es wird dringend empfohlen <code>insecure</code> zu verwenden, sogar für Terminals hinter verschlossenen Türen. Es ist ganz einfach sich mit <code>su</code> anzumelden, wenn Superuser-Rechte benötigt werden.</p></div></div></div></div><div class=sect3><h4 id=term-hup>46.1.2. <code>init</code> zwingen, <span class=filename>/etc/ttys</span> erneut zu lesen<a class=anchor href=#term-hup></a></h4><div class=paragraph><p>Nachdem Änderungen in <span class=filename>/etc/ttys</span> vorgenommen wurden, schicken Sie <code>init</code> ein SIGHUP-Signal (hangup), um es zu veranlassen, seine Konfigurationsdatei neu zu lesen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Da <code>init</code> immer der erste Prozess auf einem System ist, besitzt es immer die Prozess-ID <code>1</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn alles richtig eingerichtet ist, alle Kabel angeschlossen und die Terminals eingeschaltet sind, sollte für jeden Terminal ein <code>getty</code> Prozess laufen und auf jedem Terminal sollte eine Anmeldeaufforderung zu sehen sein.</p></div></div></div><div class=sect2><h3 id=term-debug>46.2. Fehlersuche<a class=anchor href=#term-debug></a></h3><div class=paragraph><p>Selbst wenn Sie den Anweisungen akribisch gefolgt sind, kann es immer noch zu Fehlern beim Einrichten eines Terminals kommen. Hier eine Liste der häufigsten Symptome, sowie einige mögliche Lösungen:</p></div><div class=paragraph><p>Wenn kein Anmeldeprompt erscheint, stellen Sie sicher, dass der Terminal verbunden und eingeschaltet ist. Wenn ein PC als Terminal fungiert, überprüfen Sie, dass die Terminalemulation auf den richtigen Schnittstellen läuft.</p></div><div class=paragraph><p>Stellen Sie sicher, dass Sie das richtige Kabel verwenden und dass das Kabel fest mit dem Terminal und dem FreeBSD-Rechner verbunden ist.</p></div><div class=paragraph><p>Stellen Sie sicher, dass die Einstellungen für die Geschwindigkeit (bps) und Parität auf dem FreeBSD-System und dem Terminal gleich sind. Wenn der Terminal einen Bildschirm besitzt, überprüfen Sie die richtige Einstellung von Helligkeit und Kontrast. Wenn der Terminal druckt, stellen Sie die ausreichende Versorgung mit Papier und Tinte sicher.</p></div><div class=paragraph><p>Überprüfen Sie mit <code>ps</code>, dass der <code>getty</code> Prozess für den Terminal läuft:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps -axww|grep getty</span></code></pre></div></div><div class=paragraph><p>Für jeden Terminal sollte ein Eintrag vorhanden sein. Aus dem folgenden Beispiel ist zu erkennen, dass <code>getty</code> auf der zweiten seriellen Schnittstelle <span class=filename>tyyd1</span> läuft und den Verbindungstyp <code>std.38400</code> aus <span class=filename>/etc/gettytab</span> benutzt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</code></pre></div></div><div class=paragraph><p>Wenn <code>getty</code> nicht läuft, überprüfen Sie, ob der Anschluss in <span class=filename>/etc/ttys</span> aktiviert ist. Denken Sie daran <code>kill -HUP 1</code> auszuführen, nachdem <span class=filename>/etc/ttys</span> geändert wurde.</p></div><div class=paragraph><p>Wenn <code>getty</code> läuft, aber der Terminal immer noch kein Anmeldeprompt ausgibt, oder am Anmeldeprompt nichts eingegeben werden kann, kann es sein, dass der Terminal oder Kabel keinen Hardware-Handshake unterstützt. Ändern Sie dann den Eintrag <code>std.38400</code> in <span class=filename>/etc/ttys</span> zu <code>3wire.38400</code>. Nachdem Sie <span class=filename>/etc/ttys</span> geändert haben, setzen Sie <code>kill -HUP 1</code> ab. Der Eintrag <code>3wire</code> besitzt ähnliche Eigenschaften wie der Eintrag <code>std</code>, ignoriert aber den Hardware-Handshake. Wenn Sie den Eintrag <code>3wire</code> verwenden, muss vielleicht die Geschwindigkeit verkleinert oder die Software-Flusssteuerung aktiviert werden, um Pufferüberläufe zu vermeiden.</p></div><div class=paragraph><p>Wenn nur unverständliche Zeichen erscheinen, stellen Sie sicher, dass die Einstellungen für die Geschwindigkeit (bps) und Parität auf dem FreeBSD-System und dem Terminal gleich sind. Kontrollieren Sie den <code>getty</code> Prozess und stellen Sie sicher, dass der richtige Verbindungstyp aus <span class=filename>/etc/gettytab</span> benutzt wird. Wenn das nicht der Fall ist, editieren Sie <span class=filename>/etc/ttys</span> und setzen das Kommando <code>kill-HUP 1</code> ab.</p></div><div class=paragraph><p>Wenn Zeichen doppelt und eingegebene Passwörter im Klartext erscheinen, stellen Sie den Terminal oder die Terminalemulation von "half duplex" oder "local echo" auf "full duplex" um.</p></div></div></div></div><div class=sect1><h2 id=dialup>Kapitel 47. Einwählverbindungen<a class=anchor href=#dialup></a></h2><div class=sectionbody><div class=paragraph><p>Das Einrichten von Einwählverbindungen auf FreeBSD-Systemen ähnelt dem Anschließen von Terminals, nur dass anstelle eines Terminals ein Modem verwendet wird. FreeBSD unterstützt sowohl externe als auch interne Modems.</p></div><div class=paragraph><p>Externe Modems sind für Einwählverbindungen besser geeignet, da sie die Konfiguration in nicht flüchtigem RAM speichern können. Zudem verfügen Sie über Leuchtanzeigen, die den Status wichtiger RS-232 Signale anzeigen.</p></div><div class=paragraph><p>Interne Modems verfügen normalerweise nicht über nicht flüchtiges RAM und lassen sich meist nur über DIP-Schalter konfigurieren. Selbst wenn ein internes Modem Leuchtanzeigen besitzt, sind diese meist schwer einzusehen, wenn das Modem eingebaut ist.</p></div><div class=paragraph><p>Mit einem externen Modem muss das passende Kabel verwendet werden. Ein Standard RS-232C Kabel, bei dem die folgenden Signale miteinander verbunden sind, sollte ausreichen:</p></div><table id=serialcomms-signal-names class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 22. Signalnamen</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Abkürzung</th><th class="tableblock halign-left valign-top">Bedeutung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Received Data</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Transmitted Data</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Terminal Ready</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Set Ready</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Carrier Detect (dadurch erkennt RS-232 das Signal <em>Received Line</em>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Signal Ground</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Request to Send</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clear to Send</p></td></tr></tbody></table><div class=paragraph><p>Ab Geschwindigkeiten von 2400 bps benötigt FreeBSD die Signale RTS und CTS für die Flusssteuerung. Das Signal CD zeigt an, ob ein Träger vorliegt, das heißt ob die Verbindung aufgebaut ist oder beendet wurde. DTR zeigt an, dass das Gerät betriebsbereit ist. Es gibt einige Kabel, bei denen nicht alle nötigen Signale verbunden sind. Wenn Probleme dieser Art auftreten, dass zum Beispiel die Sitzung nicht beendet wird, obwohl die Verbindung beendet wurde, kann das an einem solchen Kabel liegen.</p></div><div class=paragraph><p>Wie andere UNIX® Betriebssysteme auch, benutzt FreeBSD Hardwaresignale, um festzustellen, ob ein Anruf beantwortet wurde, eine Verbindung beendet wurde, oder um die Verbindung zu schließen und das Modem zurückzusetzen. FreeBSD vermeidet es, dem Modem Kommandos zu senden, oder den Statusreport des Modems abzufragen.</p></div><div class=sect2><h3 id=_schnittstellenbausteine>47.1. Schnittstellenbausteine<a class=anchor href=#_schnittstellenbausteine></a></h3><div class=paragraph><p>FreeBSD unterstützt EIA RS-232C (CCITT V.24) serielle Schnittstellen, die auf den NS8250, NS16450, NS16550 oder NS16550A Bausteinen basieren. Die Bausteine der Serie 16550 verfügen über einen 16 Byte großen Puffer, der als FIFO angelegt ist. Wegen Fehler in der FIFO-Logik kann der Puffer in einem 16550 Baustein allerdings nicht genutzt werden, das heißt der Baustein muss als 16450 betrieben werden. Bei allen Bausteinen ohne Puffer und dem 16550 Baustein muss jedes Byte einzeln von dem Betriebssystem verarbeitet werden, was Fehler bei hohen Geschwindigkeiten oder großer Systemlast erzeugt. Es sollten daher nach Möglichkeit serielle Schnittstellen, die auf 16550A Bausteinen basieren, eingesetzt werden.</p></div></div><div class=sect2><h3 id=_überblick>47.2. Überblick<a class=anchor href=#_überblick></a></h3><div class=paragraph><p>Wie bei Terminals auch, startet <code>init</code> für jede serielle Schnittstelle, die eine Einwählverbindung zur Verfügung stellt, einen <code>getty</code> Prozess. Wenn das Modem beispielsweise an <span class=filename>/dev/ttyu0</span> angeschlossen ist, sollte in der Ausgabe von <code>ps ax</code> eine Zeile wie die folgende erscheinen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyu0</code></pre></div></div><div class=paragraph><p>Wenn sich ein Benutzer einwählt und die Verbindung aufgebaut ist, zeigt das Modem dies durch das CD Signal (Carrier Detect) an. Der Kernel merkt, dass ein Signal anliegt und weist <code>getty</code> an, die Schnittstelle zu öffnen. Dann sendet <code>getty</code> das Anmeldeprompt mit der ersten für die Verbindung vereinbarten Geschwindigkeit und wartet auf eine Antwort. Wenn die Antwort unverständlich ist, weil zum Beispiel die Geschwindigkeit des Modems von <code>getty</code>s Geschwindigkeit abweicht, versucht <code>getty</code> die Geschwindigkeit solange anzupassen, bis es eine verständliche Antwort erhält.</p></div><div class=paragraph><p>Nachdem der Benutzer seinen Benutzernamen eingegeben hat, führt <code>getty</code><span class=filename>/usr/bin/login</span> aus, welches das Passwort abfragt und danach die Shell des Benutzers startet.</p></div></div><div class=sect2><h3 id=_konfigurationsdateien_2>47.3. Konfigurationsdateien<a class=anchor href=#_konfigurationsdateien_2></a></h3><div class=paragraph><p>Drei Konfigurationsdateien in <span class=filename>/etc</span> steuern, ob eine Einwahl in das FreeBSD-System möglich ist. <span class=filename>/etc/gettytab</span>, konfiguriert den <span class=filename>/usr/libexec/getty</span> Dæmon. In <span class=filename>/etc/ttys</span> wird festgelegt, auf welchen Schnittstellen <span class=filename>/sbin/init</span> einen <code>getty</code> Prozess startet. Schließlich bietet <span class=filename>/etc/rc.d/serial</span> die Möglichkeit, Schnittstellen zu initialisieren.</p></div><div class=paragraph><p>Es gibt zwei Ansichten darüber, wie Modems für Einwählverbindungen unter UNIX® zu konfigurieren sind. Zum einen kann die Geschwindigkeit zwischen dem Modem und dem Computer fest eingestellt werden. Sie ist damit unabhängig von der Geschwindigkeit, mit der sich der entfernte Benutzer einwählt. Dies hat den Vorteil, dass der entfernte Benutzer das Anmeldeprompt sofort bekommt. Der Nachteil bei diesem Verfahren ist, dass das System die tatsächliche Geschwindigkeit der Verbindung nicht kennt. Damit können bildschirmorientierte Programme wie Emacs ihren Bildschirmaufbau nicht an langsame Verbindungen anpassen, um die Antwortzeiten zu verbessern.</p></div><div class=paragraph><p>Die andere Möglichkeit besteht darin, die Geschwindigkeit der RS-232 Schnittstelle des lokalen Modems an die Geschwindigkeit des entfernten Modems anzupassen. Bei einer V.32bis (14400 bps) Verbindung kann das lokale Modem die RS-232 Schnittstelle mit 19200 bps betreiben, während bei einer Verbindung mit 2400 bps die RS-232 Schnittstelle mit 2400 bps betrieben wird. Da <code>getty</code> die Verbindungsgeschwindigkeit des Modems nicht kennt, startet es den Anmeldevorgang mit der Ausgabe von <code>login:</code> und wartet auf eine Antwort. Wenn der Benutzer der Gegenstelle nun nur unverständliche Zeichen erhält, muss er solange <kbd>Enter</kbd> drücken, bis das Anmeldeprompt erscheint. Solange die Geschwindigkeiten nicht übereinstimmen, sind die Antworten der Gegenstelle für <code>getty</code> ebenfalls unverständlich. In diesem Fall wechselt <code>getty</code> zur nächsten Geschwindigkeit und gibt wieder <code>login:</code> aus. In aller Regel erhält der Benutzer der Gegenstelle nach ein bis zwei Tastendrücken eine erkennbare Anmeldeaufforderung. Diese Anmeldeprozedur sieht nicht so sauber wie die Methode mit einer festen Geschwindigkeit aus, bietet dem Benutzer einer langsamen Verbindung allerdings den Vorteil, dass sich bildschirmorientierte Programme an die Geschwindigkeit anpassen können.</p></div><div class=paragraph><p>Im Folgenden wird die Konfiguration für beide Methoden besprochen, doch die Methode der angepassten Geschwindigkeit wird bei der Diskussion bevorzugt.</p></div><div class=sect3><h4 id=_etcgettytab>47.3.1. <span class=filename>/etc/gettytab</span><a class=anchor href=#_etcgettytab></a></h4><div class=paragraph><p>Mit <span class=filename>/etc/gettytab</span> wird <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> im Stil von <a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a> konfiguriert. Das Format dieser Datei und die Bedeutung der Einträge wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> beschrieben.</p></div><div class=paragraph><p>Wenn die Modemgeschwindigkeit vorgeben wird, sollten Anpassungen in <span class=filename>/etc/gettytab</span> nicht erforderlich sein.</p></div><div class=paragraph><p>Wenn jedoch die Geschwindigkeit angepasst werden soll, erstellen Sie einen Eintrag in <span class=filename>/etc/gettytab</span>, um <code>getty</code> die Geschwindigkeit für das Modem mitzuteilen. Für ein 2400 bps Modem kann der vorhandene <code>D2400</code> Eintrag benutzt werden.</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</pre></div></div><div class=paragraph><p>Wird ein Modem mit einer höheren Geschwindigkeit eingesetzt, müssen weitere Einträge in <span class=filename>/etc/gettytab</span> erstellt werden. Dieses Beispiel zeigt einen Eintrag für ein 14400 bps Modem mit einer Geschwindigkeit bis zu 19200 bps:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</pre></div></div><div class=paragraph><p>Die damit erzeugten Verbindungen verwenden 8 Bit und keine Parität.</p></div><div class=paragraph><p>Im obigen Beispiel startet die Geschwindigkeit bei 19200 bps (eine V.32bis Verbindung) und geht dann über 9600 bps (V.32), 400 bps, 1200 bps und 300 bps wieder zurück zu 19200 bps. Das Schlüsselwort <code>nx=</code> (next table) sorgt für das zyklische Durchlaufen der Geschwindigkeiten. Jede Zeile zieht zudem noch mit <code>tc=</code> (table continuation) die Vorgabewerte für die jeweilige Geschwindigkeit an.</p></div><div class=paragraph><p>Wenn Sie ein 28800 bps Modem besitzen und/oder Kompression mit einem 14400 bps Modem benutzen wollen, brauchen Sie höhere Geschwindigkeiten als 19200 bps. Das folgende Beispiel startet mit 57600 bps:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57600 bps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</pre></div></div><div class=paragraph><p>Wenn Sie eine langsame CPU oder ein stark ausgelastetes System besitzen und sich kein 16550A im System befindet, erhalten Sie bei 57600 bps vielleicht <code>sio</code> Fehlermeldungen der Form "silo overflow".</p></div></div><div class=sect3><h4 id=dialup-ttys>47.3.2. <span class=filename>/etc/ttys</span><a class=anchor href=#dialup-ttys></a></h4><div class=paragraph><p><span class=filename>/etc/ttys</span> wurde bereits in <a href=#ex-etc-ttys>Einträge in <span class=filename>/etc/ttys</span> hinzufügen</a> besprochen. Die Konfiguration für Modems ist ähnlich, allerdings braucht <code>getty</code> ein anderes Argument und es muss ein anderer Terminaltyp angegeben werden. Der Eintrag für beide Methoden (feste und angepasste Geschwindigkeit) hat die folgende Form:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty xxx&#34;   dialup on</pre></div></div><div class=paragraph><p>Das erste Feld der obigen Zeile gibt die Gerätedatei für diesen Eintrag an. <span class=filename>ttyu0</span> bedeutet, dass <code>getty</code> mit <span class=filename>/dev/ttyu0</span> arbeitet. Das zweite Feld <code>"/usr/libexec/getty xxx"</code> gibt das Kommando an, das <code>init</code> für dieses Gerät startet (<em>xxx</em> wird durch einen passenden Eintrag aus <span class=filename>/etc/gettytab</span> ersetzt). Die Vorgabe für den Terminaltyp, hier <code>dialup</code>, wird im dritten Feld angegeben. Das vierte Feld, <code>on</code>, zeigt <code>init</code> an, dass die Schnittstelle aktiviert ist. Im fünften Feld könnte noch <code>secure</code> angegeben werden, um Anmeldungen von <code>root</code> zu erlauben, doch sollte das wirklich nur für physikalisch sichere Terminals, wie die Systemkonsole, aktiviert werden.</p></div><div class=paragraph><p>Die Vorgabe für den Terminaltyp, <code>dialup</code> im obigen Beispiel, hängt von lokalen Gegebenheiten ab. Traditionell wird <code>dialup</code> für Einwählverbindungen verwendet, so dass die Benutzer in ihren Anmeldeskripten den Terminaltyp auf ihren Terminal abstimmen können, wenn der Typ auf <code>dialup</code> gesetzt ist. Wenn Sie nur VT102 Terminals oder Emulatoren einsetzen, können Sie den Terminaltyp hier auch fest auf <code>vt102</code> setzen.</p></div><div class=paragraph><p>Nachdem <span class=filename>/etc/ttys</span> geändert wurde, muss <code>init</code> ein HUP Signal schicken, damit es die Datei wieder einliest:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>Stellen Sie sicher, dass das Modem richtig konfiguriert und angeschlossen ist, bevor Sie das Signal an <code>init</code> schicken.</p></div><div class=paragraph><p>Das Argument von <code>getty</code> muss in diesem Fall eine feste Geschwindigkeit vorgeben. Der Eintrag für ein Modem, das fest auf 19200 bps eingestellt ist, könnte wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty std.19200&#34;   dialup on</pre></div></div><div class=paragraph><p>Wenn das Modem auf eine andere Geschwindigkeit eingestellt ist, setzen Sie anstelle von <code>std.19200</code> einen passenden Eintrag der Form <code>std.<em>speed</em></code> ein. Stellen Sie sicher, dass dies auch ein gültiger Verbindungstyp aus <span class=filename>/etc/gettytab</span> ist.</p></div><div class=paragraph><p>Das Argument von <code>getty</code> muss hier auf einen der Einträge aus <span class=filename>/etc/gettytab</span> zeigen, der zu einer Kette von Einträgen gehört, die die zu probierenden Geschwindigkeiten beschreiben. Wenn Sie dem obigen Beispiel gefolgt sind und zusätzliche Einträge in <span class=filename>/etc/gettytab</span> erzeugt haben, können Sie die folgende Zeile verwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty V19200&#34;   dialup on</pre></div></div></div><div class=sect3><h4 id=_etcrc_dserial>47.3.3. <span class=filename>/etc/rc.d/serial</span><a class=anchor href=#_etcrc_dserial></a></h4><div class=paragraph><p>Modems, die höhere Geschwindigkeiten unterstützen, zum Beispiel V.32, V.32bis und V.34 Modems, benutzen Hardware-Flusssteuerung (<code>RTS/CTS</code>). Für die entsprechenden Schnittstellen können Sie die Flusssteuerung mit <code>stty</code> in <span class=filename>/etc/rc.d/serial</span> einstellen.</p></div><div class=paragraph><p>Um beispielsweise die Hardware-Flusssteuerung für die Geräte zur Ein- und Auswahl der zweiten seriellen Schnittstelle (<span class=filename>COM2</span>) zu aktivieren, benutzen Sie die Dateien zur Initialisierung der entsprechenden Geräte und fügen die folgenden Zeilen in <span class=filename>/etc/rc.d/serial</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre># Serial port initial configuration
stty -f /dev/ttyu1.init crtscts
stty -f /dev/cuad1.init crtscts</pre></div></div></div></div><div class=sect2><h3 id=_modemkonfiguration>47.4. Modemkonfiguration<a class=anchor href=#_modemkonfiguration></a></h3><div class=paragraph><p>Für ein Modem, das seine Konfiguration in nicht flüchtigem RAM speichert, wird ein Terminalprogramm wie Telix unter MS-DOS® oder <code>tip</code> unter FreeBSD benötigt, um die Parameter einzustellen. Verbinden Sie sich mit derselben Geschwindigkeit, die <code>getty</code> zuerst benutzen würde, mit dem Modem und treffen Sie folgende Einstellungen:</p></div><div class=ulist><ul><li><p>DCD ist eingeschaltet, wenn das Trägersignal des entfernten Modems erkannt wird.</p></li><li><p>Im Betrieb liegt DTR an. Bei einem Verlust von DTR legt das Modem auf und setzt sich zurück.</p></li><li><p>CTS Flusssteuerung ist für ausgehende Daten aktiviert.</p></li><li><p>XON/XOFF Flusssteuerung ist ausgeschaltet.</p></li><li><p>RTS Flusssteuerung ist für eingehende Daten aktiviert.</p></li><li><p>Keine Rückmeldungen ausgeben.</p></li><li><p>Die Echo-Funktion ist deaktiviert.</p></li></ul></div><div class=paragraph><p>Lesen Sie die Dokumentation für das Modem, um herauszufinden welche Befehle und/oder DIP-Schalterstellungen benötigt werden.</p></div><div class=paragraph><p>Für ein externes 14400 gelten zum Beispiel die folgenden Befehle:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
ATC1D2H1I0R2W</pre></div></div><div class=paragraph><p>Bei dieser Gelegenheit können Sie auch gleich andere Einstellungen, zum Beispiel ob Sie V42.bis und/oder MNP5 Kompression benutzen wollen, an Ihrem Modem vornehmen.</p></div><div class=paragraph><p>Bei einem externen 14400 müssen Sie auch noch einige DIP-Schalter einstellen. Die folgenden Einstellungen können verwendet werden:</p></div><div class=ulist><ul><li><p>Schalter 1: OBEN - DTR normal</p></li><li><p>Schalter 2: N/A (Rückmeldungen als Text/numerische Rückmeldungen)</p></li><li><p>Schalter 3: OBEN - Keine Rückmeldungen ausgeben</p></li><li><p>Schalter 4: UNTEN - Echo-Funktion aus</p></li><li><p>Schalter 5: OBEN - Rufannahme aktiviert</p></li><li><p>Schalter 6: OBEN - Carrier Detect normal</p></li><li><p>Schalter 7: OBEN - Einstellungen aus dem NVRAM laden</p></li><li><p>Schalter 8: N/A (Smart Mode/Dumb Mode)</p></li></ul></div><div class=paragraph><p>Für Einwählverbindungen sollten die Rückmeldungen deaktiviert sein, da sonst <code>getty</code> dem Modem das Anmeldeprompt <code>login:</code> schickt und das Modem im Kommandomodus das Prompt wieder ausgibt (Echo-Funktion) oder eine Rückmeldung gibt. Das führt dann zu einer länglichen und fruchtlosen Kommunikation zwischen dem Modem und <code>getty</code>.</p></div><div class=paragraph><p>Die Geschwindigkeit zwischen Modem und Computer muss auf einen festen Wert eingestellt werden. Mit einem externen 14400 Modem setzen die folgenden Kommandos die Geschwindigkeit auf den Wert der Datenendeinrichtung fest:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
ATB1W</pre></div></div><div class=paragraph><p>In diesem Fall muss die Geschwindigkeit der seriellen Schnittstelle des Modems der eingehenden Geschwindigkeit angepasst werden. Für ein externes 14400 Modem erlauben die folgenden Befehle eine Anpassung der Geschwindigkeit der seriellen Schnittstelle für Verbindungen, die keine Fehlerkorrektur verwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
ATB2W</pre></div></div><div class=paragraph><p>Verbindungen mit Fehlerkorrektur (V.42, MNP) verwenden die Geschwindigkeit der Datenendeinrichtung.</p></div><div class=sect3><h4 id=_überprüfen_der_modemkonfiguration>47.4.1. Überprüfen der Modemkonfiguration<a class=anchor href=#_überprüfen_der_modemkonfiguration></a></h4><div class=paragraph><p>Die meisten Modems verfügen über Kommandos, die die Konfiguration des Modems in lesbarer Form ausgeben. Auf einem externen 14400 zeigt <code>ATI5</code> die Einstellungen im nicht flüchtigen RAM an. Um die wirklichen Einstellungen unter Berücksichtigung der DIP-Schalter zu sehen, benutzen Sie <code>ATZ</code> gefolgt von <code>ATI4</code>.</p></div><div class=paragraph><p>Wenn Sie ein anderes Modem benutzen, schauen Sie bitte in der Dokumentation des Modems nach, wie Sie die Konfiguration des Modems überprüfen können.</p></div></div></div><div class=sect2><h3 id=_fehlersuche_3>47.5. Fehlersuche<a class=anchor href=#_fehlersuche_3></a></h3><div class=paragraph><p>Bei Problemen können Sie die Einwählverbindung anhand der folgenden Punkte überprüfen:</p></div><div class=paragraph><p>Schließen Sie das Modem an das FreeBSD-System an und booten Sie das System. Wenn das Modem über Statusindikatoren verfügt, überprüfen Sie, ob der DTR Indikator leuchtet, wenn das Anmeldeprompt erscheint. Dies zeigt an, dass das FreeBSD-System einen <code>getty</code> Prozess auf der entsprechenden Schnittstelle gestartet hat und das Modem auf einkommende Verbindungen wartet.</p></div><div class=paragraph><p>Wenn der DTR-Indikator nicht leuchtet, melden Sie sich an dem FreeBSD-System an und überprüfen mit <code>ps ax</code>, ob FreeBSD einen <code>getty</code>-Prozess auf der entsprechenden Schnittstelle gestartet hat:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu1</code></pre></div></div><div class=paragraph><p>Wenn das Modem noch keinen Anruf entgegengenommen hat und Sie stattdessen die folgende Zeile sehen</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyu0</code></pre></div></div><div class=paragraph><p>bedeutet dies, dass <code>getty</code> die Schnittstelle schon geöffnet hat und zeigt Kabelprobleme oder eine falsche Modemkonfiguration an, da <code>getty</code> die Schnittstelle erst dann öffnen kann, wenn das CD Signal (Carrier Detect) vom Modem anliegt.</p></div><div class=paragraph><p>Wenn Sie keine <code>getty</code>-Prozesse auf den gewünschten <span class=filename>ttyuN</span> Ports finden, untersuchen Sie <span class=filename>/etc/ttys</span> auf Fehler. Suchen Sie auch in <span class=filename>/var/log/messages</span> nach Meldungen von <code>init</code> oder <code>getty</code>. Wenn Sie dort Meldungen finden, sollten Sie noch einmal die beiden Konfigurationsdateien <span class=filename>/etc/ttys</span> und <span class=filename>/etc/gettytab</span> nach Fehlern durchsehen. Überprüfen Sie auch, ob die Gerätedateien <span class=filename>/dev/ttyuN</span> vorhanden sind.</p></div><div class=paragraph><p>Versuchen Sie als nächstes, sich in das System einzuwählen. Auf dem entfernten System stellen Sie bitte die folgenden Kommunikationsparameter ein: 8 Bit, keine Parität, ein Stop-Bit. Wenn kein Anmeldeprompt erscheint oder nur unleserliche Zeichen, drücken Sie mehrmals, in Abständen von ungefähr einer Sekunde, <kbd>Enter</kbd>. Wenn Sie immer noch nicht die <code>login:</code> Meldung sehen, schicken Sie ein <code>BREAK</code> Kommando. Wenn Sie zur Einwahl ein Highspeed-Modem benutzen, verwenden Sie eine feste Geschwindigkeit auf der seriellen Schnittstelle des Modems.</p></div><div class=paragraph><p>Wenn jetzt immer noch kein Anmeldeprompt erscheint, überprüfen Sie nochmals <span class=filename>/etc/gettytab</span> und stellen sicher, dass:</p></div><div class=ulist><ul><li><p>der Verbindungstyp in <span class=filename>/etc/ttys</span> zu einem gültigen Eintrag in <span class=filename>/etc/gettytab</span> gehört.</p></li><li><p>jeder der <code>nx=</code> Einträge in <span class=filename>gettytab</span> gültig ist und</p></li><li><p>jeder <code>tc=</code> Eintrag auf einen gültigen Eintrag in <span class=filename>gettytab</span> verweist.</p></li></ul></div><div class=paragraph><p>Wenn das Modem am FreeBSD-System auf einen eingehenden Anruf nicht antwortet, stellen Sie sicher, dass das Modem so konfiguriert ist, dass es einen Anruf beantwortet, wenn DTR anliegt. Wenn das Modem Statusindikatoren besitzt, können Sie das Anliegen von DTR anhand der Leuchten überprüfen.</p></div><div class=paragraph><p>Wenn Sie alles schon mehrfach überprüft haben und es immer noch noch nicht funktioniert, versuchen Sie es zu einem späteren Zeitpunkt erneut. Wenn es immer noch nicht funktioniert, können Sie eine Mail an die Mailingliste schicken, in der Sie Ihr Modem und Ihr Problem beschreiben.</p></div></div></div></div><div class=sect1><h2 id=dialout>Kapitel 48. Verbindungen nach Außen<a class=anchor href=#dialout></a></h2><div class=sectionbody><div class=paragraph><p>Die folgenden Ratschläge beschreiben, wie Sie mit einem Modem eine Verbindung zu einem anderen Computer herstellen. Dies können Sie nutzen, um sich auf einem entfernten Computer anzumelden.</p></div><div class=paragraph><p>Weiterhin ist diese Art von Verbindungen nützlich, wenn PPP mal nicht funktioniert. Wenn Sie zum Beispiel eine Datei mit FTP übertragen wollen und das über PPP gerade nicht möglich ist, melden Sie sich auf dem entfernten Rechner an und führen dort die FTP-Sitzung durch. Die Dateien können danach mit zmodem auf den lokalen Rechner übertragen werden.</p></div><div class=sect2><h3 id=hayes-unsupported>48.1. Ein Hayes Modem benutzen<a class=anchor href=#hayes-unsupported></a></h3><div class=paragraph><p>Es gibt einen eingebauten, allgemeinen Hayes Wähler in <code>tip</code>. Verwenden Sie <code>at=hayes</code> in <span class=filename>/etc/remote</span>.</p></div><div class=paragraph><p>Der Hayes-Treiber ist nicht schlau genug, um ein paar der erweiterten Funktionen von neueren Modems, bspw. <code>BUSY</code>, <code>NO DIALTONE</code> oder <code>CONNECT 115200</code> zu nutzen. Schalten Sie diese Nachrichten mit Hilfe von <code>ATX0W</code> ab, wenn Sie <code>tip</code> benutzen.</p></div><div class=paragraph><p>Der Anwahl-Timeout von <code>tip</code> beträgt 60 Sekunden. Das Modem sollte weniger verwenden, oder <code>tip</code> denkt, dass ein Kommunikationsfehler vorliegt. Versuchen Sie es mit <code>ATS7=45W</code>.</p></div></div><div class=sect2><h3 id=direct-at>48.2. <code>AT</code>-Befehle benutzen<a class=anchor href=#direct-at></a></h3><div class=paragraph><p>Erstellen Sie einen <code>direct</code> Eintrag in <span class=filename>/etc/remote</span>. Wenn das Modem zum Beispiel an der ersten seriellen Schnittstelle, <span class=filename>/dev/cuad0</span>, angeschlossen ist, dann fügen Sie die folgende Zeile hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>cuad0:dv=/dev/cuad0:br#19200:pa=none</pre></div></div><div class=paragraph><p>Verwenden Sie die höchste bps-Rate, die das Modem in der <code>br</code> Fähigkeit unterstützt. Geben Sie dann <code>tip cuad0</code> ein und Sie sind mit dem Modem verbunden.</p></div><div class=paragraph><p>Oder benutzen Sie <code>cu</code> als <code>root</code> mit dem folgenden Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -lline -sspeed</span></code></pre></div></div><div class=paragraph><p><em>line</em> steht für die serielle Schnittstelle (<span class=filename>/dev/cuad0</span>) und <em>speed</em> für die Geschwindigkeit (<code>57600</code>). Wenn Sie mit dem Eingeben der AT Befehle fertig sind, beenden Sie mit <code>~.</code>.</p></div></div><div class=sect2><h3 id=gt-failure>48.3. Das <code>@</code> Zeichen funktioniert nicht<a class=anchor href=#gt-failure></a></h3><div class=paragraph><p>Das <code>@</code> Zeichen in der Telefonnummerfähigkeit sagt <code>tip</code>, dass es in <span class=filename>/etc/phones</span> nach einer Nummer suchen soll. Aber <code>@</code> ist auch ein spezielles Zeichen in den Dateien, in denen Fähigkeiten beschrieben werden, wie <span class=filename>/etc/remote</span>. Schreiben Sie es mit einem Backslash:</p></div><div class="literalblock programlisting"><div class=content><pre>pn=\@</pre></div></div></div><div class=sect2><h3 id=dial-command-line>48.4. Wie kann ich von der Kommandozeile eine Telefonnummer wählen?<a class=anchor href=#dial-command-line></a></h3><div class=paragraph><p>Setzen Sie einen allgemeinen Eintrag in <span class=filename>/etc/remote</span>. Zum Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuad0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuad0:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>Folgendes sollte jetzt funktionieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tip -115200 5551234</span></code></pre></div></div><div class=paragraph><p>Benutzer, die <code>cu</code> gegenüber <code>tip</code> bevorzugen, können einen allgemeinen <code>cu</code>-Eintrag verwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuad1:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>und benutzen zum Wählen das Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu 5551234 -s 115200</span></code></pre></div></div></div><div class=sect2><h3 id=set-bps>48.5. Die bps-Rate angeben<a class=anchor href=#set-bps></a></h3><div class=paragraph><p>Schreiben Sie einen <code>tip1200</code>- oder einen <code>cu1200</code>-Eintrag, aber geben Sie auch die bps-Rate an, die das Modem wirklich unterstützt. Leider denkt <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a>, dass 1200 bps ein guter Standardwert ist und deswegen sucht es nach einem <code>tip1200</code>-Eintrag. Natürlich müssen Sie nicht 1200 bps benutzen.</p></div></div><div class=sect2><h3 id=terminal-server>48.6. Über einen Terminal-Server auf verschiedene Rechner zugreifen<a class=anchor href=#terminal-server></a></h3><div class=paragraph><p>Sie müssen nicht warten bis Sie verbunden sind, und jedes Mal <code>CONNECT <em>Rechner</em></code> eingeben, benutzen Sie <code>tip</code>s <code>cm</code>-Fähigkeit. Sie können diese Einträge in <span class=filename>/etc/remote</span> verwenden. Mit den Befehlen <code>tip pain</code> oder <code>tip muffin</code> können Sie eine Verbindungen zu den Rechnern <code>pain</code> oder <code>muffin</code> herstellen; mit <code>tip deep13</code> verbinden Sie sich mit dem Terminalserver.</p></div><div class="literalblock programlisting"><div class=content><pre>pain|pain.deep13.com|Forrester&#39;s machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank&#39;s machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuad2:br#38400:at=hayes:du:pa=none:pn=5551234:</pre></div></div></div><div class=sect2><h3 id=tip-multiline>48.7. Mehr als eine Verbindung mit <code>tip</code> benutzen<a class=anchor href=#tip-multiline></a></h3><div class=paragraph><p>Das ist oft ein Problem, wenn eine Universität mehrere Telefonleitungen hat und viele tausend Studenten diese benutzen wollen.</p></div><div class=paragraph><p>Erstellen Sie einen Eintrag in <span class=filename>/etc/remote</span> und benutzen Sie <code>@</code> für die <code>pn</code>-Fähigkeit:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuad3:br#9600:at=courier:du:pa=none:</pre></div></div><div class=paragraph><p>Listen Sie dann die Telefonnummern in <span class=filename>/etc/phones</span> auf:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</pre></div></div><div class=paragraph><p><code>tip</code> probiert jede der Nummern in der aufgelisteten Reihenfolge und gibt dann auf. Möchten Sie, dass <code>tip</code> beim Versuchen eine Verbindung herzustellen nicht aufgibt, lassen Sie es in einer <code>while</code>-Schleife laufen.</p></div></div><div class=sect2><h3 id=multi-controlp>48.8. Eine Übertragung erzwingen<a class=anchor href=#multi-controlp></a></h3><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> ist das voreingestellte Zeichen, mit dem eine Übertragung erzwungen werden kann und wird benutzt, um <code>tip</code> zu sagen, dass das nächste Zeichen direkt gesendet werden soll und nicht als Fluchtzeichen interpretiert werden soll. Mit Hilfe der Fluchtsequenz <code>~s</code>, mit der man Variablen setzen kann, können Sie jedes andere Zeichen als "force"-Zeichen definieren.</p></div><div class=paragraph><p>Geben Sie <code>~sforce=<em>Zeichen</em></code> gefolgt von <kbd>Enter</kbd> ein. Für <em>Zeichen</em> können Sie ein beliebiges einzelnes Zeichen einsetzen. Wenn Sie <em>Zeichen</em> weglassen, ist das "force"-Zeichen "nul", das Sie mit <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> oder <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Leertaste</kbd></span> eingeben können. Ein guter Wert für <em>Zeichen</em> ist <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span>, welches nur auf wenigen Terminal Servern benutzt wird.</p></div><div class=paragraph><p>Sie können das "force"-Zeichen auch bestimmen, indem Sie in <span class=filename>$HOME/.tiprc</span> das Folgende einstellen:</p></div><div class="literalblock programlisting"><div class=content><pre>force=single-char</pre></div></div></div><div class=sect2><h3 id=uppercase>48.9. Großbuchstaben<a class=anchor href=#uppercase></a></h3><div class=paragraph><p>Dies passiert, wenn <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span> eingegeben wurde, das "raise"-Zeichen von <code>tip</code>, das speziell für Leute mit defekten caps-lock Tasten eingerichtet wurde. Benutzen Sie <code>~s</code> wie oben und setzen Sie die Variable <code>raisechar</code> auf etwas, das Ihnen angemessen erscheint. Tatsächlich kann die Variable auf das gleiche Zeichen wie das "force"-Zeichen gesetzt werden, wenn diese Fähigkeiten niemals benutzt werden sollen.</p></div><div class=paragraph><p>Hier ist ein Muster der <span class=filename>.tiprc</span> Datei für Emacs Benutzer, die <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> und <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span> tippen müssen:</p></div><div class="literalblock programlisting"><div class=content><pre>force=^^
raisechar=^^</pre></div></div><div class=paragraph><p>Geben Sie für <code>^^</code> <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span> ein.</p></div></div><div class=sect2><h3 id=tip-filetransfer>48.10. Dateien mit <code>tip</code> übertragen<a class=anchor href=#tip-filetransfer></a></h3><div class=paragraph><p>Wenn Sie mit einem anderen UNIX® System kommunizieren, können Sie mit <code>~p</code> (put) und <code>~t</code> (take) Dateien senden und empfangen. Diese Befehle lassen <code>cat</code> und <code>echo</code> auf dem entfernten System laufen, um Dateien zu empfangen und zu senden. Die Syntax ist:</p></div><div class=paragraph><p><code>~p</code> local-file [ remote-file ]</p></div><div class=paragraph><p><code>~t</code> remote-file [ local-file ]</p></div><div class=paragraph><p>Es gibt keine Fehlerkontrolle, deshalb sollte besser ein anderes Protokoll, wie zmodem, benutzt werden.</p></div></div><div class=sect2><h3 id=zmodem-tip>48.11. zmodem mit <code>tip</code> benutzen<a class=anchor href=#zmodem-tip></a></h3><div class=paragraph><p>Um Dateien zu empfangen, starten Sie das Programm zum Senden auf dem entfernten Computer. Geben Sie dann <code>~C rz</code> ein, um die Dateien lokal zu empfangen.</p></div><div class=paragraph><p>Um Dateien zu senden, starten Sie das Programm zum Empfangen auf dem entfernten Computer. Geben Sie dann <code>~C sz <em>Dateien</em></code> ein, um Dateien auf das entfernte System zu senden.</p></div></div></div></div><div class=sect1><h2 id=serialconsole-setup>Kapitel 49. Einrichten der seriellen Konsole<a class=anchor href=#serialconsole-setup></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD kann ein System mit einem Dumb-Terminal (unintelligente Datenstation) an einer seriellen Schnittstelle als Konsole booten. Diese Konfiguration ist besonders nützlich für Systemadministratoren, die FreeBSD auf Systemen ohne Tastatur oder Monitor installieren wollen, und Entwickler, die den Kernel oder Gerätetreiber debuggen.</p></div><div class=paragraph><p>Wie in <a href=./#boot>FreeBSDs Bootvorgang</a> beschrieben, besitzt FreeBSD drei Bootphasen. Der Code für die ersten beiden Bootphasen befindet sich im Bootsektor am Anfang der FreeBSD-Slice der Bootplatte. Dieser Bootblock lädt den Bootloader in Phase drei.</p></div><div class=paragraph><p>Um eine serielle Konsole einzurichten, muss der Bootblock, der Bootloader und der Kernel konfiguriert werden.</p></div><div class=sect2><h3 id=serialconsole-howto-fast>49.1. Schnelle Konfiguration der seriellen Konsole<a class=anchor href=#serialconsole-howto-fast></a></h3><div class=paragraph><p>Dieser Abschnitt bietet einen schnellen Überblick über die Einrichtung einer seriellen Konsolen. Es wird vorausgesetzt, dass die Voreinstellungen verwendet werden.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Verbinden Sie die serielle Konsole mit <span class=filename>COM1</span> sowie dem Kontrollterminal.</p></li><li><p>Um die Startmeldungen der seriellen Konsole zu sehen, geben Sie als <code>root</code> folgendes ein:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell></code></pre></div></div></li><li><p>Ändern Sie in <span class=filename>/etc/ttys</span> den Eintrag für <span class=filename>ttyu0</span> von <code>off</code> auf <code>on</code>. Zusätzlich sollten Sie den Wert <code>dialup</code> auf <code>vt100</code> ändern. Nur so wird auf der seriellen Konsole eine Eingabeaufforderung mit einer Passwortabfrage aktiviert.</p></li><li><p>Starten Sie nun das System neu, damit die serielle Konsole aktiviert wird.</p></li></ol></div><div class=paragraph><p>Wenn Sie eine unterschiedliche Konfiguration benötigen, lesen Sie den nächsten Abschnitt für eine tiefer gehende Erklärung.</p></div></div><div class=sect2><h3 id=serialconsole-howto>49.2. Konfiguration der seriellen Konsole<a class=anchor href=#serialconsole-howto></a></h3><div class="sidebarblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Bereiten Sie ein serielles Kabel vor.</p><div class=paragraph><p>Sie benötigen entweder ein Nullmodemkabel oder ein serielles Standard Kabel mit einem Nullmodemkabel-Adapter. In <a href=#term-cables-null>Kabel und Schnittstellen</a> werden serielle Kabel beschrieben.</p></div></li><li><p>Trennen Sie die Tastatur vom Computer.</p><div class=paragraph><p>Viele PC Systeme suchen beim Power On Self Test (POST) nach einer Tastatur und geben eine Fehlermeldung aus, wenn sie keine finden. Einige Maschinen werden sich sogar weigern, ohne Tastatur zu booten.</p></div><div class=paragraph><p>Wenn der Rechner trotz einer Fehlermeldung normal weiterbootet, brauchen Sie weiter nichts zu tun.</p></div><div class=paragraph><p>Wenn das System ohne Tastatur nicht booten will, müssen Sie das BIOS so konfigurieren, dass es diesen Fehler ignoriert (wenn das möglich ist). Das Handbuch zum Motherboard sollte beschreiben, wie das zu bewerkstelligen ist.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Selbst wenn Sie im BIOS "Not installed" für die Tastatur einstellen, können Sie eine Tastatur angeschlossen haben und diese auch weiterhin benutzen, da sie mit dieser Anweisung das BIOS lediglich anweisen, nach dem Einschalten des Rechners nicht nach einer Tastatur zu suchen und den Rechner ohne entsprechende Fehlermeldung zu starten. Wenn die oben beschriebene Option nicht im BIOS vorhanden ist, halten Sie stattdessen Ausschau nach einer "Halt on Error" Option. Sie können den gleichen Effekt wie oben erzielen, wenn Sie diese Option auf "All but Keyboard" oder sogar "No Errors" setzen.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn das System über eine PS/2® Maus verfügt, müssen Sie diese wahrscheinlich auch abziehen. Da sich die PS/2® Maus und die Tastatur einige Hardwarekomponenten teilen, kann das dazu führen, dass die Hardwareerkennung fälschlicherweise eine Tastatur findet, wenn eine PS/2® Maus angeschlossen ist.</p></div></td></tr></tbody></table></div></li><li><p>Schließen Sie einen Dumb-Terminal an <span class=filename>COM1</span> (<span class=filename>sio0</span>) an.</p><div class=paragraph><p>Wenn Sie keinen Dumb-Terminal besitzen, können Sie einen alten Computer mit einem Terminalemulator oder die serielle Schnittstelle eines anderen UNIX® Rechners benutzen. Sie benötigen auf jeden Fall eine freie erste serielle Schnittstelle (<span class=filename>COM1</span>). Zurzeit ist es nicht möglich, in den Bootblöcken eine andere Schnittstelle zu konfigurieren, ohne diese neu zu kompilieren. Wenn Sie <span class=filename>COM1</span> bereits für ein anderes Gerät benutzen, müssen Sie dieses Gerät temporär entfernen und einen neuen Bootblock sowie Kernel installieren, wenn FreeBSD erst einmal installiert ist.</p></div></li><li><p>Stellen Sie sicher, dass die Kernelkonfiguration die richtigen Optionen für <span class=filename>COM1</span> (<span class=filename>sio0</span>) enthält.</p><div class=paragraph><p>Relevante Optionen sind:</p></div><div class=dlist><dl><dt class=hdlist1><code>0x10</code></dt><dd><p>Aktiviert die Konsolenunterstützung für dieses Gerät. Zurzeit kann nur ein Gerät die Konsolenunterstützung aktiviert haben. Das erste, in der Konfigurationsdatei aufgeführte Gerät, mit dieser Option, verfügt über eine aktivierte Konsolenunterstützung. Beachten Sie, dass diese Option alleine nicht ausreicht, um die serielle Konsole zu aktivieren. Setzen Sie entweder noch die nachfolgend diskutierte Option oder verwenden Sie beim Booten, wie unten beschrieben, den Schalter <code>-h</code>.</p></dd><dt class=hdlist1><code>0x20</code></dt><dd><p>Das erste Gerät in der Kernelkonfigurationsdatei mit dieser Option wird, unabhängig von dem unten diskutierten Schalter <code>-h</code>, zur Konsole. Die Option <code>0x20</code> muss zusammen mit <code>0x10</code> verwendet werden.</p></dd><dt class=hdlist1><code>0x40</code></dt><dd><p>Reserviert dieses Gerät und sperrt es für normale Zugriffe. Sie sollten diese Option nicht auf dem Gerät setzen, das Sie als serielle Konsole verwenden wollen. Der Zweck dieser Option ist es, dieses Gerät für das Remote-Debuggen zu reservieren. Das <a href=https://docs.freebsd.org/de/books/developers-handbook/>FreeBSD Developers' Handbook</a> enthält dazu weitere Informationen.</p><div class=paragraph><p>Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>device sio0 at isa? port IO_COM1 tty flags 0x10 irq 4</pre></div></div><div class=paragraph><p>Weitere Einzelheiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>.</p></div><div class=paragraph><p>Wenn diese Optionen nicht gesetzt sind, müssen Sie auf einer anderen Konsole beim Booten UserConfig starten oder den Kernel neu kompilieren.</p></div></dd></dl></div></li><li><p>Erstellen Sie <span class=filename>boot.config</span> im Rootverzeichnis der <code>a</code>-Partition des Bootlaufwerks.</p><div class=paragraph><p>Der Code des Bootblocks entnimmt dieser Datei, wie Sie Ihr System booten möchten. Um die serielle Konsole zu aktivieren, müssen Sie hier eine oder mehrere Optionen (alle in derselben Zeile) angeben. Die folgenden Optionen stehen zur Auswahl der Konsole zur Verfügung:</p></div><div class=dlist><dl><dt class=hdlist1><code>-h</code></dt><dd><p>Schaltet zwischen der internen und der seriellen Konsole um. Wenn Sie beispielsweise von der internen Konsole (Bildschirm) booten, weist <code>-h</code> den Bootloader und den Kernel an, die serielle Schnittstelle als Konsole zu nehmen. Wenn die Konsole normal auf der seriellen Schnittstelle liegt, wählen Sie mit <code>-h</code> den Bildschirm aus.</p></dd><dt class=hdlist1><code>-D</code></dt><dd><p>Schaltet zwischen Einzelkonsole und Dual-Konsole um. Die Einzelkonsole ist entweder die interne Konsole (der Bildschirm) oder die serielle Schnittstelle, je nach dem Stand von <code>-h</code>. Im Dual-Konsolen Betrieb ist die Konsole, unabhängig von <code>-h</code>, gleichzeitig der Bildschirm und die serielle Schnittstelle. Dies trifft aber nur zu, wenn der Bootblock ausgeführt wird. Sobald der Bootloader ausgeführt wird, wird die durch <code>-h</code> gegebene Konsole die alleinige Konsole.</p></dd><dt class=hdlist1><code>-P</code></dt><dd><p>Veranlasst den Bootblock nach einer Tastatur zu suchen. Wenn keine Tastatur gefunden wird, werden <code>-D</code> und <code>-h</code> automatisch gesetzt.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wegen Platzbeschränkungen in den Bootblöcken kann <code>-P</code> nur erweiterte Tastaturen erkennen. Tastaturen mit weniger als 101 Tasten und ohne F11 und F12 Tasten werden wahrscheinlich, wie vielleicht auch die Tastaturen einiger Laptops, nicht erkannt. Wenn das der Fall ist, können Sie <code>-P</code> nicht verwenden, da es leider keine Abhilfe für dieses Problem gibt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Benutzen Sie also entweder <code>-P</code>, um die Konsole automatisch zu setzen, oder <code>-h</code>, um die serielle Konsole zu verwenden.</p></div><div class=paragraph><p>Weitere Optionen werden in <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> beschrieben.</p></div><div class=paragraph><p>Mit Ausnahme von <code>-P</code> werden die Optionen an den Bootloader weitergegeben. Der Bootloader untersucht dann einzig <code>-h</code> um festzustellen, welches Gerät die Konsole wird. Wenn Sie also nur <code>-D</code> angegeben haben, können Sie die serielle Schnittstelle nur als Konsole verwenden während der Bootblock ausgeführt wird. Danach wird der Bootloader, da ja <code>-h</code> fehlt, den Bildschirm zur Konsole machen.</p></div></dd></dl></div></li><li><p>Booten Sie die Maschine.</p><div class=paragraph><p>Wenn Sie das FreeBSD-System starten, werden die Bootblöcke den Inhalt von <span class=filename>/boot.config</span> auf der Konsole ausgeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/boot.config: <span class=nt>-P</span>
Keyboard: no</code></pre></div></div><div class=paragraph><p>Die zweite Zeile sehen Sie nur, wenn Sie in <span class=filename>/boot.config</span><code>-P</code> angegeben haben. Sie zeigt an, ob eine Tastatur angeschlossen ist oder nicht. Die Meldungen gehen je nach den Einstellungen in <span class=filename>/boot.config</span> auf die interne Konsole, die serielle Konsole, oder beide Konsolen.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Optionen</th><th class="tableblock halign-left valign-top">Meldungen erscheinen auf</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>keine</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>der internen Konsole</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>der seriellen Konsole</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>der seriellen und der internen Konsole</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>der seriellen und der internen Konsole</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, mit Tastatur</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>der internen Konsole</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, ohne Tastatur</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>der seriellen Konsole</p></td></tr></tbody></table><div class=paragraph><p>Nach den oben gezeigten Meldungen gibt es eine kleine Verzögerung bevor die Bootblöcke den Bootloader laden und weitere Meldungen auf der Konsole erscheinen. Sie können die Ausführung der Bootblöcke unterbrechen, um zu überprüfen, ob auch alles richtig aufgesetzt ist, brauchen das aber unter normalen Umständen nicht zu tun.</p></div><div class=paragraph><p>Drücken Sie eine Taste außer <kbd>Enter</kbd> um den Bootvorgang zu unterbrechen. Sie erhalten dann ein Prompt, an dem Sie weitere Eingaben tätigen können:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div><div class=paragraph><p>Je nach Inhalt von <span class=filename>/boot.config</span> erscheint das Prompt auf der seriellen Konsole, der internen Konsole oder beiden Konsolen. Wenn die Meldung auf der richtigen Konsole erscheint, drücken Sie <kbd>Enter</kbd> um fortzufahren.</p></div><div class=paragraph><p>Wenn kein Prompt auf der seriellen Konsole erscheint, liegt ein Fehler in den Einstellungen vor. Als Abhilfe geben Sie an der momentanen Konsole <code>-h</code> ein, um den Bootblock und den Bootloader auf die serielle Konsole umzustellen. Führen Sie dann den Bootvorgang mit <kbd>Enter</kbd> weiter und wenn das System gebootet hat, können Sie die fehlerhaften Einstellungen korrigieren.</p></div></li></ol></div></div></div><div class=paragraph><p>Während der dritten Bootphase können Sie immer noch zwischen der internen und der seriellen Konsole auswählen. Setzen Sie dazu, wie in <a href=#serialconsole-loader>Die Konsole im Bootloader ändern</a> beschrieben, die entsprechenden Variablen des Bootloaders.</p></div></div><div class=sect2><h3 id=serialconsole-summary>49.3. Zusammenfassung<a class=anchor href=#serialconsole-summary></a></h3><div class=paragraph><p>Die folgende Tabelle bietet eine Zusammenfassung der verschiedenen Einstellungen, die in diesem Abschnitt diskutiert wurden:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 23. Fall 1: Option 0x10 für <span class=filename>sio0</span></caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Optionen in /boot.config</th><th class="tableblock halign-left valign-top">Konsole in den Bootblöcken</th><th class="tableblock halign-left valign-top">Konsole im Bootloader</th><th class="tableblock halign-left valign-top">Konsole im Kernel</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>keine</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle und interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle und interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, mit Tastatur</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, ohne Tastatur</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle und interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td></tr></tbody></table><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 24. Fall 2: Option 0x30 für <span class=filename>sio0</span></caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Optionen in /boot.config</th><th class="tableblock halign-left valign-top">Konsole in den Bootblöcken</th><th class="tableblock halign-left valign-top">Konsole im Bootloader</th><th class="tableblock halign-left valign-top">Konsole im Kernel</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>keine</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle und interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle und interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, mit Tastatur</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, ohne Tastatur</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle und interne</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serielle</p></td></tr></tbody></table></div><div class=sect2><h3 id=serialconsole-tips>49.4. Hinweise zur seriellen Konsole<a class=anchor href=#serialconsole-tips></a></h3><div class=sect3><h4 id=_verwenden_einer_höheren_geschwindigkeit>49.4.1. Verwenden einer höheren Geschwindigkeit<a class=anchor href=#_verwenden_einer_höheren_geschwindigkeit></a></h4><div class=paragraph><p>Die Vorgabewerte für die Kommunikationsparameter der seriellen Schnittstelle sind: 9600 baud, 8 Bit, keine Parität und ein Stopp-Bit. Um die Standardgeschwindigkeit zu ändern, stehen folgende Möglichkeiten zur Verfügung:</p></div><div class=ulist><ul><li><p>Geben Sie die neue Konsolengeschwindigkeit mit <code>BOOT_COMCONSOLE_SPEED</code> an und kompilieren Sie die Bootblöcke neu. Ausführliche Informationen zum Bau und zur Installation von neuen Bootblöcken finden Sie im <a href=#serialconsole-com2>Eine andere Schnittstelle als <span class=filename>sio0</span> benutzen</a> des Handbuchs.</p><div class=paragraph><p>Wenn die serielle Konsole nicht mit der Option <code>-h</code> gestartet wird, oder wenn die verwendete serielle Konsole sich von der von den Bootblöcken verwendeten unterscheidet, müsssen Sie zusätzlich die folgende Option in die Kernelkonfigurationsdatei aufnehmen und den Kernel neu bauen:</p></div><div class="literalblock programlisting"><div class=content><pre>options CONSPEED=19200</pre></div></div></li><li><p>Verwenden Sie die Option <code>-S</code>, um den Kernel zu booten. Eine Beschreibung dieses Vorgangs sowie eine Auflistung der von <span class=filename>/boot.config</span> unterstützten Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a>.</p></li><li><p>Aktivieren Sie die Option <code>comconsole_speed</code> in <span class=filename>/boot/loader.conf</span>.</p><div class=paragraph><p>Diese Option setzt voraus, dass auch die Optionen <code>console</code>, <code>boot_serial</code>, sowie <code>boot_multicons</code> in <span class=filename>/boot/loader.conf</span> gesetzt sind. Im Folgenden finden Sie ein Beispiel, in dem <code>comconsole_speed</code> verwendet wird, um die Geschwindigkeit der seriellen Konsole zu ändern:</p></div><div class="literalblock programlisting"><div class=content><pre>boot_multicons=&#34;YES&#34;
boot_serial=&#34;YES&#34;
comconsole_speed=&#34;115200&#34;
console=&#34;comconsole,vidconsole&#34;</pre></div></div></li></ul></div></div><div class=sect3><h4 id=serialconsole-com2>49.4.2. Eine andere Schnittstelle als <span class=filename>sio0</span> benutzen<a class=anchor href=#serialconsole-com2></a></h4><div class=paragraph><p>Wenn Sie, warum auch immer, ein anderes Gerät als <span class=filename>sio0</span> für die serielle Konsole einsetzen wollen, kompilieren Sie bitte die Bootblöcke, den Bootloader und den Kernel nach dem folgenden Verfahren neu.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Installieren Sie die Kernelquellen wie im <a href=./#updating-upgrading>FreeBSD aktualisieren</a> beschrieben.</p></li><li><p>Setzen Sie in <span class=filename>/etc/make.conf</span><code>BOOT_COMCONSOLE_PORT</code> auf die Adresse der Schnittstelle (0x3F8, 0x2F8, 0x3E8 oder 0x2E8), die Sie benutzen möchten. Sie können nur <span class=filename>sio0</span> bis <span class=filename>sio3</span> (<span class=filename>COM1</span> bis <span class=filename>COM4</span>) benutzen, Multiportkarten können Sie nicht als Konsole benutzen. Interrupts müssen Sie hier nicht angeben.</p></li><li><p>Erstellen Sie eine angepasste Kernelkonfiguration und geben Sie dort die richtigen Optionen für die Schnittstelle, die Sie benutzen möchten, an. Wenn Sie zum Beispiel <span class=filename>sio1</span> (<span class=filename>COM2</span>) zur Konsole machen wollen, geben Sie dort entweder</p><div class="literalblock programlisting"><div class=content><pre>device sio1 at isa? port IO_COM2 tty flags 0x10 irq 3</pre></div></div><div class=paragraph><p>oder</p></div><div class="literalblock programlisting"><div class=content><pre>device sio1 at isa? port IO_COM2 tty flags 0x30 irq 3</pre></div></div><div class=paragraph><p>an. Keine andere serielle Schnittstelle sollte als Konsole definiert werden.</p></div></li><li><p>Übersetzen und installieren Sie die Bootblöcke und den Bootloader:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/boot</span>
<span class=c># make clean</span>
<span class=c># make</span>
<span class=c># make install</span></code></pre></div></div></li><li><p>Bauen und installieren Sie einen neuen Kernel.</p></li><li><p>Schreiben Sie die Bootblöcke mit <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> auf die Bootplatte und booten Sie den neuen Kernel.</p></li></ol></div></div><div class=sect3><h4 id=serialconsole-ddb>49.4.3. DDB Debugger über die serielle Schnittstelle<a class=anchor href=#serialconsole-ddb></a></h4><div class=paragraph><p>Wenn Sie den Kerneldebugger über eine serielle Verbindung bedienen möchten, übersetzen Sie einen angepassten Kernel mit den folgenden Optionen. Das ist nützlich, kann aber gefährlich sein, wenn auf der Leitung falsche BREAK-Signale generiert werden.</p></div><div class="literalblock programlisting"><div class=content><pre>options BREAK_TO_DEBUGGER
options DDB</pre></div></div></div><div class=sect3><h4 id=_benutzung_der_seriellen_konsole_zum_anmelden>49.4.4. Benutzung der seriellen Konsole zum Anmelden<a class=anchor href=#_benutzung_der_seriellen_konsole_zum_anmelden></a></h4><div class=paragraph><p>Da Sie schon die Bootmeldungen auf der Konsole verfolgen können und den Kerneldebugger über die Konsole bedienen können, wollen Sie sich vielleicht auch an der Konsole anmelden.</p></div><div class=paragraph><p>Öffnen Sie <span class=filename>/etc/ttys</span> in einem Editor und suchen Sie nach den folgenden Zeilen:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyu1 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyu2 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyu3 &#34;/usr/libexec/getty std.9600&#34; unknown off secure</pre></div></div><div class=paragraph><p><span class=filename>ttyu0</span> bis <span class=filename>ttyu3</span> entsprechen <span class=filename>COM1</span> bis <span class=filename>COM4</span>. Ändern Sie für die entsprechende Schnittstelle <code>off</code> zu <code>on</code>. Wenn Sie auch die Geschwindigkeit der seriellen Schnittstelle geändert haben, müssen Sie <code>std.9600</code> auf die momentane Geschwindigkeit anpassen.</p></div><div class=paragraph><p>Auch kann den Terminaltyp von <code>unknown</code> auf den tatsächlich verwendeten Terminal gesetzt werden.</p></div><div class=paragraph><p>Damit die Änderungen wirksam werden, müssen Sie noch <code>kill -HUP 1</code> absetzen.</p></div></div></div><div class=sect2><h3 id=serialconsole-loader>49.5. Die Konsole im Bootloader ändern<a class=anchor href=#serialconsole-loader></a></h3><div class=paragraph><p>In den vorigen Abschnitten wurde beschrieben, wie Sie die serielle Konsole durch Änderungen im Bootblock aktivieren. Dieser Abschnitt zeigt, wie Sie mit Kommandos und Umgebungsvariablen die Konsole im Bootloader definieren. Da der Bootloader die dritte Phase im Bootvorgang ist und nach den Bootblöcken ausgeführt wird, überschreiben seine Einstellungen die des Bootblocks.</p></div><div class=sect3><h4 id=_festlegen_der_konsole>49.5.1. Festlegen der Konsole<a class=anchor href=#_festlegen_der_konsole></a></h4><div class=paragraph><p>Mit einer einzigen Zeile in <span class=filename>/boot/loader.conf</span> können Sie den Bootloader und den Kernel anweisen, die serielle Schnittstelle zur Konsole zu machen:</p></div><div class="literalblock programlisting"><div class=content><pre>console=&#34;comconsole&#34;</pre></div></div><div class=paragraph><p>Unabhängig von den Einstellungen im Bootblock legt dies die Konsole fest.</p></div><div class=paragraph><p>Die obige Zeile sollte die erste Zeile in <span class=filename>/boot/loader.conf</span> sein, so dass die Bootmeldungen so früh wie möglich auf der Konsole zu sehen sind.</p></div><div class=paragraph><p>Analog können Sie die interne Konsole verwenden:</p></div><div class="literalblock programlisting"><div class=content><pre>console=&#34;vidconsole&#34;</pre></div></div><div class=paragraph><p>Wenn die Umgebungsvariable <code>console</code> nicht gesetzt ist, bestimmt der Bootloader und damit auch der Kernel, die Konsole über die <code>-h</code> Option des Bootblocks.</p></div><div class=paragraph><p>Die Bootkonsole kann in <span class=filename>/boot/loader.conf.local</span> oder <span class=filename>/boot/loader.conf</span> angegeben werden.</p></div><div class=paragraph><p>Weitere Informationen erhalten Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Momentan gibt es im Bootloader nichts vergleichbares zu <code>-P</code> im Bootblock. Damit kann die Konsole nicht automatisch über das Vorhandensein einer Tastatur festgelegt werden.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_eine_andere_schnittstelle_als_sio0_benutzen>49.5.2. Eine andere Schnittstelle als <span class=filename>sio0</span> benutzen<a class=anchor href=#_eine_andere_schnittstelle_als_sio0_benutzen></a></h4><div class=paragraph><p>Der Bootloader muss neu kompiliert werden, wenn eine andere Schnittstelle als <span class=filename>sio0</span> benutzt werden soll. Folgen Sie der Anleitung aus <a href=#serialconsole-com2>Eine andere Schnittstelle als <span class=filename>sio0</span> benutzen</a>.</p></div></div></div><div class=sect2><h3 id=serialconsole-caveats>49.6. Vorbehalte<a class=anchor href=#serialconsole-caveats></a></h3><div class=paragraph><p>Obwohl es die meisten Systeme erlauben, ohne Tastatur zu booten, gibt es nur wenige Systeme, die ohne eine Grafikkarte booten. Maschinen mit einem AMI BIOS können ohne Grafik booten, indem Sie den Grafikadapter im CMOS-Setup auf <code>Not installed</code> setzen.</p></div><div class=paragraph><p>Viele Maschinen unterstützen diese Option allerdings nicht. Damit diese Maschinen booten, müssen sie über eine Grafikkarte, auch wenn es nur eine alte Monochromkarte ist, verfügen. Allerdings brauchen Sie keinen Monitor an die Karte anzuschließen. Sie können natürlich auch versuchen, auf diesen Maschinen ein AMI BIOS zu installieren.</p></div></div></div></div><div class=sect1><h2 id=ppp-and-slip>Kapitel 50. PPP<a class=anchor href=#ppp-and-slip></a></h2><div class=sectionbody><div class=sect2><h3 id=ppp-and-slip-synopsis>50.1. Übersicht<a class=anchor href=#ppp-and-slip-synopsis></a></h3><div class=paragraph><p>FreeBSD unterstützt das Point-to-Point (PPP) Protokoll, mit dem über ein Modem eine Verbindung mit einem Netzwerk oder dem Internet hergestellt werden kann. Dieses Kapitel beschreibt die Konfiguration von Modem-basierten Kommunikationsdiensten unter FreeBSD.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie wissen:</p></div><div class=ulist><ul><li><p>Wie Sie PPP einrichten, benutzen, sowie Fehler beheben.</p></li><li><p>Was zu tun ist, um PPP over Ethernet (PPPoE) einzurichten.</p></li><li><p>Wie Sie PPP over ATM (PPPoA) einrichten.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>Mit den grundlegenden Begriffen der Netzwerktechnik vertraut sein.</p></li><li><p>Die Grundlagen und den Zweck einer Einwahlverbindung sowie PPP kennen.</p></li></ul></div></div><div class=sect2><h3 id=userppp>50.2. PPP konfigurieren<a class=anchor href=#userppp></a></h3><div class=paragraph><p>FreeBSD enthält <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>, um Einwählverbindungen über PPP zu verwalten. Der FreeBSD-Kernel enthält Unterstützung für die <span class=filename>tun</span>-Schnittstelle, die benutzt wird um mit einem Modem zu interagieren. Für die Konfiguration muss mindestens eine Datei bearbeitet werden. Beispiele sind in den Konfigurationsdateien ebenfalls enthalten. Schlussendlich wird <code>ppp</code> benutzt, um die Verbindungen zu starten und zu verwalten.</p></div><div class=paragraph><p>Für eine PPP-Verbindung sind folgende Dinge erforderlich:</p></div><div class=ulist><ul><li><p>Ein Account bei einem Internet Service Provider (ISP).</p></li><li><p>Ein Modem.</p></li><li><p>Die Einwahlnummer(n) des ISPs.</p></li><li><p>Den Login-Namen und das Passwort, welches vom ISP zugewiesen wurde.</p></li><li><p>Die IP-Adresse von einem oder mehreren DNSServern. Üblicherweise werden diese Daten vom ISP zur Verfügung gestellt. Falls dies nicht der Fall ist, können Sie FreeBSD so konfigurieren, das es die DNS-Daten automatisch aushandeln kann.</p></li></ul></div><div class=paragraph><p>Sollte eine dieser Informationen fehlen, kontaktieren Sie den ISP!</p></div><div class=paragraph><p>Die folgenden Informationen werden möglicherweise durch den ISP zur Verfügung gestellt, sie sind aber nicht zwingend erforderlich:</p></div><div class=ulist><ul><li><p>Die IP-Adresse des Standard-Gateways. Steht diese Information nicht zur Verfügung, wird der PPP-Server des ISPs beim Verbindungsaufbau eine gültige Adresse übermitteln. Diese Adresse wird in der Konfiguration von PPP unter FreeBSD als <code>HISADDR</code> bezeichnet.</p></li><li><p>Die Netzmaske. Falls der ISP keine Netzmaske vorgegeben hat, können Sie in der Konfigurationsdatei von <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> <code>255.255.255.255</code> verwenden.
*</p><div class=paragraph><p>Wenn der ISP eine statische IP-Adresse und einen Rechnernamen zugewiesen hat, sollten diese Informationen in die Konfigurationsdatei eingetragen werden. Andernfalls werden diese Informationen automatisch beim Verbindungsaufbau zur Verfügung gestellt.</p></div></li></ul></div><div class=paragraph><p>Der Rest dieses Abschnitts beschreibt, wie FreeBSD für gebräuchliche PPP-Verbindungsszenarien konfiguriert wird. Die erforderliche Konfigurationsdatei ist <span class=filename>/etc/ppp/ppp.conf</span>. Zusätzliche Dateien und Beispiele sind in <span class=filename>/usr/shared/examples/ppp/</span> verfügbar.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Beispieldateien, die in diesem Kapitel dargestellt werden, enthalten Zeilennummern. Die Nummerierung dient lediglich einer leichteren Orientierung und sollte nicht in die Dateien übernommen werden.</p></div><div class=paragraph><p>Achten Sie auf die richtige Einrückung, wenn Sie eine Konfigurationsdatei bearbeiten. Zeilen die mit einem <code>:</code> enden, beginnen in der ersten Spalte (am Beginn der Zeile). Alle anderen Zeilen sollten wie dargestellt durch Leerzeichen oder Tabulatoren eingerückt werden.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=userppp-staticIP>50.2.1. Grundlegende Konfiguration<a class=anchor href=#userppp-staticIP></a></h4><div class=paragraph><p>Um eine PPP-Verbindung zu konfigurieren, tragen Sie zuerst die Zugangsdaten des ISPs in <span class=filename>/etc/ppp/ppp.conf</span> ein. Diese Datei wird wie folgt beschrieben:</p></div><div class="literalblock programlisting"><div class=content><pre>1     default:
2       set log Phase Chat LCP IPCP CCP tun command
3       ident user-ppp VERSION
4       set device /dev/cuau0
5       set speed 115200
6       set dial &#34;ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \
7                 \&#34;\&#34; AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT&#34;
8       set timeout 180
9       enable dns
10
11    provider:
12      set phone &#34;(123) 456 7890&#34;
13      set authname foo
14      set authkey bar
15      set timeout 300
16      set ifaddr x.x.x.x/0 y.y.y.y/0 255.255.255.255 0.0.0.0
17      add default HISADDR</pre></div></div><div class=dlist><dl><dt class=hdlist1>Zeile 1</dt><dd><p>Gibt den Standardeintrag an. Befehle dieses Eintrags (Zeile 2 bis 9) werden automatisch ausgeführt, wenn <code>ppp</code> läuft.</p></dd><dt class=hdlist1>Zeile 2</dt><dd><p>Schaltet die ausführliche Protokollierung ein. Sobald die Verbindung zufriedenstellend funktioniert, können Sie diese Zeile verkürzen:</p><div class="literalblock programlisting"><div class=content><pre>set log phase tun</pre></div></div><div class=paragraph><p>Dies verhindert ein übermäßiges Anwachsen der Logdateien.</p></div></dd><dt class=hdlist1>Zeile 3</dt><dd><p>Übermittelt die Version von <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> an die PPP-Software der Gegenstelle.</p></dd><dt class=hdlist1>Zeile 4</dt><dd><p>Gibt das Device an, an dem das Modem angeschlossen ist. <span class=filename>COM1</span> entspricht <span class=filename>/dev/cuad0</span> und <span class=filename>COM2</span> entspricht <span class=filename>/dev/cuad1</span>.</p></dd><dt class=hdlist1>Zeile 5</dt><dd><p>Legt die Verbindungsgeschwindigkeit fest. Falls ein Wert von <code>115200</code> bei älteren Modems nicht funktioniert, versuchen Sie es stattdessen mit <code>38400</code>.</p></dd><dt class=hdlist1>Zeile 6 & 7</dt><dd><p>Die Zeichenfolge für die Einwahl in einer expect-send Syntax. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=chat&amp;sektion=8&amp;format=html">chat(8)</a>.</p><div class=paragraph><p>Beachten Sie, dass dieser Befehl aufgrund der besseren Lesbarkeit auf der nächsten Zeile weitergeht. Das kann für jeden Befehl in <span class=filename>ppp.conf</span> gelten, wenn <code>\</code> das letzte Zeichen in einer Zeile ist.</p></div></dd><dt class=hdlist1>Zeile 8</dt><dd><p>Legt den Zeitrahmen in Sekunden fest, innerhalb dessen eine Reaktion erfolgen muss.</p></dd><dt class=hdlist1>Zeile 9</dt><dd><p>Weist die Gegenstelle an, die DNS-Einstellungen zu bestätigen. Wenn es im lokalen Netzwerk einen DNS-Server gibt, sollte diese Zeile auskommentiert oder gelöscht werden.</p></dd><dt class=hdlist1>Zeile 10</dt><dd><p>Eine leere Zeile zur besseren Lesbarkeit. Leere Zeilen werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> ignoriert.</p></dd><dt class=hdlist1>Zeile 11</dt><dd><p>Bestimmt einen Provider, namens <code>provider</code>. Wenn Sie hier den Namen des ISP einsetzen, können Sie später die Verbindung mit <code>load <em>ISP</em></code> aufbauen.</p></dd><dt class=hdlist1>Zeile 12</dt><dd><p>Gibt die Telefonnummer des Providers an. Mehrere Telefonnummern können angegeben werden, indem Doppelpunkte (<code>:</code>) oder Pipe-Zeichen (<code>|</code>) als Trennzeichen verwendet werden. Wenn Sie die verschiedenen Nummern abwechselnd verwenden möchten, sollten Sie die Nummern durch einen Doppelpunkt trennen. Wenn Sie immer die erste Nummer verwenden möchten und die anderen nur zum Einsatz kommen sollen, wenn eine Einwahl mit der ersten Telefonnummer nicht möglich ist, sollten Sie das Pipe-Zeichen zur Trennung verwenden. Sie sollten immer die gesamte Reihe der Telefonnummern in Anführungszeichen (<code>"</code>) setzen, um Wählfehler zu vermeiden.</p></dd><dt class=hdlist1>Zeile 13 & 14</dt><dd><p>Gibt den Benutzernamen und das Passwort für den ISP an.</p></dd><dt class=hdlist1>Zeile 15</dt><dd><p>Setzt einen Zeitrahmen in Sekunden, innerhalb dessen eine Reaktion erfolgen muss. In diesem Fall, wird die Verbindung nach 300 Sekunden automatisch geschlossen, wenn keine Aktivität zu verzeichnen ist. Wenn Sie keinen Zeitrahmen festlegen wollen, nach dessen Überschreiten die Verbindung geschlossen wird, können Sie diesen Wert auf <code>0</code> setzen.</p></dd><dt class=hdlist1>Zeile 16</dt><dd><p>Legt die Adresse für die Schnittstelle fest. Die verwendeten Werte hängen davon ab, ob Sie vom ISP eine statische IP-Adresse zugeteilt bekommen haben, oder ob beim Verbindungsaufbau eine dynamische Adresse ausgehandelt wird.</p><div class=paragraph><p>Wenn Ihnen der ISP keine statische IP-Adresse zugeteilt hat, ändern Sie diese Zeile auf den folgenden Wert. Dadurch weiß <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>, dass es das IP Configuration Protocol (IPCP) benutzen soll um die dynamische IP-Adresse auszuhandeln.</p></div><div class="literalblock programlisting"><div class=content><pre>set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0</pre></div></div></dd><dt class=hdlist1>Zeile 17</dt><dd><p>Fügt eine Defaultroute für das Gateway hinzu. Belassen Sie die Zeile so wie sie ist. <code>HISADDR</code> wird dabei durch die in Zeile 16 angegebene Gateway-Adresse ersetzt. Wichtig ist, dass diese Zeile nach Zeile 16 erscheint.</p></dd></dl></div><div class=paragraph><p>Je nachdem, ob <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> manuell oder automatisch gestartet wird, muss vielleicht auch <span class=filename>/etc/ppp/ppp.linkup</span> mit dem folgenden Inhalt erstellt werden. Diese Datei ist erforderlich, falls <code>ppp</code> im <code>-auto</code>-Modus ausgefürht wird. Die Datei wird verwendet, nachdem die Verbindung hergestellt wurde. An diesem Punkt wird die IP-Adresse zugewiesen und es sollte nun möglich sein, Einträge in die Routingtabelle hinzuzufügen. Stellen Sie bei der Bearbeitung der Datei sicher, dass der Eintrag für <em>provider</em> mit dem Wert aus Zeile 11 in <span class=filename>ppp.conf</span> übereinstimmt.</p></div><div class="literalblock programlisting"><div class=content><pre>provider:
      add default HISADDR</pre></div></div><div class=paragraph><p>Diese Datei wird ebenfalls benötigt, wenn bei einer Konfiguration mit statischer IP-Adresse die Adresse des Standard-Gateways "erraten" wird. In solchen Fällen entfernen Sie Zeile 17 aus <span class=filename>ppp.conf</span> und erstellen Sie <span class=filename>/etc/ppp/ppp.linkup</span> mit den oben genannten Zeilen. Weitere Beispiele für diese Datei finden Sie in <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class=paragraph><p>In der Voreinstellung muss <code>ppp</code> als <code>root</code> ausgeführt werden. Um diesen Standard zu ändern, muss das Konto eines Benutzers, der <code>ppp</code> ausführen soll, zur Gruppe <code>network</code> in <span class=filename>/etc/group</span> hinzugefügt werden.</p></div><div class=paragraph><p>Danach geben Sie dem Benutzer ebenfalls Zugriff auf einen oder mehrere Abschnitte der Konfigurationsdatei <span class=filename>/etc/ppp/ppp.conf</span> geben müssen, indem Sie den <code>allow</code> Befehl verwenden. Um beispielsweise den Benutzern <code>fred</code> und <code>mary</code> die Berechtigung für den Eintrag <code>provider:</code> zu geben, fügen Sie in der Sektion <code>provider</code> folgende Zeile ein:</p></div><div class="literalblock programlisting"><div class=content><pre>allow users fred mary</pre></div></div><div class=paragraph><p>Wenn dieser Befehl stattdessen in der Sektion <code>default</code> verwendet wird, erhalten die angegebenen Benutzer vollständigen Zugriff.</p></div></div><div class=sect3><h4 id=_fortgeschrittene_konfiguration>50.2.2. Fortgeschrittene Konfiguration<a class=anchor href=#_fortgeschrittene_konfiguration></a></h4><div class=paragraph><p>Es ist möglich PPP so zu konfigurieren, dass bei Bedarf DNS und NetBIOS Nameserveradressen bereitgestellt werden.</p></div><div class=paragraph><p>Um diese Erweiterungen für die PPP Version 1.x zu aktivieren, sollte der entsprechende Abschnitt der Datei <span class=filename>/etc/ppp/ppp.conf</span> um folgende Zeilen ergänzt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>enable msext
set ns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>Für PPP Version 2 und höher:</p></div><div class="literalblock programlisting"><div class=content><pre>accept dns
set dns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>Damit werden den Clients die primären und sekundären Nameserveradressen sowie ein NetBIOS Nameserver-Host mitgeteilt.</p></div><div class=paragraph><p>In Version 2 und höher verwendet PPP die Werte, die in <span class=filename>/etc/resolv.conf</span> zu finden sind, wenn die Zeile <code>set dns</code> weggelassen wird.</p></div><div class=sect4><h5 id=userppp-PAPnCHAP>50.2.2.1. Authentifizierung durch PAP und CHAP<a class=anchor href=#userppp-PAPnCHAP></a></h5><div class=paragraph><p>Einige ISPs haben ihr System so eingerichtet, dass der Authentifizierungsteil eines Verbindungsaufbaus mit Hilfe von PAP oder CHAP-Mechanismen durchgeführt wird. Wenn das der Fall sein sollte, wird der ISP bei der Verbindung keinen <code>login:</code>-Prompt präsentieren, sondern sofort mit der Aushandlung der PPP-Verbindung beginnen.</p></div><div class=paragraph><p>PAP ist nicht so sicher wie CHAP, doch die Sicherheit ist hierbei normalerweise kein Problem, da Passwörter, obgleich von PAP im Klartext versandt, lediglich über die serielle Verbindung verschickt werden. Es gibt für Angreifer wenig Möglichkeiten zu "lauschen".</p></div><div class=paragraph><p>Die folgenden Veränderungen müssen vorgenommen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>13      set authname MyUserName
14      set authkey MyPassword
15      set login</pre></div></div><div class=dlist><dl><dt class=hdlist1>Zeile 13</dt><dd><p>Diese Zeile legt den PAP/CHAP Benutzernamen fest. Sie müssen den richtigen Wert für <em>MyUserName</em> eingeben.</p></dd><dt class=hdlist1>Zeile 14</dt><dd><p>Diese Zeile legt das PAP/CHAP Passwort fest. Sie müssen den richtigen Wert für <em>MyPassword</em> eingeben. Sie können eine zusätzliche Zeile, wie etwa:</p><div class="literalblock programlisting"><div class=content><pre>16      accept PAP</pre></div></div><div class=paragraph><p>oder</p></div><div class="literalblock programlisting"><div class=content><pre>16      accept CHAP</pre></div></div><div class=paragraph><p>verwenden, um deutlich zu machen, dass dies beabsichtigt ist, aber sowohl PAP wie auch CHAP als standardmäßig akzeptiert werden.</p></div></dd><dt class=hdlist1>Zeile 15</dt><dd><p>Der ISP wird normalerweise keine Anmeldung am Server verlangen, wenn PAP oder CHAP verwendet wird. Sie müssen deshalb den String "set login" deaktivieren.</p></dd></dl></div></div><div class=sect4><h5 id=userppp-nat>50.2.2.2. PPP NAT benutzen<a class=anchor href=#userppp-nat></a></h5><div class=paragraph><p>PPP kann Network Address Translation (NAT) ohne Hilfe des Kernels durchführen. Wenn Sie diese Funktion benutzen wollen, fügen Sie die folgende Zeile in <span class=filename>/etc/ppp/ppp.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>nat enable yes</pre></div></div><div class=paragraph><p>NAT kann mit der Option <code>-nat</code> auf der Kommandozeile aktiviert werden. Weiterhin kann NAT in <span class=filename>/etc/rc.conf</span> mit der Variablen <code>ppp_nat</code> aktiviert werden. Dies ist auch die Voreinstellung.</p></div><div class=paragraph><p>Die nachstehende <span class=filename>/etc/ppp/ppp.conf</span> benutzt NAT für bestimmte eingehende Verbindungen:</p></div><div class="literalblock programlisting"><div class=content><pre>nat port tcp 10.0.0.2:ftp ftp
nat port tcp 10.0.0.2:http http</pre></div></div><div class=paragraph><p>Wenn Sie Verbindungen von außen überhaupt nicht trauen, benutzen Sie die folgende Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>nat deny_incoming yes</pre></div></div></div></div><div class=sect3><h4 id=userppp-final>50.2.3. Abschließende Systemkonfiguration<a class=anchor href=#userppp-final></a></h4><div class=paragraph><p>Obwohl <code>ppp</code> nun konfiguriert ist, müssen noch einige Änderungen in <span class=filename>/etc/rc.conf</span> vorgenommen werden.</p></div><div class=paragraph><p>Gehen Sie diese Datei von oben nach unten durch, und stellen Sie als Erstes sicher, dass die Zeile <code>hostname=</code> vorhanden ist:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;foo.example.com&#34;</pre></div></div><div class=paragraph><p>Wenn der ISP eine statische IP-Adresse und einen Namen zugewiesen hat, verwenden Sie diesen Namen als Hostnamen.</p></div><div class=paragraph><p>Schauen Sie nach der Variable <code>network_interfaces</code>. Wenn Sie das System so konfigurieren möchten, dass es bei Bedarf eine Verbindung zum ISP aufbaut, sollten Sie das Gerät <span class=filename>tun0</span> zu der Liste hinzufügen oder es andernfalls entfernen.</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 tun0&#34;
ifconfig_tun0=</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Variable <code>ifconfig_tun0</code> sollte leer sein und eine Datei namens <span class=filename>/etc/start_if.tun0</span> sollte erstellt werden. Diese Datei sollte die nachfolgende Zeile enthalten:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp -auto mysystem</pre></div></div><div class=paragraph><p>Dieses Skript startet den ppp-Daemon im Automatik-Modus. Es wird bei der Netzwerkkonfiguration ausgeführt. Wenn der Rechner als Gateway für ein LAN fungiert, möchten Sie vielleicht auch die Option <code>-alias</code> verwenden. In der Manualpage sind weitere Einzelheiten zu finden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Stellen Sie sicher, dass der Start eines Routerprogramms in <span class=filename>/etc/rc.conf</span> wie folgt deaktiviert ist:</p></div><div class="literalblock programlisting"><div class=content><pre>router_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Es ist wichtig, dass der <code>routed</code>-Daemon nicht gestartet wird da <code>routed</code> dazu tendiert, die von <code>ppp</code> erstellten Einträge der Standardroute zu überschreiben.</p></div><div class=paragraph><p>Es ist außerdem sinnvoll, darauf zu achten, dass die Zeile <code>sendmail_flags</code> nicht die Option <code>-q</code> enthält, da <code>sendmail</code> sonst ab und zu die Netzwerkverbindung prüfen wird, was möglicherweise dazu führt, dass sich der Rechner einwählt. Sie können hier Folgendes angeben:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_flags=&#34;-bd&#34;</pre></div></div><div class=paragraph><p>Der Nachteil dieser Lösung ist, dass Sie <code>sendmail</code> nach jedem Aufbau einer ppp-Verbindung auffordern müssen, die Mailwarteschlange zu überprüfen. Verwenden Sie den Befehl <code>!bg</code> in <span class=filename>ppp.linkup</span>, um dies zu automatisieren:</p></div><div class="literalblock programlisting"><div class=content><pre>1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m</pre></div></div><div class=paragraph><p>Alternativ ist es möglich, einen "dfilter" einzusetzen, um SMTP-Verkehr zu blockieren. Weitere Einzelheiten hierzu finden Sie in den Beispieldateien.</p></div></div><div class=sect3><h4 id=_ppp_benutzen>50.2.4. <code>ppp</code> benutzen<a class=anchor href=#_ppp_benutzen></a></h4><div class=paragraph><p>Das Einzige, was nun noch zu tun bleibt, ist den Rechner neu zu starten. Nach dem Neustart können Sie entweder:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp</span></code></pre></div></div><div class=paragraph><p>und danach <code>dial provider</code> eingeben, um eine PPP-Sitzung zu starten, oder Sie geben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -auto provider</span></code></pre></div></div><div class=paragraph><p>ein, um <code>ppp</code> bei Datenverkehr aus dem Netzwerk heraus, automatisch eine Verbindung herstellen zu lassen (vorausgesetzt Sie haben kein <span class=filename>start_if.tun0</span> Skript erstellt).</p></div><div class=paragraph><p>Es ist möglich, dem Programm <code>ppp</code> Befehle zu erteilen, während es im Hintergrund läuft. Dazu ist jedoch die Einrichtung eines passenden Diagnose-Ports erforderlich. Ergänzen Sie hierzu die Konfigurationsdatei um folgende Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>set server /var/run/ppp-tun%d DiagnosticPassword 0177</pre></div></div><div class=paragraph><p>Damit wird PPP angewiesen, auf den angegebenen UNIX®-Domainsocket zu hören und Clients nach dem angegebenen Passwort zu fragen, bevor der Zugang gewährt wird. Das <code>%d</code> wird durch die Nummer des benutzten <span class=filename>tun</span>-Devices ersetzt.</p></div><div class=paragraph><p>Wenn ein Socket eingerichtet ist, kann das Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=pppctl&amp;sektion=8&amp;format=html">pppctl(8)</a> in Skripten verwendet werden, mit denen in das laufende Programm eingegriffen wird.</p></div></div><div class=sect3><h4 id=userppp-mgetty>50.2.5. Einwählverbindungen konfigurieren<a class=anchor href=#userppp-mgetty></a></h4><div class=paragraph><p><a href=./#dialup>“Einwählverbindungen”</a> bietet eine gute Beschreibung, wie Einwählverbindungen unter Verwendung von <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> genutzt werden können.</p></div><div class=paragraph><p>Eine Alternative zu <code>getty</code> ist <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a>, eine raffiniertere Version von <code>getty</code>, die mit Blick auf Einwählverbindungen entworfen wurde.</p></div><div class=paragraph><p>Der Vorteil von <code>mgetty</code> ist, dass es auf aktive Weise mit Modems <em>spricht</em>, das heißt wenn ein Port in <span class=filename>/etc/ttys</span> ausgeschaltet ist, wird das Modem nicht auf Anrufe reagieren.</p></div><div class=paragraph><p>Spätere Versionen von <code>mgetty</code> (von 0.99beta aufwärts) unterstützen auch die automatische Erkennung von PPP-Streams, was Clients den skriptlosen Zugang zum Server erlaubt.</p></div><div class=paragraph><p><a href=http://mgetty.greenie.net/doc/mgetty_toc.html>http://mgetty.greenie.net/doc/mgetty_toc.html</a> enthält weitere Informationen zu <code>mgetty</code>.</p></div><div class=paragraph><p>In der Voreinstellung wird <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a> mit der Option <code>AUTO_PPP</code> konfiguriert und kompiliert. Dadurch kann <code>mgetty</code> die LCP Phase von PPP-Verbindungen erkennen und automatisch eine ppp-Shell starten. Da hierbei jedoch die Login/Passwort-Sequenz nicht durchlaufen wird, ist es notwendig, Benutzer durch PAP oder CHAP zu authentifizieren.</p></div><div class=paragraph><p>In diesem Abschnitt wird davon ausgegangen, dass der Benutzer den Port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a> auf seinem System kompiliert und installiert hat.</p></div><div class=paragraph><p>Stellen Sie sicher, dass <span class=filename>/usr/local/etc/mgetty+sendfax/login.config</span> Folgendes enthält:</p></div><div class="literalblock programlisting"><div class=content><pre>/AutoPPP/ -     - /etc/ppp/ppp-pap-dialup</pre></div></div><div class=paragraph><p>Hierdurch wird <code>mgetty</code> angewiesen, <span class=filename>ppp-pap-dialup</span> für die erkannten PPP-Verbindungen auszuführen.</p></div><div class=paragraph><p>Erstellen Sie eine ausführbare Datei namens <span class=filename>/etc/ppp/ppp-pap-dialup</span> mit folgendem Inhalt:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
exec /usr/sbin/ppp -direct pap$IDENT</pre></div></div><div class=paragraph><p>Erstellen Sie bitte für jede Einwählverbindung, die Sie in <span class=filename>/etc/ttys</span> ermöglicht haben, einen korrespondierenden Eintrag in der Datei <span class=filename>/etc/ppp/ppp.conf</span>. Diese Einträge können problemlos, mit den Definitionen die weiter oben gemacht wurden, koexistieren.</p></div><div class="literalblock programlisting"><div class=content><pre>pap:
  enable pap
  set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
  enable proxy</pre></div></div><div class=paragraph><p>Jeder Benutzer, der sich auf diese Weise anmeldet, benötigt einen Benutzernamen und ein Passwort in der Datei <span class=filename>/etc/ppp/ppp.secret</span>. Sie haben auch die Möglichkeit, Benutzer mit Hilfe von PAP zu authentifizieren, indem Sie in <span class=filename>/etc/passwd</span> folgende Option hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>enable passwdauth</pre></div></div><div class=paragraph><p>Um bestimmten Benutzern eine statische IP-Adresse zuzuweisen, können Sie die Adresse als drittes Argument in <span class=filename>/etc/ppp/ppp.secret</span> angeben. Beispiele finden Sie in <span class=filename>/usr/shared/examples/ppp/ppp.secret.sample</span>.</p></div></div></div><div class=sect2><h3 id=ppp-troubleshoot>50.3. Probleme bei PPP-Verbindungen<a class=anchor href=#ppp-troubleshoot></a></h3><div class=paragraph><p>Dieser Abschnitt behandelt Probleme, die auftauchen können, wenn PPP über ein Modem verwendet wird. Einige ISPs verwenden <code>ssword</code>, andere verwenden <code>password</code>. Wenn das Einwahlskript falsch ist, scheitert die Anmeldung. Üblicherweise suchen Sie nach Fehlern der PPP-Verbindung indem Sie sich manuell verbinden.</p></div><div class=sect3><h4 id=_gerätedateien_überprüfen>50.3.1. Gerätedateien überprüfen<a class=anchor href=#_gerätedateien_überprüfen></a></h4><div class=paragraph><p>Wenn Sie einen eigenen Kernel verwenden, stellen Sie sicher, dass die folgende Zeile in der Kernelkonfigurationsdatei vorhanden ist:</p></div><div class="literalblock programlisting"><div class=content><pre>device   uart</pre></div></div><div class=paragraph><p>Das <span class=filename>uart</span>-Gerät ist bereits im <code>GENERIC</code>-Kernel vorhanden, deshalb sind in diesem Fall keine zusätzlichen Schritte vonnöten. Kontrollieren Sie die Ausgabe von <code>dmesg</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | grep uart</span></code></pre></div></div><div class=paragraph><p>In der Ausgabe sollten die entsprechenden <span class=filename>uart</span>-Geräte, beispielsweise <span class=filename>uart1</span> (<span class=filename>COM2</span>), angezeigt werden. Wird ein passendes Gerät angezeigt, braucht der Kernel nicht neu erstellt werden. Wenn das Modem an <span class=filename>uart1</span> angeschlossen ist, ist <span class=filename>/dev/cuau1</span> die dazugehörende Gerätedatei.</p></div></div><div class=sect3><h4 id=_manuelle_verbindungen>50.3.2. Manuelle Verbindungen<a class=anchor href=#_manuelle_verbindungen></a></h4><div class=paragraph><p>Ein Verbindungsaufbau zum Internet durch manuelle Steuerung von <code>ppp</code> geht schnell, ist einfach und stellt einen guten Weg dar, eine Verbindung auf Fehler hin zu überprüfen oder einfach Informationen darüber zu sammeln, wie der ISP Verbindungen handhabt. Lassen Sie uns PPP von der Kommandozeile aus starten. Beachten Sie, dass in allen Beispielen <em>example</em> der Hostname der Maschine ist, auf der PPP läuft. <code>ppp</code> starten Sie wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>device /dev/cuau1</code></pre></div></div><div class=paragraph><p>Mit dem zweiten Befehl wird das Gerät <span class=filename>cuau1</span> festgelegt.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>speed 115200</code></pre></div></div><div class=paragraph><p>Dieser Befehlt setzt die Verbindungsgeschwindigkeit auf 115200 kbps.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>enable </span>dns</code></pre></div></div><div class=paragraph><p>Dieser Befehl weist <code>ppp</code> an, den Resolver zu konfigurieren und in <span class=filename>/etc/resolv.conf</span> Einträge für den Nameserver hinzuzufügen. Falls <code>ppp</code> nicht in der Lage ist den Hostnamen selbst zu bestimmen, kann dieser auch später manuell eingetragen werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; term</code></pre></div></div><div class=paragraph><p>Wechselt in den "Terminal"-Modus, um das Modem manuell kontrollieren zu können.</p></div><div class="literalblock programlisting"><div class=content><pre>deflink: Entering terminal mode on /dev/cuau1
type &#39;~h&#39; for help</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>at
OK
atdt123456789</code></pre></div></div><div class=paragraph><p>Sie verwenden <code>at</code> zur Initialisierung des Modems und dann <code>atdt</code> sowie die Nummer des ISPs, um den Einwählprozess zu starten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>CONNECT</code></pre></div></div><div class=paragraph><p>Dies ist die Bestätigung, dass eine Verbindung aufgebaut wurde. Falls wir Verbindungsprobleme bekommen, die nicht mit der Hardware zusammenhängen, werden wir an dieser Stelle ansetzen müssen, um eine Lösung zu finden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ISP Login:myusername</code></pre></div></div><div class=paragraph><p>Hier werden Sie nach einem Benutzernamen gefragt. Geben Sie am Prompt den Namen ein, den Ihnen der ISP zur Verfügung gestellt hat.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ISP Pass:mypassword</code></pre></div></div><div class=paragraph><p>An dieser Stelle müssen Sie das Passwort angeben, das Ihnen vom ISP vorgegeben wurde. Das Passwort wird, analog dem normalen Anmeldevorgang, nicht angezeigt.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Shell or PPP:ppp</code></pre></div></div><div class=paragraph><p>Abhängig vom ISP, kann es sein, dass dieser Prompt nicht erscheint. Wir werden hier gefragt, ob wir eine Shell beim Provider verwenden oder <code>ppp</code> starten wollen. Weil wir eine Internetverbindung aufbauen wollen, haben wir uns in diesem Beispiel für <code>ppp</code> entschieden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Ppp ON example&gt;</code></pre></div></div><div class=paragraph><p>Beachten Sie, dass sich in diesem Beispiel das erste <code>p</code> in einen Großbuchstaben verwandelt hat. Dies zeigt, dass wir erfolgreich eine Verbindung zum ISP hergestellt haben.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPp ON example&gt;</code></pre></div></div><div class=paragraph><p>An dieser Stelle haben wir uns erfolgreich beim ISP authentifiziert und warten darauf, dass uns eine IP-Adresse zugewiesen wird.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPP ON example&gt;</code></pre></div></div><div class=paragraph><p>Wir haben uns mit der Gegenstelle auf eine IP-Adresse geeinigt und den Verbindungsaufbau erfolgreich abgeschlossen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPP ON example&gt; add default HISADDR</code></pre></div></div><div class=paragraph><p>Hier geben wir unsere Standardroute an. Weil zu diesem Zeitpunkt unsere einzige Verbindung zu unserer Gegenstelle besteht, müssen wir dies tun, bevor wir Kontakt zur Außenwelt aufnehmen können. Falls dies aufgrund bestehender Routen nicht funktionieren sollte, können Sie ein Ausrufungszeichen <code>!</code> vor <code>add</code> setzen. Sie können diese Standardroute aber auch vor dem eigentlichen Verbindungsaufbau angeben und PPP wird entsprechend eine neue Route aushandeln.</p></div><div class=paragraph><p>Wenn alles gut ging, sollten wir nun eine aktive Internetverbindung haben, die wir mit <span class=keyseq><kbd>Ctrl</kbd>+<kbd>z</kbd></span> in den Hintergrund schicken können. Wenn Sie feststellen, dass <code>PPP</code> wieder zu <code>ppp</code> wird, ist die Verbindung abgebrochen. Es ist gut dies zu wissen, weil dadurch der Verbindungsstatus angezeigt wird. Große <code>P</code>s zeigen an, dass eine Verbindung zum ISP besteht und kleine <code>p</code>s zeigen an, dass keine Verbindung besteht.</p></div></div><div class=sect3><h4 id=_fehlersuche_4>50.3.3. Fehlersuche<a class=anchor href=#_fehlersuche_4></a></h4><div class=paragraph><p>Wenn keine Verbindung aufgebaut werden kann, schalten Sie die Hardware-Flusssteuerung CTS/RTS aus, indem Sie die Option <code>set ctsrts off</code> verwenden. Dies ist zumeist dann der Fall, wenn Sie mit einem PPP-fähigen Terminalserver verbunden sind. Hier bleibt PPP bei dem Versuch hängen, Daten über die Nachrichtenverbindung zu schicken, weil auf einCTS-Signal (Clear-to-Send) gewartet wird, das vielleicht nie kommt. Wenn Sie diese Option jedoch gebrauchen, sollten Sie auch die Option <code>set accmap</code> verwenden, die erforderlich sein kann, um bestimmte Hardware zu kontrollieren, die auf die Übertragung bestimmter Zeichen zwischen den Kommunikations-Endpunkten (zumeist XON/XOFF) angewiesen ist. Die Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> bietet mehr Informationen zu dieser Option und ihrer Verwendung.</p></div><div class=paragraph><p>Für ein älteres Modem benötigen Sie vielleicht die Option <code>set parity even</code>. Standardmäßig wird keine Parität vorausgesetzt, sie ist aber für die Fehlerprüfung bei älteren Modems und bei bestimmten ISPs erforderlich.</p></div><div class=paragraph><p>PPP kehrt möglicherweise nicht in den Befehlsmodus zurück, was normalerweise auf einen Fehler bei der Aushandlung hinweist, wobei der ISP wartet, dass der Aushandlungsprozess beginnt. Die Option <code>~p</code> erzwingt in diesem Fall den Beginn des Aushandlungsprozesses.</p></div><div class=paragraph><p>Wenn der Login-Prompt nie erscheint, wird wahrscheinlich PAP oder CHAP für die Authentifizierung benötigt. Um PAP oder CHAP zu verwenden, ergänzen Sie PPP um folgende Optionen, bevor Sie in den Terminalmodus wechseln:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>authname myusername</code></pre></div></div><div class=paragraph><p>Hierbei sollte <em>myusername</em> durch den Benutzernamen ersetzt werden, den Sie vom ISP bekommen haben.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>authkey mypassword</code></pre></div></div><div class=paragraph><p><em>mypassword</em> sollten Sie durch das Passwort ersetzen, das Ihnen der ISP zugewiesen hat.</p></div><div class=paragraph><p>Wenn die Verbindung aufgebaut wird, Sie aber keine Rechner unter dem Domänen-Namen erreichen können, versuchen Sie, einen Rechner mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> und seiner IP-Adresse zu erreichen. Wenn 100% der Pakete verloren gehen, ist es sehr wahrscheinlich, dass keine Standardroute zugewiesen wurde. Überprüfen Sie, ob während des Verbindungsaufbaus die Option <code>add default HISADDR</code> gesetzt war. Wenn Sie zu einer entfernten IP-Adresse eine Verbindung aufbauen können, ist es möglich, dass die Adresse eines Nameservers nicht in <span class=filename>/etc/resolv.conf</span> eingetragen wurde. Diese Datei sollte folgendermaßen aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>domain example.com
nameserver x.x.x.x
nameserver y.y.y.y</pre></div></div><div class=literalblock><div class=content><pre>Dabei sollten _x.x.x.x_ und _y.y.y.y_ durch die IP-Adressen der DNS-Server des ISPs ersetzt werden.</pre></div></div><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> kann die PPP-Verbindung protokolliert werden. Fügen Sie einfach die folgende Zeile in <span class=filename>/etc/syslog.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>!ppp
*.*     /var/log/ppp.log</pre></div></div></div></div><div class=sect2><h3 id=pppoe>50.4. PPP over Ethernet (PPPoE)<a class=anchor href=#pppoe></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie PPP over Ethernet (PPPoE) einrichten.</p></div><div class=paragraph><p>Dies ist ein Beispiel einer funktionierenden <span class=filename>ppp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>default:
  set log Phase tun command # you can add more detailed logging if you wish
  set ifaddr 10.0.0.1/0 10.0.0.2/0

name_of_service_provider:
  set device PPPoE:xl1 # replace xl1 with your Ethernet device
  set authname YOURLOGINNAME
  set authkey YOURPASSWORD
  set dial
  set login
  add default HISADDR</pre></div></div><div class=paragraph><p>Als <code>root</code>, geben Sie ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -ddial name_of_service_provider</span></code></pre></div></div><div class=paragraph><p>Fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp_enable=&#34;YES&#34;
ppp_mode=&#34;ddial&#34;
ppp_nat=&#34;YES&#34;	# if you want to enable nat for your local network, otherwise NO
ppp_profile=&#34;name_of_service_provider&#34;</pre></div></div><div class=sect3><h4 id=_verwendung_einer_pppoe_dienstbezeichnung_service_tag>50.4.1. Verwendung einer PPPoE-Dienstbezeichnung (service tag)<a class=anchor href=#_verwendung_einer_pppoe_dienstbezeichnung_service_tag></a></h4><div class=paragraph><p>Manchmal kann es notwendig sein, eine Dienstbezeichnung (service tag) zu verwenden, um eine Verbindung aufzubauen. Dienstbezeichnungen werden eingesetzt, um zwischen verschiedenen PPPoE-Servern unterscheiden zu können, die einem bestehenden Netzwerk zugeteilt sind.</p></div><div class=paragraph><p>Die erforderlichen Dienstbezeichnungen sollten in der Dokumentation, zu finden sein, die der ISP zur Verfügung gestellt hat.</p></div><div class=paragraph><p>Als letzte Möglichkeit könnten Sie versuchen, <a class=package href=https://cgit.freebsd.org/ports/tree/net/rr-pppoe/>net/rr-pppoe</a> zu installieren. Bedenken Sie aber, dass dadurch Daten Ihres Modems gelöscht werden können, so dass es nicht mehr benutzt werden kann. Überlegen Sie also genau, ob Sie dies machen wollen. Installieren Sie einfach das Programm, das Ihnen der Provider zusammen mit dem Modem geliefert hat. Gehen Sie dann in das Menü <b class=menuref>System</b> dieses Programms. Der Name des Profils, sollte in der Liste aufgeführt sein. Normalerweise ist dies <em>ISP</em>.</p></div><div class=paragraph><p>Der Name des Profils (service tag) wird im Eintrag für die PPPoE-Konfiguration in der Datei <span class=filename>ppp.conf</span> verwendet, als der Teil des Befehls <code>set device</code> (die Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> enthält Einzelheiten hierzu), der den Provider angibt. Dieser Eintrag sollte folgendermaßen aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>set device PPPoE:xl1:ISP</pre></div></div><div class=paragraph><p>Vergessen Sie nicht, statt <em>xl1</em> das richtige Gerät für die Netzwerkkarte anzugeben.</p></div><div class=paragraph><p>Denken Sie auch daran, <em>ISP</em> durch das Profil zu ersetzen.</p></div><div class=paragraph><p>Weitere Informationen finden Sie unter <a href=http://renaud.waldura.com/doc/freebsd/pppoe/>Cheaper Broadband with FreeBSD on DSL</a> von Renaud Waldura.</p></div></div><div class=sect3><h4 id=ppp-3com>50.4.2. PPPoE mit einem 3Com® HomeConnect™ ADSL Modem Dual Link<a class=anchor href=#ppp-3com></a></h4><div class=paragraph><p>Dieses Modem folgt nicht den in <a href=http://www.faqs.org/rfcs/rfc2516.html>RFC 2516</a> festgelegten Spezifikationen.</p></div><div class=paragraph><p>Um FreeBSD in die Lage zu versetzen, mit diesem Gerät zu kommunizieren, muss ein sysctl Befehl angegeben werden. Dies kann beim Systemstart automatisch geschehen, indem die Datei <span class=filename>/etc/sysctl.conf</span> angepasst wird:</p></div><div class="literalblock programlisting"><div class=content><pre>net.graph.nonstandard_pppoe=1</pre></div></div><div class=paragraph><p>oder, wenn der Befehl unmittelbar wirksam werden soll, durch:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.graph.nonstandard_pppoe=1</span></code></pre></div></div><div class=paragraph><p>Da hiermit eine systemweit gültige Einstellung vorgenommen wird, ist es nicht möglich, gleichzeitig mit einem normalen PPPoE-Client oder Server und einem 3Com® HomeConnect™ ADSL Modem zu kommunizieren.</p></div></div></div><div class=sect2><h3 id=pppoa>50.5. PPP over ATM (PPPoA)<a class=anchor href=#pppoa></a></h3><div class=paragraph><p>Nachfolgend wird beschrieben, wie PPP over ATM (PPPoA) eingerichtet wird. PPPoA ist vor allem unter europäischen DSL-Providern populär.</p></div><div class=sect3><h4 id=_die_verwendung_von_mpd>50.5.1. Die Verwendung von mpd<a class=anchor href=#_die_verwendung_von_mpd></a></h4><div class=paragraph><p>Sie können mpd verwenden, um zu einer Reihe von Diensten, insbesondere PPTP-Diensten eine Verbindung herzustellen. Das Programm kann aus den Ports oder als Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net/mpd5/>net/mpd5</a> installiert werden. Viele ADSL Modems sind auf einen PPTP-Tunnel zwischen dem Modem und dem Rechner angewiesen.</p></div><div class=paragraph><p>Sobald das Programm installiert ist, müssen Sie es nach den Vorgaben des Providers konfigurieren. Der Port installiert auch einige gut dokumentierte Beispielkonfigurationsdateien in <span class=filename>/usr/local/etc/mpd/</span>. Ein kompletter Leitfaden zur Konfiguration von mpd ist unter <span class=filename>/usr/local/shared/doc/mpd/</span> zu finden. Hier ist eine Beispielkonfiguration, um mit mpd eine Verbindung zu einem ADSL-Dienst aufzubauen. Die Konfiguration ist auf zwei Dateien verteilt. Zunächst die Datei <span class=filename>mpd.conf</span>:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dieses Beispiel für <span class=filename>mpd.conf</span> funktioniert nur mit mpd 4.x.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>default:
    load adsl

adsl:
    new -i ng0 adsl adsl
    set bundle authname username <i class=conum data-value=1></i><b>(1)</b>
    set bundle password password <i class=conum data-value=2></i><b>(2)</b>
    set bundle disable multilink

    set link no pap acfcomp protocomp
    set link disable chap
    set link accept chap
    set link keep-alive 30 10

    set ipcp no vjcomp
    set ipcp ranges 0.0.0.0/0 0.0.0.0/0

    set iface route default
    set iface disable on-demand
    set iface enable proxy-arp
    set iface idle 0

    open</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Der Benutzername, den Sie zur Authentifizierung bei Ihrem ISP verwenden.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Das Passwort, das Sie zur Authentifizierung bei Ihrem ISP verwenden.</td></tr></tbody></table></div><div class=paragraph><p>Die Datei <span class=filename>mpd.links</span> enthält Informationen über die Verbindung(en), die Sie aufbauen möchten. Eine Beispieldatei <span class=filename>mpd.links</span>, die das vorige Beispiel ergänzt, wird unten angegeben:</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
    set link type pptp
    set pptp mode active
    set pptp enable originate outcall
    set pptp self 10.0.0.1 <i class=conum data-value=1></i><b>(1)</b>
    set pptp peer 10.0.0.138 <i class=conum data-value=2></i><b>(2)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Die IP-Adresse des FreeBSD-Rechners von dem aus Sie mpd verwenden.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Die IP-Adresse des ADSL-Modems. Das Alcatel SpeedTouch™ Home hat die Adresse <code>10.0.0.138</code> voreingestellt.</td></tr></tbody></table></div><div class=paragraph><p>Ein Verbindungsaufbau kann einfach durch Eingabe des folgenden Befehls als <code>root</code> gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpd -b adsl</span></code></pre></div></div><div class=paragraph><p>Sie können sich den Status der Verbindung durch folgenden Befehl anzeigen lassen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig ng0
ng0: <span class=nv>flags</span><span class=o>=</span>88d1&lt;UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST&gt; mtu 1500
     inet 216.136.204.117 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffffff</code></pre></div></div><div class=paragraph><p>Die Verwendung von mpd ist der empfehlenswerteste Weg, um mit FreeBSD eine Verbindung zu einem ADSL-Dienst aufzubauen.</p></div></div><div class=sect3><h4 id=_die_verwendung_von_pptpclient>50.5.2. Die Verwendung von pptpclient<a class=anchor href=#_die_verwendung_von_pptpclient></a></h4><div class=paragraph><p>Es ist außerdem möglich, mit FreeBSD eine Verbindung zu anderen PPPoA-Diensten aufzubauen. Dazu wird <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a> verwendet.</p></div><div class=paragraph><p>Um mit <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a> eine Verbindung zu einem DSL-Dienst aufbauen zu können, müssen Sie den entsprechenden Port bzw. das Paket installieren und <span class=filename>/etc/ppp/ppp.conf</span> bearbeiten. Eine Beispieldatei für <span class=filename>ppp.conf</span> ist weiter unten angegeben. Weitere Informationen zu den Optionen von <span class=filename>ppp.conf</span> finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
 set log phase chat lcp ipcp ccp tun command
 set timeout 0
 enable dns
 set authname username <i class=conum data-value=1></i><b>(1)</b>
 set authkey password <i class=conum data-value=2></i><b>(2)</b>
 set ifaddr 0 0
 add default HISADDR</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Der Benutzername für den Zugang beim DSL-Provider.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Das Passwort für Ihren Account.</td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Weil das Passwort in <span class=filename>ppp.conf</span> im Klartext hinzugefügt wird, sollten Sie sicherstellen, dass niemand den Inhalt dieser Datei lesen kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:wheel /etc/ppp/ppp.conf</span>
<span class=c># chmod 600 /etc/ppp/ppp.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Dies wird einen Tunnel für eine PPP-Session zum DSL-Router öffnen. Ethernet-DSL-Modems haben eine vorkonfigurierte LAN-IP-Adresse, mit der Sie eine Verbindung aufbauen. Im Falle des Alcatel SpeedTouch™ Home handelt es sich dabei um die Adresse <code>10.0.0.138</code>. In der Dokumentation des Routers sollte angegeben sein, welche Adresse das Gerät verwendet. Um den Tunnel zu öffnen und eine PPP-Session zu starten, führen Sie folgenden Befehl aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pptp address adsl</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Wenn Sie ein kaufmännisches Und ("&") an das Ende dieses Kommandos anfügen, wird pptp den Prompt zurückgeben.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ein virtuelles Tunnel-Device <span class=filename>tun</span> wird für das Zusammenspiel der Prozesse pptp und ppp geschaffen. Wenn Sie den Prompt zurückerhalten haben oder der pptp-Prozess das Vorliegen einer Verbindung bestätigt, können Sie den Tunnel folgendermaßen überprüfen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig tun0
tun0: <span class=nv>flags</span><span class=o>=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
        inet 216.136.204.21 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffff00
        Opened by PID 918</code></pre></div></div><div class=paragraph><p>Wenn die Verbindung fehlschlägt, überprüfen Sie die Konfiguration des Routers, den Sie normalerweise mit einem Web-Browser erreichen können. Prüfen Sie auch die Ausgabe des Befehls <code>pptp</code> und die Logdatei <span class=filename>/var/log/ppp.log</span>.</p></div></div></div></div></div><div class=sect1><h2 id=mail>Kapitel 51. Elektronische Post (E-Mail)<a class=anchor href=#mail></a></h2><div class=sectionbody><div class=sect2><h3 id=mail-de-term>51.1. Terminologie<a class=anchor href=#mail-de-term></a></h3><div class=paragraph><p>Das Akronym <em>MTA</em> steht für <em>Mail Transfer Agent</em> was übersetzt "Mailübertragungs-Agent" bedeutet.</p></div><div class=paragraph><p>Während die Bezeichnung <em>Server-Dämon</em> die Komponente eines MTA benennt, die für eingehende Verbindungen zuständig ist, wird mit dem Begriff <em>Mailer</em> öfters die Komponente des MTA bezeichnet, die E-Mails versendet.</p></div></div><div class=sect2><h3 id=mail-synopsis>51.2. Übersicht<a class=anchor href=#mail-synopsis></a></h3><div class=paragraph><p>"Elektronische Post", besser bekannt als E-Mail, ist eine der am weit verbreitetsten Formen der Kommunikation heutzutage. Dieses Kapitel bietet eine grundlegende Einführung in das Betreiben eines E-Mail-Servers unter FreeBSD. Ebenfalls wird der Versand und Empfang von E-Mails unter FreeBSD behandelt. Eine umfassende Betrachtung zu diesem Thema finden Sie in den Büchern, die in <a href=./#bibliography>Bibliografie</a> aufgelistet sind.</p></div><div class=paragraph><p>Dieses Kapitel behandelt die folgenden Punkte:</p></div><div class=ulist><ul><li><p>Welche Software-Komponenten beim Senden und Empfangen von elektronischer Post involviert sind.</p></li><li><p>Wo sich grundlegende Sendmail Konfigurationsdateien in FreeBSD befinden.</p></li><li><p>Den Unterschied zwischen entfernten und lokalen Postfächern.</p></li><li><p>Wie man Versender von Spam daran hindern kann, E-Mail-Server illegalerweise als Weiterleitung zu verwenden.</p></li><li><p>Wie man einen alternativen MTA installiert und konfiguriert, um Sendmail zu ersetzen.</p></li><li><p>Wie man oft auftretende E-Mail-Server Probleme behebt.</p></li><li><p>Wie E-Mails über einen Relay verschickt werden.</p></li><li><p>Wie E-Mails über eine Einwahlverbindung gehandhabt werden.</p></li><li><p>Wie SMTP-Authentifizierung einrichtet wird.</p></li><li><p>Den Empfang und den Versand von E-Mails mithilfe von Programmen wie mutt.</p></li><li><p>Wie E-Mails von einem entfernten Server mit POP oder IMAP abgeholt werden.</p></li><li><p>Wie eingehende E-Mail automatisch gefiltert wird.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>Die Netzwerk-Verbindung richtig einrichten. (<a href=./#advanced-networking>Weiterführende Netzwerkthemen</a>).</p></li><li><p>Die DNS-Information für einen E-Mail-Server einstellen (<a href=./#network-servers>Netzwerkserver</a>).</p></li><li><p>Wissen, wie man zusätzliche Dritthersteller-Software installiert (<a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=mail-using>51.3. E-Mail Komponenten<a class=anchor href=#mail-using></a></h3><div class=paragraph><p>Es gibt fünf größere Komponenten die am Austausch von E-Mails beteiligt sind: der Mail User Agent (MUA), der Mail Transfer Agent (MTA), der Mail Host, ein entferntes oder lokales Postfach, sowie DNS. Dieser Abschnitt enthält eine Übersicht über diese Komponenten.</p></div><div class=dlist><dl><dt class=hdlist1>Mail User Agent (MUA)</dt><dd><p>Der Mail User Agent (MUA) ist das Benutzerprogramm zum Verfassen, Senden und Empfangen von E-Mails. Diese Anwendung kann ein Kommandozeilenprogramm sein, wie das in FreeBSD enthaltene Programm <code>mail</code>, oder ein Programm aus der Ports-Sammlung wie beispielsweise mutt, alpine oder elm. In der Ports-Sammlung sind auch dutzende von grafischen Programmen verfügbar, darunter ClawsMail, Evolution und Thunderbird. Einige Unternehmen bieten auch ein Web-Mail-Programm an, das über einen Webbrowser verwaltet werden kann. Weitere Informationen zur Installation und Verwendung von MUAs unter FreeBSD finden Sie im <a href=#mail-agents>E-Mail-Programme</a>.</p></dd><dt class=hdlist1>Mail Transfer Agent (MTA)</dt><dd><p>Der Mail Transfer Agent (MTA) ist ein E-Mail-Server Daemon, welcher für dem Empfang von eingehenden E-Mails und für den Versand von ausgehenden E-Mails verantwortlich ist. FreeBSD wird mit Sendmail als Standard-MTA ausgeliefert, aber es unterstützt auch weitere E-Mail-Server, darunter Exim, Postfix und qmail. Die Konfiguration von Sendmail wird im <a href=#sendmail>Sendmail-Konfigurationsdateien</a> beschrieben. Wenn Sie einen anderen MTA aus der Ports-Sammlung installieren, lesen Sie die Nachrichten die nach der Installation der Anwendung ausgegeben werden, wenn Sie FreeBSD spezifische Informationen benötigen. Allgemeine Informationen zur Konfiguration finden Sie in der Regel auf der Webseite des Herstellers.</p></dd><dt class=hdlist1>Mail Host und Postfächer</dt><dd><p>Der Mail Host ist für die Zustellung und das Empfangen von E-Mails für den Rechner oder eines Netzwerks zuständig. Der Mail Host empfängt alle E-Mails für eine Domäne und speichert diese entweder im voreingestellten <span class=filename>mbox</span>-Format, oder im Maildir-Format. Diese E-Mails können lokal mit einem Benutzerprogramm MUA gelesen werden. Mithilfe von Protokollen wie POP oder IMAP können die E-Mails auch von entfernten Rechnern gelesen werden. Wenn die E-Mails direkt auf dem Mail Host gelesen werden, wird kein POP- oder IMAP-Server benötigt.</p><div class=paragraph><p>Um auf entfernte Postfächer zuzugreifen, wird ein Zugang zu einem POP- oder IMAP-Server benötigt. Beide Protokolle ermöglichen es Benutzern, auf ein entferntes Postfach zuzugreifen. IMAP bietet gegenüber POP einige Vorteiler. Dazu zählt die Fähigkeit eine Kopie aller Nachrichten auf einem entfernten Server zu speichern, sowie gleichzeitig ablaufende Aktualisierungen. IMAP kann auch über langsame Verbindungen nützlich sein, da nicht gleich die komplette Nachricht heruntergeladen wird. Weiterhin können E-Mails auf dem Server durchsucht werden, was den Datenverkehr zwischen Clients und dem Server minimiert.</p></div><div class=paragraph><p>Die Ports-Sammlung enthält einige POP- und IMAP-Server, darunter <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/imap-uw/>mail/imap-uw</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/courier-imap/>mail/courier-imap</a> und <a class=package href=https://cgit.freebsd.org/ports/tree/mail/dovecot2/>mail/dovecot2</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Beachten Sie, dass sowohl POP als auch IMAP Daten, wie den Benutzernamen und das Passwort, im Klartext übertragen. Um die Übermittlung von Daten über diese Protokolle zu schützen, können Sie Sitzungen über <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> (<a href=./#security-ssh-tunneling>SSH-Tunnel</a>) tunneln oder SSL (<a href=./#openssl>OpenSSL</a>) verwenden.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>Domain Name System (DNS)</dt><dd><p>Das Domain Name System (DNS) und sein Daemon <code>named</code> spielen eine große Rolle bei der Auslieferung von E-Mails. Um E-Mails auszuliefern, fragt der MTA im DNS den Rechner ab, der E-Mails für das Zielsystem entgegennimmt. Der gleiche Vorgang läuft ab, wenn eine E-Mail von einem entfernten Server zum MTA zugestellt wird.</p><div class=paragraph><p>Im DNS werden Rechnernamen auf IP-Adressen abgebildet. Daneben werden spezielle Informationen für das Mail-System gespeichert, die <em>MX-Einträge</em> (MX record) genannt werden. Der MX-Eintrag (von Mail eXchanger) gibt an, welche Rechner E-Mails für eine Domäne annehmen.</p></div><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=host&amp;sektion=1&amp;format=html">host(1)</a> können die MX-Einträge für eine Domäne abgefragt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># host -t mx FreeBSD.org</span>
FreeBSD.org mail is handled by 10 mx1.FreeBSD.org</code></pre></div></div><div class=paragraph><p>Weitere Informationen zu DNS und dessen Konfiguration finden Sie im <a href=./#network-dns>Domain Name System (DNS)</a>.</p></div></dd></dl></div></div><div class=sect2><h3 id=sendmail>51.4. Sendmail-Konfigurationsdateien<a class=anchor href=#sendmail></a></h3><div class=paragraph><p>Sendmail ist der standardmäßig in FreeBSD installierte MTA. Es nimmt E-Mails von E-Mail-Benutzerprogrammen (MUA) entgegen und liefert diese zu den entsprechenden Mail Hosts, die in der Konfigurationsdatei definiert sind. Sendmail kann auch Netzwerkverbindungen annehmen und E-Mails an lokale <em>Mailboxen</em>, oder an andere Programme ausliefern.</p></div><div class=paragraph><p>Die Konfigurationsdateien von Sendmail befinden sich in <span class=filename>/etc/mail</span>. In diesem Abschnitt werden diese Dateien im Detail beschrieben.</p></div><div class=dlist><dl><dt class=hdlist1><span class=filename>/etc/mail/access</span></dt><dd><p>Diese Datenbank bestimmt, welche Rechner oder IP-Adressen Zugriff auf den lokalen Mail-Server haben und welche Art von Zugriff ihnen gestattet wird. Rechner die als <code>OK</code> aufgelistet sind, was der Standard ist, sind berechtigt E-Mails zu diesem Rechner zu schicken, solange die endgültige Zieladresse der lokale Rechner ist. Rechner die als <code>REJECT</code> aufgelistet sind, werden abgelehnt. Rechner die als <code>RELAY</code> aufgelistet sind, wird es erlaubt Post für jede Zieladresse durch diesen Mail-Server zu senden. Rechner die als <code>ERROR</code> aufgelistet sind, bekommen ihre E-Mail mit einem speziellen Fehler zurück. Wenn ein Rechner als <code>SKIP</code> aufgelistet ist, wird Sendmail die aktuelle Suche abbrechen, ohne die E-Mail zu akzeptieren oder abzulehnen. E-Mails von Rechnern die als <code>QUARANTAINE</code> aufgelistet sind, werden vorerst zurückgehalten. Dem sendenden Rechner wird ein festgelegter Text als Grund für die Quarantäne zurückgeschickt.</p><div class=paragraph><p>Beispiele für die Verwendung dieser Optionen für IPv4- und IPv6-Adressen finden Sie in der Beispielkonfiguration <span class=filename>/etc/mail/access.sample</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
# Mail relay access control list.  Default is to reject mail unless the
# destination is local, or listed in /etc/mail/local-host-names
#
## Examples (commented out for safety)
#From:cyberspammer.com          ERROR:&#34;550 We don&#39;t accept mail from spammers&#34;
#From:okay.cyberspammer.com     OK
#Connect:sendmail.org           RELAY
#To:sendmail.org                RELAY
#Connect:128.32                 RELAY
#Connect:128.32.2               SKIP
#Connect:IPv6:1:2:3:4:5:6:7     RELAY
#Connect:suspicious.example.com QUARANTINE:Mail from suspicious host
#Connect:[127.0.0.3]            OK
#Connect:[IPv6:1:2:3:4:5:6:7:8] OK</pre></div></div><div class=paragraph><p>Um die Datenbank zu konfigurieren, verwenden Sie das im Beispiel gezeigte Format, um Einträge in <span class=filename>/etc/mail/access</span> hinzuzufügen, aber setzen Sie kein Kommentarsymbol (<code>#</code>) vor die Einträge. Erstellen Sie einen Eintrag für jeden Rechner, dessen Zugriff konfiguriert werden soll. E-Mail-Versender, die mit der linken Spalte der Tabelle übereinstimmen, sind betroffen von der Aktion in der rechten Spalte.</p></div><div class=paragraph><p>Immer wenn diese Datei verändert wurde, muss die Datenbank aktualisiert und Sendmail neu gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># makemap hash /etc/mail/access &lt; /etc/mail/access</span>
<span class=c># service sendmail restart</span></code></pre></div></div></dd><dt class=hdlist1><span class=filename>/etc/mail/aliases</span></dt><dd><p>Diese Datenbank enthält eine Liste der virtuellen Mailboxen, die in andere Benutzer, Dateien, Programme oder andere Aliase expandiert werden. Hier sind ein paar Beispiele, die das Dateiformat verdeutlichen:</p><div class="literalblock programlisting"><div class=content><pre>root: localuser
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: &#34;|/usr/local/bin/procmail&#34;</pre></div></div><div class=paragraph><p>Der Name der Mailbox auf der linken Seite des Doppelpunkts wird mit den Zielen auf der rechten Seite ersetzt. Der erste Eintrag ersetzt die Mailbox <code>root</code> mit der Mailbox <code>localuser</code>, die dann in der Datenbank <span class=filename>/etc/mail/aliases</span> gesucht wird. Wird kein passender Eintrag gefunden, wird die Nachricht zum <code>localuser</code> geliefert. Der zweite Eintrag zeigt eine E-Mail-Verteilerliste. E-Mails an <code>ftp-bugs</code> werden zu den drei lokalen Mailboxen <code>joe</code>, <code>eric</code> und <code>paul</code> gesendet. Eine entfernte Mailbox kann auch als <em>user@example.com</em> angegeben werden. Der dritte Eintrag zeigt wie E-Mails in eine Datei geschrieben werden, in diesem Fall <span class=filename>/dev/null</span>. Der letzte Eintrag verdeutlicht das Senden von E-Mails an ein Programm. Hier wird die Nachricht über eine UNIX® Pipe an <span class=filename>/usr/local/bin/procmail</span> gesendet. Weitere Informationen zu dem Format dieser Datei finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=aliases&amp;sektion=5&amp;format=html">aliases(5)</a>.</p></div><div class=paragraph><p>Wenn diese Datei geändert wird, muss <code>newaliases</code> ausgeführt werden, um die Datenbank zu aktualisieren.</p></div></dd><dt class=hdlist1><span class=filename>/etc/mail/sendmail.cf</span></dt><dd><p>Dies ist die Hauptkonfigurations-Datei von Sendmail. Sie kontrolliert das allgemeine Verhalten von Sendmail, einschließlich allem vom Umschreiben von E-Mail Adressen bis hin zum Übertragen von Ablehnungsnachrichten an entfernte E-Mail-Server. Dementsprechend ist die Konfigurationsdatei ziemlich komplex. Glücklicherweise muss diese Datei selten für Standard E-Mail-Server geändert werden.</p><div class=paragraph><p>Die Sendmail Hauptkonfigurationsdatei kann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> Makros erstellt werden, die Eigenschaften und Verhalten von Sendmail definieren. Einige der Details finden Sie in <span class=filename>/usr/src/contrib/sendmail/cf/README</span>.</p></div><div class=paragraph><p>Wenn Änderungen an dieser Datei vorgenommen werden, muss Sendmail neu gestartet werden, damit die Änderungen Wirkung zeigen.</p></div></dd><dt class=hdlist1><span class=filename>/etc/mail/virtusertable</span></dt><dd><p>Diese Datenbank ordnet Adressen für virtuelle Domänen und Benutzern reellen Mailboxen zu. Diese Mailboxen können lokal, auf entfernten Systemen, Aliase in <span class=filename>/etc/mail/aliases</span> oder eine Datei sein. Dadurch können mehrere virtuelle Domains auf einem Rechner gehostet werden.</p><div class=paragraph><p>FreeBSD enthält eine Beispielkonfiguration in <span class=filename>/etc/mail/virtusertable.sample</span>, die das Format genauer beschreibt. Das folgende Beispiel zeigt, wie benutzerdefinierte Einträge in diesem Format erstellt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>root@example.com                root
postmaster@example.com          postmaster@noc.example.net
@example.com                    joe</pre></div></div><div class=paragraph><p>Diese Datei wird nach dem ersten übereinstimmenden Eintrag durchsucht. Wenn eine E-Mail-Adresse mit der Adresse auf der linken Seite übereinstimmt, wird sie dem Eintrag auf der rechten Seite zugeordnet. Der erste Eintrag in diesem Beispiel ordnet eine bestimmte E-Mail-Adresse einer lokalen Mailbox zu, während der zweite Eintrag eine bestimmte E-Mail-Adresse einer entfernten Mailbox zuordnet. Zuletzt wird jede E-Mail-Adresse von <code>example.com</code>, welche nicht mit einem der vorherigen Einträge übereinstimmt, mit dem letzten Eintrag übereinstimmen und der lokalen Mailbox <code>joe</code> zugeordnet. Benutzen Sie dieses Format, wenn Sie neue Einträge in <span class=filename>/etc/mail/virtusertable</span> hinzufügen. Jedes Mal, wenn diese Datei bearbeitet wurde, muss die Datenbank aktualisiert und Sendmail neu gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># makemap hash /etc/mail/virtusertable &lt; /etc/mail/virusertable</span>
<span class=c># service sendmail restart</span></code></pre></div></div></dd><dt class=hdlist1><span class=filename>/etc/mail/relay-domains</span></dt><dd><p>In der standardmäßigen FreeBSD-Installation wird Sendmail nur dazu konfiguriert, E-Mails von dem Rechner, auf dem es läuft, zu senden. Wenn zum Beispiel ein POP-Server installiert ist, können Benutzer ihre E-Mails von entfernten Standorten überprüfen. Sie werden jedoch keine E-Mails von außen verschicken können. Typischerweise wird ein paar Sekunden nach dem Versuch eine E-Mail von MAILER-DAEMON mit einer <code>5.7 Relaying Denied</code> Fehlermeldung versendet werden.</p><div class=paragraph><p>Die einfachste Lösung ist, wie im folgenden Beispiel gezeigt, den FQDN des Internet-Dienstanbieters und gegebenenfalls weitere Adressen in <span class=filename>/etc/mail/relay-domains</span> einzutragen:</p></div><div class="literalblock programlisting"><div class=content><pre>your.isq.example.com
other.isp.example.net
users.isp.example.org
www.example.org</pre></div></div><div class=paragraph><p>Nachdem diese Datei erstellt oder editiert wurde, muss Sendmail mittels <code>service sendmail restart</code> neu gestartet werden.</p></div><div class=paragraph><p>Ab jetzt wird jede E-Mail, die von einem in der Liste eingetragenen Rechner durch das System geschickt wird, ihr Ziel erreichen, vorausgesetzt der Benutzer hat einen Account auf dem System. Dies erlaubt es Benutzern aus der Ferne, E-Mails über das System zu versenden, ohne dem Massenversand (SPAM) die Tür zu öffnen.</p></div></dd></dl></div></div><div class=sect2><h3 id=mail-changingmta>51.5. Wechseln des Mailübertragungs-Agenten<a class=anchor href=#mail-changingmta></a></h3><div class=paragraph><p>FreeBSD enthält mit Sendmail bereits einen MTA, der für die ein- und ausgehenden E-Mails verantwortlich ist. Der Systemadministrator kann aber den MTA des Systems wechseln. Eine große Auswahl an alternativen MTAs ist in der Kategorie <code>mail</code> der FreeBSD Ports-Sammlung verfügbar.</p></div><div class=paragraph><p>Sobald ein neuer MTA installiert ist, können Sie die neue Software konfigurieren und testen, bevor Sie Sendmail ersetzen. Informationen über die Konfiguration des neu gewählten MTA finden Sie in der dazugehörigen Dokumentation.</p></div><div class=paragraph><p>Sobald der neue MTA wie gewünscht funktioniert, benutzen Sie die Anweisungen in diesem Abschnitt, um Sendmail zu deaktivieren und stattdessen den neuen MTA zu verwenden.</p></div><div class=sect3><h4 id=mail-disable-sendmail>51.5.1. Sendmail deaktivieren<a class=anchor href=#mail-disable-sendmail></a></h4><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Wenn der ausgehende Mail-Dienst von Sendmail deaktiviert ist, muss für den E-Mail-Versand ein alternatives System installiert werden. Andernfalls sind Systemfunktionen wie <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> nicht mehr in der Lage, ihre Resulate und Meldungen als E-Mail zu versenden. Aber auch viele andere Teile des Systems erwarten einen funktionalen MTA. Sind Programme auf die deaktivierten Sendmail-Binärdateien angewiesen, landen deren E-Mails ansonsten in einer inaktiven Sendmail-Warteschlange und können nicht ausgeliefert werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um Sendmail komplett zu deaktivieren, müssen folgende Zeilen in <span class=filename>/etc/rc.conf</span> hinzugefügt oder editiert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;
sendmail_submit_enable=&#34;NO&#34;
sendmail_outbound_enable=&#34;NO&#34;
sendmail_msp_queue_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Um lediglich die Funktion zum Empfang von E-Mails durch Sendmail zu deaktivieren, muss folgender Eintrag in <span class=filename>/etc/rc.conf</span> gesetzt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Weitere Informationen zu den Startoptionen von Sendmail finden Sie in der Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.sendmail&amp;sektion=8&amp;format=html">rc.sendmail(8)</a>.</p></div></div><div class=sect3><h4 id=_den_voreingestellten_mta_ersetzen>51.5.2. Den voreingestellten MTA ersetzen<a class=anchor href=#_den_voreingestellten_mta_ersetzen></a></h4><div class=paragraph><p>Wenn ein neuer MTA über die Ports-Sammlung installiert wird, werden auch die Startskripten installiert. Die Anweisungen zum starten dieser Skripte werden in den Paketnachrichten erwähnt. Bevor Sie den neuen MTA in Betrieb nehmen, stoppen Sie alle laufenden Sendmail-Prozesse. In diesem Beispiel werden alle notwendigen Dienste gestoppt und danach der Postfix Dienst gestartet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sendmail stop</span>
<span class=c># service postfix start</span></code></pre></div></div><div class=paragraph><p>Damit der angegebene MTA automatisch beim Hochfahren des Systems gestartet wird, fügen Sie dessen Konfigurationszeile in <span class=filename>/etc/rc.conf</span> hinzu. Dieser Eintrag startet den PostfixMTA:</p></div><div class="literalblock programlisting"><div class=content><pre>postfix_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Da Sendmail allgegenwärtig ist und manche Anwendungen einfach davon ausgehen es bereits installiert und konfiguriert, wird einige zusätzliche Konfiguration benötigt. Überprüfen Sie <span class=filename>/etc/periodic.conf</span> und stellen Sie sicher, dass diese Werte auf <code>NO</code> gesetzt werden. Wenn die Datei nicht existiert, erstellen Sie sie mit folgenden Einträgen:</p></div><div class="literalblock programlisting"><div class=content><pre>daily_clean_hoststat_enable=&#34;NO&#34;
daily_status_mail_enable=&#34;NO&#34;
daily_status_include_submit_mailq=&#34;NO&#34;
daily_submit_queuerun=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Viele alternative MTAs stellen ihre eigenen kompatiblen Implementierungen der Sendmail Kommandozeilen-Schnittstelle zur Verfügung, was die Verwendung als "drop-in" Ersatz für Sendmail vereinfacht. Allerdings versuchen einige MUAs Sendmails Standard-Dateien auszuführen, anstelle der Dateien des neuen MTAs. FreeBSD verwendet <span class=filename>/etc/mail/mailer.conf</span> um die erwarteten Sendmail Dateien auf die neuen Dateien abzubilden. Weitere Informationen über diese Zuordnungen können in <a href="https://man.freebsd.org/cgi/man.cgi?query=mailwrapper&amp;sektion=8&amp;format=html">mailwrapper(8)</a> gefunden werden.</p></div><div class=paragraph><p>In der Voreinstellung sieht <span class=filename>/etc/mail/mailer.conf</span> wie folgt aus:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
# Execute the &#34;real&#34; sendmail program, named /usr/libexec/sendmail/sendmail
#
sendmail        /usr/libexec/sendmail/sendmail
send-mail       /usr/libexec/sendmail/sendmail
mailq           /usr/libexec/sendmail/sendmail
newaliases      /usr/libexec/sendmail/sendmail
hoststat        /usr/libexec/sendmail/sendmail
purgestat       /usr/libexec/sendmail/sendmail</pre></div></div><div class=paragraph><p>Wenn eines der Kommandos auf der linken Seite ausgeführt werden soll, führt das System tatsächlich den damit verbundenen Befehl auf der rechten Seite aus. Mit diesem System lassen sich Programme, die für die Sendmail-Funktionen gestartet werden, leicht ändern.</p></div><div class=paragraph><p>Einige MTAs aus der Ports-Sammlung können diese Datei aktualisieren. Zum Beispiel würde Postfix die Datei wie folgt aktualisieren:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Execute the Postfix sendmail program, named /usr/local/sbin/sendmail
#
sendmail        /usr/local/sbin/sendmail
send-mail       /usr/local/sbin/sendmail
mailq           /usr/local/sbin/sendmail
newaliases      /usr/local/sbin/sendmail</pre></div></div><div class=paragraph><p>Falls die Installation des MTA nicht automatisch <span class=filename>/etc/mail/mailer.conf</span> aktualisiert, bearbeiten Sie diese Datei in einem Texteditor, so dass auf die neuen Dateien verwiesen wird. Dieses Beispiel zeigt auf die Dateien, die von <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> installiert wurden:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail        /usr/local/sbin/ssmtp
send-mail       /usr/local/sbin/ssmtp
mailq           /usr/local/sbin/ssmtp
newaliases      /usr/local/sbin/ssmtp
hoststat        /usr/bin/true
purgestat       /usr/bin/true</pre></div></div><div class=paragraph><p>Sobald alles konfiguriert ist, wird empfohlen, das System neu zu starten. Ein Neustart bietet auch die Möglichkeit sicherzustellen, dass das System korrekt konfiguriert wurde, um den neuen MTA automatisch beim Hochfahren zu starten.</p></div></div></div><div class=sect2><h3 id=mail-trouble>51.6. Fehlerbehebung<a class=anchor href=#mail-trouble></a></h3><div class=paragraph><p>Hier finden sich ein paar häufig gestellte Fragen und ihre Antworten, die von der <a href=https://docs.freebsd.org/de/books/faq/>FAQ</a> übernommen wurden.</p></div><div class=sect3><h4 id=_warum_muss_ich_einen_fqdn_fully_qualified_domain_name_voll_ausgeschriebenen_domänennamen_für_meine_rechner_verwenden>51.6.1. Warum muss ich einen FQDN (fully-qualified domain name / voll ausgeschriebenen Domänennamen) für meine Rechner verwenden?<a class=anchor href=#_warum_muss_ich_einen_fqdn_fully_qualified_domain_name_voll_ausgeschriebenen_domänennamen_für_meine_rechner_verwenden></a></h4><div class=paragraph><p>Vielleicht befindet sich der Rechner in einer anderen Domäne. Um beispielsweise von einem Rechner in <code>foo.bar.edu</code> einen Rechner namens <code>mumble</code> in der Domäne <code>foo.bar.edu</code> zu erreichen, geben Sie seinen voll ausgeschriebenen Domänennamen (FQDN) <code>mumble.bar.edu</code>, anstelle von <code>mumble</code> an.</p></div><div class=paragraph><p>Das liegt daran, dass die aktuelle Version von BIND, die mit FreeBSD ausgeliefert wird, keine Standardabkürzungen für nicht komplett angegebene Domänennamen außerhalb der lokalen Domäne unterstützt. Daher muss ein nicht-qualifizierter Rechner, wie <code>mumble</code>, entweder als <code>mumble.foo.bar.edu</code> gefunden werden, oder er wird in der root Domäne gesucht.</p></div><div class=paragraph><p>In älteren Versionen von BIND lief die Suche über <code>mumble.bar.edu</code> und <code>mumble.edu</code>. RFC 1535 erklärt, warum dieses Verhalten als schlechte Praxis oder sogar als Sicherheitsloch angesehen wird.</p></div><div class=paragraph><p>Um das zu umgehen, setzen Sie die Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>search foo.bar.edu bar.edu</pre></div></div><div class=paragraph><p>anstatt der vorherigen</p></div><div class="literalblock programlisting"><div class=content><pre>domain foo.bar.edu</pre></div></div><div class=paragraph><p>in <span class=filename>/etc/resolv.conf</span> ein. Stellen Sie jedoch sicher, dass die Suchordnung nicht die Begrenzung von "lokaler und öffentlicher Administration", wie RFC 1535 sie nennt, überschreitet.</p></div></div><div class=sect3><h4 id=_wie_kann_ich_einen_e_mail_server_auf_einem_anwahl_ppp_rechner_betreiben>51.6.2. Wie kann ich einen E-Mail-Server auf einem Anwahl-PPP Rechner betreiben?<a class=anchor href=#_wie_kann_ich_einen_e_mail_server_auf_einem_anwahl_ppp_rechner_betreiben></a></h4><div class=paragraph><p>Sie wollen sich mit einem FreeBSD E-Mail Gateway im LAN verbinden. Die PPP-Verbindung ist keine Standleitung.</p></div><div class=paragraph><p>Ein Weg dies zu tun ist, von einem immer mit dem Internet verbundenen Server einen sekundären MX-Dienst für die Domäne zur Verfügung gestellt zu bekommen. In diesem Beispiel heißt die Domäne <code>example.com</code>, und der Internet-Dienstanbieter hat <code>example.net</code> so eingestellt, dass er für die Domäne einen sekundären MX-Dienst zur Verfügung stellt:</p></div><div class="literalblock programlisting"><div class=content><pre>example.com.            MX        10      bigco.com.
	                MX        20      example.net.</pre></div></div><div class=paragraph><p>Nur ein Rechner sollte als Endempfänger angegeben sein. Sendmail fügen Sie <code>Cw example.com</code> zu <span class=filename>/etc/sendmail.cf</span> auf <code>example.com</code> hinzu.</p></div><div class=paragraph><p>Wenn der MTA des Versenders versucht die E-Mail zuzustellen, wird es versuchen das System <code>example.com</code> über die PPP-Verbindung zu erreichen. Es kommt zu einer Zeitüberschreitung, wenn das Zielsystem offline ist. Der MTA wird die E-Mail automatisch der sekundären MX-Seite des Internet-Providers <code>example.net</code> zustellen. Die sekundäre MX-Seite wird periodisch versuchen, eine Verbindung zur primären MX-Seite <code>example.com</code> aufzubauen.</p></div><div class=paragraph><p>Verwenden Sie etwas wie dies als Login-Skript:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Put me in /usr/local/bin/pppmyisp
( sleep 60 ; /usr/sbin/sendmail -q ) &amp;
/usr/sbin/ppp -direct pppmyisp</pre></div></div><div class=paragraph><p>Wenn Sie ein separates Login-Skript für einen Benutzer erstellen, benutzen Sie stattdessen <code>sendmail -qRexample.com</code> in dem oben gezeigten Skript. Das erzwingt die sofortige Verarbeitung der E-Mails in der Warteschlange für <code>example.com</code></p></div><div class=paragraph><p>Eine weitere Verfeinerung der Situation kann an diesem Beispiel von <a href=https://lists.FreeBSD.org/subscription/freebsd-isp>FreeBSD Internet service providers</a> entnommen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>&gt; wir stellen einem Kunden den sekundären MX zur Verfügung.
&gt; Der Kunde verbindet sich mit unseren Diensten mehrmals am Tag
&gt; automatisch um die E-Mails zu seinem primären MX zu holen
&gt; (wir wählen uns nicht bei ihm ein, wenn E-Mails für seine
&gt; Domäne eintreffen).  Unser sendmail sendet den Inhalt der
&gt; E-Mail-Warteschlange alle 30 Minuten.  Momentan muss er 30 Minuten
&gt; eingewählt bleiben um sicher zu sein, dass alle seine E-Mails
&gt; beim primären MX eingetroffen sind.
&gt;
&gt; Gibt es einen Befehl, der sendmail dazu bringt, alle E-Mails sofort
&gt; zu senden? Der Benutzer hat natürlich keine root-Rechte auf
&gt; unserer Maschine.

In der privacy flags Sektion von sendmail.cf befindet sich die
Definition Opgoaway,restrictqrun

Entferne restrictqrun um nicht-root Benutzern zu erlauben, die Verarbeitung
der Nachrichten-Warteschlangen zu starten.  Möglicherweise willst du
auch die MX neu sortieren.  Wir sind der primäre MX für unsere
Kunden mit diesen Wünschen und haben definiert:

# Wenn wir der beste MX für einen Rechner sind, versuche es direkt
# anstatt einen lokalen Konfigurationsfehler zu generieren.
OwTrue

Auf diesem Weg liefern Gegenstellen direkt zu dir, ohne die Kundenverbindung
zu versuchen.  Dann sendest du zu deinem Kunden.  Das funktioniert nur
für Rechner, du musst also deinen Kunden dazu bringen,
ihre E-Mail Maschine customer.com zu nennen, sowie
hostname.customer.com im DNS.  Setze einfach einen A-Eintrag
in den DNS für customer.com.</pre></div></div></div></div><div class=sect2><h3 id=mail-advanced>51.7. Weiterführende Themen<a class=anchor href=#mail-advanced></a></h3><div class=paragraph><p>Dieser Abschnitt behandelt kompliziertere Themen wie E-Mail-Konfiguration und Einrichtung von E-Mail für eine ganze Domäne.</p></div><div class=sect3><h4 id=mail-config>51.7.1. Grundlegende Konfiguration<a class=anchor href=#mail-config></a></h4><div class=paragraph><p>Mit der Software im Auslieferungszustand sollte es möglich sein, E-Mails an externe Rechner zu senden, vorausgesetzt <span class=filename>/etc/resolv.conf</span> ist konfiguriert, oder das Netzwerk hat Zugriff auf einen konfigurierten DNS-Server. Um E-Mails an den MTA auf dem Rechner auszuliefern, stehen zwei Möglichkeiten zur Auswahl:</p></div><div class=ulist><ul><li><p>Betreiben Sie einen DNS-Server für die Domäne.</p></li><li><p>Lassen Sie die E-Mails direkt über den FQDN des Rechners ausliefern.</p></li></ul></div><div class=paragraph><p>Um E-Mails direkt zu einem Rechner geliefert zu bekommen, wird eine permanente statische IP-Adresse (keine dynamische IP-Adresse) benötigt. Befindet sich das System hinter einer Firewall, muss diese den SMTP-Verkehr weiterleiten. Um E-Mails direkt am Rechner zu empfangen, muss eines der folgenden Dinge konfiguriert werden:</p></div><div class=ulist><ul><li><p>Vergewissern Sie sich, dass der MX-Eintrag mit der kleinsten Nummer im DNS auf die statische IP-Adresse des Rechners zeigt.</p></li><li><p>Stellen Sie sicher, dass für den Rechner kein MX-Eintrag im DNS existiert.</p></li></ul></div><div class=paragraph><p>Jede der erwähnten Konfigurationsmöglichkeiten erlaubt es, E-Mails direkt auf dem Rechner zu empfangen.</p></div><div class=paragraph><p>Versuchen Sie das:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hostname</span>
example.FreeBSD.org

<span class=c># host example.FreeBSD.org</span>
example.FreeBSD.org has address 204.216.27.XX</code></pre></div></div><div class=paragraph><p>In diesem Beispiel sollte es funktionieren, E-Mails direkt an <a href=mailto:yourlogin@example.FreeBSD.org>yourlogin@example.FreeBSD.org</a> zu senden, vorausgesetzt dass Sendmail auf <code>example.FreeBSD.org</code> korrekt läuft.</p></div><div class=paragraph><p>In diesem Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># host example.FreeBSD.org</span>
example.FreeBSD.org has address 204.216.27.XX
example.FreeBSD.org mail is handled <span class=o>(</span><span class=nv>pri</span><span class=o>=</span>10<span class=o>)</span> by devnull.FreeBSD.org</code></pre></div></div><div class=paragraph><p>Hier wird jede an den Rechner <code>example.FreeBSD.org</code> gesandte E-Mail auf <code>hub</code> unter dem gleichen Benutzernamen gesammelt, anstatt diese direkt zu Ihrem Rechner zu senden.</p></div><div class=paragraph><p>Die obige Information wird von einem DNS-Server verwaltet. Der DNS-Eintrag, der die Information zum E-Mail-Routing enthält, ist der MX-Eintrag. Existiert kein MX-Eintrag, werden E-Mails direkt über die IP-Adresse an den Rechner geliefert.</p></div><div class=paragraph><p>Der MX-Eintrag für <code>freefall.FreeBSD.org</code> sah einmal so aus:</p></div><div class="literalblock programlisting"><div class=content><pre>freefall		MX	30	mail.crl.net
freefall		MX	40	agora.rdrop.com
freefall		MX	10	freefall.FreeBSD.org
freefall		MX	20	who.cdrom.com</pre></div></div><div class=paragraph><p><code>freefall</code> hatte viele MX-Einträge. Die kleinste MX-Nummer definiert de Rechner, der die E-Mails direkt empfängt, wobei die anderen Rechner temporär E-Mails in Warteschlangen einreihen, falls <code>freefall</code> beschäftigt oder unerreichbar ist.</p></div><div class=paragraph><p>Es ist sehr sinnvoll, dass stellvertretende MX-Seiten separate Internet-Verbindungen verwenden. Ihr ISP kann diesen Dienst zur Verfügung stellen.</p></div></div><div class=sect3><h4 id=mail-domain>51.7.2. E-Mails für eine Domäne<a class=anchor href=#mail-domain></a></h4><div class=paragraph><p>Wird ein MTA für ein Netzwerk konfiguriert, dann sollte jede E-Mail die an einen Rechner in dieser Domäne geschickt wird, an den MTA umgeleitet werden, damit die Benutzer ihre E-Mails vom zentralen Mail-Server empfangen können.</p></div><div class=paragraph><p>Am einfachsten ist es, wenn Accounts mit gleichen <em>Benutzernamen</em> sowohl auf dem MTA, als auch auf dem System mit dem MUA existieren. Verwenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a>, um Benutzerkonten anzulegen.</p></div><div class=paragraph><p>Der MTA muss auf jeder Workstation im Netzwerk als der zuständige Rechner für den E-Mail-Austausch gekennzeichnet werden. Dies wird in der DNS-Konfiguration über den MX-Eintrag gesteuert:</p></div><div class="literalblock programlisting"><div class=content><pre>example.FreeBSD.org	A	204.216.27.XX		; Workstation
			MX	10 devnull.FreeBSD.org	; Mailhost</pre></div></div><div class=paragraph><p>Diese Einstellung wird E-Mails für die Workstations zum MTA weiterleiten, egal wo der A-Eintrag hinzeigt. Die E-Mails werden zum MX-Rechner gesendet.</p></div><div class=paragraph><p>Diese Einstellung muss auf dem DNS-Server konfiguriert werden. Besitzt das Netzwerk keinen eigenen DNS-Server, kontaktieren Sie Ihren ISP oder DNS-Verwalter.</p></div><div class=paragraph><p>Im Folgenden ist ein Beispiel für virtuelles E-Mail-Hosting. Nehmen wir an, dass für einen Kunden mit der Domäne <code>customer1.org</code>, alle E-Mails für <code>customer1.org</code> an <code>mail.myhost.com</code> gesendet werden sollen. Der entsprechende DNS-Eintrag sollte wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>customer1.org		MX	10	mail.myhost.com</pre></div></div><div class=paragraph><p>Wenn für die Domäne nur E-Mails verarbeitet werden sollen, wird für <code>customer1.org</code> <em>kein</em> <code>A</code>-Eintrag benötigt. Allerdings wird ein <code>ping</code> gegen <code>customer1.org</code> nur dann funktionieren, wenn ein <code>A</code>-Eintrag existiert.</p></div><div class=paragraph><p>Teilen Sie dem MTA mit, für welche Domänen bzw. Hostnamen Post entgegengenommen werden soll. Die beiden folgenden Methoden funktionieren für Sendmail:</p></div><div class=ulist><ul><li><p>Fügen Sie die Rechnernamen in <span class=filename>/etc/mail/local-host-names</span> hinzu, wenn <code>FEATURE(use_cw_file)</code> verwendet wird.</p></li><li><p>Fügen Sie eine Zeile <code>Cwyour.host.com</code> in <span class=filename>/etc/sendmail.cf</span> hinzu.</p></li></ul></div></div></div><div class=sect2><h3 id=outgoing-only>51.8. Ausgehende E-Mail über einen Relay versenden<a class=anchor href=#outgoing-only></a></h3><div class=paragraph><p>In vielen Fällen möchte man E-Mail nur über einen Relay verschicken. Zum Beispiel:</p></div><div class=ulist><ul><li><p>Der Rechner ist ein Arbeitsplatzrechner und benutzt Programme wie <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> über ein Relay des ISP.</p></li><li><p>Ein Server, der E-Mails nicht selbst verarbeitet, soll alle E-Mails zu einem Relay schicken.</p></li></ul></div><div class=paragraph><p>Obwohl jeder MTA diese Aufgabe erfüllen kann, ist es oft schwierig einen vollwertigen MTA so zu konfigurieren, dass er lediglich ausgehende E-Mails weiterleitet. Es ist übertrieben, Programme wie Sendmail und Postfix nur für diesen Zweck einzusetzen.</p></div><div class=paragraph><p>Weiterhin kann es sein, dass die Bestimmungen des Internetzugangs es verbieten, einen eigenen Mail-Server zu betreiben.</p></div><div class=paragraph><p>Um die hier beschriebenen Anforderungen zu erfüllen, installieren Sie einfach den Port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/mail/ssmtp</span>
<span class=c># make install replace clean</span></code></pre></div></div><div class=paragraph><p>Nach der Installation kann <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> über <span class=filename>/usr/local/etc/ssmtp/ssmtp.conf</span> konfiguriert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>root=yourrealemail@example.com
mailhub=mail.example.com
rewriteDomain=example.com
hostname=_HOSTNAME_</pre></div></div><div class=paragraph><p>Verwenden Sie eine gültige E-Mail-Adresse für <code>root</code>. Geben Sie für <code>mail.example.com</code> den Mail-Relay des ISPs an. Einige ISPs nennen den Relay "Postausgangsserver" oder "SMTP-Server".</p></div><div class=paragraph><p>Deaktivieren Sie Sendmail, einschließlich des Services für den Postausgang. Details finden Sie in <a href=#mail-disable-sendmail>Sendmail deaktivieren</a>.</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> verfügt über weitere Optionen. Die Beispiele in <span class=filename>/usr/local/etc/ssmtp</span> oder die Manualpage von ssmtp enthalten weitere Informationen.</p></div><div class=paragraph><p>Wird ssmtp wie hier beschrieben eingerichtet, können Anwendungen E-Mails von dem lokalen Rechner verschicken. Man verstößt damit auch nicht gegen Bestimmungen des ISPs und läuft nicht Gefahr, dass der Rechner zum Versenden von Spam missbraucht wird.</p></div></div><div class=sect2><h3 id=SMTP-dialup>51.9. E-Mail über Einwahl-Verbindungen<a class=anchor href=#SMTP-dialup></a></h3><div class=paragraph><p>Wird eine feste IP-Adresse verwendet, müssen die Standardeinstellungen wahrscheinlich gar nicht geändert werden. Stellen Sie den Hostnamen auf den entsprechend zugeordneten Internetnamen ein und Sendmail übernimmt das Übrige.</p></div><div class=paragraph><p>Bei der Verwendung einer dynamisch zugewiesenen IP-Adresse und einer PPP-Wählverbindung mit dem Internet, hat man in der Regel ein Postfach auf dem Mailserver des ISP. In diesem Beispiel ist die Domäne des ISP <code>example.net</code>, der Benutzername ist <code>user</code>, der Rechnername ist <code>bsd.home</code> und der ISP erlaubt es, <code>relay.example.net</code> als Mail-Relayhost zu benutzen.</p></div><div class=paragraph><p>Um Mails aus der Mailbox des ISPs abzuholen, muss ein gesondertes Programm aus der Ports-Sammlung installiert werden. <a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a> ist eine gute Wahl, weil es viele verschiedene Protokolle unterstützt. Für gewöhnlich stellt der ISPPOP zur Verfügung. Falls User-PPP verwendet wird, können durch folgenden Eintrag in <span class=filename>/etc/ppp/ppp.linkup</span> E-Mails automatisch abgerufen werden, sobald eine Verbindung zum Netz aufgebaut wird:</p></div><div class="literalblock programlisting"><div class=content><pre>MYADDR:
!bg su user -c fetchmail</pre></div></div><div class=paragraph><p>Wird Sendmail benutzt, um E-Mails an nicht-lokale Benutzer zu versenden, konfigurieren Sie es so, dass die Warteschlange abgearbeitet wird, sobald eine Verbindung mit dem Internet besteht. Um dies zu erreichen, müssen folgende Zeilen nach dem <code>fetchmail</code>-Eintrag in <span class=filename>/etc/ppp/ppp.linkup</span> hinzugefügt werden.</p></div><div class="literalblock programlisting"><div class=content><pre>!bg su user -c &#34;sendmail -q&#34;</pre></div></div><div class=paragraph><p>In diesem Beispiel existiert auf <code>bsd.home</code> ein Benutzer <code>user</code>. Erstellen Sie auf <code>bsd.home</code> im Heimatverzeichnis von <code>user</code> die Datei <span class=filename>.fetchmailrc</span> mit folgender Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.net protocol pop3 fetchall pass MySecret;</pre></div></div><div class=paragraph><p>Diese Datei sollte für niemandem außer <code>user</code> lesbar sein, weil sie das Passwort <code>MySecret</code> enthält.</p></div><div class=paragraph><p>Um Mails mit dem richtigen <code>from:</code>-Header zu versenden, müssen Sie Sendmail so konfigurieren, dass es <a href=mailto:user@example.net>user@example.net</a> und nicht <a href=mailto:user@bsd.home>user@bsd.home</a> benutzen soll und das alle Mails über <code>relay.example.net</code> versendet werden, um eine schnellere Übertragung von Mails zu gewährleisten.</p></div><div class=paragraph><p>Die folgende <span class=filename>.mc</span> sollte ausreichen:</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`bsd.home.mc version 1.0&#39;)
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net&#39;)dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST&#39;, `relay.example.net&#39;)
Dmbsd.home
define(`confDOMAIN_NAME&#39;,`bsd.home&#39;)dnl
define(`confDELIVERY_MODE&#39;,`deferred&#39;)dnl</pre></div></div><div class=paragraph><p>Im vorherigen Abschnitt finden Sie Details dazu, wie Sie diese Datei in das Format <span class=filename>sendmail.cf</span> konvertieren können. Vergessen Sie nicht, Sendmail neu zu starten, nachdem <span class=filename>sendmail.cf</span> verändert wurde.</p></div></div><div class=sect2><h3 id=SMTP-Auth>51.10. SMTP-Authentifizierung<a class=anchor href=#SMTP-Auth></a></h3><div class=paragraph><p>Die Konfiguration von SMTP-Authentifizierung auf dem MTA bietet einige Vorteile. Die erforderliche Authentifizierung erhöht die Sicherheit von Sendmail und mobilen Benutzern, die auf entfernten Rechnern arbeiten. Diese Benutzer können denselben MTA verwenden, ohne jedes Mal das Benutzerprogramm neu konfigurieren zu müssen.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Installieren Sie <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2/>security/cyrus-sasl2</a> aus der Ports-Sammlung. Dieser Port verfügt über einige Optionen, die während der Übersetzung festgelegt werden. Für die in diesem Abschnitt beschriebene Methode zur SMTP-Authentifizierung muss die Option <code>LOGIN</code> aktiviert werden.</p></li><li><p>Nach der Installation von <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2/>security/cyrus-sasl2</a> editieren Sie <span class=filename>/usr/local/lib/sasl2/Sendmail.conf</span>. Erstellen Sie die Datei, wenn sie nicht existiert und fügen Sie die folgende Zeile hinzu:</p><div class="literalblock programlisting"><div class=content><pre>pwcheck_method: saslauthd</pre></div></div></li><li><p>Als nächstes installieren Sie <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2-saslauthd/>security/cyrus-sasl2-saslauthd</a>, und fügen die folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p><div class="literalblock programlisting"><div class=content><pre>saslauthd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Abschließend starten Sie den saslauthd-Dämon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service saslauthd start</span></code></pre></div></div><div class=paragraph><p>Dieser Dämon agiert als Broker zwischen Sendmail und der FreeBSD-<span class=filename>passwd</span>-Datenbank. Dadurch müssen zum Versenden von E-Mails keine zusätzlichen Accounts und Passwörter angelegt werden. Die Benutzer verwenden dasselbe Passwort zum Anmelden wie zum Verschicken von E-Mails.</p></div></li><li><p>Fügen Sie danach in <span class=filename>/etc/make.conf</span> die folgenden Zeilen hinzu:</p><div class="literalblock programlisting"><div class=content><pre>SENDMAIL_CFLAGS=-I/usr/local/include/sasl -DSASL
SENDMAIL_LDADD=/usr/local/lib/libsasl2.so</pre></div></div><div class=paragraph><p>Beim Übersetzen von Sendmail werden damit die <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl2/>cyrus-sasl2</a>-Bibliotheken benutzt. Stellen Sie daher vor dem Übersetzen von Sendmail sicher, dass <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl2/>cyrus-sasl2</a> installiert ist.</p></div></li><li><p>Übersetzen Sie Sendmail mit den nachstehenden Kommandos:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/lib/libsmutil</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make</span>
<span class=c># cd /usr/src/lib/libsm</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make</span>
<span class=c># cd /usr/src/usr.sbin/sendmail</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make &amp;&amp; make install</span></code></pre></div></div><div class=paragraph><p>Die Übersetzung sollte keine Probleme bereiten, wenn <span class=filename>/usr/src</span> nicht umfangreich verändert wurde und die benötigten Bibliotheken installiert sind.</p></div></li><li><p>Nachdem Sendmail übersetzt und installiert wurde, editieren Sie <span class=filename>/etc/mail/freebsd.mc</span> beziehungsweise die lokale <span class=filename>.mc</span>-Datei. Viele Administratoren verwenden die Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=hostname&amp;sektion=1&amp;format=html">hostname(1)</a>, um der <span class=filename>.mc</span> einen eindeutigen Namen zu geben. Fügen Sie die folgenden Zeilen hinzu:</p><div class="literalblock programlisting"><div class=content><pre>dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confAUTH_MECHANISMS&#39;, `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl</pre></div></div><div class=paragraph><p>Diese Anweisungen konfigurieren die Methoden, die Sendmail zur Authentifizierung von Benutzern verwendet. Lesen Sie die Sendmail Dokumentation, wenn eine andere Methode als <code>pwcheck</code> verwendet werden soll.</p></div></li><li><p>Abschließend rufen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> in <span class=filename>/etc/mail</span> auf. Damit wird aus der <span class=filename>.mc</span>-Datei eine neue <span class=filename>.cf</span>-Datei erzeugt. Der Name ist entweder <span class=filename>freebsd.cf</span> oder der Name der lokalen <span class=filename>.mc</span>-Datei. <code>make install restart</code> installiert die Datei nach <span class=filename>/etc/mail/sendmail.cf</span> und startet Sendmail neu. Weitere Informationen zu diesem Vorgang entnehmen Sie bitte <span class=filename>/etc/mail/Makefile</span>.</p></li></ol></div><div class=paragraph><p>Um die Konfiguration zu testen, verwenden Sie einen MUA, um eine Testnachricht zu senden. Mail-Benutzerprogramm das Passwort für die Authentifizierung ein und versenden Sie zum Testen eine E-Mail. Zur Fehlersuche, setzen Sie den <code>LogLevel</code> von Sendmail auf <code>13</code> und untersuchen die Fehlermeldungen in <span class=filename>/var/log/maillog</span>.</p></div><div class=paragraph><p>Weitere Information finden Sie unter <a href=http://www.sendmail.org/~ca/email/auth.html>SMTP-Authentifizierung</a>.</p></div></div><div class=sect2><h3 id=mail-agents>51.11. E-Mail-Programme<a class=anchor href=#mail-agents></a></h3><div class=paragraph><p>Anwendungen, die E-Mails versenden und empfangen, werden als E-Mail-Programme oder Mail-User-Agents (MUA) bezeichnet. Mit der Entwicklung und Ausbreitung von E-Mail wachsen auch die E-Mail-Programme und bieten Benutzern mehr Funktionen und höhere Flexibilität. Die Kategorie <code>mail</code> der FreeBSD Ports-Sammlung enthält zahlreiche E-Mail-Programme. Dazu gehören grafische Programme, wie beispielsweise Evolution oder Balsa und Konsolen basierte Programme wie mutt oder alpine.</p></div><div class=sect3><h4 id=mail-command>51.11.1. <code>mail</code><a class=anchor href=#mail-command></a></h4><div class=paragraph><p>Das standardmäßig unter FreeBSD installierte E-Mail-Programm ist <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>. Das Programm ist konsolenorientiert und enthält alle Funktionen, die zum Versand und Empfang textbasierter E-Mails erforderlich sind. Es bietet eine begrenzte Unterstützung für Anhänge und kann auf lokale Postfächer zugreifen.</p></div><div class=paragraph><p><code>mail</code> kann nicht direkt auf POP- oder IMAP-Server zugreifen. Entfernte Postfächer können aber mit einer Anwendung wie fetchmail in eine lokale <span class=filename>mbox</span> geladen werden.</p></div><div class=paragraph><p>Um E-Mails zu versenden oder zu empfangen, starten Sie einfach <code>mail</code> wie im nachstehenden Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail</code></pre></div></div><div class=paragraph><p><code>mail</code> liest automatisch den Inhalt des Benutzer-Postfachs im Verzeichnis <span class=filename>/var/mail</span>. Sollte das Postfach leer sein, beendet sich <code>mail</code> mit der Nachricht, dass keine E-Mails vorhanden sind. Wenn E-Mails vorhanden sind, wird die Benutzeroberfläche gestartet und eine Liste der E-Mails angezeigt. Die E-Mails werden automatisch nummeriert wie im folgenden Beispiel gezeigt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mail version 8.1 6/6/93.  Type ? <span class=k>for </span>help.
<span class=s2>&#34;/var/mail/marcs&#34;</span>: 3 messages 3 new
<span class=o>&gt;</span>N  1 root@localhost        Mon Mar  8 14:05  14/510   <span class=s2>&#34;test&#34;</span>
 N  2 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;user account&#34;</span>
 N  3 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;sample&#34;</span></code></pre></div></div><div class=paragraph><p>Einzelne Nachrichten können nun durch Eingabe von <kbd>t</kbd> gefolgt von der Nummer der Nachricht gelesen werden. Im nachstehenden Beispiel wird die erste E-Mail gelesen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp;
 t 1
Message 1:
From root@localhost  Mon Mar  8 14:05:52 2004
X-Original-To: marcs@localhost
Delivered-To: marcs@localhost
To: marcs@localhost
Subject: <span class=nb>test
</span>Date: Mon,  8 Mar 2004 14:05:52 +0200 <span class=o>(</span>SAST<span class=o>)</span>
From: root@localhost <span class=o>(</span>Charlie Root<span class=o>)</span>

Das ist eine Test-Nachricht.  Antworte bitte!</code></pre></div></div><div class=paragraph><p>Wie in diesem Beispiel zu sehen ist, wird die Nachricht zusammen mit dem vollständigen Nachrichtenkopf angezeigt. Um die Liste der E-Mails erneut zu sehen, drücken Sie wieder die Taste <kbd>h</kbd>.</p></div><div class=paragraph><p>Um auf eine E-Mail zu antworten, benutzen Sie entweder <kbd>R</kbd> oder <kbd>r</kbd>. <kbd>R</kbd> weist <code>mail</code> an, dem Versender der Nachricht zu antworten, während mit <kbd>r</kbd> allen Empfängern der Nachricht geantwortet wird. Den Kommandos kann die Zahl der E-Mail, auf die geantwortet werden soll, mitgegeben werden. Nachdem die Antwort E-Mail verfasst worden ist, sollte die Eingabe mit einem einzelnen Punkt (<kbd>.</kbd>) auf einer neuen Zeile abgeschlossen werden. Hierzu ein Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp;
 R 1
To: root@localhost
Subject: Re: <span class=nb>test
 </span>Danke, ich habe deine E-Mail erhalten.
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>Neue E-Mails können mit <kbd>m</kbd>, gefolgt von der E-Mail-Adresse des Empfängers verschickt werden. Mehrere Empfänger werden durch Kommata (<kbd>,</kbd>) getrennt, angegeben. Der Betreff (subject) der Nachricht kann dann, gefolgt vom Inhalt der Nachricht eingegeben werden. Die Nachricht wird dann mit einem einzelnen Punkt (<kbd>.</kbd>) auf einer neuen Zeile abgeschlossen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp;
 mail root@localhost
Subject:
 Ich habe die E-Mails im Griff!

Jetzt kann ich E-Mails versenden und empfangen ... :<span class=o>)</span>
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>Die Taste <kbd>?</kbd> zeigt zu jeder Zeit einen Hilfetext an. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>, wenn Sie weitere Hilfe zur Benutzung von <code>mail</code> erhalten möchten.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> wurde nicht für den Umgang mit Anhängen entworfen und kann daher sehr schlecht mit Anhängen umgehen. Neuere MUAs gehen wesentlich besser mit Anhängen um. Benutzer, die <code>mail</code> bevorzugen, werden vielleicht den Port <a class=package href=https://cgit.freebsd.org/ports/tree/converters/mpack/>converters/mpack</a> zu schätzen wissen.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mutt-command>51.11.2. mutt<a class=anchor href=#mutt-command></a></h4><div class=paragraph><p>mutt ist ein leistungsfähiges E-Mail-Programm mit vielen Funktionen, darunter:</p></div><div class=ulist><ul><li><p>mutt kann den Verlauf einer Diskussion (threading) darstellen.</p></li><li><p>Unterstützung von PGP für das digitale signieren und verschlüsseln von E-Mail.</p></li><li><p>MIME-Unterstützung.</p></li><li><p>Maildir-Unterstützung.</p></li><li><p>mutt lässt sich im höchsten Maße an lokale Bedürfnisse anpassen.</p></li></ul></div><div class=paragraph><p>Mehr über mutt erfahren Sie auf der Seite <a href=http://www.mutt.org>http://www.mutt.org</a>.</p></div><div class=paragraph><p>mutt kann über den Port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/mutt/>mail/mutt</a> installiert werden. Nachdem der Port installiert ist, kann mutt mit dem folgenden Befehl gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mutt</code></pre></div></div><div class=paragraph><p>mutt liest automatisch den Inhalt des Benutzer-Postfachs im Verzeichnis <span class=filename>/var/mail</span>. Sind keine E-Mails vorhanden, wartet mutt auf Benutzereingaben. Das folgende Beispiel zeigt, wie mutt eine Nachrichten-Liste darstellt:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt1.png alt=mutt1></div></div><div class=paragraph><p>Um eine E-Mail zu lesen, wählen Sie die Nachricht einfach mit den Pfeiltasten aus und drücken <kbd>Enter</kbd>. mutt zeigt E-Mails wie folgt an:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt2.png alt=mutt2></div></div><div class=paragraph><p>Änlich wie <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>, kann auch mutt verwendet werden, um nur dem Absender, oder auch allen anderen Empfängern zu antworten. Um nur dem Absender der E-Mail zu antworten, drücken Sie <kbd>r</kbd>. Um sowohl dem Absender, als auch allen anderen Empfängern zu antworten, drücken Sie <kbd>g</kbd>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Zum Erstellen oder zum Beantworten von E-Mails ruft mutt den Editor <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> auf. Jeder Benutzer kann diese Einstellung anpassen, indem die Variable <code>editor</code> in <span class=filename>.muttrc</span> im Heimatverzeichnis gesetzt wird, oder die Umgebungsvariable <code>EDITOR</code> entsprechend angepasst wird. Weitere Informationen zur Konfiguration von mutt finden Sie unter <a href=http://www.mutt.org/>http://www.mutt.org/</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Drücken Sie <kbd>m</kbd>, um eine neue Nachricht zu verfassen. Nachdem der Betreff (subject) eingegeben wurde, startet mutt den <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> und die Nachricht kann verfasst werden. Wenn Sie fertig sind, speichern Sie die Nachricht und verlassen den <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>. mutt wird dann wieder aktiv und zeigt eine Zusammenfassung der zu sendenden Nachricht an. Drücken Sie <kbd>y</kbd>, um die E-Mail zu versenden. Der nachstehende Bildschirmabzug zeigt die Zusammenfassung der E-Mail:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt3.png alt=mutt3></div></div><div class=paragraph><p>mutt verfügt über eine umfangreiche Hilfestellung. Aus fast jedem Menü können Hilfeseiten mit <kbd>?</kbd> aufgerufen werden. In der oberen Statuszeile werden zudem die verfügbaren Tastenkombinationen angezeigt.</p></div></div><div class=sect3><h4 id=alpine-command>51.11.3. alpine<a class=anchor href=#alpine-command></a></h4><div class=paragraph><p>alpine wendet sich an Anfänger bietet aber ebenfalls einige Funktionen für Profis.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>In der Vergangenheit wurden in alpine mehrere Schwachstellen gefunden. Die Schwachstellen gestatteten entfernten Benutzern, durch das Versenden einer besonders verfassten E-Mail, Programme auf dem lokalen System laufen zu lassen. Alle <em>bekannten</em> Schwachstellen sind beseitigt worden, doch wird im Quellcode von alpine ein sehr riskanter Programmierstil verwendet, sodass der FreeBSD-Security-Officer von weiteren unbekannten Schwachstellen ausgeht. Benutzer installieren alpine auf eigene Verantwortung!</p></div></td></tr></tbody></table></div><div class=paragraph><p>Der Port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/alpine/>mail/alpine</a> enthält die aktuelle Version von alpine. Nach der Installation können Sie alpine mit dem nachstehenden Kommando starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% alpine</code></pre></div></div><div class=paragraph><p>Beim ersten Start von alpine, zeigt das Programm eine Seite mit einer kurzen Einführung an. Um die alpine-Benutzer zu zählen, bitten die Entwickler auf dieser Seite um eine anonyme E-Mail. Sie können diese anonyme E-Mail senden, indem Sie <kbd>Enter</kbd> drücken oder den Begrüßungsbildschirm mit der Taste <kbd>E</kbd> verlassen, ohne die anonyme E-Mail zu senden. Der Begrüßungsbildschirm sieht wie folgt aus:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine1.png alt=pine1></div></div><div class=paragraph><p>Nach dem Begrüßungsbildschirm wird das Hauptmenü dargestellt, das sich mit den Pfeiltasten bedienen lässt. Über Tastenkombinationen können aus dem Hauptmenü neue E-Mails erstellt, Postfächer angezeigt und das Adressbuch verwaltet werden. Unterhalb des Menüs werden die Tastenkombinationen für die verfügbaren Aktionen angezeigt.</p></div><div class=paragraph><p>In der Voreinstellung öffnet alpine das Verzeichnis <span class=filename>inbox</span>. Die Taste <kbd>I</kbd> oder der Menüpunkt <span class=guimenuitem>MESSAGE INDEX</span> führt zu einer Nachrichten-Liste:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine2.png alt=pine2></div></div><div class=paragraph><p>Die Liste zeigt die Nachrichten im Arbeitsverzeichnis. Sie können Nachrichten mit den Pfeiltasten markieren. Um eine Nachricht zu lesen, drücken Sie <kbd>Enter</kbd>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine3.png alt=pine3></div></div><div class=paragraph><p>Im nächsten Bildschirmabzug sehen Sie, wie alpine eine Nachricht darstellt. Die unteren Bildschirmzeilen zeigen die verfügbaren Tastenkombinationen. Mit <kbd>r</kbd> können Sie zum Beispiel auf die gerade angezeigte Nachricht antworten.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine4.png alt=pine4></div></div><div class=paragraph><p>Zum Antworten auf eine E-Mail wird in alpine der Editor pico, der mit installiert wird, benutzt. pico ist leicht zu bedienen und gerade für Anfänger besser geeignet als <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>. Die Antwort wird mit der Tastenkombination <span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span> versendet. Vor dem Versand bittet alpine noch um eine Bestätigung.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine5.png alt=pine5></div></div><div class=paragraph><p>Über den Menüpunkt <span class=guimenuitem>SETUP</span> des Hauptmenüs können Sie alpine an Ihre Bedürfnisse anpassen. Erläuterungen dazu finden Sie auf der Seite <a href=http://www.washington.edu/pine/>http://www.washington.edu/pine/</a>.</p></div></div></div><div class=sect2><h3 id=mail-fetchmail>51.12. E-Mails mit fetchmail abholen<a class=anchor href=#mail-fetchmail></a></h3><div class=paragraph><p>fetchmail ist ein vollwertiger IMAP- und POP-Client. Mit fetchmail können Benutzer E-Mails von entfernten IMAP- und POP-Servern in leichter zugängliche lokale Postfächer laden. fetchmail wird aus dem Port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a> installiert. Das Programm bietet unter anderem folgende Funktionen:</p></div><div class=ulist><ul><li><p>fetchmail beherrscht die Protokolle POP3, APOP, KPOP, IMAP, ETRN und ODMR.</p></li><li><p>E-Mails können mit SMTP weiterverarbeitet werden. Dadurch ist garantiert, dass Filter, Weiterleitungen und Aliase weiterhin funktionieren.</p></li><li><p>Das Programm kann als Dienst laufen und periodisch neue Nachrichten abrufen.</p></li><li><p>fetchmail kann mehrere Postfächer abfragen und je nach Konfiguration die E-Mails an verschiedene lokale Benutzer zustellen.</p></li></ul></div><div class=paragraph><p>Dieser Abschnitt erklärt einige grundlegende Funktionen von fetchmail. Das Programm benötigt eine Konfigurationsdatei <span class=filename>.fetchmailrc</span> im Heimatverzeichnis des Benutzers. In dieser Datei werden Informationen über Server wie auch Benutzerdaten und Passwörter hinterlegt. Wegen des kritischen Inhalts dieser Datei ist es ratsam, diese nur für den Benutzer lesbar zu machen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>600 .fetchmailrc</code></pre></div></div><div class=paragraph><p>Die folgende <span class=filename>.fetchmailrc</span> zeigt, wie das Postfach eines einzelnen Benutzers mit POP heruntergeladen wird. fetchmail wird angewiesen, eine Verbindung zu <code>example.com</code> herzustellen und sich dort als Benutzer <code>joesoap</code> mit dem Passwort <code>XXX</code> anzumelden. Das Beispiel setzt voraus, dass der Benutzer <code>joesoap</code> auch auf dem lokalen System existiert.</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.com protocol pop3 username &#34;joesoap&#34; password &#34;XXX&#34;</pre></div></div><div class=paragraph><p>Im folgenden Beispiel werden mehrere POP- und IMAP-Server benutzt. Wo notwendig, werden E-Mails auf andere lokale Konten umgeleitet:</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.com proto pop3:
user &#34;joesoap&#34;, with password &#34;XXX&#34;, is &#34;jsoap&#34; here;
user &#34;andrea&#34;, with password &#34;XXXX&#34;;
poll example2.net proto imap:
user &#34;john&#34;, with password &#34;XXXXX&#34;, is &#34;myth&#34; here;</pre></div></div><div class=paragraph><p>fetchmail kann als Dämon gestartet werden. Verwendet wird dazu die Kommandozeilenoption <code>-d</code> gefolgt von einer Zeitspanne in Sekunden, die angibt, wie oft die Server aus <span class=filename>.fetchmailrc</span> abgefragt werden sollen. Mit dem nachstehenden Befehl fragt fetchmail die Server alle 600 Sekunden ab:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% fetchmail <span class=nt>-d</span> 600</code></pre></div></div><div class=paragraph><p>Mehr über fetchmail erfahren Sie auf der Seite <a href=http://www.fetchmail.info/>http://www.fetchmail.info/</a>.</p></div></div><div class=sect2><h3 id=mail-procmail>51.13. E-Mails mit procmail filtern<a class=anchor href=#mail-procmail></a></h3><div class=paragraph><p>procmail ist ein mächtiges Werkzeug, mit dem sich eingehende E-Mails filtern lassen. Benutzer können Regeln für eingehende E-Mails definieren, die E-Mails zu anderen Postfächern oder anderen E-Mail-Adressen umleiten. procmail befindet sich im Port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/procmail/>mail/procmail</a>. procmail kann leicht in die meisten MTAs integriert werden. Lesen Sie dazu bitte die Dokumentation des verwendeten MTAs. Alternativ kann procmail in das E-Mail-System eingebunden werden, indem die nachstehende Zeile in die Datei <span class=filename>.forward</span> im Heimatverzeichnis eines Benutzers eingefügt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>&#34;|exec /usr/local/bin/procmail || exit 75&#34;</pre></div></div><div class=paragraph><p>Der folgende Abschnitt zeigt einige einfache procmail-Regeln sowie eine kurze Beschreibung dessen, was sie tun. Regeln müssen in <span class=filename>.procmailrc</span> im Heimatverzeichnis des Benutzers eingefügt werden.</p></div><div class=paragraph><p>Den Großteil dieser Regeln finden Sie auch in <a href="https://man.freebsd.org/cgi/man.cgi?query=procmailex&amp;sektion=5&amp;format=html">procmailex(5)</a>.</p></div><div class=paragraph><p>Um E-Mails von <a href=mailto:user@example.com>user@example.com</a> an die externe Adresse <a href=mailto:goodmail@example2.com>goodmail@example2.com</a> weiterzuleiten:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^From.*user@example.com
! goodmail@example2.com</pre></div></div><div class=paragraph><p>Um E-Mails, die kürzer als 1000 Bytes sind, an <a href=mailto:goodmail@example2.com>goodmail@example2.com</a> weiterzuleiten:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* &lt; 1000
! goodmail@example2.com</pre></div></div><div class=paragraph><p>Um E-Mails, die an <a href=mailto:alternate@example.com>alternate@example.com</a> geschickt werden, im Postfach <span class=filename>alternate</span> zu speichern:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^TOalternate@example.com
alternate</pre></div></div><div class=paragraph><p>Um E-Mails, die im Betreff <code>Spam</code> enthalten, nach <span class=filename>/dev/null</span> zu verschieben:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
^Subject:.*Spam
/dev/null</pre></div></div><div class=paragraph><p>Zuletzt ein nützliches Rezept, das eingehende E-Mails von den <code>FreeBSD.org</code>-Mailinglisten in ein separates Postfach für jede Liste einsortiert:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^Sender:.owner-freebsd-\/[^@]+@FreeBSD.ORG
{
	LISTNAME=${MATCH}
	:0
	* LISTNAME??^\/[^@]+
	FreeBSD-${MATCH}
}</pre></div></div></div></div></div><div class=sect1><h2 id=network-servers>Kapitel 52. Netzwerkserver<a class=anchor href=#network-servers></a></h2><div class=sectionbody><div class=sect2><h3 id=network-servers-synopsis>52.1. Übersicht<a class=anchor href=#network-servers-synopsis></a></h3><div class=paragraph><p>Dieses Kapitel beschreibt einige der häufiger verwendeten Netzwerkdienste auf UNIX®-Systemen. Dazu zählen Installation und Konfiguration sowie Test und Wartung verschiedener Netzwerkdienste. Zusätzlich sind im ganzen Kapitel Beispielkonfigurationen als Referenz enthalten.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</p></div><div class=ulist><ul><li><p>Den inetd-Daemon konfigurieren können.</p></li><li><p>Wissen, wie das Network File System (NFS) eingerichtet wird.</p></li><li><p>Einen Network Information Server (NIS) einrichten können, um damit Benutzerkonten im Netzwerk zu verteilen.</p></li><li><p>Wissen, wie Sie FreeBSD einrichten, um als LDAP-Server oder -Client zu agieren.</p></li><li><p>Rechner durch Nutzung von DHCP automatisch für ein Netzwerk konfigurieren können.</p></li><li><p>In der Lage sein, einen Domain Name Server (DNS) einzurichten.</p></li><li><p>Den ApacheHTTP-Server konfigurieren können.</p></li><li><p>Wissen, wie man einen File Transfer Protocol (FTP)-Server einrichtet.</p></li><li><p>Mit Samba einen Datei- und Druckserver für Windows®-Clients konfigurieren können.</p></li><li><p>Unter Nutzung des NTP-Protokolls Datum und Uhrzeit synchronisieren sowie einen Zeitserver installieren können.</p></li><li><p>Wissen, wie iSCSI eingerichtet wird.</p></li></ul></div><div class=paragraph><p>Dieses Kapitel setzt folgende Grundkenntnisse voraus:</p></div><div class=ulist><ul><li><p><span class=filename>/etc/rc</span>-Skripte.</p></li><li><p>Netzwerkterminologie</p></li><li><p>Installation zusätzlicher Software von Drittanbietern (<a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=network-inetd>52.2. Der inetd"Super-Server"<a class=anchor href=#network-inetd></a></h3><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>-Daemon wird manchmal auch als "Internet Super-Server" bezeichnet, weil er Verbindungen für viele Dienste verwaltet. Anstatt mehrere Anwendungen zu starten, muss nur der inetd-Dienst gestartet werden. Wenn eine Verbindung für einen Dienst eintrifft, der von inetd verwaltet wird, bestimmt inetd, welches Programm für die eingetroffene Verbindung zuständig ist, aktiviert den entsprechenden Prozess und reicht den Socket an ihn weiter. Der Einsatz von inetd an Stelle viele einzelner Daemonen kann auf nicht komplett ausgelasteten Servern zu einer Verringerung der Systemlast führen.</p></div><div class=paragraph><p>inetd wird vor allem dazu verwendet, andere Daemonen zu aktivieren, einige Protokolle werden aber auch intern verwaltet. Dazu gehören chargen, auth, time, echo, discard sowie daytime.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt die Konfiguration von inetd.</p></div><div class=sect3><h4 id=network-inetd-conf>52.2.1. Konfigurationsdatei<a class=anchor href=#network-inetd-conf></a></h4><div class=paragraph><p>Die Konfiguration von inetd erfolgt über <span class=filename>/etc/inetd.conf</span> Jede Zeile dieser Datei repräsentiert eine Anwendung, die von inetd gestartet werden kann. In der Voreinstellung beginnt jede Zeile mit einem Kommentar (<code>#</code>), was bedeutet dass inetd keine Verbindungen für Anwendungen akzeptiert. Entfernen Sie den Kommentar am Anfang der Zeile, damit inetd Verbindungen für diese Anwendung entgegennimmt.</p></div><div class=paragraph><p>Nachdem Sie die Änderungen gespeichert haben, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein, damit inetd bei Booten automatisch gestartet wird:</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten Sie jetzt inetd, so dass er Verbindungen für die von Ihnen konfigurierten Dienste entgegennimmt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div><div class=paragraph><p>Sobald inetd gestartet ist, muss der Dienst benachrichtigt werden, wenn eine Änderung in <span class=filename>/etc/inetd.conf</span> gemacht wird:</p></div><div id=network-inetd-reread class=exampleblock><div class=title>Beispiel 45. Die Konfigurationsdatei von inetd neu einlesen</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd reload</span></code></pre></div></div></div></div><div class=paragraph><p>Normalerweise müssen Sie lediglich den Kommentar vor der Anwendung entfernen. In einigen Situationen kann es jedoch sinnvoll sein, den Eintrag weiter zu bearbeiten.</p></div><div class=paragraph><p>Als Beispiel dient hier der Standardeintrag für <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> über IPv4:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</pre></div></div><div class=paragraph><p>Die sieben Spalten in diesem Eintrag haben folgende Bedeutung:</p></div><div class="literalblock programlisting"><div class=content><pre>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]
user[:group][/login-class]
server-program
server-program-arguments</pre></div></div><div class=dlist><dl><dt class=hdlist1>service-name</dt><dd><p>Der Dienstname eines bestimmten Daemons. Er muss einem in <span class=filename>/etc/services</span> aufgelisteten Dienst entsprechen. Hier wird festgelegt, auf welchen Port inetd eingehende Verbindungen für diesen Dienst entgegennimmt. Wenn ein neuer Dienst benutzt wird, muss er zuerst in <span class=filename>/etc/services</span> eingetragen werden.</p></dd><dt class=hdlist1>socket-type</dt><dd><p>Entweder <code>stream</code>, <code>dgram</code>, <code>raw</code>, oder <code>seqpacket</code>. Nutzen Sie <code>stream</code> für TCP-Verbindungen und <code>dgram</code> für UDP-Dienste.</p></dd><dt class=hdlist1>protocol</dt><dd><p>Benutzen Sie eines der folgenden Protokolle:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Protokoll</th><th class="tableblock halign-left valign-top">Bedeutung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp oder tcp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP (IPv4)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp oder udp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP (IPv4)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP (IPv6)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP (IPv6)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP sowohl unter IPv4 als auch unter IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP sowohl unter IPv4 als auch unter IPv6</p></td></tr></tbody></table></dd><dt class=hdlist1>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]</dt><dd><p>In diesem Feld muss <code>wait</code> oder <code>nowait</code> angegeben werden. <code>max-child</code>, <code>max-connections-per-ip-per-minute</code> sowie <code>max-child-per-ip</code> sind optional.</p><div class=paragraph><p><code>wait|nowait</code> gibt an, ob der Dienst seinen eigenen Socket verwalten kann oder nicht. <code>dgram</code>-Sockets müssen <code>wait</code> verwenden, während Daemonen mit <code>stream</code>-Sockets, die normalerweise auch aus mehreren Threads bestehen, <code>nowait</code> verwenden sollten. <code>wait</code> gibt in der Regel mehrere Sockets an einen einzelnen Daemon weiter, während <code>nowait</code> für jeden neuen Socket einen Childdaemon erzeugt.</p></div><div class=paragraph><p>Die maximale Anzahl an Child-Daemonen, die inetd erzeugen kann, wird durch die Option <code>max-child</code> festgelegt. Wenn ein bestimmter Daemon 10 Instanzen benötigt, wird der Wert <code>/10</code> hinter die Option <code>nowait</code> gesetzt. Der Wert <code>/0</code> gibt an, das es keine Beschränkung gibt.</p></div><div class=paragraph><p><code>max-connections-per-ip-per-minute</code> legt die maximale Anzahl von Verbindungsversuchen pro Minute fest, die von einer bestimmten IP-Adresse aus unternommen werden können. Sobald das Limit erreicht ist, werden weitere Verbindungen von dieser IP-Adresse geblockt, bis die Minute vorüber ist. Ein Wert von <code>/10</code> würde die maximale Anzahl der Verindungsversuche einer bestimmten IP-Adresse auf zehn Versuche in der Minute beschränken. <code>max-child-per-ip</code> legt fest, wie viele Child-Daemonen von einer bestimmten IP-Adresse aus gestartet werden können. Durch diese Optionen lassen sich Ressourcenverbrauch sowie die Auswirkungen eines <code>Denial of Service (DoS)</code>-Angriffs begrenzen.</p></div><div class=paragraph><p>Ein Beispiel finden Sie in den Voreinstellungen für <a href="https://man.freebsd.org/cgi/man.cgi?query=fingerd&amp;sektion=8&amp;format=html">fingerd(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -k -s</pre></div></div></dd><dt class=hdlist1>user</dt><dd><p>Der Benutzername, unter dem der jeweilige Daemon laufen soll. Meistens laufen Daemonen als <code>root</code>, <code>daemon</code> oder <code>nobody</code>.</p></dd><dt class=hdlist1>server-program</dt><dd><p>Der vollständige Pfad des Daemons. Wird der Daemon von inetd intern bereitgestellt, verwenden Sie <code>internal</code>.</p></dd><dt class=hdlist1>server-program-arguments</dt><dd><p>Dieser Eintrag legt die Argumente fest, die bei der Aktivierung an den Daemon übergeben werden. Wenn es sich beim Daemon um einen internen Dienst handelt, verwenden Sie wiederum <code>internal</code>.</p></dd></dl></div></div><div class=sect3><h4 id=network-inetd-cmdline>52.2.2. Kommandozeilenoptionen<a class=anchor href=#network-inetd-cmdline></a></h4><div class=paragraph><p>Wie die meisten anderen Server-Daemonen lässt sich auch inetd über verschiedene Optionen steuern. In der Voreinstellung wird inetd mit <code>-wW -C 60</code> gestartet. Durch das Setzen dieser Werte wird das TCP-Wrapping für alle inetd-Dienste aktiviert. Zudem wird verhindert, dass eine IP-Adresse eine Dienst öfter als 60 Mal pro Minute anfordern kann.</p></div><div class=paragraph><p>Um die Voreinstellungen für inetd zu ändern, fügen Sie einen Eintrag für <code>inetd_flags</code> in <span class=filename>/etc/rc.conf</span> hinzu. Wenn inetd bereits ausgeführt wird, starten Sie ihn mit <code>service inetd restart</code> neu.</p></div><div class=paragraph><p>Die verfügbaren Optionen sind:</p></div><div class=dlist><dl><dt class=hdlist1>-c maximum</dt><dd><p>Legt die maximale Anzahl von parallelen Aufrufen eines Dienstes fest; in der Voreinstellung gibt es keine Einschränkung. Diese Einstellung kann für jeden Dienst durch Setzen des Parameters <code>max-child</code> in <span class=filename>/etc/inetd.conf</span> festgelegt werden.</p></dd><dt class=hdlist1>-C rate</dt><dd><p>Legt fest, wie oft ein Dienst von einer einzelnen IP-Adresse in einer Minute aufgerufen werden kann; in der Voreinstellung gibt es keine Einschränkung. Dieser Wert kann für jeden Dienst durch das Setzen des Parameters <code>max-connections-per-ip-per-minute</code> in <span class=filename>/etc/inetd.conf</span> festgelegt werden.</p></dd><dt class=hdlist1>-R rate</dt><dd><p>Legt fest, wie oft ein Dienst in der Minute aktiviert werden kann; in der Voreinstellung sind dies <code>256</code> Aktivierungen pro Minute. Ein Wert von <code>0</code> erlaubt unbegrenzt viele Aktivierungen.</p></dd><dt class=hdlist1>-s maximum</dt><dd><p>Legt fest, wie oft ein Dienst in der Minute von einer einzelnen IP-Adresse aus aktiviert werden kann; in der Voreinstellung gibt es hier keine Beschränkung. Diese Einstellung kann für jeden Dienst durch die Angabe von <code>max-child-per-ip</code> in <span class=filename>/etc/inetd.conf</span> angepasst werden.</p></dd></dl></div><div class=paragraph><p>Es sind noch weitere Optionen verfügbar. Eine vollständige Liste der Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>.</p></div></div><div class=sect3><h4 id=network-inetd-security>52.2.3. Sicherheitsbedenken<a class=anchor href=#network-inetd-security></a></h4><div class=paragraph><p>Viele Daemonen, die von inetd verwaltet werden, sind nicht auf Sicherheit bedacht. Einige Damonen, wie beispielsweise fingerd, liefern Informationen, die für einen Angreifer nützlich sein könnten. Aktivieren Sie nur erforderliche Dienste und überwachen Sie das System auf übermäßige Verbindungsversuche. <code>max-connections-per-ip-per-minute</code>, <code>max-child</code> und <code>max-child-per-ip</code> können verwendet werden, um solche Angriffe zu begrenzen.</p></div><div class=paragraph><p>TCP-Wrapper ist in der Voreinstellung aktiviert. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a>, wenn Sie weitere Informationen zum Setzen von TCP-Beschränkungen für verschiedene von inetd aktivierte Daemonen benötigen.</p></div></div></div><div class=sect2><h3 id=network-nfs>52.3. Network File System (NFS)<a class=anchor href=#network-nfs></a></h3><div class=paragraph><p>FreeBSD unterstützt das Netzwerkdateisystem NFS, das es einem Server erlaubt, Dateien und Verzeichnisse über ein Netzwerk mit Clients zu teilen. Mit NFS können Benutzer und Programme auf Daten entfernter Systeme zugreifen, und zwar so, als ob es sich um lokal gespeicherte Daten handeln würde.</p></div><div class=paragraph><p>Die wichtigsten Vorteile von NFS sind:</p></div><div class=ulist><ul><li><p>Daten, die sonst auf jeden Client dupliziert würden, können an einem zentralen Ort aufbewahrt, und von den Clients über das Netzwerk aufgerufen werden.</p></li><li><p>Verschiedene Clients können auf ein gemeinsames Verzeichnis <span class=filename>/usr/ports/distfiles</span> zugreifen. Die gemeinsame Nutzung dieses Verzeichnisses ermöglicht einen schnellen Zugriff auf die Quelldateien, ohne sie auf jede Maschine zu kopieren zu müssen.</p></li><li><p>In größeren Netzwerken ist es praktisch, einen zentralen NFS-Server einzurichten, auf dem die Heimatverzeichnisse der Benutzer gespeichert werden. Dadurch steht den Benutzern immer das gleiche Heimatverzeichnis zur Verfügung, unabhängig davon, an welchem Client im Netzwerk sie sich anmelden.</p></li><li><p>Die Verwaltung der NFS-Exporte wird vereinfacht. Zum Beispiel gibt es dann nur noch ein Dateisystem, für das Sicherheits- oder Backup-Richtlinien festgelegt werden müssen.</p></li><li><p>Wechselmedien können von anderen Maschinen im Netzwerk verwendet werden. Dies reduziert die Anzahl von Geräten im Netzwerk und bietet einen zentralen Ort für die Verwaltung. Oft ist es einfacher, über ein zentrales Installationsmedium Software auf mehreren Computern zu installieren.</p></li></ul></div><div class=paragraph><p>NFS besteht aus einem Server und einem oder mehreren Clients. Der Client greift über das Netzwerk auf die Daten zu, die auf dem Server gespeichert sind. Damit dies korrekt funktioniert, müssen einige Prozesse konfiguriert und gestartet werden:</p></div><div class=paragraph><p>Folgende Daemonen müssen auf dem Server ausgeführt werden:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Daemon</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nfsd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Der NFS-Daemon. Er bearbeitet Anfragen der NFS-Clients.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>mountd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Der NFS-Mount-Daemon. Er bearbeitet die Anfragen von <code>nfsd</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpcbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Der Portmapper-Daemon. Durch ihn erkennen die NFS-Clients, welchen Port der NFS-Server verwendet.</p></td></tr></tbody></table><div class=paragraph><p>Der Einsatz von <a href="https://man.freebsd.org/cgi/man.cgi?query=nfsiod&amp;sektion=8&amp;format=html">nfsiod(8)</a> ist nicht zwingend erforderlich, kann aber die Leistung auf dem Client verbessern.</p></div><div class=sect3><h4 id=network-configuring-nfs>52.3.1. Konfiguration des Servers<a class=anchor href=#network-configuring-nfs></a></h4><div class=paragraph><p>Die Dateisysteme, die der NFS-Server exportieren soll, werden in <span class=filename>/etc/exports</span> festgelegt. Jede Zeile in dieser Datei beschreibt ein zu exportierendes Dateisystem, Clients, die darauf Zugriff haben sowie alle Zugriffsoptionen. Die Optionen eines auf einen anderen Rechner exportierten Dateisystems müssen alle in einer Zeile stehen. Wird in einer Zeile kein Rechner festgelegt, dürfen alle Clients im Netzwerk das exportierte Dateisystem einhängen.</p></div><div class=paragraph><p>Wie Dateisysteme exportiert werden, ist in der folgenden <span class=filename>/etc/exports</span> zu sehen. Diese Beispiele müssen natürlich an die Arbeitsumgebung und die Netzwerkkonfiguration angepasst werden. Es existieren viele verschiedene Optionen, allerdings werden hier nur wenige von ihnen erwähnt. Eine vollständige Liste der Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a>.</p></div><div class=paragraph><p>Dieses Beispiel exportiert <span class=filename>/cdrom</span> für drei Clients, <em>alpha</em>, <em>bravo</em> und <em>charlie</em>:</p></div><div class="literalblock programlisting"><div class=content><pre>/cdrom -ro alpha bravo charlie</pre></div></div><div class=paragraph><p>Die Option <code>-ro</code> kennzeichnet das exportierte Dateisystem als schreibgeschützt. Dadurch sind Clients nicht in der Lage, das exportierte Dateisystem zu verändern. Dieses Beispiel geht davon aus, dass die Hostnamen entweder über DNS oder über <span class=filename>/etc/hosts</span> aufgelöst werden können. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> falls das Netzwerk über keinen DNS-Server verfügt.</p></div><div class=paragraph><p>Das nächste Beispiel exportiert <span class=filename>/home</span> auf drei durch IP-Adressen bestimmte Clients. Diese Einstellung kann für Netzwerke ohne DNS-Server und <span class=filename>/etc/hosts</span> nützlich sein. Die Option <code>-alldirs</code> ermöglicht es, auch Unterverzeichnisse als Mountpunkte festzulegen. Dies bedeutet aber nicht, dass alle Unterverzeichnisse eingehängt werden, vielmehr wird es dem Client ermöglicht, nur diejenigen Verzeichnisse einzuhängen, die auch benötigt werden.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</pre></div></div><div class=paragraph><p>Das nächste Beispiel exportiert <span class=filename>/a</span>, damit Clients von verschiedenen Domänen auf das Dateisystem zugreifen können. Die Option <code>-maproot=root</code> erlaubt es dem Benutzer <code>root</code> des Clients, als <code>root</code> auf das exportierte Dateisystem zu schreiben. Wenn diese Option nicht gesetzt ist, wird der <code>root</code>-Benutzer des Clients dem <code>nobody</code>-Konto des Servers zugeordnet und unterliegt somit den Zugriffsbeschränkungen dieses Kontos.</p></div><div class="literalblock programlisting"><div class=content><pre>/a  -maproot=root  host.example.com box.example.org</pre></div></div><div class=paragraph><p>Ein Client kann für jedes Dateisystem nur einmal definiert werden. Wenn beispielsweise <span class=filename>/usr</span> ein gesondertes Dateisystem ist, dann wären die folgenden Einträge falsch, da in beiden Einträgen der gleiche Rechner angegeben wird:</p></div><div class="literalblock programlisting"><div class=content><pre>#Nicht erlaubt, wenn /usr ein einziges Dateisystem ist
/usr/src   client
/usr/ports client</pre></div></div><div class=paragraph><p>Das richtige Format für eine solche Situation ist:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src /usr/ports  client</pre></div></div><div class=paragraph><p>Das Folgende ist ein Beispiel für eine gültige Exportliste, in der <span class=filename>/usr</span> und <span class=filename>/exports</span> lokale Dateisysteme sind:</p></div><div class="literalblock programlisting"><div class=content><pre># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports                  client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</pre></div></div><div class=paragraph><p>Damit die vom NFS-Server benötigen Prozesse beim Booten gestartet werden, fügen Sie folgende Optionen in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>rpcbind_enable=&#34;YES&#34;
nfs_server_enable=&#34;YES&#34;
mountd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Der Server kann jetzt mit diesem Kommando gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div><div class=paragraph><p>Wenn der NFS-Server startet, wird auch mountd automatisch gestartet. Allerdings liest mountd <span class=filename>/etc/exports</span> nur, wenn der Server gestartet wird. Um nachfolgende Änderungen an <span class=filename>/etc/exports</span> wirksam werden zu lassen, kann mountd angewiesen werden, die Datei neu einzulesen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service mountd reload</span></code></pre></div></div></div><div class=sect3><h4 id=_konfiguration_des_clients>52.3.2. Konfiguration des Clients<a class=anchor href=#_konfiguration_des_clients></a></h4><div class=paragraph><p>Um den NFS-Client zu aktivieren, setzen Sie folgende Option in <span class=filename>/etc/rc.conf</span> auf jedem Client:</p></div><div class="literalblock programlisting"><div class=content><pre>nfs_client_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Der Client ist nun in der Lage, ein entferntes Dateisystem einzuhängen. In diesen Beispielen ist der Name des Servers <code>server</code> und der Name des Clients <code>client</code>. Fügen Sie folgenden Befehl aus, um das Verzeichnis <span class=filename>/home</span> vom <code>server</code> auf dem <code>client</code> ins Verzeichnis <span class=filename>/mnt</span> einzuhängen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount server:/home /mnt</span></code></pre></div></div><div class=paragraph><p>Die Dateien und Verzeichnisse in <span class=filename>/home</span> stehen dem Rechner <code>client</code> nun im Verzeichnis <span class=filename>/mnt</span> zur Verfügung.</p></div><div class=paragraph><p>Um ein entferntes Dateisystem bei jedem Systemstart automatisch einzuhängen, fügen Sie das Dateisystem in <span class=filename>/etc/fstab</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>server:/home	/mnt	nfs	rw	0	0</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> enthält eine Beschreibung aller Optionen.</p></div></div><div class=sect3><h4 id=_dateien_sperren_locking>52.3.3. Dateien sperren (Locking)<a class=anchor href=#_dateien_sperren_locking></a></h4><div class=paragraph><p>Einige Anwendungen erfordern die Sperrung von Dateien, damit sie korrekt arbeiten. Um diese Sperre zu aktivieren, müssen diese Zeilen in <span class=filename>/etc/rc.conf</span> sowohl auf dem Client als auch auf dem Server hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>rpc_lockd_enable=&#34;YES&#34;
rpc_statd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Danach starten Sie die beiden Anwendungen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service lockd start</span>
<span class=c># service statd start</span></code></pre></div></div><div class=paragraph><p>Wenn keine Dateisperren zwischen den NFS-Clients und dem NFS-Server benötigt werden, können Sie den NFS-Client durch die Übergabe der Option <code>-L</code> an mount zu einer lokalen Sperrung von Dateien zwingen. Weitere Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8&amp;format=html">mount_nfs(8)</a>.</p></div></div><div class=sect3><h4 id=network-autofs>52.3.4. Automatisches Einhängen mit <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a><a class=anchor href=#network-autofs></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> wird seit FreeBSD 10.1-RELEASE unterstützt. Um die Funktionalität des automatischen Einhängens in älteren FreeBSD-Versionen zu benutzen, verwenden Sie stattdessen <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a>. In diesem Kapitel wird nur das automatische Einhängen mit Hilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> beschrieben.</p></div></td></tr></tbody></table></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> ist eine gebräuchliche Bezeichnung für verschiedene Komponenten, welche es erlauben, lokale und entfernte Dateisysteme automatisch einzuhängen, sobald auf eine Datei oder ein Verzeichnis in diesem Dateisystem zugegriffen wird. Es besteht aus einer Kernel-Komponente <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> und mehreren Benutzerprogrammen: <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> ist eine Alternative für <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> aus früheren FreeBSD-Versionen. <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> steht nach wie vor zur Verfügung, da beide Programme ein unterschiedliches Format verwenden. Das Format welches <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> verwendet ist das gleiche wie bei anderen SVR4 Automountern, beispielsweise denen aus Solaris™, Mac OS® X und Linux®.</p></div><div class=paragraph><p>Das virtuelle <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a>-Dateisystem wird von <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a> in einen bestimmten Mountpunkt eingehängt. Dies geschieht gewöhnlich während des Bootens.</p></div><div class=paragraph><p>Jedes Mal, wenn ein Prozess versucht auf eine Datei unterhalb des <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a>-Mountpunkts zuzugreifen, wird der Kernel den <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a>-Daemon benachrichtigen und den aktuellen Prozess anhalten. Der <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a>-Daemon wird dann die Anfrage des Kernels bearbeiten und das entsprechende Dateisystem einhängen. Anschließend wird der Daemon den Kernel benachrichtigen, dass der angehaltene Prozess wieder freigegeben werden kann. Der <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a>-Daemon hängt automatisch Dateisysteme nach einiger Zeit ab, sofern sie nicht mehr verwendet werden.</p></div><div class=paragraph><p>Die primäre Konfigurationsdatei von autofs ist <span class=filename>/etc/auto_master</span>. Sie enthält die einzelnen Zuordnungen zu den Mountpunkten. Eine Erklärung zu <span class=filename>auto_master</span> und der Syntax für die Zuordnungen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=auto_master&amp;sektion=5&amp;format=html">auto_master(5)</a>.</p></div><div class=paragraph><p>Eine spezielle Automounter Zuordnung wird in <span class=filename>/net</span> eingehängt. Wenn auf eine Datei in diesem Verzeichnis zugegriffen wird, hängt <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> einen bestimmten, entfernen Mountpunkt ein. Wenn beispielsweise auf eine Datei unterhalb von <span class=filename>/net/foobar/usr</span> zugegriffen werden soll, würde <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> das exportierte Dateisystem <span class=filename>/usr</span> von dem Rechner <code>foobar</code> einhängen.</p></div><div class=exampleblock><div class=title>Beispiel 46. Ein exportiertes Dateisystem mit <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> in den Verzeichnisbaum einhängen</div><div class=content><div class=paragraph><p>In diesem Beispiel zeigt <code>showmount -e</code> die exportierten Dateisysteme des NFS-Servers <code>foobar</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% showmount <span class=nt>-e</span> foobar
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
% <span class=nb>cd</span> /net/foobar/usr</code></pre></div></div></div></div><div class=paragraph><p>Die Ausgabe von <code>showmount</code> zeigt das exportierte Dateisystem <span class=filename>/usr</span>. Wenn in das Verzeichnis <span class=filename>/host/foobar/usr</span> gewechselt wird, fängt <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> die Anforderung ab und versucht, den Rechnernamen <code>foobar</code> aufzulösen. Gelingt dies, wird <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> automatisch das exportierte Dateisystem einhängen.</p></div><div class=paragraph><p>Um <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> beim Booten zu aktivieren, fügen Sie diese Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>autofs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Danach kann <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount start</span>
<span class=c># service automountd start</span>
<span class=c># service autounmountd start</span></code></pre></div></div><div class=paragraph><p>Obwohl das Format von <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> das gleiche ist wie in anderen Betriebssystemen, kann es wünschenswert sein, Informationen von anderen Betriebssystemen zu Rate zu ziehen, wie dieses <a href=http://images.apple.com/business/docs/Autofs.pdf>Mac OS X Dokument</a>.</p></div><div class=paragraph><p>Weitere Informationen finden Sie in den Manualpages <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=auto_master&amp;sektion=5&amp;format=html">auto_master(5)</a>.</p></div></div></div><div class=sect2><h3 id=network-nis>52.4. Network Information System (NIS)<a class=anchor href=#network-nis></a></h3><div class=paragraph><p>Das Network Information System (NIS) wurde entwickelt, um UNIX®-Systeme zentral verwalten zu können. Dazu zählen beispielsweise Solaris™, HP-UX, AIX®, Linux®, NetBSD, OpenBSD und FreeBSD. NIS war ursprünglich als <em>Yellow Pages</em> bekannt, aus markenrechtlichen Gründen wurde der Name aber geändert. Dies ist der Grund, warum NIS-Kommandos mit <code>yp</code> beginnen.</p></div><div class=paragraph><p>Bei NIS handelt es sich um ein RPC-basiertes Client/Server-System. Eine Gruppe von Rechnern greift dabei innerhalb einer NIS-Domäne auf gemeinsame Konfigurationsdateien zu. Dies erlaubt es einem Systemadministrator, NIS-Clients mit minimalem Aufwand einzurichten, sowie Änderungen an der Systemkonfiguration von einem zentralen Ort aus durchzuführen.</p></div><div class=paragraph><p>FreeBSD verwendet die Version 2 des NIS-Protokolls.</p></div><div class=sect3><h4 id=_nis_begriffe_und_prozesse>52.4.1. NIS-Begriffe und -Prozesse<a class=anchor href=#_nis_begriffe_und_prozesse></a></h4><div class=paragraph><p>Tabelle 30.1 fasst die Begriffe und Anwenderprozesse zusammen, die von NIS verwendet werden:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 25. NIS Begriffe</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Begriff</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>NIS-Domänenname</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS-Masterserver und Clients benutzen einen gemeinsamen NIS-Domänennamen. In der Regel hat dieser Name nichts mit DNS zu tun.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rpcbind&amp;sektion=8&amp;format=html">rpcbind(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dieser Dienst aktiviert RPC und muss gestartet sein, damit ein NIS-Server oder -Client ausgeführt werden kann.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dieser Dienst "bindet" einen NIS-Client an seinen NIS-Server. Der Client bezieht den NIS-Domänennamen vom System und stellt über das RPC-Protokoll eine Verbindung zum NIS-Server her. ypbind ist der zentrale Bestandteil der Client-Server-Kommunikation in einer NIS-Umgebung. Wird der Dienst auf einem Client beendet, ist dieser nicht mehr in der Lage, auf den NIS-Server zuzugreifen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dies ist der Prozess für den NIS-Server. Wenn dieser Dienst nicht mehr läuft, kann der Server nicht mehr auf NIS-Anforderungen reagieren. Wenn ein Slaveserver existiert, kann dieser als Ersatz fungieren. Einige NIS-Systeme (allerdings nicht das von FreeBSD) versuchen allerdings erst gar nicht, sich mit einem anderen Server zu verbinden, wenn der Masterserver nicht mehr reagiert. Die einzige Lösung besteht darin, den Serverprozess oder den ypbind-Prozess auf dem Client neu zu starten.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.yppasswdd&amp;sektion=8&amp;format=html">rpc.yppasswdd(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dieser Prozess läuft nur auf dem NIS-Masterserver. Es handelt sich um einen Daemonprozess, der es NIS-Clients ermöglicht, ihre NIS-Passwörter zu ändern. Wenn dieser Daemon nicht läuft, müssen sich die Benutzer am NIS-Masterserver anmelden und ihre Passwörter dort ändern.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_arten_von_nis_rechnern>52.4.2. Arten von NIS-Rechnern<a class=anchor href=#_arten_von_nis_rechnern></a></h4><div class=ulist><ul><li><p>NIS-Masterserver</p><div class=paragraph><p>Dieser Server dient als zentraler Speicherort für Rechnerkonfigurationen. Zudem verwaltet er die maßgebliche Kopie, der von den NIS-Clients gemeinsam verwendeten Dateien. <span class=filename>passwd</span>, <span class=filename>group</span>, sowie verschiedene andere von den Clients verwendete Dateien existieren auf dem Masterserver. Obwohl ein Rechner auch für mehrere NIS-Domänen als Masterserver fungieren kann, wird diese Art von Konfiguration nicht behandelt, da sich dieser Abschnitt auf eine relativ kleine NIS-Umgebung konzentriert.</p></div></li><li><p>NIS-Slaveserver</p><div class=paragraph><p>NIS-Slaveserver verwalten Kopien der Daten des NIS-Masterservers um Redundanz zu bieten. Zudem entlasten Slaveserver den Masterserver: NIS-Clients verbinden sich immer mit dem NIS-Server, welcher zuerst reagiert. Dieser Server kann auch ein Slaveserver sein.</p></div></li><li><p>NIS-Clients</p><div class=paragraph><p>NIS-Clients identifizieren sich gegenüber dem NIS-Server während der Anmeldung.</p></div></li></ul></div><div class=paragraph><p>Mit NIS können Informationen aus verschiedenen Dateien von mehreren Rechnern gemeinsam verwendet werden. <span class=filename>master.passwd</span>, <span class=filename>group</span>, und <span class=filename>hosts</span> werden oft gemeinsam über NIS verwendet. Immer, wenn ein Prozess auf einem Client auf Informationen zugreifen will, die normalerweise in lokalen Dateien vorhanden wären, wird stattdessen eine Anfrage an den NIS-Server gestellt, an den der Client gebunden ist.</p></div></div><div class=sect3><h4 id=_planung>52.4.3. Planung<a class=anchor href=#_planung></a></h4><div class=paragraph><p>Dieser Abschnitt beschreibt eine einfache NIS-Umgebung, welche aus 15 FreeBSD-Maschinen besteht, für die keine zentrale Verwaltung existiert. Jeder Rechner hat also eine eigene Version von <span class=filename>/etc/passwd</span> und <span class=filename>/etc/master.passwd</span>. Diese Dateien werden manuell synchron gehalten; wird ein neuer Benutzer angelegt, so muss dies auf allen fünfzehn Rechnern manuell erledigt werden.</p></div><div class=paragraph><p>In Zukunft soll die Konfiguration wie folgt aussehen:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Rechnername</th><th class="tableblock halign-left valign-top">IP-Adresse</th><th class="tableblock halign-left valign-top">Rechneraufgabe</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ellington</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS-Master</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>coltrane</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.3</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS-Slave</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>basie</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.4</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Workstation der Fakultät</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bird</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.5</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clientrechner</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cli[1-11]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.[6-17]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Verschiedene andere Clients</p></td></tr></tbody></table><div class=paragraph><p>Wenn erstmalig ein NIS-Schema eingerichtet wird, sollte es im Voraus sorgfältig geplant werden. Unabhängig von der Größe des Netzwerks müssen einige Entscheidungen im Rahmen des Planungsprozesses getroffen werden.</p></div><div class=sect4><h5 id=_einen_nis_domänennamen_wählen>52.4.3.1. Einen NIS-Domänennamen wählen<a class=anchor href=#_einen_nis_domänennamen_wählen></a></h5><div class=paragraph><p>Wenn ein Client Informationen anfordert, ist in dieser Anforderung der Name der NIS-Domäne enthalten. Dadurch weiß jeder Server im Netzwerk, auf welche Anforderung er antworten muss. Stellen Sie sich den NIS-Domänennamen als einen Namen einer Gruppe von Rechnern vor.</p></div><div class=paragraph><p>Manchmal wird der Name der Internetdomäne auch für die NIS-Domäne verwendet. Dies ist allerdings nicht empfehlenswert, da es bei der Behebung von Problemen verwirrend sein kann. Der Name der NIS-Domäne sollte innerhalb des Netzwerks eindeutig sein. Hilfreich ist es, wenn der Name die Gruppe der in ihr zusammengefassten Rechner beschreibt. Die Kunstabteilung von Acme Inc. hätte daher vielleicht die NIS-Domäne "acme-art". Für dieses Beispiel wird der Name <code>test-domain</code> verwendet.</p></div><div class=paragraph><p>Es gibt jedoch auch Betriebssysteme, die als NIS-Domänennamen den Namen der Internetdomäne verwenden. Wenn dies für einen oder mehrere Rechner des Netzwerks zutrifft, <em>muss</em> der Name der Internetdomäne als NIS-Domänennamen verwendet werden.</p></div></div><div class=sect4><h5 id=_anforderungen_an_den_server>52.4.3.2. Anforderungen an den Server<a class=anchor href=#_anforderungen_an_den_server></a></h5><div class=paragraph><p>Bei der Wahl des NIS-Servers müssen einige Dinge beachtet werden. Da die NIS-Clients auf die Verfügbarkeit des Servers angewiesen sind, sollten Sie einen Rechner wählen, der nicht regelmäßig neu gestartet werden muss. Der NIS-Server sollte idealerweise ein alleinstehender Rechner sein, dessen einzige Aufgabe es ist, als NIS-Server zu dienen. Wenn das Netzwerk nicht zu stark ausgelastet ist, ist es auch möglich, den NIS-Server als weiteren Dienst auf einem anderen Rechner laufen zu lassen. Wenn jedoch ein NIS-Server ausfällt, wirkt sich dies negativ auf <em>alle</em> NIS-Clients aus.</p></div></div></div><div class=sect3><h4 id=_einen_nis_masterserver_konfigurieren>52.4.4. Einen NIS-Masterserver konfigurieren<a class=anchor href=#_einen_nis_masterserver_konfigurieren></a></h4><div class=paragraph><p>Die verbindlichen Kopien aller NIS-Dateien befinden sich auf dem Masterserver. Die Datenbanken, in denen die Informationen gespeichert sind, bezeichnet man als NIS-Maps. Unter FreeBSD werden diese Maps unter <span class=filename>/var/yp/[domainname]</span> gespeichert, wobei <span class=filename>[domainname]</span> der Name der NIS-Domäne ist. Da ein NIS-Server mehrere Domänen verwalten kann, können auch mehrere Verzeichnisse vorhanden sein. Jede Domäne verfügt über ein eigenes Verzeichnis sowie einen eigenen, von anderen Domänen unabhängigen Satz von NIS-Maps.</p></div><div class=paragraph><p>NIS-Master- und Slaveserver verwenden <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a>, um NIS-Anfragen zu bearbeiten. Dieser Daemon ist für eingehende Anfragen der NIS-Clients verantwortlich. Er ermittelt aus der angeforderten Domäne und Map einen Pfad zur entsprechenden Datenbank und sendet die angeforderten Daten von der Datenbank zum Client.</p></div><div class=paragraph><p>Abhängig von den Anforderungen ist die Einrichtung eines NIS-Masterservers relativ einfach, da NIS von FreeBSD bereits in der Standardkonfiguration unterstützt wird. Es kann durch folgende Zeilen in <span class=filename>/etc/rc.conf</span> aktiviert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;	 <i class=conum data-value=1></i><b>(1)</b>
nis_server_enable=&#34;YES&#34;		<i class=conum data-value=2></i><b>(2)</b>
nis_yppasswdd_enable=&#34;YES&#34; <i class=conum data-value=3></i><b>(3)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Diese Zeile setzt den NIS-Domänennamen auf <code>test-domain</code>.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Dadurch werden die NIS-Serverprozesse beim Systemstart automatisch ausgeführt.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Durch diese Zeile wird der <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.yppasswdd&amp;sektion=8&amp;format=html">rpc.yppasswdd(8)</a>-Daemon aktiviert, der die Änderung von NIS-Passwörtern von einem Client aus ermöglicht.</td></tr></tbody></table></div><div class=paragraph><p>Wird ypserv in einer Multi-Serverdomäne verwendet, in der NIS-Server gleichzeitig als NIS-Clients arbeiten, ist es eine gute Idee, diese Server zu zwingen, sich an sich selbst zu binden. Damit wird verhindert, dass Bindeanforderungen gesendet werden und sich die Server gegenseitig binden. Sonst könnten seltsame Fehler auftreten, wenn ein Server ausfällt, auf den andere Server angewiesen sind. Letztlich werden alle Clients einen Timeout melden, und versuchen, sich an andere Server zu binden. Die dadurch entstehende Verzögerung kann beträchtlich sein. Außerdem kann der Fehler erneut auftreten, da sich die Server wiederum aneinander binden könnten.</p></div><div class=paragraph><p>Server, die auch als Client arbeiten, können durch das Hinzufügen der folgenden Zeilen in <span class=filename>/etc/rc.conf</span> zu gezwungen werden, sich an einen bestimmten Server zu binden:</p></div><div class="literalblock programlisting"><div class=content><pre>nis_client_enable=&#34;YES&#34; <i class=conum data-value=1></i><b>(1)</b>
nis_client_flags=&#34;-S test-domain,server&#34; <i class=conum data-value=2></i><b>(2)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Ermöglicht die Aktivierung der Client-Komponenten.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Diese Zeile setzt den NIS-Domain Namen <code>test-domain</code> und bindet sich an sich selbst.</td></tr></tbody></table></div><div class=paragraph><p>Nachdem die Parameter konfiguriert wurden, muss noch <code>/etc/netstart</code> ausgeführt werden, um alles entsprechend den Vorgaben in <span class=filename>/etc/rc.conf</span> einzurichten. Bevor die NIS-Maps einrichtet werden können, muss der <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a>-Daemon manuell gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ypserv start</span></code></pre></div></div><div class=sect4><h5 id=_die_nis_maps_initialisieren>52.4.4.1. Die NIS-Maps initialisieren<a class=anchor href=#_die_nis_maps_initialisieren></a></h5><div class=paragraph><p>NIS-Maps Sie werden am NIS-Masterserver aus den Konfigurationsdateien unter <span class=filename>/etc</span> erzeugt. Einzige Ausnahme: <span class=filename>/etc/master.passwd</span>. Dies verhindert, dass die Passwörter für <code>root</code>- oder andere Administratorkonten an alle Server in der NIS-Domäne verteilt werden. Deshalb werden die primären Passwort-Dateien konfiguriert, bevor die NIS-Maps initialisiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/master.passwd /var/yp/master.passwd</span>
<span class=c># cd /var/yp</span>
<span class=c># vi master.passwd</span></code></pre></div></div><div class=paragraph><p>Es ist ratsam, alle Einträge für Systemkonten sowie Benutzerkonten, die nicht an die NIS-Clients weitergegeben werden sollen, wie beispielsweise <code>root</code> und weitere administrative Konten, zu entfernen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Stellen Sie sicher, dass <span class=filename>/var/yp/master.passwd</span> weder von der Gruppe noch von der Welt gelesen werden kann, indem Sie Zugriffsmodus auf <code>600</code> einstellen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nun können die NIS-Maps initialisiert werden. FreeBSD verwendet dafür das Skript <a href="https://man.freebsd.org/cgi/man.cgi?query=ypinit&amp;sektion=8&amp;format=html">ypinit(8)</a>. Geben Sie <code>-m</code> und den NIS-Domänennamen an, wenn Sie NIS-Maps für den Masterserver erzeugen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# ypinit <span class=nt>-m</span> test-domain
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n] n
Ok, please remember to go back and redo manually whatever fails.
If not, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please <span class=k>continue </span>to add any slave servers, one per line. When you are
<span class=k>done </span>with the list, <span class=nb>type </span>a &lt;control D&gt;.
master server   :  ellington
next host to add:  coltrane
next host to add:  ^D
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  <span class=o>[</span>y/n: y] y

<span class=o>[</span>..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</code></pre></div></div><div class=paragraph><p>Dadurch erzeugt <code>ypinit</code><span class=filename>/var/yp/Makefile</span> aus <span class=filename>/var/yp/Makefile.dist</span>. Diese Datei geht in der Voreinstellung davon aus, dass in einer NIS-Umgebung mit nur einem Server gearbeitet wird und dass alle Clients unter FreeBSD laufen. Da <code>test-domain</code> aber auch über einen Slaveserver verfügt, muss <span class=filename>/var/yp/Makefile</span> entsprechend angepasst werden, sodass es mit einem Kommentar (<code>#</code>) beginnt:</p></div><div class="literalblock programlisting"><div class=content><pre>NOPUSH = &#34;True&#34;</pre></div></div></div><div class=sect4><h5 id=_neue_benutzer_hinzufügen>52.4.4.2. Neue Benutzer hinzufügen<a class=anchor href=#_neue_benutzer_hinzufügen></a></h5><div class=paragraph><p>Jedes Mal, wenn ein neuer Benutzer angelegt wird, muss er am NIS-Masterserver hinzugefügt und die NIS-Maps anschließend neu erzeugt werden. Wird dieser Punkt vergessen, kann sich der neue Benutzer <em>nur</em> am NIS-Masterserver anmelden. Um beispielsweise den neuen Benutzer <code>jsmith</code> zur Domäne <code>test-domain</code> hinzufügen wollen, müssen folgende Kommandos auf dem Masterserver ausgeführt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd jsmith</span>
<span class=c># cd /var/yp</span>
<span class=c># make test-domain</span></code></pre></div></div><div class=paragraph><p>Statt <code>pw useradd jsmith</code> kann auch <code>adduser jsmith</code> verwendet werden.</p></div></div></div><div class=sect3><h4 id=_einen_nis_slaveserver_einrichten>52.4.5. Einen NIS-Slaveserver einrichten<a class=anchor href=#_einen_nis_slaveserver_einrichten></a></h4><div class=paragraph><p>Um einen NIS-Slaveserver einzurichten, melden Sie sich am Slaveserver an und bearbeiten Sie <span class=filename>/etc/rc.conf</span> analog zum Masterserver. Erzeugen Sie aber keine NIS-Maps, da diese bereits auf dem Server vorhanden sind. Wenn <code>ypinit</code> auf dem Slaveserver ausgeführt wird, benutzen Sie <code>-s</code> (Slave) statt <code>-m</code> (Master). Diese Option benötigt den Namen des NIS-Masterservers und den Domänennamen, wie in diesem Beispiel zu sehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>coltrane# ypinit <span class=nt>-s</span> ellington test-domain

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If not, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Remember to update map ypservers on ellington.</code></pre></div></div><div class=paragraph><p>Hierbei wird auf dem Slaveserver ein Verzeichnis namens <span class=filename>/var/yp/test-domain</span> erstellt, welches Kopien der NIS-Masterserver-Maps enthält. Durch hinzufügen der folgenden Zeilen in <span class=filename>/etc/crontab</span> wird der Slaveserver angewiesen, seine Maps mit den Maps des Masterservers zu synchronisieren:</p></div><div class="literalblock programlisting"><div class=content><pre>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</pre></div></div><div class=paragraph><p>Diese Einträge sind nicht zwingend notwendig, da der Masterserver automatisch versucht, alle Änderungen seiner NIS-Maps an seine Slaveserver weiterzugeben. Da Passwortinformationen aber auch für nur vom Slaveserver abhängige Systeme vital sind, ist es eine gute Idee, diese Aktualisierungen zu erzwingen. Besonders wichtig ist dies in stark ausgelasteten Netzen, in denen Map-Aktualisierungen unvollständig sein könnten.</p></div><div class=paragraph><p>Um die Konfiguration abzuschließen, führen Sie <code>/etc/netstart</code> auf dem Slaveserver aus, um die NIS-Dienste erneut zu starten.</p></div></div><div class=sect3><h4 id=_einen_nis_client_einrichten>52.4.6. Einen NIS-Client einrichten<a class=anchor href=#_einen_nis_client_einrichten></a></h4><div class=paragraph><p>Ein NIS-Client <code>bindet</code> sich unter Verwendung von <code>ypbind</code> an einen NIS-Server. Dieser Daemon sendet RPC-Anfragen auf dem lokalen Netzwerk. Diese Anfragen legen den Namen der Domäne fest, die auf dem Client konfiguriert ist. Wenn der Server der entsprechenden Domäne eine solche Anforderung erhält, schickt er eine Antwort an <code>ypbind</code>, das wiederum die Adresse des Servers speichert. Wenn mehrere Server verfügbar sind, verwendet der Client die erste erhaltene Adresse und richtet alle Anfragen an genau diesen Server. <code>ypbind</code> "pingt" den Server gelegentlich an, um sicherzustellen, dass der Server funktioniert. Antwortet der Server innerhalb eines bestimmten Zeitraums nicht (Timeout), markiert <code>ypbind</code> die Domäne als ungebunden und beginnt erneut, RPCs über das Netzwerk zu verteilen, um einen anderen Server zu finden.</p></div><div class=paragraph><p>Einen FreeBSD-Rechner als NIS-Client einrichten:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> ein, um den NIS-Domänennamen festzulegen, und um <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a> bei der Initialisierung des Netzwerks zu starten:</p><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;
nis_client_enable=&#34;YES&#34;</pre></div></div></li><li><p>Um alle Passworteinträge des NIS-Servers zu importieren, löschen Sie alle Benutzerkonten in <span class=filename>/etc/master.passwd</span> mit <code>vipw</code>. Denken Sie daran, zumindest ein lokales Benutzerkonto zu behalten. Dieses Konto sollte außerdem Mitglied der Gruppe <code>wheel</code> sein. Wenn es mit NIS Probleme gibt, können Sie diesen Zugang verwenden, um sich als Superuser anzumelden und das Problem zu beheben. Bevor Sie die Änderungen speichern, fügen Sie folgende Zeile am Ende der Datei hinzu:</p><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class=paragraph><p>Diese Zeile legt für alle gültigen Benutzerkonten der NIS-Server-Maps einen Zugang an. Es gibt verschiedene Wege, den NIS-Client durch Änderung dieser Zeile zu konfigurieren. Eine Methode wird in <a href=#network-netgroups>Netzgruppen verwenden</a> beschrieben. Weitere detaillierte Informationen finden Sie im Buch <code>Managing NFS and NIS</code> vom O’Reilly Verlag.</p></div></li><li><p>Um alle möglichen Gruppeneinträge vom NIS-Server zu importieren, fügen Sie folgende Zeile in <span class=filename>/etc/group</span> ein:</p><div class="literalblock programlisting"><div class=content><pre>+:*::</pre></div></div></li></ol></div><div class=paragraph><p>Um den NIS-Client direkt zu starten, führen Sie als Superuser die folgenden Befehle aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/netstart</span>
<span class=c># service ypbind start</span></code></pre></div></div><div class=paragraph><p>Danach sollte bei der Eingabe von <code>ypcat passwd</code> auf dem Client die <code>passwd-Map</code> des NIS-Servers angezeigt werden.</p></div></div><div class=sect3><h4 id=_sicherheit_unter_nis>52.4.7. Sicherheit unter NIS<a class=anchor href=#_sicherheit_unter_nis></a></h4><div class=paragraph><p>Da RPC ein Broadcast-basierter Dienst ist, kann jedes System innerhalb der Domäne mittels ypbind den Inhalt der NIS-Maps abrufen. Um nicht autorisierte Transaktionen zu verhindern, unterstützt <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> eine Funktion namens "securenets", durch die der Zugriff auf bestimmte Rechner beschränkt werden kann. In der Voreinstellung sind diese Informationen in <span class=filename>/var/yp/securenets</span> gespeichert, es sei denn, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> wurde mit der Option <code>-p</code> und einem alternativen Pfad gestartet. Diese Datei enthält Einträge, die aus einer Netzwerkadresse und einer Netzmaske bestehen. Kommentarzeilen beginnen mit "#". <span class=filename>/var/yp/securnets</span> könnte beispielsweise so aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0</pre></div></div><div class=paragraph><p>Wenn <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> eine Anforderung von einer zu diesen Regeln passenden Adresse erhält, wird die Anforderung bearbeitet. Gibt es keine passende Regel, wird die Anforderung ignoriert und eine Warnmeldung aufgezeichnet. Wenn <span class=filename>securenets</span> nicht existiert, erlaubt <code>ypserv</code> Verbindungen von jedem Rechner.</p></div><div class=paragraph><p><a href=./#tcpwrappers>TCP Wrapper</a> beschreibt eine alternative Methode zur Zugriffskontrolle. Obwohl beide Methoden einige Sicherheit gewähren, sind sie anfällig für "IP-Spoofing"-Angriffe. Der NIS-Verkehr sollte daher von einer Firewall blockiert werden.</p></div><div class=paragraph><p>Server, die <span class=filename>securenets</span> verwenden, können Schwierigkeiten bei der Anmeldung von NIS-Clients haben, die ein veraltetes TCP/IP-Subsystem besitzen. Einige dieser TCP/IP-Subsysteme setzen alle Rechnerbits auf Null, wenn sie einen <code>Broadcast</code> durchführen oder können die Subnetzmaske nicht auslesen, wenn sie die Broadcast-Adresse berechnen. Einige Probleme können durch Änderungen der Clientkonfiguration behoben werden. Andere hingegen lassen sich nur durch das Entfernen des betreffenden Rechners aus dem Netzwerk oder den Verzicht auf <span class=filename>securenets</span> umgehen.</p></div><div class=paragraph><p>Die Verwendung der TCP-Wrapper verlangsamt die Reaktion des NIS-Servers. Diese zusätzliche Reaktionszeit kann in Clientprogrammen zu Timeouts führen. Dies vor allem in Netzwerken, die stark ausgelastet sind, oder nur über langsame NIS-Server verfügen. Wenn ein oder mehrere Clients dieses Problem aufweisen, sollten Sie die betreffenden Clients in NIS-Slaveserver umwandeln, und diese an sich selbst binden.</p></div><div class=sect4><h5 id=_bestimmte_benutzer_an_der_anmeldung_hindern>52.4.7.1. Bestimmte Benutzer an der Anmeldung hindern<a class=anchor href=#_bestimmte_benutzer_an_der_anmeldung_hindern></a></h5><div class=paragraph><p>In diesem Beispiel gibt es innerhalb der NIS-Domäne den Rechner <code>basie</code>, der nur für Mitarbeiter der Fakultät bestimmt ist. Die <span class=filename>passwd</span> Datenbank des NIS-Masterservers enthält Benutzerkonten sowohl für Fakultätsmitarbeiter als auch für Studenten. Dieser Abschnitt beschreibt, wie Sie den Mitarbeitern der Fakultät die Anmeldung am System ermöglichen, während den Studenten die Anmeldung verweigert wird.</p></div><div class=paragraph><p>Es gibt eine Möglichkeit, bestimmte Benutzer an der Anmeldung an einem bestimmten Rechner zu hindern, selbst wenn diese in der NIS-Datenbank vorhanden sind. Dazu kann mit <code>vipw</code> der Eintrag <code>-<em>Benutzername</em></code> und die richtige Anzahl von Doppelpunkten an das Ende von <span class=filename>/etc/master.passwd</span> gesetzt werden, wobei <em>Benutzername</em> der zu blockierende Benutzername ist. Die Zeile mit dem geblockten Benutzer muss dabei vor der <code>+</code> Zeile, für zugelassene Benutzer stehen. In diesem Beispiel wird die Anmeldung für den Benutzer <code>bill</code> am Rechner <code>basie</code> blockiert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>basie# <span class=nb>cat</span> /etc/master.passwd
root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:<span class=k>*</span>:1:1::0:0:Owner of many system processes:/root:/usr/sbin/nologin
operator:<span class=k>*</span>:2:5::0:0:System &amp;:/:/usr/sbin/nologin
bin:<span class=k>*</span>:3:7::0:0:Binaries Commands and Source,,,:/:/usr/sbin/nologin
<span class=nb>tty</span>:<span class=k>*</span>:4:65533::0:0:Tty Sandbox:/:/usr/sbin/nologin
kmem:<span class=k>*</span>:5:65533::0:0:KMem Sandbox:/:/usr/sbin/nologin
games:<span class=k>*</span>:7:13::0:0:Games pseudo-user:/usr/games:/usr/sbin/nologin
news:<span class=k>*</span>:8:8::0:0:News Subsystem:/:/usr/sbin/nologin
man:<span class=k>*</span>:9:9::0:0:Mister Man Pages:/usr/shared/man:/usr/sbin/nologin
<span class=nb>bind</span>:<span class=k>*</span>:53:53::0:0:Bind Sandbox:/:/usr/sbin/nologin
uucp:<span class=k>*</span>:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:<span class=k>*</span>:67:67::0:0:X-10 daemon:/usr/local/xten:/usr/sbin/nologin
pop:<span class=k>*</span>:68:6::0:0:Post Office Owner:/nonexistent:/usr/sbin/nologin
nobody:<span class=k>*</span>:65534:65534::0:0:Unprivileged user:/nonexistent:/usr/sbin/nologin
<span class=nt>-bill</span>:::::::::
+:::::::::

basie#</code></pre></div></div></div></div><div class=sect3><h4 id=network-netgroups>52.4.8. Netzgruppen verwenden<a class=anchor href=#network-netgroups></a></h4><div class=paragraph><p>Bestimmten Benutzern die Anmeldung an einzelnen Systemen zu verweigern, kann in großen Netzwerken schnell unübersichtlich werden. Dadurch verlieren Sie den Hauptvorteil von NIS: die <em>zentrale</em> Verwaltung.</p></div><div class=paragraph><p>Netzgruppen wurden entwickelt, um große, komplexe Netzwerke mit Hunderten Benutzern und Rechnern zu verwalten. Ihre Aufgabe ist vergleichbar mit UNIX® Gruppen. Die Hauptunterschiede sind das Fehlen einer numerischen ID sowie die Möglichkeit, Netzgruppen zu definieren, die sowohl Benutzer als auch andere Netzgruppen enthalten.</p></div><div class=paragraph><p>Um das Beispiel in diesem Kapitel fortzuführen, wird die NIS-Domäne um zusätzliche Benutzer und Rechner erweitert:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 26. Zusätzliche Benutzer</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Benutzername(n)</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>alpha</code>, <code>beta</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mitarbeiter der IT-Abteilung</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>charlie</code>, <code>delta</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lehrlinge der IT-Abteilung</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>echo</code>, <code>foxtrott</code>, <code>golf</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mitarbeiter</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>able</code>, <code>baker</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Praktikanten</p></td></tr></tbody></table><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 27. Zusätzliche Rechner</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Rechnername(n)</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>war</code>, <code>death</code>, <code>famine</code>, <code>pollution</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nur Mitarbeiter der IT-Abteilung dürfen sich an diesen Rechnern anmelden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pride</code>, <code>greed</code>, <code>envy</code>, <code>wrath</code>, <code>lust</code>, <code>sloth</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nur Mitarbeiter und Lehrlinge der IT-Abteilung dürfen sich auf diesen Rechnern anmelden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>one</code>, <code>two</code>, <code>three</code>, <code>four</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gewöhnliche Arbeitsrechner für Mitarbeiter.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>trashcan</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein sehr alter Rechner ohne kritische Daten. Sogar Praktikanten dürfen diesen Rechner verwenden.</p></td></tr></tbody></table><div class=paragraph><p>Bei der Verwendung von Netzgruppen wird jeder Benutzer einer oder mehreren Netzgruppen zugewiesen und die Anmeldung wird dann für die Netzgruppe erlaubt oder verwehrt. Wenn ein neuer Rechner hinzugefügt wird, müssen die Zugangsbeschränkungen nur für die Netzgruppen festgelegt werden. Wird ein neuer Benutzer angelegt, muss er einer oder mehreren Netzgruppen zugewiesen werden. Wenn die Einrichtung von NIS sorgfältig geplant wurde, muss nur noch eine zentrale Konfigurationsdatei bearbeitet werden, um den Zugriff auf bestimmte Rechner zu erlauben oder zu verbieten.</p></div><div class=paragraph><p>Dieses Beispiel erstellt vier Netzgruppen: IT-Mitarbeiter, IT-Lehrlinge, normale Mitarbeiter sowie Praktikanten:</p></div><div class="literalblock programlisting"><div class=content><pre>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
        (,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</pre></div></div><div class=paragraph><p>Jede Zeile konfiguriert eine Netzgruppe. Die erste Spalte der Zeile bezeichnet den Namen der Netzgruppe. Die Einträge in den Klammern stehen entweder für eine Gruppe von einem oder mehreren Benutzern, oder für den Namen einer weiteren Netzgruppe. Wenn ein Benutzer angegeben wird, haben die drei Felder in der Klammer folgende Bedeutung:</p></div><div class="olist arabic"><ol class=arabic><li><p>Der Name des Rechner(s), auf dem die weiteren Felder für den Benutzer gültig sind. Wird kein Rechnername festgelegt, ist der Eintrag auf allen Rechnern gültig.</p></li><li><p>Der Name des Benutzerkontos, der zu dieser Netzgruppe gehört.</p></li><li><p>Die NIS-Domäne für das Benutzerkonto. Benutzerkonten können von anderen NIS-Domänen in eine Netzgruppe importiert werden.</p></li></ol></div><div class=paragraph><p>Wenn eine Gruppe mehrere Benutzer enthält, müssen diese durch Leerzeichen getrennt werden. Darüber hinaus kann jedes Feld Wildcards enthalten. Weitere Einzelheiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=netgroup&amp;sektion=5&amp;format=html">netgroup(5)</a>.</p></div><div class=paragraph><p>Netzgruppennamen sollten nicht länger als 8 Zeichen sein. Es wird zwischen Groß- und Kleinschreibung unterschieden. Die Verwendung von Großbuchstaben für Netzgruppennamen ermöglicht eine leichte Unterscheidung zwischen Benutzern, Rechnern und Netzgruppen.</p></div><div class=paragraph><p>Einige NIS-Clients (dies gilt nicht für FreeBSD) können keine Netzgruppen mit mehr als 15 Einträgen verwalten. Diese Grenze kann umgangen werden, indem mehrere Subnetzgruppen mit weniger als fünfzehn Benutzern angelegt werden und diese Subnetzgruppen wiederum in einer Netzgruppe zusammengefasst wird, wie in diesem Beispiel zu sehen:</p></div><div class="literalblock programlisting"><div class=content><pre>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</pre></div></div><div class=paragraph><p>Wiederholen Sie diesen Vorgang, wenn mehr als 225 (15*15) Benutzer in einer einzigen Netzgruppe existieren.</p></div><div class=paragraph><p>Die neue NIS-Map aktivieren und verteilen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# <span class=nb>cd</span> /var/yp
ellington# make</code></pre></div></div><div class=paragraph><p>Dadurch werden die NIS-Maps <span class=filename>netgroup</span>, <span class=filename>netgroup.byhost</span> und <span class=filename>netgroup.byuser</span> erzeugt. Prüfen Sie die Verfügbarkeit der neuen NIS-Maps mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ypcat&amp;sektion=1&amp;format=html">ypcat(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington% ypcat <span class=nt>-k</span> netgroup
ellington% ypcat <span class=nt>-k</span> netgroup.byhost
ellington% ypcat <span class=nt>-k</span> netgroup.byuser</code></pre></div></div><div class=paragraph><p>Die Ausgabe des ersten Befehls gibt den Inhalt von <span class=filename>/var/yp/netgroup</span> wieder. Der zweite Befehl erzeugt nur dann eine Ausgabe, wenn rechnerspezifische Netzgruppen erzeugt wurden. Der dritte Befehl gibt die Netzgruppen nach Benutzern sortiert aus.</p></div><div class=paragraph><p>Wenn Sie einen Client einrichten, verwenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> um den Namen der Netzgruppe anzugeben. Ersetzen Sie beispielsweise auf dem Server namens <code>war</code> die folgende Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class=paragraph><p>durch</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::</pre></div></div><div class=paragraph><p>ersetzt werden.</p></div><div class=paragraph><p>Diese Zeile legt fest, dass nur noch Benutzer der Netzgruppe <code>IT_EMP</code> in die Passwortdatenbank dieses Systems importiert werden. Nur diese Benutzer dürfen sich an diesem Server anmelden.</p></div><div class=paragraph><p>Diese Konfiguration gilt auch für die <code>~</code>-Funktion der Shell und für alle Routinen, die auf Benutzernamen und numerische Benutzer-IDs zugreifen. Oder anders formuliert, <code>cd ~<em>Benutzer</em></code> ist nicht möglich, <code>ls -l</code> zeigt die numerische Benutzer-ID statt dem Benutzernamen und <code>find . -user joe -print</code> erzeugt die Fehlermeldung <code>No such user</code>. Um dieses Problem zu beheben, müssen alle Benutzereinträge importiert werden, ohne ihnen jedoch zu erlauben, sich am Server anzumelden. Dies kann durch das Hinzufügen einer zusätzlichen Zeile erreicht werden:</p></div><div class="literalblock programlisting"><div class=content><pre>+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>Diese Zeile weist den Client an, alle Einträge zu importieren, aber die Shell in diesen Einträgen durch <span class=filename>/usr/sbin/nologin</span> zu ersetzen.</p></div><div class=paragraph><p>Stellen Sie sicher, dass die zusätzliche Zeile <em>nach</em> der Zeile <code>+@IT_EMP:::::::::</code> eingetragen ist. Andernfalls haben alle via NIS importierten Benutzerkonten <span class=filename>/usr/sbin/nologin</span> als Loginshell und niemand wird sich mehr am System anmelden können.</p></div><div class=paragraph><p>Um die weniger wichtigen Server zu konfigurieren, ersetzen Sie den alten Eintrag <code>+:::::::::</code> auf den Servern mit diesen Zeilen:</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>Die entsprechenden Zeilen für Arbeitsplätze lauten:</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>NIS ist in der Lage, Netzgruppen aus anderen Netzgruppen zu bilden. Dies kann nützlich sein, wenn sich die Firmenpolitik ändert. Eine Möglichkeit ist die Erzeugung rollenbasierter Netzgruppen. Sie könnten eine Netzgruppe <code>BIGSRV</code> erzeugen, um den Zugang zu den wichtigsten Servern zu beschränken, eine weitere Gruppe <code>SMALLSRV</code> für die weniger wichtigen Server und eine dritte Netzgruppe <code>USERBOX</code> für die Arbeitsplatzrechner. Jede dieser Netzgruppen enthält die Netzgruppen, die sich auf diesen Rechnern anmelden dürfen. Die Einträge der Netzgruppen in der NIS-Map sollten ähnlich den folgenden aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</pre></div></div><div class=paragraph><p>Diese Methode funktioniert besonders gut, wenn Rechner in Gruppen mit identischen Beschränkungen eingeteilt werden können. Unglücklicherweise ist dies die Ausnahme und nicht die Regel. Meistens wird die Möglichkeit zur rechnerspezischen Zugangsbeschränkung benötigt.</p></div><div class=paragraph><p>Rechnerspezifische Netzgruppen sind eine weitere Möglichkeit, um mit den oben beschriebenen Änderungen umzugehen. In diesem Szenario enthält <span class=filename>/etc/master.passwd</span> auf jedem Rechner zwei mit "+" beginnende Zeilen. Die erste Zeile legt die Netzgruppe mit den Benutzern fest, die sich auf diesem Rechner anmelden dürfen. Die zweite Zeile weist allen anderen Benutzern <span class=filename>/usr/sbin/nologin</span> als Shell zu. Verwenden Sie auch hier (analog zu den Netzgruppen) Großbuchstaben für die Rechnernamen:</p></div><div class="literalblock programlisting"><div class=content><pre>+@BOXNAME:::::::::
+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>Sobald dies für alle Rechner erledigt ist, müssen die lokalen Versionen von <span class=filename>/etc/master.passwd</span> nie mehr verändert werden. Alle weiteren Änderungen geschehen über die NIS-Maps. Nachfolgend ein Beispiel für eine mögliche Netzgruppen-Map:</p></div><div class="literalblock programlisting"><div class=content><pre># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION  BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]</pre></div></div><div class=paragraph><p>Es ist nicht immer ratsam, rechnerbasierte Netzgruppen zu verwenden. Wenn Dutzende oder Hunderte identische Rechner eingerichtet werden müssen, sollten rollenbasierte Netzgruppen verwendet werden, um die Größe der NIS-Maps in Grenzen zu halten.</p></div></div><div class=sect3><h4 id=_passwortformate>52.4.9. Passwortformate<a class=anchor href=#_passwortformate></a></h4><div class=paragraph><p>Alle Rechner innerhalb der NIS-Domäne müssen für die Verschlüsselung von Passwörtern das gleiche Format benutzen. Wenn Benutzer Schwierigkeiten bei der Authentifizierung auf einem NIS-Client haben, liegt dies möglicherweise an einem anderen Passwort-Format. In einem heterogenen Netzwerk muss das verwendete Format von allen Betriebssystemen unterstützt werden, wobei DES der kleinste gemeinsame Standard ist.</p></div><div class=paragraph><p>Welches Format die Server und Clients verwenden, steht in <span class=filename>/etc/login.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[weitere Einträge]</pre></div></div><div class=paragraph><p>In diesem Beispiel verwendet das System das Format DES. Weitere mögliche Werte sind unter anderem <code>blf</code> und <code>md5</code> (mit Blowfish und MD5 verschlüsselte Passwörter).</p></div><div class=paragraph><p>Wird auf einem Rechner das Format entsprechend der NIS-Domäne geändert, muss anschließend die Login-Capability Datenbank neu erstellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Das Format der schon bestehenden Passwörter wird erst aktualisiert, wenn ein Benutzer sein Passwort ändert, <em>nachdem</em> die Datenbank neu erstellt wurde.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-ldap>52.5. Lightweight Access Directory Protocol (LDAP)<a class=anchor href=#network-ldap></a></h3><div class=paragraph><p>Das Lightweight Directory Access Protocol (LDAP) ist ein Protokoll der Anwendungsschicht, das verwendet wird um Objekte mithilfe eines verteilten Verzeichnisdienstes abzurufen, zu verändern und zu authentifizieren. Betrachten Sie es als ein Telefonbuch, das homogene Informationen in mehreren hierarchischen Ebenen speichert. Es wird in Active Directory und OpenLDAP-Netzwerken eingesetzt, in denen Benutzer unter Verwendung eines einzigen Kontos auf diverse interne Informationen zugreifen. Beispielsweise kann E-Mail-Authentifizierung, Abfrage von Kontaktinformationen und Website-Authentifizierung über ein einzelnes Benutzerkonto aus der Datenbank des LDAP-Servers erfolgen.</p></div><div class=paragraph><p>Dieser Abschnitt enthält eine kompakte Anleitung, um einen LDAP-Server auf einem FreeBSD-System zu konfigurieren. Es wird vorausgesetzt, dass der Administrator bereits einen Plan erarbeitet hat, der verschiedene Punkte umfasst, unter anderem die Art der zu speichernden Informationen, für was die Informationen verwendet werden, welche Benutzer Zugriff auf die Informationen haben und wie die Informationen vor unbefugtem Zugriff geschützt werden.</p></div><div class=sect3><h4 id=_ldap_terminologie_und_struktur>52.5.1. LDAP Terminologie und Struktur<a class=anchor href=#_ldap_terminologie_und_struktur></a></h4><div class=paragraph><p>LDAP verwendet mehrere Begriffe die Sie verstehen sollten bevor Sie die Konfiguration beginnen. Alle Verzeichniseinträge bestehen aus einer Gruppe von <em>Attributen</em>. Jede Attributgruppe enthält einen eindeutigen Bezeichner, der als distinguished name (DN) bekannt ist. Dieser setzt sich normalerweise aus mehreren anderen Attributen, wie dem Relative Distinguished Name (RDN) zusammen. Wie bei Verzeichnissen gibt es auch hier absolute und relative Pfade. Betrachten Sie DN als absoluten Pfad und RDN als relativen Pfad.</p></div><div class=paragraph><p>Beispielsweise könnte ein LDAP-Eintrag wie folgt aussehen. Dieses Beispiel sucht nach dem Eintrag für das angegebene Benutzerkonto (<code>uid</code>), Organisationseinheit (<code>ou</code> und Organisation (<code>o</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ldapsearch <span class=nt>-xb</span> <span class=s2>&#34;uid=trhodes,ou=users,o=example.com&#34;</span>
<span class=c># extended LDIF</span>

<span class=c>#</span>
<span class=c># LDAPv3</span>
<span class=c># base &lt;uid=trhodes,ou=users,o=example.com&gt; with scope subtree</span>
<span class=c># filter: (objectclass=*)</span>
<span class=c># requesting: ALL</span>
<span class=c>#</span>

<span class=c># trhodes, users, example.com</span>
dn: <span class=nv>uid</span><span class=o>=</span>trhodes,ou<span class=o>=</span><span class=nb>users</span>,o<span class=o>=</span>example.com
mail: trhodes@example.com
cn: Tom Rhodes
uid: trhodes
telephoneNumber: <span class=o>(</span>123<span class=o>)</span> 456-7890

<span class=c># search result</span>
search: 2
result: 0 Success

<span class=c># numResponses: 2</span>
<span class=c># numEntries:1</span></code></pre></div></div><div class=paragraph><p>Die Einträge in diesem Beispiel zeigen die Werte für die Attribute <code>dn</code>, <code>mail</code>, <code>cn</code>, <code>uid</code> und <code>telephoneNumber</code>. Das Attribut <code>cn</code> ist der RDN.</p></div><div class=paragraph><p>Weitere Informationen über LDAP und dessen Terminologie finden Sie unter <a href=http://www.openldap.org/doc/admin24/intro.html>http://www.openldap.org/doc/admin24/intro.html</a>.</p></div></div><div class=sect3><h4 id=ldap-config>52.5.2. Konfiguration eines LDAP-Servers<a class=anchor href=#ldap-config></a></h4><div class=paragraph><p>FreeBSD integriert keinen LDAP-Server. Beginnen Sie die Konfiguration mit der Installation des Ports oder Pakets <a class=package href=https://cgit.freebsd.org/ports/tree/net/openldap-server/>net/openldap-server</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install openldap-server</span></code></pre></div></div><div class=paragraph><p>Im <a href=https://docs.freebsd.org/de/articles/linux-users/##software>Paket</a> sind eine große Anzahl an Optionen aktiviert. Mit dem Befehl <code>pkg info openldap-server</code> können diese überprüft werden. Falls die Optionen nicht ausreichend sind (weil bspw. SQL-Unterstützung benötigt wird), sollten Sie in Betracht ziehen, den Port mit dem entsprechenden Framework neu zu übersetzen.</p></div><div class=paragraph><p>Während der Installation wird für die Daten das Verzeichnis <span class=filename>/var/db/openldap-data</span> erstellt. Das Verzeichnis für die Ablage der Zertifikate muss manuell angelegt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /usr/local/etc/openldap/private</span></code></pre></div></div><div class=paragraph><p>Im nächsten Schritt wird die Zertifizierungsstelle konfiguriert. Die folgenden Befehle müssen in <span class=filename>/usr/local/etc/openldap/private</span> ausgeführt werden. Dies ist wichtig, da die Dateiberechtigungen restriktiv gesetzt werden und Benutzer keinen direkten Zugriff auf diese Daten haben sollten. Weitere Informationen über Zertifikate und deren Parameter finden Sie im <a href=./#openssl>OpenSSL</a>. Geben Sie folgenden Befehl ein, um die Zertifizierungsstelle zu erstellen und folgen Sie den Anweisungen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -days 365 -nodes -new -x509 -keyout ca.key -out ../ca.crt</span></code></pre></div></div><div class=paragraph><p>Diese Einträge sind frei wählbar, <em>mit Ausnahme</em> von <em>Common Name</em>. Hier muss etwas anderes als der Hostname des Systems eingetragen werden. Wenn ein selbstsigniertes Zertifikat verwendet wird, stellen Sie dem Hostnamen einfach das Präfix <code>CA</code> für die Zertifizierungsstelle voran.</p></div><div class=paragraph><p>Die nächste Aufgabe besteht darin, einen Zertifikatsregistrierungsanforderung (CSR) sowie einen privaten Schlüssel zu erstellen. Geben Sie folgenden Befehl ein und folgen Sie den Anweisungen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -days 365 -nodes -new -keyout server.key -out server.csr</span></code></pre></div></div><div class=paragraph><p>Stellen Sie hierbei sicher, dass <code>Common Name</code> richtig eingetragen wird. Die Zertifikatsregistrierungsanforderung muss mit dem Schlüssel der Zertifizierungsstelle unterschrieben werden, um als gültiges Zertifikat verwendet zu werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl x509 -req -days 365 -in server.csr -out ../server.crt -CA ../ca.crt -CAkey ca.key -CAcreateserial</span></code></pre></div></div><div class=paragraph><p>Der letzte Schritt für die Erstellung der Zertifikate besteht darin, die Client-Zertifikate zu erstellen und zu signieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -days 365 -nodes -new -keyout client.key -out client.csr</span>
<span class=c># openssl x509 -req -days 3650 -in client.csr -out ../client.crt -CAkey ca.key</span></code></pre></div></div><div class=paragraph><p>Achten Sie wieder auf das Attribut <code>Common name</code>. Stellen Sie außerdem sicher, dass bei diesem Verfahren acht (8) neue Dateien erzeugt worden sind.</p></div><div class=paragraph><p>Der Daemon, auf dem der OpenLDAP-Server läuft, heißt <span class=filename>slapd</span>. Die Konfiguration erfolgt über <span class=filename>slapd.ldif</span>. Die alte <span class=filename>slapd.conf</span> wird von OpenLDAP nicht mehr verwendet.</p></div><div class=paragraph><p><a href=http://www.openldap.org/doc/admin24/slapdconf2.html>Konfigurationsbeispiele</a> für <span class=filename>slapd.ldif</span> finden sich auch in <span class=filename>/usr/local/etc/openldap/slapd.ldif.sample</span>. Optionen sind in slapd-config(5) dokumentiert. Jeder Abschnitt in <span class=filename>slapd.ldif</span> wird, wie alle anderen LDAP-Attributgruppen, durch einen DN eindeutig identifiziert. Achten Sie darauf, dass keine Leerzeilen zwischen der Anweisung <code>dn:</code> und dem gewünschten Ende des Abschnitts verbleiben. Im folgenden Beispiel wird TLS verwendet, um einen sicheren Kanal zu implementieren. Der erste Abschnitt stellt die globale Konfiguration dar:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# See slapd-config(5) for details on configuration options.
# This file should NOT be world readable.
#
dn: cn=config
objectClass: olcGlobal
cn: config
#
#
# Define global ACLs to disable default read access.
#
olcArgsFile: /var/run/openldap/slapd.args
olcPidFile: /var/run/openldap/slapd.pid
olcTLSCertificateFile: /usr/local/etc/openldap/server.crt
olcTLSCertificateKeyFile: /usr/local/etc/openldap/private/server.key
olcTLSCACertificateFile: /usr/local/etc/openldap/ca.crt
#olcTLSCipherSuite: HIGH
olcTLSProtocolMin: 3.1
olcTLSVerifyClient: never</pre></div></div><div class=paragraph><p>Hier müssen die Zertifizierungsstelle, das Serverzertifikat und die privaten Schlüssel des Servers angegeben werden. Es wird empfohlen, den Clients die Wahl der Sicherheits-Chiffre zu überlassen und die Option <code>olcTLSCipherSuite</code> wegzulassen (inkompatibel mit anderen TLS-Clients als <span class=filename>openssl</span>). Mit der Option <code>olcTLSProtocolMin</code> benötigt der Server nur eine minimale Sicherheitsstufe. Diese Option wird empfohlen. Während die Verfizierung für den Server verpflichtend ist, ist sie es nicht für den Client: <code>olcTLSVerifyClient: never</code>.</p></div><div class=paragraph><p>Der zweite Abschnitt behandelt die Backend-Module und kann wie folgt konfiguriert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Load dynamic backend modules:
#
dn: cn=module,cn=config
objectClass: olcModuleList
cn: module
olcModulepath:	/usr/local/libexec/openldap
olcModuleload:	back_mdb.la
#olcModuleload:	back_bdb.la
#olcModuleload:	back_hdb.la
#olcModuleload:	back_ldap.la
#olcModuleload:	back_passwd.la
#olcModuleload:	back_shell.la</pre></div></div><div class=paragraph><p>Der dritte Abschnitt widmet sich dem Laden der benötigten ldif-Schemata, die von den Datenbanken verwendet werden sollen. Diese Dateien sind essentiell.</p></div><div class="literalblock programlisting"><div class=content><pre>dn: cn=schema,cn=config
objectClass: olcSchemaConfig
cn: schema

include: file:///usr/local/etc/openldap/schema/core.ldif
include: file:///usr/local/etc/openldap/schema/cosine.ldif
include: file:///usr/local/etc/openldap/schema/inetorgperson.ldif
include: file:///usr/local/etc/openldap/schema/nis.ldif</pre></div></div><div class=paragraph><p>Als nächstes folgt der Abschnitt zur Frontend-Konfiguration:</p></div><div class="literalblock programlisting"><div class=content><pre># Frontend settings
#
dn: olcDatabase={-1}frontend,cn=config
objectClass: olcDatabaseConfig
objectClass: olcFrontendConfig
olcDatabase: {-1}frontend
olcAccess: to * by * read
#
# Sample global access control policy:
#	Root DSE: allow anyone to read it
#	Subschema (sub)entry DSE: allow anyone to read it
#	Other DSEs:
#		Allow self write access
#		Allow authenticated users read access
#		Allow anonymous users to authenticate
#
#olcAccess: to dn.base=&#34;&#34; by * read
#olcAccess: to dn.base=&#34;cn=Subschema&#34; by * read
#olcAccess: to *
#	by self write
#	by users read
#	by anonymous auth
#
# if no access controls are present, the default policy
# allows anyone and everyone to read anything but restricts
# updates to rootdn.  (e.g., &#34;access to * by * read&#34;)
#
# rootdn can always read and write EVERYTHING!
#
olcPasswordHash: {SSHA}
# {SSHA} is already the default for olcPasswordHash</pre></div></div><div class=paragraph><p>Ein weiterer Abschnitt ist dem Konfigurations-Backend gewidmet, der einzige Weg, später auf die OpenLDAP-Serverkonfiguration zuzugreifen, ist als globaler Superuser.</p></div><div class="literalblock programlisting"><div class=content><pre>dn: olcDatabase={0}config,cn=config
objectClass: olcDatabaseConfig
olcDatabase: {0}config
olcAccess: to * by * none
olcRootPW: {SSHA}iae+lrQZILpiUdf16Z9KmDmSwT77Dj4U</pre></div></div><div class=paragraph><p>Der voreingestellte Benutzername für den Administrator lautet <code>cn=config</code>. Geben Sie <span class=filename>slappasswd</span> in eine Shell ein, wählen Sie ein Passwort und verwenden Sie seinen Hash in <code>olcRootPW</code>. Wenn diese Option jetzt nicht angegeben ist, kann vor dem Import der <span class=filename>slapd.ldif</span> niemand später den Abschnitt <em>global configuration</em> ändern.</p></div><div class=paragraph><p>Der letzte Abschnitt befasst sich mit dem Datenbank-Backend:</p></div><div class="literalblock programlisting"><div class=content><pre>#######################################################################
# LMDB database definitions
#######################################################################
#
dn: olcDatabase=mdb,cn=config
objectClass: olcDatabaseConfig
objectClass: olcMdbConfig
olcDatabase: mdb
olcDbMaxSize: 1073741824
olcSuffix: dc=domain,dc=example
olcRootDN: cn=mdbadmin,dc=domain,dc=example
# Cleartext passwords, especially for the rootdn, should
# be avoided.  See slappasswd(8) and slapd-config(5) for details.
# Use of strong authentication encouraged.
olcRootPW: {SSHA}X2wHvIWDk6G76CQyCMS1vDCvtICWgn0+
# The database directory MUST exist prior to running slapd AND
# should only be accessible by the slapd and slap tools.
# Mode 700 recommended.
olcDbDirectory:	/var/db/openldap-data
# Indices to maintain
olcDbIndex: objectClass eq</pre></div></div><div class=paragraph><p>Diese Datenbank enthält den <em>eigentlichen Inhalt</em> des LDAP-Verzeichnisses. Neben <code>mdb</code> sind weitere Versionen verfügbar. Dessen Superuser, nicht zu verwechseln mit dem globalen, wird hier konfiguriert: ein Benutzername in <code>olcRootDN</code> und der Passworthash in <code>olcRootPW</code>; <span class=filename>slappasswd</span> kann wie zuvor benutzt werden.</p></div><div class=paragraph><p>Dieses <a href="http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=tree;f=tests/data/regressions/its8444;h=8a5e808e63b0de3d2bdaf2cf34fecca8577ca7fd;hb=HEAD">Repository</a> enthält vier Beispiele für <span class=filename>slapd.ldif</span>. Lesen Sie diese Seite, um eine bestehende <span class=filename>slapd.conf</span> in <span class=filename>slapd.ldif</span> zu konvertieren. Beachten Sie, dass dies einige unbrauchbare Optionen einführen kann.</p></div><div class=paragraph><p>Wenn die Konfiguration abgeschlossen ist, muss <span class=filename>slapd.ldif</span> in ein leeres Verzeichnis verschoben werden. Folgendes ist die empfohlene Vorgehensweise:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /usr/local/etc/openldap/slapd.d/</span></code></pre></div></div><div class=paragraph><p>Importieren Sie die Konfigurationsdatenbank:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/slapadd -n0 -F /usr/local/etc/openldap/slapd.d/ -l /usr/local/etc/openldap/slapd.ldif</span></code></pre></div></div><div class=paragraph><p>Starten Sie den <span class=filename>slapd</span>-Daemon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/libexec/slapd -F /usr/local/etc/openldap/slapd.d/</span></code></pre></div></div><div class=paragraph><p>Die Option <code>-d</code> kann, wie in slapd(8) beschrieben, zur Fehlersuche benutzt werden. Stellen Sie sicher, dass der Server läuft und korrekt arbeitet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ldapsearch -x -b &#39;&#39; -s base &#39;(objectclass=*)&#39; namingContexts</span>
<span class=c># extended LDIF</span>
<span class=c>#</span>
<span class=c># LDAPv3</span>
<span class=c># base &lt;&gt; with scope baseObject</span>
<span class=c># filter: (objectclass=*)</span>
<span class=c># requesting: namingContexts</span>
<span class=c>#</span>

<span class=c>#</span>
dn:
namingContexts: <span class=nv>dc</span><span class=o>=</span>domain,dc<span class=o>=</span>example

<span class=c># search result</span>
search: 2
result: 0 Success

<span class=c># numResponses: 2</span>
<span class=c># numEntries: 1</span></code></pre></div></div><div class=paragraph><p>Dem Server muss noch vertraut werden. Wenn dies noch nie zuvor geschehen ist, befolgen Sie diese Anweisungen. Installieren Sie das Paket oder den Port OpenSSL:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install openssl</span></code></pre></div></div><div class=paragraph><p>Aus dem Verzeichnis, in dem <span class=filename>ca.crt</span> gespeichert ist (in diesem Beispiel <span class=filename>/usr/local/etc/openldap</span>), starten Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># c_rehash .</span></code></pre></div></div><div class=paragraph><p>Sowohl die CA als auch das Serverzertifikat werden nun in ihren jeweiligen Rollen korrekt erkannt. Um dies zu überprüfen, führen die folgenden Befehl aus dem Verzeichnis der <span class=filename>server.crt</span> aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl verify -verbose -CApath . server.crt</span></code></pre></div></div><div class=paragraph><p>Falls <span class=filename>slapd</span> ausgeführt wurde, muss der Daemon neu gestartet werden. Wie in <span class=filename>/usr/local/etc/rc.d/slapd</span> angegeben, müssen die folgenden Zeilen in <span class=filename>/etc/rc.conf</span> eingefügt werden, um <span class=filename>slapd</span> beim Booten ordnungsgemäß auszuführen:</p></div><div class="literalblock programlisting"><div class=content><pre>lapd_enable=&#34;YES&#34;
slapd_flags=&#39;-h &#34;ldapi://%2fvar%2frun%2fopenldap%2fldapi/
ldap://0.0.0.0/&#34;&#39;
slapd_sockets=&#34;/var/run/openldap/ldapi&#34;
slapd_cn_config=&#34;YES&#34;</pre></div></div><div class=paragraph><p><span class=filename>slapd</span> bietet beim Booten keine Möglichkeit zur Fehlersuche. Überprüfen Sie dazu <span class=filename>/var/log/debug.log</span>, <code>dmesg -a</code> und <span class=filename>/var/log/messages</span>.</p></div><div class=paragraph><p>Das folgende Beispiel fügt die Gruppe <code>team</code> und den Benutzer <code>john</code> zur LDAP-Datenbank <code>domain.example</code> hinzu, die bislang leer ist. Erstellen Sie zunächst die Datei <span class=filename>domain.ldif</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat domain.ldif</span>
dn: <span class=nv>dc</span><span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: dcObject
objectClass: organization
o: domain.example
dc: domain

dn: <span class=nv>ou</span><span class=o>=</span><span class=nb>groups</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: organizationalunit
ou: <span class=nb>groups

</span>dn: <span class=nv>ou</span><span class=o>=</span><span class=nb>users</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: organizationalunit
ou: <span class=nb>users

</span>dn: <span class=nv>cn</span><span class=o>=</span>team,ou<span class=o>=</span><span class=nb>groups</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: posixGroup
cn: team
gidNumber: 10001

dn: <span class=nv>uid</span><span class=o>=</span>john,ou<span class=o>=</span><span class=nb>users</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: account
objectClass: posixAccount
objectClass: shadowAccount
cn: John McUser
uid: john
uidNumber: 10001
gidNumber: 10001
homeDirectory: /home/john/
loginShell: /usr/bin/bash
userPassword: secret</code></pre></div></div><div class=paragraph><p>Weitere Informationen finden Sie in der OpenLDAP-Dokumentation. Benutzen Sie <span class=filename>slappasswd</span>, um das Passwort durch einen Hash in <code>userPassword</code> zu ersetzen. Der in <code>loginShell</code> angegebene Pfad muss in allen Systemen existieren, in denen <code>john</code> sich anmelden darf. Benutzen Sie schließlich den <code>mdb</code>-Administrator, um die Datenbank zu ändern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ldapadd -W -D &#34;cn=mdbadmin,dc=domain,dc=example&#34; -f domain.ldif</span></code></pre></div></div><div class=paragraph><p>Änderungen im Bereich <em>global configuration</em> können nur vom globalen Superuser vorgenommen werden. Angenommen die Option <code>olcTLSCipherSuite: HIGH:MEDIUM:SSLv3</code> wurde ursprünglich definiert und soll nun gelöscht werden. Dazu erstellen Sie zunächst eine Datei mit folgendem Inhalt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat global_mod</span>
dn: <span class=nv>cn</span><span class=o>=</span>config
changetype: modify
delete: olcTLSCipherSuite</code></pre></div></div><div class=paragraph><p>Übernehmen Sie dann die Änderungen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ldapmodify -f global_mod -x -D &#34;cn=config&#34; -W</span></code></pre></div></div><div class=paragraph><p>Geben Sie bei Aufforderung das im Abschnitt <em>configuration backend</em> gewählte Passwort ein. Der Benutzername ist nicht erforderlich: Hier repräsentiert <code>cn=config</code> den DN des zu ändernden Datenbankabschnitts. Alternativ können Sie mit <code>ldapmodify</code> eine einzelne Zeile der Datenbank löschen, mit <code>ldapdelete</code> einen ganzen Eintrag.</p></div><div class=paragraph><p>Wenn etwas schief geht oder der globale Superuser nicht auf das Konfigurations-Backend zugreifen kann, ist es möglich, die gesamte Konfiguration zu löschen und neu zu schreiben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm -rf /usr/local/etc/openldap/slapd.d/</span></code></pre></div></div><div class=paragraph><p><span class=filename>slapd.ldif</span> kann dann bearbeitet und erneut importiert werden. Bitte folgenden Sie dieser Vorgehensweise nur, wenn keine andere Lösung verfügbar ist.</p></div><div class=paragraph><p>Dies ist nur die Konfiguration des Servers. Auf demselben Rechner kann auch ein LDAP-Client mit eigener, separater Konfiguration betrieben werden.</p></div></div></div><div class=sect2><h3 id=network-dhcp>52.6. Dynamic Host Configuration Protocol (DHCP)<a class=anchor href=#network-dhcp></a></h3><div class=paragraph><p>Das Dynamic Host Configuration Protocol (DHCP) ermöglicht es einem System, sich mit einem Netzwerk zu verbinden und die für die Kommunikation mit diesem Netzwerk nötigen Informationen zu beziehen. FreeBSD verwendet den von OpenBSD stammenden <code>dhclient</code>, um die Adressinformationen zu beziehen. FreeBSD installiert keinen DHCP-Server, aber es stehen einige Server in der FreeBSD Ports-Sammlung zu Verfügung. Das DHCP-Protokoll wird vollständig im <a href=http://www.freesoft.org/CIE/RFC/2131/>RFC 2131</a> beschrieben. Eine weitere, lehrreiche Informationsquelle existiert unter <a href=http://www.isc.org/downloads/dhcp>isc.org/downloads/dhcp/</a>.</p></div><div class=paragraph><p>In diesem Abschnitt wird beschrieben, wie der integrierte DHCP-Client verwendet wird. Anschließend wird erklärt, wie ein DHCP-Server zu installieren und konfigurieren ist.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Unter FreeBSD wird das Gerät <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> für den DHCP-Server und den DHCP-Client benötigt. Das Gerät ist bereits im <span class=filename>GENERIC</span>-Kernel enthalten. Benutzer, die es vorziehen einen angepassten Kernel zu erstellen, müssen dieses Gerät behalten, wenn DHCP verwendet wird.</p></div><div class=paragraph><p>Es sei darauf hingewiesen, dass <span class=filename>bpf</span> es priviligierten Benutzern ermöglicht einen Paket-Sniffer auf dem System auszuführen.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_einen_dhcp_client_konfigurieren>52.6.1. Einen DHCP-Client konfigurieren<a class=anchor href=#_einen_dhcp_client_konfigurieren></a></h4><div class=paragraph><p>Die Unterstützung für den DHCP-Client ist im Installationsprogramm von FreeBSD enthalten, sodass ein neu installiertes System automatisch die Adressinformationen des Netzwerks vom DHCP-Server erhält. In <a href=./#bsdinstall-post>Benutzerkonten, Zeitzone, Dienste und Sicherheitsoptionen</a> finden Sie Beispiele für eine Netzwerkkonfiguration.</p></div><div class=paragraph><p><code>dhclient</code> beginnt von einem Clientrechner aus über den UDP-Port 68 Konfigurationsinformationen anzufordern. Der Server antwortet auf dem UDP-Port 67, indem er dem Client eine IP-Adresse zuweist und ihm weitere relevante Informationen über das Netzwerk, wie Netzmasken, Router und DNS-Server mitteilt. Diese Informationen werden als DHCP-Lease bezeichnet und sind nur für bestimmte Zeit, die vom Administrator des DHCP-Servers vorgegeben wird, gültig. Dadurch fallen verwaiste IP-Adressen, deren Clients nicht mehr mit dem Netzwerk verbunden sind, automatisch an den Server zurück. DHCP-Clients können sehr viele Informationen von einem DHCP-Server erhalten. Eine ausführliche Liste finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a>.</p></div><div class=paragraph><p>Das Gerät <span class=filename>bpf</span> ist im <span class=filename>GENERIC</span>-Kernel bereits enthalten. Für die Nutzung von DHCP muss also kein angepasster Kernel erzeugt werden. In einer angepassten Kernelkonfigurationsdatei muss das Gerät enthalten sein, damit DHCP ordnungsgemäß funktioniert.</p></div><div class=paragraph><p>Standardmässig läuft die DHCP-Konfiguration bei FreeBSD im Hintergrund oder auch <em>asynchron</em>. Andere Startskripte laufen weiter, während DHCP fertig abgearbeitet wird, was den Systemstart beschleunigt.</p></div><div class=paragraph><p>DHCP im Hintergrund funktioniert gut, wenn der DHCP-Server schnell auf Anfragen der Clients antwortet. Jedoch kann DHCP eine lange Zeit benötigen, um auf manchen Systemen fertig zu werden. Falls Netzwerkdienste gestartet werden, bevor DHCP die Informationen und Netzwerkadressen gesetzt hat, werden diese fehlschlagen. Durch die Verwendung von DHCP im <em>asynchronen</em> Modus wird das Problem verhindert, so dass die Startskripte pausiert werden, bis die DHCP-Konfiguration abgeschlossen ist.</p></div><div class=paragraph><p>Diese Zeile wird in <span class=filename>/etc/rc.conf</span> verwendet, um den asynchronen Modus zu aktivieren:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Die Zeile kann bereits vorhanden sein, wenn bei der Installation des Systems DHCP konfiguriert wurde. Ersetzen Sie <em>fxp0</em> durch die entsprechende Schnittstelle. Die dynamische Konfiguration von Netzwerkkarten wird in <a href=./#config-network-setup>“Einrichten von Netzwerkkarten”</a> beschrieben.</p></div><div class=paragraph><p>Um stattdessen den synchronen Modus zu verwenden, der während des Systemstarts pausiert bis die DHCP-Konfiguration abgeschlossen ist, benutzen Sie "SYNCDHCP":</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;SYNCDHCP&#34;</pre></div></div><div class=paragraph><p>Es stehen weitere Optionen für den Client zur Verfügung. Suchen Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> nach <code>dhclient</code>, wenn Sie an Einzelheiten interessiert sind.</p></div><div class=paragraph><p>Der DHCP-Client verwendet die folgenden Dateien:</p></div><div class=ulist><ul><li><p><span class=filename>/etc/dhclient.conf</span></p><div class=paragraph><p>Die Konfigurationsdatei von <code>dhclient</code>. Diese Datei enthält normalerweise nur Kommentare, da die Vorgabewerte zumeist ausreichend sind. Diese Konfigurationsdatei wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a> beschrieben.</p></div></li><li><p><span class=filename>/sbin/dhclient</span></p><div class=paragraph><p>Weitere Informationen über dieses Kommando finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>.</p></div></li><li><p><span class=filename>/sbin/dhclient-script</span></p><div class=paragraph><p>Das FreeBSD-spezifische Konfigurationsskript des DHCP-Clients. Es wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient-script&amp;sektion=8&amp;format=html">dhclient-script(8)</a> beschrieben und kann meist unverändert übernommen werden.</p></div></li><li><p><span class=filename>/var/db/dhclient.leases.interface</span></p><div class=paragraph><p>Der DHCP-Client verfügt über eine Datenbank, die alle derzeit gültigen Leases enthält und als Logdatei erzeugt wird. Diese Datei wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.leases&amp;sektion=5&amp;format=html">dhclient.leases(5)</a> beschrieben.</p></div></li></ul></div></div><div class=sect3><h4 id=network-dhcp-server>52.6.2. Einen DHCP-Server installieren und einrichten<a class=anchor href=#network-dhcp-server></a></h4><div class=paragraph><p>Dieser Abschnitt beschreibt die Einrichtung eines FreeBSD-Systems als DHCP-Server. Dazu wird die DHCP-Implementation von ISC (Internet Systems Consortium) verwendet. Diese Implementation und die Dokumentation können als Port oder Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a> installiert werden.</p></div><div class=paragraph><p>Der Port <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a> installiert eine Beispiel-Konfigurationsdatei. Kopieren Sie <span class=filename>/usr/local/etc/dhcpd.conf.example</span> nach <span class=filename>/usr/local/etc/dhcpd.conf</span> und nehmen Sie die Änderungen an der neuen Datei vor.</p></div><div class=paragraph><p>Diese Konfigurationsdatei umfasst Deklarationen für Subnetze und Rechner, die den DHCP-Cleints zur Verfügung gestellt wird. Die folgenden Zeilen konfigurieren Folgendes:</p></div><div class="literalblock programlisting"><div class=content><pre>option domain-name &#34;example.org&#34;;<i class=conum data-value=1></i><b>(1)</b>
option domain-name-servers ns1.example.org;<i class=conum data-value=2></i><b>(2)</b>
option subnet-mask 255.255.255.0;<i class=conum data-value=3></i><b>(3)</b>

default-lease-time 600;<i class=conum data-value=4></i><b>(4)</b>
max-lease-time 72400;<i class=conum data-value=5></i><b>(5)</b>
ddns-update-style none;<i class=conum data-value=6></i><b>(6)</b>

subnet 10.254.239.0 netmask 255.255.255.224 {
  range 10.254.239.10 10.254.239.20;<i class=conum data-value=7></i><b>(7)</b>
  option routers rtr-239-0-1.example.org;<i class=conum data-value=8></i><b>(8)</b>
}

host fantasia {
  hardware ethernet 08:00:07:26:c0:a5;<i class=conum data-value=9></i><b>(9)</b>
  fixed-address fantasia.fugue.com;<i class=conum data-value=10></i><b>(10)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Diese Option beschreibt die Standardsuchdomäne, die den Clients zugewiesen wird. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a>.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Diese Option legt eine, durch Kommata getrennte Liste von DNS-Servern fest, die von den Clients verwendet werden sollen. Die Server können über den Namen (FQDN) oder die IP-Adresse spezifiziert werden.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Die den Clients zugewiesene Subnetzmaske.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Die Voreinstellung für die Ablaufzeit des Lease in Sekunden. Ein Client kann diesen Wert in der Konfiguration überschreiben.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Die maximale Zeitdauer, für die der Server Leases vergibt. Sollte ein Client eine längere Zeitspanne anfordern, wird dennoch nur der Wert <code>max-lease-time</code> zugewiesen.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Die Voreinstellung <code>none</code> deaktiviert dynamische DNS-Updates. Bei der Einstellung <code>interim</code> aktualisiert der DHCP-Server den DNS-Server, wenn ein Lease vergeben oder zurückgezogen wurde. Ändern Sie die Voreinstellung nicht, wenn der Server so konfiguriert wurde, dynamische DNS-Updates zu unterstützen.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Diese Zeile erstellt einen Pool der verfügbaren IP-Adressen, die für die Zuweisung der DHCP-Clients reserviert sind. Der Bereich muss für das angegebene Netz oder Subnetz aus der vorherigen Zeile gültig sein.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Legt das Standard-Gateway für das Netz oder Subnetz fest, das nach der öffnenden Klammer <code>{</code> gültig ist.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Bestimmt die Hardware-MAC-Adresse eines Clients, durch die der DHCP-Server den Client erkennt, der eine Anforderung an ihn stellt.</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>Einem Rechner soll immer die gleiche IP-Adresse zugewiesen werden. Hier ist auch ein Rechnername gültig, da der DHCP-Server den Rechnernamen auflöst, bevor er das Lease zuweist.</td></tr></tbody></table></div><div class=paragraph><p>Die Konfigurationsdatei unterstützt viele weitere Optionen. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.conf&amp;sektion=5&amp;format=html">dhcpd.conf(5)</a>, die mit dem Server installiert wird, für Details und Beispiele.</p></div><div class=paragraph><p>Nachdem <span class=filename>dhcpd.conf</span> konfiguriert ist, aktivieren Sie den DHCP-Server in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;
dhcpd_ifaces=&#34;dc0&#34;</pre></div></div><div class=paragraph><p>Dabei müssen Sie <code>dc0</code> durch die Gerätedatei (mehrere Gerätedateien müssen durch Leerzeichen getrennt werden) ersetzen, die der DHCP-Server auf Anfragen von DHCP-Clients hin überwachen soll.</p></div><div class=paragraph><p>Starten Sie den Server mit folgenden Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div><div class=paragraph><p>Künftige Änderungen an der Konfiguration des Servers erfordern, dass der Dienst <code>dhcpd</code> gestoppt und anschließend mit <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> gestartet wird.</p></div><div class=ulist><ul><li><p><span class=filename>/usr/local/sbin/dhcpd</span></p><div class=paragraph><p>Weitere Informationen zu dhcpd finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd&amp;sektion=8&amp;format=html">dhcpd(8)</a>.</p></div></li><li><p><span class=filename>/usr/local/etc/dhcpd.conf</span></p><div class=paragraph><p>Die Konfigurationsdatei des Servers muss alle Informationen enthalten, die an die Clients weitergegeben werden soll. Außerdem sind hier Informationen zur Konfiguration des Servers enthalten. Diese Konfigurationsdatei wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.conf&amp;sektion=5&amp;format=html">dhcpd.conf(5)</a> beschrieben.</p></div></li><li><p><span class=filename>/var/db/dhcpd.leases</span></p><div class=paragraph><p>Der DHCP-Server hat eine Datenbank, die alle vergebenen Leases enthält. Diese wird als Logdatei erzeugt. <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.leases&amp;sektion=5&amp;format=html">dhcpd.leases(5)</a> enthält eine ausführliche Beschreibung.</p></div></li><li><p><span class=filename>/usr/local/sbin/dhcrelay</span></p><div class=paragraph><p>Dieser Daemon wird in komplexen Umgebungen verwendet, in denen ein DHCP-Server eine Anfrage eines Clients an einen DHCP-Server in einem separaten Netzwerk weiterleitet. Wenn Sie diese Funktion benötigen, müssen Sie <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-relay/>net/isc-dhcp44-relay</a> installieren. Weitere Informationen zu diesem Thema finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcrelay&amp;sektion=8&amp;format=html">dhcrelay(8)</a>.</p></div></li></ul></div></div></div><div class=sect2><h3 id=network-dns>52.7. Domain Name System (DNS)<a class=anchor href=#network-dns></a></h3><div class=paragraph><p>DNS ist das für die Umwandlung von Rechnernamen in IP-Adressen zuständige Protokoll. Im Internet wird DNS durch ein komplexes System von autoritativen Root-Nameservern, Top Level Domain-Servern (TLD) sowie anderen kleineren Nameservern verwaltet, die individuelle Domaininformationen speichern und untereinander abgleichen. Für einfache DNS-Anfragen wird auf dem lokalen System kein Nameserver benötigt.</p></div><div class=paragraph><p>Die folgende Tabelle beschreibt einige mit DNS verbundenen Begriffe:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 28. DNS-Begriffe</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Begriff</th><th class="tableblock halign-left valign-top">Bedeutung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Forward-DNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Rechnernamen in IP-Adressen umwandeln.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Origin (Ursprung)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die in einer bestimmten Zonendatei beschriebene Domäne.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Resolver</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ein Systemprozess, durch den ein Rechner Zoneninformationen von einem Nameserver anfordert.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Reverse-DNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>die Umwandlung von IP-Adressen in Rechnernamen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Root-Zone</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Der Beginn der Internet-Zonenhierarchie. Alle Zonen befinden sich innerhalb der Root-Zone. Dies ist analog zu einem Dateisystem, in dem sich alle Dateien und Verzeichnisse innerhalb des Wurzelverzeichnisses befinden.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Zone</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eine individuelle Domäne, Unterdomäne, oder ein Teil von DNS, der von der gleichen Autorität verwaltet wird.</p></td></tr></tbody></table><div class=paragraph><p>Es folgen nun einige Zonenbeispiele:</p></div><div class=ulist><ul><li><p>Innerhalb der Dokumentation wird die Root-Zone in der Regel mit <code>.</code> bezeichnet.</p></li><li><p><code>org.</code> ist eine Top level Domain (TLD) innerhalb der Root-Zone.</p></li><li><p><code>example.org.</code> ist eine Zone innerhalb der <code>org.</code>-TLD.</p></li><li><p><code>1.168.192.in-addr.arpa.</code> ist die Zone mit allen IP-Adressen des Bereichs <code>192.168.1.*</code>.</p></li></ul></div><div class=paragraph><p>Wie man an diesen Beispielen erkennen kann, befindet sich der spezifischere Teil eines Rechnernamens auf der linken Seite der Adresse. <code>example.org.</code> beschreibt einen Rechner also genauer als <code>org.</code>, während <code>org.</code> genauer als die Root-Zone ist. Jeder Teil des Rechnernamens hat Ähnlichkeiten mit einem Dateisystem, in dem etwa <span class=filename>/dev</span> dem Wurzelverzeichnis untergeordnet ist.</p></div><div class=sect3><h4 id=_gründe_für_die_verwendung_eines_nameservers>52.7.1. Gründe für die Verwendung eines Nameservers<a class=anchor href=#_gründe_für_die_verwendung_eines_nameservers></a></h4><div class=paragraph><p>Es gibt zwei Arten von Nameservern: Autoritative Nameserver sowie zwischenspeichernde (cachende, auch bekannt als auflösende) Nameserver.</p></div><div class=paragraph><p>Ein autoritativer Nameserver ist notwendig, wenn</p></div><div class=ulist><ul><li><p>Sie anderen verbindliche DNS-Auskünfte erteilen wollen.</p></li><li><p>eine Domain, beispielsweise <code>example.org</code>, registriert wird, und den zu dieser Domain gehörenden Rechnern IP-Adressen zugewiesen werden müssen.</p></li><li><p>ein IP-Adressblock reverse-DNS-Einträge benötigt, um IP-Adressen in Rechnernamen auflösen zu können.</p></li><li><p>ein Backup-Nameserver (auch Slaveserver genannt) oder ein zweiter Nameserver auf Anfragen antworten soll.</p></li></ul></div><div class=paragraph><p>Ein cachender Nameserver ist notwendig, weil</p></div><div class=ulist><ul><li><p>ein lokaler DNS-Server Daten zwischenspeichern und daher schneller auf Anfragen reagieren kann als ein entfernter Server.</p></li></ul></div><div class=paragraph><p>Wird nach <code>www.FreeBSD.org</code> gesucht, leitet der Resolver diese Anfrage an den Nameserver des ISPs weiter und nimmt danach das Ergebnis der Abfrage entgegen. Existiert ein lokaler, zwischenspeichernder DNS-Server, muss dieser die Anfrage nur einmal nach außen weitergeben. Für alle weiteren Anfragen ist dies nicht mehr nötig, da diese Information nun lokal gespeichert ist.</p></div></div><div class=sect3><h4 id=_dns_server_konfiguration>52.7.2. DNS-Server Konfiguration<a class=anchor href=#_dns_server_konfiguration></a></h4><div class=paragraph><p>Unbound ist im Basissystem von FreeBSD enthalten. In der Voreinstellung bietet es nur die DNS-Auflösung auf dem lokalen Rechner. Obwohl das im Basissystem enthaltene Unbound konfiguriert werden kann, um Namensauflösung über den lokalen Rechner hinweg bereitzustellen, ist es empfehlenswert für solche Anforderungen Unbound aus der FreeBSD Ports-Sammlung zu installieren.</p></div><div class=paragraph><p>Um Unbound zu aktivieren, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>local_unbound_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Alle vorhandenen Nameserver aus <span class=filename>/etc/resolv.conf</span> werden als Forwarder in der neuen Unbound-Konfiguration benutzt.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn einer der aufgeführten Nameserver kein DNSSEC unterstützt, wird die lokale DNS-Auflösung nicht funktionieren. Testen Sie jeden Server und entfernen Sie die Server, die den Test nicht bestehen. Das folgende Beispiel zeigt einen Trust Tree beziehungsweise einen Fehler für den Nameserver auf <code>192.168.1.1</code>:</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># drill -S FreeBSD.org @192.168.1.1</span></code></pre></div></div><div class=paragraph><p>Nachdem jeder Server für DNSSEC konfiguriert ist, starten Sie Unbound:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service local_unbound onestart</span></code></pre></div></div><div class=paragraph><p>Dieses Kommando sorgt für die Aktualisierung von <span class=filename>/etc/resolv.conf</span>, so dass Abfragen für DNSSEC gesicherte Domains jetzt funktionieren. Führen Sie folgenden Befehl aus, um den DNSSECTrust Tree für FreeBSD.org zu überprüfen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% drill <span class=nt>-S</span> FreeBSD.org
<span class=p>;;</span> Number of trusted keys: 1
<span class=p>;;</span> Chasing: freebsd.org. A

DNSSEC Trust tree:
freebsd.org. <span class=o>(</span>A<span class=o>)</span>
|---freebsd.org. <span class=o>(</span>DNSKEY keytag: 36786 alg: 8 flags: 256<span class=o>)</span>
    |---freebsd.org. <span class=o>(</span>DNSKEY keytag: 32659 alg: 8 flags: 257<span class=o>)</span>
    |---freebsd.org. <span class=o>(</span>DS keytag: 32659 digest <span class=nb>type</span>: 2<span class=o>)</span>
        |---org. <span class=o>(</span>DNSKEY keytag: 49587 alg: 7 flags: 256<span class=o>)</span>
            |---org. <span class=o>(</span>DNSKEY keytag: 9795 alg: 7 flags: 257<span class=o>)</span>
            |---org. <span class=o>(</span>DNSKEY keytag: 21366 alg: 7 flags: 257<span class=o>)</span>
            |---org. <span class=o>(</span>DS keytag: 21366 digest <span class=nb>type</span>: 1<span class=o>)</span>
            |   |---. <span class=o>(</span>DNSKEY keytag: 40926 alg: 8 flags: 256<span class=o>)</span>
            |       |---. <span class=o>(</span>DNSKEY keytag: 19036 alg: 8 flags: 257<span class=o>)</span>
            |---org. <span class=o>(</span>DS keytag: 21366 digest <span class=nb>type</span>: 2<span class=o>)</span>
                |---. <span class=o>(</span>DNSKEY keytag: 40926 alg: 8 flags: 256<span class=o>)</span>
                    |---. <span class=o>(</span>DNSKEY keytag: 19036 alg: 8 flags: 257<span class=o>)</span>
<span class=p>;;</span> Chase successful</code></pre></div></div></div></div><div class=sect2><h3 id=network-apache>52.8. Apache HTTP-Server<a class=anchor href=#network-apache></a></h3><div class=paragraph><p>Der Open Source Apache HTTP-Server ist der am weitesten verbreitete Webserver. Dieser Webserver ist nicht im Basissystem von FreeBSD enthalten, kann aber als Paket oder Port <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache24/>www/apache24</a> installiert werden.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt die Konfiguration der Version 2.<em>x</em> des Apache HTTP-Server. Weiterführende Informationen und Konfigurationsanweisungen für Apache 2.X finden Sie unter <a href=http://httpd.apache.org/>httpd.apache.org</a>.</p></div><div class=sect3><h4 id=_apache_konfigurieren_und_starten>52.8.1. Apache konfigurieren und starten<a class=anchor href=#_apache_konfigurieren_und_starten></a></h4><div class=paragraph><p>Der Apache HTTP-Server wird unter FreeBSD primär in <span class=filename>/usr/local/etc/apache2x/httpd.conf</span> konfiguriert, wobei das <em>x</em> die Versionsnummer darstellt. In dieser Textdatei leitet ein <code>#</code> einen Kommentar ein. Die am häufigsten verwendeten Optionen sind:</p></div><div class=dlist><dl><dt class=hdlist1><code>ServerRoot "/usr/local"</code></dt><dd><p>Legt das Standardwurzelverzeichnis für die Apache-Installation fest. Binärdateien werden in die Verzeichnisse <span class=filename>bin</span> und <span class=filename>sbin</span> unterhalb des Serverwurzelverzeichnisses installiert, während sich Konfigurationsdateien im Unterverzeichnis <span class=filename>etc/apache2x</span> befinden.</p></dd><dt class=hdlist1><code>ServerAdmin <a href=mailto:you@example.com>you@example.com</a></code></dt><dd><p>Die E-Mail-Adresse, an die Mitteilungen über Serverprobleme geschickt werden. Diese Adresse erscheint auf vom Server erzeugten Seiten, beispielsweise auf Fehlerseiten.</p></dd><dt class=hdlist1><code>ServerName www.example.com:80</code></dt><dd><p>Erlaubt dem Administrator, einen Rechnernamen festzulegen, den der Server an die Clients sendet. Beispielsweise könnte <code>www</code> statt des richtigen Rechnernamens verwendet werden. Wenn das System keinen eingetragenen DNS-Namen hat, kann stattdessen die IP-Adresse eingetragen werden. Lauscht der Server auf einem anderen Port, tauschen Sie die <code>80</code> gegen eine entsprechende Portnummer.</p></dd><dt class=hdlist1><code>DocumentRoot "/usr/local/www/apache2<em>x</em>/data"</code></dt><dd><p>Das Verzeichnis, in dem die Dokumente abgelegt sind. In der Voreinstellung befinden sich alle Seiten in diesem Verzeichnis, durch symbolische Links oder Aliase lassen sich aber auch andere Orte festlegen.</p></dd></dl></div><div class=paragraph><p>Es ist empfehlenswert, eine Sicherungskopie der Apache-Konfigurationsdatei anzulegen, bevor Änderungen durchgeführt werden. Wenn die Konfiguration von Apache abgeschlossen ist, speichern Sie die Datei und überprüfen Sie die Konfiguration mit <code>apachectl</code>. Der Befehl <code>apachectl configtest</code> sollte <code>Syntax OK</code> zurückgeben.</p></div><div class=paragraph><p>Um den Apache beim Systemstart zu starten, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>apache24_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Wenn Sie während des Systemstarts weitere Parameter an den Apache übergeben wollen, können Sie diese durch eine zusätzliche Zeile in <span class=filename>rc.conf</span> angeben:</p></div><div class="literalblock programlisting"><div class=content><pre>apache24_flags=&#34;&#34;</pre></div></div><div class=paragraph><p>Wenn apachectl keine Konfigurationsfehler meldet, starten Sie <code>httpd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service apache24 start</span></code></pre></div></div><div class=paragraph><p>Sie können den <code>httpd</code>-Dienst testen, indem Sie <code>http://<em>localhost</em></code> in einen Browser eingeben, wobei Sie <em>localhost</em> durch den vollqualifizierten Domainnamen der Maschine ersetzen, auf dem der <code>httpd</code> läuft. Die Standard Webseite, die angezeigt wird, ist <span class=filename>/usr/local/www/apache24/data/index.html</span>.</p></div><div class=paragraph><p>Die Konfiguration von Apache kann bei nachfolgenden Änderungen an der Konfigurationsdatei bei laufendem <code>httpd</code>, auf Fehler überprüft werden. Geben Sie dazu folgendes Kommando ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service apache24 configtest</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es ist wichitg zu beachten, dass <code>configtest</code> kein <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-Standard ist, und somit nicht zwingend mit anderen <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-Startskripten funktioniert.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_virtual_hosting>52.8.2. Virtual Hosting<a class=anchor href=#_virtual_hosting></a></h4><div class=paragraph><p>Virtual Hosting ermöglicht es, mehrere Webseiten auf einem Apache-Server laufen zu lassen. Die virtuellen Hosts können <em>IP-basiert</em> oder <em>namensbasiert</em> sein. IP-basiertes virtual Hosting verwendet eine IP-Adresse für jede Webseite. Beim namensbasierten virtual Hosting wird der HTTP/1.1-Header der Clients dazu verwendet, den Rechnernamen zu bestimmen. Dadurch wird es möglich, mehrere Domains unter der gleichen IP-Adresse zu betreiben.</p></div><div class=paragraph><p>Damit der Apache namenbasierte virtuelle Domains verwalten kann, fügen Sie für jede Webseite einen separaten <code>VirtualHost</code>-Block ein. Wenn der Webserver beispielsweise <code>www.domain.tld</code> heißt und die virtuelle Domain <code>www.someotherdomain.tld</code> einrichtet werden soll, ergänzen Sie <span class=filename>httpd.conf</span> um folgende Einträge:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;VirtualHost *&gt;
    ServerName www.domain.tld
    DocumentRoot /www/domain.tld
&lt;/VirtualHost&gt;

&lt;VirtualHost *&gt;
    ServerName www.someotherdomain.tld
    DocumentRoot /www/someotherdomain.tld
&lt;/VirtualHost&gt;</pre></div></div><div class=paragraph><p>Setzen Sie für jeden virtuellen Host die entsprechenden Werte für <code>ServerName</code> und <code>DocumentRoot</code>.</p></div><div class=paragraph><p>Ausführliche Informationen zum Einrichten von virtuellen Hosts finden Sie in der offiziellen Apache-Dokumentation unter <a href=http://httpd.apache.org/docs/vhosts/>http://httpd.apache.org/docs/vhosts/</a>.</p></div></div><div class=sect3><h4 id=_häufig_verwendete_apache_module>52.8.3. Häufig verwendete Apache-Module<a class=anchor href=#_häufig_verwendete_apache_module></a></h4><div class=paragraph><p>Apache verwendet Module, die den Server um zusätzliche Funktionen erweitern. Eine vollständige Auflistung der zur Verfügung stehenden Module und Konfigurationsdetails finden Sie unter <a href=http://httpd.apache.org/docs/current/mod/>http://httpd.apache.org/docs/current/mod/</a>.</p></div><div class=paragraph><p>In FreeBSD können einige Module mit dem Port <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache24/>www/apache24</a> kompiliert werden. Geben Sie in <span class=filename>/usr/ports/www/apache24</span><code>make config</code> ein, um zu sehen, welche Module zur Verfügung stehen und welche Module in der Voreinstellung aktiviert sind. Wenn ein Modul nicht zusammen mit dem Port kompiliert wird, bietet die Ports-Sammlung die Möglichkeit viele Module zu installieren. Dieser Abschnitt beschreibt drei der am häufigsten verwendeten Module.</p></div><div class=sect4><h5 id=_ssl_unterstützung>52.8.3.1. SSL-Unterstützung<a class=anchor href=#_ssl_unterstützung></a></h5><div class=paragraph><p>Zu einem bestimmten Zeitpunkt erforderte die Unterstützung von SSL innerhalb von Apache ein separates Modul namens <span class=filename>mod_ssl</span>. Dies ist nicht mehr der Fall und die Installation des Apache-Webservers wird im Standard mit SSL-Unterstützung ausgeliefert. Ein Beispiel, wie Sie SSL-Unterstützung für einen Webserver aktivieren können, finden Sie in der Datei <span class=filename>httpd-ssl.conf</span> im Verzeichnis <span class=filename>/usr/local/etc/apache24/extra</span>. In diesem Verzeichnis befindet sich auch eine Beispieldatei namens <span class=filename>ssl.conf-sample</span>. Es wird empfohlen, beide Dateien zu überprüfen, um sichere Webseiten auf dem Apache-Webserver einzurichten.</p></div><div class=paragraph><p>Nachdem die Konfiguration von SSL abgeschlossen ist, muss die folgende Zeile in <span class=filename>httpd.conf</span> auskommentiert werden, um die Änderungen beim nächsten Neustart oder erneuten Laden der Konfiguration zu aktivieren:</p></div><div class="literalblock programlisting"><div class=content><pre>#Include etc/apache24/extra/httpd-ssl.conf</pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>SSL in Version 2 und 3 haben bekannte Schwachstellen. Es wird dringend empfohlen, TLS Version 1.2 und 1.3 anstelle der älteren SSL-Optionen zu aktivieren. Dies kann durch die Einstellung der folgenden Optionen in <span class=filename>ssl.conf</span> erreicht werden:</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>SSLProtocol all -SSLv3 -SSLv2 +TLSv1.2 +TLSv1.3
SSLProxyProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1</pre></div></div><div class=paragraph><p>Um die Konfiguration von SSL im Webserver abzuschließen, entfernen Sie den Kommentar in der folgenden Zeile, um sicherzustellen, dass die Konfiguration bei einem Neustart oder beim erneuten laden der Konfiguration von Apache übernommen wird:</p></div><div class="literalblock programlisting"><div class=content><pre># Secure (SSL/TLS) connections
Include etc/apache24/extra/httpd-ssl.conf</pre></div></div><div class=paragraph><p>Diese Zeilen müssen in <span class=filename>httpd.conf</span> ebenfalls auskommentiert bleiben, um SSL in Apache vollständig zu unterstützen:</p></div><div class="literalblock programlisting"><div class=content><pre>LoadModule authn_socache_module libexec/apache24/mod_authn_socache.so
LoadModule socache_shmcb_module libexec/apache24/mod_socache_shmcb.so
LoadModule ssl_module libexec/apache24/mod_ssl.so</pre></div></div><div class=paragraph><p>Der nächste Schritt ist die Kooperation mit einer Zertifizierungsstelle, um die entsprechenden Zertifikate auf dem System installieren zu lassen. Dadurch wird eine Vertrauenskette für die Webseite etabliert und jegliche Warnungen vor selbstsignierten Zertifikaten verhindert.</p></div></div><div class=sect4><h5 id=_mod_perl>52.8.3.2. <span class=filename>mod_perl</span><a class=anchor href=#_mod_perl></a></h5><div class=paragraph><p>Das Modul <span class=filename>mod_perl</span> macht es möglich, vollständig in Perl geschriebene Apache-Module zu erzeugen. Da der Perl-Interpreter in den Server eingebettet wird, muss weder ein externer Interpreter noch Perl zusätzlich aufgerufen werden.</p></div><div class=paragraph><p><span class=filename>mod_perl</span> wird über den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_perl2/>www/mod_perl2</a> installiert. Dokumentation für dieses Modul finden Sie unter <a href=http://perl.apache.org/docs/2.0/index.html>http://perl.apache.org/docs/2.0/index.html</a>.</p></div></div><div class=sect4><h5 id=_mod_php>52.8.3.3. <span class=filename>mod_php</span><a class=anchor href=#_mod_php></a></h5><div class=paragraph><p><em>PHP: Hypertext Preprocessor</em> (PHP) ist eine vielseitig verwendbare Skriptsprache, die besonders für die Web-Entwicklung geeignet ist. PHP kann in HTML eingebettet werden und ähnelt von der Syntax her Sprachen wie C, Java™ und Perl. Das Hauptanliegen von PHP ist es, Web-Entwicklern die rasche Erstellung von dynamisch erzeugten Internetseiten zu ermöglichen.</p></div><div class=paragraph><p>PHP und weitere in PHP geschriebene Funktionen unterstützt, muss das entsprechende Paket installiert werden.</p></div><div class=paragraph><p>Sie können mit <code>pkg</code> die Paketdatenbank nach allen unterstützten PHP-Versionen durchsuchen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg search php</span></code></pre></div></div><div class=paragraph><p>Die Ausgabe ist eine Liste mit Versionen und Funktionen des jeweiligen Pakets. Die Komponenten sind vollständig modular, d.h. die Funktionen werden durch die Installation des entsprechenden Pakets aktiviert. Geben Sie folgenden Befehl ein, um PHP-Version 7.4 für Apache zu installieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mod_php74</span></code></pre></div></div><div class=paragraph><p>Falls irgendwelche Pakete Abhängigkeiten besitzen, werden diese zusätzlichen Pakete ebenfalls installiert.</p></div><div class=paragraph><p>Standardmäßig ist PHP nicht aktiviert. Die folgenden Zeilen müssen in der Apache-Konfigurationsdatei unterhalb von <span class=filename>/usr/local/etc/apache24</span> hinzugefügt werden, um PHP zu aktivieren:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;FilesMatch &#34;\.php$&#34;&gt;
    SetHandler application/x-httpd-php
&lt;/FilesMatch&gt;
&lt;FilesMatch &#34;\.phps$&#34;&gt;
    SetHandler application/x-httpd-php-source
&lt;/FilesMatch&gt;</pre></div></div><div class=paragraph><p>Zusätzlich muss auch der <code>DirectoryIndex</code> in der Konfigurationsdatei aktualisiert werden und Apache muss entweder neu gestartet, oder die Konfiguration neu geladen werden, damit die Änderungen wirksam werden.</p></div><div class=paragraph><p>Mit <code>pkg</code> kann die Unterstützung für viele weitere PHP-Funktionen installiert werden. Um beispielsweise die Unterstützung für XML oder SSL zu erhalten, installieren Sie die entsprechenden Pakete:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install php74-xml php74-openssl</span></code></pre></div></div><div class=paragraph><p>Wie zuvor muss die Konfiguration von Apache neu geladen werden, damit die Änderungen wirksam werden. Dies gilt auch für Fälle, in denen lediglich ein Modul installiert wurde.</p></div><div class=paragraph><p>Geben Sie folgenden Befehl ein, um einen geordneten Neustart durchzuführen und die Konfiguration neu zu laden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># apachectl graceful</span></code></pre></div></div><div class=paragraph><p>Sobald die Installation abgeschlossen ist, gibt es zwei Möglichkeiten, um eine Liste der installierten PHP-Module und Informationen über die Umgebung der Installation zu erhalten. Die erste Möglichkeit besteht darin, die vollständige PHP-Binärdatei zu installieren und den Befehl auszuführen, um die Informationen zu erhalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install php74</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># php -i | less</span></code></pre></div></div><div class=paragraph><p>Da die Ausgabe des Befehls sehr umfangreich ist, ist die Weiterleitung an einen Pager, wie beispielsweise <code>more</code> oder <code>less</code>, sinnvoll.</p></div><div class=paragraph><p>Um Änderungen an der globalen Konfiguration von PHP vorzunehmen, gibt es schließlich eine gut dokumentierte Datei, die in <span class=filename>/usr/local/etc/php.ini</span> installiert ist. Zum Zeitpunkt der Installation wird diese Datei nicht existieren, da zwei Versionen zur Auswahl stehen. Eine <span class=filename>php.ini-development</span> und eine <span class=filename>php.ini-production</span>. Diese Dateien sind Ansatzpunkte, die Administratoren bei der Implementierung unterstützen sollen.</p></div></div></div><div class=sect3><h4 id=_dynamische_webseiten>52.8.4. Dynamische Webseiten<a class=anchor href=#_dynamische_webseiten></a></h4><div class=paragraph><p>Neben mod_perl und mod_php stehen noch weitere Sprachen zur Erstellung von dynamischen Inhalten zur Verfügung. Dazu gehören auch Django und Ruby on Rails.</p></div><div class=sect4><h5 id=_django>52.8.4.1. Django<a class=anchor href=#_django></a></h5><div class=paragraph><p>Bei Django handelt es sich um ein unter der BSD-Lizenz verfügbares Framework zur schnellen Erstellung von mächtigen Internet-Applikationen. Es beinhaltet einen objekt-relationalen Mapper (wodurch Datentypen als Phyton-Objekte entwickelt werden können) sowie eine API für den dynamischen Datenbankzugriff auf diese Objekte, ohne dass Entwickler jemals SQL-Code schreiben müssen. Zusätzlich existiert ein umfangreiches Template-System, wodurch die Programmlogik von der HTML-Präsentation getrennt werden kann.</p></div><div class=paragraph><p>Django setzt das Modul mod_python und eine SQL-Datenbank voraus. In FreeBSD wird bei der Installation von <a class=package href=https://cgit.freebsd.org/ports/tree/www/py-django/>www/py-django</a> automatisch <span class=filename>mod_python</span> installiert. Als Datenbanken werden PostgreSQL, MySQL und SQLite unterstützt, wobei SQLite die Voreinstellung ist. Wenn Sie die Datenbank ändern möchten, geben Sie in <span class=filename>/usr/ports/www/py-django</span><code>make config</code> ein und installieren Sie den Port neu.</p></div><div class=paragraph><p>Nachdem Django installiert ist, benötigt die Anwendung ein Projektverzeichnis und die Apache-Konfiguration, um den eingebetteten Python-Interpreter zu nutzen. Dieser Interpreter wird verwendet um die Anwendung für spezifische URLs der Seite aufrufen.</p></div><div class=paragraph><p>Damit Apache Anfragen für bestimmte URLs an die Web-Applikation übergeben kann, müssen Sie den vollständigen Pfad zum Projektverzeichnis in <span class=filename>httpd.conf</span> festlegen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&lt;Location <span class=s2>&#34;/&#34;</span><span class=o>&gt;</span>
    SetHandler python-program
    PythonPath <span class=s2>&#34;[&#39;/pfad/zu/den/django/paketen/&#39;] + sys.path&#34;</span>
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mysite.settings
    PythonAutoReload On
    PythonDebug On
&lt;/Location&gt;</code></pre></div></div><div class=paragraph><p>Weitere Informationen zur Verwendung von Django finden Sie unter <a href=https://docs.djangoproject.com/en/1.6/>https://docs.djangoproject.com/en/1.6/</a>.</p></div></div><div class=sect4><h5 id=_ruby_on_rails>52.8.4.2. Ruby on Rails<a class=anchor href=#_ruby_on_rails></a></h5><div class=paragraph><p>Ruby on Rails ist ein weiteres, als Open Source verfügbares Webframework. Es bietet einen kompletten Entwicklungsstack und erlaubt es Webentwicklern, umfangreiche und mächtige Applikationen in kurzer Zeit zu programmieren. Unter FreeBSD kann das Framework über den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/www/rubygem-rails/>www/rubygem-rails</a> installiert werden.</p></div><div class=paragraph><p>Weitere Informationen zur Verwendung von Ruby on Rails finden Sie unter <a href=http://rubyonrails.org/documentation>http://rubyonrails.org/documentation</a>.</p></div></div></div></div><div class=sect2><h3 id=network-ftp>52.9. File Transfer Protocol (FTP)<a class=anchor href=#network-ftp></a></h3><div class=paragraph><p>Das File Transfer Protocol (FTP) ermöglicht auf einfache Art und Weise den Dateiaustausch mit einem FTP-Server. Der FTP-Server ftpd ist bei FreeBSD bereits im Basisystem enthalten.</p></div><div class=paragraph><p>FreeBSD verwendet mehrere Konfigurationsdateien, um den Zugriff auf den FTP zu kontrollieren. Dieser Abschnitt fasst diese Dateien zusammen. In <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> finden Sie weitere Inforamtionen über den integrierten FTP-Server.</p></div><div class=sect3><h4 id=_konfiguration_3>52.9.1. Konfiguration<a class=anchor href=#_konfiguration_3></a></h4><div class=paragraph><p>Der wichtigste Punkt ist hier die Entscheidung darüber, welche Benutzer auf den FTP-Server zugreifen dürfen. Ein FreeBSD-System verfügt über diverse Systembenutzerkonten, die jedoch nicht auf den FTP-Server zugreifen sollen. Die Datei <span class=filename>/etc/ftpusers</span> enthält alle Benutzer, die vom FTP-Zugriff ausgeschlossen sind. In der Voreinstellung gilt dies auch die gerade erwähnten Systembenutzerkonten. Sie können über diese Datei weitere Benutzer vom FTP-Zugriff ausschließen.</p></div><div class=paragraph><p>In einigen Fällen kann es wünschenswert sein, den Zugang für manche Benutzer einzuschränken, ohne dabei FTP komplett zu verbieten. Dazu passen Sie <span class=filename>/etc/ftpchroot</span>, wie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpchroot&amp;sektion=5&amp;format=html">ftpchroot(5)</a> beschrieben, entsprechend an. Diese Datei enthält Benutzer und Gruppen sowie die für sie geltenden Einschränkungen für FTP.</p></div><div class=paragraph><p>Um anonymen FTP-Zugriff auf dem Server zu aktivieren, muss ein Benutzer <code>ftp</code> auf dem FreeBSD-System angelegt werden. Danach können sich Benutzer mit dem Benutzernamen <code>ftp</code> oder <code>anonymous</code> am FTP-Server anmelden. Das Passwort ist dabei beliebig, allerdings wird dazu in der Regel eine E-Mail-Adresse verwendet. Meldet sich ein anonymer Benutzer an, aktiviert der FTP-Server <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a>, um den Zugriff auf das Heimatverzeichnis des Benutzers <code>ftp</code> zu beschränken.</p></div><div class=paragraph><p>Es gibt zwei Textdateien, deren Inhalt den FTP-Clients bei der Anmeldung angezeigt wird. Der Inhalt von <span class=filename>/etc/ftpwelcome</span> wird angezeigt, bevor der Login-Prompt erscheint. Nach einer erfolgreichen Anmeldung wird der Inhalt von <span class=filename>/etc/ftpmotd</span> angezeigt. Beachten Sie aber, dass es dabei um einen Pfad relativ zur Umgebung des anzumeldenden Benutzers handelt. Bei einer anonymen Anmeldung würde also der Inhalt von <span class=filename>~ftp/etc/ftpmotd</span> angezeigt.</p></div><div class=paragraph><p>Sobald der FTP-Server konfiguriert ist, setzen Sie die entsprechende Variable in <span class=filename>/etc/rc.conf</span>, damit der Dienst beim Booten gestartet wird:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten Sie den Dienst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ftpd start</span></code></pre></div></div><div class=paragraph><p>Testen Sie die Verbindung zum FTP-Server, indem Sie folgendes eingeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ftp localhost</code></pre></div></div></div><div class=sect3><h4 id=_wartung>52.9.2. Wartung<a class=anchor href=#_wartung></a></h4><div class=paragraph><p>Der ftpd-Daemon verwendet <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a>, um Protokolldateien zu erstellen. In der Voreinstellung werden alle FTP betreffenden Nachrichten nach <span class=filename>/var/log/xferlog</span> geschrieben. Dies lässt sich aber durch das Einfügen der folgenden Zeile in <span class=filename>/etc/syslog.conf</span> ändern:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp.info      /var/log/xferlog</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Beachten Sie, dass mit dem Betrieb eines anonymen FTP-Servers verschiedene Sicherheitsrisiken verbunden sind. Problematisch ist hier vor allem die Erlaubnis zum anonymen Upload von Dateien. Dadurch könnte der Server zur Verbreitung von illegaler oder nicht lizensierter Software oder noch Schlimmeren missbraucht werden. Wenn anonyme FTP-Uploads dennoch erforderlich sind, sollten Sie die Zugriffsrechte so setzen, dass solche Dateien erst nach Zustimmung eines Administrators von anderen Benutzern heruntergeladen werden können.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-samba>52.10. Datei- und Druckserver für Microsoft® Windows®-Clients (Samba)<a class=anchor href=#network-samba></a></h3><div class=paragraph><p>Samba ist ein beliebtes Open Source Softwarepaket, das Datei- und Druckdienste über das SMB/CIFS-Protokoll zur Verfügung stellt. Dieses Protokoll ist in Microsoft® Windows®-Systemen enthalten und kann über die Installation der Samba-Client-Bibliotheken in andere Betriebssysteme integriert werden. Das Protokoll ermöglicht es Clients auf freigegebene Daten und Drucker zuzugreifen, so als ob es sich um lokale Drucker und Festplatten handeln würde.</p></div><div class=paragraph><p>Unter FreeBSD können die Samba-Client-Bibliotheken über den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net/samba410/>net/samba410</a> installiert werden. Der Client ermöglicht es einem FreeBSD-System auf SMB/CIFS-Freigaben in einem Microsoft® Windows®-Netzwerk zuzugreifen.</p></div><div class=paragraph><p>Ein FreeBSD-System kann auch als Samba-Server agieren, wenn Sie den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net/samba410/>net/samba410</a> installieren. Dies erlaubt es dem Administrator SMB/CIFS-Freigaben auf dem FreeBSD-System einzurichten, auf welche dann Clients mit Microsoft® Windows® oder den Samba-Client-Bibliotheken zugreifen können.</p></div><div class=sect3><h4 id=_konfiguration_des_servers>52.10.1. Konfiguration des Servers<a class=anchor href=#_konfiguration_des_servers></a></h4><div class=paragraph><p>Samba wird in <span class=filename>/usr/local/etc/smb4.conf</span> konfiguriert. Diese Datei muss erstellt werden, bevor Samba benutzt werden kann.</p></div><div class=paragraph><p>Eine einfache <span class=filename>smb4.conf</span>, wie hier gezeigt, stellt den Zugriff auf Verzeichnisse und Drucker für Windows®-Clients in einer Arbeitsgruppe (engl. Workgroup) zur Verfügung. In aufwendigeren Installationen, in denen LDAP oder Active Directory zum Einsatz kommt, ist es einfacher die <span class=filename>smb4.conf</span> mit dem Werkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=samba-tool&amp;sektion=8&amp;format=html">samba-tool(8)</a> zu erstellen.</p></div><div class="literalblock programlisting"><div class=content><pre>[global]
workgroup = WORKGROUP
server string = Samba Server Version %v
netbios name = ExampleMachine
wins support = Yes
security = user
passdb backend = tdbsam

# Example: share /usr/src accessible only to &#39;developer&#39; user
[src]
path = /usr/src
valid users = developer
writable  = yes
browsable = yes
read only = no
guest ok = no
public = no
create mask = 0666
directory mask = 0755</pre></div></div><div class=sect4><h5 id=_globale_einstellungen>52.10.1.1. Globale Einstellungen<a class=anchor href=#_globale_einstellungen></a></h5><div class=paragraph><p>Einstellungen für das Netzwerk werden in <span class=filename>/usr/local/etc/smb4.conf</span> definiert:</p></div><div class=dlist><dl><dt class=hdlist1><code>workgroup</code></dt><dd><p>Der Name der Arbeitsgruppe.</p></dd><dt class=hdlist1><code>netbios name</code></dt><dd><p>Der NetBIOS-Namen fest, unter dem der Samba-Server bekannt ist. In der Regel handelt es sich dabei um den ersten Teil des DNS-Namens des Servers.</p></dd><dt class=hdlist1><code>server string</code></dt><dd><p>Legt die Beschreibung fest, die angezeigt wird, wenn mit <code>net view</code> oder anderen Netzwerkprogrammen Informationen über den Server angefordert werden.</p></dd><dt class=hdlist1><code>wins support</code></dt><dd><p>Legt fest, ob Samba als WINS-Server fungieren soll. Aktivieren Sie die Unterstützung für WINS auf maximal einem Server im Netzwerk.</p></dd></dl></div></div><div class=sect4><h5 id=_samba_absichern>52.10.1.2. Samba absichern<a class=anchor href=#_samba_absichern></a></h5><div class=paragraph><p>Die wichtigsten Einstellungen in <span class=filename>/usr/local/etc/smb4.conf</span> betreffen das zu verwendende Sicherheitsmodell sowie das Backend-Passwortformat. Die folgenden Direktiven steuern diese Optionen:</p></div><div class=dlist><dl><dt class=hdlist1><code>security</code></dt><dd><p>Die häufigsten Optionen sind <code>security = share</code> und <code>security = user</code>. Wenn die Clients Benutzernamen verwenden, die den Benutzernamen auf dem FreeBSD-Rechner entsprechen, dann sollte die Einstellung <code>user level</code> verwendet werden. Dies ist die Standardeinstellung. Allerdings ist es dazu erforderlich, dass sich die Clients auf dem Rechner anmelden, bevor sie auf gemeinsame Ressourcen zugreifen können.</p><div class=paragraph><p>In der Einstellung <code>share level</code> müssen sich Clients nicht unter Verwendung eines gültigen Logins auf dem Rechner anmelden, bevor sie auf gemeinsame Ressourcen zugreifen können. In früheren Samba-Versionen war dies die Standardeinstellung.</p></div></dd><dt class=hdlist1><code>passdb backend</code></dt><dd><p>Samba erlaubt verschiedene Backend-Authentifizierungsmodelle. Clients können sich durch LDAP, NIS+, eine SQL-Datenbank oder eine Passwortdatei authentifizieren. Die empfohlene Authentifizierungsmethode, <code>tdbsam</code>, ist ideal für einfache Netzwerke und wird hier vorgestellt. Für größere oder komplexere Netzwerke wird <code>ldapsam</code> empfohlen. <code>smbpasswd</code> war der frühere Standard und gilt mittlerweile als veraltet.</p></dd></dl></div></div><div class=sect4><h5 id=_samba_benutzer>52.10.1.3. Samba Benutzer<a class=anchor href=#_samba_benutzer></a></h5><div class=paragraph><p>Damit Windows®-Clients auf die Freigaben zugreifen können, müssen die FreeBSD-Benutzerkonten in der <code>SambaSAMAccount</code>-Datenbank zugeordnet werden. Für bereits vorhandene Benutzerkonten kann dazu <a href="https://man.freebsd.org/cgi/man.cgi?query=pdbedit&amp;sektion=8&amp;format=html">pdbedit(8)</a> benutzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pdbedit -a username</span></code></pre></div></div><div class=paragraph><p>Dieser Abschnitt beschreibt lediglich die am häufigsten verwendeten Einstellungen. Ausführliche Informationen zur Konfiguration von Samba finden Sie im <a href=http://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/>Official Samba HOWTO</a>.</p></div></div></div><div class=sect3><h4 id=_samba_starten>52.10.2. Samba starten<a class=anchor href=#_samba_starten></a></h4><div class=paragraph><p>Damit Samba beim Systemstart automatisch aktiviert wird, fügen Sie die folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>samba_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Jetzt kann Samba direkt gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service samba_server start</span>
Performing sanity check on Samba configuration: OK
Starting nmbd.
Starting smbd.</code></pre></div></div><div class=paragraph><p>Samba verwendet drei Daemonen. Sowohl nmbd als auch smbd werden durch <code>samba_enable</code> gestartet. Wenn eine Namensauflösung über winbind benötigt wird, setzen Sie zusätzlich:</p></div><div class="literalblock programlisting"><div class=content><pre>winbindd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Samba kann jederzeit durch folgenden Befehl beendet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service samba_server stop</span></code></pre></div></div><div class=paragraph><p>Samba ist ein komplexes Softwarepaket mit umfassenden Funktionen, die eine weitreichende Integration von Microsoft® Windows®-Netzwerken ermöglichen. Für eine Beschreibung dieser Zusatzfunktionen sollten Sie sich auf <a href=http://www.samba.org>http://www.samba.org</a> umsehen.</p></div></div></div><div class=sect2><h3 id=network-ntp>52.11. Die Uhrzeit mit NTP synchronisieren<a class=anchor href=#network-ntp></a></h3><div class=paragraph><p>Die interne Uhrzeit eines Computers ist nie ganz exakt. Dies ist problematisch, da viele Dienste darauf angewiesen sind, dass die Computer im Netzwerk die exakte Uhrzeit übermitteln. Die exakte Uhrzeit ist auch erforderlich um sicherzustellen, dass die Zeitstempel der Dateien konsistent bleiben. Das Network Time Protocol (NTP) bietet die Möglichkeit, die exakte Uhrzeit in einem Netzwerk zur Verfügung zu stellen.</p></div><div class=paragraph><p>FreeBSD enthält <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>, das andere NTP-Server abfragen kann um die Uhrzeit auf diesem Computer zu synchronisieren, oder um selbst die Uhrzeit für andere Computer im Netzwerk bereitzustellen.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt die Konfiguration von ntpd unter FreeBSD. Zusätzliche Dokumentation im HTML-Format finden Sie in <span class=filename>/usr/shared/doc/ntp/</span>.</p></div><div class=sect3><h4 id=_ntp_konfigurieren>52.11.1. NTP konfigurieren<a class=anchor href=#_ntp_konfigurieren></a></h4><div class=paragraph><p>FreeBSD enthält mit ntpd ein Werkzeug, das zur Synchronisation der Uhrzeit verwendet werden kann. Die Konfiguration von Ntpd erfolgt über Variablen in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> und <span class=filename>/etc/ntp.conf</span>, und wird in den folgenden Abschnitten beschrieben.</p></div><div class=paragraph><p>Ntpd kommuniziert über UDP mit mit seinen Peers. Sämtliche Firewalls zwischen Ihrem Rechner und seinen NTP-Peers müssen so konfiguriert sein, dass UDP-Pakete auf Port 123 ein- und ausgehen können.</p></div><div class=sect4><h5 id=_etcntp_conf>52.11.1.1. <span class=filename>/etc/ntp.conf</span><a class=anchor href=#_etcntp_conf></a></h5><div class=paragraph><p>Ntpd liest <span class=filename>/etc/ntp.conf</span> um herauszufinden, welche NTP-Server abgefragt werden sollen. Die Auswahl mehrerer NTP-Server wird empfohlen, falls einer der Server nicht erreichbar ist oder sich seine Uhr als unzuverlässig erweist. Wenn ntpd Antworten erhält, bevorzugt es zuverlässige Server gegenüber weniger zuverlässigen. Die abgefragten Server können lokal im Netzwerk, von einem ISP bereitgestellt oder aus einer <a href=http://support.ntp.org/bin/view/Servers/WebHome>Liste öffentlich zugänglicher NTP-Server</a> ausgewählt werden. Wenn Sie einen öffentlichen NTP-Server auswählen, wählen Sie einen geografisch nahen NTP-Server und überprüfen Sie dessen Nutzungsrichtlinien. Das Schlüsselwort <code>pool</code> wählt einen oder mehrere Server aus einem Pool von Servern aus. Eine <a href=http://support.ntp.org/bin/view/Servers/NTPPoolServers>Liste mit öffentlich zugänglichen NTP-Pools</a> ist ebenfalls verfügbar, sortiert nach geografischen Gebieten. Darüber hinaus bietet FreeBSD einen vom Projekt gespendeten Pool, <code>0.freebsd.pool.ntp.org</code>.</p></div><div class=exampleblock><div class=title>Beispiel 47. Beispiel für <span class=filename>/etc/ntp.conf</span></div><div class=content><div class=paragraph><p>Dies ist ein einfaches Beispiel für eine <span class=filename>ntp.conf</span>-Datei. Die Einträge können so übernommen werden, wie sie sind. Die Datei enthält die notwendigen Einschränkungen für den Betrieb an einer öffentlich zugänglichen Netzwerkverbindung.</p></div><div class="literalblock programlisting"><div class=content><pre># Disallow ntpq control/query access.  Allow peers to be added only
# based on pool and server statements in this file.
restrict default limited kod nomodify notrap noquery nopeer
restrict source  limited kod nomodify notrap noquery

# Allow unrestricted access from localhost for queries and control.
restrict 127.0.0.1
restrict ::1

# Add a specific server.
server ntplocal.example.com iburst

# Add FreeBSD pool servers until 3-6 good servers are available.
tos minclock 3 maxclock 6
pool 0.freebsd.pool.ntp.org iburst

# Use a local leap-seconds file.
leapfile &#34;/var/db/ntpd.leap-seconds.list&#34;</pre></div></div></div></div><div class=paragraph><p>Das Format dieser Datei ist in <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a> beschrieben. Die folgenden Erläuterungen geben einen Überblick über die Schlüsselwörter, die in dem obigen Beispiel benutzt werden.</p></div><div class=paragraph><p>In der Voreinstellung ist ein NTP-Server für jeden Host im Netzwerk zugänglich. Das Schlüsselwort <code>restrict</code> steuert, welche Systeme auf den Server zugreifen dürfen. Es werden mehrere <code>restrict</code>-Einträge unterstützt, die jeweils die vorherigen Anweisungen verfeinern. Die im Beispiel gezeigten Werte gewährem dem lokalen System vollen Abfrage- und Kontrollzugriff, während entfernte Systemen nur die Möglichkeit gegeben wird, die Zeit abzufragen. Weitere Details finden Sie im Abschnitt <code>Access Control Support</code> von <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a>.</p></div><div class=paragraph><p>Das Schlüsselwort <code>server</code> gibt einen einzelnen Server zur Abfrage der Zeit an. Die Datei kann das Schlüsselwort <code>server</code> mehrmals enthalten, wobei pro Zeile jeweils ein Server aufgeführt ist. Das Schlüsselwort <code>pool</code> gibt einen Pool von Servern an. Ntpd fügt bei Bedarf einen oder mehrere Server aus diesem Pool hinzu, um die Anzahl der mit dem Wert <code>tos minclock</code> Peers zu erreichen. Das Schlüsselwort <code>iburst</code> weist ntpd an, einen Burst von acht schnellen Paketen mit dem Server auszutauschen, wenn der Kontakt zum ersten Mal hergestellt wird, um so die Systemzeit schneller zu synchronisieren.</p></div><div class=paragraph><p>Das Schlüsselwort <code>leapfile</code> gibt den Pfad einer Datei an, die Informationen über Schaltsekunden enthält. Die Datei wird automatisch durch <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> aktualisiert. Der angegebene Pfad muss mit dem in der Variable <code>ntp_db_leapfile</code> aus <span class=filename>/etc/rc.conf</span> übereinstimmen.</p></div></div><div class=sect4><h5 id=_ntp_einträge_in_etcrc_conf>52.11.1.2. NTP-Einträge in <span class=filename>/etc/rc.conf</span><a class=anchor href=#_ntp_einträge_in_etcrc_conf></a></h5><div class=paragraph><p>Um ntpd beim Booten zu starten, Sie in <span class=filename>/etc/rc.conf</span> den Eintrag <code>ntpd_enable="YES"</code> hinzu. Danach kann ntpd direkt gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ntpd start</span></code></pre></div></div><div class=paragraph><p>Lediglich <code>ntpd_enable</code> wird benötigt um ntpd benutzen zu können. Die unten aufgeführten <span class=filename>rc.conf</span>-Variablen können bei Bedarf ebenfalls verwendet werden.</p></div><div class=paragraph><p>Ist <code>ntpd_sync_on_start="YES"</code> konfiguriert, setzt ntpd die Uhrzeit beim Systemstart, unabhängig davon wie hoch die Abweichung ist. Normalerweise protokolliert ntpd eine Fehlermeldung und beendet sich selbst, wenn die Uhr um mehr als 1000 Sekunden abweicht. Diese Option ist besonders auf Systemem ohne batteriegepufferte Echtzeituhr nützlich.</p></div><div class=paragraph><p>Setzen Sie <code>ntpd_oomprotect="YES"</code>, um ntpd-Daemon davor zu schützen, vom System beendet zu werden, das versucht, sich von einer Out of Memory (OOM) Situation zu retten.</p></div><div class=paragraph><p>Mit <code>ntpd_config=</code> setzen Sie den Pfad auf eine alternative <span class=filename>ntp.conf</span>-Datei.</p></div><div class=paragraph><p>In <code>ntpd_flags=</code> können bei Bedarf weitere Werte enthalten sein. Vermeiden Sie jedoch die Werte, die intern von <span class=filename>/etc/rc.d/ntpd</span> verwaltet werden:</p></div><div class=ulist><ul><li><p><code>-p</code> (Pfad zur PID-Datei)</p></li><li><p><code>-c</code> (Setzen Sie stattdessen <code>ntpd_config=</code>)</p></li></ul></div></div><div class=sect4><h5 id=_ntpd_und_der_nicht_privilegierte_ntpd_benutzer>52.11.1.3. Ntpd und der nicht privilegierte <code>ntpd</code>-Benutzer<a class=anchor href=#_ntpd_und_der_nicht_privilegierte_ntpd_benutzer></a></h5><div class=paragraph><p>In FreeBSD kann Ntpd als nicht privilegierter Benutzer gestartet und ausgeführt werden. Dies erfordert das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ntpd&amp;sektion=4&amp;format=html">mac_ntpd(4)</a>. Das Startskript <span class=filename>/etc/rc.d/ntpd</span> untersucht zunächst die NTP Konfiguration. Wenn möglich, lädt es das <code>mac_ntpd</code>-Modul und startet dann ntpd als nicht privilegierten Benutzer <code>ntpd</code> (Benutzer-ID 123). Um Probleme mit dem Datei- und Verzeichniszugriff zu vermeiden, wird das Startskript ntpd nicht automatisch als Benutzer <code>ntpd</code> starten, falls die Konfiguration irgendwelche Datei-bezogenen Optionen enthält.</p></div><div class=paragraph><p>Falls einer der folgenden Werte in <code>ntpd_flags</code> vorhanden ist, muss eine manuelle Konfiguration vorgenommen werden, damit der Daemon vom <code>ntpd</code>-Benutzer ausgeführt werden kann:</p></div><div class=ulist><ul><li><p>-f oder --driftfile</p></li><li><p>-i oder --jaildir</p></li><li><p>-k oder --keyfile</p></li><li><p>-l oder --logfile</p></li><li><p>-s oder --statsdir</p></li></ul></div><div class=paragraph><p>Wenn einer der folgenden Schlüsselwörter in <span class=filename>ntp.conf</span> vorhanden ist, muss eine manuelle Konfiguration vorgenommen werden, damit der Daemon vom <code>ntpd</code>-Benutzer ausgeführt werden kann:</p></div><div class=ulist><ul><li><p>crypto</p></li><li><p>driftfile</p></li><li><p>key</p></li><li><p>logdir</p></li><li><p>statsdir</p></li></ul></div><div class=paragraph><p>Um ntpd so zu konfigurieren, dass der Daemon als Benutzer <code>ntpd</code> läuft, müssen folgende Voraussetzungen erfüllt sein:</p></div><div class=ulist><ul><li><p>Stellen Sie sicher, dass der <code>ntpd</code>-Benutzer Zugriff auf alle in der Konfiguration angegebenen Dateien und Verzeichnisse hat.</p></li><li><p>Stellen Sie sicher, dass das Modul <code>mac_ntpd</code> in den Kernel geladen oder kompiliert wird. <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ntpd&amp;sektion=4&amp;format=html">mac_ntpd(4)</a> enthält weitere Details.</p></li><li><p>Setzen Sie <code>ntpd_user="ntpd"</code> in <span class=filename>/etc/rc.conf</span>.</p></li></ul></div></div></div><div class=sect3><h4 id=_ntp_mit_einer_ppp_verbindung_verwenden>52.11.2. NTP mit einer PPP-Verbindung verwenden<a class=anchor href=#_ntp_mit_einer_ppp_verbindung_verwenden></a></h4><div class=paragraph><p>ntpd benötigt keine ständige Internetverbindung. Wenn Sie sich über eine PPP-Verbindung ins Internet einwählen, sollten Sie verhindern, dass NTP-Verkehr eine Verbindung aufbauen oder aufrechterhalten kann. Dies kann in den <code>filter</code>-Direktiven von <span class=filename>/etc/ppp/ppp.conf</span> festgelegt werden. Ein Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>set filter dial 0 deny udp src eq 123
# Prevent NTP traffic from initiating dial out
set filter dial 1 permit 0 0
set filter alive 0 deny udp src eq 123
# Prevent incoming NTP traffic from keeping the connection open
set filter alive 1 deny udp dst eq 123
# Prevent outgoing NTP traffic from keeping the connection open
set filter alive 2 permit 0/0 0/0</pre></div></div><div class=paragraph><p>Weitere Informationen finden Sie im Abschnitt <code>PACKET FILTERING</code> von <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> sowie in den Beispielen unter <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Einige Internetprovider blockieren Ports mit niedrigen Nummern. In solchen Fällen funktioniert NTP leider nicht, da Antworten eines NTP-Servers den Rechner nicht erreichen werden.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-iscsi>52.12. iSCSI Initiator und Target Konfiguration<a class=anchor href=#network-iscsi></a></h3><div class=paragraph><p>iSCSI bietet die Möglichkeit, Speicherkapazitäten über ein Netzwerk zu teilen. Im Gegensatz zu NFS, das auf Dateisystemebene arbeitet, funktioniert iSCSI auf Blockgerätebene.</p></div><div class=paragraph><p>In der iSCSI-Terminologie wird das System, das den Speicherplatz zur Verfügung stellt, als <em>Target</em> bezeichnet. Der Speicherplatz selbst kann aus einer physischen Festplatte bestehen, oder auch aus einem Bereich, der mehrere Festplatten, oder nur Teile einer Festplatte, repräsentiert. Wenn beispielsweise die Festplatte(n) mit ZFS formatiert ist, kann ein zvol erstellt werden, welches dann als iSCSI-Speicher verwendet werden kann.</p></div><div class=paragraph><p>Die Clients, die auf den iSCSI-Speicher zugreifen, werden <em>Initiator</em> genannt. Ihnen steht der verfügbare Speicher als rohe, nicht formatierte Festplatte, die auch als LUN bezeichnet wird, zur Verfügung. Die Gerätedateien für die Festplatten erscheinen in <span class=filename>/dev/</span> und müssen separat formatiert und eingehangen werden.</p></div><div class=paragraph><p>FreeBSD enthält einen nativen, kernelbasierten iSCSI <em>Target</em> und <em>Initiator</em>. Dieser Abschnitt beschreibt, wie ein FreeBSD-System als Target oder Initiator konfiguriert wird.</p></div><div class=sect3><h4 id=network-iscsi-target>52.12.1. Ein iSCSI-Target konfigurieren<a class=anchor href=#network-iscsi-target></a></h4><div class=paragraph><p>Um ein iSCSI-Target zu konfigurieren, erstellen Sie die Konfigurationsdatei <span class=filename>/etc/ctl.conf</span> und fügen Sie eine Zeile in <span class=filename>/etc/rc.conf</span> hinzu, um sicherzustellen, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> automatisch beim Booten gestartet wird. Starten Sie dann den Daemon.</p></div><div class=paragraph><p>Das folgende Beispiel zeigt eine einfache <span class=filename>/etc/ctl.conf</span>. Eine vollständige Beschreibung dieser Datei und der verfügbaren Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ctl.conf&amp;sektion=5&amp;format=html">ctl.conf(5)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>portal-group pg0 {
	discovery-auth-group no-authentication
	listen 0.0.0.0
	listen [::]
}

target iqn.2012-06.com.example:target0 {
	auth-group no-authentication
	portal-group pg0

	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre></div></div><div class=paragraph><p>Der erste Eintrag definiert die Portalgruppe <code>pg0</code>. Portalgruppen legen fest, auf welchen Netzwerk-Adressen der <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a>-Daemon Verbindungen entgegennehmen wird. Der Eintrag <code>discovery-auth-group no-authentication</code> zeigt an, dass jeder Initiator iSCSI-Targets suchen darf, ohne sich authentifizieren zu müssen. Die dritte und vierte Zeilen konfigurieren <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> so, dass er auf allen IPv4- (<code>listen 0.0.0.0</code>) und IPv6-Adressen (<code>listen [::]</code>) auf dem Standard-Port 3260 lauscht.</p></div><div class=paragraph><p>Es ist nicht zwingend notwendig eine Portalgruppe zu definieren, da es bereits eine integrierte Portalgruppe namens <code>default</code> gibt. In diesem Fall ist der Unterschied zwischen <code>default</code> und <code>pg0</code> der, dass bei <code>default</code> eine Authentifizierung nötig ist, während bei <code>pg0</code> die Suche nach Targets immer erlaubt ist.</p></div><div class=paragraph><p>Der zweite Eintrag definiert ein einzelnes Target. Ein Target hat zwei mögliche Bedeutungen: eine Maschine die iSCSI bereitstellt, oder eine Gruppe von LUNs. Dieses Beispiel verwendet die letztere Bedeutung, wobei <code>iqn.2012-06.com.example:target0</code> der Name des Targets ist. Dieser Name ist nur für Testzwecke geeignet. Für den tatsächlichen Gebrauch ändern Sie <code>com.example</code> auf einen echten, rückwärts geschriebenen Domainnamen. <code>2012-06</code> steht für das Jahr und den Monat, an dem die Domain erworben wurde. <code>target0</code> darf einen beliebigen Wert haben und in der Konfigurationsdatei darf eine beliebige Anzahl von Targets definiert werden.</p></div><div class=paragraph><p>Der Eintrag <code>auth-group no-authentication</code> erlaubt es allen Initiatoren sich mit dem angegebenen Target zu verbinden und <code>portal-group pg0</code> macht das Target über die Portalgruppe <code>pg0</code> erreichbar.</p></div><div class=paragraph><p>Die nächste Sektion definiert die LUN. Jede LUN wird dem Initiator als separate Platte präsentiert. Für jedes Target können mehrere LUNs definiert werden. Jede LUN wird über eine Nummer identifiziert, wobei LUN 0 verpflichtend ist. Die Zeile mit dem Pfad <code>path /data/target0-0</code> definiert den absoluten Pfad zu der Datei oder des zvols für die LUN. Der Pfad muss vorhanden sein, bevor <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> gestartet wird. Die zweite Zeile ist optional und gibt die Größe der LUN an. Als nächstes fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein, um <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> automatisch beim Booten zu starten:</p></div><div class="literalblock programlisting"><div class=content><pre>ctld_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Um <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> jetzt zu starten, geben Sie dieses Kommando ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld start</span></code></pre></div></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a>-Daemon liest beim Start <span class=filename>/etc/ctl.conf</span>. Wenn diese Datei nach dem Starten des Daemons bearbeitet wird, verwenden Sie folgenden Befehl, damit die Änderungen sofort wirksam werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld reload</span></code></pre></div></div><div class=sect4><h5 id=_authentifizierung>52.12.1.1. Authentifizierung<a class=anchor href=#_authentifizierung></a></h5><div class=paragraph><p>Die vorherigen Beispiele sind grundsätzlich unsicher, da keine Authentifizierung verwendet wird und jedermann vollen Zugriff auf alle Targets hat. Um für den Zugriff auf die Targets einen Benutzernamen und ein Passwort vorauszusetzen, ändern Sie die Konfigurationsdatei wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>auth-group ag0 {
	chap username1 secretsecret
	chap username2 anothersecret
}

portal-group pg0 {
	discovery-auth-group no-authentication
	listen 0.0.0.0
	listen [::]
}

target iqn.2012-06.com.example:target0 {
	auth-group ag0
	portal-group pg0
	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre></div></div><div class=paragraph><p>Die Sektion <code>auth-group</code> definiert die Benutzernamen und Passwörter. Um sich mit <code>iqn.2012-06.com.example:target0</code> zu verbinden, muss ein Initiator zuerst einen Benutzernamen und ein Passwort angeben. Eine Suche nach Targets wird jedoch immer noch ohne Authentifizierung gestattet. Um eine Authentifizierung zu erfordern, setzen Sie <code>discovery-auth-group</code> auf eine definierte <code>auth-group</code> anstelle von <code>no-autentication</code>.</p></div><div class=paragraph><p>In der Regel wird für jeden Initiator ein einzelnes Target exportiert. In diesem Beispiel wird der Benutzername und das Passwort direkt im Target-Eintrag festgelegt:</p></div><div class="literalblock programlisting"><div class=content><pre>target iqn.2012-06.com.example:target0 {
	portal-group pg0
	chap username1 secretsecret

	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre></div></div></div></div><div class=sect3><h4 id=network-iscsi-initiator>52.12.2. Einen iSCSI-Initiator konfigurieren<a class=anchor href=#network-iscsi-initiator></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Der in dieser Sektion beschriebene iSCSI-Initiator wird seit FreeBSD 10.0-RELEASE unterstützt. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=iscontrol&amp;sektion=8&amp;format=html">iscontrol(8)</a>, wenn Sie den iSCSI-Initiator mit älteren Versionen benutzen möchten.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um den Initiator zu verwenden, muss zunächst ein iSCSI-Daemon gestartet sein. Der Daemon des Initiators benötigt keine Konfigurationsdatei. Um den Daemon automatisch beim Booten zu starten, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>iscsid_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Um <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a> jetzt zu starten, geben Sie dieses Kommando ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service iscsid start</span></code></pre></div></div><div class=paragraph><p>Die Verbindung mit einem Target kann mit, oder ohne eine Konfigurationsdatei <span class=filename>/etc/iscsi.conf</span> durchgeführt werden. Dieser Abschnitt beschreibt beide Möglichkeiten.</p></div><div class=sect4><h5 id=_verbindung_zu_einem_target_herstellen_ohne_konfigurationsdatei>52.12.2.1. Verbindung zu einem Target herstellen - ohne Konfigurationsdatei<a class=anchor href=#_verbindung_zu_einem_target_herstellen_ohne_konfigurationsdatei></a></h5><div class=paragraph><p>Um einen Initiator mit einem Target zu verbinden, geben Sie die IP-Adresse des Portals und den Namen des Ziels an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -A -p 10.10.10.10 -t iqn.2012-06.com.example:target0</span></code></pre></div></div><div class=paragraph><p>Um zu überprüfen, ob die Verbindung gelungen ist, rufen Sie <code>iscsictl</code> ohne Argumente auf. Die Ausgabe sollte in etwa wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Connected: da0</pre></div></div><div class=paragraph><p>In diesem Beispiel wurde die iSCSI-Sitzung mit der LUN <span class=filename>/dev/da0</span> erfolgreich hergestellt. Wenn das Target <code>iqn.2012-06.com.example:target0</code> mehr als nur eine LUN exportiert, werden mehrere Gerätedateien in der Ausgabe angezeigt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Connected: da0 da1 da2.</code></pre></div></div><div class=paragraph><p>Alle Fehler werden auf die Ausgabe und in die Systemprotokolle geschrieben. Diese Meldung deutet beispielsweise darauf hin, dass der <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a>-Daemon nicht ausgeführt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Waiting for iscsid(8)</pre></div></div><div class=paragraph><p>Die folgende Meldung deutet auf ein Netzwerkproblem hin, zum Beispiel eine falsche IP-Adresse oder einen falschen Port:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.11     Connection refused</pre></div></div><div class=paragraph><p>Diese Meldung bedeutet, dass der Name des Targets falsch angegeben wurde:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Not found</pre></div></div><div class=paragraph><p>Diese Meldung bedeutet, dass das Target eine Authentifizierung erfordert:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Authentication failed</pre></div></div><div class=paragraph><p>Verwenden Sie diese Syntax, um einen CHAP-Benutzernamen und ein Passwort anzugeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -A -p 10.10.10.10 -t iqn.2012-06.com.example:target0 -u user -s secretsecret</span></code></pre></div></div></div><div class=sect4><h5 id=_verbindung_mit_einem_target_herstellen_mit_konfigurationsdatei>52.12.2.2. Verbindung mit einem Target herstellen - mit Konfigurationsdatei<a class=anchor href=#_verbindung_mit_einem_target_herstellen_mit_konfigurationsdatei></a></h5><div class=paragraph><p>Wenn Sie für die Verbindung eine Konfigurationsdatei verwenden möchten, erstellen Sie <span class=filename>/etc/iscsi.conf</span> mit etwa folgendem Inhalt:</p></div><div class="literalblock programlisting"><div class=content><pre>t0 {
	TargetAddress   = 10.10.10.10
	TargetName      = iqn.2012-06.com.example:target0
	AuthMethod      = CHAP
	chapIName       = user
	chapSecret      = secretsecret
}</pre></div></div><div class=paragraph><p><code>t0</code> gibt den Namen der Sektion in der Konfigurationsdatei an. Diser Name wird vom Initiator benutzt, um zu bestimmen, welche Konfiguration verwendet werden soll. Die anderen Einträge legen die Parameter fest, die während der Verbindung verwendet werden. <code>TargetAddress</code> und <code>TargetName</code> müssen angegeben werden, die restlichen sind optional. In diesen Beispiel wird der CHAP-Benuztername und das Passwort angegeben.</p></div><div class=paragraph><p>Um sich mit einem bestimmten Target zu verbinden, geben Sie dessen Namen an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -An t0</span></code></pre></div></div><div class=paragraph><p>Um sich stattdessen mit allen definierten Targets aus der Konfigurationsdatei zu verbinden, verwenden Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -Aa</span></code></pre></div></div><div class=paragraph><p>Damit sich der Initiator automatisch mit allen Targets aus <span class=filename>/etc/iscsi.conf</span> verbindet, fügen Sie folgendes in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>iscsictl_enable=&#34;YES&#34;
iscsictl_flags=&#34;-Aa&#34;</pre></div></div></div></div></div></div></div><div class=sect1><h2 id=firewalls>Kapitel 53. Firewalls<a class=anchor href=#firewalls></a></h2><div class=sectionbody><div class=sect2><h3 id=firewalls-intro>53.1. Einführung<a class=anchor href=#firewalls-intro></a></h3><div class=paragraph><p>Firewalls ermöglichen es, den ein- und ausgehenden Netzwerkverkehr eines Systems zu filtern. Dazu verwendet eine Firewall eine oder mehrere Gruppen von "Regeln", um ankommende Netzwerkpakete zu untersuchen und entweder durchzulassen oder zu blockieren. Die Regeln einer Firewall untersuchen charakteristische Eigenschaften von Datenpaketen, darunter den Protokolltyp, die Quell- und Zieladresse sowie den Quell- und Zielport.</p></div><div class=paragraph><p>Firewalls können die Sicherheit eines Rechners oder eines Netzwerks erhöhen, indem sie folgende Aufgaben übernehmen:</p></div><div class=ulist><ul><li><p>Den Schutz der Anwendungen, Dienste und Rechner eines internen Netzwerks vor unerwünschtem Datenverkehr aus dem Internet.</p></li><li><p>Die Beschränkung des Zugriffs von Rechnern des internen Netzwerks auf Rechner oder Dienste des öffentlichen Internets.</p></li><li><p>Den Einsatz von Network Address Translation (NAT), welches es durch die Verwendung von privaten IP-Adressen ermöglicht, eine einzige gemeinsame Internetverbindung für mehrere Rechner zu nutzen. Dies geschieht entweder über eine einzige IP-Adresse oder über eine Gruppe von jeweils automatisch zugewiesenen öffentlichen Adressen.</p></li></ul></div><div class=paragraph><p>Das Basissystem von FreeBSD enthält drei Firewalls: PF, IPFW und IPFILTER (auch als IPF bekannt). FreeBSD enthält ebenfalls zwei Traffic-Shaper zur Kontrolle der Bandbreite: <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>. ALTQ ist traditionell eng an PF gebunden, während dummynet zusammen mit IPFW verwendet wird. Gemeinsam ist allen Firewalls, dass sie Regeln einsetzen, um den Transfer von ein- und ausgehenden Datenpaketen des Systems zu steuern. Unterschiedlich ist aber die Art und Weise, wie dies realisiert wird. Auch die für diese Regeln verwendete Syntax ist unterschiedlich.</p></div><div class=paragraph><p>FreeBSD besitzt mehrere Firewalls, um den unterschiedlichen Anforderungen und Vorlieben von Benutzern gerecht zu werden. Jeder Benutzer sollte selbst beurteilen, welche Firewall seinen Bedürfnissen am besten entspricht.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie wissen:</p></div><div class=ulist><ul><li><p>Wie man Paketfilterregeln erstellt.</p></li><li><p>Was die Unterschiede zwischen den in FreeBSD eingebauten Firewalls sind.</p></li><li><p>Wie die PF-Firewall konfiguriert und einsetzt wird.</p></li><li><p>Wie die IPFW-Firewall konfiguriert und einsetzt wird.</p></li><li><p>Wie die IPFILTER-Firewall konfiguriert und einsetzt wird.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>Die grundlegenden Konzepte von FreeBSD und dem Internet verstehen.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Da alle Firewalls auf der Inspektion ausgewählter Kontrollfelder in Datenpaketen basieren, muss für die Erstellung von Firewallregeln ein grundlegendes Verständnis von TCP/IP vorhanden sein. Eine gute Einführung finden Sie in <a href=http://www.ipprimer.com>Daryl’s TCP/IP Primer</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=firewalls-concepts>53.2. Firewallkonzepte<a class=anchor href=#firewalls-concepts></a></h3><div class=paragraph><p>Ein Regelsatz besteht aus einer Gruppe von Regeln, die Pakete basierend auf ihren Inhalt entweder blockieren oder durchlassen. Der bidirektionale Austausch von Paketen zwischen zwei Rechnern wird als Sitzung (Session) bezeichnet. Der Regelsatz verarbeitet sowohl ankommende Pakete aus dem Internet, als auch die vom System erzeugten Antwortpakete. Jeder TCP/IP-Dienst hat ein festgelegtes Protokoll und einen vorgegebenen Port. Pakete für einen bestimmten Dienst stammen von einer Quelladresse und einem unprivilegierten Port und gehen an einen spezifischen Port auf der Zieladresse. Alle oben genannten Parameter können als Selektionskriterien verwendet werden, um einen Regelsatz zu erstellen, der den Zugriff auf bestimmte Dienste gewährt oder blockiert.</p></div><div class=paragraph><p>Unbekannte Portnummern können Sie in <span class=filename>/etc/services</span> nachschlagen. Alternativ finden Sie die Portnummern und deren Verwendungszweck auf <a href=http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers>http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a>.</p></div><div class=paragraph><p>Unter diesem Link finden Sie <a href=http://web.archive.org/web/20150803024617/http://www.sans.org/security-resources/idfaq/oddports.php>Portnummern, die auch von Trojanern benutzt werden</a>.</p></div><div class=paragraph><p>FTP hat zwei Modi: Aktiv und Passiv. Unterschied liegt in der Bestimmung des Datenkanals. Der Passiv-Modus ist sicherer, da der Datenkanal vom Client bestimmt wird. Eine ausführliche Erklärung von FTP und den verschiedenen Modi finden Sie unter <a href=http://www.slacksite.com/other/ftp.html>http://www.slacksite.com/other.ftp.html</a>.</p></div><div class=paragraph><p>Ein Firewall-Regelsatz kann entweder "einschließend" (inclusive firewall) oder "ausschließend" (exclusive Firewall) sein. Eine ausschließende Firewall lässt jeden Datenverkehr durch, der nicht durch eine Regel ausgeschlossen wurde. Eine einschließende Firewall macht das genaue Gegenteil. Sie lässt Datenverkehr nur dann passieren, wenn dieser einer der definierten Regeln entspricht.</p></div><div class=paragraph><p>Eine einschließende Firewall bietet eine wesentlich bessere Kontrolle des ausgehenden Verkehrs, was sie zur besseren Wahl für Systeme macht, welche Dienste für das Internet anbieten. Sie kontrolliert auch den Verkehr aus dem öffentlichen Internet zum privaten Netzwerk. Jeder Verkehr, der keiner Regel entspricht wird geblockt und protokolliert. Einschließende Firewalls sind generell sicherer als ausschließende Firewalls, da sie das Risiko, dass unerwünschter Verkehr hindurch geht, drastisch reduzieren.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn nicht anders vermerkt, verwenden alle Konfigurationen und Regelsätze in diesem Kapitel einschließende Firewalls.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Sicherheit kann durch den Einsatz einer "zustandsorientierten Firewall" (stateful firewall) weiter erhöht werden. Dieser Typ Firewall überwacht alle offenen Verbindungen und erlaubt nur Datenverkehr von bereits bestehenden Verbindungen oder wenn eine neue Verbindung aufgebaut wird.</p></div><div class=paragraph><p>Eine zustandsorientierte Firewall behandelt den Verkehr als einen bidirektionalen Austausch von Paketen während einer Session. Wenn ein Zustand für eine passende Regel angegeben wird, erstellt die Firewall dynamisch interne Regeln für jedes Paket, das während dieser Session ausgetauscht wird. Die Firewall hat ausreichend Möglichkeiten, um zu bestimmen, ob ein Paket zu einer Session gehört. Alle Pakete, die nicht zu dieser Session passen, werden automatisch abgelehnt.</p></div><div class=paragraph><p>Sobald die Session beendet ist, wird sie aus der dynamischen Zustandstabelle entfernt.</p></div><div class=paragraph><p>Eine zustandsorientierte Filterung erlaubt es, sich auf die Sperrung bzw. Freigabe von neuen Sessions zu konzentrieren. Wenn eine neue Session genehmigt wird, werden alle nachfolgenden Pakete dieser Session automatisch erlaubt und betrügerische Pakete werden automatisch abgelehnt. Wenn eine neue Session nicht genehmigt wird, werden alle nachfolgenden Pakete dieser Session abgelehnt. Die zustandsorientierte Filterung bietet fortgeschrittene Fähigkeiten zur Abwehr von verschiedensten Angriffsmethoden, die von Angreifern eingesetzt werden.</p></div><div class=paragraph><p>NAT steht für <em>Network Address Translation</em>. Die NAT-Funktion ermöglicht es einem privaten LAN hinter einer Firewall, sich eine einzelne vom ISP zugewiesene IP-Adresse zu teilen, auch wenn die Adresse dynamisch zugewiesen wird. NAT ermöglicht den Internetzugriff für jeden Rechner im LAN, ohne dass der ISP für mehrere Internet-Konten bezahlt wird.</p></div><div class=paragraph><p>NAT übersetzt automatisch die private IP-Adresse auf die öffentliche IP-Adresse, sobald ein Paket für das öffentliche Internet die Firewall passiert. Zusätzlich führt es auch die Übersetzung der Anwortpakete durch.</p></div><div class=paragraph><p>Gemäß RFC 1918 sind die folgenden IP-Adressbereiche für private Netzwerke reserviert und werden nie ins öffentliche Internet weitergeleitet. Daher sind diese Bereiche für den Einsatz mit NAT geeignet:</p></div><div class=ulist><ul><li><p><code>10.0.0.0/8</code></p></li><li><p><code>172.16.0.0/12</code></p></li><li><p><code>192.168.0.0/16</code></p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Seien Sie <em>äußerst vorsichtig</em> wenn Sie mit Firewallregeln arbeiten. Durch eine falsche Konfiguration kann der Administrator den Zugriff auf den Server verlieren. Um auf der sicheren Seite zu sein, sollten Sie die anfängliche Konfiguration der Firewall von der lokalen Konsole durchführen, anstatt dass Sie dies aus der Ferne über ssh tun.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=firewalls-pf>53.3. PF<a class=anchor href=#firewalls-pf></a></h3><div class=paragraph><p>In FreeBSD 5.3 wurde PF von OpenBSD in das Basissystem integriert. Bei PF handelt es sich um eine komplette, voll ausgestattete Firewall, die optional auch ALTQ (Alternatives Queuing) unterstützt. ALTQ stellt Quality of Service (QoS) zur Verfügung.</p></div><div class=paragraph><p>Das OpenBSD-Projekt pflegt die maßgebliche Referenz von PF in der <a href=http://www.openbsd.org/faq/pf>PF FAQ</a>. Peter Hansteen betreut ein sehr ausführliches PF-Tutorial unter <a href=http://home.nuug.no/~peter/pf/>http://home.nuug.no/~peter/pf/</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Bedenken Sie beim Studium der <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a>, dass die PF-Version von FreeBSD im Laufe der Jahre erheblich von der Version in OpenBSD abgewichen ist. Nicht alle Eigenschaften funktionieren unter FreeBSD genauso wie unter OpenBSD und umgekehrt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die <a href=https://lists.FreeBSD.org/subscription/freebsd-pf>FreeBSD packet filter mailing list</a> ist ein guter Anlaufpunkt für Fragen zur Konfiguration und dem Einsatz der PF-Firewall. Überprüfen Sie aber zunächst die Archive der Mailingliste, bevor Sie eine Frage stellen. Vielleicht wurde die Frage dort schon beantwortet.</p></div><div class=paragraph><p>Dieser Abschnitt konzentriert sich auf PF in FreeBSD. Es wird beschrieben, wie PF und ALTQ aktiviert werden. Zusätzlich wird demonstriert, wie Regelsätze auf einem FreeBSD-System erstellt werden.</p></div><div class=sect3><h4 id=_pf_aktivieren>53.3.1. PF aktivieren<a class=anchor href=#_pf_aktivieren></a></h4><div class=paragraph><p>Um PF zu benutzen, muss zunächst das Kernelmodul geladen werden. Dieser Abschnitt beschreibt die Einträge für <span class=filename>/etc/rc.conf</span>, die verwendet werden können um PF zu aktivieren.</p></div><div class=paragraph><p>Beginnen Sie damit <code>pf_enable=yes</code> in <span class=filename>/etc/rc.conf</span> hinzuzufügen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pf_enable=yes</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> beschreibt zusätzliche Optionen, die beim Start an PF übergeben werden können. Fügen Sie diesen Eintrag in <span class=filename>/etc/rc.conf</span> hinzu und schreiben Sie die benötigten Optionen zwischen die Anführungszeichen:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_flags=&#34;&#34;                     # additional flags for pfctl startup</pre></div></div><div class=paragraph><p>PF kann nicht gestartet werden, wenn es seine Konfigurationsdatei nicht findet. In der Voreinstellung existiert unter FreeBSD kein Regelsatz namens <span class=filename>/etc/pf.conf</span>. Beispiel-Regelsätze finden Sie in <span class=filename>/usr/shared/examples/pf/</span>. Wenn bereits ein Regelsatz an anderer Stelle gespeichert wurde, fügen Sie in <span class=filename>/etc/rc.conf</span> einen Eintrag mit dem vollständigen Pfad zur Datei ein:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_rules=&#34;/path/to/pf.conf&#34;</pre></div></div><div class=paragraph><p>Protokollierungsfunktionen für PF werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a> zur Verfügung gestellt. Fügen Sie <code>pflog_enable=yes</code> in <span class=filename>/etc/rc.conf</span> ein, um diese Funktion zu aktivieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pflog_enable=yes</span></code></pre></div></div><div class=paragraph><p>Die folgenden Zeilen können zusätzlich hinzugefügt werden, um den Speicherort der Protokolldatei zu bestimmen und weitere Optionen beim Start an <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a> zu übergeben:</p></div><div class="literalblock programlisting"><div class=content><pre>pflog_logfile=&#34;/var/log/pflog&#34;  # where pflogd should store the logfile
pflog_flags=&#34;&#34;                  # additional flags for pflogd startup</pre></div></div><div class=paragraph><p>Falls ein LAN hinter der Firewall existiert und die Pakete an die Rechner im LAN weitergeleitet werden müssen, oder wenn NAT benötigt wird, aktivieren Sie die folgende Option:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;            # Enable as LAN gateway</pre></div></div><div class=paragraph><p>Nachdem die Änderungen gespeichert wurden, kann PF mit Unterstützung für Protokollierung gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service pf start</span>
<span class=c># service pflog start</span></code></pre></div></div><div class=paragraph><p>In der Voreinstellung liest PF seine Konfiguration aus <span class=filename>/etc/pf.conf</span> und modifiziert, verwirft oder akzeptiert Pakete anhand der Definitionen in dieser Datei. FreeBSD enthält mehrere Beispieldateien unter <span class=filename>/usr/shared/examples/pf/</span>. Auch die <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a> enthält sehr ausführliche Beispiele für PF-Regeln.</p></div><div class=paragraph><p>Zur Steuerung von PF wird <code>pfctl</code> verwendet. <a href=#pfctl>Nützliche <code>pfctl</code> Optionen</a> fasst einige nützliche Optionen für diesen Befehl zusammen. Eine Beschreibung aller verfügbaren Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a>.</p></div><table id=pfctl class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 29. Nützliche <code>pfctl</code> Optionen</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Kommando</th><th class="tableblock halign-left valign-top">Aufgabe</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PF aktivieren</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PF deaktivieren</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -F all -f /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alle Filterregeln zurücksetzen (NAT, Filter, Zustandstabelle) und <span class=filename>/etc/pf.conf</span> erneut einlesen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -s [ rules | nat | states ]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zusammenfassung der Filterregeln, NAT-Regeln, oder der Zustandstabelle.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -vnf /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Überprüft <span class=filename>/etc/pf.conf</span> auf Fehler, lädt aber die Filterregeln nicht neu.</p></td></tr></tbody></table><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> ist nützlich um Kommandos mit erhöhten Berechtigungen auszuführen, wie beispielsweise <code>pfctl</code>. Das Programm kann aus der Ports-Sammlung installiert werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um den ein- und ausgehenden Verkehr im Auge zu behalten, können Sie ein Werkzeug wie <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/pftop/>sysutils/pftop</a> benutzen. Sobald das Programm installiert ist, können Sie pftop ausführen, um einen Snapshot des Datenverkehrs zu sehen. Das Format der Ausgabe ist der von <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> sehr ähnlich.</p></div></div><div class=sect3><h4 id=pf-tutorial>53.3.2. PF Regelsätze<a class=anchor href=#pf-tutorial></a></h4><div class=paragraph><p>Dieser Abschnitt beschreibt die Erstellung von angepassten Regelsätzen. Es wird mit dem einfachsten Regelsatz begonnen auf dem dann weitere aufgebaut werden, um die Konzepte und Funktionen von PF an einigen konkreten Beispielen zu verdeutlichen.</p></div><div class=paragraph><p>Der einfachste Regelsatz gilt für einen Rechner, der keine Dienste anbietet und Zugriff auf das Internet haben soll. Für diesen minimalen Regelsatz wird <span class=filename>/etc/pf.conf</span> wie folgt konfiguriert:</p></div><div class="literalblock programlisting"><div class=content><pre>block in all
pass out all keep state</pre></div></div><div class=paragraph><p>Die erste Regel blockiert jeglichen eingehenden Datenverkehr. Die zweite Regel erlaubt ausgehende Verbindungen von diesem Rechner, während die Zustandsinformationen dieser Verbindungen gespeichert werden. Diese Zustandsinformationen machen es möglich, den Antwortverkehr für diese Verbindungen zu erlauben. Der Regelsatz wird mit dem folgenden Befehl geladen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -e ; pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Neben den Zustandsinformationen verfügt PF über <em>Listen</em> und <em>Makros</em>. Diese können bei der Erstellung der Regeln definiert werden. Makros können Listen enthalten und sie müssen vor ihrer ersten Benutzung definiert sein. Fügen Sie beispielsweise folgende Zeilen an den Anfang des Regelsatzes:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;</pre></div></div><div class=paragraph><p>PF versteht sowohl Portnamen als auch Portnummern, solange die Namen in <span class=filename>/etc/services</span> aufgeführt sind. Dieses Beispiel erstellt zwei Makros. Das erste ist eine Liste mit sieben TCP-Portnamen, die zweite Liste enthält einen UDP-Portnamen. Sobald ein Makro definiert ist, kann es in den Regeln verwendet werden. In diesem Beispiel wird der gesamte Datenverkehr geblockt, mit Ausnahme der Verbindungen die von diesem Rechner initiiert wurden und sich auf einen der angegebenen TCP-Dienste oder den UDP-Dienst beziehen:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Obwohl UDP als zustandsloses Protokoll betrachtet wird, ist PF in der Lage einige Zustandsinformationen zu verfolgen. Wenn beispielsweise eine UDP-Abfrage für einen Nameserver das System verlässt, wird PF nach der Antwort Ausschau halten und das Antwortpaket durch lassen.</p></div><div class=paragraph><p>Nachdem der Regelsatz verändert wurde, muss er neu geladen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Wenn keine Syntaxfehler festgestellt werden, wird <code>pfctl</code> keine Ausgabe erzeugen. Die Syntax kann auch getestet werden, bevor der Regelsatz geladen wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -nf /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Die Option <code>-n</code> bewirkt, dass die Regeln nur interpretiert, jedoch nicht geladen werden. Dies bietet die Möglichkeit, alle Fehler zu korrigieren. Es wird immer der letzte gültige Regelsatz geladen, bis PF entweder deaktiviert, oder ein neuer Regelsatz geladen wird.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Wenn Sie beim Laden oder Prüfen des Regelsatzes noch die Option <code>-v</code> hinzufügen, wird <code>pfctl</code> den komplett interpretierten Regelsatz anzeigen. Dies ist äußerst nützlich, wenn Sie versuchen Fehler im Regelsatz zu finden.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=pftut-gateway>53.3.2.1. Einfaches Gateway mit NAT<a class=anchor href=#pftut-gateway></a></h5><div class=paragraph><p>Dieser Abschnitt zeigt wie ein FreeBSD-System mit PF als Gateway konfiguriert wird. Das Gateway muss über mindestens zwei Netzwerkkarten verfügen, die jeweils mit einem separaten Netzwerk verbunden sind. In diesem Beispiel ist <span class=filename>xl0</span> mit dem Internet verbunden und <span class=filename>xl1</span> ist mit dem internen Netzwerk verbunden.</p></div><div class=paragraph><p>Aktivieren Sie zunächst das Gateway, damit der Rechner den Netzwerkverkehr von einer Schnittstelle zur nächsten weiterleiten kann. Diese sysctl-Einstellung sorgt dafür, dass IPv4-Pakete weitergeleitet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>So leiten Sie IPv6-Datenverkehr weiter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet6.ip6.forwarding=1</span></code></pre></div></div><div class=paragraph><p>Um diese Einstellungen beim Systemstart zu aktivieren, fügen Sie sie mit Hilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;format=html">sysrc(8)</a> in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc gateway_enable=yes</span>
<span class=c># sysrc ipv6_gateway_enable=yes</span></code></pre></div></div><div class=paragraph><p>Prüfen Sie mit <code>ifconfig</code>, dass beide Schnittstellen vorhanden und aktiv sind.</p></div><div class=paragraph><p>Als nächstes erstellen Sie die nötigen PF-Regeln, damit das Gateway den Datenverkehr weiterleiten kann. Die folgende Regel erlaubt den zustandsorientierten Verkehr aus dem Internet zu den Rechnern im Netzwerk:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in on xl1 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>Diese Regel erlaubt lediglich den Datenverkehr über das Gateway auf der internen Schnittstelle. Damit die Pakete noch weiter gehen, wird eine passende Regel benötigt:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out on xl0 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>Obwohl diese beiden Regeln funktionieren, werden sie in der Praxis so spezifisch selten benötigt. Ein lesbarer Regelsatz ist oft ein sicherer Regelsatz. Der Rest dieses Abschnitts zeigt, wie Sie die Regeln so einfach und lesbar wie möglich halten. Zum Beispiel könnten die beiden Regeln zu einer Regel zusammengefasst werden:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from xl1:network to any port $ports keep state</pre></div></div><div class=paragraph><p>Die Notation <code>interface:network</code> kann durch ein Makro ersetzt werden, um den Regelsatz besser lesbar zu machen. Zum Beispiel könnte für das Netzwerk an der internen Schnittstelle (<code>xl0:network</code>) ein Makro namens <code>$localnet</code> definiert werden. Alternativ könnte für die Definition von <code>$localnet</code> auch eine <em>IP-Adresse/Netzmaske</em> Notation verwendet werden, um ein Netzwerk zu bezeichnen, beispielsweise <code>192.168.100.1/24</code> für ein privates Subnetz.</p></div><div class=paragraph><p>Bei Bedarf kann für <code>$localnet</code> auch eine Liste von Netzwerken definiert werden. Abhängig von den Bedürfnissen kann <code>$localnet</code> auch für eine typische Regel wie folgt verwendet werden:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from $localnet to any port $ports keep state</pre></div></div><div class=paragraph><p>Der folgende Regelsatz erlaubt sämtlichen Verkehr, der von den Rechnern im internen Netzwerk initiiert wird. Zunächst werden zwei Makros definiert, die die externen und internen 3COM-Schnittstellen repräsentieren.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bei Einwählverbindungen wird <span class=filename>tun0</span> für die externe Schnittstelle verwendet. Bei ADSL-Verbindungen, insbesondere denen die PPP over Ethernet (PPPoE) verwenden, ist die richtige externe Schnittstelle <span class=filename>tun0</span> und nicht die physische Ethernet-Schnittstelle.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>ext_if = &#34;xl0&#34;	# macro for external interface - use tun0 for PPPoE
int_if = &#34;xl1&#34;	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</pre></div></div><div class=paragraph><p>Dieser Regelsatz führt die NAT-Regel ein, die verwendet wird, um die Übersetzung der Netzwerkadressen von den nicht-routebaren Adressen im internen Netzwerk auf die IP-Adresse der externen Schnittstelle zu handhaben. Die Klammern im letzten Teil der NAT-Regel <code>($ext_if)</code> werden angegeben, wenn die IP-Adresse der externen Schnittstelle dynamisch zugewiesen wird. Damit wird sichergestellt, dass der Netzwerkverkehr ohne schwerwiegende Unterbrechungen weiterläuft, auch wenn sich die externe IP-Adresse ändert.</p></div><div class=paragraph><p>Beachten Sie, dass dieser Regelsatz wahrscheinlich mehr Verkehr aus dem Netzwerk zulässt, als eigentlich nötig ist. Bei einem angemessenen Aufbau könnte folgendes Makro erstellt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>client_out = &#34;{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }&#34;</pre></div></div><div class=paragraph><p>Dieses Makro wird dann in der Filterregel benutzt:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</pre></div></div><div class=paragraph><p>Weitere <code>pass</code> Regeln werden vielleicht noch benötigt. Diese Regel aktiviert SSH auf der externen Schnittstelle:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in inet proto tcp to $ext_if port ssh</pre></div></div><div class=paragraph><p>Dieses Makrodefinition und Regel erlaubt DNS und NTP für interne Clients:</p></div><div class="literalblock programlisting"><div class=content><pre>udp_services = &#34;{ domain, ntp }&#34;
pass quick inet proto { tcp, udp } to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Beachten Sie das Schlüsselwort <code>quick</code> in dieser Regel. Da der Regelsatz aus mehreren Regeln besteht, ist es wichtig, die Beziehungen zwischen den einzelnen Regeln zu verstehen. Die Regeln werden von oben nach unten ausgewertet, in der Reihenfolge wie sie geschrieben sind. Für jedes Paket oder jede Verbindung, das PF ausgewertet, wird die letzte übereinstimmende Regel im Regelsatz angewendet. Wenn jedoch ein Paket auf eine Regel passt, welche das Schlüsselwort <code>quick</code> enthält, wird das Paket entsprechend dieser Regel behandelt und die Regelverarbeitung wird gestoppt. Diese Vorgehensweise ist sehr nützlich, wenn eine Ausnahme von den allgemeinen Regeln erforderlich ist.</p></div></div><div class=sect4><h5 id=pftut-ftp>53.3.2.2. Einen FTP-Proxy einrichten<a class=anchor href=#pftut-ftp></a></h5><div class=paragraph><p>Die Konfiguration einer funktionierenden Regel für FTP kann aufgrund der Beschaffenheit des FTP-Protokolls problematisch sein. FTP ist sehr viel älter als Firewalls und schon vom Design her unsicher. Die häufigsten Argumente gegen eine Verwendung von FTP sind:</p></div><div class=ulist><ul><li><p>Passwörter werden im Klartext übertragen.</p></li><li><p>Das Protokoll erfordert die Verwendung von mindestens zwei TCP-Verbindungen (Steuerung und Daten) auf separaten Ports.</p></li><li><p>Wenn eine Sitzung aufgebaut wird, werden die Daten auf zufällig ausgewählten Ports übermittelt.</p></li></ul></div><div class=paragraph><p>All diese Punkte stellen Herausforderungen dar, noch bevor die Client- oder Server-Software auf potenzielle Sicherheitslücken überprüft wurde. Es existieren aber auch sichere Alternativen für die Dateiübertragung, wie <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, wo die Authentifizierung und die Datenübertragung über eine verschlüsselte Verbindung erfolgt.</p></div><div class=paragraph><p>Für Situationen, in denen FTP erforderlich ist, kann PF den FTP-Datenverkehr an ein kleines Proxy-Programm namens <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a> weiterleiten. Dieses Programm ist im Basissystem von FreeBSD enthalten. Die Aufgabe des Proxies ist das dynamische Einfügen und Entfernen von Regeln im Regelsatz. Dies wird durch den Einsatz von Ankern erreicht, damit der FTP-Verkehr korrekt verarbeitet werden kann.</p></div><div class=paragraph><p>Fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> ein, um den Proxy zu aktivieren:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpproxy_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Danach kann der Proxy mit <code>service ftp-proxy start</code> gestartet werden.</p></div><div class=paragraph><p>Für die Grundkonfiguration müssen drei weitere Einträge in <span class=filename>/etc/pf.conf</span> hinzugefügt werden. Zunächst werden die Anker hinzugefügt, die der Proxy für die FTP-Sitzungen verwendet:</p></div><div class="literalblock programlisting"><div class=content><pre>nat-anchor &#34;ftp-proxy/*&#34;
rdr-anchor &#34;ftp-proxy/*&#34;</pre></div></div><div class=paragraph><p>Dann wird eine <code>pass</code>-Regel benötigt, damit der FTP-Datenverkehr durch den Proxy geleitet werden kann.</p></div><div class=paragraph><p>Die Regeln für Umleitung und NAT müssen vor den eigentlichen Filterregeln definiert werden. Fügen Sie diese <code>rdr</code>-Regel unmittelbar nach der NAT-Regel ein:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</pre></div></div><div class=paragraph><p>Zum Schluss muss der umgeleitete Verkehr die Firewall passieren dürfen:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out proto tcp from $proxy to any port ftp</pre></div></div><div class=paragraph><p><code>$poxy</code> enthält die Adresse, an dem der Proxy-Daemon gebunden ist.</p></div><div class=paragraph><p>Speichern Sie <span class=filename>/etc/pf.conf</span> und laden Sie die Regeln neu. Prüfen Sie von einem Client, ob die FTP-Verbindungen funktionieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Dieses Beispiel umfasst eine Grundkonfiguration, in der die Rechner im lokalen Netzwerk Zugriff auf entfernte FTP-Server benötigen. Diese Konfiguration sollte mit den meisten FTP-Clients und -Servern gut funktionieren. Das Verhalten von <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a> kann durch diverse Optionen in <code>ftpproxy_flags</code> beeinflusst werden. Einige Clients und Server haben bestimmte Marotten, die bei der Konfiguration berücksichtigt werden müssen. Es kann zum Beispiel notwendig sein, den FTP-Datenverkehr für den Proxy einer bestimmten Warteschlange zuzuweisen.</p></div><div class=paragraph><p>Es besteht auch die Möglichkeit einen FTP-Server mit PF und <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a> zu schützen. Konfigurieren Sie einen separaten <code>ftp-proxy</code> mit <code>-R</code> für den Reverse-Modus auf einem separaten Port und einer eigenen Umleitungsregel.</p></div></div><div class=sect4><h5 id=pftut-icmp>53.3.2.3. ICMP verwalten<a class=anchor href=#pftut-icmp></a></h5><div class=paragraph><p>Viele Werkzeuge zur Fehlerbehebung in TCP/IP-Netzwerken verlassen sich auf das Internet Control Message Protocol (ICMP), das speziell für diese Zwecke entwickelt wurde.</p></div><div class=paragraph><p>Das ICMP-Protokoll sendet und empfängt Kontrollnachrichten zwischen Rechnern und Gateways, hauptsächlich um ungewöhnliche Bedingungen auf dem Weg zum Zielrechner zu berichten. Router verwenden ICMP um Paketgrößen und andere Übertragungsparameter zu ermitteln. Dieser Prozess ist auch als <em>Path MTU Discovery</em> bekannt.</p></div><div class=paragraph><p>Aus der Sicht einer Firewall sind einige ICMP-Kontrollnachrichten anfällig für bekannte Angriffsmethoden. Zwar ist die Fehlerbehebung einfacher, wenn alle ICMP-Pakete bedingungslos durch gelassen werden, aber dass macht es auch für Angreifer leichter, Informationen über das Netzwerk zu extrahieren. Aus diesen Gründen ist die folgende Regel nicht optimal:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from any to any</pre></div></div><div class=paragraph><p>Eine Lösung besteht darin, nur den ICMP-Verkehr aus dem lokalen Netz zu akzeptieren, während ICMP-Pakete von außerhalb des Netzwerks verworfen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</pre></div></div><div class=paragraph><p>Es stehen noch weitere Optionen zur Verfügung, die die Flexibilität von PF demonstrieren. Anstatt beispielsweise alle ICMP-Nachrichten zu erlauben, kann man die Nachrichten angeben, die von <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> verwendet werden. Beginnen Sie damit, ein Makro für diese Art von Nachrichten zu definieren:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;echoreq&#34;</pre></div></div><div class=paragraph><p>Erstellen Sie dann eine Regel, die das eben erstellte Makro benutzt:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>Wenn weitere Arten von ICMP-Nachrichten benötigt werden, kann die Liste <code>icmp_types</code> einfach erweitert werden. Geben Sie <code>more /usr/src/sbin/pfctl/pfctl_parser.c</code> ein, um eine Liste der von PF unterstützten ICMP-Nachrichten zu sehen. Die Webseite <a href=http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml>http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</a> enthält eine Erklärung für jeden Nachrichtentyp.</p></div><div class=paragraph><p>Da UNIX® <code>traceroute</code> in der Voreinstellung UDP verwendet, wird eine weitere Regel benötigt:</p></div><div class="literalblock programlisting"><div class=content><pre># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</pre></div></div><div class=paragraph><p>Da <code>TRACERT.EXE</code> unter Microsoft® Windows®-Systemen ICMP Echo Request Meldungen verwendet, ist nur die erste Regel notwendig um Traces für solche Systeme zu ermöglichen. UNIX® <code>traceroute</code> kann aber auch andere Protokolle verwenden, zum Beispiel ICMP Echo Request, wenn der Schalter <code>-I</code> benutzt wird. Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div><div class=sect5><h6 id=pftut-pathmtudisc>53.3.2.3.1. Path MTU Discovery<a class=anchor href=#pftut-pathmtudisc></a></h6><div class=paragraph><p>Internet-Protokolle sind so ausgelegt, dass sie geräteunabhängig sind. Eine Folge davon ist, dass die optimale Paketgröße nicht immer zuverlässig vorhergesagt werden kann. Das größte Hindernis ist hier die <em>Maximum Transmission Unit</em> (<code>MTU</code>), welche die Obergrenze für die Paketgröße festlegt. Die MTU für die Schnittstelle des Systems können Sie sich mit <code>ifconfig</code> anzeigen lassen.</p></div><div class=paragraph><p>TCP/IP benutzt ein Verfahren, das als path MTU discovery bekannt ist, um die korrekte Paketgröße für eine Verbindung zu bestimmen. Dieses Verfahren sendet Pakete unterschiedlicher Größe mit dem Flag "do not fragment" und erwartet ein ICMP-Antwortpaket vom Typ "type 3, code 4", wenn die Obergrenze erreicht worden ist. Typ 3 bedeutet "Ziel nicht erreichbar" und Code 4 ist die Abkürzung für "Fragmentierung nötig, aber Do-not-Fragment Flag ist gesetzt". Um path MTU discovery zu erlauben und damit Verbindungen zu anderen MTUs zu unterstützen, fügen Sie dem Makro <code>icmp_types</code> den Typ <code>destination unreachable</code> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;{ echoreq, unreach }&#34;</pre></div></div><div class=paragraph><p>Da die <code>pass</code>-Regel bereits das Makro verwendet, braucht es nicht geändert werden um den neuen ICMP-Typ zu unterstützen:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>PF kann alle Variationen von ICMP-Typen und Codes filtern. Eine Liste der verfügbaren Typen und Codes ist in <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp&amp;sektion=4&amp;format=html">icmp(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp6&amp;sektion=4&amp;format=html">icmp6(4)</a> dokumentiert.</p></div></div></div><div class=sect4><h5 id=pftut-tables>53.3.2.4. Tabellen benutzen<a class=anchor href=#pftut-tables></a></h5><div class=paragraph><p>Manchmal sind bestimmte Daten für die Filterung und Weiterleitung interessant, jedoch wäre eine Definition einer solchen Filterregel für einen Regelsatz viel zu lang. PF unterstützt die Verwendung von Tabellen. Dies sind definierte Listen, die verändert werden können, ohne den gesamten Regelsatz neu laden zu müssen. Zudem können diese Listen sehr schnell durchsucht werden. Tabellennamen sind immer in <code>&lt; ></code> eingeschlossen und sehen wie folgt aus:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</pre></div></div><div class=paragraph><p>In diesem Beispiel ist das Netzwerk <code>192.168.2.0/24</code> Teil der Tabelle. <code>192.168.2.5</code> wurde im dem Operator <code>!</code> ausgeschlossen und ist somit nicht Teil der Tabelle. Es ist auch möglich Tabellen aus Dateien zu laden, wo jeder Eintrag in einer separaten Zeile steht. Dieses Beispiel verwendet dazu die Datei <span class=filename>/etc/clients</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.2.0/24
!192.168.2.5</pre></div></div><div class=paragraph><p>Um sich auf diese Datei zu beziehen, definieren Sie die Tabelle wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; persist file &#34;/etc/clients&#34;</pre></div></div><div class=paragraph><p>Sobald die Tabelle definiert ist, kann eine Filterregel Bezug darauf nehmen:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</pre></div></div><div class=paragraph><p>Die Inhalte einer Tabelle können mit <code>pfctl</code> direkt verändert werden. Dieses Beispiel fügt ein weiteres Netzwerk zur Tabelle hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T add 192.168.1.0/16</span></code></pre></div></div><div class=paragraph><p>Beachten Sie, dass auf diese Weise vorgenommene Änderungen direkt übernommen werden, jedoch bei einem Neustart des Systems oder bei einem Stromausfall verloren gehen. Um die Änderungen dauerhaft zu speichern, müssen sie in der Definition der Tabelle oder in der Datei, auf die sich die Tabelle bezieht, bearbeitet werden. Mit einem <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> Job und einem Befehl wie <code>pfctl -t clients -T show >/etc/clients</code> können Sie auch eine Kopie der Tabelle auf Platte speichern und dann in regelmäßigen Abständen aktualisieren. Alternativ kann <span class=filename>/etc/clients</span> auch mit den Tabelleneinträgen, die sich aktuell im Speicher befinden, aktualisiert werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T replace -f /etc/clients</span></code></pre></div></div></div><div class=sect4><h5 id=pftut-overload>53.3.2.5. Verwendung von Tabellen zum Schutz von SSH<a class=anchor href=#pftut-overload></a></h5><div class=paragraph><p>Benutzer, die SSH auf einer externen Schnittstelle ausführen, haben wahrscheinlich schon einmal ähnliche Meldungen in den Protokolldateien gesehen:</p></div><div class="literalblock programlisting"><div class=content><pre>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</pre></div></div><div class=paragraph><p>Diese Meldungen deuten auf einen Brute-Force-Angriff hin, bei dem ein Angreifer oder ein Programm versucht, den Benutzernamen und das Passwort zu erraten, um Zugriff auf das System zu bekommen.</p></div><div class=paragraph><p>Wenn der Zugriff über SSH für berechtigte Benutzer erforderlich ist, kann eine Änderung des Standard-Ports für SSH einen gewissen Schutz bieten. Allerdings bietet PF eine elegantere Lösung für dieses Problem. <code>pass</code>-Regeln können Einschränkungen für Dinge enthalten, die ein verbindender Rechner tun kann. Bei einem Verstoß gegen diese Einschränkungen kann dann dem betroffenen Rechner der Zugriff teilweise oder ganz entzogen werden. Es ist sogar möglich, alle bestehenden Verbindungen zu trennen, falls die Grenze überschritten wird.</p></div><div class=paragraph><p>Um dies zu konfigurieren, erstellen Sie folgende Tabelle im Regelsatz:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;bruteforce&gt; persist</pre></div></div><div class=paragraph><p>Fügen Sie dann ziemlich am Anfang der Filterregeln folgende Regeln hinzu, um die Brute-Force-Angriffe zu blocken und gleichzeitig berechtigte Verbindungen zu erlauben:</p></div><div class="literalblock programlisting"><div class=content><pre>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn 100, max-src-conn-rate 15/5, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class=paragraph><p>Der Teil in Klammern definiert die Grenzwerte. Die Zahlen sollten an die lokalen Anforderungen angepasst werden. Die Zeilen können wie folgt interpretiert werden:</p></div><div class=paragraph><p><code>max-src-conn</code> definiert die maximal erlaubte Anzahl gleichzeitiger Verbindungen von einem Rechner.</p></div><div class=paragraph><p><code>max-src-conn-rate</code> definiert die maximal erlaubte Anzahl neuer Verbindungen eines einzelnen Rechners (<em>15</em>) pro Anzahl von Sekunden (<em>5</em>).</p></div><div class=paragraph><p><code>overload &lt;bruteforce></code> bedeutet, dass jeder Rechner, der diesen Grenzwert überschreitet, zur Tabelle <code>bruteforce</code> hinzugefügt wird. Diese Filterregel blockiert jeglichen Datenverkehr von Adressen aus der Tabelle <code>bruteforce</code>.</p></div><div class=paragraph><p><code>flush global</code> besagt, dass alle (<code>global</code>) Verbindungen dieses Rechners getrennt (<code>flush</code>) werden, wenn der Grenzwert erreicht wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Diese Filterregeln helfen nicht bei langsamen Brute-Force-Angriffen, wie sie in <a href=http://home.nuug.no/~peter/hailmary2013/>http://home.nuug.no/~peter/hailmary2013/</a> beschrieben sind.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dieser Beispielregelsatz dient lediglich als Illustration. Wenn Sie allgemein eine große Anzahl an Verbindungen erlauben wollen, aber gleichzeitig bei SSH etwas restriktiver vorgehen möchten, können Sie die obige Regel ergänzen:</p></div><div class="literalblock programlisting"><div class=content><pre>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Es ist möglicherweise nicht notwendig, alle aggressiven Rechner zu blockieren</div><div class=paragraph><p>Es ist zu erwähnen, dass der <code>overlaod</code>-Mechanismus eine allgemeine Technik darstellt, die nicht auf SSH beschränkt ist. Außerdem ist es nicht immer optimal, Datenverkehr von aggressiven Rechnern zu blockieren.</p></div><div class=paragraph><p>Eine <code>overload</code>-Regel kann beispielsweise benutzt werden, um einen Mail- oder Webserver zu schützen. Die <code>overload</code>-Tabelle könnte dann in einer Regel verwendet werden, um aggressive Rechner einer Warteschlange mit geringerer Bandbreite zuzuweisen, oder den Rechner auf eine bestimtme Webseite umzuleiten.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Im Laufe der Zeit werden die Tabellen durch die <code>overload</code>-Regeln immer größer und belegen immer mehr Speicher. Manchmal wird eine geblockte IP-Adresse einem Rechner dynamisch zugewiesen, der eigentlich berechtigt ist, mit den Rechnern im lokalen Netzwerk zu kommunizieren.</p></div><div class=paragraph><p>Für solche Situationen bietet <code>pfctl</code> die Möglichkeit, Tabelleneinträge auslaufen zu lassen. Dieses Kommando würde beispielsweise Einträge aus der Tabelle <code>&lt;bruteforce></code> löschen, die seit <code>86400</code> Sekunden nicht mehr referenziert wurden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t bruteforce -T expire 86400</span></code></pre></div></div><div class=paragraph><p>Eine ähnliche Funktionalität bietet <a class=package href=https://cgit.freebsd.org/ports/tree/security/expiretable/>security/expiretable</a>, welches Einträge entfernt, die für einen bestimmten Zeitraum nicht referenziert wurden.</p></div><div class=paragraph><p>Nach der Installation kann expiretable benutzt werden, um Einträge aus der Tabelle <code>&lt;bruteforce></code> nach einer bestimmten Zeit zu entfernen. Dieses Beispiel entfernt alle Einträge, die älter sind als 24 Stunden:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</pre></div></div></div><div class=sect4><h5 id=pftut-spamd>53.3.2.6. Schutz vor SPAM<a class=anchor href=#pftut-spamd></a></h5><div class=paragraph><p>Im Gegensatz zum spamd-Daemon von spamassassin, kann <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> zusammen mit PF den SPAM direkt an der Firewall abwehren. Dieser spamd wird in PF über einen Satz von Umleitungen konfiguriert.</p></div><div class=paragraph><p>Spammer neigen dazu, eine große Anzahl von Nachrichten zu versenden. Dabei nutzten Sie SPAM-freundliche Netzwerke und gekaperte Rechner, welche dann ziemlich schnell bei sogenannten Blacklists gemeldet werden.</p></div><div class=paragraph><p>Wenn eine SMTP-Verbindung von einer Adresse in der Blacklist empfangen wird, präsentiert spamd einen Banner und schaltet sofort in einen Modus, in dem die Antworten auf den SMTP-Verkehr jeweils ein Byte groß sind. Diese Technik, die möglichst viel Zeit des Spammers verschwenden soll, wird Tarpitting genannt. Die spezifische Implementierung, welche ein Byte SMTP-Antworten verwendet, wird als Stuttering bezeichnet.</p></div><div class=paragraph><p>Dieses Beispiel zeigt das grundlegende Verfahren zur Konfiguration von spamd mit automatisch aktualisierten Blacklists. Für weitere Informationen lesen die Manualpages, die zusammen mit <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> installiert werden.</p></div><div class="sidebarblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Konfiguration von spamd</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Installieren Sie das Paket oder den Port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a>. Um spamd’s Greylisting-Funktion zu nutzen, muss <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> in <span class=filename>/dev/fd</span> eingehängt werden. Fügen Sie folgende Zeile in <span class=filename>/etc/fstab</span> ein:</p><div class="literalblock programlisting"><div class=content><pre>fdescfs /dev/fd fdescfs rw 0 0</pre></div></div><div class=paragraph><p>Danach hängen Sie das Dateisystem ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount fdescfs</span></code></pre></div></div></li><li><p>Fügen Sie folgende Zeilen in den PF-Regelsatz ein:</p><div class="literalblock programlisting"><div class=content><pre>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</pre></div></div><div class=paragraph><p>Die beiden Tabellen <code>&lt;spamd></code> und <code>&lt;spam-white></code> sind von großer Bedeutung. SMTP-Verkehr von einer Adresse, die in <code>&lt;spamd></code> aber nicht in <code>&lt;spamd-white></code> ist, wird an den spamd-Daemon auf Port 8025 umgeleitet.</p></div></li><li><p>Im nächsten Schritt wird spamd in <span class=filename>/usr/local/etc/spamd.conf</span> konfiguriert und einige Parameter werden in <span class=filename>/etc/rc.conf</span> hinzugefügt.</p><div class=paragraph><p>Die Installation von <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> enthält eine Beispielkonfiguration (<span class=filename>/usr/local/etc/spamd.conf.sample</span>) und eine Manualpage für <span class=filename>spamd.conf</span>. Beziehen Sie sich für zusätzliche Konfigurationsoptionen auf diese Dokumentation.</p></div><div class=paragraph><p>Die Konfigurationsdatei enthält einen Block, in dem die <code>all</code>-Liste definiert ist, die wiederum weitere Listen spezifiziert:</p></div><div class="literalblock programlisting"><div class=content><pre>all:\
    :traplist:whitelist:</pre></div></div><div class=paragraph><p>Dieser Eintrag fügt die gewünschten Blacklists, getrennt durch einen Doppelpunkt (<code>:</code>), hinzu. Um auch eine Whitelist zu verwenden, fügen Sie den Namen unmittelbar hinter dem Namen der Blacklist ein. Zum Beispiel: <code>:Blacklist:Whitelist:</code>.</p></div><div class=paragraph><p>Danach folgt die Definition der verwendeten Blacklist:</p></div><div class="literalblock programlisting"><div class=content><pre>traplist:\
    :black:\
    :msg=&#34;SPAM. Your address %A has sent spam within the last 24 hours&#34;:\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</pre></div></div><div class=paragraph><p>In der ersten Zeile steht der Name der Blacklist und die zweite Zeile gibt den Typ an. Das Feld <code>msg</code> enthält die Nachricht, die dem Absender während des SMTP-Dialogs angezeigt wird. Das Feld <code>mehtod</code> legt fest, wie spamd-setup die Listen bezieht; unterstützte Methoden sind <code>http</code>, <code>ftp</code>, <code>file</code> und ein externes Programm via <code>exec</code>. Im letzten Feld gibt <code>file</code> den Namen der Datei an, die spamd erwartet.</p></div><div class=paragraph><p>Die Definition der Whitelist ist ähnlich. Das Feld <code>msg</code> wird jedoch nicht definiert, da eine Meldung hier nicht erforderlich ist:</p></div><div class="literalblock programlisting"><div class=content><pre>whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</pre></div></div></li></ol></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>Wählen Sie die Datenquellen mit Sorgfalt</div><div class=paragraph><p>Bei der Verwendung von sämtlichen Blacklists aus der Beispieldatei <span class=filename>spamd.conf</span> würden große Teile des Internets geblockt. Der Administrator muss diese Datei bearbeiten, um eine optimale Konfiguration zu erzielen. Dazu gehört auch die Auswahl von geeigneten Blacklists und, wenn nötig, die Erstellung von benutzerdefinierten Listen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Als nächstes fügen Sie folgenden Eintrag in <span class=filename>/etc/rc.conf</span> hinzu. Zusätzliche Optionen sind in der Manualpage beschrieben:</p></div><div class="literalblock programlisting"><div class=content><pre>spamd_flags=&#34;-v&#34; # use &#34;&#34; and see spamd-setup(8) for flags</pre></div></div><div class=paragraph><p>Wenn Sie fertig sind, starten Sie spamd durch die Eingabe von <code>service obspamd start</code>. Führen Sie die weitere Konfiguration mit <code>spamd-setup</code> durch. Erstellen Sie zum Schluss einen <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>-Job, der <code>spamd-setup</code> in regelmäßigen Abständen aufruft, um die Listen zu aktualisieren.</p></div></div></div><div class=paragraph><p>Auf einem typischen Gateway vor dem Mailserver, werden Rechner innerhalb von wenigen Minuten geblockt.</p></div><div class=paragraph><p>PF unterstützt auch <em>Greylisting</em>, das Nachrichten von unbekannten Rechnern vorübergehend mit <em>45n</em>-Codes ablehnt. Nachrichten von diesen Rechnern werden bei einem erneuten Versuch nach einer angemessenen Zeit durchgelassen. Nachrichten von Rechnern, die nach RFC 1123 und RFC 2821 konfiguriert sind, werden sofort durchgelassen.</p></div><div class=paragraph><p>Weitere Informationen über Greylisting finden Sie unter <a href=http://www.greylisting.org/>greylisting.org</a>. Das Erstaunlichste an Greylisting ist, neben der einfachen Benutzung, dass es immer noch funktioniert. Spammer und Malware-Autoren gelingt es bislang nur schwer, diese Technik zu umgehen.</p></div><div class=paragraph><p>Die grundsätzliche Vorgehensweise zur Konfiguration von Greylisting ist wie folgt:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Konfiguration von Greylisting</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Stellen Sie sicher, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> eingehängt ist. Dies wird in Schritt 1 der vorherigen Prozedur beschrieben.</p></li><li><p>Um spamd im Greylisting-Modus auszuführen, fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> ein:</p><div class="literalblock programlisting"><div class=content><pre>spamd_grey=&#34;YES&#34;  # use spamd greylisting if YES</pre></div></div><div class=paragraph><p>Lesen Sie die Manualpage von spamd für Beschreibungen von zusätzlichen Parametern.</p></div></li><li><p>Starten Sie die Dienste, um die Konfiguration von Greylisting abzuschließen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service obspamd restart</span>
<span class=c># service spamlogd start</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Hinter den Kulissen führen die spamdb-Datenbank und spamlogd wesentliche Aufgaben der Greylisting-Funktion aus. spamdb ist die Schnittstelle für den Administrator, der über den Inhalt der Datenbank <span class=filename>/var/db/spamdb</span> Blaklists, Whitelists und Greylists verwaltet.</p></div></div><div class=sect4><h5 id=pftut-hygiene>53.3.2.7. Netzwerk-Hygiene<a class=anchor href=#pftut-hygiene></a></h5><div class=paragraph><p>Dieser Abschnitt beschreibt die Verwendung von <code>block-policy</code>, <code>scrub</code> und <code>antispoof</code>, mit denen das Verhalten des Regelsatzes weiter optimiert werden kann.</p></div><div class=paragraph><p>Die Option <code>block-policy</code> kann im Teil <code>options</code> des Regelwerks konfiguriert werden, vor den Umleitungen und den eigentlichen Filterregeln. Diese Option legt fest, welche Rückmeldung PF an einen geblockten Rechner sendet. Es existieren zwei mögliche Werte: <code>drop</code> verwirft das Paket ohne Rückmeldung und <code>return</code> gibt eine Statusmeldung, wie etwa <code>Connection refused</code> zurück.</p></div><div class=paragraph><p>Die Voreinstellung ist <code>drop</code>. Geben Sie den gewünschten Wert ein, um die <code>block-policy</code>-Richtlinie zu ändern:</p></div><div class="literalblock programlisting"><div class=content><pre>set block-policy return</pre></div></div><div class=paragraph><p><code>scrub</code> ist ein Schlüsselwort in PF, das die Paket-Normalisierung aktiviert. Dieser Prozess fügt fragmentierte Pakete wieder zusammen und blockt TCP-Pakete mit ungültigen Flag-Kombinationen. Ein aktiviertes <code>scrub</code> bietet einen gewissen Schutz gegen Angriffe, die auf die falsche Handhabung von fragmentierten Paketen aufbauen. Es stehen viele Optionen zur Verfügung, jedoch sollte die einfachste Form für die meisten Konfigurationen ausreichend sein:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all</pre></div></div><div class=paragraph><p>Einige Dienste, wie beispielsweise NFS, erfordern eine bestimmte Handhabung von fragmentierten Paketen. Weitere Informationen finden Sie unter <a href=https://home.nuug.no/~peter/pf/en/scrub.html>https://home.nuug.no/~peter/pf/en/scrub.html</a>.</p></div><div class=paragraph><p>Dieses Beispiel fügt fragmentierte Pakete wieder zusammen, löscht das "do not fragment"-Bit und setzt die maximale Segmentgröße auf 1440 Bytes:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all fragment reassemble no-df max-mss 1440</pre></div></div><div class=paragraph><p>Der <code>antispoof</code>-Mechanismus bietet einen Schutz gegen gefälschte IP-Adressen. Dabei werden hauptsächlich Pakete verworfen, die auf der falschen Schnittstellen ankommen.</p></div><div class=paragraph><p>Folgende Regeln verwerfen gefälschte Adressen, wenn sie aus dem Internet oder dem lokalen Netzwerk stammen:</p></div><div class="literalblock programlisting"><div class=content><pre>antispoof for $ext_if
antispoof for $int_if</pre></div></div></div><div class=sect4><h5 id=pftut-unrouteables>53.3.2.8. Handhabung von nicht-routebaren Adressen<a class=anchor href=#pftut-unrouteables></a></h5><div class=paragraph><p>Sogar bei einem richtig konfigurierten NAT-Gateway müssen Sie vielleicht die Fehlkonfiguration anderer Personen ausgleichen. Ein typischer Fehler besteht darin, nicht-routebare Adressen ins Internet zu lassen. Da der Verkehr von nicht-routebaren Adressen Teil eines DoS-Angriffs sein kann, sollten Sie in Betracht ziehen, diesen Verkehr explizit an der externen Schnittstelle des Netzwerks zu blockieren.</p></div><div class=paragraph><p>In diesem Beispiel wird ein Makro erstellt, das die nicht-routebaren Adressen enthält. Datenverkehr von und zu diesen Adressen wird dann an der externen Schnittstelle des Gateways verworfen.</p></div><div class="literalblock programlisting"><div class=content><pre>martians = &#34;{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }&#34;

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</pre></div></div></div></div><div class=sect3><h4 id=_altq_aktivieren>53.3.3. ALTQ aktivieren<a class=anchor href=#_altq_aktivieren></a></h4><div class=paragraph><p>Unter FreeBSD kann ALTQ zusammen mit PF benutzt werden, um Quality of Service (QoS) bereitzustellen. Sobald ALTQ aktiviert ist, können Warteschlangen definiert werden, mit denen Sie die Priorität für ausgehende Pakete festlegen können.</p></div><div class=paragraph><p>Bevor Sie ALTQ aktivieren, sollten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> lesen und sicherstellen, das der Treiber der Netzwerkkarte diese Funktion unterstützt.</p></div><div class=paragraph><p>ALTQ steht nicht als ladbares Kernelmodul zur Verfügung. Wenn die Netzwerkkarte des Systems ALTQ unterstützt, erstellen Sie nach den Anweisungen in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> einen angepassten Kernel. Als erstes muss ALTQ aktiviert werden. Zudem ist mindestens eine weitere Option nötig, um den Algorithmus für die Warteschlange zu bestimmen:</p></div><div class="literalblock programlisting"><div class=content><pre>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Schedule (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</pre></div></div><div class=paragraph><p>Die folgenden Algorithmen stehen zur Verfügung:</p></div><div class=dlist><dl><dt class=hdlist1>CBQ</dt><dd><p>Class Based Queuing (CBQ) erlaubt es, die Bandbreite einer Verbindung in verschiedene Klassen oder Warteschlangen zu unterteilen, um die Priorität von Datenpaketen basierend auf Filterregeln zu beeinflussen.</p></dd><dt class=hdlist1>RED</dt><dd><p>Random Early Detection (RED) wird eingesetzt, um eine Überlastung des Netzwerks zu vermeiden. Dazu ermittelt RED die Größe der Warteschlange und vergleicht diesen Wert mit den minimalen und maximalen Grenzwerten der Warteschlange. Ist die Warteschlange größer als das erlaubte Maximum, werden alle neuen Pakete nach dem Zufallsprinzip verworfen.</p></dd><dt class=hdlist1>RIO</dt><dd><p>Random Early Detection In and Out (RIO). Dieser Modus verwaltet mehrere Warteschlangen durchschnittlicher Größe mit mehreren Schwellwerten, eine für jedes QoS-Level.</p></dd><dt class=hdlist1>HFSC</dt><dd><p>Hierachical Fair Service Curve Packet Scheduler (HFSC) wird in <a href=http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html>http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</a> beschrieben.</p></dd><dt class=hdlist1>PRIQ</dt><dd><p>Priority Queuing (PRIQ) lässt den Verkehr einer Warteschlange mit höherer Priorität zuerst durch.</p></dd></dl></div><div class=paragraph><p>Weitere Informationen über diese Algorithmen und Beispiele für Regelsätze finden Sie in den <a href=https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html>OpenBSD Archiven</a>.</p></div></div></div><div class=sect2><h3 id=firewalls-ipfw>53.4. IPFW<a class=anchor href=#firewalls-ipfw></a></h3><div class=paragraph><p>IPFW ist eine Stateful-Firewall für FreeBSD, die sowohl IPv4 als auch IPv6 unterstützt. Die Firewall setzt sich aus mehreren Komponenten zusammen: dem Kernel Firewall Filter-Prozessor mit integriertem Paket-Accounting, Protokollfunktionen, NAT, dem <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> Traffic-Shaper, sowie Weiterleitungs-, Bridge- und ipstealth-Funktionen.</p></div><div class=paragraph><p>FreeBSD enthält mit <span class=filename>/etc/rc.firewall</span> ein Beispielregelwerk, welches mehrere Firewall-Typen für gebräuchliche Szenarien definiert und unerfahrene Anwender dabei unterstützen soll, ein geeignetes Regelwerk zu erstellen. IPFW besitzt eine leistungsstarke Syntax, mit der erfahrene Benutzer ihre eigenen Regeln anfertigen können, um den Sicherheitsanforderungen der jeweiligen Umgebung gerecht zu werden.</p></div><div class=paragraph><p>Diser Abschnitt beschreibt, wie IPFW aktiviert wird und bietet einen Überblick über die Regelsyntax. Zudem werden mehrere Regelsätze für gebräuchliche Konfigurationsszenarien vorgestellt.</p></div><div class=sect3><h4 id=firewalls-ipfw-enable>53.4.1. IPFW aktivieren<a class=anchor href=#firewalls-ipfw-enable></a></h4><div class=paragraph><p>Das FreeBSD Basissystem enthält für IPFW ein ladbares Kernelmodul, was bedeutet, dass kein angepasster Kernel benötigt wird, um IPFW zu benutzen.</p></div><div class=paragraph><p>Wenn Sie eine statische Unterstützung für IPFW in den Kernel kompilieren wollen, lesen Sie <a href=#firewalls-ipfw-kernelconfig>IPFW Kerneloptionen</a>.</p></div><div class=paragraph><p>Um IPFW beim Systemstart zu aktivieren, fügen Sie <code>firewall_enable="YES"</code> in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_enable=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Wenn Sie einen der von FreeBSD zur Verfügung gestellten Firewall-Profile benutzen möchten, fügen Sie eine weitere Zeile hinzu, in der Sie das Profil bestimmen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_type=&#34;open&#34;</span></code></pre></div></div><div class=paragraph><p>Folgende Profile stehen zur Verfügung:</p></div><div class=ulist><ul><li><p><code>open</code>: gestattet jeglichen Datenverkehr.</p></li><li><p><code>client</code>: schützt lediglich diesen Rechner.</p></li><li><p><code>simple</code>: schützt das gesamte Netzwerk.</p></li><li><p><code>closed</code>: blockiert den gesamten IP-Datenverkehr, mit Ausnahme des Verkehrs über die Loopback-Schnittstelle.</p></li><li><p><code>workstation</code>: schützt lediglich diesen Rechner und verwendet zustandsorientierte Regeln.</p></li><li><p><code>UNKNOWN</code>: deaktiviert das Laden von Firewallregeln.</p></li><li><p><span class=filename>filename</span>: absoluter Pfad zu einer Datei, in der die Firewallregeln definiert sind.</p></li></ul></div><div class=paragraph><p>Wenn Sie <code>firewall_type</code> auf <code>client</code> oder <code>simple</code> setzen, müssen Sie die voreingestellten Regeln in <span class=filename>/etc/rc.firewall</span> anpassen, damit sie der Konfiguration des Systems entsprechen.</p></div><div class=paragraph><p>Beachten Sie, dass das Profil <code>filename</code> verwendet wird, um ein benutzerdefiniertes Regelwerk zu laden.</p></div><div class=paragraph><p>Eine alternative Möglichkeit, um ein benutzerdefiniertes Regelwerk zu laden, bietet die Variable <code>firewall_script</code>. Setzen Sie die Variable auf den absoluten Pfad eines <em>ausführbaren Skripts</em>, welches die Befehle für IPFW enthält. Die Beispiele in diesem Abschnitt gehen davon aus, dass <code>firewall_script</code> auf <span class=filename>/etc/ipfw.rules</span> gesetzt ist.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_script=&#34;/etc/ipfw.rules&#34;</span></code></pre></div></div><div class=paragraph><p>Die Protokollierung wird mit diesem Befehl aktiviert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logging=&#34;YES&#34;</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Es werden nur Firewallregeln mit der Option <code>log</code> protokolliert. Die voreingestellten Regeln enthalten diese Option nicht und müssen manuell hinzugefügt werden. Daher ist es ratsam, diese Regeln zu bearbeiten. Außerdemkann eine Rotation der Protokolle erwünscht sein, wenn die Protokolle in einer separaten Datei gespeichert werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Es existiert keine Variable für <span class=filename>/etc/rc.conf</span>, um die Protokollierung zu begrenzen. Um die Anzahl der Protokoll-Nachrichten pro Verbindungsversuch zu begrenzen, legen Sie die Anzahl der Einträge in <span class=filename>/etc/sysctl.conf</span> fest:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;net.inet.ip.fw.verbose_limit=5&#34; &gt;&gt; /etc/sysctl.conf</span></code></pre></div></div><div class=paragraph><p>Um die Protokollierung über die spezielle Schnittstelle <code>ipfw0</code> zu aktivieren, fügen Sie stattdessen folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logif=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie dann tcpdump, um zu sehen, was protokolliert wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tcpdump -t -n -i ipfw0</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Durch die Protokollierung entsteht kein Aufwand, es sei denn, tcpdump wird an die Schnittstelle angebunden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nachdem Sie die Änderungen vorgenommen haben, können Sie die Firewall starten. Um auch die Anzahl der Protokoll-Nachrichten zu konfigurieren, setzen Sie mit <code>sysctl</code> den gewünschten Wert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service firewall start</span>
<span class=c># sysctl net.inet.ip.fw.verbose_limit=5</span></code></pre></div></div></div><div class=sect3><h4 id=firewalls-ipfw-rules>53.4.2. IPFW Regel-Syntax<a class=anchor href=#firewalls-ipfw-rules></a></h4><div class=paragraph><p>Wenn ein Paket die Firewall "betritt", also von der Firewall geprüft und verarbeitet wird, wird die erste Regel des Regelwerkes auf das Paket angewandt. Auf diese Weise wird in aufsteigender Reihenfolge der Regelnummer mit allen weiteren Regeln verfahren. Falls die Selektionsparameter einer Regel auf ein Paket zutreffen, wird das Aktionsfeld der Regel ausgeführt und die Prüfung des Pakets beendet, nachfolgende Regeln werden also nicht mehr geprüft. Diese Suchmethode wird als "erster Treffer gewinnt" bezeichnet. Falls keine Regel auf das betreffende Paket zutrifft, wird die obligatorische IPFW-Rückfallregel mit der Nummer 65535 angewendet und das Paket wird ohne Rückantwort verworfen. Wenn das Paket jedoch einer Regel mit dem Schlüsselwort <code>count</code>, <code>skipto</code> oder <code>tee</code> entspricht, wird die Prüfung des Pakets weiter fortgeführt. Weitere Details darüber, wie diese Schlüsselwörter die Regelverarbeitung beeinflussen, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div><div class=paragraph><p>Bei der Erstellung der IPFW-Regeln müssen die Schlüsselwörter in der folgenden Reihenfolge geschrieben werden. Einige Schlüsselwörter müssen zwingend angegeben werden, während andere optional sind. Die Wörter in Großbuchstaben repräsentieren Variablen und die Wörter in Kleinbuchstaben müssen den Variablen vorangestellt werden. Das Zeichen <code>#</code> wird benutzt, um einen Kommentar einzuleiten und kann am Ende einer Regel oder in einer eigenen Zeile stehen. Leerzeilen werden ignoriert.</p></div><div class=paragraph><p><code><em>CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT OPTIONS</em></code></p></div><div class=paragraph><p>Dieser Abschnitt bietet einen Überblick über diese Schlüsselwörter und deren Optionen. Es ist keine vollständige Liste aller verfügbaren Optionen. Eine vollständige Beschreibung der Regel-Syntax, die Sie verwenden können um IPFW-Regeln zu erstellen, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div><div class=dlist><dl><dt class=hdlist1>CMD</dt><dd><p>Jede Regel muss mit <span class=parameter>ipfw add</span> beginnen.</p></dd><dt class=hdlist1>RULE_NUMBER</dt><dd><p>Jede Regel gehört zu einer Nummer zwischen <code>1</code> und <code>65534</code>. Die Nummer wird verwendet, um die Reihenfolge der Regelverarbeitung zu kennzeichnen. Es ist möglich, dass mehrere Regeln dieselbe Nummer haben. In diesem Fall werden sie entsprechend der Reihenfolge angewendet, in der sie aufgenommen wurden.</p></dd><dt class=hdlist1>SET_NUMBER</dt><dd><p>Jede Regel ist einer <em>Set</em>-Nummer zwischen <code>0</code> und <code>31</code> zugeordnet. Sets können einzeln aktiviert oder deaktiviert werden. Dies macht es möglich, eine Reihe von Regeln schnell hinzuzufügen oder zu löschen. Wenn <code>SET_NUMBER</code> nicht angegeben ist, wird die Regel zu Set <code>0</code> hinzugefügt.</p></dd><dt class=hdlist1>ACTION</dt><dd><p>Eine Regel kann mit einer der folgenden Aktionen verknüpft werden. Die festgelegte Aktion wird ausgeführt, wenn das Paket den Selektionskriterien der Regel entspricht.</p><div class=paragraph><p><span class=parameter>allow | accept | pass | permit</span>: All diese Aktionen sind gleichbedeutend und erlauben Pakete, die mit der Regel übereinstimmen.</p></div><div class=paragraph><p><span class=parameter>check-state</span>: Diese Aktion überprüft die Regel in der dynamischen Zustandstabelle. Bei einer Übereinstimmung wird die mit der dynamischen Regel verknüpfte Aktion ausgeführt, andernfalls wird mit der Prüfung gegen die nächste Regel fortgefahren. Die Regel <code>check-state</code> hat selbst kein Selektionskriterium. Sollte keine <code>check-state</code>-Regel im Regelwerk vorhanden sein, wird die dynamische Zustandstabelle beim ersten Vorkommen einer <code>keep-state</code>- oder <code>limit</code>-Regel überprüft.</p></div><div class=paragraph><p><span class=parameter>count</span>: Aktualisiert die Zähler für alle Pakete, die mit dieser Regel übereinstimmen. Die Prüfung wird mit der nächsten Regel fortgesetzt.</p></div><div class=paragraph><p><span class=parameter>deny | drop</span>: Diese Aktionen sind gleichbedeutend und verwerfen Pakete, die mit dieser Regel übereinstimmen.</p></div><div class=paragraph><p>Es stehen noch weitere Aktionen zur Verfügung. Einzelheiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div></dd><dt class=hdlist1>LOG_AMOUNT</dt><dd><p>Erfüllt ein Paket die Selektionskriterien mit dem Schlüsselwort <code>log</code>, wird dies von <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> mit der Annotation <code>SECURITY</code> protokolliert. Dies erfolgt allerdings nur, wenn die Anzahl der protokollierten Pakete der betreffenden Regel die definierte <code>LOG_AMOUNT</code>-Grenze nicht übersteigt. Wenn <code>LOG_AMOUNT</code> nicht definiert ist, wird die Grenze aus dem Wert von <code>net.inet.ip.fw.verbose_limit</code> benutzt. Ein Wert von <code>0</code> bedeutet eine unbegrenzte Protokollierung. Wird eine definierte Grenze erreicht, wird die Protokollierung für diese Regel deaktiviert. Um die Protokollierung zu reaktivieren, können Sie den Protokoll- oder Paketzähler mit <code>ipfw resetlog</code> zurücksetzen.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Protokollierung findet statt, nachdem alle Selektionskriterien geprüft und bevor die endgültige Aktion auf das Paket angewendet wird. Der Administrator entscheidet, welche Regel protokolliert werden soll.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>PROTO</dt><dd><p>Dieser optionale Wert wird verwendet, um einen beliebigen Protokollnamen oder -nummer aus <span class=filename>/etc/protocols</span> gegen das Paket zu prüfen.</p></dd><dt class=hdlist1>SRC</dt><dd><p>Nach dem Schlüsslwort <code>from</code> muss die Quelladresse stehen, oder ein Schlüsselwort, das die Quelladresse darstellt. Eine Adresse wird dargestellt duch <code>any</code>, <code>me</code> (jede Adresse dieses Systems), <code>me6</code> (jede IPv6-Adresse dieses Systems), oder <code>table</code> gefolgt von der Nummer der Tabelle, welche die Adressen enthält. IP-Adressen können in CIDR-Notation geschrieben werden. Beispielsweise <code>1.2.3.4/25</code> oder <code>1.2.3.4:255.255.255.128</code>.</p></dd><dt class=hdlist1>SRC_PORT</dt><dd><p>Optional kann ein Quellport über eine Nummer oder einen Namen aus <span class=filename>/etc/services</span> spezifiziert werden.</p></dd><dt class=hdlist1>DST</dt><dd><p>Nach dem Schlüsselwort <code>to</code> muss die Zieladresse stehen, oder ein Schlüsselwort, das die Zieladresse darstellt. Es können die gleichen Schlüsselwörter und Adressen benutzt werden, die bereits im SRC-Abschnitt beschrieben wurden.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>Optional kann ein Zielport über eine Nummer oder einen Namen aus <span class=filename>/etc/services</span> spezifiziert werden.</p></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Nach der Quell- und Zieladresse können noch weitere Optionen angegeben werden. Wie der Name bereits sagt, sind <code>OPTIONS</code> optional. Häufig verwendete Optionen sind <code>in</code> oder <code>out</code>, mit denen die Richtug des Pakets bestimmt wird, <code>icmptypes</code> gefolgt vom Typ der ICMP-Nachricht, sowie <code>keep-state</code>.</p><div class=paragraph><p>Wenn ein Paket auf eine <span class=parameter>keep-state</span>-Regel zutrifft, wird die Firewall eine dynamische Regel erstellen, die dem bidirektionalen Datenverkehr zwischen den gleichen Quell- und Zieladressen mit dem gleichen Protokoll entspricht.</p></div><div class=paragraph><p>Dynamische Regeln sind für einen sogenannten SYN-flood-Angriff anfällig, bei dem eine riesige Anzahl an dynamischen Regeln erzeugt wird. Verwenden Sie die Option <code>limit</code>, um einen solchen Angriff entgegenzuwirken. Diese Option begrenzt die Anzahl der gleichzeitig möglichen Sitzungen. Es handelt sich dabei um einen Zähler, der die Anzahl von dynamischen Regeln in Kombination mit der Quelladresse verfolgt. Übersteigt der Zähler den durch <code>limit</code> definierten Wert, wird das Paket verworfen.</p></div><div class=paragraph><p>Es stehen noch viele weitere Optionen zur Verfügung. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> enthält eine Beschreibung der einzelnen Optionen.</p></div></dd></dl></div></div><div class=sect3><h4 id=_beispiel_für_einen_regelsatz>53.4.3. Beispiel für einen Regelsatz<a class=anchor href=#_beispiel_für_einen_regelsatz></a></h4><div class=paragraph><p>Dieser Abschnitt die Erstellung eines Firewall-Skripts namens <span class=filename>/etc/ipfw.rules</span> mit zustandsorientierten (stateful Regeln. Alle Regeln in diesem Beispiel verwenden die Optionen <code>in</code> und <code>out</code>, um die Richtung des Pakets zu verdeutlichen. Zusätzlich wird <code>via</code> <em>interface-name</em> benutzt, um die Schnittstelle für das Paket zu prüfen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bei den anfänglichen Tests mit dem Firewall-Regelsatz sollten Sie vielleicht folgende Einstellung vornehmen:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.ip.fw.default_to_accept=&#34;1&#34;</pre></div></div><div class=paragraph><p>Dies legt die Standardregel von <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> etwas großzügiger fest, als das voreingestellte <code>default deny ip from any to any</code>. Dadurch sinkt die Gefahr, sich nach einem Neustart des Systems auszusperren.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Das Firewall-Skript beginnt mit einem Hinweis, dass es sich um ein Bourne Shell-Skript handelt. Danach werden alle vorhandenen Filterregeln gelöscht. Anschließend wird die Variable <code>cmd</code> erstellt, sodass <code>ipfw add</code> nicht jedes mal von Hand eingegeben werden muss. Die Variable <code>pif</code> repräsentiert die mit dem Internet verbundene Schnittstelle.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd=&#34;ipfw -q add&#34;
pif=&#34;dc0&#34;     # interface name of NIC attached to Internet</pre></div></div><div class=paragraph><p>Jetzt folgen die eigentlichen Filterregeln. Diese ersten beiden Regeln erlauben den Datenverkehr aus dem internen Netzwerk und über die Loopback-Schnittstelle:</p></div><div class="literalblock programlisting"><div class=content><pre># Change xl0 to LAN NIC interface name
$cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
$cmd 00010 allow all from any to any via lo0</pre></div></div><div class=paragraph><p>Die nächste Regel erlaubt Pakete, für die ein Eintrag in der dynamischen Zustandstabelle existiert:</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 00101 check-state</pre></div></div><div class=paragraph><p>Die nächsten Regeln definieren, welche internen Rechner Verbindungen zu anderen Rechnern im Internet aufbauen dürfen. Hier werden wieder zustandsorientierte Regeln verwendet:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

# Allow access to ISP&#39;s DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
$cmd 00120 allow log udp from any to any 67 out via $pif keep-state
#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

# Allow outbound HTTP and HTTPS connections
$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state
$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

# Allow outbound email connections
$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

# Allow outbound ping
$cmd 00250 allow icmp from any to any out via $pif keep-state

# Allow outbound NTP
$cmd 00260 allow udp from any to any 123 out via $pif keep-state

# Allow outbound SSH
$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

# deny and log all other outbound connections
$cmd 00299 deny log all from any to any out via $pif</pre></div></div><div class=paragraph><p>Die folgenden Regeln steuern die Verbindungen von Rechern aus dem Internet ins interne Netzwerk. Zuerst werden Pakete verworfen, die typischerweise im Zusammenhang mit Angriffen stehen. Danach werden bestimmte Arten von Verbindungen erlaubt. Alle Dienste aus dem öffentlichen Internet beinhalten die Option <code>limit</code>, um Flooding zu unterbinden.</p></div><div class="literalblock programlisting"><div class=content><pre># Deny all inbound traffic from non-routable reserved address spaces
$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP
$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP
$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP
$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback
$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config
$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect
$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D &amp; E multicast

# Deny public pings$
$cmd 00310 deny icmp from any to any in via $pif$
$
# Deny ident$
$cmd 00315 deny tcp from any to any 113 in via $pif$
$
# Deny all Netbios services.$
$cmd 00320 deny tcp from any to any 137 in via $pif$
$cmd 00321 deny tcp from any to any 138 in via $pif$
$cmd 00322 deny tcp from any to any 139 in via $pif$
$cmd 00323 deny tcp from any to any 81 in via $pif$

# Deny fragments
$cmd 00330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 00332 deny tcp from any to any established in via $pif

# Allow traffic from ISP&#39;s DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

# Allow HTTP connections to internal web server
$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow inbound SSH connections
$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Reject and log all other incoming connections
$cmd 00499 deny log all from any to any in via $pif</pre></div></div><div class=paragraph><p>Die letzte Regel protokolliert alle Pakete, die mit keiner Regel im Regelsatz übereinstimmen:</p></div><div class="literalblock programlisting"><div class=content><pre># Everything else is denied and logged
$cmd 00999 deny log all from any to any</pre></div></div></div><div class=sect3><h4 id=in-kernel-nat>53.4.4. In-Kernel NAT<a class=anchor href=#in-kernel-nat></a></h4><div class=paragraph><p>Die IPFW-Firewall von FreeBSD hat zwei NAT-Implementierungen: die Userland-Implementierung <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> und die neuere, kernelinterne NAT-Implementierung. Beide arbeiten in Verbindung mit IPFW, um die Übersetzung von Netzwerkadressen zu ermöglichen. Damit kann eine Lösung zur gemeinsamen Nutzung der Internetverbindung bereitgestellt werden, so dass mehrere interne Rechner unter Verwendung einer einzigen öffentlichen IP-Adresse eine Verbindung zum Internet herstellen können.</p></div><div class=paragraph><p>Um dies zu tun, muss der mit dem Internet verbundene FreeBSD-Rechner als Gateway eingerichtet sein. Das System muss über zwei Netzwerkschnittstellen verfügen, wobei eine Schnittstelle mit dem Internet verbunden ist und die andere mit dem internen Netzwerk. Jeder Rechner im internen Netzwerk sollte eine <a href=https://www.ietf.org/rfc/rfc1918.txt>RFC 1918</a> konforme Adresse zugewiesen bekommen.</p></div><div class=paragraph><p>Es ist noch ein wenig Konfiguration nötig, um die In-Kernel NAT-Funktion von IPFW zu aktivieren. Um die In-Kernel NAT-Unterstützung beim Booten zu aktivieren, müssen folgende Einträge in <span class=filename>/etc/rc.conf</span> vorhanden sein:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
firewall_enable=&#34;YES&#34;
firewall_nat_enable=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn <code>firewall_nat_enable</code> gesetzt ist, <code>firewall_enable</code> jedoch nicht, hat dies keine Auswirkung, da die NAT-Implementierung im Kernel nur mit IPFW kompatibel ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn der Regelsatz zustandsorientierte Regeln enthält, ist die Position der NAT-Regel kritisch und die <code>skipto</code>-Aktion wird benutzt. Die Aktion <code>skipto</code> benötigt eine Regelnummer, damit IPFW weiß, zu welcher Regel es springen muss. Das folgende Beispiel baut auf den im vorherigen Abschnitt gezeigten Firewall-Relgelsatz auf. Es werden einige neue Einträge hinzugefügt und bestehende Regeln modifiziert, um In-Kernel NAT zu konfigurieren. Zunächst werden einige Variablen hinzugefügt, darunter Regelnummern, die <code>keep-state</code>-Option und eine Liste mit TCP-Ports um die Anzahl der Regeln zu reduzieren:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ipfw -q -f flush
cmd=&#34;ipfw -q add&#34;
skip=&#34;skipto 1000&#34;
pif=dc0
ks=&#34;keep-state&#34;
good_tcpo=&#34;22,25,37,53,80,443,110&#34;</pre></div></div><div class=paragraph><p>Bei In-Kernel NAT muss aufgrund der Architektur von <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a>, einer Bibliothek, die als Kernel-Modul implementiert ist, um die In-Kernel NAT-Funktion für IPFW bereitzustellen, TCP segment offloading (TSO) deaktiviert werden. TSO kann pro Netzwerkschnittstelle mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, oder systemweit mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> deaktiviert werden. Um TSO systemweit zu deaktivieren, muss folgende Zeile in <span class=filename>/etc/sysctl.conf</span> enthalten sein:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.tcp.tso=&#34;0&#34;</pre></div></div><div class=paragraph><p>Danach wird eine NAT-Instanz konfiguriert. Mit In-Kernel NAT ist es möglich, mehrere NAT-Instanzen mit jeweils eigener Konfiguration zu betreiben. In diesem Beispiel wird jedoch nur eine NAT-Instanz mit der Nummer 1 benötigt. Die Konfiguration kann ein paar Optionen enthalten, zum Beispiel: <code>if</code>, dass die öffentliche Netzwerkschnittstelle angibt, <code>same_ports</code>, das dafür sorgt, dass Alias-Ports und lokale Portnummern identisch zugeordnet werden, <code>unreg_only</code> führt dazu, dass nur unregistrierte (private) Adressräume von der NAT-Instanz verarbeitet werden, und <code>reset</code>, was dazu beiträgt, dass eine NAT-Instanz auch dann erhalten bleibt, wenn sich die öffentliche IP-Adresse des Rechners ändert. Weitere mögliche Optionen, die an einzelne NAT-Instanzen übergeben werden können, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Wenn eine zustandsorientierte NAT-Firewall konfiguriert wird, ist es notwendig, dass übersetzte Pakete zur weiteren Verarbeitung in die Firewall eingespielt werden können, was durch die Deaktivierung des <code>one_pass</code>-Verhaltens beim Start des Firewall-Skripts erreicht werden kann.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw disable one_pass
ipfw -q nat 1 config if $pif same_ports unreg_only reset</pre></div></div><div class=paragraph><p>Die NAT-Regel für eingehende Pakete wird <em>nach</em> den beiden Regeln, die das interne Netzwerk und die Loopback-Schnittstelle erlauben, und nach der Reassamble-Regel, aber <em>vor</em> der <code>check-state</code>-Regel eingefügt. Es ist wichtig, dass die Nummer der NAT-Regel (in diesem Beispiel <code>100</code>) höher ist, als die drei vorherigen Regeln und niedriger, als die <code>check-state</code>-Regel. Darüber hinaus wird aufgrund des Verhaltens von In-Kernel NAT empfohlen, eine Reassamble-Regel kurz vor der ersten NAT-Regel, aber hinter den Regeln zu platzieren, die den Datenverkehr auf einer vertrauenswürdigen Schnittstelle erlauben. In der Regel sollte es nicht zu einer Fragmentierung kommen, aber bei getunnelten IPSEC/ESP/GRE-Verkehr kann es vorkommen, und das Zusammensetzen von Fragmenten ist notwendig, bevor das komplette Paket an das In-Kernel NAT übergeben werden kann.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Reassamble-Regel wird beim Userland <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> nicht benötigt, da die Aktion <code>divert</code> von IPFW dies bereits automatisch übernimmt, bevor das Paket an den Socket ausgeliefert wird. Dies ist auch in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> dokumentiert.</p></div><div class=paragraph><p>Beachten Sie, dass die aktuelle NAT-Instanznummer und NAT-Regelnummer in diesem Beispiel nicht mit der voreingestellten NAT-Instanznummer und Regelnummer übereinstimmt, wenn sie mit dem <span class=filename>rc.firewall</span>-Skript von FreeBSD erstellt wurde.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>$cmd 005 allow all from any to any via xl0  # exclude LAN traffic
$cmd 010 allow all from any to any via lo0  # exclude loopback traffic
$cmd 099 reass all from any to any in       # reassemble inbound packets
$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
$cmd 101 check-state</pre></div></div><div class=paragraph><p>Die Regeln für den ausgehenden Verkehr werden ebenfalls modifiziert, um Aktionen mit der <code>$skipto</code>-Variable zu erlauben und anzuzeigen, dass die Prüfung mit der Regel <code>1000</code> fortgesetzt wird. Die sieben Regeln für TCP wurden durch die Regel <code>125</code> ersetzt, da die sieben erlaubten ausgehenden Ports in der Variable <code>$good_tcp0</code> enthalten sind.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Beachten Sie, dass die Leistung von IPFW weitgehend von der Anzahl der im Regelsatz vorhandenen Regeln bestimmt wird.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># Authorized outbound packets
$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks
$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks
$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
$cmd 130 $skip icmp from any to any out via $pif $ks</pre></div></div><div class=paragraph><p>Die eingehenden Regeln bleiben unverändert, mit Ausnahme der letzten Regel, in der das <code>via $pif</code> entfernt wird, um ein- und ausgehende Pakete prüfen zu können. Nach der letzten Regel für ausgehende Pakete muss die NAT-Regel folgen. Die Regel muss eine höhere Nummer als die letzte Regel haben und die Nummer muss über die <code>skipto</code>-Aktion referenziert werden. In diesem Regelsatz leitet die Regel mit der Nummer <code>1000</code> alle ausgehenden Pakete zur konfigurierten NAT-Instanz weiter. Die darauf folgende Regel lässt alle von NAT verarbeiteten Pakete passieren.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 999 deny log all from any to any
$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules
$cmd 1001 allow ip from any to any</pre></div></div><div class=paragraph><p>In diesem Beispiel steuern die Regeln <code>100</code>, <code>101</code>, <code>125</code>, <code>1000</code> und <code>1001</code> die Adressübersetzung der ein- und ausgehende Pakete, so dass immer die private LANIP-Adresse in der dynamische Zustandstabelle registriert werden.</p></div><div class=paragraph><p>Nehmen wir beispielsweise einen Web-Browser, der neue HTTP-Sitzungen über Port 80 aufbaut. Wenn nun das erste ausgehende Paket von der Firewall geprüft wird, trifft es nicht auf Regel <code>100</code> zu, da das Paket nach außen geleitet wird und nicht nach innen. Das Paket trifft auch nicht auf Regel <code>101</code> zu, da es das erste ist und somit noch nicht in der dynamischen Zustandstabelle enthalten ist. Das Paket entspricht schließlich Regel <code>125</code>, da es ausgehend auf einem erlaubten Port gesendet wird und von einer IP-Adresse aus dem internen LAN stammt. Für Pakete, die auf diese Regel zutreffen, werden zwei Aktionen ausgeführt. Zuerst wird durch die Aktion <code>keep-state</code> ein dynamischer Eintrag in der Statustabelle erstellt und die angegebene Aktion <code>skipto 1000</code> ausgeführt. Als nächstes durchläuft das Paket NAT und wird dann an das Internet gesendet. Nachdem dieses Paket am Webserver angekommen ist, wird dort eine Antwort erzeugt und zurückgeschickt. Dieses Paket wird wieder von oben nach unten durch das Regelwerk geprüft. Dieses Mal trifft Regel <code>100</code> auf das Paket zu und die Zieladresse wird auf die zugehörige (lokale) LAN-Adresse abgebildet. Danach wird das Paket von der Regel <code>check-state</code> verarbeitet. Die Zustandstabelle erkennt, dass eine zugehörige aktive Sitzung vorliegt und das Paket wird freigegeben und in das LAN geleitet.</p></div><div class=paragraph><p>Für den eingehenden Datenverkehr muss der Regelsatz unerwünschte Pakete blockieren und Pakete für autorisierte Dienste durchlassen. Ein Paket, das mit einer Regel für den eingehenden Datenverkehr übereinstimmt, wird in der dynamischen Zustandstabelle eingetragen und dann an das LAN freigegeben. Das Antwortpaket wird von der Regel <code>check-state</code> als Paket einer aktiven Sitzung erkannt. Das Paket wird dann von Regel <code>1000</code> per NAT verarbeitet, bevor es über die externe Schnittstelle verschickt wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Der Wechsel vom Userland <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> zu In-Kernel NAT mag zunächst nahtlos erscheinen, aber es gibt einen kleinen Haken. Bei Verwendung des <span class=filename>GENERIC</span>-Kernels wird IPFW das Kernelmodul <span class=filename>libalias.ko</span> laden, wenn <code>firewall_nat_enable</code> in <span class=filename>rc.conf</span> aktiviert ist. Das Kernelmodul <span class=filename>libalias.ko</span> stellt nur grundlegende NAT-Funktionalität bereit, während die Userland-Implementierung <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> alle Funktionalitäten ohne zusätzliche Konfiguration zur Verfügung stellt. Die gesamte Funktionalität bezieht sich auf die folgenden Kernelmodule, die bei Bedarf zusätzlich zu <span class=filename>libalias.ko</span> geladen werden können: <span class=filename>alias_cuseeme.ko</span>, <span class=filename>alias_ftp.ko</span>, <span class=filename>alias_bbt.ko</span>, <span class=filename>skinny.ko</span>, <span class=filename>irc.ko</span>, <span class=filename>alias_pptp.ko</span> und <span class=filename>alias_smedia.ko</span> unter Verwendung der <code>kld_list</code> Direktive in <span class=filename>rc.conf</span>. Wenn ein angepasster Kernel benutzt wird, kann die volle Funktionalität der Userland-Bibliothek im Kernel mit <code>options LIBALIAS</code> gebaut werden.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_weiterleitung_von_ports>53.4.4.1. Weiterleitung von Ports<a class=anchor href=#_weiterleitung_von_ports></a></h5><div class=paragraph><p>Der Nachteil von NAT ist, dass die Rechner im LAN nicht aus dem Internet zugänglich sind. Diese Rechner können zwar ausgehende Verbindungen zur Außenwelt aufbauen, jedoch keine eingehenden Verbindungen empfangen. Dies stellt ein Problem dar, wenn Sie auf einem Rechner im LAN Dienste anbieten möchten, die aus dem Internet erreichbar sein sollen. In diesem Fall können Sie die Ports, welche über das Internet erreichbar sein sollen, über die NAT-Maschine an den Rechner im LAN weiterleiten.</p></div><div class=paragraph><p>Angenommen es gibt einen IRC-Server auf Rechner <code>A</code> und einen Webserver auf Rechner <code>B</code>. Damit dies funktioniert, müssen die Verbindungen auf den Ports 6667 (IRC) und 80 (HTTP) an die jeweiligen Rechner weitergeleitet werden.</p></div><div class=paragraph><p>Bei In-Kernel NAT wird die gesamte Konfiguration in der NAT-Instanz selbst vorgenommen. Alle Optionen, die in einer NAT-Instanz benutzt werden können, sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> dokumentiert. Die Syntax für IPFW folgt dabei der von natd. Die Syntax für <code>-redirect_port</code> lautet:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port proto targetIP:targetPORT[-targetPORT]
  [aliasIP:]aliasPORT[-aliasPORT]
  [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>Für das obige Beispiel sollten die Argumente wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Nachdem diese Argumente der Konfiguration der NAT-Instanz 1 im obigen Regelsatz hinzugefügt wurden, werden die TCP-Ports an die Rechner im LAN weitergeleitet, auf denen IRC- und HTTP-Dienste laufen.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw -q nat 1 config if $pif same_ports unreg_only reset \
  redirect_port tcp 192.168.0.2:6667 6667 \
  redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Portbereiche können über <code>redirect_port</code> festgelegt werden. Zum Beispiel würde <em>tcp 192.168.0.2:2000-3000 2000-3000</em> alle Verbindungen auf die Ports 2000 bis 3000 an die Ports 2000 bis 3000 an Rechner <code>A</code> weiterleiten.</p></div></div><div class=sect4><h5 id=_weiterleiten_von_adressen>53.4.4.2. Weiterleiten von Adressen<a class=anchor href=#_weiterleiten_von_adressen></a></h5><div class=paragraph><p>Das Weiterleiten von Adressen ist nützlich, wenn mehr als eine IP-Adresse zur Verfügung steht. Jeder Rechner im LAN kann über <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> seine eigene externe IP-Adresse zugewiesen bekommen. IPFW wird dann den ausgehenden Datenverkehr der Rechner aus dem LAN mit der entsprechenden externen IP-Adresse umschreiben. Auch der eingehenden Datenverkehr über die externe IP-Adresse wird an die entsprechenden Rechner im LAN weitergeleitet. Diese Methode ist auch als statisches NAT bekannt. Wenn Ihnen beispielsweise die IP-Adressen <code>128.1.1.1</code>, <code>128.1.1.2</code> und <code>128.1.1.3</code> zur Verfügung stehen, kann <code>128.1.1.1</code> als externe Adresse der <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>-Maschine verwendet werden, während <code>128.1.1.2</code> und <code>128.1.1.3</code> an Rechner <code>A</code> und Rechner <code>B</code> im LAN weitergeleitet werden.</p></div><div class=paragraph><p>Die Syntax für <code>redirect_address</code> lautet wie im Folgenden, wobei <code>localIP</code> die interne IP-Adresse des Rechners im LAN, und <code>publicIP</code> die externe IP-Adresse ist, die dem Rechner im LAN entspricht.</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address localIP publicIP</pre></div></div><div class=paragraph><p>Auf das Beispiel bezogen, würden die Argumente so lauten:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address 192.168.0.2 128.1.1.2
redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p>Genau wie bei <code>redirect_port</code>, werden diese Argumente in der Konfiguration der NAT-Instanz gesetzt. Bei der Weiterleitung von Adressen ist keine Portumleitung notwendig, da alle Daten, die auf einer bestimmten IP-Adresse empfangen werden, weitergeleitet werden.</p></div><div class=paragraph><p>Die externe IP-Adresse der <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>-Maschine muss auf der externen Schnittstelle aktiv und mit einem Alias versehen sein. Weitere Einzelheiten sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>; beschrieben.</p></div></div><div class=sect4><h5 id=_userland_nat>53.4.4.3. Userland NAT<a class=anchor href=#_userland_nat></a></h5><div class=paragraph><p>Zunächst sei gesagt, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, die Userland-Implementierung aufwändiger ist als In-Kernel NAT. Damit <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> Pakete übersetzen kann, müssen die Pakete vom Kernel ins Userland und zurück kopiert werden, was zusätzlichen Aufwand mit sich bringt. Dieser Aufwand entfällt bei In-Kernel NAT.</p></div><div class=paragraph><p>Um den Userland NAT-Daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> beim Systemstart zu aktivieren, ist etwas Konfiguration in <span class=filename>/etc/rc.conf</span> nötig. <code>natd_interface</code> wird auf den Namen der mit dem Internet verbundenen Schnittstelle gesetzt. Das <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-Skript von <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> wird selbstständig prüfen, ob eine dynamische IP-Adresse benutzt wird und sich selbst so konfigurieren, dass es damit umgehen kann.</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
natd_enable=&#34;YES&#34;
natd_interface=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>Generell kann der obige Regelsatz, wie er für In-Kernel NAT erklärt wurde, auch zusammen mit <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> benutzt werden. Die Ausnahmen sind die Konfiguration der In-Kernel NAT-Instanz <code>(ipfw -q nat 1 config …​)</code>, die nicht zusammen mit der Regel 99 benötigt wird, da die <code>divert</code>-Aktion sich um die Fragmentierung kümmert. Die Regeln 100 und 1000 müssen leicht modifiziert werden, wie unten gezeigt.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 100 divert natd ip from any to any in via $pif
$cmd 1000 divert natd ip from any to any out via $pif</pre></div></div><div class=paragraph><p>Um eine Port- oder Adressumleitung zu konfigurieren, wird eine ähnliche Syntax wie bei In-Kernel NAT verwendet. Anstatt die Konfiguration in unserem Regelsatz-Skript wie bei In-Kernel NAT anzugeben, wird die Konfiguration von <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> am besten in einer Konfigurationsdatei vorgenommen. Dazu muss eine zusätzliche Option in <span class=filename>/etc/rc.conf</span> übergeben werden, welche den Pfad zur Konfigurationsdatei angibt.</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Konfigurationsdatei muss eine Liste von Optionen enthalten, eine pro Zeile. Weitere Informationen über die Konfigurationsdatei und mögliche Variablen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>. Hier zwei Beispieleinträge, einer pro Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_address 192.168.0.3 128.1.1.3</pre></div></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=firewalls-ipfw-cmd>53.4.5. Das IPFW Kommando<a class=anchor href=#firewalls-ipfw-cmd></a></h4><div class=paragraph><p><code>ipfw</code> kann benutzt werden, um einzelne Regeln im laufenden Betrieb hinzuzufügen oder zu entfernen. Problematisch ist jedoch, dass diese Änderungen bei einem Neustart des Systems verloren gehen. Daher ist es empfehlenswert, eigene Regeln in einer Datei zu definieren und diese zu laden, um die Regeln der Firewall im laufenden Betrieb anzupassen.</p></div><div class=paragraph><p><code>ipfw</code> ist auch hilfreich, um die geladenen Regeln der auf der Konsole auszugeben. IPFW erzeugt dynamisch einen Zähler, der jedes Paket, auf das eine Regel zutrifft, zählt. Dadurch ist es möglich, die Funktion einer Regel zu überprüfen.</p></div><div class=paragraph><p>Eine Auflistung aller geladenen Regeln erhalten Sie mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw list</span></code></pre></div></div><div class=paragraph><p>Eine Auflistung aller Regeln inklusive des letzten Treffers erhalten Sie mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -t list</span></code></pre></div></div><div class=paragraph><p>Das nächste Beispiel zeigt Informationen über die Anzahl der Pakete, die von einer Regel gefiltert wurden sowie die Regel selbst. Der erste Spalte zeigt die Nummer der Regel, gefolgt von der Anzahl der gefilterten Pakete und der Anzahl der Pakete in Bytes. Zum Schluss steht die Regel selbst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -a list</span></code></pre></div></div><div class=paragraph><p>Das folgende Kommando zeigt zusätzlich alle dynamischen Regeln an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d list</span></code></pre></div></div><div class=paragraph><p>Um diese Auflistung um die "abgelaufenen" Regeln zu erweitern, geben Sie folgendes Kommando ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d -e list</span></code></pre></div></div><div class=paragraph><p>Hiermit werden alle Zähler auf Null zurückgesetzt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero</span></code></pre></div></div><div class=paragraph><p>Es ist auch möglich, einen spezifischen Zähler zurückzusetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero NUM</span></code></pre></div></div><div class=sect4><h5 id=_protokollierung_von_firewall_nachrichten>53.4.5.1. Protokollierung von Firewall-Nachrichten<a class=anchor href=#_protokollierung_von_firewall_nachrichten></a></h5><div class=paragraph><p>Auch bei aktivierter Protokollierung wird IPFW von selbst keine Regeln protokollieren. Der Administrator muss entscheiden, welche Regeln aus dem Regelwerk protokolliert werden sollen. In diesen Regeln muss dann das Schlüsselwort <code>log</code> hinzugefügt werden. Normalerweise werden nur geblockte Pakete protokolliert. Es ist üblich, die "ipfw default deny everything"-Regel am Ende des Regelwerks mit dem Schlüsselwort <code>log</code> zu duplizieren. Dadurch ist es möglich, alle Pakete zu sehen, auf die keine Regel zutraf.</p></div><div class=paragraph><p>Protokollierung ist allerdings ein zweischneidiges Schwert. Bei mangelnder Vorsicht oder einem DoS-Angriff wird die Festplatte mit einer enormen Flut von Protokolldaten belastet. Protokoll-Nachrichten werden nicht nur an <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> geschickt, sondern auch auf der Konsole angezeigt, was dann schnell lästig werden kann.</p></div><div class=paragraph><p>Die Kerneloption <code>IPFIREWALL_VERBOSE_LIMIT=5</code> begrenzt die Anzahl identischer Nachrichten an <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> für eine gegebene Regel auf fünf Nachrichten. Ist diese Option im Kernel aktiviert, wird nach Erreichen den festgelegten Anzahl die Protokollierung von aufeinanderfolgenden Nachrichten auf den festgelegten Wert begrenzt, da beispielsweise die Speicherung von 200 gleichen Protokoll-Nachrichten sinnlos ist. Daher werden durch diese Option nur fünf gleichartige Nachrichten protokolliert. Alle weiteren Nachrichten werden nur gezählt und deren Gesamtzahl wird schließlich von <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> wie folgt ausgegeben:</p></div><div class="literalblock programlisting"><div class=content><pre>Last message repeated 45 times</pre></div></div><div class=paragraph><p>Alle protokollierten Pakete werden in der Voreinstellung in <span class=filename>/var/log/security</span> gespeichert. Dies wird in <span class=filename>/etc/syslog.conf</span> definiert.</p></div></div><div class=sect4><h5 id=firewalls-ipfw-rules-script>53.4.5.2. Ein Firewall-Regelwerk erstellen<a class=anchor href=#firewalls-ipfw-rules-script></a></h5><div class=paragraph><p>Die meisten fortgeschrittenen IPFW-Benutzer erzeugen eine Datei, welche die Regeln für die Firewall enthält, um diese als Skript ausführen zu können. Der Vorteil einer derartigen Konfiguration besteht darin, dass dadurch mehrere Regeln gleichzeitig geändert und aktiviert werden können, ohne dass dazu das System neu gestartet werden muss. Dies ist zudem beim Testen von Regeländerungen sehr hilfreich. Weil es sich bei der Datei um ein Skript handelt, ist es auch möglich, häufig verwendete Befehle durch Aliase zu ersetzen und diese dann in mehreren Regeln zu nutzen.</p></div><div class=paragraph><p>Die Syntax des folgenden Skripts entspricht der Syntax von <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>. Felder, die symbolisch substituiert werden, haben das Präfix $ (Dollarzeichen). Symbolische Felder haben das $-Präfix nicht. Der Wert, mit dem das symbolische Feld belegt wird, muss in doppelten Anführungszeichen ("") stehen.</p></div><div class=paragraph><p>Die Datei mit den Regeln könnte wie folgt aufgebaut sein:</p></div><div class="literalblock programlisting"><div class=content><pre>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif=&#34;tun0&#34;             # out interface
odns=&#34;192.0.2.11&#34;      # ISP&#39;s DNS server IP address
cmd=&#34;ipfw -q add &#34;     # build rule prefix
ks=&#34;keep-state&#34;        # just too lazy to key this each time
$cmd 00500 check-state
$cmd 00502 deny all from any to any frag
$cmd 00501 deny tcp from any to any established
$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
$cmd 00611 allow udp from any to $odns 53 out via $oif $ks
################### End of example ipfw rules script ############</pre></div></div><div class=paragraph><p>Die Regeln in diesem Beispiel sind nicht wichtig. Wichtig ist es, zu zeigen, wie die symbolische Substitution innerhalb der Regeln verwendet wird.</p></div><div class=paragraph><p>Wenn dieses Beispiel in <span class=filename>etc/ipfw.rules</span> gespeichert wurde, so könnten alle Regeln durch die Ausführung des folgenden Kommandos neu geladen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/ipfw.rules</span></code></pre></div></div><div class=paragraph><p>Anstelle von <span class=filename>/etc/ipfw.rules</span> kann ein beliebig anderer Name oder Speicherort verwendet werden.</p></div><div class=paragraph><p>Alternativ können die einzelnen Befehle dieses Skripts auch von Hand eingegeben werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -q -f flush</span>
<span class=c># ipfw -q add check-state</span>
<span class=c># ipfw -q add deny all from any to any frag</span>
<span class=c># ipfw -q add deny tcp from any to any established</span>
<span class=c># ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</span></code></pre></div></div></div></div><div class=sect3><h4 id=firewalls-ipfw-kernelconfig>53.4.6. IPFW Kerneloptionen<a class=anchor href=#firewalls-ipfw-kernelconfig></a></h4><div class=paragraph><p>Um die Unterstützung für IPFW statisch in den Kernel zu kompilieren, lesen Sie die Anweisungen in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a>. Die folgenden Optionen können in der Kernelkonfigurationsdatei verwendet werden:</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword to syslogd(8)
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT	# sets default policy to pass what is not explicitly denied
options    IPFIREWALL_NAT		# enables basic in-kernel NAT support
options    LIBALIAS			# enables full in-kernel NAT support
options    IPFIREWALL_NAT64		# enables in-kernel NAT64 support
options    IPFIREWALL_NPTV6		# enables in-kernel IPv6 NPT support
options    IPFIREWALL_PMOD		# enables protocols modification module support
options    IPDIVERT			# enables NAT through natd(8)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>IPFW kann auch als Kernelmodul geladen werden: Die oben genannten Optionen werden standardmäßig als Module erstellt, oder können zur Laufzeit über Parameter festgelegt werden.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=firewalls-ipf>53.5. IPFILTER (IPF)<a class=anchor href=#firewalls-ipf></a></h3><div class=paragraph><p>IPFILTER, auch als IPF bekannt, ist eine plattformübergreifende Open Source Firewall, die auf mehrere Betriebssysteme portiert wurde, einschließlich FreeBSD, NetBSD, OpenBSD und Solaris™.</p></div><div class=paragraph><p>IPFILTER basiert auf einer kernelseitigen Firewall und einem NAT-Mechanismus, der durch Anwenderprogramme gesteuert und überwacht werden kann. Firewallregeln werden mit ipf gesetzt oder gelöscht. Für die Manipulation der NAT-Regeln wird ipnat benutzt. Mit ipfstat werden Laufzeitstatistiken der kernelseitigen Anteile von IPFILTER aufgelistet. Mit ipmon können die Aktionen von IPFILTER in Protokolldateien gespeichert werden.</p></div><div class=paragraph><p>IPF wurde ursprünglich mit der Verarbeitungslogik "die letzte passende Regel gewinnt" geschrieben und verwendete ausschließlich Regeln ohne feste Zustände. Inzwischen wurde IPF modernisiert und unterstützt nun auch die Optionen <code>quick</code> und <code>keep state</code>.</p></div><div class=paragraph><p>Antworten auf häufige Fragen finden Sie unter <a href=http://www.phildev.net/ipf/index.html>http://www.phildev.net/ipf/index.html</a>. Ein Archiv der IPFILTER Mailingliste steht unter <a href="http://marc.info/?l=ipfilter">http://marc.info/?l=ipfilter</a> zur Verfügung.</p></div><div class=paragraph><p>Dieser Abschnitt des Handbuchs konzentriert sich auf IPF unter FreeBSD. Es werden auch Firewallregeln mit den Optionen <code>quick</code> und <code>keep state</code> vorgestellt.</p></div><div class=sect3><h4 id=_ipf_aktivieren>53.5.1. IPF aktivieren<a class=anchor href=#_ipf_aktivieren></a></h4><div class=paragraph><p>IPF ist in FreeBSD als ladbares Kernelmodul enthalten. Das bedeutet, dass Sie keinen angepassten Kernel erzeugen müssen um IPF zu aktivieren.</p></div><div class=paragraph><p>Benutzer, die IPF lieber statisch in den Kernel kompilieren, sollten den Anweisungen in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> folgen. Die folgenden Kerneloptionen stehen zur Verfügung:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</pre></div></div><div class=paragraph><p><code>options IPFILTER</code> aktiviert die Unterstützung für IPFILTER. <code>options IPFILTER_LOG</code> aktiviert die Protokollierung über die Pseudo-Schnittstelle <span class=filename>ipl</span> für Firewallrelgen, die das Schlüsselwort <code>log</code> enthalten. <code>IPFILTER_LOOKUP</code> aktiviert IP-Pools, um die Suche nach IP-Adressen zu beschleunigen. <code>IPFILTER_DEFAULT_BLOCK</code> ändert das Verhalten der Firewall dahingehend, dass jedes Paket, das nicht explizit von einer <code>pass</code>-Regel Zugang erhält, geblockt wird.</p></div><div class=paragraph><p>Um IPF während des Bootens zu aktivieren, müssen folgende Einträge in <span class=filename>/etc/rc.conf</span> hinzugefügt werden. Diese Einträge aktivieren ebenfalls die Protokollierung und die Regel <code>default pass all</code>. Um diese Voreinstellung zu ändern, ohne einen neuen Kernel zu übersetzen, müssen Sie am Ende der Firewallregeln eine <code>block all</code> Regel hinzufügen.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfilter_enable=&#34;YES&#34;             # Start ipf firewall
ipfilter_rules=&#34;/etc/ipf.rules&#34;   # loads rules definition text file
ipv6_ipfilter_rules=&#34;/etc/ipf6.rules&#34; # loads rules definition text file for IPv6
ipmon_enable=&#34;YES&#34;                # Start IP monitor log
ipmon_flags=&#34;-Ds&#34;                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>Wenn die NAT-Funktionalität benötigt wird, müssen auch diese Zeilen hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;              # Enable as LAN gateway
ipnat_enable=&#34;YES&#34;                # Start ipnat function
ipnat_rules=&#34;/etc/ipnat.rules&#34;    # rules definition file for ipnat</pre></div></div><div class=paragraph><p>Jetzt können Sie IPF starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ipfilter start</span></code></pre></div></div><div class=paragraph><p>Um die Firewallregeln zu laden, übergeben Sie den Namen des Regelwerks an <code>ipf</code>. Mit dem folgenden Kommando ersetzen Sie alle aktuell geladenen Regeln:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipf -Fa -f /etc/ipf.rules</span></code></pre></div></div><div class=paragraph><p><code>-Fa</code> löscht zunächst alle internen Regeln und mit <code>-f</code> wird die Datei angegeben, welche die zu ladenen Regeln enthält.</p></div><div class=paragraph><p>Damit haben Sie die Möglichkeit, Änderungen an der laufenden Firewall zu machen, ohne dass das System neu gestartet werden muss. Da dieser Vorgang beliebig oft wiederholt werden kann, ist es ein sehr bequemer Weg neue Regeln zu testen.</p></div><div class=paragraph><p>Diese und weitere Optionen sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> beschrieben.</p></div></div><div class=sect3><h4 id=_ipf_regel_syntax>53.5.2. IPF Regel-Syntax<a class=anchor href=#_ipf_regel_syntax></a></h4><div class=paragraph><p>Mit der hier beschriebenen Regel-Syntax können zustandsorientierte Regeln erstellt werden. Beim Erstellen von Regeln ist zu beachten, dass Regeln ohne das Schlüsselwort <code>quick</code> der Reihe nach geprüft werden und "die letzte zutreffende Regel" angewendet wird. Das bedeutet, dass selbst dann, wenn die erste zutreffende Regel eine <code>pass</code>-Regel ist, das Paket dennoch geblockt wird, falls später eine <code>block</code>-Regel zutrifft. Beispielregelsätze finden Sie in <span class=filename>/usr/shared/examples/ipfilter</span>.</p></div><div class=paragraph><p>Beim Erstellen von Regeln wird das Zeichen <code>#</code> verwendet, um einen Kommentar bis zum Ende der Zeile einzuleiten. Leere Zeilen werden ignoriert.</p></div><div class=paragraph><p>Die Schlüsselwörter, die in den Regeln verwendet werden, müssen in einer bestimmten Reihenfolge geschrieben werden, von links nach rechts. Einige Schlüsselwörter sind verbindlich, andere sind optional. Einige Schlüsselwörter haben Unteroptionen, die wiederum selbst Schlüsselwörter sind und ebenfalls weitere Unteroptionen einschließen können. Die Reihenfolge der Schlüsselwörter ist wie folgt, wobei die Wörter in Großbuchstaben eine Variable darstellen und die Wörter in Kleinbuchstaben der Variable vorangestellt werden müssen:</p></div><div class=paragraph><p><code><em>ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT TCP_FLAG|ICMP_TYPE keep state STATE</em></code></p></div><div class=paragraph><p>Dieser Abschnitt beschreibt jedes dieser Schlüsselwörter und ihre Optionen. Es ist jedoch keine vollständige Liste aller möglichen Optionen. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> enthält eine vollständige Beschreibung der Syntax und einige Beispiele zur Erstellung von IPF-Regeln.</p></div><div class=dlist><dl><dt class=hdlist1>ACTION</dt><dd><p>Dieses Schlüsselwort bestimmt, was mit dem Paket zu tun ist, wenn es auf eine Regel zutrifft. Jede Regel <em>muss</em> dieses Schlüsselwort enthalten. Die folgenden Aktionen werden erkannt:</p><div class=paragraph><p><code>block</code>: Das Paket wird verworfen.</p></div><div class=paragraph><p><code>pass</code>: Das Paket wird durchgelassen.</p></div><div class=paragraph><p><code>log</code>: Das Paket wird protokolliert.</p></div><div class=paragraph><p><code>count</code>: Zählt die Anzahl der Pakete und die Bytes. Die kann einen Hinweis darauf geben, wie oft Pakete auf diese Regel zutreffen.</p></div><div class=paragraph><p><code>auth</code>: Das Paket geht in eine Warteschlange zur Weiterverarbeitung durch ein anderes Programm.</p></div><div class=paragraph><p><code>call</code>: Ermöglicht den Zugriff auf eingebaute IPF-Funktionen, die komplexere Aktionen ermöglichen.</p></div><div class=paragraph><p><code>decapsulate</code>: Entfernt alle Header, um den Inhalt des Pakets zu verarbeiten.</p></div></dd><dt class=hdlist1>DIRECTION</dt><dd><p>Als nächstes muss für jede Regel explizit die Richtung mit einem der folgenden Schlüsselwörter angegeben werden:</p><div class=paragraph><p><code>in</code>: Die Regel wird auf ein eingehendes Paket angewendet.</p></div><div class=paragraph><p><code>out</code>: Die Regel wird auf ein ausgehendes Paket angewendet.</p></div><div class=paragraph><p><code>all</code>: Die Regel gilt für beide Richtungen.</p></div><div class=paragraph><p>Wenn das System mehrere Schnittstellen ausweist, kann die Schnittstelle zusammen mit der Richtung angegeben werden. Ein Beispiel wäre <code>in on fxp0</code>.</p></div></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Optionen müssen nicht zwingend angegeben werden. Falls jedoch mehrere Optionen angegeben werden, müssen sie in der hier gezeigten Reihenfolge verwendet werden.</p><div class=paragraph><p><code>log</code>: Wenn die Firewall die angegebene Aktion durchführt, werden die Kopfdaten des Pakets auf der Pseudo-Schnittstelle <a href="https://man.freebsd.org/cgi/man.cgi?query=ipl&amp;sektion=4&amp;format=html">ipl(4)</a> protokolliert.</p></div><div class=paragraph><p><code>quick</code>: Wenn ein Paket mit dieser Regel übereinstimmt, wird die Aktion für diese Regel ausgeführt und die Regelprüfung stoppt an dieser Stelle.</p></div><div class=paragraph><p><code>on</code>: Auf dieses Schlüsselwort muss der Name der Schnittstelle folgen. Die Regel trifft nur dann zu, wenn das Paket auf der angegebenen Schnittstelle in die angegebene Richtung geht.</p></div><div class=paragraph><p>Wenn das Schlüsselwort <code>log</code> verwendet wird, können die folgenden Ausdrücke in dieser Reihenfolge benutzt werden:</p></div><div class=paragraph><p><code>body</code>: die ersten 128 Bytes des Paketinhaltes werden zusätzlich zu den Kopfdaten protokolliert.</p></div><div class=paragraph><p><code>first</code>: trifft nur zu, wenn das Schlüsselwort <code>log</code> zusammen mit <code>keep-state</code> verwendet wird. Es bestimmt, dass nur das auslösende Paket protokolliert wird und nicht jedes weitere Paket, dass von der gespeicherten Status-Regel betroffen ist.</p></div><div class=paragraph><p>Es stehen noch weitere Optionen zur Rückmeldung von Fehlern verfügbar. Ausführliche Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a>.</p></div></dd><dt class=hdlist1>PROTO_TYPE</dt><dd><p>Der Protokolltyp ist optional. Er ist jedoch zwingend erforderlich, falls die Regel einen SRC_PORT oder DST_PORT angeben muss da es den Typ des Protokolls bestimmt. Wenn Sie das Protokoll angeben, verwenden Sie das Schlüsselwort <code>proto</code>, gefolgt von der Protokollnummer oder dem Namen aus <span class=filename>/etc/protocols</span>. Zum Beispiel <code>tcp</code>, <code>udp</code>, oder <code>icmp</code>. Wenn PROTO_TYPE angegeben wird und SCR_PORT oder DST_PORT ausgelassen werden, stimmen alle Portnummern für dieses Protokoll mit dieser Regel überein.</p></dd><dt class=hdlist1>SRC_ADDR</dt><dd><p>Das Schlüsselwort <code>from</code> ist verpflichtend und darauf folgt das Schlüsselwort, das die Quelle des Pakets darstellt. Die Quelle kann ein Rechnername, eine IP-Adresse gefolgt von der CIDR-Maske, ein Adresspool oder das Schlüsselwort <code>all</code> sein. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> enthält einige Beispiele.</p><div class=paragraph><p>IP-Bereiche können nur in der CIDR-Notation angegeben werden. Der Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/ipcalc/>net-mgmt/ipcalc</a> hilft bei der Berechnung der richtigen CIDR-Maske. Weiterführende Informationen finden Sie auf der Webseite <a href=http://jodies.de/ipcalc>http://jodies.de/ipcalc</a>.</p></div></dd><dt class=hdlist1>SCR_PORT</dt><dd><p>Die Portnummer der Quelle ist optional. Wenn sie jedoch verwendet wird, muss in der Regel zuerst PROTO_TYPE angegeben werden. Die Portnummer muss auch auf das Schlüsselwort <code>proto</code> folgen.</p><div class=paragraph><p>Es werden verschiedene Vergleichsoperatoren unterstützt: <code>=</code> (gleich), <code>!=</code> (nicht gleich), <code>&lt;</code> (kleiner als), <code>></code> (größer als), <code>⇐</code> (kleiner als oder gleich) <code>>=</code> (größer als oder gleich).</p></div><div class=paragraph><p>Um Portbereiche anzugeben, schreiben Sie zwei Portnummern zwischen <code>&lt;></code> (kleiner als und größer als), <code>>&lt;</code> (größer als und kleiner als), oder <code>:</code> (größer als oder gleich und kleiner als oder gleich).</p></div></dd><dt class=hdlist1>DST_ADDR</dt><dd><p>Das Schlüsselwort <code>to</code> ist verpflichtend und darauf folgt das Schlüsselwort, welches das Ziel des Pakets darstellt. Dieses Ziel kann ein Rechnername, eine IP-Adresse gefolgt von der CIDR-Maske, ein Adresspool oder das Schlüsselwort <code>all</code> sein.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>Die Portnummer des Ziels ist optional. Wenn sie jedoch verwendet wird, muss in der Regel zuerst PROTO_TYPE angegeben werden. Die Portnummer muss auch auf das Schlüsselwort <code>proto</code> folgen.</p></dd><dt class=hdlist1>TCP_FLAG|ICMP_TYPE</dt><dd><p>Wenn <code>tcp</code> als PROTO_TYPE verwendet wird, können bestimmte TCP-Flags angegeben werden, die den Zustand einer Verbindung bestimmen. Mögliche Flags sind: <code>S</code> (SYN), <code>A</code> (ACK), <code>P</code> (PSH), <code>F</code> (FIN), <code>U</code> (URG), <code>R</code> (RST), <code>C</code> (CWN) und <code>E</code> (ECN).</p><div class=paragraph><p>Wenn <code>icmp</code> als PROTO_TYPE verwendet wird, kann der ICMP-Typ mit angegeben werden. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> enthält eine Auflistung der zulässigen Typen.</p></div></dd><dt class=hdlist1>STATE</dt><dd><p>Wenn eine <code>pass</code>-Regel das Schlüsselwort <code>keep state</code> enthält, wird IPF einen Eintrag in der dynamischen Zustandstabelle hinzufügen, damit nachfolgende Pakete dieser Verbindung ebenfalls durchgelassen werden. IPF kann den Zustand für TCP, UDP und ICMP-Sitzungen verfolgen. IPF wird jedes Paket, das zu einer aktiven Sitzung gehört, durchlassen, auch wenn ein anderes Protokoll verwendet wird.</p><div class=paragraph><p>Pakete, die über die Schnittstelle zum öffentlichen Internet raus gehen, werden von IPF zuerst gegen die dynamische Zustandstabelle geprüft. Wenn das nächste Paket dieser aktiven Sitzung mit dem vorherigen Paket übereinstimmt, verlässt dieses Paket die Firewall und der Status wird in der dynamischen Zustandstabelle aktualisiert. Pakete, die nicht zu einer aktiven Sitzung gehören, werden gegen ausgehende Regeln geprüft. Eingehende Pakete von der Schnittstelle zum öffentlichen Internet werden gegen die dynamische Zustandstabelle geprüft. Wenn das nächste Paket mit der aktiven Sitzung übereinstimmt, verlässt dieses Paket die Firewall und der Status wird in der dynamischen Zustandstabelle aktualisiert. Pakete, die nicht zu einer aktiven Sitzung gehören, werden gegen eingehende Regeln geprüft.</p></div><div class=paragraph><p>Mehrere Schlüsselwörter können an <code>keep state</code> angefügt werden. Bei der Verwendung dieser Schlüsselwörter werden verschiedene Optionen gesetzt, um die zustandsorientierte Filterung zu steuern. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> enthält eine Liste der verfügbaren Optionen und deren Beschreibungen.</p></div></dd></dl></div></div><div class=sect3><h4 id=_beispielregelsatz>53.5.3. Beispielregelsatz<a class=anchor href=#_beispielregelsatz></a></h4><div class=paragraph><p>Dieser Abschnitt beschreibt die Erstellung eines Regelsatzes, welcher nur entsprechende Dienste erlaubt und alle anderen Verbindungen blockiert.</p></div><div class=paragraph><p>FreeBSD verwendet die Loopback-Schnittstelle (<span class=filename>lo0</span>) und die IP-Adresse <code>127.0.0.1</code> zur internen Kommunikation. Der Regelsatz muss Regeln enthalten, die Pakete für diesen internen Verkehr ermöglichen:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on the loopback interface
pass in quick on lo0 all
pass out quick on lo0 all</pre></div></div><div class=paragraph><p>Die mit dem Internet verbundene Schnittstelle wird für die Autorisierung und den Zugriff aller ein- und ausgehenden Verbindungen verwendet. Wenn eine oder mehrere Schnittstellen mit privaten Netzwerken verbunden sind, müssen Regeln existieren, die den Datenverkehr aus dem LAN zwischen den internen Netzwerken oder ins Internet erlauben. Der Regelsatz sollte in drei Bereiche unterteilt werden: vertrauenswürdige interne Schnittstellen, ausgehende Verbindungen über die öffentlichen Schnittstellen und eingehende Verbindungen über die öffentliche Schnittstelle.</p></div><div class=paragraph><p>Diese beiden Regeln erlauben den gesamten Datenverkehr über eine vertrauenswürdige LAN-Schnittstelle namens <span class=filename>xl0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all</pre></div></div><div class=paragraph><p>Die Regeln für den ein- und ausgehenden Verkehr der öffentlichen Schnittstelle sollten in einer bestimmten Reihenfolge geschrieben werden. Zuerst Regeln, die häufiger übereinstimmen, danach Regeln, die seltener übereinstimmen. Die letzte Regel blockiert und protokolliert alle Pakete auf der Schnittstelle.</p></div><div class=paragraph><p>Der folgende Regelsatz definiert die ausgehenden Regeln der öffentlichen Schnittstelle <span class=filename>dc0</span>. Die Regeln prüfen den Zustand und identifizieren bestimmte Dienste, auf die die internen Systeme zugreifen dürfen. Alle Regeln verwenden das Schlüsselwort <code>quick</code> und geben die passenden Portnummern und ggf. auch die Zieladressen an.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x. with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x. port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow access to ISP&#39;s specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all</pre></div></div><div class=paragraph><p>Die folgenden Beispielregeln für den eingehenden Verkehr auf der öffentlichen Schnittstelle blockieren zuerst alle unerwünschten Pakete. Dies reduziert die Anzahl der Pakete, die durch die letzte Regel protokolliert werden.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81</pre></div></div><div class=paragraph><p>Wenn eine Regel mit der Option <code>log first</code> protokolliert wird, können Sie mit <code>ipfstat -hio</code> prüfen, wie viele Übereinstimmungen es für diese Regel gibt. Eine große Anzahl von Übereinstimmungen kann darauf hindeuten, dass das System angegriffen wird.</p></div><div class=paragraph><p>Die restlichen Regeln definieren, welche Verbindungen aus dem Internet kommend hergestellt werden dürfen. Die letzte Regel blockiert alle Verbindungen, die nicht ausdrücklich von vorhergehenden Regeln erlaubt wurden.</p></div><div class="literalblock programlisting"><div class=content><pre># Allow traffic in from ISP&#39;s DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all</pre></div></div></div><div class=sect3><h4 id=_nat_konfiguration>53.5.4. NAT Konfiguration<a class=anchor href=#_nat_konfiguration></a></h4><div class=paragraph><p>Um NAT zu aktivieren, fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> hinzu. Geben Sie den Namen der Datei an, welche die NAT-Regeln enthält:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
ipnat_enable=&#34;YES&#34;
ipnat_rules=&#34;/etc/ipnat.rules&#34;</pre></div></div><div class=paragraph><p>NAT-Regeln sind sehr flexibel, um den Bedürfnissen von kommerziellen Anwendern und Heimanwendern gerecht zu werden. Die hier vorgestellte Regelsyntax wurde vereinfacht, um die gemeinsame Nutzung zu demonstrieren. Eine vollständige Beschreibung der Syntax finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipnat&amp;sektion=5&amp;format=html">ipnat(5)</a>.</p></div><div class=paragraph><p>Die grundlegende Syntax für eine NAT-Regel ist wie folgt. <code>map</code> leitet die Regel ein und <code>IF</code> sollte durch den Namen der externen Schnittstelle ersetzt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>map IF LAN_IP_RANGE -&gt; PUBLIC_ADDRESS</pre></div></div><div class=paragraph><p><code><em>LAN_IP_RANGE</em></code> ist ein Bereich von IP-Adressen, der von den internen Rechnern verwendet wird. In der Regel ist dies ein privater Bereich, beispielsweise <code>192.168.1.0/24</code>. <code><em>PUBLIC_ADDRESS</em></code> kann entweder eine statische externe IP-Adresse sein, oder das Schlüsselwort <code>0/32</code>, welches der zugewiesenen IP-Adresse für <em>IF</em> entspricht.</p></div><div class=paragraph><p>Wenn ein Paket aus dem LAN mit einem öffentlichen Ziel an der IPF Firewall ankommt, werden zunächst die Regeln für den ausgehenden Verkehr geprüft. Danach wird das Paket an das NAT-Regelwerk geleitet, wo es von oben nach unten gelesen und geprüft wird, wobei die erste übereinstimmende Regel gewinnt. IPF testet jede NAT-Regel gegen die Schnittstelle und die Quell-IP-Adresse des Pakets. Wenn der Schnittstellenname des Pakets mit einer NAT-Regel übereinstimmt, wird geprüft, ob die Quell-IP-Adresse des Pakets auf den Bereich in <code><em>LAN_IP_RANGE</em></code> passt. Wenn dies der Fall ist, wird die Quell-IP-Adresse des Pakets mit der Adresse aus <code><em>PUBLIC_ADDRESS</em></code> überschrieben. IPF speichert die Einträge in seiner internen NAT-Tabelle, so dass wenn das Paket aus dem Internet zurückkehrt, es der ursprünglichen privaten IP-Adresse zugeordnet werden kann, bevor es von den weiteren Firewallregeln geprüft wird.</p></div><div class=paragraph><p>Bei Netzwerken mit einer großen Anzahl von Systemen oder mehreren Subnetzen, steigert sich der Ressourcenverbrauch für das Umschreiben der IP-Adressen. Es existieren zwei Methoden, um dieses Problem zu umgehen.</p></div><div class=paragraph><p>Bei der ersten Methode wird ein Portbereich definiert, der für die Quell-Ports verwendet wird. Durch das Hinzufügen des Schlüsselworts <code>portmap</code> kann NAT angewiesen werden, nur Quell-Ports aus dem angegebenen Bereich zu benutzen:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</pre></div></div><div class=paragraph><p>Alternativ kann das Schlüsselwort <code>auto</code> verwendet werden. Dadurch ermittelt NAT selbstständig die zur Verfügung stehenden Ports:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</pre></div></div><div class=paragraph><p>Mit der zweiten Methode wird ein Pool von öffentlichen Adressen verwendet. Dies ist nützlich, wenn es viele Systeme im Netzwerk gibt und ein Block öffentlicher IP-Adressen verfügbar ist. Aus diesem Pool kann NAT dann IP-Adressen für die ausgehenden Pakete auswählen.</p></div><div class=paragraph><p>Der Bereich der öffentlichen IP-Adressen kann mit einer Netzmaske oder der CIDR-Notation festgelegt werden. Die folgenden Regeln sind identisch:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</pre></div></div><div class=paragraph><p>Es ist gängige Praxis, öffentlich zugängliche Web- oder Mail-Server getrennt von den internen Netzwerksegmenten zu betreiben. Der Verkehr von diesen Servern muss dennoch von NAT bearbeitet werden und die Portumleitung ist erforderlich, um den eingehenden Datenverkehr an den richtigen Server zu leiten. Verwenden Sie beispielsweise folgende Regel, um den eingehenden Verkehr auf der öffentlichen IP-Adresse <code>20.20.20.5</code> dem internen Server mit der Adresse <code>10.0.10.25</code> zuzuordnen:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>Wenn dies der einzige Webserver im Netz ist, würde auch folgende Regel funktionieren, die alle HTTP-Anfragen an <code>10.0.10.25</code> umleitet:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>IPF enthält einen FTP-Proxy, der zusammen mit NAT benutzt werden kann. Dieser Proxy überwacht den ausgehenden Datenverkehr für aktive und passive Verbindungsanfragen und erstellt dynamische Filterregeln, welche die Portnummern des jeweiligen FTP-Datenkanal enthalten. Dadurch entfällt die Notwendigkeit, viele Ports für FTP-Verbindungen zu öffnen.</p></div><div class=paragraph><p>In diesem Beispiel verwendet die erste Regel den Proxy für ausgehende FTP-Verbindungen aus dem internen LAN. Die zweite Regel übergibt den FTP-Datenverkehr von der Firewall an das Internet und die dritte Regel handhabt den restlichen Datenverkehr aus dem internen LAN:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -&gt; 0/32</pre></div></div><div class=paragraph><p>FTP <code>map</code>-Regeln stehen vor den NAT-Regeln. Wenn ein Paket mit der FTP-Regel übereinstimmt, erstellt der FTP-Proxy eine temporäre Filterregel, damit die Pakete durchgelassen und von NAT verarbeitet werden können. Alle Pakte aus dem LAN, die nicht für FTP bestimmt sind, werden von NAT verarbeitet, wenn sie mit der dritten Regel übereinstimmen.</p></div><div class=paragraph><p>Ohne den FTP-Proxy würden stattdessen folgende Regeln benötigt. Beachten Sie, dass ohne den Proxy alle Ports oberhalb von <code>1024</code> freigegeben werden müssen:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state$
# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</pre></div></div><div class=paragraph><p>Nachdem die Datei mit den NAT-Regeln bearbeitet wurde, führen Sie <code>ipnat</code> mit <code>-CF</code> aus, um die aktuellen NAT-Regeln und den Inhalt der dynamischen Zuordnungstabelle zu löschen. Geben Sie <code>-f</code> zusammen mit dem NAT-Regelsatz an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -CF -f /etc/ipnat.rules</span></code></pre></div></div><div class=paragraph><p>Statistiken zu NAT lassen sich wie folgt anzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -s</span></code></pre></div></div><div class=paragraph><p>Die aktuellen Zuordnungen der NAT-Tabelle geben Sie mit diesem Kommando aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -l</span></code></pre></div></div><div class=paragraph><p>Ausführliche Informationen erhalten Sie mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -v</span></code></pre></div></div></div><div class=sect3><h4 id=_ipf_statistiken>53.5.5. IPF Statistiken<a class=anchor href=#_ipf_statistiken></a></h4><div class=paragraph><p>IPF enthält mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> ein Werkzeug, mit dem Statistiken abgerufen und angezeigt werden können. Die Zahlen beziehen sich auf den Zeitpunkt, an dem die Firewall zuletzt gestartet wurde, beziehungsweise die Statistik mit <code>ipf -Z</code> zurückgesetzt wurde.</p></div><div class=paragraph><p>Die Ausgabe von <code>ifstat</code> sieht in etwa wie folgt aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
input packets logged: blocked 99286 passed 0
output packets logged: blocked 0 passed 0
packets logged: input 0 output 0
log failures: input 3898 output 0
fragment state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 0 lost 0
fragment state<span class=o>(</span>out<span class=o>)</span>: kept 0 lost 0
packet state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 169364 lost 0
packet state<span class=o>(</span>out<span class=o>)</span>: kept 431395 lost 0
ICMP replies: 0 TCP RSTs sent: 0
Result cache hits<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 1215208 <span class=o>(</span>out<span class=o>)</span>: 1098963
IN Pullups succeeded: 2 failed: 0
OUT Pullups succeeded: 0 failed: 0
Fastroute successes: 0 failures: 0
TCP <span class=nb>cksum </span>fails<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 0 <span class=o>(</span>out<span class=o>)</span>: 0
Packet log flags <span class=nb>set</span>: <span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Es stehen viele Optionen zur Verfügung. Wird entweder <code>-i</code> (eingehend) oder <code>-o</code> (ausgehend) angegeben, wird der Befehl die entsprechende Liste mit den derzeit vom Kernel benutzten Filterregeln anzeigen. Um auch die Regelnummern zu sehen, muss <code>-n</code> angegeben werden. Zum Beispiel zeigt <code>ipfstat -on</code> die Tabelle für ausgehende Regeln und die Regelnummer an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Wenn Sie der Regel ein <code>-h</code> voranstellen, wird der Zähler für die jeweilige Regel ausgegeben. Zum Beispiel gibt <code>ipfstat -oh</code> die ausgehenden Regeln inklusive der Zähler aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Benutzen Sie <code>ipfstat -t</code> um die Zustandstabelle in einem <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> ähnlichen Format anzuzeigen. Unterliegt die Firewall einem Angriff, bietet diese Option die Möglichkeit, die entsprechenden Pakete zu identifizieren. Mit den optionalen Flags können IP-Adressen, Ports oder Protokolle in Echtzeit überwacht werden. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> für weitere Informationen.</p></div></div><div class=sect3><h4 id=_ipf_protokollierung>53.5.6. IPF Protokollierung<a class=anchor href=#_ipf_protokollierung></a></h4><div class=paragraph><p>IPF enthält mit <code>ipmon</code> ein Werkzeug, mit dem die Protokolle der Firewall in menschenlesbarer Form gespeichert werden können. Dies erfordert jedoch, dass <code>options IPFILTER_LOG</code> in die Kernelkonfigurationsdatei hinzugefügt wird. Folgen Sie dazu den Anweisungen in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a>.</p></div><div class=paragraph><p>Um eine kontinuierliche Protokolldatei bereitzustellen, läuft dieses Kommando normalerweise im Daemon-Modus, damit auch ältere Ereignisse nachverfolgt werden können. Da FreeBSD mit <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> ein Werkzeug besitzt, das automatisch Protokolldateien rotiert, wird in der Voreinstellung für <code>ipmon_flags -Ds</code> in <span class=filename>rc.conf</span> verwendet:</p></div><div class="literalblock programlisting"><div class=content><pre>ipmon_flags=&#34;-Ds&#34; # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>Protokollierung bietet die im Nachhinein die Möglichkeit festzustellen, welche Pakete verworfen wurden, von welchen Adressen diese Pakete kamen und wohin sie gehen sollten. Diese Informationen sind hilfreich beim Aufspüren von Angreifern.</p></div><div class=paragraph><p>Nachdem die Protokollierung in <span class=filename>/etc/rc.conf</span> aktiviert und mit <code>service ipmon start</code> gestartet wurde, wird IPF Regeln aufzeichnen, welche das Schlüsselwort <code>log</code> enthalten. Der Firewalladministrator entscheidet, welche Regeln protokolliert werden. In der Regel werden nur geblockte Pakete protokolliert. Es ist üblich, das Schlüsselwort <code>log</code> in der letzten Regel des Regelsatzes mit aufzunehmen. Dies macht es möglich, alle Pakete zu sehen, die mit keiner Regel des Regelsatzes übereinstimmten.</p></div><div class=paragraph><p>In der Voreinstellung verwendet <code>ipmon -Ds local0</code> als Protokoll-Facility. Die folgenden Level können verwendet werden, um die erfassten Daten weiter aufzuspalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>LOG_INFO - packets logged using the <span class=s2>&#34;log&#34;</span> keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header</code></pre></div></div><div class=paragraph><p>Damit IPF alle Daten protokolliert, legen Sie zunächst eine neue Datei <span class=filename>/var/log/ipfilter.log</span> an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/ipfilter.log</span></code></pre></div></div><div class=paragraph><p>Um alle Nachrichten in der angegebenen Datei zu protokollieren, fügen Sie den folgenden Eintrag in <span class=filename>/etc/syslog.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>local0.* /var/log/ipfilter.log</pre></div></div><div class=paragraph><p>Führen Sie <code>service syslogd reload</code> aus, damit <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> <span class=filename>/etc/syslog.conf</span> neu einliest, um die Änderungen zu aktivieren.</p></div><div class=paragraph><p>Denken Sie daran, auch <span class=filename>/etc/newsyslog.conf</span> anzupassen, damit das neue Protokoll rotiert wird.</p></div><div class=paragraph><p>Die von <code>ipmon</code> generierten Nachrichten bestehen aus Daten, welche durch Leerzeichen getrennt sind. Alle Nachrichten enthalten die folgenden Felder:</p></div><div class="olist arabic"><ol class=arabic><li><p>Das Datum, an dem das Paket empfangen wurde.</p></li><li><p>Die Uhrzeit, wann das Paket empfangen wurde. Das Format ist HH:MM:SS.F (Stunden, Minuten, Sekunden und Sekundenbruchteile).</p></li><li><p>Der Name der Schnittstelle, die das Paket verarbeitet hat.</p></li><li><p>Die Gruppen- und Regelnummer im Format <code>@0:17</code>.</p></li><li><p>Die Aktion: <code>p</code> für durchgelassene Pakete, <code>b</code> für blockierte Pakete, <code>S</code> für kurze Pakete, <code>n</code> für Pakete auf die keine Regel zutraf und <code>L</code> für Pakete die protokolliert wurden.</p></li><li><p>Die Adressen werden in drei Felder unterteilt: die Quelladresse und der Port getrennt durch Komma, das Zeichen →, sowie die Zieladresse und Port. Zum Beispiel <code>209.53.17.22,80 → 198.72.220.17,1722</code>.</p></li><li><p><code>PR</code>, gefolgt vom Namen oder Nummer des Protokolls. Zum Beispiel <code>PR tcp</code>.</p></li><li><p><code>len</code>, gefolgt von der Größe des Headers und der Gesamtgröße des Pakets. Zum Beispiel <code>len 20 40</code>.</p></li></ol></div><div class=paragraph><p>Wenn es sich beim dem Paket um ein TCP-Paket handelt, gibt es ein zusätzliches Feld, das mit einem Bindestrich beginnt und die Buchstaben der entsprechenden Flags enthält. Eine Liste der Flags und deren Buchstaben finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a>.</p></div><div class=paragraph><p>Wenn es sich beim dem Paket um ein ICMP-Paket handelt, gibt es zwei zusätzliche Felder: das erste Feld ist immer "icmp" und das zweite Feld enthält die ICMP-Nachricht und den Nachrichten-Code, getrennt durch einen Schrägstrich. Beispielswiese <code>icmp 3/3</code> für die Nachricht Port unreachable.</p></div></div></div><div class=sect2><h3 id=firewalls-blacklistd>53.6. Blacklistd<a class=anchor href=#firewalls-blacklistd></a></h3><div class=paragraph><p>Blacklistd ist ein Daemon der auf Sockets lauscht, um Benachrichtigungen von anderen Daemons über fehlgeschlagene oder erfolgreiche Verbindungsversuche zu erhalten. Dieser Daemon wird häufig verwendet, um zu viele Verbindungsversuche auf offenen Ports zu blockieren. Ein Beispiel ist SSH, das viele Anfragen von Bots oder Skripten erhält, die versuchen, Passwörter zu erraten und Zugriff zu erhalten. Mit Hilfe von blacklistd kann der Daemon die Firewall benachrichtigen, eine Filterregel zu erstellen, um übermäßige Verbindungsversuche einer einzigen Quelle nach einer Reihe von Versuchen zu blockieren. Blacklistd wurde ursprünglich auf NetBSD entwickelt und erschien dort in der Version 7. FreeBSD 11 hat blacklistd von NetBSD importiert.</p></div><div class=paragraph><p>In diesem Kapitel wird die Einrichtung und Konfiguration von blacklistd besprochen. Sie finden aber auch Beispiele für die Verwendung von blacklistd. Sie sollten allerdings mit grundlegenden Firewall-Konzepten wie Filterregeln vertraut sein. Weitere Informationen finden Sie im Kapitel Firewalls. In diesen Beispielen wird PF benutzt, aber auch andere unter FreeBSD verfügbare Firewalls sollten in der Lage sein mit blacklistd zusammen zu arbeiten.</p></div><div class=sect3><h4 id=_blacklistd_aktivieren>53.6.1. Blacklistd aktivieren<a class=anchor href=#_blacklistd_aktivieren></a></h4><div class=paragraph><p>Die Konfiguration für blacklistd wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> gespeichert. Um das Laufzeitverhalten von blacklistd zu beeinflussen, sind verschiedene Kommandozeilenoptionen verfügbar. Die permanente Konfiguration über Neustarts hinweg sollte in <span class=filename>/etc/blacklistd.conf</span> gespeichert werden. Um den Daemon während des Systemstarts zu aktivieren, fügen Sie eine Zeile <code>blacklistd_enable</code> in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc blacklistd_enable=yes</span></code></pre></div></div><div class=paragraph><p>Sie können den Daemon auch manuell starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service blacklistd start</span></code></pre></div></div></div><div class=sect3><h4 id=_erstellen_von_blacklistd_regeln>53.6.2. Erstellen von Blacklistd-Regeln<a class=anchor href=#_erstellen_von_blacklistd_regeln></a></h4><div class=paragraph><p>Die Regeln für blacklistd werden in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> mit einem Eintrag pro Zeile konfiguriert. Jede Regel enthält ein Tupel, das durch Leerzeichen oder Tabulator getrennt ist. Eine Regel gilt entweder für einen lokalen oder einen entfernten Rechner.</p></div><div class=sect4><h5 id=_lokale_regeln>53.6.2.1. Lokale Regeln<a class=anchor href=#_lokale_regeln></a></h5><div class=paragraph><p>Ein typischer Eintrag für eine lokale Regel in <span class=filename>/etc/blacklistd.conf</span> sieht wie folgt aus:</p></div><div class="literalblock programlisting"><div class=content><pre>[local]
ssh             stream  *       *               *       3       24h</pre></div></div><div class=paragraph><p>Alle Regeln, die dem Abschnitt <code>[local]</code> folgen, werden als lokale Regeln behandelt, die für den lokalen Rechner gelten. In einem <code>[remote]</code>-Abschnitt gelten alle Regeln für entfernte Maschinen.</p></div><div class=paragraph><p>Die sieben Felder einer Regel werden entweder durch Tabulator oder Leerzeichen getrennt. Die ersten vier Felder identifizieren den Netzwerkverkehr, welcher geblockt werden soll. Die drei folgenden Felder definieren das Verhalten von blacklistd. Wildcards werden mit einem Sternchen (<code>*</code>) gekennzeichnet und stimmen mit allen anderen in diesem Feld überein. Das erste Feld definiert den Standort. In den lokalen Regeln sind dies die Ports. Die Syntax ist wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>[address|interface][/mask][:port]</pre></div></div><div class=paragraph><p>Adressen können als IPv4 im numerischen Format oder IPv6 in eckigen Klammern angegeben werden. Ebenfalls kann der Name der Schnittstelle wie <code><em>em0</em></code> verwendet werden.</p></div><div class=paragraph><p>Im zweiten Feld wird der Socket-Typ definiert. TCP-Sockets sind vom Typ <code>stream</code>, wohingegen UDP als <code>dgram</code> bezeichnet wird. Das obige Beispiel verwendet TCP, weil SSH dieses Protokoll benutzt.</p></div><div class=paragraph><p>Im dritten Feld kann ein Protokoll definiert werden. Die folgenden Protokolle können verwendet werden: <code>tcp</code>, <code>udp</code>, <code>tcp6</code>, <code>udp6</code> oder numerisch. Eine Wildcard, wie im Beispiel, wird typischerweise verwendet, um alle Protokolle abzubilden, es sei denn, es gibt einen Grund, den Verkehr nach einem bestimmten Protokoll zu differenzieren.</p></div><div class=paragraph><p>Im vierten Feld wird der effektive Benutzer oder Eigentümer des Daemon-Prozesses definiert, welcher das Ereignis meldet. Hier kann der Benutzer oder die UID sowie eine Wildcard verwendet werden (siehe Beispiel oben).</p></div><div class=paragraph><p>Der Name der Firewallregel wird im fünften Feld definiert. In der Voreinstellung setzt blacklistd alle geblockten Pakete unter einen pf-Anker namens <code>blacklistd</code> in <span class=filename>pf.conf</span> wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>anchor &#34;blacklistd/*&#34; in on $ext_if
block in
pass out</pre></div></div><div class=paragraph><p>Für separate Blacklists kann in diesem Feld ein Ankername benutzt werden. In anderen Fällen genügt eine Wildcard. Ein Name mit vorangestelltem Bindestrich (<code>-</code>) bedeutet, das ein Anker mit dem voreingestellten Regelnamen verwendet werden sollte. Ein modifiziertes Beispiel von oben mit dem Bindestrich würde so aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>ssh             stream  *       *               -ssh       3       24h</pre></div></div><div class=paragraph><p>Mit einer solchen Regel werden alle neuen Blacklistregeln zu einem Anker namens <code>blacklistd-ssh</code> hinzugefügt.</p></div><div class=paragraph><p>Um ganze Subnetze für eine einzelne Regelverletzung zu blockieren, kann ein <code>/</code> im Regelnamen benutzt werden. Dadurch wird der verbleibende Teil des Namens als Maske interpretiert, die auf die in der Regel angegebene Adresse angewendet wird. Diese Regel würde beispielsweise jede Adresse blockieren, die an <code>/24</code> angrenzt:</p></div><div class="literalblock programlisting"><div class=content><pre>22              stream  tcp       *               */24    3       24h</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es ist wichtig, hier das richtige Protokoll anzugeben. IPv4 und IPv6 behandeln <code>/24</code> unterschiedlich, deshalb kann <code>*</code> im dritten Feld für diese Regel nicht benutzt werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Diese Regel bewirkt, dass, wenn ein Rechner in diesem Netzwerk wegen seines Verhaltens blockiert wird, auch alle anderen Rechner aus diesem Netzwerk blockiert werden.</p></div><div class=paragraph><p>Das sechste Feld, genannt <code>nfail</code>, legt die Anzahl der Anmeldeversuche fest, die erforderlich sind, um die betreffende IP auf die Blacklist zu setzen. Eine Wildcard an dieser Stelle bedeutet, dass niemals geblockt wird. Im obigen Beispiel ist eine Anzahl von 3 definiert, was bedeutet, dass die IP nach drei fehlgeschlagenen Anmeldeversuchen über SSH gesperrt wird.</p></div><div class=paragraph><p>Das letzte Feld in der Regel gibt an, wie lange ein Rechner auf der Blacklist steht. Die Standardeinheit ist Sekunden, aber Suffixe wie <code>m</code> (Minuten), <code>h</code> (Stunden) und <code>d</code> (Tage) können auch angegeben werden.</p></div><div class=paragraph><p>Die Regel im Beispiel besagt, dass nach dreimaliger Authentifizierung über SSH eine neue PF-Regel für diesen Rechner angelegt wird. Beim Überprüfen der Regeln werden zuerst lokale Regeln, von sehr spezifisch bis am wenigsten spezifisch, geprüft. Wenn eine Übereinstimmung auftritt, werden die <code>remote</code>-Regeln angewendet und die Felder <code>name</code>, <code>nfail</code> und <code>disable</code> werden durch die entsprechende <code>remote</code>-Regel geändert.</p></div></div><div class=sect4><h5 id=_remote_regeln>53.6.2.2. Remote-Regeln<a class=anchor href=#_remote_regeln></a></h5><div class=paragraph><p>Mit Remote-Regeln wird das Verhalten von blacklistd, in Abhängigkeit vom aktuell ausgewerteten Remote-Rechner, festgelegt. Die einzelnen Felder einer Remote-Regel sind identisch mit den Feldern einer lokalen Regel. Der einzige Unterschied besteht darin, wie blacklistd sie verwendet. Zur besseren Verständlichkeit wird folgende Regel benutzt:</p></div><div class="literalblock programlisting"><div class=content><pre>[remote]
203.0.113.128/25 *      *       *               =/25    =       48h</pre></div></div><div class=paragraph><p>Das Adressfeld kann eine IP-Adresse (entweder v4 oder v6), einen Port oder beides beinhalten. Dies ermöglicht es, wie in diesem Beispiel, spezielle Regeln für einen bestimmten entfernten Adressbereich festzulegen. Die Felder für den Socket-Typ, Protokoll und Besitzer werden genauso wie in den lokalen Regeln interpretiert.</p></div><div class=paragraph><p>Die Felder für den Namen sind jedoch unterschiedlich. Das Gleichheitszeichen (<code>=</code>) in einer Remote-Regel weist blacklistd an, den Wert aus der entsprechenden lokalen Regel zu verwenden. Das bedeutet, dass der Eintrag der Firewall-Regel übernommen und das Präfix <code>/25</code> (eine Netzmaske von <code>255.255.255.128</code>) hinzugefügt wird. Wenn eine Verbindung aus diesem Adressbereich geblockt wird, ist das gesamte Subnetz betroffen. Ein PF-Ankername kann auch hier verwendet werden. In diesem Fall fügt blacklistd Regeln für diesen Adressbereich dem Namen des Ankers hinzu. Die Standardtabelle wird verwendet, wenn eine Wildcard angegeben wird.</p></div><div class=paragraph><p>Für eine Adresse kann im Feld <code>nfail</code> die Anzahl von Fehlversuchen definiert werden. Dies ist nützlich für Ausnahmen, um weniger strenge Anwendungen zu ermöglichen, oder um Anmeldeversuche ein wenig nachsichtiger zu gestalten. Die Sperrung wird aufgehoben, wenn im sechsten Feld eine Wildcard benutzt wird.</p></div><div class=paragraph><p>Remote-Regeln ermöglichen eine strengere Durchsetzung der Beschränkungen bei Anmeldeversuchen im Vergleich zu Anmeldeversuchen die aus dem lokalen Netzwerk kommen.</p></div></div></div><div class=sect3><h4 id=_blacklistd_client_konfiguration>53.6.3. Blacklistd Client Konfiguration<a class=anchor href=#_blacklistd_client_konfiguration></a></h4><div class=paragraph><p>Es gibt einige Softwarepakete in FreeBSD, die die Funktionalität von blacklistd nutzen können. Die beiden bekanntesten sind <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>. Beide Programme nutzen blacklistd, um übermäßige Verbindungsversuche zu unterbinden. Um blacklistd im SSH-Daemon zu aktivieren, muss folgend Zeile in <span class=filename>/etc/ssh/sshd_config</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>UseBlacklist yes</pre></div></div><div class=paragraph><p>Damit die Änderungen wirksam werden, muss sshd im Anschluss neu gestartet werden.</p></div><div class=paragraph><p>Für <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> wird blacklistd mit dem Schalter <code>-B</code> aktiviert. Entweder in <span class=filename>/etc/inetd.conf</span> oder in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpd_flags=&#34;-B&#34;</pre></div></div><div class=paragraph><p>Das ist alles, was benötigt wird, damit diese Programme mit blacklist kommunizieren.</p></div></div><div class=sect3><h4 id=_blacklistd_verwaltung>53.6.4. Blacklistd Verwaltung<a class=anchor href=#_blacklistd_verwaltung></a></h4><div class=paragraph><p>Blacklistd stellt dem Benutzer das Verwaltungswerkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistctl&amp;sektion=8&amp;format=html">blacklistctl(8)</a> zur Verfügung. Es zeigt blockierte Adressen und Netzwerke an, die nach den in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> definierten Regeln auf der Blacklist stehen. Um die Liste der aktuell blockierten Rechner anzuzeigen, benutzen Sie <code>dump</code> zusammen mit der Option <code>-b</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -b</span>
      address/ma:port <span class=nb>id      </span>nfail   last access
213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19</code></pre></div></div><div class=paragraph><p>Dieses Beispiel zeigt, dass es sechs von drei erlaubten Anmeldeversuchen auf Port 22 aus dem Adressbereich <code>213.0.123.128/25</code> gab. Es sind mehr Versuche aufgelistet, als erlaubt sind, da SSH es einem Client erlaubt, mehrere Anmeldungen über eine einzige TCP-Verbindung zu tätigen. Eine derzeit laufende Verbindung wird nicht von blacklistd unterbunden. Der letzte Verbindungsversuch ist in der letzten Spalte der Ausgabe aufgeführt.</p></div><div class=paragraph><p>Um die verbleibende Zeit zu sehen, die sich dieser Rechner auf der Blacklist befindet, fügen Sie <code>-r</code> zum vorherigen Befehl hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -br</span>
      address/ma:port <span class=nb>id      </span>nfail   remaining <span class=nb>time
</span>213.0.123.128/25:22   OK      6/3     36s</code></pre></div></div><div class=paragraph><p>In diesem Beispiel bleiben noch 36 Sekunden, bis dieser Rechner nicht mehr blockiert wird.</p></div></div><div class=sect3><h4 id=_rechner_aus_der_blocklist_entfernen>53.6.5. Rechner aus der Blocklist entfernen<a class=anchor href=#_rechner_aus_der_blocklist_entfernen></a></h4><div class=paragraph><p>Manchmal ist es notwendig, einen Rechner aus der Blocklist zu entfernen, bevor die verbleibende Zeit abgelaufen ist. Leider bietet blacklistd keine Möglichkeit dies zu tun. Es ist jedoch möglich, die Adresse mit <code>pfctl</code> aus der PF-Tabelle zu entfernen. Für den blockierten Port gibt es einen untergeordneten Anker innerhalb des definierten blacklistd-Ankers in <span class=filename>/etc/pf.conf</span>. Wenn es beispielsweise einen untergeordneten Anker zum Blockieren von Port 22 gibt, wird dieser als <code>blacklistd/22</code> bezeichnet. In diesem untergeordneten Anker befindet sich eine Tabelle, die die blockierten Adressen enthält. Diese Tabelle wird Port genannt, gefolgt von der Portnummer. In diesem Beispiel würde es <code>port22</code> heißen. Mit diesen Informationen und <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> ist es nun möglich, alle geblockten Adressen anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -t port22 -T show</span>
...
213.0.123.128/25
...</code></pre></div></div><div class=paragraph><p>Nachdem Sie die entsprechende Adresse ermittelt wurde, kann sie mit folgendem Befehl aus der Liste entfernt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -t port22 -T delete 213.0.123.128/25</span></code></pre></div></div><div class=paragraph><p>Die Adresse ist nun aus PF entfernt, erscheint aber immer noch in der Liste von <code>blacklistctl</code>, da dieser keine Kenntnis von Änderungen an PF hat. Der Eintrag in blacklist’s Datenbank wird irgendwann ablaufen und dann aus der Ausgabe entfernt werden. Der Eintrag wird wieder hinzugefügt, falls der Rechner erneut gegen eine der Regeln von blacklistd verstößt.</p></div></div></div></div></div><div class=sect1><h2 id=advanced-networking>Kapitel 54. Weiterführende Netzwerkthemen<a class=anchor href=#advanced-networking></a></h2><div class=sectionbody><div class=sect2><h3 id=advanced-networking-synopsis>54.1. Übersicht<a class=anchor href=#advanced-networking-synopsis></a></h3><div class=paragraph><p>Dieses Kapitel beschreibt verschiedene weiterführende Netzwerkthemen.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</p></div><div class=ulist><ul><li><p>Die Grundlagen von Gateways und Routen kennen.</p></li><li><p>Wissen, wie man USB Tethering einrichtet.</p></li><li><p>Bluetooth®- sowie drahtlose, der Norm IEEE® 802.11 entsprechende, Geräte mit FreeBSD verwenden können.</p></li><li><p>Eine Bridge unter FreeBSD einrichten können.</p></li><li><p>Wissen, wie man mithilfe von PXE über ein Netzwerk von einem NFS Root-Dateisystem bootet.</p></li><li><p>IPv6 auf einem FreeBSD-Rechner einrichten können.</p></li><li><p>Das Common Address Redundancy Protocol (CARP) unter FreeBSD einsetzen können.</p></li><li><p>Wissen, wie VLANs unter FreeBSD konfiguriert werden.</p></li><li><p>Wissen, wie Bluetooth-Kopfhörer konfiguriert werden.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie</p></div><div class=ulist><ul><li><p>Die Grundlagen der <span class=filename>/etc/rc</span>-Skripte verstanden haben.</p></li><li><p>Mit der grundlegenden Netzwerkterminologie vertraut sein.</p></li><li><p>Einen neuen FreeBSD-Kernel konfigurieren und installieren können (<a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a>).</p></li><li><p>Wissen, wie man zusätzliche Software von Drittherstellern installiert (<a href=./#ports>Installieren von Anwendungen: Pakete und Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=network-routing>54.2. Gateways und Routen<a class=anchor href=#network-routing></a></h3><div class=paragraph><p>Der Mechanismus mit dem ein Rechner einen Rechner über ein Netzwerk finden kann, wird als <em>Routing</em> bezeichnet. Eine "Route" besteht aus einem definierten Adresspaar: Einem "Ziel" und einem "Gateway". Die Route zeigt an, dass Pakete über das <em>Gateway</em> zum <em>Ziel</em> gelangen können. Es gibt drei Arten von Zielen: Einzelne Rechner (Hosts), Subnetze und das "Standard"ziel. Die "Standardroute" wird verwendet, wenn keine andere Route zutrifft. Außerdem gibt es drei Arten von Gateways: Einzelne Rechner (Hosts), Schnittstellen (Interfaces, auch als "Links" bezeichnet), sowie Ethernet Hardware-Adressen (MAC). Bekannte Adressen werden in einer Routingtabelle gespeichert.</p></div><div class=paragraph><p>Dieser Abschnitt bietet einen Überblick über die Grundlagen des Routings. Er demonstriert, wie ein FreeBSD-System als Router konfiguriert werden kann und bietet einige Tipps zur Fehlerbehebung.</p></div><div class=sect3><h4 id=network-routing-default>54.2.1. Grundlagen des Routings<a class=anchor href=#network-routing-default></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> zeigt die Routingtabellen eines FreeBSD-Systems an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Internet:
Destination      Gateway            Flags     Refs     Use     Netif Expire
default          outside-gw         UGS        37      418       em0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1            UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>Die Einträge in diesem Beispiel sind wie folgt:</p></div><div class=dlist><dl><dt class=hdlist1>default</dt><dd><p>Die erste Route in der Ausgabe gibt die Standardroute (<code>default</code>) an. Wenn sich der lokale Rechner mit einem entfernten Rechner verbinden will, wird die Routingtabelle überprüft, um festzustellen, ob bereits ein bekannter Pfad vorhanden ist. Wird für den entfernten Rechner ein Eintrag in der Routingtabelle gefunden, so prüft das System ob es sich über die angegebene Schnittstelle verbinden kann.</p><div class=paragraph><p>Wenn das Zielsystem mit keinem Eintrag übereinstimmt, oder wenn alle bekannten Routen fehlschlagen, verwendet das System die Standardroute. Für die Rechner im lokalen Netzwerk ist das Feld <code>Gateway</code> auf das System gesetzt, welches direkt mit dem Internet verbunden ist. <code>UG</code> in der Spalte <code>Flags</code> zeigt an, dass das Gateway einsatzbereit ist.</p></div><div class=paragraph><p>Die Standardroute für einen Rechner, der selbst als Gateway zur Außenwelt fungiert, ist der Gateway-Rechner des Internetanbieters (ISP).</p></div></dd><dt class=hdlist1>localhost</dt><dd><p>Die zweite Route zeigt die <code>localhost</code> Route. Die festgelegte Schnittstelle in der <code>Netif</code>-Spalte für <code>localhost</code> ist <code>lo0</code>, das auch als loopback-Gerät bekannt ist. Das bedeutet, dass der gesamte Datenverkehr für dieses Ziel intern bleibt, anstatt ihn über ein Netzwerk zu versenden.</p></dd><dt class=hdlist1>MAC-Adresse</dt><dd><p>Bei den mit <code>0:e0:</code> beginnenden Adressen handelt es sich um MAC-Adressen. FreeBSD identifiziert Rechner im lokalen Netz, im Beispiel <code>test0</code>, automatisch und fügt eine direkte Route über die Ethernet-Schnittstelle <span class=filename>re0</span> zu diesem Rechner hinzu. Außerdem existiert in der Spalte <code>Expire</code> ein Timeout, der verwendet wird, wenn dieser Rechner in einem definierten Zeitraum nicht reagiert. Wenn dies passiert, wird die Route zu diesem Rechner automatisch gelöscht. Rechner im lokalen Netz werden über das Routing Information Protocol (RIP) identifiziert, welches den kürzesten Weg zu den jeweiligen Rechnern berechnet.</p></dd><dt class=hdlist1>Subnetz</dt><dd><p>FreeBSD wird automatisch Subnetzrouten für das lokale Subnetz hinzufügen. In diesem Beispiel ist <code>10.20.30.255</code> die Broadcast-Adresse für das Subnetz <code>10.20.30</code>, und <code>example.com</code> ist der zu diesem Subnetz gehörige Domainname. Das Ziel <code>link#1</code> bezieht sich auf die erste Ethernet-Karte im Rechner.</p><div class=paragraph><p>Routen für Rechner im lokalen Netz und lokale Subnetze werden automatisch durch den <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a> Daemon konfiguriert. Ist dieser nicht gestartet, existieren nur statische Routen, die vom Administrator definiert werden.</p></div></dd><dt class=hdlist1>Host</dt><dd><p>Die Zeile <code>host1</code> bezieht sich auf den Rechner, der durch seine Ethernetadresse bekannt ist. Da es sich um den sendenden Rechner handelt, verwendet FreeBSD automatisch das Loopback-Gerät (<span class=filename>lo0</span>), anstatt den Datenverkehr über die Ethernet-Schnittstelle zu senden.</p><div class=paragraph><p>Die zwei <code>host2</code> Zeilen repräsentieren Aliase, die mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> erstellt wurden. Das Symbol <code>⇒</code> nach der <span class=filename>lo0</span>-Schnittstelle sagt aus, dass zusätzlich zur Loopback-Adresse auch ein Alias eingestellt ist. Solche Routen sind nur auf Rechnern vorhanden, die den Alias bereitstellen. Alle anderen Rechner im lokalen Netz haben für solche Routen nur eine <code>link#1</code> Zeile.</p></div></dd><dt class=hdlist1>224</dt><dd><p>Die letzte Zeile (Zielsubnetz <code>224</code>) behandelt Multicasting.</p></dd></dl></div><div class=paragraph><p>Schließlich gibt es für Routen noch verschiedene Attribute, die sich in der Spalte <code>Flags</code> befinden. <a href=#routeflags>Allgemeine Attribute in Routingtabellen</a> fasst einige dieser Flags und deren Bedeutung zusammen:</p></div><table id=routeflags class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 30. Allgemeine Attribute in Routingtabellen</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Attribut</th><th class="tableblock halign-left valign-top">Bedeutung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die Route ist aktiv (up).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Das Ziel der Route ist ein einzelner Rechner (Host).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alle Daten, die an dieses Ziel gesendet werden, werden von dem Gateway an ihr jeweiliges Ziel weitergeleitet.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diese Route wurde statisch konfiguriert.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Erzeugt eine neue Route, basierend auf der Route für den Rechner, mit dem wir uns verbinden. Diese Routenart wird normalerweise für lokale Netzwerke verwendet.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eine Route, die automatisch konfiguriert wurde. Sie basiert auf einer lokalen Netzwerkroute (Clone).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die Route beinhaltet einen Verweis auf eine Ethernetkarte (Link).</p></td></tr></tbody></table><div class=paragraph><p>In FreeBSD kann die Standardroute durch die Angabe der IP-Adresse des Standard-Gateways in <span class=filename>/etc/rc.conf</span> definiert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>Die Standardroute kann mit <code>route</code> auch manuell gesetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>Beachten Sie, dass manuell hinzugefügte Routen bei einem Neustart des Systems verloren gehen. Weitere Informationen zum Bearbeiten von Netzwerk-Routingtabellen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>.</p></div></div><div class=sect3><h4 id=network-static-routes>54.2.2. Statische Routen einrichten<a class=anchor href=#network-static-routes></a></h4><div class=paragraph><p>Ein FreeBSD-System kann als Standard-Gateway bzw. Router für ein Netzwerk konfiguriert werden, wenn es sich um einen Dual-Homed-Host handelt. Ein Dual-Homed-Host ist ein Rechner, der sich in mindestens zwei verschiedenen Netzwerken befindet. Typischerweise ist jedes Netzwerk über eine separate Netzwerkschnittstelle verbunden. Mit IP Aliasing können mehrere Adressen, die jeweils zu einem andren Subnetz gehören, an eine physikalische Schnittstelle gebunden werden.</p></div><div class=paragraph><p>Damit Pakete zwischen den Schnittstellen weitergeleitet werden können, muss das FreeBSD-System als Router konfiguriert werden. Internetstandards und gute Ingenieurspraxis sorgten dafür, dass diese Funktion in FreeBSD in der Voreinstellung deaktiviert ist. Sie kann jedoch aktiviert werden, indem folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzugefügt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;          # Auf YES setzen, wenn der Rechner als Gateway arbeiten soll</pre></div></div><div class=paragraph><p>Um das Routing zu aktivieren, setzen Sie die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>net.inet.ip.forwarding</code> auf <code>1</code>. Um das Routing zu stoppen, muss die Variable wieder auf <code>0</code> gesetzt werden.</p></div><div class=paragraph><p>Die Routingtabelle eines Routers benötigt zusätzliche Routen, damit er weiß, wie er andere Netzwerke erreichen kann. Die Routen können entweder manuell als statische Routen hinzugefügt werden, oder aber der Router lernt automatisch die Routen anhand des Routing-Protokolls. Statische Routen eignen sich für kleine Netzwerke und dieser Abschnitt beschreibt, wie Sie eine statische Route für ein kleines Netzwerk hinzufügen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In großen Netzwerken sind statische Routen schlecht skalierbar. FreeBSD beinhaltet den BSD-Routing-Daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, der die Protokolle RIP (Version 1 und Version 2) sowie IRDP unterstützt. Die Routing-Protokolle BGP und OSPF können über den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a> installiert werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nehmen wir an, dass wir über folgendes Netzwerk verfügen:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p><code>RouterA</code>, ein FreeBSD-Rechner, dient als Router für den Zugriff auf das Internet. Die Standardroute ist auf <code>10.0.0.1</code> gesetzt, damit ein Zugriff auf das Internet möglich wird. <code>RouterB</code> ist bereits konfiguriert, da er <code>192.168.1.1</code> als Standard-Gateway benutzt.</p></div><div class=paragraph><p>Bevor die statischen Routen hinzugefügt werden, sieht die Routingtabelle auf <code>RouterA</code> in etwa so aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1/24       <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>Mit dieser Routingtabelle hat <code>RouterA</code> keine Route zum Netzwerk <code>192.168.2.0/24</code>. Der folgende Befehl wird das interne Netz 2 in die Routingtabelle von <code>RouterA</code> aufnehmen und dabei <code>192.168.1.2</code> als nächsten Zwischenschritt (Hop) verwenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Ab sofort kann <code>RouterA</code> alle Rechner des Netzwerks <code>192.168.2.0/24</code> erreichen. Allerdings gehen die Routing-Informationen verloren, wenn das FreeBSD-System neu gestartet wird. Um statische Routen dauerhaft einzurichten, müssen diese in <span class=filename>/etc/rc.conf</span> eingetragen werden:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a persistent static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>Die Variable <code>static_routes</code> enthält eine Reihe von Strings, die durch Leerzeichen getrennt sind. Jeder String bezieht sich auf den Namen einer Route. Die Variable <code>route__internalnet2_</code> enthält die statische Route.</p></div><div class=paragraph><p>Wird mit der Variablen <code>static_routes</code> mehr als eine Variable angegeben, so werden auch mehrere Routen angelegt. Im folgenden Beispiel werden statische Routen zu den Netzwerken <code>192.168.0.0/24</code> und <code>192.168.1.0/24</code> angelegt.</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div><div class=sect3><h4 id=network-routing-troubleshooting>54.2.3. Problembehandlung<a class=anchor href=#network-routing-troubleshooting></a></h4><div class=paragraph><p>Wenn ein Adressraum einem Netzwerk zugeordnet wird, konfiguriert der Dienstanbieter seine Routing-Tabellen, so dass der gesamte Verkehr für das Netzwerk über die Verbindung zu der Seite gesendet wird. Aber woher wissen externe Webseiten, dass sie die Daten an das Netzwerk des ISP senden sollen?</p></div><div class=paragraph><p>Es gibt ein System, das alle zugewiesenen Adressräume verwaltet und die Verbindung zum Internet-Backbone definiert. Der "Backbone" ist das Netz aus Hauptverbindungen, die den Internetverkehr in der ganzen Welt transportieren und verteilen. Jeder Backbone-Rechner verfügt über eine Kopie von Master-Tabellen, die den Verkehr für ein bestimmtes Netzwerk hierarchisch vom Backbone über eine Kette von Dienstanbietern bis hin zu einem bestimmten Netzwerk leiten.</p></div><div class=paragraph><p>Es ist die Aufgabe des Dienstanbieters, den Backbone-Seiten mitzuteilen, dass sie mit einer Seite verbunden wurden. Dieser Vorgang wird als <em>Bekanntmachung von Routen</em> (routing propagation) bezeichnet.</p></div><div class=paragraph><p>Manchmal kommt es zu Problemen bei der Bekanntmachung von Routen, und einige Seiten sind nicht in der Lage, sich zu verbinden. Der vielleicht nützlichste Befehl, um festzustellen wo das Routing nicht funktioniert, ist <code>traceroute</code>. Das Programm ist nützlich, falls <code>ping</code> fehlschlägt.</p></div><div class=paragraph><p>Rufen Sie <code>traceroute</code> mit dem Namen des entfernten Rechners auf, mit dem eine Verbindung aufgebaut werden soll. Die Ausgabe zeigt die Gateway-Rechner entlang des Verbindungspfades an. Schließlich wird der Zielrechner erreicht oder es kommt zu einem Verbindungsabbruch. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect3><h4 id=network-routing-multicast>54.2.4. Multicast-Routing<a class=anchor href=#network-routing-multicast></a></h4><div class=paragraph><p>FreeBSD unterstützt sowohl Multicast-Anwendungen als auch Multicast-Routing. Multicast-Anwendungen benötigen keine spezielle Konfiguration, um auf FreeBSD lauffähig zu sein. Damit Multicast-Routing unterstützt wird, muss die folgende Option in der Kernelkonfiguration aktiviert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>Der Multicast-Routing-Daemon mrouted kann als Port oder Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net/mroute/>net/mroute</a> installiert werden. Dieser Daemon implementiert das DVMRP Multicast-Routing-Protokoll. Um die Tunnel und DVMRP einzurichten, muss <span class=filename>/usr/local/etc/mrouted.conf</span> bearbeitet werden. Bei der Installation von mrouted wird auch map-mbone und mrinfo sowie die zugehörigen Manualpages installiert, in denen Sie auch Konfigurationsbeispiele finden können.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>DVMRP wurde in vielen Multicast-Installationen weitgehend durch das PIM-Protokoll ersetzt. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=pim&amp;sektion=4&amp;format=html">pim(4)</a>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-wireless>54.3. Drahtlose Netzwerke<a class=anchor href=#network-wireless></a></h3><div class=sect3><h4 id=_grundlagen>54.3.1. Grundlagen<a class=anchor href=#_grundlagen></a></h4><div class=paragraph><p>Die meisten drahtlosen Netzwerke basieren auf dem Standard IEEE® 802.11. Ein einfaches drahtloses Netzwerk besteht aus Stationen, die im 2,4 GHz- oder im 5 GHz-Band miteinander kommunizieren. Es ist aber auch möglich, dass regional andere Frequenzen, beispielsweise im 2,3 GHz- oder 4,9 GHz-Band, verwendet werden.</p></div><div class=paragraph><p>802.11-Netzwerke können auf zwei verschiedene Arten aufgebaut sein: Im <em>Infrastruktur-Modus</em> agiert eine Station als Master, mit dem sich alle anderen Stationen verbinden. Die Summe aller Stationen wird als Basic Service Set (BSS), die Master-Station hingegen als Access Point (AP) bezeichnet. In einem BSS läuft jedwede Kommunikation über den Access Point. Die zweite Form drahtloser Netzwerke sind die sogenannten <em>Ad-hoc-Netzwerke</em> (auch als IBSS bezeichnet), in denen es keinen Access Point gibt und in denen die Stationen direkt miteinander kommunizieren.</p></div><div class=paragraph><p>Die ersten 802.11-Netzwerke arbeiteten im 2,4 GHz-Band und nutzten dazu Protokolle der IEEE®-Standards 802.11 sowie 802.11b. Diese Standards legen unter anderem Betriebsfrequenzen sowie Merkmale des MAC-Layers (wie Frames und Transmissionsraten) fest. Später kam der Standard 802.11a hinzu, der im 5 GHz-Band, im Gegensatz zu den ersten beiden Standards aber mit unterschiedlichen Signalmechanismen und höheren Transmissionsraten arbeitet. Der neueste Standard 802.11g implementiert die Signal- und Transmissionsmechanismen von 802.11a im 2,4 GHz-Band, ist dabei aber abwärtskompatibel zu 802.11b-Netzwerken.</p></div><div class=paragraph><p>Unabhängig von den zugrundeliegenden Transportmechanismen verfügen 802.11-Netzwerke über diverse Sicherheitsmechanismen. Der ursprüngliche 802.11-Standard definierte lediglich ein einfaches Sicherheitsprotokoll namens WEP. Dieses Protokoll verwendet einen fixen, gemeinsam verwendeten Schlüssel sowie die RC4-Kryptografie-Chiffre, um Daten verschlüsselt über das drahtlose Netzwerk zu senden. Alle Stationen des Netzwerks müssen sich auf den gleichen fixen Schlüssel einigen, um miteinander kommunizieren zu können. Dieses Schema ist sehr leicht zu knacken und wird deshalb heute kaum mehr eingesetzt. Aktuelle Sicherheitsmechanismen bauen auf dem Standard IEEE® 802.11i auf, der neue kryptographische Schlüssel (Chiffren), ein neues Protokoll für die Anmeldung von Stationen an einem Access Point, sowie Mechanismen zum Austausch von Schlüsseln als Vorbereitung der Kommunikation zwischen verschiedenen Geräten festlegt. Kryptografische Schlüssel werden in regelmäßigen Abständen aktualisiert. Außerdem gibt es Mechanismen zur Feststellung und Prävention von Einbruchsversuchen. Ein weiteres häufig verwendetes Sicherheitsprotokoll ist WPA. Dabei handelt es sich um einen Vorläufer von 802.11i, der von einem Industriekonsortium als Zwischenlösung bis zur endgültigen Verabschiedung von 802.11i entwickelt wurde. WPA definiert eine Untergruppe der Anforderungen des 802.11i-Standards und ist für den Einsatz in älterer Hardware vorgesehen. WPA benötigt nur den TKIP-Chiffre, welcher auf dem ursprünglichen WEP-Code basiert. 802.11i erlaubt zwar auch die Verwendung von TKIP, benötigt aber zusätzlich eine stärkere Chiffre (AES-CCM) für die Datenverschlüsselung. AES war für WPA nicht vorgesehen, weil man es als zu rechenintensiv für den Einsatz in älteren Geräten ansah.</p></div><div class=paragraph><p>Ein weiterer zu beachtender Standard ist 802.11e. Dieser definiert Protokolle zur Übertragung von Multimedia-Anwendungen, wie das Streaming von Videodateien oder Voice-over-IP (VoIP) in einem 802.11-Netzwerk. Analog zu 802.11i verfügt auch 802.11e über eine vorläufige Spezifikation namens WMM (ursprünglich WME), die von einem Industriekonsortium als Untergruppe von 802.11e spezifiziert wurde, um Multimedia-Anwendungen bereits vor der endgültigen Verabschiedung des 802.11e-Standards implementieren zu können. 802.11e sowie WME/WMM erlauben eine Prioritätenvergabe beim Datentransfer in einem drahtlosen Netzwerk. Möglich wird dies durch den Einsatz von Quality of Service-Protokollen (QoS) und erweiterten Medienzugriffsprotokollen. Werden diese Protokolle korrekt implementiert, erlauben sie hohe Datenübertragungsraten und einen priorisierten Datenfluss.</p></div><div class=paragraph><p>FreeBSD unterstützt die Standards 802.11a, 802.11b und 802.11g. Ebenfalls unterstützt werden WPA sowie die Sicherheitsprotokolle gemäß 802.11i (sowohl für 11a, 11b als auch 11g). QoS und Verkehrspriorisierung, die von den WME/WMM-Protokollen benötigt werden, werden für einen begrenzten Satz von drahtlosen Geräten unterstützt.</p></div></div><div class=sect3><h4 id=network-wireless-quick-start>54.3.2. Schnellstartanleitung<a class=anchor href=#network-wireless-quick-start></a></h4><div class=paragraph><p>Häufig soll ein Computer an ein vorhandenes Drahtlosnetzwerk angeschlossen werden. Diese Prozedur zeigt die dazu erforderlichen Schritte.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Besorgen Sie sich vom Netzwerkadministrator die SSID (Service Set Identifier) und den PSK (Pre Shared Key) für das Drahtlosnetzwerk.</p></li><li><p>Ermitteln Sie den drahtlosen Adapter. Der <span class=filename>GENERIC</span>-Kernel von FreeBSD enthält Treiber für viele gängige Adapter. Wenn der drahtlose Adapter eines dieser Modelle ist, wird das in der Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> angezeigt:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig | <span class=nb>grep</span> <span class=nt>-B3</span> <span class=nt>-i</span> wireless</code></pre></div></div><div class=paragraph><p>In FreeBSD 11 und neueren Versionen verwenden Sie stattdessen diesen Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl net.wlan.devices</code></pre></div></div><div class=paragraph><p>Wenn der drahtlose Adapter nicht aufgeführt wird, könnte ein zusätzliches Kernelmodul erforderlich sein. Es besteht jedoch auch die Möglichkeit, dass der Adapter von FreeBSD nicht unterstützt wird.</p></div><div class=paragraph><p>Dieses Beispiel verwendet einen drahtlosen Atheros-Adapter <code>ath0</code>.</p></div></li><li><p>Fügen Sie in <span class=filename>/etc/wpa_supplicant.conf</span> einen Eintrag für das Netzwerk hinzu. Wenn die Datei nicht existiert, müssen Sie diese erstellen. Ersetzen Sie <em>myssid</em> und <em>psk</em> durch die SSID und den PSK. Diese Informationen werden vom Netzwerkadministrator zur Verfügung gestellt.</p><div class="literalblock programlisting"><div class=content><pre>network={
	ssid=&#34;myssid&#34;
	psk=&#34;mypsk&#34;
}</pre></div></div></li><li><p>Fügen Sie die entsprechenden Einträge in <span class=filename>/etc/rc.conf</span> ein, um das Netzwerk beim Start zu konfigurieren:</p><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA SYNCDHCP&#34;</pre></div></div></li><li><p>Starten Sie den Computer oder den Netzwerkdienst neu, um sich mit dem Netzwerk zu verbinden:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div></li></ol></div></div><div class=sect3><h4 id=network-wireless-basic>54.3.3. Basiskonfiguration<a class=anchor href=#network-wireless-basic></a></h4><div class=sect4><h5 id=_kernelkonfiguration_2>54.3.3.1. Kernelkonfiguration<a class=anchor href=#_kernelkonfiguration_2></a></h5><div class=paragraph><p>Um ein drahtloses Netzwerk zu nutzen, wird eine drahtlose Netzwerkkarte benötigt und ein Kernel, der drahtlose Netzwerke unterstützt. Der Kernel unterstützt den Einsatz von Kernelmodulen. Daher muss nur die Unterstützung für die verwendeten Geräte aktiviert werden.</p></div><div class=paragraph><p>Die meisten drahtlosen Geräte verwenden Bauteile von Atheros und werden deshalb vom <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>-Treiber unterstützt. Um diesen Treiber zu verwenden, muss die folgende Zeile in <span class=filename>/boot/loader.conf</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>if_ath_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Der Atheros-Treiber besteht aus drei Teilen: dem Treiber selbst (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>), dem Hardware-Support-Layer für die chip-spezifischen Funktionen (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath_hal&amp;sektion=4&amp;format=html">ath_hal(4)</a>) sowie einem Algorithmus zur Auswahl der Frame-Übertragungsrate (ath_rate_sample). Wenn diese Unterstützung als Kernelmodul geladen wird, kümmert sich das Modul automatisch um Abhängigkeiten. Um die Unterstützung für ein anderes drahtloses Gerät zu laden, geben Sie das entsprechende Modul für dieses Gerät an. Dieses Beispiel zeigt die Verwendung von Geräten, die auf Bauteilen von Intersil Prism basieren und den Treiber <a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a> benötigen:</p></div><div class="literalblock programlisting"><div class=content><pre>if_wi_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Beispiele in diesem Abschnitt verwenden den <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>-Treiber. Verwenden Sie ein anderes Gerät, muss der Gerätename an die Konfiguration angepasst werden. Eine Liste aller verfügbaren Treiber und unterstützten drahtlosen Geräte finden sich in den FreeBSD Hardware Notes unter <a href=https://www.FreeBSD.org/releases/>Release Information</a> der FreeBSD Homepage. Gibt es keinen nativen FreeBSD-Treiber für das drahtlose Gerät, kann möglicherweise mit <a href=./#config-network-ndis>NDIS</a> ein Windows®-Treiber verwendet werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Zusätzlich müssen die Module zur Verschlüsselung des drahtlosen Netzwerks geladen werden. Diese werden normalerweise dynamisch vom <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a>-Modul geladen. Im folgenden Beispiel erfolgt allerdings eine manuelle Konfiguration. Folgende Module sind verfügbar: <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a>. Sowohl <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> als auch <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a> werden nur benötigt, wenn WPA und/oder die Sicherheitsprotokolle von 802.11i verwendet werden. Wenn das Netzwerk keine Verschlüsselung verwendet, wird die <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a>-Unterstützung nicht benötigt. Um diese Module beim Systemstart zu laden, fügen Sie folgende Zeilen in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>wlan_wep_load=&#34;YES&#34;
wlan_ccmp_load=&#34;YES&#34;
wlan_tkip_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Sobald diese Einträge in <span class=filename>/boot/loader.conf</span> vorhanden sind, muss das FreeBSD-System neu gestartet werden. Alternativ können die Kernelmodule auch manuell mit <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> geladen werden.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Benutzer, die keine Kernelmodule verwenden wollen, können die benötigten Treiber auch in den Kernel kompilieren. Dazu müssen die folgenden Zeilen in die Kernelkonfigurationsdatei aufgenommen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC&#39;s
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</pre></div></div><div class=paragraph><p>Mit diesen Informationen in der Kernelkonfigurationsdatei kann der Kernel neu gebaut, und das FreeBSD-System anschließend neu gestartet werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Informationen über das drahtlose Gerät sollten in den Boot-Meldungen folgendermaßen angezeigt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: <span class=o>[</span>ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</code></pre></div></div></div><div class=sect4><h5 id=_konfiguration_der_entsprechenden_region>54.3.3.2. Konfiguration der entsprechenden Region<a class=anchor href=#_konfiguration_der_entsprechenden_region></a></h5><div class=paragraph><p>Da die rechtliche Situation in verschiedenen Teilen der Welt unterschiedlich ist, ist es notwendig, die für Ihre Region geltenden Domänen korrekt einzustellen, um die richtigen Informationen darüber zu erhalten, welche Kanäle benutzt werden können.</p></div><div class=paragraph><p>Die verfügbaren Definitionen der Regionen finden Sie in <span class=filename>/etc/regdomain.xml</span>. Um die Daten zur Laufzeit einzustellen, benutzen Sie <code>ifconfig</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 regdomain ETSI country AT</span></code></pre></div></div><div class=paragraph><p>Um die Einstellungen beizubehalten, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc create_args_wlan0=&#34;country AT regdomain ETSI&#34;</span></code></pre></div></div></div></div><div class=sect3><h4 id=_infrastruktur_modus>54.3.4. Infrastruktur-Modus<a class=anchor href=#_infrastruktur_modus></a></h4><div class=paragraph><p>Drahtlose Netzwerke werden in der Regel im Infrastruktur-Modus (BSS) betrieben. Dazu werden mehrere drahtlose Access Points zu einem gemeinsamen drahtlosen Netzwerk verbunden. Jedes dieser drahtlosen Netzwerke hat einen eigenen Namen, der als >SSID> bezeichnet wird. Alle Clients eines drahtlosen Netzwerks verbinden sich in diesem Modus mit einem Access Point.</p></div><div class=sect4><h5 id=_freebsd_clients>54.3.4.1. FreeBSD-Clients<a class=anchor href=#_freebsd_clients></a></h5><div class=sect5><h6 id=_einen_access_point_finden>54.3.4.1.1. Einen Access Point finden<a class=anchor href=#_einen_access_point_finden></a></h6><div class=paragraph><p>Um nach verfügbaren drahtlosen Netzwerken zu suchen verwenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Dieser Scanvorgang kann einen Moment dauern, da jede verfügbare Frequenz auf verfügbare Access Points hin überprüft werden muss. Nur der Super-User kann einen Scanvorgang starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M <span class=nt>-90</span>:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-83</span>:96   100 EPS  WPA</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Netzwerkkarte muss in den Status <code>up</code> versetzt werden, bevor der erste Scanvorgang gestartet werden kann. Für spätere Scans ist dies aber nicht mehr erforderlich.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Als Ergebnis erhalten Sie eine Liste mit allen gefundenen BSS/IBSS-Netzwerken. Zusätzlich zum Namen des Netzwerks, der <code>SSID</code>, wird auch die <code>BSSID</code> ausgegeben. Dabei handelt es sich um die MAC-Adresse des Access Points. Das Feld <code>CAPS</code> gibt den Typ des Netzwerks sowie die Fähigkeiten der Stationen innerhalb des Netzwerks an:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 31. Station Capability Codes</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Capability Code</th><th class="tableblock halign-left valign-top">Bedeutung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>E</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Extended Service Set (ESS). Zeigt an, dass die Station Teil eines Infrastruktur-Netzwerks ist, und nicht eines IBSS/Ad-hoc-Netzwerks.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>I</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IBSS/Ad-hoc-Netzwerk. Die Station ist Teil eines Ad-hoc-Netzwerks und nicht eines ESS-Netzwerks.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>P</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Privacy. Alle Datenframes, die innerhalb des BSS ausgetauscht werden, sind verschlüsselt. Dieses BSS verwendet dazu kryptographische Verfahren wie WEP, TKIP oder AES-CCMP.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>S</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Short Preamble. Das Netzwerk verwendet eine kurze Präambel (definiert in 802.11b High Rate/DSSS PHY). Eine kurze Präambel verwendet ein 56 Bit langes Sync-Feld, im Gegensatz zu einer langen Präambel, die ein 128 Bit langes Sync-Feld verwendet.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>s</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Short slot time. Das 802.11g-Netzwerk verwendet eine kurze Slotzeit, da es in diesem Netzwerk keine veralteten (802.11b) Geräte gibt.</p></td></tr></tbody></table><div class=paragraph><p>Um eine Liste der bekannten Netzwerke auszugeben, verwenden Sie den folgenden Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 list scan</span></code></pre></div></div><div class=paragraph><p>Diese Liste kann entweder automatisch durch das drahtlose Gerät oder manuell durch eine <code>scan</code>-Aufforderung aktualisiert werden. Veraltete Informationen werden dabei automatisch entfernt.</p></div></div><div class=sect5><h6 id=_basiseinstellungen>54.3.4.1.2. Basiseinstellungen<a class=anchor href=#_basiseinstellungen></a></h6><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie eine drahtlose Netzwerkkarte ohne Verschlüsselung unter FreeBSD einrichten. Nachdem Sie sich mit den Informationen dieses Abschnitts vertraut gemacht haben, sollten Sie das drahtlose Netzwerk mit <a href=#network-wireless-wpa>WPA</a> verschlüsseln.</p></div><div class=paragraph><p>Das Einrichten eines drahtlosen Netzwerks erfolgt in drei Schritten: Der Auswahl eines Access Points, die Anmeldung der Station sowie der Konfiguration der IP-Adresse.</p></div><div class=sect6><h7 id=_einen_access_point_auswählen>54.3.4.1.2.1. Einen Access Point auswählen<a class=anchor href=#_einen_access_point_auswählen></a></h7><div class=paragraph><p>Im Normalfall wird sich die Station automatisch mit einem der zur Verfügung stehenden Access Points verbinden. Dazu muss lediglich das drahtlose Gerät aktiviert, oder in <span class=filename>/etc/rc.conf</span> eingetragen sein:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Stehen mehrere Access Points zur Verfügung, kann ein spezifischer durch Angabe der SSID gewählt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid Ihre_SSID DHCP&#34;</pre></div></div><div class=paragraph><p>Gibt es in einem Netzwerk mehrere Access Points mit der gleichen SSID, was das Routing vereinfacht, kann es notwendig sein, dass ein bestimmtes Gerät verbunden werden muss. Dazu muss lediglich die BSSID des Access Points angeben werden. Die Angabe der SSID ist hierbei nicht zwingend notwendig:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid Ihre_SSID bssid xx:xx:xx:xx:xx:xx DHCP&#34;</pre></div></div><div class=paragraph><p>Es gibt noch weitere Möglichkeiten, den Zugriff auf bestimmte Access Point zu beschränken, beispielsweise durch die Begrenzung der Frequenzen, auf denen eine Station nach einem Access Point sucht. Sinnvoll ist ein solches Vorgehen beispielsweise, wenn das drahtlose Gerät in verschiedenen Frequenzbereichen arbeiten kann, da in diesem Fall das Prüfen aller Frequenzen sehr zeitintensiv sein kann. Um nur innerhalb eines bestimmten Frequenzbereichs nach einem Access Point zu suchen, verwenden Sie die Option <code>mode</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;mode 11g ssid Ihre_SSID DHCP&#34;</pre></div></div><div class=paragraph><p>In diesem Beispiel sucht das drahtlose Gerät nur im 2,4 GHz-Band (802.11g), aber nicht innerhalb des 5 GHz-Bandes nach einem Access Point. Mit der Option <code>channel</code> kann eine bestimmte Frequenz vorgegeben werden, auf der gesucht werden soll. Die Option <code>chanlist</code> erlaubt die Angabe mehrerer erlaubter Frequenzen. Eine umfassende Beschreibung dieser Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect6><h7 id=_authentifizierung_2>54.3.4.1.2.2. Authentifizierung<a class=anchor href=#_authentifizierung_2></a></h7><div class=paragraph><p>Sobald ein Access Point gefunden wurde, muss sich die Station am Access Point authentifizieren, bevor Daten übertragen werden können. Dazu gibt es verschiedene Möglichkeiten. Am häufigsten wird die sogenannte <em>offene Authentifizierung</em> verwendet. Dabei wird es jeder Station erlaubt, sich mit einem Netzwerk zu verbinden und Daten zu übertragen. Aus Sicherheitsgründen sollte diese Methode allerdings nur zu Testzwecken bei der erstmaligen Einrichtung eines drahtlosen Netzwerks verwendet werden. Andere Authentifizierungsmechanismen erfordern den Austausch kryptographischer Informationen, bevor sie die Übertragung von Daten erlauben. Dazu gehören der Austausch fixer (vorher vereinbarter) Schlüssel oder Kennwörter, sowie der Einsatz komplexerer Verfahren mit Backend-Diensten wie RADIUS. Die offene Authentifizierung ist die Voreinstellung. Am zweithäufigsten kommt das im <a href=#network-wireless-wpa-wpa-psk>WPA-PSK</a> beschriebene WPA-PSK zum Einsatz, welches auch als WPA Personal bezeichnet wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Kommt eine Apple® AirPort® Extreme-Basisstation als Access Point zum Einsatz, muss sowohl die Shared-Key-Authentifizierung als auch ein WEP-Schlüssel konfiguriert werden. Die entsprechende Konfiguration erfolgt entweder in <span class=filename>/etc/rc.conf</span> oder über das Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Für eine einzelne AirPort®-Basisstation kann der Zugriff wie folgt konfiguriert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP&#34;</pre></div></div><div class=paragraph><p>Normalerweise sollte Shared-Key-Authentifizierung nicht verwendet werden, da diese die Sicherheit des WEP-Schlüssel noch weiter verringert. Wenn WEP für Kompatibilität mit älteren Geräten verwendet werden muss, ist es besser, WEP mit offener Authentifizierung zu verwenden. Weitere Informationen zu WEP finden Sie im <a href=#network-wireless-wep>WEP</a>.</p></div></td></tr></tbody></table></div></div><div class=sect6><h7 id=_eine_ip_adresse_über_dhcp_beziehen>54.3.4.1.2.3. Eine IP-Adresse über DHCP beziehen<a class=anchor href=#_eine_ip_adresse_über_dhcp_beziehen></a></h7><div class=paragraph><p>Sobald ein Access Point ausgewählt ist und die Authentifizierungsparameter festgelegt sind, wird eine IP-Adresse benötigt. In der Regel wird die IP-Adresse über DHCP bezogen. Um dies zu erreichen, bearbeiten Sie <span class=filename>/etc/rc.conf</span> und fügen Sie <code>DHCP</code> für das drahtlose Gerät in die Konfiguration hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Das drahtlose Gerät kann nun gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span></code></pre></div></div><div class=paragraph><p>Nachdem das Gerät aktiviert wurde, kann mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> der Status des Geräts <span class=filename>ath0</span> abgefragt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 <span class=o>(</span>2462 Mhz 11g<span class=o>)</span> bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</code></pre></div></div><div class=paragraph><p><code>status: associated</code> besagt, dass sich das Gerät mit dem drahtlosen Netzwerk verbunden hat. <code>bssid 00:13:46:49:41:76</code> ist die MAC-Adresse des Access Points und <code>authmode OPEN</code> zeigt an, dass die Kommunikation nicht verschlüsselt wird.</p></div></div><div class=sect6><h7 id=_statische_ip_adressen>54.3.4.1.2.4. Statische IP-Adressen<a class=anchor href=#_statische_ip_adressen></a></h7><div class=paragraph><p>Wenn eine IP-Adresse nicht von einem DHCP-Server bezogen werden kann, vergeben Sie eine statische IP-Adresse. Ersetzten Sie dazu das oben gezeigte Schlüsselwort <code>DHCP</code> durch die entsprechende IP-Adresse. Beachten Sie dabei, dass Sie die anderen Konfigurationsparameter nicht versehentlich verändern:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here&#34;</pre></div></div></div></div><div class=sect5><h6 id=network-wireless-wpa>54.3.4.1.3. WPA<a class=anchor href=#network-wireless-wpa></a></h6><div class=paragraph><p>Wi-Fi Protected Access (WPA) ist ein Sicherheitsprotokoll, das in 802.11-Netzwerken verwendet wird, um die fehlende Authentifizierung und Schwächen von WEP zu vermeiden. WPA stellt das aktuelle 802.1X-Authentifizierungsprotokoll dar und verwendet eine von mehreren Chiffren, um die Datensicherheit zu gewährleisten. Die einzige Chiffre, die von WPA verlangt wird, ist Temporary Key Integrity Protocol (TKIP). TKIP ist eine Chiffre, die die von WEP verwendete RC4-Chiffre um Funktionen zur Prüfung der Datenintegrität und zur Erkennung und Bekämpfung von Einbruchsversuchen erweitert. TKIP ist durch Softwaremodifikationen auch unter veralteter Hardware lauffähig. Im Vergleich zu WEP ist WPA zwar sehr viel sicherer, es ist aber dennoch nicht völlig immun gegen Angriffe. WPA definiert mit AES-CCMP noch eine weitere Chiffre als Alternative zu TKIP. AES-CCMP, welches häufig als WPA2 oder RSN bezeichnet wird, sollte bevorzugt eingesetzt werden.</p></div><div class=paragraph><p>WPA definiert Authentifizierungs- und Verschlüsselungsprotokolle. Die Authentifizierung erfolgt in der Regel über eine der folgenden Techniken: 802.1X gemeinsam mit einem Backend-Authentifizierungsdienst wie RADIUS, oder durch einen Minimal-Handshake zwischen der Station und dem Access Point mit einem vorher vereinbarten gemeinsamen Schlüssel. Die erste Technik wird als WPA Enterprise, die zweite hingegen als WPA Personal bezeichnet. Da sich der Aufwand für das Aufsetzen eines RADIUS-Backend-Servers für die meisten drahtlosen Netzwerke nicht lohnt, wird WPA in der Regel als WPA-PSK konfiguriert.</p></div><div class=paragraph><p>Die Kontrolle der drahtlosen Verbindung sowie das Aushandeln des Schlüssel, oder die Authentifizierung mit einem Server, erfolgt über <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Dieses Programm benötigt eine Konfigurationsdatei, <span class=filename>/etc/wpa_supplicant.conf</span>. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</p></div><div class=sect6><h7 id=network-wireless-wpa-wpa-psk>54.3.4.1.3.1. WPA-PSK<a class=anchor href=#network-wireless-wpa-wpa-psk></a></h7><div class=paragraph><p>WPA-PSK, das auch als WPA-Personal bekannt ist, basiert auf einem gemeinsamen, vorher vereinbarten Schlüssel (PSK), der aus einem Passwort generiert und danach als Master-Key des drahtlosen Netzwerks verwendet wird. Jeder Benutzer des drahtlosen Netzwerks verwendet daher <em>den gleichen</em> Schlüssel. WPA-PSK sollte nur in kleinen Netzwerken eingesetzt werden, in denen die Konfiguration eines Authentifizierungsservers nicht möglich oder erwünscht ist.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Achten Sie darauf, immer starke Passwörter zu verwenden, die ausreichend lang sind und auch Sonderzeichen enthalten, damit diese nicht leicht erraten oder umgangen werden können.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Der erste Schritt zum Einsatz von WPA-PSK ist die Konfiguration der SSID und des gemeinsamen Schlüssels des Netzwerks in <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  psk=&#34;freebsdmall&#34;
}</pre></div></div><div class=paragraph><p>Danach wird in <span class=filename>/etc/rc.conf</span> definiert, dass WPA zur Verschlüsselung eingesetzt werden soll und dass die IP-Adresse über DHCP bezogen wird:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Nun kann das drahtlose Gerät aktiviert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Alternativ kann das drahtlose Gerät manuell, mit Hilfe der Informationen aus <span class=filename>/etc/wpa_supplicant.conf</span> konfiguriert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:11:95:c3:0d:ac <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;freebsdap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2412 MHz<span class=o>)</span>
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac <span class=o>[</span><span class=nv>PTK</span><span class=o>=</span>CCMP <span class=nv>GTK</span><span class=o>=</span>CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed <span class=o>(</span>auth<span class=o>)</span> <span class=o>[</span><span class=nb>id</span><span class=o>=</span>0 <span class=nv>id_str</span><span class=o>=]</span></code></pre></div></div><div class=paragraph><p>Im zweiten Schritt starten Sie nun <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>, um eine IP-Adresse vom DHCP-Server zu beziehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient wlan0</span>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Enthält <span class=filename>/etc/rc.conf</span> bereits die Zeile <code>ifconfig_wlan0="DHCP"</code>, wird <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> automatisch gestartet, nachdem <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> sich mit dem Access Point verbunden hat.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sollte der Einsatz von DHCP nicht möglich oder nicht gewünscht sein, konfigurieren Sie eine statische IP-Adresse, nachdem <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> die Station authentifiziert hat:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</span>
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Falls DHCP nicht verwendet wird, müssen zusätzlich noch das Standard-Gateway sowie der Nameserver manuell festgelegt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default your_default_router</span>
<span class=c># echo &#34;nameserver your_DNS_server&#34; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-tls>54.3.4.1.3.2. WPA und EAP-TLS<a class=anchor href=#network-wireless-wpa-eap-tls></a></h7><div class=paragraph><p>Die zweite Möglichkeit, WPA einzusetzen, ist die Verwendung eines 802.1X-Backend-Authentifizierungsservers. Diese Variante wird als WPA-Enterprise bezeichnet, um sie vom weniger sicheren WPA-Personal abzugrenzen. Die bei WPA-Enterprise verwendete Authentifizierung basiert auf dem Extensible Authentication Protocol (EAP).</p></div><div class=paragraph><p>EAP selbst bietet keine Verschlüsselung, sondern operiert in einem verschlüsselten Tunnel. Es gibt verschiedene auf EAP basierende Authentifizierungsmethoden, darunter EAP-TLS, EAP-TTLS und EAP-PEAP.</p></div><div class=paragraph><p>EAP mit Transport Layers Security (EAP-TLS) ist ein sehr gut unterstütztes Authentifizierungsprotokoll, da es sich dabei um die erste EAP-Methode handelt, die von der <a href=http://www.wi-fi.org/>Wi-Fi Alliance</a> zertifiziert wurde. EAP-TLS erfordert drei Zertifikate: Das auf allen Rechnern installierte CA-Zertifikat, das Server-Zertifikat des Authentifizierungsservers, sowie ein Client-Zertifikat für jeden drahtlosen Client. Sowohl der Authentifizierungsservers als auch die drahtlosen Clients authentifizieren sich gegenseitig über Zertifikate, wobei sie überprüfen, ob diese Zertifikate auch von der Zertifizierungs-Authorität (CA) des jeweiligen Unternehmens signiert wurden.</p></div><div class=paragraph><p>Die Konfiguration erfolgt (analog zu WPA-PSK) über <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34; <i class=conum data-value=1></i><b>(1)</b>
  proto=RSN  <i class=conum data-value=2></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class=conum data-value=3></i><b>(3)</b>
  eap=TLS <i class=conum data-value=4></i><b>(4)</b>
  identity=&#34;loader&#34; <i class=conum data-value=5></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=6></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class=conum data-value=7></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class=conum data-value=8></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class=conum data-value=9></i><b>(9)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Der Name des Netzwerks (SSID).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Das als WPA2 bekannte RSN IEEE® 802.11i Protokoll wird verwendet.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Die <code>key_mgmt</code>-Zeile bezieht sich auf das verwendete Key-Management-Protokoll. In diesem Beispiel wird WPA gemeinsam mit der EAP-Authentifizierung verwendet.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Die für die Verbindung verwendete EAP-Methode.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Das <code>identity</code>-Feld enthält den von EAP verwendeten Identifizierungsstring.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Das Feld <code>ca_cert</code> gibt den Pfad zum CA-Zertifikat an. Diese Datei wird zur Verifizierung des Server-Zertifikats benötigt.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Die <code>client_cert</code>-Zeile gibt den Pfad zum Client-Zertifikat an. Jeder Client hat ein eigenes, innerhalb des Netzwerks eindeutiges, Zertifikat.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Das Feld <code>private_key</code> gibt den Pfad zum privaten Schlüssel des Client-Zertifikat an.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Das Feld <code>private_key_passwd</code> enthält die Passphrase für den privaten Schlüssel.</td></tr></tbody></table></div><div class=paragraph><p>Danach fügen Sie die folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Nun können Sie das drahtlose Gerät aktivieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Alternativ kann das drahtlose Gerät manuell mit <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> aktiviert werden.</p></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-ttls>54.3.4.1.3.3. WPA mit EAP-TTLS<a class=anchor href=#network-wireless-wpa-eap-ttls></a></h7><div class=paragraph><p>Bei EAP-TLS müssen sowohl der Authentifizierungsserver als auch die Clients jeweils ein eigenes Zertifikat aufweisen. Bei EAP-TTLS ist das Client-Zertifikat optional. EAP-TTLS geht dabei vor wie ein Webserver, der einen sicheren SSL-Tunnel erzeugen kann, ohne dass der Besucher dabei über ein clientseitiges Zertifikat verfügen muss. EAP-TTLS verwendet einen verschlüsselten TLS-Tunnel zum sicheren Transport der Authentifizierungsdaten.</p></div><div class=paragraph><p>Die erforderliche Konfiguration erfolgt in <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class=conum data-value=5></i><b>(5)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Die für die Verbindung verwendete EAP-Methode.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Das <code>identity</code>-Feld enthält den Identifizierungsstring für die EAP-Authentifizierung innerhalb des verschlüsselten TLS-Tunnels.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Das <code>password</code>-Feld enthält die Passphrase für die EAP-Authentifizierung.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Das Feld <code>ca_cert</code> gibt den Pfad zum CA-Zertifikat an. Diese Datei wird zur Verifizierung des Server-Zertifikats benötigt.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Die innerhalb des verschlüsselten TLS-Tunnels verwendete Authentifizierungsmethode. In Fall von PEAP ist dies <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>Folgende Zeilen müssen in <span class=filename>/etc/rc.conf</span> aufgenommen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Nun kann das drahtlose Gerät aktiviert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-peap>54.3.4.1.3.4. WPA mit EAP-PEAP<a class=anchor href=#network-wireless-wpa-eap-peap></a></h7><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>PEAPv0/EAP-MSCHAPv2 ist die gängigste PEAP-Methode. In diesem Kapitel wird der Begriff PEAP stellvertretend für diese Methode verwendet.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Protected EAP (PEAP) wurde als Alternative zu EAP-TTLS entwickelt und ist nach EAP-TLS der meist genutzte EAP-Standard. In einem Netzwerk mit verschiedenen Betriebssystemen sollte PEAP das am besten unterstützte Standard nach EAP-TLS sein.</p></div><div class=paragraph><p>PEAP arbeitet ähnlich wie EAP-TTLS. Es verwendet ein serverseitiges Zertifikat, um einen verschlüsselten TLS-Tunnel, über den die sichere Authentifizierung zwischen den Clients und dem Authentifizierungsserver erfolgt. In Sachen Sicherheit unterscheiden sich EAP-TTLS und PEAP allerdings: PEAP überträgt den Benutzernamen im Klartext und verschlüsselt nur das Passwort, während EAP-TTLS sowohl den Benutzernamen, als auch das Passwort über den TLS-Tunnel überträgt.</p></div><div class=paragraph><p>Um EAP-PEAP zu konfigurieren, fügen Sie die folgenden Zeilen in <span class=filename>/etc/wpa_supplicant.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34;  <i class=conum data-value=5></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class=conum data-value=6></i><b>(6)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Die für die Verbindung verwendete EAP-Methode.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Das <code>identity</code>-Feld enthält den Identifizierungsstring für die innerhalb des verschlüsselten TLS-Tunnels erfolgende EAP-Authentifizierung.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Das Feld <code>password</code> enthält die Passphrase für die EAP-Authentifizierung.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Das Feld <code>ca_cert</code> gibt den Pfad zum CA-Zertifikat an. Diese Datei wird zur Verifizierung des Server-Zertifikats benötigt.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Dieses Feld enthält die Parameter für die erste Phase der Authentifizierung, den TLS-Tunnel. Je nachdem, welcher Authentifizierungsserver benutzt wird, kann
ein spezifisches Label für die Authentifizierung verwendet werden. Meistens lautet das Label "client EAP encryption", dass durch <code>peaplabel=0</code> gesetzt wird. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Das innerhalb des verschlüsselten TLS-Tunnels verwendete Authentifizierungsprotokoll. In unserem Beispiel handelt es sich dabei um <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>Danach fügen Sie die folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_ath0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Nun kann das drahtlose Gerät aktiviert werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 MHz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div></div><div class=sect5><h6 id=network-wireless-wep>54.3.4.1.4. WEP<a class=anchor href=#network-wireless-wep></a></h6><div class=paragraph><p>Wired Equivalent Privacy (WEP) ist Teil des ursprünglichen 802.11-Standards. Es enthält keinen Authentifzierungsmechanismus und verfügt lediglich über eine schwache Zugriffskontrolle, die sehr leicht umgangen werden kann.</p></div><div class=paragraph><p>WEP kann über <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> aktiviert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \</span>
            ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012</code></pre></div></div><div class=ulist><ul><li><p><code>weptxkey</code> definiert den WEP-Schlüssel, der für die Datenübertragung verwendet wird. Dieses Beispiel verwendet den dritten Schlüssel. Der gleiche Schlüssel muss auch am Access Point eingestellt sein. Kennen Sie den vom Access Point verwendeten Schlüssel nicht, sollten Sie zuerst den Wert <code>1</code> (den ersten Schlüssel) für diese Variable verwenden.</p></li><li><p><code>wepkey</code> legt den zu verwendenden WEP-Schlüssel in der Form <em>Nummer:Schlüssel</em> fest. Schlüssel <code>1</code> wird standardmäßig verwendet. Die "Nummer" muss nur angegeben werden, wenn ein anderer als der erste Schlüssel verwendet werden soll.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ersetzen Sie <code>0x3456789012</code> durch den am Access Point konfigurierten Schlüssel.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class=paragraph><p>Das Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> eignet sich ebenfalls dazu, WEP für drahtlose Geräte zu aktivieren. Obige Konfiguration lässt sich dabei durch die Aufnahme der folgenden Zeilen in <span class=filename>/etc/wpa_supplicant.conf</span> realisieren:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;my_net&#34;
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</pre></div></div><div class=paragraph><p>Danach müssen Sie das Programm noch aufrufen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:13:46:49:41:76 <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;dlinkap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2437 MHz<span class=o>)</span>
Associated with 00:13:46:49:41:76</code></pre></div></div></div></div></div><div class=sect3><h4 id=_ad_hoc_modus>54.3.5. Ad-hoc-Modus<a class=anchor href=#_ad_hoc_modus></a></h4><div class=paragraph><p>Der IBSS-Modus, der auch als Ad-hoc-Modus bezeichnet wird, ist für Punkt-zu-Punkt-Verbindungen vorgesehen. Um beispielsweise eine Ad-hoc-Verbindung zwischen den Rechnern <code>A</code> und <code>B</code> aufzubauen, werden lediglich zwei IP-Adressen und eine SSID benötigt.</p></div><div class=paragraph><p>Auf Rechner <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>Der <code>adhoc</code>-Parameter zeigt an, dass die Schnittstelle im IBSS-Modus läuft.</p></div><div class=paragraph><p>Rechner <code>B</code> sollte nun in der Lage sein, Rechner <code>A</code> zu finden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 up scan</span>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M <span class=nt>-64</span>:-96  100 IS   WME</code></pre></div></div><div class=paragraph><p>Der Wert <code>I</code> (Spalte CAPS) in dieser Ausgabe bestätigt, dass sich Rechner <code>A</code> im Ad-hoc-Modus befindet. Nun müssen Sie noch Rechner <code>B</code> eine andere IP-Adresse zuweisen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>Damit sind die Rechner <code>A</code> und <code>B</code> bereit und können untereinander Daten austauschen.</p></div></div><div class=sect3><h4 id=network-wireless-ap>54.3.6. FreeBSD Host Access Points<a class=anchor href=#network-wireless-ap></a></h4><div class=paragraph><p>FreeBSD kann als Access Point (AP) agieren. Dies verhindert, dass man sich einen Hardware AP kaufen oder ein Ad-hoc Netzwerk laufen lassen muss. Dies kann sinnvoll sein, falls der FreeBSD-Computer als Gateway zu einem anderen Netzwerk, wie dem Internet, fungiert.</p></div><div class=sect4><h5 id=network-wireless-ap-basic>54.3.6.1. Grundeinstellungen<a class=anchor href=#network-wireless-ap-basic></a></h5><div class=paragraph><p>Bevor Sie einen FreeBSD-Computer als AP konfigurieren, muss der Kernel mit der entsprechenden Netzwerkunterstützung für die drahtlose Karte, sowie die Sicherheitsprotokolle konfiguriert werden. Weitere Informationen finden Sie im <a href=#network-wireless-basic>Basiskonfiguration</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Verwendung der NDIS Treiber für Windows® erlauben zur Zeit keinen AP-Modus. Nur die nativen FreeBSD-Wireless-Treiber unterstützen den AP-Modus.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nachdem die Netzwerkunterstützung geladen ist, überprüfen Sie, ob das Wireless-Gerät den hostbasierenden Access-Point Modus, der auch als hostap-Modus bekannt ist, unterstützt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 list caps</span>
<span class=nv>drivercaps</span><span class=o>=</span>6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
<span class=nv>cryptocaps</span><span class=o>=</span>1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</code></pre></div></div><div class=paragraph><p>Diese Ausgabe zeigt die Eigenschaften der Karte. Das Wort <code>HOSTAP</code> bestätigt, dass diese Wireless-Karte als AP agieren kann. Die verschiedenen unterstützten Algorithmen werden ebenfalls angezeigt: WEP, TKIP und AES. Diese Informationen zeigen an, welche Sicherheitsprotokolle auf dem AP nutzbar sind.</p></div><div class=paragraph><p>Das Wireless-Gerät kann nur während der Erzeugung des Pseudo-Geräts in den hostap-Modus gesetzt werden. Zuvor erstellte Pseudo-Geräte müssen also vorher zerstört werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 destroy</span></code></pre></div></div><div class=paragraph><p>Danach muss das Gerät erneut erstellt werden, bevor die restlichen Netzwerkparameter konfiguriert werden können:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie danach erneut <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, um den Status der <span class=filename>wlan0</span>-Schnittstelle abzufragen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>Die <code>hostap</code>-Parameter geben die Schnittstelle an, die im hostbasierenden Access Point Modus läuft.</p></div><div class=paragraph><p>Die Konfiguration der Schnittstelle kann durch Hinzufügen der folgenden Zeilen in die Datei <span class=filename>/etc/rc.conf</span> automatisch während des Bootvorganges erfolgen:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
create_args_wlan0=&#34;wlanmode hostap&#34;
ifconfig_wlan0=&#34;inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&#34;</pre></div></div></div><div class=sect4><h5 id=_hostbasierender_access_point_ohne_authentifizierung_oder_verschlüsselung>54.3.6.2. Hostbasierender Access Point ohne Authentifizierung oder Verschlüsselung<a class=anchor href=#_hostbasierender_access_point_ohne_authentifizierung_oder_verschlüsselung></a></h5><div class=paragraph><p>Obwohl es nicht empfohlen wird, einen AP ohne jegliche Authentifizierung oder Verschlüsselung laufen zu lassen, ist es eine einfache Art zu testen, ob der AP funktioniert. Diese Konfiguration ist auch wichtig für die Fehlersuche bei Client-Problemen.</p></div><div class=paragraph><p>Nachdem der AP konfiguriert wurde, ist es möglich von einem anderen drahtlosen Computer eine Suche nach dem AP zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-66</span>:-96  100 ES   WME</code></pre></div></div><div class=paragraph><p>Der Client-Rechner hat den AP gefunden und kann nun eine Verbindung aufbauen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
      scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
      roam:rate 5 protmode CTS wme burst</code></pre></div></div></div><div class=sect4><h5 id=network-wireless-ap-wpa>54.3.6.3. WPA2-hostbasierter Access Point<a class=anchor href=#network-wireless-ap-wpa></a></h5><div class=paragraph><p>Dieser Abschnitt beschäftigt sich mit der Konfiguration eines FreeBSD Access Point mit dem WPA2-Sicherheitsprotokoll. Weitere Einzelheiten zu WPA und der Konfiguration von Clients mit WPA finden Sie im <a href=#network-wireless-wpa>WPA</a>.</p></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>-Dienst wird genutzt, um die Client-Authentifizierung und das Schlüsselmanagement auf dem AP mit aktiviertem WPA2 zu nutzen.</p></div><div class=paragraph><p>Die folgende Konfiguration wird auf dem FreeBSD-Computer ausgeführt, der als AP agiert. Nachdem der AP korrekt arbeitet, sollte <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> automatisch beim Booten durch folgende Zeile in <span class=filename>/etc/rc.conf</span> aktiviert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>hostapd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Bevor Sie versuchen <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> zu konfigurieren, konfigurieren Sie zunächst die Grundeinstellungen, wie im <a href=#network-wireless-ap-basic>Grundeinstellungen</a> beschrieben.</p></div><div class=sect5><h6 id=_wpa2_psk>54.3.6.3.1. WPA2-PSK<a class=anchor href=#_wpa2_psk></a></h6><div class=paragraph><p>WPA2-PSK ist für kleine Netzwerke gedacht, in denen die Verwendung eines Authentifizierungs-Backend-Server nicht möglich oder nicht erwünscht ist.</p></div><div class=paragraph><p>Die Konfiguration wird in <span class=filename>/etc/hostapd.conf</span> durchgeführt:</p></div><div class="literalblock programlisting"><div class=content><pre>interface=wlan0                  <i class=conum data-value=1></i><b>(1)</b>
debug=1                          <i class=conum data-value=2></i><b>(2)</b>
ctrl_interface=/var/run/hostapd  <i class=conum data-value=3></i><b>(3)</b>
ctrl_interface_group=wheel       <i class=conum data-value=4></i><b>(4)</b>
ssid=freebsdap                   <i class=conum data-value=5></i><b>(5)</b>
wpa=2                            <i class=conum data-value=6></i><b>(6)</b>
wpa_passphrase=freebsdmall       <i class=conum data-value=7></i><b>(7)</b>
wpa_key_mgmt=WPA-PSK             <i class=conum data-value=8></i><b>(8)</b>
wpa_pairwise=CCMP                <i class=conum data-value=9></i><b>(9)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Die Wireless-Schnittstelle, die für den Access Point verwendet wird an.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Der debuglevel von <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> während der Ausführung. Ein Wert von <code>1</code> ist der kleinste zulässige Wert.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Der Pfadname des Verzeichnisses, der von <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> genutzt wird, um die Domain-Socket-Dateien zu speichern, die für die Kommunikation mit externen Programmen, wie z.B. <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd_cli&amp;sektion=8&amp;format=html">hostapd_cli(8)</a>, benutzt werden. In diesem Beispiel wird der Standardwert verwendet.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Die Gruppe die Zugriff auf die Schnittstellendateien hat.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Der Name des drahtlosen Netzwerks (SSID).</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Aktiviert WPA und gibt an welches WPA-Authentifizierungprotokoll benötigt wird. Ein Wert von <code>2</code> konfiguriert den AP mit WPA2. Setzen Sie den Wert nur auf <code>1</code>, wenn Sie das veraltete WPA benötigen.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Das ASCII-Passwort für die WPA-Authentifizierung.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Das verwendete Schlüsselmanagement-Protokoll. Dieses Beispiel nutzt WPA-PSK.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Die zulässigen Verschlüsselungsverfahren des Access-Points. In diesem Beispiel wird nur CCMP (AES) akzeptiert. CCMP ist eine Alternative zu TKIP und sollte wenn möglich eingesetzt werden. TKIP sollte nur da eingesetzt werden, wo kein CCMP möglich ist.</td></tr></tbody></table></div><div class=paragraph><p>Als nächstes wird hostapd gestartet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hostapd forcestart</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether 04:f0:21:16:8e:10
	inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
	nd6 <span class=nv>options</span><span class=o>=</span>21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
	media: IEEE 802.11 Wireless Ethernet autoselect mode 11na &lt;hostap&gt;
	status: running
	ssid No5ignal channel 36 <span class=o>(</span>5180 MHz 11a ht/40+<span class=o>)</span> bssid 04:f0:21:16:8e:10
	country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
	AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
	scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
	dtimperiod 1 <span class=nt>-dfs</span>
	<span class=nb>groups</span>: wlan</code></pre></div></div><div class=paragraph><p>Sobald der AP läuft, können sich die Clients mit ihm verbinden. Weitere Informationen finden Sie im <a href=#network-wireless-wpa>WPA</a>. Es ist möglich zu sehen, welche Stationen mit dem AP verbunden sind. Geben Sie dazu <code>ifconfig <em>wlan0</em> list sta</code> ein.</p></div></div></div><div class=sect4><h5 id=_wep_hostbasierter_access_point>54.3.6.4. WEP-hostbasierter Access Point<a class=anchor href=#_wep_hostbasierter_access_point></a></h5><div class=paragraph><p>Es ist nicht empfehlenswert, einen AP mit WEP zu konfigurieren, da es keine Authentifikationsmechanismen gibt und WEP leicht zu knacken ist. Einige ältere drahtlose Karten unterstützen nur WEP als Sicherheitsprotokoll. Diese Karten können nur mit einem AP ohne Authentifikation oder Verschlüsselung genutzt werden.</p></div><div class=paragraph><p>Das Wireless-Gerät kann nun in den hostap-Modus versetzt werden und mit der korrekten SSID und IP-Adresse konfiguriert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \</span>
  ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</code></pre></div></div><div class=ulist><ul><li><p>Der <code>weptxkey</code> zeigt an, welcher WEP-Schlüssel bei der Übertragung benutzt wird. In diesem Beispiel wird der dritte Schlüssel benutzt, da die Nummerierung bei <code>1</code> beginnt. Dieser Parameter muss angegeben werden, damit die Daten verschlüsselt werden.</p></li><li><p>Der <code>wepkey</code> gibt den gewählten WEP-Schlüssel an. Er sollte im folgenden Format <em>index:key</em> vorliegen. Wenn kein Index vorhanden ist, wird der Schlüssel <code>1</code> benutzt. Ansonsten muss der Index manuell festgelegt werden.</p></li></ul></div><div class=paragraph><p>Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> um den Status der <span class=filename>wlan0</span>-Schnittstelle erneut anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 4 <span class=o>(</span>2427 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
      txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>Es ist möglich, von einem anderen drahtlosen Computer eine Suche nach dem AP zu starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</code></pre></div></div><div class=paragraph><p>Der Client-Rechner hat den AP gefunden und kann nun eine Verbindung aufbauen. Weitere Informationen finden Sie im <a href=#network-wireless-wep>WEP</a>.</p></div></div></div><div class=sect3><h4 id=_benutzung_von_drahtgebundenen_und_drahtlosen_verbindungen>54.3.7. Benutzung von drahtgebundenen und drahtlosen Verbindungen<a class=anchor href=#_benutzung_von_drahtgebundenen_und_drahtlosen_verbindungen></a></h4><div class=paragraph><p>Eine Verbindung per Kabel bietet eine bessere Leistung und eine höhere Zuverlässigkeit, während die Wireless-Verbindung eine höhere Flexibilität und Mobilität bietet. Benutzer von Laptops wollen normalerweise beides nutzen und zwischen beiden Verbindungen hin und her schalten.</p></div><div class=paragraph><p>Unter FreeBSD ist es möglich zwei oder mehr Netzwerkschnittstellen in einem "failover"-Mode zu kombinieren. Diese Konfiguration nutzt die beste verfügbare Verbindung aus einer Gruppe von Netzwerkverbindungen. Sobald sich der Linkstatus ändert, wechselt das Betriebssystem automatisch auf eine andere Verbindung.</p></div><div class=paragraph><p>Link-Aggregation und Failover werden im <a href=#network-aggregation>Link-Aggregation und Failover</a> behandelt. Ein Beispiel für die Verwendung von kabelgebundenen und drahtlosen Verbindungen gibt es im <a href=#networking-lagg-wired-and-wireless>Failover Modus zwischen Ethernet- und drahtlosen Schnittstellen</a>.</p></div></div><div class=sect3><h4 id=_problembehandlung>54.3.8. Problembehandlung<a class=anchor href=#_problembehandlung></a></h4><div class=paragraph><p>Dieser Abschnitt beschreibt eine Reihe von Maßnahmen zur Behebung von alltäglichen Problemen mit Drahtlosnetzwerken.</p></div><div class=ulist><ul><li><p>Wird der Access Point bei der Suche nicht gefunden, überprüfen Sie, dass die Konfiguration des drahtlosen Geräts nicht die Anzahl der Kanäle beschränkt.</p></li><li><p>Wenn sich das Gerät nicht mit dem Access Point verbinden kann, überprüfen Sie, ob die Konfiguration der Station auch der des Access Points entspricht. Dazu gehören auch die Authentifzierungsmethode und die Sicherheitsprotokolle. Halten Sie die Konfiguration so einfach wie möglich. Wenn Sie ein Sicherheitsprotokoll wie WPA oder WEP verwenden, können Sie testweise den Access Point auf <em>offene Authentifizierung</em> und <em>keine Sicherheit</em> einstellen.</p><div class=paragraph><p>Für die Fehlersuche steht <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> zur Verfügung. Starten Sie das Programm manuell mit der Option <code>-dd</code> und durchsuchen Sie anschließend die Systemprotokolle nach eventuellen Fehlermeldungen.</p></div></li><li><p>Sobald sich das Gerät mit dem Access Point verbinden kann, prüfen Sie die Netzwerkkonfiguration mit einfachen Werkzeugen wie <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>.</p></li><li><p>Zusätzlich gibt es auch zahlreiche Low-Level-Debugging-Werkzeuge. Die Ausgabe von Debugging-Informationen des 802.11 Protocol Support Layers lassen sich mit dem Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=wlandebug&amp;sektion=8&amp;format=html">wlandebug(8)</a> aktivieren. Um beispielsweise während der Suche nach Access Points und des Aufbaus von 802.11-Verbindungen (Handshake) auftretende Systemmeldungen auf die Konsole auszugeben, verwenden Sie den folgenden Befehl:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wlandebug -i wlan0 +scan+auth+debug+assoc</span>
  net.wlan.0.debug: 0 <span class=o>=&gt;</span> 0xc80000&lt;assoc,auth,scan&gt;</code></pre></div></div><div class=paragraph><p>Der 802.11-Layer liefert umfangreiche Statistiken, die mit dem Werkzeug <code>wlanstats</code>, das sich in <span class=filename>/usr/src/tools/tools/net80211</span> befindet, abgerufen werden können. Diese Statistiken sollten alle Fehler identifizieren, die im 802.11-Layer auftreten. Beachten Sie aber, dass einige Fehler bereits im darunterliegenden Gerätetreiber auftreten und daher in diesen Statistiken nicht enthalten sind. Wie Sie Probleme des Gerätetreibers identifizieren, entnehmen Sie bitte der Dokumentation des Gerätetreibers.</p></div></li></ul></div><div class=paragraph><p>Wenn die oben genannten Informationen nicht helfen das Problem zu klären, erstellen Sie einen Problembericht, der die Ausgabe der weiter oben genannten Werkzeuge beinhaltet.</p></div></div></div><div class=sect2><h3 id=network-usb-tethering>54.4. USB Tethering<a class=anchor href=#network-usb-tethering></a></h3><div class=paragraph><p>Viele Mobiltelefone bieten die Möglichkeit, ihre Datenverbindung über USB (oft "Tethering" genannt) zu teilen. Diese Funktion verwendet entweder das RNDIS-, CDC- oder ein Apple® iPhone®/iPad®-Protokoll.</p></div><div class=ulist><ul><li><p>Android™-Geräte benutzen in der Regel den <a href="https://man.freebsd.org/cgi/man.cgi?query=urndis&amp;sektion=4&amp;format=html">urndis(4)</a>-Treiber.</p></li><li><p>Apple®-Geräte benutzen den <a href="https://man.freebsd.org/cgi/man.cgi?query=ipheth&amp;sektion=4&amp;format=html">ipheth(4)</a>-Treiber.</p></li><li><p>Ältere Geräte benutzen oft den <a href="https://man.freebsd.org/cgi/man.cgi?query=cdce&amp;sektion=4&amp;format=html">cdce(4)</a>-Treiber.</p></li></ul></div><div class=paragraph><p>Bevor Sie ein Gerät anschließen, laden Sie den entsprechenden Treiber in den Kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_urndis</span>
<span class=c># kldload if_cdce</span>
<span class=c># kldload if_ipheth</span></code></pre></div></div><div class=paragraph><p>Sobald das Gerät angeschlossen ist, steht es unter <code>ue</code><em>0</em> wie ein normales Netzwerkgerät zur Verfügung. Stellen Sie sicher, dass die Option "USB Tethering" auf dem Gerät aktiviert ist.</p></div><div class=paragraph><p>Um diese Änderungen dauerhaft zu speichern und den Treiber beim Booten als Modul zu laden, müssen die entsprechenden Zeilen in <span class=filename>/boot/loader.conf</span> konfiguriert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>if_urndis_load=&#34;YES&#34;
if_cdce_load=&#34;YES&#34;
if_ipteth_load=&#34;YES&#34;</pre></div></div></div><div class=sect2><h3 id=network-bluetooth>54.5. Bluetooth<a class=anchor href=#network-bluetooth></a></h3><div class=paragraph><p>Bluetooth ermöglicht die Bildung von persönlichen Netzwerken über drahtlose Verbindungen bei einer maximalen Reichweite von 10 Metern und operiert im unlizensierten 2,4-GHz-Band. Solche Netzwerke werden normalerweise spontan gebildet, wenn sich mobile Geräte, wie Mobiltelefone, Handhelds oder Notebooks miteinander verbinden. Im Gegensatz zu Wireless LAN ermöglicht Bluetooth auch höherwertige Dienste, wie FTP-ähnliche Dateiserver, Filepushing, Sprachübertragung, Emulation von seriellen Verbindungen und mehr.</p></div><div class=paragraph><p>Dieses Kapitel beschreibt die Verwendung von USB-Bluetooth-Adaptern in FreeBSD. Weiterhin werden verschiedene Bluetooth-Protokolle und Programme vorgestellt.</p></div><div class=sect3><h4 id=_die_bluetooth_unterstützung_aktivieren>54.5.1. Die Bluetooth-Unterstützung aktivieren<a class=anchor href=#_die_bluetooth_unterstützung_aktivieren></a></h4><div class=paragraph><p>Der Bluetooth-Stack von FreeBSD verwendet das <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a>-Framework. Viele Bluetooth-USB-Adapter werden durch den <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>-Treiber unterstützt. Auf dem Chip BCM2033 von Broadcom basierende Bluetooth-Geräte werden von den Treibern <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> unterstützt. Die Bluetooth-PC-Card 3CRWB60-A von 3Com verwendet den <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a>-Treiber. Serielle sowie auf UART basierende Bluetooth-Geräte werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a> unterstützt.</p></div><div class=paragraph><p>Bevor ein Gerät angeschlossen wird, muss der entsprechende Treiber in den Kernel geladen werden. Hier verwendet das Gerät den <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>-Treiber:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>Ist das Bluetooth-Gerät beim Systemstart angeschlossen, kann das entsprechende Modul bei Booten geladen werden, indem der entsprechende Treiber in <span class=filename>/boot/loader.conf</span> hinzugefügt wird:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Sobald der Treiber geladen ist, schließen Sie den USB-Adapter an. Eine Meldung ähnlich der folgenden wird auf der Konsole und in <span class=filename>/var/log/messages</span> erscheinen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class=paragraph><p>Verwenden Sie das Startskript zum Starten und Beenden des Bluetooth-Stacks. Es ist empfehlenswert, den Bluetooth-Stack zu beenden, bevor Sie den Adapter entfernen. Das Starten des Bluetooth-Stacks kann das Starten von <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> erfordern. Wenn Sie den Bluetooth-Stack starten, erhalten Sie eine Meldung ähnlich der folgenden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></div><div class=sect3><h4 id=_suche_nach_anderen_bluetooth_geräten>54.5.2. Suche nach anderen Bluetooth-Geräten<a class=anchor href=#_suche_nach_anderen_bluetooth_geräten></a></h4><div class=paragraph><p>Das Host Controller Interface (HCI) bietet eine einheitliche Methode für den Zugriff auf Bluetooth-Basisband-Funktionen. In FreeBSD wird ein netgraph HCI-Knoten für jedes Bluetooth-Gerät erstellt. Weitere Einzelheiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a>.</p></div><div class=paragraph><p>Eine der wichtigsten Aufgaben ist das Auffinden von sich in Reichweite befindenden Bluetooth-Geräten. Diese Funktion wird als <em>inquiry</em> bezeichnet. Inquiry sowie andere mit HCI in Verbindung stehende Funktionen werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a> zur Verfügung gestellt. Das folgende Beispiel zeigt, wie man herausfindet, welche Bluetooth-Geräte sich in Reichweite befinden. Eine solche Abfrage dauert nur wenige Sekunden. Beachten Sie, dass ein Gerät nur dann antwortet, wenn es sich im Modus <em>discoverable</em> befindet.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p><code>BD_ADDR</code> stellt, ähnlich der MAC-Adresse einer Netzwerkkarte, die eindeutige Adresse eines Bluetooth-Gerätes dar. Diese Adresse ist für die Kommunikation mit dem Gerät nötig. Es ist aber auch möglich, <code>BD_ADDR</code> einen Klartextnamen zuzuweisen. <span class=filename>/etc/bluetooth/hosts</span> enthält Informationen über die bekannten Bluetooth-Rechner. Das folgende Beispiel zeigt, wie man den Klartextnamen eines entfernten Geräts in Erfahrung bringen kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>Wenn Sie ein entferntes Bluetooth-Gerät abfragen, wird dieses den Rechner unter dem Namen "your.host.name (ubt0)" finden. Dieser Name kann aber jederzeit geändert werden.</p></div><div class=paragraph><p>Entfernten Geräten können Aliase in <span class=filename>/etc/bluetooth/hosts</span> zugewiesen werden. Weitere Informationen zu <span class=filename>/etc/bluetooth/hosts</span> finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=bluetooth.hosts&amp;sektion=5&amp;format=html">bluetooth.hosts(5)</a>.</p></div><div class=paragraph><p>Bluetooth ermöglicht Punkt-zu-Punkt-Verbindungen an denen nur zwei Bluetooth-Geräte beteiligt sind, aber auch Punkt-zu-Multipunkt-Verbindungen, bei denen eine Verbindung von mehreren Bluetooth-Geräten gemeinsam genutzt wird. Das folgende Beispiel zeigt, wie man eine Verbindung zu einem entferntem Gerät aufbauen kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci create_connection BT_ADDR</code></pre></div></div><div class=paragraph><p><code>create_connection</code> aktzeptiert <code>BT_ADDR</code> oder auch einen Alias aus <span class=filename>/etc/bluetooth/hosts</span>.</p></div><div class=paragraph><p>Das folgende Beispiel zeigt, wie man die aktiven Basisbandverbindungen des lokalen Gerätes anzeigen kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>Ein <em>connection handle</em> ist für die Beendigung einer Basisbandverbindung nützlich. Im Normalfall werden inaktive Verbindungen aber automatisch vom Bluetooth-Stack getrennt.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Rufen Sie <code>hccontrol help</code> auf, wenn Sie eine komplette Liste aller verfügbaren HCI-Befehle benötigen. Die meisten dieser Befehle müssen nicht als <code>root</code> ausgeführt werden.</p></div></div><div class=sect3><h4 id=_erstmaliger_verbindungsaufbau_zwischen_zwei_bluetooth_geräten_pairing>54.5.3. Erstmaliger Verbindungsaufbau zwischen zwei Bluetooth-Geräten (Pairing)<a class=anchor href=#_erstmaliger_verbindungsaufbau_zwischen_zwei_bluetooth_geräten_pairing></a></h4><div class=paragraph><p>In der Voreinstellung nutzt Bluetooth keine Authentifizierung, daher kann sich jedes Bluetoothgerät mit jedem anderen Gerät verbinden. Ein Bluetoothgerät, wie beispielsweise ein Mobiltelefon, kann jedoch für einen bestimmten Dienst, etwa eine Einwählverbindung, eine Authentifizierung anfordern. Bluetooth verwendet zu diesem Zweck <em>PIN-Codes</em>. Ein PIN-Code ist ein maximal 16 Zeichen langer ASCII-String. Damit eine Verbindung zustande kommt, muss auf beiden Geräten der gleiche PIN-Code verwendet werden. Nachdem der Code eingegeben wurde, erzeugen beide Geräte einen <em>link key</em>, der auf den Geräten gespeichert wird. Beim nächsten Verbindungsaufbau wird der zuvor erzeugte Link Key verwendet. Diesen Vorgang bezeichnet man als Pairing. Geht der Link Key auf einem Gerät verloren, muss das Pairing wiederholt werden.</p></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>-Daemon verarbeitet Bluetooth-Authentifzierungsanforderungen und wird über die Datei <span class=filename>/etc/bluetooth/hcsecd.conf</span> konfiguriert. Der folgende Ausschnitt dieser Datei zeigt die Konfiguration für ein Mobiltelefon, das den PIN-Code "1234" verwendet:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>Von der Länge abgesehen, unterliegen PIN-Codes keinen Einschränkungen. Einige Geräte, beispielsweise Bluetooth-Headsets, haben einen festen PIN-Code eingebaut. Die Option <code>-d</code> sorgt dafür, dass der <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>-Daemon im Vordergrund läuft. Dadurch kann der Ablauf einfach verfolgt werden. Stellen Sie das entfernte Gerät auf receive pairing und initiieren Sie die Bluetoothverbindung auf dem entfernten Gerät. Sie erhalten die Meldung, dass Pairing akzeptiert wurde und der PIN-Code benötigt wird. Geben Sie den gleichen PIN-Code ein, den Sie in <span class=filename>hcsecd.conf</span> festgelegt haben. Der Computer und das entfernte Gerät sind nun miteinander verbunden. Alternativ können Sie das Pairing auch auf dem entfernten Gerät initiieren.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> kann durch das Einfügen der folgenden Zeile in <span class=filename>/etc/rc.conf</span> beim Systemstart automatisch aktiviert werden:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Es folgt nun eine beispielhafte Ausgabe des <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>-Daemons:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect3><h4 id=_einwahlverbindungen_und_netzwerkverbindungen_mit_ppp_profilen_einrichten>54.5.4. Einwahlverbindungen und Netzwerkverbindungen mit PPP-Profilen einrichten<a class=anchor href=#_einwahlverbindungen_und_netzwerkverbindungen_mit_ppp_profilen_einrichten></a></h4><div class=paragraph><p>Ein Dial-Up Networking-Profil (DUN) kann dazu benutzt werden, ein Mobiltelefon als drahtloses Modem zu nutzen, um sich über einen Einwahlprovider mit dem Internet zu verbinden. Es kann auch dazu genutzt werden, einen Computer so zu konfigurieren, dass dieser Datenabfragen empfängt.</p></div><div class=paragraph><p>Der Zugriff auf ein Netzwerk über ein PPP-Profil kann einen Zugriff auf das LAN für ein oder mehrere Bluetooth-Geräte bieten. Eine PC-zu-PC-Verbindung unter Verwendung einer PPP-Verbindung über eine serielle Verbindung ist ebenfalls möglich.</p></div><div class=paragraph><p>Diese Profile werden unter FreeBSD durch <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> implementiert - einem Wrapper, der Bluetooth-Verbindungen unter PPP nutzbar macht. Bevor ein Profil verwendet werden kann, muss ein neuer PPP-Abschnitt in <span class=filename>/etc/ppp/ppp.conf</span> erzeugt werden. Beispielkonfigurationen zu diesem Thema finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>.</p></div><div class=paragraph><p>Dieses Beispiel verwendet <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>, um eine Verbindung zu einem entfernten Gerät mit der <code>BD_ADDR 00:80:37:29:19:a4</code> auf dem RFCOMM-Kanal <code>DUN</code> aufzubauen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>Die aktuelle Kanalnummer des entfernten Geräts erhalten Sie über das SDP-Protokoll. Es ist auch möglich, manuell einen RFCOMM-Kanal festzulegen. In diesem Fall führt <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> keine SDP-Abfrage durch. Verwenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a>, um die RFCOMM-Kanäle des entfernten Geräts herauszufinden.</p></div><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>-Server muss laufen, damit ein Netzzugriff mit dem PPPLAN-Profil möglich ist. Außerdem muss für den LAN-Client ein neuer Eintrag in <span class=filename>/etc/ppp/ppp.conf</span> erzeugt werden. Beispielkonfigurationen zu diesem Thema finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Danach starten Sie den RFCOMMPPP-Server über eine gültige RFCOMM-Kanalnummer. Der RFCOMMPPP-Server bindet dadurch den Bluetooth-LAN-Dienst an den lokalen SDP-Daemon. Das folgende Beispiel zeigt, wie man den RFCOMMPPP-Server startet.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect3><h4 id=_bluetooth_protokolle>54.5.5. Bluetooth-Protokolle<a class=anchor href=#_bluetooth_protokolle></a></h4><div class=paragraph><p>Dieser Abschnitt gibt einen Überblick über die verschiedenen Bluetooth-Protokolle, ihre Funktionen sowie weitere Programme.</p></div><div class=sect4><h5 id=_das_logical_link_control_and_adaptation_protocol_l2cap>54.5.5.1. Das Logical Link Control and Adaptation Protocol (L2CAP)<a class=anchor href=#_das_logical_link_control_and_adaptation_protocol_l2cap></a></h5><div class=paragraph><p>Das Logical Link Control and Adaptation Protocol (L2CAP) bietet höherwertigen Protokollen verbindungsorientierte und verbindungslose Datendienste an. L2CAP erlaubt höherwertigen Protokollen und Programmen den Versand und Empfang von L2CAP-Datenpaketen mit einer Länge von bis zu 64 Kilobytes.</p></div><div class=paragraph><p>L2CAP arbeitet _kanal_basiert. Ein Kanal ist eine logische Verbindung innerhalb einer Basisbandverbindung. Jeder Kanal ist dabei an ein einziges Protokoll gebunden. Mehrere Geräte können an das gleiche Protokoll gebunden sein, es ist aber nicht möglich, einen Kanal an mehrere Protokolle zu binden. Jedes über einen Kanal ankommende L2CAP-Paket wird an das entsprechende höherwertige Protokoll weitergeleitet. Mehrere Kanäle können sich die gleiche Basisbandverbindung teilen.</p></div><div class=paragraph><p>Unter FreeBSD wird eine netgraph-Gerätedatei vom Typ <em>l2cap</em> für jedes einzelne Bluetooth-Gerät erzeugt. Diese Gerätedatei ist normalerweise mit der Bluetooth-HCI-Gerätedatei (downstream) sowie der Bluetooth-Socket-Gerätedatei (upstream) verbunden. Der Standardname für die L2CAP-Gerätedatei lautet "devicel2cap". Weitere Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a>.</p></div><div class=paragraph><p>Ein nützlicher Befehl zum Anpingen von anderen Geräten ist <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>. Einige Bluetooth-Geräte senden allerdings nicht alle erhaltenen Daten zurück. Die Ausgabe <code>0 bytes</code> im folgenden Beispiel ist also kein Fehler:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>Das Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> liefert Informationen über L2CAP-Dateien. Das folgende Beispiel zeigt, wie man die Liste der logischen Verbindungen (Kanäle) sowie die Liste der Basisbandverbindungen abfragen kann:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a> ist ein weiteres Diagnoseprogramm. Es funktioniert ähnlich wie <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>, arbeitet aber mit Bluetooth-Datenstrukturen. Das folgende Beispiel zeigt die gleiche Liste der logischen Verbindungen wie <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> im vorherigen Beispiel.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect4><h5 id=_radio_frequency_communication_rfcomm>54.5.5.2. Radio Frequency Communication (RFCOMM)<a class=anchor href=#_radio_frequency_communication_rfcomm></a></h5><div class=paragraph><p>Das RFCOMM-Protokoll emuliert serielle Verbindungen über das L2CAP-Protokoll. Bei RFCOMM handelt es sich um ein einfaches Transportprotokoll, das um Funktionen zur Emulation der 9poligen Schaltkreise von mit RS-232 (EIATIA-232-E) kompatiblen seriellen Ports ergänzt wurde. Es erlaubt bis zu 60 simultane Verbindungen (RFCOMM-Kanäle) zwischen zwei Bluetooth-Geräten.</p></div><div class=paragraph><p>Eine RFCOMM-Kommunikation besteht aus zwei Anwendungen (den Kommunikationsendpunkten), die über das Kommunikationssegment miteinander verbunden sind. RFCOMM unterstützt Anwendungen, die auf serielle Ports angewiesen sind. Das Kommunikationssegment entspricht der direkten Bluetooth-Verbindung zwischen den beiden Geräten.</p></div><div class=paragraph><p>RFCOMM kümmert sich um die direkte Verbindung von zwei Geräten, oder um die Verbindung zwischen einem Gerät und einem Modem über eine Netzwerkverbindung. RFCOMM unterstützt auch andere Konfigurationen. Ein Beispiel dafür sind Module, die drahtlose Bluetooth-Geräte mit einer verkabelten Schnittstelle verbinden können.</p></div><div class=paragraph><p>Unter FreeBSD ist das RFCOMM-Protokoll im Bluetooth Socket-Layer implementiert.</p></div></div><div class=sect4><h5 id=_das_service_discovery_protocol_sdp>54.5.5.3. Das Service Discovery Protocol (SDP)<a class=anchor href=#_das_service_discovery_protocol_sdp></a></h5><div class=paragraph><p>Das Service Discovery Protocol (SDP) erlaubt es Clientanwendungen, von Serveranwendungen angebotene Dienste sowie deren Eigenschaften abzufragen. Zu diesen Eigenschaften gehören die Art oder die Klasse der angebotenen Dienste sowie der Mechanismus oder das Protokoll, die zur Nutzung des Dienstes notwendig sind.</p></div><div class=paragraph><p>SDP ermöglicht Verbindungen zwischen einem SDP-Server und einem SDP-Client. Der Server enthält eine Liste mit den Eigenschaften der vom Server angebotenen Dienste. Jeder Eintrag beschreibt jeweils einen einzigen Serverdienst. Ein Client kann diese Informationen durch eine SDP-Anforderung vom SDP-Server beziehen. Wenn der Client oder eine Anwendung des Clients einen Dienst nutzen will, muss eine separate Verbindung mit dem Dienstanbieter aufgebaut werden. SDP bietet einen Mechanismus zum Auffinden von Diensten und deren Eigenschaften an, es bietet aber keine Mechanismen zur Verwendung dieser Dienste.</p></div><div class=paragraph><p>Normalerweise sucht ein SDP-Client nur nach Diensten, die bestimmte geforderte Eigenschaften erfüllen. Es ist aber auch möglich, anhand der Dienstbeschreibungen eine allgemeine Suche nach den von einem SDP-Server angebotenen Diensten durchzuführen. Diesen Vorgang bezeichnet man als Browsing.</p></div><div class=paragraph><p>Der Bluetooth-SDP-Server <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> und der Kommandozeilenclient <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> sind bereits in der Standardinstallation von FreeBSD enthalten. Das folgende Beispiel zeigt, wie eine SDP-Abfrage durchgeführt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class=paragraph><p>Beachten Sie, dass jeder Dienst eine Liste seiner Eigenschaften, wie etwa den RFCOMM-Kanal, zurückgibt. Je nachdem, welche Dienste der Benutzer benötigt, sollten einige dieser Eigenschaften notiert werden. Einige Bluetooth-Implementationen unterstützen kein Service Browsing und geben daher eine leere Liste zurück. Ist dies der Fall, ist es dennoch möglich, nach einem bestimmten Dienst zu suchen. Das folgende Beispiel demonstriert die Suche nach dem OBEX Object Push (OPUSH) Dienst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>Unter FreeBSD ist es die Aufgabe des <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>-Servers, Bluetooth-Clients verschiedene Dienste anzubieten. Sie können diesen Server durch das Einfügen der folgenden Zeile in <span class=filename>/etc/rc.conf</span> aktivieren:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Nun kann der <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>-Daemon durch folgende Eingabe gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sdpd start</span></code></pre></div></div><div class=paragraph><p>Der lokale Server, der den entfernten Clients Bluetooth-Dienste anbieten soll, bindet diese Dienste an den lokalen SDP-Daemon. Ein Beispiel für eine solche Anwendung ist <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Einmal gestartet, wird der Bluetooth-LAN-Dienst an den lokalen SDP-Daemon gebunden.</p></div><div class=paragraph><p>Die Liste der vorhandenen Dienste, die am lokalen SDP-Server registriert sind, lässt sich durch eine SDP-Abfrage über einen lokalen Kontrollkanal abfragen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect4><h5 id=_obex_object_push_opush>54.5.5.4. OBEX Object-Push (OPUSH)<a class=anchor href=#_obex_object_push_opush></a></h5><div class=paragraph><p>OBEX ist ein häufig verwendetes Protokoll für den Dateitransfer zwischen Mobilgeräten. Sein Hauptzweck ist die Kommunikation über die Infrarotschnittstelle. Es dient daher zum Datentransfer zwischen Notebooks oder PDAs sowie zum Austausch von Visitenkarten oder Kalendereinträgen zwischen Mobiltelefonen und anderen Geräten mit PIM-Funktionen.</p></div><div class=paragraph><p>Server und Client von OBEX werden durch obexapp bereitgestellt, das als Paket oder Port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a> installiert werden kann.</p></div><div class=paragraph><p>Mit dem OBEX-Client werden Objekte zum OBEX-Server geschickt oder angefordert. Ein Objekt kann etwa eine Visitenkarte oder ein Termin sein. Der OBEX-Client fordert über SDP die Nummer des RFCOMM-Kanals vom entfernten Gerät an. Dies kann auch durch die Verwendung des Servicenamens anstelle der RFCOMM-Kanalnummer erfolgen. Folgende Dienste werden unterstützt: <code>IrMC</code>, <code>FTRN</code> und <code>OPUSH</code>. Es ist möglich, den RFCOMM-Kanal als Nummer anzugeben. Es folgt ein Beispiel für eine OBEX-Sitzung, bei der ein Informationsobjekt vom Mobiltelefon angefordert und ein neues Objekt (hier eine Visitenkarte) an das Telefonbuch des Mobiltelefons geschickt wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Um OBEX-Push-Dienste anbieten zu können, muss der sdpd-Server gestartet sein. Ein Wurzelverzeichnis, in dem alle ankommenden Objekte gespeichert werden, muss zusätzlich angelegt werden. In der Voreinstellung ist dies <span class=filename>/var/spool/obex</span>. Starten Sie den OBEX-Server mit einer gültigen Kanalnummer. Der OBEX-Server registriert nun den OBEX-Push-Dienst mit dem lokalen SDP-Daemon. Das folgende Beispiel zeigt, wie der OBEX-Server gestartet wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect4><h5 id=_das_serial_port_profil_spp>54.5.5.5. Das Serial-Port Profil (SPP)<a class=anchor href=#_das_serial_port_profil_spp></a></h5><div class=paragraph><p>Das Serial Port Profile (SSP) ermöglicht es Bluetooth-Geräten eine serielle Kabelverbindung zu emulieren. Anwendungen sind dadurch in der Lage, über eine virtuelle serielle Verbindung Bluetooth als Ersatz für eine Kabelverbindung zu nutzen.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> implementiert unter FreeBSD SSP und ein Pseudo-tty, das als virtuelle serielle Verbindung verwendet wird. Das folgende Beispiel zeigt, wie man eine Verbindung mit einem entfernten Serial-Port-Dienst herstellt. Ein RFCOMM-Kanal muss dabei nicht angegeben werden, da <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> den Kanal über SDP abfragen kann. Um dies zu umgehen, geben Sie einen RFCOMM-Kanal auf der Kommandozeile an.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t</span>
rfcomm_sppd[94692]: Starting on /dev/pts/6...
/dev/pts/6</code></pre></div></div><div class=paragraph><p>Sobald die Verbindung hergestellt ist, kann pseudo-tty als serieller Port verwenden werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/pts/6</span></code></pre></div></div><div class=paragraph><p>Das pseudo-tty wird auf der Standardausgabe ausgegeben und kann von Wrapper-Skripten gelesen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
cu -l $PTS</pre></div></div></div></div><div class=sect3><h4 id=_problembehandlung_2>54.5.6. Problembehandlung<a class=anchor href=#_problembehandlung_2></a></h4><div class=paragraph><p>Wenn FreeBSD eine neue Verbindung akzeptiert, versucht es, die Rolle zu tauschen, um zum Master zu werden. Einige ältere Geräte, die dies nicht unterstützen, können keine Verbindung aufbauen. Da der Rollentausch ausgeführt wird sobald eine neue Verbindung aufgebaut wird, ist es nicht möglich, das entfernte Gerät zu fragen ob es den Rollentausch unterstützt. Es gibt jedoch eine HCI-Option, die dieses Verhalten deaktiviert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div><div class=paragraph><p>Verwenden Sie hcidump, das als Paket Port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a> installiert werden kann, um Bluetooth-Pakete anzuzeigen. Dieses Programm hat Ähnlichkeiten mit <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> und kann zur Anzeige der Bluetooth-Pakete in einem Terminal, oder zur Speicherung von Paketen in einer Datei (Dump) verwendet werden.</p></div></div></div><div class=sect2><h3 id=network-bridging>54.6. LAN-Kopplung mit einer Bridge<a class=anchor href=#network-bridging></a></h3><div class=paragraph><p>Manchmal ist es nützlich, ein Netzwerk, wie ein Ethernetsegment, in separate Netzwerke aufzuteilen, ohne gleich IP-Subnetze zu erzeugen, die über einen Router miteinander verbunden sind. Ein Gerät, das zwei Netze auf diese Weise verbindet, wird als "Bridge" bezeichnet.</p></div><div class=paragraph><p>Eine Bridge arbeitet, indem sie die MAC-Adressen der Geräte in ihren Netzwerksegmenten lernt. Der Verkehr wird nur dann zwischen zwei Segmenten weitergeleitet, wenn sich Sender und Empfänger in verschiedenen Netzwerksegmenten befinden. Jedes FreeBSD-System mit zwei Netzwerkkarten kann als Bridge fungieren.</p></div><div class=paragraph><p>Bridging kann in den folgenden Situationen sinnvoll sein:</p></div><div class=dlist><dl><dt class=hdlist1>Verbinden von Netzwerken</dt><dd><p>Die Hauptaufgabe einer Bridge ist die Verbindung von zwei oder mehreren Netzwerksegmenten. Es gibt viele Gründe, eine hostbasierte Bridge einzusetzen, anstelle von Netzwerkkomponenten, wie beispielsweise Kabelverbindungen oder Firewalls. Eine Bridge kann außerdem ein drahtloses Gerät mit einem Kabelnetzwerk verbinden. Diese Fähigkeit der Bridge wird als HostAP-Modus bezeichnet. Die Bridge agiert in diesem Fall als Access Point für das drahtlose Gerät.</p></dd><dt class=hdlist1>Filtering / Traffic Shaping Firewall</dt><dd><p>Eine Bridge kann eingesetzt werden, wenn Firewallfunktionen benötigt werden, ohne dabei Routing oder Network Adress Translation (NAT) zu verwenden.</p><div class=paragraph><p>Ein Beispiel dafür wäre ein kleines Unternehmen, das über DSL oder ISDN an einen ISP angebunden ist. Es verfügt über 13 erreichbare IP-Adressen und das Netzwerk besteht aus 10 Rechnern. In dieser Situation ist der Einsatz von Subnetzen sowie einer routerbasierten Firewall aufgrund der IP-Adressierung schwierig. Eine Bridge-basierte Firewall kann hingegen ohne Probleme konfiguriert werden.</p></div></dd><dt class=hdlist1>Netzwerküberwachung</dt><dd><p>Eine Bridge kann zwei Netzwerksegmente miteinander verbinden und danach alle Ethernet-Rahmen überprüfen, die zwischen den beiden Netzwerksegmenten ausgetauscht werden. Dazu verwendet man entweder <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> auf dem Netzgerät der Bridge oder schickt Kopien aller Rahmen an ein zusätzliches Netzgerät, das als Span Port bekannt ist.</p></dd><dt class=hdlist1>Layer 2 VPN</dt><dd><p>Zwei Ethernetnetzwerke können über einen IP-Link miteinander verbunden werden, indem die beiden Netzwerke über einen EtherIP-Tunnel gekoppelt werden, oder eine <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a>-basierte Lösung wie OpenVPN eingesetzt wird.</p></dd><dt class=hdlist1>Layer 2 Redundanz</dt><dd><p>Die Systeme eines Netzwerks können über das Spanning Tree Protocol (STP) redundant miteinander verbunden sein, um redundante Pfade zu blockieren.</p></dd></dl></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie ein FreeBSD-System mit Hilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> als Bridge konfiguriert wird. Ein netgraph-Bridge-Treiber ist ebenfalls verfügbar und wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bridge&amp;sektion=4&amp;format=html">ng_bridge(4)</a> beschrieben.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Paketfilter können mit allen Firewallpaketen verwendet werden, die das <a href="https://man.freebsd.org/cgi/man.cgi?query=pfil&amp;sektion=9&amp;format=html">pfil(9)</a>-Framework benutzen. Eine Bridge kann auch als Traffic Shaper verwendet werden, wenn Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> einsetzen.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_die_bridge_aktivieren>54.6.1. Die Bridge aktivieren<a class=anchor href=#_die_bridge_aktivieren></a></h4><div class=paragraph><p>In FreeBSD handelt es sich bei <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> um ein Kernelmodul, das von <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> automatisch geladen wird, wenn eine Bridge-Schnittstelle erzeugt wird. Es ist auch möglich, die Unterstützung für den Treiber in den Kernel zu kompilieren, indem die Zeile <code>device if_bridge</code> in die Kernelkonfigurationsdatei hinzugefügt wird.</p></div><div class=paragraph><p>Eine Bridge wird durch das Klonen von Schnittstellen erzeugt. Um eine Bridge zu erzeugen, verwenden Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge create</span>
bridge0
<span class=c># ifconfig bridge0</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:00:00:00:00:00 priority 0 ifcost 0 port 0</code></pre></div></div><div class=paragraph><p>Wenn eine Bridge erzeugt wird, erhält sie automatisch eine zufällig generierte Ethernet-Adresse. Die Parameter <code>maxaddr</code> sowie <code>timeout</code> legen fest, wie viele MAC-Adressen die Bridge in ihrer Forward-Tabelle halten kann und wie viele Sekunden jeder Eintrag erhalten bleiben soll, nachdem er zuletzt verwendet wurde. Die restlichen Parameter sind für die Konfiguration von STP notwendig.</p></div><div class=paragraph><p>Im nächsten Schritt werden die Schnittstellen, die die Bridge verbinden soll, zugewiesen. Damit die Bridge Datenpakete weiterleiten kann, müssen sowohl die Bridge als auch die Schnittstellen der zu verbindenden Netzwerksegmente aktiviert sein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 up</span>
<span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span></code></pre></div></div><div class=paragraph><p>Jetzt ist die Bridge in der Lage, Ethernet-Rahmen zwischen den Schnittstellen <span class=filename>fxp0</span> und <span class=filename>fxp1</span> weiterzuleiten. Um diese Konfiguration beim Systemstart automatisch zu aktivieren, müssen die folgenden Zeilen in <span class=filename>/etc/rc.conf</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;addm fxp0 addm fxp1 up&#34;
ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;</pre></div></div><div class=paragraph><p>Wenn die Bridge eine IP-Adresse benötigt, muss diese der Schnittstelle der Bridge zugewiesen werden und nicht der Schnittstelle der gekoppelten Netzwerksegmente. Die IP-Adresse kann manuell gesetzt, oder über DHCP bezogen werden. Dieses Beispiel verwendet eine statische IP-Adresse:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>Es ist auch möglich der Bridge-Schnittstelle eine IPv6-Adresse zuzuweisen. Um die Änderungen dauerhaft zu speichern, fügen Sie die Adressinformationen in <span class=filename>/etc/rc.conf</span> ein.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nachdem ein Paketfilter aktiviert wurde, können Datenpakete, die von den Schnittstellen der gekoppelten Netzwerksegmente gesendet und empfangen werden, über die Bridge weitergeleitet oder nach bestimmten Regeln gefiltert oder auch komplett geblockt werden. Ist die Richtung des Paketflusses wichtig, ist es am besten, eine Firewall auf den Schnittstellen der einzelnen Netzwerksegmente einzurichten und nicht auf der Bridge selbst.</p></div><div class=paragraph><p>Eine Bridge verfügt über verschiedene Optionen zur Weiterleitung von Nicht-IP- und IP-Paketen, sowie Paketfilterung auf Layer 2 mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_spanning_tree_aktivieren>54.6.2. Spanning Tree aktivieren<a class=anchor href=#_spanning_tree_aktivieren></a></h4><div class=paragraph><p>Damit ein Ethernet-Netzwerk richtig funktioniert, kann nur ein aktiver Pfad zwischen zwei Geräten existieren. Das STP-Protokoll erkennt Schleifen in einer Netzwerktopologie und setzt redundante Pfade in einen blockierten Zustand. Sollte eine der aktiven Verbindungen ausfallen, berechnet STP einen anderen Baum und ermöglicht es dann einem blockierten Pfad, alle Netzwerkverbindungen wiederherzustellen.</p></div><div class=paragraph><p>Das Rapid Spanning Tree Protocol (RSTP oder 802.1w), ist abwärtskompatibel zum veralteten STP. RSTP arbeitet schneller und tauscht Informationen mit benachbarten Switchen aus, um Pakete korrekt weiterzuleiten und eine Schleifenbildung zu verhindern. FreeBSD unterstützt die Betriebsmodi RSTP und STP, wobei RSTP als Standardmodus voreingestellt ist.</p></div><div class=paragraph><p>STP kann auf den Schnittstellen der durch die Bridge verbundenen Netzwerksegmente mittels <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> aktiviert werden. Für eine Bridge, die die Schnittstellen <span class=filename>fxp0</span> und <span class=filename>fxp1</span> verbindet, aktivieren Sie STP wie folgt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 stp fxp0 stp fxp1</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>Diese Bridge hat die Spanning-Tree-ID <code>00:01:02:4b:d4:50</code> und die Priorität <code>32768</code>. Da diese ID mit der <code>Root-ID</code> identisch ist, handelt es sich um die Root-Bridge dieses Netzwerks.</p></div><div class=paragraph><p>Auf einer anderen Bridge des Netzwerks ist STP ebenfalls aktiviert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>Die Zeile <code>root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4</code> zeigt an, dass die Root-Bridge die ID <code>00:01:02:4b:d4:50</code> hat. Die Pfadkosten hin zur Root-Bridge betragen <code>400000</code>, wobei der Pfad zur Root-Bridge über <code>port 4</code> geht, der wiederum der Schnittstelle <span class=filename>fxp0</span> entspricht.</p></div></div><div class=sect3><h4 id=_parameter_der_bridge_schnittstelle>54.6.3. Parameter der Bridge-Schnittstelle<a class=anchor href=#_parameter_der_bridge_schnittstelle></a></h4><div class=paragraph><p>Einige Parameter von <code>ifconfig</code> dienen ausschließlich der Konfiguration von Bridge-Schnittstellen. Dieser Abschnitt fasst die Verwendung dieser Parameter zusammen. Die vollständige Liste der verfügbaren Parameter wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> beschrieben.</p></div><div class=dlist><dl><dt class=hdlist1>private</dt><dd><p>Eine private Schnittstelle leitet keine Daten an einen Port weiter, bei dem es sich ebenfalls um eine private Schnittstelle handelt. Der Datenverkehr wird dabei komplett blockiert, auch Ethernet-Rahmen und ARP-Pakete werden nicht weitergeleitet. Wollen Sie hingegen nur spezifische Datenpakete blockieren, sollten Sie eine Firewall einsetzen.</p></dd><dt class=hdlist1>span</dt><dd><p>Ein Span Port übertragt eine Kopie jedes Ethernet-Rahmens, der an der Bridge ankommt. Auf einer Bridge können beliebig viele Span Ports festgelegt werden. Wird eine Schnittstelle als Span Port konfiguriert, kann sie nicht mehr als normaler Bridge-Port verwendet werden. Eine derartige Konfiguration ist beispielsweise sinnvoll, um den Datenverkehr, der in einem Netzwerk über die Bridge läuft, auf einen Rechner zu übertragen, der mit einem Span Port der Bridge verbunden ist. Um beispielsweise eine Kopie aller Ethernet-Rahmen über die Schnittstelle <span class=filename>fxp0</span> zu übertragen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 span fxp4</span></code></pre></div></div></dd><dt class=hdlist1>sticky</dt><dd><p>Wenn die Schnittstelle eines über eine Bridge verbundenen Netzwerksegments als sticky gekennzeichnet wird, werden alle dynamisch gelernten Adressen als statische Adressen behandelt, sobald sie in den Forward-Cache der Bridge aufgenommen wurden. Sticky-Einträge werden niemals aus dem Cache entfernt oder ersetzt. Selbst dann nicht, wenn die Adresse von einer anderen Schnittstelle verwendet wird. Sie können dadurch die Vorteile statischer Adresseinträge nutzen, ohne die Forward-Tabelle vor dem Einsatz der Bridge mit statischen Einträgen füllen zu müssen. Clients, die sich in einem bestimmten von der Bridge verwalteten Segmente befinden, können dabei nicht in ein anderes Segment wechseln.</p><div class=paragraph><p>Ein Beispiel für den Einsatz von Sticky-Adressen ist die Kombination einer Bridge mit mehreren VLANs, um einen Router zu konfigurieren, der einzelne Kundennetzwerke voneinander trennt, ohne dabei IP-Adressbereiche zu verschwenden. Für das folgende Beispiel nehmen wir an, dass sich der Client <code>CustomerA</code> im VLAN <code>vlan100</code> und der Client <code>CustomerB</code> im VLAN <code>vlan101</code> befinden. Die Bridge hat die IP-Adresse <code>192.168.0.1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</span>
<span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>In diesem Beispiel sehen beide Clients <code>192.168.0.1</code> als das Default-Gateway. Da der Brücken-Cache <em>sticky</em> ist, sind Sie nicht dazu in der Lage, die MAC-Adresse des anderen Kunden zu spoofen und dessen Datenverkehr abzufangen.</p></div><div class=paragraph><p>Sie können die Kommunikation zwischen den VLANs vollständig unterbinden, wenn Sie private Schnittstellen oder eine Firewall einsetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 private vlan100 private vlan101</span></code></pre></div></div><div class=paragraph><p>Die Kunden sind nun komplett voneinander isoliert und der komplette <code>/24</code>-Adressbereich kann zugewiesen werden, ohne dass Subnetze eingesetzt werden.</p></div><div class=paragraph><p>Die maximale mögliche Anzahl an eindeutigen MAC-Adressen hinter einer Schnittstelle kann festgelegt werden. Sobald das Limit erreicht ist, werden Pakete mit einer unbekannten Quell-Adresse solange verworfen, bis ein existierender Eintrag gelöscht wird oder abläuft.</p></div><div class=paragraph><p>Das folgende Beispiel setzt die maximale Anzahl von Netzgeräten für <code>CustomerA</code> für das VLAN <code>vlan100</code> auf 10.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 ifmaxaddr vlan100 10</span></code></pre></div></div></dd></dl></div><div class=paragraph><p>Die Bridge unterstützt auch den Monitormodus. Dabei werden alle Pakete verworfen, nachdem sie von <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> verarbeitet wurden. In diesem Modus erfolgt keine weitere Bearbeitung und auch keine Weiterleitung von Datenpaketen. Es ist daher möglich, die Eingabe von zwei oder mehr Netzwerkschnittstellen in einen einzigen gemeinsamen <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>-Stream zu vereinen. Ein solcher Datenstrom ist beispielsweise nützlich, um den Datenverkehr für "network taps" zu rekonstruieren, die ihre RX/TX-Signale über verschiedene Schnittstellen senden. Um beispielsweise die Eingabe von vier Netzwerkschnittstellen in einzigen gemeinsamen Datenstrom zu vereinen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</span>
<span class=c># tcpdump -i bridge0</span></code></pre></div></div></div><div class=sect3><h4 id=_snmp_monitoring>54.6.4. SNMP-Monitoring<a class=anchor href=#_snmp_monitoring></a></h4><div class=paragraph><p>Die Schnittstelle der Bridge sowie die STP-Parameter können durch den im Basissystem enthaltenen <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> überwacht werden. Die exportierten Bridge-MIBs entsprechen den IETF-Standards, daher kann ein beliebiger SNMP-Client oder ein beliebiges Monitoring-Werkzeug eingesetzt werden, um die benötigten Daten zu erhalten.</p></div><div class=paragraph><p>Um das Monitoring auf der Bridge zu aktivieren, kommentieren Sie diese Zeile in <span class=filename>/etc/snmpd.config</span> aus, indem Sie das Zeichen <code>#</code> entfernen:</p></div><div class="literalblock programlisting"><div class=content><pre>begemotSnmpdModulePath.&#34;bridge&#34; = &#34;/usr/lib/snmp_bridge.so&#34;</pre></div></div><div class=paragraph><p>Weitere Konfigurationsparameter wie Community-Namen und Zugriffslisten müssen ebenfalls in dieser Datei angepasst werden. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=snmp_bridge&amp;sektion=3&amp;format=html">snmp_bridge(3)</a>. Nachdem die Änderungen gespeichert wurden, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>bsnmpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Danach starten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bsnmpd start</span></code></pre></div></div><div class=paragraph><p>Die folgenden Beispiele verwenden das Softwarepaket Net-SNMP (<a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/net-snmp/>net-mgmt/net-snmp</a>), um die Bridge vom Client aus abzufragen. Alternativ kann auch der Port <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/bsnmptools/>net-mgmt/bsnmptools</a> benutzt werden. Auf dem SNMP-Client müssen danach die folgenden Zeilen in <span class=filename>$HOME/.snmp/snmp.conf</span> hinzugefügt werden, um die MIB-Definitionen der Bridge in Net-SNMP zu importieren:</p></div><div class="literalblock programlisting"><div class=content><pre>mibdirs +/usr/shared/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</pre></div></div><div class=paragraph><p>Um eine einzelne Bridge über den IETF BRIDGE-MIB (RFC4188) zu überwachen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 <span class=o>=</span> STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 <span class=o>=</span> INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 <span class=o>=</span> Timeticks: <span class=o>(</span>189959<span class=o>)</span> 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 <span class=o>=</span> Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 <span class=o>=</span> INTEGER: forwarding<span class=o>(</span>5<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortEnable.3 <span class=o>=</span> INTEGER: enabled<span class=o>(</span>1<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortPathCost.3 <span class=o>=</span> INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 <span class=o>=</span> INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 <span class=o>=</span> Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 <span class=o>=</span> Counter32: 1
RSTP-MIB::dot1dStpVersion.0 <span class=o>=</span> INTEGER: rstp<span class=o>(</span>2<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Der Wert der Variable <code>dot1dStpTopChanges.0</code> ist hier 2, die STP-Topologie der Bridge wurde also bereits zweimal geändert. Unter einer Änderung versteht man die Anpassung eines oder mehrerer Links und die Kalkulation eines neuen Baums. Der Wert der Variable <code>dot1dStpTimeSinceTopologyChange.0</code> gibt an, wann dies zuletzt geschah.</p></div><div class=paragraph><p>Um mehrere Bridge-Schnittstellen zu überwachen, kann der private BEGEMOT-BRIDGE-MIB eingesetzt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>116927<span class=o>)</span> 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>82773<span class=o>)</span> 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 50 8B B8 C6 A9</code></pre></div></div><div class=paragraph><p>Um die über den <code>mib-2.dot1dBridge</code>-Subtree überwachte Bridge-Schnittstelle zu ändern:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpset <span class=nt>-v</span> 2c <span class=nt>-c</span> private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</code></pre></div></div></div></div><div class=sect2><h3 id=network-aggregation>54.7. Link-Aggregation und Failover<a class=anchor href=#network-aggregation></a></h3><div class=paragraph><p>Die von FreeBSD unterstützte <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>-Schnittstelle erlaubt die Gruppierung von mehreren Netzwerkadaptern als eine virtuelle Schnittstelle, mit dem Ziel, Ausfallsicherheit (Failover) und Link Aggregation bereitzustellen. Bei Failover kann der Verkehr auch dann weiter fließen, wenn nur eine Schnittstelle verfügbar ist. Link Aggregation funktioniert am besten mit Switches, die LCAP unterstützen, da dieses Protokoll den Datenverkehr bidirektional verteilt, während es auch auf den Ausfall einzelner Verbindungen reagiert.</p></div><div class=paragraph><p>Die von der lagg-Schnittstelle unterstützten Protokolle bestimmen, welche Ports für den ausgehenden Datenverkehr benutzt werden, und ob ein bestimmter Port eingehenden Datenverkehr akzeptiert. Die folgenden Protokolle werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> unterstützt:</p></div><div class=dlist><dl><dt class=hdlist1>Failover (Ausfallsicherheit)</dt><dd><p>Dieser Modus sendet und empfängt Datenverkehr nur auf dem Masterport. Sollte der Masterport nicht zur Verfügung stehen, wird der nächste aktive Port verwendet. Der zuerst hinzugefügte Adapter der virtuellen Schnittstelle wird zum Masterport, jeder weitere Adapter dient als Gerät zur Ausfallsicherheit. Wenn ein Failover auf einem Nicht-Master Port stattfindet, wird der ursprüngliche Port wieder zum Master-Port, sobald er wieder verfügbar ist.</p></dd><dt class=hdlist1>fec / loadbalance (Lastverteilung)</dt><dd><p>Cisco® Fast EtherChannel® (FEC) findet sich auf älteren Cisco® Switches. Es bietet eine statische Konfiguration und handelt weder Aggregation mit der Gegenstelle aus, noch werden Frames zur Überwachung der Verbindung ausgetauscht. Wenn der Switch LACP unterstützt, sollte diese Option auch verwendet werden.</p></dd><dt class=hdlist1>lacp</dt><dd><p>Das IEEE® 802.3ad Link-Aggregation Control Protokoll (LACP). Mit LACP wird eine Menge von aggregierbaren Verbindungen mit der Gegenstelle in einer oder mehreren Link Aggregated Groups (LAG) ausgehandelt. Jede LAG besteht aus Ports der gleichen Geschwindigkeit, eingestellt auf Voll-Duplex-Betrieb. Der Verkehr wird über die Ports in der LAG mit der größten Gesamtgeschwindigkeit balanciert. Typischerweise gibt es nur eine LAG, die alle Ports enthält. Im Falle von Änderungen in der physischen Anbindung wird LACP schnell zu einer neuen Konfiguration konvergieren.</p><div class=paragraph><p>LACP balanciert ausgehenden Verkehr über die aktiven Ports basierend auf der gehashten Protokollheaderinformation und akzeptiert eingehenden Verkehr auf jedem aktiven Port. Der Hash beinhaltet die Ethernet-Quell- und Zieladresse, und, soweit verfügbar, den VLAN-Tag, sowie die IPv4 oder IPv6 Quell- und Zieladresse.</p></div></dd><dt class=hdlist1>roundrobin</dt><dd><p>Dieser Modus verteilt ausgehenden Verkehr mittels einer Round-Robin-Zuteilung über alle aktiven Ports und akzeptiert eingehenden Verkehr auf jedem aktiven Port. Da dieser Modus die Reihenfolge von Ethernet-Rahmen verletzt, sollte er mit Vorsicht eingesetzt werden.</p></dd></dl></div><div class=sect3><h4 id=_beispiele_5>54.7.1. Beispiele<a class=anchor href=#_beispiele_5></a></h4><div class=paragraph><p>Dieser Abschnitt zeigt, wie man einen Cisco® Switch und ein FreeBSD-System für LACP Load Balancing konfiguriert. Weiterhin wird gezeigt, wie man zwei Ethernet-Schnittstellen, sowie eine Ethernet- und eine Drahtlos-Schnittstelle für den Failover-Modus konfigurieren kann.</p></div><div id=networking-lacp-aggregation-cisco class=exampleblock><div class=title>Beispiel 48. LACP Aggregation mit einem Cisco® Switch</div><div class=content><div class=paragraph><p>Dieses Beispiel verbindet zwei <a href="https://man.freebsd.org/cgi/man.cgi?query=fxp&amp;sektion=4&amp;format=html">fxp(4)</a> Ethernet-Schnittstellen einer FreeBSD-Maschine zu den ersten zwei Ethernet-Ports auf einem Cisco® Switch als eine einzelne, lastverteilte und ausfallsichere Verbindung. Weitere Adapter können hinzugefügt werden, um den Durchsatz zu erhöhen und die Ausfallsicherheit zu steigern. Ersetzen Sie die Namen der Cisco®-Ports, Ethernet-Geräte, channel-group Nummern und IP-Adressen im Beispiel durch Namen, die mit Ihrer lokalen Konfiguration übereinstimmen.</p></div><div class=paragraph><p>Da die Reihenfolge der Frames bei Ethernet zwingend eingehalten werden muss, fließt auch jeglicher Verkehr zwischen zwei Stationen über den gleichen physischen Kanal, was die maximale Geschwindigkeit der Verbindung auf die eines einzelnen Adapters beschränkt. Der Übertragungsalgorithmus versucht, so viele Informationen wie möglich zu verwenden, um die verschiedenen Verkehrsflüsse zu unterscheiden und balanciert diese über die verfügbaren Adapter.</p></div><div class=paragraph><p>Fügen Sie auf dem Cisco®-Switch die Adapter <em>FastEthernet0/1</em> und <em>FastEthernet0/2</em> zu der channel-group <em>1</em> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
<span class=o>!</span>
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</code></pre></div></div><div class=paragraph><p>Erstellen Sie auf der FreeBSD Maschine die <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>-Schnittstelle unter Verwendung von <em>fxp0</em> und <em>fxp1</em> und starten Sie die Schnittstelle mit der IP-Adresse <em>10.0.0.3/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</span></code></pre></div></div><div class=paragraph><p>Überprüfen Sie den Status der virtuellen Schnittstelle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</code></pre></div></div><div class=paragraph><p>Ports, die als <em>ACTIVE</em> markiert sind, sind Teil der aktiven Aggregations-Gruppe, die mit dem Switch ausgehandelt wurde. Der Verkehr wird über diese Gruppe übertragen und empfangen. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> mit <code>-v</code>, um sich die LAG-Bezeichner anzeigen zu lassen.</p></div><div class=paragraph><p>Um den Status der Ports auf dem Switch anzuzeigen, benutzen Sie <code>show lacp neighbor</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is <span class=k>in </span>Active mode       P - Device is <span class=k>in </span>Passive mode

Channel group 1 neighbors

Partner<span class=s1>&#39;s information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie <code>show lacp neighbor detail</code>, um weitere Informationen zu erhalten.</p></div><div class=paragraph><p>Damit diese Konfiguration auch nach einem Neustart erhalten bleibt, fügen Sie auf dem FreeBSD-System folgende Einträge in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0
ifconfig_lagg0=&#34;laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24&#34;</pre></div></div></div></div><div id=networking-lagg-failover class=exampleblock><div class=title>Beispiel 49. Ausfallsicherer Modus</div><div class=content><div class=paragraph><p>Der ausfallsichere Modus kann verwendet werden, um zu einer zweiten Schnittstelle zu wechseln, sollte die Verbindung mit der Master-Schnittstelle ausfallen. Um den ausfallsicheren Modus zu konfigurieren, aktivieren Sie zunächst die zugrunde liegenden physikalischen Schnittstellen. Erstellen Sie dann die <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>-Schnittstelle mit <em>fxp0</em> als Master-Schnittstelle und <em>fxp1</em> als sekundäre Schnittstelle. Der virtuellen Schnittstelle wird die IP-Adresse <em>10.0.0.15/24</em> zugewiesen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</span></code></pre></div></div><div class=paragraph><p>Die virtuelle Schnittstelle sollte in etwa so aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;</code></pre></div></div><div class=paragraph><p>Der Verkehr wird auf <em>fxp0</em> übertragen und empfangen. Wenn die Verbindung auf <em>fxp0</em> abbricht, wird <em>fxp1</em> die Verbindung übernehmen. Sobald die Verbindung auf der Master-Schnittstelle wiederhergestellt ist, wird diese wieder als aktive Schnittstelle genutzt.</p></div><div class=paragraph><p>Damit diese Konfiguration auch nach einem Neustart erhalten bleibt, fügen Sie folgende Einträge in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0
ifconfig_lagg0=&#34;laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24&#34;</pre></div></div></div></div><div id=networking-lagg-wired-and-wireless class=exampleblock><div class=title>Beispiel 50. Failover Modus zwischen Ethernet- und drahtlosen Schnittstellen</div><div class=content><div class=paragraph><p>Für Laptop-Benutzer ist es normalerweise wünschenswert, "wireless" als sekundäre Schnittstelle einzurichten, die verwendet wird, wenn die Ethernet-Verbindung nicht verfügbar ist. Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> ist es möglich, ein Failover mit einer IP-Adresse zu konfigurieren, welches die Ethernet-Verbindung aus Performance- und Sicherheitsgründen bevorzugt, während es gleichzeitig möglich bleibt, Daten über die drahtlose Verbindung zu übertragen.</p></div><div class=paragraph><p>Dies wird erreicht, indem die MAC-Adresse der Ethernet-Schnittstelle mit der MAC Adresse der drahtlosen Schnittstelle überschrieben wird.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>Theoretisch kann die Ethernet- oder die drahtlose MAC-Adresse so geändert werden, dass sie mit der jeweils anderen Adresse übereinstimmt. Bei einigen drahtlosen Schnittstellen fehlt jedoch die Unterstützung für das Überschreiben der MAC-Adresse. Daher wird empfohlen, die MAC-Adresse der Ethernet-Schnittstelle für diesen Zweck zu überschreiben.</p></div></div></div><div class=sidebarblock><div class=content><div class=paragraph><p>Wenn der Treiber für die drahtlose Schnittstelle nicht im <code>GENERIC</code>-Kernel oder in einem angepassten Kernel enthalten ist, kann unter FreeBSD 12.1 mit <code>_driver__load="YES"</code> die entsprechende <span class=filename>.ko</span>-Datei in <span class=filename>/boot/loader.conf</span> geladen werden. Dann muss das System neu gestartet werden. Ein anderer, besserer Weg ist es, den Treiber über <span class=filename>/etc/rc.conf</span> zu laden, indem Sie ihn zu <code>kld_list</code> (siehe <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>) hinzufügen und dann das System neu starten. Dies ist notwendig, da sonst der Treiber zum Zeitpunkt der Konfiguration der <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>-Schnittstelle noch nicht geladen ist.</p></div></div></div><div class=paragraph><p>In diesem Beispiel ist die Ethernet-Schnittstelle <em>re0</em> der Master und die drahtlose Schnittstelle <em>wlan0</em> der Failover. Die Schnittstelle <em>wlan0</em> wurde aus der physischen Schnittstelle <em>ath0</em> erstellt, und die Ethernet-Schnittstelle wird mit der MAC-Adresse der drahtlosen Schnittstelle konfiguriert. Im ersten Schritt wird die MAC-Adresse der drahtlosen Schnittstelle ermittelt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether b8:ee:65:5b:32:59
	<span class=nb>groups</span>: wlan
	ssid Bbox-A3BD2403 channel 6 <span class=o>(</span>2437 MHz 11g ht/20<span class=o>)</span> bssid 00:37:b7:56:4b:60
	regdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON
	deftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60
	protmode CTS ampdulimit 64k ampdudensity 8 shortgi <span class=nt>-stbctx</span> stbcrx
	<span class=nt>-ldpc</span> wme burst roaming MANUAL
	media: IEEE 802.11 Wireless Ethernet MCS mode 11ng
	status: associated
	nd6 <span class=nv>options</span><span class=o>=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;</code></pre></div></div><div class=paragraph><p>Ersetzen Sie <em>ath0</em> durch den Namen der drahtlosen Schnittstelle. Die <code>ether</code>-Zeile wird die MAC-Adresse der angegebenen Schnittstelle enthalten. Ändern Sie nun die MAC-Adresse der zugrunde liegenden Ethernet-Schnittstelle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 ether b8:ee:65:5b:32:59</span></code></pre></div></div><div class=paragraph><p>Starten Sie die drahtlose Schnittstelle, aber ohne eine IP-Adresse zu setzen. Ersetzen Sie <em>FR</em> durch den entsprechenden Ländercode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev iwn0 country FR ssid my_router up</span></code></pre></div></div><div class=paragraph><p>Stellen Sie sicher, dass die <em>re0</em>-Schnittstelle aktiv ist. Erstellen Sie die <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>-Schnittstelle mit <em>re0</em> als Master und <em>wlan0</em> als Failover:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0</span></code></pre></div></div><div class=paragraph><p>Die virtuelle Schnittstelle sollte in etwa so aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether b8:ee:65:5b:32:59
        laggproto failover lagghash l2,l3,l4
        laggport: re0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;
        laggport: wlan0 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        <span class=nb>groups</span>: lagg
        media: Ethernet autoselect
        status: active</code></pre></div></div><div class=paragraph><p>Starten Sie dann den DHCP-Client, um eine IP-Adresse zu erhalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient lagg0</span></code></pre></div></div><div class=paragraph><p>Damit diese Konfiguration auch nach einem Neustart erhalten bleibt, fügen Sie folgende Einträge in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_re0=&#34;ether b8:ee:65:5b:32:59&#34;
wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA&#34;
create_args_wlan0=&#34;country FR&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;up laggproto failover laggport re0 laggport wlan0 DHCP&#34;</pre></div></div></div></div></div></div><div class=sect2><h3 id=network-diskless>54.8. Plattenloser Betrieb mit PXE<a class=anchor href=#network-diskless></a></h3><div class=paragraph><p>Das Intel® Preboot eXecution Environment (PXE) erlaubt es dem Betriebssystem über das Netzwerk zu starten. Zum Beispiel kann ein FreeBSD-System, ohne lokale Festplatte, über das Netzwerk gestartet und betrieben werden. Die Dateisysteme werden dabei über einen NFS-Server eingehangen. PXE-Unterstützung steht in der Regel im BIOS zur Verfügung. Um PXE beim Systemstart zu verwenden, müssen Sie im BIOS des Rechners die Option <code>Über das Netzwerk starten</code> aktivieren. Alternativ können Sie während der PC-Initialisierung auch eine Funktionstaste drücken.</p></div><div class=paragraph><p>Um die notwendigen Dateien für ein Betriebssystem für den Start über das Netzwerk bereitzustellen, benötigt ein PXE-Setup einen richtig konfigurierten DHCP-, TFTP- und NFS-Server, wobei:</p></div><div class=ulist><ul><li><p>Die initialen Parameter, wie IP-Adresse, Dateiname und Speicherort der ausführbaren Bootdateien, Servername sowie Root-Pfad vom DHCP-Server bezogen werden.</p></li><li><p>Der Loader für das Betriebssystem über TFTP gestartet wird.</p></li><li><p>Die Dateisysteme über NFS geladen werden.</p></li></ul></div><div class=paragraph><p>Sobald das Gastsystem über PXE startet, erhält es vom DHCP-Server Informationen, wo der initiale Bootloader per TFTP zu bekommen ist. Nachdem das Gastsystem diese Informationen erhalten hat, lädt es den Bootloader über TFTP herunter und führt diesen anschließend aus. In FreeBSD ist <span class=filename>/boot/pxeboot</span> der Bootloader. Nachdem <span class=filename>/boot/pxeboot</span> ausgeführt und der FreeBSD-Kernel geladen wurde, wird mit dem Rest der FreeBSD-Bootsequenz, wie in <a href=./#boot>FreeBSDs Bootvorgang</a> beschrieben, fortgefahren.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie diese Dienste auf einem FreeBSD-System so konfigurieren, sodass andere Systeme FreeBSD über PXE starten können. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Wie beschrieben, ist das System, welches diese Dienste bereitstellt, unsicher. Daher sollte es in einem geschützten Bereich des Netzwerks aufgestellt und von anderen Hosts als nicht vertrauenswürdig eingestuft werden.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=network-pxe-nfs>54.8.1. Konfiguration der PXE-Umgebung<a class=anchor href=#network-pxe-nfs></a></h4><div class=paragraph><p>Die in diesem Abschnitt dargestellten Schritte konfigurieren die in FreeBSD enthaltenen NFS- und TFTP-Server. Der folgende Abschnitt beschreibt die Installation und Konfiguration des DHCP-Servers. In diesem Beispiel verwenden wir <span class=filename>/b/tftpboot/FreeBSD/install</span>, welches die Dateien für PXE-Benutzer enthält. Es ist wichtig, dass dieses Verzeichnis existiert und das der gleiche Verzeichnisname ebenfalls in <span class=filename>/etc/inetd.conf</span> und <span class=filename>/usr/local/etc/dhcpd.conf</span> gesetzt wird.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Erstellen Sie das Root-Verzeichnis, welches eine FreeBSD-Installation enthält und über NFS eingehangen werden kann:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># export NFSROOTDIR=/b/tftpboot/FreeBSD/install</span>
<span class=c># mkdir -p ${NFSROOTDIR}</span></code></pre></div></div></li><li><p>Aktivieren Sie den NFS-Server, indem Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzufügen:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Exportieren Sie das Root-Verzeichnis über NFS, indem Sie folgende Zeile in <span class=filename>/etc/exports</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>/b -ro -alldirs -maproot=root</pre></div></div></li><li><p>Starten Sie den NFS-Server:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div></li><li><p>Aktivieren Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>, indem Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzufügen:</p><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div></li><li><p>Kommentieren Sie die folgende Zeile in <span class=filename>/etc/inetd.conf</span> aus, indem Sie sicherstellen, dass die Zeile nicht mit einem <code>#</code>-Zeichen beginnt:</p><div class="literalblock programlisting"><div class=content><pre>tftp dgram udp wait root /usr/libexec/tftp tftp -l -s /b/tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Einige PXE-Versionen benötigen die TCP-Version von TFTP. In diesem Fall können Sie die zweite <code>tftp</code>-Zeile, welche <code>stream tcp</code> enthält, auskommentieren.</p></div></td></tr></tbody></table></div></li><li><p>Starten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div></li><li><p>Installieren Sie das Basissystem nach <span class=filename>${NFSROOTDIR}</span>, indem Sie die offiziellen Archive entpacken, oder ein neues Basissystem und einen FreeBSD-Kernel erstellen. Detaillierte Anweisungen hierzu finden Sie im <a href=./#makeworld>“FreeBSD aus den Quellen aktualisieren”</a>. Vergessen Sie jedoch nicht <code>DESTDIR=<em>${NFSROOTDIR}</em></code> hinzuzufügen, wenn Sie die Kommandos <code>make installkernel</code> und <code>make installworld</code> ausführen.</p></li><li><p>Testen Sie den TFTP-Server und vergewissern Sie sich, dass Sie den Bootloader herunterladen können, der über PXE bereitgestellt wird:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp localhost</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div></li><li><p>Bearbeiten Sie <span class=filename>${NFSROOTDIR}/etc/fstab</span> und erstellen Sie einen Eintrag, um das Root-Dateisystem über NFS einzuhängen:</p><div class="literalblock programlisting"><div class=content><pre># Device                                         Mountpoint    FSType   Options  Dump Pass$
	    myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</pre></div></div><div class=paragraph><p>Ersetzen Sie <em>myhost.example.com</em> durch den Hostnamen oder die IP-Adresse des NFS-Servers. In diesem Beispiel wird das Root-Dateisystem schreibgeschützt eingehangen, um ein potenzielles Löschen des Inhalts durch die NFS-Clients zu verhindern.</p></div></li><li><p>Setzen Sie das root-Passwort in der PXE-Umgebung für Client-Maschinen, die über PXE starten:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># passwd</span></code></pre></div></div></li><li><p>Falls erforderlich, aktivieren Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> root-Logins für Client-Maschinen, die über PXE starten, indem Sie die Option <code>PermitRootLogin</code> in <span class=filename>${NFSROOTDIR}/etc/ssh/sshd_config</span> aktivieren. Dies ist in <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a> dokumentiert.</p></li><li><p>Führen Sie alle weiteren Anpassungen der PXE-Umgebung in <span class=filename>${NFSROOTDIR}</span> durch, wie zum Beispiel die Installation weiterer Pakete, oder dass Bearbeiten der Passwortdatei mit <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>.</p></li></ol></div><div class=paragraph><p>Booten Sie von einem NFS-Root-Volume, so erkennt <span class=filename>/etc/rc</span> dies und startet daraufhin das <span class=filename>/etc/rc.initdiskless</span> Skript. Lesen Sie die Kommentare in diesem Skript um zu verstehen, was dort vor sich geht. Weil das NFS-Root-Verzeichnis schreibgeschützt ist, wir aber Schreibzugriff für <span class=filename>/etc</span> und <span class=filename>/var</span> benötigen, müssen wir diese Verzeichnisse über Speicher-Dateisysteme (memory backed file system) einbinden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># mkdir -p conf/base</span>
<span class=c># tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</span>
<span class=c># tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</span></code></pre></div></div><div class=paragraph><p>Wenn das System bootet, werden Speicher-Dateisysteme für <span class=filename>/etc</span> und <span class=filename>/var</span> erstellt und eingehangen. Anschließend wird der Inhalt der <span class=filename>cpio.gz</span>-Dateien in diese Dateisysteme kopiert. Standardmäßig haben diese Dateisysteme eine maximale Kapazität von 5 Megabyte. Wenn die Archive nicht passen, was für gewöhnlich bei <span class=filename>/var</span> der Fall ist, erhöhen Sie die Kapazität indem Sie die Anzahl der benötigten 512 Byte Sektoren (5 Megabyte sind 10240 Sektoren) in <span class=filename>${NFSROOTDIR}/conf/base/etc/md_size</span> und <span class=filename>${NFSROOTDIR}/conf/base/var/md_size</span> für die Dateisysteme <span class=filename>/etc</span> und <span class=filename>/var</span> eintragen.</p></div></div><div class=sect3><h4 id=network-pxe-setting-up-dhcp>54.8.2. Konfiguration des DHCP-Servers<a class=anchor href=#network-pxe-setting-up-dhcp></a></h4><div class=paragraph><p>Der DHCP-Server muss nicht auf derselben Maschine laufen wie der TFTP- und NFS-Server, aber er muss über das Netzwerk erreichbar sein.</p></div><div class=paragraph><p>DHCP ist nicht Bestandteil des FreeBSD Basissystems, kann jedoch über den Port <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a> oder als Paket nachinstalliert werden.</p></div><div class=paragraph><p>Einmal installiert, bearbeiten Sie die Konfigurationsdatei <span class=filename>/usr/local/etc/dhcpd.conf</span>. Konfigurieren Sie die <code>next-server</code>, <code>filename</code> und <code>root-path</code> Einstellungen, wie in diesem Beispiel zu sehen ist:</p></div><div class="literalblock programlisting"><div class=content><pre>subnet 192.168.0.0 netmask 255.255.255.0 {
range 192.168.0.2 192.168.0.3;
option subnet-mask 255.255.255.0;
option routers 192.168.0.1;
option broadcast-address 192.168.0.255;
option domain-name-servers 192.168.35.35, 192.168.35.36;
option domain-name &#34;example.com&#34;;

# IP address of TFTP server
next-server 192.168.0.1;

# path of boot loader obtained via tftp
filename &#34;FreeBSD/install/boot/pxeboot&#34;;

# pxeboot boot loader will try to NFS mount this directory for root FS
option root-path &#34;192.168.0.1:/b/tftpboot/FreeBSD/install/&#34;;
}</pre></div></div><div class=paragraph><p>Die Anweisung <code>next-server</code> wird benutzt, um die IP-Adresse des TFTP-Servers anzugeben.</p></div><div class=paragraph><p>Die Anweisung <code>filename</code> definiert den Pfad zu <span class=filename>/boot/pxeboot</span>. Da hier der relative Dateiname verwendet wird, bedeutet das, dass <span class=filename>/b/tftpboot</span> nicht im Pfad enthalten ist.</p></div><div class=paragraph><p>Die Option <code>root-path</code> bestimmt den Pfad zum NFS root-Dateisystem.</p></div><div class=paragraph><p>Sobald die Änderungen gespeichert werden, aktivieren Sie DHCP beim Systemstart, indem Sie die folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzufügen:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Starten Sie anschließend den DHCP-Dienst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div></div><div class=sect3><h4 id=_fehlersuche_bei_pxe_problemen>54.8.3. Fehlersuche bei PXE Problemen<a class=anchor href=#_fehlersuche_bei_pxe_problemen></a></h4><div class=paragraph><p>Sobald alle Dienste konfiguriert und gestartet wurden, sollten PXE-Clients in der Lage sein, FreeBSD automatisch über das Netzwerk zu starten. Wenn ein bestimmter Client beim hochfahren keine Verbindung herstellen kann, sehen Sie im BIOS nach, ob die Option für den Start über das Netzwerk konfiguriert ist.</p></div><div class=paragraph><p>Dieser Abschnitt gibt einige Tipps zu Fehlerbehebung und zeigt, wie Sie Konfigurationsprobleme eingrezen können für den Fall, dass PXE-Clients nicht in der Lage sind über das Netzwerk zu starten.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Benutzen Sie den <a class=package href=https://cgit.freebsd.org/ports/tree/net/wireshark/>net/wireshark</a> Port um Fehler im Netzwerkverkehr während des Bootvorgangs von PXE zu finden. Der Bootvorgang wird im folgenden Diagramm schematisch dargestellt.</p><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/pxe-nfs.png alt="pxe nfs"></div><div class=title>Abbildung 60. PXE-Bootvorgang mit NFS Root Mount</div></div></li><li><p>Schauen Sie in <span class=filename>/var/log/xferlog</span> auf dem TFTP-Server und vergewissern Sie sich, dass die <span class=filename>pxeboot</span>-Datei von der richtigen Adresse heruntergeladen wurde. Um die obige Konfiguration von <span class=filename>/usr/local/etc/dhcpd.conf</span> zu testen, geben Sie folgendes ein:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp 192.168.0.1</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=tftpd&amp;sektion=8&amp;format=html">tftpd(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=tftp&amp;sektion=1&amp;format=html">tftp(1)</a>. Die <code>BUGS</code>-Sektionen dieser Seiten dokumentieren einige Einschränkungen von TFTP.</p></div></li><li><p>Achten Sie darauf, dass Sie das Root-Dateisystem über NFS einhängen können. Auch hier können Sie Ihre Einstellungen aus <span class=filename>/usr/local/etc/dhcpd.conf</span> wie folgt testen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</span></code></pre></div></div></li></ol></div></div></div><div class=sect2><h3 id=network-ipv6>54.9. IPv6<a class=anchor href=#network-ipv6></a></h3><div class=paragraph><p>IPv6 ist die neueste Version des bekannten IP-Protokolls, das auch als IPv4 bezeichnet wird. IPv6 bietet gegenüber IPv4 mehrere Vorteile sowie viele neue Funktionen:</p></div><div class=ulist><ul><li><p>IPv6 hat einen 128 Bit großen Adressraum, der 340.282.366.920.938.463.463.374.607.431.768.211.456 Adressen erlaubt. Dies behebt das Problem der immer knapper werdenden IPv4-Adressen und einer eventuellen Erschöpfung des IPv4-Adressraums.</p></li><li><p>Router speichern nur noch Netzwerk-Aggregationsadressen in ihren Routingtabellen. Dadurch reduziert sich die durchschnittliche Größe einer Routingtabelle auf 8192 Einträge. Dies ist mit den Problemen bei der Skalierbarkeit von IPv4 verbunden, da jeder zugeordnete Block von IPv4-Adressen erfordert, dass Routing-Informationen zwischen vielen Routern im Internet ausgetauscht werden müssen. Die Routing-Tabellen wurden mit der Zeit so groß, dass ein effizientes Routing jetzt kaum noch möglich ist.</p></li><li><p>Die automatische Konfiguration von Adressen, die im <a href=http://www.ietf.org/rfc/rfc2462.txt>RFC2462</a> beschrieben wird.</p></li><li><p>Verpflichtende Multicast-Adressen.</p></li><li><p>Integriertes IPsec (IP-Security).</p></li><li><p>Eine vereinfachte Headerstruktur.</p></li><li><p>Unterstützung für mobile IP-Adressen.</p></li><li><p>Die Umwandlung von IPv4- in IPv6-Adressen.</p></li></ul></div><div class=paragraph><p>FreeBSD enthält die IPv6-Referenzimplementation von <a href=http//www.kame.net/>KAME</a> und erfüllt damit bereits alle für die Nutzung von IPv6 nötigen Voraussetzungen. Dieser Abschnitt konzentriert sich auf die Konfiguration und den Betrieb von IPv6.</p></div><div class=sect3><h4 id=_hintergrundinformationen_zu_ipv6_adressen>54.9.1. Hintergrundinformationen zu IPv6-Adressen<a class=anchor href=#_hintergrundinformationen_zu_ipv6_adressen></a></h4><div class=paragraph><p>Es gibt verschiedene Arten von IPv6-Adressen:</p></div><div class=dlist><dl><dt class=hdlist1>Unicast</dt><dd><p>Ein Paket, das an eine Unicast-Adresse gesendet wird, kommt nur an der Schnittstelle an, die dieser Adresse zugeordnet ist.</p></dd><dt class=hdlist1>Anycast</dt><dd><p>Anycast-Adressen unterscheiden sich in ihrer Syntax nicht von Unicast-Adressen, sie wählen allerdings aus mehreren Schnittstellen eine Schnittstelle aus. Ein für eine Anycast-Adresse bestimmtes Paket kommt an der nächstgelegenen (entsprechend der Router-Metrik) Schnittstelle an. Anycast-Adressen werden nur von Routern verwendet.</p></dd><dt class=hdlist1>Mulitcast</dt><dd><p>Multicast-Adressen bestimmen Gruppen, denen mehrere Schnittstellen angehören. Ein Paket, das an eine Multicast-Adresse geschickt wird, kommt an allen Schnittstellen an, die zur Multicast-Gruppe gehören. Die von IPv4 bekannte Broadcast-Adresse (normalerweise <code>xxx.xxx.xxx.255</code>) wird bei IPv6 durch Multicast-Adressen verwirklicht.</p></dd></dl></div><div class=paragraph><p>Die kanonische Form einer IPv6-Adresse lautet <code>x:x:x:x:x:x:x:x</code>, wobei jedes "x" für einen 16-Bit-Hexadezimalwert steht. Ein Beispiel für eine IPv6-Adresse wäre etwa <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code>.</p></div><div class=paragraph><p>Eine IPv6-Adresse enthält oft Teilzeichenfolgen aus lauter Nullen. Eine solche Zeichenfolge kann zu "::" verkürzt werden. Bis zu drei führende Nullen eines Hexquads können ebenfalls weggelassen werden. <code>fe80::1</code> entspricht also der Adresse <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>.</p></div><div class=paragraph><p>Eine weitere Möglichkeit ist die Darstellung der letzten 32 Bit in der bekannten IPv4-Notation. <code>2002::10.0.0.1</code> ist also eine andere Schreibweise für die (hexadezimale) kanonische Form <code>2002:0000:0000:0000:0000:0000:0a00:0001</code>, die wiederum der Adresse <code>2002::a00:1</code> entspricht.</p></div><div class=paragraph><p>Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, um die IPv6-Adresse eines FreeBSD-Systems anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span>
rl0: <span class=nv>flags</span><span class=o>=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect <span class=o>(</span>100baseTX <span class=o>)</span>
         status: active</code></pre></div></div><div class=paragraph><p>Bei <code>fe80::200:21ff:fe03:8e1%rl0</code> handelt es sich um eine automatisch konfigurierte link-local-Adresse. Sie wird im Rahmen der automatischen Konfiguration aus der MAC-Adresse erzeugt.</p></div><div class=paragraph><p>Einige IPv6-Adressen sind reserviert. Eine Zusammenfassung dieser Adressen finden Sie in <a href=#reservedip6>Reservierte IPv6-Adressen</a>:</p></div><table id=reservedip6 class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 32. Reservierte IPv6-Adressen</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">IPv6-Adresse</th><th class="tableblock halign-left valign-top">Präfixlänge</th><th class="tableblock halign-left valign-top">Beschreibung</th><th class="tableblock halign-left valign-top">Anmerkungen</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>nicht festgelegt</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>entspricht <code>0.0.0.0</code> bei IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Loopback-Adresse</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>entspricht <code>127.0.0.1</code> bei IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eingebettete IPv4-Adresse</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die niedrigen 32 Bit sind die kompatiblen IPv4-Adressen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eine auf IPv6 abgebildete IPv4-Adresse.</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die niedrigen 32 Bit sind IPv4-Adressen für Hosts, die kein IPv6 unterstützen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::/10</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>link-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Entspricht 196.254.0.0/16 bei IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fc00::/7</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unique-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diese einzigartigen Adressen sind für die lokale Kommunikation bestimmt und werden nur innerhalb von abgegrenzten Standorten (Sites) weitergeleitet.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff00::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Multicast</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>2000::-3fff::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 Bit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Globaler Unicast</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alle globalen Unicast-Adressen stammen aus diesem Pool. Die ersten 3 Bit lauten <code>001</code>.</p></td></tr></tbody></table><div class=paragraph><p>Weitere Informationen zum Aufbau von IPv6-Adressen finden Sie im <a href=http://www.ietf.org/rfc/rfc3513.txt>RFC3513</a>.</p></div></div><div class=sect3><h4 id=_ipv6_konfigurieren>54.9.2. IPv6 konfigurieren<a class=anchor href=#_ipv6_konfigurieren></a></h4><div class=paragraph><p>Um ein FreeBSD-System als IPv6-Client zu konfigurieren, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 accept_rtadv&#34;
rtsold_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Die erste Zeile ermöglicht der angegebenen Schnittstelle, Router-Advertisement-Nachrichten zu empfangen. Die zweite Zeile aktiviert den Router-Solicitation-Daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;format=html">rtsold(8)</a>.</p></div><div class=paragraph><p>Falls die Schnittstelle eine statisch zugewiesene IPv6-Adresse benötigt, fügen Sie einen Eintrag mit der statischen Adresse und dem zugehörigen Präfix für das Subnetz hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen 64&#34;</pre></div></div><div class=paragraph><p>Um einen Standardrouter festzulegen, fügen Sie die Adresse hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;2001:db8:4672:6565::1&#34;</pre></div></div></div><div class=sect3><h4 id=_verbindung_zu_einem_provider_aufbauen>54.9.3. Verbindung zu einem Provider aufbauen<a class=anchor href=#_verbindung_zu_einem_provider_aufbauen></a></h4><div class=paragraph><p>Um sich mit anderen IPv6-Netzwerken zu verbinden, benötigen Sie einen Provider oder einen Tunnel, der IPv6 unterstützt:</p></div><div class=ulist><ul><li><p>Fragen Sie einen Internetprovider, ob er IPv6 anbietet.</p></li><li><p><a href=http://www.tunnelbroker.net>Hurricane Electric</a> bietet weltweit IPv6-Tunnelverbindungen an.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Verwendung des Ports <span class=filename>/usr/ports/net/freenet6</span> für Einwahlverbindungen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dieser Abschnitt beschreibt, wie Sie die Anweisungen eines Tunnel-Providers dauerhaft in <span class=filename>/etc/rc.conf</span> einrichten.</p></div><div class=paragraph><p>Der erste Eintrag in <span class=filename>/etc/rc.conf</span> erzeugt die generische Tunnelschnittstelle <span class=filename>gif0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;gif0&#34;</pre></div></div><div class=paragraph><p>Als nächstes konfigurieren Sie die IPv4-Adressen der lokalen und entfernten Endpunkte. Ersetzen Sie <em>MY_IPv4_ADDR</em> und <em>REMOTE_IPv4_ADDR</em> durch die tatsächlichen IPv4-Adressen:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces_gif0=&#34;MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre></div></div><div class=paragraph><p>Um die zugewiesene IPv6-Adresse als Endpunkt für den IPv6-Tunnel zu verwenden, fügen Sie folgende Zeile für FreeBSD 9.<em>x</em> (und neuer) ein:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_gif0_ipv6=&#34;inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Legen Sie dann die Standardroute für das andere Ende des IPv6-Tunnels fest. Ersetzen Sie <em>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</em> mit der Adresse des Standard-Gateways des Providers:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Wenn das FreeBSD-System IPv6-Verkehr zwischen dem Netzwerk und der Außenwelt routen muss, aktivieren Sie das Gateway mit dieser Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_gateway_enable=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=_bekanntmachung_von_routen_und_automatische_rechnerkonfiguration>54.9.4. Bekanntmachung von Routen und automatische Rechnerkonfiguration<a class=anchor href=#_bekanntmachung_von_routen_und_automatische_rechnerkonfiguration></a></h4><div class=paragraph><p>Dieser Abschnitt beschreibt die Einrichtung von <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>, das Sie bei der Bekanntmachung der IPv6-Standardroute unterstützt.</p></div><div class=paragraph><p>Um <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> zu aktivieren, fügen Sie folgende Zeile in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Es ist wichtig, die Schnittstelle anzugeben, über die IPv6-Routen bekanntgemacht werden sollen. Soll <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> <span class=filename>rl0</span> verwenden, ist folgender Eintrag nötig:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_interfaces=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>Danach erzeugen Sie die Konfigurationsdatei <span class=filename>/etc/rtadvd.conf</span>. Dazu ein Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>rl0:\
    :addrs#1:addr=&#34;2001:db8:1f11:246::&#34;:prefixlen#64:tc=ether:</pre></div></div><div class=paragraph><p>Ersetzen Sie dabei <span class=filename>fxp0</span> durch die zu verwendende Schnittstelle, und <code>2001:db8:1f11:246::</code> durch das entsprechend zugewiesene Präfix.</p></div><div class=paragraph><p>Bei einem <code>/64</code>-Subnetz müssen keine weiteren Anpassungen vorgenommen werden. Anderenfalls muss <code>prefixlen#</code> auf den korrekten Wert gesetzt werden.</p></div></div><div class=sect3><h4 id=_ipv6_und_abbildung_von_ipv6_adressen>54.9.5. IPv6 und Abbildung von IPv6-Adressen<a class=anchor href=#_ipv6_und_abbildung_von_ipv6_adressen></a></h4><div class=paragraph><p>Wenn IPv6 auf einem Server aktiviert ist, kann es für die Kommunikation erforderlich sein, IPv4-Adressen auf IPv6-Adressen abzubilden. Diese Kompatibilität erlaubt es, das IPv4-Adressen als IPv6-Adressen dargestellt werden. Die Kommunikation von IPv6-Anwendungen mit IPv4 und umgekehrt kann jedoch ein Sicherheitsrisiko darstellen.</p></div><div class=paragraph><p>Diese Option dient nur der Kompatibilität und wird in den meisten Fällen nicht erforderlich sein. Die Option ermöglicht es IPv6-Anwendungen zusammen mit IPv4 in einer Dual-Stack-Umgebung zu funktionieren. Dies ist besonders nützlich für Anwendungen von Drittanbietern, die evtl. keine IPv6-Umgebungen unterstützen. Um diese Funktion zu aktivieren, fügen Sie folgendes in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ip4mapping=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Für einige Administratoren können die Informationen im RFC 3493 (Sektion 3.6 und 3.7) und RFC 4038 (Sektion 4.2) hilfreich sein.</p></div></div></div><div class=sect2><h3 id=carp>54.10. Common Address Redundancy Protocol (CARP)<a class=anchor href=#carp></a></h3><div class=paragraph><p>Das Common Address Redundancy Protocol (CARP) erlaubt es, mehreren Rechnern die gleiche IP-Adresse und Virtual Host ID (VHID) zuzuweisen und <em>Hochverfügbarkeit</em> bereitzustellen. Das bedeutet, dass ein oder mehrere Rechner ausfallen können und die anderen Rechner transparent einspringen, ohne dass die Benutzer etwas von einem Ausfall mitbekommen.</p></div><div class=paragraph><p>Neben der gemeinsamen IP-Adresse, haben die jeweiligen Rechner auch eine eindeutige IP-Adresse zur Verwaltung und Konfiguration. Alle Maschinen, die sich eine IP-Adresse teilen, verwenden die gleiche VHID. Die VHID für jede einzelne IP-Adresse muss, entsprechend der Broadcast-Domäne der Netzwerkschnittstelle, eindeutig sein.</p></div><div class=paragraph><p>Hochverfügbarkeit mit CARP ist in FreeBSD enthalten, jedoch unterscheidet sich die Konfiguration von der eingesetzten FreeBSD-Version. Dieser Abschnitt enthält die gleichen Konfigurationsdateien für verschiedene Versionen von FreeBSD.</p></div><div class=paragraph><p>Dieses Beispiel konfiguriert eine Failover-Unterstützung mit drei Servern (mit jeweils eigener, eindeutiger IP-Adresse), die alle den gleichen Web-Inhalt anbieten. Es werden zwei verschiedene Master namens <code>hosta.example.org</code> und <code>hostb.example.org</code> benutzt, mit einem gemeinsamen Backup namens <code>hostc.example.org</code>.</p></div><div class=paragraph><p>Die Lastverteilung dieser Maschinen wird dabei über Round RobinDNS konfiguriert. Mit Ausnahme des Hostnamens und der IP-Management-Adresse sind Master- und Backup-Maschinen identisch konfiguriert. Die Server müssen die gleiche Konfiguration und die gleichen Dienste aktiviert haben. Tritt ein Failover auf, können Anfragen an den Dienst mit der gemeinsam genutzten IP-Adresse nur dann richtig beantwortet werden, wenn der Backup-Server Zugriff auf denselben Inhalt hat. Die Backup-Maschine verfügt über zwei zusätzliche CARP-Schnittstellen, eine für jede IP-Adresse des Master-Content-Servers. Sobald ein Fehler auftritt, übernimmt der Backup-Server die IP-Adresse des ausgefallenen Master-Servers.</p></div><div class=sect3><h4 id=carp-10x>54.10.1. CARP mit FreeBSD 10 (und neuer) benutzen<a class=anchor href=#carp-10x></a></h4><div class=paragraph><p>Unterstützung für CARP erhalten Sie durch das Laden des Kernelmoduls <span class=filename>carp.ko</span> in <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>So laden Sie das Modul ohne Neustart:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Benutzer, die einen angepassten Kernel verwenden möchten, müssen die folgende Zeile in die Konfigurationsdatei aufnehmen. Anschließend muss der Kernel, wie in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> beschrieben, neu gebaut werden:</p></div><div class="literalblock programlisting"><div class=content><pre>device  carp</pre></div></div><div class=paragraph><p>Hostname, IP-Management-Adresse, Subnetzmaske, gemeinsame IP-Adresse und VHID werden durch Einträge in <span class=filename>/etc/rc.conf</span> gesetzt. Dieses Beispiel ist für <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 pass testpass alias 192.168.1.50/32&#34;</pre></div></div><div class=paragraph><p>Die nächsten Einträge sind für <code>hostb.example.org</code>. Da der Rechner einen zweiten Master darstellt, verwendet er eine andere gemeinsame IP-Adresse und VHID. Die mittels <code>pass</code> angegebenen Passwörter müssen jedoch identisch sein, da CARP nur mit Systemen kommuniziert, die über das richtige Passwort verfügen.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 2 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>Die dritte Maschine, <code>hostc.example.org</code> ist so konfiguriert, das sie aktiviert wird, wenn einer der beiden Masterserver ausfällt. Diese Maschine ist mit zwei CARPVHIDs konfiguriert, eine für jede virtuelle IP-Adresse der beiden Master-Server. Die CARP advertising skew, <code>advskew</code> wird gesetzt, um sicherzustellen, dass sich der Backup-Server später ankündigt wie der Master-Server, da <code>advskew</code> die Rangfolge steuert für den Fall, dass mehrere Backup-Server zur Verfügung stehen.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32&#34;
ifconfig_em0_alias1=&#34;inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>Durch die beiden konfigurierten CARPVHIDs ist <code>hostc.example.org</code> in der Lage festzustellen, wenn einer der Master-Server nicht mehr reagiert. Wenn der Master-Server sich später ankündigt als der Backup-Server, übernimmt der Backup-Server die gemeinsame IP-Adresse, bis der Master-Server erneut verfügbar ist.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Auch wenn der ursprüngliche Master-Server wieder verfügbar wird, gibt <code>hostc.example.org</code> die virtuelle IP-Adresse nicht automatisch wieder frei. Dazu muss Preemption aktiviert werden. Preemption ist standardmäßig deaktiviert und wird über die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>net.inet.carp.preempt</code> gesteuert. Der Administrator kann den Backup-Server zwingen, die IP-Adresse an den Master zurückzugeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0 vhid 1 state backup</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald die Konfiguration abgeschlossen ist, muss das Netzwerk oder die Maschine neu gestartet werden. Hochverfügbarkeit ist nun aktiviert.</p></div><div class=paragraph><p>Die Funktionalität von CARP kann, wie in der Manualpage <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a> beschrieben, über verschiedene <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> Parameter kontrolliert werden. Mit dem Einsatz von <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> können weitere Aktionen zu CARP-Ereignissen ausgelöst werden.</p></div></div><div class=sect3><h4 id=carp-9x>54.10.2. CARP mit FreeBSD 9 (und älter) benutzen<a class=anchor href=#carp-9x></a></h4><div class=paragraph><p>Die Konfiguration für diese Versionen von FreeBSD ist ähnlich wie im vorhergehenden Abschnitt beschrieben, mit der Ausnahme, dass zuerst ein CARP-Gerät in der Konfiguration erstellt und bezeichnet werden muss.</p></div><div class=paragraph><p>Unterstützung für CARP erhalten Sie durch das Laden des Kernelmoduls <span class=filename>carp.ko</span> in <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>if_carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>So laden Sie das Modul ohne Neustart:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Benutzer, die einen angepassten Kernel verwenden möchten, müssen die folgende Zeile in die Konfigurationsdatei aufnehmen. Anschließend muss der Kernel, wie in <a href=./#kernelconfig>Konfiguration des FreeBSD-Kernels</a> beschrieben, neu gebaut werden:</p></div><div class="literalblock programlisting"><div class=content><pre>device    carp</pre></div></div><div class=paragraph><p>Als nächstes erstellen Sie auf jedem Rechner eine CARP-Schnittstelle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 create</span></code></pre></div></div><div class=paragraph><p>Konfigurieren Sie Hostnamen, IP-Management-Adresse, die gemeinsam genutzte IP-Adresse und die VHID, indem Sie die erforderlichen Zeilen in <span class=filename>/etc/rc.conf</span> hinzufügen. Da anstelle eines Alias eine virtuelles CARP-Gerät verwendet wird, wird die tatsächliche Subnetzmaske <code>/24</code> anstatt <code>/32</code> benutzt. Hier sind die Einträge für <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpass 192.168.1.50/24&#34;</pre></div></div><div class=paragraph><p>Beispiel für <code>hostb.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class=paragraph><p>Die dritte Maschine, <code>hostc.example.org</code> ist so konfiguriert, das sie aktiviert wird, wenn einer der beiden Masterserver ausfällt:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Preemption ist im <span class=filename>GENERIC</span>-Kernel deaktiviert. Haben Sie jedoch Preemption in einem angepassten Kernel aktiviert, dass <code>hostc.example.org</code> die virtuelle IP-Adresse nicht wieder an den Master-Server zurückgibt. Der Administrator kann jedoch den Backup-Server dazu zwingen, die übernommene IP-Adresse wieder an den Master-Server zurückzugeben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre></div></div><div class=paragraph><p>Dieser Befehl muss auf dem <span class=filename>carp</span>-Gerät ausgeführt werden, dass dem betroffenen System zugeordnet ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sobald die Konfiguration abgeschlossen ist, muss das Netzwerk oder die Maschine neu gestartet werden. Hochverfügbarkeit ist nun aktiviert.</p></div></div></div><div class=sect2><h3 id=network-vlan>54.11. VLANs<a class=anchor href=#network-vlan></a></h3><div class=paragraph><p>VLANs sind eine Möglichkeit ein Netzwerk virtuell in viele Subnetze zu unterteilen. Man spricht hier auch von Segmentierung. Jedes Subnetz hat seine eigene Broadcast-Domäne und ist von anderen VLANs isoliert.</p></div><div class=paragraph><p>Unter FreeBSD müssen VLANs vom Treiber der Netzwerkkarte unterstützt werden. <a href="https://man.freebsd.org/cgi/man.cgi?query=vlan&amp;sektion=4&amp;format=html">vlan(4)</a> enthält eine Liste von Treibern mit integrierter VLAN-Unterstützung.</p></div><div class=paragraph><p>Für die Konfiguration eines VLAN werden zwei Informationen benötigt: die verwendete Netzwerkschnittstelle und das VLAN-Tag.</p></div><div class=paragraph><p>Das folgende Kommando konfiguriert ein VLAN mit der Netzwerkschnittstelle <code>em0</code> und dem VLAN-Tag <code>5</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In diesem Beispiel fällt auf, dass der Name der Schnittstelle den Treibernamen und das VLAN-Tag enthält, getrennt durch einen Punkt. Diese Methode hat sich bewährt, da sie die Konfiguration von Systemen mit mehreren VLANs deutlich erleichtert.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um VLANs beim Booten zu konfigurieren, muss <span class=filename>/etc/rc.conf</span> angepasst werden. Für das obige Beispiel müssten folgende Zeilen in die Konfiguration aufgenommen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_em0=&#34;5&#34;
ifconfig_em0_5=&#34;inet 192.168.20.20/24&#34;</pre></div></div><div class=paragraph><p>Das gleiche Schema kann benutzt werden, um weitere VLANs hinzuzufügen.</p></div><div class=paragraph><p>Es ist sinnvoll, einer Schnittstelle einen symbolischen Namen zuzuweisen, so dass bei einem Wechsel der zugehörigen Hardware nur wenige Konfigurationsvariablen aktualisiert werden müssen. Nehmen wir beispielsweise an, dass Überwachungskameras im VLAN1 auf <code>em0</code> betrieben werden. Wenn später die Karte <code>em0</code> durch eine Karte ersetzt wird, die den <a href="https://man.freebsd.org/cgi/man.cgi?query=ixgb&amp;sektion=4&amp;format=html">ixgb(4)</a> Treiber verwendet, müssen nicht alle Referenzen auf <code>em0.1</code> durch <code>ixgb0.1</code> ersetzt werden.</p></div><div class=paragraph><p>Der folgende Befehl konfiguriert VLAN <code>5</code> auf der Netzwerkkarte <code>em0</code>. Die Schnittstelle bekommt den Namen <code>cameras</code> und eine IP-Adresse <code><em>192.168.20.20</em></code> mit einem <code>24</code>-Bit Präfix.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Dieser Befehl konfiguriert die Schnittstelle mit dem Namen <code>video</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Um die Änderungen beim Booten anzuwenden, fügen Sie folgenden Zeilen in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_video=&#34;cameras&#34;
create_args_cameras=&#34;vlan 5&#34;
ifconfig_cameras=&#34;inet 192.168.20.20/24&#34;</pre></div></div><div class=paragraph><p>path: "/books/handbook/partv/"
---
:sectnums!:
:leveloffset: +1</p></div></div></div></div><div class=sect1><h2 id=mirrors>Anhang A: Bezugsquellen für FreeBSD<a class=anchor href=#mirrors></a></h2><div class=sectionbody></div></div><div class=sect1><h2 id=mirrors-cdrom>Kapitel 55. CD and DVD Sets<a class=anchor href=#mirrors-cdrom></a></h2><div class=sectionbody><div class=paragraph><p>Die FreeBSD-CDs und -DVDs werden von verschiedenen Online-Händlern angeboten:</p></div><div class=ulist><ul><li><p>FreeBSD Mall, Inc.<br>2420 Sand Creek Rd C-1 #347<br>Brentwood, CA<br>94513<br>USA<br>Phone: +1 925 240-6652<br>Fax: +1 925 674-0821<br>Email: &lt;<a href=mailto:info@freebsdmall.com>info@freebsdmall.com</a>><br>WWW: <a href=https://www.freebsdmall.com class=bare>https://www.freebsdmall.com</a></p></li><li><p>Getlinux<br>78 Rue de la Croix Rochopt<br>Épinay-sous-Sénart<br>91860<br>France<br>Email: &lt;<a href=mailto:contact@getlinux.fr>contact@getlinux.fr</a>><br>WWW: <a href=http://www.getlinux.fr/ class=bare>http://www.getlinux.fr/</a></p></li><li><p>Dr. Hinner EDV<br>Kochelseestr. 11<br>D-81371 München<br>Germany<br>Phone: (0177) 428 419 0<br>Email: &lt;<a href=mailto:infow@hinner.de>infow@hinner.de</a>><br>WWW: <a href=http://www.hinner.de/linux/freebsd.html class=bare>http://www.hinner.de/linux/freebsd.html</a></p></li><li><p>Linux Center<br>Galernaya Street, 55<br>Saint-Petersburg<br>190000<br>Russia<br>Phone: +7-812-309-06-86<br>Email: &lt;<a href=mailto:info@linuxcenter.ru>info@linuxcenter.ru</a>><br>WWW: <a href=http://linuxcenter.ru/shop/freebsd class=bare>http://linuxcenter.ru/shop/freebsd</a></p></li></ul></div></div></div><div class=sect1><h2 id=mirrors-ftp>Kapitel 56. FTP-Server<a class=anchor href=#mirrors-ftp></a></h2><div class=sectionbody><div class=paragraph><p>Die offiziellen Quellen von FreeBSD sind mit anonymous FTP über ein weltweites Netz von Spiegeln erhältlich. Die Seite <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/>ftp://ftp.FreeBSD.org/pub/FreeBSD/</a> ist über HTTP und FTP erreichbar. Sie besteht aus mehreren Servern, die von den Cluster-Administratoren des Projekts über GeoDNS betrieben wird, um Benutzer auf den nächsten verfügbaren Spiegel umzuleiten.</p></div><div class=paragraph><p>Sie können FreeBSD auch über anonymous FTP von den folgenden Spiegeln beziehen. Wenn Sie FreeBSD über anonymous FTP beziehen wollen, wählen Sie bitte einen Spiegel in Ihrer Nähe. Die unter "Haupt-Spiegel" aufgeführten Spiegel stellen normalerweise das komplette FreeBSD-Archiv (alle momentan erhältlichen Versionen für jede unterstützte Architektur) zur Verfügung. Wahrscheinlich geht es aber schneller, wenn Sie einen Spiegel in Ihrer Nähe benutzen. Die Länder-Spiegel stellen die neusten Versionen für die beliebtesten Architekturen bereit, sie stellen aber unter Umständen nicht das komplette FreeBSD-Archiv bereit. Auf alle Server kann mit anonymous FTP zugegriffen werden, einige Server bieten auch andere Zugriffsmethoden an. Die zur Verfügung stehenden Zugriffsmethoden sind bei jedem Server in Klammern angegeben.</p></div><div class=paragraph><p><a href=#central>Central Servers</a>, <a href=#primary>Primary Mirror Sites</a>, <a href=#armenia>Armenia</a>, <a href=#australia>Australia</a>, <a href=#austria>Austria</a>, <a href=#brazil>Brazil</a>, <a href=#czech-republic>Czech Republic</a>, <a href=#denmark>Denmark</a>, <a href=#estonia>Estonia</a>, <a href=#finland>Finland</a>, <a href=#france>France</a>, <a href=#germany>Germany</a>, <a href=#greece>Greece</a>, <a href=#hong-kong>Hong Kong</a>, <a href=#ireland>Ireland</a>, <a href=#japan>Japan</a>, <a href=#korea>Korea</a>, <a href=#latvia>Latvia</a>, <a href=#lithuania>Lithuania</a>, <a href=#netherlands>Netherlands</a>, <a href=#new-zealand>New Zealand</a>, <a href=#norway>Norway</a>, <a href=#poland>Poland</a>, <a href=#russia>Russia</a>, <a href=#saudi-arabia>Saudi Arabia</a>, <a href=#slovenia>Slovenia</a>, <a href=#south-africa>South Africa</a>, <a href=#spain>Spain</a>, <a href=#sweden>Sweden</a>, <a href=#switzerland>Switzerland</a>, <a href=#taiwan>Taiwan</a>, <a href=#ukraine>Ukraine</a>, <a href=#uk>United Kingdom</a>, <a href=#usa>United States of America</a>.</p></div><div class=paragraph><p>(aktualisiert am: UTC)</p></div><div id=central class=paragraph><p><strong>Central Servers</strong></p></div><div class=paragraph><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.FreeBSD.org/pub/FreeBSD/</a>)</p></div><div id=primary class=paragraph><p><strong>Primary Mirror Sites</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:mirror-admin@FreeBSD.org>mirror-admin@FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp10.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp10.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp10.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp11.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp14.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp14.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp14.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=armenia class=paragraph><p><strong>Armenia</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@am.FreeBSD.org>hostmaster@am.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp1.am.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp1.am.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li></ul></div><div id=australia class=paragraph><p><strong>Australia</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@au.FreeBSD.org>hostmaster@au.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=austria class=paragraph><p><strong>Austria</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@at.FreeBSD.org>hostmaster@at.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.at.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.at.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.at.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=brazil class=paragraph><p><strong>Brazil</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@br.FreeBSD.org>hostmaster@br.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp2.br.FreeBSD.org/FreeBSD/ class=bare>ftp://ftp2.br.FreeBSD.org/FreeBSD/</a> (ftp / <a href=http://ftp2.br.FreeBSD.org/ class=bare>http://ftp2.br.FreeBSD.org/</a>)</p></li><li><p><a href=ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=czech-republic class=paragraph><p><strong>Czech Republic</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@cz.FreeBSD.org>hostmaster@cz.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.cz.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=denmark class=paragraph><p><strong>Denmark</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:staff@dotsrc.org>staff@dotsrc.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.dk.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.dk.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=estonia class=paragraph><p><strong>Estonia</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@ee.FreeBSD.org>hostmaster@ee.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=finland class=paragraph><p><strong>Finland</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@fi.FreeBSD.org>hostmaster@fi.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=france class=paragraph><p><strong>France</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@fr.FreeBSD.org>hostmaster@fr.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp1.fr.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp1.fr.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=germany class=paragraph><p><strong>Germany</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:de-bsd-hubs@de.FreeBSD.org>de-bsd-hubs@de.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.de.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp1.de.FreeBSD.org/freebsd/ class=bare>ftp://ftp1.de.FreeBSD.org/freebsd/</a> (ftp / <a href=http://www1.de.FreeBSD.org/freebsd/ class=bare>http://www1.de.FreeBSD.org/freebsd/</a> / rsync://rsync3.de.FreeBSD.org/freebsd/)</p></li><li><p><a href=ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.de.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp4.de.FreeBSD.org/FreeBSD/ class=bare>ftp://ftp4.de.FreeBSD.org/FreeBSD/</a> (ftp / <a href=http://ftp4.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.de.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp7.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp7.de.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=greece class=paragraph><p><strong>Greece</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@gr.FreeBSD.org>hostmaster@gr.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=hong-kong class=paragraph><p><strong>Hong Kong</strong></p></div><div class=paragraph><p><a href=ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></div><div id=ireland class=paragraph><p><strong>Ireland</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@ie.FreeBSD.org>hostmaster@ie.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li></ul></div><div id=japan class=paragraph><p><strong>Japan</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@jp.FreeBSD.org>hostmaster@jp.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=korea class=paragraph><p><strong>Korea</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@kr.FreeBSD.org>hostmaster@kr.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.kr.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.kr.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=latvia class=paragraph><p><strong>Latvia</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@lv.FreeBSD.org>hostmaster@lv.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.lv.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.lv.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=lithuania class=paragraph><p><strong>Lithuania</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@lt.FreeBSD.org>hostmaster@lt.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.lt.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.lt.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=netherlands class=paragraph><p><strong>Netherlands</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@nl.FreeBSD.org>hostmaster@nl.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.nl.FreeBSD.org/os/FreeBSD/ class=bare>http://ftp.nl.FreeBSD.org/os/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=new-zealand class=paragraph><p><strong>New Zealand</strong></p></div><div class=ulist><ul><li><p><a href=ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.nz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.nz.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=norway class=paragraph><p><strong>Norway</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@no.FreeBSD.org>hostmaster@no.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.no.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.no.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li></ul></div><div id=poland class=paragraph><p><strong>Poland</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@pl.FreeBSD.org>hostmaster@pl.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p>ftp2.pl.FreeBSD.org</p></li></ul></div><div id=russia class=paragraph><p><strong>Russia</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@ru.FreeBSD.org>hostmaster@ru.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ru.FreeBSD.org/FreeBSD/ class=bare>http://ftp.ru.FreeBSD.org/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.ru.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.ru.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp5.ru.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp5.ru.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=saudi-arabia class=paragraph><p><strong>Saudi Arabia</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:ftpadmin@isu.net.sa>ftpadmin@isu.net.sa</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.isu.net.sa/pub/ftp.freebsd.org class=bare>ftp://ftp.isu.net.sa/pub/ftp.freebsd.org</a> (ftp)</p></li></ul></div><div id=slovenia class=paragraph><p><strong>Slovenia</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@si.FreeBSD.org>hostmaster@si.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.si.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.si.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=south-africa class=paragraph><p><strong>South Africa</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@za.FreeBSD.org>hostmaster@za.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=spain class=paragraph><p><strong>Spain</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@es.FreeBSD.org>hostmaster@es.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.es.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.es.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.es.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.es.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=sweden class=paragraph><p><strong>Sweden</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@se.FreeBSD.org>hostmaster@se.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.se.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync://ftp2.se.FreeBSD.org/)</p></li><li><p><a href=ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/ / rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/)</p></li><li><p><a href=ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp6.se.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=switzerland class=paragraph><p><strong>Switzerland</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@ch.FreeBSD.org>hostmaster@ch.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.ch.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=taiwan class=paragraph><p><strong>Taiwan</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@tw.FreeBSD.org>hostmaster@tw.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.tw.FreeBSD.org/ class=bare>http://ftp6.tw.FreeBSD.org/</a> / rsync)</p></li><li><p><a href=ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp11.tw.FreeBSD.org/FreeBSD/ class=bare>http://ftp11.tw.FreeBSD.org/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=ukraine class=paragraph><p><strong>Ukraine</strong></p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ua.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.ua.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.ua.FreeBSD.org/pub/FreeBSD class=bare>http://ftp6.ua.FreeBSD.org/pub/FreeBSD</a> / rsync://ftp6.ua.FreeBSD.org/FreeBSD/)</p></li><li><p><a href=ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=uk class=paragraph><p><strong>United Kingdom</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@uk.FreeBSD.org>hostmaster@uk.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync://ftp2.uk.FreeBSD.org/ftp.freebsd.org/pub/FreeBSD/)</p></li><li><p><a href=ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=usa class=paragraph><p><strong>United States of America</strong></p></div><div class=paragraph><p>Bei Problemen wenden Sie sich bitte an den Betreuer <code>&lt;<a href=mailto:hostmaster@us.FreeBSD.org>hostmaster@us.FreeBSD.org</a>></code> dieser Domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.us.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.us.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp13.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp13.us.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp14.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp14.us.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div></div></div><div class=sect1><h2 id=svn>Kapitel 57. Benutzen von Subversion<a class=anchor href=#svn></a></h2><div class=sectionbody><div class=sect2><h3 id=svn-intro>57.1. Einführung<a class=anchor href=#svn-intro></a></h3><div class=paragraph><p>Seit Juli 2012 nutzt FreeBSD ausschließlich Subversion als Versionskontrollsystem zur Speicherung des gesamten FreeBSD Quellcodes, der Dokumentation und der Ports-Sammlung.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Subversion ist hauptsächlich ein Werkzeug für Entwickler. Die meisten Benutzer bevorzugen <code>freebsd-update</code> (<a href=./#updating-upgrading-freebsdupdate>FreeBSD-Update</a>) um das FreeBSD Basissystem zu aktualisieren, und <code>portsnap</code> (<a href=./#ports-using>Benutzen der Ports-Sammlung</a>) um die FreeBSD Ports-Sammlung aktuell zu halten.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dieser Abschnitt zeigt, wie Subversion unter FreeBSD installiert wird und wie Sie damit eine lokale Kopie des FreeBSD Repositories erstellen. Weitere Informationen über die Benutzung von Subversion sind ebenfalls enthalten.</p></div></div><div class=sect2><h3 id=svn-ssl-certificates>57.2. SSL Root-Zertifikate<a class=anchor href=#svn-ssl-certificates></a></h3><div class=paragraph><p>Die Installation von <a class=package href=https://cgit.freebsd.org/ports/tree/security/ca_root_nss/>security/ca_root_nss</a> erlaubt es Subversion die Identität des HTTPS-Repository-Servers zu überprüfen. Die SSL Root-Zertifikate können aus der Ports-Sammlung installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/security/ca_root_nss</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Alternativ kann das Paket installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install ca_root_nss</span></code></pre></div></div></div><div class=sect2><h3 id=svn-svnlite>57.3. Svnlite<a class=anchor href=#svn-svnlite></a></h3><div class=paragraph><p>Mit <code>svnlite</code> enthält FreeBSD bereits eine vereinfachte Version von Subversion. Der Port oder das Paket ist nur erforderlich, wenn die Python oder Perl API benötigt wird, oder eine neuere Version von Subversion gewünscht ist.</p></div><div class=paragraph><p>Der einzige Unterschied zum normalen Subversion ist, dass der Name des Kommandos <code>svnlite</code> lautet.</p></div></div><div class=sect2><h3 id=svn-install>57.4. Installation<a class=anchor href=#svn-install></a></h3><div class=paragraph><p>Falls <code>svnlite</code> nicht verfügbar ist, oder die komplette Version von Subversion benötigt wird, muss das Programm installiert werden.</p></div><div class=paragraph><p>Subversion kann aus der Ports-Sammlung installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/devel/subversion</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Subversion kann auch als Paket installiert werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install subversion</span></code></pre></div></div></div><div class=sect2><h3 id=svn-usage>57.5. Subversion benutzen<a class=anchor href=#svn-usage></a></h3><div class=paragraph><p>Der <code>svn</code> Befehl wird verwendet, um eine Kopie der Quellen in ein lokales Verzeichnis zu holen. Die Dateien in diesem Verzeichnis werden <em>lokale Arbeitskopie</em> genannt.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Verschieben oder löschen Sie das Zielverzeichnis bevor Sie <code>checkout</code> benutzen.</p></div><div class=paragraph><p>In ein bestehendes nicht-<code>svn</code> Verzeichnis auszuchecken kann zu Konflikten zwischen den vorhandenen Dateien und denen aus dem Respository führen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In Subversion werden URLs in der Form von <em>protocol://hostname/path</em> verwendet, um ein Repository zu kennzeichnen. Die erste Komponente des Pfades ist das FreeBSD Repository auf welches zugegriffen wird. Es gibt drei verschiedene Repositories. <code>base</code> für den Quellcode des FreeBSD Basissystems, <code>ports</code> für die Ports-Sammlung und <code>doc</code> für die Dokumentation. Als Beispiel spezifiziert die URL <code>svn://svn.FreeBSD.org/ports/head/</code> den Hauptzweig des Port-Repositories auf dem Mirror <code>svn.FreeBSD.org</code>, über das <code>svn</code>-Protokoll.</p></div><div class=paragraph><p>Das Auschecken aus einem bestimmten Repository kann wie folgt durchgeführt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/repository/branch lcwdir</span></code></pre></div></div><div class=paragraph><p>wobei:</p></div><div class=ulist><ul><li><p><em>repository</em> eines der Projekt-Repositories ist: <code>base</code>, <code>ports</code> oder <code>doc</code>.</p></li><li><p><em>branch</em> vom verwendeten Repository abhängt. <code>ports</code> und <code>doc</code> werden meist im <code>head</code> Zweig aktualisiert, während <code>base</code> die neueste Version von -CURRENT unter <code>head</code> und die jeweilige neueste Version des -STABLE Zweiges unter <code>stable/9</code> (9.<em>x</em>) und <code>stable/10</code> (10.<em>x</em>) verwaltet wird.</p></li><li><p><em>lcwdir</em> das Zielverzeichnis ist, in dem die Inhalte des angegebenen Zweiges platziert werden sollen. Dies ist üblicherweise <span class=filename>/usr/ports</span> für <code>ports</code>, <span class=filename>/usr/src</span> für <code>base</code>, und <span class=filename>/usr/doc</span> für <code>doc</code>.</p></li></ul></div><div class=paragraph><p>Dieses Beispiel checkt die Ports-Sammlung aus dem Repositroy über das HTTPS-Protokoll aus, und speichert die Arbeitskopie unter <span class=filename>/usr/ports</span>. Wenn <span class=filename>/usr/ports</span> bereits vorhanden ist, aber nicht von <code>svn</code> erstellt wurde, denken Sie vor dem Auschecken daran, das Verzeichnis umzubenennen oder zu löschen.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/ports/head /usr/ports</span></code></pre></div></div><div class=paragraph><p>Dies kann eine Weile dauern, da beim ersten Auschecken der komplette Zweig vom entfernten Repository heruntergeladen werden muss. Bitte haben Sie Geduld.</p></div><div class=paragraph><p>Nach dem ersten Auschecken können Sie Ihre lokale Arbeitskopie wie folgt aktualisieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update lcwdir</span></code></pre></div></div><div class=paragraph><p>Um <span class=filename>/usr/ports</span> aus dem oben erstellten Beispiel zu aktualisieren, benutzen Sie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update /usr/ports</span></code></pre></div></div><div class=paragraph><p>Das Update ist viel schneller als ein Auschecken, da nur die Dateien übertragen werden müssen, die sich auch geändert haben.</p></div><div class=paragraph><p>Eine alternative Möglichkeit zur Aktualisierung Ihrer Arbeitskopie nach dem Auschecken ist es, das bestehende <span class=filename>Makefile</span> in den Verzeichnissen <span class=filename>/usr/ports</span>, <span class=filename>/usr/src</span>, und <span class=filename>/usr/doc</span> zu nutzen. Setzen Sie dazu <code>SVN_UPDATE</code> und benutzen Sie das <code>update</code> Ziel. Zum Beispiel, um <span class=filename>/usr/src</span> zu aktualisieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make update SVN_UPDATE=yes</span></code></pre></div></div></div><div class=sect2><h3 id=svn-mirrors>57.6. Subversion Mirror Sites<a class=anchor href=#svn-mirrors></a></h3><div class=paragraph><p>Das FreeBSD Subversion Repository ist:</p></div><div class="literalblock programlisting"><div class=content><pre>svn.FreeBSD.org</pre></div></div><div class=paragraph><p>Dies ist ein öffentlich zugängliches Netzwerk aus Spiegeln, das GeoDNS verwendet, um einen entsprechenden Backend-Server auszuwählen. Um das FreeBSD Subversion Repository über einen Browser anzuzeigen, verwenden Sie <a href=https://svnweb.FreeBSD.org/>http://svnweb.FreeBSD.org/</a>.</p></div><div class=paragraph><p>HTTPS ist das bevorzugte Protokoll, jedoch muss das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/security/ca_root_nss/>security/ca_root_nss</a> installiert werden, um Zertifikate automatisch zu validieren.</p></div></div><div class=sect2><h3 id=_weiterführende_informationen>57.7. Weiterführende Informationen<a class=anchor href=#_weiterführende_informationen></a></h3><div class=paragraph><p>Weitere Informationen über die Verwendung von Subversion finden Sie im "Subversion Buch" mit dem Namen <a href=http://svnbook.red-bean.com/>Versionskontrolle mit Subversion</a>, oder in der <a href=http://subversion.apache.org/docs/>Subversion Dokumentation</a>.</p></div></div></div></div><div class=sect1><h2 id=mirrors-rsync>Kapitel 58. Benutzen von rsync<a class=anchor href=#mirrors-rsync></a></h2><div class=sectionbody><div class=paragraph><p>Die folgenden Server stellen FreeBSD über das rsync-Protokoll zur Verfügung. Das Programm rsync überträgt lediglich geänderte Dateien und ist sehr nützlich, wenn Sie einen FreeBSD FTP-Spiegel betreiben. rsync ist für viele Betriebssysteme verfügbar. Für FreeBSD sehen Sie sich den Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> an.</p></div><div class=dlist><dl><dt class=hdlist1>Großbritannien</dt><dd><p>rsync://rsync.mirrorservice.org/</p><div class=paragraph><p>Verfügbare Sammlungen:</p></div><div class=ulist><ul><li><p>ftp.freebsd.org: Kompletter Spiegel des FreeBSD FTP-Servers.</p></li></ul></div></dd><dt class=hdlist1>Niederlande</dt><dd><p>rsync://ftp.nl.FreeBSD.org/</p><div class=paragraph><p>Verfügbare Sammlungen:</p></div><div class=ulist><ul><li><p>FreeBSD: Kompletter Spiegel des FreeBSD FTP-Servers.</p></li></ul></div></dd><dt class=hdlist1>Russland</dt><dd><p>rsync://ftp.mtu.ru/</p><div class=paragraph><p>Verfügbare Sammlungen:</p></div><div class=ulist><ul><li><p>FreeBSD: Kompletter Spiegel des FreeBSD FTP-Servers.</p></li><li><p>FreeBSD-Archive: Ein Spiegel des FreeBSD Archive-FTP-Servers.</p></li></ul></div></dd><dt class=hdlist1>Schweden</dt><dd><p>rsync://ftp4.se.freebsd.org/</p><div class=paragraph><p>Verfügbare Sammlungen:</p></div><div class=ulist><ul><li><p>FreeBSD: Kompletter Spiegel des FreeBSD FTP-Servers.</p></li></ul></div></dd><dt class=hdlist1>Taiwan</dt><dd><p>rsync://ftp.tw.FreeBSD.org/</p><div class=paragraph><p>rsync://ftp2.tw.FreeBSD.org/</p></div><div class=paragraph><p>rsync://ftp6.tw.FreeBSD.org/</p></div><div class=paragraph><p>Verfügbare Sammlungen:</p></div><div class=ulist><ul><li><p>FreeBSD: Kompletter Spiegel des FreeBSD FTP-Servers.</p></li></ul></div></dd><dt class=hdlist1>Tschechische Republik</dt><dd><p>rsync://ftp.cz.FreeBSD.org/</p><div class=paragraph><p>Verfügbare Sammlungen:</p></div><div class=ulist><ul><li><p>ftp: Unvollständiger Spiegel des FreeBSD FTP-Servers.</p></li><li><p>FreeBSD: Vollständiger Spiegel des FreeBSD FTP-Servers.</p></li></ul></div></dd><dt class=hdlist1>USA</dt><dd><p>rsync://ftp-master.FreeBSD.org/</p><div class=paragraph><p>Dieser Server darf nur von primären Spiegeln benutzt werden.</p></div><div class=paragraph><p>Verfügbare Sammlungen:</p></div><div class=ulist><ul><li><p>FreeBSD: Das Hauptarchiv des FreeBSD FTP-Servers.</p></li><li><p>acl: Die primäre ACL-Liste.</p><div class=paragraph><p>rsync://ftp13.FreeBSD.org/</p></div><div class=paragraph><p>Verfügbare Sammlungen:</p></div></li><li><p>FreeBSD: Kompletter Spiegel des FreeBSD FTP-Servers.</p></li></ul></div></dd></dl></div></div></div><div class=sect1><h2 id=bibliography>Anhang B: Bibliografie<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p>Während die Manualpages eine definitive Referenz über bestimmte Teile des FreeBSD-Betriebssystems bieten, so können sie jedoch selten veranschaulichen, wie man die einzelnen Teile zusammenfügt, um ein vollständig laufendes Betriebssystem herzustellen. Daher gibt es keinen Ersatz für ein gutes Buch oder Benutzerhandbuch über die Administration von UNIX®-Systemen.</p></div><div class=paragraph><p>In der Regel handelt es sich im folgenden Kapitel um englische Ausgaben der genannten Werke. Übersetzungen oder Ausgaben in anderen Sprachen sind mit entsprechenden Hinweisen versehen.</p></div><div class=sect2><h3 id=bibliography-freebsd>B.1. Bücher speziell für FreeBSD<a class=anchor href=#bibliography-freebsd></a></h3><div class=paragraph><p><em>Internationale Bücher:</em></p></div><div class=ulist><ul><li><p><a href=http://jdli.tw.FreeBSD.org/publication/book/freebsd2/index.htm>Using FreeBSD</a>, herausgegeben von <a href=http://www.drmaster.com.tw/>Drmaster</a>, 1997 (in traditionellem Chinesisch). ISBN 9-578-39435-7.</p></li><li><p>FreeBSD Unleashed (in vereinfachtem Chinesisch), herausgegeben von <a href=http://www.hzbook.com/>China Press</a>. ISBN 7-111-10201-0.</p></li><li><p>FreeBSD From Scratch Second Edition (in vereinfachtem Chinesisch), herausgegeben von <a href=http://www.hzbook.com/>China Press</a>. ISBN 7-111-10286-X.</p></li><li><p>FreeBSD Handbook Second Edition (in vereinfachtem Chinesisch), herausgegeben von <a href=http://www.ptpress.com.cn/>Posts & Telecom Press</a>. ISBN 7-115-10541-3.</p></li><li><p>FreeBSD & Windows (in vereinfachtem Chinesisch), herausgegeben von <a href=http://www.tdpress.com/>China Railway Publishing House</a>. ISBN 7-113-03845-X.</p></li><li><p>FreeBSD Internet Services HOWTO (in vereinfachtem Chinesisch), herausgegeben von China Railway Publishing House. ISBN 7-113-03423-3.</p></li><li><p>FreeBSD (in japanischer Sprache), herausgegeben von CUTT. ISBN 4-906391-22-2 C3055 P2400E.</p></li><li><p><a href="http://www.shoeisha.com/book/Detail.asp?bid=650">Complete Introduction to FreeBSD</a> (in Japanese), published by <a href=http://www.shoeisha.co.jp/>Shoeisha Co., Ltd</a>. ISBN 4-88135-473-6 P3600E.</p></li><li><p><a href=http://www.ascii.co.jp/pb/book1/shinkan/detail/1322785.html>Personal UNIX Starter Kit FreeBSD</a> (in japanischer Sprache), herausgegeben von <a href=http://www.ascii.co.jp/>ASCII</a>. ISBN 4-7561-1733-3 P3000E.</p></li><li><p>FreeBSD Handbook (japanische Übersetzung), herausgegeben von <a href=http://www.ascii.co.jp/>ASCII</a>. ISBN 4-7561-1580-2 P3800E.</p></li><li><p>FreeBSD mit Methode (in deutscher Sprache), herausgegeben von <a href=http://www.cul.de>Computer und Literatur Verlag</a> /Vertrieb Hanser, 1998. ISBN 3-932311-31-0.</p></li><li><p><a href=http://www.mitp.de/vmi/mitp/detail/pWert/1343/>FreeBSD de Luxe</a> (in German), published by <a href=http://www.mitp.de>Verlag Modere Industrie</a>, 2003. ISBN 3-8266-1343-0.</p></li><li><p><a href=http://www.pc.mycom.co.jp/FreeBSD/install-manual.html>FreeBSD Install and Utilization Manual</a> (in japanischer Sprache), herausgegeben von <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN 4-8399-0112-0.</p></li><li><p>Onno W Purbo, Dodi Maryanto, Syahrial Hubbany, Widjil Widodo <em><a href=http://maxwell.itb.ac.id/>Building Internet Server with FreeBSD</a></em> (in indonesischer Sprache), herausgegeben von <a href=http://www.elexmedia.co.id/>Elex Media Komputindo</a>.</p></li><li><p>Absolute BSD: The Ultimate Guide to FreeBSD (in traditionellem Chinesisch), herausgegeben von <a href=http://www.grandtech.com.tw/>GrandTech Press</a>, 2003. ISBN 986-7944-92-5.</p></li><li><p><a href=http://www.twbsd.org/cht/book/>The FreeBSD 6.0 Book</a> (in traditionellem Chinesisch, herausgegeben von Drmaster, 2006. ISBN 9-575-27878-X.</p></li></ul></div><div class=paragraph><p><em>Englischsprachige Bücher:</em></p></div><div class=ulist><ul><li><p><a href=http://www.absoluteFreeBSD.com/>Absolute FreeBSD, 2nd Edition: The Complete Guide to FreeBSD</a>, herausgegeben von <a href=http://www.nostarch.com/>No Starch Press</a>, 2007. ISBN: 978-1-59327-151-0</p></li><li><p><a href=http://www.freebsdmall.com/cgi-bin/fm/bsdcomp>The Complete FreeBSD</a>, herausgegeben von <a href=http://www.oreilly.com/>O’Reilly</a>, 2003. ISBN: 0596005164</p></li><li><p><a href=http://www.freebsd-corp-net-guide.com/>The FreeBSD Corporate Networker’s Guide</a>, herausgegeben von <a href=http://www.awl.com/aw/>Addison-Wesley</a>, 2002. ISBN: 0201704811</p></li><li><p><a href=http://andrsn.stanford.edu/FreeBSD/introbook/>FreeBSD: An Open-Source Operating System for Your Personal Computer</a>, herausgegeben von The Bit Tree Press, 2001. ISBN: 0971204500</p></li><li><p>Teach Yourself FreeBSD in 24 Hours, herausgegeben von <a href=http://www.samspublishing.com/>Sams</a>, 2002. ISBN: 0672324245</p></li><li><p>FreeBSD6 Unleashed, herausgegeben von <a href=http://www.samspublishing.com/>Sams</a>, 2006. ISBN: 0672328755</p></li><li><p>FreeBSD: The Complete Reference, herausgegeben von <a href=http://books.mcgraw-hill.com>McGrawHill</a>, 2003. ISBN: 0072224096</p></li></ul></div></div><div class=sect2><h3 id=bibliography-userguides>B.2. Handbücher<a class=anchor href=#bibliography-userguides></a></h3><div class=ulist><ul><li><p>Die Ohio State University hat ein <a href=http://www.cs.duke.edu/csl/docs/unix_course/>UNIX Introductory Course</a> veröffentlicht, welcher auch online im HTML- und PostScriptformat verfügbar ist.</p><div class=paragraph><p>Eine <a href=https://www.FreeBSD.org/doc/it_IT.ISO8859-15/books/unix-introduction/index.html>italienische Übersetzung</a> ist Teil des FreeBSD Italian Documentation Projects.</p></div></li><li><p><a href=http://www.ed.ac.uk/>Edinburgh University</a> hat einen <a href=http://www.ed.ac.uk/information-services/help-consultancy/is-skills/catalogue/program-op-sys-catalogue/unix1>Online Guide</a> für Anfänger in Sachen UNIX geschrieben.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-adminguides>B.3. Administrations-Anleitungen<a class=anchor href=#bibliography-adminguides></a></h3><div class=ulist><ul><li><p><a href=http://www.jp.FreeBSD.org/>Jpman Project, Japan FreeBSD Users Group</a>. <a href=http://www.pc.mycom.co.jp/FreeBSD/sam.html>FreeBSD System Administrator’s Manual</a> (japanische Übersetzung). <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN4-8399-0109-0 P3300E.</p></li><li><p>Dreyfus, Emmanuel. <a href=http://www.eyrolles.com/Informatique/Livre/9782212114638/>Cahiers de l’Admin: BSD</a> 2nd Ed. (in French), Eyrolles, 2004. ISBN 2-212-11463-X.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-programmers>B.4. Programmierhandbücher<a class=anchor href=#bibliography-programmers></a></h3><div class=ulist><ul><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Reference Manual</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-078-3</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Supplementary Documents</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-079-1</p></li><li><p>Harbison, Samuel P. and Steele, Guy L. Jr. <em>C: A Reference Manual</em>. 4th Ed. Prentice Hall, 1995. ISBN 0-13-326224-3</p></li><li><p>Kernighan, Brian and Dennis M. Ritchie. <em>The C Programming Language</em>. 2nd Ed., PTR Prentice Hall, 1988. ISBN 0-13-110362-9</p></li><li><p>Lehey, Greg. <em>Porting UNIX Software</em>. O’Reilly & Associates, Inc., 1995. ISBN 1-56592-126-7</p></li><li><p>Plauger, P. J. <em>The Standard C Library</em>. Prentice Hall, 1992. ISBN 0-13-131509-9</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codereading/>Code Reading: The Open Source Perspective</a>. Addison-Wesley, 2003. ISBN 0-201-79940-5</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codequality/>Code Quality: The Open Source Perspective</a>. Addison-Wesley, 2006. ISBN 0-321-16607-8</p></li><li><p>Stevens, W. Richard and Stephen A. Rago. <em>Advanced Programming in the UNIX Environment</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 2005. ISBN 0-201-43307-9</p></li><li><p>Stevens, W. Richard. <em>UNIX Network Programming</em>. 2nd Ed, PTR Prentice Hall, 1998. ISBN 0-13-490012-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-osinternals>B.5. Betriebssystem-Interna<a class=anchor href=#bibliography-osinternals></a></h3><div class=ulist><ul><li><p>Andleigh, Prabhat K. <em>UNIX System Architecture</em>. Prentice-Hall, Inc., 1990. ISBN 0-13-949843-5</p></li><li><p>Jolitz, William. "Porting UNIX to the 386". <em>Dr. Dobb’s Journal</em>. January 1991-July 1992.</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, Michael J Karels and John Quarterman <em>The Design and Implementation of the 4.3BSD UNIX Operating System</em>. Reading, Mass. : Addison-Wesley, 1989. ISBN 0-201-06196-1</p><div class=paragraph><p>Kapitel 2 dieses Buchs ist Teil des FreeBSD Documentation Projects und <a href=https://docs.freebsd.org/en/books/design-44bsd/>online</a> erhältlich.</p></div></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, <em>The Design and Implementation of the 4.3BSD UNIX Operating System: Answer Book</em>. Reading, Mass. : Addison-Wesley, 1991. ISBN 0-201-54629-9</p></li><li><p>McKusick, Marshall Kirk, Keith Bostic, Michael J Karels, and John Quarterman. <em>The Design and Implementation of the 4.4BSD Operating System</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-54979-4</p></li><li><p>Marshall Kirk McKusick, George V. Neville-Neil. <em>The Design and Implementation of the FreeBSD Operating System</em>. Boston, Mass. : Addison-Wesley, 2004. ISBN 0-201-70245-2</p></li><li><p>Marshall Kirk McKusick, George V. Neville-Neil, Robert N. M. Watson <em>The Design and Implementation of the FreeBSD Operating System, 2nd Ed.</em>. Westford, Mass: Pearson Education, Ind., 2014. ISBN 0-321-96897-2</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 1: The Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63346-9</p></li><li><p>Schimmel, Curt. <em>Unix Systems for Modern Architectures</em>. Reading, Mass. : Addison-Wesley, 1994. ISBN 0-201-63338-8</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63495-3</p></li><li><p>Vahalia, Uresh. <em>UNIX Internals — The New Frontiers</em>. Prentice Hall, 1996. ISBN 0-13-101908-2</p></li><li><p>Wright, Gary R. and W. Richard Stevens. <em>TCP/IP Illustrated, Volume 2: The Implementation</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63354-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-security>B.6. Sicherheits-Anleitung<a class=anchor href=#bibliography-security></a></h3><div class=ulist><ul><li><p>Cheswick, William R. and Steven M. Bellovin. <em>Firewalls and Internet Security: Repelling the Wily Hacker</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63357-4</p></li><li><p>Garfinkel, Simson. <em>PGP Pretty Good Privacy</em> O’Reilly & Associates, Inc., 1995. ISBN 1-56592-098-8</p></li></ul></div></div><div class=sect2><h3 id=bibliography-hardware>B.7. Hardware-Anleitung<a class=anchor href=#bibliography-hardware></a></h3><div class=ulist><ul><li><p>Anderson, Don and Tom Shanley. <em>Pentium Processor System Architecture</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40992-5</p></li><li><p>Ferraro, Richard F. <em>Programmer’s Guide to the EGA, VGA, and Super VGA Cards</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-62490-7</p></li><li><p>Die Intel Corporation veröffentlicht Dokumentationen Ihrer CPUs, Chipsets und Standards auf ihrer <a href=http://developer.intel.com/>developer web site</a>, normalerweise als PDF-Dateien.</p></li><li><p>Shanley, Tom. <em>80486 System Architecture</em>. 3rd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40994-1</p></li><li><p>Shanley, Tom. <em>ISA System Architecture</em>. 3rd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40996-8</p></li><li><p>Shanley, Tom. <em>PCI System Architecture</em>. 4th Ed. Reading, Mass. : Addison-Wesley, 1999. ISBN 0-201-30974-2</p></li><li><p>Van Gilluwe, Frank. <em>The Undocumented PC</em>, 2nd Ed. Reading, Mass: Addison-Wesley Pub. Co., 1996. ISBN 0-201-47950-8</p></li><li><p>Messmer, Hans-Peter. <em>The Indispensable PC Hardware Book</em>, 4th Ed. Reading, Mass: Addison-Wesley Pub. Co., 2002. ISBN 0-201-59616-4</p></li></ul></div></div><div class=sect2><h3 id=bibliography-history>B.8. UNIX® Geschichte<a class=anchor href=#bibliography-history></a></h3><div class=ulist><ul><li><p>Lion, John <em>Lion’s Commentary on UNIX, 6th Ed. With Source Code</em>. ITP Media Group, 1996. ISBN 1573980137</p></li><li><p>Raymond, Eric S. <em>The New Hacker’s Dictionary, 3rd edition</em>. MIT Press, 1996. ISBN 0-262-68092-0. Auch bekannt als das <a href=http://www.catb.org/~esr/jargon/html/index.html>Jargon File</a></p></li><li><p>Salus, Peter H. <em>A quarter century of UNIX</em>. Addison-Wesley Publishing Company, Inc., 1994. ISBN 0-201-54777-5</p></li><li><p>Simon Garfinkel, Daniel Weise, Steven Strassmann. <em>The UNIX-HATERS Handbook</em>. IDG Books Worldwide, Inc., 1994. ISBN 1-56884-203-1. <a href=http://www.simson.net/ref/ugh.pdf>Online</a> verfügbar.</p></li><li><p>Don Libes, Sandy Ressler <em>Life with UNIX</em> - special edition. Prentice-Hall, Inc., 1989. ISBN 0-13-536657-7</p></li><li><p><em>The BSD family tree</em>. <a href="https://svnweb.freebsd.org/base/head/shared/misc/bsd-family-tree?view=co">https://svnweb.freebsd.org/base/head/shared/misc/bsd-family-tree=view=co</a> oder unter <a href=file://localhost/usr/shared/misc/bsd-family-tree>/usr/shared/misc/bsd-family-tree</a> auf einem FreeBSD-System.</p></li><li><p><em>Networked Computer Science Technical Reports Library</em>.</p></li><li><p><em>Old BSD releases from the Computer Systems Research group (CSRG)</em>. <a href=http://www.mckusick.com/csrg/>http://www.mckusick.com/csrg/</a>: Das Paket mit 4 CD-ROMs enthält alle BSD-Versionen von 1BSD bis 4.4BSD und 4.4BSD-Lite2 (nicht aber 2.11BSD). Die letzte CD beinhaltet auch die finalen Sourcen inklusive den SCCS Dateien.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-journals>B.9. Zeitschriften, Magazine und Journale<a class=anchor href=#bibliography-journals></a></h3><div class=ulist><ul><li><p><a href=http://www.admin-magazin.de/>Admin Magazin</a> (in deutscher Sprache), herausgegeben von Medialinx AG. ISSN: 2190-1066</p></li><li><p><a href=http://www.bsdmag.org/>BSD Magazine</a>, herausgegeben von Software Press Sp. z o.o. SK. ISSN: 1898-9144</p></li><li><p><a href=http://www.bsdnow.tv/>BSD Now - Video Podcast</a>, herausgegeben von Jupiter Broadcasting LLC</p></li><li><p><a href=http://bsdtalk.blogspot.com/>BSD Talk Podcast</a>, von Will Backman</p></li><li><p><a href=http://freebsdjournal.com/>FreeBSD Journal</a>, herausgegeben von S&amp;W Publishing, gefördert durch The FreeBSD Foundation. ISBN: 978-0-615-88479-0</p></li></ul></div></div></div></div><div class=sect1><h2 id=eresources>Anhang C: Ressourcen im Internet<a class=anchor href=#eresources></a></h2><div class=sectionbody><div class=paragraph><p>Gedruckte Medien können mit der schnellen Entwicklung von FreeBSD nicht Schritt halten. Elektronische Medien sind häufig die einzige Möglichkeit, über aktuelle Entwicklungen informiert zu sein. Da FreeBSD ein Projekt von Freiwilligen ist, gibt die Benutzergemeinde selbst auch technische Unterstützung. Die Benutzergemeinde erreichen Sie am besten über E-Mail, Internetforen oder Usenet-News.</p></div><div class=paragraph><p>Die wichtigsten Wege, auf denen Sie die FreeBSD-Benutzergemeinde erreichen können, sind unten dargestellt. Schicken Sie weitere Ressourcen, die hier fehlen, an die Mailingliste des <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD documentation project</a>, damit diese hier aufgenommen werden können.</p></div><div class=sect2><h3 id=eresources-www>C.1. Webseiten<a class=anchor href=#eresources-www></a></h3><div class=ulist><ul><li><p><a href=https://forums.FreeBSD.org/>Die FreeBSD Foren</a> dienen als webbasiertes Diskussionsforum für Fragen und technische Diskussionen zu FreeBSD.</p></li><li><p>Der <a href=http://www.youtube.com/bsdconferences>BSDConferences YouTube-Kanal</a> beinhaltet eine Sammlung von qualitativ hochwertigen Videos von BSD Konferenzen aus der ganzen Welt. Dies ist eine ausgezeichnete Art und Weise, den Entwicklern beim Präsentieren von neuen Arbeiten an FreeBSD zuzuschauen.</p></li></ul></div></div><div class=sect2><h3 id=eresources-mail>C.2. Mailinglisten<a class=anchor href=#eresources-mail></a></h3><div class=paragraph><p>Die Mailinglisten sind der direkteste Weg, um Fragen an das gesamte FreeBSD Publikum zu stellen oder eine technische Diskussion zu beginnen. Es existiert eine große Vielfalt von Listen mit einer Reihe von verschiedenen FreeBSD Themen. Wenn Sie Fragen an die richtige Mailingliste richten können Sie viel eher mit einer passenden Antwort darauf rechnen.</p></div><div class=paragraph><p>Die Chartas der verschiedenen Listen sind unten wiedergegeben. <em>Bevor Sie sich einer Mailingliste anschließen oder E-Mails an eine Liste senden, lesen Sie bitte die Charta der Liste.</em> Die meisten Mitglieder der Mailinglisten erhalten jeden Tag Hunderte E-Mails zum Thema FreeBSD. Die Chartas und Regeln, die den Gebrauch der Listen beschreiben, garantieren die hohe Qualität der Listen. Die Listen würden ihren hohen Wert für das Projekt verlieren, wenn wir weniger Regeln aufstellen würden.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>Um zu testen, ob Sie eine Nachricht an eine FreeBSD-Liste senden können, verwenden Sie bitte die Liste <a href=https://lists.FreeBSD.org/subscription/freebsd-test>FreeBSD test</a>.</em> Schicken Sie derartige Nachrichten bitte nicht an eine der anderen Listen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn Sie Sich nicht sicher sind, auf welcher Liste Sie Ihre Frage stellen sollen, sollten Sie den Artikel <a href=https://docs.freebsd.org/en/articles/freebsd-questions/>How to get best results from the FreeBSD-questions mailing list</a> lesen.</p></div><div class=paragraph><p>Bevor Sie eine Nachricht an eine Mailingliste senden, sollten Sie die korrekte Nutzung der Mailinglisten erlernen. Dazu gehört auch das Vermeiden von sich häufig wiederholenden Diskussionen (lesen Sie deshalb zuerst die <a href=https://docs.freebsd.org/en/articles/mailing-list-faq/>Mailing List Frequently Asked Questions</a>).</p></div><div class=paragraph><p>Alle Mailinglisten werden archiviert und können auf dem <a href=https://www.FreeBSD.org/search/>FreeBSD World Wide Web Server</a> durchsucht werden. Das nach Schlüsselwörtern durchsuchbare Archiv bietet die hervorragende Möglichkeit, Antworten auf häufig gestellte Fragen zu finden. Nutzen Sie bitte diese Möglichkeit, bevor Sie Fragen auf einer Liste stellen. Beachten Sie auch, dass das zur Folge hat, dass die Nachrichten an die FreeBSD Mailinglisten für die Ewigkeit erhalten bleiben. Wenn Sie am Schutz Ihrer Privatsphäre interessiert sind, ziehen Sie die Verwendung einer Wegwerf-E-Mail-Adresse in Betracht und schreiben Sie nur solche Nachrichten, die für die Öffentlichkeit bestimmt sind.</p></div><div class=sect3><h4 id=eresources-summary>C.2.1. Beschreibung der Mailinglisten<a class=anchor href=#eresources-summary></a></h4><div class=paragraph><p><em>Allgemeine Listen:</em> Jeder kann die folgenden allgemeinen Listen abonnieren (und ist dazu aufgefordert):</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Mailingliste</th><th class="tableblock halign-left valign-top">Zweck</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-advocacy>freebsd-advocacy</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Verbreitung von FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-announce>FreeBSD announcements</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Wichtige Ereignisse und Meilensteine des Projekts (moderiert)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-arch>freebsd-arch</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Architektur und Design von FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bugbusters>freebsd-bugbusters</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussionen über die Pflege der FreeBSD Fehlerberichte-Datenbank und die dazu benutzten Werkzeuge</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>freebsd-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fehlerberichte</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-chat>freebsd-chat</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nicht technische Themen, welche die FreeBSD-Gemeinschaft betreffen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-chromium>freebsd-chromium</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussionen zum Einsatz von Chromium unter FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gebrauch von FreeBSD-CURRENT</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-isp>freebsd-isp</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Für Internet-Service-Provider, die FreeBSD benutzen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-jobs>freebsd-jobs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Anstellung und Beratung im FreeBSD-Umfeld</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-quarterly-calls>freebsd-quarterly-calls</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Aufrufe für vierteljährliche Statusberichte (moderiert)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Benutzerfragen und technische Unterstützung</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>FreeBSD security notifications</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ankündigungen zum Thema Sicherheit (moderiert)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-stable>FreeBSD-STABLE;</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gebrauch von FreeBSD-STABLE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-test>FreeBSD test</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Schicken Sie Testnachrichten an diese Liste anstelle der wirklichen Listen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-women>freebsd-women</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD Befürwortung von Frauen</p></td></tr></tbody></table><div class=paragraph><p><em>Technische Listen:</em> Auf den folgenden Listen werden technische Diskussionen geführt. Bevor Sie eine der Listen abonnieren oder Nachrichten an sie schicken, lesen Sie sich die Charta der Liste durch, da der Inhalt und Zweck dieser Listen genau festgelegt ist.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Mailingliste</th><th class="tableblock halign-left valign-top">Zweck</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Entwicklung von ACPI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-amd64>freebsd-amd64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von FreeBSD auf AMD64-Systeme (moderiert)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-apache>freebsd-apache</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über Ports, die mit Apache zusammenhängen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-arm>freebsd-arm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von FreeBSD auf ARM®-Prozessoren</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-atm>freebsd-atm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Benutzung von ATM-Netzen mit FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bluetooth>freebsd-bluetooth</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bluetooth® unter FreeBSD verwenden</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-cloud>freebsd-cloud</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD auf Cloud-Plattformen (EC2, GCE, Azure, etc.)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-cluster>freebsd-cluster</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Benutzung von FreeBSD in einem Cluster</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-database>freebsd-database</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über Datenbanken und Datenbankprogrammierung unter FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-desktop>freebsd-desktop</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD als Desktop verwenden und verbessern</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-ci>dev-ci</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Build- und Testberichte von den Continuous Integration Servern</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-reviews>dev-reviews</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Benachrichtigungen über das Review-System von FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-doc>freebsd-doc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Erstellen der FreeBSD-Dokumentation</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-drivers>freebsd-drivers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gerätetreiber für FreeBSD schreiben</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-dtrace>freebsd-dtrace</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Entwicklung und Benutzung von DTrace unter FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-eclipse>freebsd-eclipse</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Für FreeBSD-Anwender, welche die Eclipse IDE, deren Werkzeuge, Anwendungen und Ports einsetzen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-elastic>freebsd-elastic</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion zu ElasticSearch unter FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD in eingebetteten Anwendungen einsetzen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-emulation>freebsd-emulation</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Emulation anderer Systeme wie Linux®, MS-DOS® oder Windows®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-enlightenment>freebsd-enlightenment</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von Enlightenment und Enlightenment-Applikationen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-eol>freebsd-eol</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Support für FreeBSD-bezogene Software, die vom FreeBSD Project offiziell nicht mehr unterstützt wird.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-erlang>freebsd-erlang</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-spezifische Erlang-Diskussionen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-firewire>freebsd-firewire</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Technische Diskussion über FreeBSD FireWire® (iLink, IEEE 1394)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-fortran>freebsd-fortran</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fortran unter FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-fs>freebsd-fs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dateisysteme</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-games>freebsd-games</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Unterstützung für Spiele unter FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-gecko>freebsd-gecko</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Angelegenheiten zur Gecko Rendering Engine</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-geom>freebsd-geom</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über GEOM</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-git>freebsd-git</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussionen zur Verwendung von git im FreeBSD Project</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-gnome>freebsd-gnome</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von GNOME und GNOME-Anwendungen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>freebsd-hackers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Allgemeine technische Diskussionen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-haskell>freebsd-haskell</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-spezifische Haskell-Themen und Diskussionen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hardware>freebsd-hardware</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Allgemeine Diskussion über Hardware, auf der FreeBSD läuft</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-i18n>freebsd-i18n</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Internationalisierung von FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-infiniband>freebsd-infiniband</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Infiniband unter FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ipfw>freebsd-ipfw</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Technische Diskussion über die Neubearbeitung der IP-Firewall Quellen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Für Entwickler des ISDN-Systems</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-java>freebsd-java</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Für Java™ Entwickler und Leute, die JDK™s nach FreeBSD portieren</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://mail.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von KDE und KDE-Anwendungen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-lfs>freebsd-lfs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von LFS nach FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mips>freebsd-mips</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von FreeBSD zu MIPS®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mono>freebsd-mono</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mono und C# Anwendungen auf FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-multimedia>FreeBSD multimedia</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Multimedia Anwendungen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-new-bus>freebsd-new-bus</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Technische Diskussionen über die Architektur von Bussen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-net>freebsd-net</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über Netzwerke und den TCP/IP Quellcode</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-numerics>freebsd-numerics</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussionen über die Implementierung hochwertiger Funktionen in libm</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ocaml>freebsd-ocaml</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-spezifische Diskussionen zu OCaml</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-office>freebsd-office</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Office-Anwendungen für FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-performance>freebsd-performance</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fragen zur Optimierung der Leistung stark ausgelasteter Systeme</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-perl>freebsd-perl</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pflege der portierten Perl-Anwendungen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pf>freebsd-pf</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussionen und Fragen zu packet filter als Firewallsystem.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pkg>freebsd-pkg</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussionen über die Verwaltung von Binärpaketen und entsprechenden Werkzeugen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pkg-fallout>freebsd-pkg-fallout</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Protokolle von fehlgeschlagenen Paketbauvorgängen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pkgbase>freebsd-pkgbase</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Paketierung des FreeBSD-Basissystems</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-platforms>freebsd-platforms</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierungen von FreeBSD auf nicht-Intel® Architekturen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports>freebsd-ports</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über die Ports-Sammlung</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-announce>freebsd-ports-announce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Wichtige Neuigkeiten und Anweisungen zur Ports-Sammlung (moderiert)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>freebsd-ports-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über Fehler und PRs der Ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ppc>freebsd-ppc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von FreeBSD auf den PowerPC®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-proliant>freebsd-proliant</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Technische Diskussionen zum Einsatz von FreeBSD auf HP ProLiant-Serverplattformen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-python>freebsd-python</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-spezifische Diskussionen zu Python</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-rc>freebsd-rc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über das <span class=filename>rc.d</span>-System sowie dessen Weiterentwicklung</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-realtime>freebsd-realtime</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Entwicklung von Echtzeiterweiterungen für FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-riscv>freebsd-riscv</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von FreeBSD auf RISC-V®-Systeme</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ruby>freebsd-ruby</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-spezifische Diskussionen zu Ruby</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-scsi>freebsd-scsi</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über das SCSI-Subsystem</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-security>FreeBSD security</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sicherheitsthemen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-snapshots>freebsd-snapshots</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ankündigungen für FreeBSD Entwickler-Snapshots</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-sparc64>freebsd-sparc64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von FreeBSD auf SPARC® Systeme</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-standards>freebsd-standards</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Konformität von FreeBSD mit den C99- und POSIX®-Standards</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-sysinstall>freebsd-sysinstall</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> Entwicklung</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-tcltk>freebsd-tcltk</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD spezifische Tcl/TK Diskussionen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-testing>freebsd-testing</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tests unter FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-tex>freebsd-tex</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung von TeX und dessen Anwendungen nach FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-threads>freebsd-threads</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Leichtgewichtige Prozesse (Threads) in FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-tilera>freebsd-tilera</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussionen zur Portierung von FreeBSD auf die Tilera-CPU-Familie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-tokenring>freebsd-tokenring</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Token-Ring Unterstützung in FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-toolchain>freebsd-toolchain</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Wartung der FreeBSD-Toolchain</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-translators>freebsd-translators</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Übersetzung von FreeBSD-Dokumenten und Programmen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-transport>freebsd-transport</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über Transportprotokolle in FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-usb>freebsd-usb</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>USB-Unterstützung in FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-virtualization>freebsd-virtualization</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über verschiedene Virtualisierungsverfahren, die von FreeBSD unterstützt werden</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-vuxml>freebsd-vuxml</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussion über die Infrastruktur von VuXML</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-x11>freebsd-x11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Wartung und Unterstützung von X11 auf FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-xen>freebsd-xen</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussionen über die FreeBSD Portierung auf Xen™ - Implementierung und Verwendung</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-xfce>freebsd-xfce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portierung und Wartung von XFCE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-zope>freebsd-zope</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zope für FreeBSD - Portierung und Wartung</p></td></tr></tbody></table><div class=paragraph><p><em>Eingeschränkte Listen:</em> Die folgenden Listen wenden sich an Zielgruppen mit speziellen Anforderungen und sind nicht für die Öffentlichkeit gedacht. Bevor Sie eine dieser Listen abonnieren, sollten Sie einige der technischen Listen abonniert haben, um mit den Umgangsformen vertraut zu sein.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Mailingliste</th><th class="tableblock halign-left valign-top">Zweck</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hubs>freebsd-hubs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Betrieb von FreeBSD-Spiegeln</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-user-groups>freebsd-user-groups</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Koordination von Benutzergruppen</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-wip-status>freebsd-wip-status</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Status von in Arbeit befindlichen FreeBSD-Tätigkeiten</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-wireless>freebsd-wireless</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diskussionen zum 802.11-Stack sowie zur Entwicklung von Tools und Gerätetreibern</p></td></tr></tbody></table><div class=paragraph><p><em>Zusammenfassungen:</em> Alle eben aufgezählten Listen sind auch in zusammengefasster Form (digest) erhältlich. In den Einstellungen Ihres Accounts legen Sie fest, in welcher Form Sie die Listen empfangen.</p></div><div class=paragraph><p><em>SVN Listen:</em> Die folgenden Listen versenden die Log-Einträge zu Änderungen an verschiedenen Teilen des Quellbaums. Diese Listen sollen <em>nur gelesen</em> werden, schicken Sie bitte keine Nachrichten an eine der Listen.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Mailingliste</th><th class="tableblock halign-left valign-top">Teil des Quellbaums</th><th class="tableblock halign-left valign-top">Beschreibung</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-doc-all>svn-doc-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im doc Subversion Repository (mit Ausnahme von <span class=filename>user</span>, <span class=filename>projects</span> und <span class=filename>translations</span>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-doc-head>svn-doc-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im "head"-Zweig des doc Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-doc-projects>svn-doc-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>projects</span>-Bereich des doc Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-doc-svnadmin>svn-doc-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen an den administrativen Skripten, Hooks und anderen Konfigurationsdateien des doc Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-ports-all>svn-ports-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alle Änderungen des ports Subverison Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-ports-head>svn-ports-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im "head"-Zweig des ports Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-ports-svnadmin>svn-ports-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen an den administrativen Skripten, Hooks und anderen Konfigurationsdateien des ports Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-all>SVN commit messages for the entire src tree (except for "user" and "projects")</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im src Subversion Repository (außer für <span class=filename>user</span> und <span class=filename>projects</span>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-head>SVN commit messages for the src tree for head/-current</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im "head" Zweig des src Subversion Repository (der FreeBSD-CURRENT Zweig)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-projects>svn-src-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>projects</span> Bereich des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-release>svn-src-release</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>releases</span> Bereich des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-releng>svn-src-releng</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>releng</span> Zweig des src Subversion Repository (der security / release engineering Zweige)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable>svn-src-stable</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen an allen stable Zweigen des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-6>svn-src-stable-6</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>stable/6</span> Zweig des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-7>svn-src-stable-7</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>stable/7</span> Zweig des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href={svn-src-stable-8-url}>svn-src-stable-8</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>stable/8</span> Zweig des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-9>SVN commit messages for only the 9-stable src tree</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>stable/9</span> Zweig des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-10>svn-src-stable-10</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>stable/10</span> Zweig des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-11>svn-src-stable-11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>stable/11</span> Zweig des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-12>svn-src-stable-12</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen im <span class=filename>stable/12</span> Zweig des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-stable-other>svn-src-stable-other</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen an älteren <span class=filename>stable</span> Zweigen des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-svnadmin>svn-src-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen an den administrativen Skripten, hooks, und anderen Daten zur Konfiguration des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-user>svn-src-user</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen am experimentellen <span class=filename>user</span> Bereich des src Subversion Repository</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/svn-src-vendor>svn-src-vendor</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Änderungen am Herstellerbereich des src Subversion Repository</p></td></tr></tbody></table></div><div class=sect3><h4 id=eresources-subscribe>C.2.2. Mailinglisten abonnieren<a class=anchor href=#eresources-subscribe></a></h4><div class=paragraph><p>Um eine Liste zu abonnieren, besuchen die Webseite <a href=https://lists.freebsd.org class=bare>https://lists.freebsd.org</a> und klicken dort auf die Liste, die Sie abonnieren wollen. Sie gelangen dann auf die Webseite der Liste, die weitere Anweisungen für diese Liste enthält.</p></div><div class=paragraph><p>Um eine Nachricht an eine Mailingliste zu schicken, schreiben Sie einfach eine E-Mail an <a href=mailto:Liste@FreeBSD.org>Liste@FreeBSD.org</a>. Die E-Mail wird dann an alle Mitglieder der Mailingliste verteilt.</p></div><div class=paragraph><p>Wenn Sie das Abonnement aufheben wollen, folgen Sie der URL, die am Ende jeder Mail der Liste angegeben ist. Sie können das Abonnement auch mit einer E-Mail an <a href=mailto:Liste-unsubscribe@FreeBSD.org>Liste-unsubscribe@FreeBSD.org</a> aufheben.</p></div><div class=paragraph><p>Verwenden Sie bitte die technischen Listen ausschließlich für technische Diskussionen. Wenn Sie nur an wichtigen Ankündigungen interessiert sind, abonnieren Sie die Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>FreeBSD announcements</a>, auf der nur wenige Nachrichten versendet werden.</p></div></div><div class=sect3><h4 id=eresources-charters>C.2.3. Chartas der Mailinglisten<a class=anchor href=#eresources-charters></a></h4><div class=paragraph><p><em>Alle</em> FreeBSD-Mailinglisten besitzen Grundregeln, die von jedem beachtet werden müssen. Für die ersten beiden Male, in denen ein Absender gegen diese Regeln verstößt, erhält er jeweils eine Warnung vom FreeBSD-Postmaster <a href=mailto:postmaster@FreeBSD.org>postmaster@FreeBSD.org</a>. Ein dritter Verstoß gegen die Regeln führt dazu, dass der Absender in allen FreeBSD-Mailinglisten gesperrt wird und weitere Nachrichten von ihm nicht mehr angenommen werden. Wir bedauern sehr, dass wir solche Maßnahmen ergreifen müssen, aber heutzutage ist das Internet eine recht rauhe Umgebung, in der immer weniger Leute Rücksicht aufeinander nehmen.</p></div><div class=paragraph><p>Die Regeln:</p></div><div class=ulist><ul><li><p>Das Thema einer Nachricht soll der Charta der Liste, an die sie gesendet wird, entsprechen. Wenn Sie eine Nachricht an eine technische Liste schicken, sollte die Nachricht auch technische Inhalte haben. Fortwährendes Geschwätz oder Streit mindern den Wert der Liste für alle Mitglieder und wird nicht toleriert. Benutzen Sie <a href=https://lists.FreeBSD.org/subscription/freebsd-chat>FreeBSD chat</a> für allgemeine Diskussionen über FreeBSD.</p></li><li><p>Eine Nachricht sollte an nicht mehr als zwei Mailinglisten gesendet werden. Schicken Sie eine Nachricht nur dann an zwei Listen, wenn das wirklich notwendig ist. Viele Leute haben mehrere Mailinglisten abonniert und Nachrichten sollten nur zu ungewöhnlichen Kombinationen der Listen, wie "-stable" und "-scsi", gesendet werden. Wenn Sie eine Nachricht erhalten, die im <code>Cc</code>-Feld mehrere Listen enthält, sollten Sie das Feld kürzen, bevor Sie eine Antwort darauf verschicken. <em>Unabhängig von dem ursprünglichen Verteiler sind Sie für Ihre eigenen Mehrfach-Sendungen selbst verantwortlich.</em></p></li><li><p>Persönliche Angriffe und Beschimpfungen sind in einer Diskussion nicht erlaubt. Dies gilt gleichermaßen für Benutzer wie Entwickler. Grobe Verletzungen der Netiquette, wie das Verschicken oder Zitieren von privater E-Mail ohne eine entsprechende Genehmigung, werden nicht gebilligt. Die Nachrichten werden aber nicht besonders auf Verletzungen der Netiquette untersucht. Es kann sein, dass eine Verletzung der Netiquette durchaus zu der Charta einer Liste passt, aber der Absender aufgrund der Verletzung eine Warnung erhält oder gesperrt wird.</p></li><li><p>Werbung für Produkte oder Dienstleistungen, die nichts mit FreeBSD zu tun haben, sind verboten. Ist die Werbung als Spam verschickt worden, wird der Absender sofort gesperrt.</p></li></ul></div><div class=paragraph><p><em>Chartas einzelner Listen:</em></p></div><div class=dlist><dl><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI</a></dt><dd><p>Die Entwicklung von ACPI und Energieverwaltungsfunktionen.</p></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-announce>FreeBSD announcements</a></dt><dd><p><em>Wichtige Ereignisse und Meilensteine</em></p><div class=paragraph><p>Diese Liste ist für Personen, die nur an den wenigen Ankündigungen wichtiger Ereignisse interessiert sind. Die Ankündigungen betreffen Schnappschüsse und Releases, neue Merkmale von FreeBSD und die Suche nach freiwilligen Mitarbeitern. Auf der Liste herrscht wenig Verkehr und sie wird streng moderiert.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-arch>freebsd-arch</a></dt><dd><p><em>Architektur und Design von FreeBSD</em></p><div class=paragraph><p>Auf dieser technischen Liste wird die FreeBSD-Architektur diskutiert. Beispiele für angemessene Themen sind:</p></div><div class=ulist><ul><li><p>Wie das Bausystem zu verändern ist, damit verschiedene Läufe gleichzeitig möglich sind.</p></li><li><p>Was am VFS geändert werden muss, damit Heidemann Schichten eingesetzt werden können.</p></li><li><p>Wie die Schnittstelle der Gerätetreiber angepasst werden muss, damit derselbe Treiber auf verschiedenen Bussen und Architekturen eingesetzt werden kann.</p></li><li><p>Wie ein Netzwerktreiber geschrieben wird.</p></li></ul></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bluetooth>freebsd-bluetooth</a></dt><dd><p><em>Bluetooth® unter FreeBSD</em></p><div class=paragraph><p>Diese Liste diskutiert Probleme der Verwendung von Bluetooth® unter FreeBSD. Designprobleme, Implementierungsdetails, Patches, Fehler- und Statusberichte, Verbesserungsvorschläge sowie alle anderen mit Bluetooth® zusammenhängenden Themen werden hier behandelt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bugbusters>freebsd-bugbusters</a></dt><dd><p><em>Bearbeitung der Fehlerberichte</em></p><div class=paragraph><p>Auf dieser Liste wird die Bearbeitung der Fehlerberichte (PR, engl. problem report) koordiniert. Sie dient dem "Bugmeister" und allen Leuten, die ein Interesse an der Datenbank der Fehlerberichte haben, als Diskussionsforum. Auf dieser Liste werden keine spezifischen Fehler, Fehlerbehebungen oder PRs diskutiert.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>freebsd-bugs</a></dt><dd><p><em>Fehlerberichte</em></p><div class=paragraph><p>Auf dieser Liste werden Fehlerberichte gesammelt. Fehlerberichte sollten immer mit der <a href=https://bugs.freebsd.org/bugzilla/enter_bug.cgi>Web-Schnittstelle</a> erstellt werden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-chat>freebsd-chat</a></dt><dd><p><em>Nicht technische Themen, welche die FreeBSD Gemeinschaft betreffen</em></p><div class=paragraph><p>Auf dieser Liste werden nicht-technische soziale Themen diskutiert, die nicht auf die anderen Listen passen. Hier kann diskutiert werden, ob Jordan wie ein Frettchen aus einem Zeichentrickfilm aussieht oder nicht, ob grundsätzlich in Großbuchstaben geschrieben werden soll, wer zuviel Kaffee trinkt, wo das beste Bier gebraut wird und wer Bier in seinem Keller braut. Gelegentlich können auf den technischen Listen wichtige Ereignisse wie Feste, Hochzeiten oder Geburten angekündigt werden, aber nachfolgende Nachrichten sollten auf die Liste <a href=https://lists.FreeBSD.org/subscription/freebsd-chat>FreeBSD chat</a> gesendet werden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-chromium>freebsd-chromium</a></dt><dd><p><em>Diskussionen zum Einsatz von Chromium unter FreeBSD</em></p><div class=paragraph><p>Auf dieser technischen Liste werden Fragen zur Entwicklung, zur Installation sowie zum Einsatz von Chromium unter FreeBSD diskutiert.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-cloud>freebsd-cloud</a></dt><dd><p><em>FreeBSD auf verschiedenen Cloud-Plattformen betreiben</em></p><div class=paragraph><p>Diese Liste diskutiert FreeBSD auf Amazon EC2, Google Compute Engine, Microsoft Azure und weiteren Cloud-Plattformen.</p></div></dd><dt class=hdlist1>freebsd-core</dt><dd><p><em>FreeBSD Core Team</em></p><div class=paragraph><p>Dies ist eine interne Mailingliste des FreeBSD Core Teams. Wenn in einer wichtigen Angelegenheit, die FreeBSD betrifft, entschieden werden muss oder die Angelegenheit einer genauen Prüfung unterzogen werden muss, können Nachrichten an diese Liste gesendet werden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT</a></dt><dd><p><em>Gebrauch von FreeBSD-CURRENT</em></p><div class=paragraph><p>Diese Mailingliste ist für die Benutzer von FreeBSD-CURRENT eingerichtet. Auf ihr finden sich Ankündigungen über Besonderheiten von -CURRENT, von denen Benutzer betroffen sind. Sie enthält weiterhin Anweisungen, wie man ein System auf -CURRENT hält. Jeder, der ein -CURRENT System besitzt, muss diese Liste lesen. Die Liste ist nur für technische Inhalte bestimmt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-desktop>freebsd-desktop</a></dt><dd><p><em>FreeBSD als Desktop verwenden und verbessern</em></p><div class=paragraph><p>Dies ist ein Forum für Diskussionen um FreeBSD auf dem Desktop. Es wird primär von Desktop-Portierern und Nutzern verwendet, um Probleme und Verbesserungen zu FreeBSDs Einsatz auf dem Desktop zu besprechen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-doc>freebsd-doc</a></dt><dd><p>Auf dieser Mailingliste werden Themen diskutiert, die im Zusammenhang mit der Erstellung der FreeBSD Dokumentation stehen. "The FreeBSD Documentation Project" besteht aus den Mitgliedern dieser Liste. Diese Liste steht jedem offen, Sie sind herzlich eingeladen teilzunehmen und mitzuhelfen.</p></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-drivers>freebsd-drivers</a></dt><dd><p><em>Gerätetreiber für FreeBSD schreiben</em></p><div class=paragraph><p>Ein Forum für technische Diskussionen über das Schreiben von Gerätetreibern für FreeBSD. Daher werden hier vor allem Fragen behandelt, die sich um das Schreiben von Treibern, welche die APIs des Kernels nutzen, drehen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-dtrace>freebsd-dtrace</a></dt><dd><p><em>Entwicklung und Benutzung von DTrace unter FreeBSD</em></p><div class=paragraph><p>DTrace ist Bestandteil von FreeBSD und stellt Laufzeitinformationen vom Kernel und Anwendungsprogrammen zur Verfügung. Diese Liste ist für Diskussionen von Entwicklern und Benutzern.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-eclipse>freebsd-eclipse</a></dt><dd><p><em>Für FreeBSD-Anwender, welche die Eclipse IDE deren Werkzeuge, Anwendungen und Ports einsetzen</em></p><div class=paragraph><p>Das Ziel dieser Liste ist es, Unterstützung für all jene zu bieten, die mit der Installation, Verwendung, Entwicklung und Wartung der Eclipse-IDE sowie deren Werkzeugen und Anwendungen unter FreeBSD zu tun haben. Außerdem wird Hilfe bei der Portierung der IDE und deren Plugins auf FreeBSD geboten.</p></div><div class=paragraph><p>Zusätzlich soll diese Liste einen Informationsaustausch zwischen der Eclipse- und der FreeBSD-Gemeinde ermöglichen, von dem beide Seiten profitieren können.</p></div><div class=paragraph><p>Obwohl sich diese Liste auf die Anforderungen von Anwendern konzentriert, möchte sie auch Entwickler unterstützen, die an der Entwicklung von FreeBSD-spezifischen Anwendungen unter Nutzung des Eclipse-Frameworks arbeiten.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a></dt><dd><p><em>FreeBSD in eingebetteten Anwendungen einsetzen</em></p><div class=paragraph><p>Diese Liste diskutiert Themen im Zusammenhang mit dem Einsatz von ungewöhnlich kleinen und eingebetteten FreeBSD-Installationen. Auf dieser Liste werden ausschließlich technische Diskussionen geführt. Unter eingebetteten Systemen versteht diese Liste Systeme, bei denen es sich nicht um Desktopsysteme handelt, und die in der Regel nur einem einzigen Zweck dienen (im Gegensatz zu Desktopsystemen, die für die Bewältigung verschiedenster Aufgaben geeignet sind). In die Gruppe der eingebetteten Systeme gehören beispielsweise Telefone, Netzwerkgeräte wie Router, Switche oder PBX-Systeme, PDAs, Verkaufsautomaten und andere mehr.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-emulation>freebsd-emulation</a></dt><dd><p><em>Emulation anderer Systeme wie Linux®, MS-DOS® oder Windows®</em></p><div class=paragraph><p>Hier werden technische Diskussionen zum Einsatz von Programmen, die für andere Betriebssysteme geschrieben wurden, geführt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-enlightenment>freebsd-enlightenment</a></dt><dd><p><em>Enlightenment</em> Desktop-Umgebung für FreeBSD-Systeme. Dies ist eine technische Liste, in der nur technische Inhalte erwartet werden.</p></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-eol>freebsd-eol</a></dt><dd><p><em>Support für FreeBSD-bezogene Software, die vom FreeBSD Project offiziell nicht mehr unterstützt wird.</em></p><div class=paragraph><p>Diese Liste ist für all jene interessant, die Unterstützung für vom FreeBSD Project offiziell nicht mehr (in Form von Security Advisories oder Patches) unterstützte Programme benötigen oder anbieten wollen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-firewire>freebsd-firewire</a></dt><dd><p><em>FireWire® (iLink, IEEE 1394)</em></p><div class=paragraph><p>Auf dieser Liste wird das Design und die Implementierung eines FireWire®-Subsystems (auch IEEE 1394 oder iLink) für FreeBSD diskutiert. Relevante Themen sind die Standards, Busse und ihre Protokolle, sowie Adapter, Karten und Chipsätze. Des Weiteren die Architektur und der Quellcode, die nötig sind, diese Geräte zu unterstützen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-fortran>freebsd-fortran</a></dt><dd><p><em>Fortran unter FreeBSD</em></p><div class=paragraph><p>Diese Liste ist für Diskussionen rund um Fortran-Ports unter FreeBSD: Compiler, Bibliotheken, wissenschaftliche und technische Anwendungen von Laptops bis hin zu HPC-Clustern.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-fs>freebsd-fs</a></dt><dd><p><em>Dateisysteme</em></p><div class=paragraph><p>Diskussionen über FreeBSD-Dateisysteme. Dies ist eine technische Liste, in der nur technische Inhalte erwartet werden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-games>freebsd-games</a></dt><dd><p><em>Spiele unter FreeBSD</em></p><div class=paragraph><p>Eine Liste für technische Diskussionen im Zusammenhang mit Spielen unter FreeBSD. Die Liste ist für Personen, die an Portierungen arbeiten und alternative Lösungen erörtern. Personen, die an technischen Diskussionen interessiert sind, sind ebenfalls willkommen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-gecko>freebsd-gecko</a></dt><dd><p>Angelegenheiten zur <em>Gecko Rendering Engine</em></p><div class=paragraph><p>Dies ist ein Forum über Gecko-Anwendungen, die FreeBSD verwenden.</p></div><div class=paragraph><p>Die Diskussion dreht sich um die Portierung von Gecko-Anwendungen, deren Installation, die Entwicklung sowie deren Unterstützung innerhalb von FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-geom>freebsd-geom</a></dt><dd><p><em>GEOM</em></p><div class=paragraph><p>Diskussion über GEOM und verwandte Implementierungen. Dies ist eine technische Liste, in der nur technische Inhalte erwartet werden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-git>freebsd-git</a></dt><dd><p><em>Verwendung von git im FreeBSD Project</em></p><div class=paragraph><p>Diskussionen über die Verwendung von git in der FreeBSD Infrastruktur. Personen, die einen Spiegel aufsetzen wollen, oder allgemeine Fragen zu git unter FreeBSD haben, können hier Fragen stellen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-gnome>freebsd-gnome</a></dt><dd><p><em>GNOME</em></p><div class=paragraph><p>Diskussionen über die grafische Benutzeroberfläche GNOME. Dies ist eine technische Liste, in der nur technische Inhalte erwartet werden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-infiniband>freebsd-infiniband</a></dt><dd><p><em>Infiniband unter FreeBSD</em></p><div class=paragraph><p>Technische Liste mit Diskussionen über Infiniband, OFED und OpenSM unter FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ipfw>freebsd-ipfw</a></dt><dd><p><em>IP Firewall</em></p><div class=paragraph><p>Diskussionen über eine Neubearbeitung des IP-Firewall Quelltexts in FreeBSD. Dies ist eine technische Liste, in der nur technische Inhalte erwartet werden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a></dt><dd><p><em>ISDN Subsystem</em></p><div class=paragraph><p>Mailingliste für die Entwickler des ISDN Subsystems von FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-java>freebsd-java</a></dt><dd><p><em>Java™ Entwicklung</em></p><div class=paragraph><p>Mailingliste, auf der die Entwicklung von Java™ Anwendungen für FreeBSD sowie die Portierung und Pflege von JDK™s diskutiert wird.</p></div></dd></dl></div><div id=eresources-charters-jobs class=dlist><dl><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-jobs>freebsd-jobs</a></dt><dd><p><em>Stellenangebote und Stellengesuche</em></p><div class=paragraph><p>In diesem Forum können Sie Stellenangebote und Stellengesuche, die mit FreeBSD zu tun haben, aufgeben. Diese Mailingliste ist <em>nicht</em> der Ort, um über allgemeine Beschäftigungsprobleme zu diskutieren; dazu gibt es anderswo geeignete Foren.</p></div><div class=paragraph><p>Beachten Sie bitte, dass diese Liste, wie die anderen <code>FreeBSD.org</code>-Listen, weltweit gelesen wird. Geben Sie daher bitte den Arbeitsort genau an. Geben Sie bitte auch an, ob Telearbeit möglich ist und ob Hilfen für einen Umzug angeboten werden.</p></div><div class=paragraph><p>Benutzen Sie in der E-Mail bitte nur offene Formate - vorzugsweise nur das Textformat. Andere Formate, wie PDF oder HTML, werden von den Lesern akzeptiert. Nicht offene Formate wie Microsoft® Word (<span class=filename>.doc</span>) werden vom Server der Liste abgelehnt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>freebsd-hackers</a></dt><dd><p><em>Technische Diskussionen</em></p><div class=paragraph><p>Dies ist ein Forum für technische Diskussionen über FreeBSD. Leute, die aktiv an FreeBSD arbeiten, können hier Probleme und deren Lösungen diskutieren. Interessierte, die den Diskussionen folgen wollen, steht die Liste ebenfalls offen. Auf dieser Liste finden nur technische Diskussionen statt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hardware>freebsd-hardware</a></dt><dd><p><em>Allgemeine Diskussionen über Hardware</em></p><div class=paragraph><p>Allgemeine Diskussionen über die Hardware, auf der FreeBSD läuft: Probleme und Ratschläge welche Hardware man kaufen sollte und welche nicht.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hubs>freebsd-hubs</a></dt><dd><p><em>FreeBSD-Spiegel</em></p><div class=paragraph><p>Ankündigungen und Diskussionsforum für Leute, die FreeBSD-Spiegel betreiben.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-isp>freebsd-isp</a></dt><dd><p><em>Themen für Internet Service Provider</em></p><div class=paragraph><p>Diese Liste ist für Internet Service Provider (ISP), die FreeBSD benutzen. Auf dieser Liste finden nur technische Diskussionen statt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-mono>freebsd-mono</a></dt><dd><p><em>Mono und C# Anwendungen auf FreeBSD</em></p><div class=paragraph><p>Diese Liste beinhaltet Diskussionen über das Mono Entwicklungsframework auf FreeBSD. Dies ist eine technische Mailingliste. Es ist für Personen gedacht, die aktiv an der Portierung von Mono oder C# Anwendungen auf FreeBSD sind, um Probleme oder alternative Lösungen zu beratschlagen. Personen die der technischen Diskussion folgen möchten sind ebenso willkommen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ocaml>freebsd-ocaml</a></dt><dd><p><em>FreeBSD-spezifische Diskussionen zu OCaml</em></p><div class=paragraph><p>Diskussionen im Zusammenhang mit der OCaml-Unterstützung auf FreeBSD. Dies ist eine technische Mailingliste für Benutzer, die an OCaml-Ports, Bibliotheken und Frameworks von Drittanbietern arbeiten. Auch Benutzer, die an der technischen Diskussion interessiert sind, sind willkommen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-office>freebsd-office</a></dt><dd><p><em>Office-Anwendungen für FreeBSD</em></p><div class=paragraph><p>Diskussionen über Office-Anwendungen, ihre Installation, Entwicklung und Unterstützung innerhalb von FreeBSD</p></div></dd><dt class=hdlist1><a href=https://mail.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></dt><dd><p><em>KDE</em></p><div class=paragraph><p>Diskussionen über KDE auf FreeBSD-Systemen. Dies ist eine technische Liste, in der nur technische Inhalte diskutiert werden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-announce>freebsd-announce</a></dt><dd><p><em>Projekt-Infrastruktur Ankündigungen</em></p><div class=paragraph><p>Diese Liste für Leute gedacht, die an Veränderungen im Zusammenhang der FreeBSD-Projekt Infrastruktur interessiert sind.</p></div><div class=paragraph><p>Diese moderierte Liste wird ausschließlich für Ankündigungen verwendet. Sie können keine Anfragen an diese Liste stellen und erhalten somit auch keine Antworten.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-performance>freebsd-performance</a></dt><dd><p><em>Diskussionsforum mit dem Ziel, die Leistung von FreeBSD zu verbessern.</em></p><div class=paragraph><p>Auf dieser Liste diskutieren Hacker, Systemadministratoren und andere Interessierte die Leistung von FreeBSD. Zulässige Themen sind beispielsweise Systeme unter hoher Last, Systeme mit Leistungsproblemen oder Systeme, die Leistungsgrenzen von FreeBSD überwinden. Jeder, der mithelfen will, die Leistung von FreeBSD zu verbessern, sollte diese Liste abonnieren. Die Liste ist technisch anspruchsvoll und geeignet für erfahrene FreeBSD-Benutzer, Hacker oder Administratoren, die FreeBSD schnell, robust und skalierbar halten wollen. Auf der Liste werden Beiträge gesammelt oder Fragen nach ungelösten Problemen beantwortet. Sie ist kein Ersatz für das gründliche Studium der Dokumentation.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-pf>freebsd-pf</a></dt><dd><p><em>Diskussionen und Fragen zu packet filter als Firewallsystem.</em></p><div class=paragraph><p>FreeBSD-spezifische Diskussionen zur Benutzung von packet filter (pf) als Firewallsystem. Sowohl technische Diskussionen als auch Anwenderfragen sind auf dieser Liste willkommen. Fragen zum ALTQ QoS Framework können ebenfalls gestellt werden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-pkg>freebsd-pkg</a></dt><dd><p><em>Diskussionen über die Verwaltung von Binärpaketen und entsprechenden Werkzeugen</em></p><div class=paragraph><p>Diskussionen über die Verwendung von Binärpaketen, Werkzeuge zur Paketverwaltung, Entwicklung und Unterstützung innerhalb von FreeBSD, Verwaltung der Paket-Repositories und die Verwaltung von Paketen von Drittherstellern.</p></div><div class=paragraph><p>Beachten Sie, dass diese Liste nicht geeignet ist, um Probleme über nicht gebaute Pakete zu melden. Diese Probleme werden im allgemeinen als Problem des Ports betrachtet.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-pkg-fallout>freebsd-pkg-fallout</a></dt><dd><p><em>Protokolle von fehlgeschlagenen Paketbauvorgängen</em></p><div class=paragraph><p>Alle Fehlerprotokolle aus dem Paketcluster.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-pkgbase>freebsd-pkgbase</a></dt><dd><p><em>Paketierung des FreeBSD-Basissystems</em></p><div class=paragraph><p>Diskussion über die Implementierung und Probleme im Bezug auf die Paketierung des FreeBSD-Basissystems.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-platforms>freebsd-platforms</a></dt><dd><p><em>Portierung auf nicht-Intel® Plattformen</em></p><div class=paragraph><p>Plattformübergreifende Themen und Vorschläge für die Portierung auf nicht-Intel® Plattformen. Auf dieser Liste finden nur technische Diskussionen statt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ports>freebsd-ports</a></dt><dd><p><em>Diskussion über die Ports-Sammlung</em></p><div class=paragraph><p>Diskussionen über die FreeBSD-Ports-Sammlung und die Infrastruktur der Sammlung. Die Liste dient auch der allgemeinen Koordination der Dinge, welche die Ports-Sammlung betreffen. Auf dieser Liste finden nur technische Diskussionen statt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>freebsd-ports-bugs</a></dt><dd><p><em>Diskussion über Fehler in den Ports</em></p><div class=paragraph><p>Diskussion über Fehler in der Ports-Sammlung (<span class=filename>/usr/ports</span>), neue Ports oder Änderungen an bestehenden Ports. Auf dieser Liste finden nur technische Diskussionen statt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-proliant>freebsd-proliant</a></dt><dd><p><em>Technische Diskussionen zum Einsatz von FreeBSD auf HP ProLiant-Serverplattformen</em></p><div class=paragraph><p>Diese Mailingliste bietet technische Diskussionen zum Einsatz von FreeBSD auf der ProLiant-Serverplattform von HP, darunter Fragen zu ProLiant-spezifischen Treibern, Konfigurationswerkzeugen sowie BIOS-Aktualisierungen. Daher ist sie die erste Anlaufstelle, um die Module hpasmd, hpasmcli, sowie hpacucli zu diskutieren.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-python>freebsd-python</a></dt><dd><p><em>Python unter FreeBSD</em></p><div class=paragraph><p>Diese technische Liste dient der Verbesserung der Python-Unterstützung unter FreeBSD. Sie wird von Personen gelesen, die an der Portierung von Python, von Python-Modulen Dritter und von Zope nach FreeBSD arbeiten. Personen, die diese technischen Diskussion verfolgen wollen, sind ebenfalls willkommen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a></dt><dd><p><em>Benutzerfragen</em></p><div class=paragraph><p>Auf dieser Mailingliste können Fragen zu FreeBSD gestellt werden. Fragen Sie bitte nicht nach Anleitungen, wenn Sie nicht sicher sind, dass Ihre Frage wirklich technischer Natur ist.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ruby>freebsd-ruby</a></dt><dd><p><em>Ruby unter FreeBSD</em></p><div class=paragraph><p>Diese technische Liste dient der Verbesserung der Ruby-Unterstützung unter FreeBSD. Sie wird von Personen gelesen, die an der Portierung von Ruby, von Bibliotheken Dritter und Frameworks arbeiten. Personen, die diese technischen Diskussionen verfolgen wollen, sind ebenfalls willkommen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-scsi>freebsd-scsi</a></dt><dd><p><em>SCSI Subsystem</em></p><div class=paragraph><p>Diese Mailingliste ist für die Entwickler des SCSI Subsystems von FreeBSD. Auf dieser Liste finden nur technische Diskussionen statt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-security>FreeBSD security</a></dt><dd><p><em>Sicherheitsthemen</em></p><div class=paragraph><p>Sicherheitsthemen, die FreeBSD betreffen, wie DES, Kerberos, bekannte Sicherheitslöcher und Fehlerbehebungen. Stellen Sie bitte auf dieser Liste keine allgemeinen Fragen zum Thema Sicherheit. Willkommen sind allerdings Beiträge zur FAQ, das heißt eine Frage mit der passenden Antwort. Auf dieser Liste finden nur technische Diskussionen statt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>FreeBSD security notifications</a></dt><dd><p><em>Ankündigungen zum Thema Sicherheit</em></p><div class=paragraph><p>Ankündigungen über Sicherheitsprobleme von FreeBSD und deren Behebungen. Diese Liste ist kein Diskussionsforum, benutzen Sie <a href=https://lists.FreeBSD.org/subscription/freebsd-security>FreeBSD security</a>, um Sicherheitsthemen zu diskutieren.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-snapshots>freebsd-snapshots</a></dt><dd><p><em>Ankündigungen für FreeBSD Entwickler-Snapshots</em></p><div class=paragraph><p>Diese Liste informiert über die Verfügbarkeit von neuen FreeBSD-Snapshots aus den Zweigen head/ und stable/.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-stable>FreeBSD-STABLE;</a></dt><dd><p><em>Gebrauch von FreeBSD-STABLE.</em></p><div class=paragraph><p>Diese Mailingliste ist für die Benutzer von FreeBSD-STABLE eingerichtet. -STABLE ist der Zweig, in dem die Entwicklung nach einen RELEASE stattfindet, einschließlich Fehlerkorrekturen und neuer Funktionen. Die ABI wird wegen Binärkompatibilitäten stabil gehalten. Auf der Liste finden sich Ankündigungen über Besonderheiten von -STABLE, von denen Benutzer betroffen sind. Sie enthält weiterhin Anweisungen, wie man ein System auf -STABLE hält. Jeder, der ein -STABLE System besitzt, muss diese Liste lesen. Die Liste ist nur für technische Inhalte bestimmt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-standards>freebsd-standards</a></dt><dd><p><em>Konformität von FreeBSD mit den C99- und POSIX® Standards</em></p><div class=paragraph><p>Dieses Forum ist für technische Diskussionen über die Konformität von FreeBSD mit den C99- und POSIX®-Standards.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-teaching>freebsd-teaching</a></dt><dd><p><em>Unterrichten mit FreeBSD</em></p><div class=paragraph><p>Mailingliste, die das Unterrichten mit FreeBSD diskutiert.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-testing>freebsd-testing</a></dt><dd><p><em>Tests unter FreeBSD</em></p><div class=paragraph><p>Technische Liste, auf der Tests unter FreeBSD diskutiert werden, einschließlich ATF/Kyua, der Test/Build-Infrastruktur, und Portierungen von anderen Betriebssystemen (NetBSD, …​) nach FreeBSD.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-tex>freebsd-tex</a></dt><dd><p><em>Portierung von TeX und dessen Anwendungen nach FreeBSD</em></p><div class=paragraph><p>Technische Liste für Diskussionen im Zusammenhang mit TeX und dessen Anwendungen unter FreeBSD. Diese Liste ist für Menschen, die an der Portierung von TeX nach FreeBSD arbeiten. Es werden aber auch Probleme und Lösungen erörtert. Personen, die an technischen Diskussionen interessiert sind, sind ebenfalls willkommen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-toolchain>freebsd-toolchain</a></dt><dd><p><em>Wartung der FreeBSD-Toolchain</em></p><div class=paragraph><p>Auf dieser Mailingliste werden alle Themen rund um die FreeBSD-Toolchain diskutiert. Dazu gehören der Status von Clang und GCC, aber auch Fragen zu Programmen wie Assemblern, Linkern und Debuggern.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-translators>freebsd-translators</a></dt><dd><p><em>Übersetzung von FreeBSD-Dokumenten und Programmen</em></p><div class=paragraph><p>Auf dieser Liste können Übersetzer von FreeBSD-Dokumenten über die Methoden und Werkzeuge für die Übersetzung diskutieren. Neue Benutzer werden gebeten sich vorzustellen und die Sprache zu erwähnen, an dessen Übersetzung sie interessiert sind.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-transport>freebsd-transport</a></dt><dd><p><em>Diskussion über Transportprotokolle in FreeBSD</em></p><div class=paragraph><p>Diese Liste behandelt die Probleme und das Design von FreeBSDs Netzwerkstack, darunter auch TCP, SCTP und UDP. Andere Netzwerkthemen sollten auf der <a href=https://lists.FreeBSD.org/subscription/freebsd-net>FreeBSD networking</a> diskutiert werden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-usb>freebsd-usb</a></dt><dd><p><em>USB-Unterstützung in FreeBSD.</em></p><div class=paragraph><p>Auf dieser Liste finden nur technische Diskussionen statt.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-user-groups>freebsd-user-groups</a></dt><dd><p><em>Koordination von Benutzergruppen</em></p><div class=paragraph><p>Diese Liste ist für Koordinatoren lokaler Benutzergruppen und einem ausgesuchten Mitglied des Core Teams eingerichtet worden. Der Inhalt sollte Inhalte von Treffen und die Koordination von Projekten mehrerer Benutzergruppen beschränkt sein.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-virtualization>freebsd-virtualization</a></dt><dd><p><em>Diskussion über verschiedene Virtualisierungsverfahren, die von FreeBSD unterstützt werden</em></p><div class=paragraph><p>Eine Liste, auf der die verschiedenen Virtualisierungsverfahren, die von FreeBSD unterstützt werden, diskutiert werden. Auf der einen Seite liegt der Fokus auf der Implementierung der zugrundeliegenden Funktionalitäten, ebenso wie das Hinzufügen neuer Eigenschaften. Auf der anderen Seite haben die Benutzer ein Forum, um Fragen bei Problemen zu stellen oder um ihre Anwendungsfälle zu besprechen.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-wip-status>freebsd-wip-status</a></dt><dd><p><em>Status von in Arbeit befindlichen FreeBSD-Tätigkeiten</em></p><div class=paragraph><p>Diese Mailingliste kann dazu verwendet werden, eigene Kreationen und deren Fortschritt von FreeBSD-verwandten Tätigkeiten anzukündigen. Die Nachrichten werden moderiert. Es wird empfohlen, die Nachricht "An:" eine mehr themenverwandte FreeBSD-Liste zu senden und diese Liste nur in Blindkopie zu setzen. Auf diese Weise kann ihre in Arbeit befindliche Tätigkeit auch auf der themenverwandten Liste diskutiert werden, da auf dieser Liste keine Diskussionen erlaubt sind.</p></div><div class=paragraph><p>Sehen Sie sich das Archiv der Liste für passende Nachrichten an.</p></div><div class=paragraph><p>Redaktionelle Auszüge der Nachrichten an diese Liste werden eventuell alle paar Monate auf die FreeBSD Webseite als Teil der Statusberichte gestellt. Weitere Beispiele und zurückliegende Berichte können Sie auch dort finden.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-wireless>freebsd-wireless</a></dt><dd><p><em>Diskussionen zum 802.11-Stack sowie zur Entwicklung von Tools und Gerätetreibern</em></p><div class=paragraph><p>Die Mailingliste freebsd-wireless diskutiert Themen rund um den 802.11-Stack (sys/net80211). Besprochen werden die Entwicklung von Tools und Gerätetreibern sowie auftretende Probleme, neue Funktionen sowie die Wartung der existierenden Werkzeuge und Treiber.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-xen>freebsd-xen</a></dt><dd><p><em>Diskussionen über die FreeBSD Portierung auf Xen™ - Implementierung und Verwendung</em></p><div class=paragraph><p>Eine Liste, welche die FreeBSD Portierung auf Xen™ behandelt. Das erwartete Nachrichtenaufkommen ist klein genug, so dass es als Forum für sowohl technische Diskussionen über die Implementierung und Entwurfsdetails, als auch administrative Verteilaspekte ausgelegt ist.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-xfce>freebsd-xfce</a></dt><dd><p><em>XFCE</em></p><div class=paragraph><p>Eine Liste, auf der Fragen zum Einsatz von XFCE unter FreeBSD diskutiert werden. Es handelt sich um eine technische Mailingliste, die sich primär an Entwickler richtet, die aktiv an der Portierung von XFCE nach FreeBSD arbeiten. Aber auch Nutzer, die einfach nur die technischen Diskussionen verfolgen wollen, sind willkommen. Diskutiert werden vor allem bei der Portierung auftretende Probleme und mögliche Lösungswege.</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-zope>freebsd-zope</a></dt><dd><p><em>Zope</em></p><div class=paragraph><p>Ein Forum für Diskussionen darüber, wie man die Zope-Umgebung auf FreeBSD portieren kann. Dies ist eine technische Mailingliste. Sie ist für Leute gedacht, die aktiv an der Portierung von Zope auf FreeBSD arbeiten, um aufkommende Probleme oder alternative Lösungsansätze zu besprechen. Personen, die der technischen Diskussion folgen möchten, sind ebenfalls willkommen.</p></div></dd></dl></div></div><div class=sect3><h4 id=eresources-mailfiltering>C.2.4. Filter der Mailinglisten<a class=anchor href=#eresources-mailfiltering></a></h4><div class=paragraph><p>Um die Verbreitung von Spam, Viren und anderen nicht erwünschten E-Mails zu verhindern, werden auf den FreeBSD-Mailinglisten Filter eingesetzt. Dieser Abschnitt beschreibt nur einen Teil der zum Schutz der Listen eingesetzten Filter.</p></div><div class=paragraph><p>Auf den Mailinglisten sind nur die unten aufgeführten Anhänge erlaubt. Anhänge mit einem anderen MIME-Typ werden entfernt, bevor eine E-Mail an eine Liste verteilt wird.</p></div><div class=ulist><ul><li><p>application/octet-stream</p></li><li><p>application/pdf</p></li><li><p>application/pgp-signature</p></li><li><p>application/x-pkcs7-signature</p></li><li><p>message/rfc822</p></li><li><p>multipart/alternative</p></li><li><p>multipart/related</p></li><li><p>multipart/signed</p></li><li><p>text/html</p></li><li><p>text/plain</p></li><li><p>text/x-diff</p></li><li><p>text/x-patch</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Einige Mailinglisten erlauben vielleicht Anhänge mit anderem MIME-Typ. Für die meisten Mailinglisten sollte die obige Aufzählung aber richtig sein.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn eine E-Mail sowohl aus einer HTML-Version wie auch aus einer Text-Version besteht, wird die HTML-Version entfernt. Wenn eine E-Mail nur im HTML-Format versendet wurde, wird sie in reinen Text umgewandelt.</p></div></div></div><div class=sect2><h3 id=eresources-news>C.3. Usenet-News<a class=anchor href=#eresources-news></a></h3><div class=paragraph><p>Neben den Gruppen, die sich ausschließlich mit BSD beschäftigen, gibt es viele weitere in denen über FreeBSD diskutiert wird, oder die für FreeBSD-Benutzer wichtig sind.</p></div><div class=sect3><h4 id=_bsd_spezifische_gruppen>C.3.1. BSD spezifische Gruppen<a class=anchor href=#_bsd_spezifische_gruppen></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix.bsd.freebsd.announce>comp.unix.bsd.freebsd.announce</a></p></li><li><p><a href=news:comp.unix.bsd.freebsd.misc>comp.unix.bsd.freebsd.misc</a></p></li><li><p><a href=news:de.comp.os.unix.bsd>de.comp.os.unix.bsd</a> (deutsch)</p></li><li><p><a href=news:fr.comp.os.bsd>fr.comp.os.bsd</a> (französisch)</p></li></ul></div></div><div class=sect3><h4 id=_weitere_unix_gruppen>C.3.2. Weitere UNIX Gruppen<a class=anchor href=#_weitere_unix_gruppen></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix>comp.unix</a></p></li><li><p><a href=news:comp.unix.questions>comp.unix.questions</a></p></li><li><p><a href=news:comp.unix.admin>comp.unix.admin</a></p></li><li><p><a href=news:comp.unix.programmer>comp.unix.programmer</a></p></li><li><p><a href=news:comp.unix.shell>comp.unix.shell</a></p></li><li><p><a href=news:comp.unix.misc>comp.unix.misc</a></p></li><li><p><a href=news:comp.unix.bsd>comp.unix.bsd</a></p></li></ul></div></div><div class=sect3><h4 id=_x_window_system>C.3.3. X Window System<a class=anchor href=#_x_window_system></a></h4><div class=ulist><ul><li><p><a href=news:comp.windows.x>comp.windows.x</a></p></li></ul></div></div></div><div class=sect2><h3 id=eresources-web>C.4. Offizielle Spiegel<a class=anchor href=#eresources-web></a></h3><div class=paragraph><p><a href=#central-mirrors>Central Servers</a>, <a href=#armenia-mirrors>Armenia</a>, <a href=#australia-mirrors>Australia</a>, <a href=#austria-mirrors>Austria</a>, <a href=#czech-republic-mirrors>Czech Republic</a>, <a href=#denmark-mirrors>Denmark</a>, <a href=#finland-mirrors>Finland</a>, <a href=#france-mirrors>France</a>, <a href=#germany-mirrors>Germany</a>, <a href=#hong-kong-mirrors>Hong Kong</a>, <a href=#ireland-mirrors>Ireland</a>, <a href=#japan-mirrors>Japan</a>, <a href=#latvia-mirrors>Latvia</a>, <a href=#lithuania-mirrors>Lithuania</a>, <a href=#netherlands-mirrors>Netherlands</a>, <a href=#norway-mirrors>Norway</a>, <a href=#russia-mirrors>Russia</a>, <a href=#slovenia-mirrors>Slovenia</a>, <a href=#south-africa-mirrors>South Africa</a>, <a href=#spain-mirrors>Spain</a>, <a href=#sweden-mirrors>Sweden</a>, <a href=#switzerland-mirrors>Switzerland</a>, <a href=#taiwan-mirrors>Taiwan</a>, <a href=#uk-mirrors>United Kingdom</a>, <a href=#usa-mirrors>United States of America</a>.</p></div><div class=paragraph><p>(aktualisiert am: UTC)</p></div><div id=central-mirrors class=paragraph><p><strong>Central Servers</strong></p></div><div class=ulist><ul><li><p><a href=https://www.FreeBSD.org/ class=bare>https://www.FreeBSD.org/</a></p></li></ul></div><div id=armenia-mirrors class=paragraph><p><strong>Armenia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.at.FreeBSD.org/ class=bare>http://www.at.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=australia-mirrors class=paragraph><p><strong>Australia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.au.FreeBSD.org/ class=bare>http://www.au.FreeBSD.org/</a></p></li><li><p><a href=http://www2.au.FreeBSD.org/ class=bare>http://www2.au.FreeBSD.org/</a></p></li></ul></div><div id=austria-mirrors class=paragraph><p><strong>Austria</strong></p></div><div class=ulist><ul><li><p><a href=http://www.at.FreeBSD.org/ class=bare>http://www.at.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=czech-republic-mirrors class=paragraph><p><strong>Czech Republic</strong></p></div><div class=ulist><ul><li><p><a href=http://www.cz.FreeBSD.org/ class=bare>http://www.cz.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=denmark-mirrors class=paragraph><p><strong>Denmark</strong></p></div><div class=ulist><ul><li><p><a href=http://www.dk.FreeBSD.org/ class=bare>http://www.dk.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=finland-mirrors class=paragraph><p><strong>Finland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.fi.FreeBSD.org/ class=bare>http://www.fi.FreeBSD.org/</a></p></li></ul></div><div id=france-mirrors class=paragraph><p><strong>France</strong></p></div><div class=ulist><ul><li><p><a href=http://www1.fr.FreeBSD.org/ class=bare>http://www1.fr.FreeBSD.org/</a></p></li></ul></div><div id=germany-mirrors class=paragraph><p><strong>Germany</strong></p></div><div class=ulist><ul><li><p><a href=http://www.de.FreeBSD.org/ class=bare>http://www.de.FreeBSD.org/</a></p></li></ul></div><div id=hong-kong-mirrors class=paragraph><p><strong>Hong Kong</strong></p></div><div class=ulist><ul><li><p><a href=http://www.hk.FreeBSD.org/ class=bare>http://www.hk.FreeBSD.org/</a></p></li></ul></div><div id=ireland-mirrors class=paragraph><p><strong>Ireland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ie.FreeBSD.org/ class=bare>http://www.ie.FreeBSD.org/</a></p></li></ul></div><div id=japan-mirrors class=paragraph><p><strong>Japan</strong></p></div><div class=ulist><ul><li><p><a href=http://www.jp.FreeBSD.org/www.FreeBSD.org/ class=bare>http://www.jp.FreeBSD.org/www.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=latvia-mirrors class=paragraph><p><strong>Latvia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.lv.FreeBSD.org/ class=bare>http://www.lv.FreeBSD.org/</a></p></li></ul></div><div id=lithuania-mirrors class=paragraph><p><strong>Lithuania</strong></p></div><div class=ulist><ul><li><p><a href=http://www.lt.FreeBSD.org/ class=bare>http://www.lt.FreeBSD.org/</a></p></li></ul></div><div id=netherlands-mirrors class=paragraph><p><strong>Netherlands</strong></p></div><div class=ulist><ul><li><p><a href=http://www.nl.FreeBSD.org/ class=bare>http://www.nl.FreeBSD.org/</a></p></li></ul></div><div id=norway-mirrors class=paragraph><p><strong>Norway</strong></p></div><div class=ulist><ul><li><p><a href=http://www.no.FreeBSD.org/ class=bare>http://www.no.FreeBSD.org/</a></p></li></ul></div><div id=russia-mirrors class=paragraph><p><strong>Russia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ru.FreeBSD.org/ class=bare>http://www.ru.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=slovenia-mirrors class=paragraph><p><strong>Slovenia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.si.FreeBSD.org/ class=bare>http://www.si.FreeBSD.org/</a></p></li></ul></div><div id=south-africa-mirrors class=paragraph><p><strong>South Africa</strong></p></div><div class=ulist><ul><li><p><a href=http://www.za.FreeBSD.org/ class=bare>http://www.za.FreeBSD.org/</a></p></li></ul></div><div id=spain-mirrors class=paragraph><p><strong>Spain</strong></p></div><div class=ulist><ul><li><p><a href=http://www.es.FreeBSD.org/ class=bare>http://www.es.FreeBSD.org/</a></p></li><li><p><a href=http://www2.es.FreeBSD.org/ class=bare>http://www2.es.FreeBSD.org/</a></p></li></ul></div><div id=sweden-mirrors class=paragraph><p><strong>Sweden</strong></p></div><div class=ulist><ul><li><p><a href=http://www.se.FreeBSD.org/ class=bare>http://www.se.FreeBSD.org/</a></p></li></ul></div><div id=switzerland-mirrors class=paragraph><p><strong>Switzerland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ch.FreeBSD.org/ class=bare>http://www.ch.FreeBSD.org/</a> (IPv6)</p></li><li><p><a href=http://www2.ch.FreeBSD.org/ class=bare>http://www2.ch.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=taiwan-mirrors class=paragraph><p><strong>Taiwan</strong></p></div><div class=ulist><ul><li><p><a href=http://www.tw.FreeBSD.org/ class=bare>http://www.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www2.tw.FreeBSD.org/ class=bare>http://www2.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www4.tw.FreeBSD.org/ class=bare>http://www4.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www5.tw.FreeBSD.org/ class=bare>http://www5.tw.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=uk-mirrors class=paragraph><p><strong>United Kingdom</strong></p></div><div class=ulist><ul><li><p><a href=http://www1.uk.FreeBSD.org class=bare>http://www1.uk.FreeBSD.org</a></p></li><li><p><a href=http://www3.uk.FreeBSD.org/ class=bare>http://www3.uk.FreeBSD.org/</a></p></li></ul></div><div id=usa-mirrors class=paragraph><p><strong>United States of America</strong></p></div><div class=ulist><ul><li><p><a href=http://www5.us.FreeBSD.org/ class=bare>http://www5.us.FreeBSD.org/</a> (IPv6)</p></li></ul></div></div></div></div><div class=sect1><h2 id=pgpkeys>Anhang D: OpenPGP-Schlüssel<a class=anchor href=#pgpkeys></a></h2><div class=sectionbody><div class=paragraph><p>Verwenden Sie die nachstehenden Schlüssel, wenn Sie eine Signatur überprüfen oder eine verschlüsselte E-Mail an einen Ansprechpartner oder einen Entwickler schicken wollen. Eine vollständige Liste der FreeBSD OpenPGP-Schlüssel finden Sie im Artikel <a href=https://docs.freebsd.org/en/articles/pgpkeys/>PGP Keys</a>. Den vollständigen Schlüsselring der Entwickler von FreeBSD finden Sie unter <a href=https://docs.FreeBSD.org/pgpkeys/pgpkeys.txt>pgpkeyring.txt</a>.</p></div><div class=sect2><h3 id=pgpkeys-officers>D.1. Ansprechpartner<a class=anchor href=#pgpkeys-officers></a></h3><div class=sect3><h4 id=_security_officer_team_security_officerfreebsd_org>D.1.1. Security Officer Team <code>&lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>></code><a class=anchor href=#_security_officer_team_security_officerfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/D9AD2A18057474CB 2022-12-11 [C] [expires: 2026-01-24]
      Key fingerprint = 0BE3 3275 D74C 953C 79F8  1107 D9AD 2A18 0574 74CB
uid                            FreeBSD Security Officer &lt;security-officer@freebsd.org&gt;
sub   rsa4096/6E58DE901F001AEF 2022-12-11 [S] [expires: 2025-01-15]
sub   rsa4096/46DB26D62F6039B7 2022-12-11 [E] [expires: 2025-01-15]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGOVdeUBEADHF5VGg1iPbACB+7lomX6aDytUf0k2k2Yc/Kp6lfYv7JKU+1nr
TcNF7Gt1YkajPSeWRKNZw/X94g4w5TEOHbJ6QQWx9g+N7RjEq75actQ/r2N5zY4S
ujfFTepbvgR55mLTxlxGKFBmNrfNbpHRyh4GwFRgPlxf5Jy9SB+0m54yFS4QlSd0
pIzO0CLkjHUFy/8S93oSK2zUkgok5gLWruBXom+8VC3OtBElkWswPkE1pKZvMQCv
VyM+7BS+MCFXSdZczDZZoEzpQJGhUYFsdg0KqlLv6z1rP+HsgUYKTkRpcrumDQV0
MMuCE4ECU6nFDDTnbR8Wn3LF5oTt0GtwS0nWf+nZ1SFTDURcSPR4Lp/PKjuDAkOS
P8BaruCNx1ItHSwcnXw0gS4+h8FjtWNZpsawtzjjgApcl+m9KP6dkBcbN+i1DHm6
NG6YQVtVWyN8aOKmoC/FEm1CWh1bv+ri9XOkF2EqT/ktbjbT1hFoFGBkS9/35y1G
3KKyWtwKcyF4OXcArl6sQwGgiYnZEG3sUMaGrwQovRtMf7le3cAYsMkXyiAnEufa
deuabYLD8qp9L/eNo+9aZmhJqQg4EQb+ePH7bGPNDZ+M5oGUwReX857FoWaPhs4L
dAKQ1YwASxdKKh8wnaamjIeZSGP5TCjurH7pADAIaB3/D+ZNl2a7od+C1wARAQAB
tDdGcmVlQlNEIFNlY3VyaXR5IE9mZmljZXIgPHNlY3VyaXR5LW9mZmljZXJAZnJl
ZWJzZC5vcmc+iQJSBBMBCgA8AhsBBAsJCAcEFQoJCAUWAgMBAAIeBQIXgBYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJjlXeQBQkF3u+rAAoJENmtKhgFdHTLOVoQALS3
cj7rqYkHiV4zDYrgPEp9O1kAyGI8VdfGAMkDVTqr+wP4v/o7LIUrgwZl5qxesVFB
VknFr0Wp5g9h0iAjasoI5sDd6tH2SmumhBHXFVdftzDQhrugxH6fWRhHs0SaFYCk
Qt5nFbcpUfWgtQ35XTbsL8iENdYpjKXsSFQrJneGSwxIjWYTFn6ps/AI3gwR8+Bn
OffEFdYugJ049O6Vu6YBFJHrnMO7NbF4v95dVYuLtpMIaXWM+V9KITmhaBzFz5fM
Q7UOzcLlbxOYKNIWcp8QQk429mayKW5VUeUExUD1ZzBHn+P6ZG7QTMDu/RmBqiHo
ewCMVz4n9uXT5BiOngE4CvS0WQwHzK+k9MLpG2u/Bo9+LT0Ceh9Ou1rfU5+0tRwl
GyOFFjf3INS7I7gkcAwxQ7dzDItN/UQPZpg8y9mABU2x4enz0AvTnb61d/1dnTEr
tdNgU433he0ZnD1HurZCjBEWC656wv6iMdWcD8gjhMbmEpPmjvXcYlTO6zhEygSM
DiwdQCWK2W4++YJerA6ULBi3niNWBpofOFH8XylV56ruhjtHCo7+/3carcMoPOJv
lVZ1zCKxLro3TRBT15JTFBGqblRyTopFK3PuxW//GTnZOtpQEOV6yL4RAXcWeC1d
1hb5k/YxUmRF6XsDNEH4b08T8ZO8dV3dAV43Wh1oiQEzBBABCAAdFiEEuyjUCzYO
7pNq7RVv5fe8y6O93fgFAmObXVYACgkQ5fe8y6O93fiBlwf/W8y1XXJIx1ZA3n6u
f7aS70rbP9KFPr4U0dixwKE/gbtIQ9ckeNXrDDWz0v0NCz4qS+33IPiJg1WcY3vR
W90e7QgAueCo5TdZPImPbCs42vadpa5byMXS4Pw+xyT+d/yp2oLKYbj3En4bg1GM
w71DezIjvV+e01UR++u1t9yZ8LOWM5Kumz1zyQLZDZ8qIKt1bBfpa+E0cEqtNQWu
iGhQE3AHI8eWV+jBkg5y2zHRIevbWb1UPsj43lgkFtAGHk9rrM8Rmgr4AXr531iD
srBwauKZ/MElcF3MINuLH+gkPPaFHw/YIpLRLaZXZVsw3Xi1RNXI2n2ea29dvs/C
Lcf1vYkCMwQQAQgAHRYhBPwOh4rlr+eIAo1jVdOXkvSep+XCBQJjm14FAAoJENOX
kvSep+XC0DcP/1ZB7k9p1T+9QbbZZE1PJiHby3815ccH3XKexbNmmakHIn3L6Cet
F891Kqt9ssbhFRMNtyZ/k/8y8Hv5bKxVep5/HMyK+8aqfDFN0WMrqZh0/CiR6DJh
gnAmPNw/hAVHMHaYGII9kCrFfPFJ02FKoc81g9F08odb7TV+UlvRjkErhRxF+dGS
wQoO0RCbf0Z1cs7nd0Vb2z4IJh4XMxBjWc/uQ2Q9dH/0uRzwpAnR4YX+MG5YrX7Z
zBvDyR0r76iQwRSDKgioNgkr6R3rq1NZGdaj+8b0LzdOqtzKJ/eupDe3+H67e/EN
qymtreGjrubpiU9bKvYArisUqhE5KtguryvR6Qz9bj87nPg33DT3WWGVrwFRxBox
dbWzjQFv0wug8m4GAwVF7fPR5/eW7IHw8zvgn0vSPcZz7MZ4e6Y5jN4kA5/xWJYZ
Sps54qQWB+FA30unIXN68KqdIzONIbtaY3W4/JjJUCm4T+wEjKaH+wJX8w1DMjlg
mkTmGh/UrTyC1vXbPgk9Sy3cRTICR1T9z7W8UlmTtnKrUklrjlFR7SXzrEXzLGOX
Fm+NEHpHNXqzcm6c3QfzY/yQ9HSAQ/t7SUQ9caRePbDz3/msyPxtGFor9roQv6VN
wRXCyRgkH4Y5tPhJAQ8G/FxX+VXFb93QL0lfelb23/BBu6cUwW63SRn5uQINBGOV
dskBEADqo8z6TFAhrvHhJV5wHdj67guoYvpXP8gvdCqos8SLluqi0AWgJEwlqu7L
mKQ6qMoJ+2DN6y+dEtvOVgBAgF63LLf3FQKq9FB/3uqeIiQlCIl3H43f8KttEZzf
/lbry4Y6QhS2OXM31Ut9Q+1IfTGwvs1E8/J1U4jQrAGqNKknXyQyMweJ0jvvcSLJ
nv3S7COUJVOT3cTgVeh3RIQlFzqK2rSQmygDpS8bT8MjCsZr+KGezKpbddKXio4a
QW/e6nCMyYR8bo0GQ9DpsyAOsaENnkghncQhA7GdPZK9xLMNQMCp0OdcZlqRVjRZ
OutuzNW6PPoczs/NQq02YWK4BPtSV7+ldS9gPZTLIpnRNQRzcnA0vnQTqSAfasVw
sAGm+MpH7zcaMf2Tw1K08u7+5gyObgzUzQmGLCgo9VIncnDis0s4gfTmtrr5jCeV
7LYDQX+2fApMtXbVXeKJem1PS+Z6LPbW2HklxYuG5nFgewCYlQjKujfiwW1Clhi4
JQeE1Naobbaar99V/VeoHrOYAEWP0bkUyrFcocLJ+0g3KpjSkctIptgGGpMBKe4U
9O7pWoTki8Yz/uYQn/p0iZcG8SfKM8I4283jdsi5SUiNNJJZCBQTVA7d8MxUVv5+
qpX/v5XqYM3pHza2DLXzwfAE9O2dgN1OMZYIld+OnWcpm2PxIwARAQABiQRyBBgB
CgAmFiEEC+MydddMlTx5+BEH2a0qGAV0dMsFAmOVdskCGwIFCQICKQACQAkQ2a0q
GAV0dMvBdCAEGQEKAB0WIQS2FSd+gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBu
WN6QHwAa77gbEADpUBT14cesITuMsOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMP
Xih9G1tDo9ExIWT8jNjSSA+w0Viua/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJW
y944YegHF/5ytntwZ/L4BMYc3MztyZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37
bbUVw62xHQIn2zafSmMQ4oMXZTm9EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1
G9jqkwlaRYWjcLD0qxwc5m9LNrF6OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDC
lTTH+dAx3b6J1KFB0UiHP3FeTalFh8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2
RAo/o2X5r40qk/lhydQRZTSTFsiuH3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7r
e0jj8XMIO7G5yjQKQCnYuPdXbx++bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17
MEPIton1+NRfsU0peEVggQXlwdTcZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpK
a9qfIqBX/monjy7w5IHmhvLwAYI6IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69
PxMbOJbMpWSg8L7xW3LXKR1VwXggUC1+b3y67E5Ggi1hf0lfTnTMpL2ClO2QD/oC
hMIafhzxbjh2WzgYahVHZH3gpHc1/0Bnc07s9+Pa6EYYM9r0XzezLW7bswOjVloR
FreQ3FIF/2OSN0OGdm7dyYl0OliTIDDDlwK/l8bcckUcpHNR1dw0P3KvDlmLmzZy
G4HmzzSBa9jiFirEfcg2rnGc6Zi382jGVALuYVplPXyMOUiChp0AAQZzTIYpXw/g
pBE6em2k740yuK6WqG4yXXgk67FoH10TQvMd4Q73K4zw+9DMpThlUHcfBmAoViZw
il7C0xl+ysHX8ZI3JU8s1r3XAnpqdHi4Wpixm/ctXbVnTSA3FQr2SctJYqR1VHRW
GMW+Ii2SQDS+t9bZTzOgAPLDtfy+JqhBpwCB1a1EHftkJEojpfZipaYGkf3yc+vN
wUeUHp/csF9CT7Qbqaj1t7fVWzv7jcVKpRwngIT4vTSzqbo6WC34FuUAH0t7tJ5K
eZ625AqEFLmtqtDo+ydJhZrVrXBNXPfkx5hSVW/I9hvckMNwA3t0KfQC2sz+Z1Q1
a4vDWQYRytfyrgZkWGbXMn6l1JyqIolgJZuax2kYs7Vu3t8KptqCbv0ZBAGoMm7r
RLgVodhI9voA8YxCirSChrueJYn+JKk8MIyk3DdXpBoocMIAjFJAUgXjV5NQpZMy
xR8BEiQnBcHRIKVWEEyhbLtHpmCEsnKNyKVGoxs31IkEcgQYAQoAJgIbAhYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJlhctvBQkD8n2mAkDBdCAEGQEKAB0WIQS2FSd+
gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBuWN6QHwAa77gbEADpUBT14cesITuM
sOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMPXih9G1tDo9ExIWT8jNjSSA+w0Viu
a/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJWy944YegHF/5ytntwZ/L4BMYc3Mzt
yZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37bbUVw62xHQIn2zafSmMQ4oMXZTm9
EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1G9jqkwlaRYWjcLD0qxwc5m9LNrF6
OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDClTTH+dAx3b6J1KFB0UiHP3FeTalF
h8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2RAo/o2X5r40qk/lhydQRZTSTFsiu
H3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7re0jj8XMIO7G5yjQKQCnYuPdXbx++
bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17MEPIton1+NRfsU0peEVggQXlwdTc
ZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpKa9qfIqBX/monjy7w5IHmhvLwAYI6
IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69PxMbOJbMpWSg8L7xW3LXKR1VwXgg
UC1+b3y67E5Ggi1hf0lfTnTMpL2ClAkQ2a0qGAV0dMsjqhAAorQ725G342raJ+os
6+E/EFNsr4SR5H+AeinlQ2ymNSeO/ODsV6dmyYD3hed0mAXvIJt2B46fFC4eAP9f
VOIbMMhPMpnJuZyLPDi8gXcZLgWSRhJ88R98KIsmKlh+/fdZM4RI1JLjICi7kyNR
4jtKCzLj0DYVBzp1mn0lTwtFzv7SC9djpqFLnO5YoGPWfQHHhY02Trh2posRwAHO
oacXSFvsoQv6k6XNlStJ4lnrkH6t+Od4kU3/TJ0eQXs7Zd2WEVnMe1IhbihsGcAY
mzZzZlLOhskHCeVE2taHiXC6h4tC3/69I16N8ICauxGY41clPhiNmVaAzmkunOPz
ry5utl6HkpZ5/3UMVHI1JIvsfJW+vSMUhdcQILAv6DbRWWHeax3ZZ6iAVGCtJS7U
glwZM1Xor0okGtIS+aJ/Cw7tZ8Nm18lutcrf2MVW+BWpzMQKnWFQYTn1NEWjzYnx
9Na22+E8AvW02TdS0NSiP0sG/0q7lBNEck9vH4WEbbEXktj51Dg4ISUhQyW8BWwW
X+kSiNeqtcaikUb8SFj5vpTDotTSzikfT/jisvR5goTMNFCVHFZdXCdsbUZd8Iub
egAOh6Db/06y3mFYDEfcGJipab400OY03a2xw9Vz+YxrKfELCTBo2tZv+3K8kXgq
XFcbyJnkXmjnYM/sw5kKqtzuc7i5Ag0EY5V3BwEQAMpFVczZo9ZPNsgW791UW5o6
wnrnd1nIO+S4rc37q2TEz8KGHCuxo5NwffZ2t6Ln04BI54pbapg17b7a0hPka37H
FkL28n4VyMdx0CsAm3QEfUsdK6xwKV2SucYeVcrV1upcN4PdXD7su1I7/A4CWXFJ
G047zJ0Z89lJZiQEiAq7ghvEoinC0sm+0a6ao/ocqCgWCKM1yCPOyzJXleRrv29S
RnYziMR+q2U0x9xg9Xl6GMwUmFwbJc9nORVvLH7fbU6/du8EgoAYrglFOFZG/TSo
lSGWRSMiavz0JSD/i+rEN4aIT4WfBe+L9Wy1AmrNxiAO+zKmzHQu3JSxDncr+y+h
cd+W0gqw10FoI9jWLcL7kR+6a0iOjuJSXSopq2l3DafiPxtCFmr4CGQhzBHM6e4/
v/NNd3F0XpVbJ6RQph7lkfvfz8q2lvUlHhezJ0p1xXmhff9CHjdVMhmAmz5+imBA
Xk2mottNfKb0pFEen1xY3K/UPA4g+oPsSj495MsvIg9eIMCcC3/z0SEUMWH/styy
JzPqfpyfGwZeTcIj9vg2o+RnGvmcLVYA/EGToPk905kv/cK73oy8bZyOB0zMg7T9
PaWgLUO0sqjqo0Mw3knFySg3oRXlcilPQvfPdX0JvwLpc9DWlr1+1GkCXJ08lWug
Jc96CJQupKRb1IbC0oUXABEBAAGJAjwEGAEKACYWIQQL4zJ110yVPHn4EQfZrSoY
BXR0ywUCY5V3BwIbDAUJAgIpAAAKCRDZrSoYBXR0ywwtD/wIDmEcHdFlyFRTomUB
jbeK2uzcZIhkkgL58lc63UPle5iJ2FBvmYS+0rQS53sVEsccn5KfkOwTryKllvWb
l0IzuiqfawxALcfWpfZJHzTMSnDHfgXvOOyFMQruqRDAHAr7PNC0CnbT0sEF2ZFz
ad8M9fLqtkXUx4mgECNGJ4CVqg75KY8uUzv/BmRwEf587FT5/iAIed5MjFB2VFDX
9GABcvTTbHxCZIxnxl3cs15SxT0lAofZ2ueU6kWYWZSXFeaEM/4ymPJws2mmV0Ak
bJghLXCn9Mx3nX6NTZZ9Harbru+RzW3/Hg3DZd0J9vko8PafP0l1NWtgyX74CqvT
gjzTxXTnqrRXzcczK7fhcC2u4i0prPtXXcyyi7SwpoLikaZCLFFhUmOx+mS5Tjtg
FyFZBNxnO7iAwkzfcTcC9sPoWaFmiQf6q5EIYzG+WQpncj80mxl3HWOP6oFj/hZJ
RYseKeMkvJzLTo87rFdM6CsMrLwETR6e+aWM0btPFil1rXVACNOjsy0bxTV8OJEf
yxnYmyjvnBvB0kdiaVEDdVhxgSqzLAX4mgXa49/V6M/uzMr+n3/A1Jdk4V6fVm8S
5cFIXxoUat3cB4xGaT9OWD3o1NPr6eS9Vo0EsJlRl81SG68fS+Qtk2fX27T68YG4
Aa3zMfZxUsVuFLtTuQbRC+fJpIkCPAQYAQoAJgIbDBYhBAvjMnXXTJU8efgRB9mt
KhgFdHTLBQJlhcuqBQkD8n1oAAoJENmtKhgFdHTLoO0QAJsTE9fkleb7YzPEuP9G
J3jx8PGdWm7n+8UNdr24kS6gOXVUfPZrWa5So21hcIwZb4PZDqHSVSQnRciKhSnG
7gplYPNGZ4+FWbLr/mBRYarjkVFLUuCPexSIjxV1KSGJnWs9YTVAKZAz75GpCML6
jD6biCOQCQ86wqOdWvZIZR8YvurrxR64ABB0rjbsaG8cNOUX1cwAfdLwthf64dS+
2m3lqNGDHkP5eNL0RIxC5gXYEp0lvmlMH3ZuO5WrfH73PTDg89bxXeuhrFmSEwf4
xWm603oi8/2qQvR9/7jb0o+t71NQuWrWIFONZWWgZBUGso+uyT3XgY4YqKGR3z2Q
zKHYnJ6M7SvSYpqS7RtcxcCXF0HGNfES8cAgtKVpFtbtSwXXp8O8oLyjmVIO/NjU
pbLOGdFIsarsezLFV9f2fqZ63J34hyUSg8LrYVV1fA5DJUpebbX4hLpdk0MMtgG4
3BwKIGlJTpL5RkQ/uQU3YW2kairy7o+1imDD0TRzQxtdjVOI5vnlTNcfJZIIfLx4
drABA12OvpX3dfPV62R+8BAlJFT430CG6AISJIBqJRFvuikmnZGUvEHmOUs/FLbb
aXTPkKc7tR2WIwljRvMV+Qk84cWcX6YchMslMuiDM1mtlQZig34WHGSE+zCWnXAs
lIHlSwox7qfdO0Kz2XncSbIA
=QvUh
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_core_team_secretary_core_secretaryfreebsd_org>D.1.2. Core Team Secretary <code>&lt;<a href=mailto:core-secretary@FreeBSD.org>core-secretary@FreeBSD.org</a>></code><a class=anchor href=#_core_team_secretary_core_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/4D632518C3546B05 2024-02-17 [SC] [expires: 2025-02-16]
      Key fingerprint = 1A23 6A92 528D 00DD 7965  76FE 4D63 2518 C354 6B05
uid                            FreeBSD Core Team Secretary &lt;core-secretary@FreeBSD.org&gt;
sub   rsa4096/CABFDE12CA516ED2 2024-02-17 [E] [expires: 2025-02-16]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGXQ1o8BEAC+Rcg8cmVxuP17Vu+q5KgCx/XiulQuqKXAqqBlYCH2jqk6DINP
yFrREGBhzd/qNmlAYEahQ4Zgl0bUZNTrZVDyzicOvPP0jH+KSTQwRs7NOawEdlVO
cyHrwDCPEqf5ZzD4NhfTriEOw+j0pEH/onitUGvoQRtx15xWyaJQxDEBMTYMLewE
86D1bltwnTNczE3UZb7oQLJXkAX5hcLtou70XJGgZITvJkK+kp/xot2eFjnqRz/u
WeXnKhYAmC07EKwZ1uw047eHKwMMRBYqzApLwoQtfE430Kxf2q8de64x8zDbi6YM
1J4r8OAxOtHVyfJ0j7Q23DEZz0VVb4b1Tx5OG2Re/KSNvqI0awJO4TcRmOR88OyY
dzyXgnX6Sa7GVQY1FXvn7vtFuDAt7egZOzeomSHL9bdX07LTQ4UtM88EV9wm3q4q
smoatV9jsvPQ1zxCU3aQD/5eWTJH2/kz1LIuBL/Qi5XQpJn91lBtUWJrCgkHWPGu
f//rnnXmsG7DAChW+yZ7cFO8lfNa8sFhPqSxCYphWmJTrvadyQtDngB8JakWdnmK
pfGS6y5lel+181vw38ZZKt04AKM+nDY8051lBM7Q9Q6kTLI33UZeImndx5xYukVD
kV6aQ31HYfEark15c7iEz+OAcwFnM2ntXMt7kKGd40CqzusiPcQkPqPbAQARAQAB
tDhGcmVlQlNEIENvcmUgVGVhbSBTZWNyZXRhcnkgPGNvcmUtc2VjcmV0YXJ5QEZy
ZWVCU0Qub3JnPokCVwQTAQoAQRYhBBojapJSjQDdeWV2/k1jJRjDVGsFBQJl0NaP
AhsDBQkB4TOACAsJDQgMBwsDBRUKCQgLBRYDAgEAAh4FAheAAAoJEE1jJRjDVGsF
nacP/3PSg8JPmWoBfWrgT287NZ7OAU16/uGpDxlBUoVeEtkEDqZVW8yBFzrMhbwj
bJs3CZ+L85HMUDLZoxSwVnPM8PLVRzHTybYV7agYYzMox5C/jp2aeAgy9KYVd0Tk
07GMTYrSh4fhHWpxXz7IBOxk0RXvQxTHlg1u0DASkibYb2UTDcUNG5Q9kP/8jaIZ
kVDX8a5LDdOCgWaYdKPg4blv/UMjkegJz+Ayp7gXTcux6koW5F6ysSw9sgLBWb2D
b/KNIi4MBMe46xyXB/dqGAR4ibrUXTcQ4OAZNq1L6uWG1A49XuSgykdIwr00MzQw
wfVpKT31ww4ayVHLgj7NuqPlab9S5/fPfJ4MAvGE4GqWQFgsPKgKImUMgnnxTGpv
l7Dqk2MnWqn+wEi0bRES0PVBG96G+sZJQeaxBhoB+HwUSFqoZQg166AJIl//4t2w
bx0a1aWQSS0DZt3wsQW3NW9AE6L+FnFfIc2pQVoLjmvcGalDuvnemRmEOgotiZmt
32bi2aWxg0/Qio2rjLS2LpV+fhwDSN3Agvtnu53yUdD1TFFjTSMloM4SKhiXoPbI
XgfCLiBLNMsZL0AvO7wQfSePzPYxDLyEcwsfPJ8be+eGG1L62RUyad+MdfyXMH/S
m0sgqW/MW6Nv10RyPQOq3Jbgmp2laRMzKTOvQt5WwQf2FEl9uQINBGXQ1o8BEAC9
1cBYn6Z0QmM0OFWdXQI6fMOeNokaa6ngPgt7bzW5NjryqTdwyHOPZdm4DWf1SO/0
+fJRCqxbICyuMAFrb9fDle8bodALjm5ZquTL3D61HpZD4+RwOzOjYP6wLm7h38HT
/yIyK882Ovlw4Xz/TeSiL/VUSWE9twW7yz3oreCeLUBAfzacS9y+syO+aquEd0/x
JBz+mPQbrqfS64rCZXMZEivgsjkQoE6RM+n1rF4kw4Eu3E2kPevVwsoAaY+MEUM8
JAXaJMaNcLIhbeMy7dO/z6z2I3h5bUw5KxfVwzYSzSeRpYh53dNaB4NY+f5/vTrL
4dZmqBcLgcV0zZ02dj/u0SiwWlUFUpFGuSiW16DN7+2zG1zOWi7Nl44JawM62Tlf
mO8zruVGEHaV3e8fFwBLRKM0Sc7e3aLECISsfYeC5ZbRRbpQ1KX+VQr3FBKAMzG4
l9Go7vZ+UcLKpQx2rVPTJt1vDnRV49X6CF2Q/lV9iafQ4MTy6ACdAloT1yfH/lhU
iWQo1qDyRCSlmNBDsYl8gLrwMp4gGQAv3imZHxnJF5ru3nUYGG0U08D5mf2sWv5P
Wh7By8Jm8bmaP8cUF86lO9BJXh2d9QN5jqrAtXqYzenZ+ABSoL1XrD/yv3270rH7
H4gAUtgP+vJ3uMyRu9055OC+ie/b613NojCW5nYN2QARAQABiQI8BBgBCgAmFiEE
GiNqklKNAN15ZXb+TWMlGMNUawUFAmXQ1o8CGwwFCQHhM4AACgkQTWMlGMNUawXh
7w/+KjbEWTwAhjm2HJ3w4tXtPC5URg+A+BzYYVH/q0+956c1QeD0LYafHBw4LEMI
lhRvHQnmzwjtY8v/DgmLOVDMiMWVHo0Q2iQyMvOT1WyEPcgOTJLhvyVzDqRZx7AS
B4G8uNVkKAdBZ7OSXAP27lR/2SEoG05esw8b7Y39pVtucC3aeiua+19PLJWadBjj
XuvXuSCho0km+nk4IgadYmxIDyiMeyKZ8wCl7CJkzECm83q2OtNsMe3k8lgEXybt
KlQxnYApZmhqLMV5ob8WOk3AgAVsif1m332CiEIb1Sfx6wt3nXy/410CXdDDucuj
ndJVfJ6Un33tn0irZ5scPA2HmzK1PGMfgOGtkM8B3LE/x8kEKeWKb3l9boB32Unm
iTfKgEna+JISEab3bzOPWdCQFB8LyGXuWlhtvqmRoX8GtiMRy/F4mzh+l3lYHjj3
4EvPVyippO5zwU+S9HElJ2G37K6zrOmd5cGBrw4aBDoO70QVrMN4O86uvC9kChDb
qyFF5UgXg29QxJjiSCv98ksDMqpJ5AFYrmrsBtwU64OANrxxJ4AZLQ1apYmG9RWD
VHZgfeI60FNBLfKwix9UffFT7piQ/MLrjSde8gPH5S6ezBMrYpfGEopaI9A5qXe3
LnHz88gfdmaBM77YDZM/p23nmCrUxlE3kkbgjTY8NRjYyF8=
=MkAH
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_ports_management_team_secretary_portmgr_secretaryfreebsd_org>D.1.3. Ports Management Team Secretary <code>&lt;<a href=mailto:portmgr-secretary@FreeBSD.org>portmgr-secretary@FreeBSD.org</a>></code><a class=anchor href=#_ports_management_team_secretary_portmgr_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   ed25519/E3C401F60D709D59 2023-03-06 [SC] [expires: 2027-03-05]
      Key fingerprint = BED4 A1D3 6555 B681 2E9F  ABDA E3C4 01F6 0D70 9D59
uid                            FreeBSD Ports Management Team Secretary &lt;portmgr-secretary@FreeBSD.org&gt;
sub   cv25519/2C92B55E27A641C3 2023-03-06 [E] [expires: 2027-03-05]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZAXJvxYJKwYBBAHaRw8BAQdASFAC20WL3R1T6uNyGMZbfJCxDkcP4C5vi3Op
tcZ2fbq0R0ZyZWVCU0QgUG9ydHMgTWFuYWdlbWVudCBUZWFtIFNlY3JldGFyeSA8
cG9ydG1nci1zZWNyZXRhcnlARnJlZUJTRC5vcmc+iJYEExYKAD4WIQS+1KHTZVW2
gS6fq9rjxAH2DXCdWQUCZAXJvwIbAwUJB4TOAAULCQgHAwUVCgkICwUWAwIBAAIe
BQIXgAAKCRDjxAH2DXCdWYN1AP43TjyfZtZ3DLYT++g0+SuPsoO/3yWVybA+UmFL
zb8MngEA+LLNUfvEwCuXS/soh+ww5bpfmi3UUmeGiQEAXug3iA+JATMEEAEKAB0W
IQT7N0XIbxXo7ayBMvzYKU7Du8TX1QUCZAXLkwAKCRDYKU7Du8TX1XHMB/9R1MX4
6zMgpKqPPt76GOI+eGEdBK6bY8aJZjQGdqTh9f6VtXVoTGIG7cvhc9X8tDBoB0PT
2KZWheF51AV1+NHU4HwLAQ1BMebrFvWSfkw4xg4fBGwDhz9/GN85No+Js772V5ey
8lRiL6meRVWxMlLyWcxGd8JjcC5yX/iAUQ3SBGCLqW7unWjjg7CTd+AMBwcqPGrv
ax8q6eFVguJcHJAjMnKf6HAy4cpK3s+uMoUBCGnszSN12B3ysKfyC4pNO/pix5tA
Q5v8aRqTeFPh5zmNhWo0KGPzplTPqRQSHDl7GDQC8Ru3MhzFkeWzHsexjZVwS6W2
DPcYpuuAsA0XOZIZiQIzBBABCgAdFiEEEBpxaxYrAOVb7eoFrbv4YQo3ibcFAmQF
0u0ACgkQrbv4YQo3ibccwg/9F2Xuic3nhKxRbB3mJeDo6SYQETa/Gh1qQ34+8zlt
8UMazOx67gnYQfy+pXjro6eQ2up0a4eUYezcNOudqAQD21nRz3HA6EQVNcE/TzEA
xl5CJntTaLOt7S+EDXFW5BuQIvhhoMGgm8+WNVgA0EJ7tfL0OcYBSvr19fqwChEn
9c14cSk6mgHSsleP5NvskYN053pxHwy0LTSb8YBBv52th37t/CRFC1363rS5q+D7
JixFopd1O5pKpA5ipvE4gGgRjPtwjx0SjjepwK/3fuhEJQQyKzTIKlMfu2Dj/iR2
Li1Sfccau5LQXOj9fUITU3u1YG7yrm8VGzT7ao4d+KRwgMLjd2pLqiGIbbJwGBiP
FRmtilWQoeIlmSlFX4obAA517DOK0pW1mH8+eEn4EJd3SekT3yzFyKTASv0J48Z8
3F928xg+eZvHxVC0t1J+J5IG0gt3EEncuWKIPQGR7PiQbti6R3FQVTz6WfMWOebP
Qi0E9F/Aqakr6Vj2sKGrDq+ebpaF5G8Yw1YrUl2IDiPzkCegp3ZbI0wh11Xvzhi8
LXPQGK4jBQas4G8cegfitzmtdGRHYrbMv0R9I4mvaL+WlOuD2AvyVG28lguqVhnN
AZP+ohdquYyX2CNCVvbKWAtXo6Ur0vWG8BL8m6defAtEkIwVBALaOHQOSI3aNUz4
lwy4OARkBcm/EgorBgEEAZdVAQUBAQdAsefmSfxEOdOr02+K/6noYCuJ1FeAWVz6
jFYQ+9w6jggDAQgHiH4EGBYKACYWIQS+1KHTZVW2gS6fq9rjxAH2DXCdWQUCZAXJ
vwIbDAUJB4TOAAAKCRDjxAH2DXCdWRl4AP9h5ot212BK29S6ZcMBhHvmtF5PG1oD
c7LnZycSRmbFiwEAndCMpAGOhDW8iVgDd0wLQq/ZMPe+xccfG1b3zFH2EgE=
=iiAT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_doceng_secretaryfreebsd_org>D.1.4. <code>&lt;<a href=mailto:doceng-secretary@FreeBSD.org>doceng-secretary@FreeBSD.org</a>></code><a class=anchor href=#_doceng_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa2048/E1C03580AEB45E58 2019-10-31 [SC] [expires: 2022-10-30]
      Key fingerprint = F24D 7B32 B864 625E 5541  A0E4 E1C0 3580 AEB4 5E58
uid                            FreeBSD Doceng Team Secretary &lt;doceng-secretary@freebsd.org&gt;
sub   rsa2048/9EA8D713509472FC 2019-10-31 [E] [expires: 2022-10-30]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQENBF27FFcBCADeoSsIgyQUY8vREwkTikwFFlNg31MVy5s/Nq1cNK1PRfRMnprS
yfB62KqbYuz16bmQKaA9zHN4FGfiTvR6tl66LVHm1s/5HPiLv8sP14GsruLro9zN
v72dO7a9i68bMw+jarPOnu9dGiDFEI0dACOkdCGEYKEUapQeNpmWRrQ46BeXyFwF
JcNx76bJJUkwk6fWC0W63D762e6lCEX6ndoaPjjLBnFvtx13heNGUc8RukBwe2mA
U5pSGHj47J05bdWiRSwZaXa8PcW+20zTWaP755w7zWe4h60GANY7OsT9nuOqsioJ
QonxTrJuZweKRV8fNQ1EfDws3HZr7/7iXvO3ABEBAAG0PEZyZWVCU0QgRG9jZW5n
IFRlYW0gU2VjcmV0YXJ5IDxkb2Nlbmctc2VjcmV0YXJ5QGZyZWVic2Qub3JnPokB
VAQTAQoAPhYhBPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsDBQkFo5qABQsJ
CAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEOHANYCutF5YB2IIALw+EPYmOz9qlqIn
oTFmk/5MrcdzC5iLEfxubbF6TopDWsWPiOh5mAuvfEmROSGf6ctvdYe9UtQV3VNY
KeeyskeFrIBOFo2KG/dFqKPAWef6IfhbW3HWDWo5uOBg01jHzQ/pB1n6SMKiXfsM
idL9wN+UQKxF3Y7S/bVrZTV0isRUolO9+8kQeSYT/NMojVM0H2fWrTP/TaNEW4fY
JBDAl5hsktzdl8sdbNqdC0GiX3xb4GvgVzGGQELagsxjfuXk6PfOyn6Wx2d+yRcI
FrKojmhihBp5VGFQkntBIXQkaW0xhW+WBGxwXdaAl0drQlZ3W+edgdOl705x73kf
Uw3Fh2a5AQ0EXbsUVwEIANEPAsltM4vFj2pi5xEuHEcZIrIX/ZJhoaBtZkqvkB+H
4pu3/eQHK5hg0Dw12ugffPMz8mi57iGNI9TXd8ZYMJxAdvEZSDHCKZTX9G+FcxWa
/AzKNiG25uSISzz7rMB/lV1gofCdGtpHFRFTiNxFcoacugTdlYDiscgJZMJSg/hC
GXBdEKXR5WRAgAGandcL8llCToOt1lZEOkd5vJM861w6evgDhAZ2HGhRuG8/NDxG
r4UtlnYGUCFof/Q4oPNbDJzmZXF+8OQyTNcEpVD3leEOWG1Uv5XWS2XKVHcHZZ++
ISo/B5Q6Oi3SJFCVV9f+g09YF+PgfP/mVMBgif2fT20AEQEAAYkBPAQYAQoAJhYh
BPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsMBQkFo5qAAAoJEOHANYCutF5Y
kecIAMTh2VHQqjXHTszQMsy3NjiTVVITI3z+pzY0u2EYmLytXQ2pZMzLHMcklmub
5po0X4EvL6bZiJcLMI2mSrOs0Gp8P3hyMI40IkqoLMp7VA2LFlPgIJ7K5W4oVwf8
khY6lw7qg2l69APm/MM3xAyiL4p6MU8tpvWg5AncZ6lxyy27rxVflzEtCrKQuG/a
oVaOlMjH3uxvOK6IIxlhvWD0nKs/e2h2HIAZ+ILE6ytS5ZEg2GXuigoQZdEnv71L
xyvE9JANwGZLkDxnS5pgN2ikfkQYlFpJEkrNTQleCOHIIIp8vgJngEaP51xOIbQM
CiG/y3cmKQ/ZfH7BBvlZVtZKQsI=
=MQKT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 14. Januar 2022 by <a href="https://cgit.freebsd.org/doc/commit/?id=0c272255af" target=_blank>Li-Wen Hsu</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#book-preface>Vorwort</a><ul><li><a href=#preface-audience>Über dieses Buch</a></li><li><a href=#preface-changes-from3>Änderungen gegenüber der dritten Auflage</a></li><li><a href=#preface-changes-from2>Änderungen gegenüber der zweiten Auflage (2004)</a></li><li><a href=#preface-changes>Änderungen gegenüber der ersten Auflage (2001)</a></li><li><a href=#preface-overview>Gliederung</a></li><li><a href=#preface-conv>Konventionen in diesem Buch</a></li><li><a href=#preface-acknowledgements>Danksagung</a></li></ul></li><li><a href=#introduction>Teil I: Einleitung</a><ul><li><a href=#introduction-synopsis>Kapitel 1. Überblick</a></li><li><a href=#nutshell>Kapitel 2. Willkommen zu FreeBSD!</a></li><li><a href=#history>Kapitel 3. Über das FreeBSD Projekt</a></li><li><a href=#bsdinstall>Kapitel 4. FreeBSD installieren</a></li><li><a href=#basics>Kapitel 5. Grundlagen des FreeBSD Betriebssystems</a></li><li><a href=#ports>Kapitel 6. Installieren von Anwendungen: Pakete und Ports</a></li><li><a href=#x11>Kapitel 7. Das X-Window-System</a></li></ul></li><li><a href=#desktop>Teil II: Desktop-Anwendungen</a><ul><li><a href=#desktop-synopsis>Kapitel 8. Übersicht</a></li><li><a href=#desktop-browsers>Kapitel 9. Browser</a></li><li><a href=#desktop-productivity>Kapitel 10. Büroanwendungen</a></li><li><a href=#desktop-viewers>Kapitel 11. Anzeigen von Dokumenten</a></li><li><a href=#desktop-finance>Kapitel 12. Finanzsoftware</a></li><li><a href=#multimedia>Kapitel 13. Multimedia</a></li><li><a href=#kernelconfig>Kapitel 14. Konfiguration des FreeBSD-Kernels</a></li><li><a href=#printing>Kapitel 15. Drucken</a></li><li><a href=#linuxemu>Kapitel 16. Linux®-Binärkompatibilität</a></li></ul></li><li><a href=#config-tuning>Teil III: Konfiguration und Tuning</a><ul><li><a href=#config-synopsis>Kapitel 17. Übersicht</a></li><li><a href=#configtuning-starting-services>Kapitel 18. Start von Diensten</a></li><li><a href=#configtuning-cron>Kapitel 19. cron(8) konfigurieren</a></li><li><a href=#configtuning-rcd>Kapitel 20. Dienste unter FreeBSD verwalten</a></li><li><a href=#config-network-setup>Kapitel 21. Einrichten von Netzwerkkarten</a></li><li><a href=#configtuning-virtual-hosts>Kapitel 22. Virtual Hosts</a></li><li><a href=#configtuning-syslog>Kapitel 23. Konfiguration der Systemprotokollierung</a></li><li><a href=#configtuning-configfiles>Kapitel 24. Konfigurationsdateien</a></li><li><a href=#configtuning-sysctl>Kapitel 25. Einstellungen mit sysctl(8)</a></li><li><a href=#configtuning-disk>Kapitel 26. Tuning von Laufwerken</a></li><li><a href=#configtuning-kernel-limits>Kapitel 27. Einstellungen von Kernel Limits</a></li><li><a href=#adding-swap-space>Kapitel 28. Hinzufügen von Swap-Bereichen</a></li><li><a href=#acpi-overview>Kapitel 29. Energie- und Ressourcenverwaltung</a></li><li><a href=#boot>Kapitel 30. FreeBSDs Bootvorgang</a></li><li><a href=#security>Kapitel 31. Sicherheit</a></li><li><a href=#jails>Kapitel 32. Jails</a></li><li><a href=#mac>Kapitel 33. Verbindliche Zugriffskontrolle</a></li><li><a href=#audit>Kapitel 34. Security Event Auditing</a></li><li><a href=#disks>Kapitel 35. Speichermedien</a></li><li><a href=#geom>Kapitel 36. GEOM: Modulares Framework zur Plattentransformation</a></li><li><a href=#zfs>Kapitel 37. Das Z-Dateisystem (ZFS)</a></li><li><a href=#filesystems>Kapitel 38. Dateisystemunterstützung</a></li><li><a href=#virtualization>Kapitel 39. Virtualisierung</a></li><li><a href=#l10n>Kapitel 40. Localization - i18n/L10n Usage and Setup</a></li><li><a href=#updating-upgrading>Kapitel 41. FreeBSD aktualisieren</a></li><li><a href=#dtrace>Kapitel 42. DTrace</a></li><li><a href=#usb-device-mode>Kapitel 43. USB Gerätemodus</a></li></ul></li><li><a href=#serialcomms>Teil IV: Serielle Datenübertragung</a><ul><li><a href=#serial-synopsis>Kapitel 44. Übersicht</a></li><li><a href=#serial>Kapitel 45. Begriffe und Hardware</a></li><li><a href=#term>Kapitel 46. Terminals</a></li><li><a href=#dialup>Kapitel 47. Einwählverbindungen</a></li><li><a href=#dialout>Kapitel 48. Verbindungen nach Außen</a></li><li><a href=#serialconsole-setup>Kapitel 49. Einrichten der seriellen Konsole</a></li><li><a href=#ppp-and-slip>Kapitel 50. PPP</a></li><li><a href=#mail>Kapitel 51. Elektronische Post (E-Mail)</a></li><li><a href=#network-servers>Kapitel 52. Netzwerkserver</a></li><li><a href=#firewalls>Kapitel 53. Firewalls</a></li><li><a href=#advanced-networking>Kapitel 54. Weiterführende Netzwerkthemen</a></li></ul></li><li><a href=#mirrors>Anhang A: Bezugsquellen für FreeBSD</a></li><li><a href=#mirrors-cdrom>Kapitel 55. CD and DVD Sets</a></li><li><a href=#mirrors-ftp>Kapitel 56. FTP-Server</a></li><li><a href=#svn>Kapitel 57. Benutzen von Subversion</a><ul><li><a href=#svn-intro>57.1. Einführung</a></li><li><a href=#svn-ssl-certificates>57.2. SSL Root-Zertifikate</a></li><li><a href=#svn-svnlite>57.3. Svnlite</a></li><li><a href=#svn-install>57.4. Installation</a></li><li><a href=#svn-usage>57.5. Subversion benutzen</a></li><li><a href=#svn-mirrors>57.6. Subversion Mirror Sites</a></li><li><a href=#_weiterführende_informationen>57.7. Weiterführende Informationen</a></li></ul></li><li><a href=#mirrors-rsync>Kapitel 58. Benutzen von rsync</a></li><li><a href=#bibliography>Anhang B: Bibliografie</a><ul><li><a href=#bibliography-freebsd>B.1. Bücher speziell für FreeBSD</a></li><li><a href=#bibliography-userguides>B.2. Handbücher</a></li><li><a href=#bibliography-adminguides>B.3. Administrations-Anleitungen</a></li><li><a href=#bibliography-programmers>B.4. Programmierhandbücher</a></li><li><a href=#bibliography-osinternals>B.5. Betriebssystem-Interna</a></li><li><a href=#bibliography-security>B.6. Sicherheits-Anleitung</a></li><li><a href=#bibliography-hardware>B.7. Hardware-Anleitung</a></li><li><a href=#bibliography-history>B.8. UNIX® Geschichte</a></li><li><a href=#bibliography-journals>B.9. Zeitschriften, Magazine und Journale</a></li></ul></li><li><a href=#eresources>Anhang C: Ressourcen im Internet</a><ul><li><a href=#eresources-www>C.1. Webseiten</a></li><li><a href=#eresources-mail>C.2. Mailinglisten</a></li><li><a href=#eresources-news>C.3. Usenet-News</a></li><li><a href=#eresources-web>C.4. Offizielle Spiegel</a></li></ul></li><li><a href=#pgpkeys>Anhang D: OpenPGP-Schlüssel</a><ul><li><a href=#pgpkeys-officers>D.1. Ansprechpartner</a></li></ul></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/handbook/handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/book target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/de/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>