<!doctype html><html class=theme-light lang=de><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/de/books/handbook/config/><title>Kapitel 11. Konfiguration und Tuning | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Kapitel 11. Konfiguration und Tuning"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="http://172.16.201.134:1313/de/books/handbook/config/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/de\/books\/handbook\/config\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/de/books>Books</a></li><li><a href=http://172.16.201.134:1313/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/preface/>Vorwort</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-audience>Über dieses Buch</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-changes-from3>Änderungen gegenüber der dritten Auflage</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-changes-from2>Änderungen gegenüber der zweiten Auflage (2004)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-changes>Änderungen gegenüber der ersten Auflage (2001)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-overview>Gliederung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-conv>Konventionen in diesem Buch</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/preface/#preface-acknowledgements>Danksagung</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/parti/>Teil I. Erste Schritte</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/introduction/>Kapitel 1. Einleitung</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/introduction/#introduction-synopsis>1.1. Überblick</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/introduction/#nutshell>1.2. Willkommen zu FreeBSD!</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/introduction/#history>1.3. Über das FreeBSD Projekt</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/>Kapitel 2. FreeBSD installieren</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Minimale Hardwareanforderungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Vor der Installation</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-start>2.4. Die Installation starten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#using-bsdinstall>2.5. Verwendung von bsdinstall</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Plattenplatz bereitstellen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Abrufen der Distributionen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-post>2.8. Benutzerkonten, Zeitzone, Dienste und Sicherheitsoptionen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-network>2.9. Netzwerkschnittstellen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Fehlerbehebung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bsdinstall/#using-live-cd>2.11. Verwendung der Live-CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/basics/>Kapitel 3. Grundlagen des FreeBSD Betriebssystems</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#basics-synopsis>3.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#consoles>3.2. Virtuelle Konsolen und Terminals</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#users-synopsis>3.3. Benutzer und grundlegende Account-Verwaltung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#permissions>3.4. Zugriffsrechte</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#dirstructure>3.5. Verzeichnis-Strukturen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#disk-organization>3.6. Festplatten, Slices und Partitionen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#mount-unmount>3.7. Anhängen und Abhängen von Dateisystemen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#basics-processes>3.8. Prozesse und Dämonen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#editors>3.10. Text-Editoren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#basics-devices>3.11. Geräte und Gerätedateien</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/basics/#basics-more-information>3.12. Manualpages</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/ports/>Kapitel 4. Installieren von Anwendungen: Pakete und Ports</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-synopsis>4.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-overview>4.2. Installation von Software</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-finding-applications>4.3. Suchen einer Anwendung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#pkgng-intro>4.4. Benutzen von pkg zur Verwaltung von Binärpaketen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-using>4.5. Benutzen der Ports-Sammlung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-poudriere>4.6. Pakete mit Poudriere bauen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-nextsteps>4.7. Nach der Installation</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ports/#ports-broken>4.8. Kaputte Ports</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/x11/>Kapitel 5. Das X-Window-System</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x11-synopsis>5.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-understanding>5.2. Terminologie</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-install>5.3. Xorg installieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-config>5.4. Xorg konfigurieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-fonts>5.5. Schriftarten in Xorg benutzen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-xdm>5.6. Der X-Display-Manager</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x11-wm>5.7. Grafische Oberflächen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x-compiz-fusion>5.8. Compiz Fusion installieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/x11/#x11-troubleshooting>5.9. Fehlersuche</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/partii/>Teil II. Oft benutzte Funktionen</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/desktop/>Kapitel 6. Desktop-Anwendungen</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/desktop/#desktop-synopsis>6.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/desktop/#desktop-browsers>6.2. Browser</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/desktop/#desktop-productivity>6.3. Büroanwendungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/desktop/#desktop-viewers>6.4. Anzeigen von Dokumenten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/desktop/#desktop-finance>6.5. Finanzsoftware</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/>Kapitel 7. Multimedia</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#multimedia-synopsis>7.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#sound-setup>7.2. Soundkarten einrichten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#sound-mp3>7.3. MP3-Audio</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#video-playback>7.4. Videos wiedergeben</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#tvcard>7.5. TV-Karten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/multimedia/#scanners>7.7. Scanner</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/>Kapitel 8. Konfiguration des FreeBSD-Kernels</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Wieso einen eigenen Kernel bauen?</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Informationen über die vorhandene Hardware beschaffen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-config>8.4. Die Kernelkonfigurationsdatei</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-building>8.5. Einen angepassten Kernel bauen und installieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. Wenn etwas schiefgeht</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/printing/>Kapitel 9. Drucken</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-quick-start>9.1. Schnellstart</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-connections>9.2. Druckerverbindungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-pdls>9.3. Gebräuchliche Seitenbeschreibungssprachen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-direct>9.4. Direktes Drucken</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-lpd>9.5. LPD (Line Printer Daemon)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/printing/#printing-other>9.6. Andere Drucksysteme</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/linuxemu/>Kapitel 10. Linux®-Binärkompatibilität</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Konfiguration der Linux®-Binärkompatibilität</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/linuxemu/#linuxemu-advanced>10.3. Weiterführende Themen</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/partiii/>Teil III. Systemadministration</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle checked>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/config/>Kapitel 11. Konfiguration und Tuning</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#config-synopsis>11.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-starting-services>11.2. Start von Diensten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-cron>11.3. cron(8) konfigurieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-rcd>11.4. Dienste unter FreeBSD verwalten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#config-network-setup>11.5. Einrichten von Netzwerkkarten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-virtual-hosts>11.6. Virtual Hosts</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-syslog>11.7. Konfiguration der Systemprotokollierung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-configfiles>11.8. Konfigurationsdateien</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-sysctl>11.9. Einstellungen mit sysctl(8)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-disk>11.10. Tuning von Laufwerken</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#configtuning-kernel-limits>11.11. Einstellungen von Kernel Limits</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#adding-swap-space>11.12. Hinzufügen von Swap-Bereichen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/config/#acpi-overview>11.13. Energie- und Ressourcenverwaltung</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/boot/>Kapitel 12. FreeBSDs Bootvorgang</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/boot/#boot-synopsis>12.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/boot/#boot-introduction>12.2. FreeBSDs Bootvorgang</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/boot/#boot-splash>12.3. Willkommensbildschirme während des Bootvorgangs konfigurieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/boot/#device-hints>12.4. Konfiguration von Geräten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/boot/#boot-shutdown>12.5. Der Shutdown-Vorgang</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/security/>Kapitel 13. Sicherheit</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-synopsis>13.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-intro>13.2. Einführung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#one-time-passwords>13.3. Einmalpasswörter</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#ipsec>13.7. VPN mit IPsec</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#fs-acl>13.9. Zugriffskontrolllisten für Dateisysteme (ACL)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-pkg>13.10. Sicherheitsprobleme in Software von Drittanbietern überwachen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-advisories>13.11. FreeBSD Sicherheitshinweise</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-accounting>13.12. Prozess-Überwachung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-resourcelimits>13.13. Einschränkung von Ressourcen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/security/#security-sudo>13.14. Gemeinsame Administration mit Sudo</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/jails/>Kapitel 14. Jails</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-synopsis>14.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-terms>14.2. Jails - Definitionen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-build>14.3. Einrichtung und Verwaltung von Jails</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-tuning>14.4. Feinabstimmung und Administration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-application>14.5. Mehrere Jails aktualisieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/jails/#jails-ezjail>14.6. Verwaltung von Jails mit ezjail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/mac/>Kapitel 15. Verbindliche Zugriffskontrolle</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-synopsis>15.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-inline-glossary>15.2. Schlüsselbegriffe</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-initial>15.3. Erläuterung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-understandlabel>15.4. MAC Labels verstehen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-planning>15.5. Planung eines Sicherheitsmodells</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-modules>15.6. Modulkonfiguration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-seeotheruids>15.7. Das MAC Modul seeotheruids</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-bsdextended>15.8. Das MAC Modul bsdextended</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-ifoff>15.9. Das MAC Modul ifoff</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-portacl>15.10. Das MAC Modul portacl</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-partition>15.11. Das MAC Modul partition</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-mls>15.12. Das MAC Modul Multi-Level Security</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-biba>15.13. Das MAC Modul Biba</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-lomac>15.14. Das MAC Modul LOMAC</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-implementing>15.15. Beispiel 1: Nagios in einer MAC Jail</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-userlocked>15.16. Beispiel 2: User Lock Down</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mac/#mac-troubleshoot>15.17. Fehler im MAC beheben</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/audit/>Kapitel 16. Security Event Auditing</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/audit/#audit-synopsis>16.1. Einleitung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/audit/#audit-inline-glossary>16.2. Schlüsselbegriffe</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/audit/#audit-config>16.3. Audit Konfiguration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/audit/#audit-administration>16.4. Audit-Trails</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/disks/>Kapitel 17. Speichermedien</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-synopsis>17.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-adding>17.2. Hinzufügen von Laufwerken</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-growing>17.3. Partitionen vergrößern</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#usb-disks>17.4. USB Speichermedien</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#creating-cds>17.5. Erstellen und Verwenden von CDs</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#creating-dvds>17.6. DVDs benutzen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#floppies>17.7. Disketten benutzen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#backup-basics>17.8. Datensicherung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-virtual>17.9. Speicherbasierte Laufwerke</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#snapshots>17.10. Schnappschüsse von Dateisystemen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#quotas>17.11. Disk Quotas</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-encrypting>17.12. Partitionen verschlüsseln</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#swap-encrypting>17.13. Den Auslagerungsspeicher verschlüsseln</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/disks/#disks-hast>17.14. Highly Available Storage (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/geom/>Kapitel 18. GEOM: Modulares Framework zur Plattentransformation</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-synopsis>18.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-mirror>18.3. RAID1 - Spiegelung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-raid3>18.4. RAID3 - Byte-Level Striping mit dedizierter Parität</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-graid>18.5. Software RAID</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-ggate>18.6. GEOM Gate Netzwerk</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-glabel>18.7. Das Labeln von Laufwerken</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/geom/#geom-gjournal>18.8. UFS Journaling in GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/zfs/>Kapitel 19. Das Z-Dateisystem (ZFS)</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-differences>19.1. Was ZFS anders macht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-quickstart>19.2. Schnellstartanleitung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-zpool>19.3. <code>zpool</code> Administration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-zfs>19.4. <code>zfs</code> Administration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-zfs-allow>19.5. Delegierbare Administration</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-advanced>19.6. Themen für Fortgeschrittene</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-links>19.7. Zusätzliche Informationen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/zfs/#zfs-term>19.8. ZFS-Eigenschaften und Terminologie</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/filesystems/>Kapitel 20. Dateisystemunterstützung</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/filesystems/#filesystems-synopsis>20.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/filesystems/#filesystems-linux>20.2. Linux® Dateisysteme</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/>Kapitel 21. Virtualisierung</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-synopsis>21.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-guest-parallels>21.2. FreeBSD als Gast-Betriebssystem unter Parallels für Mac OS® X</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. FreeBSD als Gast-Betriebssystem unter Virtual PC für Windows®</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-guest-vmware>21.4. FreeBSD als Gast-Betriebssystem unter VMware Fusion für Mac OS®</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-guest-virtualbox-guest-additions>21.5. FreeBSD als Gast mit VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. FreeBSD als Host mit Virtualbox</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-host-bhyve>21.7. FreeBSD als Host mit bhyve</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/virtualization/#virtualization-host-xen>21.8. FreeBSD als Xen™-Host</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/l10n/>Kapitel 22. Lokalisierung – I18N/L10N einrichten und benutzen</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/l10n/#l10n-synopsis>22.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/l10n/#using-localization>22.2. Lokale Anpassungen benutzen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/l10n/#l10n-compiling>22.3. I18N-Programme</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/l10n/#lang-setup>22.4. Lokalisierung für einzelne Sprachen</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/>Kapitel 23. FreeBSD aktualisieren</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. FreeBSD-Update</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. Aktualisieren der Dokumentationssammlung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#current-stable>23.4. Einem Entwicklungszweig folgen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#makeworld>23.5. FreeBSD aus den Quellen aktualisieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/cutting-edge/#small-lan>23.6. Installation mehrerer Maschinen</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/dtrace/>Kapitel 24. DTrace</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/dtrace/#dtrace-synopsis>24.1. Überblick</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/dtrace/#dtrace-implementation>24.2. Unterschiede in der Implementierung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/dtrace/#dtrace-enable>24.3. Die DTrace Unterstützung aktivieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/dtrace/#dtrace-using>24.4. DTrace verwenden</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/usb-device-mode/>Kapitel 25. USB Gerätemodus</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. Virtuelle serielle USB-Ports</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. Netzwerkkarten im USB-Gerätemodus</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. Virtuelle USB-Speichergeräte</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/partiv/>Teil IV. Netzwerke</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/>Kapitel 26. Serielle Datenübertragung</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#serial-synopsis>26.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#serial>26.2. Begriffe und Hardware</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#term>26.3. Terminals</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#dialup>26.4. Einwählverbindungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#dialout>26.5. Verbindungen nach Außen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/serialcomms/#serialconsole-setup>26.6. Einrichten der seriellen Konsole</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/>Kapitel 27. PPP</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/#userppp>27.2. PPP konfigurieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. Probleme bei PPP-Verbindungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/#pppoe>27.4. PPP over Ethernet (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/ppp-and-slip/#pppoa>27.5. PPP over ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/mail/>Kapitel 28. Elektronische Post (E-Mail)</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-de-term>28.1. Terminologie</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-synopsis>28.2. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-using>28.3. E-Mail Komponenten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#sendmail>28.4. Sendmail-Konfigurationsdateien</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-changingmta>28.5. Wechseln des Mailübertragungs-Agenten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-trouble>28.6. Fehlerbehebung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-advanced>28.7. Weiterführende Themen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#outgoing-only>28.8. Ausgehende E-Mail über einen Relay versenden</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#SMTP-dialup>28.9. E-Mail über Einwahl-Verbindungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#SMTP-Auth>28.10. SMTP-Authentifizierung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-agents>28.11. E-Mail-Programme</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-fetchmail>28.12. E-Mails mit fetchmail abholen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mail/#mail-procmail>28.13. E-Mails mit procmail filtern</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/>Kapitel 29. Netzwerkserver</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-servers-synopsis>29.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-inetd>29.2. Der inetd"Super-Server"</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-nis>29.4. Network Information System (NIS)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-ldap>29.5. Lightweight Access Directory Protocol (LDAP)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-dhcp>29.6. Dynamic Host Configuration Protocol (DHCP)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-dns>29.7. Domain Name System (DNS)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-apache>29.8. Apache HTTP-Server</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-ftp>29.9. File Transfer Protocol (FTP)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-samba>29.10. Datei- und Druckserver für Microsoft® Windows®-Clients (Samba)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-ntp>29.11. Die Uhrzeit mit NTP synchronisieren</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/network-servers/#network-iscsi>29.12. iSCSI Initiator und Target Konfiguration</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/>Kapitel 30. Firewalls</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-intro>30.1. Einführung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-concepts>30.2. Firewallkonzepte</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/>Kapitel 31. Weiterführende Netzwerkthemen</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Übersicht</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-routing>31.2. Gateways und Routen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-wireless>31.3. Drahtlose Netzwerke</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-bluetooth>31.5. Bluetooth</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-bridging>31.6. LAN-Kopplung mit einer Bridge</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-aggregation>31.7. Link-Aggregation und Failover</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-diskless>31.8. Plattenloser Betrieb mit PXE</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#carp>31.10. Common Address Redundancy Protocol (CARP)</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/partv/>Teil V. Anhang</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/mirrors/>Anhang A. Bezugsquellen für FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/mirrors/#mirrors-cdrom>A.1. CD and DVD Sets</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mirrors/#mirrors-ftp>A.2. FTP-Server</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mirrors/#svn>A.3. Benutzen von Subversion</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/mirrors/#mirrors-rsync>A.4. Benutzen von rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/>Anhang B. Bibliografie</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-freebsd>B.1. Bücher speziell für FreeBSD</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-userguides>B.2. Handbücher</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-adminguides>B.3. Administrations-Anleitungen</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-programmers>B.4. Programmierhandbücher</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-osinternals>B.5. Betriebssystem-Interna</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-security>B.6. Sicherheits-Anleitung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-hardware>B.7. Hardware-Anleitung</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-history>B.8. UNIX® Geschichte</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/bibliography/#bibliography-journals>B.9. Zeitschriften, Magazine und Journale</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/eresources/>Anhang C. Ressourcen im Internet</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/eresources/#eresources-www>C.1. Webseiten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/eresources/#eresources-mail>C.2. Mailinglisten</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/eresources/#eresources-news>C.3. Usenet-News</a></li><li><a href=http://172.16.201.134:1313/de/books/handbook/eresources/#eresources-web>C.4. Offizielle Spiegel</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/de/books/handbook/pgpkeys/>Anhang D. OpenPGP-Schlüssel</a><ul><li><a href=http://172.16.201.134:1313/de/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Ansprechpartner</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Kapitel 11. Konfiguration und Tuning</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#config-synopsis>11.1. Übersicht</a></li><li><a href=#configtuning-starting-services>11.2. Start von Diensten</a></li><li><a href=#configtuning-cron>11.3. cron(8) konfigurieren</a></li><li><a href=#configtuning-rcd>11.4. Dienste unter FreeBSD verwalten</a></li><li><a href=#config-network-setup>11.5. Einrichten von Netzwerkkarten</a></li><li><a href=#configtuning-virtual-hosts>11.6. Virtual Hosts</a></li><li><a href=#configtuning-syslog>11.7. Konfiguration der Systemprotokollierung</a></li><li><a href=#configtuning-configfiles>11.8. Konfigurationsdateien</a></li><li><a href=#configtuning-sysctl>11.9. Einstellungen mit sysctl(8)</a></li><li><a href=#configtuning-disk>11.10. Tuning von Laufwerken</a></li><li><a href=#configtuning-kernel-limits>11.11. Einstellungen von Kernel Limits</a></li><li><a href=#adding-swap-space>11.12. Hinzufügen von Swap-Bereichen</a></li><li><a href=#acpi-overview>11.13. Energie- und Ressourcenverwaltung</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=config-synopsis>11.1. Übersicht<a class=anchor href=#config-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Die richtige Systemkonfiguration ist einer der wichtigsten Aspekte unter FreeBSD. Dieses Kapitel beschreibt die Konfiguration von FreeBSD sowie Maßnahmen zur Leistungssteigerung von FreeBSD-Systemen.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel durchgearbeitet haben, werden Sie Folgendes wissen:</p></div><div class=ulist><ul><li><p>Die Grundlagen der Konfiguration von <span class=filename>rc.conf</span> und die Skripte zum Starten von Anwendungen in <span class=filename>/usr/local/etc/rc.d</span>.</p></li><li><p>Wie Sie Netzwerkkarten konfigurieren und testen.</p></li><li><p>Wie Sie virtuelle Hosts und Netzwerkgeräte konfigurieren.</p></li><li><p>Wie Sie die verschiedenen Konfigurationsdateien in <span class=filename>/etc</span> benutzen.</p></li><li><p>Wie Sie mit FreeBSD mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variablen einstellen können.</p></li><li><p>Wie Sie die Platten-Performance einstellen und Kernel-Parameter modifizieren können.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie</p></div><div class=ulist><ul><li><p>die Grundlagen von UNIX® und FreeBSD (<a href=../basics/#basics>Grundlagen des FreeBSD Betriebssystems</a>) verstehen.</p></li><li><p>Damit vertraut sein, wie Sie einen Kernel konfigurieren und kompilieren (<a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=configtuning-starting-services>11.2. Start von Diensten<a class=anchor href=#configtuning-starting-services></a></h2><div class=sectionbody><div class=paragraph><p>Viele Benutzer installieren Software Dritter auf FreeBSD mithilfe der Ports-Sammlung. Häufig soll die Software bei einem Systemstart mitgestartet werden. Beispielsweise sollen die Dienste <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> oder <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> nach einem Systemstart laufen. Dieser Abschnitt stellt die Startprozeduren für Software Dritter vor.</p></div><div class=paragraph><p>Unter FreeBSD werden die meisten der im System enthaltenen Dienste wie <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> mithilfe von Systemskripten gestartet.</p></div><div class=sect2><h3 id=_dienste_über_das_rc_d_system_starten>11.2.1. Dienste über das <span class=filename>rc.d</span>-System starten<a class=anchor href=#_dienste_über_das_rc_d_system_starten></a></h3><div class=paragraph><p>Mit <span class=filename>rc.d</span> lässt sich der Start von Anwendungen besser steuern und es sind mehr Funktionen verfügbar. Mit den in <a href=#configtuning-rcd>Dienste unter FreeBSD verwalten</a> besprochenen Schlüsselwörtern können Anwendungen in einer bestimmten Reihenfolge gestartet werden und Optionen können in <span class=filename>rc.conf</span> statt fest im Startskript der Anwendung festgelegt werden. Ein einfaches Startskript sieht wie folgt aus:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Dieses Skript stellt sicher, dass <code>utility</code> nach den <code>DAEMON</code>-Pseudodiensten gestartet wird. Es stellt auch eine Methode bereit, die Prozess-ID (PID) der Anwendung in einer Datei zu speichern.</p></div><div class=paragraph><p>In <span class=filename>/etc/rc.conf</span> könnte für diese Anwendung die folgende Zeile stehen:</p></div><div class="literalblock programlisting"><div class=content><pre>utility_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Die Methode erleichtert den Umgang mit Kommandozeilenargumenten, bindet Funktionen aus <span class=filename>/etc/rc.subr</span> ein, ist kompatibel zu <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> und lässt sich über <span class=filename>rc.conf</span> leichter konfigurieren.</p></div></div><div class=sect2><h3 id=_andere_arten_um_dienste_zu_starten>11.2.2. Andere Arten, um Dienste zu starten<a class=anchor href=#_andere_arten_um_dienste_zu_starten></a></h3><div class=paragraph><p>Andere Dienste können über <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> gestartet werden. Die Konfiguration von <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> wird in <a href=../network-servers/#network-inetd>“Der inetd Super-Server”</a> ausführlich beschrieben.</p></div><div class=paragraph><p>Systemdienste können auch mit <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> gestartet werden. Dieser Ansatz hat einige Vorteile; nicht zuletzt, weil <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> die Prozesse unter dem Eigentümer der <span class=filename>crontab</span> startet, ist es möglich, dass Dienste von normalen Benutzern gestartet und gepflegt werden können.</p></div><div class=paragraph><p>Für die Zeitangabe in <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> kann <code>@reboot</code> eingesetzt werden. Damit wird das Kommando gestartet, wenn <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> kurz nach dem Systemboot gestartet wird.</p></div></div></div></div><div class=sect1><h2 id=configtuning-cron>11.3. <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> konfigurieren<a class=anchor href=#configtuning-cron></a></h2><div class=sectionbody><div class=paragraph><p>Ein sehr nützliches Werkzeug von FreeBSD ist cron. Dieses Programm läuft im Hintergrund und überprüft fortlaufend <span class=filename>/etc/crontab</span> und <span class=filename>/var/cron/tabs</span>. In diesen Dateien wird festgelegt, welche Programme zu welchem Zeitpunkt von cron ausgeführt werden sollen. Jede Zeile in diesen Dateien definiert eine auszuführende Aufgabe, die auch als <em>Cronjob</em> bezeichnet wird.</p></div><div class=paragraph><p>Das Werkzeug verwendet zwei verschiedene Konfigurationsdateien: die System-crontab, welche nicht verändert werden sollte und die Benutzer-crontabs, die nach Bedarf erstellt und geändert werden können. Das Format, dass von diesen beiden Dateien verwendet wird, ist in <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> dokumentiert. Das Format der System-crontab in <span class=filename>/etc/crontab</span> enthält das Feld <code>who</code>, das in der Benutzer-crontab nicht existiert. Dieses Feld gibt den Benutzer an, mit dem die Aufgabe ausgeführt wird. Die Aufgaben in den Benutzer-crontabs laufen unter dem Benutzer, der die crontab erstellt hat.</p></div><div class=paragraph><p>Benutzer-crontabs erlauben es den Benutzern, ihre eigenen Aufgaben zu planen. Der Benutzer <code>root</code> kann auch seine eigene Benutzer-crontab haben, um Aufgaben zu planen, die nicht in der System-crontab existieren.</p></div><div class=paragraph><p>Hier ist ein Beispieleintrag aus der System-crontab, <span class=filename>/etc/crontab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/crontab - root&#39;s crontab for FreeBSD
#
# $FreeBSD$
<i class=conum data-value=1></i><b>(1)</b>
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <i class=conum data-value=2></i><b>(2)</b>
#
#minute	hour	mday	month	wday	who	command <i class=conum data-value=3></i><b>(3)</b>
#
*/5	*	*	*	*	root	/usr/libexec/atrun <i class=conum data-value=4></i><b>(4)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Das Zeichen <code>#</code> am Zeilenanfang leitet einen Kommentar ein. Benutzen Sie Kommentare, um die Funktion eines Eintrags zu erläutern. Kommentare müssen in einer extra Zeile stehen. Sie können nicht in derselben Zeile wie ein Kommando stehen, da sie sonst Teil des Kommandos wären. Leerzeilen in dieser Datei werden ignoriert.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Umgebungsvariablen werden mit dem Gleichheits-Zeichen (<code>=</code>) festgelegt. Im Beispiel werden die Variablen <code>SHELL</code>, <code>PATH</code> und <code>HOME</code> definiert. Wenn die Variable <code>SHELL</code> nicht definiert wird, benutzt cron die Bourne Shell. Wird die Variable <code>PATH</code> nicht gesetzt, müssen alle Pfadangaben absolut sein, da es keinen Vorgabewert für <code>PATH</code> gibt.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>In dieser Zeile werden sieben Felder der System-crontab beschrieben: <code>minute</code>, <code>hour</code>, <code>mday</code>, <code>month</code>, <code>wday</code>, <code>who</code> und <code>command</code>. Das Feld <code>minute</code> legt die Minute fest in der die Aufgabe ausgeführt wird, das Feld <code>hour</code> die Stunde, das Feld <code>mday</code> den Tag des Monats. Im Feld <code>month</code> wird der Monat und im Feld <code>wday</code> der Wochentag festgelegt. Alle Felder müssen numerische Werte enthalten und die Zeitangaben sind im 24-Stunden-Format. Das Zeichen <code>*</code> repräsentiert dabei alle möglichen Werte für dieses Feld. Das Feld <code>who</code> gibt es nur in der System-crontab und gibt den Account an, unter dem das Kommando laufen soll. Im letzten Feld wird schließlich das auszuführende Kommando angegeben.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Diese Zeile definiert die Werte für den Cronjob. Die Zeichenfolge <code>*/5</code> gefolgt von mehreren <code>*</code>-Zeichen bedeutet, dass <code>/usr/libexec/atrun</code> von <code>root</code> alle fünf Minuten aufgerufen wird.Bei den Kommandos können beliebig viele Optionen angegeben werden. Wenn das Kommando zu lang ist und auf der nächsten Zeile fortgesetzt werden soll, muss am Ende der Zeile das Fortsetzungszeichen (<code>\</code>) angegeben werden.</td></tr></tbody></table></div><div class=sect2><h3 id=configtuning-installcrontab>11.3.1. Eine Benutzer-crontab erstellen<a class=anchor href=#configtuning-installcrontab></a></h3><div class=paragraph><p>Rufen Sie <code>crontab</code> im Editor-Modus auf, um eine Benutzer-crontab zu erstellen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-e</span></code></pre></div></div><div class=paragraph><p>Dies wird die crontab des Benutzers mit dem voreingestellten Editor öffnen. Wenn der Benutzer diesen Befehl zum ersten Mal ausführt, wird eine leere Datei geöffnet. Nachdem der Benutzer eine crontab erstellt hat, wird die Datei mit diesem Kommando zur Bearbeitung geöffnet.</p></div><div class=paragraph><p>Es empfiehlt sich, die folgenden Zeilen an den Anfang der crontab-Datei hinzuzufügen, um die Umgebungsvariablen zu setzen und die einzelnen Felder zu beschreiben:</p></div><div class="literalblock programlisting"><div class=content><pre>SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin
# Order of crontab fields
# minute	hour	mday	month	wday	command</pre></div></div><div class=paragraph><p>Fügen Sie dann für jedes Kommando oder Skript eine Zeile hinzu, mit der Angabe wann das Kommando ausgeführt werden soll. In diesem Beispiel wird ein Bourne Shell Skript täglich um 14:00 Uhr ausgeführt. Da der Pfad zum Skript nicht in <code>PATH</code> enthalten ist, wird der vollständige Pfad zum Skript angegeben:</p></div><div class="literalblock programlisting"><div class=content><pre>0	14	*	*	*	/usr/home/dru/bin/mycustomscript.sh</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Bevor Sie ein eigenes Skript verwenden, stellen Sie sicher, dass es ausführbar ist und dass es mit den wenigen Umgebungsvariablen von cron funktioniert. Um die Umgebung nachzubilden, die der obige cron-Eintrag bei der Ausführung verwenden würde, benutzen Sie dieses Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>env</span> <span class=nt>-i</span> <span class=nv>SHELL</span><span class=o>=</span>/bin/sh <span class=nv>PATH</span><span class=o>=</span>/etc:/bin:/sbin:/usr/bin:/usr/sbin <span class=nv>HOME</span><span class=o>=</span>/home/dru <span class=nv>LOGNAME</span><span class=o>=</span>dru /usr/home/dru/bin/mycustomscript.sh</code></pre></div></div><div class=paragraph><p>Die Umgebung von cron wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> beschrieben. Es ist wichtig, dass sichergestellt wird, dass die Skripte in der Umgebung von cron korrekt arbeiten, besonders wenn Befehle enthalten sind, welche Dateien mit Wildcards löschen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn Sie mit der Bearbeitung der crontab fertig sind, speichern Sie die Datei. Sie wird automatisch installiert und cron wird die darin enthalten Cronjobs zu den angegebenen Zeiten ausführen. Um die Cronjobs in einer crontab aufzulisten, verwenden Sie diesen Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-l</span>
0	14	<span class=k>*</span>	<span class=k>*</span>	<span class=k>*</span>	/usr/home/dru/bin/mycustomscript.sh</code></pre></div></div><div class=paragraph><p>Um alle Cronjobs einer Benutzer-crontab zu löschen, verwenden Sie diesen Befehl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-r</span>
remove crontab <span class=k>for </span>dru? y</code></pre></div></div></div></div></div><div class=sect1><h2 id=configtuning-rcd>11.4. Dienste unter FreeBSD verwalten<a class=anchor href=#configtuning-rcd></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD verwendet die vom <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-System bereit gestellten Startskripten beim Systemstart und für die Verwaltung von Diensten. Die Skripte sind in <span class=filename>/etc/rc.d</span> abgelegt und bieten grundlegende Dienste an, die über die Optionen <code>start</code>, <code>stop</code> und <code>restart</code> des <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> Kommandos kontrolliert werden können. Beispielsweise kann <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> mit dem nachstehenden Kommando neu gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd restart</span></code></pre></div></div><div class=paragraph><p>Analog können Sie andere Dienste starten und stoppen. Normalerweise werden die Dienste beim Systemstart über Einträge in der Datei <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> automatisch gestartet. <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> wird zum Beispiel mit dem folgenden Eintrag in <span class=filename>/etc/rc.conf</span> aktiviert:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Wenn dort bereits die Zeile <code>natd_enable="NO"</code> existiert, ändern Sie <code>NO</code> in <code>YES</code>. Die <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-Skripten starten, wie unten beschrieben, auch abhängige Dienste.</p></div><div class=paragraph><p>Da das <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-System primär zum automatischen Starten und Stoppen von Systemdiensten dient, funktionieren die Optionen <code>start</code>, <code>stop</code> und <code>restart</code> nur, wenn die entsprechenden Variablen in <span class=filename>/etc/rc.conf</span> gesetzt sind. Beispielsweise funktioniert <code>sshd restart</code> nur dann, wenn in <span class=filename>/etc/rc.conf</span> die Variable <code>sshd_enable</code> auf <code>YES</code> gesetzt wurde. Wenn Sie die Optionen <code>start</code>, <code>stop</code> oder <code>restart</code> unabhängig von den Einstellungen in <span class=filename>/etc/rc.conf</span> benutzen wollen, müssen Sie den Optionen mit dem Präfix "one" verwenden. Um beispielsweise <code>sshd</code> unabhängig von den Einstellungen in <span class=filename>/etc/rc.conf</span> neu zu starten, benutzen Sie das nachstehende Kommando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd onerestart</span></code></pre></div></div><div class=paragraph><p>Ob ein Dienst in <span class=filename>/etc/rc.conf</span> aktiviert ist, können Sie herausfinden, indem Sie das entsprechende <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-Skript mit der Option <code>rcvar</code> aufrufen. Dieses Beispiel prüft, ob der <code>sshd</code>-Dienst in <span class=filename>/etc/rc.conf</span> aktiviert ist:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd rcvar</span>
<span class=c># sshd</span>
<span class=c>#</span>
<span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=c>#   (default: &#34;&#34;)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Zeile <code># sshd</code> wird von dem Kommando ausgegeben; sie kennzeichnet nicht die Eingabeaufforderung von <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ob ein Dienst läuft, kann mit <code>status</code> abgefragt werden. Das folgende Kommando überprüft, ob <code>sshd</code> auch wirklich gestartet wurde:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd status</span>
sshd is running as pid 433.</code></pre></div></div><div class=paragraph><p>Einige Dienste können über die Option <code>reload</code> neu initialisiert werden. Dazu wird dem Dienst über ein Signal mitgeteilt, dass er seine Konfigurationsdateien neu einlesen soll. Oft wird dazu das Signal <code>SIGHUP</code> verwendet. Beachten Sie aber, dass nicht alle Dienste diese Option unterstützen.</p></div><div class=paragraph><p>Die meisten Systemdienste werden beim Systemstart vom <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-System gestartet. Zum Beispiel aktiviert das Skript <span class=filename>/etc/rc.d/bgfsck</span> die Prüfung von Dateisystemen im Hintergrund. Das Skript gibt die folgende Meldung aus, wenn es gestartet wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Starting background file system checks <span class=k>in </span>60 seconds.</code></pre></div></div><div class=paragraph><p>Dieses Skript wird während des Systemstarts ausgeführt und führt eine Überprüfung der Dateisysteme im Hintergrund durch.</p></div><div class=paragraph><p>Viele Systemdienste hängen von anderen Diensten ab. <a href="https://man.freebsd.org/cgi/man.cgi?query=yp&amp;sektion=8&amp;format=html">yp(8)</a> und andere RPC-basierende Systeme hängen beispielsweise von dem <code>rpcbind</code>-Dienst ab. Im Kopf der Startskripten befinden sich die Informationen über Abhängigkeiten von anderen Diensten und weitere Metadaten. Mithilfe dieser Daten bestimmt das Programm <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> beim Systemstart die Startreihenfolge der Dienste.</p></div><div class=paragraph><p>Folgende Schlüsselwörter müssen im Kopf aller Startskripten verwendet werden, da sie von <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> zum "Aktivieren" des Startskripts benötigt werden:</p></div><div class=ulist><ul><li><p><code>PROVIDE</code>: Gibt die Namen der Dienste an, die mit dieser Datei zur Verfügung gestellt werden.</p></li></ul></div><div class=paragraph><p>Die folgenden Schlüsselwörter können im Kopf des Startskripts angegeben werden. Sie sind zwar nicht unbedingt notwendig, sind aber hilfreich beim Umgang mit <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>:</p></div><div class=ulist><ul><li><p><code>REQUIRE</code>: Gibt die Namen der Dienste an, von denen dieser Dienst abhängt. Ein Skript, das dieses Schlüsselwort enthält wird <em>nach</em> den angegebenen Diensten ausgeführt.</p></li><li><p><code>BEFORE</code>: Zählt Dienste auf, die auf diesen Dienst angewiesen sind. Ein Skript, dass dieses Schlüsselwort enthält wird <em>vor</em> den angegebenen Diensten ausgeführt.</p></li></ul></div><div class=paragraph><p>Durch das Verwenden dieser Schlüsselwörter kann ein Administrator die Startreihenfolge von Systemdiensten feingranuliert steuern, ohne mit den Schwierigkeiten des "runlevel"-Systems anderer UNIX® Systeme kämpfen zu müssen.</p></div><div class=paragraph><p>Weitere Informationen über das <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-System finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Wenn Sie eigene <span class=filename>rc.d</span>-Skripte schreiben wollen, sollten Sie <a href=https://docs.freebsd.org/en/articles/rc-scripting/>diesen Artikel</a> lesen.</p></div><div class=sect2><h3 id=configtuning-core-configuration>11.4.1. Systemspezifische Konfiguration<a class=anchor href=#configtuning-core-configuration></a></h3><div class=paragraph><p>Informationen zur Systemkonfiguration sind hauptsächlich in <span class=filename>/etc/rc.conf</span>, die meist beim Start des Systems verwendet wird, abgelegt. Sie enthält die Konfigurationen für die <span class=filename>rc*</span> Dateien.</p></div><div class=paragraph><p>In <span class=filename>rc.conf</span> werden die Vorgabewerte aus <span class=filename>/etc/defaults/rc.conf</span> überschrieben. Die Vorgabedatei sollte nicht editiert werden. Stattdessen sollten alle systemspezifischen Änderungen in <span class=filename>rc.conf</span> vorgenommen werden.</p></div><div class=paragraph><p>Um den administrativen Aufwand gering zu halten, existieren in geclusterten Anwendungen mehrere Strategien, globale Konfigurationen von systemspezifischen Konfigurationen zu trennen. Der empfohlene Weg hält die globale Konfiguration in einer separaten Datei z.B. <span class=filename>/etc/rc.conf.local</span>. Zum Beispiel so:</p></div><div class=ulist><ul><li><p><span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;
keyrate=&#34;fast&#34;
defaultrouter=&#34;10.1.1.254&#34;</pre></div></div></li><li><p><span class=filename>/etc/rc.conf.local</span>:</p><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;node1.example.org&#34;
ifconfig_fxp0=&#34;inet 10.1.1.1/8&#34;</pre></div></div></li></ul></div><div class=paragraph><p><span class=filename>/etc/rc.conf</span> kann dann auf jedes System mit rsync oder puppet verteilt werden, während <span class=filename>/etc/rc.conf.local</span> dabei systemspezifisch bleibt.</p></div><div class=paragraph><p>Bei einem Upgrade des Systems wird <span class=filename>/etc/rc.conf</span> nicht überschrieben, so dass die Systemkonfiguration erhalten bleibt.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/rc.conf</span> und <span class=filename>/etc/rc.conf.local</span> werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> gelesen. Dies erlaubt es dem Systemadministrator, komplexe Konfigurationsszenarien zu erstellen. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, um weitere Informationen zu diesem Thema zu erhalten.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=config-network-setup>11.5. Einrichten von Netzwerkkarten<a class=anchor href=#config-network-setup></a></h2><div class=sectionbody><div class=paragraph><p>Die Konfiguration einer Netzwerkkarte gehört zu den alltäglichen Aufgaben eines FreeBSD Administrators.</p></div><div class=sect2><h3 id=_bestimmen_des_richtigen_treibers>11.5.1. Bestimmen des richtigen Treibers<a class=anchor href=#_bestimmen_des_richtigen_treibers></a></h3><div class=paragraph><p>Ermitteln Sie zunächst das Modell der Netzwerkkarte und den darin verwendeten Chip. FreeBSD unterstützt eine Vielzahl von Netzwerkkarten. Prüfen Sie die Hardware-Kompatibilitätsliste für das FreeBSD Release, um zu sehen ob die Karte unterstützt wird.</p></div><div class=paragraph><p>Wenn die Karte unterstützt wird, müssen Sie den Treiber für die Karte bestimmen. <span class=filename>/usr/src/sys/conf/NOTES</span> und <span class=filename>/usr/src/sys/arch/conf/NOTES</span> enthalten eine Liste der verfügbaren Treiber mit Informationen zu den unterstützten Chipsätzen. Wenn Sie sich nicht sicher sind, ob Sie den richtigen Treiber ausgewählt haben, lesen Sie die Hilfeseite des Treibers. Sie enthält weitere Informationen über die unterstützten Geräte und bekannte Einschränkungen des Treibers.</p></div><div class=paragraph><p>Die Treiber für gebräuchliche Netzwerkkarten sind schon im <span class=filename>GENERIC</span>-Kernel enthalten, so dass die Karte während des Systemstarts erkannt werden sollte. Die Systemmeldungen können Sie sich mit <code>more /var/run/dmesg.boot</code> ansehen. Mit der Leertaste können Sie durch den Text blättern. In diesem Beispiel findet das System zwei Karten, die den <a href="https://man.freebsd.org/cgi/man.cgi?query=dc&amp;sektion=4&amp;format=html">dc(4)</a>-Treiber benutzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: <span class=o>[</span>ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: <span class=o>[</span>ITHREAD]</code></pre></div></div><div class=paragraph><p>Ist der Treiber für die Netzwerkkarte nicht in <span class=filename>GENERIC</span> enthalten, muss zunächst ein Treiber geladen werden, um die Karte konfigurieren und benutzen zu können. Dafür gibt es zwei Methoden:</p></div><div class=ulist><ul><li><p>Am einfachsten ist es, das Kernelmodul für die Karte mit <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> zu laden. Um den Treiber automatisch beim Systemstart zu laden, fügen Sie die entsprechende Zeile in <span class=filename>/boot/loader.conf</span> ein. Es gibt nicht für alle Karten Kernelmodule.</p></li><li><p>Alternativ kann der Treiber für die Karte fest in den Kernel eingebunden werden. Lesen Sie dazu <span class=filename>/usr/src/sys/conf/NOTES</span>, <span class=filename>/usr/src/sys/arch/conf/NOTES</span> und die Hilfeseite des Treibers, den Sie in den Kernel einbinden möchten, an. Die Übersetzung des Kernels wird in <a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a> beschrieben. Wenn die Karte während des Systemstarts vom Kernel erkannt wurde, muss der Kernel nicht neu übersetzt werden.</p></li></ul></div><div class=sect3><h4 id=config-network-ndis>11.5.1.1. Windows®-NDIS-Treiber einsetzen<a class=anchor href=#config-network-ndis></a></h4><div class=paragraph><p>Leider stellen nach wie vor viele Unternehmen die Spezifikationen ihrer Treiber der Open Source Gemeinde nicht zur Verfügung, weil sie diese Informationen als Geschäftsgeheimnisse betrachten. Daher haben die Entwickler von FreeBSD und anderen Betriebssystemen nur zwei Möglichkeiten. Entweder versuchen sie in einem aufwändigen Prozess den Treiber durch Reverse Engineering nachzubauen, oder sie versuchen, die vorhandenen Binärtreiber der Microsoft® Windows®-Plattform zu verwenden.</p></div><div class=paragraph><p>FreeBSD bietet "native" Unterstützung für die Network Driver Interface Specification (NDIS). <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> wird benutzt, um einen Windows® XP-Treiber in ein Format zu konvertieren, das von FreeBSD verwendet werden kann. Da der <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>-Treiber einen Windows® XP-Binärtreiber nutzt, kann er nur auf i386™- und amd64-Systemen verwendet werden. Unterstützt werden PCI, CardBus, PCMCIA und USB-Geräte.</p></div><div class=paragraph><p>Um den NDISulator zu verwenden, benötigen Sie drei Dinge:</p></div><div class="olist arabic"><ol class=arabic><li><p>Die FreeBSD Kernelquellen</p></li><li><p>Den Windows® XP-Binärtreiber mit der Erweiterung <span class=filename>.SYS</span></p></li><li><p>Die Konfigurationsdatei des Windows® XP-Treibers mit der Erweiterung <span class=filename>.INF</span></p></li></ol></div><div class=paragraph><p>Laden Sie die <span class=filename>.SYS</span>- und <span class=filename>.INF</span>-Dateien für die Karte. Diese befinden sich meistens auf einer beigelegten CD-ROM, oder können von der Internetseite des Herstellers heruntergeladen werden. In den folgenden Beispielen werden die Dateien <span class=filename>W32DRIVER.SYS</span> und <span class=filename>W32DRIVER.INF</span> verwendet.</p></div><div class=paragraph><p>Die Architektur des Treibers muss zur jeweiligen Version von FreeBSD passen. Benutzen Sie einen Windows® 32-bit Treiber für FreeBSD/i386. Für FreeBSD/amd64 wird ein Windows® 64-bit Treiber benötigt.</p></div><div class=paragraph><p>Als Nächstes kompilieren Sie den binären Treiber, um ein Kernelmodul zu erzeugen. Dazu rufen Sie als <code>root</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> auf:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</span></code></pre></div></div><div class=paragraph><p>Dieses Kommando arbeitet interaktiv, benötigt es weitere Informationen, so fragt es Sie danach. Das Ergebnis ist ein neu erzeugtes Kernelmodul im aktuellen Verzeichnis. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> um das neue Modul zu laden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ./W32DRIVER.ko</span></code></pre></div></div><div class=paragraph><p>Neben dem erzeugten Kernelmodul müssen auch die Kernelmodule <span class=filename>ndis.ko</span> und <span class=filename>if_ndis.ko</span> geladen werden. Dies passiert automatisch, wenn Sie ein von <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> abhängiges Modul laden. Andernfalls können die Module mit den folgenden Kommandos manuell geladen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>Der erste Befehl lädt den <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>-Miniport-Treiber, der zweite das tatsächliche Netzwerkgerät.</p></div><div class=paragraph><p>Überprüfen Sie die Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> auf eventuelle Fehler während des Ladevorgangs. Gab es dabei keine Probleme, sollte die Ausgabe wie folgt aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>Ab jetzt kann das Gerät <span class=filename>ndis0</span> wie jede andere Netzwerkkarte konfiguriert werden.</p></div><div class=paragraph><p>Um die <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>-Module automatisch beim Systemstart zu laden, kopieren Sie das erzeugte Modul <span class=filename>W32DRIVER_SYS.ko</span> nach <span class=filename>/boot/modules</span>. Danach fügen Sie die folgende Zeile in <span class=filename>/boot/loader.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>W32DRIVER_SYS_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect2><h3 id=_konfiguration_von_netzwerkkarten>11.5.2. Konfiguration von Netzwerkkarten<a class=anchor href=#_konfiguration_von_netzwerkkarten></a></h3><div class=paragraph><p>Nachdem der richtige Treiber für die Karte geladen ist, muss die Karte konfiguriert werden. Unter Umständen ist die Karte schon während der Installation mit <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a> konfiguriert worden.</p></div><div class=paragraph><p>Das nachstehende Kommando zeigt die Konfiguration der Netzwerkkarten an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig
dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active
dc1: <span class=nv>flags</span><span class=o>=</span>8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        <span class=nv>options</span><span class=o>=</span>3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 <span class=nv>options</span><span class=o>=</span>3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</code></pre></div></div><div class=paragraph><p>Im Beispiel werden Informationen zu den folgenden Geräten angezeigt:</p></div><div class=ulist><ul><li><p><span class=filename>dc0</span>: Der erste Ethernet-Adapter.</p></li><li><p><span class=filename>dc1</span>: Der zweite Ethernet-Adapter.</p></li><li><p><span class=filename>lo0</span>: Das Loopback-Gerät.</p></li></ul></div><div class=paragraph><p>Der Name der Netzwerkkarte wird aus dem Namen des Treibers und einer Zahl zusammengesetzt. Die Zahl gibt die Reihenfolge an, in der die Geräte beim Systemstart erkannt wurden. Die dritte Karte, die den <a href="https://man.freebsd.org/cgi/man.cgi?query=sis&amp;sektion=4&amp;format=html">sis(4)</a> Treiber benutzt, würde beispielsweise <span class=filename>sis2</span> heißen.</p></div><div class=paragraph><p>Der Adapter <span class=filename>dc0</span> aus dem Beispiel ist aktiv. Sie erkennen das an den folgenden Hinweisen:</p></div><div class="olist arabic"><ol class=arabic><li><p><code>UP</code> bedeutet, dass die Karte konfiguriert und aktiv ist.</p></li><li><p>Der Karte wurde die Internet-Adresse (<code>inet</code>) <code>192.168.1.3</code> zugewiesen.</p></li><li><p>Die Subnetzmaske ist richtig (<code>0xffffff00</code> entspricht <code>255.255.255.0</code>).</p></li><li><p>Die Broadcast-Adresse <code>192.168.1.255</code> ist richtig.</p></li><li><p>Die MAC-Adresse der Karte (<code>ether</code>) lautet <code>00:a0:cc:da:da:da</code>.</p></li><li><p>Die automatische Medienerkennung ist aktiviert (<code>media: Ethernet autoselect (100baseTX &lt;full-duplex>)</code>). Der Adapter <span class=filename>dc1</span> benutzt das Medium <code>10baseT/UTP</code>. Weitere Informationen über die einstellbaren Medien entnehmen Sie der Hilfeseite des Treibers.</p></li><li><p>Der Verbindungsstatus (<code>status</code>) ist <code>active</code>, das heißt es wurde ein Trägersignal entdeckt. Für <span class=filename>dc1</span> wird <code>status: no carrier</code> angezeigt. Das ist normal, wenn kein Kabel an der Karte angeschlossen ist.</p></li></ol></div><div class=paragraph><p>Wäre die Karte nicht konfiguriert, würde die Ausgabe von <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> so aussehen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active</code></pre></div></div><div class=paragraph><p>Die Karte muss als Benutzer <code>root</code> konfiguriert werden. Die Konfiguration kann auf der Kommandozeile mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> erfolgen. Allerdings gehen diese Informationen bei einem Neustart verloren. Tragen Sie stattdessen die Konfiguration in <span class=filename>/etc/rc.conf</span> ein. Wenn es im LAN einen DHCP-Server gibt, fügen Sie einfach folgende Zeile hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Ersetzen Sie <em>>dc0</em> durch die richtigen Werte für das System.</p></div><div class=paragraph><p>Nachdem Sie die Zeile hinzugefügt haben, folgen Sie den Anweisungen in <a href=#config-network-testing>Test und Fehlersuche</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn das Netzwerk während der Installation konfiguriert wurde, existieren vielleicht schon Einträge für die Netzwerkkarte(n). Überprüfen Sie <span class=filename>/etc/rc.conf</span> bevor Sie weitere Zeilen hinzufügen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Falls kein DHCP-Server zur Verfügung steht, müssen die Netzwerkkarten manuell konfiguriert werden. Fügen Sie für jede Karte im System eine Zeile hinzu, wie in diesem Beispiel zu sehen:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_dc1=&#34;inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP&#34;</pre></div></div><div class=paragraph><p>Ersetzen Sie <span class=filename>dc0</span> und <span class=filename>dc1</span> und die IP-Adressen durch die richtigen Werte für das System. Die Manualpages des Treibers, <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> enthalten weitere Einzelheiten über verfügbare Optionen und die Syntax von <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Wenn das Netzwerk kein DNS benutzt, können Sie in <span class=filename>/etc/hosts</span> die Namen und IP-Adressen der Rechner des LANs eintragen. Weitere Informationen entnehmen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> und <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls kein DHCP-Server zur Verfügung steht, Sie aber Zugang zum Internet benötigen, müssen Sie das Standard-Gateway und die Nameserver manuell konfigurieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;defaultrouter=&#34;Ihr_Default_Gateway&#34;&#39; &gt;&gt; /etc/rc.conf</span>
<span class=c># echo &#39;nameserver Ihr_DNS_Server&#39; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=config-network-testing>11.5.3. Test und Fehlersuche<a class=anchor href=#config-network-testing></a></h3><div class=paragraph><p>Nachdem die notwendigen Änderungen in <span class=filename>/etc/rc.conf</span> gespeichert wurden, kann das System neu gestartet werden, um die Konfiguration zu testen und zu überprüfen, ob das System ohne Fehler neu gestartet wurde. Alternativ können Sie mit folgenden Befehl die Netzwerkeinstellungen neu initialisieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Falls in <span class=filename>/etc/rc.conf</span> ein Default-Gateway definiert wurde, müssen Sie auch den folgenden Befehl ausführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service routing restart</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn das System gestartet ist, sollten Sie die Netzwerkkarten testen.</p></div><div class=sect3><h4 id=_test_der_ethernet_karte>11.5.3.1. Test der Ethernet-Karte<a class=anchor href=#_test_der_ethernet_karte></a></h4><div class=paragraph><p>Um zu prüfen, ob die Ethernet-Karte richtig konfiguriert ist, testen Sie zunächst mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> den Adapter selbst und sprechen Sie dann eine andere Maschine im LAN an.</p></div><div class=paragraph><p>Zuerst, der Test des Adapters:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.3
PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.082 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.074 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.108 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms

<span class=nt>---</span> 192.168.1.3 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.074/0.083/0.108/0.013 ms</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.2
PING 192.168.1.2 <span class=o>(</span>192.168.1.2<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.726 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.766 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.700 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.747 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.704 ms

<span class=nt>---</span> 192.168.1.2 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.700/0.729/0.766/0.025 ms</code></pre></div></div><div class=paragraph><p>Um die Namensauflösung zu testen, verwenden Sie den Namen der Maschine anstelle der IP-Adresse. Wenn kein DNS-Server im Netzwerk vorhanden ist, muss <span class=filename>/etc/hosts</span> entsprechend eingerichtet sein. Fügen Sie dazu die Namen und IP-Adressen der Rechner im LAN in <span class=filename>/etc/hosts</span> hinzu, falls sie nicht bereits vorhanden sind. Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> und <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div></div><div class=sect3><h4 id=_fehlersuche>11.5.3.2. Fehlersuche<a class=anchor href=#_fehlersuche></a></h4><div class=paragraph><p>Fehler zu beheben, ist immer sehr mühsam. Indem Sie die einfachen Sachen zuerst prüfen, erleichtern Sie sich die Aufgabe. Steckt das Netzwerkkabel? Sind die Netzwerkdienste richtig konfiguriert? Funktioniert die Firewall? Wird die Netzwerkkarte von FreeBSD unterstützt? Lesen Sie immer die Hardware-Informationen des Releases, bevor Sie einen Fehlerbericht einsenden. Aktualisieren Sie die FreeBSD-Version auf die neueste -STABLE Version. Suchen Sie in den Archiven der Mailinglisten und im Internet nach bekannten Lösungen.</p></div><div class=paragraph><p>Wenn die Karte funktioniert, die Verbindungen aber zu langsam sind, sollten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a> lesen. Prüfen Sie auch die Netzwerkkonfiguration, da falsche Einstellungen die Ursache für langsame Verbindungen sein können.</p></div><div class=paragraph><p>Wenn Sie viele <code>device timeout</code> Meldungen in den Systemprotokollen finden, prüfen Sie, dass es keinen Konflikt zwischen der Netzwerkkarte und anderen Geräten des Systems gibt. Überprüfen Sie nochmals die Verkabelung. Unter Umständen benötigen Sie eine andere Netzwerkkarte.</p></div><div class=paragraph><p>Bei <code>watchdog timeout</code> Fehlermeldungen, kontrollieren Sie zuerst die Verkabelung. Überprüfen Sie dann, ob der PCI-Steckplatz der Karte Bus Mastering unterstützt. Auf einigen älteren Motherboards ist das nur für einen Steckplatz (meistens Steckplatz 0) der Fall. Lesen Sie in der Dokumentation der Karte und des Motherboards nach, ob das vielleicht die Ursache des Problems sein könnte.</p></div><div class=paragraph><p>Die Meldung <code>No route to host</code> erscheint, wenn das System ein Paket nicht zustellen kann. Das kann vorkommen weil beispielsweise keine Default-Route gesetzt wurde oder das Netzwerkkabel nicht richtig steckt. Schauen Sie in der Ausgabe von <code>netstat -rn</code> nach, ob eine gültige Route zu dem Zielsystem existiert. Wenn nicht, lesen Sie <a href=../advanced-networking/#network-routing>“Gateways und Routen”</a>.</p></div><div class=paragraph><p>Die Meldung <code>ping: sendto: Permission denied</code> wird oft von einer falsch konfigurierten Firewall verursacht. Wenn keine Regeln definiert wurden, blockiert eine aktivierte Firewall alle Pakete, selbst einfache <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>-Pakete. Weitere Informationen erhalten Sie in <a href=../firewalls/#firewalls>Firewalls</a>.</p></div><div class=paragraph><p>Falls die Leistung der Karte schlecht ist, setzen Sie die Medienerkennung von <code>autoselect</code> (automatisch) auf das richtige Medium. In vielen Fällen löst diese Maßnahme Leistungsprobleme. Wenn nicht, prüfen Sie nochmal die Netzwerkeinstellungen und lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-virtual-hosts>11.6. Virtual Hosts<a class=anchor href=#configtuning-virtual-hosts></a></h2><div class=sectionbody><div class=paragraph><p>Ein gebräuchlicher Zweck von FreeBSD ist das virtuelle Hosting, bei dem ein Server im Netzwerk wie mehrere Server aussieht. Dies wird dadurch erreicht, dass einem Netzwerkinterface mehrere Netzwerk-Adressen zugewiesen werden.</p></div><div class=paragraph><p>Ein Netzwerkinterface hat eine "echte" Adresse und kann beliebig viele "alias" Adressen haben. Die Aliase werden durch entsprechende alias Einträge in <span class=filename>/etc/rc.conf</span> festgelegt, wie in diesem Beispiel zu sehen ist:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>Beachten Sie, dass die Alias-Einträge mit <code>alias_0_</code> anfangen müssen und weiter hochgezählt werden, das heißt <code>alias1</code>, <code>alias2</code>, und so weiter. Die Konfiguration der Aliase hört bei der ersten fehlenden Zahl auf.</p></div><div class=paragraph><p>Die Berechnung der Alias-Netzwerkmasken ist wichtig. Für jedes Interface muss es eine Adresse geben, die die Netzwerkmaske des Netzwerkes richtig beschreibt. Alle anderen Adressen in diesem Netzwerk haben dann eine Netzwerkmaske, die mit <code>1</code> gefüllt ist, also <code>255.255.255.255</code> oder hexadezimal <code>0xffffffff</code>.</p></div><div class=paragraph><p>Als Beispiel betrachten wir den Fall, in dem <span class=filename>fxp0</span> mit zwei Netzwerken verbunden ist: dem Netzwerk <code>10.1.1.0</code> mit der Netzwerkmaske <code>255.255.255.0</code> und dem Netzwerk <code>202.0.75.16</code> mit der Netzwerkmaske <code>255.255.255.240</code>. Das System soll die Adressen <code>10.1.1.1</code> bis <code>10.1.1.5</code> und <code>202.0.75.17</code> bis <code>202.0.75.20</code> belegen. Nur die erste Adresse in einem Netzwerk sollte die richtige Netzwerkmaske haben. Alle anderen Adressen (<code>10.1.1.2</code> bis <code>10.1.1.5</code> und <code>202.0.75.18</code> bis <code>202.0.75.20</code>) müssen die Maske <code>255.255.255.255</code> erhalten.</p></div><div class=paragraph><p>Die folgenden Einträge in <span class=filename>/etc/rc.conf</span> konfigurieren den Adapter entsprechend dem Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div><div class=paragraph><p>Dies kann mit einer durch Leerzeichen getrennten Liste von IP-Adressbereichen auch einfacher ausgedrückt werden. Die erste Adresse hat wieder die angegebene Netzwerkmaske und die zusätzlichen Adressen haben die Netzwerkmaske <code>255.255.255.255</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_aliases=&#34;inet 10.1.1.1-5/24 inet 202.0.75.17-20/28&#34;</pre></div></div></div></div><div class=sect1><h2 id=configtuning-syslog>11.7. Konfiguration der Systemprotokollierung<a class=anchor href=#configtuning-syslog></a></h2><div class=sectionbody><div class=paragraph><p>Die Aufzeichnung und Kontrolle von Log-Meldungen ist ein wichtiger Aspekt der Systemadministration. Die Informationen werden nicht nur verwendet um Hard- und Softwarefehler ausfindig zu machen, auch zur Überwachung der Sicherheit und der Reaktion bei einem Zwischenfall spielen diese Aufzeichnungen eine wichtige Rolle. Die meisten Systemdienste und Anwendungen erzeugen Log-Meldungen.</p></div><div class=paragraph><p>FreeBSD stellt mit syslogd ein Werkzeug zur Verwaltung von Protokollen bereit. In der Voreinstellung wird syslogd beim Booten automatisch gestartet. Dieses Verhalten wird über die Variable <code>syslogd_enable</code> in <span class=filename>/etc/rc.conf</span> gesteuert. Dazu gibt es noch zahlreiche Argumente, die in der Variable <code>syslogd_flags</code> in <span class=filename>/etc/rc.conf</span> gesetzt werden können. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> für weitere Informationen über die verfügbaren Argumente.</p></div><div class=paragraph><p>Dieser Abschnitt beschreibt die Konfiguration und Verwendung des FreeBSD Protokollservers, und diskutiert auch die Log-Rotation und das Management von Logdateien.</p></div><div class=sect2><h3 id=_konfiguration_der_lokalen_protokollierung>11.7.1. Konfiguration der lokalen Protokollierung<a class=anchor href=#_konfiguration_der_lokalen_protokollierung></a></h3><div class=paragraph><p>Die Konfigurationsdatei <span class=filename>/etc/syslog.conf</span> steuert, was syslogd mit Log-Meldungen macht, sobald sie empfangen werden. Es gibt verschiedene Parameter, die das Verhalten bei eingehenden Ereignissen kontrollieren. facility beschreibt das Subsystem, welches das Ereignis generiert hat. Beispielsweise der Kernel, oder ein Daemon. level hingegen beschreibt den Schweregrad des aufgetretenen Ereignisses. Dies macht es möglich, Meldungen in verschiedenen Logdateien zu protokollieren, oder Meldungen zu verwerfen, je nach Konfiguration von facility und level. Ebenfalls besteht die Möglichkeit auf Meldungen zu reagieren, die von einer bestimmten Anwendung stammen, oder von einem spezifischen Host erzeugt wurden.</p></div><div class=paragraph><p>Die Konfigurationsdatei von <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> enthält für jede Aktion eine Zeile. Die Syntax besteht aus einem Auswahlfeld, gefolgt von einem Aktionsfeld. Die Syntax für das Auswahlfeld ist <em>facility.level</em>. Dies entspricht Log-Meldungen von <em>facility</em> mit einem Level von <em>level</em> oder höher. Um noch präziser festzulegen was protokolliert wird, kann dem Level optional ein Vergleichsflag vorangestellt werden. Mehrere Auswahlen können, durch Semikolon (<code>;</code>) getrennt, für die gleiche Aktion verwendet werden. <code>*</code> wählt dabei alles aus. Das Aktionsfeld definiert, wohin die Log-Meldungen gesendet werden, beispielsweise in eine Datei oder zu einem entfernten Log-Server. Als Beispiel dient hier <span class=filename>/etc/syslog.conf</span> aus FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you$
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit                /dev/console
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
security.*                                      /var/log/security
auth.info;authpriv.info                         /var/log/auth.log
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
ftp.info                                        /var/log/xferlog
cron.*                                          /var/log/cron
!-devd
*.=debug                                        /var/log/debug.log
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
# Uncomment this if you wish to see messages produced by devd
# !devd
# *.&gt;=info
!ppp
*.*                                             /var/log/ppp.log
!*</pre></div></div><div class=paragraph><p>In diesem Beispiel:</p></div><div class=ulist><ul><li><p>Zeile 8 selektiert alle Meldungen vom Level <code>err</code>, sowie <code>kern.warning</code>, <code>auth.notice</code> und <code>mail.crit</code> und schickt diese zur Konsole (<span class=filename>/dev/console</span>).</p></li><li><p>Zeile 12 selektiert alle Meldungen von <code>mail</code> ab dem Level <code>info</code> oder höher und schreibt diese in <span class=filename>/var/log/maillog</span>.</p></li><li><p>Zeile 17 benutzt ein Vergleichsflag (<code>=</code>), um nur Meldungen vom Level <code>debug</code> zu selektieren und schreibt diese in <span class=filename>/var/log/debug.log</span>.</p></li><li><p>Zeile 33 zeigt ein Beispiel für die Nutzung einer Programmspezifikation. Die nachfolgenden Regeln sind dann nur für Programme gültig, welche der Programmspezifikation stehen. In diesem Fall werden alle Meldungen von ppp (und keinem anderen Programm) in <span class=filename>/var/log/ppp.log</span> geschrieben.</p></li></ul></div><div class=paragraph><p>Die verfügbaren level, beginnend mit den höchst kritischen, hin zu den weniger kritischen, sind: <code>emerg</code>, <code>alert</code>, <code>crit</code>, <code>err</code>, <code>warning</code>, <code>notice</code>, <code>info</code> und <code>debug</code>.</p></div><div class=paragraph><p>Die facilities, in beliebiger Reihenfolge, sind: <code>auth</code>, <code>authpriv</code>, <code>console</code>, <code>cron</code>, <code>daemon</code>, <code>ftp</code>, <code>kern</code>, <code>lpr</code>, <code>mail</code>, <code>mark</code>, <code>news</code>, <code>security</code>, <code>syslog</code>, <code>user</code>, <code>uucp</code>, sowie <code>local0</code> bis <code>local7</code>. Beachten Sie, dass andere Betriebssysteme hiervon abweichende facilities haben können.</p></div><div class=paragraph><p>Um alle Meldungen vom Level <code>notice</code> und höher in <span class=filename>/var/log/daemon.log</span> zu protokollieren, fügen Sie folgenden Eintrag hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>daemon.notice                                        /var/log/daemon.log</pre></div></div><div class=paragraph><p>Für weitere Informationen zu verschiedenen Level und faclilities, lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>. Weitere Informationen zu <span class=filename>/etc/syslog.conf</span>, dessen Syntax und erweiterten Anwendungsbeispielen, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>.</p></div></div><div class=sect2><h3 id=_management_und_rotation_von_logdateien>11.7.2. Management und Rotation von Logdateien<a class=anchor href=#_management_und_rotation_von_logdateien></a></h3><div class=paragraph><p>Logdateien können schnell wachsen und viel Speicherplatz belegen, was es schwieriger macht, nützliche Informationen zu finden. Log-Management versucht, diesen Effekt zu mildern. FreeBSD verwendet newsyslog für die Verwaltung von Logdateien. Dieses in FreeBSD integrierte Programm rotiert und komprimiert in regelmäßigen Abständen Logdateien. Optional kann es auch fehlende Logdateien erstellen und Programme benachrichtigen, wenn Logdateien verschoben wurden. Die Logdateien können von syslogd oder einem anderen Programm generiert werden. Obwohl newsyslog normalerweise von <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> aufgerufen wird, ist es kein Systemdämon. In der Standardkonfiguration wird dieser Job jede Stunde ausgeführt.</p></div><div class=paragraph><p>Um zu wissen, welche Maßnahmen zu ergreifen sind, liest newsyslog seine Konfigurationsdatei <span class=filename>/etc/newsyslog.conf</span>. Diese Konfigurationsdatei enthält eine Zeile für jede Datei, die von newsyslog verwaltet wird. Jede Zeile enthält Informationen über den Besitzer der Datei, die Dateiberechtigungen, wann die Datei rotiert wird, optionale Flags, welche die Log-Rotation beeinflussen (bspw. Komprimierung) und Programme, denen ein Signal geschickt wird, wenn Logdateien rotiert werden. Hier folgt die Standardkonfiguration in FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre># configuration file for newsyslog
# $FreeBSD$
#
# Entries which do not specify the &#39;/pid_file&#39; field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the &#39;N&#39; flag.
#
# The &#39;flags&#39; field is one or more of the letters: BCDGJNUXZ or a &#39;-&#39;.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/amd.log                        644  7     100  *     J
/var/log/auth.log                       600  7     100  @0101T JC
/var/log/console.log                    600  5     100  *     J
/var/log/cron                           600  3     100  *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     100  *     JC
/var/log/kerberos.log                   600  7     100  *     J
/var/log/lpd-errs                       644  7     100  *     JC
/var/log/maillog                        640  7     *    @T00  JC
/var/log/messages                       644  5     100  @0101T JC
/var/log/monthly.log                    640  12    *    $M1D0 JN
/var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log        root:network    640  3     100  *     JC
/var/log/devd.log                       644  3     100  *     JC
/var/log/security                       600  10    100  *     JC
/var/log/sendmail.st                    640  10    *    168   B
/var/log/utx.log                        644  3     *    @01T05 B
/var/log/weekly.log                     640  5     1    $W6D0 JN
/var/log/xferlog                        600  7     100  *     JC</pre></div></div><div class=paragraph><p>Jede Zeile beginnt mit dem Namen der Protokolldatei, die rotiert werden soll, optional gefolgt von Besitzer und Gruppe für rotierende, als auch für neu erstellte Dateien. Das Feld <code>mode</code> definiert die Zugriffsrechte der Datei. <code>count</code> gibt an, wie viele rotierte Dateien aufbewahrt werden sollen. Anhand der <code>size</code>- und <code>when</code>-Flags erkennt newsyslog, wann die Datei rotiert werden muss. Eine Logdatei wird rotiert, wenn ihre Größe den Wert von <code>size</code> überschreitet, oder wenn die Zeit im <code>when</code>-Feld abgelaufen ist. Ein <code>*</code> bedeutet, dass dieses Feld ignoriert wird. Das <em>flags</em>-Feld gibt newsyslog weitere Instruktionen, zum Beispiel wie eine Datei zu rotieren ist, oder eine Datei zu erstellen falls diese nicht existiert. Die letzten beiden Felder sind optional und bestimmen die PID-Datei und wann die Datei rotiert wird.</p></div><div class=paragraph><p>Weitere Informationen zu allen Feldern, gültigen Flags und wie Sie die Rotationszeit angeben können, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a>. Denken Sie daran, dass newsyslog von <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> aufgerufen wird und somit Dateien auch nur dann rotiert, wenn es von <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> aufgerufen wird, und nicht häufiger.</p></div></div><div class=sect2><h3 id=network-syslogd>11.7.3. Protokollierung von anderen Hosts<a class=anchor href=#network-syslogd></a></h3><div class=paragraph><p>Die Überwachung der Protokolldateien kann bei steigender Anzahl von Rechnern sehr unhandlich werden. Eine zentrale Protokollierung kann manche administrativen Belastungen bei der Verwaltung von Protokolldateien reduzieren.</p></div><div class=paragraph><p>Die Aggregation, Zusammenführung und Rotation von Protokolldateien kann in FreeBSD mit syslogd und newsyslog konfiguriert werden. In der folgenden Beispielkonfiguration sammelt Host <code>A</code>, genannt <code>logserv.example.com</code>, Protokollinformationen für das lokale Netzwerk. Host <code>B</code>, genannt <code>logclient.example.com</code> wird seine Protokollinformationen an den Server weiterleiten.</p></div><div class=sect3><h4 id=_konfiguration_des_protokollservers>11.7.3.1. Konfiguration des Protokollservers<a class=anchor href=#_konfiguration_des_protokollservers></a></h4><div class=paragraph><p>Ein Protokollserver ist ein System, welches Protokollinformationen von anderen Hosts akzeptiert. Bevor Sie diesen Server konfigurieren, prüfen Sie folgendes:</p></div><div class=ulist><ul><li><p>Falls eine Firewall zwischen dem Protokollserver und den -Clients steht, muss das Regelwerk der Firewall UDP auf Port 514 sowohl auf Client- als auch auf Serverseite freigegeben werden.</p></li><li><p>Der <code>syslogd</code>-Server und alle Clientrechner müssen gültige Einträge für sowohl Vorwärts- als auch Umkehr-DNS besitzen. Falls im Netzwerk kein DNS-Server vorhanden ist, muss auf jedem System die Datei <span class=filename>/etc/hosts</span> mit den richtigen Einträgen gepflegt werden. Eine funktionierende Namensauflösung ist zwingend erforderlich, ansonsten würde der Server die Protokollnachrichten ablehnen.</p></li></ul></div><div class=paragraph><p>Bearbeiten Sie <span class=filename>/etc/syslog.conf</span> auf dem Server. Tragen Sie den Namen des Clients ein, den Verbindungsweg und den Namen der Protokolldatei. Dieses Beispiel verwendet den Rechnernamen <code>B</code>, alle Verbindungswege, und die Protokolle werden in <span class=filename>/var/log/logclient.log</span> gespeichert.</p></div><div class=exampleblock><div class=title>Beispiel 1. Einfache Server Konfiguration</div><div class=content><div class="literalblock programlisting"><div class=content><pre>+logclient.example.com
*.*     /var/log/logclient.log</pre></div></div></div></div><div class=paragraph><p>Fügen Sie für jeden Client zwei Zeilen hinzu, falls Sie mehrere Clients in diese Datei aufnehmen. Weitere Informationen über die verfügbaren Verbindungswege finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>.</p></div><div class=paragraph><p>Konfigurieren Sie als nächstes <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-a logclient.example.com -v -v&#34;</pre></div></div><div class=paragraph><p>Der erste Eintrag startet <code>syslogd</code> während des Bootens. Der zweite Eintrag erlaubt es, Daten von dem spezifizierten Client auf diesem Server zu akzeptieren. Die Verwendung von <code>-v -v</code> erhöht die Anzahl von Protokollnachrichten. Dies ist hilfreich für die Feineinstellung der Verbindungswege, da Administratoren auf diese Weise erkennen, welche Arten von Nachrichten von welchen Verbindungswegen protokolliert werden.</p></div><div class=paragraph><p>Mehrere <code>-a</code>-Optionen können angegeben werden, um die Protokollierung von mehreren Clients zu erlauben. IP-Adressen und ganze Netzblöcke können ebenfalls spezifiziert werden. Eine vollständige Liste der Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>.</p></div><div class=paragraph><p>Zum Schluss muss die Protokolldatei erstellt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/logclient.log</span></code></pre></div></div><div class=paragraph><p>Zu diesem Zeitpunkt sollte <code>syslogd</code> neu gestartet und überprüft werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
<span class=c># pgrep syslog</span></code></pre></div></div><div class=paragraph><p>Wenn eine PID zurückgegeben wird, wurde der Server erfolgreich neu gestartet und die Clientkonfiguration kann beginnen. Wenn der Server nicht neu gestartet wurde, suchen Sie in <span class=filename>/var/log/messages</span> nach dem Fehler.</p></div></div><div class=sect3><h4 id=_konfiguration_des_protokollclients>11.7.3.2. Konfiguration des Protokollclients<a class=anchor href=#_konfiguration_des_protokollclients></a></h4><div class=paragraph><p>Ein Protokollclient sendet Protokollinformationen an einen Protokollserver. Zusätzlich behält er eine lokale Kopie seiner eigenen Protokolle.</p></div><div class=paragraph><p>Sobald der Server konfiguriert ist, bearbeiten Sie <span class=filename>/etc/rc.conf</span> auf dem Client:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-s -v -v&#34;</pre></div></div><div class=paragraph><p>Der erste Eintrag aktiviert den <code>syslogd</code>-Dienst während des Systemstarts. Der zweite Eintrag erhöht die Anzahl der Protokollnachrichten. Die Option <code>-s</code> verhindert, dass dieser Client Protokolle von anderen Hosts akzeptiert.</p></div><div class=paragraph><p>Als nächstes muss der Protokollserver in der <span class=filename>/etc/syslog.conf</span> des Clients eingetragen werden. In diesem Beispiel wird das <code>@</code>-Symbol benutzt, um sämtliche Protokolldaten an einen bestimmten Server zu senden:</p></div><div class="literalblock programlisting"><div class=content><pre>*.*               @logserv.example.com</pre></div></div><div class=paragraph><p>Nachdem die Änderungs gespeichert wurden, muss <code>syslogd</code> neu gestartet werden, damit die Änderungen wirksam werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>Um zu testen, ob Protokollnachrichten über das Netzwerk gesendet werden, kann <a href="https://man.freebsd.org/cgi/man.cgi?query=logger&amp;sektion=1&amp;format=html">logger(1)</a> auf dem Client benutzt werden, um eine Nachricht an syslogd zu schicken:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># logger &#34;Test message from logclient&#34;</span></code></pre></div></div><div class=paragraph><p>Diese Nachricht sollte jetzt sowohl in <span class=filename>/var/log/messages</span> auf dem Client, als auch in <span class=filename>/var/log/logclient.log</span> auf dem Server vorhanden sein.</p></div></div><div class=sect3><h4 id=_fehlerbehebung_beim_protokollserver>11.7.3.3. Fehlerbehebung beim Protokollserver<a class=anchor href=#_fehlerbehebung_beim_protokollserver></a></h4><div class=paragraph><p>Wenn der Server keine Nachrichten empfängt, ist die Ursache wahrscheinlich ein Netzwerkproblem, ein Problem bei der Namensauflösung oder ein Tippfehler in einer Konfigurationsdatei. Um die Ursache zu isolieren, müssen Sie sicherstellen, dass sich Server und Client über den in <span class=filename>/etc/rc.conf</span> konfigurierten Hostnamen mit <code>ping</code> erreichen lässt. Falls dies nicht gelingt sollten Sie die Netzwerkverkabelung überprüfen, außerdem Firewallregeln sowie die Einträge für Hosts im DNS und <span class=filename>/etc/hosts</span>. Überprüfen Sie diese Dinge auf dem Server und dem Client, bis der <code>ping</code> von beiden Hosts erfolgreich ist.</p></div><div class=paragraph><p>Wenn sich die Hosts gegenseitig mit <code>ping</code> erreichen können, der Server aber immer noch keine Nachrichten empfängt, können Sie vorübergehend die Ausführlichkeit der Protokollierung erhöhen, um die Ursache für das Problem weiter einzugrenzen. In dem folgenden Beispiel ist auf dem Server die Datei <span class=filename>/var/log/logclient.log</span> leer und in der Datei <span class=filename>/var/log/messages</span> auf dem Client ist keine Ursache für das Problem erkennbar. Um nun die Ausführlichkeit der Protokollierung zu erhöhen, passen Sie auf dem Server den Eintrag <code>syslogd_flags</code> an. Anschließend starten Sie den Dienst neu:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_flags=&#34;-d -a logclient.example.com -v -v&#34;</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>Informationen wie diese werden sofort nach dem Neustart auf der Konsole erscheinen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
Logging to FILE /var/log/messages
syslogd: kernel boot file is /boot/kernel/kernel
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
rejected <span class=k>in </span>rule 0 due to name mismatch.</code></pre></div></div><div class=paragraph><p>In diesem Beispiel werden die Nachrichten aufgrund eines fehlerhaften Namens abgewiesen. Der Hostname sollte <code>logclient</code> und nicht <code>logclien</code> sein. Beheben Sie den Tippfehler, starten Sie den Dienst neu und überprüfen Sie das Ergebnis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel
logmsg: pri 166, flags 17, from logserv.example.com,
msg Dec 10 20:55:02 &lt;syslog.err&gt; logserv.example.com syslogd: exiting on signal 2
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
accepted <span class=k>in </span>rule 0.
logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
Logging to FILE /var/log/logclient.log
Logging to FILE /var/log/messages</code></pre></div></div><div class=paragraph><p>Zu diesem Zeitpunkt werden die Nachrichten korrekt empfangen und in die richtige Datei geschrieben.</p></div></div><div class=sect3><h4 id=_sicherheitsbedenken>11.7.3.4. Sicherheitsbedenken<a class=anchor href=#_sicherheitsbedenken></a></h4><div class=paragraph><p>Wie mit jedem Netzwerkdienst, müssen Sicherheitsanforderungen in Betracht gezogen werden, bevor ein Protokollserver eingesetzt wird. Manchmal enthalten Protokolldateien sensitive Daten über aktivierte Dienste auf dem lokalen Rechner, Benutzerkonten und Konfigurationsdaten. Daten, die vom Client an den Server geschickt werden, sind weder verschlüsselt noch mit einem Passwort geschützt. Wenn ein Bedarf für Verschlüsselung besteht, ist es möglich <a class=package href=https://cgit.freebsd.org/ports/tree/security/stunnel/>security/stunnel</a> zu verwenden, welches die Protokolldateien über einen verschlüsselten Tunnel versendet.</p></div><div class=paragraph><p>Lokale Sicherheit ist ebenfalls ein Thema. Protokolldateien sind während der Verwendung oder nach ihrer Rotation nicht verschlüsselt. Lokale Benutzer versuchen vielleicht, auf diese Dateien zuzugreifen, um zusätzliche Einsichten in die Systemkonfiguration zu erlangen. Es ist absolut notwendig, die richtigen Berechtigungen auf diesen Dateien zu setzen. Das Werkzeug newsyslog unterstützt das Setzen von Berechtigungen auf gerade erstellte oder rotierte Protokolldateien. Protokolldateien mit Zugriffsmodus <code>600</code> sollten verhindern, dass lokale Benutzer darin herumschnüffeln. Zusätzliche Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-configfiles>11.8. Konfigurationsdateien<a class=anchor href=#configtuning-configfiles></a></h2><div class=sectionbody><div class=sect2><h3 id=_etc_layout>11.8.1. <span class=filename>/etc</span> Layout<a class=anchor href=#_etc_layout></a></h3><div class=paragraph><p>Konfigurationsdateien finden sich in einigen Verzeichnissen unter anderem in:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enthält generelle systemspezifische Konfigurationsinformationen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Default Versionen der Konfigurationsdateien.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enthält die <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> Konfiguration und weitere MTA Konfigurationsdateien.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Hier findet sich die Konfiguration für die User- und Kernel-ppp Programme.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Installierte Anwendungen legen hier ihre Konfigurationsdateien ab. Dieses Verzeichnis kann Unterverzeichnisse für bestimmte Anwendungen enthalten.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-Skripten installierter Anwendungen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Automatisch generierte systemspezifische Datenbanken, wie die Paket-Datenbank oder die <a href="https://man.freebsd.org/cgi/man.cgi?query=locate&amp;sektion=1&amp;format=html">locate(1)</a>-Datenbank.</p></td></tr></tbody></table></div><div class=sect2><h3 id=_hostnamen>11.8.2. Hostnamen<a class=anchor href=#_hostnamen></a></h3><div class=sect3><h4 id=_etcresolv_conf>11.8.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h4><div class=paragraph><p>Wie ein FreeBSD-System auf das Internet Domain Name System (DNS) zugreift, wird in <span class=filename>/etc/resolv.conf</span> festgelegt.</p></div><div class=paragraph><p>Die gebräuchlichsten Einträge in <span class=filename>/etc/resolv.conf</span> sind:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Die IP-Adresse eines Nameservers, den der Resolver abfragen soll. Bis zu drei Server werden in der Reihenfolge, in der sie aufgezählt sind, abgefragt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Suchliste mit Domain-Namen zum Auflösen von Hostnamen. Die Liste wird normalerweise durch den Domain-Teil des lokalen Hostnamens festgelegt.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Der lokale Domain-Name.</p></td></tr></tbody></table><div class=paragraph><p>Beispiel für eine typische <span class=filename>/etc/resolv.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nur eine der Anweisungen <code>search</code> oder <code>domain</code> sollte benutzt werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn Sie DHCP benutzen, überschreibt <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> für gewöhnlich <span class=filename>/etc/resolv.conf</span> mit den Informationen vom DHCP-Server.</p></div></div><div class=sect3><h4 id=_etchosts>11.8.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h4><div class=paragraph><p><span class=filename>/etc/hosts</span> ist eine einfache textbasierte Datenbank. Zusammen mit DNS und NIS stellt sie eine Abbildung zwischen Namen und IP-Adressen zur Verfügung. Anstatt <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> zu konfigurieren, können hier lokale Rechner, die über ein LAN verbunden sind, eingetragen werden. Lokale Einträge für gebräuchliche Internet-Adressen in <span class=filename>/etc/hosts</span> verhindern die Abfrage eines externen Servers und beschleunigen die Namensauflösung.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace &#39;my.domain&#39; below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1         localhost localhost.my.domain
127.0.0.1       localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2       myname.my.domain myname
#10.0.0.3       myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#   10.0.0.0    -   10.255.255.255
#   172.16.0.0  -   172.31.255.255
#   192.168.0.0 -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</pre></div></div><div class=paragraph><p><span class=filename>/etc/hosts</span> hat das folgende Format:</p></div><div class="literalblock programlisting"><div class=content><pre>[Internet Adresse] [Offizieller Hostname] [Alias1] [Alias2] ...</pre></div></div><div class=paragraph><p>Zum Beispiel:</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>Weitere Informationen entnehmen Sie bitte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-sysctl>11.9. Einstellungen mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><a class=anchor href=#configtuning-sysctl></a></h2><div class=sectionbody><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> können Sie Änderungen an einem laufenden FreeBSD-System vornehmen. Unter anderem können Optionen des TCP/IP-Stacks oder des virtuellen Speichermanagements verändert werden. Unter der Hand eines erfahrenen Systemadministrators kann dies die Systemperformance erheblich verbessern. Über 500 Variablen können mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> gelesen und gesetzt werden.</p></div><div class=paragraph><p>Der Hauptzweck von <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> besteht darin, Systemeinstellungen zu lesen und zu verändern.</p></div><div class=paragraph><p>Alle auslesbaren Variablen werden wie folgt angezeigt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>Um eine spezielle Variable zu lesen, geben Sie den Namen an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>Um eine Variable zu setzen, benutzen Sie die Syntax <em>Variable</em>= <em>Wert</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>Mit sysctl können Strings, Zahlen oder Boolean-Werte gesetzt werden. Bei Boolean-Werten steht <code>1</code> für wahr und <code>0</code> für falsch.</p></div><div class=paragraph><p>Um die Variablen automatisch während des Systemstarts zu setzen, fügen Sie sie in <span class=filename>/etc/sysctl.conf</span> ein. Weitere Informationen finden Sie in der Hilfeseite <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> und in <a href=#configtuning-sysctlconf><span class=filename>sysctl.conf</span></a>.</p></div><div class=sect2><h3 id=configtuning-sysctlconf>11.9.1. <span class=filename>sysctl.conf</span><a class=anchor href=#configtuning-sysctlconf></a></h3><div class=paragraph><p><span class=filename>/etc/sysctl.conf</span> sieht ähnlich wie <span class=filename>/etc/rc.conf</span> aus. Werte werden in der Form <code>Variable=Wert</code> gesetzt. Die angegebenen Werte werden gesetzt, nachdem sich das System bereits im Mehrbenutzermodus befindet. Allerdings lassen sich im Mehrbenutzermodus nicht alle Werte setzen.</p></div><div class=paragraph><p>Um das Protokollieren von fatalen Signalen abzustellen und Benutzer daran zu hindern, von anderen Benutzern gestartete Prozesse zu sehen, können Sie in <span class=filename>/etc/sysctl.conf</span> die folgenden Variablen setzen:</p></div><div class="literalblock programlisting"><div class=content><pre># Do not log fatal signal exits (e.g. sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre></div></div></div><div class=sect2><h3 id=sysctl-readonly>11.9.2. Schreibgeschützte Variablen<a class=anchor href=#sysctl-readonly></a></h3><div class=paragraph><p>Wenn schreibgeschützte <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variablen verändert werden, ist ein Neustart des Systems erforderlich.</p></div><div class=paragraph><p>Beispielsweise hat <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> auf einigen Laptops Schwierigkeiten, Speicherbereiche zu erkennen. Es treten dann Fehlermeldungen wie die folgende auf:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</code></pre></div></div><div class=paragraph><p>Um dieses Problem zu lösen, muss eine schreibgeschützte <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable verändert werden. Fügen Sie <code>hw.pci.allow_unsupported_io_range=1</code> in <span class=filename>/boot/loader.conf</span> hinzu und starten Sie das System neu. Danach sollte <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> fehlerfrei funktionieren.</p></div></div></div></div><div class=sect1><h2 id=configtuning-disk>11.10. Tuning von Laufwerken<a class=anchor href=#configtuning-disk></a></h2><div class=sectionbody><div class=paragraph><p>Der folgende Abschnitt beschreibt die verschiedenen Methoden zur Feinabstimmung der Laufwerke. Oft sind mechanische Teile in Laufwerken, wie SCSI-Laufwerke, verbaut. Diese können einen Flaschenhals bei der Gesamtleistung des Systems darstellen. Sie können zwar auch ein Laufwerk ohne mechanische Teile einbauen, wie z.B. ein Solid-State-Drive, aber Laufwerke mit mechanischen Teilen werden auch in naher Zukunft nicht vom Markt verschwinden. Bei der Feinabstimmung ist es ratsam, die Funktionen von <a href="https://man.freebsd.org/cgi/man.cgi?query=iostat&amp;sektion=8&amp;format=html">iostat(8)</a> zu verwenden, um verschiedene Änderungen zu testen und um nützliche IO-Informationen des Systems zu erhalten.</p></div><div class=sect2><h3 id=_sysctl_variablen>11.10.1. Sysctl Variablen<a class=anchor href=#_sysctl_variablen></a></h3><div class=sect3><h4 id=_vfs_vmiodirenable>11.10.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h4><div class=paragraph><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>vfs.vmiodirenable</code> besitzt in der Voreinstellung den Wert <code>1</code>. Die Variable kann auf den Wert <code>0</code> (deaktiviert) oder <code>1</code> (aktiviert) gesetzt werden. Sie steuert, wie Verzeichnisse vom System zwischengespeichert werden. Die meisten Verzeichnisse sind klein und benutzen nur ein einzelnes Fragment, typischerweise 1 kB, im Dateisystem und 512 Bytes im Buffer-Cache. Ist die Variable deaktiviert, wird der Buffer-Cache nur eine limitierte Anzahl Verzeichnisse zwischenspeichern, auch wenn das System über sehr viel Speicher verfügt. Ist die Variable aktiviert, kann der Buffer-Cache den VM-Page-Cache benutzen, um Verzeichnisse zwischenzuspeichern. Der ganze Speicher steht damit zum Zwischenspeichern von Verzeichnissen zur Verfügung. Der Nachteil bei dieser Vorgehensweise ist, dass zum Zwischenspeichern eines Verzeichnisses mindestens eine physikalische Seite im Speicher, die normalerweise 4 kB groß ist, anstelle von 512 Bytes gebraucht wird. Es wird empfohlen, diese Option aktiviert zu lassen, wenn Sie Dienste zur Verfügung stellen, die viele Dateien manipulieren. Beispiele für solche Dienste sind Web-Caches, große Mail-Systeme oder Netnews. Die aktivierte Variable vermindert, trotz des verschwendeten Speichers, in aller Regel nicht die Leistung des Systems, obwohl Sie das nachprüfen sollten.</p></div></div><div class=sect3><h4 id=_vfs_write_behind>11.10.1.2. <code>vfs.write_behind</code><a class=anchor href=#_vfs_write_behind></a></h4><div class=paragraph><p>In der Voreinstellung besitzt die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>vfs.write_behind</code> den Wert <code>1</code> (aktiviert). Mit dieser Einstellung schreibt das Dateisystem anfallende vollständige Cluster, die besonders beim sequentiellen Schreiben großer Dateien auftreten, direkt auf das Medium aus. Dies verhindert, dass sich im Buffer-Cache veränderte Puffer (dirty buffers) ansammeln, die die I/O-Verarbeitung nicht mehr beschleunigen würden. Unter bestimmten Umständen blockiert diese Funktion allerdings Prozesse. Setzen Sie in diesem Fall die Variable <code>vfs.write_behind</code> auf den Wert <code>0</code>.</p></div></div><div class=sect3><h4 id=_vfs_hirunningspace>11.10.1.3. <code>vfs.hirunningspace</code><a class=anchor href=#_vfs_hirunningspace></a></h4><div class=paragraph><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>vfs.hirunningspace</code> bestimmt systemweit die Menge ausstehender Schreiboperationen, die dem Platten-Controller zu jedem beliebigen Zeitpunkt übergeben werden können. Normalerweise können Sie den Vorgabewert verwenden. Auf Systemen mit vielen Platten kann der Wert aber auf 4 bis 5 <em>Megabyte</em> erhöht werden. Ein zu hoher Wert (größer als der Schreib-Schwellwert des Buffer-Caches) kann zu Leistungsverlusten führen. Setzen Sie den Wert daher nicht zu hoch! Hohe Werte können auch Leseoperationen verzögern, die gleichzeitig mit Schreiboperationen ausgeführt werden.</p></div><div class=paragraph><p>Es gibt weitere <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variablen, mit denen Sie den Buffer-Cache und den VM-Page-Cache beeinflussen können. Es wird nicht empfohlen, diese Variablen zu verändern, da das VM-System den virtuellen Speicher selbst sehr gut verwaltet.</p></div></div><div class=sect3><h4 id=_vm_swap_idle_enabled>11.10.1.4. <code>vm.swap_idle_enabled</code><a class=anchor href=#_vm_swap_idle_enabled></a></h4><div class=paragraph><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>vm.swap_idle_enabled</code> ist für große Mehrbenutzer-Systeme gedacht, auf denen sich viele Benutzer an- und abmelden und auf denen es viele Prozesse im Leerlauf (idle) gibt. Solche Systeme fragen kontinuierlich freien Speicher an. Wenn Sie die Variable <code>vm.swap_idle_enabled</code> aktivieren, können Sie die Auslagerungs-Hysterese von Seiten mit den Variablen <code>vm.swap_idle_threshold1</code> und <code>vm.swap_idle_threshold2</code> einstellen. Die Schwellwerte beider Variablen geben die Zeit in Sekunden an, in denen sich ein Prozess im Leerlauf befinden muss. Wenn die Werte so eingestellt sind, dass Seiten früher als nach dem normalen Algorithmus ausgelagert werden, verschafft das dem Auslagerungs-Prozess mehr Luft. Aktivieren Sie diese Funktion nur, wenn Sie sie wirklich benötigen: Die Speicherseiten werden eher früher als später ausgelagert. Der Platz im Swap-Bereich wird dadurch schneller verbraucht und die Plattenaktivitäten steigen an. Auf kleinen Systemen hat diese Funktion spürbare Auswirkungen. Auf großen Systemen, die sowieso schon Seiten auslagern müssen, können ganze Prozesse leichter in den Speicher geladen oder ausgelagert werden.</p></div></div><div class=sect3><h4 id=_hw_ata_wc>11.10.1.5. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h4><div class=paragraph><p>Obwohl das Abstellen des IDE-Schreib-Zwischenspeichers die Bandbreite zum Schreiben auf die IDE-Festplatte verringert, kann es aus Gründen der Datenkonsistenz als notwendig angesehen werden. Das Problem ist, dass IDE-Platten keine zuverlässige Aussage über das Ende eines Schreibvorgangs treffen. Wenn der Schreib-Zwischenspeicher aktiviert ist, werden die Daten nicht in der Reihenfolge ihres Eintreffens geschrieben. Es kann sogar passieren, dass das Schreiben mancher Blöcke im Fall von starker Plattenaktivität auf unbefristete Zeit verzögert wird. Ein Absturz oder Stromausfall zu dieser Zeit kann die Dateisysteme erheblich beschädigen. Sie sollten den Wert der <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>hw.ata.wc</code> auf dem System überprüfen. Wenn der Schreib-Zwischenspeicher abgestellt ist, können Sie ihn beim Systemstart aktivieren, indem Sie die Variable in <span class=filename>/boot/loader.conf</span> auf den Wert <code>1</code> setzen.</p></div><div class=paragraph><p>Weitere Informationen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a>.</p></div></div><div class=sect3><h4 id=_scsi_delay_kern_cam_scsi_delay>11.10.1.6. <code>SCSI_DELAY</code> (<code>kern.cam.scsi_delay</code>)<a class=anchor href=#_scsi_delay_kern_cam_scsi_delay></a></h4><div class=paragraph><p>Mit der Kerneloption <code>SCSI_DELAY</code> kann die Dauer des Systemstarts verringert werden. Der Vorgabewert ist recht hoch und er verzögert den Systemstart um <code>15</code> oder mehr Sekunden. Normalerweise kann dieser Wert, insbesondere mit modernen Laufwerken, mit der <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>kern.cam.scsi_delay</code> auf <code>5</code> Sekunden heruntergesetzt werden. Die Variable sowie die Kerneloption verwenden für die Zeitangabe Millisekunden und <em>nicht</em> Sekunden.</p></div></div></div><div class=sect2><h3 id=soft-updates>11.10.2. Soft Updates<a class=anchor href=#soft-updates></a></h3><div class=paragraph><p>Mit <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> lassen sich Feineinstellungen an Dateisystemen vornehmen. Das Programm hat verschiedene Optionen. Soft Updates werden wie folgt ein- und ausgeschaltet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>Ein eingehängtes Dateisystem kann nicht mit <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> modifiziert werden. Soft Updates werden am besten im Single-User Modus aktiviert, bevor Partitionen eingehangen sind.</p></div><div class=paragraph><p>Durch Einsatz eines Zwischenspeichers wird die Performance im Bereich der Metadaten, vorwiegend beim Anlegen und Löschen von Dateien, gesteigert. Es wird empfohlen, Soft Updates auf allen UFS-Dateisystemen zu aktivieren. Allerdings sollten Sie sich über die zwei Nachteile von Soft Updates bewusst sein: Erstens garantieren Soft Updates zwar die Konsistenz der Daten im Fall eines Absturzes, aber es kann passieren, dass das Dateisystem über mehrere Sekunden oder gar eine Minute nicht synchronisiert wurde. Nicht geschriebene Daten gehen dann vielleicht verloren. Zweitens verzögern Soft Updates die Freigabe von Datenblöcken. Eine größere Aktualisierung eines fast vollen Dateisystems, wie dem Root-Dateisystem, z.B. während eines <code>make installworld</code>, kann das Dateisystem vollaufen lassen. Dadurch würde die Aktualisierung fehlschlagen.</p></div><div class=sect3><h4 id=_details_über_soft_updates>11.10.2.1. Details über Soft Updates<a class=anchor href=#_details_über_soft_updates></a></h4><div class=paragraph><p>Bei einem Metadaten-Update werden die Inodes und Verzeichniseinträge aktualisiert auf die Platte zurückgeschrieben. Es gibt zwei klassische Ansätze, um die Metadaten des Dateisystems auf die Platte zu schreiben.</p></div><div class=paragraph><p>Das historisch übliche Verfahren waren synchrone Updates der Metadaten, d. h. wenn eine Änderung an einem Verzeichnis nötig war, wurde anschließend gewartet, bis diese Änderung tatsächlich auf die Platte zurückgeschrieben worden war. Der <em>Inhalt</em> der Dateien wurde im "Buffer Cache" zwischengespeichert und später asynchron auf die Platte geschrieben. Der Vorteil dieser Implementierung ist, dass sie sicher funktioniert. Wenn während eines Updates ein Ausfall erfolgt, haben die Metadaten immer einen konsistenten Zustand. Eine Datei ist entweder komplett angelegt oder gar nicht. Wenn die Datenblöcke einer Datei im Fall eines Absturzes noch nicht den Weg aus dem "Buffer Cache" auf die Platte gefunden haben, kann <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> das Dateisystem reparieren, indem es die Dateilänge einfach auf <code>0</code> setzt. Außerdem ist die Implementierung einfach und überschaubar. Der Nachteil ist, dass Änderungen der Metadaten sehr langsam vor sich gehen. Ein <code>rm -r</code> beispielsweise fasst alle Dateien eines Verzeichnisses der Reihe nach an, aber jede dieser Änderungen am Verzeichnis (Löschen einer Datei) wird einzeln synchron auf die Platte geschrieben. Gleiches beim Auspacken großer Hierarchien mit <code>tar -x</code>.</p></div><div class=paragraph><p>Der zweite Ansatz sind asynchrone Metadaten-Updates. Das ist der Standard, wenn UFS-Dateisysteme mit <code>mount -o async</code> eingehängt werden. Man schickt die Updates der Metadaten einfach auch noch über den "Buffer Cache", sie werden also zwischen die Updates der normalen Daten eingeschoben. Vorteil ist, dass man nun nicht mehr auf jeden Update warten muss, Operationen, die zahlreiche Metadaten ändern, werden also viel schneller. Auch hier ist die Implementierung sehr einfach und wenig anfällig für Fehler. Nachteil ist, dass keinerlei Konsistenz des Dateisystems mehr gesichert ist. Wenn mitten in einer Operation, die viele Metadaten ändert, ein Ausfall erfolgt (Stromausfall, drücken des Reset-Schalters), dann ist das Dateisystem anschließend in einem unbestimmten Zustand. Niemand kann genau sagen, was noch geschrieben worden ist und was nicht mehr; die Datenblöcke einer Datei können schon auf der Platte stehen, während die inode Tabelle oder das zugehörige Verzeichnis nicht mehr aktualisiert worden ist. Man kann praktisch kein <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> mehr implementieren, das diesen Zustand wieder reparieren kann, da die dazu nötigen Informationen einfach auf der Platte fehlen. Wenn ein Dateisystem irreparabel beschädigt wurde, hat man nur noch die Möglichkeit es neu zu erzeugen und die Daten vom Backup zurückspielen.</p></div><div class=paragraph><p>Der Ausweg aus diesem Dilemma ist ein <em>dirty region logging</em>, was auch als <em>Journalling</em> bezeichnet wird. Man schreibt die Metadaten-Updates zwar synchron, aber nur in einen kleinen Plattenbereich, die <em>logging area</em>. Von da aus werden sie dann asynchron auf ihre eigentlichen Bereiche verteilt. Da die <em>logging area</em> ein kleines zusammenhängendes Stückchen ist, haben die Schreibköpfe der Platte bei massiven Operationen auf Metadaten keine allzu großen Wege zurückzulegen, so dass alles ein ganzes Stück schneller geht als bei klassischen synchronen Updates. Die Komplexität der Implementierung hält sich ebenfalls in Grenzen, somit auch die Anfälligkeit für Fehler. Als Nachteil ergibt sich, dass Metadaten zweimal auf die Platte geschrieben werden müssen (einmal in die <em>logging area</em>, einmal an die richtige Stelle), so dass das im Falle regulärer Arbeit (also keine gehäuften Metadatenoperationen) eine "Pessimisierung" des Falls der synchronen Updates eintritt, es wird alles langsamer. Dafür hat man als Vorteil, dass im Falle eines Absturzes der konsistente Zustand dadurch erzielbar ist, dass die angefangenen Operationen aus dem <em>dirty region log</em> entweder zu Ende ausgeführt oder komplett verworfen werden, wodurch das Dateisystem schnell wieder zur Verfügung steht.</p></div><div class=paragraph><p>Die Lösung von Kirk McKusick, dem Schöpfer von Berkeley FFS, waren <em>Soft Updates</em>: die notwendigen Updates der Metadaten werden im Speicher gehalten und dann sortiert auf die Platte geschrieben ("ordered metadata updates"). Dadurch hat man den Effekt, dass im Falle massiver Metadaten-Änderungen spätere Operationen die vorhergehenden, noch nicht auf die Platte geschriebenen Updates desselben Elements im Speicher "einholen". Alle Operationen, auf ein Verzeichnis beispielsweise, werden also in der Regel noch im Speicher abgewickelt, bevor der Update überhaupt auf die Platte geschrieben wird (die dazugehörigen Datenblöcke werden natürlich auch so sortiert, dass sie nicht vor ihren Metadaten auf der Platte sind). Im Fall eines Absturzes hat man ein implizites "log rewind": alle Operationen, die noch nicht den Weg auf die Platte gefunden haben, sehen danach so aus, als hätten sie nie stattgefunden. Man hat so also den konsistenten Zustand von ca. 30 bis 60 Sekunden früher sichergestellt. Der verwendete Algorithmus garantiert dabei, dass alle tatsächlich benutzten Ressourcen auch in den entsprechenden Bitmaps (Block- und inode Tabellen) als belegt markiert sind. Der einzige Fehler, der auftreten kann, ist, dass Ressourcen noch als "belegt" markiert sind, die tatsächlich "frei" sind. <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> erkennt dies und korrigiert diese nicht mehr belegten Ressourcen. Die Notwendigkeit eines Dateisystem-Checks darf aus diesem Grunde auch ignoriert und das Dateisystem mittels <code>mount -f</code> zwangsweise eingebunden werden. Um noch allozierte Ressourcen freizugeben muss später ein <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> nachgeholt werden. Das ist dann auch die Idee des <em>background fsck</em>: beim Starten des Systems wird lediglich ein <em>Schnappschuss</em> des Dateisystems gemacht, mit dem <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> dann später arbeiten kann. Alle Dateisysteme dürfen "unsauber" eingebunden werden und das System kann sofort in den Multiuser-Modus gehen. Danach wird ein Hintergrund-<a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> für die Dateisysteme gestartet, die dies benötigen, um möglicherweise irrtümlich belegte Ressourcen freizugeben. Dateisysteme ohne <em>Soft Updates</em> benötigen natürlich immer noch den üblichen Vordergrund-<a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, bevor sie eingebunden werden können.</p></div><div class=paragraph><p>Der Vorteil ist, dass die Metadaten-Operationen beinahe so schnell ablaufen wie im asynchronen Fall, also auch schneller als beim <em>logging</em>, das die Metadaten immer zweimal schreiben muss. Als Nachteil stehen dem die Komplexität des Codes, ein erhöhter Speicherverbrauch und einige spezielle Eigenheiten entgegen. Nach einem Absturz ist ein etwas "älterer" Stand auf der Platte - statt einer leeren, aber bereits angelegten Datei, wie nach einem herkömmlichen <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> Lauf, ist auf einem Dateisystem mit <em>Soft Updates</em> keine Spur der entsprechenden Datei mehr zu sehen, da weder die Metadaten noch der Dateiinhalt je auf die Platte geschrieben wurden. Weiterhin kann der Platz nach einem <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a> nicht sofort wieder als verfügbar markiert werden, sondern erst dann, wenn der Update auch auf die Platte vermittelt worden ist. Dies kann besonders dann Probleme bereiten, wenn große Datenmengen in einem Dateisystem installiert werden, das nicht genügend Platz hat, um alle Dateien zweimal unterzubringen.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-kernel-limits>11.11. Einstellungen von Kernel Limits<a class=anchor href=#configtuning-kernel-limits></a></h2><div class=sectionbody><div class=sect2><h3 id=file-process-limits>11.11.1. Datei und Prozeß Limits<a class=anchor href=#file-process-limits></a></h3><div class=sect3><h4 id=kern-maxfiles>11.11.1.1. <code>kern.maxfiles</code><a class=anchor href=#kern-maxfiles></a></h4><div class=paragraph><p>Abhängig von den Anforderungen an das System kann die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>kern.maxfiles</code> erhöht oder gesenkt werden. Die Variable legt die maximale Anzahl von Dateideskriptoren auf dem System fest. Wenn die Dateideskriptoren aufgebraucht sind, werden Sie die Meldung <code>file: table is full</code> wiederholt im Puffer für Systemmeldungen sehen. Den Inhalt des Puffers können Sie sich mit <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> anzeigen lassen.</p></div><div class=paragraph><p>Jede offene Datei, jedes Socket und jede FIFO verbraucht einen Dateideskriptor. Auf "dicken" Produktionsservern können leicht Tausende Dateideskriptoren benötigt werden, abhängig von der Art und Anzahl der gleichzeitig laufenden Dienste.</p></div><div class=paragraph><p>In älteren FreeBSD-Versionen wurde die Voreinstellung von <code>kern.maxfile</code> aus der Kernelkonfigurationsoption <code>maxusers</code> bestimmt. <code>kern.maxfiles</code> wächst proportional mit dem Wert von <code>maxusers</code>. Wenn Sie einen angepassten Kernel kompilieren, empfiehlt es sich diese Option entsprechend der maximalen Benutzerzahl des Systems einzustellen. Obwohl auf einer Produktionsmaschine vielleicht nicht 256 Benutzer gleichzeitig angemeldet sind, können die benötigten Ressourcen ähnlich hoch wie bei einem großen Webserver sein.</p></div><div class=paragraph><p>Die nur lesbare <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>kern.maxusers</code> wird beim Systemstart automatisch aus dem zur Verfügung stehenden Hauptspeicher bestimmt. Im laufenden Betrieb kann dieser Wert aus <code>kern.maxusers</code> ermittelt werden. Einige Systeme benötigen für diese Variable einen anderen Wert, wobei <code>64</code>, <code>128</code> und <code>256</code> gewöhnliche Werte darstellen. Es wird nicht empfohlen, die Anzahl der Dateideskriptoren auf einen Wert größer <code>256</code> zu setzen, es sei denn, Sie benötigen wirklich eine riesige Anzahl von ihnen. Viele der von <code>kern.maxusers</code> auf einen Standardwert gesetzten Parameter können beim Systemstart oder im laufenden Betrieb in <span class=filename>/boot/loader.conf</span> angepasst werden. In <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> und <span class=filename>/boot/defaults/loader.conf</span> finden Sie weitere Details und Hinweise.</p></div><div class=paragraph><p>Ältere FreeBSD-Versionen setzen diesen Wert selbst, wenn Sie in der Konfigurationsdatei den Wert <code>0</code> angeben. Wenn Sie den Wert selbst bestimmen wollen, sollten Sie <code>maxusers</code> mindestens auf <code>4</code> setzen. Dies gilt insbesondere dann, wenn Sie beabsichtigen, Xorg zu benutzen oder Software zu kompilieren. Der wichtigste Wert, der durch <code>maxusers</code> bestimmt wird, die maximale Anzahl an Prozessen ist, die auf <code>20 + 16 * maxusers</code> gesetzt wird. Wird <code>maxusers</code> auf <code>1</code> setzen, können gleichzeitig nur <code>36</code> Prozesse laufen, von denen ungefähr <code>18</code> schon beim Booten des Systems gestartet werden. Dazu kommen nochmals etwa <code>15</code> Prozesse beim Start von Xorg. Selbst eine einfache Aufgabe wie das Lesen einer Manualpage benötigt neun Prozesse zum Filtern, Dekomprimieren und Betrachten der Datei. Für die meisten Benutzer sollte es ausreichen, <code>maxusers</code> auf <code>64</code> zu setzen, womit <code>1044</code> gleichzeitige Prozesse zur Verfügung stehen. Wenn Sie allerdings den Fehler beim Start eines Programms oder auf einem Server mit einer großen Benutzerzahl sehen, dann sollten Sie den Wert nochmals erhöhen und den Kernel neu bauen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Anzahl der Benutzer, die sich auf einem Rechner anmelden kann, wird durch <code>maxusers</code> <em>nicht</em> begrenzt. Der Wert dieser Variablen legt neben der möglichen Anzahl der Prozesse eines Benutzers weitere sinnvolle Größen für bestimmte Systemtabellen fest.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_kern_ipc_soacceptqueue>11.11.1.2. <code>kern.ipc.soacceptqueue</code><a class=anchor href=#_kern_ipc_soacceptqueue></a></h4><div class=paragraph><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>kern.ipc.soacceptqueue</code> beschränkt die Größe der Warteschlange (Listen-Queue) für neue TCP-Verbindungen. Der Vorgabewert von <code>128</code> ist normalerweise zu klein, um neue Verbindungen auf einem stark ausgelasteten Webserver zuverlässig zu handhaben. Auf solchen Servern sollte der Wert auf <code>1024</code> oder höher gesetzt werden. Dienste wie <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> oder Apache können die Größe der Queue selbst einschränken. Oft gibt es die Möglichkeit, die Größe der Listen-Queue in einer Konfigurationsdatei einzustellen. Eine große Listen-Queue übersteht vielleicht auch einen Denial of Service Angriff ().</p></div></div></div><div class=sect2><h3 id=nmbclusters>11.11.2. Netzwerk Limits<a class=anchor href=#nmbclusters></a></h3><div class=paragraph><p>Die Kerneloption <code>NMBCLUSTERS</code> schreibt die Anzahl der Netzwerkpuffer (Mbufs) fest, die das System besitzt. Eine zu geringe Anzahl Mbufs auf einem Server mit viel Netzwerkverkehr verringert die Leistung von FreeBSD. Jeder Mbuf-Cluster nimmt ungefähr 2 kB Speicher in Anspruch, so dass ein Wert von <code>1024</code> insgesamt 2 Megabyte Speicher für Netzwerkpuffer im System reserviert. Wie viele Cluster benötigt werden, lässt sich durch eine einfache Berechnung herausfinden. Ein Webserver, der maximal <code>1000</code> gleichzeitige Verbindungen servieren soll, wobei jede der Verbindungen einen 6 kB großen Sendepuffer und einen 16 kB großen Empfangspuffer benötigt, braucht ungefähr 32 MB Speicher für Netzwerkpuffer. Als Daumenregel verdoppeln Sie diese Zahl, so dass sich für <code>NMBCLUSTERS</code> der Wert 2x32 MB / 2 kB= 64 MB / 2 kB= <code>32768</code> ergibt. Für Maschinen mit viel Speicher werden Werte zwischen <code>4096</code> und <code>32768</code> empfohlen. Unter keinen Umständen sollten Sie diesen Wert willkürlich erhöhen, da dies zu einem Absturz beim Systemstart führen kann. Verwenden Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> mit <code>-m</code> um den Gebrauch der Netzwerkpuffer zu kontrollieren.</p></div><div class=paragraph><p>Die Netzwerkpuffer können beim Systemstart mit der Loader-Variablen <code>kern.ipc.nmbclusters</code> eingestellt werden. Nur auf älteren FreeBSD-Systemen müssen Sie die Kerneloption <code>NMBCLUSTERS</code> verwenden.</p></div><div class=paragraph><p>Die Anzahl der <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> Puffer muss auf ausgelasteten Servern, die den Systemaufruf <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> oft verwenden, vielleicht erhöht werden. Dazu können Sie die Kerneloption <code>NSFBUFS</code> verwenden oder die Anzahl der Puffer in <span class=filename>/boot/loader.conf</span> (siehe <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>) setzen. Die Puffer sollten erhöht werden, wenn Sie Prozesse im Zustand <code>sfbufa</code> sehen. Die schreibgeschützte <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>kern.ipc.nsfbufs</code> zeigt die Anzahl eingerichteten Puffer im Kernel. Der Wert dieser Variablen wird normalerweise von <code>kern.maxusers</code> bestimmt. Manchmal muss die Pufferanzahl jedoch manuell eingestellt werden.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Auch wenn ein Socket nicht blockierend angelegt wurde, kann der Aufruf von <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> blockieren, um auf freie <code>struct sf_buf</code> Puffer zu warten.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_net_inet_ip_portrange>11.11.2.1. <code>net.inet.ip.portrange.*</code><a class=anchor href=#_net_inet_ip_portrange></a></h4><div class=paragraph><p>Die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>net.inet.ip.portrange.*</code> legt die Portnummern für TCP- und UDP-Sockets fest. Es gibt drei Bereiche: den niedrigen Bereich, den normalen Bereich und den hohen Bereich. Die meisten Netzprogramme benutzen den normalen Bereich. Dieser Bereich umfasst in der Voreinstellung die Portnummern <code>1024</code> bis <code>5000</code> und wird durch die Variablen <code>net.inet.ip.portrange.first</code> und <code>net.inet.ip.portrange.last</code> festgelegt. Die festgelegten Bereiche für Portnummern werden von ausgehenden Verbindungen benutzt. Unter bestimmten Umständen, beispielsweise auf stark ausgelasteten Proxy-Servern, sind alle Portnummern für ausgehende Verbindungen belegt. Bereiche für Portnummern spielen auf Servern keine Rolle, die hauptsächlich eingehende Verbindungen verarbeiten (wie ein normaler Webserver) oder nur eine begrenzte Anzahl ausgehender Verbindungen öffnen (beispielsweise ein Mail-Relay). Wenn keine freien Portnummern mehr vorhanden sind, sollte die Variable <code>net.inet.ip.portrange.last</code> langsam erhöht werden. Ein Wert von <code>10000</code>, <code>20000</code> oder <code>30000</code> ist angemessen. Beachten Sie auch eine vorhandene Firewall, wenn Sie die Bereiche für Portnummern ändern. Einige Firewalls sperren große Bereiche (normalerweise aus den kleinen Portnummern) und erwarten, dass hohe Portnummern für ausgehende Verbindungen verwendet werden. Daher kann es erforderlich sein, den Wert von <code>net.inet.ip.portrange.first</code> zu erhöhen.</p></div></div><div class=sect3><h4 id=_tcp_bandwidth_delay_product_begrenzung>11.11.2.2. <code>TCP</code> Bandwidth Delay Product Begrenzung<a class=anchor href=#_tcp_bandwidth_delay_product_begrenzung></a></h4><div class=paragraph><p>Die <code>TCP</code> Bandwidth Delay Product Begrenzung wird aktiviert, indem die <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-Variable <code>net.inet.tcp.inflight.enable</code> auf den Wert <code>1</code> gesetzt wird. Das System wird dadurch angewiesen, für jede Verbindung, das Produkt aus der Übertragungsrate und der Verzögerungszeit zu bestimmen. Dieses Produkt begrenzt die Datenmenge, die für einen optimalen Durchsatz zwischengespeichert werden muss.</p></div><div class=paragraph><p>Diese Begrenzung ist nützlich, wenn Sie Daten über Verbindungen mit einem hohen Produkt aus Übertragungsrate und Verzögerungszeit wie Modems, Gigabit-Ethernet oder schnellen WANs, zur Verfügung stellen. Insbesondere wirkt sich die Begrenzung aus, wenn die Verbindung die Option Window-scaling verwendet oder große Sende-Fenster (send window) benutzt. Schalten Sie die Debug-Meldungen aus, wenn Sie die Begrenzung aktiviert haben. Dazu setzen Sie die Variable <code>net.inet.tcp.inflight.debug</code> auf <code>0</code>. Auf Produktions-Systemen sollten Sie zudem die Variable <code>net.inet.tcp.inflight.min</code> mindestens auf den Wert <code>6144</code> setzen. Allerdings kann ein zu hoher Wert, abhängig von der Verbindung, die Begrenzungsfunktion unwirksam machen. Die Begrenzung reduziert die Datenmenge in den Queues von Routern und Switches, sowie die Datenmenge in der Queue der lokalen Netzwerkkarte. Die Verzögerungszeit (Round Trip Time) für interaktive Anwendungen sinkt, da weniger Pakete zwischengespeichert werden. Dies gilt besonders für Verbindungen über langsame Modems. Die Begrenzung wirkt sich allerdings nur auf das Versenden von Daten aus (Uploads, Server). Auf den Empfang von Daten (Downloads) hat die Begrenzung keine Auswirkungen.</p></div><div class=paragraph><p>Die Variable <code>net.inet.tcp.inflight.stab</code> sollte <em>nicht</em> angepasst werden. Der Vorgabewert der Variablen beträgt <code>20</code>, das heißt es werden maximal zwei Pakete zu dem Produkt aus Übertragungsrate und Verzögerungszeit addiert. Dies stabilisiert den Algorithmus und verbessert die Reaktionszeit auf Veränderungen. Bei langsamen Verbindungen können sich aber die Laufzeiten der Pakete erhöhen (ohne diesen Algorithmus wären sie allerdings noch höher). In solchen Fällen können Sie versuchen, den Wert der Variablen auf <code>15</code>, <code>10</code> oder <code>5</code> herabzusetzen. Gleichzeitig müssen Sie vielleicht auch <code>net.inet.tcp.inflight.min</code> auf einen kleineren Wert (beispielsweise <code>3500</code>) setzen. Ändern Sie diese Variablen nur ab, wenn Sie keine anderen Möglichkeiten mehr haben.</p></div></div></div><div class=sect2><h3 id=_virtueller_speicher_virtual_memory>11.11.3. Virtueller Speicher (Virtual Memory)<a class=anchor href=#_virtueller_speicher_virtual_memory></a></h3><div class=sect3><h4 id=_kern_maxvnodes>11.11.3.1. <code>kern.maxvnodes</code><a class=anchor href=#_kern_maxvnodes></a></h4><div class=paragraph><p>Ein vnode ist die interne Darstellung einer Datei oder eines Verzeichnisses. Die Erhöhung der Anzahl der für das Betriebssystem verfügbaren vnodes verringert also die Schreib- und Lesezugriffe auf der Festplatte. vnodes werden im Normalfall vom Betriebssystem automatisch vergeben und müssen nicht manuell angepasst werden. In einigen Fällen stellt der Zugriff auf eine Platte allerdings einen Flaschenhals dar, daher sollten Sie in diesem Fall die Anzahl der möglichen vnodes erhöhen, um dieses Problem zu beheben. Beachten Sie dabei aber die Größe des inaktiven und freien Hauptspeichers.</p></div><div class=paragraph><p>Um die Anzahl der derzeit verwendeten vnodes zu sehen, geben Sie Folgendes ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.numvnodes</span>
vfs.numvnodes: 91349</code></pre></div></div><div class=paragraph><p>Die maximal mögliche Anzahl der vnodes erhalten Sie durch die Eingabe von:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxvnodes</span>
kern.maxvnodes: 100000</code></pre></div></div><div class=paragraph><p>Wenn sich die Anzahl der genutzten vnodes dem maximal möglichen Wert nähert, sollten Sie den Wert <code>kern.maxvnodes</code> zuerst um etwa <code>1000</code> erhöhen. Beobachten Sie danach die Anzahl der vom System genutzten <code>vfs.numvnodes</code>. Nähert sich der Wert wiederum dem definierten Maximum, müssen Sie <code>kern.maxvnodes</code> nochmals erhöhen. Sie sollten nun eine Änderung des Speicherverbrauches über <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> registrieren können und über mehr aktiven Speicher verfügen.</p></div></div></div></div></div><div class=sect1><h2 id=adding-swap-space>11.12. Hinzufügen von Swap-Bereichen<a class=anchor href=#adding-swap-space></a></h2><div class=sectionbody><div class=paragraph><p>Manchmal benötigt ein System mehr Swap-Bereiche. Dieser Abschnitt beschreibt zwei Methoden, um Swap-Bereiche hinzuzufügen: auf einer bestehenden Partition oder auf einem neuen Laufwerk, und das Hinzufügen einer Swap-Datei auf einer existierenden Partition.</p></div><div class=paragraph><p>Für Informationen zur Verschlüsselung von Swap-Partitionen, zu den dabei möglichen Optionen sowie zu den Gründen für eine Verschlüsselung des Auslagerungsspeichers lesen Sie <a href=../disks/#swap-encrypting>“Den Auslagerungsspeicher verschlüsseln”</a>.</p></div><div class=sect2><h3 id=new-drive-swap>11.12.1. Swap auf einer neuen Festplatte oder einer existierenden Partition<a class=anchor href=#new-drive-swap></a></h3><div class=paragraph><p>Das Hinzufügen einer neuen Festplatte für den Swap-Bereich bietet eine bessere Leistung, als die Verwendung einer Partition auf einem vorhandenem Laufwerk. Die Einrichtung von Partitionen und Laufwerken wird in <a href=../disks/#disks-adding>“Hinzufügen von Laufwerken“</a> beschrieben. <a href=../bsdinstall/#configtuning-initial>“Ein Partitionslayout entwerfen“</a> diskutiert Aspekte über die Anordnung und Größe von Swap-Bereichen.</p></div><div class=paragraph><p>Benutzen Sie <code>swapon</code> um eine Swap-Partition zum System hinzuzufügen. Zum Beispiel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon /dev/ada1s1b</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Sie können jede Partition verwenden, sofern sie nicht schon eingehangen ist. Das gilt auch dann, wenn die Partition bereits Daten enthält. Wird <code>swapon</code> auf einer Partition ausgeführt die Daten enthält, werden die vorhandenen Daten überschrieben und sind unweigerlich verloren. Stellen Sie sicher, dass die Partition, die Sie als Swap-Bereich hinzufügen möchten, wirklich die gewünschte Partition ist, bevor Sie <code>swapon</code> ausführen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um diese Swap-Partition automatisch beim Systemstart hinzuzufügen, fügen Sie einen Eintrag in <span class=filename>/etc/fstab</span> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1s1b	none	swap	sw	0	0</pre></div></div><div class=paragraph><p>Die einzelnen Einträge von <span class=filename>/etc/fstab</span> werden in <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> erläutert. Weitere Informationen zu <code>swapon</code> finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>.</p></div></div><div class=sect2><h3 id=create-swapfile>11.12.2. Swap-Dateien erstellen<a class=anchor href=#create-swapfile></a></h3><div class=paragraph><p>Anstatt eine Partition zu verwenden, erstellen diese Beispiele eine 512 MB große Swap-Datei mit dem Namen <span class=filename>/usr/swap0</span>.</p></div><div class=paragraph><p>Die Verwendung von Swap-Dateien macht es erforderlich, dass das Modul <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> entweder im Kernel vorhanden oder geladen wird, bevor Swap aktiviert ist. <a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a> enthält Informationen zum Bau eines angepassten Kernels.</p></div><div id=swapfile-10-and-later class=exampleblock><div class=title>Beispiel 2. Erstellen einer Swap-Datei</div><div class=content><div class="olist arabic procedure"><ol class=arabic><li><p>Erstellen Sie die Swap-Datei:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1024k count=512</span></code></pre></div></div></li><li><p>Setzen Sie die richtigen Berechtigungen für die neue Datei:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>Fügen Sie einen Eintrag in <span class=filename>/etc/fstab</span> hinzu:</p><div class="literalblock programlisting"><div class=content><pre>md99	none	swap	sw,file=/usr/swap0,late	0	0</pre></div></div><div class=paragraph><p>Das <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> Gerät <span class=filename>md99</span> wird verwendet, damit die niedrigeren Gerätenummer für die interaktive Benutzung frei bleiben.</p></div></li><li><p>Der Swap-Speicher wird nun automatisch beim Systemstart hinzugefügt. Benutzen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a> um den Swap-Speicher direkt zu aktivieren:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon -aL</span></code></pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=acpi-overview>11.13. Energie- und Ressourcenverwaltung<a class=anchor href=#acpi-overview></a></h2><div class=sectionbody><div class=paragraph><p>Es ist wichtig, Hardware effizient einzusetzen. Energie- und Ressourcenverwaltung ermöglicht es dem System auf verschiedene Ereignisse, beispielsweise einen unerwarteten Temperaturanstieg, reagieren zu können. Eine frühe Spezifikation für die Energieverwaltung war das Advanced Power Management (APM). APM steuert den Energieverbrauch eines Systems auf Basis der Systemaktivität. Ursprünglich konnten Stromverbrauch und Wärmeabgabe eines Systems nur schlecht von Betriebssystemen gesteuert werden. Die Hardware wurde vom BIOS gesteuert, was die Kontrolle der Energieverwaltung für den Anwender erschwerte. Das APM-BIOS wird von dem Hersteller des Systems zur Verfügung gestellt und ist auf die spezielle Hardware angepasst. Der APM-Treiber des Betriebssystems greift auf das <em>APM Software Interface</em> zu, das den Energieverbrauch regelt.</p></div><div class=paragraph><p>APM hat hauptsächlich vier Probleme. Erstens läuft die Energieverwaltung unabhängig vom Betriebssystem in einem herstellerspezifischen BIOS. Beispielsweise kann das APM-BIOS die Festplatten nach einer konfigurierbaren Zeit ohne die Zustimmung des Betriebssystems herunterfahren. Zweitens befindet sich die ganze APM-Logik im BIOS; das Betriebssystem hat gar keine APM-Komponenten. Bei Problemen mit dem APM-BIOS muss das Flash-ROM aktualisiert werden. Diese Prozedur ist gefährlich, da sie im Fehlerfall das System unbrauchbar machen kann. Zum Dritten ist APM eine Technik, die herstellerspezifisch ist und nicht koordiniert wird. Fehler im BIOS eines Herstellers werden nicht unbedingt im BIOS anderer Hersteller korrigiert. Das letzte Problem ist, dass im APM-BIOS nicht genügend Platz vorhanden ist, um eine durchdachte oder eine auf den Zweck der Maschine zugeschnittene Energieverwaltung zu implementieren.</p></div><div class=paragraph><p>Das <em>Plug and Play BIOS (PNPBIOS)</em> war in vielen Situationen ebenfalls unzureichend. Das PNPBIOS verwendet eine 16-Bit-Technik. Damit das Betriebssystem das PNPBIOS ansprechen kann, muss es in einer 16-Bit-Emulation laufen. FreeBSD stellt einen APM-Treiber zur Verfügung, welcher für Systeme benutzt werden sollte, die vor dem Jahr 2000 hergestellt wurden. Der Treiber wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a> beschrieben.</p></div><div class=paragraph><p>Der Nachfolger von APM ist das <em>Advanced Configuration and Power Interface</em> (ACPI). ACPI ist ein Standard verschiedener Hersteller, welcher die Verwaltung von Hardware und Energiesparfunktionen festlegt. Die ACPI-Funktionen, die mehr Kontrolle und Flexibilität bieten, können vom Betriebssystem gesteuert werden.</p></div><div class=paragraph><p>Dieser Abschnitt zeigt die Konfiguration von ACPI unter FreeBSD. Zudem werden einige Tipps zur Fehlersuche vorgestellt und wie Sie Problemberichte einreichen können, sodass Entwickler ACPI-Probleme erfassen und beheben können.</p></div><div class=sect2><h3 id=acpi-config>11.13.1. Konfiguration des ACPI<a class=anchor href=#acpi-config></a></h3><div class=paragraph><p>Der <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>-Treiber wird standardmäßig beim Systemstart vom <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> geladen und sollte daher <em>nicht</em> fest in den Kernel eingebunden werden. Der Treiber kann im laufenden Betrieb nicht entfernt werden, da er zur Kommunikation mit der Hardware verwendet wird. Falls jedoch Probleme auftreten, kann ACPI auch komplett deaktiviert werden. Dazu muss <code>hint.acpi.0.disabled="1"</code> in <span class=filename>/boot/loader.conf</span> gesetzt und anschließend das System neu gestartet werden. Alternativ können Sie diese Variable auch am <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>-Prompt eingeben, wie in <a href=../boot/#boot-loader>“Phase Drei”</a> beschrieben.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ACPI und APM können nicht zusammen verwendet werden. Das zuletzt geladene Modul beendet sich, sobald es bemerkt, dass das andere Modul geladen ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Mit <code>acpiconf</code> können Sie das System in einen Ruhemodus (sleep mode) versetzen. Es gibt verschiedene Modi (von <code>1</code> bis <code>5</code>), die Sie auf der Kommandozeile mit <code>-s</code> angeben können. Für die meisten Anwender sind die Modi <code>1</code> und <code>3</code> völlig ausreichend. Der Modus <code>5</code> schaltet das System aus (Soft-off) und entspricht dem Befehl <code>halt -p</code>.</p></div><div class=paragraph><p>Verschiedene Optionen können mit <code>sysctl</code> gesetzt werden. Lesen Sie dazu <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a>.</p></div></div><div class=sect2><h3 id=ACPI-comprob>11.13.2. Häufige Probleme<a class=anchor href=#ACPI-comprob></a></h3><div class=paragraph><p>ACPI gibt es in allen modernen Rechnern der ia32- (x86) und amd64- (AMD) Architektur. Der vollständige Standard bietet Funktionen zur Steuerung und Verwaltung der CPU-Leistung, der Stromversorgung, von Wärmebereichen, Batterien, eingebetteten Controllern und Bussen. Auf den meisten Systemen wird nicht der vollständige Standard implementiert. Arbeitsplatzrechner besitzen meist nur Funktionen zur Verwaltung der Busse, während Notebooks Funktionen zur Temperaturkontrolle und Ruhezustände besitzen.</p></div><div class=paragraph><p>Ein ACPI konformes System besitzt verschiedene Komponenten. Die BIOS- und Chipsatz-Hersteller stellen mehrere statische Tabellen bereit, zum Beispiel die Fixed-ACPI-Description-Table (FADT). Die Tabellen enthalten beispielsweise die mit SMP-Systemen benutzte APIC-Map, Konfigurationsregister und einfache Konfigurationen. Zusätzlich gibt es die <em>Differentiated-System-Description-Table</em> (DSDT), die Bytecode enthält. Die Tabelle ordnet Geräte und Methoden in einem baumartigen Namensraum an.</p></div><div class=paragraph><p>Ein ACPI-Treiber muss die statischen Tabellen einlesen, einen Interpreter für den Bytecode bereitstellen und die Gerätetreiber im Kernel so modifizieren, dass sie mit dem ACPI-Subsystem kommunizieren. Für FreeBSD, Linux® und NetBSD hat Intel® den Interpreter ACPI-CA, zur Verfügung gestellt. Der Quelltext zu ACPI-CA befindet sich im Verzeichnis <span class=filename>src/sys/contrib/dev/acpica</span>. Die Schnittstelle von ACPI-CA zu FreeBSD befindet sich unter <span class=filename>src/sys/dev/acpica/Osd</span>. Treiber, die verschiedene ACPI-Geräte implementieren, befinden sich im Verzeichnis <span class=filename>src/sys/dev/acpica</span>.</p></div><div class=paragraph><p>Damit ACPI richtig funktioniert, müssen alle Teile funktionieren. Im Folgenden finden Sie eine Liste mit Problemen und möglichen Abhilfen oder Korrekturen. Die Liste ist nach der Häufigkeit, mit der die Probleme auftreten, sortiert. Wenn eine Korrektur das Problem nicht behebt, finden Sie in <a href=#ACPI-submitdebug>Abrufen und Einreichen von Informationen zur Fehlersuche</a> Anweisungen, wie Sie einen Problembericht einreichen können.</p></div><div class=sect3><h4 id=_mausprobleme>11.13.2.1. Mausprobleme<a class=anchor href=#_mausprobleme></a></h4><div class=paragraph><p>Es kann vorkommen, dass die Maus nicht mehr funktioniert, wenn Sie nach einem Suspend weiterarbeiten wollen. Ist dies bei Ihnen der Fall, reicht es meistens aus, den Eintrag <code>hint.psm.0.flags="0x3000"</code> in <span class=filename>/boot/loader.conf</span> aufzunehmen.</p></div></div><div class=sect3><h4 id=_suspendresume>11.13.2.2. Suspend/Resume<a class=anchor href=#_suspendresume></a></h4><div class=paragraph><p>ACPI kennt drei Suspend-to-RAM-Zustände (STR), <code>S1</code>-<code>S3</code> sowie einen Suspend-to-Disk-Zustand (STD) <code>S4</code>. STD kann auf zwei Arten implementiert werden: <code>S4</code>BIOS und <code>S4</code>OS. Im ersten Fall wird der Suspend-to-Disk-Zustand durch das BIOS hergestellt im zweiten Fall alleine durch das Betriebssystem. Der Zustand <code>S5</code> wird "Soft off" genannt. In diesem Zustand befindet sich ein Rechner, wenn die Stromversorgung angeschlossen ist, der Rechner aber nicht hochgefahren ist.</p></div><div class=paragraph><p>Benutzen Sie <code>sysctl hw.acpi</code> um die Suspend-Zustände zu ermitteln. Diese Beispielausgabe stammt von einem Thinkpad:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</code></pre></div></div><div class=paragraph><p>Diese Ausgabe besagt, dass mit dem Befehl <code>acpiconf -s</code> die Zustände <code>S3</code>, <code>S4</code> und <code>S5</code> eingestellt werden können. Hätte <code>s4bios</code> den Wert <code>1</code>, gäbe es den Zustand <code>S4</code>BIOS anstelle von <code>S4</code>.</p></div><div class=paragraph><p>Wenn Sie die Suspend- und Resume-Funktionen testen, fangen Sie mit dem <code>S1</code>-Zustand an, wenn er angeboten wird. Dieser Zustand wird am ehesten funktionieren, da der Zustand wenig Treiber-Unterstützung benötigt. Der Zustand <code>S2</code> ist ähnlich wie <code>S1</code>, allerdings hat ihn noch niemand implementiert. Als nächstes sollten Sie den Zustand <code>S3</code> ausprobieren. Dies ist der tiefste STR-Schlafzustand. Dieser Zustand ist auf massive Treiber-Unterstützung angewiesen, um die Geräte wieder richtig zu initialisieren.</p></div><div class=paragraph><p>Ein häufiges Problem mit Suspend/Resume ist, dass viele Gerätetreiber ihre Firmware, Register und Gerätespeicher nicht korrekt speichern, wiederherstellen und/oder reinitialisieren. Um dieses Problem zu lösen, sollten Sie zuerst die folgenden Befehle ausführen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.bootverbose=1</span>
<span class=c># sysctl debug.acpi.suspend_bounce=1</span>
<span class=c># acpiconf -s 3</span></code></pre></div></div><div class=paragraph><p>Dieser Test emuliert einen Suspend/Resume-Zyklus für alle Geräte (ohne dass diese dabei wirklich in den Status <code>S3</code> wechseln). In vielen Fällen reicht dies bereits aus, um Probleme (beispielsweise verlorener Firmware-Status, Timeouts, hängende Geräte) zu entdecken. Beachten Sie dabei, dass das Gerät bei diesem Test nicht wirklich in den Status <code>S3</code> wechseln. Es kann also vorkommen, dass manche Geräte weiterhin mit Strom versorgt werden (dies wäre bei einem wirklichen Wechsel in den Status <code>S3</code> NICHT möglich. Andere Geräte werden normal weiterarbeiten, weil sie über keine Suspend/Resume-Funktionen verfügen.</p></div><div class=paragraph><p>Schwierigere Fälle können den Einsatz zusätzlicher Hardware (beispielsweise serielle Ports/Kabel für die Verbindung über eine serielle Konsole oder Firewire-Ports/Kabel für <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a>) sowie Kenntnisse im Bereich Kerneldebugging erforderlich machen.</p></div><div class=paragraph><p>Um das Problem einzugrenzen, entladen Sie soviele Treiber wie möglich. Wenn das funktioniert, laden Sie einen Treiber nach dem anderen, bis der Fehler wieder auftritt. Typischerweise verursachen binäre Treiber wie <span class=filename>nvidia.ko</span>, Grafiktreiber und USB-Treiber die meisten Fehler, hingegen laufen Ethernet-Treiber für gewöhnlich sehr zuverlässig. Wenn ein Treiber zuverlässig geladen und entfernt werden kann, können Sie den Vorgang automatisieren, indem Sie die entsprechenden Kommandos in <span class=filename>/etc/rc.suspend</span> und <span class=filename>/etc/rc.resume</span> einfügen. In den Dateien finden Sie ein deaktiviertes Beispiel, das einen Treiber lädt und wieder entfernt. Ist die Bildschirmanzeige bei der Wiederaufnahme des Betriebs gestört, setzen Sie die Variable <code>hw.acpi.reset_video</code> auf <code>1</code>. Versuchen Sie auch, die Variable <code>hw.acpi.sleep_delay</code> auf kürzere Zeitspannen zu setzen.</p></div><div class=paragraph><p>Die Suspend- und Resume-Funktionen können Sie auch auf einer neuen Linux®-Distribution mit ACPI testen. Wenn es mit Linux® funktioniert, liegt das Problem wahrscheinlich bei einem FreeBSD-Treiber. Es hilft uns, das Problem zu lösen, wenn Sie feststellen können, welcher Treiber das Problem verursacht. Beachten Sie bitte, dass die ACPI-Entwickler normalerweise keine anderen Treiber pflegen (beispielsweise Sound- oder ATA-Treiber). Es ist wohl das beste, die Ergebnisse der Fehlersuche an die Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT</a> und den Entwickler des Treibers zu schicken. Erfahrene Benutzer können versuchen, den Fehler in der Resume-Funktion zu finden, indem sie einige <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a>-Anweisungen in den Code des fehlerhaften Treibers einfügen.</p></div><div class=paragraph><p>Schließlich können Sie ACPI noch abschalten und stattdessen APM verwenden. Wenn die Suspend- und Resume-Funktionen mit APM funktionieren, sollten Sie besser APM verwenden (insbesondere mit alter Hardware von vor dem Jahr 2000). Die Hersteller benötigten einige Zeit, um ACPI korrekt zu implementieren, daher gibt es mit älterer Hardware oft ACPI-Probleme.</p></div></div><div class=sect3><h4 id=_systemhänger>11.13.2.3. Systemhänger<a class=anchor href=#_systemhänger></a></h4><div class=paragraph><p>Die meisten Systemhänger entstehen durch verlorene Interrupts oder einen Interrupt-Sturm. Probleme werden verursacht durch die Art, in der das BIOS Interrupts vor dem Systemstart konfiguriert, durch eine fehlerhafte APIC-Tabelle und durch die Zustellung des System-Control-Interrupts (SCI).</p></div><div class=paragraph><p>Anhand der Ausgabe des Befehls <code>vmstat -i</code> können Sie verlorene Interrupts von einem Interrupt-Sturm unterscheiden. Untersuchen Sie die Ausgabezeile, die <code>acpi0</code> enthält. Ein Interrupt-Sturm liegt vor, wenn der Zähler öfter als ein paar Mal pro Sekunde hochgezählt wird. Wenn sich das System aufgehangen hat, versuchen Sie mit der Tastenkombination <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Esc</kbd></span> in den Debugger DDB zu gelangen. Geben Sie dort den Befehl <code>show interrupts</code> ein.</p></div><div class=paragraph><p>Wenn Sie Interrupt-Probleme haben, ist es vorerst wohl am besten, APIC zu deaktivieren. Tragen Sie dazu die Zeile <code>hint.apic.0.disabled="1"</code> in <span class=filename>/boot/loader.conf</span> ein.</p></div></div><div class=sect3><h4 id=_abstürze_panics>11.13.2.4. Abstürze (Panics)<a class=anchor href=#_abstürze_panics></a></h4><div class=paragraph><p>Panics werden so schnell wie möglich behoben; mit ACPI kommt es aber selten dazu. Zuerst sollten Sie die Panic reproduzieren und dann versuchen einen backtrace (eine Rückverfolgung der Funktionsaufrufe) zu erstellen. Richten Sie dazu den DDB über die serielle Schnittstelle (siehe <a href=../serialcomms/#serialconsole-ddb>“DDB Debugger über die serielle Schnittstelle”</a>) oder eine gesonderte <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>-Partition ein. In DDB können Sie den backtrace mit dem Kommando <code>tr</code> erstellen. Falls Sie den backtrace vom Bildschirm abschreiben müssen, schreiben Sie bitte mindestens die fünf ersten und die fünf letzten Zeile der Ausgabe auf.</p></div><div class=paragraph><p>Versuchen Sie anschließend, das Problem durch einen Neustart ohne ACPI zu beseitigen. Wenn das funktioniert hat, können Sie versuchen, das verantwortliche ACPI-Subsystem durch Setzen der Variablen <code>debug.acpi.disable</code> herauszufinden. Die Hilfeseite <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> enthält dazu einige Beispiele.</p></div></div><div class=sect3><h4 id=_nach_einem_suspend_oder_einem_stopp_startet_das_system_wieder>11.13.2.5. Nach einem Suspend oder einem Stopp startet das System wieder<a class=anchor href=#_nach_einem_suspend_oder_einem_stopp_startet_das_system_wieder></a></h4><div class=paragraph><p>Setzen Sie zuerst <code>hw.acpi.disable_on_poweroff="0"</code> in <span class=filename>/boot/loader.conf</span>. Damit wird verhindert, dass ACPI während des Systemabschlusses die Bearbeitung verschiedener Ereignisse deaktiviert. Auf manchen Systemen muss die Variable den Wert <code>1</code> besitzen (die Voreinstellung). Normalerweise wird der unerwünschte Neustart des Systems durch Setzen dieser Variablen behoben.</p></div></div><div class=sect3><h4 id=ACPI-aslanddump>11.13.2.6. BIOS mit fehlerhaftem Bytecode<a class=anchor href=#ACPI-aslanddump></a></h4><div class=paragraph><p>Einige BIOS-Hersteller liefern einen fehlerhaften Bytecode aus. Dies erkennen Sie an Kernelmeldungen wie diesen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ACPI-1287: <span class=k>***</span> Error: Method execution failed <span class=o>[</span><span class=se>\\</span>_SB_.PCI0.LPC0.FIGD._STA] <span class=se>\\</span>
<span class=o>(</span>Node 0xc3f6d160<span class=o>)</span>, AE_NOT_FOUND</code></pre></div></div><div class=paragraph><p>Oft können Sie das Problem dadurch lösen, dass Sie eine aktuelle BIOS-Version einspielen. Die meisten Meldungen auf der Konsole sind harmlos, wenn aber beispielsweise der Batteriestatus falsch angezeigt wird, können Sie in den Meldungen nach Problemen suchen.</p></div></div></div><div class=sect2><h3 id=_die_voreingestellte_asl_überschreiben>11.13.3. Die voreingestellte ASL überschreiben<a class=anchor href=#_die_voreingestellte_asl_überschreiben></a></h3><div class=paragraph><p>Der BIOS-Bytecode, bekannt als ACPI Maschine Language (AML) wird aus der Sprache namens ACPI Source Language (ASL) übersetzt. Die AML ist in einer Tabelle, bekannt als Differentiated System Description Table (DSDT), abgelegt.</p></div><div class=paragraph><p>Es ist das Ziel von FreeBSD, dass ACPI ohne Eingriffe des Benutzers läuft. Zurzeit werden allerdings noch Abhilfen für Fehler der BIOS-Hersteller entwickelt. Der Microsoft®-Interpreter (<span class=filename>acpi.sys</span> und <span class=filename>acpiec.sys</span>) prüft die ASL nicht streng gegen den Standard. Daher reparieren BIOS-Hersteller, die ACPI nur unter Windows® testen, ihre ASL nicht. Die FreeBSD Entwickler hoffen, dass sie das vom Standard abweichende Verhalten des Microsoft®-Interpreters dokumentieren und in FreeBSD replizieren können. Dadurch müssen Benutzer ihre ASL nicht selbst reparieren.</p></div><div class=paragraph><p>Um bei der Fehlersuche zu helfen und das Problem möglicherweise zu beheben, kann eine Kopie der ASL gemacht werden. Dazu nutzen Sie <code>acpidump</code> zusammen mit <code>-t</code>, um den Inhalt der Tabelle anzuzeigen und <code>-d</code>, um die AML zu zerlegen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -td &gt; my.asl</span></code></pre></div></div><div class=paragraph><p>Einige AMLs gehen davon aus, dass der Anwender eine Windows®-Versionen benutzt. Versuchen Sie das Betriebssystem, das Sie in der ASL finden, in <span class=filename>/boot/loader.conf</span> anzugeben: <code>hw.acpi.osname=<em>"Windows 2009"</em></code>.</p></div><div class=paragraph><p>Manche Abhilfen erfordern eine Anpassung von <span class=filename>my.asl</span>. Wenn diese Datei bearbeitet wird, erstellen Sie die neue ASL mit dem folgenden Befehl. Warnung können meistens ignoriert werden, aber Fehler verhindern die ordnungsgemäße Funktion von ACPI.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl -f my.asl</span></code></pre></div></div><div class=paragraph><p>Die Option <code>-f</code> erzwingt das Erstellen der AML auch dann, wenn während der Übersetzung Fehler auftreten. Einige Fehler, wie fehlende Return-Anweisungen, werden automatisch vom FreeBSD Interpreter umgangen.</p></div><div class=paragraph><p>Die voreingestellte Ausgabedatei von <code>iasl</code> ist <span class=filename>DSDT.aml</span>. Wenn Sie diese Datei anstelle der fehlerhaften Kopie des BIOS laden wollen, editieren Sie <span class=filename>/boot/loader.conf</span> wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>acpi_dsdt_load=&#34;YES&#34;
acpi_dsdt_name=&#34;/boot/DSDT.aml&#34;</pre></div></div><div class=paragraph><p>Stellen Sie bitte sicher, dass sich <span class=filename>DSDT.aml</span> in <span class=filename>/boot</span> befindet und starten Sie das System neu. Wenn dadurch das Problem behoben wird, schicken Sie einen <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> der alten und der neuen ASL an <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI</a>, damit die Entwickler das Problem in <span class=filename>acpica</span> umgehen können.</p></div></div><div class=sect2><h3 id=ACPI-submitdebug>11.13.4. Abrufen und Einreichen von Informationen zur Fehlersuche<a class=anchor href=#ACPI-submitdebug></a></h3><div class=paragraph><p>Der ACPI-Treiber besitzt flexible Möglichkeiten zur Fehlersuche. Sie können sowohl die zu untersuchenden Subsysteme als auch die zu erzeugenden Ausgaben festlegen. Die zu untersuchenden Subsysteme werden als "layer" angegeben und in Komponenten (<code>ACPI_ALL_COMPONENTS</code>) und ACPI-Hardware (<code>ACPI_ALL_DRIVERS</code>) aufgeteilt. Welche Meldungen ausgegeben werden, wird über "level" gesteuert. Die Level reichen von von <code>ACPI_LV_ERROR</code> (es werden nur Fehler ausgegeben) bis zu <code>ACPI_LV_VERBOSE</code> (alles wird ausgegeben). Das Level ist eine Bitmaske, sodass verschiedene Stufen auf einmal (durch Leerzeichen getrennt) angegeben werden können. Die erzeugte Ausgabemenge passt vielleicht nicht in den Konsolenpuffer. In diesem Fall sollte die Ausgabe mithilfe einer seriellen Konsole gesichert werden. Die möglichen Werte für "layers" und "level" werden in <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> beschrieben.</p></div><div class=paragraph><p>Die Ausgaben zur Fehlersuche sind in der Voreinstellung nicht aktiviert. Wenn ACPI im Kernel enthalten ist, fügen Sie <code>options ACPI_DEBUG</code> zur Kernelkonfigurationsdatei hinzu. Sie können die Ausgaben zur Fehlersuche global aktivieren, indem Sie in der Datei <span class=filename>/etc/make.conf</span> die Zeile <code>ACPI_DEBUG=1</code> einfügen. Das Modul <span class=filename>acpi.ko</span> können Sie wie folgt neu übersetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/modules/acpi/acpi &amp;&amp; make clean &amp;&amp; make ACPI_DEBUG=1</span></code></pre></div></div><div class=paragraph><p>Kopieren Sie anschließend <span class=filename>acpi.ko</span> ins Verzeichnis <span class=filename>/boot/kernel</span>. In <span class=filename>/boot/loader.conf</span> stellen Sie "level" und "layer" ein. Das folgende Beispiel aktiviert die Ausgabe von Fehlern für alle ACPI-Komponenten und alle Hardwaretreiber:</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.layer=&#34;ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS&#34;
debug.acpi.level=&#34;ACPI_LV_ERROR&#34;</pre></div></div><div class=paragraph><p>Wenn ein Problem durch ein bestimmtes Ereignis, beispielsweise den Start nach einem Ruhezustand, hervorgerufen wird, können Sie die Einstellungen für "level" und "layer" auch mit dem Kommando <code>sysctl</code> vornehmen. In diesem Fall müssen Sie <span class=filename>/boot/loader.conf</span> nicht editieren. Auf der Kommandozeile geben Sie über <code>sysctl</code> dieselben Variablennamen wie in <span class=filename>/boot/loader.conf</span> an.</p></div><div class=paragraph><p>Sobald Sie die Fehlerinformationen gesammelt haben, schicken Sie diese an <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI</a>, sodass die Betreuer des FreeBSD-ACPI-Subsystems diese Informationen zur Analyse und für die Entwicklung einer Lösung verwenden können.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bevor Sie einen Fehlerbericht an diese Mailingliste einreichen, stellen Sie bitte sicher, dass das BIOS und die Firmware des Controllers aktuell sind.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn Sie einen Fehlerbericht einsenden, fügen Sie bitte die folgenden Informationen ein:</p></div><div class=ulist><ul><li><p>Beschreiben Sie den Fehler und alle Umstände, unter denen der Fehler auftritt. Geben Sie ebenfalls den Typ und das Modell Ihres Systems an. Wenn Sie einen neuen Fehler entdeckt haben, versuchen Sie möglichst genau zu beschreiben, wann der Fehler das erste Mal aufgetreten ist.</p></li><li><p>Die Ausgabe von <code>dmesg</code> nach der Eingabe von <code>boot -v</code>. Geben Sie auch alle Fehlermeldungen an, die erscheinen, wenn Sie den Fehler provozieren.</p></li><li><p>Die Ausgabe von <code>dmesg</code> nach der Eingabe von <code>boot -v</code> und mit deaktiviertem ACPI, wenn das Problem ohne ACPI nicht auftritt.</p></li><li><p>Die Ausgabe von <code>sysctl hw.acpi</code>. Dieses Kommando zeigt die vom System unterstützten ACPI-Funktionen an.</p></li><li><p>Die URL, unter der die ASL liegt. Schicken Sie bitte <em>nicht</em> die ASL an die Mailingliste, da die ASL sehr groß sein kann. Eine Kopie der ASL erstellen Sie mit dem nachstehenden Befehl:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -td &gt; name-system.asl</span></code></pre></div></div><div class=paragraph><p>Setzen Sie für <em>name</em> den Namen des Kontos und für <em>system</em> den Hersteller und das Modell des Systems ein. Zum Beispiel: <span class=filename>njl-FooCo6000.asl</span>.</p></div></li></ul></div><div class=paragraph><p>Obwohl die meisten Entwickler die Mailingliste <a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT</a> lesen, sollten Sie Fehlerberichte an die Liste <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI</a> schicken. Seien Sie bitte geduldig; wir haben alle Arbeit außerhalb des Projekts. Wenn der Fehler nicht offensichtlich ist, bitten wir Sie vielleicht, einen offiziellen Fehlerbericht (PR) einzusenden. Geben Sie im Fehlerbericht bitte dieselben Informationen wie oben an. Mithilfe der PRs verfolgen und lösen wir Probleme. Senden Sie bitte keinen PR ein, ohne vorher den Fehlerbericht an die Liste <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI</a> zu senden. Es kann sein, dass der Fehler schon von jemand anderem gemeldet wurde.</p></div></div><div class=sect2><h3 id=ACPI-References>11.13.5. Referenzen<a class=anchor href=#ACPI-References></a></h3><div class=paragraph><p>Weitere Informationen über ACPI finden Sie hier:</p></div><div class=ulist><ul><li><p>Die FreeBSD ACPI Mailingliste (<a href=https://lists.freebsd.org/pipermail/freebsd-acpi/>https://lists.freebsd.org/pipermail/freebsd-acpi/</a>)</p></li><li><p>Die <a href=https://uefi.org/specifications#ACPI>ACPI Spezifikation</a></p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_thermal&amp;sektion=4&amp;format=html">acpi_thermal(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=iasl&amp;sektion=8&amp;format=html">iasl(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidb&amp;sektion=8&amp;format=html">acpidb(8)</a></p></li></ul></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9. März 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/de/books/handbook/partiii class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/de/books/handbook/boot class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#config-synopsis>11.1. Übersicht</a></li><li><a href=#configtuning-starting-services>11.2. Start von Diensten</a></li><li><a href=#configtuning-cron>11.3. cron(8) konfigurieren</a></li><li><a href=#configtuning-rcd>11.4. Dienste unter FreeBSD verwalten</a></li><li><a href=#config-network-setup>11.5. Einrichten von Netzwerkkarten</a></li><li><a href=#configtuning-virtual-hosts>11.6. Virtual Hosts</a></li><li><a href=#configtuning-syslog>11.7. Konfiguration der Systemprotokollierung</a></li><li><a href=#configtuning-configfiles>11.8. Konfigurationsdateien</a></li><li><a href=#configtuning-sysctl>11.9. Einstellungen mit sysctl(8)</a></li><li><a href=#configtuning-disk>11.10. Tuning von Laufwerken</a></li><li><a href=#configtuning-kernel-limits>11.11. Einstellungen von Kernel Limits</a></li><li><a href=#adding-swap-space>11.12. Hinzufügen von Swap-Bereichen</a></li><li><a href=#acpi-overview>11.13. Energie- und Ressourcenverwaltung</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/handbook/handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/de/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>