<!doctype html><html class=theme-light lang=de><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/de/books/handbook/firewalls/><title>Kapitel 30. Firewalls | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Kapitel 30. Firewalls"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="de"><meta property="og:url" content="https://docs.freebsd.org/de/books/handbook/firewalls/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/de\/books\/handbook\/firewalls\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/de>Documentation portal</a></li><li><a href=https://docs.freebsd.org/de/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/de/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/de/books>Books</a></li><li><a href=https://docs.freebsd.org/de/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/de/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=de>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/preface/>Vorwort</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-audience>Über dieses Buch</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-changes-from3>Änderungen gegenüber der dritten Auflage</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-changes-from2>Änderungen gegenüber der zweiten Auflage (2004)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-changes>Änderungen gegenüber der ersten Auflage (2001)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-overview>Gliederung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-conv>Konventionen in diesem Buch</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/preface/#preface-acknowledgements>Danksagung</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/parti/>Teil I. Erste Schritte</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/introduction/>Kapitel 1. Einleitung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/introduction/#introduction-synopsis>1.1. Überblick</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/introduction/#nutshell>1.2. Willkommen zu FreeBSD!</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/introduction/#history>1.3. Über das FreeBSD Projekt</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/>Kapitel 2. FreeBSD installieren</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Minimale Hardwareanforderungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Vor der Installation</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-start>2.4. Die Installation starten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#using-bsdinstall>2.5. Verwendung von bsdinstall</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Plattenplatz bereitstellen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Abrufen der Distributionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-post>2.8. Benutzerkonten, Zeitzone, Dienste und Sicherheitsoptionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-network>2.9. Netzwerkschnittstellen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Fehlerbehebung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bsdinstall/#using-live-cd>2.11. Verwendung der Live-CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/basics/>Kapitel 3. Grundlagen des FreeBSD Betriebssystems</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-synopsis>3.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#consoles>3.2. Virtuelle Konsolen und Terminals</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#users-synopsis>3.3. Benutzer und grundlegende Account-Verwaltung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#permissions>3.4. Zugriffsrechte</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#dirstructure>3.5. Verzeichnis-Strukturen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#disk-organization>3.6. Festplatten, Slices und Partitionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#mount-unmount>3.7. Anhängen und Abhängen von Dateisystemen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-processes>3.8. Prozesse und Dämonen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#editors>3.10. Text-Editoren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-devices>3.11. Geräte und Gerätedateien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/basics/#basics-more-information>3.12. Manualpages</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/ports/>Kapitel 4. Installieren von Anwendungen: Pakete und Ports</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-synopsis>4.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-overview>4.2. Installation von Software</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-finding-applications>4.3. Suchen einer Anwendung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#pkgng-intro>4.4. Benutzen von pkg zur Verwaltung von Binärpaketen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-using>4.5. Benutzen der Ports-Sammlung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-poudriere>4.6. Pakete mit Poudriere bauen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-nextsteps>4.7. Nach der Installation</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ports/#ports-broken>4.8. Kaputte Ports</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/x11/>Kapitel 5. Das X-Window-System</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x11-synopsis>5.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-understanding>5.2. Terminologie</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-install>5.3. Xorg installieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-config>5.4. Xorg konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-fonts>5.5. Schriftarten in Xorg benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-xdm>5.6. Der X-Display-Manager</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x11-wm>5.7. Grafische Oberflächen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x-compiz-fusion>5.8. Compiz Fusion installieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/x11/#x11-troubleshooting>5.9. Fehlersuche</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partii/>Teil II. Oft benutzte Funktionen</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/desktop/>Kapitel 6. Desktop-Anwendungen</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-synopsis>6.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-browsers>6.2. Browser</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-productivity>6.3. Büroanwendungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-viewers>6.4. Anzeigen von Dokumenten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/desktop/#desktop-finance>6.5. Finanzsoftware</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/multimedia/>Kapitel 7. Multimedia</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#multimedia-synopsis>7.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#sound-setup>7.2. Soundkarten einrichten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#sound-mp3>7.3. MP3-Audio</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#video-playback>7.4. Videos wiedergeben</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#tvcard>7.5. TV-Karten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/multimedia/#scanners>7.7. Scanner</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/>Kapitel 8. Konfiguration des FreeBSD-Kernels</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Wieso einen eigenen Kernel bauen?</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Informationen über die vorhandene Hardware beschaffen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-config>8.4. Die Kernelkonfigurationsdatei</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-building>8.5. Einen angepassten Kernel bauen und installieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. Wenn etwas schiefgeht</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/printing/>Kapitel 9. Drucken</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-quick-start>9.1. Schnellstart</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-connections>9.2. Druckerverbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-pdls>9.3. Gebräuchliche Seitenbeschreibungssprachen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-direct>9.4. Direktes Drucken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-lpd>9.5. LPD (Line Printer Daemon)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/printing/#printing-other>9.6. Andere Drucksysteme</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/>Kapitel 10. Linux®-Binärkompatibilität</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Konfiguration der Linux®-Binärkompatibilität</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/linuxemu/#linuxemu-advanced>10.3. Weiterführende Themen</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partiii/>Teil III. Systemadministration</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/config/>Kapitel 11. Konfiguration und Tuning</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/config/#config-synopsis>11.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-starting-services>11.2. Start von Diensten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-cron>11.3. cron(8) konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-rcd>11.4. Dienste unter FreeBSD verwalten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#config-network-setup>11.5. Einrichten von Netzwerkkarten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-virtual-hosts>11.6. Virtual Hosts</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-syslog>11.7. Konfiguration der Systemprotokollierung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-configfiles>11.8. Konfigurationsdateien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-sysctl>11.9. Einstellungen mit sysctl(8)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-disk>11.10. Tuning von Laufwerken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#configtuning-kernel-limits>11.11. Einstellungen von Kernel Limits</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#adding-swap-space>11.12. Hinzufügen von Swap-Bereichen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/config/#acpi-overview>11.13. Energie- und Ressourcenverwaltung</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/boot/>Kapitel 12. FreeBSDs Bootvorgang</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-synopsis>12.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-introduction>12.2. FreeBSDs Bootvorgang</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-splash>12.3. Willkommensbildschirme während des Bootvorgangs konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#device-hints>12.4. Konfiguration von Geräten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/boot/#boot-shutdown>12.5. Der Shutdown-Vorgang</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/security/>Kapitel 13. Sicherheit</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-synopsis>13.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-intro>13.2. Einführung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#one-time-passwords>13.3. Einmalpasswörter</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#ipsec>13.7. VPN mit IPsec</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#fs-acl>13.9. Zugriffskontrolllisten für Dateisysteme (ACL)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-pkg>13.10. Sicherheitsprobleme in Software von Drittanbietern überwachen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-advisories>13.11. FreeBSD Sicherheitshinweise</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-accounting>13.12. Prozess-Überwachung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-resourcelimits>13.13. Einschränkung von Ressourcen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/security/#security-sudo>13.14. Gemeinsame Administration mit Sudo</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/jails/>Kapitel 14. Jails</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-synopsis>14.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-terms>14.2. Jails - Definitionen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-build>14.3. Einrichtung und Verwaltung von Jails</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-tuning>14.4. Feinabstimmung und Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-application>14.5. Mehrere Jails aktualisieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/jails/#jails-ezjail>14.6. Verwaltung von Jails mit ezjail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/mac/>Kapitel 15. Verbindliche Zugriffskontrolle</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-synopsis>15.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-inline-glossary>15.2. Schlüsselbegriffe</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-initial>15.3. Erläuterung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-understandlabel>15.4. MAC Labels verstehen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-planning>15.5. Planung eines Sicherheitsmodells</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-modules>15.6. Modulkonfiguration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-seeotheruids>15.7. Das MAC Modul seeotheruids</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-bsdextended>15.8. Das MAC Modul bsdextended</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-ifoff>15.9. Das MAC Modul ifoff</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-portacl>15.10. Das MAC Modul portacl</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-partition>15.11. Das MAC Modul partition</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-mls>15.12. Das MAC Modul Multi-Level Security</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-biba>15.13. Das MAC Modul Biba</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-lomac>15.14. Das MAC Modul LOMAC</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-implementing>15.15. Beispiel 1: Nagios in einer MAC Jail</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-userlocked>15.16. Beispiel 2: User Lock Down</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mac/#mac-troubleshoot>15.17. Fehler im MAC beheben</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/audit/>Kapitel 16. Security Event Auditing</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-synopsis>16.1. Einleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-inline-glossary>16.2. Schlüsselbegriffe</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-config>16.3. Audit Konfiguration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/audit/#audit-administration>16.4. Audit-Trails</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/disks/>Kapitel 17. Speichermedien</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-synopsis>17.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-adding>17.2. Hinzufügen von Laufwerken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-growing>17.3. Partitionen vergrößern</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#usb-disks>17.4. USB Speichermedien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#creating-cds>17.5. Erstellen und Verwenden von CDs</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#creating-dvds>17.6. DVDs benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#floppies>17.7. Disketten benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#backup-basics>17.8. Datensicherung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-virtual>17.9. Speicherbasierte Laufwerke</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#snapshots>17.10. Schnappschüsse von Dateisystemen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#quotas>17.11. Disk Quotas</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-encrypting>17.12. Partitionen verschlüsseln</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#swap-encrypting>17.13. Den Auslagerungsspeicher verschlüsseln</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/disks/#disks-hast>17.14. Highly Available Storage (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/geom/>Kapitel 18. GEOM: Modulares Framework zur Plattentransformation</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-synopsis>18.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-mirror>18.3. RAID1 - Spiegelung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-raid3>18.4. RAID3 - Byte-Level Striping mit dedizierter Parität</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-graid>18.5. Software RAID</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-ggate>18.6. GEOM Gate Netzwerk</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-glabel>18.7. Das Labeln von Laufwerken</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/geom/#geom-gjournal>18.8. UFS Journaling in GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/zfs/>Kapitel 19. Das Z-Dateisystem (ZFS)</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-differences>19.1. Was ZFS anders macht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-quickstart>19.2. Schnellstartanleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-zpool>19.3. <code>zpool</code> Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-zfs>19.4. <code>zfs</code> Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-zfs-allow>19.5. Delegierbare Administration</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-advanced>19.6. Themen für Fortgeschrittene</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-links>19.7. Zusätzliche Informationen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/zfs/#zfs-term>19.8. ZFS-Eigenschaften und Terminologie</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/filesystems/>Kapitel 20. Dateisystemunterstützung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/filesystems/#filesystems-synopsis>20.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/filesystems/#filesystems-linux>20.2. Linux® Dateisysteme</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/virtualization/>Kapitel 21. Virtualisierung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-synopsis>21.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-parallels>21.2. FreeBSD als Gast-Betriebssystem unter Parallels für Mac OS® X</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. FreeBSD als Gast-Betriebssystem unter Virtual PC für Windows®</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-vmware>21.4. FreeBSD als Gast-Betriebssystem unter VMware Fusion für Mac OS®</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-guest-virtualbox-guest-additions>21.5. FreeBSD als Gast mit VirtualBox™</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. FreeBSD als Host mit Virtualbox</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-host-bhyve>21.7. FreeBSD als Host mit bhyve</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/virtualization/#virtualization-host-xen>21.8. FreeBSD als Xen™-Host</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/l10n/>Kapitel 22. Lokalisierung – I18N/L10N einrichten und benutzen</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#l10n-synopsis>22.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#using-localization>22.2. Lokale Anpassungen benutzen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#l10n-compiling>22.3. I18N-Programme</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/l10n/#lang-setup>22.4. Lokalisierung für einzelne Sprachen</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/>Kapitel 23. FreeBSD aktualisieren</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. FreeBSD-Update</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. Aktualisieren der Dokumentationssammlung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#current-stable>23.4. Einem Entwicklungszweig folgen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#makeworld>23.5. FreeBSD aus den Quellen aktualisieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/cutting-edge/#small-lan>23.6. Installation mehrerer Maschinen</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/dtrace/>Kapitel 24. DTrace</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-synopsis>24.1. Überblick</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-implementation>24.2. Unterschiede in der Implementierung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-enable>24.3. Die DTrace Unterstützung aktivieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/dtrace/#dtrace-using>24.4. DTrace verwenden</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/>Kapitel 25. USB Gerätemodus</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. Virtuelle serielle USB-Ports</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. Netzwerkkarten im USB-Gerätemodus</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. Virtuelle USB-Speichergeräte</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partiv/>Teil IV. Netzwerke</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/>Kapitel 26. Serielle Datenübertragung</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#serial-synopsis>26.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#serial>26.2. Begriffe und Hardware</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#term>26.3. Terminals</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#dialup>26.4. Einwählverbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#dialout>26.5. Verbindungen nach Außen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/serialcomms/#serialconsole-setup>26.6. Einrichten der seriellen Konsole</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/>Kapitel 27. PPP</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#userppp>27.2. PPP konfigurieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. Probleme bei PPP-Verbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#pppoe>27.4. PPP over Ethernet (PPPoE)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/ppp-and-slip/#pppoa>27.5. PPP over ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/mail/>Kapitel 28. Elektronische Post (E-Mail)</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-de-term>28.1. Terminologie</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-synopsis>28.2. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-using>28.3. E-Mail Komponenten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#sendmail>28.4. Sendmail-Konfigurationsdateien</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-changingmta>28.5. Wechseln des Mailübertragungs-Agenten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-trouble>28.6. Fehlerbehebung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-advanced>28.7. Weiterführende Themen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#outgoing-only>28.8. Ausgehende E-Mail über einen Relay versenden</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#SMTP-dialup>28.9. E-Mail über Einwahl-Verbindungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#SMTP-Auth>28.10. SMTP-Authentifizierung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-agents>28.11. E-Mail-Programme</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-fetchmail>28.12. E-Mails mit fetchmail abholen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mail/#mail-procmail>28.13. E-Mails mit procmail filtern</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/network-servers/>Kapitel 29. Netzwerkserver</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-servers-synopsis>29.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-inetd>29.2. Der inetd"Super-Server"</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-nis>29.4. Network Information System (NIS)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-ldap>29.5. Lightweight Access Directory Protocol (LDAP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-dhcp>29.6. Dynamic Host Configuration Protocol (DHCP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-dns>29.7. Domain Name System (DNS)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-apache>29.8. Apache HTTP-Server</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-ftp>29.9. File Transfer Protocol (FTP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-samba>29.10. Datei- und Druckserver für Microsoft® Windows®-Clients (Samba)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-ntp>29.11. Die Uhrzeit mit NTP synchronisieren</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/network-servers/#network-iscsi>29.12. iSCSI Initiator und Target Konfiguration</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle checked>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/firewalls/>Kapitel 30. Firewalls</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-intro>30.1. Einführung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-concepts>30.2. Firewallkonzepte</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/>Kapitel 31. Weiterführende Netzwerkthemen</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Übersicht</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-routing>31.2. Gateways und Routen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-wireless>31.3. Drahtlose Netzwerke</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-bluetooth>31.5. Bluetooth</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-bridging>31.6. LAN-Kopplung mit einer Bridge</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-aggregation>31.7. Link-Aggregation und Failover</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-diskless>31.8. Plattenloser Betrieb mit PXE</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#carp>31.10. Common Address Redundancy Protocol (CARP)</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/partv/>Teil V. Anhang</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/mirrors/>Anhang A. Bezugsquellen für FreeBSD</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#mirrors-cdrom>A.1. CD and DVD Sets</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#mirrors-ftp>A.2. FTP-Server</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#svn>A.3. Benutzen von Subversion</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/mirrors/#mirrors-rsync>A.4. Benutzen von rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/bibliography/>Anhang B. Bibliografie</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-freebsd>B.1. Bücher speziell für FreeBSD</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-userguides>B.2. Handbücher</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-adminguides>B.3. Administrations-Anleitungen</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-programmers>B.4. Programmierhandbücher</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-osinternals>B.5. Betriebssystem-Interna</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-security>B.6. Sicherheits-Anleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-hardware>B.7. Hardware-Anleitung</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-history>B.8. UNIX® Geschichte</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/bibliography/#bibliography-journals>B.9. Zeitschriften, Magazine und Journale</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/eresources/>Anhang C. Ressourcen im Internet</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-www>C.1. Webseiten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-mail>C.2. Mailinglisten</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-news>C.3. Usenet-News</a></li><li><a href=https://docs.freebsd.org/de/books/handbook/eresources/#eresources-web>C.4. Offizielle Spiegel</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/de/books/handbook/pgpkeys/>Anhang D. OpenPGP-Schlüssel</a><ul><li><a href=https://docs.freebsd.org/de/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Ansprechpartner</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>Kapitel 30. Firewalls</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#firewalls-intro>30.1. Einführung</a></li><li><a href=#firewalls-concepts>30.2. Firewallkonzepte</a></li><li><a href=#firewalls-pf>30.3. PF</a></li><li><a href=#firewalls-ipfw>30.4. IPFW</a></li><li><a href=#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=firewalls-intro>30.1. Einführung<a class=anchor href=#firewalls-intro></a></h2><div class=sectionbody><div class=paragraph><p>Firewalls ermöglichen es, den ein- und ausgehenden Netzwerkverkehr eines Systems zu filtern. Dazu verwendet eine Firewall eine oder mehrere Gruppen von "Regeln", um ankommende Netzwerkpakete zu untersuchen und entweder durchzulassen oder zu blockieren. Die Regeln einer Firewall untersuchen charakteristische Eigenschaften von Datenpaketen, darunter den Protokolltyp, die Quell- und Zieladresse sowie den Quell- und Zielport.</p></div><div class=paragraph><p>Firewalls können die Sicherheit eines Rechners oder eines Netzwerks erhöhen, indem sie folgende Aufgaben übernehmen:</p></div><div class=ulist><ul><li><p>Den Schutz der Anwendungen, Dienste und Rechner eines internen Netzwerks vor unerwünschtem Datenverkehr aus dem Internet.</p></li><li><p>Die Beschränkung des Zugriffs von Rechnern des internen Netzwerks auf Rechner oder Dienste des öffentlichen Internets.</p></li><li><p>Den Einsatz von Network Address Translation (NAT), welches es durch die Verwendung von privaten IP-Adressen ermöglicht, eine einzige gemeinsame Internetverbindung für mehrere Rechner zu nutzen. Dies geschieht entweder über eine einzige IP-Adresse oder über eine Gruppe von jeweils automatisch zugewiesenen öffentlichen Adressen.</p></li></ul></div><div class=paragraph><p>Das Basissystem von FreeBSD enthält drei Firewalls: PF, IPFW und IPFILTER (auch als IPF bekannt). FreeBSD enthält ebenfalls zwei Traffic-Shaper zur Kontrolle der Bandbreite: <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>. ALTQ ist traditionell eng an PF gebunden, während dummynet zusammen mit IPFW verwendet wird. Gemeinsam ist allen Firewalls, dass sie Regeln einsetzen, um den Transfer von ein- und ausgehenden Datenpaketen des Systems zu steuern. Unterschiedlich ist aber die Art und Weise, wie dies realisiert wird. Auch die für diese Regeln verwendete Syntax ist unterschiedlich.</p></div><div class=paragraph><p>FreeBSD besitzt mehrere Firewalls, um den unterschiedlichen Anforderungen und Vorlieben von Benutzern gerecht zu werden. Jeder Benutzer sollte selbst beurteilen, welche Firewall seinen Bedürfnissen am besten entspricht.</p></div><div class=paragraph><p>Nachdem Sie dieses Kapitel gelesen haben, werden Sie wissen:</p></div><div class=ulist><ul><li><p>Wie man Paketfilterregeln erstellt.</p></li><li><p>Was die Unterschiede zwischen den in FreeBSD eingebauten Firewalls sind.</p></li><li><p>Wie die PF-Firewall konfiguriert und einsetzt wird.</p></li><li><p>Wie die IPFW-Firewall konfiguriert und einsetzt wird.</p></li><li><p>Wie die IPFILTER-Firewall konfiguriert und einsetzt wird.</p></li></ul></div><div class=paragraph><p>Bevor Sie dieses Kapitel lesen, sollten Sie:</p></div><div class=ulist><ul><li><p>Die grundlegenden Konzepte von FreeBSD und dem Internet verstehen.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Da alle Firewalls auf der Inspektion ausgewählter Kontrollfelder in Datenpaketen basieren, muss für die Erstellung von Firewallregeln ein grundlegendes Verständnis von TCP/IP vorhanden sein. Eine gute Einführung finden Sie in <a href=http://www.ipprimer.com>Daryl’s TCP/IP Primer</a>.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=firewalls-concepts>30.2. Firewallkonzepte<a class=anchor href=#firewalls-concepts></a></h2><div class=sectionbody><div class=paragraph><p>Ein Regelsatz besteht aus einer Gruppe von Regeln, die Pakete basierend auf ihren Inhalt entweder blockieren oder durchlassen. Der bidirektionale Austausch von Paketen zwischen zwei Rechnern wird als Sitzung (Session) bezeichnet. Der Regelsatz verarbeitet sowohl ankommende Pakete aus dem Internet, als auch die vom System erzeugten Antwortpakete. Jeder TCP/IP-Dienst hat ein festgelegtes Protokoll und einen vorgegebenen Port. Pakete für einen bestimmten Dienst stammen von einer Quelladresse und einem unprivilegierten Port und gehen an einen spezifischen Port auf der Zieladresse. Alle oben genannten Parameter können als Selektionskriterien verwendet werden, um einen Regelsatz zu erstellen, der den Zugriff auf bestimmte Dienste gewährt oder blockiert.</p></div><div class=paragraph><p>Unbekannte Portnummern können Sie in <span class=filename>/etc/services</span> nachschlagen. Alternativ finden Sie die Portnummern und deren Verwendungszweck auf <a href=http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers>http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a>.</p></div><div class=paragraph><p>Unter diesem Link finden Sie <a href=http://web.archive.org/web/20150803024617/http://www.sans.org/security-resources/idfaq/oddports.php>Portnummern, die auch von Trojanern benutzt werden</a>.</p></div><div class=paragraph><p>FTP hat zwei Modi: Aktiv und Passiv. Unterschied liegt in der Bestimmung des Datenkanals. Der Passiv-Modus ist sicherer, da der Datenkanal vom Client bestimmt wird. Eine ausführliche Erklärung von FTP und den verschiedenen Modi finden Sie unter <a href=http://www.slacksite.com/other/ftp.html>http://www.slacksite.com/other.ftp.html</a>.</p></div><div class=paragraph><p>Ein Firewall-Regelsatz kann entweder "einschließend" (inclusive firewall) oder "ausschließend" (exclusive Firewall) sein. Eine ausschließende Firewall lässt jeden Datenverkehr durch, der nicht durch eine Regel ausgeschlossen wurde. Eine einschließende Firewall macht das genaue Gegenteil. Sie lässt Datenverkehr nur dann passieren, wenn dieser einer der definierten Regeln entspricht.</p></div><div class=paragraph><p>Eine einschließende Firewall bietet eine wesentlich bessere Kontrolle des ausgehenden Verkehrs, was sie zur besseren Wahl für Systeme macht, welche Dienste für das Internet anbieten. Sie kontrolliert auch den Verkehr aus dem öffentlichen Internet zum privaten Netzwerk. Jeder Verkehr, der keiner Regel entspricht wird geblockt und protokolliert. Einschließende Firewalls sind generell sicherer als ausschließende Firewalls, da sie das Risiko, dass unerwünschter Verkehr hindurch geht, drastisch reduzieren.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn nicht anders vermerkt, verwenden alle Konfigurationen und Regelsätze in diesem Kapitel einschließende Firewalls.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die Sicherheit kann durch den Einsatz einer "zustandsorientierten Firewall" (stateful firewall) weiter erhöht werden. Dieser Typ Firewall überwacht alle offenen Verbindungen und erlaubt nur Datenverkehr von bereits bestehenden Verbindungen oder wenn eine neue Verbindung aufgebaut wird.</p></div><div class=paragraph><p>Eine zustandsorientierte Firewall behandelt den Verkehr als einen bidirektionalen Austausch von Paketen während einer Session. Wenn ein Zustand für eine passende Regel angegeben wird, erstellt die Firewall dynamisch interne Regeln für jedes Paket, das während dieser Session ausgetauscht wird. Die Firewall hat ausreichend Möglichkeiten, um zu bestimmen, ob ein Paket zu einer Session gehört. Alle Pakete, die nicht zu dieser Session passen, werden automatisch abgelehnt.</p></div><div class=paragraph><p>Sobald die Session beendet ist, wird sie aus der dynamischen Zustandstabelle entfernt.</p></div><div class=paragraph><p>Eine zustandsorientierte Filterung erlaubt es, sich auf die Sperrung bzw. Freigabe von neuen Sessions zu konzentrieren. Wenn eine neue Session genehmigt wird, werden alle nachfolgenden Pakete dieser Session automatisch erlaubt und betrügerische Pakete werden automatisch abgelehnt. Wenn eine neue Session nicht genehmigt wird, werden alle nachfolgenden Pakete dieser Session abgelehnt. Die zustandsorientierte Filterung bietet fortgeschrittene Fähigkeiten zur Abwehr von verschiedensten Angriffsmethoden, die von Angreifern eingesetzt werden.</p></div><div class=paragraph><p>NAT steht für <em>Network Address Translation</em>. Die NAT-Funktion ermöglicht es einem privaten LAN hinter einer Firewall, sich eine einzelne vom ISP zugewiesene IP-Adresse zu teilen, auch wenn die Adresse dynamisch zugewiesen wird. NAT ermöglicht den Internetzugriff für jeden Rechner im LAN, ohne dass der ISP für mehrere Internet-Konten bezahlt wird.</p></div><div class=paragraph><p>NAT übersetzt automatisch die private IP-Adresse auf die öffentliche IP-Adresse, sobald ein Paket für das öffentliche Internet die Firewall passiert. Zusätzlich führt es auch die Übersetzung der Anwortpakete durch.</p></div><div class=paragraph><p>Gemäß RFC 1918 sind die folgenden IP-Adressbereiche für private Netzwerke reserviert und werden nie ins öffentliche Internet weitergeleitet. Daher sind diese Bereiche für den Einsatz mit NAT geeignet:</p></div><div class=ulist><ul><li><p><code>10.0.0.0/8</code></p></li><li><p><code>172.16.0.0/12</code></p></li><li><p><code>192.168.0.0/16</code></p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Seien Sie <em>äußerst vorsichtig</em> wenn Sie mit Firewallregeln arbeiten. Durch eine falsche Konfiguration kann der Administrator den Zugriff auf den Server verlieren. Um auf der sicheren Seite zu sein, sollten Sie die anfängliche Konfiguration der Firewall von der lokalen Konsole durchführen, anstatt dass Sie dies aus der Ferne über ssh tun.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=firewalls-pf>30.3. PF<a class=anchor href=#firewalls-pf></a></h2><div class=sectionbody><div class=paragraph><p>In FreeBSD 5.3 wurde PF von OpenBSD in das Basissystem integriert. Bei PF handelt es sich um eine komplette, voll ausgestattete Firewall, die optional auch ALTQ (Alternatives Queuing) unterstützt. ALTQ stellt Quality of Service (QoS) zur Verfügung.</p></div><div class=paragraph><p>Das OpenBSD-Projekt pflegt die maßgebliche Referenz von PF in der <a href=http://www.openbsd.org/faq/pf>PF FAQ</a>. Peter Hansteen betreut ein sehr ausführliches PF-Tutorial unter <a href=http://home.nuug.no/~peter/pf/>http://home.nuug.no/~peter/pf/</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Bedenken Sie beim Studium der <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a>, dass die PF-Version von FreeBSD im Laufe der Jahre erheblich von der Version in OpenBSD abgewichen ist. Nicht alle Eigenschaften funktionieren unter FreeBSD genauso wie unter OpenBSD und umgekehrt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Die <a href=https://lists.FreeBSD.org/subscription/freebsd-pf>FreeBSD packet filter mailing list</a> ist ein guter Anlaufpunkt für Fragen zur Konfiguration und dem Einsatz der PF-Firewall. Überprüfen Sie aber zunächst die Archive der Mailingliste, bevor Sie eine Frage stellen. Vielleicht wurde die Frage dort schon beantwortet.</p></div><div class=paragraph><p>Dieser Abschnitt konzentriert sich auf PF in FreeBSD. Es wird beschrieben, wie PF und ALTQ aktiviert werden. Zusätzlich wird demonstriert, wie Regelsätze auf einem FreeBSD-System erstellt werden.</p></div><div class=sect2><h3 id=_pf_aktivieren>30.3.1. PF aktivieren<a class=anchor href=#_pf_aktivieren></a></h3><div class=paragraph><p>Um PF zu benutzen, muss zunächst das Kernelmodul geladen werden. Dieser Abschnitt beschreibt die Einträge für <span class=filename>/etc/rc.conf</span>, die verwendet werden können um PF zu aktivieren.</p></div><div class=paragraph><p>Beginnen Sie damit <code>pf_enable=yes</code> in <span class=filename>/etc/rc.conf</span> hinzuzufügen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pf_enable=yes</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> beschreibt zusätzliche Optionen, die beim Start an PF übergeben werden können. Fügen Sie diesen Eintrag in <span class=filename>/etc/rc.conf</span> hinzu und schreiben Sie die benötigten Optionen zwischen die Anführungszeichen:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_flags=&#34;&#34;                     # additional flags for pfctl startup</pre></div></div><div class=paragraph><p>PF kann nicht gestartet werden, wenn es seine Konfigurationsdatei nicht findet. In der Voreinstellung existiert unter FreeBSD kein Regelsatz namens <span class=filename>/etc/pf.conf</span>. Beispiel-Regelsätze finden Sie in <span class=filename>/usr/shared/examples/pf/</span>. Wenn bereits ein Regelsatz an anderer Stelle gespeichert wurde, fügen Sie in <span class=filename>/etc/rc.conf</span> einen Eintrag mit dem vollständigen Pfad zur Datei ein:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_rules=&#34;/path/to/pf.conf&#34;</pre></div></div><div class=paragraph><p>Protokollierungsfunktionen für PF werden von <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a> zur Verfügung gestellt. Fügen Sie <code>pflog_enable=yes</code> in <span class=filename>/etc/rc.conf</span> ein, um diese Funktion zu aktivieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pflog_enable=yes</span></code></pre></div></div><div class=paragraph><p>Die folgenden Zeilen können zusätzlich hinzugefügt werden, um den Speicherort der Protokolldatei zu bestimmen und weitere Optionen beim Start an <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a> zu übergeben:</p></div><div class="literalblock programlisting"><div class=content><pre>pflog_logfile=&#34;/var/log/pflog&#34;  # where pflogd should store the logfile
pflog_flags=&#34;&#34;                  # additional flags for pflogd startup</pre></div></div><div class=paragraph><p>Falls ein LAN hinter der Firewall existiert und die Pakete an die Rechner im LAN weitergeleitet werden müssen, oder wenn NAT benötigt wird, aktivieren Sie die folgende Option:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;            # Enable as LAN gateway</pre></div></div><div class=paragraph><p>Nachdem die Änderungen gespeichert wurden, kann PF mit Unterstützung für Protokollierung gestartet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service pf start</span>
<span class=c># service pflog start</span></code></pre></div></div><div class=paragraph><p>In der Voreinstellung liest PF seine Konfiguration aus <span class=filename>/etc/pf.conf</span> und modifiziert, verwirft oder akzeptiert Pakete anhand der Definitionen in dieser Datei. FreeBSD enthält mehrere Beispieldateien unter <span class=filename>/usr/shared/examples/pf/</span>. Auch die <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a> enthält sehr ausführliche Beispiele für PF-Regeln.</p></div><div class=paragraph><p>Zur Steuerung von PF wird <code>pfctl</code> verwendet. <a href=#pfctl>Nützliche <code>pfctl</code> Optionen</a> fasst einige nützliche Optionen für diesen Befehl zusammen. Eine Beschreibung aller verfügbaren Optionen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a>.</p></div><table id=pfctl class="tableblock frame-none grid-all stretch"><caption class=title>Tabelle 1. Nützliche <code>pfctl</code> Optionen</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Kommando</th><th class="tableblock halign-left valign-top">Aufgabe</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PF aktivieren</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PF deaktivieren</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -F all -f /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alle Filterregeln zurücksetzen (NAT, Filter, Zustandstabelle) und <span class=filename>/etc/pf.conf</span> erneut einlesen.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -s [ rules | nat | states ]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zusammenfassung der Filterregeln, NAT-Regeln, oder der Zustandstabelle.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -vnf /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Überprüft <span class=filename>/etc/pf.conf</span> auf Fehler, lädt aber die Filterregeln nicht neu.</p></td></tr></tbody></table><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> ist nützlich um Kommandos mit erhöhten Berechtigungen auszuführen, wie beispielsweise <code>pfctl</code>. Das Programm kann aus der Ports-Sammlung installiert werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um den ein- und ausgehenden Verkehr im Auge zu behalten, können Sie ein Werkzeug wie <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/pftop/>sysutils/pftop</a> benutzen. Sobald das Programm installiert ist, können Sie pftop ausführen, um einen Snapshot des Datenverkehrs zu sehen. Das Format der Ausgabe ist der von <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> sehr ähnlich.</p></div></div><div class=sect2><h3 id=pf-tutorial>30.3.2. PF Regelsätze<a class=anchor href=#pf-tutorial></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt die Erstellung von angepassten Regelsätzen. Es wird mit dem einfachsten Regelsatz begonnen auf dem dann weitere aufgebaut werden, um die Konzepte und Funktionen von PF an einigen konkreten Beispielen zu verdeutlichen.</p></div><div class=paragraph><p>Der einfachste Regelsatz gilt für einen Rechner, der keine Dienste anbietet und Zugriff auf das Internet haben soll. Für diesen minimalen Regelsatz wird <span class=filename>/etc/pf.conf</span> wie folgt konfiguriert:</p></div><div class="literalblock programlisting"><div class=content><pre>block in all
pass out all keep state</pre></div></div><div class=paragraph><p>Die erste Regel blockiert jeglichen eingehenden Datenverkehr. Die zweite Regel erlaubt ausgehende Verbindungen von diesem Rechner, während die Zustandsinformationen dieser Verbindungen gespeichert werden. Diese Zustandsinformationen machen es möglich, den Antwortverkehr für diese Verbindungen zu erlauben. Der Regelsatz wird mit dem folgenden Befehl geladen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -e ; pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Neben den Zustandsinformationen verfügt PF über <em>Listen</em> und <em>Makros</em>. Diese können bei der Erstellung der Regeln definiert werden. Makros können Listen enthalten und sie müssen vor ihrer ersten Benutzung definiert sein. Fügen Sie beispielsweise folgende Zeilen an den Anfang des Regelsatzes:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;</pre></div></div><div class=paragraph><p>PF versteht sowohl Portnamen als auch Portnummern, solange die Namen in <span class=filename>/etc/services</span> aufgeführt sind. Dieses Beispiel erstellt zwei Makros. Das erste ist eine Liste mit sieben TCP-Portnamen, die zweite Liste enthält einen UDP-Portnamen. Sobald ein Makro definiert ist, kann es in den Regeln verwendet werden. In diesem Beispiel wird der gesamte Datenverkehr geblockt, mit Ausnahme der Verbindungen die von diesem Rechner initiiert wurden und sich auf einen der angegebenen TCP-Dienste oder den UDP-Dienst beziehen:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Obwohl UDP als zustandsloses Protokoll betrachtet wird, ist PF in der Lage einige Zustandsinformationen zu verfolgen. Wenn beispielsweise eine UDP-Abfrage für einen Nameserver das System verlässt, wird PF nach der Antwort Ausschau halten und das Antwortpaket durch lassen.</p></div><div class=paragraph><p>Nachdem der Regelsatz verändert wurde, muss er neu geladen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Wenn keine Syntaxfehler festgestellt werden, wird <code>pfctl</code> keine Ausgabe erzeugen. Die Syntax kann auch getestet werden, bevor der Regelsatz geladen wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -nf /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Die Option <code>-n</code> bewirkt, dass die Regeln nur interpretiert, jedoch nicht geladen werden. Dies bietet die Möglichkeit, alle Fehler zu korrigieren. Es wird immer der letzte gültige Regelsatz geladen, bis PF entweder deaktiviert, oder ein neuer Regelsatz geladen wird.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Wenn Sie beim Laden oder Prüfen des Regelsatzes noch die Option <code>-v</code> hinzufügen, wird <code>pfctl</code> den komplett interpretierten Regelsatz anzeigen. Dies ist äußerst nützlich, wenn Sie versuchen Fehler im Regelsatz zu finden.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=pftut-gateway>30.3.2.1. Einfaches Gateway mit NAT<a class=anchor href=#pftut-gateway></a></h4><div class=paragraph><p>Dieser Abschnitt zeigt wie ein FreeBSD-System mit PF als Gateway konfiguriert wird. Das Gateway muss über mindestens zwei Netzwerkkarten verfügen, die jeweils mit einem separaten Netzwerk verbunden sind. In diesem Beispiel ist <span class=filename>xl0</span> mit dem Internet verbunden und <span class=filename>xl1</span> ist mit dem internen Netzwerk verbunden.</p></div><div class=paragraph><p>Aktivieren Sie zunächst das Gateway, damit der Rechner den Netzwerkverkehr von einer Schnittstelle zur nächsten weiterleiten kann. Diese sysctl-Einstellung sorgt dafür, dass IPv4-Pakete weitergeleitet werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>So leiten Sie IPv6-Datenverkehr weiter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet6.ip6.forwarding=1</span></code></pre></div></div><div class=paragraph><p>Um diese Einstellungen beim Systemstart zu aktivieren, fügen Sie sie mit Hilfe von <a href="https://man.freebsd.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;format=html">sysrc(8)</a> in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc gateway_enable=yes</span>
<span class=c># sysrc ipv6_gateway_enable=yes</span></code></pre></div></div><div class=paragraph><p>Prüfen Sie mit <code>ifconfig</code>, dass beide Schnittstellen vorhanden und aktiv sind.</p></div><div class=paragraph><p>Als nächstes erstellen Sie die nötigen PF-Regeln, damit das Gateway den Datenverkehr weiterleiten kann. Die folgende Regel erlaubt den zustandsorientierten Verkehr aus dem Internet zu den Rechnern im Netzwerk:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in on xl1 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>Diese Regel erlaubt lediglich den Datenverkehr über das Gateway auf der internen Schnittstelle. Damit die Pakete noch weiter gehen, wird eine passende Regel benötigt:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out on xl0 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>Obwohl diese beiden Regeln funktionieren, werden sie in der Praxis so spezifisch selten benötigt. Ein lesbarer Regelsatz ist oft ein sicherer Regelsatz. Der Rest dieses Abschnitts zeigt, wie Sie die Regeln so einfach und lesbar wie möglich halten. Zum Beispiel könnten die beiden Regeln zu einer Regel zusammengefasst werden:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from xl1:network to any port $ports keep state</pre></div></div><div class=paragraph><p>Die Notation <code>interface:network</code> kann durch ein Makro ersetzt werden, um den Regelsatz besser lesbar zu machen. Zum Beispiel könnte für das Netzwerk an der internen Schnittstelle (<code>xl0:network</code>) ein Makro namens <code>$localnet</code> definiert werden. Alternativ könnte für die Definition von <code>$localnet</code> auch eine <em>IP-Adresse/Netzmaske</em> Notation verwendet werden, um ein Netzwerk zu bezeichnen, beispielsweise <code>192.168.100.1/24</code> für ein privates Subnetz.</p></div><div class=paragraph><p>Bei Bedarf kann für <code>$localnet</code> auch eine Liste von Netzwerken definiert werden. Abhängig von den Bedürfnissen kann <code>$localnet</code> auch für eine typische Regel wie folgt verwendet werden:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from $localnet to any port $ports keep state</pre></div></div><div class=paragraph><p>Der folgende Regelsatz erlaubt sämtlichen Verkehr, der von den Rechnern im internen Netzwerk initiiert wird. Zunächst werden zwei Makros definiert, die die externen und internen 3COM-Schnittstellen repräsentieren.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bei Einwählverbindungen wird <span class=filename>tun0</span> für die externe Schnittstelle verwendet. Bei ADSL-Verbindungen, insbesondere denen die PPP over Ethernet (PPPoE) verwenden, ist die richtige externe Schnittstelle <span class=filename>tun0</span> und nicht die physische Ethernet-Schnittstelle.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>ext_if = &#34;xl0&#34;	# macro for external interface - use tun0 for PPPoE
int_if = &#34;xl1&#34;	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</pre></div></div><div class=paragraph><p>Dieser Regelsatz führt die NAT-Regel ein, die verwendet wird, um die Übersetzung der Netzwerkadressen von den nicht-routebaren Adressen im internen Netzwerk auf die IP-Adresse der externen Schnittstelle zu handhaben. Die Klammern im letzten Teil der NAT-Regel <code>($ext_if)</code> werden angegeben, wenn die IP-Adresse der externen Schnittstelle dynamisch zugewiesen wird. Damit wird sichergestellt, dass der Netzwerkverkehr ohne schwerwiegende Unterbrechungen weiterläuft, auch wenn sich die externe IP-Adresse ändert.</p></div><div class=paragraph><p>Beachten Sie, dass dieser Regelsatz wahrscheinlich mehr Verkehr aus dem Netzwerk zulässt, als eigentlich nötig ist. Bei einem angemessenen Aufbau könnte folgendes Makro erstellt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>client_out = &#34;{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }&#34;</pre></div></div><div class=paragraph><p>Dieses Makro wird dann in der Filterregel benutzt:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</pre></div></div><div class=paragraph><p>Weitere <code>pass</code> Regeln werden vielleicht noch benötigt. Diese Regel aktiviert SSH auf der externen Schnittstelle:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in inet proto tcp to $ext_if port ssh</pre></div></div><div class=paragraph><p>Dieses Makrodefinition und Regel erlaubt DNS und NTP für interne Clients:</p></div><div class="literalblock programlisting"><div class=content><pre>udp_services = &#34;{ domain, ntp }&#34;
pass quick inet proto { tcp, udp } to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Beachten Sie das Schlüsselwort <code>quick</code> in dieser Regel. Da der Regelsatz aus mehreren Regeln besteht, ist es wichtig, die Beziehungen zwischen den einzelnen Regeln zu verstehen. Die Regeln werden von oben nach unten ausgewertet, in der Reihenfolge wie sie geschrieben sind. Für jedes Paket oder jede Verbindung, das PF ausgewertet, wird die letzte übereinstimmende Regel im Regelsatz angewendet. Wenn jedoch ein Paket auf eine Regel passt, welche das Schlüsselwort <code>quick</code> enthält, wird das Paket entsprechend dieser Regel behandelt und die Regelverarbeitung wird gestoppt. Diese Vorgehensweise ist sehr nützlich, wenn eine Ausnahme von den allgemeinen Regeln erforderlich ist.</p></div></div><div class=sect3><h4 id=pftut-ftp>30.3.2.2. Einen FTP-Proxy einrichten<a class=anchor href=#pftut-ftp></a></h4><div class=paragraph><p>Die Konfiguration einer funktionierenden Regel für FTP kann aufgrund der Beschaffenheit des FTP-Protokolls problematisch sein. FTP ist sehr viel älter als Firewalls und schon vom Design her unsicher. Die häufigsten Argumente gegen eine Verwendung von FTP sind:</p></div><div class=ulist><ul><li><p>Passwörter werden im Klartext übertragen.</p></li><li><p>Das Protokoll erfordert die Verwendung von mindestens zwei TCP-Verbindungen (Steuerung und Daten) auf separaten Ports.</p></li><li><p>Wenn eine Sitzung aufgebaut wird, werden die Daten auf zufällig ausgewählten Ports übermittelt.</p></li></ul></div><div class=paragraph><p>All diese Punkte stellen Herausforderungen dar, noch bevor die Client- oder Server-Software auf potenzielle Sicherheitslücken überprüft wurde. Es existieren aber auch sichere Alternativen für die Dateiübertragung, wie <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> oder <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, wo die Authentifizierung und die Datenübertragung über eine verschlüsselte Verbindung erfolgt.</p></div><div class=paragraph><p>Für Situationen, in denen FTP erforderlich ist, kann PF den FTP-Datenverkehr an ein kleines Proxy-Programm namens <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a> weiterleiten. Dieses Programm ist im Basissystem von FreeBSD enthalten. Die Aufgabe des Proxies ist das dynamische Einfügen und Entfernen von Regeln im Regelsatz. Dies wird durch den Einsatz von Ankern erreicht, damit der FTP-Verkehr korrekt verarbeitet werden kann.</p></div><div class=paragraph><p>Fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> ein, um den Proxy zu aktivieren:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpproxy_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Danach kann der Proxy mit <code>service ftp-proxy start</code> gestartet werden.</p></div><div class=paragraph><p>Für die Grundkonfiguration müssen drei weitere Einträge in <span class=filename>/etc/pf.conf</span> hinzugefügt werden. Zunächst werden die Anker hinzugefügt, die der Proxy für die FTP-Sitzungen verwendet:</p></div><div class="literalblock programlisting"><div class=content><pre>nat-anchor &#34;ftp-proxy/*&#34;
rdr-anchor &#34;ftp-proxy/*&#34;</pre></div></div><div class=paragraph><p>Dann wird eine <code>pass</code>-Regel benötigt, damit der FTP-Datenverkehr durch den Proxy geleitet werden kann.</p></div><div class=paragraph><p>Die Regeln für Umleitung und NAT müssen vor den eigentlichen Filterregeln definiert werden. Fügen Sie diese <code>rdr</code>-Regel unmittelbar nach der NAT-Regel ein:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</pre></div></div><div class=paragraph><p>Zum Schluss muss der umgeleitete Verkehr die Firewall passieren dürfen:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out proto tcp from $proxy to any port ftp</pre></div></div><div class=paragraph><p><code>$poxy</code> enthält die Adresse, an dem der Proxy-Daemon gebunden ist.</p></div><div class=paragraph><p>Speichern Sie <span class=filename>/etc/pf.conf</span> und laden Sie die Regeln neu. Prüfen Sie von einem Client, ob die FTP-Verbindungen funktionieren:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Dieses Beispiel umfasst eine Grundkonfiguration, in der die Rechner im lokalen Netzwerk Zugriff auf entfernte FTP-Server benötigen. Diese Konfiguration sollte mit den meisten FTP-Clients und -Servern gut funktionieren. Das Verhalten von <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a> kann durch diverse Optionen in <code>ftpproxy_flags</code> beeinflusst werden. Einige Clients und Server haben bestimmte Marotten, die bei der Konfiguration berücksichtigt werden müssen. Es kann zum Beispiel notwendig sein, den FTP-Datenverkehr für den Proxy einer bestimmten Warteschlange zuzuweisen.</p></div><div class=paragraph><p>Es besteht auch die Möglichkeit einen FTP-Server mit PF und <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a> zu schützen. Konfigurieren Sie einen separaten <code>ftp-proxy</code> mit <code>-R</code> für den Reverse-Modus auf einem separaten Port und einer eigenen Umleitungsregel.</p></div></div><div class=sect3><h4 id=pftut-icmp>30.3.2.3. ICMP verwalten<a class=anchor href=#pftut-icmp></a></h4><div class=paragraph><p>Viele Werkzeuge zur Fehlerbehebung in TCP/IP-Netzwerken verlassen sich auf das Internet Control Message Protocol (ICMP), das speziell für diese Zwecke entwickelt wurde.</p></div><div class=paragraph><p>Das ICMP-Protokoll sendet und empfängt Kontrollnachrichten zwischen Rechnern und Gateways, hauptsächlich um ungewöhnliche Bedingungen auf dem Weg zum Zielrechner zu berichten. Router verwenden ICMP um Paketgrößen und andere Übertragungsparameter zu ermitteln. Dieser Prozess ist auch als <em>Path MTU Discovery</em> bekannt.</p></div><div class=paragraph><p>Aus der Sicht einer Firewall sind einige ICMP-Kontrollnachrichten anfällig für bekannte Angriffsmethoden. Zwar ist die Fehlerbehebung einfacher, wenn alle ICMP-Pakete bedingungslos durch gelassen werden, aber dass macht es auch für Angreifer leichter, Informationen über das Netzwerk zu extrahieren. Aus diesen Gründen ist die folgende Regel nicht optimal:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from any to any</pre></div></div><div class=paragraph><p>Eine Lösung besteht darin, nur den ICMP-Verkehr aus dem lokalen Netz zu akzeptieren, während ICMP-Pakete von außerhalb des Netzwerks verworfen werden:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</pre></div></div><div class=paragraph><p>Es stehen noch weitere Optionen zur Verfügung, die die Flexibilität von PF demonstrieren. Anstatt beispielsweise alle ICMP-Nachrichten zu erlauben, kann man die Nachrichten angeben, die von <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> verwendet werden. Beginnen Sie damit, ein Makro für diese Art von Nachrichten zu definieren:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;echoreq&#34;</pre></div></div><div class=paragraph><p>Erstellen Sie dann eine Regel, die das eben erstellte Makro benutzt:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>Wenn weitere Arten von ICMP-Nachrichten benötigt werden, kann die Liste <code>icmp_types</code> einfach erweitert werden. Geben Sie <code>more /usr/src/sbin/pfctl/pfctl_parser.c</code> ein, um eine Liste der von PF unterstützten ICMP-Nachrichten zu sehen. Die Webseite <a href=http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml>http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</a> enthält eine Erklärung für jeden Nachrichtentyp.</p></div><div class=paragraph><p>Da UNIX® <code>traceroute</code> in der Voreinstellung UDP verwendet, wird eine weitere Regel benötigt:</p></div><div class="literalblock programlisting"><div class=content><pre># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</pre></div></div><div class=paragraph><p>Da <code>TRACERT.EXE</code> unter Microsoft® Windows®-Systemen ICMP Echo Request Meldungen verwendet, ist nur die erste Regel notwendig um Traces für solche Systeme zu ermöglichen. UNIX® <code>traceroute</code> kann aber auch andere Protokolle verwenden, zum Beispiel ICMP Echo Request, wenn der Schalter <code>-I</code> benutzt wird. Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div><div class=sect4><h5 id=pftut-pathmtudisc>30.3.2.3.1. Path MTU Discovery<a class=anchor href=#pftut-pathmtudisc></a></h5><div class=paragraph><p>Internet-Protokolle sind so ausgelegt, dass sie geräteunabhängig sind. Eine Folge davon ist, dass die optimale Paketgröße nicht immer zuverlässig vorhergesagt werden kann. Das größte Hindernis ist hier die <em>Maximum Transmission Unit</em> (<code>MTU</code>), welche die Obergrenze für die Paketgröße festlegt. Die MTU für die Schnittstelle des Systems können Sie sich mit <code>ifconfig</code> anzeigen lassen.</p></div><div class=paragraph><p>TCP/IP benutzt ein Verfahren, das als path MTU discovery bekannt ist, um die korrekte Paketgröße für eine Verbindung zu bestimmen. Dieses Verfahren sendet Pakete unterschiedlicher Größe mit dem Flag "do not fragment" und erwartet ein ICMP-Antwortpaket vom Typ "type 3, code 4", wenn die Obergrenze erreicht worden ist. Typ 3 bedeutet "Ziel nicht erreichbar" und Code 4 ist die Abkürzung für "Fragmentierung nötig, aber Do-not-Fragment Flag ist gesetzt". Um path MTU discovery zu erlauben und damit Verbindungen zu anderen MTUs zu unterstützen, fügen Sie dem Makro <code>icmp_types</code> den Typ <code>destination unreachable</code> hinzu:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;{ echoreq, unreach }&#34;</pre></div></div><div class=paragraph><p>Da die <code>pass</code>-Regel bereits das Makro verwendet, braucht es nicht geändert werden um den neuen ICMP-Typ zu unterstützen:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>PF kann alle Variationen von ICMP-Typen und Codes filtern. Eine Liste der verfügbaren Typen und Codes ist in <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp&amp;sektion=4&amp;format=html">icmp(4)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp6&amp;sektion=4&amp;format=html">icmp6(4)</a> dokumentiert.</p></div></div></div><div class=sect3><h4 id=pftut-tables>30.3.2.4. Tabellen benutzen<a class=anchor href=#pftut-tables></a></h4><div class=paragraph><p>Manchmal sind bestimmte Daten für die Filterung und Weiterleitung interessant, jedoch wäre eine Definition einer solchen Filterregel für einen Regelsatz viel zu lang. PF unterstützt die Verwendung von Tabellen. Dies sind definierte Listen, die verändert werden können, ohne den gesamten Regelsatz neu laden zu müssen. Zudem können diese Listen sehr schnell durchsucht werden. Tabellennamen sind immer in <code>&lt; ></code> eingeschlossen und sehen wie folgt aus:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</pre></div></div><div class=paragraph><p>In diesem Beispiel ist das Netzwerk <code>192.168.2.0/24</code> Teil der Tabelle. <code>192.168.2.5</code> wurde im dem Operator <code>!</code> ausgeschlossen und ist somit nicht Teil der Tabelle. Es ist auch möglich Tabellen aus Dateien zu laden, wo jeder Eintrag in einer separaten Zeile steht. Dieses Beispiel verwendet dazu die Datei <span class=filename>/etc/clients</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.2.0/24
!192.168.2.5</pre></div></div><div class=paragraph><p>Um sich auf diese Datei zu beziehen, definieren Sie die Tabelle wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; persist file &#34;/etc/clients&#34;</pre></div></div><div class=paragraph><p>Sobald die Tabelle definiert ist, kann eine Filterregel Bezug darauf nehmen:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</pre></div></div><div class=paragraph><p>Die Inhalte einer Tabelle können mit <code>pfctl</code> direkt verändert werden. Dieses Beispiel fügt ein weiteres Netzwerk zur Tabelle hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T add 192.168.1.0/16</span></code></pre></div></div><div class=paragraph><p>Beachten Sie, dass auf diese Weise vorgenommene Änderungen direkt übernommen werden, jedoch bei einem Neustart des Systems oder bei einem Stromausfall verloren gehen. Um die Änderungen dauerhaft zu speichern, müssen sie in der Definition der Tabelle oder in der Datei, auf die sich die Tabelle bezieht, bearbeitet werden. Mit einem <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> Job und einem Befehl wie <code>pfctl -t clients -T show >/etc/clients</code> können Sie auch eine Kopie der Tabelle auf Platte speichern und dann in regelmäßigen Abständen aktualisieren. Alternativ kann <span class=filename>/etc/clients</span> auch mit den Tabelleneinträgen, die sich aktuell im Speicher befinden, aktualisiert werden.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T replace -f /etc/clients</span></code></pre></div></div></div><div class=sect3><h4 id=pftut-overload>30.3.2.5. Verwendung von Tabellen zum Schutz von SSH<a class=anchor href=#pftut-overload></a></h4><div class=paragraph><p>Benutzer, die SSH auf einer externen Schnittstelle ausführen, haben wahrscheinlich schon einmal ähnliche Meldungen in den Protokolldateien gesehen:</p></div><div class="literalblock programlisting"><div class=content><pre>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</pre></div></div><div class=paragraph><p>Diese Meldungen deuten auf einen Brute-Force-Angriff hin, bei dem ein Angreifer oder ein Programm versucht, den Benutzernamen und das Passwort zu erraten, um Zugriff auf das System zu bekommen.</p></div><div class=paragraph><p>Wenn der Zugriff über SSH für berechtigte Benutzer erforderlich ist, kann eine Änderung des Standard-Ports für SSH einen gewissen Schutz bieten. Allerdings bietet PF eine elegantere Lösung für dieses Problem. <code>pass</code>-Regeln können Einschränkungen für Dinge enthalten, die ein verbindender Rechner tun kann. Bei einem Verstoß gegen diese Einschränkungen kann dann dem betroffenen Rechner der Zugriff teilweise oder ganz entzogen werden. Es ist sogar möglich, alle bestehenden Verbindungen zu trennen, falls die Grenze überschritten wird.</p></div><div class=paragraph><p>Um dies zu konfigurieren, erstellen Sie folgende Tabelle im Regelsatz:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;bruteforce&gt; persist</pre></div></div><div class=paragraph><p>Fügen Sie dann ziemlich am Anfang der Filterregeln folgende Regeln hinzu, um die Brute-Force-Angriffe zu blocken und gleichzeitig berechtigte Verbindungen zu erlauben:</p></div><div class="literalblock programlisting"><div class=content><pre>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn 100, max-src-conn-rate 15/5, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class=paragraph><p>Der Teil in Klammern definiert die Grenzwerte. Die Zahlen sollten an die lokalen Anforderungen angepasst werden. Die Zeilen können wie folgt interpretiert werden:</p></div><div class=paragraph><p><code>max-src-conn</code> definiert die maximal erlaubte Anzahl gleichzeitiger Verbindungen von einem Rechner.</p></div><div class=paragraph><p><code>max-src-conn-rate</code> definiert die maximal erlaubte Anzahl neuer Verbindungen eines einzelnen Rechners (<em>15</em>) pro Anzahl von Sekunden (<em>5</em>).</p></div><div class=paragraph><p><code>overload &lt;bruteforce></code> bedeutet, dass jeder Rechner, der diesen Grenzwert überschreitet, zur Tabelle <code>bruteforce</code> hinzugefügt wird. Diese Filterregel blockiert jeglichen Datenverkehr von Adressen aus der Tabelle <code>bruteforce</code>.</p></div><div class=paragraph><p><code>flush global</code> besagt, dass alle (<code>global</code>) Verbindungen dieses Rechners getrennt (<code>flush</code>) werden, wenn der Grenzwert erreicht wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Diese Filterregeln helfen nicht bei langsamen Brute-Force-Angriffen, wie sie in <a href=http://home.nuug.no/~peter/hailmary2013/>http://home.nuug.no/~peter/hailmary2013/</a> beschrieben sind.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Dieser Beispielregelsatz dient lediglich als Illustration. Wenn Sie allgemein eine große Anzahl an Verbindungen erlauben wollen, aber gleichzeitig bei SSH etwas restriktiver vorgehen möchten, können Sie die obige Regel ergänzen:</p></div><div class="literalblock programlisting"><div class=content><pre>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Es ist möglicherweise nicht notwendig, alle aggressiven Rechner zu blockieren</div><div class=paragraph><p>Es ist zu erwähnen, dass der <code>overlaod</code>-Mechanismus eine allgemeine Technik darstellt, die nicht auf SSH beschränkt ist. Außerdem ist es nicht immer optimal, Datenverkehr von aggressiven Rechnern zu blockieren.</p></div><div class=paragraph><p>Eine <code>overload</code>-Regel kann beispielsweise benutzt werden, um einen Mail- oder Webserver zu schützen. Die <code>overload</code>-Tabelle könnte dann in einer Regel verwendet werden, um aggressive Rechner einer Warteschlange mit geringerer Bandbreite zuzuweisen, oder den Rechner auf eine bestimtme Webseite umzuleiten.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Im Laufe der Zeit werden die Tabellen durch die <code>overload</code>-Regeln immer größer und belegen immer mehr Speicher. Manchmal wird eine geblockte IP-Adresse einem Rechner dynamisch zugewiesen, der eigentlich berechtigt ist, mit den Rechnern im lokalen Netzwerk zu kommunizieren.</p></div><div class=paragraph><p>Für solche Situationen bietet <code>pfctl</code> die Möglichkeit, Tabelleneinträge auslaufen zu lassen. Dieses Kommando würde beispielsweise Einträge aus der Tabelle <code>&lt;bruteforce></code> löschen, die seit <code>86400</code> Sekunden nicht mehr referenziert wurden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t bruteforce -T expire 86400</span></code></pre></div></div><div class=paragraph><p>Eine ähnliche Funktionalität bietet <a class=package href=https://cgit.freebsd.org/ports/tree/security/expiretable/>security/expiretable</a>, welches Einträge entfernt, die für einen bestimmten Zeitraum nicht referenziert wurden.</p></div><div class=paragraph><p>Nach der Installation kann expiretable benutzt werden, um Einträge aus der Tabelle <code>&lt;bruteforce></code> nach einer bestimmten Zeit zu entfernen. Dieses Beispiel entfernt alle Einträge, die älter sind als 24 Stunden:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</pre></div></div></div><div class=sect3><h4 id=pftut-spamd>30.3.2.6. Schutz vor SPAM<a class=anchor href=#pftut-spamd></a></h4><div class=paragraph><p>Im Gegensatz zum spamd-Daemon von spamassassin, kann <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> zusammen mit PF den SPAM direkt an der Firewall abwehren. Dieser spamd wird in PF über einen Satz von Umleitungen konfiguriert.</p></div><div class=paragraph><p>Spammer neigen dazu, eine große Anzahl von Nachrichten zu versenden. Dabei nutzten Sie SPAM-freundliche Netzwerke und gekaperte Rechner, welche dann ziemlich schnell bei sogenannten Blacklists gemeldet werden.</p></div><div class=paragraph><p>Wenn eine SMTP-Verbindung von einer Adresse in der Blacklist empfangen wird, präsentiert spamd einen Banner und schaltet sofort in einen Modus, in dem die Antworten auf den SMTP-Verkehr jeweils ein Byte groß sind. Diese Technik, die möglichst viel Zeit des Spammers verschwenden soll, wird Tarpitting genannt. Die spezifische Implementierung, welche ein Byte SMTP-Antworten verwendet, wird als Stuttering bezeichnet.</p></div><div class=paragraph><p>Dieses Beispiel zeigt das grundlegende Verfahren zur Konfiguration von spamd mit automatisch aktualisierten Blacklists. Für weitere Informationen lesen die Manualpages, die zusammen mit <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> installiert werden.</p></div><div class="sidebarblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Konfiguration von spamd</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Installieren Sie das Paket oder den Port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a>. Um spamd’s Greylisting-Funktion zu nutzen, muss <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> in <span class=filename>/dev/fd</span> eingehängt werden. Fügen Sie folgende Zeile in <span class=filename>/etc/fstab</span> ein:</p><div class="literalblock programlisting"><div class=content><pre>fdescfs /dev/fd fdescfs rw 0 0</pre></div></div><div class=paragraph><p>Danach hängen Sie das Dateisystem ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount fdescfs</span></code></pre></div></div></li><li><p>Fügen Sie folgende Zeilen in den PF-Regelsatz ein:</p><div class="literalblock programlisting"><div class=content><pre>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</pre></div></div><div class=paragraph><p>Die beiden Tabellen <code>&lt;spamd></code> und <code>&lt;spam-white></code> sind von großer Bedeutung. SMTP-Verkehr von einer Adresse, die in <code>&lt;spamd></code> aber nicht in <code>&lt;spamd-white></code> ist, wird an den spamd-Daemon auf Port 8025 umgeleitet.</p></div></li><li><p>Im nächsten Schritt wird spamd in <span class=filename>/usr/local/etc/spamd.conf</span> konfiguriert und einige Parameter werden in <span class=filename>/etc/rc.conf</span> hinzugefügt.</p><div class=paragraph><p>Die Installation von <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> enthält eine Beispielkonfiguration (<span class=filename>/usr/local/etc/spamd.conf.sample</span>) und eine Manualpage für <span class=filename>spamd.conf</span>. Beziehen Sie sich für zusätzliche Konfigurationsoptionen auf diese Dokumentation.</p></div><div class=paragraph><p>Die Konfigurationsdatei enthält einen Block, in dem die <code>all</code>-Liste definiert ist, die wiederum weitere Listen spezifiziert:</p></div><div class="literalblock programlisting"><div class=content><pre>all:\
    :traplist:whitelist:</pre></div></div><div class=paragraph><p>Dieser Eintrag fügt die gewünschten Blacklists, getrennt durch einen Doppelpunkt (<code>:</code>), hinzu. Um auch eine Whitelist zu verwenden, fügen Sie den Namen unmittelbar hinter dem Namen der Blacklist ein. Zum Beispiel: <code>:Blacklist:Whitelist:</code>.</p></div><div class=paragraph><p>Danach folgt die Definition der verwendeten Blacklist:</p></div><div class="literalblock programlisting"><div class=content><pre>traplist:\
    :black:\
    :msg=&#34;SPAM. Your address %A has sent spam within the last 24 hours&#34;:\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</pre></div></div><div class=paragraph><p>In der ersten Zeile steht der Name der Blacklist und die zweite Zeile gibt den Typ an. Das Feld <code>msg</code> enthält die Nachricht, die dem Absender während des SMTP-Dialogs angezeigt wird. Das Feld <code>mehtod</code> legt fest, wie spamd-setup die Listen bezieht; unterstützte Methoden sind <code>http</code>, <code>ftp</code>, <code>file</code> und ein externes Programm via <code>exec</code>. Im letzten Feld gibt <code>file</code> den Namen der Datei an, die spamd erwartet.</p></div><div class=paragraph><p>Die Definition der Whitelist ist ähnlich. Das Feld <code>msg</code> wird jedoch nicht definiert, da eine Meldung hier nicht erforderlich ist:</p></div><div class="literalblock programlisting"><div class=content><pre>whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</pre></div></div></li></ol></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>Wählen Sie die Datenquellen mit Sorgfalt</div><div class=paragraph><p>Bei der Verwendung von sämtlichen Blacklists aus der Beispieldatei <span class=filename>spamd.conf</span> würden große Teile des Internets geblockt. Der Administrator muss diese Datei bearbeiten, um eine optimale Konfiguration zu erzielen. Dazu gehört auch die Auswahl von geeigneten Blacklists und, wenn nötig, die Erstellung von benutzerdefinierten Listen.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Als nächstes fügen Sie folgenden Eintrag in <span class=filename>/etc/rc.conf</span> hinzu. Zusätzliche Optionen sind in der Manualpage beschrieben:</p></div><div class="literalblock programlisting"><div class=content><pre>spamd_flags=&#34;-v&#34; # use &#34;&#34; and see spamd-setup(8) for flags</pre></div></div><div class=paragraph><p>Wenn Sie fertig sind, starten Sie spamd durch die Eingabe von <code>service obspamd start</code>. Führen Sie die weitere Konfiguration mit <code>spamd-setup</code> durch. Erstellen Sie zum Schluss einen <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>-Job, der <code>spamd-setup</code> in regelmäßigen Abständen aufruft, um die Listen zu aktualisieren.</p></div></div></div><div class=paragraph><p>Auf einem typischen Gateway vor dem Mailserver, werden Rechner innerhalb von wenigen Minuten geblockt.</p></div><div class=paragraph><p>PF unterstützt auch <em>Greylisting</em>, das Nachrichten von unbekannten Rechnern vorübergehend mit <em>45n</em>-Codes ablehnt. Nachrichten von diesen Rechnern werden bei einem erneuten Versuch nach einer angemessenen Zeit durchgelassen. Nachrichten von Rechnern, die nach RFC 1123 und RFC 2821 konfiguriert sind, werden sofort durchgelassen.</p></div><div class=paragraph><p>Weitere Informationen über Greylisting finden Sie unter <a href=http://www.greylisting.org/>greylisting.org</a>. Das Erstaunlichste an Greylisting ist, neben der einfachen Benutzung, dass es immer noch funktioniert. Spammer und Malware-Autoren gelingt es bislang nur schwer, diese Technik zu umgehen.</p></div><div class=paragraph><p>Die grundsätzliche Vorgehensweise zur Konfiguration von Greylisting ist wie folgt:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Konfiguration von Greylisting</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Stellen Sie sicher, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> eingehängt ist. Dies wird in Schritt 1 der vorherigen Prozedur beschrieben.</p></li><li><p>Um spamd im Greylisting-Modus auszuführen, fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> ein:</p><div class="literalblock programlisting"><div class=content><pre>spamd_grey=&#34;YES&#34;  # use spamd greylisting if YES</pre></div></div><div class=paragraph><p>Lesen Sie die Manualpage von spamd für Beschreibungen von zusätzlichen Parametern.</p></div></li><li><p>Starten Sie die Dienste, um die Konfiguration von Greylisting abzuschließen:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service obspamd restart</span>
<span class=c># service spamlogd start</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Hinter den Kulissen führen die spamdb-Datenbank und spamlogd wesentliche Aufgaben der Greylisting-Funktion aus. spamdb ist die Schnittstelle für den Administrator, der über den Inhalt der Datenbank <span class=filename>/var/db/spamdb</span> Blaklists, Whitelists und Greylists verwaltet.</p></div></div><div class=sect3><h4 id=pftut-hygiene>30.3.2.7. Netzwerk-Hygiene<a class=anchor href=#pftut-hygiene></a></h4><div class=paragraph><p>Dieser Abschnitt beschreibt die Verwendung von <code>block-policy</code>, <code>scrub</code> und <code>antispoof</code>, mit denen das Verhalten des Regelsatzes weiter optimiert werden kann.</p></div><div class=paragraph><p>Die Option <code>block-policy</code> kann im Teil <code>options</code> des Regelwerks konfiguriert werden, vor den Umleitungen und den eigentlichen Filterregeln. Diese Option legt fest, welche Rückmeldung PF an einen geblockten Rechner sendet. Es existieren zwei mögliche Werte: <code>drop</code> verwirft das Paket ohne Rückmeldung und <code>return</code> gibt eine Statusmeldung, wie etwa <code>Connection refused</code> zurück.</p></div><div class=paragraph><p>Die Voreinstellung ist <code>drop</code>. Geben Sie den gewünschten Wert ein, um die <code>block-policy</code>-Richtlinie zu ändern:</p></div><div class="literalblock programlisting"><div class=content><pre>set block-policy return</pre></div></div><div class=paragraph><p><code>scrub</code> ist ein Schlüsselwort in PF, das die Paket-Normalisierung aktiviert. Dieser Prozess fügt fragmentierte Pakete wieder zusammen und blockt TCP-Pakete mit ungültigen Flag-Kombinationen. Ein aktiviertes <code>scrub</code> bietet einen gewissen Schutz gegen Angriffe, die auf die falsche Handhabung von fragmentierten Paketen aufbauen. Es stehen viele Optionen zur Verfügung, jedoch sollte die einfachste Form für die meisten Konfigurationen ausreichend sein:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all</pre></div></div><div class=paragraph><p>Einige Dienste, wie beispielsweise NFS, erfordern eine bestimmte Handhabung von fragmentierten Paketen. Weitere Informationen finden Sie unter <a href=https://home.nuug.no/~peter/pf/en/scrub.html>https://home.nuug.no/~peter/pf/en/scrub.html</a>.</p></div><div class=paragraph><p>Dieses Beispiel fügt fragmentierte Pakete wieder zusammen, löscht das "do not fragment"-Bit und setzt die maximale Segmentgröße auf 1440 Bytes:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all fragment reassemble no-df max-mss 1440</pre></div></div><div class=paragraph><p>Der <code>antispoof</code>-Mechanismus bietet einen Schutz gegen gefälschte IP-Adressen. Dabei werden hauptsächlich Pakete verworfen, die auf der falschen Schnittstellen ankommen.</p></div><div class=paragraph><p>Folgende Regeln verwerfen gefälschte Adressen, wenn sie aus dem Internet oder dem lokalen Netzwerk stammen:</p></div><div class="literalblock programlisting"><div class=content><pre>antispoof for $ext_if
antispoof for $int_if</pre></div></div></div><div class=sect3><h4 id=pftut-unrouteables>30.3.2.8. Handhabung von nicht-routebaren Adressen<a class=anchor href=#pftut-unrouteables></a></h4><div class=paragraph><p>Sogar bei einem richtig konfigurierten NAT-Gateway müssen Sie vielleicht die Fehlkonfiguration anderer Personen ausgleichen. Ein typischer Fehler besteht darin, nicht-routebare Adressen ins Internet zu lassen. Da der Verkehr von nicht-routebaren Adressen Teil eines DoS-Angriffs sein kann, sollten Sie in Betracht ziehen, diesen Verkehr explizit an der externen Schnittstelle des Netzwerks zu blockieren.</p></div><div class=paragraph><p>In diesem Beispiel wird ein Makro erstellt, das die nicht-routebaren Adressen enthält. Datenverkehr von und zu diesen Adressen wird dann an der externen Schnittstelle des Gateways verworfen.</p></div><div class="literalblock programlisting"><div class=content><pre>martians = &#34;{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }&#34;

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</pre></div></div></div></div><div class=sect2><h3 id=_altq_aktivieren>30.3.3. ALTQ aktivieren<a class=anchor href=#_altq_aktivieren></a></h3><div class=paragraph><p>Unter FreeBSD kann ALTQ zusammen mit PF benutzt werden, um Quality of Service (QoS) bereitzustellen. Sobald ALTQ aktiviert ist, können Warteschlangen definiert werden, mit denen Sie die Priorität für ausgehende Pakete festlegen können.</p></div><div class=paragraph><p>Bevor Sie ALTQ aktivieren, sollten Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> lesen und sicherstellen, das der Treiber der Netzwerkkarte diese Funktion unterstützt.</p></div><div class=paragraph><p>ALTQ steht nicht als ladbares Kernelmodul zur Verfügung. Wenn die Netzwerkkarte des Systems ALTQ unterstützt, erstellen Sie nach den Anweisungen in <a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a> einen angepassten Kernel. Als erstes muss ALTQ aktiviert werden. Zudem ist mindestens eine weitere Option nötig, um den Algorithmus für die Warteschlange zu bestimmen:</p></div><div class="literalblock programlisting"><div class=content><pre>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Schedule (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</pre></div></div><div class=paragraph><p>Die folgenden Algorithmen stehen zur Verfügung:</p></div><div class=dlist><dl><dt class=hdlist1>CBQ</dt><dd><p>Class Based Queuing (CBQ) erlaubt es, die Bandbreite einer Verbindung in verschiedene Klassen oder Warteschlangen zu unterteilen, um die Priorität von Datenpaketen basierend auf Filterregeln zu beeinflussen.</p></dd><dt class=hdlist1>RED</dt><dd><p>Random Early Detection (RED) wird eingesetzt, um eine Überlastung des Netzwerks zu vermeiden. Dazu ermittelt RED die Größe der Warteschlange und vergleicht diesen Wert mit den minimalen und maximalen Grenzwerten der Warteschlange. Ist die Warteschlange größer als das erlaubte Maximum, werden alle neuen Pakete nach dem Zufallsprinzip verworfen.</p></dd><dt class=hdlist1>RIO</dt><dd><p>Random Early Detection In and Out (RIO). Dieser Modus verwaltet mehrere Warteschlangen durchschnittlicher Größe mit mehreren Schwellwerten, eine für jedes QoS-Level.</p></dd><dt class=hdlist1>HFSC</dt><dd><p>Hierachical Fair Service Curve Packet Scheduler (HFSC) wird in <a href=http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html>http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</a> beschrieben.</p></dd><dt class=hdlist1>PRIQ</dt><dd><p>Priority Queuing (PRIQ) lässt den Verkehr einer Warteschlange mit höherer Priorität zuerst durch.</p></dd></dl></div><div class=paragraph><p>Weitere Informationen über diese Algorithmen und Beispiele für Regelsätze finden Sie in den <a href=https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html>OpenBSD Archiven</a>.</p></div></div></div></div><div class=sect1><h2 id=firewalls-ipfw>30.4. IPFW<a class=anchor href=#firewalls-ipfw></a></h2><div class=sectionbody><div class=paragraph><p>IPFW ist eine Stateful-Firewall für FreeBSD, die sowohl IPv4 als auch IPv6 unterstützt. Die Firewall setzt sich aus mehreren Komponenten zusammen: dem Kernel Firewall Filter-Prozessor mit integriertem Paket-Accounting, Protokollfunktionen, NAT, dem <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> Traffic-Shaper, sowie Weiterleitungs-, Bridge- und ipstealth-Funktionen.</p></div><div class=paragraph><p>FreeBSD enthält mit <span class=filename>/etc/rc.firewall</span> ein Beispielregelwerk, welches mehrere Firewall-Typen für gebräuchliche Szenarien definiert und unerfahrene Anwender dabei unterstützen soll, ein geeignetes Regelwerk zu erstellen. IPFW besitzt eine leistungsstarke Syntax, mit der erfahrene Benutzer ihre eigenen Regeln anfertigen können, um den Sicherheitsanforderungen der jeweiligen Umgebung gerecht zu werden.</p></div><div class=paragraph><p>Diser Abschnitt beschreibt, wie IPFW aktiviert wird und bietet einen Überblick über die Regelsyntax. Zudem werden mehrere Regelsätze für gebräuchliche Konfigurationsszenarien vorgestellt.</p></div><div class=sect2><h3 id=firewalls-ipfw-enable>30.4.1. IPFW aktivieren<a class=anchor href=#firewalls-ipfw-enable></a></h3><div class=paragraph><p>Das FreeBSD Basissystem enthält für IPFW ein ladbares Kernelmodul, was bedeutet, dass kein angepasster Kernel benötigt wird, um IPFW zu benutzen.</p></div><div class=paragraph><p>Wenn Sie eine statische Unterstützung für IPFW in den Kernel kompilieren wollen, lesen Sie <a href=#firewalls-ipfw-kernelconfig>IPFW Kerneloptionen</a>.</p></div><div class=paragraph><p>Um IPFW beim Systemstart zu aktivieren, fügen Sie <code>firewall_enable="YES"</code> in <span class=filename>/etc/rc.conf</span> ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_enable=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Wenn Sie einen der von FreeBSD zur Verfügung gestellten Firewall-Profile benutzen möchten, fügen Sie eine weitere Zeile hinzu, in der Sie das Profil bestimmen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_type=&#34;open&#34;</span></code></pre></div></div><div class=paragraph><p>Folgende Profile stehen zur Verfügung:</p></div><div class=ulist><ul><li><p><code>open</code>: gestattet jeglichen Datenverkehr.</p></li><li><p><code>client</code>: schützt lediglich diesen Rechner.</p></li><li><p><code>simple</code>: schützt das gesamte Netzwerk.</p></li><li><p><code>closed</code>: blockiert den gesamten IP-Datenverkehr, mit Ausnahme des Verkehrs über die Loopback-Schnittstelle.</p></li><li><p><code>workstation</code>: schützt lediglich diesen Rechner und verwendet zustandsorientierte Regeln.</p></li><li><p><code>UNKNOWN</code>: deaktiviert das Laden von Firewallregeln.</p></li><li><p><span class=filename>filename</span>: absoluter Pfad zu einer Datei, in der die Firewallregeln definiert sind.</p></li></ul></div><div class=paragraph><p>Wenn Sie <code>firewall_type</code> auf <code>client</code> oder <code>simple</code> setzen, müssen Sie die voreingestellten Regeln in <span class=filename>/etc/rc.firewall</span> anpassen, damit sie der Konfiguration des Systems entsprechen.</p></div><div class=paragraph><p>Beachten Sie, dass das Profil <code>filename</code> verwendet wird, um ein benutzerdefiniertes Regelwerk zu laden.</p></div><div class=paragraph><p>Eine alternative Möglichkeit, um ein benutzerdefiniertes Regelwerk zu laden, bietet die Variable <code>firewall_script</code>. Setzen Sie die Variable auf den absoluten Pfad eines <em>ausführbaren Skripts</em>, welches die Befehle für IPFW enthält. Die Beispiele in diesem Abschnitt gehen davon aus, dass <code>firewall_script</code> auf <span class=filename>/etc/ipfw.rules</span> gesetzt ist.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_script=&#34;/etc/ipfw.rules&#34;</span></code></pre></div></div><div class=paragraph><p>Die Protokollierung wird mit diesem Befehl aktiviert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logging=&#34;YES&#34;</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Es werden nur Firewallregeln mit der Option <code>log</code> protokolliert. Die voreingestellten Regeln enthalten diese Option nicht und müssen manuell hinzugefügt werden. Daher ist es ratsam, diese Regeln zu bearbeiten. Außerdemkann eine Rotation der Protokolle erwünscht sein, wenn die Protokolle in einer separaten Datei gespeichert werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Es existiert keine Variable für <span class=filename>/etc/rc.conf</span>, um die Protokollierung zu begrenzen. Um die Anzahl der Protokoll-Nachrichten pro Verbindungsversuch zu begrenzen, legen Sie die Anzahl der Einträge in <span class=filename>/etc/sysctl.conf</span> fest:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;net.inet.ip.fw.verbose_limit=5&#34; &gt;&gt; /etc/sysctl.conf</span></code></pre></div></div><div class=paragraph><p>Um die Protokollierung über die spezielle Schnittstelle <code>ipfw0</code> zu aktivieren, fügen Sie stattdessen folgende Zeile in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logif=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Benutzen Sie dann tcpdump, um zu sehen, was protokolliert wird:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tcpdump -t -n -i ipfw0</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Durch die Protokollierung entsteht kein Aufwand, es sei denn, tcpdump wird an die Schnittstelle angebunden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Nachdem Sie die Änderungen vorgenommen haben, können Sie die Firewall starten. Um auch die Anzahl der Protokoll-Nachrichten zu konfigurieren, setzen Sie mit <code>sysctl</code> den gewünschten Wert:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service firewall start</span>
<span class=c># sysctl net.inet.ip.fw.verbose_limit=5</span></code></pre></div></div></div><div class=sect2><h3 id=firewalls-ipfw-rules>30.4.2. IPFW Regel-Syntax<a class=anchor href=#firewalls-ipfw-rules></a></h3><div class=paragraph><p>Wenn ein Paket die Firewall "betritt", also von der Firewall geprüft und verarbeitet wird, wird die erste Regel des Regelwerkes auf das Paket angewandt. Auf diese Weise wird in aufsteigender Reihenfolge der Regelnummer mit allen weiteren Regeln verfahren. Falls die Selektionsparameter einer Regel auf ein Paket zutreffen, wird das Aktionsfeld der Regel ausgeführt und die Prüfung des Pakets beendet, nachfolgende Regeln werden also nicht mehr geprüft. Diese Suchmethode wird als "erster Treffer gewinnt" bezeichnet. Falls keine Regel auf das betreffende Paket zutrifft, wird die obligatorische IPFW-Rückfallregel mit der Nummer 65535 angewendet und das Paket wird ohne Rückantwort verworfen. Wenn das Paket jedoch einer Regel mit dem Schlüsselwort <code>count</code>, <code>skipto</code> oder <code>tee</code> entspricht, wird die Prüfung des Pakets weiter fortgeführt. Weitere Details darüber, wie diese Schlüsselwörter die Regelverarbeitung beeinflussen, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div><div class=paragraph><p>Bei der Erstellung der IPFW-Regeln müssen die Schlüsselwörter in der folgenden Reihenfolge geschrieben werden. Einige Schlüsselwörter müssen zwingend angegeben werden, während andere optional sind. Die Wörter in Großbuchstaben repräsentieren Variablen und die Wörter in Kleinbuchstaben müssen den Variablen vorangestellt werden. Das Zeichen <code>#</code> wird benutzt, um einen Kommentar einzuleiten und kann am Ende einer Regel oder in einer eigenen Zeile stehen. Leerzeilen werden ignoriert.</p></div><div class=paragraph><p><code><em>CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT OPTIONS</em></code></p></div><div class=paragraph><p>Dieser Abschnitt bietet einen Überblick über diese Schlüsselwörter und deren Optionen. Es ist keine vollständige Liste aller verfügbaren Optionen. Eine vollständige Beschreibung der Regel-Syntax, die Sie verwenden können um IPFW-Regeln zu erstellen, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div><div class=dlist><dl><dt class=hdlist1>CMD</dt><dd><p>Jede Regel muss mit <span class=parameter>ipfw add</span> beginnen.</p></dd><dt class=hdlist1>RULE_NUMBER</dt><dd><p>Jede Regel gehört zu einer Nummer zwischen <code>1</code> und <code>65534</code>. Die Nummer wird verwendet, um die Reihenfolge der Regelverarbeitung zu kennzeichnen. Es ist möglich, dass mehrere Regeln dieselbe Nummer haben. In diesem Fall werden sie entsprechend der Reihenfolge angewendet, in der sie aufgenommen wurden.</p></dd><dt class=hdlist1>SET_NUMBER</dt><dd><p>Jede Regel ist einer <em>Set</em>-Nummer zwischen <code>0</code> und <code>31</code> zugeordnet. Sets können einzeln aktiviert oder deaktiviert werden. Dies macht es möglich, eine Reihe von Regeln schnell hinzuzufügen oder zu löschen. Wenn <code>SET_NUMBER</code> nicht angegeben ist, wird die Regel zu Set <code>0</code> hinzugefügt.</p></dd><dt class=hdlist1>ACTION</dt><dd><p>Eine Regel kann mit einer der folgenden Aktionen verknüpft werden. Die festgelegte Aktion wird ausgeführt, wenn das Paket den Selektionskriterien der Regel entspricht.</p><div class=paragraph><p><span class=parameter>allow | accept | pass | permit</span>: All diese Aktionen sind gleichbedeutend und erlauben Pakete, die mit der Regel übereinstimmen.</p></div><div class=paragraph><p><span class=parameter>check-state</span>: Diese Aktion überprüft die Regel in der dynamischen Zustandstabelle. Bei einer Übereinstimmung wird die mit der dynamischen Regel verknüpfte Aktion ausgeführt, andernfalls wird mit der Prüfung gegen die nächste Regel fortgefahren. Die Regel <code>check-state</code> hat selbst kein Selektionskriterium. Sollte keine <code>check-state</code>-Regel im Regelwerk vorhanden sein, wird die dynamische Zustandstabelle beim ersten Vorkommen einer <code>keep-state</code>- oder <code>limit</code>-Regel überprüft.</p></div><div class=paragraph><p><span class=parameter>count</span>: Aktualisiert die Zähler für alle Pakete, die mit dieser Regel übereinstimmen. Die Prüfung wird mit der nächsten Regel fortgesetzt.</p></div><div class=paragraph><p><span class=parameter>deny | drop</span>: Diese Aktionen sind gleichbedeutend und verwerfen Pakete, die mit dieser Regel übereinstimmen.</p></div><div class=paragraph><p>Es stehen noch weitere Aktionen zur Verfügung. Einzelheiten finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div></dd><dt class=hdlist1>LOG_AMOUNT</dt><dd><p>Erfüllt ein Paket die Selektionskriterien mit dem Schlüsselwort <code>log</code>, wird dies von <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> mit der Annotation <code>SECURITY</code> protokolliert. Dies erfolgt allerdings nur, wenn die Anzahl der protokollierten Pakete der betreffenden Regel die definierte <code>LOG_AMOUNT</code>-Grenze nicht übersteigt. Wenn <code>LOG_AMOUNT</code> nicht definiert ist, wird die Grenze aus dem Wert von <code>net.inet.ip.fw.verbose_limit</code> benutzt. Ein Wert von <code>0</code> bedeutet eine unbegrenzte Protokollierung. Wird eine definierte Grenze erreicht, wird die Protokollierung für diese Regel deaktiviert. Um die Protokollierung zu reaktivieren, können Sie den Protokoll- oder Paketzähler mit <code>ipfw resetlog</code> zurücksetzen.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Protokollierung findet statt, nachdem alle Selektionskriterien geprüft und bevor die endgültige Aktion auf das Paket angewendet wird. Der Administrator entscheidet, welche Regel protokolliert werden soll.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>PROTO</dt><dd><p>Dieser optionale Wert wird verwendet, um einen beliebigen Protokollnamen oder -nummer aus <span class=filename>/etc/protocols</span> gegen das Paket zu prüfen.</p></dd><dt class=hdlist1>SRC</dt><dd><p>Nach dem Schlüsslwort <code>from</code> muss die Quelladresse stehen, oder ein Schlüsselwort, das die Quelladresse darstellt. Eine Adresse wird dargestellt duch <code>any</code>, <code>me</code> (jede Adresse dieses Systems), <code>me6</code> (jede IPv6-Adresse dieses Systems), oder <code>table</code> gefolgt von der Nummer der Tabelle, welche die Adressen enthält. IP-Adressen können in CIDR-Notation geschrieben werden. Beispielsweise <code>1.2.3.4/25</code> oder <code>1.2.3.4:255.255.255.128</code>.</p></dd><dt class=hdlist1>SRC_PORT</dt><dd><p>Optional kann ein Quellport über eine Nummer oder einen Namen aus <span class=filename>/etc/services</span> spezifiziert werden.</p></dd><dt class=hdlist1>DST</dt><dd><p>Nach dem Schlüsselwort <code>to</code> muss die Zieladresse stehen, oder ein Schlüsselwort, das die Zieladresse darstellt. Es können die gleichen Schlüsselwörter und Adressen benutzt werden, die bereits im SRC-Abschnitt beschrieben wurden.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>Optional kann ein Zielport über eine Nummer oder einen Namen aus <span class=filename>/etc/services</span> spezifiziert werden.</p></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Nach der Quell- und Zieladresse können noch weitere Optionen angegeben werden. Wie der Name bereits sagt, sind <code>OPTIONS</code> optional. Häufig verwendete Optionen sind <code>in</code> oder <code>out</code>, mit denen die Richtug des Pakets bestimmt wird, <code>icmptypes</code> gefolgt vom Typ der ICMP-Nachricht, sowie <code>keep-state</code>.</p><div class=paragraph><p>Wenn ein Paket auf eine <span class=parameter>keep-state</span>-Regel zutrifft, wird die Firewall eine dynamische Regel erstellen, die dem bidirektionalen Datenverkehr zwischen den gleichen Quell- und Zieladressen mit dem gleichen Protokoll entspricht.</p></div><div class=paragraph><p>Dynamische Regeln sind für einen sogenannten SYN-flood-Angriff anfällig, bei dem eine riesige Anzahl an dynamischen Regeln erzeugt wird. Verwenden Sie die Option <code>limit</code>, um einen solchen Angriff entgegenzuwirken. Diese Option begrenzt die Anzahl der gleichzeitig möglichen Sitzungen. Es handelt sich dabei um einen Zähler, der die Anzahl von dynamischen Regeln in Kombination mit der Quelladresse verfolgt. Übersteigt der Zähler den durch <code>limit</code> definierten Wert, wird das Paket verworfen.</p></div><div class=paragraph><p>Es stehen noch viele weitere Optionen zur Verfügung. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> enthält eine Beschreibung der einzelnen Optionen.</p></div></dd></dl></div></div><div class=sect2><h3 id=_beispiel_für_einen_regelsatz>30.4.3. Beispiel für einen Regelsatz<a class=anchor href=#_beispiel_für_einen_regelsatz></a></h3><div class=paragraph><p>Dieser Abschnitt die Erstellung eines Firewall-Skripts namens <span class=filename>/etc/ipfw.rules</span> mit zustandsorientierten (stateful Regeln. Alle Regeln in diesem Beispiel verwenden die Optionen <code>in</code> und <code>out</code>, um die Richtung des Pakets zu verdeutlichen. Zusätzlich wird <code>via</code> <em>interface-name</em> benutzt, um die Schnittstelle für das Paket zu prüfen.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Bei den anfänglichen Tests mit dem Firewall-Regelsatz sollten Sie vielleicht folgende Einstellung vornehmen:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.ip.fw.default_to_accept=&#34;1&#34;</pre></div></div><div class=paragraph><p>Dies legt die Standardregel von <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> etwas großzügiger fest, als das voreingestellte <code>default deny ip from any to any</code>. Dadurch sinkt die Gefahr, sich nach einem Neustart des Systems auszusperren.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Das Firewall-Skript beginnt mit einem Hinweis, dass es sich um ein Bourne Shell-Skript handelt. Danach werden alle vorhandenen Filterregeln gelöscht. Anschließend wird die Variable <code>cmd</code> erstellt, sodass <code>ipfw add</code> nicht jedes mal von Hand eingegeben werden muss. Die Variable <code>pif</code> repräsentiert die mit dem Internet verbundene Schnittstelle.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd=&#34;ipfw -q add&#34;
pif=&#34;dc0&#34;     # interface name of NIC attached to Internet</pre></div></div><div class=paragraph><p>Jetzt folgen die eigentlichen Filterregeln. Diese ersten beiden Regeln erlauben den Datenverkehr aus dem internen Netzwerk und über die Loopback-Schnittstelle:</p></div><div class="literalblock programlisting"><div class=content><pre># Change xl0 to LAN NIC interface name
$cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
$cmd 00010 allow all from any to any via lo0</pre></div></div><div class=paragraph><p>Die nächste Regel erlaubt Pakete, für die ein Eintrag in der dynamischen Zustandstabelle existiert:</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 00101 check-state</pre></div></div><div class=paragraph><p>Die nächsten Regeln definieren, welche internen Rechner Verbindungen zu anderen Rechnern im Internet aufbauen dürfen. Hier werden wieder zustandsorientierte Regeln verwendet:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

# Allow access to ISP&#39;s DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
$cmd 00120 allow log udp from any to any 67 out via $pif keep-state
#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

# Allow outbound HTTP and HTTPS connections
$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state
$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

# Allow outbound email connections
$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

# Allow outbound ping
$cmd 00250 allow icmp from any to any out via $pif keep-state

# Allow outbound NTP
$cmd 00260 allow udp from any to any 123 out via $pif keep-state

# Allow outbound SSH
$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

# deny and log all other outbound connections
$cmd 00299 deny log all from any to any out via $pif</pre></div></div><div class=paragraph><p>Die folgenden Regeln steuern die Verbindungen von Rechern aus dem Internet ins interne Netzwerk. Zuerst werden Pakete verworfen, die typischerweise im Zusammenhang mit Angriffen stehen. Danach werden bestimmte Arten von Verbindungen erlaubt. Alle Dienste aus dem öffentlichen Internet beinhalten die Option <code>limit</code>, um Flooding zu unterbinden.</p></div><div class="literalblock programlisting"><div class=content><pre># Deny all inbound traffic from non-routable reserved address spaces
$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP
$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP
$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP
$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback
$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config
$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect
$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D &amp; E multicast

# Deny public pings$
$cmd 00310 deny icmp from any to any in via $pif$
$
# Deny ident$
$cmd 00315 deny tcp from any to any 113 in via $pif$
$
# Deny all Netbios services.$
$cmd 00320 deny tcp from any to any 137 in via $pif$
$cmd 00321 deny tcp from any to any 138 in via $pif$
$cmd 00322 deny tcp from any to any 139 in via $pif$
$cmd 00323 deny tcp from any to any 81 in via $pif$

# Deny fragments
$cmd 00330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 00332 deny tcp from any to any established in via $pif

# Allow traffic from ISP&#39;s DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

# Allow HTTP connections to internal web server
$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow inbound SSH connections
$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Reject and log all other incoming connections
$cmd 00499 deny log all from any to any in via $pif</pre></div></div><div class=paragraph><p>Die letzte Regel protokolliert alle Pakete, die mit keiner Regel im Regelsatz übereinstimmen:</p></div><div class="literalblock programlisting"><div class=content><pre># Everything else is denied and logged
$cmd 00999 deny log all from any to any</pre></div></div></div><div class=sect2><h3 id=in-kernel-nat>30.4.4. In-Kernel NAT<a class=anchor href=#in-kernel-nat></a></h3><div class=paragraph><p>Die IPFW-Firewall von FreeBSD hat zwei NAT-Implementierungen: die Userland-Implementierung <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> und die neuere, kernelinterne NAT-Implementierung. Beide arbeiten in Verbindung mit IPFW, um die Übersetzung von Netzwerkadressen zu ermöglichen. Damit kann eine Lösung zur gemeinsamen Nutzung der Internetverbindung bereitgestellt werden, so dass mehrere interne Rechner unter Verwendung einer einzigen öffentlichen IP-Adresse eine Verbindung zum Internet herstellen können.</p></div><div class=paragraph><p>Um dies zu tun, muss der mit dem Internet verbundene FreeBSD-Rechner als Gateway eingerichtet sein. Das System muss über zwei Netzwerkschnittstellen verfügen, wobei eine Schnittstelle mit dem Internet verbunden ist und die andere mit dem internen Netzwerk. Jeder Rechner im internen Netzwerk sollte eine <a href=https://www.ietf.org/rfc/rfc1918.txt>RFC 1918</a> konforme Adresse zugewiesen bekommen.</p></div><div class=paragraph><p>Es ist noch ein wenig Konfiguration nötig, um die In-Kernel NAT-Funktion von IPFW zu aktivieren. Um die In-Kernel NAT-Unterstützung beim Booten zu aktivieren, müssen folgende Einträge in <span class=filename>/etc/rc.conf</span> vorhanden sein:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
firewall_enable=&#34;YES&#34;
firewall_nat_enable=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Wenn <code>firewall_nat_enable</code> gesetzt ist, <code>firewall_enable</code> jedoch nicht, hat dies keine Auswirkung, da die NAT-Implementierung im Kernel nur mit IPFW kompatibel ist.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Wenn der Regelsatz zustandsorientierte Regeln enthält, ist die Position der NAT-Regel kritisch und die <code>skipto</code>-Aktion wird benutzt. Die Aktion <code>skipto</code> benötigt eine Regelnummer, damit IPFW weiß, zu welcher Regel es springen muss. Das folgende Beispiel baut auf den im vorherigen Abschnitt gezeigten Firewall-Relgelsatz auf. Es werden einige neue Einträge hinzugefügt und bestehende Regeln modifiziert, um In-Kernel NAT zu konfigurieren. Zunächst werden einige Variablen hinzugefügt, darunter Regelnummern, die <code>keep-state</code>-Option und eine Liste mit TCP-Ports um die Anzahl der Regeln zu reduzieren:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ipfw -q -f flush
cmd=&#34;ipfw -q add&#34;
skip=&#34;skipto 1000&#34;
pif=dc0
ks=&#34;keep-state&#34;
good_tcpo=&#34;22,25,37,53,80,443,110&#34;</pre></div></div><div class=paragraph><p>Bei In-Kernel NAT muss aufgrund der Architektur von <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a>, einer Bibliothek, die als Kernel-Modul implementiert ist, um die In-Kernel NAT-Funktion für IPFW bereitzustellen, TCP segment offloading (TSO) deaktiviert werden. TSO kann pro Netzwerkschnittstelle mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, oder systemweit mit <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> deaktiviert werden. Um TSO systemweit zu deaktivieren, muss folgende Zeile in <span class=filename>/etc/sysctl.conf</span> enthalten sein:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.tcp.tso=&#34;0&#34;</pre></div></div><div class=paragraph><p>Danach wird eine NAT-Instanz konfiguriert. Mit In-Kernel NAT ist es möglich, mehrere NAT-Instanzen mit jeweils eigener Konfiguration zu betreiben. In diesem Beispiel wird jedoch nur eine NAT-Instanz mit der Nummer 1 benötigt. Die Konfiguration kann ein paar Optionen enthalten, zum Beispiel: <code>if</code>, dass die öffentliche Netzwerkschnittstelle angibt, <code>same_ports</code>, das dafür sorgt, dass Alias-Ports und lokale Portnummern identisch zugeordnet werden, <code>unreg_only</code> führt dazu, dass nur unregistrierte (private) Adressräume von der NAT-Instanz verarbeitet werden, und <code>reset</code>, was dazu beiträgt, dass eine NAT-Instanz auch dann erhalten bleibt, wenn sich die öffentliche IP-Adresse des Rechners ändert. Weitere mögliche Optionen, die an einzelne NAT-Instanzen übergeben werden können, finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Wenn eine zustandsorientierte NAT-Firewall konfiguriert wird, ist es notwendig, dass übersetzte Pakete zur weiteren Verarbeitung in die Firewall eingespielt werden können, was durch die Deaktivierung des <code>one_pass</code>-Verhaltens beim Start des Firewall-Skripts erreicht werden kann.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw disable one_pass
ipfw -q nat 1 config if $pif same_ports unreg_only reset</pre></div></div><div class=paragraph><p>Die NAT-Regel für eingehende Pakete wird <em>nach</em> den beiden Regeln, die das interne Netzwerk und die Loopback-Schnittstelle erlauben, und nach der Reassamble-Regel, aber <em>vor</em> der <code>check-state</code>-Regel eingefügt. Es ist wichtig, dass die Nummer der NAT-Regel (in diesem Beispiel <code>100</code>) höher ist, als die drei vorherigen Regeln und niedriger, als die <code>check-state</code>-Regel. Darüber hinaus wird aufgrund des Verhaltens von In-Kernel NAT empfohlen, eine Reassamble-Regel kurz vor der ersten NAT-Regel, aber hinter den Regeln zu platzieren, die den Datenverkehr auf einer vertrauenswürdigen Schnittstelle erlauben. In der Regel sollte es nicht zu einer Fragmentierung kommen, aber bei getunnelten IPSEC/ESP/GRE-Verkehr kann es vorkommen, und das Zusammensetzen von Fragmenten ist notwendig, bevor das komplette Paket an das In-Kernel NAT übergeben werden kann.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Reassamble-Regel wird beim Userland <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> nicht benötigt, da die Aktion <code>divert</code> von IPFW dies bereits automatisch übernimmt, bevor das Paket an den Socket ausgeliefert wird. Dies ist auch in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> dokumentiert.</p></div><div class=paragraph><p>Beachten Sie, dass die aktuelle NAT-Instanznummer und NAT-Regelnummer in diesem Beispiel nicht mit der voreingestellten NAT-Instanznummer und Regelnummer übereinstimmt, wenn sie mit dem <span class=filename>rc.firewall</span>-Skript von FreeBSD erstellt wurde.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>$cmd 005 allow all from any to any via xl0  # exclude LAN traffic
$cmd 010 allow all from any to any via lo0  # exclude loopback traffic
$cmd 099 reass all from any to any in       # reassemble inbound packets
$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
$cmd 101 check-state</pre></div></div><div class=paragraph><p>Die Regeln für den ausgehenden Verkehr werden ebenfalls modifiziert, um Aktionen mit der <code>$skipto</code>-Variable zu erlauben und anzuzeigen, dass die Prüfung mit der Regel <code>1000</code> fortgesetzt wird. Die sieben Regeln für TCP wurden durch die Regel <code>125</code> ersetzt, da die sieben erlaubten ausgehenden Ports in der Variable <code>$good_tcp0</code> enthalten sind.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Beachten Sie, dass die Leistung von IPFW weitgehend von der Anzahl der im Regelsatz vorhandenen Regeln bestimmt wird.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># Authorized outbound packets
$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks
$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks
$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
$cmd 130 $skip icmp from any to any out via $pif $ks</pre></div></div><div class=paragraph><p>Die eingehenden Regeln bleiben unverändert, mit Ausnahme der letzten Regel, in der das <code>via $pif</code> entfernt wird, um ein- und ausgehende Pakete prüfen zu können. Nach der letzten Regel für ausgehende Pakete muss die NAT-Regel folgen. Die Regel muss eine höhere Nummer als die letzte Regel haben und die Nummer muss über die <code>skipto</code>-Aktion referenziert werden. In diesem Regelsatz leitet die Regel mit der Nummer <code>1000</code> alle ausgehenden Pakete zur konfigurierten NAT-Instanz weiter. Die darauf folgende Regel lässt alle von NAT verarbeiteten Pakete passieren.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 999 deny log all from any to any
$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules
$cmd 1001 allow ip from any to any</pre></div></div><div class=paragraph><p>In diesem Beispiel steuern die Regeln <code>100</code>, <code>101</code>, <code>125</code>, <code>1000</code> und <code>1001</code> die Adressübersetzung der ein- und ausgehende Pakete, so dass immer die private LANIP-Adresse in der dynamische Zustandstabelle registriert werden.</p></div><div class=paragraph><p>Nehmen wir beispielsweise einen Web-Browser, der neue HTTP-Sitzungen über Port 80 aufbaut. Wenn nun das erste ausgehende Paket von der Firewall geprüft wird, trifft es nicht auf Regel <code>100</code> zu, da das Paket nach außen geleitet wird und nicht nach innen. Das Paket trifft auch nicht auf Regel <code>101</code> zu, da es das erste ist und somit noch nicht in der dynamischen Zustandstabelle enthalten ist. Das Paket entspricht schließlich Regel <code>125</code>, da es ausgehend auf einem erlaubten Port gesendet wird und von einer IP-Adresse aus dem internen LAN stammt. Für Pakete, die auf diese Regel zutreffen, werden zwei Aktionen ausgeführt. Zuerst wird durch die Aktion <code>keep-state</code> ein dynamischer Eintrag in der Statustabelle erstellt und die angegebene Aktion <code>skipto 1000</code> ausgeführt. Als nächstes durchläuft das Paket NAT und wird dann an das Internet gesendet. Nachdem dieses Paket am Webserver angekommen ist, wird dort eine Antwort erzeugt und zurückgeschickt. Dieses Paket wird wieder von oben nach unten durch das Regelwerk geprüft. Dieses Mal trifft Regel <code>100</code> auf das Paket zu und die Zieladresse wird auf die zugehörige (lokale) LAN-Adresse abgebildet. Danach wird das Paket von der Regel <code>check-state</code> verarbeitet. Die Zustandstabelle erkennt, dass eine zugehörige aktive Sitzung vorliegt und das Paket wird freigegeben und in das LAN geleitet.</p></div><div class=paragraph><p>Für den eingehenden Datenverkehr muss der Regelsatz unerwünschte Pakete blockieren und Pakete für autorisierte Dienste durchlassen. Ein Paket, das mit einer Regel für den eingehenden Datenverkehr übereinstimmt, wird in der dynamischen Zustandstabelle eingetragen und dann an das LAN freigegeben. Das Antwortpaket wird von der Regel <code>check-state</code> als Paket einer aktiven Sitzung erkannt. Das Paket wird dann von Regel <code>1000</code> per NAT verarbeitet, bevor es über die externe Schnittstelle verschickt wird.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Der Wechsel vom Userland <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> zu In-Kernel NAT mag zunächst nahtlos erscheinen, aber es gibt einen kleinen Haken. Bei Verwendung des <span class=filename>GENERIC</span>-Kernels wird IPFW das Kernelmodul <span class=filename>libalias.ko</span> laden, wenn <code>firewall_nat_enable</code> in <span class=filename>rc.conf</span> aktiviert ist. Das Kernelmodul <span class=filename>libalias.ko</span> stellt nur grundlegende NAT-Funktionalität bereit, während die Userland-Implementierung <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> alle Funktionalitäten ohne zusätzliche Konfiguration zur Verfügung stellt. Die gesamte Funktionalität bezieht sich auf die folgenden Kernelmodule, die bei Bedarf zusätzlich zu <span class=filename>libalias.ko</span> geladen werden können: <span class=filename>alias_cuseeme.ko</span>, <span class=filename>alias_ftp.ko</span>, <span class=filename>alias_bbt.ko</span>, <span class=filename>skinny.ko</span>, <span class=filename>irc.ko</span>, <span class=filename>alias_pptp.ko</span> und <span class=filename>alias_smedia.ko</span> unter Verwendung der <code>kld_list</code> Direktive in <span class=filename>rc.conf</span>. Wenn ein angepasster Kernel benutzt wird, kann die volle Funktionalität der Userland-Bibliothek im Kernel mit <code>options LIBALIAS</code> gebaut werden.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_weiterleitung_von_ports>30.4.4.1. Weiterleitung von Ports<a class=anchor href=#_weiterleitung_von_ports></a></h4><div class=paragraph><p>Der Nachteil von NAT ist, dass die Rechner im LAN nicht aus dem Internet zugänglich sind. Diese Rechner können zwar ausgehende Verbindungen zur Außenwelt aufbauen, jedoch keine eingehenden Verbindungen empfangen. Dies stellt ein Problem dar, wenn Sie auf einem Rechner im LAN Dienste anbieten möchten, die aus dem Internet erreichbar sein sollen. In diesem Fall können Sie die Ports, welche über das Internet erreichbar sein sollen, über die NAT-Maschine an den Rechner im LAN weiterleiten.</p></div><div class=paragraph><p>Angenommen es gibt einen IRC-Server auf Rechner <code>A</code> und einen Webserver auf Rechner <code>B</code>. Damit dies funktioniert, müssen die Verbindungen auf den Ports 6667 (IRC) und 80 (HTTP) an die jeweiligen Rechner weitergeleitet werden.</p></div><div class=paragraph><p>Bei In-Kernel NAT wird die gesamte Konfiguration in der NAT-Instanz selbst vorgenommen. Alle Optionen, die in einer NAT-Instanz benutzt werden können, sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> dokumentiert. Die Syntax für IPFW folgt dabei der von natd. Die Syntax für <code>-redirect_port</code> lautet:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port proto targetIP:targetPORT[-targetPORT]
  [aliasIP:]aliasPORT[-aliasPORT]
  [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>Für das obige Beispiel sollten die Argumente wie folgt aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Nachdem diese Argumente der Konfiguration der NAT-Instanz 1 im obigen Regelsatz hinzugefügt wurden, werden die TCP-Ports an die Rechner im LAN weitergeleitet, auf denen IRC- und HTTP-Dienste laufen.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw -q nat 1 config if $pif same_ports unreg_only reset \
  redirect_port tcp 192.168.0.2:6667 6667 \
  redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Portbereiche können über <code>redirect_port</code> festgelegt werden. Zum Beispiel würde <em>tcp 192.168.0.2:2000-3000 2000-3000</em> alle Verbindungen auf die Ports 2000 bis 3000 an die Ports 2000 bis 3000 an Rechner <code>A</code> weiterleiten.</p></div></div><div class=sect3><h4 id=_weiterleiten_von_adressen>30.4.4.2. Weiterleiten von Adressen<a class=anchor href=#_weiterleiten_von_adressen></a></h4><div class=paragraph><p>Das Weiterleiten von Adressen ist nützlich, wenn mehr als eine IP-Adresse zur Verfügung steht. Jeder Rechner im LAN kann über <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> seine eigene externe IP-Adresse zugewiesen bekommen. IPFW wird dann den ausgehenden Datenverkehr der Rechner aus dem LAN mit der entsprechenden externen IP-Adresse umschreiben. Auch der eingehenden Datenverkehr über die externe IP-Adresse wird an die entsprechenden Rechner im LAN weitergeleitet. Diese Methode ist auch als statisches NAT bekannt. Wenn Ihnen beispielsweise die IP-Adressen <code>128.1.1.1</code>, <code>128.1.1.2</code> und <code>128.1.1.3</code> zur Verfügung stehen, kann <code>128.1.1.1</code> als externe Adresse der <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>-Maschine verwendet werden, während <code>128.1.1.2</code> und <code>128.1.1.3</code> an Rechner <code>A</code> und Rechner <code>B</code> im LAN weitergeleitet werden.</p></div><div class=paragraph><p>Die Syntax für <code>redirect_address</code> lautet wie im Folgenden, wobei <code>localIP</code> die interne IP-Adresse des Rechners im LAN, und <code>publicIP</code> die externe IP-Adresse ist, die dem Rechner im LAN entspricht.</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address localIP publicIP</pre></div></div><div class=paragraph><p>Auf das Beispiel bezogen, würden die Argumente so lauten:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address 192.168.0.2 128.1.1.2
redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p>Genau wie bei <code>redirect_port</code>, werden diese Argumente in der Konfiguration der NAT-Instanz gesetzt. Bei der Weiterleitung von Adressen ist keine Portumleitung notwendig, da alle Daten, die auf einer bestimmten IP-Adresse empfangen werden, weitergeleitet werden.</p></div><div class=paragraph><p>Die externe IP-Adresse der <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>-Maschine muss auf der externen Schnittstelle aktiv und mit einem Alias versehen sein. Weitere Einzelheiten sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>; beschrieben.</p></div></div><div class=sect3><h4 id=_userland_nat>30.4.4.3. Userland NAT<a class=anchor href=#_userland_nat></a></h4><div class=paragraph><p>Zunächst sei gesagt, dass <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, die Userland-Implementierung aufwändiger ist als In-Kernel NAT. Damit <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> Pakete übersetzen kann, müssen die Pakete vom Kernel ins Userland und zurück kopiert werden, was zusätzlichen Aufwand mit sich bringt. Dieser Aufwand entfällt bei In-Kernel NAT.</p></div><div class=paragraph><p>Um den Userland NAT-Daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> beim Systemstart zu aktivieren, ist etwas Konfiguration in <span class=filename>/etc/rc.conf</span> nötig. <code>natd_interface</code> wird auf den Namen der mit dem Internet verbundenen Schnittstelle gesetzt. Das <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>-Skript von <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> wird selbstständig prüfen, ob eine dynamische IP-Adresse benutzt wird und sich selbst so konfigurieren, dass es damit umgehen kann.</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
natd_enable=&#34;YES&#34;
natd_interface=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>Generell kann der obige Regelsatz, wie er für In-Kernel NAT erklärt wurde, auch zusammen mit <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> benutzt werden. Die Ausnahmen sind die Konfiguration der In-Kernel NAT-Instanz <code>(ipfw -q nat 1 config …​)</code>, die nicht zusammen mit der Regel 99 benötigt wird, da die <code>divert</code>-Aktion sich um die Fragmentierung kümmert. Die Regeln 100 und 1000 müssen leicht modifiziert werden, wie unten gezeigt.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 100 divert natd ip from any to any in via $pif
$cmd 1000 divert natd ip from any to any out via $pif</pre></div></div><div class=paragraph><p>Um eine Port- oder Adressumleitung zu konfigurieren, wird eine ähnliche Syntax wie bei In-Kernel NAT verwendet. Anstatt die Konfiguration in unserem Regelsatz-Skript wie bei In-Kernel NAT anzugeben, wird die Konfiguration von <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> am besten in einer Konfigurationsdatei vorgenommen. Dazu muss eine zusätzliche Option in <span class=filename>/etc/rc.conf</span> übergeben werden, welche den Pfad zur Konfigurationsdatei angibt.</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Die Konfigurationsdatei muss eine Liste von Optionen enthalten, eine pro Zeile. Weitere Informationen über die Konfigurationsdatei und mögliche Variablen finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>. Hier zwei Beispieleinträge, einer pro Zeile:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_address 192.168.0.3 128.1.1.3</pre></div></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=firewalls-ipfw-cmd>30.4.5. Das IPFW Kommando<a class=anchor href=#firewalls-ipfw-cmd></a></h3><div class=paragraph><p><code>ipfw</code> kann benutzt werden, um einzelne Regeln im laufenden Betrieb hinzuzufügen oder zu entfernen. Problematisch ist jedoch, dass diese Änderungen bei einem Neustart des Systems verloren gehen. Daher ist es empfehlenswert, eigene Regeln in einer Datei zu definieren und diese zu laden, um die Regeln der Firewall im laufenden Betrieb anzupassen.</p></div><div class=paragraph><p><code>ipfw</code> ist auch hilfreich, um die geladenen Regeln der auf der Konsole auszugeben. IPFW erzeugt dynamisch einen Zähler, der jedes Paket, auf das eine Regel zutrifft, zählt. Dadurch ist es möglich, die Funktion einer Regel zu überprüfen.</p></div><div class=paragraph><p>Eine Auflistung aller geladenen Regeln erhalten Sie mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw list</span></code></pre></div></div><div class=paragraph><p>Eine Auflistung aller Regeln inklusive des letzten Treffers erhalten Sie mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -t list</span></code></pre></div></div><div class=paragraph><p>Das nächste Beispiel zeigt Informationen über die Anzahl der Pakete, die von einer Regel gefiltert wurden sowie die Regel selbst. Der erste Spalte zeigt die Nummer der Regel, gefolgt von der Anzahl der gefilterten Pakete und der Anzahl der Pakete in Bytes. Zum Schluss steht die Regel selbst:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -a list</span></code></pre></div></div><div class=paragraph><p>Das folgende Kommando zeigt zusätzlich alle dynamischen Regeln an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d list</span></code></pre></div></div><div class=paragraph><p>Um diese Auflistung um die "abgelaufenen" Regeln zu erweitern, geben Sie folgendes Kommando ein:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d -e list</span></code></pre></div></div><div class=paragraph><p>Hiermit werden alle Zähler auf Null zurückgesetzt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero</span></code></pre></div></div><div class=paragraph><p>Es ist auch möglich, einen spezifischen Zähler zurückzusetzen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero NUM</span></code></pre></div></div><div class=sect3><h4 id=_protokollierung_von_firewall_nachrichten>30.4.5.1. Protokollierung von Firewall-Nachrichten<a class=anchor href=#_protokollierung_von_firewall_nachrichten></a></h4><div class=paragraph><p>Auch bei aktivierter Protokollierung wird IPFW von selbst keine Regeln protokollieren. Der Administrator muss entscheiden, welche Regeln aus dem Regelwerk protokolliert werden sollen. In diesen Regeln muss dann das Schlüsselwort <code>log</code> hinzugefügt werden. Normalerweise werden nur geblockte Pakete protokolliert. Es ist üblich, die "ipfw default deny everything"-Regel am Ende des Regelwerks mit dem Schlüsselwort <code>log</code> zu duplizieren. Dadurch ist es möglich, alle Pakete zu sehen, auf die keine Regel zutraf.</p></div><div class=paragraph><p>Protokollierung ist allerdings ein zweischneidiges Schwert. Bei mangelnder Vorsicht oder einem DoS-Angriff wird die Festplatte mit einer enormen Flut von Protokolldaten belastet. Protokoll-Nachrichten werden nicht nur an <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> geschickt, sondern auch auf der Konsole angezeigt, was dann schnell lästig werden kann.</p></div><div class=paragraph><p>Die Kerneloption <code>IPFIREWALL_VERBOSE_LIMIT=5</code> begrenzt die Anzahl identischer Nachrichten an <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> für eine gegebene Regel auf fünf Nachrichten. Ist diese Option im Kernel aktiviert, wird nach Erreichen den festgelegten Anzahl die Protokollierung von aufeinanderfolgenden Nachrichten auf den festgelegten Wert begrenzt, da beispielsweise die Speicherung von 200 gleichen Protokoll-Nachrichten sinnlos ist. Daher werden durch diese Option nur fünf gleichartige Nachrichten protokolliert. Alle weiteren Nachrichten werden nur gezählt und deren Gesamtzahl wird schließlich von <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> wie folgt ausgegeben:</p></div><div class="literalblock programlisting"><div class=content><pre>Last message repeated 45 times</pre></div></div><div class=paragraph><p>Alle protokollierten Pakete werden in der Voreinstellung in <span class=filename>/var/log/security</span> gespeichert. Dies wird in <span class=filename>/etc/syslog.conf</span> definiert.</p></div></div><div class=sect3><h4 id=firewalls-ipfw-rules-script>30.4.5.2. Ein Firewall-Regelwerk erstellen<a class=anchor href=#firewalls-ipfw-rules-script></a></h4><div class=paragraph><p>Die meisten fortgeschrittenen IPFW-Benutzer erzeugen eine Datei, welche die Regeln für die Firewall enthält, um diese als Skript ausführen zu können. Der Vorteil einer derartigen Konfiguration besteht darin, dass dadurch mehrere Regeln gleichzeitig geändert und aktiviert werden können, ohne dass dazu das System neu gestartet werden muss. Dies ist zudem beim Testen von Regeländerungen sehr hilfreich. Weil es sich bei der Datei um ein Skript handelt, ist es auch möglich, häufig verwendete Befehle durch Aliase zu ersetzen und diese dann in mehreren Regeln zu nutzen.</p></div><div class=paragraph><p>Die Syntax des folgenden Skripts entspricht der Syntax von <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> sowie <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>. Felder, die symbolisch substituiert werden, haben das Präfix $ (Dollarzeichen). Symbolische Felder haben das $-Präfix nicht. Der Wert, mit dem das symbolische Feld belegt wird, muss in doppelten Anführungszeichen ("") stehen.</p></div><div class=paragraph><p>Die Datei mit den Regeln könnte wie folgt aufgebaut sein:</p></div><div class="literalblock programlisting"><div class=content><pre>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif=&#34;tun0&#34;             # out interface
odns=&#34;192.0.2.11&#34;      # ISP&#39;s DNS server IP address
cmd=&#34;ipfw -q add &#34;     # build rule prefix
ks=&#34;keep-state&#34;        # just too lazy to key this each time
$cmd 00500 check-state
$cmd 00502 deny all from any to any frag
$cmd 00501 deny tcp from any to any established
$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
$cmd 00611 allow udp from any to $odns 53 out via $oif $ks
################### End of example ipfw rules script ############</pre></div></div><div class=paragraph><p>Die Regeln in diesem Beispiel sind nicht wichtig. Wichtig ist es, zu zeigen, wie die symbolische Substitution innerhalb der Regeln verwendet wird.</p></div><div class=paragraph><p>Wenn dieses Beispiel in <span class=filename>etc/ipfw.rules</span> gespeichert wurde, so könnten alle Regeln durch die Ausführung des folgenden Kommandos neu geladen werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/ipfw.rules</span></code></pre></div></div><div class=paragraph><p>Anstelle von <span class=filename>/etc/ipfw.rules</span> kann ein beliebig anderer Name oder Speicherort verwendet werden.</p></div><div class=paragraph><p>Alternativ können die einzelnen Befehle dieses Skripts auch von Hand eingegeben werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -q -f flush</span>
<span class=c># ipfw -q add check-state</span>
<span class=c># ipfw -q add deny all from any to any frag</span>
<span class=c># ipfw -q add deny tcp from any to any established</span>
<span class=c># ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</span></code></pre></div></div></div></div><div class=sect2><h3 id=firewalls-ipfw-kernelconfig>30.4.6. IPFW Kerneloptionen<a class=anchor href=#firewalls-ipfw-kernelconfig></a></h3><div class=paragraph><p>Um die Unterstützung für IPFW statisch in den Kernel zu kompilieren, lesen Sie die Anweisungen in <a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a>. Die folgenden Optionen können in der Kernelkonfigurationsdatei verwendet werden:</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword to syslogd(8)
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT	# sets default policy to pass what is not explicitly denied
options    IPFIREWALL_NAT		# enables basic in-kernel NAT support
options    LIBALIAS			# enables full in-kernel NAT support
options    IPFIREWALL_NAT64		# enables in-kernel NAT64 support
options    IPFIREWALL_NPTV6		# enables in-kernel IPv6 NPT support
options    IPFIREWALL_PMOD		# enables protocols modification module support
options    IPDIVERT			# enables NAT through natd(8)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>IPFW kann auch als Kernelmodul geladen werden: Die oben genannten Optionen werden standardmäßig als Module erstellt, oder können zur Laufzeit über Parameter festgelegt werden.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=firewalls-ipf>30.5. IPFILTER (IPF)<a class=anchor href=#firewalls-ipf></a></h2><div class=sectionbody><div class=paragraph><p>IPFILTER, auch als IPF bekannt, ist eine plattformübergreifende Open Source Firewall, die auf mehrere Betriebssysteme portiert wurde, einschließlich FreeBSD, NetBSD, OpenBSD und Solaris™.</p></div><div class=paragraph><p>IPFILTER basiert auf einer kernelseitigen Firewall und einem NAT-Mechanismus, der durch Anwenderprogramme gesteuert und überwacht werden kann. Firewallregeln werden mit ipf gesetzt oder gelöscht. Für die Manipulation der NAT-Regeln wird ipnat benutzt. Mit ipfstat werden Laufzeitstatistiken der kernelseitigen Anteile von IPFILTER aufgelistet. Mit ipmon können die Aktionen von IPFILTER in Protokolldateien gespeichert werden.</p></div><div class=paragraph><p>IPF wurde ursprünglich mit der Verarbeitungslogik "die letzte passende Regel gewinnt" geschrieben und verwendete ausschließlich Regeln ohne feste Zustände. Inzwischen wurde IPF modernisiert und unterstützt nun auch die Optionen <code>quick</code> und <code>keep state</code>.</p></div><div class=paragraph><p>Antworten auf häufige Fragen finden Sie unter <a href=http://www.phildev.net/ipf/index.html>http://www.phildev.net/ipf/index.html</a>. Ein Archiv der IPFILTER Mailingliste steht unter <a href="http://marc.info/?l=ipfilter">http://marc.info/?l=ipfilter</a> zur Verfügung.</p></div><div class=paragraph><p>Dieser Abschnitt des Handbuchs konzentriert sich auf IPF unter FreeBSD. Es werden auch Firewallregeln mit den Optionen <code>quick</code> und <code>keep state</code> vorgestellt.</p></div><div class=sect2><h3 id=_ipf_aktivieren>30.5.1. IPF aktivieren<a class=anchor href=#_ipf_aktivieren></a></h3><div class=paragraph><p>IPF ist in FreeBSD als ladbares Kernelmodul enthalten. Das bedeutet, dass Sie keinen angepassten Kernel erzeugen müssen um IPF zu aktivieren.</p></div><div class=paragraph><p>Benutzer, die IPF lieber statisch in den Kernel kompilieren, sollten den Anweisungen in <a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a> folgen. Die folgenden Kerneloptionen stehen zur Verfügung:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</pre></div></div><div class=paragraph><p><code>options IPFILTER</code> aktiviert die Unterstützung für IPFILTER. <code>options IPFILTER_LOG</code> aktiviert die Protokollierung über die Pseudo-Schnittstelle <span class=filename>ipl</span> für Firewallrelgen, die das Schlüsselwort <code>log</code> enthalten. <code>IPFILTER_LOOKUP</code> aktiviert IP-Pools, um die Suche nach IP-Adressen zu beschleunigen. <code>IPFILTER_DEFAULT_BLOCK</code> ändert das Verhalten der Firewall dahingehend, dass jedes Paket, das nicht explizit von einer <code>pass</code>-Regel Zugang erhält, geblockt wird.</p></div><div class=paragraph><p>Um IPF während des Bootens zu aktivieren, müssen folgende Einträge in <span class=filename>/etc/rc.conf</span> hinzugefügt werden. Diese Einträge aktivieren ebenfalls die Protokollierung und die Regel <code>default pass all</code>. Um diese Voreinstellung zu ändern, ohne einen neuen Kernel zu übersetzen, müssen Sie am Ende der Firewallregeln eine <code>block all</code> Regel hinzufügen.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfilter_enable=&#34;YES&#34;             # Start ipf firewall
ipfilter_rules=&#34;/etc/ipf.rules&#34;   # loads rules definition text file
ipv6_ipfilter_rules=&#34;/etc/ipf6.rules&#34; # loads rules definition text file for IPv6
ipmon_enable=&#34;YES&#34;                # Start IP monitor log
ipmon_flags=&#34;-Ds&#34;                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>Wenn die NAT-Funktionalität benötigt wird, müssen auch diese Zeilen hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;              # Enable as LAN gateway
ipnat_enable=&#34;YES&#34;                # Start ipnat function
ipnat_rules=&#34;/etc/ipnat.rules&#34;    # rules definition file for ipnat</pre></div></div><div class=paragraph><p>Jetzt können Sie IPF starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ipfilter start</span></code></pre></div></div><div class=paragraph><p>Um die Firewallregeln zu laden, übergeben Sie den Namen des Regelwerks an <code>ipf</code>. Mit dem folgenden Kommando ersetzen Sie alle aktuell geladenen Regeln:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipf -Fa -f /etc/ipf.rules</span></code></pre></div></div><div class=paragraph><p><code>-Fa</code> löscht zunächst alle internen Regeln und mit <code>-f</code> wird die Datei angegeben, welche die zu ladenen Regeln enthält.</p></div><div class=paragraph><p>Damit haben Sie die Möglichkeit, Änderungen an der laufenden Firewall zu machen, ohne dass das System neu gestartet werden muss. Da dieser Vorgang beliebig oft wiederholt werden kann, ist es ein sehr bequemer Weg neue Regeln zu testen.</p></div><div class=paragraph><p>Diese und weitere Optionen sind in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> beschrieben.</p></div></div><div class=sect2><h3 id=_ipf_regel_syntax>30.5.2. IPF Regel-Syntax<a class=anchor href=#_ipf_regel_syntax></a></h3><div class=paragraph><p>Mit der hier beschriebenen Regel-Syntax können zustandsorientierte Regeln erstellt werden. Beim Erstellen von Regeln ist zu beachten, dass Regeln ohne das Schlüsselwort <code>quick</code> der Reihe nach geprüft werden und "die letzte zutreffende Regel" angewendet wird. Das bedeutet, dass selbst dann, wenn die erste zutreffende Regel eine <code>pass</code>-Regel ist, das Paket dennoch geblockt wird, falls später eine <code>block</code>-Regel zutrifft. Beispielregelsätze finden Sie in <span class=filename>/usr/shared/examples/ipfilter</span>.</p></div><div class=paragraph><p>Beim Erstellen von Regeln wird das Zeichen <code>#</code> verwendet, um einen Kommentar bis zum Ende der Zeile einzuleiten. Leere Zeilen werden ignoriert.</p></div><div class=paragraph><p>Die Schlüsselwörter, die in den Regeln verwendet werden, müssen in einer bestimmten Reihenfolge geschrieben werden, von links nach rechts. Einige Schlüsselwörter sind verbindlich, andere sind optional. Einige Schlüsselwörter haben Unteroptionen, die wiederum selbst Schlüsselwörter sind und ebenfalls weitere Unteroptionen einschließen können. Die Reihenfolge der Schlüsselwörter ist wie folgt, wobei die Wörter in Großbuchstaben eine Variable darstellen und die Wörter in Kleinbuchstaben der Variable vorangestellt werden müssen:</p></div><div class=paragraph><p><code><em>ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT TCP_FLAG|ICMP_TYPE keep state STATE</em></code></p></div><div class=paragraph><p>Dieser Abschnitt beschreibt jedes dieser Schlüsselwörter und ihre Optionen. Es ist jedoch keine vollständige Liste aller möglichen Optionen. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> enthält eine vollständige Beschreibung der Syntax und einige Beispiele zur Erstellung von IPF-Regeln.</p></div><div class=dlist><dl><dt class=hdlist1>ACTION</dt><dd><p>Dieses Schlüsselwort bestimmt, was mit dem Paket zu tun ist, wenn es auf eine Regel zutrifft. Jede Regel <em>muss</em> dieses Schlüsselwort enthalten. Die folgenden Aktionen werden erkannt:</p><div class=paragraph><p><code>block</code>: Das Paket wird verworfen.</p></div><div class=paragraph><p><code>pass</code>: Das Paket wird durchgelassen.</p></div><div class=paragraph><p><code>log</code>: Das Paket wird protokolliert.</p></div><div class=paragraph><p><code>count</code>: Zählt die Anzahl der Pakete und die Bytes. Die kann einen Hinweis darauf geben, wie oft Pakete auf diese Regel zutreffen.</p></div><div class=paragraph><p><code>auth</code>: Das Paket geht in eine Warteschlange zur Weiterverarbeitung durch ein anderes Programm.</p></div><div class=paragraph><p><code>call</code>: Ermöglicht den Zugriff auf eingebaute IPF-Funktionen, die komplexere Aktionen ermöglichen.</p></div><div class=paragraph><p><code>decapsulate</code>: Entfernt alle Header, um den Inhalt des Pakets zu verarbeiten.</p></div></dd><dt class=hdlist1>DIRECTION</dt><dd><p>Als nächstes muss für jede Regel explizit die Richtung mit einem der folgenden Schlüsselwörter angegeben werden:</p><div class=paragraph><p><code>in</code>: Die Regel wird auf ein eingehendes Paket angewendet.</p></div><div class=paragraph><p><code>out</code>: Die Regel wird auf ein ausgehendes Paket angewendet.</p></div><div class=paragraph><p><code>all</code>: Die Regel gilt für beide Richtungen.</p></div><div class=paragraph><p>Wenn das System mehrere Schnittstellen ausweist, kann die Schnittstelle zusammen mit der Richtung angegeben werden. Ein Beispiel wäre <code>in on fxp0</code>.</p></div></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Optionen müssen nicht zwingend angegeben werden. Falls jedoch mehrere Optionen angegeben werden, müssen sie in der hier gezeigten Reihenfolge verwendet werden.</p><div class=paragraph><p><code>log</code>: Wenn die Firewall die angegebene Aktion durchführt, werden die Kopfdaten des Pakets auf der Pseudo-Schnittstelle <a href="https://man.freebsd.org/cgi/man.cgi?query=ipl&amp;sektion=4&amp;format=html">ipl(4)</a> protokolliert.</p></div><div class=paragraph><p><code>quick</code>: Wenn ein Paket mit dieser Regel übereinstimmt, wird die Aktion für diese Regel ausgeführt und die Regelprüfung stoppt an dieser Stelle.</p></div><div class=paragraph><p><code>on</code>: Auf dieses Schlüsselwort muss der Name der Schnittstelle folgen. Die Regel trifft nur dann zu, wenn das Paket auf der angegebenen Schnittstelle in die angegebene Richtung geht.</p></div><div class=paragraph><p>Wenn das Schlüsselwort <code>log</code> verwendet wird, können die folgenden Ausdrücke in dieser Reihenfolge benutzt werden:</p></div><div class=paragraph><p><code>body</code>: die ersten 128 Bytes des Paketinhaltes werden zusätzlich zu den Kopfdaten protokolliert.</p></div><div class=paragraph><p><code>first</code>: trifft nur zu, wenn das Schlüsselwort <code>log</code> zusammen mit <code>keep-state</code> verwendet wird. Es bestimmt, dass nur das auslösende Paket protokolliert wird und nicht jedes weitere Paket, dass von der gespeicherten Status-Regel betroffen ist.</p></div><div class=paragraph><p>Es stehen noch weitere Optionen zur Rückmeldung von Fehlern verfügbar. Ausführliche Details finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a>.</p></div></dd><dt class=hdlist1>PROTO_TYPE</dt><dd><p>Der Protokolltyp ist optional. Er ist jedoch zwingend erforderlich, falls die Regel einen SRC_PORT oder DST_PORT angeben muss da es den Typ des Protokolls bestimmt. Wenn Sie das Protokoll angeben, verwenden Sie das Schlüsselwort <code>proto</code>, gefolgt von der Protokollnummer oder dem Namen aus <span class=filename>/etc/protocols</span>. Zum Beispiel <code>tcp</code>, <code>udp</code>, oder <code>icmp</code>. Wenn PROTO_TYPE angegeben wird und SCR_PORT oder DST_PORT ausgelassen werden, stimmen alle Portnummern für dieses Protokoll mit dieser Regel überein.</p></dd><dt class=hdlist1>SRC_ADDR</dt><dd><p>Das Schlüsselwort <code>from</code> ist verpflichtend und darauf folgt das Schlüsselwort, das die Quelle des Pakets darstellt. Die Quelle kann ein Rechnername, eine IP-Adresse gefolgt von der CIDR-Maske, ein Adresspool oder das Schlüsselwort <code>all</code> sein. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> enthält einige Beispiele.</p><div class=paragraph><p>IP-Bereiche können nur in der CIDR-Notation angegeben werden. Der Port oder das Paket <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/ipcalc/>net-mgmt/ipcalc</a> hilft bei der Berechnung der richtigen CIDR-Maske. Weiterführende Informationen finden Sie auf der Webseite <a href=http://jodies.de/ipcalc>http://jodies.de/ipcalc</a>.</p></div></dd><dt class=hdlist1>SCR_PORT</dt><dd><p>Die Portnummer der Quelle ist optional. Wenn sie jedoch verwendet wird, muss in der Regel zuerst PROTO_TYPE angegeben werden. Die Portnummer muss auch auf das Schlüsselwort <code>proto</code> folgen.</p><div class=paragraph><p>Es werden verschiedene Vergleichsoperatoren unterstützt: <code>=</code> (gleich), <code>!=</code> (nicht gleich), <code>&lt;</code> (kleiner als), <code>></code> (größer als), <code>⇐</code> (kleiner als oder gleich) <code>>=</code> (größer als oder gleich).</p></div><div class=paragraph><p>Um Portbereiche anzugeben, schreiben Sie zwei Portnummern zwischen <code>&lt;></code> (kleiner als und größer als), <code>>&lt;</code> (größer als und kleiner als), oder <code>:</code> (größer als oder gleich und kleiner als oder gleich).</p></div></dd><dt class=hdlist1>DST_ADDR</dt><dd><p>Das Schlüsselwort <code>to</code> ist verpflichtend und darauf folgt das Schlüsselwort, welches das Ziel des Pakets darstellt. Dieses Ziel kann ein Rechnername, eine IP-Adresse gefolgt von der CIDR-Maske, ein Adresspool oder das Schlüsselwort <code>all</code> sein.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>Die Portnummer des Ziels ist optional. Wenn sie jedoch verwendet wird, muss in der Regel zuerst PROTO_TYPE angegeben werden. Die Portnummer muss auch auf das Schlüsselwort <code>proto</code> folgen.</p></dd><dt class=hdlist1>TCP_FLAG|ICMP_TYPE</dt><dd><p>Wenn <code>tcp</code> als PROTO_TYPE verwendet wird, können bestimmte TCP-Flags angegeben werden, die den Zustand einer Verbindung bestimmen. Mögliche Flags sind: <code>S</code> (SYN), <code>A</code> (ACK), <code>P</code> (PSH), <code>F</code> (FIN), <code>U</code> (URG), <code>R</code> (RST), <code>C</code> (CWN) und <code>E</code> (ECN).</p><div class=paragraph><p>Wenn <code>icmp</code> als PROTO_TYPE verwendet wird, kann der ICMP-Typ mit angegeben werden. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> enthält eine Auflistung der zulässigen Typen.</p></div></dd><dt class=hdlist1>STATE</dt><dd><p>Wenn eine <code>pass</code>-Regel das Schlüsselwort <code>keep state</code> enthält, wird IPF einen Eintrag in der dynamischen Zustandstabelle hinzufügen, damit nachfolgende Pakete dieser Verbindung ebenfalls durchgelassen werden. IPF kann den Zustand für TCP, UDP und ICMP-Sitzungen verfolgen. IPF wird jedes Paket, das zu einer aktiven Sitzung gehört, durchlassen, auch wenn ein anderes Protokoll verwendet wird.</p><div class=paragraph><p>Pakete, die über die Schnittstelle zum öffentlichen Internet raus gehen, werden von IPF zuerst gegen die dynamische Zustandstabelle geprüft. Wenn das nächste Paket dieser aktiven Sitzung mit dem vorherigen Paket übereinstimmt, verlässt dieses Paket die Firewall und der Status wird in der dynamischen Zustandstabelle aktualisiert. Pakete, die nicht zu einer aktiven Sitzung gehören, werden gegen ausgehende Regeln geprüft. Eingehende Pakete von der Schnittstelle zum öffentlichen Internet werden gegen die dynamische Zustandstabelle geprüft. Wenn das nächste Paket mit der aktiven Sitzung übereinstimmt, verlässt dieses Paket die Firewall und der Status wird in der dynamischen Zustandstabelle aktualisiert. Pakete, die nicht zu einer aktiven Sitzung gehören, werden gegen eingehende Regeln geprüft.</p></div><div class=paragraph><p>Mehrere Schlüsselwörter können an <code>keep state</code> angefügt werden. Bei der Verwendung dieser Schlüsselwörter werden verschiedene Optionen gesetzt, um die zustandsorientierte Filterung zu steuern. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> enthält eine Liste der verfügbaren Optionen und deren Beschreibungen.</p></div></dd></dl></div></div><div class=sect2><h3 id=_beispielregelsatz>30.5.3. Beispielregelsatz<a class=anchor href=#_beispielregelsatz></a></h3><div class=paragraph><p>Dieser Abschnitt beschreibt die Erstellung eines Regelsatzes, welcher nur entsprechende Dienste erlaubt und alle anderen Verbindungen blockiert.</p></div><div class=paragraph><p>FreeBSD verwendet die Loopback-Schnittstelle (<span class=filename>lo0</span>) und die IP-Adresse <code>127.0.0.1</code> zur internen Kommunikation. Der Regelsatz muss Regeln enthalten, die Pakete für diesen internen Verkehr ermöglichen:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on the loopback interface
pass in quick on lo0 all
pass out quick on lo0 all</pre></div></div><div class=paragraph><p>Die mit dem Internet verbundene Schnittstelle wird für die Autorisierung und den Zugriff aller ein- und ausgehenden Verbindungen verwendet. Wenn eine oder mehrere Schnittstellen mit privaten Netzwerken verbunden sind, müssen Regeln existieren, die den Datenverkehr aus dem LAN zwischen den internen Netzwerken oder ins Internet erlauben. Der Regelsatz sollte in drei Bereiche unterteilt werden: vertrauenswürdige interne Schnittstellen, ausgehende Verbindungen über die öffentlichen Schnittstellen und eingehende Verbindungen über die öffentliche Schnittstelle.</p></div><div class=paragraph><p>Diese beiden Regeln erlauben den gesamten Datenverkehr über eine vertrauenswürdige LAN-Schnittstelle namens <span class=filename>xl0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all</pre></div></div><div class=paragraph><p>Die Regeln für den ein- und ausgehenden Verkehr der öffentlichen Schnittstelle sollten in einer bestimmten Reihenfolge geschrieben werden. Zuerst Regeln, die häufiger übereinstimmen, danach Regeln, die seltener übereinstimmen. Die letzte Regel blockiert und protokolliert alle Pakete auf der Schnittstelle.</p></div><div class=paragraph><p>Der folgende Regelsatz definiert die ausgehenden Regeln der öffentlichen Schnittstelle <span class=filename>dc0</span>. Die Regeln prüfen den Zustand und identifizieren bestimmte Dienste, auf die die internen Systeme zugreifen dürfen. Alle Regeln verwenden das Schlüsselwort <code>quick</code> und geben die passenden Portnummern und ggf. auch die Zieladressen an.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x. with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x. port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow access to ISP&#39;s specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all</pre></div></div><div class=paragraph><p>Die folgenden Beispielregeln für den eingehenden Verkehr auf der öffentlichen Schnittstelle blockieren zuerst alle unerwünschten Pakete. Dies reduziert die Anzahl der Pakete, die durch die letzte Regel protokolliert werden.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81</pre></div></div><div class=paragraph><p>Wenn eine Regel mit der Option <code>log first</code> protokolliert wird, können Sie mit <code>ipfstat -hio</code> prüfen, wie viele Übereinstimmungen es für diese Regel gibt. Eine große Anzahl von Übereinstimmungen kann darauf hindeuten, dass das System angegriffen wird.</p></div><div class=paragraph><p>Die restlichen Regeln definieren, welche Verbindungen aus dem Internet kommend hergestellt werden dürfen. Die letzte Regel blockiert alle Verbindungen, die nicht ausdrücklich von vorhergehenden Regeln erlaubt wurden.</p></div><div class="literalblock programlisting"><div class=content><pre># Allow traffic in from ISP&#39;s DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all</pre></div></div></div><div class=sect2><h3 id=_nat_konfiguration>30.5.4. NAT Konfiguration<a class=anchor href=#_nat_konfiguration></a></h3><div class=paragraph><p>Um NAT zu aktivieren, fügen Sie folgende Zeilen in <span class=filename>/etc/rc.conf</span> hinzu. Geben Sie den Namen der Datei an, welche die NAT-Regeln enthält:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
ipnat_enable=&#34;YES&#34;
ipnat_rules=&#34;/etc/ipnat.rules&#34;</pre></div></div><div class=paragraph><p>NAT-Regeln sind sehr flexibel, um den Bedürfnissen von kommerziellen Anwendern und Heimanwendern gerecht zu werden. Die hier vorgestellte Regelsyntax wurde vereinfacht, um die gemeinsame Nutzung zu demonstrieren. Eine vollständige Beschreibung der Syntax finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipnat&amp;sektion=5&amp;format=html">ipnat(5)</a>.</p></div><div class=paragraph><p>Die grundlegende Syntax für eine NAT-Regel ist wie folgt. <code>map</code> leitet die Regel ein und <code>IF</code> sollte durch den Namen der externen Schnittstelle ersetzt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>map IF LAN_IP_RANGE -&gt; PUBLIC_ADDRESS</pre></div></div><div class=paragraph><p><code><em>LAN_IP_RANGE</em></code> ist ein Bereich von IP-Adressen, der von den internen Rechnern verwendet wird. In der Regel ist dies ein privater Bereich, beispielsweise <code>192.168.1.0/24</code>. <code><em>PUBLIC_ADDRESS</em></code> kann entweder eine statische externe IP-Adresse sein, oder das Schlüsselwort <code>0/32</code>, welches der zugewiesenen IP-Adresse für <em>IF</em> entspricht.</p></div><div class=paragraph><p>Wenn ein Paket aus dem LAN mit einem öffentlichen Ziel an der IPF Firewall ankommt, werden zunächst die Regeln für den ausgehenden Verkehr geprüft. Danach wird das Paket an das NAT-Regelwerk geleitet, wo es von oben nach unten gelesen und geprüft wird, wobei die erste übereinstimmende Regel gewinnt. IPF testet jede NAT-Regel gegen die Schnittstelle und die Quell-IP-Adresse des Pakets. Wenn der Schnittstellenname des Pakets mit einer NAT-Regel übereinstimmt, wird geprüft, ob die Quell-IP-Adresse des Pakets auf den Bereich in <code><em>LAN_IP_RANGE</em></code> passt. Wenn dies der Fall ist, wird die Quell-IP-Adresse des Pakets mit der Adresse aus <code><em>PUBLIC_ADDRESS</em></code> überschrieben. IPF speichert die Einträge in seiner internen NAT-Tabelle, so dass wenn das Paket aus dem Internet zurückkehrt, es der ursprünglichen privaten IP-Adresse zugeordnet werden kann, bevor es von den weiteren Firewallregeln geprüft wird.</p></div><div class=paragraph><p>Bei Netzwerken mit einer großen Anzahl von Systemen oder mehreren Subnetzen, steigert sich der Ressourcenverbrauch für das Umschreiben der IP-Adressen. Es existieren zwei Methoden, um dieses Problem zu umgehen.</p></div><div class=paragraph><p>Bei der ersten Methode wird ein Portbereich definiert, der für die Quell-Ports verwendet wird. Durch das Hinzufügen des Schlüsselworts <code>portmap</code> kann NAT angewiesen werden, nur Quell-Ports aus dem angegebenen Bereich zu benutzen:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</pre></div></div><div class=paragraph><p>Alternativ kann das Schlüsselwort <code>auto</code> verwendet werden. Dadurch ermittelt NAT selbstständig die zur Verfügung stehenden Ports:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</pre></div></div><div class=paragraph><p>Mit der zweiten Methode wird ein Pool von öffentlichen Adressen verwendet. Dies ist nützlich, wenn es viele Systeme im Netzwerk gibt und ein Block öffentlicher IP-Adressen verfügbar ist. Aus diesem Pool kann NAT dann IP-Adressen für die ausgehenden Pakete auswählen.</p></div><div class=paragraph><p>Der Bereich der öffentlichen IP-Adressen kann mit einer Netzmaske oder der CIDR-Notation festgelegt werden. Die folgenden Regeln sind identisch:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</pre></div></div><div class=paragraph><p>Es ist gängige Praxis, öffentlich zugängliche Web- oder Mail-Server getrennt von den internen Netzwerksegmenten zu betreiben. Der Verkehr von diesen Servern muss dennoch von NAT bearbeitet werden und die Portumleitung ist erforderlich, um den eingehenden Datenverkehr an den richtigen Server zu leiten. Verwenden Sie beispielsweise folgende Regel, um den eingehenden Verkehr auf der öffentlichen IP-Adresse <code>20.20.20.5</code> dem internen Server mit der Adresse <code>10.0.10.25</code> zuzuordnen:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>Wenn dies der einzige Webserver im Netz ist, würde auch folgende Regel funktionieren, die alle HTTP-Anfragen an <code>10.0.10.25</code> umleitet:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>IPF enthält einen FTP-Proxy, der zusammen mit NAT benutzt werden kann. Dieser Proxy überwacht den ausgehenden Datenverkehr für aktive und passive Verbindungsanfragen und erstellt dynamische Filterregeln, welche die Portnummern des jeweiligen FTP-Datenkanal enthalten. Dadurch entfällt die Notwendigkeit, viele Ports für FTP-Verbindungen zu öffnen.</p></div><div class=paragraph><p>In diesem Beispiel verwendet die erste Regel den Proxy für ausgehende FTP-Verbindungen aus dem internen LAN. Die zweite Regel übergibt den FTP-Datenverkehr von der Firewall an das Internet und die dritte Regel handhabt den restlichen Datenverkehr aus dem internen LAN:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -&gt; 0/32</pre></div></div><div class=paragraph><p>FTP <code>map</code>-Regeln stehen vor den NAT-Regeln. Wenn ein Paket mit der FTP-Regel übereinstimmt, erstellt der FTP-Proxy eine temporäre Filterregel, damit die Pakete durchgelassen und von NAT verarbeitet werden können. Alle Pakte aus dem LAN, die nicht für FTP bestimmt sind, werden von NAT verarbeitet, wenn sie mit der dritten Regel übereinstimmen.</p></div><div class=paragraph><p>Ohne den FTP-Proxy würden stattdessen folgende Regeln benötigt. Beachten Sie, dass ohne den Proxy alle Ports oberhalb von <code>1024</code> freigegeben werden müssen:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state$
# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</pre></div></div><div class=paragraph><p>Nachdem die Datei mit den NAT-Regeln bearbeitet wurde, führen Sie <code>ipnat</code> mit <code>-CF</code> aus, um die aktuellen NAT-Regeln und den Inhalt der dynamischen Zuordnungstabelle zu löschen. Geben Sie <code>-f</code> zusammen mit dem NAT-Regelsatz an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -CF -f /etc/ipnat.rules</span></code></pre></div></div><div class=paragraph><p>Statistiken zu NAT lassen sich wie folgt anzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -s</span></code></pre></div></div><div class=paragraph><p>Die aktuellen Zuordnungen der NAT-Tabelle geben Sie mit diesem Kommando aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -l</span></code></pre></div></div><div class=paragraph><p>Ausführliche Informationen erhalten Sie mit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -v</span></code></pre></div></div></div><div class=sect2><h3 id=_ipf_statistiken>30.5.5. IPF Statistiken<a class=anchor href=#_ipf_statistiken></a></h3><div class=paragraph><p>IPF enthält mit <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> ein Werkzeug, mit dem Statistiken abgerufen und angezeigt werden können. Die Zahlen beziehen sich auf den Zeitpunkt, an dem die Firewall zuletzt gestartet wurde, beziehungsweise die Statistik mit <code>ipf -Z</code> zurückgesetzt wurde.</p></div><div class=paragraph><p>Die Ausgabe von <code>ifstat</code> sieht in etwa wie folgt aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
input packets logged: blocked 99286 passed 0
output packets logged: blocked 0 passed 0
packets logged: input 0 output 0
log failures: input 3898 output 0
fragment state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 0 lost 0
fragment state<span class=o>(</span>out<span class=o>)</span>: kept 0 lost 0
packet state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 169364 lost 0
packet state<span class=o>(</span>out<span class=o>)</span>: kept 431395 lost 0
ICMP replies: 0 TCP RSTs sent: 0
Result cache hits<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 1215208 <span class=o>(</span>out<span class=o>)</span>: 1098963
IN Pullups succeeded: 2 failed: 0
OUT Pullups succeeded: 0 failed: 0
Fastroute successes: 0 failures: 0
TCP <span class=nb>cksum </span>fails<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 0 <span class=o>(</span>out<span class=o>)</span>: 0
Packet log flags <span class=nb>set</span>: <span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Es stehen viele Optionen zur Verfügung. Wird entweder <code>-i</code> (eingehend) oder <code>-o</code> (ausgehend) angegeben, wird der Befehl die entsprechende Liste mit den derzeit vom Kernel benutzten Filterregeln anzeigen. Um auch die Regelnummern zu sehen, muss <code>-n</code> angegeben werden. Zum Beispiel zeigt <code>ipfstat -on</code> die Tabelle für ausgehende Regeln und die Regelnummer an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Wenn Sie der Regel ein <code>-h</code> voranstellen, wird der Zähler für die jeweilige Regel ausgegeben. Zum Beispiel gibt <code>ipfstat -oh</code> die ausgehenden Regeln inklusive der Zähler aus:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Benutzen Sie <code>ipfstat -t</code> um die Zustandstabelle in einem <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> ähnlichen Format anzuzeigen. Unterliegt die Firewall einem Angriff, bietet diese Option die Möglichkeit, die entsprechenden Pakete zu identifizieren. Mit den optionalen Flags können IP-Adressen, Ports oder Protokolle in Echtzeit überwacht werden. Lesen Sie <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> für weitere Informationen.</p></div></div><div class=sect2><h3 id=_ipf_protokollierung>30.5.6. IPF Protokollierung<a class=anchor href=#_ipf_protokollierung></a></h3><div class=paragraph><p>IPF enthält mit <code>ipmon</code> ein Werkzeug, mit dem die Protokolle der Firewall in menschenlesbarer Form gespeichert werden können. Dies erfordert jedoch, dass <code>options IPFILTER_LOG</code> in die Kernelkonfigurationsdatei hinzugefügt wird. Folgen Sie dazu den Anweisungen in <a href=../kernelconfig/#kernelconfig>Konfiguration des FreeBSD-Kernels</a>.</p></div><div class=paragraph><p>Um eine kontinuierliche Protokolldatei bereitzustellen, läuft dieses Kommando normalerweise im Daemon-Modus, damit auch ältere Ereignisse nachverfolgt werden können. Da FreeBSD mit <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> ein Werkzeug besitzt, das automatisch Protokolldateien rotiert, wird in der Voreinstellung für <code>ipmon_flags -Ds</code> in <span class=filename>rc.conf</span> verwendet:</p></div><div class="literalblock programlisting"><div class=content><pre>ipmon_flags=&#34;-Ds&#34; # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>Protokollierung bietet die im Nachhinein die Möglichkeit festzustellen, welche Pakete verworfen wurden, von welchen Adressen diese Pakete kamen und wohin sie gehen sollten. Diese Informationen sind hilfreich beim Aufspüren von Angreifern.</p></div><div class=paragraph><p>Nachdem die Protokollierung in <span class=filename>/etc/rc.conf</span> aktiviert und mit <code>service ipmon start</code> gestartet wurde, wird IPF Regeln aufzeichnen, welche das Schlüsselwort <code>log</code> enthalten. Der Firewalladministrator entscheidet, welche Regeln protokolliert werden. In der Regel werden nur geblockte Pakete protokolliert. Es ist üblich, das Schlüsselwort <code>log</code> in der letzten Regel des Regelsatzes mit aufzunehmen. Dies macht es möglich, alle Pakete zu sehen, die mit keiner Regel des Regelsatzes übereinstimmten.</p></div><div class=paragraph><p>In der Voreinstellung verwendet <code>ipmon -Ds local0</code> als Protokoll-Facility. Die folgenden Level können verwendet werden, um die erfassten Daten weiter aufzuspalten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>LOG_INFO - packets logged using the <span class=s2>&#34;log&#34;</span> keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header</code></pre></div></div><div class=paragraph><p>Damit IPF alle Daten protokolliert, legen Sie zunächst eine neue Datei <span class=filename>/var/log/ipfilter.log</span> an:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/ipfilter.log</span></code></pre></div></div><div class=paragraph><p>Um alle Nachrichten in der angegebenen Datei zu protokollieren, fügen Sie den folgenden Eintrag in <span class=filename>/etc/syslog.conf</span> ein:</p></div><div class="literalblock programlisting"><div class=content><pre>local0.* /var/log/ipfilter.log</pre></div></div><div class=paragraph><p>Führen Sie <code>service syslogd reload</code> aus, damit <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> <span class=filename>/etc/syslog.conf</span> neu einliest, um die Änderungen zu aktivieren.</p></div><div class=paragraph><p>Denken Sie daran, auch <span class=filename>/etc/newsyslog.conf</span> anzupassen, damit das neue Protokoll rotiert wird.</p></div><div class=paragraph><p>Die von <code>ipmon</code> generierten Nachrichten bestehen aus Daten, welche durch Leerzeichen getrennt sind. Alle Nachrichten enthalten die folgenden Felder:</p></div><div class="olist arabic"><ol class=arabic><li><p>Das Datum, an dem das Paket empfangen wurde.</p></li><li><p>Die Uhrzeit, wann das Paket empfangen wurde. Das Format ist HH:MM:SS.F (Stunden, Minuten, Sekunden und Sekundenbruchteile).</p></li><li><p>Der Name der Schnittstelle, die das Paket verarbeitet hat.</p></li><li><p>Die Gruppen- und Regelnummer im Format <code>@0:17</code>.</p></li><li><p>Die Aktion: <code>p</code> für durchgelassene Pakete, <code>b</code> für blockierte Pakete, <code>S</code> für kurze Pakete, <code>n</code> für Pakete auf die keine Regel zutraf und <code>L</code> für Pakete die protokolliert wurden.</p></li><li><p>Die Adressen werden in drei Felder unterteilt: die Quelladresse und der Port getrennt durch Komma, das Zeichen →, sowie die Zieladresse und Port. Zum Beispiel <code>209.53.17.22,80 → 198.72.220.17,1722</code>.</p></li><li><p><code>PR</code>, gefolgt vom Namen oder Nummer des Protokolls. Zum Beispiel <code>PR tcp</code>.</p></li><li><p><code>len</code>, gefolgt von der Größe des Headers und der Gesamtgröße des Pakets. Zum Beispiel <code>len 20 40</code>.</p></li></ol></div><div class=paragraph><p>Wenn es sich beim dem Paket um ein TCP-Paket handelt, gibt es ein zusätzliches Feld, das mit einem Bindestrich beginnt und die Buchstaben der entsprechenden Flags enthält. Eine Liste der Flags und deren Buchstaben finden Sie in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a>.</p></div><div class=paragraph><p>Wenn es sich beim dem Paket um ein ICMP-Paket handelt, gibt es zwei zusätzliche Felder: das erste Feld ist immer "icmp" und das zweite Feld enthält die ICMP-Nachricht und den Nachrichten-Code, getrennt durch einen Schrägstrich. Beispielswiese <code>icmp 3/3</code> für die Nachricht Port unreachable.</p></div></div></div></div><div class=sect1><h2 id=firewalls-blacklistd>30.6. Blacklistd<a class=anchor href=#firewalls-blacklistd></a></h2><div class=sectionbody><div class=paragraph><p>Blacklistd ist ein Daemon der auf Sockets lauscht, um Benachrichtigungen von anderen Daemons über fehlgeschlagene oder erfolgreiche Verbindungsversuche zu erhalten. Dieser Daemon wird häufig verwendet, um zu viele Verbindungsversuche auf offenen Ports zu blockieren. Ein Beispiel ist SSH, das viele Anfragen von Bots oder Skripten erhält, die versuchen, Passwörter zu erraten und Zugriff zu erhalten. Mit Hilfe von blacklistd kann der Daemon die Firewall benachrichtigen, eine Filterregel zu erstellen, um übermäßige Verbindungsversuche einer einzigen Quelle nach einer Reihe von Versuchen zu blockieren. Blacklistd wurde ursprünglich auf NetBSD entwickelt und erschien dort in der Version 7. FreeBSD 11 hat blacklistd von NetBSD importiert.</p></div><div class=paragraph><p>In diesem Kapitel wird die Einrichtung und Konfiguration von blacklistd besprochen. Sie finden aber auch Beispiele für die Verwendung von blacklistd. Sie sollten allerdings mit grundlegenden Firewall-Konzepten wie Filterregeln vertraut sein. Weitere Informationen finden Sie im Kapitel Firewalls. In diesen Beispielen wird PF benutzt, aber auch andere unter FreeBSD verfügbare Firewalls sollten in der Lage sein mit blacklistd zusammen zu arbeiten.</p></div><div class=sect2><h3 id=_blacklistd_aktivieren>30.6.1. Blacklistd aktivieren<a class=anchor href=#_blacklistd_aktivieren></a></h3><div class=paragraph><p>Die Konfiguration für blacklistd wird in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> gespeichert. Um das Laufzeitverhalten von blacklistd zu beeinflussen, sind verschiedene Kommandozeilenoptionen verfügbar. Die permanente Konfiguration über Neustarts hinweg sollte in <span class=filename>/etc/blacklistd.conf</span> gespeichert werden. Um den Daemon während des Systemstarts zu aktivieren, fügen Sie eine Zeile <code>blacklistd_enable</code> in <span class=filename>/etc/rc.conf</span> hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc blacklistd_enable=yes</span></code></pre></div></div><div class=paragraph><p>Sie können den Daemon auch manuell starten:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service blacklistd start</span></code></pre></div></div></div><div class=sect2><h3 id=_erstellen_von_blacklistd_regeln>30.6.2. Erstellen von Blacklistd-Regeln<a class=anchor href=#_erstellen_von_blacklistd_regeln></a></h3><div class=paragraph><p>Die Regeln für blacklistd werden in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> mit einem Eintrag pro Zeile konfiguriert. Jede Regel enthält ein Tupel, das durch Leerzeichen oder Tabulator getrennt ist. Eine Regel gilt entweder für einen lokalen oder einen entfernten Rechner.</p></div><div class=sect3><h4 id=_lokale_regeln>30.6.2.1. Lokale Regeln<a class=anchor href=#_lokale_regeln></a></h4><div class=paragraph><p>Ein typischer Eintrag für eine lokale Regel in <span class=filename>/etc/blacklistd.conf</span> sieht wie folgt aus:</p></div><div class="literalblock programlisting"><div class=content><pre>[local]
ssh             stream  *       *               *       3       24h</pre></div></div><div class=paragraph><p>Alle Regeln, die dem Abschnitt <code>[local]</code> folgen, werden als lokale Regeln behandelt, die für den lokalen Rechner gelten. In einem <code>[remote]</code>-Abschnitt gelten alle Regeln für entfernte Maschinen.</p></div><div class=paragraph><p>Die sieben Felder einer Regel werden entweder durch Tabulator oder Leerzeichen getrennt. Die ersten vier Felder identifizieren den Netzwerkverkehr, welcher geblockt werden soll. Die drei folgenden Felder definieren das Verhalten von blacklistd. Wildcards werden mit einem Sternchen (<code>*</code>) gekennzeichnet und stimmen mit allen anderen in diesem Feld überein. Das erste Feld definiert den Standort. In den lokalen Regeln sind dies die Ports. Die Syntax ist wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>[address|interface][/mask][:port]</pre></div></div><div class=paragraph><p>Adressen können als IPv4 im numerischen Format oder IPv6 in eckigen Klammern angegeben werden. Ebenfalls kann der Name der Schnittstelle wie <code><em>em0</em></code> verwendet werden.</p></div><div class=paragraph><p>Im zweiten Feld wird der Socket-Typ definiert. TCP-Sockets sind vom Typ <code>stream</code>, wohingegen UDP als <code>dgram</code> bezeichnet wird. Das obige Beispiel verwendet TCP, weil SSH dieses Protokoll benutzt.</p></div><div class=paragraph><p>Im dritten Feld kann ein Protokoll definiert werden. Die folgenden Protokolle können verwendet werden: <code>tcp</code>, <code>udp</code>, <code>tcp6</code>, <code>udp6</code> oder numerisch. Eine Wildcard, wie im Beispiel, wird typischerweise verwendet, um alle Protokolle abzubilden, es sei denn, es gibt einen Grund, den Verkehr nach einem bestimmten Protokoll zu differenzieren.</p></div><div class=paragraph><p>Im vierten Feld wird der effektive Benutzer oder Eigentümer des Daemon-Prozesses definiert, welcher das Ereignis meldet. Hier kann der Benutzer oder die UID sowie eine Wildcard verwendet werden (siehe Beispiel oben).</p></div><div class=paragraph><p>Der Name der Firewallregel wird im fünften Feld definiert. In der Voreinstellung setzt blacklistd alle geblockten Pakete unter einen pf-Anker namens <code>blacklistd</code> in <span class=filename>pf.conf</span> wie folgt:</p></div><div class="literalblock programlisting"><div class=content><pre>anchor &#34;blacklistd/*&#34; in on $ext_if
block in
pass out</pre></div></div><div class=paragraph><p>Für separate Blacklists kann in diesem Feld ein Ankername benutzt werden. In anderen Fällen genügt eine Wildcard. Ein Name mit vorangestelltem Bindestrich (<code>-</code>) bedeutet, das ein Anker mit dem voreingestellten Regelnamen verwendet werden sollte. Ein modifiziertes Beispiel von oben mit dem Bindestrich würde so aussehen:</p></div><div class="literalblock programlisting"><div class=content><pre>ssh             stream  *       *               -ssh       3       24h</pre></div></div><div class=paragraph><p>Mit einer solchen Regel werden alle neuen Blacklistregeln zu einem Anker namens <code>blacklistd-ssh</code> hinzugefügt.</p></div><div class=paragraph><p>Um ganze Subnetze für eine einzelne Regelverletzung zu blockieren, kann ein <code>/</code> im Regelnamen benutzt werden. Dadurch wird der verbleibende Teil des Namens als Maske interpretiert, die auf die in der Regel angegebene Adresse angewendet wird. Diese Regel würde beispielsweise jede Adresse blockieren, die an <code>/24</code> angrenzt:</p></div><div class="literalblock programlisting"><div class=content><pre>22              stream  tcp       *               */24    3       24h</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es ist wichtig, hier das richtige Protokoll anzugeben. IPv4 und IPv6 behandeln <code>/24</code> unterschiedlich, deshalb kann <code>*</code> im dritten Feld für diese Regel nicht benutzt werden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Diese Regel bewirkt, dass, wenn ein Rechner in diesem Netzwerk wegen seines Verhaltens blockiert wird, auch alle anderen Rechner aus diesem Netzwerk blockiert werden.</p></div><div class=paragraph><p>Das sechste Feld, genannt <code>nfail</code>, legt die Anzahl der Anmeldeversuche fest, die erforderlich sind, um die betreffende IP auf die Blacklist zu setzen. Eine Wildcard an dieser Stelle bedeutet, dass niemals geblockt wird. Im obigen Beispiel ist eine Anzahl von 3 definiert, was bedeutet, dass die IP nach drei fehlgeschlagenen Anmeldeversuchen über SSH gesperrt wird.</p></div><div class=paragraph><p>Das letzte Feld in der Regel gibt an, wie lange ein Rechner auf der Blacklist steht. Die Standardeinheit ist Sekunden, aber Suffixe wie <code>m</code> (Minuten), <code>h</code> (Stunden) und <code>d</code> (Tage) können auch angegeben werden.</p></div><div class=paragraph><p>Die Regel im Beispiel besagt, dass nach dreimaliger Authentifizierung über SSH eine neue PF-Regel für diesen Rechner angelegt wird. Beim Überprüfen der Regeln werden zuerst lokale Regeln, von sehr spezifisch bis am wenigsten spezifisch, geprüft. Wenn eine Übereinstimmung auftritt, werden die <code>remote</code>-Regeln angewendet und die Felder <code>name</code>, <code>nfail</code> und <code>disable</code> werden durch die entsprechende <code>remote</code>-Regel geändert.</p></div></div><div class=sect3><h4 id=_remote_regeln>30.6.2.2. Remote-Regeln<a class=anchor href=#_remote_regeln></a></h4><div class=paragraph><p>Mit Remote-Regeln wird das Verhalten von blacklistd, in Abhängigkeit vom aktuell ausgewerteten Remote-Rechner, festgelegt. Die einzelnen Felder einer Remote-Regel sind identisch mit den Feldern einer lokalen Regel. Der einzige Unterschied besteht darin, wie blacklistd sie verwendet. Zur besseren Verständlichkeit wird folgende Regel benutzt:</p></div><div class="literalblock programlisting"><div class=content><pre>[remote]
203.0.113.128/25 *      *       *               =/25    =       48h</pre></div></div><div class=paragraph><p>Das Adressfeld kann eine IP-Adresse (entweder v4 oder v6), einen Port oder beides beinhalten. Dies ermöglicht es, wie in diesem Beispiel, spezielle Regeln für einen bestimmten entfernten Adressbereich festzulegen. Die Felder für den Socket-Typ, Protokoll und Besitzer werden genauso wie in den lokalen Regeln interpretiert.</p></div><div class=paragraph><p>Die Felder für den Namen sind jedoch unterschiedlich. Das Gleichheitszeichen (<code>=</code>) in einer Remote-Regel weist blacklistd an, den Wert aus der entsprechenden lokalen Regel zu verwenden. Das bedeutet, dass der Eintrag der Firewall-Regel übernommen und das Präfix <code>/25</code> (eine Netzmaske von <code>255.255.255.128</code>) hinzugefügt wird. Wenn eine Verbindung aus diesem Adressbereich geblockt wird, ist das gesamte Subnetz betroffen. Ein PF-Ankername kann auch hier verwendet werden. In diesem Fall fügt blacklistd Regeln für diesen Adressbereich dem Namen des Ankers hinzu. Die Standardtabelle wird verwendet, wenn eine Wildcard angegeben wird.</p></div><div class=paragraph><p>Für eine Adresse kann im Feld <code>nfail</code> die Anzahl von Fehlversuchen definiert werden. Dies ist nützlich für Ausnahmen, um weniger strenge Anwendungen zu ermöglichen, oder um Anmeldeversuche ein wenig nachsichtiger zu gestalten. Die Sperrung wird aufgehoben, wenn im sechsten Feld eine Wildcard benutzt wird.</p></div><div class=paragraph><p>Remote-Regeln ermöglichen eine strengere Durchsetzung der Beschränkungen bei Anmeldeversuchen im Vergleich zu Anmeldeversuchen die aus dem lokalen Netzwerk kommen.</p></div></div></div><div class=sect2><h3 id=_blacklistd_client_konfiguration>30.6.3. Blacklistd Client Konfiguration<a class=anchor href=#_blacklistd_client_konfiguration></a></h3><div class=paragraph><p>Es gibt einige Softwarepakete in FreeBSD, die die Funktionalität von blacklistd nutzen können. Die beiden bekanntesten sind <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> und <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>. Beide Programme nutzen blacklistd, um übermäßige Verbindungsversuche zu unterbinden. Um blacklistd im SSH-Daemon zu aktivieren, muss folgend Zeile in <span class=filename>/etc/ssh/sshd_config</span> hinzugefügt werden:</p></div><div class="literalblock programlisting"><div class=content><pre>UseBlacklist yes</pre></div></div><div class=paragraph><p>Damit die Änderungen wirksam werden, muss sshd im Anschluss neu gestartet werden.</p></div><div class=paragraph><p>Für <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> wird blacklistd mit dem Schalter <code>-B</code> aktiviert. Entweder in <span class=filename>/etc/inetd.conf</span> oder in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpd_flags=&#34;-B&#34;</pre></div></div><div class=paragraph><p>Das ist alles, was benötigt wird, damit diese Programme mit blacklist kommunizieren.</p></div></div><div class=sect2><h3 id=_blacklistd_verwaltung>30.6.4. Blacklistd Verwaltung<a class=anchor href=#_blacklistd_verwaltung></a></h3><div class=paragraph><p>Blacklistd stellt dem Benutzer das Verwaltungswerkzeug <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistctl&amp;sektion=8&amp;format=html">blacklistctl(8)</a> zur Verfügung. Es zeigt blockierte Adressen und Netzwerke an, die nach den in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> definierten Regeln auf der Blacklist stehen. Um die Liste der aktuell blockierten Rechner anzuzeigen, benutzen Sie <code>dump</code> zusammen mit der Option <code>-b</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -b</span>
      address/ma:port <span class=nb>id      </span>nfail   last access
213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19</code></pre></div></div><div class=paragraph><p>Dieses Beispiel zeigt, dass es sechs von drei erlaubten Anmeldeversuchen auf Port 22 aus dem Adressbereich <code>213.0.123.128/25</code> gab. Es sind mehr Versuche aufgelistet, als erlaubt sind, da SSH es einem Client erlaubt, mehrere Anmeldungen über eine einzige TCP-Verbindung zu tätigen. Eine derzeit laufende Verbindung wird nicht von blacklistd unterbunden. Der letzte Verbindungsversuch ist in der letzten Spalte der Ausgabe aufgeführt.</p></div><div class=paragraph><p>Um die verbleibende Zeit zu sehen, die sich dieser Rechner auf der Blacklist befindet, fügen Sie <code>-r</code> zum vorherigen Befehl hinzu:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -br</span>
      address/ma:port <span class=nb>id      </span>nfail   remaining <span class=nb>time
</span>213.0.123.128/25:22   OK      6/3     36s</code></pre></div></div><div class=paragraph><p>In diesem Beispiel bleiben noch 36 Sekunden, bis dieser Rechner nicht mehr blockiert wird.</p></div></div><div class=sect2><h3 id=_rechner_aus_der_blocklist_entfernen>30.6.5. Rechner aus der Blocklist entfernen<a class=anchor href=#_rechner_aus_der_blocklist_entfernen></a></h3><div class=paragraph><p>Manchmal ist es notwendig, einen Rechner aus der Blocklist zu entfernen, bevor die verbleibende Zeit abgelaufen ist. Leider bietet blacklistd keine Möglichkeit dies zu tun. Es ist jedoch möglich, die Adresse mit <code>pfctl</code> aus der PF-Tabelle zu entfernen. Für den blockierten Port gibt es einen untergeordneten Anker innerhalb des definierten blacklistd-Ankers in <span class=filename>/etc/pf.conf</span>. Wenn es beispielsweise einen untergeordneten Anker zum Blockieren von Port 22 gibt, wird dieser als <code>blacklistd/22</code> bezeichnet. In diesem untergeordneten Anker befindet sich eine Tabelle, die die blockierten Adressen enthält. Diese Tabelle wird Port genannt, gefolgt von der Portnummer. In diesem Beispiel würde es <code>port22</code> heißen. Mit diesen Informationen und <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> ist es nun möglich, alle geblockten Adressen anzuzeigen:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -t port22 -T show</span>
...
213.0.123.128/25
...</code></pre></div></div><div class=paragraph><p>Nachdem Sie die entsprechende Adresse ermittelt wurde, kann sie mit folgendem Befehl aus der Liste entfernt werden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -t port22 -T delete 213.0.123.128/25</span></code></pre></div></div><div class=paragraph><p>Die Adresse ist nun aus PF entfernt, erscheint aber immer noch in der Liste von <code>blacklistctl</code>, da dieser keine Kenntnis von Änderungen an PF hat. Der Eintrag in blacklist’s Datenbank wird irgendwann ablaufen und dann aus der Ausgabe entfernt werden. Der Eintrag wird wieder hinzugefügt, falls der Rechner erneut gegen eine der Regeln von blacklistd verstößt.</p></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 9. März 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/de/books/handbook/network-servers class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/de/books/handbook/advanced-networking class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#firewalls-intro>30.1. Einführung</a></li><li><a href=#firewalls-concepts>30.2. Firewallkonzepte</a></li><li><a href=#firewalls-pf>30.3. PF</a></li><li><a href=#firewalls-ipfw>30.4. IPFW</a></li><li><a href=#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/de/books/handbook/handbook_de.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/de/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/de/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>German</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/de class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/de/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>