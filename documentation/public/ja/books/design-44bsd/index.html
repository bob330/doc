<!doctype html><html class=theme-light lang=ja><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/ja/books/design-44bsd/><title>4.4BSD オペレーティングシステムの設計と実装 | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="4.4BSD オペレーティングシステムの設計と実装"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="ja"><meta property="og:url" content="https://docs.freebsd.org/ja/books/design-44bsd/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/ja\/books\/design-44bsd\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/ja>Documentation portal</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/ja/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/ja/books>Books</a></li><li><a href=https://docs.freebsd.org/ja/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/ja/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=ja>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>4.4BSD オペレーティングシステムの設計と実装</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1996 Addison-Wesley Longman, Inc</div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary></details></div><div class=toc-mobile><h3>目次</h3><nav id=TableOfContents><ul><li><a href=#overview>2.1. 4.4BSD の設計の概要</a><ul><li><a href=#overview-facilities>2.1.1. 4.4BSD の機能とカーネル</a></li><li><a href=#overview-kernel-organization>2.1.2. カーネルの構成</a></li><li><a href=#overview-kernel-service>2.1.3. カーネル サービス</a></li><li><a href=#overview-process-management>2.1.4. プロセス管理</a></li><li><a href=#overview-memory-management>2.1.5. メモリ管理</a></li><li><a href=#overview-io-system>2.1.6. I/O システム</a></li><li><a href=#overview-filesystem>2.1.7. ファイルシステム</a></li><li><a href=#overview-filestore>2.1.8. ファイル記録機構</a></li><li><a href=#overview-nfs>2.1.9. ネットワークファイルシステム</a></li><li><a href=#overview-terminal>2.1.10. 端末</a></li><li><a href=#overview-ipc>2.1.11. プロセス間通信 (IPC)</a></li><li><a href=#overview-network-communication>2.1.12. ネットワーク通信</a></li><li><a href=#overview-network-implementation>2.1.13. ネットワーク実装</a></li><li><a href=#overview-operation>2.1.14. システム運用</a></li><li><a href=#references>参考文献</a></li><li><a href=#jacknowledgement>付録 A: 日本語化について</a></li><li><a href=#_翻訳者>翻訳者</a></li></ul></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><hr></div></div><div class=sect1><h2 id=overview>2.1. 4.4BSD の設計の概要<a class=anchor href=#overview></a></h2><div class=sectionbody><div class=sect2><h3 id=overview-facilities>2.1.1. 4.4BSD の機能とカーネル<a class=anchor href=#overview-facilities></a></h3><div class=paragraph><p>4.4BSD カーネルは 4 つの基本機能を提供します。 それはプロセス、ファイルシステム、コミュニケーション、そしてシステムの起動です。 この節ではその 4 つの基本サービスのそれぞれについて この本で書かれていることを紹介します。</p></div><div class="olist arabic"><ol class=arabic><li><p>プロセスはアドレス空間上でのコントロールの流れを構成します。 生成や終了やその他のプロセスをコントロールするための仕組みは 4 章に述べます。システムは各プロセスの個別の仮想アドレス空間を 多重化します。このメモリ管理については 5 章で議論します。</p></li><li><p>ファイルシステムとデバイスへのユーザインタフェースは似ているため、 6 章ではそれらに共通する特徴について議論します。 7 章で説明するファイルシステムは、 ディレクトリが木構造になった階層で組織された名前付きのファイルと、 それらを扱うための操作からなります。 ファイルはディスクのような物理的なメディア上に存在します。 4.4BSD はディスク上のデータ配置法をいくつかサポートしており、 それは 8 章の中で述べます。 遠隔マシン上のファイルへのアクセスについては 9 章、 システムにアクセスするために使われている端末とその動作については 10 章で扱います。</p></li><li><p>UNIX で古くから提供されている通信機構には、 関連するプロセス間における単純で信頼性の高いバイトストリーム (11.1 節パイプを参照)および、 例外イベントの通知 (4.7 節シグナルを参照)があります。 また、4.4BSD は汎用のプロセス間通信機構も備えています。 11 章に述べるこの通信機構は、 ファイルシステムのものとは異なるアクセス機構を使用していますが、 一度接続が確立されれば、 プロセスからはパイプと同じようにアクセスすることができます。 12 章では汎用のネットワーク通信フレームワークについて扱っています。 これは通常、IPC 機構の下位レイヤとして使われているものです。 13 章では、ある特定のネットワークの実装について詳細に述べます。</p></li><li><p>いかなる実際のオペレーティングシステムにも、 どのように起動するかというような運用上の話題があります。 14 章では起動時や運用上の話題について述べます。</p></li></ol></div><div class=paragraph><p>2.3 節から 2.14 節は 3 章から 14 章の内容を紹介するものです。 わたしたちは用語を定義し、基本的なシステムコールについて扱い、 開発の歴史について解説していきます。 そして最後に、中心となっている数多くの設計が、 どうやって選ばれたのかという理由を示します。</p></div><div class=sect3><h4 id=_カーネル>2.1.1.1. カーネル<a class=anchor href=#_カーネル></a></h4><div class=paragraph><p><em>カーネル</em> はプロテクトモードで動作し、 すべてのユーザプログラムが基本的なハードウェア (たとえば CPU、ディスク、端末、ネットワーク接続機器) および ソフトウェアを構成するもの (たとえばファイルシステム、 ネットワークプロトコル) へのアクセスを解決します。 カーネルは基礎的なシステムの機能を提供します。 それはプロセスを生成して管理を行い、ファイルシステムへのアクセス機能や コミュニケーション機能を提供します。 <em>システムコール</em> と呼ばれるこれらの機能は ライブラリのサブルーチンとしてユーザプロセスに現れます。 これらのシステムコールはプロセスがこれらの機能に対して持っている 唯一のインタフェースです。 システムコール機構の詳細は、 システムコールを実行することで実現されているもの以外の、 いくつかのカーネル内機構を説明した 3 章で扱います。</p></div><div class=paragraph><p>従来のオペレーティングシステムの用語における <em>カーネル</em> とは、 オペレーティングシステムにサービスを追加する実装を行うために必要な 最小限の仕組みだけを提供する、 ソフトウェアの小さな核となる部分のことです。 同時代のオペレーティングシステムの研究、たとえば Chorus <a href=#biblio-rozier>Rozier et al, 1988</a>, Mach <a href=#biblio-accetta>Accetta et al, 1986</a>, Tunis <a href=#biblio-ewens>Ewens et al, 1985</a>, V Kernel <a href=#biblio-cheriton>Cheriton, 1988</a> では、 このカーネルという機能による区分が、さらに論理的に複数に分けられています。 ファイルシステムやネットワークプロトコルといったサービスは、 その核もしくはカーネルに対するクライアントアプリケーションプロセスとして 実装されています。</p></div><div class=paragraph><p>4.4BSD カーネルは複数のプロセスには分割されていません。 この基本設計の決定は UNIX の最初のバージョンで行われました。 Ken Thompson によって行われた初めの 2 つの実装では メモリマッピングがなく、 ユーザおよびカーネル空間はハードウェアによる分離が行なわれていませんでした <a href=#biblio-ritchie>Ritchie, 1988</a>。 メッセージ伝達システムは、 実際に実装されたカーネルとユーザプロセスのモデルと 同じくらい容易に実装することが可能でした。 単純化と性能のためにモノリシックカーネルが選ばれました。 また、初期のカーネルは非常に小さいものでしたが、 ネットワークのような機能が追加されることで 次第に大きくなっていきました。 現在のオペレーティングシステムの研究の最先端では そのようなサービスをユーザ空間に置くことで カーネルの大きさを減らそうとする傾向にあります。</p></div><div class=paragraph><p>ユーザは通常、 <em>シェル</em>と呼ばれる コマンド言語インタプリタや、 追加されたユーザアプリケーションプログラムを通してシステムと対話します。 そのようなプログラムやシェルは、プロセスを使って実装されています。 それらのプログラムの詳細についてはこの本の範囲を超えますので、 ここではカーネルについてのみ、考えることにします。</p></div><div class=paragraph><p>2.3 節、2.4 節では 4.4BSD カーネルによって提供されるサービスや最近の設計の概要について扱います。 そして後の章では、 4.4BSD に現れるそれらのサービスの設計と実装の詳細を説明します。</p></div></div></div><div class=sect2><h3 id=overview-kernel-organization>2.1.2. カーネルの構成<a class=anchor href=#overview-kernel-organization></a></h3><div class=paragraph><p>この節では、2 つの側面から 4.4BSD カーネルの構成を見ていきます。</p></div><div class="olist arabic"><ol class=arabic><li><p>ソフトウェアの静的側面、つまりカーネルを構築するためのモジュール によって提供された機能性による分類</p></li><li><p>その動的な機能、つまりユーザに提供されるサービスによる分類</p></li></ol></div><div class=paragraph><p>カーネルの大部分は、システムコールを通してアプリケーションが アクセスするためのシステムサービスを実装しています。 4.4BSD では、このソフトウェアは次のような構成になっています。</p></div><div class=ulist><ul><li><p>基礎的なカーネル機能: タイマーおよびシステム時計の取り扱い、 記述子管理、そしてプロセス管理</p></li><li><p>メモリ管理のサポート: ページングとスワッピング</p></li><li><p>汎用のシステムインタフェース: I/O、コントロール、 記述子によって実現される多重化操作</p></li><li><p>ファイルシステム: ファイル、ディレクトリ、パス名の解釈、ファイルロック、 I/O バッファ管理</p></li><li><p>端末の取り扱いのサポート: 端末のインタフェースドライバと ラインディシプリン</p></li><li><p>プロセス間通信機能: ソケット</p></li><li><p>ネットワーク通信への対応: 経路制御等の通信プロトコル、一般的なネットワーク機能</p></li></ul></div><table id=table-mach-indep class="tableblock frame-none grid-all stretch"><caption class=title>表 1. 4.4BSD カーネルにおける機種非依存なソフトウェア</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">分類</th><th class="tableblock halign-left valign-top">コード行数</th><th class="tableblock halign-left valign-top">カーネル内での割合</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ヘッダ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>9,393</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4.6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>初期化部分</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1,107</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>カーネルの機能</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8,793</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4.4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>汎用のインタフェース</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,782</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>プロセス間通信</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,540</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>端末の取り扱い</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,911</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.9</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>仮想メモリ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>11,813</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5.8</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>vnode 管理</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7,954</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3.9</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ファイルシステムネーミング</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6,550</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3.2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>FFS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,365</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ログ構造化ファイルシステム</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,337</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>メモリベースのファイルシステム</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>645</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cd9660 ファイルシステム</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,177</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>その他のファイルシステム (10)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>12,695</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ネットワークファイルシステム</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>17,199</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8.5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ネットワーク通信</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8,630</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>インターネットプロトコル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>11,984</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5.9</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO プロトコル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>23,924</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>11.8</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>X.25 プロトコル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10,626</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5.3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>XNS プロトコル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5,192</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.6</p></td></tr></tbody><tfoot><tr><td class="tableblock halign-left valign-top"><p class=tableblock>機種非依存部分の総計</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>162,617</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>80.4</p></td></tr></tfoot></table><div class=paragraph><p>これらのカテゴリのソフトウェアのほとんどは機種非依存であり、しかも 異なるハードウェアアーキテクチャに移植できるものです。</p></div><div class=paragraph><p>カーネルの機種依存部分は本流のコードから分離されています。 特に、機種依存しているコードのどれを取っても、 特定のアーキテクチャのためのコードを含んでいません。 機種に依存する機能が必要なときには、機種に依存しないコードは 機種依存のコード内にあるアーキテクチャ依存の関数を呼び出します。 機種依存であるソフトウェアは次のものを含んでいます。</p></div><div class=ulist><ul><li><p>低レベルなシステム起動のための動作</p></li><li><p>トラップおよびフォールトの扱い</p></li><li><p>プロセスの動作状態に関する低レベルな操作</p></li><li><p>ハードウェアデバイスの設定と初期化</p></li><li><p>I/O デバイスのランタイムサポート</p></li></ul></div><table id=table-mach-dep class="tableblock frame-none grid-all stretch"><caption class=title>表 2. 4.4BSD カーネル内にある HP300 用の機種依存部分</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">分類</th><th class="tableblock halign-left valign-top">コード行数</th><th class="tableblock halign-left valign-top">カーネル内での割合</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>機種依存部分のヘッダ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1,562</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0.8</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>デバイスドライバのヘッダ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,495</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.7</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>デバイスドライバのソースコード</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>17,506</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8.7</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>仮想メモリ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,087</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>他の機種依存部分</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6,287</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3.1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>アセンブリ言語で書かれたルーチン</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3,014</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>HP/UX 互換機能</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4,683</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.3</p></td></tr></tbody><tfoot><tr><td class="tableblock halign-left valign-top"><p class=tableblock>機種依存部分の総計</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>39,634</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>19.6</p></td></tr></tfoot></table><div class=paragraph><p><a href=#table-mach-indep>4.4BSD カーネルにおける機種非依存なソフトウェア</a> は HP300 用 4.4BSD カーネルを構成するソフトウェアのうち、 機種非依存の部分をまとめたものです。 2 列目の数値は C 言語のソースコード、ヘッダファイル、そして アセンブリ言語のものを表しており、 アセンブリ言語のものは 2% 以下しかありません。 また、<a href=#table-mach-dep>4.4BSD カーネル内にある HP300 用の機種依存部分</a> の統計が示しているように、 機種依存のソフトウェアは、HP/UX やデバイスサポートを除いて、 カーネルのうちわずかに 6.9% しかありません。</p></div><div class=paragraph><p>カーネルのごく小さな部分だけがシステムの初期化に専念します。 このコードはシステムが <em>起動する</em> ときに用いられ、 カーネルがハードウェアやソフトウェアの環境構築をするための基本部分と なります (14 章参照)。 (制限された物理メモリを持つものには特に) オペレーティングシステムの中には これらの機能が実行された後にそのソフトウェアを廃棄してしまうか、 <em>上から覆ってしまう</em> ものもあります。 4.4BSD カーネルは、起動するために要したコードのためのメモリを再利用しません。 それは通常の機種ではカーネルのリソースのうち 0.5% に過ぎないからです。 そして、起動のためのコードはカーネルの中の一部分に固まってはいません。 それは全体にわたって散在しており、初期化されたときに論理的に関連していた 場所に存在します。</p></div></div><div class=sect2><h3 id=overview-kernel-service>2.1.3. カーネル サービス<a class=anchor href=#overview-kernel-service></a></h3><div class=paragraph><p>カーネルレベルコードとユーザレベルコードの間の境界は、 基盤となるハードウェアで提供されるハードウェアレベルの保護機能によって 分離されています。 カーネルは、ユーザプロセスにとってアクセスしにくい切り離された アドレス空間で作動します。特権のある操作 — たとえば I/O の開始や中央処理装置 (CPU) の停止 — は、カーネルだけが利用可能です。 アプリケーションは<em>システムコール</em>を用いてカーネルに サービスを要求します。システムコールは二次記憶装置にデータを 書き込むような複雑な作業や、現在の日時を返すような単純な作業を カーネルに実行させるために使用されます。 アプリケーションからは、 すべてのシステムコールが<em>同期的に実行</em>するように見えます。 つまりアプリケーションは、カーネルがシステムコールに関連した 動作をしているときには停止しています。 カーネルはシステムコール操作の一部を、 システムコールが戻った後に完了することもあります。 たとえば <em>write</em> システムコールは、 プロセスが待っている間に書き込むデータをユーザプロセスからカーネルバッファにコピーしますが、 通常、そのカーネルバッファがディスクに書き込まれる前にシステムコールから戻ります。</p></div><div class=paragraph><p>通常、システムコールは CPU の実行モードおよび現在のアドレス空間マッピングを変更する ハードウェアトラップとして実装されています。 ユーザによって与えられたシステムコール中のパラメータは、 使用される前にカーネルによって検証されます。 そのようなチェックはシステムの完全性を保証します。 カーネルへ渡されたパラメータはすべてカーネルのアドレス空間にコピーされます。 これは、システムコールの副作用により検証されたパラメータが 変更されないことを保証するためです。 システムコールの戻り値は、カーネルによってハードウェアレジスタ中に返されるか、 あるいはユーザが指定したメモリアドレスにコピーされる値で返されます。 カーネルへ渡されたパラメータのように 結果を戻すためにアプリケーションによって指定されたアドレスは、 それらが確実にアプリケーションのアドレス空間の一部である、 ということが検証されなければなりません。 システムコールを処理する間にカーネルがエラーに遭遇した場合、カーネルは ユーザにエラーコードを返します。 C プログラミング言語においては、このエラーコードが大域変数 <em>errno</em>に格納されます。また、システムコールを 実行した関数は -1 の値を返します。</p></div><div class=paragraph><p>ユーザアプリケーションとカーネルは、互いに独立して動作します。 4.4BSD は I/O コントロールブロックや、 オペレーティングシステムに関連するその他のデータ構造体を アプリケーションのアドレス空間に格納しません。 ユーザレベルのアプリケーションはそれぞれ、 実行のための独立したアドレス空間を提供されます。 カーネルは、たとえば別のプロセスが走っている間そのプロセスを停止させ、 関係するプロセスに見えないようにするというような、 状態変更のほとんどを実現しています。</p></div></div><div class=sect2><h3 id=overview-process-management>2.1.4. プロセス管理<a class=anchor href=#overview-process-management></a></h3><div class=paragraph><p>4.4BSD はマルチタスク環境をサポートしています。 実行されたそれぞれのタスクまたはスレッドは <em>プロセス</em>と呼ばれています。 4.4BSD のプロセスの<em>コンテキスト</em>は、 アドレス空間の内容とランタイム環境を含むユーザレベルの状態と、 スケジューリングのパラメータやリソース制御、識別情報を含む カーネルレベルの状態から構成されています。 コンテキストにはカーネルがプロセスにサービスを 提供する際に使用するすべてが含まれています。 ユーザはプロセスを生成し、その実行を制御し、 プロセスの実行状態が変化したときに通知を受け取ることができます。 すべてのプロセスには<em>プロセス ID</em> (PID) と呼ばれる一意の値が割り当てられます。 この値はカーネルがユーザに実行状態の変化を報告するときにプロセスの身元を確認したり、 ユーザがシステムコールを実行するために参照する際に使用されます。</p></div><div class=paragraph><p>カーネルは他のプロセスのコンテキストを複製してプロセスを生成します。 新しく生成されたプロセスを 元の<em>親プロセスの 子プロセス</em>と呼びます。 プロセス生成時に複製されたコンテキストは、ユーザレベルのプロセスの実行状態と カーネルが管理しているプロセスのシステム状態の両方を含んでいます。 カーネルの状態に関する重要な構成要素については、4 章で解説しています。</p></div><div id=fig-process-lifecycle class=imageblock><div class=content><img src=../../../images/books/design-44bsd/fig1.png alt=プロセス管理システムコール></div><div class=title>図 1. プロセスのライフサイクル</div></div><div class=paragraph><p><a href=#fig-process-lifecycle>プロセスのライフサイクル</a>ではプロセスのライフサイクルを示しています。 プロセスは <em>fork</em> システムコールを用いて、 元のプロセスのコピーとして新しいプロセスを生成することができます。 <em>fork</em> は呼び出されると 二度戻ります。一方は親プロセスに子プロセスのプロセス ID を返し、 もう一方は子プロセスに 0 を返します。 プロセスの親子関係はシステム上のプロセスの組に階層構造をもたらします。 新しく生成されたプロセスはファイル記述子やシグナルハンドラの状態、 メモリレイアウトのような親が持っているリソースすべてを共有します。</p></div><div class=paragraph><p>親のコピーとして生成された新しいプロセスであっても、 別のプログラムをロードし実行することでより便利で特有の動作をすることもできます。 プロセスは <em>execve</em> システムコールを用いることで、 別のプログラムのメモリイメージで自分自身を上書きして、 新しい引数の組をその新しく作成したイメージに引き渡すことができます。 引数の一つは、システムで認識されるフォーマット (バイナリ実行ファイルや指定されたインタプリタプログラムの起動を促すファイル) をしたファイルの名前です。</p></div><div class=paragraph><p>プロセスは <em>exit</em> システムコールを実行することで、 親プロセスに 8 ビットの exit ステータスを送信して終了することができます。 もしプロセスが 1 バイト以上の情報を親プロセスに伝えたい場合には、 パイプやソケット、または仲介ファイルを用いて プロセス間通信チャネルをセットアップする必要があります。 プロセス間通信については 11 章で大きく取り上げています。</p></div><div class=paragraph><p>プロセスは、<em>wait</em> システムコールを用いて 子プロセスのいずれかが終了するまで実行を中断することができ、 wait システムコールは終了した子プロセスの PID と終了ステータスを返します。 親プロセスは、子プロセスが終了または異常終了したときのシグナルによる通知のされ方を調整できます。 <em>wait4</em> システムコールを使用することで、 親プロセスは子プロセスの終了を引き起こしたイベントについての情報と、 子プロセスが生存期間の間に消費したリソースについての情報を取得することができます。 もし親プロセスが先に終了したためにリソースがオーファンド (親のない状態) になってしまった場合、カーネルは <em>init</em> という特別なプロセスにその子プロセスの 終了ステータスが渡されるよう調整します。これについては 3.1 節および 14.6 節を参照してください。</p></div><div class=paragraph><p>5 章では、カーネルがどのようにしてプロセスを生成し 消滅させるかについての詳細を述べています。</p></div><div class=paragraph><p>プロセスは<em>プロセス優先度</em>というパラメータに従って 実行をスケジュールされます。 この優先度はカーネルベースのスケジューリングアルゴリズムによって管理されています。 スケジューリングの優先度全体に重みづけする特別なパラメータ (<em>nice</em>) によって、ユーザはプロセスの実行優先度に影響を与えることができますが、 カーネルのスケジューリングポリシに従って、基本となる CPU リソースを共有する必要があります。</p></div><div class=sect3><h4 id=_シグナル>2.1.4.1. シグナル<a class=anchor href=#_シグナル></a></h4><div class=paragraph><p>システムはプロセスに送ることができる <em>シグナル</em>のセットを定義しています。 4.4BSD におけるシグナルはハードウェア割り込みをモデルとしています。 プロセスはユーザレベルのサブルーチンをシグナルが送られるべき <em>ハンドラ</em>として指定できます。 シグナルが発生して、それがハンドラによって<em>捕捉</em>されている間は さらなるシグナルの発生はブロックされます。 シグナルを捕捉することで、現在のプロセスのコンテキストを保存し、 ハンドラを実行するための新たなコンテキストを構築することになります。 シグナルがハンドラに伝わると、そのハンドラはプロセスをアボートさせたり、 (おそらく大域変数に値を設定した後で) 実行中のプロセスに戻ることもできます。 ハンドラから戻ると、そのシグナルはブロックされなくなり、 発生する (そして捕捉される) ことが再び可能になります。</p></div><div class=paragraph><p>また、プロセスはシグナルを<em>無視</em>することや、 カーネルで定義されているデフォルトの動作を行なうように指定することができます。 ある種のシグナルのデフォルトでの動作はプロセスを終了させることです。 このような場合の終了は、事後のデバッグに使用できるようにその時のプロセスのメモリイメージを含んだ <em>コアファイル</em>の生成を伴います。</p></div><div class=paragraph><p>いくつかのシグナルは捕捉することも無視することもできません。 そのシグナルは、暴走したプロセスを停止させる <em>SIGKILL</em> や、 ジョブコントロールシグナルである <em>SIGSTOP</em> です。</p></div><div class=paragraph><p>プロセスはシグナルを特別なスタックに伝達させることも選択できます。 これにより、洗練されたソフトウェアスタック操作が可能です。 たとえば、コルーチンをサポートしている言語では それぞれのコルーチンにスタックを提供する必要があります。 その言語の実行システムは、4.4BSD で提供される単一のスタックを分割することで、 これらのスタックを割り当てることができます。 もしカーネルが独立したシグナルスタックをサポートしていない場合、 それぞれのコルーチンに割り当てられた領域を シグナルの捕捉に必要な分だけ拡張しなければなりません。</p></div><div class=paragraph><p>すべてのシグナルは、同じ<em>優先度</em>を持っています。 もし複数のシグナルが同時に未処理となっている場合は、 シグナルの届く順序は実装に依存します。 シグナルハンドラは、そのシグナルがブロックされるようにして実行しますが、 他のシグナルは依然発生可能です。 このメカニズムにより、プロセスは コードのクリティカルな部分を特定のシグナルの発生に対して保護することができるのです。</p></div><div class=paragraph><p>シグナルの設計と実装の詳細は、4.7 節で解説しています。</p></div></div><div class=sect3><h4 id=_プロセスグループとセッション>2.1.4.2. プロセスグループとセッション<a class=anchor href=#_プロセスグループとセッション></a></h4><div class=paragraph><p>複数のプロセスを組織して<em>プロセスグループ</em>が作られます。 プロセスグループは端末へのアクセスの制御や 関係プロセスの集合にシグナルを送る手段を提供するのに使用されます。 プロセスは親プロセスからプロセスグループを引き継ぎます。 プロセスが自分自身または自分の子孫のプロセスグループを変更できるようにする メカニズムをカーネルは提供しています。 新しいプロセスグループを作成することは簡単です。 新しいプロセスグループの値はたいてい 作成したプロセスのプロセス ID となります。</p></div><div class=paragraph><p>プロセスグループにおけるプロセスの集合は、<em>ジョブ</em>と呼ばれることがあり、 シェルのような高レベルのシステムソフトウェアで操作されます。 シェルによって生成されるよくある類のジョブは、いくつかのプロセスをパイプでつないだ <em>パイプライン</em>で、最初のプロセスの出力が 2 番目の入力となり、 2 番目の出力が 3 番目の入力となり、4 番目も同様に…​ というものです。 シェルはパイプラインの各段階においてプロセスを fork して、 これらすべてのプロセスを別個のプロセスグループにおくことで このようなジョブを生成します。</p></div><div class=paragraph><p>ユーザプロセスは、単独のプロセスに送る場合と同様に プロセスグループのそれぞれのプロセスにまとめてシグナルを送ることができます。 指定されたプロセスグループに属するプロセスが そのプロセスグループに影響するソフトウェア割り込みを受け取ると、 それによってプロセスグループは実行を中断や再開をしたり、 割り込みを受けたり、終了させられたりします。</p></div><div class=paragraph><p>端末にはプロセスグループ ID が割り当てられています。 この ID は、端末に関連づけられたプロセスグループの ID が通常セットされます。 ジョブコントロール機能を持つシェルは、同じ端末に関連づけされた プロセスグループを多数作成することができます。 その端末は、これらのプロセスグループに属するプロセスの<em>制御端末</em>となります。 プロセスは、端末のプロセスグループ ID とそのプロセスのプロセスグループ ID が一致したときのみ、 制御端末を記述子から読むことができます。 もしプロセスグループ ID が一致していなければ、 プロセスがその端末から読み込もうとする際にブロックされます。 端末のプロセスグループ ID を変更することで、 シェルはいくつかの異なるジョブの間で端末を調停することができます。 この調停は<em>ジョブコントロール</em>と呼ばれ、 プロセスグループとともに 4.8 節で解説しています。</p></div><div class=paragraph><p>関連するプロセスの集合をプロセスグループとしてまとめることができるのと同じように、 プロセスグループの集合を<em>セッション</em>としてまとめることができます。 セッションのおもな用途は、デーモンプロセスとその子プロセスに対して隔離した環境を作り出したり、 ユーザのログインシェルとそのシェルが作り出すジョブをひとまとめにすることです。</p></div></div></div><div class=sect2><h3 id=overview-memory-management>2.1.5. メモリ管理<a class=anchor href=#overview-memory-management></a></h3><div class=paragraph><p>それぞれのプロセスはプロセスごとのプライベートアドレス空間を持っています。 アドレス空間は、最初に論理的な3つのセグメントに分割されます: <em>テキスト</em>、 <em>データ</em>、および <em>スタック</em>です。 テキストセグメントは読み出し専用で、プログラムの命令を含んでいます。 データ及びスタックセグメントは読み取り書き込みともに可能です。 データセグメントには 初期化されているデータと初期化されていないデータがあるのに対し、 スタックセグメントはランタイムスタックを保持します。 ほとんどのマシンでは、プロセスが実行するとともに、 カーネルによってスタックセグメントは自動的に拡張されます。 プロセスはシステムコールによりデータセグメントを拡張する事が可能ですが、 セグメントの内容がファイルシステムからのデータである場合、あるいは デバッグ時に限りプロセスはそのテキストセグメントのサイズを変更することができます。 子プロセスのセグメントの初期の内容は親プロセスのセグメントのコピーです。</p></div><div class=paragraph><p>プロセスアドレス空間の全内容はプロセスが実行するのには必要がありません。 プロセスがメインメモリにおいて保持されていないアドレス空間の一部を参照する場合、 システムはメインメモリーからメモリの中の必要な情報を <em>ページ</em> につけます。 システムリソースが不足する場合、システムは利用可能な資源を維持するために2レベルのアプローチをします。 適度の量のメモリが利用可能な場合でこれらの資源が最近使用されていない場合、 システムはプロセスからメモリリソースを解放します。 メモリー不足が深刻だった場合、システムはプロセスの全情況を２次キャッシュの <em>スワップ</em> に頼ります。 <em>ページング</em> と <em>スワップ</em> の交換はシステムによって行われた、プロセスに有効です。 プロセスは実行援助として予期された将来のメモリ利用についてシステムに助言するかもしれません。</p></div><div class=sect3><h4 id=_bsdメモリ管理設計の決定>2.1.5.1. BSDメモリ管理設計の決定<a class=anchor href=#_bsdメモリ管理設計の決定></a></h4><div class=paragraph><p>疎の広いアドレス空間のサポート、 メモリマップファイル、共有メモリは、 4.2BSD に要求されたものの一つでした。 独立したプロセス群がプロセスのアドレス空間をファイルにマッピングし、 それの共有を可能にする <em>mmap</em> と呼ばれるインタフェースが規定されました。 複数のプロセスが同じファイルにプロセスのアドレス空間をマッピングした場合、 一つのプロセスがファイルにマッピングされたアドレス空間の一部分に対して 加えた変更は、通常のファイルがそうであるのと同様、 同じ部分をマッピングしている他のプロセスにも反映されます。 しかし結局、4.2BSDは <em>mmap</em> インタフェースを含まない形でリリースされました。 これはネットワークのような他の機能を実現する方が重要で、 時間的な余裕がなかったからです。</p></div><div class=paragraph><p><em>mmap</em> インタフェースの開発は、4.3BSD の作業の間も続けられました。 40 社を超える会社と研究グループが、 Berkeley Software Architecture Manual <a href=#biblio-mckusick-1>McKusick et al, 1994</a> に記載されたアーキテクチャの改訂版を策定する議論に参加し、 いくつかの企業はその改訂版のインタフェースを実装しました <a href=#biblio-gingell>Gingell et al, 1987</a>。</p></div><div class=paragraph><p>しかし、またもや時間的な問題により 4.3BSD への mmap インタフェースの実装は見送られました。 もちろん既存の 4.3BSD 仮想記憶システムにそのインタフェースを組み込むことは 可能だったのですが、4.3BSD の仮想記憶システムの実装は 10 年近く前のものであったため、開発者たちはそれを組み込まないことに決定したのです。 4.3BSD の仮想記憶システムはローカルに接続されたディスク装置は高速・大容量・安価で、 コンピュータのメモリは小容量・高価であるという仮定に基づいて設計されており、 そのため、その設計はメモリ利用量を節約できる代わりに 余分なディスクアクセスを生成してしまうものでした。 また、この実装は VAX のメモリ管理ハードウェアに強く依存するもので、 他のコンピュータアーキテクチャへの移植が困難でした。 最後にもう一つ付け加えるなら、この仮想記憶システムは 現在普及がすすみ重要になってきている密結合マルチプロセッサに 対応するように設計されていなかったのです。</p></div><div class=paragraph><p>古い仮想記憶システムの実装を改良しようという試みは、 ますます失敗が運命づけられたように思われました。 その一方で、完全に新しい設計は大容量メモリを利用し、 ディスクへのデータ転送を低減し、 マルチプロセッサで動作することができる能力を持っていました。 その結果、仮想記憶システムは 4.4BSD で完全に置き換えられることになったのです。 4.4BSD 仮想記憶システムは Mach 2.0 VM システム <a href=#biblio-tevanian>Tevanian, 1987</a> をベースに、Mach 2.5 と Mach 2.0 の改良を採り入れたものです。 この実装は、 メモリ共有の効率が良く機種依存部分と機種非依存部分がきれいに分離されていて、 (現在は使われていませんが) マルチプロセッサに対応しているという特徴を持っています。 各プロセスは自分のアドレス空間のあらゆる部分をファイルにマッピングすることができ、 互いに同一のファイルにアドレス空間をマッピングすることで、 プロセス間でアドレス空間の一部を共有することが可能になりました。 一つのプロセスが加えた変更は他のプロセスのアドレス空間にも反映され、 マッピングされたファイル自身にも書き込まれます。 また、プロセスはファイルをプライベートマッピングすることも可能です。 プライベートマッピングとは、プロセスが加えた変更が、 そのファイルをマッピングしている他のプロセスから見えないようにしたり、 ファイル自身に書き戻されないようにするものです。</p></div><div class=paragraph><p>仮想記憶システムの抱えるもう一つの問題は、 システムコールが発行された時にカーネルに情報を渡す方法です。 4.4BSD では、常にプロセスのアドレス空間からカーネル内のバッファに データをコピーしていました。 大容量のデータを転送する読み書き操作が発生することを考えると、 このコピーの実行には時間がかかる可能性があります。 コピーを実現するもう一つの方法として、 プロセスのメモリをカーネル内に再マッピングする方法があります。 しかし 4.4BSD カーネルは、 以下の理由から常にデータをコピーします。</p></div><div class=ulist><ul><li><p>ほとんどの場合ユーザデータはページ境界にアラインされていませんし、 ハードウェアページ長の倍数でもありません。</p></li><li><p>そのページをプロセスが破棄してしまうと、 カーネルがページを参照できなくなってしまいます。 プログラムの中には、カーネル内のバッファに 書かれたデータが残っていることを想定しているものがあります。</p></li><li><p>(現在の 4.4BSD セマンティクスで可能なように) プロセスがページのコピーを持てる場合、 そのページは必ず<em>コピーオンライト(copy-on-write)</em> になっています。 コピーオンライトのページとは、 読み込み専用に設定することで書き込みに対する保護機能を有効化したページのことです。 プロセスがそのページを変更しようとするとカーネルは書き込み例外を検出します。 その際カーネルは、プロセスが変更できるようにそのページのコピーを作成します。 残念ながら、プロセスは通常すぐに出力バッファに新しいデータを書こうとするため、 結局データのコピーが発生してしまいます。</p></li><li><p>ページが新しい仮想メモリアドレスに再マッピングされる際、 ほとんどのメモリ管理ハードウェアでは、 ハードウェアアドレス変換キャッシュの一部を破棄する必要があります。 多くの場合、このキャッシュの破棄は時間がかかるため、 4 から 8 キロバイトより小さいデータブロックに対しては、 コピーするよりも再マッピングする方が実質的に遅い、 という結果となります。</p></li></ul></div><div class=paragraph><p>メモリマッピングの最も大きな目的は、 巨大なファイルへのアクセスと、 プロセス間の大容量のデータ転送という要求に応えることです。 <em>mmap</em> インタフェースは、 両方の要求をコピーを行なうことなく実現する一つの方法を提供します。</p></div></div><div class=sect3><h4 id=_カーネル内部のメモリ管理>2.1.5.2. カーネル内部のメモリ管理<a class=anchor href=#_カーネル内部のメモリ管理></a></h4><div class=paragraph><p>カーネルは一つのシステムコールの間だけ必要とされるメモリの割り当てを頻繁に行ないます。 ユーザプロセスではおそらく、 そのような短期間使われるメモリはランタイムスタックに割り当てられるでしょう。 カーネルのランタイムスタックには上限があるため、 小さめのメモリブロックだとしてもスタックにメモリを割り当てることはできません。 そのため、 そのようなメモリはもっと動的な機能を用いて割り当てる必要があります。 たとえば、システムがパス名の解釈を行なう場合、 パス名を保持するために 1 キロバイトのバッファを割り当てる必要があります。 しかしメモリブロックは一つのシステムコールよりも 長く持続していなければならないため、 スタックに空きがあったとしても、そこに割り当てることはできないでしょう。 こういう例の一つに、ネットワークが接続されている間維持している必要がある プロトコル制御ブロックがあります。</p></div><div class=paragraph><p>カーネル内の動的なメモリ割り当てに対する需要は、 サービスが追加されるにつれて増加しています。 汎用のメモリアロケータがあれば、 カーネル内部のコードを書く際の複雑さを低減することができます。 そのため 4.4BSD カーネルでは、システムのあらゆる場面で利用可能な 単一のメモリアロケータを備えています。 これは、 アプリケーションプログラム用のメモリ割り付けを実現するために C ライブラリルーチンに含まれている <em>malloc</em> と <em>free</em> と類似したインタフェースを持っています <a href=#biblio-mckusick-2>McKusick & Karels, 1988</a>。 この割り付けルーチンは C ライブラリインタフェースと同様、 引数として必要なメモリサイズを指定します。 割り当てるメモリサイズの上限はありませんが、 割り当てられるのは物理メモリであり、ページではありません。 メモリ解放ルーチンは解放するメモリへのポインタを引数にとります。 その際、解放するメモリサイズを指定する必要はありません。</p></div></div></div><div class=sect2><h3 id=overview-io-system>2.1.6. I/O システム<a class=anchor href=#overview-io-system></a></h3><div class=paragraph><p>基本的な UNIX の I/O システムモデルは、ランダムアクセスおよび シーケンシャルアクセスの可能なバイト列です。 通常の UNIX ユーザープロセスには、 <em>アクセスメソッド</em> や <em>コントロールブロック</em> は存在しません。</p></div><div class=paragraph><p>I/O にさまざまなレベルの構造を期待するプログラムは各種ありますが、 カーネルは I/O に構造を課しません。 たとえば、テキストファイルは改行文字 (ASCII LF 文字) で区切られた ASCII 文字の行の集まりですが、 カーネルはそのような構造を関知しません。 ほとんどのプログラムにとって、 このモデルはデータバイトのストリームもしくは <em>I/O ストリーム</em> にすぎません。 このような単一のデータ構造が、UNIX のツールベースのアプローチ (tool-based approach) を可能にしているのです<a href=#biblio-kernighan>Kernighan & Pike, 1984</a>。 あるプログラムの出力ストリームは、他のほとんどのプログラムの入力 ストリームとしてそのまま与える事ができます (このような伝統的な UNIX の I/O ストリームを、Eighth Edition のストリーム I/O システムや、 System V Release 3 の STREAMS と混同すべきではありませんが、 どちらのストリームも伝統的な I/O ストリームと同じようにアクセスすることが可能です)。</p></div><div class=sect3><h4 id=_記述子と_io>2.1.6.1. 記述子と I/O<a class=anchor href=#_記述子と_io></a></h4><div class=paragraph><p>UNIX のプロセスは、I/O ストリームを参照するのに <em>記述子(descriptor)</em>を使用します。 記述子は <em>open</em> または <em>socket</em> システムコールにより取得される符号無しの小さな整数です。 <em>open</em>システムコールは、 引数にファイル名および許可モードをとり、 それぞれ開くファイルおよび、モード (読み込み、書き込みまたは読み書き) を指定します。 <em>open</em> システムコールは、新しい空のファイルの作成にも使用できます。 <em>read</em>および <em>write</em>システムコールを記述子に対して使用し、 データの転送を行います。 <em>close</em>システムコールは、任意の記述子を開放します。</p></div><div class=paragraph><p>記述子は、カーネルでサポートされるオブジェクトを表します。 4.4BSD では、ファイル、パイプ、ソケットの 3 つのオブジェクトを 表すことができます。</p></div><div class=ulist><ul><li><p><em>ファイル</em>は、少なくとも 1 個の名前を持つバイト列です。 ファイルは、すべての名前を明示的に削除し、 その記述子を持つすべてのプロセスが消滅するまで存在します。 プロセスは、<em>open</em> システムコールにより、 指定されたファイル名を持つファイルのファイル記述子を取得します。 I/O デバイスはファイルとしてアクセスされます。</p></li><li><p><em>パイプ</em>とは、 ファイルと同じくバイト列ですが I/O ストリームとしてのみ使われ、単一方向にのみ使われます。 パイプには名前がないので、<em>open</em> システムコールでは開くことができません。 パイプを開くには、<em>pipe</em> システムコールを使用します。 <em>pipe</em>システムコールは 2 つの記述子を返します。 ひとつの記述子に入力されたデータは、 もう一方の記述子にそのまま順序を変えずに出力されます。 名前付きパイプ (FIFO) も使用できます。 名前があるのでファイルシステム上に配置され、 <em>open</em> システムコールでアクセスできる以外は、 パイプと同一の機能を持ちます。 FIFO を使用してプロセス間通信を行いたい場合は、 片方のプロセスが FIFO を書き込み用に開き、 もう片方では読み込み用に開きます。</p></li><li><p><em>ソケット</em>は、 プロセス間通信のために使用されるオブジェクトで、 ソケットを参照する記述子を持つプロセスが存在する間のみ存在します。 ソケットは <em>socket</em> システムコールで作成します。 <em>socket</em> システムコールは、 作成したソケットの記述子を返します。 さまざまな通信方法を実現するために、 各種のソケットがあります。 たとえば、信頼性の高いデータ転送を目的としたソケット、 メッセージの順番を保持するソケット、 メッセージの境界を保護するソケットなどがあります。</p></li></ul></div><div class=paragraph><p>4.2BSD でソケットが導入されるまで、 パイプはファイルシステムを用いて実装されていました。 4.2BSD 以降では、ソケットを使用して実装されています。</p></div><div class=paragraph><p>カーネルはそれぞれのプロセスの<em>記述子テーブル</em>を保持しており、 記述子の外部表現を内部表現に変換するために用いられます (記述子そのものはこのテーブルへのインデックス値にすぎません)。 記述子テーブルは、親プロセスから子プロセスに継承されます。 そのため、記述子の参照先も同じく継承されます。 記述子を得るためには、オブジェクトを開いたり、 作成したりする以外に、 このような親プロセスからの継承による方法があります。 また IPC ソケットを使用すれば、 同一マシン上で動作している無関係なプロセス間で、 記述子のやりとりが可能です。</p></div><div class=paragraph><p>すべての有効な記述子は、 オブジェクトの先頭からの位置を <em>ファイルオフセット</em> としてバイト単位で保持しています。 読み込みおよび書き込み動作は、 このオフセット位置から行われ、 データが転送される毎にオフセットの位置は更新されます。 ランダムアクセスを許可しているオブジェクトの場合、 ファイルオフセットは、<em>lseek</em> システムコールを利用して移動することもできます。 通常のファイルやある種のデバイスはランダムアクセス可能です。 パイプ、ソケットはランダムアクセスできません。</p></div><div class=paragraph><p>プロセスが終了すると、 カーネルはそのプロセスに使用されていたすべての識別子を回収します。 プロセスがオブジェクトへの参照を保持したまま終了した場合は、 オブジェクトマネージャに通知し、ファイルの削除、 ソケットの開放などの必要なクリーンアップを行わせます。</p></div></div><div class=sect3><h4 id=_記述子の管理>2.1.6.2. 記述子の管理<a class=anchor href=#_記述子の管理></a></h4><div class=paragraph><p>ほとんどの場合、プロセスが起動されると、 3 つの記述子がすでに開かれています。 それらの記述子は、0、1、2 で、それぞれ一般的には、 <em>標準入力</em>、 <em>標準出力</em>、 <em>標準エラー出力</em> として知られています。 通常これらの識別子は、 ログインプロセスによりユーザの端末に割り当てられています (14.6 節参照)。すなわち、キーボードからの入力を標準入力として受け取り、 標準出力への出力は端末の画面に表示されます。 標準エラー出力もエラー出力用に書き込み用に開かれていますが、 通常の出力には標準出力が利用されます。</p></div><div class=paragraph><p>これらの記述子を (他の記述子も) 端末以外のオブジェクトに割り当てることも可能です。 このような割り当てを、 <em>I/O リダイレクト</em>と呼びます。 すべての標準シェルでは、ユーザが I/O リダイレクトを行うことができます。 記述子 1 (標準出力) を閉じ、 指定したファイルを記述子 1 として開くことで、 シェルは出力をファイルに送ることができます。 同様に、記述子 0 を閉じ、 指定したファイルを開くことで、 ファイルから標準入力を受け取るようにできます。</p></div><div class=paragraph><p>パイプは、プログラムの変更をまったく行わず (再リンクも必要ありません)、あるプログラムの出力を 他のプログラムに入力することを可能にします。 出力側のプログラムの記述子 1 (標準出力) は、端末出力の代わりにパイプの入力記述子に割り当てられます。 同様に入力側のプログラムの記述子 0 (標準入力) は、 端末からのキーボード入力ではなくパイプの出力記述子に割り当てられます。</p></div><div class=paragraph><p><em>open</em>、 <em>pipe</em>、 <em>socket</em> システムコールは、新しい記述子を生成し、 使用できる最も小さい番号を割り当てます。 パイプを動作させるためには、そのように生成された記述子を 0 や 1 にマップする仕組みが必要になります。 <em>dup</em> システムコールは、 同一のファイルテーブルエントリを指す記述子のコピーを作成します。 新しい記述子も同じく使用可能な最小の番号が使われるため、 <em>dup</em>システムコールを使用して、 必要なマップを行えます。 ただ、記述子 1 が必要な場合でも、記述子 0 が既に閉じられていると、 記述子 0 が割り当てられてしまいますので注意が必要です。 この問題を避けるため、 <em>dup2</em> システムコールがあります。 <em>dup</em> に引数が 1 つ追加され、 割り当てたい記述子の番号を指定することができます (もし、指定された番号の記述子が使用中の場合、 <em>dup2</em> は、まずその記述子を閉じたのち、 再割り当てします)。</p></div></div><div class=sect3><h4 id=_デバイス>2.1.6.3. デバイス<a class=anchor href=#_デバイス></a></h4><div class=paragraph><p>ハードウェアデバイスはファイル名を持ち、通常のファイルと 同一のシステムコールでアクセスできます。カーネルは、 <em>デバイス特殊ファイル</em> や <em>特殊ファイル</em>を区別し、 参照しているデバイスを特定できますが、 ほとんどのプロセスにとって、このような区別は必要ありません。 端末、プリンタ、テープデバイスは、4.4BSD のディスクファイルと同様、 バイト列としてアクセスされます。そのため、デバイス依存部分や特殊部分は、 可能な限りカーネルに隠蔽され、さらにカーネル内でも、 それらの大部分がデバイスドライバ内に分離されています。</p></div><div class=paragraph><p>ハードウェアデバイスは、 <em>構造を持つ</em>デバイスと <em>構造を持たない</em>デバイスに分けられます。 それぞれ、 <em>ブロック</em>デバイス、 <em>キャラクタ</em>デバイスと呼ばれます。 それらのデバイスファイルへのアクセスは、カーネル内の <em>デバイスドライバ</em> と呼ばれるソフトウェアモジュールによって処理されます。 ほとんどのネットワーク通信ハードウェアデバイスは、 ファイルシステム上に特殊ファイルを持たず、 プロセス間通信機能によってのみアクセスできます。 それは、<em>raw-socket</em>の方が特殊ファイルより、 より自然なインタフェースを提供できるためです。</p></div><div class=paragraph><p>典型的なブロックデバイス (構造を持つデバイス) としては、 ディスク、磁気テープがあげられますが、 ほとんどのランダムアクセスデバイスがそれに該当します。 カーネルは、読み込み-変更-書き込みに対してバッファリングを提供し、 通常ファイルと同様の、 完全なバイトアドレス指定のランダムアクセスを提供します。 ファイルシステムは、ブロックデバイス上に構築されます。</p></div><div class=paragraph><p>構造を持たないデバイスは、 ブロック構造をサポートしないデバイスで、通信線、ラスタプロッタ、 バッファのない磁気ディスクやテープなどです。 構造を持たないデバイスは通常、 大容量のブロック I/O 転送をサポートします。</p></div><div class=paragraph><p>構造を持たないファイルは<em>キャラクタデバイス</em>と呼ばれます。 これは最初に実装されたこの種類のデバイスが、 端末デバイスドライバだったからです。 このようなデバイスに対するカーネルのインタフェースは、 他のブロック構造を持たないデバイスに対しても有用であることが証明されました。</p></div><div class=paragraph><p>デバイス特殊ファイルは、 <em>mknod</em>システムコールにより作成されます。 <em>ioctl</em>システムコールは、 特殊ファイルに対応するデバイスのパラメータを操作するのに使われます。 このシステムコールは、他のシステムコールに新たな機能を追加せずに、 デバイスの特殊な機能を操作することを可能にします。 たとえば、<em>ioctl</em>を使用して、 終了マークをテープデバイスに書き込むことができます。 <em>write</em> に変更を加えたり、 特殊なバージョンを用意する必要はありません。</p></div></div><div class=sect3><h4 id=_ソケット_ipc>2.1.6.4. ソケット IPC<a class=anchor href=#_ソケット_ipc></a></h4><div class=paragraph><p>4.2BSD カーネルはソケットを利用して、パイプより柔軟な IPC 機能を導入しました。ソケットは、ファイルやパイプと同様、 記述子により参照される、通信の末端点です。 2 つのプロセスがそれぞれ、ソケットを作成して接続することにより、 信頼性の高いバイトストリームを作成できます。 接続されれば、それぞれのプロセスは、パイプと同じように、 読み込み書き込みをソケットに対して行えます。 ソケットの透明性により、カーネルはプロセスの出力を、 別のマシン上のプロセスの入力に送ることも可能です。 パイプとソケットの大きな違いは、 パイプは共通の親プロセスが設定する必要があるのに対して、 ソケットはまったく無関係の (異なるマシン上で動作する) プロセス間でも使用できる点です。</p></div><div class=paragraph><p>System V は、FIFO もしくは<em>名前付きパイプ</em>と呼ばれる ローカルプロセス間通信の仕組みを備えています。 FIFO はファイルシステム上のオブジェクトとして現われ、 パイプと同様な方法でオープンし、データを送ることができます。 そのため、FIFO は共通の親プロセスによって設定される必要はなく、 プロセス同士が起動し動作開始してから接続することが可能です。 しかしソケットとは異なり、 異なるマシン上で動作するプロセスに対しては使用できません。 4.4BSD で、FIFO が実装されているのは、 POSIX.1 標準に準拠するためのみです。 FIFO の機能は、ソケットの機能の一部になっています。</p></div><div class=paragraph><p>ソケット機構を実現するには、 伝統的な UNIX の I/O システムコールに名前付けや接続機能を追加する必要がありました。 開発者は、既存のインタフェースへの拡張は既存のシステムコールが変更なしに使用できる範囲にとどめ、 追加機能を扱う新しいインタフェースを設計しました。 バイトストリーム型の接続の読み込み書き込みを行う <em>read</em>と <em>write</em> システムコールに加え、 ネットワークダイアグラムのような宛名付きメッセージを読み込むため、 新たに 6 つのシステムコールが追加されました。 メッセージ書き込み用の <em>send</em>、 <em>sendto</em>、 <em>sendmsg</em> システムコールと、 メッセージの読み込み用の <em>recv</em>、 <em>recvfrom</em>、 <em>recvmsg</em> システムコールです。 考え直して見ると、 それぞれの読み書き用のシステムコールのうち最初の 2 つは次のシステムコールの特殊な場合であるので、 <em>recvfrom</em> と <em>sendto</em> システムコールは、それぞれ <em>recvmsg</em> と <em>sendmsg</em> のライブラリインタフェースとし て追加すべきだったかも知れません。</p></div></div><div class=sect3><h4 id=_scattergather_io>2.1.6.5. Scatter/Gather I/O<a class=anchor href=#_scattergather_io></a></h4><div class=paragraph><p>既存の <em>read</em> および <em>write</em> システムコールに加え、 4.2BSD で scatter/gather I/O 機能が導入されました。 scatter 入力は <em>readv</em> システムコールによって行われ、 複数の異なるバッファに対して単一の読み込みを実行できます。 逆に <em>writev</em> システムコールは、複数の異なるバッファに対してアトミックな書き込みを実行できます。 <em>read</em> や <em>write</em> によって行われるように、 単一のバッファと長さをパラメータとして渡す代わりに、 バッファと長さの配列へのポインタとそのサイズを渡します。</p></div><div class=paragraph><p>この機能により、 プロセスアドレス空間の異なる場所にあるバッファに対してアトミックな単一の書き込みを行え、 隣接するバッファにコピーする必要もありません。 テープデバイスのように、それぞれの要求に対し、 テープブロックを出力をする必要があるようなレコードベースのデバイスを抽象化した場合、 アトミックな書き込みが必要になります。 また、単一の読み込みリクエストで複数のバッファに読み込めるのは非常に便利です (たとえばレコードヘッダとデータをそれぞれ別のバッファに読み込む場合など)。 もちろん単一の大きなバッファにデータを読み込み、 読み込んだデータを必要な場所に移動することで scatter 動作をシミュレートすることは可能です。 ただし、このようなメモリ間のコピーのコストは、 アプリケーションの動作に必要な時間を 2 倍以上にしてしまうことも良くあります。</p></div><div class=paragraph><p><em>send</em> と <em>recv</em> がそれぞれ、 <em>sendto</em> と <em>recvfrom</em> のライブラリインタフェースとして実装可能であったのと同じく、 <em>read</em> と <em>write</em> をそれぞれ、 <em>readv</em> と <em>writev</em> のライブラリインタフェースとして実装も可能であったでしょう。 しかし、 <em>read</em> と <em>write</em> はより頻繁に使われるため、 シミュレートするための追加コストを考えると ライブラリインタフェースとしての実装は割に合わなかったでしょう。</p></div></div><div class=sect3><h4 id=_複数のファイルシステムのサポート>2.1.6.6. 複数のファイルシステムのサポート<a class=anchor href=#_複数のファイルシステムのサポート></a></h4><div class=paragraph><p>ネットワークコンピューティングの発達により、 ローカルおよびリモートファイルシステムへの対応が望まれるようになりました。 複数のファイルシステムのサポートを簡単にするために、 開発者は <em>vnode</em> インタフェースをカーネルに追加しました。 vnode インタフェースから提供される操作は、 以前にローカルファイルシステムでサポートされていたファイルシステム操作とほぼ同じですが、 幅広いファイルシステムにより使用ができるようになっています。</p></div><div class=ulist><ul><li><p>ローカルのディスクファイルシステム</p></li><li><p>各種リモートファイルシステムプロトコルによりインポートされたファイル</p></li><li><p>読み込み専用 CD-ROM ファイルシステム</p></li><li><p>特殊機能を提供するファイルシステム。 たとえば <span class=filename>/proc</span> ファイルシステムなど</p></li></ul></div><div class=paragraph><p>4.4BSD 由来の OS の中には FreeBSD のように、 <em>mount</em> でファイルシステムが初めて参照された時にファイルシステムを動的に読み込むことが できるものもあります。 vnode インタフェースについては 6.5 節、 補助サポートルーチンについては 6.6 節、 特殊機能ファイルシステムについては 6.7 節に記載されています。</p></div></div></div><div class=sect2><h3 id=overview-filesystem>2.1.7. ファイルシステム<a class=anchor href=#overview-filesystem></a></h3><div class=paragraph><p>通常ファイルとは一次元のバイト列であり、 任意の場所から読み込み・書き込みが可能です。 カーネルは、ファイルのレコード境界を認識しませんが、 多くのプログラムは 改行 (LF) 文字を行の終りと認識します。 またこれとは異なるファイル構造を利用するアプリケーションもあります。 ファイル自身には、ファイルに関するシステム情報はまったく含まれません。 各ファイルのファイル所有者、許可属性、 使用状況などのいくつかの情報はファイルではなくファイルシステムが保持しています。</p></div><div class=paragraph><p><em>ファイル名</em>は最大 255 文字までの文字列です。 ファイル名は<em>ディレクトリ</em> と呼ばれる型のファイルに保管されます。 ディレクトリに含まれるファイルの情報は<em>ディレクトリエントリ</em>と呼ばれ、 ファイル名以外にファイルそのものへのポインタも含みます。 ディレクトリエントリには通常のファイル以外に、 他のディレクトリを参照するエントリが含まれます。 このようにしてディレクトリとファイルによる階層が形作られ、 その階層構造を<em>ファイルシステム</em>と呼びます。</p></div><div id=fig-small-fs class=imageblock><div class=content><img src=../../../images/books/design-44bsd/fig2.png alt=小規模なファイルシステムツリー></div><div class=title>図 2. 小規模なファイルシステム</div></div><div class=paragraph><p><a href=#fig-small-fs>小規模なファイルシステム</a>は小規模なファイルシステムの一例です。 ディレクトリはサブディレクトリを含むことができ、 入れ子の深さには特に制限はありません。 ファイルシステムの一貫性を保つため、 カーネルはプロセスが直接ディレクトリへ書き込むことを禁止しています。 ファイルシステムには、通常ファイル、ディレクトリ以外に、 デバイスファイルやソケットなどの他のオブジェクトへの参照も含まれます。</p></div><div class=paragraph><p>ファイルシステムは、 <em>ルートディレクトリ</em> を始点とする木構造を持っています。 ルートディレクトリは、 <em>スラッシュ</em> と呼ばれる場合もあり、斜線文字(/)で表されます。 ルートディレクトリにはファイルが含まれます。 図 2.2 の例では、 <span class=filename>usr</span> ディレクトリが含まれ、その <span class=filename>usr</span> ディレクトリには、 <span class=filename>bin</span> ディレクトリが含まれます。 <span class=filename>bin</span> ディレクトリには、通常 <span class=filename>ls</span> や <span class=filename>vi</span> をはじめとする、プログラムの実行可能コードが含まれます。</p></div><div class=paragraph><p>プロセスは、ファイルの指定を<em>パス名</em>によって行います。 パス名は、0 個以上のファイル名を斜線文字(/)で区切った文字列です。 カーネルはパス名を解釈するため、それぞれのプロセスに 2 つのパス名を関連付けます。 プロセスの<em>ルートディレクトリ</em>は、 プロセスがアクセスできるファイルシステム上で最も上位の点です。 通常、このルートディレクトリは、 ファイルシステム全体のルートディレクトリに設定されます。 斜線文字 (/) ではじまるパス名は<em>絶対パス名</em>と呼ばれ、 カーネルは、そのパス名がプロセスのルートディレクトリから 開始するものと解釈します。</p></div><div class=paragraph><p>斜線文字 (/) ではじまらないパス名は<em>相対パス名</em>と呼ばれ、 プロセスの<em>カレント作業ディレクトリ</em>を基準とした相対的なパスとして解釈されます (このディレクトリは、短縮して <em>カレントディレクトリ</em> または、 <em>作業ディレクトリ</em> とも呼ばれます)。 カレントディレクトリそのものは、 <em>ドット</em> とも呼ばれ、1 つのピリオド (<span class=filename>.</span>) で表されます。 ファイル名 <em>ドットドット</em> (<span class=filename>..</span>) は、 ディレクトリの親ディレクトリを表します。 ルートディレクトリの親ディレクトリはルートディレクトリ自身です。</p></div><div class=paragraph><p><em>chroot</em> システムコールにより、プロセスのルートディレクトリを、 <em>chdir</em> システムコールにより、カレントディレクトリを変更できます。 <em>chdir</em> はいつでも行えますが、 <em>chroot</em> の実行は、管理者特権を持つプロセスに限られます。 <em>chroot</em> は通常、システムに対するアクセス制限を課すために用いられます。</p></div><div class=paragraph><p>図 2.2 のファイルシステムにおいて、プロセスのルートディレクトリ がファイルシステムのルートディレクトリで、カレントディレクトリが <span class=filename>/usr</span> であったとします。このとき、 <span class=filename>vi</span> を参照するには、絶対パスを用いて、 <span class=filename>/usr/bin/vi</span> とも書けますし、カレントディレクトリからの相対パスを用いて、 <span class=filename>bin/vi</span> とも書けます。</p></div><div class=paragraph><p>システムのユーティリティやデータベースは、 よく知られたある決まったディレクトリに保存されます。 ファイルシステムの階層構造としてよく知られたものに、 各々のユーザの<em>ホームディレクトリ</em>があります。 たとえば、図 2.2 の <span class=filename>/usr/staff/mckusick</span> や <span class=filename>/usr/staff/karels</span> などです。 ユーザがログインすると、 シェルのカレントディレクトリはホームディレクトリに設定されます。 ユーザはホームディレクトリ内で通常ファイルの作成と同様にディレクトリも作成できるため、 複雑な階層構造を構築することも可能です。</p></div><div class=paragraph><p>ユーザからはファイルシステムが 1 つに見えますが、 システムは 1 つの仮想ファイルシステムが、 実際には異なるデバイス上の複数の物理ファイルシステムから構成されていることを認識しています。 物理ファイルシステムは、異なったデバイスにまたがることはできません。 ほとんどの場合、物理ディスクデバイスは複数の論理デバイスに分割されるため、 1 つの物理デバイス上に複数のファイルシステムを構成することもできます。 すべての絶対パス名を解決できるファイルシステムを <em>ルートファイルシステム</em>と呼び、 常に利用可能な状態になっています。 他のファイルシステムは、マウントすることができます。 マウントとは、ルートファイルシステムのディレクトリ構造の一部として統合する操作です。 ファイルシステムにマウントされたディレクトリの参照は、 そのマウントされたファイルシステムのルートディレクトリの参照へと カーネルによって透過的に変換されます。</p></div><div class=paragraph><p><em>link</em> システムコールは、既存のファイル名に、別名を与えます。 <em>リンク</em>が成功すると、 ファイルはどちらのファイル名からでもアクセスできるようになります。 ファイル名は <em>unlink</em> システムコールにより削除できます。 ファイルを参照していた最後の名前が削除されると (さらにファイルを開いていた最後のプロセスがファイルを閉じると) ファイルそのものも削除されます。</p></div><div class=paragraph><p>ファイルは<em>ディレクトリ</em>内で階層構造を持って保持されます。 ディレクトリそのものも一種のファイルですが、 ディレクトリは一般のファイルと異なり、 システムによって決められた構造を持っています。 ディレクトリは一般のファイルと同じくプロセスから読み込むことが可能ですが、 ディレクトリに変更を加えられるのはカーネルだけです。 ディレクトリは <em>mkdir</em> システムコールで作成し、 <em>rmdir</em> システムコールで削除します。 4.2BSD 以前のシステムにおける <em>mkdir</em> と <em>rmdir</em> システムコールは、一連の <em>link</em>、<em>unlink</em> システムコールの実行として実装されていました。 明示的にディレクトリの作成、 削除を行うシステムコールを新たに追加した理由は、3 つあります。</p></div><div class="olist arabic"><ol class=arabic><li><p>アトミックな動作を可能にするため。 link システムコールによる実装の場合と異なり、 システムがクラッシュした場合に ディレクトリの構造が中途半端なままになることがありません。</p></li><li><p>ネットワークファイルシステムを使用している場合には シリアライズ (操作順序の保証) を行うため、ファイルおよびディレクトリの作成、 削除はアトミックに行われる必要があります。</p></li><li><p>UNIX 以外のファイルシステム (他のパーティション上の MS-DOS ファイルシステムなど) をサポートする場合、 そのファイルシステムが link システムコールをサポートしない可能性があります。 たとえそれがディレクトリをサポートするファイルシステムであっても、 UNIX ファイルシステムとは異なり、ディレクトリをリンクとして作成、 削除しないものもあります。 そのためそのようなファイルシステムでは、 ディレクトリの作成、削除は、 明示的に要求されない限り行われません。</p></li></ol></div><div class=paragraph><p><em>chown</em> システムコールはファイルの所有者とグループを設定します。 <em>chmod</em> システムコールは、ファイルの保護モードを変更します。 これらのファイルの属性は、 <em>stat</em> システムコールをファイル名に対し実行することで読み出すことができます。 <em>fchown</em>、 <em>fchmod</em>、 <em>fstat</em> システムコールは、同様な動作をファイル名ではなくファイル記述子に対して行います。 <em>rename</em> システムコールは、ファイルに新しい名前をつけて古い名前を削除します。 ディレクトリ作成・削除操作と同じように、 <em>rename</em> システムコールはローカルファイルシステムの名前変更動作をアトミックにするため 4.2BSD で追加されました。 後に、この動作はネットワーク上の非 UNIX ファイルシステムに対して名前変更操作を行う場合に有効であることがわかりました。</p></div><div class=paragraph><p><em>truncate</em>は、 4.2BSD で追加されたファイルを任意の長さに切り詰めるシステムコールです。 このシステムコール追加の主な目的は ランダムアクセスファイルの最後をプログラムが最後にアクセスした場所に設定する、 という動作を持つ Fortran ランタイムライブラリのサポートでした。 <em>truncate</em> システムコールを使用しない場合、 ファイルの長さを縮める唯一の方法は必要な部分をコピーしたファイルを作成し、 元のファイルを削除した後にコピーしたファイルをリネームする方法です。 このアルゴリズムは遅いだけでなく、 空き容量の少ないファイルシステムでは失敗する可能性があります。</p></div><div class=paragraph><p>ファイルシステムにファイルを縮める機能が追加されると、 それはカーネルが大きな空のディレクトリを小さくする用途に使用するようになりました。 空のディレクトリを縮小すると、 ファイルの作成、 削除時にカーネルがファイルを検索する時間を短縮できるという利点があります。</p></div><div class=paragraph><p>新規に作成されたファイルには、 作成したプロセスのユーザ識別子と作成が行われたディレクトリのグループ識別子を与えられます。 ファイルの保護用に 3 レベルのアクセス制御機構が用意されています。 この 3 レベルのファイルアクセス許可は</p></div><div class="olist arabic"><ol class=arabic><li><p>ファイルを所有しているユーザ</p></li><li><p>ファイルを所有しているグループ</p></li><li><p>他のすべて</p></li></ol></div><div class=paragraph><p>に対して設定することができます。 それぞれのアクセスレベルは、さらに 読み取り許可、書き込み許可、実行許可に分けられています。</p></div><div class=paragraph><p>ファイルは作成時に長さが 0 であり、 書き込みされるにつれて長くなっていきます。 システムはファイルが開かれると、 対応する記述子の現在位置を指定するポインタを保持します。 このポインタはファイル内をランダムアクセスするように動かすことが可能です。 <em>fork</em> や <em>dup</em> システムコールによりファイル記述子を共有するプロセス間では、 この現在位置ポインタは共有されます。 別々の <em>open</em> システムコールによって 作成されたファイル記述子は、独立した現在位置ポインタを持ちます。 ファイルは<em>穴</em>を持つことがあります。 穴とはファイルの一次元構造の中で、 データが一度も書き込まれたことのない空の部分です。 ファイルの最後尾より後にポインタを動かし書き込みを行うことで、 ファイルに穴をつくることができます。 読み込まれた場合、穴は 0 の値をもつバイトとして扱われます。</p></div><div class=paragraph><p>初期の UNIX システムではファイル名に 14 文字以内という制限があり、 よく問題となっていました。 たとえば、ユーザは当然ながら長く説明的なファイル名を付けたいと望みますし、 <span class=filename>basename.extension</span> という慣用的なファイル命名規則を考えると、 extension (C のソースファイルの <code>.c</code>、 中間バイナリオブジェクトファイルの <code>.o</code> というように、ファイルの種類を示す部分) に 1 から 3 文字必要ですから、 basename に付けられる文字数は 10 から 12 しか残っていません。 ソースコード制御システムやエディタは通常、 独自の目的のためにさらに 2 文字をファイル名の前後に付加しますので、 実際に使えるのは、8 から 10 文字になります。 basename として英語を一単語 (たとえば multiplexer) 使うだけで、 簡単に 10 から 12 文字になってしまうでしょう。</p></div><div class=paragraph><p>このような制限を守るのは不可能ではありませんが、 危険な場合もあります。 他の UNIX システムでは、 より長いファイル名を受け付けるものの実際にファイルを作成する時点でファイル名を <em>切り詰める</em>ものがあるからです。 C のソースコードファイル <span class=filename>multiplexer.c</span> (すでに 13 文字です) のソースコード制御ファイルは、 頭に <code>s.</code> が付加されて <span class=filename>s.multiplexer</span> となります。 このファイルは、C ソースの文書の <code>troff</code> ソースファイル <span class=filename>multiplexer.ms</span> のソースコード制御ファイルと区別がつきません。 ソースコード制御システムはこの問題に対して警告を出さないため、 これらの 2 つのファイル内容の取り違えは容易に発生します。 注意深くコーディングすればこのような問題は避けられますが、 4.2BSD でロングファイルネームが導入されたことで この問題は実質的になくなりました。</p></div></div><div class=sect2><h3 id=overview-filestore>2.1.8. ファイル記録機構<a class=anchor href=#overview-filestore></a></h3><div class=paragraph><p>ローカルファイルシステムに対する操作には二種類あります。 まず、ローカルファイルシステムすべてに共通して 階層化されたファイルのネーミング、ロック、割り当て、 属性管理、保護といった、データの記録方法とは独立した機能です。 4.4BSD はこれらの機能を提供する単一の実装を備えています。</p></div><div class=paragraph><p>もう一つは記録媒体上におけるデータ構成と管理です。 ファイル内容を記録媒体上に配置するのはファイル記録機構の役割であり、 4.4BSD は 3 種類の異なるファイル配置法に対応しています。</p></div><div class=ulist><ul><li><p>伝統的な Berkeley Fast Filesystem</p></li><li><p>Sprite という OS の設計に由来する ログ構造化ファイルシステム <a href=#biblio-rosenblum>Rosenblum & Ousterhout, 1992</a></p></li><li><p>メモリベースのファイルシステム</p></li></ul></div><div class=paragraph><p>これらのファイル記録機構の構成はまったく異なるものですが、 それを使用するプロセスからは違いを意識することはありません。</p></div><div class=paragraph><p>Fast Filesystem は、データをシリンダグループという単位で構成します。 ファイルシステム階層の配置から考えて同時にアクセスされやすいと考えられるファイルは、 同じシリンダグループに記録され、同時にアクセスされる可能性の低いファイルは 異なるシリンダグループに記録されます。 この記録機構では以上のように、複数のファイルが同時に書き込まれたとしても、 記録される場所はディスクのまったく違う場所になる可能性があるのです。</p></div><div class=paragraph><p>ログ構造化ファイルシステムは、データをログという形で構成します。 ある時点で記録されたデータはすべて一つに集められ、 同じディスクの場所に書き込まれます。 データが上書きされることは絶対にありません。 ファイルの更新は、ファイルを上書きする代わりに 新しいファイルを書き込んでそのファイルを置き換えることによって行なわれます。 ファイルシステムに空き容量がなくなり新たに空き容量が必要になった場合は ゴミ集め (garbage-collection) プロセスが実行され、 古いファイルが再利用されます。</p></div><div class=paragraph><p>メモリベースのファイルシステムは、 データを仮想メモリに記録するように設計されたものです。 これは <span class=filename>/tmp</span> のように高速アクセスが必要で、 永続的でないファイルシステムに使われます。 メモリベースファイルシステムの目標は、 仮想メモリ資源の利用量を可能な限り最小限に保つことにあります。</p></div></div><div class=sect2><h3 id=overview-nfs>2.1.9. ネットワークファイルシステム<a class=anchor href=#overview-nfs></a></h3><div class=paragraph><p>当初、ネットワーク通信はデータをあるマシンから 他のマシンへ転送するために用いられていましたが、 のちにそれは、ユーザが離れたマシンへログイン可能な形に発展しました。 次に期待されたのはユーザがデータを取り行くのではなく、 ユーザの元にデータがやってくるようにすることでした。 そのために生まれたのがネットワークファイルシステムです。 ローカルで作業しているユーザはキー入力時にネットワークの遅れを感じず、 より応答性の良い環境を手に入れたのです。</p></div><div class=paragraph><p>ファイルシステムをローカルマシンに持ってくることは 初期のサーバ-クライアント型アプリケーションの中で主要なもののひとつでした。 <em>サーバ</em> は 1 つもしくはそれ以上のファイルシステムを エクスポートするリモートのマシンです。 <em>クライアント</em> はそのファイルシステムをインポートするローカルのマシンです。 ローカルのクライアントから見ると、 リモートでマウントされたファイルシステムは ローカルにマウントされた他のファイルシステムのように ファイルツリーの名前空間に現れます。 ローカルのクライアントは リモートのファイルシステム上にディレクトリを変えたり、 ローカルのファイルシステム上でするのとまったく同じように リモートのファイルシステムで読み書きをしたり、 バイナリを実行したりできます。</p></div><div class=paragraph><p>ローカルのクライアントが リモートのファイルシステム上で操作すると、 その操作要求がひとまとめにされてサーバに送られます。 サーバは要求された操作を行い、 クライアントから要求された情報、もしくは、 なぜその要求が拒絶されたかを示すエラーを返します。 適切な性能を得るには、 クライアントは頻繁にアクセスされたデータをキャッシュしなければなりません。 リモートファイルシステムの複雑さは、 サーバと多くのクライアントの間のキャッシュの一貫性を維持することにあります。</p></div><div class=paragraph><p>長期にわたって数多くのリモートファイルシステムプロトコルが開発されてきましたが、 UNIX システムにおいて最も普及しているものは、 そのプロトコルと実装の大部分が Sun Microsystems によって行なわれた ネットワークファイルシステム (NFS) です。 実装はプロトコル規格から独立して行われましたが、 4.4BSD カーネルは NFS プロトコルをサポートしています <a href=#biblio-macklem>Macklem, 1994</a>。 NFS プロトコルについては 9 章で説明しています。</p></div></div><div class=sect2><h3 id=overview-terminal>2.1.10. 端末<a class=anchor href=#overview-terminal></a></h3><div class=paragraph><p>端末は、標準的なシステム I/O 操作はもちろんのこと、 入力文字の編集や出力のディレイの制御をするための端末固有の操作をひととおり サポートしています。 一番低いレベルにあるのは、ハードウェア端末ポートを制御する端末デバイスドライバです。 端末入力は、たとえばボーレートのような基礎的な通信特性や、 パリティ検査のようなソフトウェアで制御可能なパラメータ類に 従って扱われます。</p></div><div class=paragraph><p>端末デバイスドライバの上の層には、 文字処理をどの程度行なうかを定義している ラインディシプリン (line discipline; 回線端末制御) と呼ばれるものがあります。 対話的なログインをするためにポートが 用いられるときにはデフォルトのラインディシプリンが選択され、 そのラインディシプリンは<em>カノニカルモード</em>で動作します。 これは、入力が標準的な行指向編集機能を提供するように処理され、 入力自体を行単位の処理で表現するモードです。</p></div><div class=paragraph><p>スクリーンエディタや、他のコンピュータと通信をするプログラム (訳注: telnet など) は、普通<em>非カノニカルモード</em> (<em>raw モード<em>や</em>キャラクタごとのモード (character-at-a-time mode)</em> などとも呼ばれます) で動作します。 これらのモードでは、入力はそのまますぐに読み込み側の プロセスへと渡されます。 すべての特殊文字入力の処理は無効化されていて、 削除やその他の行編集処理は行なわれず、 すべての文字はその端末から読み込もうとしているプロセスへと渡されます。</p></div><div class=paragraph><p>端末は、この二つの両極端のモードの中間の多くの組み合わせで 設定することが可能です。 たとえば、あるスクリーンエディタがユーザからの割り込みを非同期的に 受け入れたい場合に、シグナルを生成する文字や出力の流量制御を許可したまま、 それ以外を非カノニカルモードで動かして、これらの文字以外の文字を まったく解釈しないまま渡す、ということが可能です。</p></div><div class=paragraph><p>出力では、端末処理は次のような単純な整形サービスを提供しています。</p></div><div class=ulist><ul><li><p>ラインフィードをキャリッジリターンとラインフィードの並びへと変換</p></li><li><p>特定の標準的な制御文字の後にディレイを挿入</p></li><li><p>タブ文字の展開</p></li><li><p>エコーされた非表示アスキー文字を <code>^C</code> (すなわち、アスキーのキャレット文字 の後に、そのキャラクタの値をアスキーの <code>@</code> 文字からのオフセットとした アスキー文字) という二文字の並びとして表示</p></li></ul></div><div class=paragraph><p>これらの整形機能は、コントロールリクエストを使ってそれぞれ独立に 無効化することが可能です。</p></div></div><div class=sect2><h3 id=overview-ipc>2.1.11. プロセス間通信 (IPC)<a class=anchor href=#overview-ipc></a></h3><div class=paragraph><p>4.4BSD のプロセス間通信 (IPC) は、<em>コミュニケーション ドメイン</em>内で働くようになっています。現在サポートされて いるドメインには、同じマシン上で実行している複数のプロセス間 での通信用の<em>ローカルドメイン</em>、 TCP/IP プロトコルスイート用の (おそらく the Internet 内) <em>インターネットドメイン</em>、 ISO/OSI プロトコルファミリでの通信を行なうことが必要なサイト間通信用の ISO/OSI プロトコルファミリ、 XEROX Network Systems (XNS) を使用したプロセス間通信用の <em>XNS ドメイン</em>が含まれています。</p></div><div class=paragraph><p>ドメイン内では、<em>ソケット</em>として知られ ている通信終端間で通信が行なわれます。 2.6 節で説明しているように、 <em>socket</em> システムコールはソケットを生成し、その記述子を返します。 他の IPC システムコールについては 11 章で解説します。 各ソケットは、通信セマンティクスを定義した型を持ちます。 このセマンティクスには信頼性、順序、メッセージの重複防止が 含まれています。</p></div><div class=paragraph><p>各ソケットは、<em>通信プロトコル</em> と関連しています。 ここでのプロトコルは、通信相手のソケットの型に従って そのソケットで要求されているセマンティクスを提供します。 アプリケーションは、ソケットを生成する際に特定のプロトコルを 要求することができますし、また、そのシステムは、将来生成される ソケットの型にふさわしいプロトコルを選択するようにすることも 可能です。</p></div><div class=paragraph><p>ソケットは、そのソケットと関連づけされた (バインドされた) アドレスを持つことができます。 ソケットアドレスの形式と意味は、そのソケットが生成された コミュニケーションドメインに依存します。 ローカルドメインにおいてソケットに名前をバインドすると、 そのファイルシステムにおいてファイルが生成されます。</p></div><div class=paragraph><p>ソケットを通じて送受信される通常のデータは型づけされていません。 データ表現については、プロセス間通信機能の最上位に位置するライブラリに責任があります。 通常データの配送に加えて、コミュニケーションドメインは <em>access rights</em> という特別な型のデータの 送受信をサポートすることができます。 たとえばローカルドメインはプロセス間で記述子を渡すために、 この機能を使用します。</p></div><div class=paragraph><p>4.2BSD より前の UNIX におけるネットワーク機能の実装は、 大抵キャラクタデバイスインタフェースをオーバロードさせることで 動作していました。 ソケットインタフェースの目的の一つは、単純なプログラムが ストリーム型の通信を変更せずに動作するようにすることです。 そのようなプログラムは、<em>read</em> と <em>write</em> のシステムコールが変更されなければ 動作します。 当然、元のインタフェースがそのまま残されれば、 ストリーム型のソケット上で動作し続けるようになります。 <em>send</em> の各呼び出しで指定しなければならない 送信先アドレスを持つデータグラムを送信するような、 より複雑なソケット用に新しいインタフェースが追加されました。</p></div><div class=paragraph><p>もう一つの利点は、この新しいインタフェースは移植性が 非常に良いということです。 バークレーから入手できたテストリリースのすぐ後で、 ソケットインタフェースは UNIX ベンダによって System III に移植されました (しかし、AT&amp;T は System V Release 4 のリリースまでソケットインタフェースをサポートせず、 その代わりに Eighth Edition のストリーム機構を使用する ことを決めました)。 ソケットインタフェースはまた、Excelan 社や Interlan 社のような ベンダによって多くのイーサネットカードで動作するように移植され、 マシンが小さすぎてメインプロセッサ中でネットワーク通信を動作 させることができない PC 市場に売り出されました。 ごく最近では、Microsoft 社の Windows 用の Winsock ネットワークインタフェースの基盤として ソケットインタフェースが使われています。</p></div></div><div class=sect2><h3 id=overview-network-communication>2.1.12. ネットワーク通信<a class=anchor href=#overview-network-communication></a></h3><div class=paragraph><p><em>ソケット</em> IPC 機構が対応している ネットワークドメインのいくつかは、 ネットワークプロトコルへのアクセスを提供しています。 これらのプロトコルは理論上、 カーネルのソケットソフトウェアよりも下の層にある 別のソフトウェアとして実装されています。 カーネルは、バッファ管理、メッセージ配送、 各プロトコルへの汎用インタフェースを提供し、 また、さまざまなネットワークプロトコルを使用するための ネットワークインタフェースドライバへのインタフェースなど、 多くの付随サービスを提供します。</p></div><div class=paragraph><p>4.2BSD が実装された時点ではさまざまなネットワークプロトコルが 使用され、また開発中の段階にありました。 それらはそれぞれ固有の強みと弱みを持っており、 明らかに優れたプロトコルやプロトコルスイートというものは存在しませんでした。 4.2BSD は複数のプロトコルに対応することで、 バークレー校の環境で利用可能だったさまざまなマシン間での 資源の共有や、相互運用の提供を可能にしていました。 またこの複数プロトコルへの対応は、 将来的な変更に備えて設計されていました。 今日利用されている 10-100Mbps のイーサネット用のプロトコルは、 将来の 1-10Gbps 光ファイバネットワークに対して、 おそらく十分なものではないでしょう。 そのため、ネットワーク通信レイヤは複数のプロトコルに対応できるように 設計されています。 新しいプロトコルがカーネルに追加されても、 既存のプロトコルがその影響を受けることはまったくありません。 新しいアプリケーションは新しいネットワークプロトコルで動作し、 一方で既存のアプリケーションもまた、 それと同じ物理ネットワーク上で今までどおりのプロトコルを 利用し続けることが可能です。</p></div></div><div class=sect2><h3 id=overview-network-implementation>2.1.13. ネットワーク実装<a class=anchor href=#overview-network-implementation></a></h3><div class=paragraph><p>4.2BSD で実装された最初のプロトコルスイートは DARPA の Transmission Control Protocol/Internet Protocol (TCP/IP) でした。 CSRG は、ソケット IPC フレームワークに組み込む最初のネットワークとして TCP/IP を選択しました。その理由は、4.1BSD ベースの実装が DARPA がスポンサーとなっていた Bolt、Beranek、Newman (BBN) におけるプロジェクトからパブリックに入手可能だったからです。 それは大きな選択でした。 このプロトコルスイートが非常に広く利用されたのは、 主に 4.2BSD でのこの実装が理由となっています。 TCP/IP の実装に対するその後の性能と能力の改善も広く採用されました。 TCP/IP の実装については、13 章で詳細に解説しています。</p></div><div class=paragraph><p>4.3BSD のリリースでは、メリーランド大学とコーネル大学で部分的に 開発された Xerox Network Systems (XNS) プロトコルスイートが追加されました。 このプロトコルスイートは、TCP/IP を使用して通信できない孤立したマシンと 通信するのに必要でした。</p></div><div class=paragraph><p>4.4BSD のリリースでは、近頃米国内外で増加している ISO プロトコルスイートが追加されました。 ISO プロトコル群のために多少異なるセマンティクスを定義したので、 これらのセマンティクスに適合させるため ソケットインタフェースにいくつかの小さな変更が必要となりました。 その変更は、 他の既存プロトコルのクライアントには分からないようになされています。 ISO プロトコル群用に 4.3BSD カーネルで提供された 2 レベルルーティングテーブルに対する大規模な追加も必要でした。 4.4BSD で大きく拡張されたルーティング機能は、 可変長アドレスと ネットワークマスクを持つ任意のレベルのルーティングが含まれています。</p></div></div><div class=sect2><h3 id=overview-operation>2.1.14. システム運用<a class=anchor href=#overview-operation></a></h3><div class=paragraph><p>ブートストラップ機構はシステムを起動するために利用されます。 まず最初に、4.4BSD カーネルは CPU のメインメモリに読み込まれます。 カーネルが読み込まれると、 特定の状態へハードウェアを設定する初期化フェーズに移行します。 次に、カーネルは自動設定 (autoconfiguration) を行ないます。 これは CPU に接続された周辺機器の検出と設定を行なう過程です。 システムは最初、ディスクチェック、アカウント処理、 quota チェックを行なうスタートアップスクリプトを シングルユーザモードで実行します。 スタートアップスクリプトは最後に一般的に利用されるシステムサービス群を起動し、 システムを完全なマルチユーザモードに移行させます。</p></div><div class=paragraph><p>マルチユーザモードでは、プロセスが ユーザがアクセスできるように設定された端末回線や ネットワークポート上でのログイン要求を待ちます。 ログイン要求が検出されるとログインプロセスが生成され、 ユーザの確認処理が行われます。 そしてユーザの確認処理が成功すると、 そのユーザに対して、 他のプロセスを実行できるようにするためのログインシェルが生成されます。</p></div></div><div class=sect2><h3 id=references>参考文献<a class=anchor href=#references></a></h3><div class=paragraph><p><a id=biblio-accetta></a>Accetta et al, 1986 Mach: A New Kernel Foundation for UNIX Development" M.Accetta R.Baron W.Bolosky D.Golub R.Rashid A.Tevanian M.Young 93-113 USENIX Association Conference Proceedings USENIX Association June 1986</p></div><div class=paragraph><p><a id=biblio-cheriton></a>Cheriton, 1988 The V Distributed System D. R.Cheriton 314-333 Comm ACM, 31, 3 March 1988</p></div><div class=paragraph><p><a id=biblio-ewens></a>Ewens et al, 1985 Tunis: A Distributed Multiprocessor Operating System P.Ewens D. R.Blythe M.Funkenhauser R. C.Holt 247-254 USENIX Assocation Conference Proceedings USENIX Association June 1985</p></div><div class=paragraph><p><a id=biblio-gingell></a>Gingell et al, 1987 Virtual Memory Architecture in SunOS R.Gingell J.Moran W.Shannon 81-94 USENIX Association Conference Proceedings USENIX Association June 1987</p></div><div class=paragraph><p><a id=biblio-kernighan></a>Kernighan & Pike, 1984 The UNIX Programming Environment B. W.Kernighan R.Pike Prentice-Hall Englewood Cliffs NJ 1984</p></div><div class=paragraph><p><a id=biblio-macklem></a>Macklem, 1994 The 4.4BSD NFS Implementation R.Macklem 6:1-14 4.4BSD System Manager’s Manual O’Reilly & Associates, Inc. Sebastopol CA 1994</p></div><div class=paragraph><p><a id=biblio-mckusick-2></a>McKusick & Karels, 1988 Design of a General Purpose Memory Allocator for the 4.3BSD UNIX Kernel M. K.McKusick M. J.Karels 295-304 USENIX Assocation Conference Proceedings USENIX Assocation June 1998</p></div><div class=paragraph><p><a id=biblio-mckusick-1></a>McKusick et al, 1994 Berkeley Software Architecture Manual, 4.4BSD Edition M. K.McKusick M. J.Karels S. J.Leffler W. N.Joy R. S.Faber 5:1-42 4.4BSD Programmer’s Supplementary Documents O’Reilly & Associates, Inc. Sebastopol CA 1994</p></div><div class=paragraph><p><a id=biblio-ritchie></a>Ritchie, 1988 Early Kernel Design private communication D. M.Ritchie March 1988</p></div><div class=paragraph><p><a id=biblio-rosenblum></a>Rosenblum & Ousterhout, 1992 The Design and Implementation of a Log-Structured File System M.Rosenblum K.Ousterhout 26-52 ACM Transactions on Computer Systems, 10, 1 Association for Computing Machinery February 1992</p></div><div class=paragraph><p><a id=biblio-rozier></a>Rozier et al, 1988 Chorus Distributed Operating Systems M.Rozier V.Abrossimov F.Armand I.Boule M.Gien M.Guillemont F.Herrmann C.Kaiser S.Langlois P.Leonard W.Neuhauser 305-370 USENIX Computing Systems, 1, 4 Fall 1988</p></div><div class=paragraph><p><a id=biblio-tevanian></a>Tevanian, 1987 Architecture-Independent Virtual Memory Management for Parallel and Distributed Environments: The Mach Approach Technical Report CMU-CS-88-106, A.Tevanian Department of Computer Science, Carnegie-Mellon University Pittsburgh PA December 1987</p></div></div><div class=sect2><h3 id=jacknowledgement>付録 A: 日本語化について<a class=anchor href=#jacknowledgement></a></h3><div class=paragraph><p>The Design and Implementation of 4.4BSD Operating System Chapter 2 の日本語化は、原著の出版元である Addison-Weslay、 翻訳出版権を保有する Pearson Education Japan の協力を得て、 FreeBSD 日本語ドキュメンテーションプロジェクト (FreeBSD doc-jp) によって行なわれました。 日本語版について何かお気付きの点がありましたら 日本語ドキュメンテーションプロジェクト <a href=mailto:doc-jp@jp.FreeBSD.org>doc-jp@jp.FreeBSD.org</a> までご連絡ください。</p></div><div class=paragraph><p>この日本語版の著作権は、原著者、原著の出版元である Addison-Weslay および日本語版の翻訳出版権を保有する Pearson Education Japan に帰属します。そのため、 この文書をこれらの著作権保有者の明示的な許可なく複製、 再配布することは禁止されています。</p></div><div class=paragraph><p>2001 年 5 月 5 日にスタートした日本語化作業には、 さまざまな方々が翻訳に参加されました。 FreeBSD doc-jp では、FreeBSD 関連文書の日本語版を作成する作業を精力的に続けています。 この作業に協力したいと思われる方は、 ぜひ<a href=http://www.jp.FreeBSD.org/doc-jp/>FreeBSD 日本語ドキュメンテーションプロジェクトのページ</a>をご覧の上 doc-jp へご参加ください。</p></div></div><div class=sect2><h3 id=_翻訳者>翻訳者<a class=anchor href=#_翻訳者></a></h3><div class=ulist><ul><li><p>杉村 貴士 <a href=mailto:sugimura@jp.FreeBSD.org>sugimura@jp.FreeBSD.org</a> (2.1, 2.2 節)</p></li><li><p>IKENO Naoki <a href=mailto:nao@mc.kcom.ne.jp>nao@mc.kcom.ne.jp</a> (2.3 節)</p></li><li><p>田畑 喜晃 <a href=mailto:ytabata@tkf.att.ne.jp>ytabata@tkf.att.ne.jp</a> (2.4 節)</p></li><li><p>Atsuto <a href=mailto:atsuto@guitar.interq.or.jp>atsuto@guitar.interq.or.jp</a> (2.5 節)</p></li><li><p>はらだきろう<a href=mailto:kiroh@jp.FreeBSD.org>kiroh@jp.FreeBSD.org</a> (2.6, 2.7 節)</p></li><li><p>高田 知樹 <a href=mailto:tomoki@leergirls.org>tomoki@leergirls.org</a> (2.8 節)</p></li><li><p>倉品 英行 <a href=mailto:rushani@bl.mmtr.or.jp>rushani@bl.mmtr.or.jp</a> (2.9 節)</p></li><li><p>塩崎 拓也 <a href=mailto:tshiozak@FreeBSD.org>tshiozak@FreeBSD.org</a> (2.10 節)</p></li><li><p>こが よういちろう<a href=mailto:y-koga@jp.FreeBSD.org>y-koga@jp.FreeBSD.org</a> (2.11, 2.13 節)</p></li><li><p>森 直之<a href=mailto:mori@jp.FreeBSD.org>mori@jp.FreeBSD.org</a> (2.12 節)</p></li><li><p>坂井 順行 <a href=mailto:sakai@lac.co.jp>sakai@lac.co.jp</a> (2.14 節)</p></li><li><p>内川 喜章 <a href=mailto:yoshiaki@kt.rim.or.jp>yoshiaki@kt.rim.or.jp</a> (査読)</p></li><li><p>日野 浩志 <a href=mailto:hino@ccm.cl.nec.co.jp>hino@ccm.cl.nec.co.jp</a> (査読)</p></li><li><p>山口 雅信 <a href=mailto:yamagu-m@titan.ocn.ne.jp>yamagu-m@titan.ocn.ne.jp</a> (翻訳提供)</p></li></ul></div></div></div></div></div><hr><div class=last-modified><p><strong>最終更新日</strong>: 2021年12月11日 by <a href="https://cgit.freebsd.org/doc/commit/?id=2b027dd017" target=_blank>Sergio Carlavilla Delgado</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目次</h3><nav id=TableOfContents><ul><li><a href=#overview>2.1. 4.4BSD の設計の概要</a><ul><li><a href=#overview-facilities>2.1.1. 4.4BSD の機能とカーネル</a></li><li><a href=#overview-kernel-organization>2.1.2. カーネルの構成</a></li><li><a href=#overview-kernel-service>2.1.3. カーネル サービス</a></li><li><a href=#overview-process-management>2.1.4. プロセス管理</a></li><li><a href=#overview-memory-management>2.1.5. メモリ管理</a></li><li><a href=#overview-io-system>2.1.6. I/O システム</a></li><li><a href=#overview-filesystem>2.1.7. ファイルシステム</a></li><li><a href=#overview-filestore>2.1.8. ファイル記録機構</a></li><li><a href=#overview-nfs>2.1.9. ネットワークファイルシステム</a></li><li><a href=#overview-terminal>2.1.10. 端末</a></li><li><a href=#overview-ipc>2.1.11. プロセス間通信 (IPC)</a></li><li><a href=#overview-network-communication>2.1.12. ネットワーク通信</a></li><li><a href=#overview-network-implementation>2.1.13. ネットワーク実装</a></li><li><a href=#overview-operation>2.1.14. システム運用</a></li><li><a href=#references>参考文献</a></li><li><a href=#jacknowledgement>付録 A: 日本語化について</a></li><li><a href=#_翻訳者>翻訳者</a></li></ul></li></ul></nav><hr><div class=resources><h3>リソース</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="PDF 版のダウンロード"></i><a href=https://download.freebsd.org/doc/ja/books/design-44bsd/design-44bsd_ja.pdf>PDF 版のダウンロード</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/ja/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/ja/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>日本語</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/ja class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/ja/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>