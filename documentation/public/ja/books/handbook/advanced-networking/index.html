<!doctype html><html class=theme-light lang=ja><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/><title>第20章 高度なネットワーク | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="第20章 高度なネットワーク"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="ja"><meta property="og:url" content="https://docs.freebsd.org/ja/books/handbook/advanced-networking/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/ja\/books\/handbook\/advanced-networking\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/ja>Documentation portal</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/ja/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/ja/books>Books</a></li><li><a href=https://docs.freebsd.org/ja/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/ja/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=ja>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/preface/>前書き</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/preface/#preface-audience>想定している読者</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/preface/#preface-changes-from3>第 3 版からの変更</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/preface/#preface-changes-from2>第 2 版 (2004) からの変更</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/preface/#preface-changes>第 1 版 (2001) からの変更</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/preface/#preface-overview>この文書の構成</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/preface/#preface-conv>この文書で用いられている表記法</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/preface/#preface-acknowledgements>謝辞</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/parti/>パートI. 導入</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/introduction/>第1章 はじめに</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/introduction/#introduction-synopsis>1.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/introduction/#nutshell>1.2. FreeBSD へようこそ!</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/introduction/#history>1.3. FreeBSD プロジェクトについて</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/>第2章 FreeBSD のインストール</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. 最小ハードウェア要件</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/#bsdinstall-pre>2.3. インストール前に行う作業</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/#bsdinstall-start>2.4. インストールの開始</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/#using-bsdinstall>2.5. bsdinstall の使用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. ディスク領域の割り当て</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. 配布ファイルのダウンロード</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/#bsdinstall-post>2.8. ネットワークインターフェース、アカウント、タイムゾーン、 サービスおよびセキュリティオプションの設定</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.9. トラブルシューティング</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bsdinstall/#using-live-cd>2.10. Live CD を使う</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/basics/>第3章 FreeBSD の基礎知識</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#basics-synopsis>3.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#consoles>3.2. 仮想コンソールと端末</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#users-synopsis>3.3. ユーザと基本的なアカウント管理</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#permissions>3.4. 許可属性</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#dirstructure>3.5. ディレクトリ構造</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#disk-organization>3.6. ディスク構成</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#mount-unmount>3.7. ファイルシステムのマウントとアンマウント</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#basics-processes>3.8. プロセスおよびデーモン</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#shells>3.9. シェル</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#editors>3.10. テキストエディタ</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#basics-devices>3.11. デバイスとデバイスノード</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/basics/#basics-more-information>3.12. マニュアルページ</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/ports/>第4章 アプリケーションのインストール - packages と ports</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/ports/#ports-synopsis>4.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ports/#ports-overview>4.2. ソフトウェアのインストール</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ports/#ports-finding-applications>4.3. ソフトウェアの探し方</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ports/#pkgng-intro>4.4. pkg によるバイナリ package の管理</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ports/#ports-using>4.5. Ports Collection の利用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ports/#ports-poudriere>4.6. Poudriere を用いた package の構築</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ports/#ports-nextsteps>4.7. インストール後の作業</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ports/#ports-broken>4.8. うまく動作しない ports に遭遇した場合には</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/x11/>第5章 X Window System</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/x11/#x11-synopsis>5.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/x11/#x-understanding>5.2. 用語の説明</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/x11/#x-install>5.3. Xorg のインストール</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/x11/#x-config>5.4. Xorg の設定</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/x11/#x-fonts>5.5. Xorg でのフォントの使用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/x11/#x-xdm>5.6. X ディスプレイマネージャ</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/x11/#x11-wm>5.7. デスクトップ環境</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/x11/#x-compiz-fusion>5.8. Compiz Fusion のインストール</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/x11/#x11-troubleshooting>5.9. トラブルシューティング</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/partii/>パートII. 日々の生活</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/desktop/>第6章 デスクトップアプリケーション</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/desktop/#desktop-synopsis>6.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/desktop/#desktop-browsers>6.2. ブラウザ</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/desktop/#desktop-productivity>6.3. 生産的なアプリケーション</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/desktop/#desktop-viewers>6.4. ドキュメントビューア</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/desktop/#desktop-finance>6.5. 財務管理ソフトウェア</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/multimedia/>第7章 マルチメディア</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/multimedia/#multimedia-synopsis>7.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/multimedia/#sound-setup>7.2. サウンドカードの設定</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/multimedia/#sound-mp3>7.3. MP3 オーディオ</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/multimedia/#video-playback>7.4. ビデオ再生</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/multimedia/#tvcard>7.5. TV カードの設定</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/multimedia/#scanners>7.7. 画像スキャナ</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig/>第8章 FreeBSD カーネルのコンフィグレーション</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. なぜカスタムカーネルを作るか?</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig/#kernelconfig-devices>8.3. システムのハードウェアについて知る</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig/#kernelconfig-config>8.4. コンフィグレーションファイル</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig/#kernelconfig-building>8.5. カスタムカーネルの構築とインストール</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. 問題が起きた場合には</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/printing/>第9章 プリンタの利用</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/printing/#printing-synopsis>9.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/printing/#printing-intro-spooler>9.2. はじめに</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/printing/#printing-intro-setup>9.3. 基本的な設定</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/printing/#printing-advanced>9.4. プリンタ設定上級編</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/printing/#printing-using>9.5. プリンタを使う</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/printing/#printing-lpd-alternatives>9.6. 標準スプーラの代替品</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/printing/#printing-troubleshooting>9.7. トラブルシューティング</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/linuxemu/>第10章 Linux® バイナリ互換機能</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/linuxemu/#linuxemu-synopsis>10.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Linux® バイナリ互換機能の設定</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/linuxemu/#linuxemu-advanced>10.3. 高度なトピックス</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/partiii/>パートIII. システム管理</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/config/>第11章 設定とチューニング</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/config/#_この章では>11.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/config/#configtuning-core-configuration>11.2. 中核となる設定</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/config/#configtuning-appconfig>11.3. アプリケーションの設定</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/config/#configtuning-starting-services>11.4. サービスの起動</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/config/#configtuning-virtual-hosts>11.5. バーチャルホスト</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/config/#configtuning-configfiles>11.6. 設定ファイル</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/config/#configtuning-sysctl>11.7. sysctl によるチューニング</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/config/#configtuning-disk>11.8. ディスクのチューニング</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/config/#configtuning-kernel-limits>11.9. Kernel 制限のチューニング</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/boot/>第12章 FreeBSD の起動のプロセス</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/boot/#boot-synopsis>12.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/boot/#boot-introduction>12.2. FreeBSD の起動プロセス</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/boot/#device-hints>12.3. Device Hints</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/boot/#boot-shutdown>12.4. シャットダウン動作</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/security/>第13章 セキュリティ</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#security-synopsis>13.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#security-intro>13.2. はじめに</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#one-time-passwords>13.3. ワンタイムパスワード</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#tcpwrappers>13.4. TCP Wrappers</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#kerberos5>13.5. Kerberos5</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#ipsec>13.7. VPN over IPsec</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#fs-acl>13.9. ファイルシステムアクセス制御リスト (ACL)</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#security-portaudit>13.10. サードパーティ製ソフトウェアのセキュリティ問題を監視する</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#security-advisories>13.11. FreeBSD セキュリティ勧告</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#security-accounting>13.12. プロセスアカウンティング</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/security/#security-resourcelimits>13.13. リソースの制限</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/disks/>第14章 ストレージ</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#disks-synopsis>14.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#disk-naming>14.2. デバイス名</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#disks-adding>14.3. ディスクの追加</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#raid>14.4. RAID</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#creating-cds>14.5. 光メディア (CD & DVD) の作成と使用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#floppies>14.6. フロッピーディスクの作成と使用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#backups-tapebackups>14.7. データテープの作成と使用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#backups-floppybackups>14.8. フロッピーディスクへのバックアップ</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#backup-basics>14.9. バックアップの基本</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#disks-virtual>14.10. ネットワーク、メモリ、そしてファイルベースのファイルシステム</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#snapshots>14.11. ファイルシステムのスナップショット</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#quotas>14.12. ファイルシステムクォータ</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/disks/#disks-encrypting>14.13. ディスクパーティションの暗号化</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/l10n/>第15章 地域化 (localization) - i18n/L10n の利用と設定</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/l10n/#l10n-synopsis>15.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/l10n/#using-localization>15.2. 地域化の利用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/l10n/#l10n-compiling>15.3. 国際化 (i18n) に対応したアプリケーションを見つける</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/l10n/#lang-setup>15.4. 特定の言語にロケールを設定する</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/cutting-edge/>第16章 FreeBSD のアップデートとアップグレード</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/cutting-edge/#updating-upgrading-synopsis>16.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>16.2. FreeBSD Update</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/cutting-edge/#updating-bootcode>16.3. ブートコードのアップデート</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/cutting-edge/#updating-upgrading-documentation>16.4. ドキュメントのアップデート</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/cutting-edge/#current-stable>16.5. 開発ブランチを追いかける</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/cutting-edge/#makeworld>16.6. ソースを用いた FreeBSD のアップデート</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/cutting-edge/#small-lan>16.7. 複数のマシンで追いかける</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/partiv/>パートIV. ネットワーク通信</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/serialcomms/>第17章 シリアル通信</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/serialcomms/#serial-synopsis>17.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/serialcomms/#serial>17.2. はじめに</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/serialcomms/#term>17.3. シリアル端末</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/serialcomms/#dialup>17.4. ダイアルインサービス</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/serialcomms/#dialout>17.5. ダイアルアウトサービス</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/serialcomms/#serialconsole-setup>17.6. シリアルコンソールの設定</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/ppp-and-slip/>第18章 PPP と SLIP</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/ppp-and-slip/#_この章では>18.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ppp-and-slip/#userppp>18.2. ユーザ ppp の利用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ppp-and-slip/#ppp>18.3. カーネル PPP の利用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ppp-and-slip/#pppoe>18.4. PPP オーバイーサネット (PPPoE) の利用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/ppp-and-slip/#slip>18.5. SLIP の利用</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/mail/>第19章 電子メール</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/mail/#mail-synopsis>19.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mail/#mail-using>19.2. 電子メールを使う</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mail/#sendmail>19.3. sendmail の設定</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mail/#mail-changingmta>19.4. MTA の変更</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mail/#mail-trouble>19.5. トラブルシュート</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mail/#mail-advanced>19.6. 先進的なトピックス</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mail/#SMTP-UUCP>19.7. UUCP とともに SMTP を使う</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mail/#SMTP-dialup>19.8. ダイアルアップ接続でメールを使う</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mail/#SMTP-Auth>19.9. SMTP 認証</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle checked>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/>第20章 高度なネットワーク</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#advanced-networking-synopsis>20.1. この章では</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-routing>20.2. ゲートウェイと経路</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-wireless>20.3. 無線ネットワーク</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-bluetooth>20.4. Bluetooth</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-bridging>20.5. ブリッジ</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-nfs>20.6. NFS</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-diskless>20.7. ディスクレス稼働</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-isdn>20.8. ISDN</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-nis>20.9. NIS/YP</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-dhcp>20.10. DHCP</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-dns>20.11. DNS</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-ntp>20.12. NTP</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-natd>20.13. ネットワークアドレス変換 (NAT)</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-inetd>20.14. inetd"スーパサーバ"</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-plip>20.15. パラレルライン IP (PLIP)</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/advanced-networking/#network-ipv6>20.16. IPv6</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/partv/>パートV. 付録</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/mirrors/>付録A FreeBSD の入手方法</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/mirrors/#mirrors>A.1. Mirrors</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mirrors/#git>A.2. Git の利用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mirrors/#svn>A.3. Subversion の利用</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/mirrors/#mirrors-cdrom>A.4. CD および DVD セット</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/bibliography/>付録B. 参考図書</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/bibliography/#bibliography-freebsd>B.1. FreeBSD 専門の書籍</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bibliography/#bibliography-userguides>B.2. 利用者向けのガイド</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bibliography/#bibliography-adminguides>B.3. 管理者向けのガイド</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bibliography/#_プログラマ向けのガイド>B.4. プログラマ向けのガイド</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bibliography/#_オペレーティングシステム内部>B.5. オペレーティングシステム内部</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bibliography/#_セキュリティの参考資料>B.6. セキュリティの参考資料</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bibliography/#bibliography-hardware>B.7. ハードウェアの参考資料</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bibliography/#bibliography-history>B.8. UNIX® の歴史</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/bibliography/#bibliography-journals>B.9. 定期刊行物、雑誌およびジャーナル</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/eresources/>付録 C. インターネット上のリソース</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/eresources/#eresources-www>C.1. ウェブサイト</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/eresources/#eresources-mail>C.2. メーリングリスト</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/eresources/#eresources-news>C.3. Usenet ニュースグループ</a></li><li><a href=https://docs.freebsd.org/ja/books/handbook/eresources/#eresources-web>C.4. オフィシャルミラー</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/ja/books/handbook/pgpkeys/>付録 D. OpenPGP Keys</a><ul><li><a href=https://docs.freebsd.org/ja/books/handbook/pgpkeys/#pgpkeys-officers>D.1. オフィサ</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>第20章 高度なネットワーク</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>目次</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>20.1. この章では</a></li><li><a href=#network-routing>20.2. ゲートウェイと経路</a></li><li><a href=#network-wireless>20.3. 無線ネットワーク</a></li><li><a href=#network-bluetooth>20.4. Bluetooth</a></li><li><a href=#network-bridging>20.5. ブリッジ</a></li><li><a href=#network-nfs>20.6. NFS</a></li><li><a href=#network-diskless>20.7. ディスクレス稼働</a></li><li><a href=#network-isdn>20.8. ISDN</a></li><li><a href=#network-nis>20.9. NIS/YP</a></li><li><a href=#network-dhcp>20.10. DHCP</a></li><li><a href=#network-dns>20.11. DNS</a></li><li><a href=#network-ntp>20.12. NTP</a></li><li><a href=#network-natd>20.13. ネットワークアドレス変換 (NAT)</a></li><li><a href=#network-inetd>20.14. inetd"スーパサーバ"</a></li><li><a href=#network-plip>20.15. パラレルライン IP (PLIP)</a></li><li><a href=#network-ipv6>20.16. IPv6</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=advanced-networking-synopsis>20.1. この章では<a class=anchor href=#advanced-networking-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>この章では UNIX® システム上で良く利用されるネットワークサービスについて説明します。 FreeBSD が利用するすべてのネットワークサービスをどのように定義し、 設定し、テストし、そして保守するのかを扱います。さらに、 本章を通してあなたの役に立つ設定例が載っています。</p></div><div class=paragraph><p>この章を読めば以下のことが分かります。</p></div><div class=ulist><ul><li><p>ゲートウェイと経路の基本</p></li><li><p>FreeBSD をブリッジとして動作させる方法</p></li><li><p>ネットワークファイルシステム (NFS) の設定方法</p></li><li><p>ディスクレスマシンのネットワークブートの設定方法</p></li><li><p>ユーザアカウントを共有するためのネットワークインフォメーションサーバ (NIS) の設定方法</p></li><li><p>DHCP を用いて自動的にネットワーク設定を行う方法</p></li><li><p>ドメインネームサーバ (DNS) の設定方法</p></li><li><p>NTP プロトコルを用いて日時を同期してタイムサーバを設定する方法</p></li><li><p>ネットワークアドレス変換 (NAT) の設定方法</p></li><li><p><code>inetd</code> デーモンの管理方法</p></li><li><p>PLIP 経由で二台のコンピュータを接続する方法</p></li><li><p>FreeBSD で IPv6 を設定する方法</p></li></ul></div><div class=paragraph><p>この章を読む前に、以下のことを行っておくべきです。</p></div><div class=ulist><ul><li><p><span class=filename>/etc/rc</span> スクリプトの基本を理解していること</p></li><li><p>基礎的なネットワーク用語に精通していること</p></li></ul></div></div></div><div class=sect1><h2 id=network-routing>20.2. ゲートウェイと経路<a class=anchor href=#network-routing></a></h2><div class=sectionbody><div class=paragraph><p>あるマシンがネットワーク上で他のマシンをみつけることができるようにするには、 あるマシンから他のマシンへどのようにたどり着くかを記述する適切な仕組みが必要です。 この仕組みを<em>ルーティング</em>と呼びます。 "経路" (route) は "送信先" (destination) と "ゲートウェイ" の 2 つのアドレスの組で定義します。この組合せは、この <em>送信先</em> へたどり着こうとする場合は、その <em>ゲートウェイ</em> を通じて通信することを示しています。 送信先には個々のホスト、サブネット、"デフォルト" の 3 つの型があります。 "デフォルトルート" は他のどの経路も適用できない場合に使われます。 デフォルトルートについてはのちほどもう少し詳しく述べます。 また、ゲートウェイには、個々のホスト、インタフェース ("リンク" とも呼ばれます)、 イーサネットハードウェアアドレス (MAC アドレス) の 3 つの型があります。</p></div><div class=sect2><h3 id=_例>20.2.1. 例<a class=anchor href=#_例></a></h3><div class=paragraph><p>以下に示す <code>netstat</code> の例を使って、ルーティングのさまざまな状態を説明します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1             UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>最初の 2 行はデフォルトルート (<a href=#network-routing-default>次節</a>で扱います) と、 <code>localhost</code> への経路を示しています。</p></div><div class=paragraph><p><code>localhost</code> に割り当てるインタフェース (<code>Netif</code> 欄) としてこのルーティングテーブルが指定しているのは <span class=filename>lo0</span> で、これはループバックデバイスともいいます。 これは結局のところ出たところに戻るだけなので、 この送信先あてのトラフィックは、LAN に送られずに、すべて内部的に処理されます。</p></div><div class=paragraph><p>次の行では <code>0:e0:</code> から始まるアドレスに注目しましょう。 これはイーサネットハードウェアアドレスで、MAC アドレスともいいます。 FreeBSD はローカルなイーサネット上の任意のホスト (この例では <code>test0</code>) を自動的に認識し、 イーサネットインタフェース <span class=filename>ed0</span> にそのホストへの直接の経路をつけ加えます。 この種の経路には、タイムアウト時間 (<code>Expire</code> 欄) も結びつけられており、 指定された時間内にホストからの応答がないことを判断するのに用いられます。 その場合、そのホストへの経路情報は自動的に削除されます。 これらのホストは RIP (Routing Information Protocol) という、 最短パス判定に基づいてローカルなホストへの経路を決定する仕組みを利用して認識されます。</p></div><div class=paragraph><p>さらに FreeBSD ではローカルサブネットへの経路情報も加えることができます (<code>10.20.30.255</code> は <code>10.20.30</code> というサブネットに対するブロードキャストアドレスで、 <code>example.com</code> はこのサブネットに結びつけられているドメイン名)。 <code>link#1</code> という名称は、 このマシンの一つ目のイーサネットカードのことをさします。 これらについては、 何も追加インタフェースが指定されていないことがわかります。</p></div><div class=paragraph><p>これら 2 つのグループ (ローカルネットワークホストとローカルサブネット) は、両方とも routed というデーモンによって自動的に経路が設定されます。 routed を動かさなければ、静的に定義した (つまり明示的に設定した) 経路のみが存在することになります。</p></div><div class=paragraph><p><code>host1</code> の行は私たちのホストのことで、 イーサネットアドレスで示されています。送信側のホストの場合、 FreeBSDはイーサネットインタフェースへ送るのではなく、 ループバックインタフェース (<span class=filename>lo0</span>) を使います。</p></div><div class=paragraph><p>2 つある <code>host2</code> の行は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> のエイリアスを使ったときにどのようになるかを示す例です (このようなことをする理由については Ethernet の節を参照してください)。 <span class=filename>lo0</span> の後にある <code>⇒</code> は、 インタフェースが (このアドレスがローカルなホストを参照しているので) ループバックを使っているというだけでなく、 エイリアスになっていることも示しています。 このような経路はエイリアスに対応しているホストにのみ現れます。 ローカルネットワーク上の他のすべてのホストでは、 それぞれの経路に対して単に<code>link#1</code> となります。</p></div><div class=paragraph><p>最後の行 (送信先サブネット <code>224</code>) はマルチキャストで扱うものですが、これは他の節で説明します。</p></div><div class=paragraph><p>最後に <code>Flags</code> (フラグ) 欄にそれぞれの経路のさまざまな属性が表示されます。 以下にフラグの一部と、それが何を意味しているかを示します。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Up: この経路はアクティブです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Host: 経路の送信先が単一のホストです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gateway: この送信先へ送られると、 どこへ送ればよいかを明らかにして、 そのリモートシステムへ送られます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Static: この経路はシステムによって自動的に生成されたのではなく、 手動で作成されました。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clone: マシンに接続したときにこの経路に基づく新しい経路が作られます。 この型の経路は通常はローカルネットワークで使われます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>WasCloned: ローカルエリアネットワーク (LAN) の (Clone) 経路に基づいて自動的に生成された経路であることを示します。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Link: イーサネットハードウェアへの参照を含む経路です。</p></td></tr></tbody></table></div><div class=sect2><h3 id=network-routing-default>20.2.2. デフォルトルート<a class=anchor href=#network-routing-default></a></h3><div class=paragraph><p>ローカルシステムからリモートホストにコネクションを張る必要がある場合、 既知の経路が存在するかどうかを確認するためにルーティングテーブルをチェックします。 到達するための経路を知っているサブネットの内部にリモートホストがある場合 (Cloned routes)、 システムはそのインタフェースから接続できるかどうか確認します。</p></div><div class=paragraph><p>知っているパスがすべて駄目だった場合でも、 システムには最後の手段として "デフォルト" ルートがあります。このルートはゲートウェイルート (普通はシステムに 1 つしかありません) の特別なものです。そして、 フラグ欄には必ず <code>c</code> が表示されています。このゲートウェイは、LAN 内のホストにとって、どのマシンでも外部へ (PPP リンク、DSL、ケーブルモデム、T1、 またはその他のネットワークインタフェースのいずれかを経由して) 直接接続するために設定されるものです。</p></div><div class=paragraph><p>外部に対するゲートウェイとして機能するマシンでデフォルトルートを設定する場合、 デフォルトルートはインターネットサービスプロバイダ (ISP) のサイトのゲートウェイマシンになるでしょう。</p></div><div class=paragraph><p>それではデフォルトルートの一例を見てみましょう。 一般的な構成を示します。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/net-routing.png alt="net routing"></div></div><div class=paragraph><p>ホスト <code>Local1</code> とホスト <code>Local2</code> はあなたのサイト内にあります。<code>Local1</code> はダイアルアップ PPP 接続経由で ISP に接続されています。 この PPP サーバコンピュータは、その ISP のインターネットへの接続点に向けた外部インタフェースを備えた他のゲートウェイコンピュータへ LAN を通じて接続しています。</p></div><div class=paragraph><p>あなたのマシンのデフォルトルートはそれぞれ次のようになります。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">ホスト</th><th class="tableblock halign-left valign-top">デフォルトゲートウェイ</th><th class="tableblock halign-left valign-top">インタフェース</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ethernet</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PPP</p></td></tr></tbody></table><div class=paragraph><p>"なぜ (あるいは、どうやって) デフォルトゲートウェイを、<code>Local1</code> が接続されている ISP のサーバではなく、<code>T1-GW</code> に設定するのか" という質問がよくあります。</p></div><div class=paragraph><p>PPP 接続で、あなたのサイト側の PPP インタフェースは、 ISP のローカルネットワーク上のアドレスを用いているため、 ISP のローカルネットワーク上のすべてのマシンへの経路は 自動的に生成されています。 つまりあなたのマシンは、どのようにして <code>T1-GW</code> に到達するかという経路を既に知っていることになりますから、 ISP サーバにトラフィックを送るのに、 中間的な段階を踏む必要はありません。</p></div><div class=paragraph><p>一般的にローカルネットワークでは <code>X.X.X.1</code> というアドレスをゲートウェイアドレスとして使います。ですから (同じ例を用います)、あなたの class-C のアドレス空間が <code>10.20.30</code> で ISP が <code>10.9.9</code> を用いている場合、 デフォルトルートは次のようになります。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">ホスト</th><th class="tableblock halign-left valign-top">デフォルトルート</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2 (10.20.30.2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1, 10.9.9.30)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW (10.9.9.1)</p></td></tr></tbody></table><div class=paragraph><p>デフォルトルートは <span class=filename>/etc/rc.conf</span> ファイルで簡単に定義できます。この例では、 <code>Local2</code> マシンで <span class=filename>/etc/rc.conf</span> に次の行を追加しています。</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> コマンドを使ってコマンドラインから直接実行することもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>経路情報を手動で操作する方法について詳しいことは <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> のマニュアルページをご覧ください。</p></div></div><div class=sect2><h3 id=_デュアルホームホスト>20.2.3. デュアルホームホスト<a class=anchor href=#_デュアルホームホスト></a></h3><div class=paragraph><p>ここで扱うべき種類の設定がもう一つあります。 それは 2 つの異なるネットワークにまたがるホストです。 技術的にはゲートウェイとして機能するマシン (上の例では PPP コネクションを用いています) はすべてデュアルホームホストです。 しかし実際にはこの言葉は、2 つの LAN 上のサイトであるマシンを指す言葉としてのみ使われます。</p></div><div class=paragraph><p>2 枚のイーサネットカードを持つマシンが、 別のサブネット上にそれぞれアドレスを持っている場合があります。 あるいは、イーサネットカードが 1 枚しかないマシンで、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> のエイリアスを使っているかもしれません。 物理的に分かれている 2 つのイーサネットのネットワークが使われているならば前者が用いられます。 後者は、物理的には 1 つのネットワークセグメントで、 論理的には 2 つのサブネットに分かれている場合に用いられます。</p></div><div class=paragraph><p>どちらにしても、 このマシンがお互いのサブネットへのゲートウェイ (inbound route) として定義されていることが分かるように、 おのおののサブネットでルーティングテーブルを設定します。このマシンが 2 つのサブネットの間のルータとして動作するという構成は、 パケットのフィルタリングを実装する必要がある場合や、 一方向または双方向のファイアウォールを利用したセキュリティを構築する場合によく用いられます。</p></div><div class=paragraph><p>このマシンが二つのインタフェース間で実際にパケットを受け渡すようにしたい場合は、 FreeBSD でこの機能を有効にしないといけません。 くわしい手順については次の節をご覧ください。</p></div></div><div class=sect2><h3 id=network-dedicated-router>20.2.4. ルータの構築<a class=anchor href=#network-dedicated-router></a></h3><div class=paragraph><p>ネットワークルータは単にあるインタフェースから別のインタフェースへパケットを転送するシステムです。 インターネット標準およびすぐれた技術的な慣習から、 FreeBSD プロジェクトは FreeBSD においてこの機能をデフォルトでは有効にしていません。 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 内で次の変数を <code>YES</code> に変更することでこの機能を有効にできます。</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=YES          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>このオプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 変数の <code>net.inet.ip.forwarding</code> を <code>1</code> に設定します。 一時的にルーティングを停止する必要があるときには、 この変数を一時的に <code>0</code> に設定しなおせます。</p></div><div class=paragraph><p>次に、トラフィックの宛先を決めるために、 そのルータには経路情報が必要になります。 ネットワークが十分簡素なら、静的経路が利用できます。 また、FreeBSD は BSD の標準ルーティングデーモンである <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a> を備えています。これは RIP (バージョン 1 および 2) および IRDP を扱えます。 BGP バージョン 4、OSPF バージョン2、 その他洗練されたルーティングプロトコルは <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a> package を用いれば対応できます。 また、より複雑なネットワークルーティングソリューションには、 GateD® のような商用製品も利用可能です。</p></div><div class=paragraph><p>このように FreeBSD を設定したとしても、 ルータに対するインターネット標準要求を完全に満たすわけではありません。 しかし、通常利用に関しては十分といえます。</p></div></div><div class=sect2><h3 id=_静的な経路の設定>20.2.5. 静的な経路の設定<a class=anchor href=#_静的な経路の設定></a></h3><div class=sect3><h4 id=_手動による経路の設定>20.2.5.1. 手動による経路の設定<a class=anchor href=#_手動による経路の設定></a></h4><div class=paragraph><p>以下のようなネットワークが存在すると仮定します。</p></div><div class=literalblock><div class=content><pre>   INTERNET
      | (10.0.0.1/24) Default Router to Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (FreeBSD gateway)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Internal Net 1      | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Internal Net 2</pre></div></div><div class=paragraph><p>このシナリオでは、FreeBSD マシンの <code>RouterA</code> がインターネットに向けられたルータとして動作します。 ルータは外側のネットワークへ接続できるように <code>10.0.0.1</code> へ向けたデフォルトルートを保持しています。 <code>RouterB</code> はすでに適切に設定されており、 どこへ向かう必要があるか、 行き着く方法を知っていると仮定します (この例では、図のように簡単です。 <code>192.168.1.1</code> をゲートウェイとして <code>RouterB</code> にデフォルトルートを追加するだけです)。</p></div><div class=paragraph><p><code>RouterA</code> のルーティングテーブルを確認すると、 以下のような出力を得ます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1/24       <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>現在のルーティングテーブルでは、<code>RouterA</code> はまだ Internal Net 2 には到達できないでしょう。 <code>192.168.2.0/24</code> の経路を保持していないからです。 解決するための一つの方法は、経路を手動で追加することです。 以下のコマンドで <code>RouterA</code> のルーティングテーブルに <code>192.168.1.2</code> を送り先として、Internal Net 2 ネットワークを追加します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>これにより、<code>RouterA</code> は、 <code>192.168.2.0/24</code> ネットワーク上のホストに到達出来ます。</p></div></div><div class=sect3><h4 id=_永続的な設定>20.2.5.2. 永続的な設定<a class=anchor href=#_永続的な設定></a></h4><div class=paragraph><p>上記の例は、 起動しているシステム上に静的な経路を設定する方法としては完全です。 しかしながら、FreeBSD マシンを再起動した際にルーティング情報が残らないという問題が一つあります。 静的な経路を追加するには、<span class=filename>/etc/rc.conf</span> ファイルにルートを追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p><code>static_routes</code> の設定変数は、 スペースによって分離される文字列のリストです。 それぞれの文字列は経路名として参照されます。 上記の例では <code>static_routes</code> は一つの文字列のみを持ちます。 その文字列は <em>internalnet2</em> です。その後、 <code>route_internalnet2</code> という設定変数を追加し、 <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> コマンドに与えるすべての設定パラメータを指定しています。 前節の例では、以下のコマンド</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>を用いたので、 <code>"-net 192.168.2.0/24 192.168.1.2"</code> が必要になります。</p></div><div class=paragraph><p>上記のように <code>static_routes</code> は一つ以上の文字列を持つことが出来るので、 多数の静的な経路を作ることができます。 以下の行は <code>192.168.0.0/24</code> および <code>192.168.1.0/24</code> ネットワークを、 仮想ルータ上に静的な経路として追加する例です。</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div></div><div class=sect2><h3 id=_ルーティングの伝搬>20.2.6. ルーティングの伝搬<a class=anchor href=#_ルーティングの伝搬></a></h3><div class=paragraph><p>外部との経路をどのように定義したらよいかはすでに説明しました。 しかし外部から私たちのマシンをどのようにして見つけるのかについては説明していません。</p></div><div class=paragraph><p>ある特定のアドレス空間 (この例では class-C のサブネット) におけるすべてのトラフィックが、 到着したパケットを内部で転送するネットワーク上の特定のホストに送られるようにルーティングテーブルを設定することができるのは分かっています。</p></div><div class=paragraph><p>あなたのサイトにアドレス空間を割り当てる場合、 あなたのサブネットへのすべてのトラフィックがすべて PPP リンクを通じてサイトに送ってくるようにサービスプロバイダはルーティングテーブルを設定します。 しかし、国境の向こう側のサイトはどのようにしてあなたの ISP へ送ることを知るのでしょうか?</p></div><div class=paragraph><p>割り当てられているすべてのアドレス空間の経路を維持する (分散している DNS 情報とよく似た) システムがあり、 そのインターネットバックボーンへの接続点を定義しています。 "バックボーン" とは国を越え、 世界中のインターネットのトラフィックを運ぶ主要な信用できる幹線のことです。 どのバックボーンマシンも、 あるネットワークから特定のバックボーンのマシンへ向かうトラフィックと、 そのバックボーンのマシンからあなたのネットワークに届くサービスプロバイダまでのチェーンのマスタテーブルのコピーを持っています。</p></div><div class=paragraph><p>あなたのサイトが接続 (プロバイダからみて内側にあることになります) したということを、 プロバイダからバックボーンサイトへ通知することはプロバイダの仕事です。 これが経路の伝搬です。</p></div></div><div class=sect2><h3 id=_トラブルシューティング>20.2.7. トラブルシューティング<a class=anchor href=#_トラブルシューティング></a></h3><div class=paragraph><p>経路の伝搬に問題が生じて、 いくつかのサイトが接続をおこなうことができなくなることがあります。 ルーティングがどこでおかしくなっているかを明らかにするのに最も有効なコマンドはおそらく <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> コマンドでしょう。 このコマンドは、あなたがリモートマシンに対して接続をおこなうことができない (たとえば <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> に失敗するような) 場合も、同じように有効です。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> コマンドは、 接続を試みているリモートホストを引数にして実行します。 試みている経路が経由するゲートウェイホストを表示し、 最終的には目的のホストにたどり着くか、 コネクションの欠如によって終ってしまうかのどちらかになります。</p></div><div class=paragraph><p>より詳しい情報は、<a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> のマニュアルページをみてください。</p></div></div><div class=sect2><h3 id=_マルチキャストルーティング>20.2.8. マルチキャストルーティング<a class=anchor href=#_マルチキャストルーティング></a></h3><div class=paragraph><p>FreeBSD はマルチキャストアプリケーションとマルチキャストルーティングの両方にネイティブ対応しています。 マルチキャストアプリケーションを動かすのに FreeBSD で特別な設定をする必要は一切ありません。 アプリケーションは普通はそのままで動くでしょう。 マルチキャストルーティングに対応するには、 下のオプションを追加してカーネルをコンパイルする必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>さらに、<span class=filename>/etc/mrouted.conf</span> を編集してルーティングデーモン <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a> を設定し、トンネルと DVMRP を設置する必要があります。 マルチキャスト設定についての詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a> のマニュアルページを参照してください。</p></div></div></div></div><div class=sect1><h2 id=network-wireless>20.3. 無線ネットワーク<a class=anchor href=#network-wireless></a></h2><div class=sectionbody><div class=sect2><h3 id=_はじめに>20.3.1. はじめに<a class=anchor href=#_はじめに></a></h3><div class=paragraph><p>常にネットワークケーブルをつないでいるという面倒なことをせずに、 コンピュータを使用できることは、とても有用でしょう。 FreeBSD は無線のクライアントとして、 さらに "アクセスポイント" としても使えます。</p></div></div><div class=sect2><h3 id=_無線の動作モード>20.3.2. 無線の動作モード<a class=anchor href=#_無線の動作モード></a></h3><div class=paragraph><p>802.11 無線デバイスの設定には、BSS と IBSS の二つの方法があります。</p></div><div class=sect3><h4 id=_bss_モード>20.3.2.1. BSS モード<a class=anchor href=#_bss_モード></a></h4><div class=paragraph><p>BSS モードは一般的に使われているモードです。 BSS モードはインフラストラクチャモードとも呼ばれています。 このモードでは、 多くの無線アクセスポイントが 1 つの有線ネットワークに接続されます。 それぞれのワイヤレスネットワークは固有の名称を持っています。 その名称はネットワークの SSID と呼ばれます。</p></div><div class=paragraph><p>無線クライアントはこれらの無線アクセスポイントに接続します。 IEEE 802.11 標準は無線ネットワークが接続するのに使用するプロトコルを規定しています。 SSID が設定されているときは、 無線クライアントを特定のネットワークに結びつけることができます。 SSID を明示的に指定しないことにより、 無線クライアントを任意のネットワークに接続することもできます。</p></div></div><div class=sect3><h4 id=_ibss_モード>20.3.2.2. IBSS モード<a class=anchor href=#_ibss_モード></a></h4><div class=paragraph><p>アドホックモードとも呼ばれる IBSS モードは、 一対一通信のために設計された通信方式です。 実際には二種類のアドホックモードがあります。 一つは IBSS モードで、アドホックモード、または IEEE アドホックモードとも呼ばれます。 このモードは IEEE 802.11 標準に規定されています。 もう一つはデモアドホックモードもしくは Lucent アドホックモード (そして時々、紛らわしいことに、アドホックモード) と呼ばれるモードです。 このモードは古く、802.11 が標準化する以前のアドホックモードで、 これは古い設備でのみ使用されるべきでしょう。 ここでは、どちらのアドホックモードについてもこれ以上言及しません。</p></div></div></div><div class=sect2><h3 id=_インフラストラクチャーモード>20.3.3. インフラストラクチャーモード<a class=anchor href=#_インフラストラクチャーモード></a></h3><div class=sect3><h4 id=_アクセスポイント>20.3.3.1. アクセスポイント<a class=anchor href=#_アクセスポイント></a></h4><div class=paragraph><p>アクセスポイントは一つ以上の無線クライアントが、 そのデバイスをセントラルハブとして利用できるようにする無線ネットワークデバイスです。 アクセスポイントを使用している間、 すべてのクライアントはアクセスポイントを介して通信します。 家屋や職場、または公園などの空間を無線ネットワークで完全にカバーするために、 複数のアクセスポイントがよく使われます。</p></div><div class=paragraph><p>アクセスポイントは一般的に複数のネットワーク接続 (無線カードと、 その他のネットワークに接続するための一つ以上の有線イーサネットアダプタ) を持っています。</p></div><div class=paragraph><p>アクセスポイントは、出来合いのものを購入することもできますし、 FreeBSD と対応している無線カードを組み合わせて、 自分で構築することもできます。 いくつものメーカが、 さまざまな機能をもった無線アクセスポイントおよび無線カードを製造しています。</p></div></div><div class=sect3><h4 id=_freebsd_のアクセスポイントの構築>20.3.3.2. FreeBSD のアクセスポイントの構築<a class=anchor href=#_freebsd_のアクセスポイントの構築></a></h4><div class=sect4><h5 id=_要件>20.3.3.2.1. 要件<a class=anchor href=#_要件></a></h5><div class=paragraph><p>FreeBSD で無線アクセスポイントを設定するためには、 互換性のある無線カードが必要です。 現状では Prism チップセットのカードのみに対応しています。 また FreeBSD に対応している有線ネットワークカードも必要になるでしょう (これを見つけるのは難しくないでしょう。 FreeBSD は多くの異なるデバイスに対応しているからです) 。 この手引きでは、 無線デバイスと有線ネットワークカードに接続しているネットワーク間のトラフィックを <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> したいと仮定します。</p></div><div class=paragraph><p>FreeBSD がアクセスポイントを実装するのに使用する hostap 機能はファームウェアの特定のバージョンで一番よく性能を発揮します。 Prism 2 カードは、 1.3.4 以降のバージョンのファームウェアで使用すべきです。 Prism 2.5 および Prism 3 カードでは、バージョン 1.4.9 のバージョンのファームウェアで使用すべきです。 それより古いバージョンのファームウェアは、 正常に動くかもしれませんし、動かないかもしれません。 現時点では、カードのファームウェアを更新する唯一の方法は、 カードの製造元から入手できる Windows® 用ファームウェアアップデートユーティリティを使うものです。</p></div></div><div class=sect4><h5 id=_設定>20.3.3.2.2. 設定<a class=anchor href=#_設定></a></h5><div class=paragraph><p>はじめにシステムが無線カードを認識していることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig -a</span>
wi0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/2Mbps<span class=o>)</span>
        status: no carrier
        ssid <span class=s2>&#34;&#34;</span>
        stationname <span class=s2>&#34;FreeBSD Wireless node&#34;</span>
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</code></pre></div></div><div class=paragraph><p>細かいことは気にせず、 無線カードがインストールされていることを示す何かが表示されていることを確かめてください。 PC カードを使用していて、無線インタフェースを認識できない場合、 詳しい情報を得るために <a href="https://man.freebsd.org/cgi/man.cgi?query=pccardc&amp;sektion=8&amp;format=html">pccardc(8)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=pccardd&amp;sektion=8&amp;format=html">pccardd(8)</a> のマニュアルページを調べてみてください。</p></div><div class=paragraph><p>次に、アクセスポイント用に FreeBSD のブリッジ機能を担う部分を有効にするために、 モジュールを読み込む必要があるでしょう。 <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> モジュールを読み込むには、 次のコマンドをそのまま実行します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload bridge</span></code></pre></div></div><div class=paragraph><p>モジュールを読み込む時には、何もエラーはでないはずです。 もしもエラーがでたら、カーネルに <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> のコードを入れてコンパイルする必要があるかもしれません。 ハンドブックの<a href=#network-bridging>ブリッジ</a>の節が、 この課題を成し遂げる手助けをになるかもしれません。</p></div><div class=paragraph><p>ブリッジ部分が準備できたので、 どのインタフェース間をブリッジするのかを FreeBSD カーネルに指定する必要があります。 これは、<a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> を使って行います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.link.ether.bridge=1</span>
<span class=c># sysctl net.link.ether.bridge_cfg=&#34;wi0,xl0&#34;</span>
<span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>FreeBSD 5.2-RELEASE 以降では、次のように指定しなければなりません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.link.ether.bridge.enable=1</span>
<span class=c># sysctl net.link.ether.bridge.config=&#34;wi0,xl0&#34;</span>
<span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>さて、無線カードを設定するときです。 次のコマンドはカードをアクセスポイントとして設定します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 ssid my_net channel 11 media DS/11Mbps mediaopt hostap up stationname &#34;FreeBSD AP&#34;</span></code></pre></div></div><div class=paragraph><p>この <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> コマンド行は <span class=filename>wi0</span> インタフェースを up 状態にし、SSID を <em>my_net</em> に設定し、 ステーション名を <em>FreeBSD AP</em> に設定します。 <code>media DS/11Mbps</code> オプションはカードを 11Mbps モードに設定し、また <code>mediaopt</code> を実際に有効にするのに必要です。 <code>mediaopt hostap</code> オプションはインタフェースをアクセスポイントモードにします。 <code>channel 11</code> オプションは使用するチャネルを 802.11b に設定します。 各規制地域 (regulatory domain) で有効なチャネル番号は <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a> マニュアルページに載っています。</p></div><div class=paragraph><p>さて、 これで完全に機能するアクセスポイントが立ち上がり、動作しています。 より詳しい情報については、<a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a> のマニュアルを読むとよいでしょう。</p></div><div class=paragraph><p>また、下記の暗号化に関する節を読むこともおすすめします。</p></div></div><div class=sect4><h5 id=_ステータス情報>20.3.3.2.3. ステータス情報<a class=anchor href=#_ステータス情報></a></h5><div class=paragraph><p>一度アクセスポイントが設定されて稼働すると、 管理者はアクセスポイントを利用しているクライアントを見たいと思うでしょう。 いつでも管理者は以下のコマンドを実行できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wicontrol -l</span>
1 station:
00:09:b7:7b:9d:16  <span class=nv>asid</span><span class=o>=</span>04c0, <span class=nv>flags</span><span class=o>=</span>3&lt;ASSOC,AUTH&gt;, <span class=nv>caps</span><span class=o>=</span>1&lt;ESS&gt;, <span class=nv>rates</span><span class=o>=</span>f&lt;1M,2M,5.5M,11M&gt;, <span class=nv>sig</span><span class=o>=</span>38/15</code></pre></div></div><div class=paragraph><p>これは一つの局が、 表示されているパラメータで接続していることを示します。 表示された信号は、 相対的な強さを表示しているだけのものとして扱われるべきです。 dBm やその他の単位への変換結果は、 異なるファームウェアバージョン間で異なります。</p></div></div></div><div class=sect3><h4 id=_クライアント>20.3.3.3. クライアント<a class=anchor href=#_クライアント></a></h4><div class=paragraph><p>無線クライアントはアクセスポイント、 または他のクライアントに直接アクセスするシステムです。</p></div><div class=paragraph><p>典型的には、 無線クライアントが有しているネットワークデバイスは、 無線ネットワークカード 1 枚だけです。</p></div><div class=paragraph><p>無線クライアントを設定するにはいくつか方法があります。 それぞれは異なる無線モードに依存していますが、 一般的には BSS (アクセスポイントを必要とするインフラストラクチャーモード) か、 IBSS (アドホック、またはピアツーピアモード) のどちらかです。 ここでは、アクセスポイントと通信をするのに、 両者のうちで最も広まっている BSS モードを使用します。</p></div><div class=sect4><h5 id=_要件_2>20.3.3.3.1. 要件<a class=anchor href=#_要件_2></a></h5><div class=paragraph><p>FreeBSD を無線クライアントとして設定するのに、 本当に必要なものはたった 1 つだけです。 FreeBSD が対応している無線カードが必要です。</p></div></div><div class=sect4><h5 id=_無線_freebsd_クライアントの設定>20.3.3.3.2. 無線 FreeBSD クライアントの設定<a class=anchor href=#_無線_freebsd_クライアントの設定></a></h5><div class=paragraph><p>設定をはじめる前に、 あなたが接続しようとする無線ネットワークについていくつか知っておかなければなりません。 この例では、<em>my_net</em> という名前で暗号化は無効になっているネットワークに接続しようとしています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この例では暗号化を行っていないのですが、 これは危険な状況です。次の節で、暗号化を有効にする方法と、 なぜそれが重要で、 暗号技術によっては完全にはあなたを保護することができないのはなぜか、 ということを学ぶでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p>カードが FreeBSD に認識されていることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig -a</span>
wi0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/2Mbps<span class=o>)</span>
        status: no carrier
        ssid <span class=s2>&#34;&#34;</span>
        stationname <span class=s2>&#34;FreeBSD Wireless node&#34;</span>
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</code></pre></div></div><div class=paragraph><p>それでは、このカードをネットワークに合わせて設定しましょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net</span></code></pre></div></div><div class=paragraph><p><code>192.168.0.20</code> と <code>255.255.255.0</code> を有線ネットワークで有効な IP アドレスとネットマスクに置き換えてください。 アクセスポイントは無線ネットワークと有線ネットワークの間でデータをブリッジしているため、 ネットワーク上の他のデバイスには、このデバイスが、他と同様に、 有線ネットワーク上にあるかのように見えることに注意してください。</p></div><div class=paragraph><p>これを終えると、 あなたは標準的な有線接続を使用しているかのように、 有線ネットワーク上のホストに ping を送ることができるでしょう。</p></div><div class=paragraph><p>無線接続に関する問題がある場合は、 アクセスポイントに接続されていることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0</span></code></pre></div></div><div class=paragraph><p>いくらか情報が表示されるはずです。 その中に以下の表示があるはずです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>status: associated</code></pre></div></div><div class=paragraph><p>もし <code>associated</code> と表示されなければ、 アクセスポイントの範囲外かもしれないし、 暗号化が有効になっているかもしれないし、 または設定の問題を抱えているのかもしれません。</p></div></div></div><div class=sect3><h4 id=_暗号化>20.3.3.4. 暗号化<a class=anchor href=#_暗号化></a></h4><div class=paragraph><p>無線ネットワークを暗号化することが重要なのは、 十分保護された領域にネットワークを留める能力がもはやないからです。 無線データはその周辺全体にわたって放送されるので、 それを読みたいと思う人はだれでも読むことができます。 そこで暗号化が役に立ちます。 電波に載せて送られるデータを暗号化することによって、 興味を抱いた者が空中からデータを取得することをずっと難しくします。</p></div><div class=paragraph><p>クライアントとアクセスポイント間のデータを暗号化するもっとも一般的な方法には、 WEP と <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> の二種類があります。</p></div><div class=sect4><h5 id=_wep>20.3.3.4.1. WEP<a class=anchor href=#_wep></a></h5><div class=paragraph><p>WEP は Wired Equivalency Protocol (訳注: 直訳すると、有線等価プロトコル) の略語です。WEP は無線ネットワークを有線ネットワークと同程度に安全で確実なものにしようとする試みです。 残念ながら、これはすでに破られており、 破るのはそれほど苦労しません。 これは、機密データを暗号化するという場合に、 これに頼るものではないということも意味します。</p></div><div class=paragraph><p>なにも無いよりはましなので、 次のコマンドを使って、あなたの新しい FreeBSD アクセスポイント上で WEP を有効にしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet up ssid my_net wepmode on wepkey 0x1234567890 media DS/11Mbps mediaopt hostap</span></code></pre></div></div><div class=paragraph><p>クライアントについては次のコマンドで WEP を有効にできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net wepmode on wepkey 0x1234567890</span></code></pre></div></div><div class=paragraph><p><em>0x1234567890</em> をより特異なキーに変更すべきであることに注意してください。</p></div></div><div class=sect4><h5 id=_ipsec>20.3.3.4.2. IPsec<a class=anchor href=#_ipsec></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> はネットワーク上で交わされるデータを暗号化するための、 はるかに頑健で強力なツールです。 これは無線ネットワーク上のデータを暗号化する明らかに好ましい方法です。 ハンドブック内の <a href=../security/#ipsec>IPsec</a> 節で <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> セキュリティ、 およびその実装方法の詳細を読むことができます。</p></div></div></div><div class=sect3><h4 id=_ツール>20.3.3.5. ツール<a class=anchor href=#_ツール></a></h4><div class=paragraph><p>無線ネットワークをデバッグしたり設定するのに使うツールがわずかばかりあります。 ここでその一部と、それらが何をしているか説明します。</p></div><div class=sect4><h5 id=_bsd_airtools_パッケージ>20.3.3.5.1. bsd-airtools パッケージ<a class=anchor href=#_bsd_airtools_パッケージ></a></h5><div class=paragraph><p>bsd-airtools パッケージは、 WEP キークラッキング、 アクセスポイント検知などの無線通信を監査するツールを含む完備されたツール集です。</p></div><div class=paragraph><p>bsd-airtools ユーティリティは <a class=package href=https://cgit.freebsd.org/ports/tree/net/bsd-airtools/>net/bsd-airtools</a> port からインストールできます。 ports のインストールに関する情報はこのハンドブックの <a href=../ports/#ports>アプリケーションのインストール - packages と ports</a> を参照してください。</p></div><div class=paragraph><p><code>dstumbler</code> プログラムは、 アクセスポイントの発見および S/N 比のグラフ化をできるようにするパッケージツールです。 アクセスポイントを立ち上げて動かすのに苦労しているなら、 <code>dstumbler</code> はうまく行く手助けになるかもしれません。</p></div><div class=paragraph><p>無線ネットワークの安全性をテストするのに、 "dweputils" (<code>dwepcrack</code>, <code>dwepdump</code> および <code>dwepkeygen</code>) を使用することで、 WEP があなたの無線安全性への要求に対する正しい解決策かどうか判断するのを助けられるかもしれません。</p></div></div><div class=sect4><h5 id=_wicontrol_ancontrol_および_raycontrol_ユーティリティ>20.3.3.5.2. <code>wicontrol</code>, <code>ancontrol</code> および <code>raycontrol</code> ユーティリティ<a class=anchor href=#_wicontrol_ancontrol_および_raycontrol_ユーティリティ></a></h5><div class=paragraph><p>これらは、無線ネットワーク上で無線カードがどのように動作するかを制御するツールです。 上記の例では、無線カードが <span class=filename>wi0</span> インタフェースであるので、<a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a> を使用することに決めました。 もし Cisco の無線デバイスを持っている場合は、それは <span class=filename>an0</span> として動作するでしょうから、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ancontrol&amp;sektion=8&amp;format=html">ancontrol(8)</a> を使うことになるでしょう。</p></div></div><div class=sect4><h5 id=_ifconfig_コマンド>20.3.3.5.3. <code>ifconfig</code> コマンド<a class=anchor href=#_ifconfig_コマンド></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> は <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a> と同じオプションの多くを処理できますが、 いくつかのオプションを欠いています。 コマンドライン引数とオプションについて <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> を参照してください。</p></div></div></div><div class=sect3><h4 id=_対応しているカード>20.3.3.6. 対応しているカード<a class=anchor href=#_対応しているカード></a></h4><div class=sect4><h5 id=_アクセスポイント_2>20.3.3.6.1. アクセスポイント<a class=anchor href=#_アクセスポイント_2></a></h5><div class=paragraph><p>現在のところ (アクセスポイントとして) BSS モードに対応した唯一のカードは Prism 2, 2.5 または 3 チップセットを利用したデバイスです。 <a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a> に完全な一覧があります。</p></div></div><div class=sect4><h5 id=_クライアント_2>20.3.3.6.2. クライアント<a class=anchor href=#_クライアント_2></a></h5><div class=paragraph><p>現在、FreeBSD では、ほとんどすべての 802.11b 無線カードに対応しています。 Prism, Spectrum24, Hermes, Aironet または Raylink のチップセットを利用したほとんどのカードは、 (アドホック、ピアツーピア、そして BSS の) IBSS モードで無線ネットワークカードとして動作するでしょう。</p></div></div></div></div></div></div><div class=sect1><h2 id=network-bluetooth>20.4. Bluetooth<a class=anchor href=#network-bluetooth></a></h2><div class=sectionbody><div class=sect2><h3 id=_はじめに_2>20.4.1. はじめに<a class=anchor href=#_はじめに_2></a></h3><div class=paragraph><p>Bluetooth は免許のいらない 2.4 GHz の帯域を利用して、 10 m 程度のパーソナルネットワークを作る無線技術です。 ネットワークはたいていの場合、その場その場で、携帯電話や PDA やノートパソコンなどの携帯デバイスから形成されます。 Wi-Fi などの他の有名な無線技術とは違い、 Bluetooth はより高いレベルのサービスを提供します。 たとえば、FTP のようなファイルサーバ、ファイルのプッシュ、 音声伝送、シリアル線のエミュレーションなどのサービスです。</p></div><div class=paragraph><p>FreeBSD 内での Bluetooth スタックは Netgraph フレームワーク (<a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a> 参照) を使って実現されています。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> ドライバは、 多種多様な Bluetooth USB ドングルに対応しています。 Broadcom BCM2033 チップを搭載した Bluetooth デバイスは <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> ドライバによって対応されています。 3Com Bluetooth PC カード 3CRWB60-A は <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a> ドライバによって対応されています。 シリアルおよび UART を搭載した Bluetooth デバイスは <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a> ドライバによって対応されています。 この節では USB Bluetooth ドングルの使用法について説明します。 Bluetooth に対応しているのは FreeBSD 5.0 以降のシステムです。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>5.0, 5.1 Release ではカーネルモジュールは利用可能ですが、 種々のユーティリティとマニュアルは標準でコンパイルされていません。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_デバイスの挿入>20.4.2. デバイスの挿入<a class=anchor href=#_デバイスの挿入></a></h3><div class=paragraph><p>デフォルトでは Bluetooth デバイスドライバはカーネルモジュールとして利用できます。 デバイスを接続する前に、 カーネルにドライバを読み込む必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>Bluetooth デバイスがシステム起動時に存在している場合、 <span class=filename>/boot/loader.conf</span> からモジュールを読み込んでください。</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>USB ドングルを挿してください。コンソールに (または syslog に) 下記のような表示が現れるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class=paragraph><p><span class=filename>/usr/shared/examples/netgraph/bluetooth/rc.bluetooth</span> を <span class=filename>/etc/rc.bluetooth</span> のようなどこか便利な場所にコピーしてください。 このスクリプトは Bluetooth スタックを開始および終了させるのに使われます。 デバイスを抜く前にスタックを終了するのはよい考えですが、 (たいていの場合) しなくても致命的ではありません。 スタックを開始するときに、下記のような出力がされます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></div><div class=sect2><h3 id=_ホストコントローラインタフェース_hci>20.4.3. ホストコントローラインタフェース (HCI)<a class=anchor href=#_ホストコントローラインタフェース_hci></a></h3><div class=paragraph><p>ホストコントローラインタフェース (HCI) は、 ベースバンドコントローラおよびリンクマネージャへのコマンドインタフェースを提供し、 ハードウェアステータスおよびコントロールレジスタへアクセスします。 このインタフェースは Bluetooth ベースバンド機能へアクセスする画一的な方法を提供します。 ホストの HCI 層は Bluetooth ハードウェア上の HCI ファームウェアと、 データとコマンドをやり取りします。 ホストコントローラトランスポート層 (つまり物理的なバス) のドライバは、 両方の HCI 層に相互に情報を交換する能力を与えます。</p></div><div class=paragraph><p>一つの Bluetooth デバイスにつき、<em>hci</em> タイプの Netgraph ノードが一つ作成されます。 HCI ノードは通常 Bluetooth デバイスドライバノード (下流) と L2CAP ノード (上流) に接続されます。 すべての HCI 動作はデバイスドライバノード上ではなく、 HCI ノード上で行われなくてはいけません。 HCI ノードのデフォルト名は "devicehci" です。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a> マニュアルを参照してください。</p></div><div class=paragraph><p>最も一般的なタスクの一つに、無線通信的に近傍にある Bluetooth デバイスの発見があります。 この動作は <em>inquiry (問い合わせ)</em> と呼ばれています。 Inquiry や他の HCI に関連した動作は <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a> ユーティリティによってなされます。 下記の例は、どの Bluetooth デバイスが通信圏内にあるかを知る方法を示しています。 デバイスのリストが表示されるには数秒かかります。 リモートデバイスは <em>discoverable (発見可能な)</em> モードにある場合にのみ inquiry に返答するということに注意してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p><code>BD_ADDR</code> は Bluetooth デバイスに固有のアドレスです。 これはネットワークカードの MAC アドレスに似ています。 このアドレスはデバイスとの通信を続けるのに必要となります。 BD_ADDR に人間が判読しやすい名前を割り当てることもできます。 <span class=filename>/etc/bluetooth/hosts</span> ファイルには、 既知の Bluetooth ホストに関する情報が含まれています。 次の例はリモートデバイスに割り当てられている、 人間が判読しやすい名前を得る方法を示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>リモートの Bluetooth デバイス上で inquiry を実行すると、 あなたのコンピュータは "your.host.name (ubt0)" と認識されます。 ローカルデバイスに割り当てられた名前はいつでも変更できます。</p></div><div class=paragraph><p>Bluetooth システムは一対一接続 (二つの Bluetooth ユニットだけが関係します) または一対多接続を提供します。 一対多接続では、接続はいくつかの Bluetooth デバイス間で共有されます。 次の例は、ローカルデバイスに対するアクティブなベースバンド接続のリストを得る方法を示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p><em>connection handle</em> はベースバンド接続の終了が必要とされるときに便利です。 もっとも、通常はこれを手動で行う必要はありません。 Bluetooth スタックはアクティブでないベースバンド接続を自動的に終了します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>利用可能な HCI コマンドの完全な一覧を得るには、 <code>hccontrol help</code> を参照してください。 HCI コマンドのほとんどはスーパユーザ権限を必要としません。</p></div></div><div class=sect2><h3 id=_ロジカルリンクコントロールおよびアダプテーションプロトコル_l2cap>20.4.4. ロジカルリンクコントロールおよびアダプテーションプロトコル (L2CAP)<a class=anchor href=#_ロジカルリンクコントロールおよびアダプテーションプロトコル_l2cap></a></h3><div class=paragraph><p>ロジカルリンクコントロールおよびアダプテーションプロトコル (L2CAP) は、プロトコル多重化ケーパビリティおよび分割・再編成動作を備えた、 上位層プロトコルへのコネクション指向およびコネクションレスデータサービスを提供します。 L2CAP は上位層プロトコルおよびアプリケーションが 64 KB までの長さの L2CAP データパケットを送受信することを可能にします。</p></div><div class=paragraph><p>L2CAP は <em>チャネル</em> の概念に基づいています。 チャネルはベースバンド接続の上位に位置する論理的な接続です。 それぞれのチャネルは多対一の方法で一つのプロトコルに結びつけられます。 複数のチャネルを同じプロトコルに結びつけることは可能ですが、 一つのチャネルを複数のプロトコルに結びつけることはできません。 チャネル上で受け取られたそれぞれの L2CAP パケットは、 適切なより上位のプロトコルに渡されます。 複数のチャネルは同じベースバンド接続を共有できます。</p></div><div class=paragraph><p>一つの Bluetooth デバイスに対して、<em>l2cap</em> タイプの Netgraph ノードが一つ作成されます。 L2CAP ノードは通常 Bluetooth HCI ノード (下流) と Bluetooth ソケットノード (上流) に接続されます。 L2CAP ノードのデフォルト名は "devicel2cap" です。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a> マニュアルを参照してください。</p></div><div class=paragraph><p>便利なコマンドに、他のデバイスに ping を送ることができる <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a> があります。Bluetooth 実装によっては、 送られたデータすべては返さないことがあります。 したがって次の例で <em>0 バイト</em> は正常です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> ユーティリティは L2CAP ノード上でさまざまな操作を行うのに使われます。 この例は、ローカルデバイスに対する論理的な接続 (チャネル) およびベースバンド接続の一覧を得る方法を示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>別の診断ツールが <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a> です。 これは <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> と同様の作業を、Bluetooth ネットワークに関するデータ構造についての行います。 下記の例は上の <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> と同じ論理的な接続を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect2><h3 id=_rfcomm_プロトコル>20.4.5. RFCOMM プロトコル<a class=anchor href=#_rfcomm_プロトコル></a></h3><div class=paragraph><p>RFCOMM プロトコルは L2CAP プロトコルを介してシリアルポートのエミュレーションを提供します。 このプロトコルは ETSI (訳注: 欧州電気通信標準化機構) 標準 TS 07.10 に基づいています。 RFCOMM プロトコルは、単純な伝送プロトコルに RS-232 (EIATIA-232-E) シリアルポートの 9 本の結線をエミュレートする項目を加えたものです。 RFCOMM プロトコルは、二つの Bluetooth デバイス間で、最大 60 までの同時接続 (RFCOMM チャネル) に対応しています。</p></div><div class=paragraph><p>RFCOMM の目的から、完全な通信経路は、異なるデバイス上 (通信の端点) で動作している二つのアプリケーションと、 その間の通信セグメントを含んでいます。RFCOMM は、それが動いているデバイスのシリアルポートを利用するアプリケーションをカバーするためのものです。 通信セグメントはあるデバイスから他のデバイスへの Bluetooth リンクです (直接接続)。</p></div><div class=paragraph><p>RFCOMM は直接接続している場合のデバイス間の接続、 またはネットワークの場合のデバイスとモデムの間の接続にだけ関係があります。 RFCOMM は、一方が Bluetooth 無線技術で通信し、 もう一方で有線インタフェースを提供するモジュールのような、 他の構成にも対応できます。</p></div><div class=paragraph><p>FreeBSD では RFCOMM プロトコルは Bluetooth ソケット層に実装されています。</p></div></div><div class=sect2><h3 id=_デバイスのペアリング>20.4.6. デバイスのペアリング<a class=anchor href=#_デバイスのペアリング></a></h3><div class=paragraph><p>デフォルトでは Bluetooth 通信は認証されておらず、 すべてのデバイスが他のすべてのデバイスと通信できます。 Bluetooth デバイス (たとえば携帯電話) は特定のサービス (たとえばダイアルアップサービス) を提供するために、 認証を要求することも選択できます。 Bluetooth 認証は通常 <em>PIN コード</em> で行われます。 PIN コードは最長 16 文字のアスキー文字列です。 ユーザは両デバイスで同じ PIN コードを入力することを要求されます。 一度 PIN コードを入力すると、 両デバイスは <em>リンクキー</em> を作成します。 その後、リンクキーはそのデバイス自身または、 不揮発性記憶デバイス内に格納できます。 次の機会には、両デバイスは前に作成されたリンクキーを使用するでしょう。 このような手続きを<em>ペアリング (pairing)</em> と呼びます。いずれかのデバイス上でリンクキーが失われたときには、 ペアリングをやり直さなければならないことに注意してください。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> デーモンが Bluetooth 認証要求のすべてを扱う責任を負っています。 デフォルトの設定ファイルは <span class=filename>/etc/bluetooth/hcsecd.conf</span> です。 PIN コードが "1234" に設定された携帯電話に関する例は以下の通りです。</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>PIN コードには (長さを除いて) 制限はありません。 いくつかのデバイス (たとえば Bluetooth ヘッドフォン) には固定的な PIN コードが組み込まれているかもしれません。 <code>-d</code> オプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> デーモンがフォアグラウンドで動作するように強制するため、 何が起きているのか確認しやすくなります。 リモートデバイスがペアリングを受け取るように設定して、 リモートデバイスへの Bluetooth 接続を開始してください。 リモートデバイスはペアリングが受け入れらた、と応答して PIN コードを要求するでしょう。 <span class=filename>hcsecd.conf</span> 内にあるのと同じ PIN コードを入力してください。 これであなたの PC とリモートデバイスがペアとなりました。 また、リモートデバイスからペアリングを開始することもできます。 以下は <code>hcsecd</code> の出力例です。</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect2><h3 id=_サービスディスカバリプロトコル_sdp>20.4.7. サービスディスカバリプロトコル (SDP)<a class=anchor href=#_サービスディスカバリプロトコル_sdp></a></h3><div class=paragraph><p>サービスディスカバリプロトコル (SDP) は、 クライアントアプリケーションが、 サーバアプリケーションが提供するサービスの存在とその属性を発見する手段を提供します。 サービスの属性には提示されているサービスのタイプまたはクラス、 および、サービスを利用するのに必要な仕組みまたはプロトコルの情報が含まれます。</p></div><div class=paragraph><p>SDP には SDP サーバと SDP クライアント間の通信が含まれます。 SDP サーバは、サーバに関連づけられたサービスの特性について記述しているサービスレコードの一覧を維持しています。 各サービスレコードにはそれぞれ 1 つのサービスの情報が書かれています。 クライアントは SDP リクエストを出すことによって、 SDP サーバが維持しているサービスレコードから情報を検索できます。 クライアントまたはクライアントに関連づけられたアプリケーションがサービスを利用することにしたら、 サービスを利用するためには、 サービスプロバイダへの接続を別途開かなければなりません。 SDP はサービスとそれらの属性を発見するための仕組みを提供しますが、 そのサービスを利用するための仕組みは提供しません。</p></div><div class=paragraph><p>通常 SDP クライアントは希望するサービスの特性に基づいてサービスを検索します。 しかしながら、サービスに関する事前の情報なしに、 どのタイプのサービスが SDP サーバのサービスレコードに記述されているか知ることが望ましいことがあります。 この、提供されている任意のサービスを閲覧する手順を、 <em>ブラウジング (browsing)</em> と呼びます。</p></div><div class=paragraph><p>現在のところ Bluetooth SDP サーバおよびクライアントは、 <a href=http://www.geocities.com/m_evmenkin/>ここ</a> からダウンロードできる第三者パッケージ sdp-1.5 で実装されています。 sdptool はコマンドラインの SDP クライアントです。 次の例は SDP ブラウズの問い合わせ方法を示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdptool browse 00:80:37:29:19:a4</span>
Browsing 00:80:37:29:19:A4 ...
Service Name: Dial-up Networking
Protocol Descriptor List:
 <span class=s2>&#34;L2CAP&#34;</span> <span class=o>(</span>0x0100<span class=o>)</span>
 <span class=s2>&#34;RFCOMM&#34;</span> <span class=o>(</span>0x0003<span class=o>)</span>
   Channel: 1

Service Name: Fax
Protocol Descriptor List:
 <span class=s2>&#34;L2CAP&#34;</span> <span class=o>(</span>0x0100<span class=o>)</span>
 <span class=s2>&#34;RFCOMM&#34;</span> <span class=o>(</span>0x0003<span class=o>)</span>
   Channel: 2

Service Name: Voice gateway
Service Class ID List:
 <span class=s2>&#34;Headset Audio Gateway&#34;</span> <span class=o>(</span>0x1112<span class=o>)</span>
 <span class=s2>&#34;Generic Audio&#34;</span> <span class=o>(</span>0x1203<span class=o>)</span>
Protocol Descriptor List:
 <span class=s2>&#34;L2CAP&#34;</span> <span class=o>(</span>0x0100<span class=o>)</span>
 <span class=s2>&#34;RFCOMM&#34;</span> <span class=o>(</span>0x0003<span class=o>)</span>
   Channel: 3</code></pre></div></div><div class="olist lowerroman"><ol class=lowerroman type=i><li><p>等々。 それぞれのサービスは属性の一覧 (たとえば RFCOMM チャネル) を持っていることに注意してください。サービスによっては、 属性のリストの一部についてメモをとっておく必要があるかもしれません。 Bluetooth 実装のいくつかは、サービスブラウジングに対応しておらず、 空の一覧を返してくるかもしれません。この場合、 特定のサービスを検索をすることは可能です。下記の例は OBEX オブジェクトプッシュ (OPUSH) サービスを検索する方法です。</p></li></ol></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdptool search --bdaddr 00:07:e0:00:0b:ca OPUSH</span></code></pre></div></div><div class=paragraph><p>FreeBSD 上における Bluetooth クライアントへのサービス提供は sdpd サーバが行います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpd</span></code></pre></div></div><div class=paragraph><p>sdptool は、ローカル SDP サーバにサービスを登録するのにも用いられます。 下記の例は PPP (LAN) サービスを備えたネットワークアクセスを登録する方法を示しています。 一部のサービスでは属性 (たとえば RFCOMM チャネル) を要求することに注意してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdptool add --channel=7 LAN</span></code></pre></div></div><div class=paragraph><p>ローカル SDP サーバに登録されたサービスの一覧は SDP ブラウザの問い合わせを "特別な" BD_ADDR に送ることで得られます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdptool browse ff:ff:ff:00:00:00</span></code></pre></div></div></div><div class=sect2><h3 id=_ダイアルアップネットワーク_dun_および_ppp_lan_を用いたネットワークアクセスプロファイル>20.4.8. ダイアルアップネットワーク (DUN) および PPP (LAN) を用いたネットワークアクセスプロファイル<a class=anchor href=#_ダイアルアップネットワーク_dun_および_ppp_lan_を用いたネットワークアクセスプロファイル></a></h3><div class=paragraph><p>ダイアルアップネットワーク (DUN) プロファイルはほとんどの場合、 モデムや携帯電話とともに使用されます。 このプロファイルが対象とする場面は以下のものです。</p></div><div class=ulist><ul><li><p>コンピュータから携帯電話またはモデムを、 ダイアルアップインターネットアクセスサーバへの接続、 または他のダイアルアップサービスを利用するための無線モデムとして使うこと</p></li><li><p>データ呼び出しを受けるための、 コンピュータによる携帯電話またはモデムの使用</p></li></ul></div><div class=paragraph><p>PPP (LAN) によるネットワークアクセスプロファイルは、 次の状況で利用できます。</p></div><div class=ulist><ul><li><p>単一の Bluetooth デバイスへの LAN アクセス</p></li><li><p>マルチ Bluetooth デバイスへの LAN アクセス</p></li><li><p>(シリアルケーブルエミュレーション上の PPP ネットワーク接続を使用した) PC から PC への接続</p></li></ul></div><div class=paragraph><p>FreeBSD ではどちらのプロファイルも <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> (RFCOMM Bluetooth 接続を PPP が制御可能なように変換するラッパ) で実装されています。 いずれかのプロファイルが使用可能となる前に、 <span class=filename>/etc/ppp/ppp.conf</span> 内に新しい PPP ラベルが作成されていなければなりません。 例については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> のマニュアルページを参照してください。</p></div><div class=paragraph><p>次の例では、DUN RFCOMM チャネル上で BD_ADDR が 00:80:37:29:19:a4 のリモートデバイスへの RFCOMM 接続を開くのに <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> が使われます。実際の RFCOMM チャネル番号は SDP を介してリモートデバイスから得ます。 手動で RFCOMM チャネルを指定することもでき、その場合 <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> は SDP 問い合わせを実行しません。 リモートデバイス上の RFCOMM チャネルを見つけるには、 sdptool を使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>PPP (LAN) サービスでネットワークアクセスを提供するためには、 sdpd サーバが動いていなければなりません。 これはローカル SDP サーバに LAN サービスを登録するのにも必要です。 LAN サービスは RFCOMM チャネル属性を必要とすることに注意してください。 <span class=filename>/etc/ppp/ppp.conf</span> ファイル内に LAN クライアントの新しいエントリを作成しなければなりません。 例については <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> のマニュアルページを参照してください。 最後に、RFCOMM PPP サーバが実行され、 ローカル SDP サーバに登録されているのと同じ RFCOMM チャネルで待ち受けていなければなりません。 次の例は RFCOMM PPP サーバを起動する方法を示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect2><h3 id=_obex_プッシュ_opush_プロファイル>20.4.9. OBEX プッシュ (OPUSH) プロファイル<a class=anchor href=#_obex_プッシュ_opush_プロファイル></a></h3><div class=paragraph><p>OBEX はモバイルデバイス間で広く使われている単純なファイル転送プロトコルです。 これは主に赤外線通信で利用されており、ノートパソコンや PDA 間の汎用的なファイル転送、および PIM アプリケーションを搭載した携帯電話その他のデバイス間で名刺やカレンダーエントリを転送するのに用いられます。</p></div><div class=paragraph><p>OBEX サーバおよびクライアントは、 <a href=http://www.geocities.com/m_evmenkin/>ここ</a> からダウンロードできる obexapp-1.0 という第三者のパッケージとして実装されています。 このパッケージは openobex ライブラリ (上記の obexapp に含まれます) および <a class=package href=https://cgit.freebsd.org/ports/tree/devel/glib12/>devel/glib12</a> port を必要とします。 なお、obexapp はルート権限を必要としません。</p></div><div class=paragraph><p>OBEX クライアントは OBEX サーバとの間でオブジェクトを渡したり (プッシュ) および受け取ったり (プル) するのに使用されます。 オブジェクトは、たとえば名刺や予定などになります。 OBEX クライアントは RFCOMM チャネル番号を SDP によってリモートデバイスから得ることができます。 これは RFCOMM チャネル番号の代わりにサービス名を指定することによって行うことができます。 対応しているサービス名は IrMC, FTRN および OPUSH です。 RFCOMM チャネルを番号で指定することもできます。 下記は、デバイス情報オブジェクトを携帯電話から受け取り、 新しいオブジェクト (名刺) が携帯電話に渡される場合の OBEX セッションの例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get
get: remote file&gt; telecom/devinfo.txt
get: <span class=nb>local </span>file&gt; devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put
put: <span class=nb>local </span>file&gt; new.vcf
put: remote file&gt; new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>OBEX プッシュサービスを提供するためには、 sdpd サーバが実行されていなければなりません。 また OPUSH サービスをローカル SDP サーバに登録することも必要です。 なお、OPUSH サービスには RFCOMM チャネル属性が必要です。 渡されるオブジェクトをすべて格納するルートフォルダを作成しなければいけません。 ルートフォルダのデフォルトパスは <span class=filename>/var/spool/obex</span> です。 最後に OBEX サーバが実行され、 ローカル SDP サーバに登録されているのと同じ RFCOMM チャネルで待ち受けていなければなりません。 下記の例は OBEX サーバの起動方法を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect2><h3 id=_シリアルポート_sp_プロファイル>20.4.10. シリアルポート (SP) プロファイル<a class=anchor href=#_シリアルポート_sp_プロファイル></a></h3><div class=paragraph><p>シリアルポート (SP) プロファイルは Bluetooth デバイスが RS232 (または同様の) シリアルケーブルエミュレーションを行えるようにします。 このプロファイルが対象とする場面は、 レガシーアプリケーションが、仮想シリアルポート抽象を介して Bluetooth をケーブルの代替品として使うところです。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> ユーティリティはシリアルポートプロファイルを実装します。 Pseudo tty が仮想シリアルポート抽象概念として用いられます。 下記の例はリモートデバイスのシリアルポートサービスへ接続する方法を示します。 なお、RFCOMM チャネルを指定する必要はありません。- <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> は SDP を介してリモートデバイスからその情報を得ることができます。 これを上書きしたい場合にはコマンドラインで RFCOMM チャネルを指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</span>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</code></pre></div></div><div class=paragraph><p>接続された pseudo tty はシリアルポートとして利用することができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l ttyp6</span></code></pre></div></div></div><div class=sect2><h3 id=_トラブルシューティング_2>20.4.11. トラブルシューティング<a class=anchor href=#_トラブルシューティング_2></a></h3><div class=sect3><h4 id=_リモートデバイスが接続できません>20.4.11.1. リモートデバイスが接続できません<a class=anchor href=#_リモートデバイスが接続できません></a></h4><div class=paragraph><p>古い Bluetooth デバイスのなかにはロールスイッチング (role switching) に対応していないものがあります。 デフォルトでは FreeBSD が新しい接続を受け付けるときに、 ロールスイッチを実行してマスタになろうとします。 これに対応していないデバイスは接続できないでしょう。 なお、ロールスイッチングは新しい接続が確立されるときに実行されるので、 ロールスイッチングに対応しているかどうかリモートデバイスに問い合わせることはできません。 ローカル側でロールスイッチングを無効にする HCI オプションがあります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div></div><div class=sect3><h4 id=_何かがうまくいっていないみたいです_何が実際に起こっているか確認できますか>20.4.11.2. 何かがうまくいっていないみたいです。 何が実際に起こっているか確認できますか?<a class=anchor href=#_何かがうまくいっていないみたいです_何が実際に起こっているか確認できますか></a></h4><div class=paragraph><p>できます。 <a href=http://www.geocities.com/m_evmenkin/>ここ</a> からダウンロードできる第三者パッケージ hcidump-1.5 を使ってください。 hcidump ユーティリティは <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> と似ています。 これはターミナル上の Bluetooth パケットの内容の表示および Bluetooth パケットをファイルにダンプするのに使えます。</p></div></div></div></div></div><div class=sect1><h2 id=network-bridging>20.5. ブリッジ<a class=anchor href=#network-bridging></a></h2><div class=sectionbody><div class=sect2><h3 id=_はじめに_3>20.5.1. はじめに<a class=anchor href=#_はじめに_3></a></h3><div class=paragraph><p>IP サブネットを作成して、 それらのセグメントをルータを使って接続することなしに、 (Ethernet セグメントのような) 一つの物理ネットワークを二つのネットワークセグメントに分割することはとても有効な場合があります。 この方法で二つのネットワークを繋ぐデバイスは "ブリッジ" と呼ばれます。 二つのネットワークインタフェースカードを持つ FreeBSD システムは、ブリッジとして動作することができます。</p></div><div class=paragraph><p>ブリッジは、各ネットワークインタフェイスに繋がるデバイスの MAC 層のアドレス (Ethernet アドレス) を記憶することにより動作します。 ブリッジはトラフィックの送信元と受信先が異なったネットワーク上にある場合にのみトラフィックを転送します。</p></div><div class=paragraph><p>多くの点で、ブリッジはポート数の少ない Ethernet スイッチのようなものといえます。</p></div></div><div class=sect2><h3 id=_ブリッジがふさわしい状況>20.5.2. ブリッジがふさわしい状況<a class=anchor href=#_ブリッジがふさわしい状況></a></h3><div class=paragraph><p>今日ブリッジが活躍する場面は大きく分けて二つあります。</p></div><div class=sect3><h4 id=_トラフィックの激しいセグメント>20.5.2.1. トラフィックの激しいセグメント<a class=anchor href=#_トラフィックの激しいセグメント></a></h4><div class=paragraph><p>ひとつは、 物理ネットワークセグメントがトラフィック過剰になっているが、 なんらかの理由によりネットワークをサブネットに分け、 ルータで接続することができない場合です。</p></div><div class=paragraph><p>編集部門と製作部門がおなじサブネットに同居している新聞社を例に考えてみましょう。 編集部門のユーザはファイルサーバとして全員サーバ <code>A</code> を利用し、 製作部門のユーザはサーバ <code>B</code> を利用します。 すべてのユーザを接続するのには Ethernet が使われており、 高負荷となったネットワークは遅くなってしまいます。</p></div><div class=paragraph><p>もし編集部門のユーザを一つのネットワークセグメントに分離することができ、 製作部門のユーザも同様にできるのなら、 二つのネットワークセグメントをブリッジで繋ぐことができます。 ブリッジの "反対" 側へ向かうネットワークトラフィックだけが転送され、 各ネットワークセグメントの混雑は緩和されます。</p></div></div><div class=sect3><h4 id=_パケットフィルタ帯域制御用ファイアウォール>20.5.2.2. パケットフィルタ/帯域制御用ファイアウォール<a class=anchor href=#_パケットフィルタ帯域制御用ファイアウォール></a></h4><div class=paragraph><p>もうひとつはネットワークアドレス変換 (NAT) を使わずにファイアウォール機能を利用したい場合です。</p></div><div class=paragraph><p>ここでは DSL もしくは ISDN で ISP に接続している小さな会社を例にとってみましょう。 この会社は ISP からグローバル IP アドレスを 13 個割り当てられており、ネットワーク上には 10 台の PC が存在します。 このような状況では、サブネット化にまつわる問題から、 ルータを用いたファイアウォールを利用することは困難です。</p></div><div class=paragraph><p>ブリッジを用いたファイアウォールなら、 IP アドレスの問題を気にすること無く、 DSL/ISDN ルータの下流側に置くように設定できます。</p></div></div></div><div class=sect2><h3 id=_ブリッジを設定する>20.5.3. ブリッジを設定する<a class=anchor href=#_ブリッジを設定する></a></h3><div class=sect3><h4 id=_ネットワークインタフェースカードの選択>20.5.3.1. ネットワークインタフェースカードの選択<a class=anchor href=#_ネットワークインタフェースカードの選択></a></h4><div class=paragraph><p>ブリッジを利用するには少なくとも 2 枚のネットワークカードが必要です。 残念なことに FreeBSD 4.0 ではすべてのネットワークインタフェースカードがブリッジ機能に対応しているわけではありません。 カードに対応しているかどうかについては <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> を参照してください。</p></div><div class=paragraph><p>以下に進む前に、 二枚のネットワークカードをインストールしてテストしてください。</p></div></div><div class=sect3><h4 id=_カーネルコンフィグレーションの変更>20.5.3.2. カーネルコンフィグレーションの変更<a class=anchor href=#_カーネルコンフィグレーションの変更></a></h4><div class=paragraph><p>カーネルでブリッジ機能を有効にするには</p></div><div class="literalblock programlisting"><div class=content><pre>options BRIDGE</pre></div></div><div class=paragraph><p>という行をカーネルコンフィグレーションファイルに追加して カーネルを再構築してください。</p></div></div><div class=sect3><h4 id=_ファイアウォール対応>20.5.3.3. ファイアウォール対応<a class=anchor href=#_ファイアウォール対応></a></h4><div class=paragraph><p>ファイアウォールとしてブリッジを利用しようとしている場合には <code>IPFIREWALL</code> オプションも指定する必要があります。 ブリッジをファイアウォールとして設定する際の一般的な情報に関しては、 ファイアウォールの章 を参照してください。</p></div><div class=paragraph><p>IP 以外のパケット (ARP など) がブリッジを通過するようにするためには、 ファイアウォール用オプションを設定しなければなりません。 このオプションは <code>IPFIREWALL_DEFAULT_TO_ACCEPT</code> です。この変更により、 デフォルトではファイアウォールがすべてのパケットを受け入れるようになることに注意してください。 この設定を行う前に、 この変更が自分のルールセットにどのような影響をおよぼすかを把握しておかなければなりません。</p></div></div><div class=sect3><h4 id=_帯域制御機能>20.5.3.4. 帯域制御機能<a class=anchor href=#_帯域制御機能></a></h4><div class=paragraph><p>ブリッジで帯域制御機能を利用したい場合、 カーネルコンフィグレーションで <code>DUMMYNET</code> オプションを加える必要があります。 詳しい情報に関しては <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> を参照してください。</p></div></div></div><div class=sect2><h3 id=_ブリッジを有効にする>20.5.4. ブリッジを有効にする<a class=anchor href=#_ブリッジを有効にする></a></h3><div class=paragraph><p>ブリッジを有効にするには、 <span class=filename>/etc/sysctl.conf</span> に以下の行を加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge=1</pre></div></div><div class=paragraph><p>指定したインタフェースでブリッジを可能にするには以下を加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge_cfg=if1,if2</pre></div></div><div class=paragraph><p>(<em>if1</em> および <em>if2</em> は二つのネットワークインタフェースの名前に置き換えてください)。 ブリッジを経由したパケットを <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> でフィルタしたい場合には、 以下の行も付け加える必要があります</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge_ipfw=1</pre></div></div><div class=paragraph><p>FreeBSD 5.2-RELEASE 以降では、かわりに以下の行を使用してください。</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.enable=1
 net.link.ether.bridge.config=if1,if2
 net.link.ether.bridge.ipfw=1</pre></div></div></div><div class=sect2><h3 id=_その他の情報>20.5.5. その他の情報<a class=anchor href=#_その他の情報></a></h3><div class=paragraph><p>ネットワークからブリッジに <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> したい場合、 ネットワークカードの一つに IP アドレスを割り当てるのが正しいです。 一般的に、両方のカードに IP アドレスを割り当てるのはよい考えではないとされています。</p></div><div class=paragraph><p>ネットワーク内に複数のブリッジを設置する場合、 任意のワークステーション間で一つ以上の経路を持つことはできません。 技術的には、 これはスパニングツリーのリンク制御はサポートされていない、 ということを意味します。</p></div><div class=paragraph><p>ブリッジは、<a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> にかかる時間を遅らせることがあります。特に、 一方のセグメントからもう一方へのトラフィックでそうなります。</p></div></div></div></div><div class=sect1><h2 id=network-nfs>20.6. NFS<a class=anchor href=#network-nfs></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD がサポートしている多くのファイルシステムの中には、 NFS とも呼ばれているネットワークファイルシステムがあります。 NFS はあるマシンから他のマシンへと、 ネットワークを通じてディレクトリとファイルを共有することを可能にします。 NFS を使うことで、 ユーザやプログラムはリモートシステムのファイルを、 それがローカルファイルであるかのようにアクセスすることができます。</p></div><div class=paragraph><p>NFS が提供可能な最も特筆すべき利点いくつかは以下のものです。</p></div><div class=ulist><ul><li><p>一般的に使われるデータを単一のマシンに納めることができ、 ユーザはネットワークを通じてデータにアクセスできるため、 ローカルワークステーションが使用するディスク容量が減ります。</p></li><li><p>ネットワーク上のすべてのマシンに、 ユーザが別々にホームディレクトリを持つ必要がありません。 NFS サーバ上にホームディレクトリが設定されれば、 ネットワークのどこからでもアクセス可能です。</p></li><li><p>フロッピーディスクや CDROM ドライブ、 ZIP ドライブなどのストレージデバイスを、 ネットワーク上の他のマシンで利用することができます。 ネットワーク全体のリムーバブルドライブの数を減らせるかもしれません。</p></li></ul></div><div class=sect2><h3 id=_nfs_はどのように動作するのか>20.6.1. NFS はどのように動作するのか<a class=anchor href=#_nfs_はどのように動作するのか></a></h3><div class=paragraph><p>NFS は最低二つの主要な部分、 サーバと一つ以上のクライアントからなります。 クライアントはサーバマシン上に格納されたデータにリモートからアクセスします。 これが適切に機能するには、 いくつかのプロセスが設定されて実行されていなければなりません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.X では <code>portmap</code> ユーティリティは rpcbind ユーティリティに置き換わりました。 したがって FreeBSD 5.X では、ユーザは下記の例で、 portmap の例のすべてを <code>rpcbind</code> に置き換える必要があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>サーバは以下のデーモンを動作させなければなりません。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">デーモン</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nfsd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NFS クライアントからのリクエストを処理する NFS デーモン</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>mountd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=nfsd&amp;sektion=8&amp;format=html">nfsd(8)</a> から渡されたリクエストを実際に実行する NFS マウントデーモン</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>portmap</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NFS サーバの利用しているポートを NFS クライアントから取得できるようにするためのポートマッパデーモン</p></td></tr></tbody></table><div class=paragraph><p>クライアント側では nfsiod というデーモンも実行できます。 nfsiod デーモンは NFS サーバからのリクエストを処理します。 これは任意であり、性能を改善しますが、 通常の正しい動作には必要としません。詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=nfsiod&amp;sektion=8&amp;format=html">nfsiod(8)</a> マニュアルページを参照してください。</p></div></div><div class=sect2><h3 id=network-configuring-nfs>20.6.2. NFS の設定<a class=anchor href=#network-configuring-nfs></a></h3><div class=paragraph><p>NFS の設定は比較的素直な工程です。 動かさなければならないプロセスは <span class=filename>/etc/rc.conf</span> ファイルを少し変更すれば起動時に実行させられます。</p></div><div class=paragraph><p>NFS サーバでは <span class=filename>/etc/rc.conf</span> ファイルの中で、 以下のオプションが設定されていることを確かめてください。</p></div><div class="literalblock programlisting"><div class=content><pre>portmap_enable=&#34;YES&#34;
nfs_server_enable=&#34;YES&#34;
mountd_flags=&#34;-r&#34;</pre></div></div><div class=paragraph><p><code>mountd</code> は NFS サーバが有効になっていれば、 自動的に実行されます。</p></div><div class=paragraph><p>クライアント側では <span class=filename>/etc/rc.conf</span> 内に以下の設定があることを確認してください。</p></div><div class="literalblock programlisting"><div class=content><pre>nfs_client_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p><span class=filename>/etc/exports</span> ファイルは NFS サーバがどのファイルシステムをエクスポート (ときどき "共有" と呼ばれます) するのかを指定します。 <span class=filename>/etc/exports</span> ファイル中の各行は、 エクスポートするファイルシステム、 およびそのファイルシステムにアクセスできるマシンを指定します。 ファイルシステムにアクセスできるマシンとともに、 アクセスオプションも指定できます。 このファイルで指定できるオプションはたくさんありますが、 ここではほんの少しだけ言及します。<a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> マニュアルページを読めば、 他のオプションは簡単にみつけられるでしょう。</p></div><div class=paragraph><p>いくつか <span class=filename>/etc/exports</span> の設定例を示します。</p></div><div class=paragraph><p>以下の例はファイルシステムのエクスポートの考え方を示しますが、 あなたの環境とネットワーク設定に応じて設定は少し変わるでしょう。 たとえば次の行は <span class=filename>/cdrom</span> ディレクトリを、サーバと同じドメイン名か (そのため、いずれもドメイン名がありません)、 <span class=filename>/etc/hosts</span> に記述されている三つの例となるマシンに対してエクスポートします。 <code>-ro</code> フラグは共有されるファイルシステムを読み込み専用にします。 このフラグにより、 リモートシステムは共有されたファイルシステムに対して何の変更も行えなくなります。</p></div><div class="literalblock programlisting"><div class=content><pre>/cdrom -ro host1 host2 host3</pre></div></div><div class=paragraph><p>以下の設定は IP アドレスで指定した 3 つのホストに対して <span class=filename>/home</span> をエクスポートします。 この設定はプライベートネットワークで DNS が設定されていない場合に便利でしょう。 内部のホスト名に対して <span class=filename>/etc/hosts</span> を設定するという手段もあります。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> を参照してください。 <code>-alldirs</code> フラグはサブディレクトリがマウントポイントとなることを認めます。 言い替えると、これはサブディレクトリをマウントしませんが、 クライアントが要求するか、 または必要とするディレクトリだけをマウントできるようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</pre></div></div><div class=paragraph><p>以下の設定は、サーバとは異なるドメイン名の 2 台のクライアントがアクセスできるように <span class=filename>/a</span> をエクスポートします。 <code>-maproot=root</code> フラグは、リモートシステムの <code>root</code> ユーザが、 エクスポートされたファイルシステムに <code>root</code> として書き込むことを許可します。 <code>-maproot=root</code> フラグが無ければ、 リモートマシンの <code>root</code> 権限を持っていても、 共有されたファイルシステム上のファイルを変更することはできないでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>/a  -maproot=root  host.example.com box.example.org</pre></div></div><div class=paragraph><p>クライアントがエクスポートされたファイルシステムにアクセスするためには、 そうする権限が与えられていなければなりません。 <span class=filename>/etc/exports</span> ファイルに クライアントが含まれているかどうか確認してください。</p></div><div class=paragraph><p><span class=filename>/etc/exports</span> ファイルでは、 それぞれの行が一つのファイルシステムを一つのホストにエクスポートすることを表します。 リモートホストはファイルシステム毎に一度だけ指定することができ、 それに加えて一つのデフォルトエントリを置けます。たとえば <span class=filename>/usr</span> が単一のファイルシステムであると仮定します。 次の <span class=filename>/etc/exports</span> は無効です。</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src   client
/usr/ports client</pre></div></div><div class=paragraph><p>単一のファイルシステムである <span class=filename>/usr</span> は、2 行に渡って、同じホスト <code>client</code> へエクスポートされています。 この場合、正しい書式は次のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src /usr/ports  client</pre></div></div><div class=paragraph><p>あるホストにエクスポートされるある 1 つのファイルシステムのプロパティは、 1 行ですべて指定しなければなりません。 クライアントの指定のない行は、単一のホストとして扱われます。 これはファイルシステムをエクスポートできる方法を制限しますが、 多くの場合これは問題になりません。</p></div><div class=paragraph><p>下記は、 <span class=filename>/usr</span> および <span class=filename>/exports</span> がローカルファイルシステムである場合の、 有効なエクスポートリストの例です。</p></div><div class="literalblock programlisting"><div class=content><pre># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</pre></div></div><div class=paragraph><p>変更が有効となるように、 <span class=filename>/etc/exports</span> が変更されたら <code>mountd</code> を再起動しなければなりません。 これは <code>mountd</code> プロセスに HUP シグナルを送ることで実行できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/mountd.pid`</span></code></pre></div></div><div class=paragraph><p>他には、再起動すれば、FreeBSD はすべてを適切に設定します。 しかしながら、再起動は必須ではありません。 <code>root</code> 権限で以下のコマンドを実行すれば、すべてが起動するでしょう。</p></div><div class=paragraph><p>NFS サーバでは</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmap</span>
<span class=c># nfsd -u -t -n 4</span>
<span class=c># mountd -r</span></code></pre></div></div><div class=paragraph><p>NFS クライアントでは</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nfsiod -n 4</span></code></pre></div></div><div class=paragraph><p>これでリモートのファイルシステムを実際にマウントする準備がすべてできました。 この例では、サーバの名前は <code>server</code> で、 クライアントの名前は <code>client</code> とします。 リモートファイルシステムを一時的にマウントするだけ、 もしくは設定をテストするだけなら、クライアント上で <code>root</code> 権限で以下のコマンドを実行するだけです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount server:/home /mnt</span></code></pre></div></div><div class=paragraph><p>これで、サーバの <span class=filename>/home</span> ディレクトリが、クライアントの <span class=filename>/mnt</span> にマウントされます。もしすべてが正しく設定されていれば、 クライアントの /mnt に入り、 サーバにあるファイルすべてを見れるはずです。</p></div><div class=paragraph><p>リモートファイルシステムを起動のたびに自動的にマウントしたいなら、 ファイルシステムを <span class=filename>/etc/fstab</span> ファイルに追加してください。 例としてはこのようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>server:/home	/mnt	nfs	rw	0	0</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> マニュアルページに利用可能なオプションがすべて掲載されています。</p></div></div><div class=sect2><h3 id=_実用的な使い方>20.6.3. 実用的な使い方<a class=anchor href=#_実用的な使い方></a></h3><div class=paragraph><p>NFS には実用的な使用法がいくつもあります。 ここで典型的な使用法をいくつか紹介しましょう。</p></div><div class=ulist><ul><li><p>何台ものマシンで CDROM などのメディアを共有するように設定します。 これは安上がりで、たいていは、 複数のマシンにソフトウェアをインストールするのにより便利な方法です。</p></li><li><p>大規模なネットワークでは、 すべてのユーザのホームディレクトリを格納するメイン NFS サーバを構築すると、ずっと便利でしょう。 どのワークステーションにログインしても、 ユーザがいつでも同じホームディレクトリを利用できるように、 これらのホームディレクトリはネットワークに向けてエクスポートされます。</p></li><li><p>何台ものマシンで <span class=filename>/usr/ports/distfiles</span> ディレクトリを共有できます。こうすると、 何台ものマシン上に port をインストールする必要がある時に、 それぞれのマシンでソースコードをダウンロードすることなく、 直ちにソースにアクセスできます。</p></li></ul></div></div><div class=sect2><h3 id=network-amd>20.6.4. amd による自動マウント<a class=anchor href=#network-amd></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> (自動マウントデーモン) は、 ファイルシステム内のファイルまたはディレクトリがアクセスされると、 自動的にリモートファイルシステムをマウントします。 また、一定の間アクセスされないファイルシステムは amd によって自動的にアンマウントされます。 amd を使用することは、通常 <span class=filename>/etc/fstab</span> 内に記述する恒久的なマウントに対する、 単純な代替案となります。</p></div><div class=paragraph><p>amd はそれ自身を NFS サーバとして <span class=filename>/host</span> および <span class=filename>/net</span> ディレクトリに結びつけることによって動作します。 このディレクトリ内のどこかでファイルがアクセスされると、 amd は対応するリモートマウントを調べて、 自動的にそれをマウントします。 <span class=filename>/net</span> が、エクスポートされたファイルシステムを IP アドレスで指定してマウントするのに利用される一方で、 <span class=filename>/host</span> は、エクスポートされたファイルシステムをリモートホスト名で指定してマウントするのに利用されます。</p></div><div class=paragraph><p><span class=filename>/host/foobar/usr</span> 内のファイルにアクセスすると、 amd はホスト <code>foobar</code> からエクスポートされた <span class=filename>/usr</span> をマウントします。</p></div><div class=exampleblock><div class=title>例 1. amd によるエクスポートされたファイルシステムのマウント</div><div class=content><div class=paragraph><p><code>showmount</code> コマンドを用いて、 リモートホストのマウントで利用できるものが見られます。 たとえば、<code>foobar</code> と名付けられたホストのマウントを見るために次のように利用できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% showmount <span class=nt>-e</span> foobar
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
% <span class=nb>cd</span> /host/foobar/usr</code></pre></div></div></div></div><div class=paragraph><p>例のように <code>showmount</code> はエクスポートとして <span class=filename>/usr</span> を表示します。 <span class=filename>/host/foobar/usr</span> にディレクトリを変更すると、 amd はホスト名 <code>foobar</code> を解決し、お望みのエクスポートをマウントしようと試みます。</p></div><div class=paragraph><p>amd は <span class=filename>/etc/rc.conf</span> 内に次の行を記述すれば、 起動スクリプトによって起動されます。</p></div><div class="literalblock programlisting"><div class=content><pre>amd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>さらに <code>amd_flags</code> オプションによって amd にフラグをカスタマイズして渡せます。デフォルトでは <code>amd_flags</code> は次のように設定されています。</p></div><div class="literalblock programlisting"><div class=content><pre>amd_flags=&#34;-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map&#34;</pre></div></div><div class=paragraph><p><span class=filename>/etc/amd.map</span> ファイルは、 エクスポートがマウントされるデフォルトオプションを決定します。 <span class=filename>/etc/amd.conf</span> ファイルは、 amd のより高度な機能の一部を設定します。</p></div><div class=paragraph><p>詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=amd.conf&amp;sektion=8&amp;format=html">amd.conf(8)</a> マニュアルページを参照してください。</p></div></div><div class=sect2><h3 id=network-nfs-integration>20.6.5. 他のシステムとの統合についての問題<a class=anchor href=#network-nfs-integration></a></h3><div class=paragraph><p>ISA バス用のイーサネットアダプタの中には性能が悪いため、 ネットワーク、特に NFS で深刻な問題がおきるものがあります。 これは FreeBSD に限ったことではありませんが FreeBSD でも起こり得ます。</p></div><div class=paragraph><p>この問題は (FreeBSD を使用した) PC がシリコングラフィックス社やサン・マイクロシステムズ社などの高性能なワークステーションにネットワーク接続されている場合に頻繁に起こります。 NFS マウントはうまく動作するでしょう。 また、いくつかの操作もうまく動作するかもしれませんが、 他のシステムに対する要求や応答は続いていても、 突然サーバがクライアントの要求に対して応答しなくなります。これは、 クライアントが FreeBSD か上記のワークステーションであるときにクライアント側に起きる現象です。 多くのシステムでは、いったんこの問題が現われると、 行儀良くクライアントを終了する手段はありません。 NFS がこの状態に陥ってしまうと正常に戻すことはできないため、 多くの場合クライアントをリセットすることが唯一の解決法となります。</p></div><div class=paragraph><p>"正しい" 解決法は、より高性能のイーサネットアダプタを FreeBSD システムにインストールすることですが、 満足に動作させる簡単な方法があります。 FreeBSD システムが <em>サーバ</em> になるのなら、 クライアントからのマウント時に <code>-w=1024</code> オプションをつけて下さい。FreeBSD システムが <em>クライアント</em> になるのなら、 NFS ファイルシステムを <code>-r=1024</code> オプションつきでマウントして下さい。 これらのオプションは自動的にマウントをおこなう場合には クライアントの <span class=filename>fstab</span> エントリの 4 番目のフィールドに指定してもよいですし、 手動マウントの場合は mount コマンドの <code>-o</code> パラメータで指定してもよいでしょう。</p></div><div class=paragraph><p>NFS サーバとクライアントが別々のネットワーク上にあるような場合、 これと間違えやすい他の問題が起きることに注意して下さい。 そのような場合は、ルータが必要な UDP 情報をきちんとルーティングしているかを確かめて下さい。 していなければ、たとえあなたが何をしようと解決できないでしょう。</p></div><div class=paragraph><p>次の例では <code>fastws</code> は高性能ワークステーションのホスト (インタフェース) 名で、 <code>freebox</code> は低性能のイーサネットアダプタを備えた FreeBSD システムのホスト (インタフェース) 名です。 また <span class=filename>/sharedfs</span> はエクスポートされる NFS ファイルシステムであり (<a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> を参照) 、 <span class=filename>/project</span> はエクスポートされたファイルシステムの、 クライアント上のマウントポイントとなります。 すべての場合において、アプリケーションによっては <code>hard</code> や <code>soft</code>, <code>bg</code> といった追加オプションがふさわしいかもしれないことに注意して下さい。</p></div><div class=paragraph><p>クライアント側 FreeBSD システム (<code>freebox</code>) の <span class=filename>/etc/fstab</span> の例は以下のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>fastws:/sharedfs /project nfs rw,-r=1024 0 0</pre></div></div><div class=paragraph><p><code>freebox</code> 上で手動で mount コマンドを実行する場合は次のようにして下さい。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs -o -r=1024 fastws:/sharedfs /project</span></code></pre></div></div><div class=paragraph><p>サーバ側 FreeBSD システム (<code>fastws</code>) の <span class=filename>/etc/fstab</span> の例は以下のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>freebox:/sharedfs /project nfs rw,-w=1024 0 0</pre></div></div><div class=paragraph><p><code>fastws</code> 上で手動で mount コマンドで実行する場合は次のようにして下さい。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs -o -w=1024 freebox:/sharedfs /project</span></code></pre></div></div><div class=paragraph><p>近いうちにどのような 16 ビットのイーサネットアダプタでも、上記の読み出し、 書き込みサイズの制限なしで操作できるようになるでしょう。</p></div><div class=paragraph><p>失敗が発生したとき何が起きているか関心のある人に、 なぜ回復不可能なのかも含めて説明します。NFS は通常 (より小さいサイズへ分割されるかもしれませんが) 8 K の "ブロック" サイズで動作します。 イーサネットのパケットサイズは最大 1500 バイト程度なので、 上位階層のコードにとっては 1 つのユニットであって、 NFS "ブロック" は複数のイーサネットパケットに分割されるものの、 上位階層のコードにとっては 1 つのユニットであって、 ユニットとして受信され、組み立て直され、 <em>肯定応答</em> (ACK) されなければなりません。 高性能のワークステーションは次々に NFS ユニットを構成するパケットを、 標準の許す限り間隔を詰めて次々に送り出すことができます。 小さく、容量の低いカードでは、 同じユニットの前のパケットがホストに転送される前に、 後のパケットがそれを踏みつぶしてしまいます。 このため全体としてのユニットは、再構成も肯定応答もできません。 その結果、 ワークステーションはタイムアウトして再送を試みますが、 8 K のユニット全体を再送しようとするので、 このプロセスは際限無く繰り返されてしまいます。</p></div><div class=paragraph><p>ユニットサイズをイーサネットのパケットサイズの 制限以下に抑えることにより、 受信した完全なイーサネットパケットについて個々に肯定応答を返せることが保証されるので、 デッドロック状態を避けられるようになります。</p></div><div class=paragraph><p>それでも、高性能なワークステーションが力任せに次々と PC システムにデータを送ったときには踏みつぶしが起きるかもしれません。 しかし、高性能のカードを使っていれば、NFS "ユニット" で必ずそのような踏みつぶしが起きるとは限りません。 踏みつぶしが起きたら、影響を受けたユニットは再送されて、 受信され、組み立てられ、肯定応答される十分な見込みがあります。</p></div></div></div></div><div class=sect1><h2 id=network-diskless>20.7. ディスクレス稼働<a class=anchor href=#network-diskless></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD マシンはネットワークを通じて起動でき、 そして NFS サーバからマウントしたファイルシステムを使用して、 ローカルディスクなしで動作することができます。 標準の設定ファイルを変更する以上の、システムの修正は必要ありません。 必要な要素のすべてが用意されているので、 このようなシステムを設定するのは簡単です。</p></div><div class=ulist><ul><li><p>ネットワークを通じてカーネルを読み込む方法は、 少なくとも二つあります。</p><div class=ulist><ul><li><p>PXE: Intel® の Preboot Execution Environment システムは、 一部のネットワークカードまたはマザーボードに組み込まれた、 スマートなブート ROM の一形態です。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> を参照してください。</p></li><li><p>port の etherboot (<a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a>) は、 ネットワークを通じてカーネルを起動する ROM 化可能なコードを提供します。 コードはネットワークカード上のブート PROM に焼き付けるか、 あるいはローカルフロッピー (ハード) ディスクドライブ、 または動作している MS-DOS® システムから読み込むことができます。 多くのネットワークカードに対応しています。</p></li></ul></div></li><li><p>サンプルスクリプト (<span class=filename>/usr/shared/examples/diskless/clone_root</span>) はサーバ上で、 ワークステーションのルートファイルシステムの作成と維持をやり易くします。 このスクリプトは少し書き換えないといけないでしょうが、 早く取り掛かれるようにします。</p></li><li><p>ディスクレスシステム起動を検知しサポートする標準のシステム起動ファイルが <span class=filename>/etc</span> 内にあります。</p></li><li><p>必要なら、NFS ファイルまたはローカルディスクのどちらかにスワップできます。</p></li></ul></div><div class=paragraph><p>ディスクレスワークステーションを設定する方法はいろいろあります。 多くの要素が関わっており、 その多くはローカルの状況に合わせてカスタマイズできます。下記は、 単純さと標準の FreeBSD 起動スクリプトとの互換性を強調した完全なシステムの設定を説明します。 記述されているシステムの特徴は次のとおりです。</p></div><div class=ulist><ul><li><p>ディスクレスワークステーションは、 共有された読み取り専用の <span class=filename>ルート</span>ファイルシステムと、 共有された読み取り専用の <span class=filename>/usr</span> を使用します。</p><div class=paragraph><p><span class=filename>ルート</span> ファイルシステムは、 標準的な FreeBSD (典型的にはサーバの) のルートのコピーで、 一部の設定ファイルが、ディスクレス稼働、 また場合によってはそのワークステーションに特有のもので上書きされています。</p></div><div class=paragraph><p>書き込み可能でなければならない <span class=filename>ルート</span> の部分は <a href="https://man.freebsd.org/cgi/man.cgi?query=mfs&amp;sektion=8&amp;format=html">mfs(8)</a> ファイルシステムで覆われます。 システムが再起動するときにはすべての変更が失われるでしょう。</p></div></li><li><p>カーネルは DHCP (または BOOTP) および TFTP を用いて etherboot によって読み込まれます。</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>記述されているとおり、 このシステムは安全ではありません。 ネットワークの保護された範囲で使用されるべきであり、 他のホストから信頼されてはいけません。</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_セットアップの手順>20.7.1. セットアップの手順<a class=anchor href=#_セットアップの手順></a></h3><div class=sect3><h4 id=_dhcpbootp_の設定>20.7.1.1. DHCP/BOOTP の設定<a class=anchor href=#_dhcpbootp_の設定></a></h4><div class=paragraph><p>ネットワークを通じて設定を取得し、 ワークステーションを起動するために一般的に使用されるプロトコルには、 BOOTP と DHCP の 2 つがあります。 それらはワークステーションのブートストラップ時に何ヵ所かで使用されます。</p></div><div class=ulist><ul><li><p>etherboot はカーネルを見つけるために DHCP (デフォルト) または BOOTP (設定オプションが必要) を使用します (PXE は DHCP を使用します) 。</p></li><li><p>NFS ルートの場所を定めるためにカーネルは BOOTP を使用します。</p></li></ul></div><div class=paragraph><p>BOOTP だけを使用するようにシステムを設定することもできます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=bootpd&amp;sektion=8&amp;format=html">bootpd(8)</a> サーバプログラムは FreeBSD のベースシステムに含まれています。</p></div><div class=paragraph><p>しかしながら、DHCP には BOOTP に勝る点が多々あります。 (よりよい設定ファイル、PXE が使えること、 そしてディスクレス稼働には直接関係しない多くの長所) ここでは BOOTP だけ利用する場合と、 BOOTP と DHCP を組み合わせた設定を扱います。特に ISC DHCP ソフトウェアパッケージを利用する後者の方法に重点をおきます。</p></div><div class=sect4><h5 id=_isc_dhcp_を使用する設定>20.7.1.1.1. ISC DHCP を使用する設定<a class=anchor href=#_isc_dhcp_を使用する設定></a></h5><div class=paragraph><p>isc-dhcp サーバは、 BOOTP および DHCP リクエストの両方に答えることができます。</p></div><div class=paragraph><p>4.4-RELEASE の時点で isc-dhcp 3.0 はベースシステムの一部では無くなりました。 まずはじめに <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port または対応する package をインストールする必要があるでしょう。 ports および package に関する一般的な情報については <a href=../ports/#ports>アプリケーションのインストール - packages と ports</a> を参照してください。</p></div><div class=paragraph><p>isc-dhcp がインストールされると、 動作するために設定ファイルを必要とします (通常 <span class=filename>/usr/local/etc/dhcpd.conf</span> が指定されます) 。 下記にコメントを含めた例を示します。</p></div><div class="literalblock programlisting"><div class=content><pre>          default-lease-time 600;
          max-lease-time 7200;
          authoritative;

          option domain-name &#34;example.com&#34;;
          option domain-name-servers 192.168.4.1;
          option routers 192.168.4.1;

          subnet 192.168.4.0 netmask 255.255.255.0 {
            use-host-decl-names on; <i class=conum data-value=1></i><b>(1)</b>
            option subnet-mask 255.255.255.0;
            option broadcast-address 192.168.4.255;

            host margaux {
              hardware ethernet 01:23:45:67:89:ab;
              fixed-address margaux.example.com;
              next-server 192.168.4.4;<i class=conum data-value=2></i><b>(2)</b>
              filename &#34;/tftpboot/kernel.diskless&#34;;<i class=conum data-value=3></i><b>(3)</b>
              option root-path &#34;192.168.4.4:/data/misc/diskless&#34;;<i class=conum data-value=4></i><b>(4)</b>
            }
          }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>このオプションは <code>host</code> 宣言の値を、 ディスクレスホストへのホスト名として送るように <code>dhcpd</code> に指示します。 別の方法として、ホスト宣言内に <code>option host-name margaux</code> を加えるものがあります。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>TFTP サーバを <code>next-server</code> ディレクティブに指定します (デフォルトは DHCP サーバと同じホストを使います)。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>カーネルとして etherboot が読み込むファイルを <code>filename</code> ディレクティブに指定します。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>ルートファイルシステムへのパスを、 通常の NFS 書式で <code>root-path</code> オプションに指定します。</td></tr></tbody></table></div></div><div class=sect4><h5 id=_bootp_を使用する設定>20.7.1.1.2. BOOTP を使用する設定<a class=anchor href=#_bootp_を使用する設定></a></h5><div class=paragraph><p>続けて、<code>bootpd</code> で同等のことをする設定です。 これは <span class=filename>/etc/bootptab</span> におきます。</p></div><div class=paragraph><p>BOOTP を使用するために、デフォルトではない <code>NO_DHCP_SUPPORT</code> オプション付きで etherboot をコンパイルしなければならないことと、PXE は DHCP を <em>必要</em> とすることに注意してください。 bootpd の唯一明白な利点は、 これがベースシステムに存在するということです。</p></div><div class="literalblock programlisting"><div class=content><pre>          .def100:\
            :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
            :sm=255.255.255.0:\
            :ds=192.168.4.1:\
            :gw=192.168.4.1:\
            :hd=&#34;/tftpboot&#34;:\
            :bf=&#34;/kernel.diskless&#34;:\
            :rp=&#34;192.168.4.4:/data/misc/diskless&#34;:

          margaux:ha=0123456789ab:tc=.def100</pre></div></div></div></div><div class=sect3><h4 id=_etherboot_を用いるブートプログラムの準備>20.7.1.2. Etherboot を用いるブートプログラムの準備<a class=anchor href=#_etherboot_を用いるブートプログラムの準備></a></h4><div class=paragraph><p><a href=http://etherboot.sourceforge.net>Etherboot のウェブサイト</a> には主に Linux システムについて述べた<a href=http://etherboot.sourceforge.net/doc/html/userman/t1.html> 広範囲の文書</a> が含まれています。 しかし、それにもかかわらず有用な情報を含んでいます。 下記は FreeBSD システム上での etherboot の使用法についての概観を示します。</p></div><div class=paragraph><p>まずはじめに <a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a> の package または port をインストールしなければなりません。 etherboot port は通常 <span class=filename>/usr/ports/net/etherboot</span> にあります。 ports ツリーがシステムにインストールされている場合、 このディレクトリ内で <code>make</code> を実行すれば、よきに計らってくれます。 ports および packages に関する情報は <a href=../ports/#ports>アプリケーションのインストール - packages と ports</a> を参照してください。</p></div><div class=paragraph><p>ここで説明している方法では、ブートフロッピーを使用します。 他の方法 (PROM または DOS プログラム) については etherboot の文書を参照してください。</p></div><div class=paragraph><p>ブートフロッピーを作成するためには、 etherboot をインストールしたマシンのドライブにフロッピーディスクを挿入します。 それからカレントディレクトリを etherboot ツリー内の <span class=filename>src</span> ディレクトリにして次のように入力します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmake bin32/devicetype.fd0</span></code></pre></div></div><div class=paragraph><p><em>devicetype</em> は ディスクレスワークステーションのイーサネットカードタイプに依存します。 正しい <em>devicetype</em> を決定するために、 同じディレクトリ内の <span class=filename>NIC</span> ファイルを参照してください。</p></div></div><div class=sect3><h4 id=_tftp_および_nfs_サーバの設定>20.7.1.3. TFTP および NFS サーバの設定<a class=anchor href=#_tftp_および_nfs_サーバの設定></a></h4><div class=paragraph><p>TFTP サーバ上で <code>tftpd</code> を有効にする必要があります。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><code>tftpd</code> が提供するファイルを置くディレクトリ (たとえば <span class=filename>/tftpboot</span>) を作成してください。</p></li><li><p><span class=filename>/etc/inetd.conf</span> ファイルに以下の行を追加してください。</p><div class="literalblock programlisting"><div class=content><pre>tftp    dgram   udp     wait    root  /usr/libexec/tftpd    tftpd -s /tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>少なくとも PXE のいくつかのバージョンが TCP 版の TFTP を要求するようです。その場合 <code>dgram udp</code> を <code>stream tcp</code> に置き換えた 2 番目の行を追加してください。</p></div></td></tr></tbody></table></div></li><li><p><code>inetd</code> に設定ファイルを再読み込みさせてください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/inetd.pid`</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p><span class=filename>tftpboot</span> ディレクトリはサーバ上のどこにでも置けます。 その場所が <span class=filename>inetd.conf</span> および <span class=filename>dhcpd.conf</span> の両方に設定されていることを確かめてください。</p></div><div class=paragraph><p>さらに NFS を有効にして NFS サーバの適切なファイルシステムをエクスポートする必要があります。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>この行を <span class=filename>/etc/rc.conf</span> に追加してください。</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>下記を <span class=filename>/etc/exports</span> に加えることで、 ディスクレスマシンのルートディレクトリが位置するファイルシステムをエクスポートしてください (ボリュームのマウントポイントを適当に調節し、 <em>margaux</em> をディスクレスワークステーションの名前に置き換えてください)。</p><div class="literalblock programlisting"><div class=content><pre>/data/misc -alldirs -ro margaux</pre></div></div></li><li><p><code>mountd</code> に設定ファイルを再読み込みさせてください。 <span class=filename>/etc/rc.conf</span> 内で NFS をはじめて有効にする必要があったのなら、 代わりに再起動した方がよいかもしれません。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/mountd.pid`</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=_ディスクレス用のカーネル構築>20.7.1.4. ディスクレス用のカーネル構築<a class=anchor href=#_ディスクレス用のカーネル構築></a></h4><div class=paragraph><p>次のオプションを (通常のものに) 追加した、 ディスクレスクライアント用のカーネルコンフィグレーションファイルを作成してください。</p></div><div class="literalblock programlisting"><div class=content><pre>          options     BOOTP          # Use BOOTP to obtain IP address/hostname
          options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info
          options     BOOTP_COMPAT   # Workaround for broken bootp daemons.</pre></div></div><div class=paragraph><p><code>BOOTP_NFSV3</code> および <code>BOOTP_WIRED_TO</code> を利用してもよいかもしれません (<span class=filename>LINT</span> を参照してください)。</p></div><div class=paragraph><p>カーネルを構築して (<a href=../kernelconfig/#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> を参照)、 <span class=filename>dhcpd.conf</span> に記述した名称で tftp ディレクトリにコピーしてください。</p></div></div><div class=sect3><h4 id=_ルートファイルシステムの準備>20.7.1.5. ルートファイルシステムの準備<a class=anchor href=#_ルートファイルシステムの準備></a></h4><div class=paragraph><p><span class=filename>dhcpd.conf</span> に <code>root-path</code> として記載された ディスクレスワークステーションのためのルートファイルシステムを作成する必要があります。</p></div><div class=paragraph><p>これを行う最も簡単な方法は <span class=filename>/usr/shared/examples/diskless/clone_root</span> シェルスクリプトを使用することです。 このスクリプトは、少なくともファイルシステムが作成される場所 (<code>DEST</code> 変数) を調節するために変更する必要があります。</p></div><div class=paragraph><p>説明についてはスクリプトの一番上にあるコメントを参照してください。 ベースシステムをどのように構築するか、 またファイルがどのようにディスクレス稼働、サブネット、 または個々のワークステーションに固有のバージョンによって、 選択的にオーバライドできるかを説明します。 また、ディスクレスな場合の <span class=filename>/etc/fstab</span> ファイルおよび <span class=filename>/etc/rc.conf</span> ファイルの例を示します。</p></div><div class=paragraph><p><span class=filename>/usr/shared/examples/diskless</span> 内の <span class=filename>README</span> ファイルには、多くの興味深い背景情報が書かれています。 しかし <span class=filename>diskless</span> ディレクトリ内の他の例と同じく、 <span class=filename>clone_root</span> と <span class=filename>/etc/rc.diskless[12]</span> で実際に使われているものとは異なる設定方法が説明されています。 ここに書かれている方法は <span class=filename>rc</span> スクリプトの変更が必要になりますが、 こちらの方が気に入ったというのでなければ、 参照にとどめてください。</p></div></div><div class=sect3><h4 id=_スワップの設定>20.7.1.6. スワップの設定<a class=anchor href=#_スワップの設定></a></h4><div class=paragraph><p>必要なら、サーバに置かれたスワップファイルに NFS 経由でアクセスできます。 <span class=filename>bootptab</span> または <span class=filename>dhcpd.conf</span> の正確なオプションは、 現時点では明確には文書化されていません。 下記の設定例は isc-dhcp 3.0rc11 を使用して動作したと報告されているものです。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><span class=filename>dhcpd.conf</span> に下記の行を追加してください。</p><div class="literalblock programlisting"><div class=content><pre>              # Global section
              option swap-path code 128 = string;
              option swap-size code 129 = integer 32;

              host margaux {
                ... # Standard lines, see above
                option swap-path &#34;192.168.4.4:/netswapvolume/netswap&#34;;
                option swap-size 64000;
              }</pre></div></div><div class=paragraph><p>これは、少なくとも FreeBSD クライアントにおいては、 DHCP/BOOTP オプションコードの 128 は NFS スワップファイルへのパスで、オプションコード 129 は KB 単位のスワップサイズだということです。 もっと古いバージョンの <code>dhcpd</code> では <code>option option-128 "…​</code> という書式が受け付けられましたが、 もはや対応していません。</p></div><div class=paragraph><p>代わりに、<span class=filename>/etc/bootptab</span> では次の書式を使います。</p></div><div class=paragraph><p><code>T128="192.168.4.4:/netswapvolume/netswap":T129=0000fa00</code></p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/bootptab</span> では、スワップの大きさは 16 進数で表さなければなりません。</p></div></td></tr></tbody></table></div></li><li><p>NFS スワップファイルサーバ側でスワップファイルを作成します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /netswapvolume/netswap</span>
<span class=c># cd /netswapvolume/netswap</span>
<span class=c># dd if=/dev/zero bs=1024 count=64000 of=swap.192.168.4.6</span>
<span class=c># chmod 0600 swap.192.168.4.6</span></code></pre></div></div><div class=paragraph><p><em>192.168.4.6</em> はディスクレスクライアントの IP アドレスです。</p></div></li><li><p>NFS スワップファイルサーバ上で <span class=filename>/etc/exports</span> に下記の行を追加してください。</p><div class="literalblock programlisting"><div class=content><pre>	      /netswapvolume  -maproot=0:10 -alldirs margaux</pre></div></div><div class=paragraph><p>それから、上述したように mountd にエクスポートファイルを再読み込みさせてください。</p></div></li></ol></div></div></div></div><div class=sect3><h4 id=_雑多な問題>20.7.1.7. 雑多な問題<a class=anchor href=#_雑多な問題></a></h4><div class=sect4><h5 id=_読み取り専用の_usr_で動作させる>20.7.1.7.1. 読み取り専用の <span class=filename>/usr</span> で動作させる<a class=anchor href=#_読み取り専用の_usr_で動作させる></a></h5><div class=paragraph><p>ディスクレスワークステーションが X を起動するように設定されている場合、 xdm 設定ファイルを調整しなければならないでしょう。 これはデフォルトでエラーファイルを <span class=filename>/usr</span> に置きます。</p></div></div><div class=sect4><h5 id=_freebsd_ではないサーバを使用する>20.7.1.7.2. FreeBSD ではないサーバを使用する<a class=anchor href=#_freebsd_ではないサーバを使用する></a></h5><div class=paragraph><p>ルートファイルシステムを提供するサーバが FreeBSD で動作していない場合、 FreeBSD マシン上でルートファイルシステムを作成し、 <code>tar</code> または <code>cpio</code> を利用して置きたい場所にコピーしなければならないでしょう。</p></div><div class=paragraph><p>この状況では、major/minor 整数サイズが異なっていることにより <span class=filename>/dev</span> 内のスペシャルファイルに関する問題が時々おこります。 この問題を解決するには、非 FreeBSD サーバからディレクトリをエクスポートして、 そのディレクトリを FreeBSD マシンでマウントし、 FreeBSD マシン上で <code>MAKEDEV</code> を実行して正しいデバイスエントリを作成します (FreeBSD 5.0 およびそれ以降では、<a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> を使用してユーザに意識させずにデバイスノードを割り当てるので、 これらのバージョンでは <code>MAKEDEV</code> は必要ありません)。</p></div></div></div></div></div></div><div class=sect1><h2 id=network-isdn>20.8. ISDN<a class=anchor href=#network-isdn></a></h2><div class=sectionbody><div class=paragraph><p>ISDN 技術とハードウェアに関しては、 <a href=http://www.alumni.caltech.edu/~dank/isdn/>Dan Kegel’s ISDN Page</a> がよい参考になるでしょう。</p></div><div class=paragraph><p>手軽な ISDN の導入手順は以下のようになります。</p></div><div class=ulist><ul><li><p>ヨーロッパ在住の方は ISDN カードの節に進んでください。</p></li><li><p>ダイヤルアップ専用でない回線上で、 インターネットプロバイダをつかってインターネットに接続するために ISDN を使用することを第一に考えている場合は、 ターミナルアダプタの使用を考えてみてください。 この方法はもっとも柔軟性があり、 プロバイダを変更した場合の問題も少ないでしょう。</p></li><li><p>2 つの LAN を接続する場合や、 ISDN 専用線を使用する場合には、 スタンドアロンなルータまたはブリッジの使用を勧めます。</p></li></ul></div><div class=paragraph><p>費用はどの解決法を選ぶかを決める重要な要因です。 以下に、最も安価な方法から、高価な方法まで順に説明していきます。</p></div><div class=sect2><h3 id=network-isdn-cards>20.8.1. ISDN カード<a class=anchor href=#network-isdn-cards></a></h3><div class=paragraph><p>FreeBSD の ISDN 実装は、パッシブカードを使用した DSS1/Q.931 (または Euro-ISDN) 標準だけに対応しています。FreeBSD 4.4 からは、ファームウェアが他の信号プロトコルにも対応している 一部のアクティブカードにも対応しました。 その中には、はじめて対応された一次群速度インタフェース (PRI) ISDN カードもあります。</p></div><div class=paragraph><p>isdn4bsd は IP over raw HDLC または同期 PPP を利用して他の ISDN ルータに接続できるようにします。 PPP では、カーネル PPP を <a href="https://man.freebsd.org/cgi/man.cgi?query=sppp&amp;sektion=4&amp;format=html">sppp(4)</a> ドライバを修正した <code>isppp</code> ドライバとともに利用するか、または ユーザプロセス <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> を利用するかのどちらかになります。ユーザ <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> を利用すると、二つ以上の ISDN B チャネルを併せて利用できます。 ソフトウェア 300 ボーモデムのような多くのユーティリティとともに、 留守番電話アプリケーションも利用可能です。</p></div><div class=paragraph><p>FreeBSD が対応している PC ISDN カードの数は増加しており、 ヨーロッパ全域や世界のその他多くの地域でうまく使えることが報告されています。</p></div><div class=paragraph><p>対応しているパッシブ ISDN カードのほとんどは Infineon (前身は Siemens) の ISAC/HSCX/IPAC ISDN チップセットを備えたカードですが、 Cologne Chip から供給されたチップを備えた ISDN カード (ISA バスのみ)、Winbond W6692 チップを備えた PCI カード、 Tiger300/320/ISAC チップセットを組み合わたカードの一部、 および AVM Fritz!Card PCI V.1.0 や AVM Fritz!Card PnP のようなベンダ独自のチップセットに基づいたカードもあります。</p></div><div class=paragraph><p>現在のところ、対応しているアクティブカードは AVM B1 (ISA および PCI) BRI カードと AVM T1 PCI PRI カードです。</p></div><div class=paragraph><p>isdn4bsd についての文書は FreeBSD システム内の <span class=filename>/usr/shared/examples/isdn/</span> ディレクトリまたは <a href=http://www.freebsd-support.de/i4b/>isdn4bsd のウェブサイト</a>を参照してください。 そこにはヒントや正誤表や <a href=http://people.FreeBSD.org/~hm/>isdn4bsd ハンドブック</a>のような、 さらに多くの文書に対するポインタがあります。</p></div><div class=paragraph><p>異なる ISDN プロトコルや、現在対応されていない ISDN PC カードに対応することや、その他 isdn4bsd を拡張することに興味があるなら、Hellmuth Michaelis &lt;<a href=mailto:hm@FreeBSD.org>hm@FreeBSD.org</a>> に連絡してください。</p></div><div class=paragraph><p>isdn4bsd のインストール、設定、 そしてトラブルシューティングに関して質問があれば <a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a> メーリングリストが利用可能です。</p></div></div><div class=sect2><h3 id=_isdn_ターミナルアダプタ>20.8.2. ISDN ターミナルアダプタ<a class=anchor href=#_isdn_ターミナルアダプタ></a></h3><div class=paragraph><p>ターミナルアダプタ (TA) は ISDN で、 通常の電話線におけるモデムに相当するものです。</p></div><div class=paragraph><p>ほとんどの TA は、標準のヘイズ AT コマンドセットを使用しているので、 単にモデムと置き換えて使うことができます。</p></div><div class=paragraph><p>TA は、基本的にはモデムと同じように動作しますが、 接続方法は異なり、通信速度も古いモデムよりはるかに速くなります。 <a href=../ppp-and-slip/#ppp>PPP</a> の設定を、 モデムの場合と同じように行ってください。 特にシリアル速度を使用できる最高速度に設定するのを忘れないでください。</p></div><div class=paragraph><p>プロバイダへの接続に TA を使用する最大のメリットは、動的 PPP を行えることです。 最近 IP アドレス空間がますます不足してきているため、 ほとんどのプロバイダは、 固定 IP アドレスを割り当てないようになっています。 ほとんどのスタンドアローンルータは、動的 IP アドレス割り当てに対応していません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>最近の ISDN ルータでは IP アドレスの動的割り当てに対応しているものも多いようです。 ただし制限がある場合もありますので、 詳しくはメーカに問い合わせてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>TA を使用した場合の機能や接続の安定性は、使用している PPP デーモンに完全に依存します。そのため、FreeBSD で PPP の設定が完了していれば、使用している既存のモデムを ISDN の TA に簡単にアップグレードすることができます。ただし、それまでの PPP のプログラムに問題があった場合、その問題は TA に置き換えてもそのまま残ります。</p></div><div class=paragraph><p>最高の安定性を求めるのであれば、 <a href=../ppp-and-slip/#userppp>ユーザランド PPP</a> ではなく、カーネル <a href=../ppp-and-slip/#ppp>PPP</a>を使用してください。</p></div><div class=paragraph><p>以下の TA は、FreeBSD で動作確認ずみです。</p></div><div class=ulist><ul><li><p>Motorola BitSurfer および Bitsurfer Pro</p></li><li><p>Adtran</p></li></ul></div><div class=paragraph><p>他の TA もほとんどの場合うまく動作するでしょう。TA のメーカーでは、TA がほとんどの標準モデム AT コマンドセットを受け付けるようにするよう努力しているようです。</p></div><div class=paragraph><p>外部 TA を使う際の最大の問題点は、 モデムの場合と同じく良いシリアルカードが必要であるということです。</p></div><div class=paragraph><p>シリアルデバイスの詳細と、 非同期シリアルポートと同期シリアルポートの差を理解するには、<a href=https://docs.freebsd.org/en/articles/serial-uart/>FreeBSD シリアルハードウェア</a>チュートリアルを参照してください。</p></div><div class=paragraph><p>標準の PC シリアルポート (非同期) に接続された TA は 128 Kbs の接続を行っていても、最大通信速度が 115.2 Kbs に制限されてしまいます。128 Kbs の ISDN の性能を最大限に生かすためには TA を同期シリアルカードに接続しなければなりません。</p></div><div class=paragraph><p>内蔵 TA を購入すれば、 同期/非同期問題を回避できるとは思わないでください。内蔵 TA には、 単に標準 PC シリアルポートのチップが内蔵されているだけです。 内蔵 TA の利点といえば、 シリアルケーブルを買わなくていいということと、 電源コンセントが一つ少なくて済むということくらいでしょう。</p></div><div class=paragraph><p>同期カードと TA の組合せでも、スタンドアロンのルータと同程度の速度は確保できます。 さらに、386 の FreeBSD マシンと組合せると、 より柔軟な設定が可能です。</p></div><div class=paragraph><p>同期カード/TA を選ぶか、スタンドアロンルータを選ぶかは、 多分に宗教的な問題です。 メーリングリストでもいくつか議論がありました。議論の全容については、 <a href=https://www.FreeBSD.org/search/>アーカイブ</a> を検索してください。</p></div></div><div class=sect2><h3 id=_スタンドアロン_isdn_ブリッジルータ>20.8.3. スタンドアロン ISDN ブリッジ/ルータ<a class=anchor href=#_スタンドアロン_isdn_ブリッジルータ></a></h3><div class=paragraph><p>ISDN ブリッジあるいはルータは、 FreeBSD あるいは他の OS に特有のものでは皆目ありません。 ルーティングやブリッジング技術に関する詳細は、 ネットワークの参考書をご覧ください。</p></div><div class=paragraph><p>この節では、 ルータとブリッジのどちらでもあてはまるように記述します。</p></div><div class=paragraph><p>ローエンド ISDN ルータ/ブリッジ製品は、 価格が下がってきていることもあり、 より広く選択されるようになるでしょう。ISDN ルータは、 ローカルイーサネットネットワークに直接接続し、 自身で他のブリッジ/ルータとの接続を制御する小さな箱です。PPP や他の広く使用されているプロトコルをつかって通信するためのソフトウェアが組み込まれています。</p></div><div class=paragraph><p>ルータは、完全な同期 ISDN 接続を使用するため、通常の TA と比較してスループットが大幅に向上します。</p></div><div class=paragraph><p>ISDN ルータ/ブリッジを使用する場合の最大の問題点は、 各メーカーの製品間に相性の問題がまだ存在することです。 インターネットプロバイダとの接続を考えている場合には、 プロバイダと相談することをお勧めします。</p></div><div class=paragraph><p>事務所の LAN と家庭の LAN の間など、二つの LAN セグメントの間を接続しようとしている場合は、 これはもっともメンテナンスが簡単で、安くあがる解決方法です。 接続の両側の機材を購入するので、 リンクがうまくいくであろうことを保証できます。</p></div><div class=paragraph><p>たとえば、 家庭のコンピュータや支店のネットワークを本社のネットワークに接続するためには、 以下のような設定が使用できます。</p></div><div class=exampleblock><div class=title>例 2. 支店または家庭のネットワーク</div><div class=content><div class=paragraph><p>ネットワークは 10 Base 2 イーサネット ("thinnet") のバス型トポロジを用いています。ルータとネットワークの間は、 必要に応じて AUI/10BT トランシーバを使って接続してください。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-bus.png alt="10 Base 2 イーサネット"></div></div><div class=paragraph><p>家庭/支店で一台しかコンピュータを使用しないのであれば、 クロスのツイストペアケーブルを使用して、 直接スタンドアロンルータに接続することも可能です。</p></div></div></div><div class=exampleblock><div class=title>例 3. 本社 LAN や他の LAN</div><div class=content><div class=paragraph><p>ネットワークは 10 base T イーサネット ("Twisted Pair") のスター型トポロジを用いています。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-twisted-pair.png alt="ISDN ネットワークダイアグラム"></div></div></div></div><div class=paragraph><p>ほとんどのルータ/ブリッジの大きな利点は、 別々の二つのサイトに対して、<em>同時</em> にそれぞれ<em>独立した</em>二つの PPP 接続が可能であることです。 これは、シリアルポートを 2 つもった特定の (通常は高価な) モデルを除いて、通常の TA では対応していません。 チャネルボンディングや MPP などと混同しないでください。</p></div><div class=paragraph><p>たとえば、事務所で専用線 ISDN 接続を使用していて、 別の ISDN 回線を購入したくないときには大変便利な機能です。この場合、 事務所のルータは、インターネットに接続するための一つの専用線 B チャネル接続 (64 Kbs) を管理し、 別の B チャネルを他のデータ接続に使用できます。 2 つ目の B チャネルは他の場所とのダイアルイン、 ダイアルアウトに使用したり、バンド幅を増やすために、 1 つ目の B チャネルと動的に結合すること (MPPなど) ができます。</p></div><div class=paragraph><p>またイーサネットブリッジは、IP パケット以外も中継できます。 IPX/SPX など、使用するすべてのプロトコルを送ることが可能です。</p></div></div></div></div><div class=sect1><h2 id=network-nis>20.9. NIS/YP<a class=anchor href=#network-nis></a></h2><div class=sectionbody><div class=sect2><h3 id=_nisyp_とは>20.9.1. NIS/YP とは?<a class=anchor href=#_nisyp_とは></a></h3><div class=paragraph><p>NIS とは Network Information Services の略で Sun Microsystems によって UNIX® の (もともとは SunOS™ の) 集中管理のために開発されました。現在では事実上の業界標準になっており、 主要な UNIX® ライクシステム (Solaris™, HP-UX, AIX®, Linux, NetBSD, OpenBSD, FreeBSD、等々) はすべてこれをサポートしています。</p></div><div class=paragraph><p>NIS は元々、イエローページといっていましたが、 商標問題から Sun はその名前を変えました。 古い用語 (および yp) はまだよく見られ、使用されています。</p></div><div class=paragraph><p>NIS は RPC を使ったクライアント/サーバシステムです。 これを使うと NIS ドメイン内のマシン間で、 共通の設定ファイルを共有することができます。 また NIS を使うことでシステム管理者は最小限の設定データで NIS クライアントを立ち上げることができ、 1 ヶ所から設定データの追加、削除、変更が可能です。</p></div><div class=paragraph><p>NIS は Windows NT® のドメインシステムに似ています。 内部の実装は似ても似つかないものですが、 基本的な機能を対比することはできます。</p></div></div><div class=sect2><h3 id=_知っておくべき用語_プロセス>20.9.2. 知っておくべき用語 / プロセス<a class=anchor href=#_知っておくべき用語_プロセス></a></h3><div class=paragraph><p>NIS サーバの立ち上げや NIS クライアントの設定など、 NIS を FreeBSD に導入するにあたって、 目にするであろう用語や重要なユーザプロセスがいくつかあります。</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">用語</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>NIS ドメイン名</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS マスタサーバとそのクライアントすべて (スレーブサーバを含む) には NIS ドメイン名がついています。 Windows NT® ドメイン名と同様に、NIS ドメイン名は DNS とは何の関係もありません。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>portmap</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RPC (Remote Procedure Call, NIS で使用されるネットワークプロトコル) を利用するために実行しておかなければなりません。 <code>portmap</code> が動作していなければ、 NIS サーバを起動することも、 NIS クライアントとして動作させることもできません。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ypbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS クライアントを NIS サーバに "結びつけ" ます。 これは NIS ドメイン名をシステムから取得し RPC を用いてサーバに接続します。<code>ypbind</code> は NIS 環境におけるクライアントとサーバ間の通信の中枢です。 クライアントマシンの <code>ypbind</code> が停止した場合は、NIS サーバへアクセスすることができなくなります。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ypserv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>は NIS サーバでのみ実行されるべきもので、 NIS サーバプロセスそのものです。<a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> が停止した場合、サーバはもはや NIS リクエストに応答することができなくなるでしょう (できれば、後を引き継ぐスレーブサーバがあるとよいでしょう)。 今まで使っていたサーバが機能を停止したとき、 別のサーバに再接続しに行かない NIS の実装もいくつかあります (FreeBSD のものは違います)。 そのような場合に復帰するための唯一の方法は、 サーバプロセス (あるいはサーバ全体)、もしくはクライアントの <code>ypbind</code> プロセスを再スタートすることです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpc.yppasswdd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS マスターサーバで動かすべき、 もう一つのプロセスです。これは NIS クライアントが NIS パスワードを変更することを可能にするデーモンです。 このデーモンが動作していないときは、 ユーザは NIS マスタサーバにログインし、 そこでパスワードを変更しなければなりません。</p></td></tr></tbody></table></div><div class=sect2><h3 id=_動作のしくみ>20.9.3. 動作のしくみ<a class=anchor href=#_動作のしくみ></a></h3><div class=paragraph><p>NIS 環境にあるホストは、 マスターサーバ、スレーブサーバ、クライアントの 3 種類に分類されます。 サーバは、ホストの設定情報の中心的な情報格納庫の役割をします。 マスターサーバは元となる信頼できる情報を保持し、 スレーブサーバは冗長性を確保するためこの情報をミラーします。 そしてクライアントは、サーバから情報の提供を受けて動作します。</p></div><div class=paragraph><p>この方法を用いることで、数多くのファイルにある情報が共有できます。 よく NIS で共有されるのは、 <span class=filename>master.passwd</span> や <span class=filename>group</span>, <span class=filename>hosts</span> といったファイルです。 クライアント上のプロセスが、 通常ならローカルのファイルにある情報を必要とするときは、 クライアントは代わりに接続している NIS サーバに問い合わせを行います。</p></div><div class=sect3><h4 id=_マシンの分類>20.9.3.1. マシンの分類<a class=anchor href=#_マシンの分類></a></h4><div class=ulist><ul><li><p><em>NIS マスターサーバ</em>。 このサーバは Windows NT® で言うところのプライマリドメインコントローラにあたります。 すべての NIS クライアントで利用されるファイルを保守します。 <span class=filename>passwd</span> や <span class=filename>group</span>、 その他 NIS クライアントが参照するファイルは、 マスターサーバにあります。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>一つのマシンが一つ以上の NIS ドメインのマスターサーバになることは可能です。 しかし、ここでは比較的小規模の NIS 環境を対象としているため、 そのような場合については扱いません。</p></div></td></tr></tbody></table></div></li><li><p><em>NIS スレーブサーバ</em>。 Windows NT® のバックアップドメインコントローラに似たもので、 NIS スレーブサーバは NIS マスターサーバのデータファイルのコピーを保持します。 NIS スレーブサーバは重要な環境で必要とされる冗長性を提供し、 マスターサーバの負荷のバランスをとります。 NIS クライアントは常に最初にレスポンスを返したサーバを NIS サーバとして接続しますが、 これにはスレーブサーバも含まれます。</p></li><li><p><em>NIS クライアント</em>。 NIS クライアントは大部分の Windows NT® ワークステーションのように、ログオンに際して NIS サーバ (Windows NT® ワークステーションの場合は Windows NT® ドメインコントローラ) に接続して認証します。</p></li></ul></div></div></div><div class=sect2><h3 id=_nisyp_を使う>20.9.4. NIS/YP を使う<a class=anchor href=#_nisyp_を使う></a></h3><div class=paragraph><p>この節では NIS 環境の立ち上げ例を取り上げます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この節ではあなたが FreeBSD 3.3 以降を使っているものとします。 ここで与えられる指示は <em>おそらく</em> FreeBSD の 3.0 以降のどのバージョンでも機能するでしょうが、 それを保証するものではありません。</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_計画を立てる>20.9.4.1. 計画を立てる<a class=anchor href=#_計画を立てる></a></h4><div class=paragraph><p>あなたが大学の小さな研究室の管理人であるとしましょう。 この研究室は 15 台の FreeBSD マシンからなっていて、 現在はまだ集中管理されていません。 すなわち、各マシンは <span class=filename>/etc/passwd</span> と <span class=filename>/etc/master.passwd</span> を各々が持っています。 これらのファイルは手動でお互いに同期させています。 つまり現時点では、新しいユーザをあなたが追加するとき、 <code>adduser</code> を 15 ヶ所すべてで実行しなければなりません。 これは明らかに変える必要があるため、 あなたはこのうち 2 台をサーバにして NIS を導入することを決めました。</p></div><div class=paragraph><p>その結果、研究室の設定はこのようなものになります。</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">マシンの名前</th><th class="tableblock halign-left valign-top">IP アドレス</th><th class="tableblock halign-left valign-top">役割</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ellington</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS マスタ</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>coltrane</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.3</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS スレーブ</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>basie</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.4</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>教員用のワークステーション</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bird</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.5</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>クライアントマシン</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cli[1-11]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.[6-17]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>その他のクライアントマシン</p></td></tr></tbody></table><div class=paragraph><p>もし NIS によるシステム管理の設定を行なうのが初めてなら、 どのようにしたいのか、 ひととおり最後まで考えてみることをお勧めします。 ネットワークの規模によらず、 いくつか決めるべきことがあるからです。</p></div><div class=sect4><h5 id=_nis_ドメイン名を決める>20.9.4.1.1. NIS ドメイン名を決める<a class=anchor href=#_nis_ドメイン名を決める></a></h5><div class=paragraph><p>ここでいうドメイン名は、今まであなたが使っていた、 いわゆる "ドメイン名" と呼んでいたものとは違います。 正確には "NIS ドメイン名" と呼ばれます。 クライアントがサーバに情報を要求するとき、 その要求には自分が属する NIS ドメインの名前が含まれています。 これは 1 つのネットワークに複数のサーバがある場合に、 どのサーバが要求を処理すれば良いかを決めるために使われます。 NIS ドメイン名とは、 関連のあるホストをグループ化するための名前である、 と考えると良いでしょう。</p></div><div class=paragraph><p>組織によってはインターネットのドメイン名を NIS ドメイン名に使っているところがあります。 これはネットワークのトラブルをデバッグするときに混乱の原因となるため、 お勧めできません。 NIS ドメイン名はネットワーク内で一意なければいけません。そして、 ドメイン名がドメインに含まれるマシンを表すようなものであれば分かり易いです。 たとえば Acme 社のアート (Art) 部門であれば NIS ドメイン名を "acme-art" とすれば良いでしょう。この例では NIS ドメイン名として <em>test-domain</em> を使用します。</p></div><div class=paragraph><p>しかしながらオペレーティングシステムによっては (特に SunOS™)、 NIS ドメイン名をネットワークドメイン名として使うものもあります。 あなたのネットワークにそのような制限のあるマシンが 1 台でもあるときは、NIS のドメイン名としてインターネットのネットワークドメイン名を使わなければ <em>いけません</em>。</p></div></div><div class=sect4><h5 id=_サーバマシンの物理的必要条件>20.9.4.1.2. サーバマシンの物理的必要条件<a class=anchor href=#_サーバマシンの物理的必要条件></a></h5><div class=paragraph><p>NIS サーバとして使うマシンを選ぶ際には、 いくつか注意すべき点があります。 NIS に関する困ったことの一つに、 クライアントのサーバへの依存度があります。 クライアントが自分の NIS ドメインのサーバに接続できないと、 マシンが使用不能になることがあまりに多いのです。 もし、ユーザやグループに関する情報が得られなければ、 ほとんどのシステムは一時的に停止してしまいます。 こういったことを念頭に置いて、頻繁にリブートされるマシンや、 開発に使われそうなマシンを選ばないようにしなければなりません。 理想的には NIS サーバはスタンドアロンで NIS サーバ専用のマシンにするべきです。 ネットワークの負荷が重くなければ、 他のサービスを走らせているマシンを NIS サーバにしてもかまいません。 ただし NIS サーバが使えなくなると、 <em>すべての</em> クライアントに影響をおよぼす、 という点には注意しなければなりません。</p></div></div></div><div class=sect3><h4 id=_nis_サーバ>20.9.4.2. NIS サーバ<a class=anchor href=#_nis_サーバ></a></h4><div class=paragraph><p>元となるすべての NIS 情報は、 NIS マスターサーバと呼ばれる 1 台のマシンに格納されます。 この情報が格納されるデータベースを NIS マップと呼びます。 FreeBSD では、このマップは <span class=filename>/var/yp/[domainname]</span> に置かれます。 <span class=filename>[domainname]</span> は、 サーバがサービスする NIS ドメインです。 1 台の NIS サーバが複数のドメインをサポートすることも可能です。 つまり、このディレクトリを各々のドメインごとに作ることができます。 それぞれのドメインは、 独立したマップの集合を持つことになります。</p></div><div class=paragraph><p>NIS のマスターサーバとスレーブサーバ上では、 <code>ypserv</code> デーモンがすべての NIS 要求を処理します。 <code>ypserv</code> は NIS クライアントからの要求を受け付け、 ドメイン名とマップ名を対応するデータベースファイルへのパスに変換し、 データをクライアントに返送します。</p></div><div class=sect4><h5 id=_nis_マスターサーバの設定>20.9.4.2.1. NIS マスターサーバの設定<a class=anchor href=#_nis_マスターサーバの設定></a></h5><div class=paragraph><p>やりたいことにもよりますが NIS マスターサーバの設定は比較的単純です。 FreeBSD は初期状態で NIS に対応しています。 必要なのは以下の行を <span class=filename>/etc/rc.conf</span> に追加することだけで、 あとは FreeBSD がやってくれます。</p></div><div class="exampleblock procedure"><div class=content><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;</pre></div></div><div class="olist arabic"><ol class=arabic><li><p>この行はネットワークの設定後に (たとえば再起動後に) NIS のドメイン名を <em>test-domain</em> に設定します。</p><div class="literalblock programlisting"><div class=content><pre>nis_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>これは FreeBSD に次にネットワークが立ち上がったとき NIS のサーバプロセスを起動させます。</p><div class="literalblock programlisting"><div class=content><pre>nis_yppasswdd_enable=&#34;YES&#34;</pre></div></div></li><li><p>これは <code>rpc.yppasswdd</code> デーモンを有効にします。上述したようにこれはユーザが NIS のパスワードをクライアントのマシンから変更することを可能にします。</p></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>NIS の設定によっては、 さらに他のエントリを付け加える必要があるかもしれません。 詳細については、下記の <a href=#network-nis-server-is-client>NIS クライアントとしても動作している NIS サーバ</a> 節を参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>さて、あとはスーパユーザ権限で <code>/etc/netstart</code> コマンドを実行するだけです。 これにより <span class=filename>/etc/rc.conf</span> で定義された値を使ってすべての設定が行なわれます。</p></div></div><div class=sect4><h5 id=_nis_マップの初期化>20.9.4.2.2. NIS マップの初期化<a class=anchor href=#_nis_マップの初期化></a></h5><div class=paragraph><p><em>NIS マップ</em> とは <span class=filename>/var/yp</span> ディレクトリにあるデータベースファイルです。 これらは NIS マスタの <span class=filename>/etc</span> ディレクトリの設定ファイルから作られます。 唯一の例外は <span class=filename>/etc/master.passwd</span> ファイルです。これは <code>root</code> や他の管理用アカウントのパスワードまでその NIS ドメインのすべてのサーバに伝えたくないという、 もっともな理由によるものです。このため NIS マップの初期化の前に以下を行う必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/master.passwd /var/yp/master.passwd</span>
<span class=c># cd /var/yp</span>
<span class=c># vi master.passwd</span></code></pre></div></div><div class=paragraph><p>システムに関するアカウント (<code>bin</code>, <code>tty</code>, <code>kmem</code>, <code>games</code> など) や、NIS クライアントに伝えたくないアカウント (たとえば <code>root</code> や他の UID が 0 (スーパユーザ) のアカウント) をすべて NIS マップから取り除かなければなりません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/var/yp/master.passwd</span> が グループまたは誰もが読めるようになっていないようにしてください (モード 600)! 必要なら <code>chmod</code> コマンドを使ってください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>すべてが終わったら NIS マップを初期化します! FreeBSD には、これを行うために <code>ypinit</code> という名のスクリプトが含まれています (詳細はそのマニュアルページをご覧ください)。 このスクリプトはほとんどの UNIX® OS に存在しますが、 すべてとは限らないことを覚えておいてください。 Digital Unix/Compaq Tru64 UNIX では <code>ypsetup</code> と呼ばれています。NIS マスタのためのマップを作るためには <code>-m</code> オプションを <code>ypinit</code> に与えます。上述のステップを完了しているなら、以下を実行して NIS マップを生成します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# ypinit <span class=nt>-m</span> test-domain
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n] n
Ok, please remember to go back and redo manually whatever fails.
If you don<span class=s1>&#39;t, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server   :  ellington
next host to add:  coltrane
next host to add:  ^D
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] y

[..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</span></code></pre></div></div><div class=paragraph><p><code>ypinit</code> は <span class=filename>/var/yp/Makefile</span> を <span class=filename>/var/yp/Makefile.dist</span> から作成します。 作成された時点では、そのファイルはあなたが FreeBSD マシンだけからなるサーバが 1 台だけの NIS 環境を扱っていると仮定しています。 <em>test-domain</em> はスレーブサーバを一つ持っていますので <span class=filename>/var/yp/Makefile</span> を編集しなければなりません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# vi /var/yp/Makefile</code></pre></div></div><div class=paragraph><p>以下の行を (もし既にコメントアウトされていないならば) コメントアウトしなければなりません。</p></div><div class="literalblock programlisting"><div class=content><pre>NOPUSH = &#34;True&#34;</pre></div></div></div><div class=sect4><h5 id=_nis_スレーブサーバの設定>20.9.4.2.3. NIS スレーブサーバの設定<a class=anchor href=#_nis_スレーブサーバの設定></a></h5><div class=paragraph><p>NIS スレーブサーバの設定はマスターサーバの設定以上に簡単です。 スレーブサーバにログオンし <span class=filename>/etc/rc.conf</span> ファイルを前回と同様に編集します。唯一の違うところは <code>ypinit</code> の実行に <code>-s</code> オプションを使わなければいけないことです。 <code>-s</code> オプションは NIS マスターサーバの名前を要求し、 コマンドラインは以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>coltrane# ypinit <span class=nt>-s</span> ellington test-domain

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If you don<span class=s1>&#39;t, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don&#39;</span>t forget to update map ypservers on ellington.</code></pre></div></div><div class=paragraph><p>この例の場合 <span class=filename>/var/yp/test-domain</span> というディレクトリが必要になります。 NIS マスターサーバのマップファイルのコピーは、 このディレクトリに置いてください。 これらを確実に最新のものに維持する必要があります。 次のエントリをスレーブサーバの <span class=filename>/etc/crontab</span> に追加することで、最新のものに保つことができます。</p></div><div class="literalblock programlisting"><div class=content><pre>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</pre></div></div><div class=paragraph><p>この二行はスレーブサーバにあるマップファイルを、 マスターサーバのマップファイルと同期させるものです。 このエントリは必須というわけではありませんが、マスターサーバは NIS マップに対する変更をスレーブサーバに伝えようとしますし、 サーバが管理するシステムにとってパスワード情報はとても重要なので、 強制的に更新してしまうことはよい考えです。特に、 マップファイルの更新がきちんと行なわれるかどうかわからないくらい混雑するネットワークでは、 重要になります。</p></div><div class=paragraph><p>スレーブサーバ上でも <code>/etc/netstart</code> コマンドを実行して、NIS サーバを再起動してください。</p></div></div></div><div class=sect3><h4 id=_nis_クライアント>20.9.4.3. NIS クライアント<a class=anchor href=#_nis_クライアント></a></h4><div class=paragraph><p>NIS クライアントは <code>ypbind</code> デーモンを使って、特定の NIS サーバとの間に結合 (binding) と呼ばれる関係を成立させます。 <code>ypbind</code> はシステムのデフォルトのドメイン (<code>domainname</code> コマンドで設定されます) を確認し、RPC 要求をローカルネットワークにブロードキャストします。 この RPC 要求により <code>ypbind</code> が結合を成立させようとしているドメイン名が指定されます。 要求されているドメイン名に対してサービスするよう設定されたサーバが ブロードキャストを受信すると、 サーバは <code>ypbind</code> に応答し<code>ypbind</code> は応答のあったサーバのアドレスを記録します。複数のサーバ (たとえば一つのマスターサーバと、複数のスレーブサーバ) が利用可能な場合、<code>ypbind</code> は、 最初に応答したサーバのアドレスを使用します。 これ以降、クライアントのシステムは、 すべての NIS の要求をそのサーバに向けて送信します。 <code>ypbind</code> は、 サーバが順調に動作していることを確認するため、 時々 "ping" をサーバに送ります。 反応が戻ってくるべき時間内に ping に対する応答が来なければ、 <code>ypbind</code> は、そのドメインを結合不能 (unbound) として記録し、別のサーバを見つけるべく、 再びブロードキャストパケットの送信を行います。</p></div><div class=sect4><h5 id=_nis_クライアントの設定>20.9.4.3.1. NIS クライアントの設定<a class=anchor href=#_nis_クライアントの設定></a></h5><div class=paragraph><p>FreeBSD マシンを NIS クライアントにする設定は非常に単純です。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>ネットワークの起動時に NIS ドメイン名を設定して <code>ypbind</code> を起動させるために <span class=filename>/etc/rc.conf</span> ファイルを編集して以下の行を追加します。</p><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;
nis_client_enable=&#34;YES&#34;</pre></div></div></li><li><p>NIS サーバから、 利用可能なパスワードエントリをすべて取り込むため、 <span class=filename>/etc/master.passwd</span> からすべてのユーザアカウントを取り除いて、 <code>vipw</code> コマンドで以下の行を <span class=filename>/etc/master.passwd</span> の最後に追加します。</p><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この行によって NIS サーバのパスワードマップにアカウントがある人全員にアカウントが与えられます。 この行を変更すると、 さまざまな NIS クライアントの設定を行なうことが可能です。 詳細は <a href=#network-netgroups>ネットグループ</a> を、さらに詳しい情報については、O’Reilly の <code>Managing NFS and NIS</code> を参照してください。</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/master.passwd</span> 内に少なくとも一つのローカルアカウント (つまり NIS 経由でインポートされていないアカウント) を置くべきです。 また、このアカウントは <code>wheel</code> グループのメンバーであるべきです。 NIS がどこか調子悪いときには、 リモートからこのアカウントでログインし、 root になって修復するのに利用できます。</p></div></td></tr></tbody></table></div></li><li><p>NIS サーバにあるすべてのグループエントリを取り込むため、 以下の行を <span class=filename>/etc/group</span> に追加します。</p><div class="literalblock programlisting"><div class=content><pre>+:*::</pre></div></div></li></ol></div></div></div><div class=paragraph><p>上記の手順がすべて完了すれば、 <code>ypcat passwd</code> によって NIS サーバの passwd マップが参照できるようになっているはずです。</p></div></div></div></div><div class=sect2><h3 id=_nis_セキュリティ>20.9.5. NIS セキュリティ<a class=anchor href=#_nis_セキュリティ></a></h3><div class=paragraph><p>一般にドメイン名さえ知っていれば、 どこにいるリモートユーザでも <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> に RPC を発行して NIS マップの内容を引き出すことができます。 こういった不正なやりとりを防ぐため、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> には securenets と呼ばれる機能があります。これは、 アクセスを決められたホストだけに制限するのに使える機能です。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> は起動時に <span class=filename>/var/yp/securenets</span> ファイルから securenets に関する情報を読み込みます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>上記のパス名は <code>-p</code> オプションで指定されたパス名によって変わります。このファイルは、 空白で区切られたネットワーク指定とネットマスクのエントリからなっていて、 "#" で始まる行はコメントとみなされます。 簡単な securenets ファイルの例を以下に示します。</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
10.0.0.0      255.255.240.0</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> が上記のルールの一つと合致するアドレスからの要求を受け取った場合、 処理は正常に行なわれます。 もしアドレスがルールに合致しなければ、 その要求は無視されて警告メッセージがログに記録されます。 また <span class=filename>/var/yp/securenets</span> が存在しない場合、 <code>ypserv</code> はすべてのホストからの接続を受け入れます。</p></div><div class=paragraph><p><code>ypserv</code> は Wietse Venema 氏による tcpwrapper パッケージもサポートしています。 そのため <span class=filename>/var/yp/securenets</span> の代わりに tcpwrapper の設定ファイルを使ってアクセス制御を行なうことも可能です。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>これらのアクセス制御機能は一定のセキュリティを提供しますが、 どちらも特権ポートのテストのような "IP spoofing" 攻撃に対して脆弱です。すべての NIS 関連のトラフィックはファイアウォールでブロックされるべきです。</p></div><div class=paragraph><p><span class=filename>/var/yp/securenets</span> を使っているサーバは、古い TCP/IP 実装を持つ正当なクライアントへのサービスに失敗することがあります。 これらの実装の中にはブロードキャストのホストビットをすべて 0 でセットしてしまったり、 ブロードキャストアドレスの計算でサブネットマスクを見落としてしまったりするものがあります。 これらの問題にはクライアントの設定を正しく行なえば解決できるものもありますが、 問題となっているクライアントシステムを引退させるか、 <span class=filename>/var/yp/securenets</span> を使わないようにしなければならないものもあります。</p></div><div class=paragraph><p>このような古風な TCP/IP の実装を持つサーバで <span class=filename>/var/yp/securenets</span> を使うことは実に悪い考えであり、 あなたのネットワークの大部分において NIS の機能喪失を招きます。</p></div><div class=paragraph><p>tcpwrapper パッケージを使うとあなたの NIS サーバのレイテンシ (遅延) が増加します。特に混雑したネットワークや遅い NIS サーバでは、遅延の増加によって、 クライアントプログラムのタイムアウトが起こるかもしれません。 一つ以上のクライアントシステムがこれらの兆候を示したなら、 あなたは問題となっているクライアントシステムを NIS スレーブサーバにして自分自身に結び付くように強制すべきです。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_何人かのユーザのログオンを遮断する>20.9.6. 何人かのユーザのログオンを遮断する<a class=anchor href=#_何人かのユーザのログオンを遮断する></a></h3><div class=paragraph><p>わたしたちの研究室には <code>basie</code> という、 教員専用のマシンがあります。わたしたちはこのマシンを NIS ドメインの外に出したくないのですが、 マスタ NIS サーバの <span class=filename>passwd</span> ファイルには教員と学生の両方が載っています。 どうしたらいいでしょう?</p></div><div class=paragraph><p>当該人物が NIS のデータベースに載っていても、 そのユーザがマシンにログオンできないようにする方法があります。 そうするには <em>-username</em> をクライアントマシンの <span class=filename>/etc/master.passwd</span> ファイルの末尾に付け足します。 <em>username</em> はあなたがログインさせたくないと思っているユーザのユーザ名です。 これは <code>vipw</code> で行うべきです。 <code>vipw</code> は <span class=filename>/etc/master.passwd</span> への変更をチェックし、編集終了後パスワードデータベースを再構築します。 たとえば、ユーザ <em>bill</em> が <code>basie</code> にログオンするのを防ぎたいなら、以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>basie# vipw
<span class=o>[</span>add <span class=nt>-bill</span> to the end, <span class=nb>exit</span><span class=o>]</span>
vipw: rebuilding the database...
vipw: <span class=k>done

</span>basie# <span class=nb>cat</span> /etc/master.passwd

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:<span class=k>*</span>:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:<span class=k>*</span>:2:5::0:0:System &amp;:/:/sbin/nologin
bin:<span class=k>*</span>:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
<span class=nb>tty</span>:<span class=k>*</span>:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:<span class=k>*</span>:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:<span class=k>*</span>:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:<span class=k>*</span>:8:8::0:0:News Subsystem:/:/sbin/nologin
man:<span class=k>*</span>:9:9::0:0:Mister Man Pages:/usr/shared/man:/sbin/nologin
<span class=nb>bind</span>:<span class=k>*</span>:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:<span class=k>*</span>:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:<span class=k>*</span>:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:<span class=k>*</span>:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:<span class=k>*</span>:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
<span class=nt>-bill</span>

basie#</code></pre></div></div></div><div class=sect2><h3 id=network-netgroups>20.9.7. ネットグループの利用<a class=anchor href=#network-netgroups></a></h3><div class=paragraph><p>前節までに見てきた手法は、 極めて少ないユーザ/マシン向けに個別のルールを必要としている場合にはうまく機能します。 しかし大きなネットワークでは、 ユーザに触られたくないマシンへログオンを防ぐのを <em>忘れるでしょう</em> し、 そうでなくとも各マシンを個別に設定して回らなければならず、 <em>集中</em>管理という NIS の恩恵を失ってしまいます。</p></div><div class=paragraph><p>NIS の開発者はこの問題を <em>ネットグループ</em> と呼ばれる方法で解決しました。 その目的と意味合いは UNIX® のファイルシステムで使われている一般的なグループと比較できます。 主たる相違は数値 ID が存在しないことと、 ユーザアカウントと別のネットグループを含めたネットグループを定義できることです。</p></div><div class=paragraph><p>ネットグループは百人/台以上のユーザとマシンを含む、 大きく複雑なネットワークを扱うために開発されました。 あなたがこのような状況を扱わなければならないなら便利なものなのですが、 一方で、この複雑さは単純な例でネットグループの説明をすることをほとんど不可能にしています。 この節の残りで使われている例は、この問題を実演しています。</p></div><div class=paragraph><p>あなたの行なった、 研究室への NIS の導入の成功が上司の目に止ったとしましょう。 あなたの次の仕事は、あなたの NIS ドメインをキャンパスの他のいくつものマシンを覆うものへ拡張することです。 二つの表は新しいユーザと新しいマシンの名前とその説明を含んでいます。</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">ユーザの名前</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>alpha, beta</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IT 学科の通常の職員</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>charlie, delta</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IT 学科の新しい見習い</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>echo, foxtrott, golf, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>一般の職員</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>able, baker, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>まだインターン</p></td></tr></tbody></table><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">マシンの名前</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>war, death, famine, pollution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>最も重要なサーバ。IT 職員だけがログオンを許されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>pride, greed, envy, wrath, lust, sloth</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>あまり重要でないサーバ。 IT 学科の全員がログオンを許されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>one, two, three, four, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>通常のワークステーション。 <em>本当の</em> 職員だけがログオンを許されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>trashcan</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重要なデータの入っていないひどく古いマシン。 インターンでもこのマシンの使用を許されます。</p></td></tr></tbody></table><div class=paragraph><p>もしあなたがこの手の制限を各ユーザを個別にブロックする形で実装するなら、 あなたはそのシステムにログオンすることが許されていない各ユーザについて -<em>user</em> という 1 行を、各システムの <span class=filename>passwd</span> に追加しなければならなくなるでしょう。 もしあなたが 1 エントリでも忘れればトラブルに巻き込まれてしまいます。 最初のセットアップの時にこれを正しく行えるのはありえることかも知れませんが、 遂には連日の業務の間に例の行を追加し<em>忘れてしまうでしょう</em>。 結局マーフィーは楽観主義者だったのです。</p></div><div class=paragraph><p>この状況をネットグループで扱うといくつかの有利な点があります。 各ユーザを別個に扱う必要はなく、 ユーザを一つ以上のネットグループに割り当て、 ネットグループの全メンバのログインを許可したり禁止したりすることができます。 新しいマシンを追加するときはネットグループへログインの制限を定義するだけ、 新しいユーザを追加するときはそのユーザを一つ以上のネットグループへ追加するだけで、 それぞれ行なうことができます。 これらの変更は互いに独立なので、 "ユーザとマシンの組合わせをどうするか" は存在しなくなります。 あなたの NIS のセットアップが注意深く計画されていれば、 マシンへのアクセスを認めるにも拒否するにも中心の設定をたった一カ所変更するだけです。</p></div><div class=paragraph><p>最初のステップは NIS マップネットグループの初期化です。 FreeBSD の <a href="https://man.freebsd.org/cgi/man.cgi?query=ypinit&amp;sektion=8&amp;format=html">ypinit(8)</a> はこのマップをデフォルトで作りませんが、 その NIS の実装はそれが作られさえすればそれをサポートするものです。 空のマップを作るには、単に</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# vi /var/yp/netgroup</code></pre></div></div><div class=paragraph><p>とタイプして内容を追加していきます。 わたしたちの例では、すくなくとも IT 職員、IT 見習い、一般職員、 インターンの 4 つのネットグループが必要です。</p></div><div class="literalblock programlisting"><div class=content><pre>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
	(,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</pre></div></div><div class=paragraph><p><code>IT_EMP</code>, <code>IT_APP</code> 等はネットグループの名前です。 それぞれの括弧で囲まれたグループが一人以上のユーザアカウントをそれに登録しています。 グループの 3 つのフィールドは</p></div><div class="olist arabic"><ol class=arabic><li><p>その記述が有効なホスト (群) の名称。 ホスト名を特記しなければそのエントリはすべてのホストで有効です。 もしあなたがホスト名を特記するなら、 あなたは闇と恐怖と全き混乱の領域に入り込んでしまうでしょう。</p></li><li><p>このネットグループに所属するアカウントの名称。</p></li><li><p>そのアカウントの NIS ドメイン。 もしあなたが一つ以上の NIS ドメインの不幸な仲間なら、 あなたは他の NIS ドメインからあなたのネットグループにアカウントを導入できます。</p></li></ol></div><div class=paragraph><p>各フィールドには、ワイルドカードが使えます。 詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=netgroup&amp;sektion=5&amp;format=html">netgroup(5)</a> をご覧ください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>8 文字以上のネットグループ名は、特にあなたの NIS ドメインで他のオペレーティングシステムを走らせているときは使うべきではありません。 名前には大文字小文字の区別があります。 そのためネットグループ名に大文字を使う事は、 ユーザやマシン名とネットグループ名を区別する簡単な方法です。</p></div><div class=paragraph><p>(FreeBSD 以外の) NIS クライアントの中には 多数のエントリを扱えないものもあります。 たとえば SunOS™ の古い版では 15 以上の <em>エントリ</em> を含むネットグループはトラブルを起こします。 この制限は 15 ユーザ以下のサブネットグループをいくつも作り、 本当のネットグループはこのサブネットグループからなるようにすることで回避できます。</p></div><div class="literalblock programlisting"><div class=content><pre>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</pre></div></div><div class=paragraph><p>単一のネットグループに 225 人以上のユーザをいれたいときは、 このやり方を繰り返すことができます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>新しい NIS マップの有効化と配布は簡単です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# <span class=nb>cd</span> /var/yp
ellington# make</code></pre></div></div><div class=paragraph><p>これで新しい 3 つの NIS マップ <span class=filename>netgroup</span>, <span class=filename>netgroup.byhost</span>, <span class=filename>netgroup.byuser</span> ができるはずです。 新しい NIS マップが利用できるか確かめるには <a href="https://man.freebsd.org/cgi/man.cgi?query=ypcat&amp;sektion=1&amp;format=html">ypcat(1)</a> を使います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington% ypcat <span class=nt>-k</span> netgroup
ellington% ypcat <span class=nt>-k</span> netgroup.byhost
ellington% ypcat <span class=nt>-k</span> netgroup.byuser</code></pre></div></div><div class=paragraph><p>最初のコマンドの出力は <span class=filename>/var/yp/netgroup</span> の内容に似ているはずです。 2 番目のコマンドはホスト別のネットグループを作っていなければ出力されません。 3 番目のコマンドはユーザに対するネットグループのリストを得るのに使えます。</p></div><div class=paragraph><p>クライアント側の設定は非常に簡単です。 サーバ <em>war</em> を設定するには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> を実行して以下の行</p></div><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class=paragraph><p>を</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::</pre></div></div><div class=paragraph><p>に入れ替えるだけです。</p></div><div class=paragraph><p>今、ネットグループ <em>IT_EMP</em> で定義されたユーザのデータだけが <em>war</em> のパスワードデータベースに読み込まれ、 そのユーザだけがログインを許されています。</p></div><div class=paragraph><p>残念ながらこの制限はシェルの ~ の機能や、 ユーザ名や数値の ユーザ ID の変換ルーチンにも影響します。 つまり、 <code>cd ~user</code> はうまく動かず、 <code>ls -l</code> はユーザ名のかわりに数値の ID を表示し <code>find . -user joe -print</code> は "No such user" で失敗します。 これを避けるためには、すべてのユーザのエントリを <em>サーバにログインすることを許さずに</em> 読み込まなければなりません。</p></div><div class=paragraph><p>これはもう一行を <span class=filename>/etc/master.passwd</span> に追加することで実現できます。その行は以下の</p></div><div class=paragraph><p><code>+:::::::::/sbin/nologin</code> を含んでおり、 これは "すべてのエントリを読み込むが、読み込まれたエントリのシェルは <span class=filename>/sbin/nologin</span> で置き換えられる" ということを意味します。passwd エントリの他のフィールドを <span class=filename>/etc/master.passwd</span> の既定値から置き換えることも可能です。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><code>:::::::::/sbin/nologin` の行が `@IT_EMP:::::::::</code> の行より後ろに位置することに注意してください。 さもないと NIS から読み込まれた全ユーザが /sbin/nologin をログインシェルとして持つことになります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この変更の後では、新しい職員が IT 学科に参加しても NIS マップを一つ書き換えるだけで済みます。 同様にして、あまり重要でないサーバのローカルの <span class=filename>/etc/master.passwd</span> のかつての <code>+:::::::::</code> 行を以下のように置き換えます。</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>この行は、一般のワークステーションでは以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>これでしばらく順調に運用していましたが、 数週間後、ポリシに変更がありました。 IT 学科はインターンを雇い始め、IT インターンは一般のワークステーションと余り重要ではないサーバを使うことが許され、 IT 見習いはメインサーバへのログインが許されました。 あなたは新たなネットグループ IT_INTERN を追加して新しい IT インターンたちをそのグループに登録し、 すべてのマシンの設定を変えて回ることにしました。 古い諺にこうあります。 "集中管理における過ちは、大規模な混乱を導く"。</p></div><div class=paragraph><p>いくつかのネットグループから新たなネットグループを作るという NIS の機能は、このような状況に対処するために利用できます。 その方法の一つは、役割別のネットグループを作ることです。 たとえば、重要なサーバへのログイン制限を定義するために <em>BIGSRV</em> というネットグループを作り あまり重要ではないサーバへは <em>SMALLSRV</em> というネットグループを、そして一般のワークステーション用に <em>USERBOX</em> という第 3 のネットグループを 作ることができます。これらのネットグループの各々は、 各マシンにログインすることを許されたネットグループを含みます。 あなたの NIS マップネットグループの新しいエントリは、 以下のようになるはずです。</p></div><div class="literalblock programlisting"><div class=content><pre>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</pre></div></div><div class=paragraph><p>このログイン制限の定義法は、 同一の制限を持つマシンのグループを定義できるときには便利なものです。 残念ながらこのようなケースは例外的なものです。 ほとんどの場合、 各マシンに基づくログイン制限の定義機能が必要となるでしょう。</p></div><div class=paragraph><p>マシンごとのネットグループの定義は、 上述したようなポリシの変更を扱うことができるもうひとつの方法です。 このシナリオでは、各マシンの <span class=filename>/etc/master.passwd</span> は "+" で始まる 2 つの行からなります。 最初のものはそのマシンへのログインを許されたアカウントを追加するもので、 2 番目はその他のアカウントを <span class=filename>/sbin/nologin</span> をシェルとして追加するものです。 マシン名をすべて大文字で記述したものをネットグループの名前として使うのは良い考えです。 言い換えれば、件の行は次のようになるはずです。</p></div><div class="literalblock programlisting"><div class=content><pre>+@BOXNAME:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>一度、各マシンに対してこの作業を済ませてしまえば、 二度とローカルの <span class=filename>/etc/master.passwd</span> を編集する必要がなくなります。 以降のすべての変更は NIS マップの編集で扱うことができます。 以下はこのシナリオに対応するネットグループマップに、 いくつかの便利な定義を追加した例です。</p></div><div class="literalblock programlisting"><div class=content><pre># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION  BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]</pre></div></div><div class=paragraph><p>もしユーザアカウントを管理するのにデータベースの類を使っているなら、 データベースのレポートツールからマップの最初の部分を作れるようにするべきです。 そうすれば、新しいユーザは自動的にマシンにアクセスできるでしょう。</p></div><div class=paragraph><p>最後に使用上の注意を: マシン別のネットグループを使うことが常に賢明というわけではありません。 あなたが数ダースから数百の同一の環境のマシンを学生の研究室に配置しているのならば、 NIS マップのサイズを手頃な範囲に押さえるために、 マシン別のネットグループのかわりに役割別のネットグループを使うべきです。</p></div></div><div class=sect2><h3 id=_忘れてはいけないこと>20.9.8. 忘れてはいけないこと<a class=anchor href=#_忘れてはいけないこと></a></h3><div class=paragraph><p>NIS 環境にある今、 今までとは違ったやり方が必要なことがいくつかあります。</p></div><div class=ulist><ul><li><p>研究室にユーザを追加するときは、それをマスター NIS サーバに <em>だけ</em> 追加しなければならず、さらに <em>NIS マップを再構築することを忘れてはいけません</em>。 これを忘れると新しいユーザは NIS マスタ以外のどこにもログインできなくなります。 たとえば、新しくユーザ "jsmith" をラボに登録したいときは以下のようにします。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd jsmith</span>
<span class=c># cd /var/yp</span>
<span class=c># make test-domain</span></code></pre></div></div><div class=paragraph><p><code>pw useradd jsmith</code> のかわりに <code>adduser jsmith</code> を使うこともできます。</p></div></li><li><p><em>管理用アカウントを NIS マップから削除してください</em>。 管理用アカウントやパスワードを、 それらのアカウントへアクセスさせてはいけないユーザが居るかも知れないマシンにまで伝えて回りたいとは思わないでしょう。</p></li><li><p><em>NIS のマスタとスレーブをセキュアに、 そして機能停止時間を最短に保ってください</em>。 もし誰かがこれらのマシンをクラックしたり、 あるいは単に電源を落としたりすると、 彼らは実質的に多くの人を研究室へログインできなくしてしまえます。</p><div class=paragraph><p>これはどの集中管理システムにとってももっとも大きな弱点でしょう。 あなたの NIS サーバを守らなければ怒れるユーザと対面することになるでしょう!</p></div></li></ul></div></div><div class=sect2><h3 id=_nis_v1_との互換性>20.9.9. NIS v1 との互換性<a class=anchor href=#_nis_v1_との互換性></a></h3><div class=paragraph><p>FreeBSD の ypserv は、 NIS v1 クライアントを部分的にサポートしています。 FreeBSD の NIS 実装は NIS v2 プロトコルのみを使用していますが、 ほかの実装では、古いシステムとの下位互換性を持たせるため v1 プロトコルをサポートしているものもあります。 そのようなシステムに付いている ypbind デーモンは、 必要がないにもかかわらず NIS v1 のサーバとの結合を成立させようとします (しかも v2 サーバからの応答を受信した後でも、 ブロードキャストをし続けるかも知れません)。 FreeBSD の ypserv は、 クライアントからの通常のリクエストはサポートしていますが、 v1 のマップ転送リクエストはサポートしていないことに注意してください。 つまり FreeBSD の ypserv を、 v1 だけをサポートするような古い NIS サーバと組み合わせて マスターやスレーブサーバとして使うことはできません。 幸いなことに、現在、そのようなサーバが使われていることは ほとんどないでしょう。</p></div></div><div class=sect2><h3 id=network-nis-server-is-client>20.9.10. NIS クライアントとしても動作している NIS サーバ<a class=anchor href=#network-nis-server-is-client></a></h3><div class=paragraph><p>複数のサーバが存在し、サーバ自身が NIS クライアントでもあるようなドメインで ypserv が実行される場合には注意が必要です。 一般的に良いとされているのは、 他のサーバと結合をつくるようにブロードキャストさせるのではなく、 サーバをそれ自身に結合させることです。 もし、サーバ同士が依存関係を持っていて、一つのサーバが停止すると、 奇妙なサービス不能状態に陥ることがあります。 その結果、すべてのクライアントはタイムアウトを起こして 他のサーバに結合しようと試みますが、 これにかかる時間はかなり大きく、 サーバ同士がまた互いに結合してしまったりすると、 サービス不能状態はさらに継続することになります。</p></div><div class=paragraph><p><code>ypbind</code> に <code>-S</code> オプションフラグを指定して実行することで、 ホストを特定のサーバに結合することが可能です。 NIS サーバを再起動するたびに、これを手動で行いたくないなら、 次の行を <span class=filename>/etc/rc.conf</span> に追加すればよいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>nis_client_enable=&#34;YES&#34;	# run client stuff as well
nis_client_flags=&#34;-S NIS domain,server&#34;</pre></div></div><div class=paragraph><p>詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a> を参照してください。</p></div></div><div class=sect2><h3 id=_パスワード形式>20.9.11. パスワード形式<a class=anchor href=#_パスワード形式></a></h3><div class=paragraph><p>NIS を実装しようする人の誰もがぶつかる問題の一つに、 パスワード形式の互換性があります。 NIS サーバが DES 暗号化パスワード使っている場合には、 同様に DES を使用しているクライアントしか対応できません。 たとえば Solaris™； の NIS クライアントがネットワーク内にある場合、 ほぼ確実に DES 暗号化パスワードを使用しなければならないでしょう。</p></div><div class=paragraph><p>サーバとクライアントがどのライブラリを使用しているかは、 <span class=filename>/etc/login.conf</span> を確認してください。 ホストが DES 暗号パスワードを使用するように設定されている場合、 <code>default</code> クラスには以下のようなエントリが含まれます。</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
    :passwd_format=des:\
    :copyright=/etc/COPYRIGHT:\
    [Further entries elided]</pre></div></div><div class=paragraph><p><code>passwd_format</code> 特性について他に利用可能な値は <code>blf</code> および <code>md5</code> (それぞれ Blowfish および MD5 暗号化パスワード) です。</p></div><div class=paragraph><p><span class=filename>/etc/login.conf</span> を変更したときは、 ログイン特性データベースも再構築しなければなりません。 これは <code>root</code> 権限で下記のようにコマンドを実行すればできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>すでに <span class=filename>/etc/master.passwd</span> 内に記録されているパスワード形式は、 ログイン特性データベースが再構築された<em>後</em>、 ユーザが彼らのパスワードをはじめて変更するまで変更されないでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p>次に、 パスワードが選択した形式で暗号化されることを確実にするために、 さらに <span class=filename>/etc/auth.conf</span> 内の <code>crypt_default</code> において、 選択したパスワード形式に高い優先順位がついていることも確認してください。 そうするためには、選択した形式をリストの先頭に置いてください。 たとえば DES 暗号化されたパスワードを使用するときは、 エントリは次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>crypt_default	=	des blf md5</pre></div></div><div class=paragraph><p>FreeBSD 上の各 NIS サーバおよびクライアントにおいて上記の手順に従えば、 ネットワーク内でどのパスワード形式が使用されるかが それらのマシン間で整合されているということを確信できます。 NIS クライアント上で問題があれば、 ここから問題となりそうな部分を探すと良いでしょう。 覚えておいてください: 異種混在ネットワークに NIS サーバを配置したいときには、 DES が最大公約数的な標準となるでしょうから、 すべてのシステムで DES を使用しなければならないかもしれません。</p></div></div></div></div><div class=sect1><h2 id=network-dhcp>20.10. DHCP<a class=anchor href=#network-dhcp></a></h2><div class=sectionbody><div class=sect2><h3 id=_dhcp_とは何でしょうか>20.10.1. DHCP とは何でしょうか?<a class=anchor href=#_dhcp_とは何でしょうか></a></h3><div class=paragraph><p>DHCP (Dynamic Host Configuration Protocol) は、 システムをネットワークに接続するだけで、 ネットワークでの通信に必要な情報を入手することができる仕組みです。 FreeBSD では ISC (Internet Software Consortium) による DHCP の実装を使用しています。したがって、 ここでの説明のうち実装によって異なる部分は ISC のもの用になっています。</p></div></div><div class=sect2><h3 id=_この節で説明していること>20.10.2. この節で説明していること<a class=anchor href=#_この節で説明していること></a></h3><div class=paragraph><p>この節は ISC DHCP システムのクライアント側およびサーバ側の構成要素の両方について説明します。 クライアント側のプログラムである <code>dhclient</code> は FreeBSD のベースシステム内に含まれています。そして、サーバ側の要素は <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port から利用可能です。下記の説明の他に、 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a> マニュアルページが役にたつ情報源です。</p></div></div><div class=sect2><h3 id=_dhcp_の動作>20.10.3. DHCP の動作<a class=anchor href=#_dhcp_の動作></a></h3><div class=paragraph><p>クライアントとなるマシン上で、 DHCP のクライアントである <code>dhclient</code> を実行すると、 まず設定情報の要求をブロードキャストします。デフォルトでは、 このリクエストには UDP のポート 68 を使用します。 サーバは UDP のポート 67 で応答し、クライアントの IP アドレスと、 ネットマスクやルータ、DNS サーバなどの関連する情報を提供します。 これらの情報のすべては DHCP の "リース" の形で送られ、DHCP サーバ管理者によって決められたある一定の時間内でのみ有効になります。 これによって、ネットワークに存在しなくなったホストの IP アドレスは自動的に回収されることになります。</p></div><div class=paragraph><p>DHCP クライアントはサーバから非常に多くの情報を取得することができます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a> に非常に大きなリストが載っています。</p></div></div><div class=sect2><h3 id=_freebsd_への組み込み>20.10.4. FreeBSD への組み込み<a class=anchor href=#_freebsd_への組み込み></a></h3><div class=paragraph><p>FreeBSD は ISC の DHCP クライアントである <code>dhclient</code> を完全に組み込んでいます。 DHCP クライアントはインストーラと基本システムの両方で提供されています。 ですから DHCP サーバを走らせているネットワーク上ではネットワーク関係の設定についての詳細な知識は必要になりません。 <code>dhclient</code> は、3.2 以降のすべての FreeBSD の配布物に含まれています。</p></div><div class=paragraph><p>DHCP は sysinstall で対応されており、sysinstall でのネットワークインタフェイス設定の際は、 "このインタフェイスの設定として DHCP を試してみますか? (Do you want to try DHCP configuration of this interface?)" という質問が最初になされます。 これに同意することで <code>dhclient</code> が実行され、 それが成功すればネットワークの設定情報は自動的に取得されます。</p></div><div class=paragraph><p>システム起動時に DHCP を使ってネットワーク情報を取得するように するには、次の二つを行なう必要があります。</p></div><div class=ulist><ul><li><p><span class=filename>bpf</span> デバイスがカーネルに組み込まれていることを確認します。 これを組み込むには、カーネルコンフィグレーションファイルに <code>pseudo-device bpf</code> という行を追加し、カーネルを再構築します。 カーネルの構築に関する詳細は、 <a href=../kernelconfig/#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> を参照してください。</p><div class=paragraph><p><span class=filename>bpf</span> デバイスは、 FreeBSD にはじめから用意されている <span class=filename>GENERIC</span> カーネルに組み込まれていますので、 自分で設定を変えたカスタムカーネルを使っているのでなければ、 DHCP を動作させるためにカーネルを再構築する必要はありません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>セキュリティに関心のある方向けに注意しておきます。 <span class=filename>bpf</span> デバイスは、パケットスニファ (盗聴プログラム) を動作させることができる (ただし <code>root</code> 権限が必要) デバイスです。 <span class=filename>bpf</span> は DHCP を動作させるために <em>かならず</em>必要ですが、 セキュリティが非常に重要な場面では DHCP をいつか使うかもしれないというだけで <span class=filename>bpf</span> デバイスをカーネルに追加すべきではないでしょう。</p></div></td></tr></tbody></table></div></li><li><p><span class=filename>/etc/rc.conf</span> を編集して、 次の行を追加してください。</p><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;DHCP&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>で説明されているように <code>fxp0</code> の部分を、 動的に設定したいインタフェースの名前で置き換えることを忘れないようにしてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>もし、使っている <code>dhclient</code> の場所を変更していたり、<code>dhclient</code> にフラグを渡したい場合は、 同様に下のように書き加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>dhcp_program=&#34;/sbin/dhclient&#34;
dhcp_flags=&#34;&#34;</pre></div></div></li></ul></div><div class=paragraph><p>DHCP サーバ <code>dhcpd</code> は、Ports Collection に <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> の一部として収録されています。 この port には ISC DHCP サーバと文書が含まれています。</p></div></div><div class=sect2><h3 id=_関連ファイル>20.10.5. 関連ファイル<a class=anchor href=#_関連ファイル></a></h3><div class=ulist><ul><li><p><span class=filename>/etc/dhclient.conf</span></p><div class=paragraph><p><code>dhclient</code> は設定ファイル <span class=filename>/etc/dhclient.conf</span> を必要とします。 大抵の場合、このファイルはコメントだけであり、 デフォルトが通常使いやすい設定になっています。 この設定ファイルは <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a> マニュアルページで説明しています。</p></div></li><li><p><span class=filename>/sbin/dhclient</span></p><div class=paragraph><p><code>dhclient</code> は静的にリンクされており、 <span class=filename>/sbin</span> に置かれています。<a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> マニュアルページで <code>dhclient</code> コマンドについてより詳しく説明しています。</p></div></li><li><p><span class=filename>/sbin/dhclient-script</span></p><div class=paragraph><p><code>dhclient-script</code> は FreeBSD 特有の、 DHCP クライアント設定スクリプトです。これについては <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient-script&amp;sektion=8&amp;format=html">dhclient-script(8)</a> マニュアルページで説明されていますが、 これを編集する必要はほとんど発生しないでしょう。</p></div></li><li><p><span class=filename>/var/db/dhclient.leases</span></p><div class=paragraph><p>DHCP クライアントはこのファイルに有効なリースのデータベースをログとして記録します。 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.leases&amp;sektion=5&amp;format=html">dhclient.leases(5)</a> にもうすこし詳しい解説があります。</p></div></li></ul></div></div><div class=sect2><h3 id=_参考になる文献>20.10.6. 参考になる文献<a class=anchor href=#_参考になる文献></a></h3><div class=paragraph><p>DHCP のプロトコルは <a href=http://www.freesoft.org/CIE/RFC/2131/>RFC 2131</a> に完全に記述されています。また <a href=http://www.dhcp.org/>dhcp.org</a> にも有用な情報源が用意されています。</p></div></div><div class=sect2><h3 id=network-dhcp-server>20.10.7. DHCP サーバのインストールと設定<a class=anchor href=#network-dhcp-server></a></h3><div class=sect3><h4 id=_この節で説明していること_2>20.10.7.1. この節で説明していること<a class=anchor href=#_この節で説明していること_2></a></h4><div class=paragraph><p>この節は DHCP の ISC (Internet Software Consortium) 実装を用いて FreeBSD システムを DHCP サーバとして動作させる方法の情報を提供します。</p></div><div class=paragraph><p>DHCP のサーバ部分は FreeBSD の一部として提供されません。 したがって、このサービスを提供するために <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port をインストールする必要があるでしょう。 Ports Collection を使用する情報についての詳細は <a href=../ports/#ports>アプリケーションのインストール - packages と ports</a> を参照してください。</p></div></div><div class=sect3><h4 id=_dhcp_サーバのインストール>20.10.7.2. DHCP サーバのインストール<a class=anchor href=#_dhcp_サーバのインストール></a></h4><div class=paragraph><p>FreeBSD システムを DHCP サーバとして設定するために、<a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> デバイスがカーネルに組み込まれていることを保証する必要があります。 そうするためには、カーネルコンフィギュレーションファイルに <code>pseudo-device bpf</code> を追加して、 カーネルを再構築してください。 カーネルの構築に関する詳細は <a href=../kernelconfig/#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> を参照してください。</p></div><div class=paragraph><p><span class=filename>bpf</span> デバイスは、 FreeBSD にはじめから用意されている <span class=filename>GENERIC</span> カーネルの一部なので、DHCP を動作させるためにカスタムカーネルを作成する必要はありません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>セキュリティを特に意識する人は、<span class=filename>bpf</span> <span class=filename>bpf</span> はパケットスニファ (盗聴プログラム) が正常に (このようなプログラムはさらに特権アクセスを必要としますが) 動作することを可能にするデバイスでもあることに注意してください。 <span class=filename>bpf</span> は DHCP を使用するために必要 <em>です</em>。 しかし、セキュリティをとても気にしているなら、 DHCP をいつか使うかもしれないというだけで <span class=filename>bpf</span> デバイスをカーネルに含めるべきではないでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p>次に行わねばならないのは、 <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port によってインストールされた <span class=filename>dhcpd.conf</span> のサンプルを編集することです。 デフォルトでは、これは <span class=filename>/usr/local/etc/dhcpd.conf.sample</span> で、 編集する前にこれを <span class=filename>/usr/local/etc/dhcpd.conf</span> にコピーするべきでしょう。</p></div></div><div class=sect3><h4 id=_dhcp_サーバの設定>20.10.7.3. DHCP サーバの設定<a class=anchor href=#_dhcp_サーバの設定></a></h4><div class=paragraph><p><span class=filename>dhcpd.conf</span> はサブネットおよびホストに関する宣言で構成されます。 例を使って説明するのが最も簡単でしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>option domain-name &#34;example.com&#34;;<i class=conum data-value=1></i><b>(1)</b>
option domain-name-servers 192.168.4.100;<i class=conum data-value=2></i><b>(2)</b>
option subnet-mask 255.255.255.0;<i class=conum data-value=3></i><b>(3)</b>

default-lease-time 3600;<i class=conum data-value=4></i><b>(4)</b>
max-lease-time 86400;<i class=conum data-value=5></i><b>(5)</b>
ddns-update-style none;<i class=conum data-value=6></i><b>(6)</b>

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<i class=conum data-value=7></i><b>(7)</b>
  option routers 192.168.4.1;<i class=conum data-value=8></i><b>(8)</b>
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<i class=conum data-value=9></i><b>(9)</b>
  fixed-address mailhost.example.com;<i class=conum data-value=10></i><b>(10)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>このオプションは、 デフォルト探索ドメインとしてクライアントに渡されるドメインを指定します。 これが意味するところの詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> を参照してください。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>このオプションはクライアントが使用する、 コンマで区切られた DNS サーバのリストを指定します。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>クライアントに渡されるネットマスクです。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>クライアントは特定のリース期限を要求することもできます。 それ以外の場合は、サーバはこのリース期限値 (秒) でリースを割り当てるでしょう。</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>これはサーバがリースする時間の最大値です。 クライアントがこれより長いリースを要求しても、 <code>max-lease-time</code> 秒だけしか有効にならないでしょう。</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>このオプションは、リースが受理、またはリリースされたときに DHCP サーバが DNS を更新しようとするかどうかを指定します。 ISC 実装では、このオプションは <em>必須</em> です。</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>これはどの範囲の IP アドレスが、 クライアントに割り当てるために予約されたプールに使用されるかを示します。 この範囲に含まれている IP アドレスはクライアントに渡されます。</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>クライアントに供給されるデフォルトゲートウェイを宣言します。</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>(リクエストが生じた時に DHCP サーバがホストを認識できるように) ホストのハードウェア MAC アドレスを指定します。</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>ホストに常に同じ IP アドレスを付与することを指定します。 DHCP サーバはリース情報を返す前にホスト名の名前解決をするので、 ここにホスト名を書いても構いません。</td></tr></tbody></table></div><div class=paragraph><p><span class=filename>dhcpd.conf</span> を書き終えたら以下のコマンドでサーバを起動できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/isc-dhcpd.sh start</span></code></pre></div></div><div class=paragraph><p>今後サーバの設定に変更を加える必要が生じた時には、 <code>SIGHUP</code> シグナルを dhcpd に送っても、 多くのデーモンがそうであるようには、 設定ファイルが再読み込み <em>されない</em> ことに注意してください。 <code>SIGTERM</code> シグナルを送ってプロセスを停止し、 それから上記のコマンドを用いて再起動させる必要があります。</p></div></div><div class=sect3><h4 id=_ファイル>20.10.7.4. ファイル<a class=anchor href=#_ファイル></a></h4><div class=ulist><ul><li><p><span class=filename>/usr/local/sbin/dhcpd</span></p><div class=paragraph><p>dhcpd は静的にリンクされ <span class=filename>/usr/local/sbin</span> に置かれます。 dhcpd に関するそれ以上の情報は port とともにインストールされる <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd&amp;sektion=8&amp;format=html">dhcpd(8)</a> マニュアルページにあります。</p></div></li><li><p><span class=filename>/usr/local/etc/dhcpd.conf</span></p><div class=paragraph><p>dhcpd はクライアントへのサービス提供をはじめる前に設定ファイル <span class=filename>/usr/local/etc/dhcpd.conf</span> を必要とします。このファイルは、 サーバの稼働に関する情報に加えて、 サービスされているクライアントに提供される情報のすべてを含む必要があります。 この設定ファイルについての詳細は、 port によってインストールされる <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.conf&amp;sektion=5&amp;format=html">dhcpd.conf(5)</a> マニュアルページを参照してください。</p></div></li><li><p><span class=filename>/var/db/dhcpd.leases</span></p><div class=paragraph><p>DHCP サーバは発行したリースのデータベースをこのファイルにログとして保持します。 port によってインストールされる <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.leases&amp;sektion=5&amp;format=html">dhcpd.leases(5)</a> にはもう少し詳しい説明があります。</p></div></li><li><p><span class=filename>/usr/local/sbin/dhcrelay</span></p><div class=paragraph><p>dhcrelay は、DHCP サーバがクライアントからのリクエストを、 別のネットワーク上にある DHCP サーバに転送する高度な環境下で使用されます。 この機能が必要なら、<a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port をインストールしてください。 port とともに提供される <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcrelay&amp;sektion=8&amp;format=html">dhcrelay(8)</a> マニュアルページにはより詳細な情報が含まれます。</p></div></li></ul></div></div></div></div></div><div class=sect1><h2 id=network-dns>20.11. DNS<a class=anchor href=#network-dns></a></h2><div class=sectionbody><div class=sect2><h3 id=_概観>20.11.1. 概観<a class=anchor href=#_概観></a></h3><div class=paragraph><p>FreeBSD はデフォルトでは DNS プロトコルの最も一般的な実装である BIND (Berkeley Internet Name Domain) を使用します。DNS はホスト名を IP アドレスに、そして IP アドレスをホスト名に関連づけるプロトコルです。 たとえば <code>www.FreeBSD.org</code> に対する問い合わせは The FreeBSD Project の ウェブサーバの IP アドレスを受け取るでしょう。 その一方で <code>ftp.FreeBSD.org</code> に対する問い合わせは、 対応する FTP マシンの IP アドレスを返すでしょう。 同様に、その逆のことも可能です。 IP アドレスに対する問い合わせを行うことで、 そのホスト名を解決することができます。 DNS 検索を実行するために、 システム上でネームサーバを動作させる必要はありません。</p></div><div class=paragraph><p>DNS は、 個々のドメイン情報を格納およびキャッシュした、 権威のあるルートサーバおよび他の小規模なネームサーバによる多少複雑なシステムによって、 インターネット全体にわたって協調して動作します。</p></div><div class=paragraph><p>この文書は FreeBSD で安定版として利用されている BIND 8.x について説明します。 FreeBSD では BIND 9.x を <a class=package href=https://cgit.freebsd.org/ports/tree/net/bind9/>net/bind9</a> port からインストールできます。</p></div><div class=paragraph><p>RFC1034 および RFC1035 は DNS プロトコルを定義しています。</p></div><div class=paragraph><p>現在のところ BIND は <a href=http://www.isc.org/>Internet Software Consortium (www.isc.org)</a> によって保守されています。</p></div></div><div class=sect2><h3 id=_用語>20.11.2. 用語<a class=anchor href=#_用語></a></h3><div class=paragraph><p>この文書を理解するには DNS 関連の用語をいくつか理解しなければいけません。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">用語</th><th class="tableblock halign-left valign-top">定義</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>正引き DNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ホスト名から IP アドレスへの対応です。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>オリジン (origine)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>特定のゾーンファイルによってカバーされるドメインへの参照です。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>named, BIND, ネームサーバ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 内の BIND ネームサーバパッケージの一般名称です。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>リゾルバ (resolver)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>マシンがゾーン情報についてネームサーバに問い合わせるシステムプロセスです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>逆引き DNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>正引き DNS の逆です。つまり IP アドレスからホスト名への対応です。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ルートゾーン</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>インターネットゾーン階層の起点です。 すべてのゾーンはルートゾーンの下に属します。 これはファイルシステムのすべてのファイルがルートディレクトリの下に属することと似ています。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ゾーン</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>同じ権威によって管理される個々の DNS ドメイン、 DNS サブドメイン、あるいは DNS の一部分です。</p></td></tr></tbody></table><div class=paragraph><p>ゾーンの例:</p></div><div class=ulist><ul><li><p><code>.</code> はルートゾーンです。</p></li><li><p><code>org.</code> はルートゾーンの下のゾーンです。</p></li><li><p><code>example.org</code> は <code>org.</code> ゾーンの下のゾーンです。</p></li><li><p><code>foo.example.org.</code> はサブドメインで、 <code>example.org.</code> の下のゾーンです。</p></li><li><p><code>1.2.3.in-addr.arpa</code> は 3.2.1.* の IP 空間に含まれるすべての IP アドレスを参照するゾーンです。</p></li></ul></div><div class=paragraph><p>見て分かるように、ホスト名のより詳細な部分はその左側に現れます。 たとえば <code>example.org.</code> は <code>org.</code> より限定的です。同様に <code>org.</code> はルートゾーンより限定的です。 ホスト名の各部分のレイアウトはファイルシステムに非常に似ています。 たとえば <span class=filename>/dev</span> はルートの下であることなどです。</p></div></div><div class=sect2><h3 id=_ネームサーバを実行する理由>20.11.3. ネームサーバを実行する理由<a class=anchor href=#_ネームサーバを実行する理由></a></h3><div class=paragraph><p>ネームサーバは通常二つの形式があります: 権威のあるネームサーバとキャッシュネームサーバです。</p></div><div class=paragraph><p>権威のあるネームサーバは以下の場合に必要です。</p></div><div class=ulist><ul><li><p>問い合わせに対して信頼できる返答をすることで、 ある人が DNS 情報を世界に向けて発信したいとき。</p></li><li><p><code>example.org</code> といったドメインが登録されており、 その下にあるホスト名に IP アドレスを割り当てる必要があるとき。</p></li><li><p>IP アドレスブロックが (IP からホスト名への) 逆引き DNS エントリを必要とするとき。</p></li><li><p>プライマリサーバがダウンしているかまたはアクセスできない場合に、 代わりに問い合わせに対してスレーブと呼ばれるバックアップネームサーバが返答しなければならないとき。</p></li></ul></div><div class=paragraph><p>キャッシュネームサーバは以下の場合に必要です。</p></div><div class=ulist><ul><li><p>ローカルのネームサーバが、 外部のネームサーバに問い合わせするよりも、 キャッシュしてより速く返答できるとき。</p></li><li><p>ネットワークトラフィックの総量を減らしたいとき (DNS のトラフィックはインターネットトラフィック全体の 5% 以上を占めることが測定されています)</p></li></ul></div><div class=paragraph><p><code>www.FreeBSD.org</code> に対する問い合わせを発したとき、 リゾルバは大体の場合上流の ISP のネームサーバに問い合わせをして返答を得ます。 ローカルのキャッシュ DNS サーバがあれば、 問い合わせはキャッシュ DNS サーバによって外部に対して一度だけ発せられます。 情報がローカルに蓄えられるので、 追加の問い合わせはいずれもローカルネットワークの外側にまで確認しなくてもよくなります。</p></div></div><div class=sect2><h3 id=_動作のしくみ_2>20.11.4. 動作のしくみ<a class=anchor href=#_動作のしくみ_2></a></h3><div class=paragraph><p>FreeBSD では BIND デーモンは自明な理由から named と呼ばれます。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">ファイル</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>named</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BIND デーモン</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ndc</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ネームデーモンコントロールプログラム</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BIND のゾーン情報が置かれるディレクトリ</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb/named.conf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>デーモンの設定ファイル</p></td></tr></tbody></table><div class=paragraph><p>ゾーンファイルは通常 <span class=filename>/etc/namedb</span> ディレクトリ内に含まれており、ネームサーバによって処理される DNS ゾーン情報を含んでいます。</p></div></div><div class=sect2><h3 id=_bind_の起動>20.11.5. BIND の起動<a class=anchor href=#_bind_の起動></a></h3><div class=paragraph><p>BIND はデフォルトでインストールされているので、 すべてを設定することは比較的単純です。</p></div><div class=paragraph><p>named デーモンが起動時に開始されることを保証するには、 <span class=filename>/etc/rc.conf</span> に以下の変更をいれてください。</p></div><div class="literalblock programlisting"><div class=content><pre>named_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>デーモンを手動で起動するためには (設定をした後で)</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndc start</span></code></pre></div></div></div><div class=sect2><h3 id=_設定ファイル>20.11.6. 設定ファイル<a class=anchor href=#_設定ファイル></a></h3><div class=sect3><h4 id=_make_localhost_の利用>20.11.6.1. <code>make-localhost</code> の利用<a class=anchor href=#_make_localhost_の利用></a></h4><div class=paragraph><p>次のコマンドが</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/namedb</span>
<span class=c># sh make-localhost</span></code></pre></div></div><div class=paragraph><p>ローカル逆引き DNS ゾーンファイルを <span class=filename>/etc/namedb/localhost.rev</span> に適切に作成することを確認してください。</p></div></div><div class=sect3><h4 id=_etcnamedbnamed_conf>20.11.6.2. <span class=filename>/etc/namedb/named.conf</span><a class=anchor href=#_etcnamedbnamed_conf></a></h4><div class="literalblock programlisting"><div class=content><pre>// $FreeBSD$
//
// 詳細については named(8) マニュアルページを参照してください。プライマリサーバ
// を設定するつもりなら、DNS がどのように動作するかの詳細を確実に理解してくださ
// い。単純な間違いであっても、影響をうける相手に対する接続を壊したり、無駄な
// インターネットトラフィックを大量に引き起こし得ます。

options {
        directory &#34;/etc/namedb&#34;;

// &#34;forwarders&#34; 節に加えて次の行を有効にすることで、ネームサーバに決して自発的
// に問い合わせを発せず、常にそのフォワーダにたいして尋ねるように強制すること
// ができます:
//
//      forward only;

// あなたが上流のプロバイダ周辺の DNS サーバを利用できる場合、その IP アドレス
// をここに入力し、下記の行を有効にしてください。こうすれば、そのキャッシュの
// 恩恵にあやかることができ、インターネット全体の DNS トラフィックが減るでしょう。
/*
        forwarders {
                127.0.0.1;
        };
*/</pre></div></div><div class=paragraph><p>コメントが言っている通り、上流のキャッシュの恩恵を受けるために <code>forwarders</code> をここで有効にすることができます。 通常の状況では、ネームサーバはインターネットの特定のネームサーバを調べて、 探している返答を見つけるまで再帰的に問い合わせを行います。 これが有効になっていれば、まず上流のネームサーバ (または 与えられたネームサーバ) に問い合わせて、 そのキャッシュを利用するでしょう。 問い合わせをする上流のネームサーバが極度に通信量が多く、 高速であった場合、これを有効にする価値があるかもしれません。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>ここに <code>127.0.0.1</code> を指定しても動作 <em>しません</em>。 上流のネームサーバの IP アドレスに変更してください。</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>        /*
         * あなたと利用したいネームサーバとの間にファイアウォールがある場合、
         * 下記の quiery-source 指令を有効にする必要があるでしょう。
         * 過去の BIND のバージョンは常に 53 番ポートに問い合わせをしますが、
         * BIND 8.1 はデフォルトで非特権ポートを使用します。
         */
        // query-source address * port 53;

        /*
         * 砂場内で動作させている場合、ダンプファイルのために異なる場所を指定
         * しなければならないかもしれません。
         */
        // dump-file &#34;s/named_dump.db&#34;;
};

// 注意: 下記は将来のリリースで対応されるでしょう。
/*
host { any; } {
        topology {
                127.0.0.0/8;
        };
};
*/

// セカンダリを設定することはより簡単な方法で、そのおおまかな姿が下記で説明さ
// れています。
//
// ローカルネームサーバを有効にする場合、このサーバが最初に尋ねられるように
// /etc/resolv.conf に 127.0.0.1 を入力することを忘れないでください。さらに、
// /etc/rc.conf 内で有効にすることも確認してください。

zone &#34;.&#34; {
        type hint;
        file &#34;named.root&#34;;
};

zone &#34;0.0.127.IN-ADDR.ARPA&#34; {
        type master;
        file &#34;localhost.rev&#34;;
};

zone
&#34;0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.INT&#34; {
        type master;
        file &#34;localhost.rev&#34;;
};

// 注意: 下記の IP アドレスを使用しないでください。これはダミーでありデモや文書
// だけを目的としたものです。
//
// セカンダリ設定の例です。少なくともあなたのドメインが属するゾーンに対するセカ
// ンダリになることは便利かもしれません。プライマリの責を負っている IP アドレス
// をネットワーク管理者に尋ねてください。
//
// 逆引き参照ゾーン (IN-ADDR.ARPA) を含めることを決して忘れないでください!
// (これは &#34;.IN-ADDR.ARPA&#34; を付け加えられたそれぞれの IP アドレスの最初のバイト
// の逆順です。)
//
// プライマリゾーンの設定をはじめる前に DNS および BIND がどのように動作するか
// 完全に理解してください。時々自明でない落し穴があります。それに比べるとセカン
// ダリを設定するのは単純です。
//
// 注意: 下記の例を鵜呑みにして有効にしないでください。:-) 実際の名前とアドレス
// を代わりに使用してください。
//
// 注意!!! FreeBSD は bind を砂場のなかで動かします (rc.conf 内の named_flags
// を参照してください)。セカンダリゾーンを含んだディレクトリは、bind によって
// 書き込み可能でなければなりません。次の手順が推奨されます:
//
//      mkdir /etc/namedb/s
//      chown bind:bind /etc/namedb/s
//      chmod 750 /etc/namedb/s</pre></div></div><div class=paragraph><p>BIND を砂場 (sandbox) で (訳注: chroot をもちいて) 動作させるための詳細は <a href=#network-named-sandbox>砂場で named を実行する</a> を参照してください。</p></div><div class="literalblock programlisting"><div class=content><pre>/*
zone &#34;example.com&#34; {
        type slave;
        file &#34;s/example.com.bak&#34;;
        masters {
                192.168.1.1;
        };
};

zone &#34;0.168.192.in-addr.arpa&#34; {
        type slave;
        file &#34;s/0.168.192.in-addr.arpa.bak&#34;;
        masters {
                192.168.1.1;
        };
};
*/</pre></div></div><div class=paragraph><p><span class=filename>named.conf</span> の中で、 上記は転送と逆引きゾーンのためのスレーブエントリの例です。</p></div><div class=paragraph><p>新しくサービスするそれぞれのゾーンについて、新規のエントリを <span class=filename>named.conf</span> に加えなければいけません。</p></div><div class=paragraph><p>たとえば <code>example.org</code> に対する最もシンプルなゾーンエントリは以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>zone &#34;example.org&#34; {
	type master;
	file &#34;example.org&#34;;
};</pre></div></div><div class=paragraph><p>このゾーンは <code>type</code> 命令で示されているようにマスタで、ゾーン情報を <code>file</code> 命令で指示された <span class=filename>/etc/namedb/example.org</span> ファイルに保持しています。</p></div><div class="literalblock programlisting"><div class=content><pre>zone &#34;example.org&#34; {
	type slave;
	file &#34;example.org&#34;;
};</pre></div></div><div class=paragraph><p>スレーブの場合、 ゾーン情報は特定のゾーンのマスタネームサーバから転送され、 指定されたファイルに保存されます。 マスタサーバが停止するか到達できない場合には、 スレーブサーバが転送されたゾーン情報を保持していて、 サービスできるでしょう。</p></div></div><div class=sect3><h4 id=_ゾーンファイル>20.11.6.3. ゾーンファイル<a class=anchor href=#_ゾーンファイル></a></h4><div class=paragraph><p><code>example.org</code> に対するマスタゾーンファイル (<span class=filename>/etc/namedb/example.org</span> に保持されます) の例は以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>$TTL 3600

example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        86400 )         ; Minimum TTL

; DNS Servers
@       IN NS           ns1.example.org.
@       IN NS           ns2.example.org.

; Machine Names
localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30

; Aliases
www             IN CNAME        @

; MX Record
@               IN MX   10      mail.example.org.</pre></div></div><div class=paragraph><p>"." が最後についているすべてのホスト名は正確なホスト名であり、 一方で "." で終了しないすべての行はオリジンが参照されることに注意してください。 たとえば <code>www</code> は <code>www + オリジン</code> に展開されます。この架空のゾーンファイルでは、 オリジンは <code>example.org.</code> なので <code>www</code> は <code>www.example.org.</code> に展開されます。</p></div><div class=paragraph><p>ゾーンファイルの書式は次のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>recordname      IN recordtype   value</pre></div></div><div class=paragraph><p>DNS レコードに使われる最も一般的なものは以下のとおりです。</p></div><div class=dlist><dl><dt class=hdlist1>SOA</dt><dd><p>ゾーン権威の起点</p></dd><dt class=hdlist1>NS</dt><dd><p>権威のあるネームサーバ</p></dd><dt class=hdlist1>A</dt><dd><p>ホストのアドレス</p></dd><dt class=hdlist1>CNAME</dt><dd><p>別名としての正規の名称</p></dd><dt class=hdlist1>MX</dt><dd><p>メールエクスチェンジャ</p></dd><dt class=hdlist1>PTR</dt><dd><p>ドメインネームポインタ (逆引き DNS で使用されます)</p></dd></dl></div><div class="literalblock programlisting"><div class=content><pre>example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        86400 )         ; Minimum TTL of 1 day</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>example.org.</code></dt><dd><p>このゾーンのオリジンでもあるドメイン名</p></dd><dt class=hdlist1><code>ns1.example.org.</code></dt><dd><p>このゾーンに対して権威のあるプライマリネームサーバ</p></dd><dt class=hdlist1><code>admin.example.org.</code></dt><dd><p>このゾーンの責任者。@ を置き換えた電子メールアドレスを指定します。 (<a href=mailto:admin@example.org>admin@example.org</a> は <code>admin.example.org</code> になります)</p></dd><dt class=hdlist1><code>5</code></dt><dd><p>ファイルのシリアル番号です。 これはファイルが変更されるたびに増加させる必要があります。 現在では多くの管理者は <code>yyyymmddrr</code> という形式をシリアル番号として使用することを好みます。 2001041002 は最後に修正されたのが 2001/04/10 で、後ろの 02 はその日で二回目に修正されたものであるということを意味するでしょう。 シリアル番号は、 それが更新されたときにスレーブネームサーバに対してゾーンを通知するので重要です。</p></dd></dl></div><div class="literalblock programlisting"><div class=content><pre>@       IN NS           ns1.example.org.</pre></div></div><div class=paragraph><p>これは <code>NS</code> エントリです。 このゾーンに対して権威のある返答を返すネームサーバはすべて、 このエントリを一つ有していなければなりません。 ここにある <code>@</code> は <code>example.org.</code> を意味します。 <code>@</code> はオリジンに展開されます。</p></div><div class="literalblock programlisting"><div class=content><pre>localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30</pre></div></div><div class=paragraph><p><code>A</code> レコードはマシン名を示します。 上記のように <code>ns1.example.org</code> は <code>3.2.1.2</code> に結びつけられるでしょう。 ふたたびオリジンを示す <code>@</code> がここに使用されていますが、これは <code>example.org</code> が <code>3.2.1.30</code> に結び付けられることを意味しています。</p></div><div class="literalblock programlisting"><div class=content><pre>www             IN CNAME        @</pre></div></div><div class=paragraph><p><code>CNAME</code> レコードは通常マシンに別名を与えるときに使用されます。 例では <code>www</code> はオリジン、すなわち <code>example.org</code> (<code>3.2.1.30</code>) のアドレスをふられたマシンへの別名を与えます。 <code>CNAME</code> はホスト名の別名、 または複数のマシン間で一つのホスト名をラウンドロビン (訳注: 問い合わせがあるたびに別の IP アドレスを返すことで、 一台にアクセスが集中することを防ぐ手法) するときに用いられます。</p></div><div class="literalblock programlisting"><div class=content><pre>@               IN MX   10      mail.example.org.</pre></div></div><div class=paragraph><p><code>MX</code> レコードは、 ゾーンに対してどのメールサーバがやってきたメールを扱うことに責任を持っているかを示します。 <code>mail.example.org</code> はメールサーバのホスト名で、10 はメールサーバの優先度を示します。</p></div><div class=paragraph><p>優先度が 3,2 または 1 などのメールサーバをいくつも置くことができます。 <code>example.org</code> へ送ろうとしているメールサーバははじめに一番優先度の高いメールサーバに接続しようとします。 そして接続できない場合、二番目に優先度の高いサーバに接続しようとし、 以下、メールが適切に配送されるまで同様に繰り返します。</p></div><div class=paragraph><p>in-addr.arpa ゾーンファイル (逆引き DNS) に対しても <code>A</code> または <code>CNAME</code> の代わりに <code>PTR</code> エントリが用いられることを除けば、 同じ書式が使われます。</p></div><div class="literalblock programlisting"><div class=content><pre>$TTL 3600

1.2.3.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        3600 )          ; Minimum

@       IN NS   ns1.example.org.
@       IN NS   ns2.example.org.

2       IN PTR  ns1.example.org.
3       IN PTR  ns2.example.org.
10      IN PTR  mail.example.org.
30      IN PTR  example.org.</pre></div></div><div class=paragraph><p>このファイルは上記の架空のドメインの IP アドレスからホスト名への対応を与えます。</p></div></div></div><div class=sect2><h3 id=_キャッシュネームサーバ>20.11.7. キャッシュネームサーバ<a class=anchor href=#_キャッシュネームサーバ></a></h3><div class=paragraph><p>キャッシュネームサーバはどのゾーンに対しても権威をもたないネームサーバです。 キャッシュネームサーバは単に自分で問い合わせをし、 後で使えるように問い合わせの結果を覚えておきます。 これを設定するには、ゾーンを何も含まずに、 通常通りネームサーバを設定してください。</p></div></div><div class=sect2><h3 id=network-named-sandbox>20.11.8. 砂場で named を実行する<a class=anchor href=#network-named-sandbox></a></h3><div class=paragraph><p>セキュリティを強めるために <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> を非特権ユーザで実行し、 砂場のディレクトリ内に <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> して実行したいと思うかもしれません。 こうすると named デーモンは砂場の外にはまったく手を出すことができません。 named が乗っ取られたとしても、 これによって起こりうる損害が小さくなるでしょう。 FreeBSD にはデフォルトで、そのための <code>bind</code> というユーザとグループがあります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>多くの人々は named を <code>chroot</code> するように設定する代わりに、 <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 環境内で named を実行することを奨めるでしょう。 この節ではそれは扱いません。</p></div></td></tr></tbody></table></div><div class=paragraph><p>named は砂場の外 (共有ライブラリ、ログソケットなど) にアクセスできないので、 named を正しく動作させるためにいくつもの段階を経る必要があります。 下記のチェックリストにおいては、砂場のパスは <span class=filename>/etc/namedb</span> で、 このディレクトリの内容には何も手を加えていないと仮定します。 <code>root</code> 権限で次のステップを実行してください。</p></div><div class=ulist><ul><li><p>named が存在することを期待しているディレクトリをすべて作成します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/namedb</span>
<span class=c># mkdir -p bin dev etc var/tmp var/run master slave</span>
<span class=c># chown bind:bind slave var/* </span><i class=conum data-value=1></i><b>(1)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>これらのディレクトリに対して named が必要なのは書き込み権限だけなので、それだけを与えます。</td></tr></tbody></table></div></li><li><p>基本ゾーンファイルと設定ファイルの編集と作成を行います。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/localtime etc </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># mv named.conf etc &amp;&amp; ln -sf etc/named.conf</span>
<span class=c># mv named.root master</span>

<span class=c># sh make-localhost &amp;&amp; mv localhost.rev localhost-v6.rev master</span>
<span class=c># cat &gt; master/named.localhost</span>
<span class=nv>$ORIGIN</span> localhost.
<span class=nv>$TTL</span> 6h
@	IN	SOA	localhost. postmaster.localhost. <span class=o>(</span>
			1	<span class=p>;</span> serial
			3600	<span class=p>;</span> refresh
			1800	<span class=p>;</span> retry
			604800	<span class=p>;</span> expiration
			3600 <span class=o>)</span>	<span class=p>;</span> minimum
	IN	NS	localhost.
	IN	A		127.0.0.1
^D</code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>これは named が <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> に正しい時刻でログを書き込むことを可能にします。</td></tr></tbody></table></div></li><li><p>4.9-RELEASE より前のバージョンの FreeBSD を使用している場合、 静的リンクされた named-xfer を構築し、砂場にコピーしてください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/lib/libisc</span>
<span class=c># make cleandir &amp;&amp; make cleandir &amp;&amp; make depend &amp;&amp; make all</span>
<span class=c># cd /usr/src/lib/libbind</span>
<span class=c># make cleandir &amp;&amp; make cleandir &amp;&amp; make depend &amp;&amp; make all</span>
<span class=c># cd /usr/src/libexec/named-xfer</span>
<span class=c># make cleandir &amp;&amp; make cleandir &amp;&amp; make depend &amp;&amp; make NOSHARED=yes all</span>
<span class=c># cp named-xfer /etc/namedb/bin &amp;&amp; chmod 555 /etc/namedb/bin/named-xfer</span><i class=conum data-value=1></i><b>(1)</b></code></pre></div></div><div class=paragraph><p>静的リンクされた <code>named-xfer</code> をインストールしたら、 ソースツリーの中にライブラリまたはプログラムの古くなったコピーを残さないように、 掃除する必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/lib/libisc</span>
<span class=c># make cleandir</span>
<span class=c># cd /usr/src/lib/libbind</span>
<span class=c># make cleandir</span>
<span class=c># cd /usr/src/libexec/named-xfer</span>
<span class=c># make cleandir</span></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>このステップは時々失敗することが報告されています。 もし失敗した場合、次のコマンドを実行してください。そして <span class=filename>/usr/obj</span> ツリーを削除します。これはソースツリーからすべての "がらくた" を一掃します。 もう一度上記の手順を行うと、今度はうまく動作するでしょう。<div class=paragraph><p>バージョン 4.9-RELEASE 以降の FreeBSD を使用している場合 <span class=filename>/usr/libexec</span> にある <code>named-xfer</code> のコピーはデフォルトで静的リンクされています。 砂場にコピーするために単純に <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a> が使えます。</p></div></td></tr></tbody></table></div></li><li><p>named が見ることができ、 書き込むことのできる <span class=filename>dev/null</span> を作成します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/namedb/dev &amp;&amp; mknod null c 2 2</span>
<span class=c># chmod 666 null</span></code></pre></div></div></li><li><p><span class=filename>/etc/namedb/var/run/ndc</span> から <span class=filename>/var/run/ndc</span> へのシンボリックリンクを作成します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -sf /etc/namedb/var/run/ndc /var/run/ndc</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>これは単に <a href="https://man.freebsd.org/cgi/man.cgi?query=ndc&amp;sektion=8&amp;format=html">ndc(8)</a> を実行するたびに <code>-c</code> オプションを指定しなくてもよいようにするだけです。 /var/run の中身は起動時に削除されるため、 これが有用だと思うなら、このコマンドをルートの crontab に <code>@reboot</code> オプションを指定して追加してください。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> を参照してください。</p></div></td></tr></tbody></table></div></li><li><p>named が書き込める追加の <span class=filename>log</span> ソケットを作成するように <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> を設定します。 これを行うためには、<span class=filename>/etc/rc.conf</span> 内の <code>syslogd_flags</code> 変数に <code>-l /etc/namedb/dev/log</code> を加えてください。</p></li><li><p>次の行を <span class=filename>/etc/rc.conf</span> に加えて named が起動し、 自身を砂場内に <code>chroot</code> するように調整します</p><div class="literalblock programlisting"><div class=content><pre>named_enable=&#34;YES&#34;
named_flags=&#34;-u bind -g bind -t /etc/namedb /etc/named.conf&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>設定ファイル <em>/etc/named.conf</em> は <em>砂場のディレクトリに対して相対的な</em> フルパスで表されることに注意してください。 つまり、上記の行で示されたファイルは実際には <span class=filename>/etc/namedb/etc/named.conf</span> です。</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>次のステップは named がどのゾーンを読み込むか、 そしてディスク上のどこにゾーンファイルがあるのかを知るために <span class=filename>/etc/namedb/etc/named.conf</span> を編集することです。 下記に例をコメントを加えて示します (ここで特にコメントされていない内容については、 砂場の中で動作させない DNS サーバの設定と同じです)。</p></div><div class="literalblock programlisting"><div class=content><pre>options {
        directory &#34;/&#34;;<i class=conum data-value=1></i><b>(1)</b>
        named-xfer &#34;/bin/named-xfer&#34;;<i class=conum data-value=2></i><b>(2)</b>
        version &#34;&#34;;		// Don&#39;t reveal BIND version
        query-source address * port 53;
};
// ndc control socket
controls {
        unix &#34;/var/run/ndc&#34; perm 0600 owner 0 group 0;
};
// Zones follow:
zone &#34;localhost&#34; IN {
        type master;
        file &#34;master/named.localhost&#34;;<i class=conum data-value=3></i><b>(3)</b>
        allow-transfer { localhost; };
        notify no;
};
zone &#34;0.0.127.in-addr.arpa&#34; IN {
        type master;
        file &#34;master/localhost.rev&#34;;
        allow-transfer { localhost; };
        notify no;
};
zone &#34;0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.int&#34; {
	type master;
	file &#34;master/localhost-v6.rev&#34;;
	allow-transfer { localhost; };
	notify no;
};
zone &#34;.&#34; IN {
        type hint;
        file &#34;master/named.root&#34;;
};
zone &#34;private.example.net&#34; in {
        type master;
        file &#34;master/private.example.net.db&#34;;
	allow-transfer { 192.168.10.0/24; };
};
zone &#34;10.168.192.in-addr.arpa&#34; in {
        type slave;
        masters { 192.168.10.2; };
        file &#34;slave/192.168.10.db&#34;;<i class=conum data-value=4></i><b>(4)</b>
};</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>directory</code> は <span class=filename>/</span> を指定します。 named が必要とするファイルはすべてこのディレクトリにあります。 (この指定は "通常の" (訳注: 砂場内で動作させない) ユーザにとっての <span class=filename>/etc/namedb</span> と等価です)。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td><code>named-xfer</code> バイナリへの (named にとっての) フルパスを指定します。 named はデフォルトで <code>named-xfer</code> を <span class=filename>/usr/libexec</span> から探すようにコンパイルされているので、これが必要です</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>このゾーンに対するゾーンファイルを named が見つけられるようにファイル名を (上記と同様に <code>directory</code> からの相対パスで) 指定します。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>このゾーンに対するゾーン情報がマスタサーバからが転送されたあとに、 named がゾーンファイルのコピーを書き込むファイル名を (上記と同様に <code>directory</code> からの相対パスで) 指定します。これが、上記のように設定段階で <span class=filename>slave</span> ディレクトリの所有者を <code>bind</code> に変更する理由です。</td></tr></tbody></table></div><div class=paragraph><p>上記のステップを完了したら、サーバを再起動するか <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> を再起動し、<a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> を起動してください。その際、 <code>syslogd_flags</code> および <code>named_flags</code> に新たに指定したオプションが有効になっていることを確かめてください。 これで named を砂場のなかで動作させることができているはずです!</p></div></div><div class=sect2><h3 id=_セキュリティ>20.11.9. セキュリティ<a class=anchor href=#_セキュリティ></a></h3><div class=paragraph><p>BIND は DNS の最も一般的な実装ではありますが、 常にセキュリティ問題を抱えています。 問題になり得る、また悪用可能なセキュリティホールが時々みつかります。</p></div><div class=paragraph><p>現在のインターネットおよび FreeBSD のセキュリティ問題について常に最新の情報を得るために <a href=http://www.cert.org/>CERT</a> および <a href=../eresources/#eresources-mail>freebsd-security-notifications</a> を購読するとよいでしょう。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>問題が生じたとしても、 最新のソースからビルドした named を用意しておけば、 問題にならないかもしれません。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_さらなる情報源>20.11.10. さらなる情報源<a class=anchor href=#_さらなる情報源></a></h3><div class=paragraph><p>BIND/named のマニュアルページ: <a href="https://man.freebsd.org/cgi/man.cgi?query=ndc&amp;sektion=8&amp;format=html">ndc(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=named.conf&amp;sektion=8&amp;format=html">named.conf(8)</a></p></div><div class=ulist><ul><li><p><a href=http://www.isc.org/products/BIND/>ISC Bind 公式ページ</a></p></li><li><p><a href="http://www.nominum.com/getOpenSourceResource.php?id=6">BIND FAQ</a></p></li><li><p><a href=http://www.oreilly.com/catalog/dns4/>O’Reilly DNS and BIND 4th Edition</a></p></li><li><p><a href=ftp://ftp.isi.edu/in-notes/rfc1034.txt>RFC1034 - Domain Names - Concepts and Facilities</a> (ドメイン名、その概念と基盤)</p></li><li><p><a href=ftp://ftp.isi.edu/in-notes/rfc1035.txt>RFC1035 - Domain Names - Implementation and Specification</a> (ドメイン名、その実装と仕様)</p></li></ul></div></div></div></div><div class=sect1><h2 id=network-ntp>20.12. NTP<a class=anchor href=#network-ntp></a></h2><div class=sectionbody><div class=sect2><h3 id=_概説>20.12.1. 概説<a class=anchor href=#_概説></a></h3><div class=paragraph><p>時間の経過とともに、コンピュータの時計はずれてしまいがちです。 時間が経つと、コンピュータの時計は正確でなくなってゆきます。 NTP (Network Time Protocol) は時計が正確であることを保証する方法の一つです。</p></div><div class=paragraph><p>インターネットサービスの多くは、 コンピュータの時計が正確であることに依存しているか、 あるいは多くを負っています。 たとえば web サーバ は、 あるファイルがある時刻以降に修正されていたらそのファイルを送ってほしいという要求を受け取るかもしれません。 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> のようなサービスは所定の時間にコマンドを実行します。 時計が正確でない場合、 これらのコマンドは期待したとおりには実行されないかもしれません。</p></div><div class=paragraph><p>FreeBSD は <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> NTP サーバを搭載しています。これは、 マシンの時計を合わせるために他の NTP サーバに問い合わせをしたり、 他のマシンに対して時刻を報じるために使用できます。</p></div></div><div class=sect2><h3 id=_適切な_ntp_サーバの選択>20.12.2. 適切な NTP サーバの選択<a class=anchor href=#_適切な_ntp_サーバの選択></a></h3><div class=paragraph><p>時刻を同期するために利用する NTP サーバを、 一つ以上見つける必要があります。 ネットワーク管理者、または ISP はこの目的のために NTP サーバを設定しているかもしれません - 本当にそうなのか確かめるためにドキュメントを確認してください。 あなたの近くの NTP サーバを探せる <a href=http://www.eecis.udel.edu/~mills/ntp/servers.html>公にアクセス可能な NTP サーバのリスト</a> があります。 どのサーバを選択するとしても、そのサーバの運営ポリシを理解し、 要求されているなら利用許可を求めることを忘れないでください。</p></div><div class=paragraph><p>使用しているサーバのうちのどれかが到達不能になるか、 その時計の信頼性が低い場合、無関係の NTP サーバをいくつか選択するとよいでしょう。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> は他のサーバから受け取った応答を賢く利用します - 信頼できないサーバより信頼できるサーバを重視します。</p></div></div><div class=sect2><h3 id=_マシンの設定>20.12.3. マシンの設定<a class=anchor href=#_マシンの設定></a></h3><div class=sect3><h4 id=_基本設定>20.12.3.1. 基本設定<a class=anchor href=#_基本設定></a></h4><div class=paragraph><p>マシンが起動するときだけ時計を同期させたい場合は <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> が使えます。頻繁に再起動され、 たまに同期すれば十分なデスクトップマシンには適切かもしれません。 しかしほとんどのマシンでは <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> を実行するべきです。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> を動かしているマシンでも、起動時に <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> を使用するのはよい考えです。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> プログラムは時計を徐々に変更します。しかし <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> は正しい時刻と現在設定されているマシンの時刻がどんなに離れていようとも時計を設定します。</p></div><div class=paragraph><p>起動時に <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> を有効にするためには、 <code>ntpdate_enable="YES"</code> を <span class=filename>/etc/rc.conf</span> に追加してください。 さらに、同期したいすべてのサーバおよび、<a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> に渡すあらゆるフラグを <code>ntpdate_flags</code> に指定する必要があるでしょう。</p></div></div><div class=sect3><h4 id=_一般設定>20.12.3.2. 一般設定<a class=anchor href=#_一般設定></a></h4><div class=paragraph><p>NTP は <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a> に記述された書式の <span class=filename>/etc/ntp.conf</span> ファイルによって設定されます。 簡単な例を以下に示します。</p></div><div class="literalblock programlisting"><div class=content><pre>server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift</pre></div></div><div class=paragraph><p><code>server</code> オプションは、 使用するサーバを一行に一つずつ指定します。サーバが上記の <code>ntplocal.example.com</code> のように <code>prefer</code> 引数とともに指定された場合、 このサーバは他のサーバより優先されます。 優先されたサーバからの応答は、 他のサーバの応答と著しく異なる場合は破棄されますが、 そうでなければ他の応答を考慮することなく使用されます。 <code>prefer</code> 引数は、通常、 特別な時間モニタハードウェアを備えているような非常に正確であるとされている NTP サーバに対して使用されます。</p></div><div class=paragraph><p><code>driftfile</code> オプションはシステム時計の周波数オフセットを格納するために使用するファイルを指定します。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> プログラムは、 時計の自然変動を自動的に補正するためにこれを用います。 これにより、一定時間外部の時刻ソースから切り離されたとしても、 十分正確な時刻を維持することを可能にします。</p></div><div class=paragraph><p><code>driftfile</code> オプションは、使用している NTP サーバから過去に受け取った応答に関する情報を格納するために、 どのファイルが使用されるか指定します。 このファイルは NTP に関する内部情報を含んでいます。 これは他のプロセスによって修正されてはいけません。</p></div></div><div class=sect3><h4 id=_サーバへのアクセス制御>20.12.3.3. サーバへのアクセス制御<a class=anchor href=#_サーバへのアクセス制御></a></h4><div class=paragraph><p>デフォルトでは NTP サーバはインターネット上のすべてのホストからアクセスが可能です。 <span class=filename>/etc/ntp.conf</span> 内で <code>restrict</code> オプションを指定することによって、 どのマシンがサーバにアクセスできるかを制御できるようにします。</p></div><div class=paragraph><p>NTP サーバにアクセスするマシンのすべてを拒否したいのなら、 以下の行を <span class=filename>/etc/ntp.conf</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>restrict default ignore</pre></div></div><div class=paragraph><p>あなたのネットワーク内のマシンにだけサーバに接続して時計を同期することを認めたいが、 それらからサーバに対して設定を行うのを許さず、 同期する端末としても利用されないようにしたいのなら、 以下を加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>restrict 192.168.1.0 mask 255.255.255.0 notrust nomodify notrap</pre></div></div><div class=paragraph><p><code>192.168.1.0</code> をあなたのネットワークの IP アドレスに <code>255.255.255.0</code> をあなたのネットワークのネットマスクに置き換えてください。</p></div><div class=paragraph><p><span class=filename>/etc/ntp.conf</span> には複数の <code>restrict</code> オプションを置けます。 詳細に付いては <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a> の <code>Access Control Support</code> サブセクションを参照してください。</p></div></div></div><div class=sect2><h3 id=_ntp_サーバの実行>20.12.4. NTP サーバの実行<a class=anchor href=#_ntp_サーバの実行></a></h3><div class=paragraph><p>NTP サーバが起動時に実行されることを保証するために、 <code>xntpd_enable="YES"</code> を <span class=filename>/etc/rc.conf</span> に加えてください。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> にフラグを追加したい場合は <span class=filename>/etc/rc.conf</span> 内の <code>xntpd_flags</code> パラメータを編集してください。</p></div><div class=paragraph><p>マシンを再起動することなくサーバを実行したいときは、 <span class=filename>/etc/rc.conf</span> 内の <code>xntpd_flags</code> で追加されたパラメータをすべて指定して <code>ntpd</code> を実行してください。以下に例を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ntpd -p /var/run/ntpd.pid</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.X では <span class=filename>/etc/rc.conf</span> 内のさまざまなオプションの名前が変わりました。 したがって、上記の <code>xntpd</code> に関するオプションは <code>ntpd</code> に置き換えてください。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_一時的なインターネット接続で_ntpd_を使用する>20.12.5. 一時的なインターネット接続で ntpd を使用する<a class=anchor href=#_一時的なインターネット接続で_ntpd_を使用する></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> プログラムは正しく機能するために、 インターネットへの常時接続を必要としません。しかしながら、 オンデマンドでダイアルアップされるように設定された一時的な接続の場合、 NTP トラフィックがダイアルを引き起こしたり、 接続を維持し続けるようなことを避けるようにした方がよいでしょう。 ユーザ PPP を使用している場合、以下の例のように <span class=filename>/etc/ppp/ppp.conf</span> 内で <code>filter</code> ディレクティブが使用できます。</p></div><div class="literalblock programlisting"><div class=content><pre> set filter dial 0 deny udp src eq 123
 # Prevent NTP traffic from initiating dial out
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Prevent incoming NTP traffic from keeping the connection open
 set filter alive 1 deny udp dst eq 123
 # Prevent outgoing NTP traffic from keeping the connection open
 set filter alive 2 permit 0/0 0/0</pre></div></div><div class=paragraph><p>詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 内の <code>PACKET FILTERING</code> セクション、および <span class=filename>/usr/shared/examples/ppp/</span> 内の例を参照してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>小さい番号のポートをブロックするインターネットアクセスプロバイダでは、 応答があなたのマシンに到達しないので NTP がきちんと動作しない場合もあります。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_さらなる情報源_2>20.12.6. さらなる情報源<a class=anchor href=#_さらなる情報源_2></a></h3><div class=paragraph><p>NTP サーバに関する文書は HTML 形式で <span class=filename>/usr/shared/doc/ntp/</span> にあります。</p></div></div></div></div><div class=sect1><h2 id=network-natd>20.13. ネットワークアドレス変換 (NAT)<a class=anchor href=#network-natd></a></h2><div class=sectionbody><div class=sect2><h3 id=network-natoverview>20.13.1. 概要<a class=anchor href=#network-natoverview></a></h3><div class=paragraph><p>一般に <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> として知られている FreeBSD ネットワークアドレス変換デーモンは、 raw IP パケットを受信して、 ソースアドレスをローカルマシンに変更し、 そのパケットを外向きの IP パケットの流れに再注入するデーモンです。 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> は、 データが戻ってきたときに、データの本来の場所を判別し、 もともと要求した相手へデータを返すことができるようにソース IP アドレスとポートを変更します。</p></div><div class=paragraph><p>NAT の最も一般的な使用法は、 一般的にはインターネット接続共有として知られているものを実行することです。</p></div></div><div class=sect2><h3 id=network-natsetup>20.13.2. 設定<a class=anchor href=#network-natsetup></a></h3><div class=paragraph><p>IPv4 の IP 空間が足りなくなりつつあること、および、 ケーブルや DSL のような高速の加入者回線利用者の増加によって、 人々はますますインターネット接続を共有する手段を必要としています。 一つの接続および IP アドレスを通していくつものコンピュータを回線に接続する能力がある <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> が合理的な選択になります。</p></div><div class=paragraph><p>もっともよくあるのは、ユーザが 1 つの IP アドレスでケーブルまたは DSL 回線に接続されたマシンを持っており、 インターネットへのアクセスを LAN 経由でいくつかのコンピュータに提供するのに、 この接続されたコンピュータを使用したいという場合です。</p></div><div class=paragraph><p>そのためには、インターネットに接続されている FreeBSD マシンはゲートウェイとして動作しなければなりません。 このゲートウェイマシンは 2 つの NIC が必要です (1 つはインターネットルータへ接続するためで、もう 1 つは LAN に接続するためです)。 LAN 上のすべてのマシンはハブまたはスイッチを通して接続されます。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/natd.png alt=ネットワークレイアウト></div></div><div class=paragraph><p>インターネット接続を共有するために、 このような設定がよく使用されています。 LAN 内のマシンの 1 台がインターネットに接続しています。 残りのマシンはその "ゲートウェイ" マシンを通してインターネットにアクセスします。</p></div></div><div class=sect2><h3 id=network-natdkernconfiguration>20.13.3. 設定<a class=anchor href=#network-natdkernconfiguration></a></h3><div class=paragraph><p>次のオプションがカーネルコンフィギュレーションファイルに必要です。</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL
options IPDIVERT</pre></div></div><div class=paragraph><p>さらに、次のオプションを入れてもよいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</pre></div></div><div class=paragraph><p>下記の設定を <span class=filename>/etc/rc.conf</span> で行わなければなりません。</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
firewall_enable=&#34;YES&#34;
firewall_type=&#34;OPEN&#34;
natd_enable=&#34;YES&#34;
natd_interface=&#34;fxp0&#34;
natd_flags=&#34;&#34;</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gateway_enable="YES"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>マシンがゲートウェイとして動作するように設定します。 <code>sysctl net.inet.ip.forwarding=1</code> コマンドを実行しても同じ効果がえられます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>firewall_enable="YES"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/rc.firewall</span> にあるファイアウォールルールを起動時に有効にします。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>firewall_type="OPEN"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>これはあらかじめ定義されている、 すべてのパケットを通すファイアウォールルールセットを指定します。 他のタイプについては <span class=filename>/etc/rc.firewall</span> を参照してください。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>natd_interface="fxp0"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>パケットを転送するインタフェースを指定します (インターネットに接続されたインタフェース)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>natd_flags=""</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>起動時に <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> に渡される追加の引数</p></td></tr></tbody></table><div class=paragraph><p><span class=filename>/etc/rc.conf</span> に前述したオプションを定義すると、起動時に <code>natd -interface fxp0</code> が実行されます。 これは手動でも実行できます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>オプションの定義に <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> のコンフィグレーションファイルを使うこともできます。 この場合には、<span class=filename>/etc/rc.conf</span> に以下の行を追加し、 コンフィグレーションファイルを定義してください。</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class=paragraph><p><span class=filename>/etc/natd.conf</span> ファイルでは、一行ごとにオプションを設定します。たとえば、 次節の例では以下のような行を含むファイルを用意してください。</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>コンフィグレーションファイルに関する、より詳細な情報については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> マニュアルページの <code>-f</code> オプションを調べてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>LAN にぶら下がっているマシンおよびインタフェースのそれぞれには <a href=ftp://ftp.isi.edu/in-notes/rfc1918.txt>RFC 1918</a> で定義されているプライベートネットワーク空間の IP アドレス番号を割り当て、デフォルトゲートウェイアドレスを natd マシンの内側の IP アドレスにすべきです。</p></div><div class=paragraph><p>たとえば LAN 側のクライアント <code>A</code> および <code>B</code> は IP アドレス <code>192.168.0.2</code> および <code>192.168.0.3</code> を割り当てられており、 natd マシンの LAN インタフェースは IP アドレス <code>192.168.0.1</code> を割り当てられています。 クライアント <code>A</code> および <code>B</code> のデフォルトゲートウェイは natd マシンの <code>192.168.0.1</code> に設定されなければなりません。 natd マシンの外部、 またはインターネットインタフェースは <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> の動作に際して特別の修正を必要としません。</p></div></div><div class=sect2><h3 id=network-natdport-redirection>20.13.4. ポート転送<a class=anchor href=#network-natdport-redirection></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> の短所は、インターネットから LAN 内のクライアントにアクセスできないということです。 LAN 内のクライアントは外部に向けて接続を行うことはできますが、 入って来るものを受け取ることができません。これは、LAN クライアントのどれかでインターネットサービスを動かそうとした場合に、 問題になります。これを何とかする単純な方法は natd マシンから LAN クライアントへ、 選択したインターネットポートを転送することです。</p></div><div class=paragraph><p>たとえばクライアント <code>A</code> で実行されている IRC サーバがあり、 クライアント <code>B</code> 上で実行されている web サーバがあるとします。 これが正しく動作するには、ポート 6667 (IRC) および 80 (web) への接続を対応するマシンに転送しなければなりません。</p></div><div class=paragraph><p><code>-redirect_port</code> に適切なオプションを加えて <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> に渡さなければなりません。 書式は以下のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>上記の例では、引数は以下のようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>これで適切な <em>tcp</em> ポートが LAN クライアントマシンに転送されます。</p></div><div class=paragraph><p><code>-redirect_port</code> 引数は個々のポートを対応させるポート範囲を示すのに使えます。 たとえば <em>tcp 192.168.0.2:2000-3000 2000-3000</em> は 2000 番から 3000番ポートに受け取られたすべての接続を、 クライアント <code>A</code> 上の 2000 番から 3000 番に転送します。</p></div><div class=paragraph><p>これらのオプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> を直接実行するか、 <span class=filename>/etc/rc.conf</span> 内の <code>natd_flags=""</code> オプションで設定するか、 もしくはコンフィグレーションファイルから渡してください。</p></div><div class=paragraph><p>設定オプションの詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> をご覧ください。</p></div></div><div class=sect2><h3 id=network-natdaddress-redirection>20.13.5. アドレス転送<a class=anchor href=#network-natdaddress-redirection></a></h3><div class=paragraph><p>複数の IP アドレスが利用可能ですが、 それらが 1 台のマシン上になければならないときには、 アドレス転送が便利です。 これを用いれば <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> は LAN クライアントのそれぞれに外部 IP アドレスを割り当てることができます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> は LAN クライアントから外部へ出て行くパケットを適切な外部の IP アドレスで書き直し、 そして特定の IP アドレスに対してやって来るトラフィックのすべてを、 指定された LAN クライアントに転送します。 これは静的 NAT としても知られています。 たとえば <code>128.1.1.1</code>, <code>128.1.1.2</code> および <code>128.1.1.3</code> の IP アドレスが、 natd ゲートウェイマシンに属しているとします。 <code>128.1.1.2</code> および <code>128.1.1.3</code> は LAN クライアントの <code>A</code> および <code>B</code> に転送される一方で、<code>128.1.1.1</code> は natd ゲートウェイマシンの外部 IP アドレスとして使用することができます。</p></div><div class=paragraph><p><code>-redirect_address</code> の書式は以下のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address localIP publicIP</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>localIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>LAN クライアントの内部 IP アドレス</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>publicIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>LAN クライアントに対応する外部 IP アドレス</p></td></tr></tbody></table><div class=paragraph><p>上記の例では引数は以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p><code>-redirect_port</code> と同様に、これらの引数は <span class=filename>/etc/rc.conf</span> 内の <code>natd_flags=""</code> オプションで設定するか、 コンフィグレーションファイルから渡すことで指定できます。 アドレス転送では、 特定の IP アドレスで受け取られたデータはすべて転送されるので、 port 転送は必要ありません。</p></div><div class=paragraph><p>natd マシン上の外部 IP アドレスは、 アクティブで外部インタフェースにエイリアスされていなければなりません。 やりかたは <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> を参照してください。</p></div></div></div></div><div class=sect1><h2 id=network-inetd>20.14. inetd"スーパサーバ"<a class=anchor href=#network-inetd></a></h2><div class=sectionbody><div class=sect2><h3 id=network-inetd-overview>20.14.1. 概観<a class=anchor href=#network-inetd-overview></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> は複数のデーモンに対する接続を制御するので、 "インターネットスーパサーバ" と呼ばれます。 ネットワークサービスを提供するプログラムは、 一般的にデーモン呼ばれます。inetd は他のデーモンを管理するサーバを努めます。 接続が inetd によって受け付けられると、 inetd は接続がどのデーモンに対するものか判断して、 そのデーモンを起動し、ソケットを渡します。 inetd を 1 つ実行することにより、 それぞれのデーモンをスタンドアロンモードで実行することに比べ、 全体としてのシステム負荷を減らします。</p></div><div class=paragraph><p>基本的に、inetd は他のデーモンを起動するために使用されます。しかし、 chargen, auth および daytime のようなささいなプロトコルは直接扱われます。</p></div><div class=paragraph><p>この節ではコマンドラインオプションおよび設定ファイル <span class=filename>/etc/inetd.conf</span> による inetd の設定の基本を説明します。</p></div></div><div class=sect2><h3 id=network-inetd-settings>20.14.2. 設定<a class=anchor href=#network-inetd-settings></a></h3><div class=paragraph><p>inetd は <span class=filename>/etc/rc.conf</span> の仕組によって初期化されます。 デフォルトでは <code>inetd_enable</code> オプションは "NO" に設定されています。 しかし多くの場合、sysinstall でセキュリティプロファイルを medium に設定することにより、有効化されます。</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>または</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>を <span class=filename>/etc/rc.conf</span> に置くことで、起動時に inetd を有効または無効にできます。</p></div><div class=paragraph><p>さらに <code>inetd_flags</code> オプションによって、 いろいろなコマンドラインオプションを inetd に渡すことができます。</p></div></div><div class=sect2><h3 id=network-inetd-cmdline>20.14.3. コマンドラインオプション<a class=anchor href=#network-inetd-cmdline></a></h3><div class=paragraph><p>inetd 書式</p></div><div class=paragraph><p><code>inetd [-d] [-l] [-w] [-W] [-c maximum] [-C rate] [-a address | hostname] [-p filename] [-R rate] [configuration file]</code></p></div><div class=dlist><dl><dt class=hdlist1>-d</dt><dd><p>デバッグモードにします。</p></dd><dt class=hdlist1>-l</dt><dd><p>成功した接続のログをとります。</p></dd><dt class=hdlist1>-w</dt><dd><p>外部サービスに対して TCP Wrapper を有効にします (デフォルト)。</p></dd><dt class=hdlist1>-W</dt><dd><p>inetd 組み込みの内部サービスに対して TCP Wrapper を有効にします (デフォルト)。</p></dd><dt class=hdlist1>-c maximum</dt><dd><p>サービス毎に同時に起動可能な最大値のデフォルトを指定します。 デフォルトでは無制限です。サービスごとに指定する <code>max-child</code> パラメータで上書きできます。</p></dd><dt class=hdlist1>-C rate</dt><dd><p>1 分間にひとつの IP アドレスから起動されるサービスの、 最大値のデフォルトを指定します。デフォルトは無制限です。 サービスごとに指定する <code>max-connections-per-ip-per-minute</code> パラメータで上書きできます。</p></dd><dt class=hdlist1>-R rate</dt><dd><p>あるサービスを 1 分間に起動できる最大の数を指定します。 デフォルトは 256 です。rate に 0 を指定すると、 起動可能な数は無制限になります。</p></dd><dt class=hdlist1>-a</dt><dd><p>バインドする IP アドレスを一つ指定します。 代わりにホスト名も指定できます。この場合、ホスト名に対応する IPv4 または IPv6 アドレスが使用されます。通常 inetd が <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 内で起動される時点で、ホスト名が指定されます。この場合、 ホスト名は <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 環境に対応するものです。</p><div class=paragraph><p>ホスト名指定が使用され、 IPv4 および IPv6 両方にバインドしたい場合、 <span class=filename>/etc/inetd.conf</span> の各サービスに対して、 各バインドに対する適切なプロトコルのエントリが必要です。 たとえば TCP ベースのサービスは、 ひとつはプロトコルに "tcp4" を使用し、 もう一つは "tcp6" を使用する、 2 つのエントリが必要です。</p></div></dd><dt class=hdlist1>-p</dt><dd><p>デフォルトとは異なる PID を保持するファイルを指定します。</p></dd></dl></div><div class=paragraph><p><span class=filename>/etc/rc.conf</span> 内の <code>inetd_flags</code> オプションを用いて、これらのオプションを inetd に渡すことができます。デフォルトでは <code>inetd_flags</code> は "-wW" に設定されており、 これは inetd の内部および外部サービスに対して TCP wrapper を有効にします。 初心者ユーザはこれらのパラメータを変更する必要は通常ありませんし、 <span class=filename>/etc/rc.conf</span> に入力する必要もありません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>外部サービスは、接続を受け取ったときに起動される inetd の外部にあるデーモンで、 それに対して、内部サービスは inetd 自身が提供する内部のデーモンです。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=network-inetd-conf>20.14.4. <span class=filename>inetd.conf</span><a class=anchor href=#network-inetd-conf></a></h3><div class=paragraph><p>inetd の設定は <span class=filename>/etc/inetd.conf</span> ファイルによって制御されます。</p></div><div class=paragraph><p><span class=filename>/etc/inetd.conf</span> が変更されたときは、 以下のように inetd プロセスに HangUP シグナルを送ることにより、inetd に設定ファイルを再読み込みさせられます。</p></div><div id=network-inetd-hangup class=exampleblock><div class=title>例 4. inetd への HangUP シグナル送付</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/inetd.pid`</span></code></pre></div></div></div></div><div class=paragraph><p>設定ファイルのそれぞれの行は、 個々のデーモンについての指示になります。 ファイル内のコメントは "#" が先頭につきます。 <span class=filename>/etc/inetd.conf</span> の書式は以下のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]
user[:group][/login-class]
server-program
server-program-arguments</pre></div></div><div class=paragraph><p>IPv4 を利用する ftpd デーモンのエントリの例です。</p></div><div class="literalblock programlisting"><div class=content><pre>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</pre></div></div><div class=dlist><dl><dt class=hdlist1>service-name</dt><dd><p>これは特定のデーモンのサービス名です。 これは <span class=filename>/etc/services</span> 内のサービスリストに対応していなければなりません。 これは inetd がどのポートで受け付けなければならないかを決定します。 新しいサービスが作成された場合、まずはじめに <span class=filename>/etc/services</span> 内に記載しなければなりません。</p></dd><dt class=hdlist1>socket-type</dt><dd><p><code>stream</code>, <code>dgram</code>, <code>raw</code> または <code>seqpacket</code> のどれかを指定します。 <code>stream</code> はコネクションに基づいた TCP デーモンに使用しなければならず、 一方で <code>dgram</code> は UDP 転送プロトコルを利用したデーモンに対して使用されます。</p></dd><dt class=hdlist1>protocol</dt><dd><p>次のうちのどれか 1 つを指定します。</p><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">プロトコル</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp, tcp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp, udp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv4 および v6 の両方</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv4 および v6 の両方</p></td></tr></tbody></table></dd><dt class=hdlist1>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]</dt><dd><p><code>wait|nowait</code> は inetd から起動したデーモンが、 自分のソケットを管理できるかどうかを示します。 通常マルチスレッド化されている stream ソケットデーモンは <code>nowait</code> を使用するべきである一方、 <code>dgram</code> ソケットタイプは wait オプションを使用しなければなりません。 <code>nowait</code> は新しいソケット毎に子のデーモンを起動する一方で、 <code>wait</code> は通常複数のソケットを 1 つのデーモンに渡します。</p><div class=paragraph><p>inetd が起動できる子のデーモンの最大数は <code>max-child</code> オプションで設定できます。 特定のデーモンに対して、起動する数が 10 までという制限が必要な場合、 <code>nowait</code> の後に <code>/10</code> を置きます。</p></div><div class=paragraph><p><code>max-child</code> に加えて、他にある 1 つの場所から特定のデーモンへの最大接続数を制限するオプションが利用できます。 <code>max-connections-per-ip-per-minute</code> がそれです。ここに 10 を指定すると、特定の IP アドレスからの特定のサービスへの接続を 1 分間につき 10 回に制限します。 これは故意または故意でない資源の浪費および、 マシンへのサービス不能 (DoS) 攻撃を防ぐのに有用です。</p></div><div class=paragraph><p><code>wait</code> または <code>nowait</code> はこの欄に必ず必要です。 <code>max-child</code> および <code>max-connections-per-ip-per-minute</code> は任意です。</p></div><div class=paragraph><p><code>max-child</code> または <code>max-connections-per-ip-per-minute</code> 制限をかけない stream タイプのマルチスレッドデーモンの設定は <code>nowait</code> になります。</p></div><div class=paragraph><p>作成できる子プロセスの上限が 10 である同じデーモンの設定は <code>nowait/10</code> になります。</p></div><div class=paragraph><p>さらに、 1 分間に IP アドレスあたりの接続制限が 20、 子プロセスの上限が 10 である同じデーモンの設定は <code>nowait/10/20</code> になります。</p></div><div class=paragraph><p>以下のように、これらのオプションはすべて fingerd デーモンのデフォルト設定に使われています。</p></div><div class="literalblock programlisting"><div class=content><pre>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</pre></div></div></dd><dt class=hdlist1>user</dt><dd><p>user はあるデーモンが実行するときのユーザ名を指定します。 一般的にデーモンは <code>root</code> ユーザとして実行します。セキュリティを考慮して、 いくつかのサーバは <code>daemon</code> ユーザ、 または最低の権限が与えられている <code>nobody</code> ユーザとして実行することも多く見られます。</p></dd><dt class=hdlist1>server-program</dt><dd><p>接続を受け取ったときに実行するデーモンのフルパスです。 デーモンが inetd によって内部的に提供されるサービスの場合 <code>internal</code> を使用します。</p></dd><dt class=hdlist1>server-program-arguments</dt><dd><p>ここには、起動するときにデーモンに渡される、 argv[0] から始まる引数を指定して、 <code>server-program</code> と協調して動作します。 mydaemon -d がコマンドラインの場合、 <code>server program arguments</code> の値に <code>mydaemon -d</code> を指定します。 また、デーモンが内部サービスの場合、ここに <code>internal</code> を指定します。</p></dd></dl></div></div><div class=sect2><h3 id=network-inetd-security>20.14.5. セキュリティ<a class=anchor href=#network-inetd-security></a></h3><div class=paragraph><p>インストールの時に選択したセキュリティプロファイルによっては、 多くの inetd のデーモンがデフォルトで有効になっているかもしれません。 あるデーモンが特に必要でない場合には、それを無効にしてください! 問題となっているデーモンが記述されている行の先頭に "#" をおいて <a href=#network-inetd-hangup>inetd にハングアップシグナル</a>を送ってください。 fingerd のようないくつかのデーモンは、 動かそうとすべきではないかもしれません。なぜなら、 それらは攻撃者に対してあまりにも多くの情報を与えるからです。</p></div><div class=paragraph><p>セキュリティをあまり考慮せず、 接続試行に対してタイムアウトまでの時間が長いか、 タイムアウトしないデーモンもあります。 これは、特定のデーモンに攻撃者がゆっくり接続要求を送ることによって、 利用可能なリソースを飽和させることを可能にします。ある種のデーモンに <code>ip-per-minute</code> および <code>max-child</code> 制限を設けることはよい考えかもしれません。</p></div><div class=paragraph><p>TCP wrapper はデフォルトで有効です。 inetd から起動されるさまざまなデーモンに対して TCP 制限を設けることの詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> マニュアルページを参照してください。</p></div></div><div class=sect2><h3 id=network-inetd-misc>20.14.6. その他<a class=anchor href=#network-inetd-misc></a></h3><div class=paragraph><p>daytime, time, echo, discard, chargen および auth はすべて inetd が内部的に提供するサービスです。</p></div><div class=paragraph><p>auth サービスは identity (ident, identd) ネットワークサービスを提供し、 ある程度設定可能です。</p></div><div class=paragraph><p>詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> マニュアルを参照してください。</p></div></div></div></div><div class=sect1><h2 id=network-plip>20.15. パラレルライン IP (PLIP)<a class=anchor href=#network-plip></a></h2><div class=sectionbody><div class=paragraph><p>PLIP はパラレルポート間で TCP/IP 通信を可能にします。 これはネットワークカードの無いマシンやノートパソコンにインストールするときに役に立ちます。 この節では以下について説明します。</p></div><div class=ulist><ul><li><p>パラレル (ラップリンク または パラレルクロス) ケーブルの作成。</p></li><li><p>2 台のコンピュータの PLIP による接続。</p></li></ul></div><div class=sect2><h3 id=network-create-parallel-cable>20.15.1. パラレル (クロス) ケーブルの作成<a class=anchor href=#network-create-parallel-cable></a></h3><div class=paragraph><p>コンピュータ用品店のほとんどでパラレル (クロス) ケーブルを購入することができます。 購入することができないか、 単にケーブルがどのような構造であるか知りたい場合は、 次の表に通常のパラレルプリンタケーブルをもとに作成する方法が示されています。</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>表 1. ネットワーク向けのパラレル (クロス) ケーブル結線</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">A-名称</th><th class="tableblock halign-left valign-top">A-端</th><th class="tableblock halign-left valign-top">B-端</th><th class="tableblock halign-left valign-top">説明</th><th class="tableblock halign-left valign-top">Post/Bit</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA0
-ERROR
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
2
15
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
15
2
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x01
1/0x08
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA1
+SLCT
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
3
13
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
13
3
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x02
1/0x10
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA2
+PE
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
4
12
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
12
4
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x04
1/0x20
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA3
-ACK
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
5
10
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
10
5
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Strobe</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x08
1/0x40
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA4
BUSY
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
6
11
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
11
6
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x10
1/0x80
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>GND</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>GND</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>-</pre></div></td></tr></tbody></table></div><div class=sect2><h3 id=network-plip-setup>20.15.2. PLIP の設定<a class=anchor href=#network-plip-setup></a></h3><div class=paragraph><p>はじめに、ラップリンクケーブルを入手しなければなりません。 次に、両方のコンピュータのカーネルが <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> ドライバ対応であることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep lp /var/run/dmesg.boot</span>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</code></pre></div></div><div class=paragraph><p>パラレルポートは割り込み駆動ポートでなければなりません。 FreeBSD 4.X では、 以下のような行がカーネルコンフィギュレーションファイル内になければならないでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>device ppc0 at isa? irq 7</pre></div></div><div class=paragraph><p>FreeBSD 5.X では <span class=filename>/boot/device.hints</span> ファイルに以下の行がなければならないでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.at=&#34;isa&#34;
hint.ppc.0.irq=&#34;7&#34;</pre></div></div><div class=paragraph><p>それからカーネルコンフィギュレーションファイルに <code>device plip</code> という行があるか、または <span class=filename>plip.ko</span> カーネルモジュールが読み込まれていることを確認してください。 どちらの場合でも <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> コマンドを直接実行したときに、 パラレルネットワークインタフェースが現れるはずです。 FreeBSD 4.X ではこのようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lp0</span>
lp0: <span class=nv>flags</span><span class=o>=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</code></pre></div></div><div class=paragraph><p>FreeBSD 5.X ではこのようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0</span>
plip0: <span class=nv>flags</span><span class=o>=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>パラレルインタフェースに対して用いられるデバイス名は FreeBSD 4.X (<span class=filename>lpX</span>) と FreeBSD 5.X (<span class=filename>plipX</span>) 間で異なります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>両方のコンピュータのパラレルインタフェースにラップリンクケーブルを接続します。</p></div><div class=paragraph><p>両方のネットワークインタフェースパラメータを <code>root</code> で設定します。 たとえば、FreeBSD 4.X を動作させている <code>host1</code> と FreeBSD 5.X を動作させている <code>host2</code> の両ホストを接続したい場合は次のようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>                 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</pre></div></div><div class=paragraph><p>次のコマンドで <code>host1</code> 上のインタフェースを設定します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lp0 10.0.0.1 10.0.0.2</span></code></pre></div></div><div class=paragraph><p>次のコマンドで <code>host2</code> 上のインタフェースを設定します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0 10.0.0.2 10.0.0.1</span></code></pre></div></div><div class=paragraph><p>さて、これで接続が確立したはずです。詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=lp&amp;sektion=4&amp;format=html">lp(4)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> マニュアルページをご覧ください。</p></div><div class=paragraph><p>さらに<span class=filename>/etc/hosts</span> に両ホストを加えるとよいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain</pre></div></div><div class=paragraph><p>接続がうまくいっているか確かめるために、 両方のホスト上で互いを ping してください。 たとえば <code>host1</code> で以下を実行します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lp0</span>
lp0: <span class=nv>flags</span><span class=o>=</span>8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 <span class=nt>--</span><span class=o>&gt;</span> 10.0.0.2 netmask 0xff000000
<span class=c># netstat -r</span>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       lp0
<span class=c># ping -c 4 host2</span>
PING host2 <span class=o>(</span>10.0.0.2<span class=o>)</span>: 56 data bytes
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.774 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.530 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.556 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.714 ms

<span class=nt>---</span> host2 ping statistics <span class=nt>---</span>
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 2.530/2.643/2.774/0.103 ms</code></pre></div></div></div></div></div><div class=sect1><h2 id=network-ipv6>20.16. IPv6<a class=anchor href=#network-ipv6></a></h2><div class=sectionbody><div class=paragraph><p>IPv6 (IPng "IP next generation" とも呼ばれます) は、著名な IP プロトコル (IPv4 とも呼ばれます) の新しいバージョンです。 他の最新の *BSD システムと同様に FreeBSD は KAME IPv6 リファレンス実装を含んでいます。したがって、あなたの FreeBSD システムには IPv6を試すために必要なものすべてが備わっています。 この節では IPv6 の設定と実行に関して説明します。</p></div><div class=paragraph><p>1990 年代のはじめには、人々は IPv4 アドレス空間が急速に縮小していることに気づくようになりました。 インターネットの成長率が増大するにしたがって、 2 つの心配ごとがでてきました。</p></div><div class=ulist><ul><li><p>アドレスの枯渇。 今日では、プライベートアドレス空間 (<code>10.0.0.0/8</code>, <code>192.168.0.0/24</code> など) およびネットワークアドレス変換 (NAT) が使用されているので、それほど心配されていません。</p></li><li><p>ルーティングテーブルのエントリが大きくなりすぎていました。 これは今でも心配な事柄です。</p></li></ul></div><div class=paragraph><p>IPv6 は以下の、そしてその他多くの問題を扱います。</p></div><div class=ulist><ul><li><p>128 bit アドレス空間。言い換えると、理論上 340,282,366,920,938,463,463,374,607,431,768,211,456 個のアドレスが利用可能です。これは地球上の一平方メータあたり、 およそ 6.67 * 10^27 個の IPv6 アドレスがあることを意味します。</p></li><li><p>ルータは、 ルーティングテーブル内にネットワーク集約アドレスだけを格納することで、 ルーティングテーブルの平均を 8192 項目程度に減らします。</p></li></ul></div><div class=paragraph><p>他にも以下のように IPv6 の便利な機能がたくさんあります。</p></div><div class=ulist><ul><li><p>アドレス自動設定 (RFC2462)</p></li><li><p>エニーキャスト (anycast) アドレス ("one-out-of many" 訳注: 複数の異なるノードが応答する 1 つのアドレス。 RFC2526 を参照してください)。</p></li><li><p>強制マルチキャストアドレス</p></li><li><p>IPsec (IP セキュリティ)</p></li><li><p>シンプルなヘッダ構造</p></li><li><p>モバイル IP</p></li><li><p>IPv4 から IPv6 への移行手段</p></li></ul></div><div class=paragraph><p>詳細については下記を参照してください。</p></div><div class=ulist><ul><li><p><a href=http://www.sun.com>Sun.com</a> の IPv6 概観</p></li><li><p><a href=http://www.ipv6.org>IPv6.org</a></p></li><li><p><a href=http://www.kame.net>KAME.net</a></p></li><li><p><a href=http://www.6bone.net>6bone.net</a></p></li></ul></div><div class=sect2><h3 id=_ipv6_アドレスの背景>20.16.1. IPv6 アドレスの背景<a class=anchor href=#_ipv6_アドレスの背景></a></h3><div class=paragraph><p>いくつか違うタイプの IPv6 アドレスがあります。 ユニキャスト (Unicast)、エニーキャスト (Anycast) およびマルチキャスト (Multicast) です。</p></div><div class=paragraph><p>ユニキャストアドレスは周知のアドレスです。 ユニキャストアドレスへ送られたパケットは、 まさにそのアドレスに属するインターフェースに到着します。</p></div><div class=paragraph><p>エニーキャストアドレスはユニキャストアドレスと構文上判別不可能ですが、 インタフェース群に宛てられています。 エニーキャストアドレスに送られたパケットは (ルータメトリック的に) 最も近いインタフェースに到着します。 エニーキャストアドレスはルータでしか使ってはいけません。</p></div><div class=paragraph><p>マルチキャストアドレスはインタフェース群を識別します。 マルチキャストアドレスに送られたパケットは、 マルチキャスト群に属するすべてのインタフェースに到着します。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>IPv4 のブロードキャストアドレス (通常 <code>xxx.xxx.xxx.255</code>) は、IPv6 ではマルチキャストアドレスで表現されます。</p></div></td></tr></tbody></table></div><table class="tableblock frame-none grid-all stretch"><caption class=title>表 2. 予約された IPv6 アドレス</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">IPv6 アドレス</th><th class="tableblock halign-left valign-top">プレフィックス長 (ビット)</th><th class="tableblock halign-left valign-top">説明</th><th class="tableblock halign-left valign-top">備考</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>不特定</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 の <code>0.0.0.0</code> 参照</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ループバックアドレス</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 の <code>127.0.0.1</code> 参照</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 埋め込みアドレス</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>下位の 32 ビットは IPv4 アドレスです。 "IPv4 互換 IPv6 アドレス" とも呼ばれます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 射影 IPv6 アドレス</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>下位の 32 ビットは IPv4 アドレスです。 IPv6 に対応していないホストに対するアドレスです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::</code> - <code>feb::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>リンクローカル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 のループバックアドレス参照</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fec0::</code> - <code>fef::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>サイトローカル</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>マルチキャスト</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>001</code> (基数 2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>グローバルユニキャスト</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>すべてのグローバルユニキャストアドレスはこのプールから割り当てられます。 はじめの 3 ビットは "001" です。</p></td></tr></tbody></table></div><div class=sect2><h3 id=_ipv6_アドレスを読む>20.16.2. IPv6 アドレスを読む<a class=anchor href=#_ipv6_アドレスを読む></a></h3><div class=paragraph><p>正規の書式では <code>x:x:x:x:x:x:x:x</code> と表されます。それぞれの "x" は 16 ビットの 16 進数です。たとえば <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code> となります。</p></div><div class=paragraph><p>すべてゼロの長い部分文字列がアドレス内によく現れます。 そのため、そのような部分文字列は "::" に短縮することができます。 たとえば、<code>fe80::1</code> は正規形の <code>fe80:0000:0000:0000:0000:0000:0000:0001</code> に対応します。</p></div><div class=paragraph><p>3 番目の形式は、最後の 32 ビットの部分を "." を分割文字として使う、 なじみ深い IPv4 (10 進) 形式で書くことです。 たとえば <code>2002::10.0.0.1</code> は (16 進) 正規形の <code>2002:0000:0000:0000:0000:0000:0a00:0001</code> に対応し、同時に <code>2002::a00:1</code> と書くこととも等価です。</p></div><div class=paragraph><p>ここまで来れば、下記を理解することができるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre></div></div><div class=paragraph><p><code>fe80::200:21ff:fe03:8e1%rl0</code> は自動的に設定されたリンクローカルアドレスです。 これは自動設定の一環として、 イーサネット MAC アドレスを変換したものを含んでいます。</p></div><div class=paragraph><p>IPv6 アドレス構造についての詳細は RFC3513 をご覧ください。</p></div></div><div class=sect2><h3 id=_接続>20.16.3. 接続<a class=anchor href=#_接続></a></h3><div class=paragraph><p>現在、他の IPv6 ホストおよびネットワークに接続するためには 4 つの方法があります。</p></div><div class=ulist><ul><li><p>6bone 実験ネットワークに参加する。</p></li><li><p>上流のプロバイダから IPv6 ネットワークの割り当てを受ける。 手順については、インターネットプロバイダに問い合わせてください。</p></li><li><p>IPv6 over IPv4 によるトンネル。</p></li><li><p>ダイアルアップ接続の場合 freenet6 port を使用する。</p></li></ul></div><div class=paragraph><p>ここでは、現在もっともよく使われている方法と思われる 6bone へ接続する方法を説明します。</p></div><div class=paragraph><p>はじめに 6bone サイトをみて、 あなたに最も近い 6bone 接続先を見つけてください。 責任者に連絡すると、少しばかり運がよければ、 接続を設定する方法についての指示を受けられるでしょう。 多くのばあい、これには GRE (gif) トンネルの設定が含まれます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>6bone は <code>3ffe::</code> (16 ビット) という IPv6 アドレスを割り振られた実験目的のネットワークでしたが、 2006 年 6 月に運用を停止することになっています。 他の商用や試験的な IPv6 接続サービスを探してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ここに <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> トンネルを設定する典型的な例を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0</span>
gif0: <span class=nv>flags</span><span class=o>=</span>8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
<span class=c># ifconfig gif0 tunnel MY_IPv4_ADDR  HIS_IPv4_ADDR</span>
<span class=c># ifconfig gif0 inet6 alias MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</span></code></pre></div></div><div class=paragraph><p>大文字になっている単語を、 上流の 6bone ノードから受け取った情報に置き換えてください。</p></div><div class=paragraph><p>これでトンネルが確立されます。<a href="https://man.freebsd.org/cgi/man.cgi?query=ping6&amp;sektion=8&amp;format=html">ping6(8)</a> を <code>ff02::1%gif0</code> に送ることによって、トンネルが動作しているか確かめてください。 ping の応答を 2 つ受け取るはずです。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>ff02:1%gif0</code> というアドレスに興味をそそられている場合のために説明すると、 これはマルチキャストアドレスです。 <code>%gif0</code> は、ネットワークインタフェース <span class=filename>gif0</span> 上のマルチキャストアドレスが使用されるということを示しています。 マルチキャストアドレスに対して <code>ping</code> を送ったので、トンネルのもう一方の端も応答します。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ここまで来ると 6bone アップリンクに経路設定することは比較的簡単でしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -inet6 default -interface gif0</span>
<span class=c># ping6 -n MY_UPLINK</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># traceroute6 www.jp.FreeBSD.org</span>
<span class=o>(</span>3ffe:505:2008:1:2a0:24ff:fe57:e561<span class=o>)</span> from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1  atnet-meta6  14.147 ms  15.499 ms  24.319 ms
     2  6bone-gw2-ATNET-NT.ipv6.tilab.com  103.408 ms  95.072 ms <span class=k>*</span>
     3  3ffe:1831:0:ffff::4  138.645 ms  134.437 ms  144.257 ms
     4  3ffe:1810:0:6:290:27ff:fe79:7677  282.975 ms  278.666 ms  292.811 ms
     5  3ffe:1800:0:ff00::4  400.131 ms  396.324 ms  394.769 ms
     6  3ffe:1800:0:3:290:27ff:fe14:cdee  394.712 ms  397.19 ms  394.102 ms</code></pre></div></div><div class=paragraph><p>この出力はマシンによって異なります。 これで、あなたが <a class=package href=https://cgit.freebsd.org/ports/tree/www/mozilla/>www/mozilla</a> のような IPv6 が利用可能なブラウザを持っていれば、 IPv6 サイト <a href=http://www.kame.net>www.kame.net</a> にいって踊るカメを見ることができるでしょう。</p></div></div><div class=sect2><h3 id=_ipv6_世界の_dns>20.16.4. IPv6 世界の DNS<a class=anchor href=#_ipv6_世界の_dns></a></h3><div class=paragraph><p>IPv6 のための新しい DNS レコードが 2 種類あります。</p></div><div class=ulist><ul><li><p>AAAA レコード</p></li><li><p>A6 レコード</p></li></ul></div><div class=paragraph><p>AAAA レコードは簡単に使えます。</p></div><div class="literalblock programlisting"><div class=content><pre>MYHOSTNAME           AAAA    MYIPv6ADDR</pre></div></div><div class=paragraph><p>上記をプライマリゾーン DNS ファイルに加えて、 もらったばかりの IPv6 アドレスにホスト名を割り当ててください。 あなた自身で DNS ゾーンを管理していない場合は、 DNS プロバイダに頼んでください。 bind の最新バージョン (バージョン 8.3 および 9) は AAAA レコードに対応しています。</p></div></div></div></div></div><hr><div class=last-modified><p><strong>最終更新日</strong>: 2024年3月9日 by <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/ja/books/handbook/mail class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/ja/books/handbook/partv class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目次</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>20.1. この章では</a></li><li><a href=#network-routing>20.2. ゲートウェイと経路</a></li><li><a href=#network-wireless>20.3. 無線ネットワーク</a></li><li><a href=#network-bluetooth>20.4. Bluetooth</a></li><li><a href=#network-bridging>20.5. ブリッジ</a></li><li><a href=#network-nfs>20.6. NFS</a></li><li><a href=#network-diskless>20.7. ディスクレス稼働</a></li><li><a href=#network-isdn>20.8. ISDN</a></li><li><a href=#network-nis>20.9. NIS/YP</a></li><li><a href=#network-dhcp>20.10. DHCP</a></li><li><a href=#network-dns>20.11. DNS</a></li><li><a href=#network-ntp>20.12. NTP</a></li><li><a href=#network-natd>20.13. ネットワークアドレス変換 (NAT)</a></li><li><a href=#network-inetd>20.14. inetd"スーパサーバ"</a></li><li><a href=#network-plip>20.15. パラレルライン IP (PLIP)</a></li><li><a href=#network-ipv6>20.16. IPv6</a></li></ul></nav><hr><div class=resources><h3>リソース</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="PDF 版のダウンロード"></i><a href=https://download.freebsd.org/doc/ja/books/handbook/handbook_ja.pdf>PDF 版のダウンロード</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/ja/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/ja/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Choose language">
<span>日本語</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/ja class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/ja/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>