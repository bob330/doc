<!doctype html><html class=theme-light lang=ja><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content="FreeBSD ハンドブック,ハンドブック"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/ja/books/handbook/book/><title>FreeBSD ハンドブック | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="FreeBSD ハンドブック"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="ja"><meta property="og:url" content="http://172.16.201.134:1313/ja/books/handbook/book/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/ja\/books\/handbook\/book\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/ja>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/ja/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/ja/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/ja/books>Books</a></li><li><a href=http://172.16.201.134:1313/ja/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/ja/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=ja>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>FreeBSD ハンドブック</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2022 The FreeBSD Documentation Project</div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD は The FreeBSD Foundation の登録商標です。</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390 および ThinkPad は アメリカ合衆国、その他の国、または両方における International Business Machines Corporation の商標です。</p><p>IEEE, POSIX および 802 は アメリカ合衆国における Institute of Electrical and Electronics Engineers, Inc. の登録商標です。</p><p>Red Hat, RPM は アメリカ合衆国およびその他の国における Red Hat, Inc. の商標または登録商標です。</p><p>3Com および HomeConnect は 3Com Corporation の登録商標です。</p><p>Adobe, Acrobat, Acrobat Reader, Flash および PostScript は アメリカ合衆国および/またはその他の国の Adobe Systems Incorporated の登録商標または商標です。</p><p>Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime および TrueType は Apple Inc. の商標で、 アメリカ合衆国およびその他の国で登録されています。</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium および Xeon はアメリカ合衆国およびその他の国における Intel Corporation またはその関連会社の商標または登録商標です。</p><p>Linux は Linus Torvalds の登録商標です。</p><p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media および Windows NT は アメリカ合衆国および/またはその他の国における Microsoft Corporation の登録商標または商標です。</p><p>Motif, OSF/1 および UNIX は アメリカ合衆国およびその他の国における The Open Group の登録商標で、 IT DialTone および The Open Group は同じく商標です。</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS および VirtualBox は アメリカ合衆国およびその他の国における Sun Microsystems, Inc. の 商標または登録商標です。</p><p>RealNetworks, RealPlayer および RealAudio は RealNetworks, Inc. の登録商標です。</p><p>Oracle は Oracle Corporation の登録商標です。</p><p>3ware は 3ware Inc. の登録商標です。</p><p>ARM は ARM Limited の登録商標です。</p><p>Adaptec は Adaptec, Inc. の登録商標です。</p><p>Android は Google Inc. の商標です。</p><p>Heidelberg, Helvetica, Palatino, および Times Roman はアメリカ合衆国およびその他の国における Heidelberger Druckmaschinen AG の登録商標または商標です。</p><p>Intuit および Quicken は アメリカ合衆国およびその他の国における Intuit Inc. またはその関連会社の 商標および/または登録商標です。</p><p>LSI Logic, AcceleRAID, eXtremeRAID, MegaRAID および Mylex は LSI Logic Corp. の商標または登録商標です。</p><p>MATLAB は The MathWorks, Inc. の登録商標です。</p><p>SpeedTouch は Thomson の商標です。</p><p>VMware は VMware, Inc. の商標です。</p><p>Mathematica は Wolfram Research, Inc. の登録商標です。</p><p>Ogg Vorbis および Xiph.Org は Xiph.Org の商標です。</p><p>XFree86 は The XFree86 Project, Inc. の商標です。</p><p>製造者および販売者が製品を区別するのに 用いている表示の多くは、商標とされています。この文書に登場する表示のうち FreeBSD Project がその商標を確認しているものには、その表示に続いて“™” または “®” 記号がおかれています。</p></details></div><div class=toc-mobile><h3>目次</h3><nav id=TableOfContents><ul><li><a href=#book-preface>前書き</a><ul><li><a href=#preface-audience>想定している読者</a></li><li><a href=#preface-changes-from3>第 3 版からの変更</a></li><li><a href=#preface-changes-from2>第 2 版 (2004) からの変更</a></li><li><a href=#preface-changes>第 1 版 (2001) からの変更</a></li><li><a href=#preface-overview>この文書の構成</a></li><li><a href=#preface-conv>この文書で用いられている表記法</a></li><li><a href=#preface-acknowledgements>謝辞</a></li></ul></li><li><a href=#getting-started>Part I: 導入</a><ul><li><a href=#introduction>Chapter 1. はじめに</a></li><li><a href=#bsdinstall>Chapter 2. FreeBSD のインストール</a></li><li><a href=#basics>Chapter 3. FreeBSD の基礎知識</a></li><li><a href=#ports>Chapter 4. アプリケーションのインストール - packages と ports</a></li><li><a href=#x11>Chapter 5. X Window System</a></li></ul></li><li><a href=#common-tasks>Part II: 日々の生活</a><ul><li><a href=#desktop>Chapter 6. デスクトップアプリケーション</a></li><li><a href=#multimedia>Chapter 7. マルチメディア</a></li><li><a href=#kernelconfig>Chapter 8. FreeBSD カーネルのコンフィグレーション</a></li><li><a href=#printing>Chapter 9. プリンタの利用</a></li><li><a href=#linuxemu>Chapter 10. Linux® バイナリ互換機能</a></li></ul></li><li><a href=#system-administration>Part III: システム管理</a><ul><li><a href=#config-tuning>Chapter 11. 設定とチューニング</a></li><li><a href=#boot>Chapter 12. FreeBSD の起動のプロセス</a></li><li><a href=#security>Chapter 13. セキュリティ</a></li><li><a href=#disks>Chapter 14. ストレージ</a></li><li><a href=#l10n>Chapter 15. 地域化 (localization) - i18n/L10n の利用と設定</a></li><li><a href=#updating-upgrading>Chapter 16. FreeBSD のアップデートとアップグレード</a></li></ul></li><li><a href=#network-communication>Part IV: ネットワーク通信</a><ul><li><a href=#serialcomms>Chapter 17. シリアル通信</a></li><li><a href=#ppp-and-slip>Chapter 18. PPP と SLIP</a></li><li><a href=#mail>Chapter 19. 電子メール</a></li><li><a href=#advanced-networking>Chapter 20. 高度なネットワーク</a></li></ul></li><li><a href=#appendices>Part V: 付録</a><ul><li><a href=#_freebsd_の入手方法>付録 A: FreeBSD の入手方法</a></li><li><a href=#bibliography>付録 B: 参考図書</a></li><li><a href=#eresources>付録 C: インターネット上のリソース</a></li><li><a href=#pgpkeys>付録 D: PGP 公開鍵</a></li></ul></li></ul></nav></div><div>[ <a href=../>Split HTML</a> / Single HTML ]</div><div class=book-content><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>概要</p></div><div class=paragraph><p>FreeBSD へようこそ! このハンドブックは <em>FreeBSD 13.1-RELEASE</em> および <em>FreeBSD 12.4-RELEASE</em> のインストールと日常での使い方について記述したものです。
本ハンドブックはさまざまな人々による編集の成果で、現在も改編作業中です。
いま存在するセクションの中には情報が古くなってしまっているものがあります。
もし、この文書を新しくしたり、 新しい情報の追加に協力したいとお考えなら、 <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD documentation project メーリングリスト</a> まで電子メールを (英語で) 送ってください。</p></div><div class=paragraph><p>このハンドブックの最新バージョンは <a href=https://www.FreeBSD.org/ja/>FreeBSD ウェブサイト</a> から入手できます。
以前のバージョンは <a href=https://docs.FreeBSD.org/doc/>https://docs.FreeBSD.org/doc/</a> から入手できます。
この文書の他の文書形式や圧縮形式は <a href=https://download.freebsd.org/doc/>FreeBSD ダウンロードサーバ</a> や <a href=./mirrors#mirrors-http>ミラーサイト</a> からダウンロードできます。
ハンドブックやその他の文書は、<a href=https://www.FreeBSD.org/ja/search/>検索ページ</a> で検索できます。</p></div><hr></div></div><div class=sect1><h2 id=book-preface>前書き<a class=anchor href=#book-preface></a></h2><div class=sectionbody><div class=sect2><h3 id=preface-audience>想定している読者<a class=anchor href=#preface-audience></a></h3><div class=paragraph><p>最初の部分は FreeBSD を使い始めた人向けで、FreeBSD のインストールの過程を手引きし、UNIX® の基礎となっている概念や慣習を丁寧に紹介します。
この部分に取り組むために必要なのは、探究心と、紹介された新たな概念を理解する能力だけです。</p></div><div class=paragraph><p>その次の、ハンドブックのはるかに大きな部分では、FreeBSD システム管理者が興味を抱くあらゆる種類の話題が分かりやすく言及されています。
一部の章は、その章の前に読んでおくべきことが推奨されており、各章の始めの概要で述べられています。</p></div><div class=paragraph><p>さらなる情報源の一覧は、<a href=./#bibliography>参考図書</a> をご覧ください。</p></div></div><div class=sect2><h3 id=preface-changes-from3>第 3 版からの変更<a class=anchor href=#preface-changes-from3></a></h3><div class=paragraph><p>オンライン版のハンドブックは、FreeBSD ドキュメンテーションプロジェクトの献身的なメンバーによる 10 年以上に渡る作業の頂点に立つものです。
2004 年に出版された 2 巻組の第 3 版からの主な変更は、次のようなものです。</p></div><div class=ulist><ul><li><p>Windows® アプリケーションを FreeBSD 上で実行するための WINE に関する情報が追加されました。</p></li><li><p>強力なパフォーマンス解析ツール DTrace に関する情報が追加されました。</p></li><li><p>ファイルシステム対応の章が追加されました。 Sun™ の ZFS のような FreeBSD ネイティブではないファイルシステムへの対応について説明しています。</p></li><li><p>セキュリティ監査の章が追加されました。 FreeBSD における新しい監査のケイパビリティおよびその使用方法について説明しています。</p></li><li><p>仮想化の章が追加されました。os; を仮想化ソフトへインストールする方法などを取り上げています。</p></li><li><p>新しいインストールユーティリティの bsdinstall を用いた FreeBSD のインストール方法を説明する <a href=./#bsdinstall>FreeBSD のインストール</a> という章が追加されました。</p></li></ul></div></div><div class=sect2><h3 id=preface-changes-from2>第 2 版 (2004) からの変更<a class=anchor href=#preface-changes-from2></a></h3><div class=paragraph><p>第 3 版は、FreeBSD ドキュメンテーションプロジェクトの献身的なメンバーによる 2 年以上に渡る作業の頂点に立つものです。
サイズが大きくなったため、印刷版は、2 巻での出版となりました。
この新たな版における主な変更は、次のようなものです。</p></div><div class=ulist><ul><li><p><a href=./#config-tuning>設定とチューニング</a> に、ACPI 電源管理、<code>cron</code> システムユーティリティ、 およびカーネルチューニングオプションに関するより多くの情報が追加されました。</p></li><li><p><a href=./#security>セキュリティ</a> に、 Virtual Private Network (VPN)、 ファイルシステムアクセスコントロールリスト (ACL)、 およびセキュリティ勧告に関する情報が追加されました。</p></li><li><p>Mandatory Access Control (MAC) の章がこの版で追加されました。 MAC がどのようなもので、 このメカニズムがどのように FreeBSD システムを安全にするかについて説明しています。</p></li><li><p><a href=./#disks>ストレージ</a> に、 USB ストレージデバイス、ファイルシステムスナップショット、 ファイルシステムクォータ、 ファイルおよびネットワークベースのファイルシステム、 暗号化されたディスクパーティションに関する情報が追加されました。</p></li><li><p><a href=./#ppp-and-slip>PPP と SLIP</a> に、 トラブルシューティングの節が追加されました。</p></li><li><p><a href=./#mail>電子メール</a>, に、 他のメール転送エージェント、SMTP 認証、UUCP, fetchmail, procmail や他の高度な話題についての情報が追加されました。</p></li><li><p>ネットワークサービスの章が、この版で新しく追加されました。 この章では、Apache HTTP サーバ、 fptd および Samba を用いて Microsoft® Windows® クライアント用にサーバを設定する方法などを取り上げています。 再構成によりいくつかの節が、<a href=./#advanced-networking>高度なネットワーク</a> から移動してきました。</p></li><li><p><a href=./#advanced-networking>高度なネットワーク</a> に、 FreeBSD での Bluetooth® デバイスの使用、 ワイヤレスネットワークの設定、 Asynchronous Transfer Mode (ATM) ネットワークに関する情報が追加されました。</p></li><li><p>本書で使われている専門用語の定義をまとめた用語集が追加されました。</p></li><li><p>本書を通じて表および図の表現において数多くの改良がおこなわれました。</p></li></ul></div></div><div class=sect2><h3 id=preface-changes>第 1 版 (2001) からの変更<a class=anchor href=#preface-changes></a></h3><div class=paragraph><p>第 2 版は、FreeBSD ドキュメンテーションプロジェクトの献身的なメンバーによる 2 年以上に渡る作業の頂点に立つものでした。
この新たな版における主な変更は、次のようなものでした。</p></div><div class=ulist><ul><li><p>完備した索引が追加されました。</p></li><li><p>ASCII キャラクタによる図はすべて画像に置き換えられました (訳注: 日本語版は作業中です)。</p></li><li><p>各章に、章に記載されている内容と、 読者に期待される予備知識がすぐに分かるように、 一定の内容の概要が付け加えられました。</p></li><li><p>内容は、"始めに"、"システム管理"、 "付録" の 3 つの論理的な部分に再構成されました。</p></li><li><p><a href=./#basics>UNIX の基礎知識</a> には、プロセス、デーモン、 シグナルに関する情報が追加されました。</p></li><li><p><a href=./#ports>アプリケーションのインストール - packages と ports</a> には、バイナリパッケージの管理に関する情報が追加されました。</p></li><li><p><a href=./#x11>X Window System</a> は、 XFree86™ 4.X 上で KDE や GNOME のような近代的なデスクトップテクノロジーを利用することに力点をおいて、 完全に書き直されました。</p></li><li><p><a href=./#boot>FreeBSD の起動のプロセス</a> が拡張されました。</p></li><li><p><a href=./#disks>ストレージ</a> は、 "ディスク" と "バックアップ" の 2 つの章に分かれていたものをまとめて書き直されました。私たちは、 この話題は 1 つの章にまとめて示した方が分かりやすいと感じています。 RAID (ハードウェアとソフトウェアの両方) に関する節も追加されました。</p></li><li><p><a href=./#serialcomms>シリアル通信</a> は FreeBSD 4.X/5.X 向けに一から再構成されました。</p></li><li><p><a href=./#ppp-and-slip>PPP と SLIP</a> は大幅に更新されました。</p></li><li><p><a href=./#advanced-networking>高度なネットワーク</a> に、多くの新しい節が追加されました。</p></li><li><p><a href=./#mail>電子メール</a> に、sendmail の設定についてより多くの情報が加えられました。</p></li><li><p><a href=./#linuxemu>Linux® バイナリ互換機能</a> には、Oracle® や Mathematica® のインストール情報が加えられました (訳注: 日本語版は作業中です)。</p></li><li><p>この第 2 版では、以下の新たな話題が扱われています。</p><div class=ulist><ul><li><p><a href=./#config-tuning>設定とチューニング</a>.</p></li><li><p><a href=./#multimedia>マルチメディア</a>.</p></li></ul></div></li></ul></div></div><div class=sect2><h3 id=preface-overview>この文書の構成<a class=anchor href=#preface-overview></a></h3><div class=paragraph><p>この文書は 5 部構成になっています。
第 1 部 <em>導入</em> では、FreeBSD のインストールと基本的な使い方を扱います。
各章は順に読むことを想定していますが、馴染み深い話題を扱った章は飛ばしてもよいでしょう。
第 2 部 <em>日々の生活</em> では、FreeBSD で良く使われる機能について説明します。
この章とそれに続く章は、順不同に読むことができます。
各章の始めにはその章が何を扱っていて、読者にどんな予備知識が期待されるかを簡潔に述べた概要がおかれています。
第 3 部 <em>システム管理</em> は、システム管理に関する話題を扱っています。
第 4 部 <em>ネットワーク通信</em> では、ネットワークおよびサーバに関する話題を扱っています。
第 5 部は参考情報からなる <em>付録</em> です。</p></div><div class=dlist><dl><dt class=hdlist1><em><a href=./#introduction>はじめに</a></em></dt><dd><p>新規ユーザに FreeBSD を紹介します。ここでは、FreeBSD プロジェクトの歴史、目標と開発モデルについて述べています。</p></dd><dt class=hdlist1><em><a href=./#bsdinstall>FreeBSD のインストール</a></em></dt><dd><p>bsdinstall を用いた FreeBSD 9.<em>x</em> 以降のシステムのインストール過程を一通りユーザに案内しています。</p></dd><dt class=hdlist1><em><a href=./#basics>UNIX の基礎知識</a></em></dt><dd><p>FreeBSD オペレーティングシステムの基本的なコマンドや機能を扱っています。 Linux® やその他の UNIX® 風のものに馴染んでいたら、 この章を飛ばしても構わないでしょう。</p></dd><dt class=hdlist1><em><a href=./#ports>アプリケーションのインストール - packages と ports</a></em></dt><dd><p>FreeBSD の革新的な "Ports Collection" および標準的なバイナリパッケージによるサードパーティアプリケーションのインストールについて説明しています。</p></dd><dt class=hdlist1><em><a href=./#x11>X Window System</a></em></dt><dd><p>X Window System 全般と、特に FreeBSD 上での X11 の利用について述べています。 また、KDE や GNOME のような一般的なデスクトップ環境にも触れています。</p></dd><dt class=hdlist1><em><a href=./#desktop>デスクトップアプリケーション</a></em></dt><dd><p>Web ブラウザや生産性向上ツールのような一般的なデスクトップアプリケーションをいくつか挙げ、 FreeBSD におけるインストール方法を説明しています。</p></dd><dt class=hdlist1><em><a href=./#multimedia>マルチメディア</a></em></dt><dd><p>システムを音声やビデオ再生に対応させるためにどう設定するかを説明します。 また、音声やビデオアプリケーションも例示しています。</p></dd><dt class=hdlist1><em><a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a></em></dt><dd><p>どのような場合に新たにカーネルを構成する必要があるかを説明し、 カスタムカーネルのコンフィグレーション、構築、 インストールについて詳しく説明しています。</p></dd><dt class=hdlist1><em><a href=./#printing>プリンタの利用</a></em></dt><dd><p>FreeBSD におけるプリンタの取り扱いを説明しています。たとえば、 バナーページ、プリンターの課金、初期設定といったことです。</p></dd><dt class=hdlist1><em><a href=./#linuxemu>Linux® バイナリ互換機能</a></em></dt><dd><p>FreeBSD の Linux® バイナリ互換機能を説明しています。また、 Oracle®, Mathematica® といった人気の高い Linux® アプリケーションのインストールを詳しく説明しています。</p></dd><dt class=hdlist1><em><a href=./#config-tuning>設定とチューニング</a></em></dt><dd><p>システム管理者が FreeBSD システムを調整して最適な性能を引き出すのに利用できるパラメータについて述べています。 また、FreeBSD で利用されている様な設定ファイルとそのありかも解説しています。</p></dd><dt class=hdlist1><em><a href=./#boot>FreeBSD の起動のプロセス</a></em></dt><dd><p>FreeBSD の起動プロセスを解説し、 このプロセスを設定オプションで制御する方法を説明しています。</p></dd><dt class=hdlist1><em><a href=./#security>セキュリティ</a></em></dt><dd><p>FreeBSD システムを安全に保つために役立つ Kerberos, IPsec および OpenSSH といった利用可能なさまざまなツールについて説明しています。</p></dd><dt class=hdlist1><em><a href=./#disks>ストレージ</a></em></dt><dd><p>FreeBSD でストレージメディアやファイルシステムをどう扱うかを説明しています。 対象は、物理ディスク、RAID アレイ、 光学およびテープメディア、メモリベースのディスク、 ネットワークファイルシステムなどです。</p></dd><dt class=hdlist1><em><a href=./#l10n>地域化 (localization) - i18n/L10n の利用と設定</a></em></dt><dd><p>FreeBSD を英語以外の言語で使う方法を説明しています。 システムとアプリケーション両方のレベルの地域化を扱っています。</p></dd><dt class=hdlist1><em><a href=./#updating-upgrading>FreeBSD のアップデートとアップグレード</a></em></dt><dd><p>FreeBSD-STABLE, FreeBSD-CURRENT と FreeBSD のリリースの違いを説明します。 どんなユーザにとって開発システムを追随するのが有用かを述べ、 その方法の概要をまとめています。 システムを最新のセキュリティリリースへアップデートする方法についても説明しています。</p></dd><dt class=hdlist1><em><a href=./#serialcomms>シリアル通信</a></em></dt><dd><p>FreeBSD システムに端末やモデムを、 ダイヤルインまたはダイヤルアウト用に接続する方法を説明しています。</p></dd><dt class=hdlist1><em><a href=./#ppp-and-slip>PPP と SLIP</a></em></dt><dd><p>FreeBSD で、PPP を使ってリモートシステムに接続する方法を説明しています。</p></dd><dt class=hdlist1><em><a href=./#mail>電子メール</a></em></dt><dd><p>電子メールサーバの構成要素をそれぞれ説明し、 最もよく使われているメールサーバソフトウェアである sendmail について、 単純な設定をとりあげています。</p></dd><dt class=hdlist1><em><a href=./#advanced-networking>高度なネットワーク</a></em></dt><dd><p>LAN 上の他のコンピュータとインターネット接続の共有、 高度なルーティングに関するトピックス、ワイヤレスネットワーク、 Bluetooth®, ATM, IPv6 等々、 ネットワークに関するさまざまな話題を取り扱っています。</p></dd><dt class=hdlist1><em><a href=./#mirrors>FreeBSD の入手方法</a></em></dt><dd><p>FreeBSD を収録した CDROM や DVD の様々な入手先や、FreeBSD をダウンロードしてインストールできるインターネット上のサイトを挙げています。</p></dd><dt class=hdlist1><em><a href=./#bibliography>参考図書</a></em></dt><dd><p>この文書は、 もっと詳しい説明が欲しくなるかもしれないさまざまな題目について触れています。 参考図書には、このハンドブックで参照している、 多くの素晴らしい本が挙げられています。</p></dd><dt class=hdlist1><em><a href=./#eresources>インターネット上のリソース</a></em></dt><dd><p>FreeBSD ユーザが FreeBSD について質問したり、 技術的な議論に参加できる、 多くの公開された場について説明しています。</p></dd><dt class=hdlist1><em><a href=./#pgpkeys>PGP 公開鍵</a></em></dt><dd><p>多くの FreeBSD 開発者の PGP fingerprint を載せています。</p></dd></dl></div></div><div class=sect2><h3 id=preface-conv>この文書で用いられている表記法<a class=anchor href=#preface-conv></a></h3><div class=paragraph><p>一貫して読みやすい文章を提供するために、 この文書全体では以下の表記法が用いられています。</p></div><div class=sect3><h4 id=preface-conv-typographic>書体による表記<a class=anchor href=#preface-conv-typographic></a></h4><div class=dlist><dl><dt class=hdlist1><em>イタリック体</em></dt><dd><p><em>イタリック体</em> のフォントは、ファイル名、URL, 強調表現、技術用語の最初の使用を表すのに使われています。</p></dd><dt class=hdlist1><code>等幅</code></dt><dd><p><code>等幅</code>フォントは、エラーメッセージ、 コマンド、環境変数、ports の名称、ホスト名、ユーザ名、 グループ名、デバイスの名称、変数、 コードの断片を表すのに使われています。</p></dd><dt class=hdlist1>太字</dt><dd><p><strong>太字</strong>のフォントは、アプリケーション、コマンド、キーを表すのに使われています。</p></dd></dl></div></div><div class=sect3><h4 id=preface-conv-commands>ユーザー入力<a class=anchor href=#preface-conv-commands></a></h4><div class=paragraph><p>文章の他の部分と区別するため、キーは<strong>太字</strong>で示されています。
同時に押すことを意図したキーの組み合わせは、キーの間に <code>+</code> を入れて表されます。
たとえば</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></span></p></div><div class=paragraph><p>は、ユーザーが <kbd>Ctrl</kbd>, <kbd>Alt</kbd> それから <kbd>Del</kbd> キーを同時に押すことを意図しています。</p></div><div class=paragraph><p>順に押すことを意図したキーは、カンマで区切って表されます。 たとえば</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>, <span class=keyseq><kbd>Ctrl</kbd>+<kbd>S</kbd></span></p></div><div class=paragraph><p>は、ユーザーが <kbd>Ctrl</kbd> キーと <kbd>X</kbd> キーを同時に押してから、 <kbd>Ctrl</kbd> キーと <kbd>S</kbd> キーを同時に押すことを意図しています。</p></div></div><div class=sect3><h4 id=preface-conv-examples>例<a class=anchor href=#preface-conv-examples></a></h4><div class=paragraph><p><span class=filename>C:\></span> で始まる例は、MS-DOS® コマンドを表しています。
特に注釈がなければ、それらのコマンドは最近の Microsoft® Windows® の "コマンドプロンプト" 環境でも実行できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>C:<span class=se>\&gt;</span> tools<span class=se>\f</span>dimage floppies<span class=se>\k</span>ern.flp A:</code></pre></div></div><div class=paragraph><p>\# で始まる例は、FreeBSD 上でスーパーユーザ権限で実行しなければならないコマンドを示しています。
そのコマンドを入力するには、<code>root</code> としてログインするか、通常のアカウントでログインして、スーパーユーザ権限を取得するために <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> を使います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=kern.flp of=/dev/fd0</span></code></pre></div></div><div class=paragraph><p>% で始まる例は、通常のユーザアカウントで実行するべきコマンドを示しています。
特に断りのない限り、環境変数の設定やその他のシェルコマンドには C シェルの文法が使われています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top</code></pre></div></div></div></div><div class=sect2><h3 id=preface-acknowledgements>謝辞<a class=anchor href=#preface-acknowledgements></a></h3><div class=paragraph><p>あなたが手にしている文書は、世界中の何百人もの人々の努力の賜物です。
誤字脱字の修正を送ったのか、文章を丸々投稿したのかによらず、すべての貢献が役に立ちました。</p></div><div class=paragraph><p>多くの会社が、著者らを雇用してフルタイムでこの文書に取り掛かれるようにしたり、出版費用を出したりして、この文書を作り上げるのを援助してくれました。
特に、BSDi (その後 <a href=http://www.windriver.com>Wind River Systems</a> に買収されました) は、フルタイムでこの文書の改善作業をするように FreeBSD ドキュメンテーションプロジェクトのメンバーを雇用し、それが 2000 年 3 月の最初の出版 (ISBN 1-57176-241-8) につながりました。
その後、Wind River Systems は、印刷出力の仕組みを整備し、章を追加するために著者を何名か追加で雇用してくれました。
この作業は、2001 年 11 月の第 2 版の出版 (ISBN 1-57176-303-1) に結実しました。
2003-2004 年には、ハンドブック第 3 版の出版準備のために <a href=http://www.freebsdmall.com>FreeBSD Mall, Inc</a> が貢献者を雇用してくれました。
第 3 版は 2 巻組となりました。
各巻は、The FreeBSD Handbook 3rd Edition Volume 1: User Guide (ISBN 1-57176-327-9) および The FreeBSD Handbook 3rd Edition Volume 2: Administrators Guide (ISBN 1-57176-328-7) として出版されています。</p></div></div></div></div><h1 id=getting-started class=sect0>Part I: 導入<a class=anchor href=#getting-started></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>ハンドブックの第 1 部はユーザと FreeBSD が初めての管理者向けです。各章の内容は以下のとおりです。</p></div><div class=ulist><ul><li><p>FreeBSD の紹介</p></li><li><p>インストールの手順の解説</p></li><li><p>UNIX® の基礎</p></li><li><p>FreeBSD で利用できる豊富なサードパーティ製のアプリケーションのインストール方法</p></li><li><p>UNIX® におけるウィンドウシステムの X、 およびプロダクティブなデスクトップ環境の設定の詳細の紹介</p></li></ul></div><div class=paragraph><p>頻繁にページを飛すことなく各章を前から後へとスムーズに読み進めるように、 後方への参照を極力抑えるようにしています。</p></div></div></div><div class=sect1><h2 id=introduction>Chapter 1. はじめに<a class=anchor href=#introduction></a></h2><div class=sectionbody><div class=sect2><h3 id=introduction-synopsis>1.1. この章では<a class=anchor href=#introduction-synopsis></a></h3><div class=paragraph><p>FreeBSD に興味を持っていただきありがとうございます! この章では FreeBSD の歴史、目標、開発モデルなど、 FreeBSD プロジェクトに関するさまざまな事柄を扱います。</p></div><div class=paragraph><p>この章に書かれている話題は、次のようなものです。</p></div><div class=ulist><ul><li><p>FreeBSD とその他のオペレーティングシステムとの違い</p></li><li><p>FreeBSD プロジェクトの歴史</p></li><li><p>FreeBSD プロジェクトの目標</p></li><li><p>FreeBSD オープンソース開発モデルの基本的な考え方</p></li><li><p>そして、"FreeBSD" という名前の由来について</p></li></ul></div></div><div class=sect2><h3 id=nutshell>1.2. FreeBSD へようこそ!<a class=anchor href=#nutshell></a></h3><div class=paragraph><p>FreeBSD は、標準に準拠した Unix-like なオープンソースのオペレーティングシステムで、 x86 (32 および 64 ビットの両方), ARM®, AArch64, RISC-V®, MIPS®, POWER®, PowerPC® および Sun UltraSPARC® コンピュータに対応しています。 FreeBSD は、プリエンプティブなマルチタスク、 メモリ保護、仮想メモリ、マルチユーザシステム、SMP 対応、 さまざまな言語やフレームワーク用のすべてのオープンソースの開発ツール、 X ウィンドウシステム、KDE や GNOME を中心としたデスクトップ機能といった、 今日では標準となっている機能をすべて提供しています。 注目すべき機能は以下の通りです。</p></div><div class=ulist><ul><li><p><em>自由なオープンソースライセンス</em>。 ソースコードを自由に変更し、配布することができます。 潜在的なライセンスの互換性の問題を避け、 コピーレフトライセンスに典型的な制限を課すことなく、 オープンソースプロジェクトおよびクローズな製品の両方に組み込むことが可能です。</p></li><li><p><em>堅固な TCP/IP ネットワーク</em> - FreeBSD は、 かってないほどの性能とスケーラビリティを兼ね備えた業界標準プロトコルを実装しています。 サーバおよびルータ/ファイアウォールルールの両方と相性が良く、 実際に多くの会社やベンダがまさにこの目的で採用しています。</p></li><li><p><em>完全に統合された OpenZFS への対応</em>。 これには root-on-ZFS, ZFS ブート環境、障害管理、 委任管理、jails への対応、FreeBSD 固有の文書、 そしてシステムのインストーラによる対応が含まれます。</p></li><li><p>Capsicum ケーパビリティおよびサンドボックスメカニズムに対する強制アクセスコントロールフレームワークによる <em>拡張されたセキュリティ機能</em>。</p></li><li><p>対応しているすべてのアーキテクチャで利用可能な <em>3 万を超えるコンパイル済みの packages</em>。 そして、あなた自身のカスタマイズされたソフトウェアの構築を容易にする Ports Collection。</p></li><li><p><em>ドキュメント</em> - システム管理からカーネル内部にまで渡る内容に関する、 さまざまな著者によるハンドブックやブックに加え、 <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> ページが用意されています。 ユーザ空間のデーモン、 ユーティリティおよびコンフィグレーションファイルだけではなく、 カーネルドライバの API (セクション 9) および個々のドライバ (セクション 4) も用意されています。</p></li><li><p><em>分かりやすく首尾一貫したリポジトリ構造とビルドシステム</em> - FreeBSD は、カーネルおよびユーザ空間の両方について、 すべての構成要素をひとつのリポジトリで管理しています。 統一されカスタマイズが容易なビルドシステムおよび綿密に考えられた開発プロセスが、 あなた自身の製品のビルドインフラストラクチャに FreeBSD を統合することを容易にします。</p></li><li><p><em>Unix の哲学に忠実であり続けます</em>。 ハードコードされたモノリシックな "オールインワン" デーモンより、 要素から構成することを好みます。</p></li><li><p>Linux との <em>バイナリ互換</em>。 仮想化の必要なしに多くの Linux バイナリを実行できます。</p></li></ul></div><div class=paragraph><p>FreeBSD はカリフォルニア大学バークレイ校の Computer Systems Research Group (CSRG) による 4.4BSD-Lite リリースを基にしており、 BSD システムの開発の優れた伝統を守り続けています。 CSRG による素晴らしい活動に加えて、 FreeBSD プロジェクトは何千時間もの時間を注ぎ込んで、 実際の使用の場において最大の性能と信頼性を発揮するためにシステムのチューニングをおこなっています。 FreeBSD は、商用のオペレーティングシステムと同等の性能、信頼性を、 他では実現されていない数多くの最新の機能と共に提供しています。</p></div><div class=sect3><h4 id=os-overview>1.2.1. FreeBSD で何ができるの?<a class=anchor href=#os-overview></a></h4><div class=paragraph><p>あなたの思いつく限りのアプリケーションは、何でも FreeBSD で実行できます。ソフトウェア開発からファクトリオートメーション、 在庫制御から遠く離れた人工衛星のアンテナの方向調整まで; 商用 UNIX® 製品でできることは、FreeBSD でも十分にできるのです! また、FreeBSD は世界中の研究センターや大学によって開発される文字通り何千もの高品質で、 たいていはほとんど無料で利用できるアプリケーションによる恩恵を得ることができます。</p></div><div class=paragraph><p>FreeBSD のソースコードは自由に提供されているので、 システムも特別なアプリケーションやプロジェクトに合わせて、 いくらでもカスタマイズすることができます。 これは有名な商業ベンダから出ているほとんどのオペレーティング システムでは不可能なことです。以下に現在 FreeBSD を 使っている人々のアプリケーションの例をいくつか上げます:</p></div><div class=ulist><ul><li><p><em>インターネットサービス:</em> FreeBSD に組み込まれている 頑強な TCP/IP ネットワーキング機能は次のようなさまざまな インターネットサービスの理想的なプラットフォームになります:</p><div class=ulist><ul><li><p>ウェブサーバ</p></li><li><p>IPv4 および IPv6 ルーティング</p></li><li><p>ファイアウォールと NAT ("IP マスカレード") ゲートウェイ</p></li><li><p>FTP サーバ</p></li><li><p>メールサーバ</p></li><li><p>さらにいろいろ…​</p></li></ul></div></li><li><p><em>教育:</em> あなたは、計算機科学または関連分野の工学を専攻する学生さんですか? オペレーティングシステムやコンピュータアーキテクチャ、 ネットワークについて学習するなら、 実際に FreeBSD のソースコードを読んで、 それがどのように動作するのかを学ぶのが一番よい方法です。 また、無料で利用できる CAD や数学、 グラフィックデザインのパッケージがいくつもあるので、 コンピュータに関わる主要な目的が、 <em>他</em> のことをすることにある方にも、 大いに役立ちます。</p></li><li><p><em>研究:</em> システム全体のソースコードが利用できるため、 FreeBSD はオペレーティングシステムの研究だけでなく、 計算機科学の他の部門においても優れたプラットフォームです。 自由に利用できる FreeBSD の特長は、オープンフォーラムで 議論される特別なライセンスの同意や制限について心配することなく、 離れたグループでもアイディアや開発の共有による共同研究を可能にします。</p></li><li><p><em>ネットワーキング:</em> 新しいルータが必要? ネームサーバ (DNS) は? 内部のネットワークを人々から守るファイアウォールは? FreeBSD はすみに眠っている使われていない PC を簡単に 洗練されたパケットフィルタリング機能を持つ高級なルータに 変えることができます。</p></li><li><p><em>組み込み:</em> FreeBSD は、 組み込みシステムを構築する優れたプラットフォームとなります。
ARM®, MIPS® および PowerPC® プラットフォームへのサポートとともに、強固なネットワークスタック、最新の機能および 寛容な<a href=https://docs.freebsd.org/ja/books/faq/#bsd-license-restrictions>BSD ライセンス</a> により、FreeBSD は、組み込みルータ、ファイアウォールおよび他のデバイスを構築する優れた基盤となります。</p></li><li><p><em>デスクトップ:</em> FreeBSD は、自由に利用できる X11 サーバを使うことによって、 安価なデスクトップとなります。 FreeBSD では、標準的な GNOME および KDE グラフィカルユーザインタフェースを含む、 数多くのオープンソースのデスクトップ環境を選択できます。 FreeBSD は、 中央のサーバから"ディスクレス"でもブート可能であり、 個々のワークステーションを安価で、 容易に管理することさえ可能にします。</p></li><li><p><em>ソフトウェア開発:</em> 基本的な FreeBSD システムには、完全な C/C++ コンパイラやデバッガスイートを含む完全な開発ツールがついてきます。 他の多くの言語へのサポートも ports および package コレクションから利用できます。</p></li></ul></div><div class=paragraph><p>FreeBSD は、無料でダウンロードできます。 また、CD-ROM または DVD でも入手可能です。 詳しくは <a href=./#mirrors>FreeBSD の入手方法</a> をご覧ください。</p></div></div><div class=sect3><h4 id=introduction-nutshell-users>1.2.2. FreeBSD はどこに使われていますか?<a class=anchor href=#introduction-nutshell-users></a></h4><div class=paragraph><p>FreeBSD は、ウェブサービスの能力で知られています。 FreeBSD が利用されている代表的なサイトには <a href=https://news.ycombinator.com/>Hacker News</a>, <a href=http://www.netcraft.com/>Netcraft</a>, <a href=http://www.163.com/>NetEase</a>, <a href=https://signup.netflix.com/openconnect>Netflix</a>, <a href=http://www.sina.com/>Sina</a>, <a href=http://www.sony.co.jp/>Sony Japan</a>, <a href=http://www.rambler.ru/>Rambler</a>, <a href=http://www.yahoo.com/>Yahoo!</a> および <a href=http://www.yandex.ru/>Yandex</a> があります。</p></div><div class=paragraph><p>FreeBSD は、 先進的な機能、高いセキュリティ、および定期的なリリースサイクル、 そして寛容なライセンスにより、 多くの商用およびオープンソースのアプライアンス、 デバイスおよび製品を構築するプラットフォームとして利用されています。 世界最大規模の多くの IT 会社が FreeBSD を使っています。</p></div><div class=ulist><ul><li><p><a href=http://www.apache.org/>Apache</a> - Apache ソフトウェア財団は、 1.4 百万回を超えるコミットというおそらく世界で最も大規模な SVN リポジトリを含む、数多くの公式のインフラストラクチャで FreeBSD を使っています。</p></li><li><p><a href=http://www.apple.com/>Apple</a> - Apple により提供されている最近のオペレーションシステムは、FreeBSD からプロセスモデル、ネットワークスタック、仮想ファイルシステム、ライブラリ、マニュアルページ、そしてコマンドラインユーティリティについてのコードを取り入れています。</p></li><li><p><a href=http://www.cisco.com/>Cisco</a> - IronPort ネットワークセキュリティおよびアンチスパムアプライアンスは、 改造された FreeBSD カーネルで動いています。</p></li><li><p><a href=http://www.citrix.com/>Citrix</a> - NetScaler の一連のセキュリティアプライアンスは、 FreeBSD シェルとともに 4-7 レイヤのロードバランス、 コンテントキャシュ、アプリケーションファイアウォール、 セキュリティ VPN およびモバイルクライド・ネットワークアクセスを提供します。</p></li><li><p><a href=https://www.emc.com/isilon>Dell EMC Isilon</a> - Isilon 社のエンタープライズストレージアプライアンスは、FreeBSD ベースです。 寛大な FreeBSD ライセンスのおかげで、Isilon は、 彼らの知的財産物をカーネルに統合することができるため、 オペレーティングシステムではなく、 製品そのものに焦点を当てた開発が可能となっています。</p></li><li><p><a href=http://www.quest.com/KACE>Quest KACE</a> - KACE システム管理アプライアンスでは、 FreeBSD が用いられています。信頼性、 スケーラビリティおよび継続的な開発をサポートしているコミュニティが評価され採用されています。</p></li><li><p><a href=http://www.ixsystems.com/>iXsystems</a> - 統合ストレージアプライアンスの TrueNAS シリーズは FreeBSD ベースです。</p></li><li><p><a href=http://www.juniper.net/>Juniper</a> - Juniper のすべてのネットワークギア (ルータ、スイッチ、セキュリティおよびネットワークアプライアンス) を動かしている JunOS オペレーティングシステムは、 FreeBSD ベースです。 Juniper は、FreeBSD プロジェクトと商用製品を提供しているベンダとの間で協力関係が成功している数多くのベンダのひとつです。 将来 FreeBSD の新しい機能を JunOS へと統合する際の複雑さを減らすため、 Juniper で作成された改良点は、FreeBSD に取り込まれています。</p></li><li><p><a href=http://www.mcafee.com/>McAfee</a> - Sidewinder などの McAfee エンタープライズファイアウォール製品のベースである SecurOS は FreeBSD ベースです。</p></li><li><p><a href=http://www.netapp.com/>NetApp</a> - ストレージアプライアンスの Data ONTAP GX シリーズは、FreeBSD ベースです。 NetApp は、新しい BSD ライセンスのハイパーバイザである bhyve などの数多くの機能を FreeBSD プロジェクトに還元しています。</p></li><li><p><a href=http://www.netflix.com/>Netflix</a> - Netflix が顧客へのストリームムービーに使用している OpenConnect アプライアンスは、FreeBSD ベースです。 Netflix は、コードベースに対し多大な貢献を行っており、 FreeBSD のメインラインからの差分がゼロになるように作業を行っています。 Netflix OpenConnect アプライアンスは、 北米の全インターネットトラフィックの 32% の配送を受け持っています。</p></li><li><p><a href=http://www.sandvine.com/>Sandvine</a> - Sandvine は、 ハイパフォーマンスでリアルタイムのネットワークプロセッシングプラットフォームのベースに FreeBSD を使用しています。このプラットフォームは、 彼らのインテリジェントネットワークポリシーコントロール製品を構成しています。</p></li><li><p><a href=http://www.sony.com/>Sony</a> - PlayStation Vita, PlayStation 4 および PlayStation 5 のゲームコンソールは、 FreeBSD の改良版が動いています。</p></li><li><p><a href=http://www.sophos.com/>Sophos</a> - Sophos Email アプライアンス製品は、強化された FreeBSD がベースです。 インバウンドメールに対してスパムやウィルススキャンを行う一方で、 アウトバウンドメールがマルウェアではないか、また、 機密情報がアクシデントで漏洩してしまわないようにモニタします。</p></li><li><p><a href=http://www.spectralogic.com/>Spectra Logic</a> - アーカイブグレードストレージアプライアンスの nTier シリーズは、FreeBSD および OpenZFS が動いています。</p></li><li><p><a href=https://www.stormshield.com>Stormshield</a> - Stormshield ネットワークセキュリティアプライアンスは、 強化された FreeBSD がベースです。 BSD ライセンスが、彼らの知的財産のシステムへの統合を可能にする一方で、 コミュニティに非常に多くの興味深い開発結果をもたらしてくれます。</p></li><li><p><a href=http://www.weather.com/>The Weather Channel</a> - 各ローカルケーブルプロバイダのヘッドエンドにインストールされていて、 ローカルの天気予報をケーブル TV ネットワークプログラムに送る IntelliStar アプライアンスでは FreeBSD が動いています。</p></li><li><p><a href=http://www.verisign.com/>Verisign</a> - Verisign は .com および .net ルートドメインレジストリおよび関連する DNS インフラストラクチャの運用に責任を持っています。 彼らのインフラストラクチャに一般的な障害点がないように、FreeBSD を含むさまざまなネットワークオペレーティングシステムに信頼を寄せています。</p></li><li><p><a href=http://www.voxer.com/>Voxer</a> - Voxer のモバイルボイスメッセージのプラットフォームでは、 ZFS が FreeBSD 上で動いています。 Voxer は、Solaris から派生したオペレーティングシステムから、 FreeBSD へと移行しました。優れた文書、 幅広く活動的なコミュニティ、 そして開発者にとって好意的な環境がその理由です。 ZFS および DTrace といった決定的な機能に加え、 FreeBSD では、 ZFS が TRIM に対応しています。</p></li><li><p><a href=https://fudosecurity.com/en/>Fudo セキュリティ</a> - FUDO セキュリティアプライアンスは、 エンタープライズおよびシステムの管理者に対し、 モニタ、コントロール、レコードおよび audit コントラクタを提供します。 ZFS, GELI, Capsicum, HAST および auditdistd といった FreeBSD の最良なセキュリティ機能がベースとなっています。</p></li></ul></div><div class=paragraph><p>また、FreeBSD は関連したオープンソースプロジェクトを数多く生み出しています。</p></div><div class=ulist><ul><li><p><a href=http://bsdrp.net/>BSD Router</a> - 広く使われているエンタープライズルータの置き換えとなるような FreeBSD ベースのルータで、標準的な PC ハードウェアで動作するように設計されています。</p></li><li><p><a href=https://www.truenas.com/>TrueNAS</a> は、ネットワークアタッチトストレージ (NAS) ソフトウェアです。
データの共有およびランサムウェアやマルウェアといった現代の脅威からデータを保護します。
TrueNAS を使うことで、ユーザおよびクライアントデバイスは、仮想化および共有プロトコルを通して共有データに容易にアクセスできます。</p></li><li><p><a href=https://ghostbsd.org/>GhostBSD</a> は、FreeBSD から派生しており、GTK 環境を使用して美しい見た目や使い勝手の良さを現代の BSD プラットフォームに実現し、自然でネイティブな UNIX® 環境を提供します。</p></li><li><p><a href=http://mfsbsd.vx.sk/>mfsBSD</a> - メモリから完全に実行可能な FreeBSD システムのイメージを構築するためのツールキットです。</p></li><li><p><a href=https://xigmanas.com/>XigmaNAS</a> - PHP によるウェブインタフェースを搭載した FreeBSD ベースのファイルサーバのディストリビューションです。</p></li><li><p><a href=http://www.opnsense.org/>OPNSense</a> は、オープンソースの使いやすく構築が簡単な FreeBSD ベースのファイアウォールおよびルータのプラットフォームです。 OPNsense は、 高価な商用のファイアウォールや標準で利用可能なほとんどの機能を持っています。 オープンで検証可能なソースと共に、 商品が提供している豊富な機能のセットを提供します。</p></li><li><p><a href=https://www.midnightbsd.org>MidnightBSD</a> は、BSD から派生したオペレーティングシステムで、デスクトップユーザを念頭において開発されています。
このオペレーティングシステムには、メール、ウェブブラウザ、ワードプロセッサ、ゲームといった、日々の生活で必要と思われるすべてのソフトウェアが含まれています。</p></li><li><p><a href=https://nomadbsd.org>NomadBSD</a> は、FreeBSD ベースの USB フラッシュドライブのための永続的な live システムです。
ハードウェアを自動的に認識してセットアップを行い、すぐにデスクトップシステムとして使えるように設定します。
データリカバリ、教育および FreeBSD のハードウェア互換性の試験にも使用できます。</p></li><li><p><a href=http://www.pfsense.org/>pfSense</a> - 数多くの機能および拡張 IPv6 サポートを持つ FreeBSD ベースのファイアウォールディストリビューションです。</p></li><li><p><a href=http://zrouter.org/>ZRouter</a> - FreeBSD ベースの組み込みデバイス用のオープンソースのファームウェアです。 いつでも購入できるようなルータ上のプロプリエタリのファームウェアの置き換えとなるように設計されています。</p></li></ul></div><div class=paragraph><p>FreeBSD Foundation のウェブサイトでは、<a href=https://www.freebsdfoundation.org/about/testimonials/>FreeBSD を製品やサービスのベースに利用している会社の声</a> が紹介されています。
Wikipedia にも <a href=http://en.wikipedia.org/wiki/List_of_products_based_on_FreeBSD>FreeBSD ベースの製品のリスト</a> がまとめられています。</p></div></div></div><div class=sect2><h3 id=history>1.3. FreeBSD プロジェクトについて<a class=anchor href=#history></a></h3><div class=paragraph><p>以下の節では簡単な歴史やプロジェクトの目標、 開発モデルなど、普段は表にでない話題を提供しています。</p></div><div class=sect3><h4 id=intro-history>1.3.1. FreeBSD 小史<a class=anchor href=#intro-history></a></h4><div class=paragraph><p>FreeBSD プロジェクトは 1993 年の始めに Unofficial 386BSD Patchkit の最後の 3 人のまとめ役によって、部分的に patchkit から派生する形で開始されました。ここでの 3 人のまとめ役というのは、Nate Williams, Rod Grimes と、 Jordan Hubbard です。</p></div><div class=paragraph><p>このプロジェクトのもともとの目標は、patchkit という仕組みではもう十分に解決できなくなってしまった 386BSD の数多くの問題を修正するための、386BSD の暫定的なスナップショットを作成することでした。 こういった経緯を経ているので、 このプロジェクトの初期の頃の名前は 386BSD 0.5 や 386BSD 暫定版 (Interim) でした。</p></div><div class=paragraph><p>386BSD は、Bill Jolitz が (訳注: バークレイ Net/2 テープを基に) 作成したオペレーティングシステムです。当時の 386BSD は、ほぼ一年にわたって放っておかれていた (訳注: 作者がバグの報告を受けても何もしなかった) というひどい状況に苦しんでいました。 作者の代わりに問題を修正し続けていた patchkit は日を追うごとに不快なまでに膨張してしまっていました。 このような状況に対して、彼らは暫定的な "クリーンアップ" スナップショットを作成することで Bill を手助けしようと決めました。しかし、 この計画は唐突に終了してしまいました。Bill Jolitz が、 このプロジェクトに対する受け入れ支持を取り下げることを突然決意し、 なおかつこのプロジェクトの代わりに何をするのかを一切言明しなかったのです。</p></div><div class=paragraph><p>たとえ Bill が支持してくれないとしても、 彼ら 3 人の目標には依然としてやる価値があると考えていたため、 David Greenman が考案した名称 "FreeBSD" をプロジェクトの名前に採用し、新たなスタートを切りました。 この時点でのプロジェクトの初期目標は、すでにこのシステム (訳注: 386BSD + Patchkit) を使っていた利用者たちと相談して決められました。 プロジェクトが実現に向けて軌道に乗ってきたことが明確になった時点で、 Jordan は Walnut Creek CDROM 社に連絡してみました。CD-ROM を使って FreeBSD を配布することによって、 インターネットに容易に接続できない多くの人々が FreeBSD を簡単に入手できるようになると考えたからです。Walnut Creek CDROM 社は FreeBSD を CD で配布するというアイデアを採用してくれたばかりか、 作業するためのマシンと高速なインターネット回線をプロジェクトに提供してくれました。 当時は海のものとも山のものともわからなかったこのプロジェクトに対して、Walnut Creek CDROM 社が信じられないほどの信頼を寄せてくれたおかげで、 FreeBSD は短期間のうちにここまで大きく成長したのです。</p></div><div class=paragraph><p>CD-ROM による最初の配布 (そしてネットでの、 ベータ版ではない最初の一般向け配布) は FreeBSD 1.0 で、1993 年 12 月に公開されました。これはカリフォルニア大学バークレイ校の 4.3BSD-Lite ("Net/2") を基とし、386BSD や Free Software Foundation からも多くの部分を取り入れたものです。 これは初めて公開したものとしては十分に成功しました。続けて 1994 年 5 月に FreeBSD 1.1 を公開し、 非常に大きな成功を収めました。</p></div><div class=paragraph><p>この時期、 あまり予想していなかった嵐が遠くから接近してきていました。 バークレイ Net/2 テープの法的な位置づけについて、Novell 社とカリフォルニア大学バークレイ校との間の長期にわたる 法廷論争において和解が成立したのです。和解の内容は、Net/2 のかなりの部分が "権利つき (encumbered)" コードであり、それは Novell 社の所有物である、 というバークレイ校側が譲歩したものでした。なお、Novell 社はこれらの権利を裁判が始まる少し前に AT&amp;T 社から買収していました。 和解における譲歩の見返りにバークレイ校が得たのは、 4.4BSD-Lite が最終的に発表された時点で、 4.4BSD-Lite は権利つきではないと公式に宣言されること、 そしてすべての既存の Net/2 の利用者が 4.4BSD-Lite の利用へと移行することが強く奨励されること、という Novell 社からの "ありがたき天からの恵み" でした (訳注: 4.4BSD-Lite はその後 Novell 社のチェックを受けてから公開された)。FreeBSD も Net/2 を利用していましたから、1994 年の 7 月の終わりまでに Net/2 ベースの FreeBSD の出荷を停止するように言われました。ただし、 このときの合意によって、 私たちは締め切りまでに一回だけ最後の公開をすることを許されました。 そしてそれは FreeBSD 1.1.5.1 となりました。</p></div><div class=paragraph><p>それから FreeBSD プロジェクトは、まっさらでかなり不完全な 4.4BSD-Lite を基に、文字どおり一から再度作り直すという、 難しくて大変な作業の準備を始めました。"Lite" バージョンは、部分的には本当に軽くて、中身がなかったのです。 起動し、 動作できるシステムを実際に作り上げるために必要となるプログラムコードのかなりの部分がバークレイ校の CSRG (訳注: BSDを作っているグループ) によって (いろいろな法的要求のせいで) 削除されてしまっていたということと、4.4BSD の Intel アーキテクチャ対応が元々かなり不完全であったということがその理由です。 この移行作業は結局 1994 年の 11 月までかかりました。 そして 12 月に FreeBSD 2.0 として公開されました。これは、 かなり粗削りなところが残っていたにもかかわらず、 かなりの成功を収めました。そしてその後に、より信頼性が高く、 そしてインストールが簡単になった FreeBSD 2.0.5 が 1995 年の 6 月に公開されました。</p></div><div class=paragraph><p>これ以降、FreeBSD の安定性、速さや機能は改善され、 リリースが行われてきました。</p></div><div class=paragraph><p>長期的な開発プロジェクトは 15.0-CURRENT 開発ブランチ (main) で続けられ、 15.0 のスナップショットリリースは、開発の進行状況に応じて <a href=https://download.freebsd.org/snapshots/>スナップショットサーバ</a> より継続して入手できます。</p></div></div><div class=sect3><h4 id=goals>1.3.2. FreeBSD プロジェクトの目標<a class=anchor href=#goals></a></h4><div class=paragraph><p>FreeBSD プロジェクトの目的は、いかなる用途にも使用でき、 何ら制限のないソフトウェアを供給することです。 私たちの多くは、 コード (そしてプロジェクト) に対してかなりの投資をしてきており、 これからも多少の無駄はあっても投資を続けて行くつもりです。ただ、 他の人達にも同じような負担をするように主張しているわけではありません。 FreeBSD に興味を持っている一人の残らず全ての人々に、 目的を限定しないでコードを提供すること。これが、 私たちの最初のそして最大の "任務" であると信じています。そうすれば、コードは可能な限り広く使われ、 最大の恩恵をもたらすことができるでしょう。これが、 私たちが熱烈に支持しているフリーソフトウェアの最も基本的な目的であると、 私は信じています。</p></div><div class=paragraph><p>私たちのソースツリーに含まれるソースのうち、 GNU 一般公有使用許諾 (GPL) または GNU ライブラリ一般公有使用許諾 (LGPL) に従っているものについては、多少制限が課せられています。ただし、 ソースコードへのアクセスの保証という、 一般の制限とはいわば逆の制限 (訳注1) です。 GPL ソフトウェアの商利用には、そのライセンスにある 複雑な側面が影響してくることがあります。 ですから私たちは、そうすることが合理的であると判断されたときには、 より制限の少ない、BSD ライセンスを採用しているソフトウェアを選択するようにしています。</p></div><div class=paragraph><p>(訳注1) GPL では、「ソースコードを実際に受け取るか、 あるいは、希望しさえすればそれを入手することが可能であること」 を求めています。</p></div></div><div class=sect3><h4 id=development>1.3.3. FreeBSD の開発モデル<a class=anchor href=#development></a></h4><div class=paragraph><p>FreeBSD は <a href=https://docs.freebsd.org/en/books/dev-model/>非常に開かれた、柔軟性のあるプロセス</a> により開発されています。
<a href=https://docs.freebsd.org/en/articles/contributors/>貢献者リスト</a> を見ていただければわかるとおり、FreeBSD は文字通り世界中の何千という人々の努力によって開発されています。
FreeBSD の開発環境は、この何千という開発者がインターネット経由で共同作業できるようになっているのです。
新しいボランティアはいつでも大歓迎です。
また、より密接に関わりたいと考える方は <a href=https://docs.freebsd.org/ja/articles/contributing/>FreeBSD への貢献</a> という文書をご覧ください。</p></div><div class=paragraph><p>あと、FreeBSD プロジェクトとその開発プロセスについて、 どなたにも知っていていただきたいのは以下のようなことです。</p></div><div class=dlist><dl><dt class=hdlist1>Git リポジトリ<a id=development-cvs-repository></a></dt><dd><p>長年にわたり FreeBSD のソースツリーは、 ソースコード管理用のフリーソフトウェアである <a href=http://www.nongnu.org/cvs/>CVS</a> (Concurrent Versions System) によってメンテナンスされてきました。
2008 年 6 月、プロジェクトはソースコード管理のシステムを <a href=https://subversion.apache.org>SVN</a> (Subversion) に移行しました。
ソースツリーの急速な増加や、これまでに蓄積された膨大な量の履歴によって、CVS の持つ技術的な限界が明かになってきたためです。
ドキュメンテーションプロジェクトと Ports Collection リポジトリも、それぞれ 2012 年 5 月と 7 月に CVS から SVN へと移行しました。
そして 2020年 12 月、プロジェクトは <a href=https://www.freebsd.org/status/report-2020-10-2020-12.html#Git-Migration-Working-Group>ソースおよびドキュメンテーションのリポジトリ</a> を <a href=https://git-scm.com/>Git</a> へ移行し、2021 年 4 月に <a href=https://www.freebsd.org/status/report-2021-04-2021-06/#_git_migration_working_group>Ports</a> を移行しました。
FreeBSD <code>src/</code> リポジトリを取得するための情報は <a href=./#synching>ソースコードの入手</a> の章を、 FreeBSD Ports Collection を取得するための詳細については <a href=./#ports-using>Ports Collection の利用</a> の章をご覧ください。</p></dd><dt class=hdlist1>ソースツリー管理者<a id=development-committers></a></dt><dd><p><em>コミッター (committers)</em> は Git リポジトリへの <em>push 権限</em> を持っている人、FreeBSD のソースに変更を加えることができる人です (リポジトリに変更を加えるには、ソースをコントロールする <code>commit</code> というコマンドを使うので、これらの人々は英語では "committers" と呼ばれます)。
もしバグを見つけたのであれば、<a href=https://bugs.FreeBSD.org/submit/>障害報告データベース</a> に提出してください。
FreeBSD メーリングリスト、IRC チャネルまたはフォーラムは、その問題がバグかどうかを確認する助けとなりますので、障害報告を提出する前に、これらを使って確認してください。</p></dd><dt class=hdlist1>FreeBSD コアチーム<a id=development-core></a></dt><dd><p><em>FreeBSD コアチーム</em> は FreeBSD プロジェクトが会社だとすると取締役会にあたるものです。
コアチームとして一番重要な役割は FreeBSD プロジェクトが全体としてよい方向に向かっていることを確認することです。
責任感あふれる開発者を上記のソースツリー管理者として招くこと、 また仕事上の都合などでコアチームをやめた人たちの後任を見つけることもコアチームの役割です。
現在のコアチームは FreeBSD 開発者 (committer) の中から 2022 年 5 月に選挙によって選出されました。
コアチームを選出するための選挙は、2 年ごとに行なわれています。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>忘れてほしくないのは、多くの開発者同様に、 コアチームのほとんどは FreeBSD に対してボランティアの立場であり、 FreeBSD プロジェクトからは何ら金銭的な支援を受けていない、 ということです。ですから、 ここでの"責任"は "保証されたサポート"ではありません。 そういう意味で、上記の"取締役会" という例えはあまりよくないかもしれません。むしろ、FreeBSD のために人生を棒に振ってしまった人の集まりといった方が正しいかも…​。</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>The FreeBSD Foundation<a id=development-foundation></a></dt><dd><p>The <a href=https://freebsdfoundation.org>FreeBSD Foundation</a> は、FreeBSD プロジェクトおよびコミュニティを全世界的にサポートしたり促進することを目的としたアメリカ合衆国における 501(c)(3) に認定された非営利団体です。
この Foundation は、ソフトウェア開発に対するプロジェクトの助成を通じて資金を提供したり、緊急の事態に対する迅速な対応や新しい特徴や機能の実装に対して、スタッフを提供します。
FreeBSD のインフラストラクチャの改善および維持する目的でハードウェアを購入したり、テストカバレッジ、継続的インテグレーションおよび自動化の改善のためにスタッフを雇用しています。
世界中で開催されている技術的な会議やイベントにおいて、FreeBSD をプロモーションすることで FreeBSD を宣伝しています。
また、ワークショップ、教育的な教材やプレゼンテーションを提供して、より多くのユーザや FreeBSD の貢献者をリクルートしています。
さらに、契約の締結、ライセンス契約、およびその他の法的主体必要となる協定において FreeBSD プロジェクトを代表しています。</p></dd><dt class=hdlist1>その他のコントリビュータ</dt><dd><p>最後になりますが、 もっとも重要で多数をしめる開発者はフィードバックやバグフィクスをどんどん送ってくれるユーザ自身です。
FreeBSD のベースシステムの開発に関わっていきたいという人は、 議論の場である <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>FreeBSD technical discussions メーリングリスト</a> に参加するとよいでしょう。
サードパーティ製のアプリケーションの移植に関わる議論は、 <a href=https://lists.FreeBSD.org/subscription/freebsd-ports>FreeBSD ports メーリングリスト</a> で行われています。
FreeBSD のメーリングリストに関する詳細は、 <a href=./#eresources>インターネット上のリソース</a> をご覧ください。</p><div class=paragraph><p><a href=https://docs.freebsd.org/en/articles/contributors/>FreeBSD への貢献者リスト</a> は日に日に長くなっています。
あなたも今日、<a href=https://docs.freebsd.org/ja/articles/contributing/>FreeBSD へ何か送ることからはじめてみませんか</a>?
もちろん、コードを書くほかにもいろいろな方法があります!</p></div></dd></dl></div><div class=paragraph><p>ひとことで言うと、FreeBSD の開発組織はゆるやかな同心円状になっています。
ともすると中央集権的に見えがちなこの組織は、 FreeBSD の <em>ユーザ</em> がきちんと管理されたコードベースを 容易に追いかけられるようにデザインされているもので、 貢献したいという人を締め出す意図は全くありません!
私たちの目標は安定したオペレーティングシステムと 簡単にインストールして使うことのできる <a href=./#ports>アプリケーション</a>を提供することです。
この方法は、それを達成するために非常にうまくはたらきます。</p></div><div class=paragraph><p>これから FreeBSD の開発にたずさわろうという人に、 私たちが望むことはただ一つです。 FreeBSD の成功を継続的なものにするために、 現在の開発者と同じような情熱を持って接してください!</p></div></div><div class=sect3><h4 id=third-party-programs>1.3.4. サードパーティ製プログラム<a class=anchor href=#third-party-programs></a></h4><div class=paragraph><p>FreeBSD では基本配布セットに加え、 移植されたソフトウェア集として数千の人気の高いプログラムを提供しています。
ports には HTTP サーバから、ゲーム、言語、 エディタまでありとあらゆるものが含まれています。
36000 以上の ports (移植ソフトウェア) が存在します。
Ports Collection 全体でも 3 GB 程度にしかなりません。
ports をコンパイルするには、 インストールしたいと思っているプログラムのディレクトリに移動し、 <code>make install</code> とすると、 あとはすべてシステムがやってくれます。
どの ports もオリジナルの配布セットを動的に取ってくるので、 ディスクは構築したいと思っている ports の分だけを準備しておけば十分です。
ほとんどの ports は、すでにコンパイルされた状態で "package" として提供されており、ソースコードからコンパイルしたくない場合、これを使うと (<code>pkg install</code> というコマンドで) 簡単にインストールできます。
package と ports に関する詳細は、 <a href=./#ports>アプリケーションのインストール - packages と ports</a> をご覧ください。</p></div></div><div class=sect3><h4 id=_ドキュメント>1.3.5. ドキュメント<a class=anchor href=#_ドキュメント></a></h4><div class=paragraph><p>サポートが行われているすべての FreeBSD では、システムのセットアップ時にインストーラを使って、ドキュメントを <span class=filename>/usr/local/share/doc/freebsd</span> 以下にインストールできます。
システムをインストールした後は、package を使ってドキュメントをインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install en-freebsd-doc</span></code></pre></div></div><div class=paragraph><p>各言語に翻訳されたドキュメントをインストールするには、"en" の部分を使用する言語のコードに置き換えてください。
翻訳されたドキュメントの中には、古い情報のままの文書があり、現在では正確でなかったり関係ない内容が含まれている可能性があることに注意してください。
ローカルにインストールされたドキュメントは、HTML ブラウザを使って以下の URL から参照できます。</p></div><div class=dlist><dl><dt class=hdlist1>FreeBSD ハンドブック (英文オリジナル)</dt><dd><p><span class=filename><a href=file:///usr/local/share/doc/freebsd/en/books/handbook/book.html>/usr/local/share/doc/freebsd/en/books/handbook/book.html</a></span></p></dd><dt class=hdlist1>FreeBSD に関する FAQ (英文オリジナル)</dt><dd><p><span class=filename><a href=file://localhost/usr/local/share/doc/freebsd/en/books/faq/book.html>/usr/local/share/doc/freebsd/en/books/faq/book.html</a></span></p></dd></dl></div><div class=paragraph><p>最新版の文書は常に <a href=https://docs.FreeBSD.org/>https://docs.FreeBSD.org/</a> にありますので、こちらも参照してください。</p></div></div></div></div></div><div class=sect1><h2 id=bsdinstall>Chapter 2. FreeBSD のインストール<a class=anchor href=#bsdinstall></a></h2><div class=sectionbody><div class=sect2><h3 id=bsdinstall-synopsis>2.1. この章では<a class=anchor href=#bsdinstall-synopsis></a></h3><div class=paragraph><p>FreeBSD は、amd64, ARM®, RISC-V®, および PowerPC® 等のさまざまなアーキテクチャに対応しています。</p></div><div class=paragraph><p>インストールまたは直接 FreeBSD を実行するためのイメージは、アーキテクチャおよびプラットフォームごとに <a href=https://www.freebsd.org/ja/where/>ダウンロード</a> できます。</p></div><div class=paragraph><p>利用できるイメージのタイプは以下の通りです。</p></div><div class=ulist><ul><li><p><code>qcow2</code>, <code>vmdk</code>, <code>vhd</code> および raw デバイスイメージといった仮想マシンのディスクイメージ。これらはインストール用のイメージではなく、FreeBSD がすでにインストールされたインスタンスで、すぐに起動して、インストール後の作業を行うことができます。仮想マシンのイメージは、クラウド環境でも使われます。</p></li><li><p>Raspberry Pi のような組み込みシステム用の SD カードイメージ。これらのファイルをダウンロードしたら、展開し、ボードが起動するように raw イメージとして SD カードに書き込んでください。</p></li><li><p>ISO または USB デバイスから起動して、FreeBSD を通常のデスクトップ、ラップトップ、サーバシステムのドライブ上にインストールするためのインストールイメージ。</p></li></ul></div><div class=paragraph><p>この章では、3 番目のケースについて、bsdinstall と呼ばれるテキストベースのインストールプログラムを用いた FreeBSD のインストール方法について説明します。</p></div><div class=paragraph><p>この章では、以下について説明します。</p></div><div class=ulist><ul><li><p>FreeBSD イメージの入手方法および FreeBSD インストールメディアの作り方。</p></li><li><p>bsdinstall の起動方法。</p></li><li><p>bsdinstall が聞いてくる質問がどのような意味であり、 またどのように答えれば良いか。</p></li><li><p>インストールに失敗した時の問題の解決方法。</p></li><li><p>インストールを確定する前に、 FreeBSD の live 版へアクセスする方法。</p></li></ul></div></div><div class=sect2><h3 id=bsdinstall-hardware>2.2. 最小ハードウェア要件<a class=anchor href=#bsdinstall-hardware></a></h3><div class=paragraph><p>FreeBSD をインストールするために必要なハードウェア要件は、アーキテクチャおよびバージョンごとに異なります。
FreeBSD の各リリースが対応しているハードウェアアーキテクチャおよびデバイスの一覧は、 <a href=https://www.FreeBSD.org/ja/releases/>FreeBSD リリース情報</a> のページにまとめられています。
アーキテクチャごとに推奨される適切なイメージの選択に関しては、 <a href=https://www.FreeBSD.org/ja/where/>FreeBSD ダウンロードページ</a> でも説明されています。</p></div></div><div class=sect2><h3 id=bsdinstall-pre>2.3. インストール前に行う作業<a class=anchor href=#bsdinstall-pre></a></h3><div class=paragraph><p>システムが FreeBSD のインストールのための最小ハードウェア要件を満たしていることを確認したら、インストールファイルをダウンロードして、インストール用のメディアを用意してください。
その前に、以下のチェックリストを確認して、システムをインストールする準備ができていることを確認してください。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>重要なデータのバックアップ</p><div class=paragraph><p>オペレーティングシステムをインストールする前に、 <strong>常に</strong> 価値のあるすべてのデータを最初にバックアップしてください。
インストールしようとしているシステムにはバックアップを保存しないでください。
そのかわり、USB ドライブ、ネットワーク上の他のシステム、もしくはオンラインのバックアップサービスといったリムーバルディスクにデータを保存してください。
インストールを始める前に、バックアップを調べて、必要なすべてのファイルがバックアップに含まれていることを確認してください。
インストーラがシステムのディスクをフォーマットしてしまうと、ディスクに保存されていたすべてのデータは失われます。</p></div></li><li><p>FreeBSD をインストールする場所の決定</p><div class=paragraph><p>インストールするオペレーティングシステムが FreeBSD のみであれば、 このステップは飛ばすことができます。 しかし、ディスクに FreeBSD と 他のオペレーティングシステムを共存させる必要がある場合には、FreeBSD が利用するディスクおよびパーティションを決める必要があります。</p></div><div class=paragraph><p>i386 および amd64 アーキテクチャでは、 二つのパーティションスキームのどちらかを使って、 ハードディスクを複数の塊に分割することができます。
伝統的な <em>Master Boot Record</em> (MBR) では、ディスク 1 台あたり最大 4 つの <em>プライマリパーティション</em> をパーティションテーブルに持つことができます。
歴史的な理由により、FreeBSD では、これらのパーティションのことを <em>スライス</em> と呼びます。 プライマリパーティションの 1 つに、複数の <em>論理パーティション</em> を含む <em>拡張パーティション</em> を作成できます。
<em>GUID Partition Table</em> (GPT) は、ディスクをパーティションに分ける簡単で新しい方法です。
一般的な GPT の実装では、1 つのディスクに 128 個までのパーティションの作成が可能であり、論理パーティションは必要ありません。</p></div><div class=paragraph><p>FreeBSD のブートローダは、プライマリまたは GPT パーティションのどちらかを必要とします。 ディスク上のプライマリ、もしくは GPT パーティションがすべて使われているのであれば、 そのひとつを FreeBSD のために開放してください。 ディスクにあるデータを消去せずにパーティションを作成するには、 パーティションサイズを変更するツールを使って今あるパーティションのサイズを小さくし、 空いたスペースに新しいパーティションを作成してください。</p></div><div class=paragraph><p>パーティションサイズを変更するためのフリーまたは商用のツールは、 <a href=https://en.wikipedia.org/wiki/List_of_disk_partitioning_software>List of disk partitioning software wikipedia entry</a> にまとめられています。
<a href=https://gparted.org/livecd.php>GParted Live</a> は、GParted パーティションエディタを含むフリーのライブ CD です。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>ディスクパーティションを縮小するユーティリティは、 適切に用いるとパーティション用の空き容量を新しく安全に作成できます。 すでにあるパーティションを間違って選択してしまう可能性があるので、 ディスクのパーティションを変更する前に、 必ず重要なデータのバックアップをとり、 バックアップが正しくとれていることを検証してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ディスクパーティションごとに異なるオペレーティングシステムをインストールすることで、 一つのコンピュータに複数のオペレーティングシステムをインストールできます。<a href=https://docs.freebsd.org/en/books/handbook/virtualization/#virtualization>仮想化技術</a> を用いると、ディスクパーティションを変更することなく、複数のオペレーティングシステムを同時に起動できます。</p></div></li><li><p>ネットワーク情報の収集</p><div class=paragraph><p>FreeBSD のインストール方法によっては、ネットワークに接続し、 インストールファイルをダウンロードする必要があります。 インストールする方法に関わらず、インストール後に、 インストーラはシステムのネットワークインタフェースの設定をする機会を提供します。</p></div><div class=paragraph><p>ネットワークに DHCP サーバがあると、 自動的にネットワークの設定情報を取得できます。 DHCP を利用できない環境では、 システムの以下のネットワーク情報について、 システム管理者かプロバイダにネットワーク情報を問い合わせる必要があります。</p></div><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>IP アドレス</p></li><li><p>サブネットマスク</p></li><li><p>デフォルトゲートウェイの IP アドレス</p></li><li><p>ネットワークのドメイン名</p></li><li><p>ネットワークの DNS サーバの IP アドレス</p></li></ol></div></li><li><p>FreeBSD Errata の確認</p><div class=paragraph><p>FreeBSD プロジェクトでは FreeBSD の各リリースができる限り安定するよう努力していますが、 時々バグが発生してしまうことがあります。
極まれに、発生したバグがインストールプロセスに影響を与えることがあります。
これらの問題は発見され解決されると、FreeBSD の各バージョンごとに Errata ページに記載されます。
インストールに影響するような既知の問題が無いことを、インストールする前に Errata で確認してください。</p></div><div class=paragraph><p>すべてのリリースに関する情報や Errata は、 <a href=https://www.FreeBSD.org/ja/releases/>リリース情報</a> のページで確認できます。</p></div></li></ol></div></div></div><div class=sect3><h4 id=bsdinstall-installation-media>2.3.1. インストールメディアの準備<a class=anchor href=#bsdinstall-installation-media></a></h4><div class=paragraph><p>FreeBSD のインストーラは、 他のオペレーティングシステムで実行できるようなプログラムではありません。 そのかわり、FreeBSD インストールファイルをダウンロードしたら、 ファイルタイプやサイズに合わせてメディア (CD, DVD または USB) に焼いてください。そして、挿入したメディアからインストールするように、 システムを起動してください。</p></div><div class=paragraph><p>FreeBSD のインストールファイルは <a href=https://www.FreeBSD.org/ja/where/#download>FreeBSD ダウンロードページ</a> から入手できます。
各インストールファイルの名前は、FreeBSD のリリースバージョンおよびアーキテクチャ、ファイルタイプから構成されます。</p></div><div class=paragraph><p>インストールファイルは、さまざまな形式で、<a href="https://man.freebsd.org/cgi/man.cgi?query=xz&amp;sektion=1&amp;format=html">xz(1)</a> により圧縮されたファイルまたは圧縮されていないファイルが用意されています。
用意されているフォーマットは、 コンピュータのアーキテクチャやメディアのタイプによって異なります。</p></div><div class=paragraph><p>インストールファイルの形式</p></div><div class=ulist><ul><li><p><code><strong>-bootonly.iso</strong></code>: インストーラのみを含む最小のインストールファイルです。
インストールを行う間、インストーラは FreeBSD をインストールするために必要なファイルをダウンロードするため、ネットワーク接続が必要です。
このファイルは、光学メディアに書き込む必要があります。</p></li><li><p><code><strong>-disc1.iso</strong></code>: FreeBSD のインストールに必要となる、ソースおよび Ports Collection といったすべてのファイルが含まれています。
このファイルは、光学メディアに書き込む必要があります。</p></li><li><p><code><strong>-dvd1.iso</strong></code>: FreeBSD のインストールに必要となる、ソースおよび Ports Collection といったすべてのファイルが含まれています。
インターネットに接続することなく、メディアのみでシステムのインストールを完了できるように、良く使われるウィンドウマネージャおよびアプリケーションをインストールするためのバイナリ package も含まれています。
このファイルは、光学メディアに書き込む必要があります。</p></li><li><p><code><strong>-memstick.img</strong></code>: FreeBSD のインストールに必要となる、ソースおよび Ports Collection といったすべてのファイルが含まれています。
<a href=#bsdinstall-usb>イメージファイルを USB に書き込む</a> で説明されている手順に従って、このファイルを USB スティックに書き込んでください。</p></li><li><p><code><strong>-mini-memstick.img</strong></code>: <code><strong>-bootonly.iso</strong></code> と同じく、インストールファイルは含まれていないため、必要に応じてダウンロードする必要があります。
インストールを行う間、ネットワーク接続が必要です。
<a href=#bsdinstall-usb>イメージファイルを USB に書き込む</a> の説明に従って、USB スティックに書き込んでください。</p></li></ul></div><div class=paragraph><p>イメージファイルをダウンロードしたら、同じディレクトリから少なくとも一つの <em>チェックサム</em> ファイルをダウンロードしてください。
2 つの <em>チェックサム</em> ファイルが利用可能です。
これのファイル名にはリリース番号とアーキテクチャ名がついています。
たとえば <code>CHECKSUM.SHA256-FreeBSD-13.1-RELEASE-amd64</code> および <code>CHECKSUM.SHA512-FreeBSD-13.1-RELEASE-amd64</code> という名前がつけられます。</p></div><div class=paragraph><p>どちらかの (もしくは両方の) ファイルをダウンロードしたら、イメージファイルの <em>チェックサム</em> を計算し、 <em>チェックサム</em> ファイルに示されている値と比較してください。
計算した <em>チェックサム</em> は、2 つの異なるアルゴリズム (SHA256 および SHA512) に対応する適切なファイルと比較してください。
FreeBSD では、<em>チェックサム</em> のために <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=sha512&amp;sektion=1&amp;format=html">sha512(1)</a> を提供しています。
他のオペレーティングシステムでも同じようなプログラムを利用できます。</p></div><div class=paragraph><p>FreeBSD での <em>チェックサム</em> の検証は、以下のように <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256sum&amp;sektion=1&amp;format=html">sha256sum(1)</a> (または <a href="https://man.freebsd.org/cgi/man.cgi?query=sha512sum&amp;sektion=1&amp;format=html">sha512sum(1)</a>) を使用して自動的に行うことができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sha256sum</span> <span class=nt>-c</span> CHECKSUM.SHA256-FreeBSD-13.1-RELEASE-amd64 FreeBSD-13.1-RELEASE-amd64-dvd1.iso
FreeBSD-13.1-RELEASE-amd64-dvd1.iso: OK</code></pre></div></div><div class=paragraph><p>チェックサムは完全に一致している必要があります。
もしチェックサムが一致しなければ、 イメージファイルが壊れている可能性があるので、もう一度ダウンロードしてください。</p></div><div class=sect4><h5 id=bsdinstall-usb>2.3.1.1. イメージファイルを USB に書き込む<a class=anchor href=#bsdinstall-usb></a></h5><div class=paragraph><p><code>*memstick.img</code> ファイルは、完全なメモリスティックの内容の <em>イメージ</em> です。
これは、通常のファイルのように対象のデバイスにコピーすることは <em>できません</em>。
USB スティックへ <code>*.img</code> を書き込むためのアプリケーションは複数あります。
この節ではこのうちの二つのユーティリティについて説明します。</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>先に進む前に、USB スティックに存在する重要なデータをバックアップしてください。 以下の手順を実行すると、 スティックに存在するデータは削除されます。</p></div></td></tr></tbody></table></div><div id=bsdinstall-usb-dd class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure. <code>dd</code> を使ってイメージを書き込む</strong><br></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>この例では、イメージの書き込み先のターゲットデバイスとして、<code>/dev/da0</code> が使われています。
ここで使われるコマンドは、 指定したターゲットデバイスに存在しているデータを破壊してしまうので、 正しいデバイスが指定されていることに <strong>細心の注意を払ってください</strong>。</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> コマンドユーティリティは、 BSD, Linux®, および Mac OS® システムで利用できます。 <code>dd</code> を使ってイメージを焼くには、 USB スティックを挿入して、 デバイス名を確定してください。 その後、ダウンロードしたインストールファイルおよび、 USB スティックのデバイス名を指定してください。 この例では、amd64 インストールイメージを FreeBSD システムの最初の USB デバイスに書き込みます。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=FreeBSD-13.0-RELEASE-amd64-memstick.img of=/dev/da0 bs=1M conv=sync</span></code></pre></div></div><div class=paragraph><p>もし上記のコマンドに失敗するようでしたら、USB スティックがマウントされているかどうか、デバイス名が (パーティションではなく) ディスクに対して指定されていることを確認してください。</p></div><div class=paragraph><p>オペレーティングシステムによっては、このコマンドを <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a> で実行することが求められる場合があります。
<a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> の書式は、プラットフォームによって少し変わります。
たとえば Mac OS® では、小文字の <code>bs=1m</code> を使う必要があります。
Linux® のようなシステムでは、書き込みをバッファします。
すべての書き込みを完了させるには、<a href="https://man.freebsd.org/cgi/man.cgi?query=sync&amp;sektion=8&amp;format=html">sync(8)</a> を使用してください。</p></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure. Windows® を使ってイメージを書き込む</strong><br></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>適切なドライブレターを出力先に設定していることを十分に確認してください。 さもなければ、現在あるデータは上書きされ、 破壊されてしまうでしょう。</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p><strong>Image Writer for Windows® を入手する</strong></p><div class=paragraph><p>Image Writer for Windows® は、 イメージファイルをメモリスティックに正しく書き込むことのできるフリーのアプリケーションです。
<a href=https://sourceforge.net/projects/win32diskimager/>win32diskimager ホームページ</a> からダウンロードして、フォルダに展開してください。</p></div></li><li><p>イメージライタを使ってイメージを書き込む</p><div class=paragraph><p>Win32DiskImager アイコンをダブルクリックして、プログラムを起動してください。 <code>Device</code> の下に表示されるデバイスレターが、 メモリスティックのドライブであることを確認してください。 フォルダのアイコンをクリックして、 メモリスティックに書き込むイメージファイルを選択します。 <b class=button>Save</b> をクリックして、 イメージファイルの名前を確定してください。 すべてが正しく行われたかどうか、また、 他のウィンドウでメモリスティックのフォルダが開かれていないことを確認してください。 準備ができたら、<b class=button>Write</b> をクリックして、 メモリスティックにイメージファイルを書き込んでください。</p></div></li></ol></div></div></div></div></div></div><div class=sect2><h3 id=bsdinstall-start>2.4. インストールの開始<a class=anchor href=#bsdinstall-start></a></h3><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>デフォルトでは、次のメッセージが表示されるまで インストーラはディスクに何の変更も加えません。</p></div><div class="literalblock programlisting"><div class=content><pre>Your changes will now be written to disk. If you
have chosen to overwrite existing data, it will
be PERMANENTLY ERASED. Are you sure you want to
commit your changes?</pre></div></div><div class=paragraph><p>この警告の前であれば、いつでもインストールを中断できます。 もし、何かを間違って設定してしまったことが心配ならば、 最後の警告の前に単にコンピュータをオフにしてください。 システムのハードディスクを変更せずに済みます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この章では、<a href=#bsdinstall-installation-media>インストールメディアの準備</a> で説明されている手順によって準備されたインストールメディアから、システムを起動する方法について説明します。
起動可能な USB スティックを使用する場合には、コンピュータを立ち上げる前に、USB スティックを挿入してください。
CD もしくは DVD から起動する場合には、コンピュータを立ち上げ、すぐにメディアを挿入してください。
挿入したメディアからシステムを起動するように設定する方法は、アーキテクチャ毎に異なります。</p></div><div class=sect3><h4 id=bsdinstall-view-probe>2.4.1. FreeBSD ブートメニュー<a class=anchor href=#bsdinstall-view-probe></a></h4><div class=paragraph><p>インストールメディアからシステムが起動すると、 以下のようなメニューが表示されます。</p></div><div id=bsdinstall-newboot-loader-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-newboot-loader-menu.png alt="FreeBSD ブートローダメニュー"></div><div class=title>図 1. FreeBSD ブートローダメニュー</div></div><div class=paragraph><p>デフォルトでは、メニューは、FreeBSD インストーラが起動するまで (FreeBSD がインストールされているシステムでは、FreeBSD が起動するまで)、 ユーザからの入力を 10 秒間受け付けます。 タイマーを停止してオプションを確認には、 <kbd>Space</kbd> を押してください。オプションを選択するには、 ハイライトされている番号、文字、もしくはキーを押してください。 以下のオプションが利用可能です。</p></div><div class=ulist><ul><li><p><code>Boot Multi User</code>: FreeBSD の起動プロセスを続けます。 ブートタイマが停止しているのであれば <kbd>1</kbd>、 大文字もしくは小文字の <kbd>B</kbd> または、 <kbd>Enter</kbd> を押してください。</p></li><li><p><code>Boot Single User</code>: このモードは、すでにインストールされている FreeBSD を修復するために利用できます。 シングルユーザモードについては、 <a href=./#boot-singleuser>「シングルユーザモード」</a> で説明されています。 <kbd>2</kbd> もしくは、小文字もしくは、大文字の <kbd>S</kbd> を押すとこのモードに入ることができます。</p></li><li><p><code>Escape to loader prompt</code>: 制限された低レベルのコマンドのみが利用可能な修復用プロンプトでシステムを起動します。 このプロンプトについては、 <a href=./#boot-loader>「起動ステージ 3」</a> で説明されています。 <kbd>3</kbd> または <kbd>Esc</kbd> を押すとこのプロンプトで起動します。</p></li><li><p><code>Reboot</code>: システムを再起動します。</p></li><li><p><code>Cons</code>: <code>video</code>, <code>serial</code>, <code>Dual (serial primary)</code> または <code>Dual (Video primary)</code> でインストールを続けます。</p></li><li><p><code>Kernel</code>: 別のカーネルを読み込みます。</p></li><li><p><code>Boot Options</code>: <a href=#bsdinstall-boot-options-menu>FreeBSD ブートオプションメニュー</a> で示されるメニューを開きます。</p></li></ul></div><div id=bsdinstall-boot-options-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-boot-options-menu.png alt=サポートされているブートオプションのメニュー></div><div class=title>図 2. FreeBSD ブートオプションメニュー</div></div><div class=paragraph><p>この起動オプションメニューは、 2 つのセクションから構成されています。 最初のセクションは、メインのブートメニューに戻ったり、 オプションをデフォルト値に戻すために利用できます。</p></div><div class=paragraph><p>次のセクションでは、変更可能なオプションついて、 選択されている番号や文字を、<code>On</code> や <code>Off</code> に変更できます。 システムは、これらのオプションが変更されない限り、 常に変更されたオプションで起動します。 このメニューで変更可能なオプションは以下の通りです。</p></div><div class=ulist><ul><li><p><code>ACPI Support</code>: 起動中にシステムが固まるようでしたら、このオプションを <code>Off</code> にしてください。</p></li><li><p><code>Safe Mode</code>: 上記のオプションの対応を行ってもシステムが起動時に固まるようでしたら、 <code>ACPI Support</code> を <code>Off</code> にし、このオプションを <code>On</code> に設定してください。</p></li><li><p><code>Single User</code>: シングルユーザモードでインストールされている FreeBSD を修復には、 <code>On</code> にしてください。 シングルユーザモードについては、 <a href=./#boot-singleuser>「シングルユーザモード」</a> で説明されています。 問題が修正された後は、<code>Off</code> に戻してください。</p></li><li><p><code>Verbose</code>: 起動プロセスの表示をより詳細に表示したい場合には、 このオプションを <code>On</code> にしてください。 ハードウェアの問題を解決する際には有効です。</p></li></ul></div><div class=paragraph><p>設定が終わったら、 <kbd>1</kbd> または <kbd>Backspace</kbd> を押してメインブートメニューに戻り、 <kbd>Enter</kbd> を押して FreeBSD の起動を続けてください。 FreeBSD がハードウェアの検出を行い、 インストールプログラムをロードしている間、 ブートメッセージが表示されます。 起動後、<a href=#bsdinstall-choose-mode>ウェルカムメニュー</a> が表示されます。</p></div><div id=bsdinstall-choose-mode class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-choose-mode.png alt="FreeBSD インストーラのウェルカムメニュー"></div><div class=title>図 3. ウェルカムメニュー</div></div><div class=paragraph><p><kbd>Enter</kbd> を押して、デフォルトの <b class=button>Install</b> を選択すると、インストール作業が始まります。
この章の残りの部分では、このインストーラの使い方について説明します。
メニュー項目を選択するには、左右の矢印キーを使ったり、色付けされた文字を使ってください。
<b class=button>Shell</b> を選択すると、インストールの前に、FreeBSD シェルからコマンドラインユーティリティでディスクを準備できます。
<b class=button>Live CD</b> オプションを選択すると、 インストール前に FreeBSD を試すことができます。
live 版については、<a href=#using-live-cd>Live CD を使う</a> で説明されています。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>ハードウェアの検出などのブートメッセージを見るには 大文字または小文字の <kbd>S</kbd> を押してください。 その後、<kbd>Enter</kbd> を押して、 シェルにアクセスしてください。 シェルプロンプトから、<code>more /var/run/dmesg.boot</code> を入力してください。 メッセージのスクロールには、スペースバーを使ってってください。 終わったら、<code>exit</code> を押して、 ウェルカムメニューに戻ってください。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=using-bsdinstall>2.5. bsdinstall の使用<a class=anchor href=#using-bsdinstall></a></h3><div class=paragraph><p>この章では、 bsdinstall メニューの順番と、 システムがインストールされる前に、 尋ねられる情報の形式について紹介します。 メニューオプションの選択には、矢印キーを使い、 メニューの項目の選択や解除する場合には、<kbd>Space</kbd> キーを使ってください。 設定が終わったら、<kbd>Enter</kbd> を押して設定を保存し、次の画面へ移動してください。</p></div><div class=sect3><h4 id=bsdinstall-keymap>2.5.1. キー配列メニューの選択<a class=anchor href=#bsdinstall-keymap></a></h4><div class=paragraph><p>このプロセスが始まると、 bsdinstall は <a href=#bsdinstall-keymap-loading>キーマップの読み込み</a> のようにキーマップファイルを読み込みます。</p></div><div id=bsdinstall-keymap-loading class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-loading.png alt=キーマップの読み込み></div><div class=title>図 4. キーマップの読み込み</div></div><div class=paragraph><p>キーマップが読み込まれると、bsdinstall は <a href=#bsdinstall-keymap-10>キーマップ選択メニュー</a> を表示します。
上下の矢印キーを使って、システムのキーボードに最も近いキーマップを選択してください。
選択を保存するには、<kbd>Enter</kbd> キーを押してください。</p></div><div id=bsdinstall-keymap-10 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-10.png alt=キーマップ選択メニュー。対応しているすべてのキーボードが表示されます。></div><div class=title>図 5. キーマップ選択メニュー</div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><kbd>Esc</kbd> を押すと、メニューは終了し、 デフォルトのキーボードマップを使うようになります。 どのキーボードマップを選べばよいかわからない場合は、 <span class=guimenuitem>United States of America ISO-8859-1</span> を選ぶとよいでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p>デフォルトとは異なるキーマップを選択した場合には、 <a href=#bsdinstall-keymap-testing>キーマップテストメニュー</a> でキーマップのテストを行い、 インストールを先に進む前に正しく動くかどうかを確認できます。</p></div><div id=bsdinstall-keymap-testing class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-testing.png alt=キーマップテストメニュー></div><div class=title>図 6. キーマップテストメニュー</div></div></div><div class=sect3><h4 id=bsdinstall-hostname>2.5.2. ホスト名の設定<a class=anchor href=#bsdinstall-hostname></a></h4><div class=paragraph><p>次の bsdinstall のメニューでは、 新しくインストールするシステムに与えるホスト名を設定します。</p></div><div id=bsdinstall-config-hostname class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-hostname.png alt=ホスト名の設定></div><div class=title>図 7. ホスト名の設定</div></div><div class=paragraph><p>ネットワーク上でユニークなホスト名を入力してください。 入力するホスト名は、<code>machine3.example.com</code> のように完全修飾のホスト名で入力してください。</p></div></div><div class=sect3><h4 id=bsdinstall-components>2.5.3. インストールするコンポーネントの設定<a class=anchor href=#bsdinstall-components></a></h4><div class=paragraph><p>次に、 bsdinstall は、インストールするオプションのコンポーネントの選択に移ります。</p></div><div id=bsdinstall-config-components class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-components.png alt=base-dbg width=lib32 height="ports などのインストールするコンポーネントの設定"></div><div class=title>図 8. インストールするコンポーネントの設定</div></div><div class=paragraph><p>どのコンポーネントをインストールするかは、 システムの用途と用意されているディスク容量に依存します。 <em>base system</em> として知られている FreeBSD カーネルとユーザランドは、 常にインストールされます。 アーキテクチャによっては、表示されないコンポーネントもあります。</p></div><div class=ulist><ul><li><p><code>base-dbg</code> - デバッグシンボルを有効にしたベースツール (cat, ls や他の多くのツール)。</p></li><li><p><code>kernel-dbg</code> - デバッグシンボルを有効にしたカーネルおよびモジュール。</p></li><li><p><code>lib32-dbg</code> - 32-bit のアプリケーションを 64-bit 版の FreeBSD で実行する際に必要となる互換ライブラリ (デバッグシンボルは有効)。</p></li><li><p><code>lib32</code> - 32-bit のアプリケーションを 64-bit 版の FreeBSD で実行する際に必要となる互換ライブラリ。</p></li><li><p><code>ports</code> - FreeBSD Ports Collection は、 サードパーティ製ソフトウェアパッケージのダウンロード、 コンパイル、 インストールを自動化するように設計されたファイルの集まりです。 Ports Collection の使い方については、 <a href=./#ports>アプリケーションのインストール - packages と ports</a> で説明します。</p><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>インストールプログラムは、システムのディスクに十分な空き容量があるかどうかを確認しないので、ハードディスクに十分な容量があるときだけ、このオプションを選択するしてください。
FreeBSD Ports Collection が必要とする容量は、約 3 GB です。</p></div></td></tr></tbody></table></div></li><li><p><code>src</code> - FreeBSD のカーネルおよびユーザランド両方の完全なソースコードです。 ほとんどのアプリケーションは必要としませんが、 デバイスドライバやカーネルモジュール、 Ports Collection のアプリケーションによってはコンパイル時に必要となります。 このソースは、FreeBSD そのものの開発に使うこともできます。 すべてのソースツリーをインストールするには 1 GB のディスク容量を必要とします。 また、FreeBSD システム全体のコンパイルには、 さらに 5 GB の容量が必要です。</p></li><li><p><code>tests</code> - FreeBSD テストスイート。</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-netinstall>2.5.4. ネットワークからのインストール<a class=anchor href=#bsdinstall-netinstall></a></h4><div class=paragraph><p><a href=#bsdinstall-netinstall-notify>ネットワークからのインストール</a> で示されているメニューは、<code>-bootonly.iso</code> または <code>-mini-memstick.img</code> からインストールする時のみ表示されます。
これらのインストールメディアはインストールファイルを含んでいません。
このメニューは、 ネットワーク経由でインストールファイルをダウンロードする必要があるため、ネットワークインタフェースを最初に設定する必要があることを示しています。
このメニューがインストールのプロセスで表示された場合には、 <a href=#bsdinstall-config-network-dev>ネットワークインタフェースの設定</a> に書かれている手順に従ってください。</p></div><div id=bsdinstall-netinstall-notify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-files.png alt=インストールするコンポーネントが見つからないため、ネットワークからダウンロードを試みることを示しています。></div><div class=title>図 9. ネットワークからのインストール</div></div></div></div><div class=sect2><h3 id=bsdinstall-partitioning>2.6. ディスク領域の割り当て<a class=anchor href=#bsdinstall-partitioning></a></h3><div class=paragraph><p>次のメニューでは、ディスク領域を割り当てる方法を選択します。</p></div><div id=bsdinstall-zfs-partmenu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-partmenu.png alt="パーティションのオプションを示しています。例: マニュアル、シェルなど"></div><div class=title>図 10. パーティション分割の選択</div></div><div class=paragraph><p>bsdinstall では、ディスク領域の割り当てのために 4 つの方法が用意されています。</p></div><div class=ulist><ul><li><p><code>Auto (ZFS)</code> によるパーティションの分割では、root-on-ZFS システムを構築します。GELI 暗号に対応した <em>ブート環境</em> を構築することもできます。</p></li><li><p><code>Auto (UFS)</code> によるパーティションの分割では、 <code>UFS</code> ファイルシステムを使ってディスクパーティションを自動的に分割します。</p></li><li><p><code>Manual</code> によるパーティションの分割は、 高度な知識を持つユーザ向けで、 メニューオプションからカスタマイズしたパーティションを作成できます。</p></li><li><p><code>Shell</code> では、シェルプロンプトを起動し、 高度な知識を持つユーザが、 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> のようなコマンドラインのプログラムを実行して、 カスタマイズしたパーティションを作成できます。</p></li></ul></div><div class=paragraph><p>この章では、 ディスクパーティションをレイアウトする際の検討事項を説明します。 その後、各パーティションの作成方法について説明します。</p></div><div class=sect3><h4 id=configtuning-initial>2.6.1. パーティションレイアウトのデザイン<a class=anchor href=#configtuning-initial></a></h4><div class=paragraph><p>デフォルトのファイルシステムのパーティションレイアウトは、システム全体をひとつのファイルシステムで構成します。
十分なディスク容量または複数のディスクを用いる環境において <code>UFS</code> を用いる場合は、複数のファイルシステムを検討する価値があります。
ファイルシステムのレイアウトを行う際には、 ハードディスクの外周部は内周部よりもデータ転送が速いということを思い出してください。
これに従えば、 小さくて激しくアクセスされるファイルシステムを外周付近に、<code>/usr</code> のようなより大きなパーティションはディスクの内側に配置すべきでしょう。
そのため、パーティションを作成する際には、<code>/</code>、 スワップ、<code>/var</code>, <code>/usr</code> のような順で作ってゆくのがよいでしょう。</p></div><div class=paragraph><p><code>/var</code> パーティションのサイズは、あなたが計算機をどのように使おうとしているかを反映します。
このパーティションには主としてメールボックスやログファイル、 プリンタスプールが置かれます。
メールボックスとログファイルは、 システムのユーザ数やログの保持期間に依存して予期し得ぬサイズにまで成長する可能性があります。
概して、ほとんどのユーザは、<code>/var</code> にギガバイト以上の空き容量を必要とはしないでしょう。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>時には、たくさんのディスク容量が <code>/var/tmp</code> に必要になるときがあります。
新しいソフトウェアをインストールする際、package のツールは、package の一時的なコピーを <code>/var/tmp</code> 以下に展開します。
<code>/var/tmp</code> 以下に十分なディスク容量が用意されていないと、Firefox や LibreOffice のような、大きなソフトウェア package のインストールが、困難になることがあります。</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>/usr</code> パーティションには、FreeBSD Ports Collection およびシステムのソースコードを含む、システムをサポートするのに必要な多くのファイル群が置かれます。
このパーティションには、少なくとも 2 ギガバイトの容量を用意することをおすすめします。
また、デフォルトではユーザのホームディレクトリは <code>/usr/home</code> に置かれますが、他のパーティションに置くこともできます。
デフォルトでは、<code>/home</code> は <code>/usr/home</code> へのシンボリックリンクです。</p></div><div class=paragraph><p>パーティションのサイズを考える時、 必要量を念頭に置いてください。 別のパーティションには潤沢にスペースが余っているのに、 あるパーティションでスペースが足らないままというのは、 フラストレーションがたまるものです。</p></div><div class=paragraph><p>経験からスワップパーティションのサイズは物理メモリ (RAM) の 2 倍というのが一般的です。
RAM の少ないシステムでは、もっとスワップを増した方が性能がよくなります (大きなメモリの設定では少なくて済みます)。
スワップが少なすぎる設定は、あなたが後にメモリを増設したときに問題を起すばかりではなく、VM ページスキャニングコードの能率を落します。</p></div><div class=paragraph><p>複数の SCSI ディスクや異なるコントローラで操作される複数の IDE ディスクを持つ大規模なシステムでは、それぞれのドライブ (4 台まで) にスワップを設定することを推奨します。
各ドライブのスワップパーティションはほぼ同一サイズであるべきです。
カーネルは任意のサイズを扱うことができますが、内部のデータ構造は最大のスワップパーティションの 4 倍に調節されます。
スワップパーティションをほぼ同一のサイズにしておくことで、カーネルはスワップスペースを最適なかたちでディスクをまたいでストライプさせることができます。
多くのスワップサイズを用意すると、全体のスワップに関するカーネルの警告メッセージがが表示されることがあります。
警告メッセージに示される手順に従って、スワップの割り当てのために許容されるメモリ量を増やすことで、この制限容量を増やすことができます。</p></div><div class=paragraph><p>あなたが通常スワップをたくさん使わないとしても、
プログラムが暴走しても再起動させられる前に回復することが容易になります。</p></div><div class=paragraph><p>システムを適切にパーティション化することで、小さいが書き込みの激しいパーティションによって引き起こされるフラグメント化を、読み出し専門のパーティションにまで波及させずにすみます。
また、書き込みの激しいパーティションをディスクの周辺部に配置することで、I/O パフォーマンスを増大させることができます。
大きなパーティション内の I/O パフォーマンスもまた必要とされているでしょうが、ディスク周辺部へ移動させたとしても、<code>/var</code> を周辺部に移動させることによって大きな効果が得られたのとは対照的に、意味のあるパフォーマンスの増加は見込めないでしょう。</p></div></div><div class=sect3><h4 id=bsdinstall-part-guided>2.6.2. UFS を用いた Guided によるパーティションの分割<a class=anchor href=#bsdinstall-part-guided></a></h4><div class=paragraph><p>この方法を選択すると、 メニューには利用可能なディスクが表示されます。 複数のディスクが接続されている場合には、 FreeBSD をインストールするディスクを選択してください。</p></div><div id=bsdinstall-part-guided-disk class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-guided-disk.png alt="FreeBSD をインストールすることのできるディスクの一覧が表示されます"></div><div class=title>図 11. 複数のディスクから選択する</div></div><div class=paragraph><p>ディスクを選択したら、次のメニューでは、 ディスクのすべてにインストールを行うか、 または空き容量にパーティションを作成してインストールを行うかを設定します。 <b class=button>Entire Disk</b> を選択すると、 一般的なパーティションレイアウトが自動的に作成されます。 <b class=button>Partition</b> を選択すると、 ディスクの使用していない領域にパーティションレイアウトを作成します。</p></div><div id=bsdinstall-part-entire-part class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-entire-part.png alt=使用するディスク上で利用可能な領域をすべて使うか、もしくはパーティションを作成するかを選択するメニュー></div><div class=title>図 12. Entire Disk または Partition の選択</div></div><div class=paragraph><p><b class=button>Entire Disk</b> オプションを選択すると、bsdinstall はディスクの内容が消去されることを確認するダイアログを表示します。</p></div><div id=bsdinstall-ufs-warning class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-ufs-warning.png alt=ユーザに対しディスク上のすべてのデータが消去されることの確認メニュー></div><div class=title>図 13. 確認</div></div><div class=paragraph><p>次のメニューでは、 利用可能なパーティションスキームタイプの一覧が表示されます。
amd64 コンピュータでは、通常 GPT が最も適切な選択となります。
GPT に対応していないような古いコンピュータでは、MBR を使う必要があります。
他のパーティションスキームは、使うことがまれであったり、古いコンピュータで用いられるものです。
<a href=#partition-schemes>パーティションスキーム</a> に詳細があります。</p></div><div id=bsdinstall-ufs-scheme class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png alt=ユーザに対して選択可能なさまざまなパーティションタイプを示し、そのうちのどれかを選択するためのメニュー></div><div class=title>図 14. パーティションスキームの選択</div></div><div class=paragraph><p>パーティションのレイアウトを作成したら、インストールの条件を満たしているかどうかを深く確認してください。
<b class=button>Revert</b> を選択すると、パーティションをオリジナルの値にリセットします。
また、<b class=button>Auto</b> を選択すると、FreeBSD パーティションを自動的に作成します。
パーティションを手動で作成、変更、削除することもできます。
正しくパーティションを作成出来たら、 <b class=button>Finish</b> を選択し、インストールを進めてください。</p></div><div id=bsdinstall-part-review class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-review.png alt=作成されたパーティションを表示するメニュー></div><div class=title>図 15. 作成されたパーティションの確認</div></div><div class=paragraph><p>ディスクを一度設定すると、次のメニューは、選択したハードドライブをフォーマットする前に、設定を変更できる最後のチャンスです。
もし変更が必要であれば、 <b class=button>Back</b> を選択してメインのパーティションエディタまで戻ってください。
<b class=button>Revert & Exit</b> を選択すると、ハードドライブへの変更なしにインストールを終了します。
インストールプロセスを開始するには、 <b class=button>Commit</b> を選択してしてください。</p></div><div id=bsdinstall-ufs-final-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-confirmation.png alt=ユーザに対してインストールを開始すると、すべての変更がディスクに書き込まれ、ディスクに存在するデータは完全に削除されることを確認するメニュー></div><div class=title>図 16. 最後の確認</div></div><div class=paragraph><p><a href=#bsdinstall-fetching-distribution>配布ファイルのダウンロード</a> に進んで、インストールプロセスを続けてください。</p></div></div><div class=sect3><h4 id=bsdinstall-part-manual>2.6.3. Manual によるパーティションの分割<a class=anchor href=#bsdinstall-part-manual></a></h4><div class=paragraph><p>この方法を選択すると、 パーティションエディタが起動します。</p></div><div id=bsdinstall-part-manual-create class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-create.png alt=パーティションエディタを表示しているメニュー></div><div class=title>図 17. Manual によるパーティションの分割</div></div><div class=paragraph><p>インストール先のドライブ (この例では <code>ada0</code>) を選び、 <b class=button>Create</b> を選択すると、 利用可能なパーティションスキームの一覧が表示されます。</p></div><div id=bsdinstall-part-manual-partscheme class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png alt=選択可能なパーティションスキームを表示しているメニュー></div><div class=title>図 18. 手動でパーティションを作成する</div></div><div class=paragraph><p>amd64 コンピュータでは、通常 GPT が最も適切な選択となります。 GPT に対応していないような古いコンピュータでは、 MBR を使う必要があります。 他のパーティションスキームは、使うことがまれであったり、 古いコンピュータで用いられるものです。</p></div><table id=partition-schemes class="tableblock frame-none grid-all stretch"><caption class=title>表 1. パーティションスキーム</caption><col style=width:25%><col><thead><tr><th class="tableblock halign-left valign-top">省略形</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><th class="tableblock halign-left valign-top"><p class=tableblock>APM</p></th><td class="tableblock halign-left valign-top"><p class=tableblock>PowerPC® で使われている Apple Partition Map</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock>BSD</p></th><td class="tableblock halign-left valign-top"><p class=tableblock>MBR を用いない BSD ラベル。 BSD 以外のディスクユーティリティは認識しないため、しばしば <em>dangerously dedicated mode</em> と呼ばれます。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock>GPT</p></th><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://en.wikipedia.org/wiki/GUID_Partition_Table>GUID Partition Table</a></p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock>MBR</p></th><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://en.wikipedia.org/wiki/Master_boot_record>Master Boot Record</a></p></td></tr></tbody></table><div class=paragraph><p>パーティションスキームを選択して作成した後で、 もう一度 <b class=button>Create</b> を選択すると、 パーティションが作成されます。<kbd>Tab</kbd> キーを使ってカーソルをフィールド間で移動できます。</p></div><div id=bsdinstall-part-manual-addpart class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-addpart.png alt=追加するパーティションのタイプ、サイズ、マウントポイントおよびラベル情報を入力するためのメニュー></div><div class=title>図 19. 手動でパーティションを作成する</div></div><div class=paragraph><p>標準の FreeBSD GPT のインストールでは、UFS または ZFS を含む少なくとも 3 つのパーティションが使われます。</p></div><div class=ulist><ul><li><p><code>freebsd-boot</code> または <code>efi</code> - FreeBSD ブートコードを含んでいます。</p></li><li><p><code>freebsd-ufs</code> - FreeBSD UFS ファイルシステム。</p></li><li><p><code>freebsd-zfs</code> - FreeBSD ZFS ファイルシステム。 詳細については、 <a href=https://docs.freebsd.org/en/books/handbook/zfs/#zfs>The Z File System (ZFS)</a> をご覧ください。</p></li><li><p><code>freebsd-swap</code> - FreeBSD スワップ空間。</p></li></ul></div><div class=paragraph><p>利用可能な GPT パーティションタイプについては、<a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> をご覧ください。</p></div><div class=paragraph><p>複数のファイルシステムのパーティションを作成できます。
人によっては <code>/</code>, <code>/var</code>, <code>/tmp</code> および <code>/usr</code> にパーティションを分割する伝統的なレイアウトが好まれます。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>十分なメモリを搭載したシステムでは、メモリベースのファイルシステム (<a href="https://man.freebsd.org/cgi/man.cgi?query=tmpfs&amp;sektion=5&amp;format=html">tmpfs(5)</a>) を <code>/tmp</code> として後で追加できます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>レイアウトの例が <a href=#bsdinstall-part-manual-splitfs>伝統的なファイルシステムのパーティションの作成</a> にあります。</p></div><div class=paragraph><p><code>Size</code> には、 <em>K</em> (キロバイト)、 <em>M</em> (メガバイト)、 <em>G</em> (ギガバイト) といった通常の省略形を使用出来ます。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>セクタを適切に配置することで、 最良のパフォーマンスを得ることができます。 また、パーティションサイズを 4K バイトの偶数倍にすると、 512 バイトまたは 4K バイトのセクタでドライブが配置しやすくなります。 一般的に、 4K の偶数倍の場所からパーティションが開始するように設定する簡単な方法は、 1M または 1G の偶数倍のパーティションサイズを用いることです。 ただし、例外があります。 <em>freebsd-boot</em> パーティションは、 ブートコードの制限により 512K 以下である必要があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ファイルシステムを持つパーティションでは、<code>マウントポイント</code> が必要となります。
1 つの UFS パーティションだけを作成したのであれば、マウントポイントは <code>/</code> となります。</p></div><div class=paragraph><p><code>Label</code> は作成したパーティションを認識するための名前です。
ドライブ名や番号は、ドライブが別のコントローラやポートに接続されると変わることがありますが、パーティションラベルは変わりません。
<code>/etc/fstab</code> のようなファイルの中で、ドライブ名やパーティション番号ではなく、ラベルを参照することにより、システムがハードウェアの変更に対して、より寛容になります。
GPT ラベルは、ディスクが接続されると <code>/dev/gpt/</code> に現れます。
他のパーティションスキームでは別のラベルとなり、<code>/dev/</code> 以下の異なるディレクトリにラベルが現れます。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>名前の衝突を避けるため、 各パーティションには、一意的な名前使ってください。 コンピュータ名、使用、位置情報を表す単語をラベルに追加できます。 たとえば、<code>lab</code> という名前のコンピュータの UFS の root パーティションには、 <code>labroot</code> または <code>rootfs-lab</code> といった名前を使ってください。</p></div></td></tr></tbody></table></div><div id=bsdinstall-part-manual-splitfs class=exampleblock><div class=title>例 1. 伝統的なファイルシステムのパーティションの作成</div><div class=content><div class=paragraph><p>伝統的なパーティションレイアウト (<code>/</code>, <code>/var</code>, <code>/tmp</code> および <code>/usr</code> ディレクトリが各パーティションの別のファイルシステム) を作成するには、GPT パーティションスキームを作成し、その後、示されているようにパーティションを作成してください。
示されているパーティションサイズは 20G のディスク用です。
ディスクにより多くの容量があれば、swap または <code>/var</code> パーティションを大きく取ると良いでしょう。
ここで示されているラベルには、<code>example</code> を意味する <code>ex</code> が付けられていますが、実際には上で説明したように、これとは別のユニークなラベルをつけてください。</p></div><div class=paragraph><p>FreeBSD の <code>gptboot</code> は、 デフォルトでは最初に見つかった UFS パーティションが、 <code>/</code> パーティションであることを前提としています。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">パーティションタイプ</th><th class="tableblock halign-left valign-top">サイズ</th><th class="tableblock halign-left valign-top">マウントポイント</th><th class="tableblock halign-left valign-top">ラベル</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-boot</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>512K</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>/</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exrootfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-swap</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>4G</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exswap</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>/var</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exvarfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>1G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>/tmp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>extmpfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>デフォルト (ディスクの残りのすべての容量)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>/usr</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exusrfs</code></p></td></tr></tbody></table></div></div><div class=paragraph><p>カスタムパーティションを作成したら、 <b class=button>Finish</b> を選択して <a href=#bsdinstall-fetching-distribution>配布ファイルのダウンロード</a> に進み、インストールを先に進めてください。</p></div></div><div class=sect3><h4 id=bsdinstall-part-zfs>2.6.4. Root-on-ZFS を用いた Guided によるパーティションの作成<a class=anchor href=#bsdinstall-part-zfs></a></h4><div class=paragraph><p>このパーティションの分割モードは、 ディスクのすべての領域に対して機能するので、 ディスク上にあるすべての内容が消去されます。 メインの ZFS 設定メニューには、 プールの作成をコントロールする数多くのオプションが用意されています。</p></div><div id=bsdinstall-zfs-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-menu.png alt="ZFS プールを設定するためのオプションを表示しているメニュー"></div><div class=title>図 20. ZFS パーティションメニュー</div></div><div class=paragraph><p>このメニューのオプションは以下の通りです。</p></div><div class=ulist><ul><li><p><code>Install</code> - 選択したオプションでインストールを進めます。</p></li><li><p><code>Pool Type/Disks</code> - プールを構成する <code>Pool Type</code> およびディスクについて設定します。
現時点で ZFS の自動インストーラは、ストライプモードを除き、単一のトップレベルの仮想デバイスの作成のみに対応しています。
より複雑なプールを作成するには、 <a href=#bsdinstall-part-shell>シェルモードによるパーティションの作成</a> で説明されている方法で作成してください。</p></li><li><p><code>Rescan Devices</code> - 利用可能なディスクの一覧を再表示します。</p></li><li><p><code>Disk Info</code> - このメニューを使って各ディスクを調べることができます。
パーティションテーブルやそれ以外のデバイスモデルナンバーおよびシリアルナンバーといった情報も、可能であれば調べることができます。</p></li><li><p><code>Pool Name</code> - pool の名前を設定します。 デフォルトの名前は <em>zroot</em> です。</p></li><li><p><code>Force 4K Sectors?</code> - 4K セクタを使用するようにします。 インストーラは、デフォルトで 4K の境界に整列するようにパーティションを自動的に作成し、 ZFS が 4K セクタを使用するようにします。 これは 512 バイトセクタのディスクでも安全で、 512 バイトのディスク上に作成されたプールが将来的に 4K セクタのディスクを追加できるようにしておくことには、 ストレージ容量の追加や壊れたディスクの交換時に恩恵があります。 有効にするか無効にするかを選択して <kbd>Enter</kbd> キーを押してください。</p></li><li><p><code>Encrypt Disks?</code> - GELI を使ってディスクを暗号化できます。ディスクの暗号化の詳細については、 <a href=https://docs.freebsd.org/en/books/handbook/disks/#disks-encrypting-geli>geli によるディスクの暗号化</a> をご覧ください。 <kbd>Enter</kbd> キーを押して、暗号化を有効にするか無効にするかを選択してください。</p></li><li><p><code>Partition Scheme</code> - パーティションスキームを選択します。
ほとんどの場合において、GPT が推奨されます。
別のスキームを選択する場合には、 <kbd>Enter</kbd> キーを押してください。</p></li><li><p><code>Swap Size</code> - スワップ容量を設定します。</p></li><li><p><code>Mirror Swap?</code> - スワップ領域をディスク間でミラー化するかどうかを設定します。
スワップ領域をミラー化すると、クラッシュダンプを取得できないので注意してください。
<kbd>Enter</kbd> キーを押して有効/無効を設定してください。</p></li><li><p><code>Encrypt Swap?</code> - スワップ領域の暗号化について設定します。
これはシステムの起動時に一時キーとともにスワップ領域を暗号化し、再起動時にキーは破棄されます。
<kbd>Enter</kbd> キーを押して有効/無効を設定してください。
詳細については、 <a href=https://docs.freebsd.org/en/books/handbook/disks/#swap-encrypting>swap 領域の暗号化</a> を参照してください。</p></li></ul></div><div class=paragraph><p><kbd>T</kbd> を選択して、<code>Pool Type</code> およびプールに対応するディスクを選択してください。</p></div><div id=bsdinstall-zfs-vdev_type class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_type.png alt=stripe width=mirror height="raidz1 などの仮想デバイスタイプを選択するメニュー"></div><div class=title>図 21. ZFS プールタイプ</div></div><div class=paragraph><p>このメニューで選択可能な <code>Pool Type</code> は以下の通りです。</p></div><div class=ulist><ul><li><p><code>stripe</code> - ストライピングでは、 接続されているすべてのデバイスの最大容量を使用できます。 ただし、冗長性はありません。 一つのディスクが壊れるだけでプールにあるデータは失われてしまい、 取り返しがつきません。</p></li><li><p><code>mirror</code> - ミラーリングは各ディスク上にあるすべてのデータの完全なコピーを保存します。 ミラーリングでは、並列にすべてのディスクからデータを読むため、 読み込みのパフォーマンスが向上します。 書き込みのパフォーマンスは、 データが並列にすべてのディスクに書き込まれるため、遅くなります。 1 つを除くすべてのディスクが壊れることを許容します。 このオプションを選択するには、 少なくとも 2 つのディスクを必要とします。</p></li><li><p><code>raid10</code> - ストライピングミラー。 最も効率は良いですが、ストレージ容量は少なくなります。 偶数のディスクが必要で、 少なくとも 4 つのディスクが必要です。</p></li><li><p><code>raidz1</code> - シングルパリティの RAID。 1 台のディスクの故障に耐えられます。 少なくとも 3 つのディスクが必要です。</p></li><li><p><code>raidz2</code> - ダブルパリティの RAID。 同時に 2 台のディスクの故障に耐えられます。 少なくとも 4 つのディスクが必要です。</p></li><li><p><code>raidz3</code> - トリプルパリティの RAID。 同時に 3 台のディスクの故障に耐えられます。 少なくとも 5 つのディスクが必要です。</p></li></ul></div><div class=paragraph><p><code>Pool Type</code> を選択したら、 利用可能なディスクの一覧が表示されます。 その後、プールを構成するディスクを、1 つまたは複数選択してください。
十分なディスクが選択されているかどうかについて検証が行われます。
検証に失敗するようであれば、<b class=button>&lt;Change Selection></b> を選択して、ディスクの一覧に戻ってください。
もしくは、 <b class=button>&lt;Back></b> を選択して <code>Pool Type</code> に戻ってください。</p></div><div id=bsdinstall-zfs-disk_select class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_select.png alt=プールに追加するディスクを選択するメニュー></div><div class=title>図 22. ディスクの選択</div></div><div id=bsdinstall-zfs-vdev_invalid class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_invalid.png alt=十分なディスクが選択されていないことを示しているメニュー></div><div class=title>図 23. 無効な選択</div></div><div class=paragraph><p>この一覧の中に抜けているディスクがある時や、 インストーラが立ち上がった後にディスクを接続した場合に、 最新の利用可能なディスクの一覧を見るには、 <b class=button>- Rescan Devices</b> を選択してください。</p></div><div id=bsdinstall-zfs-rescan-devices class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-rescan-devices.png alt=デバイスのリスキャン></div><div class=title>図 24. デバイスのリスキャン</div></div><div class=paragraph><p>アクシデントで間違ったディスクを削除してしまわないように、 <b class=button>- Disk Info</b> メニュー選択して、 各ディスクのパーティションテーブル、および、 デバイスモデル番号およびシリアル番号などのさまざまな情報を確認してください。</p></div><div id=bsdinstall-zfs-disk_info class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_info.png alt=パーティションの情報を表示しているメニュー></div><div class=title>図 25. ディスクの解析</div></div><div class=paragraph><p><kbd>N</kbd> を選択して、 <code>Pool Name</code> を設定してください。 希望する名前を入力後、 <b class=button>&lt;OK></b> を選択して確定するか、 <b class=button>&lt;Cancel></b> を押して、 デフォルト名のままでメインメニューに戻ってください。</p></div><div id=bsdinstall-zfs-pool-name class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-pool-name.png alt=プールの名前を入力するメニュー></div><div class=title>図 26. Pool Name</div></div><div class=paragraph><p><kbd>S</kbd> を選択してスワップの容量を設定してください。 必要なスワップ容量を入力し、 <b class=button>&lt;OK></b> を押して確定するか、 もしくは <b class=button>&lt;Cancel></b> を押して、 デフォルトの容量のまま、メインメニューに戻ってください。</p></div><div id=bsdinstall-zfs-swap-amount class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-swap-amount.png alt=スワップメモリの容量を入力するメニュー></div><div class=title>図 27. Swap 容量</div></div><div class=paragraph><p>すべてのオプションに希望する値を設定したら、メニューの上部にある <b class=button>>>> Install</b> オプションを選択してください。
インストーラは、最終確認として ZFS プールを作成するために選択したドライブの内容が削除されることをキャンセルできる最後の機会を提供してくれます。</p></div><div id=bsdinstall-zfs-warning class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-warning.png alt=データが削除されることをユーザに確認するメニュー></div><div class=title>図 28. 最終確認</div></div><div class=paragraph><p>GELI ディスク暗号化を有効にしていたら、ディスクを暗号化するために用いるパスフレーズを 2 度求められます。
その後、暗号の初期化が開始します。</p></div><div id=bsdinstall-zfs-geli_password class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-geli_password.png alt=デバイスを暗号化するためのパスワードを入力するメニュー></div><div class=title>図 29. ディスク暗号化パスワード</div></div><div id=bsdinstall-zfs-init-encription class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-init-encription.png alt=暗号の初期化が行われていることを示すメニュー></div><div class=title>図 30. 暗号の初期化</div></div><div class=paragraph><p>その後のインストールの過程は、通常通りに進みます。 インストールを進めるには、 <a href=#bsdinstall-fetching-distribution>配布ファイルのダウンロード</a> に進んでください。</p></div></div><div class=sect3><h4 id=bsdinstall-part-shell>2.6.5. シェルモードによるパーティションの作成<a class=anchor href=#bsdinstall-part-shell></a></h4><div class=paragraph><p>高度なインストールを行う上で、bsdinstall が提供するパーティション分割のメニューは柔軟性にかけることがあります。
手動でドライブの分割、ファイルシステムの作成、<code>/tmp/bsdinstall_etc/fstab</code> の作成、そして <code>/mnt</code> 以下へのファイルシステムのマウントを行うには、パーティションメニューで <b class=button>Shell</b> オプションを選択してください。
このオプションは高度な技術を持つユーザ向けです。
以上を実行したら、<code>exit</code> を実行して bsdinstall に戻り、インストールを続けてください。</p></div></div></div><div class=sect2><h3 id=bsdinstall-fetching-distribution>2.7. 配布ファイルのダウンロード<a class=anchor href=#bsdinstall-fetching-distribution></a></h3><div class=paragraph><p>インストールにかかる時間は、どのディストリビューションを選んだか、 どのインストールメディアを使ったか、 そしてコンピュータの速度にも依存します。 進行状況を表すメッセージが逐次表示されます。</p></div><div class=paragraph><p>まず最初に、インストーラは選択されているディスクをフォーマットし、 パーティションを初期化します。 <code>bootonly media</code> または <code>mini memstick</code> メディアを用いたインストールでは、 選択されたコンポーネントがダウンロードされます。</p></div><div id=bsdinstall-distfile-fetching class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-fetching.png alt=各コンポ―テントのダウンロード状況を表示しているメニュー></div><div class=title>図 31. 配布ファイルのダウンロード</div></div><div class=paragraph><p>次に、ダウンロードの際にエラーが含まれなかったか、 インストールメディアからの読み取り中に読み間違いが起きなかったかどうか等、 配布ファイルの完全性の検証が行われます。</p></div><div id=bsdinstall-distfile-verify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-verifying.png alt=各コンポーネントの検証状況を表示しているメニュー></div><div class=title>図 32. 配布ファイルの検証</div></div><div class=paragraph><p>最後に、検証された配布ファイルがディスクへ展開されます。</p></div><div id=bsdinstall-distfile-extract class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-extracting.png alt=配布ファイルの展開状況を表示しているメニュー></div><div class=title>図 33. 配布ファイルの展開</div></div><div class=paragraph><p>必要な配布ファイルがすべて展開されると、 bsdinstall は、 インストール後の設定画面を表示します。 利用可能なインストール後のオプションについては次の章で説明します。</p></div></div><div class=sect2><h3 id=bsdinstall-post>2.8. ネットワークインターフェース、アカウント、タイムゾーン、 サービスおよびセキュリティオプションの設定<a class=anchor href=#bsdinstall-post></a></h3><div class=sect3><h4 id=bsdinstall-post-root>2.8.1. <code>root</code> パスワードの設定<a class=anchor href=#bsdinstall-post-root></a></h4><div class=paragraph><p>最初に <code>root</code> のパスワードを設定する必要があります。
パスワードを入力している際には、入力している文字は画面に表示されません。
入力ミスを防ぐため、パスワードは 2 回入力する必要があります。</p></div><div id=bsdinstall-post-set-root-passwd class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-post-root-passwd.png alt="root ユーザのパスワードを入力するメニュー"></div><div class=title>図 34. <code>root</code> パスワードの設定</div></div></div><div class=sect3><h4 id=bsdinstall-config-network-dev>2.8.2. ネットワークインタフェースの設定<a class=anchor href=#bsdinstall-config-network-dev></a></h4><div class=paragraph><p>次に、コンピュータが認識したすべてのネットワークインタフェースが表示されます。
設定するネットワークインタフェースを選んでください。</p></div><div id=bsdinstall-configure-net-interface class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface.png alt=設定を行うネットワークインタフェースを選択するメニュー></div><div class=title>図 35. イーサネットインタフェースの選択</div></div><div class=paragraph><p>イーサネットインタフェースを選択すると、<a href=#bsdinstall-configure-net-ipv4>IPv4 ネットワークの選択</a> で表示されるメニューが表示されます。
ワイヤレスネットワークを選択すると、システムはワイヤレスアクセスポイントをスキャンします。</p></div><div id=bsdinstall-wireless-scan class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-scan.png alt=ワイヤレスネットワークのスキャンの進捗を表示しているメニュー></div><div class=title>図 36. ワイヤレスアクセスポイントのスキャン</div></div><div class=paragraph><p>ワイヤレスネットワークは Service Set Identifier (SSID) によって識別されます。
SSID は、それぞれのネットワークに与えられる、短く、一意的な名前です。
スキャンで見つかった SSID は、そのネットワークで利用できる暗号化のタイプの説明とともに一覧で表示されます。
もし、期待した SSID が一覧に表示されていなければ、<b class=button>Rescan</b> を選択してもう一度スキャンしてください。
それでもなお期待したネットワークが表示されなければ、接続のためのアンテナに問題がないかを確認したり、コンピュータをアクセスポイントの近くに移動してみてください。
その後もう一度スキャンしてください。</p></div><div id=bsdinstall-wireless-accesspoints class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-accesspoints.png alt=接続できるワイヤレスネットワークが表示されているメニュー></div><div class=title>図 37. ワイヤレスネットワークの選択</div></div><div class=paragraph><p>次に、ワイヤレスネットワークに接続するための暗号情報を入力してください。
WEP のような古い暗号の安全性は低いので、WPA2 暗号が強く推奨されます。
WPA2 を使用してるネットワークでは、Pre-Shared Key (PSK) と呼ばれるパスワードを入力してください。
セキュリティ上の観点から、入力ボックスに入力した文字はアスタリスクで表示されます。</p></div><div id=bsdinstall-wireless-wpa2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-wpa2setup.png alt=ワイヤレスネットワークのパスワードを入力するメニュー></div><div class=title>図 38. WPA2 のセットアップ</div></div><div class=paragraph><p>次に、イーサネットもしくはワイヤレスインタフェースに対して、IPv4 を設定するかどうかを選択します。</p></div><div id=bsdinstall-configure-net-ipv4 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4.png alt="選択したネットワークインターフェースに対して IPv4 の設定を行うかどうかを確認するメニュー"></div><div class=title>図 39. IPv4 ネットワークの選択</div></div><div class=paragraph><p>IPv4 の設定方法は 2 通りあります。
<em>DHCP</em> はネットワークインタフェースを自動的に適切に設定する方法で、DHCP サーバのあるネットワークでは使用すべきです。
DHCP を利用できない環境では、静的な設定として、ネットワークのアドレス情報を手動で入力する必要があります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>適当なネットワーク情報を入力しても動かないので、DHCP サーバが利用できなのであれば、ネットワーク管理者またはサービスプロバイダから <a href=#bsdinstall-collect-network-information>必要となるネットワーク情報</a> に示されている情報を入手してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>DHCP サーバを利用できるのであれば、次のメニューで <b class=button>Yes</b> を選択して、ネットワークインタフェースの設定を自動的に行ってください。
DHCP サーバを検索し、システムに対するアドレス情報を入手する間、インストーラは少しの間停止しているように表示されます。</p></div><div id=bsdinstall-net-ipv4-dhcp class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-dhcp.png alt="選択したインターフェースに対して DHCP で設定を行うかを選択するメニュー"></div><div class=title>図 40. IPv4 DHCP 設定の選択</div></div><div class=paragraph><p>DHCP サーバを利用できない環境では、<b class=button>No</b> を選択し、新しく表示されるメニューにおいて以下のようなアドレス情報を入力してください。</p></div><div id=bsdinstall-net-ipv4-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-static.png alt="IPv4 ネットワークを設定するメニュー"></div><div class=title>図 41. 静的な IPv4 の設定</div></div><div id=bsdinstall-collect-network-information class=ulist><ul><li><p><code>IP Address</code> - コンピュータに与える IPv4 アドレスです。 このアドレスは一意的である必要があるため、ローカルネットワーク上の他のデバイスですでに使われているアドレスは使えません。</p></li><li><p><code>Subnet Mask</code> - ネットワークのサブネットマスクです。</p></li><li><p><code>Default Router</code> - このネットワークのデフォルトゲートウェイの IP アドレスです。</p></li></ul></div><div class=paragraph><p>次の画面では、インタフェースを IPv6 で設定すべきかを選択します。
IPv6 が利用でき、希望するのであれば、 <b class=button>Yes</b> を選択してください。</p></div><div id=bsdinstall-net-ipv6 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6.png alt="選択したネットワークインターフェースに対して IPv6 の設定を行うかどうかを確認するメニュー"></div><div class=title>図 42. IPv6 ネットワークの選択</div></div><div class=paragraph><p>IPv6 の設定に関しても 2 つの方法があります。
StateLess Address AutoConfiguration (SLAAC) は、ローカルルータから適切なネットワーク設定情報を入手するように、自動的にリクエストします。
詳細については <a href=http://tools.ietf.org/html/rfc4862>rfc4862</a> を参照してください。
静的な設定では、ネットワーク情報を手動で入力する必要があります。</p></div><div class=paragraph><p>IPv6 ルータを利用できるのであれば、次のメニューで <b class=button>Yes</b> を選択し、ネットワークインタフェースの設定を自動的に行ってください。
インストーラはルータを見つけ出し、システムに対するアドレス情報を入手するため、 少しの間停止しているように表示されます。</p></div><div id=bsdinstall-net-ipv6-slaac class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-slaac.png alt="選択したネットワークインターフェースに対して SLAAC の設定を行うかどうかを確認するメニュー]"></div><div class=title>図 43. IPv6 SLAAC 設定の選択</div></div><div class=paragraph><p>IPv6 ルータが利用できない環境では、<b class=button>No</b> を選択して、表示されるメニューで以下のアドレス情報を入力する必要があります。</p></div><div id=bsdinstall-net-ipv6-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6-static.png alt="IPv6 ネットワークを設定するメニュー"></div><div class=title>図 44. IPv6 の静的な設定</div></div><div class=ulist><ul><li><p><code>IPv6 Address</code> - このコンピュータに割り当てられた IPv6 アドレスです。このアドレスは一意的である必要があるため、ローカルネットワーク上の他のデバイスですでに使われているアドレスは使えません。</p></li><li><p><code>Default Router</code> - このネットワークのデフォルトゲートウェイの IPv6 アドレスです。</p></li></ul></div><div class=paragraph><p>最後のネットワークメニューでは、ホスト名とネットワークアドレスを変換する Domain Name System (DNS) リゾルバを設定します。
すでに DHCP または SLAAC を使って自動的にネットワークインタフェースを設定したのであれば、<code>Resolver Configuration</code> には値がすでに入っているでしょう。
そうでなければ、<code>Search</code> フィールドにローカルネットワークのドメイン名を入力してください。
<code>DNS</code> #1 および <code>DNS</code> #2 は、ローカル DNS サーバの IPv4 または IPv6 アドレスです。
少なくとも、1 つの DNS サーバは必要です。</p></div><div id=bsdinstall-net-dns-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-ipv4-dns.png alt="ネットワークの DNS を設定するメニュー"></div><div class=title>図 45. DNS の設定</div></div><div class=paragraph><p>ネットワーク接続の設定が終わったら、FreeBSD をインストールするコンピュータと同じ地域のミラーサイトを選んでください。
ターゲットコンピュータの近くのミラーサイトを選択できれば、ファイルのダウンロードは早く終わるので、インストールの時間は短くなります。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><a href=ftp://ftp.freebsd.org class=bare>ftp://ftp.freebsd.org</a> (Main Site)` を選択すると、最も近いミラーに自動的にルーティングします。</p></div></td></tr></tbody></table></div><div id=bsdinstall-netinstall-mirror class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-mirrorselect.png alt=ミラーサイトを選択するメニュー></div><div class=title>図 46. ミラーサイトの選択</div></div></div><div class=sect3><h4 id=bsdinstall-timezone>2.8.3. タイムゾーンの設定<a class=anchor href=#bsdinstall-timezone></a></h4><div class=paragraph><p>次のメニューでは、地域、国、タイムゾーンを指定します。 使用しているシステムのタイムゾーンを設定することで、 夏時間などの地域による時刻の違いが自動的に調整され、 タイムゾーンに関連した機能が適切に取り扱われます。</p></div><div class=paragraph><p>ここでの例は、 欧州スペインのメインランドタイムゾーンにあるコンピュータに対するものです。 実際の地理的位置に対応するタイムゾーンを設定してください。</p></div><div id=bsdinstall-timezone-region class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-region.png alt=地域を選択するメニュー></div><div class=title>図 47. 地域の選択</div></div><div class=paragraph><p>矢印キーを使って、適切な地域を選択し、 <kbd>Enter</kbd> を押してください。</p></div><div id=bsdinstall-timezone-country class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-country.png alt=国名を選択するメニュー></div><div class=title>図 48. 国名の選択</div></div><div class=paragraph><p>矢印キーを使って、適切に国名を選び、 <kbd>Enter</kbd> を押してください。</p></div><div id=bsdinstall-timezone-zone class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-zone.png alt=タイムゾーンを選択するメニュー></div><div class=title>図 49. タイムゾーンの選択</div></div><div class=paragraph><p>矢印キーを使って適切なタイムゾーンを選択し、 <kbd>Enter</kbd> を押してください。</p></div><div id=bsdinstall-timezone-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-confirm.png alt=タイムゾーンを確定するメニュー></div><div class=title>図 50. タイムゾーンの確定</div></div><div class=paragraph><p>タイムゾーンの省略形が正しいかどうかを確認してください。</p></div><div id=bsdinstall-timezone-date class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-date.png alt=システムの日付を設定するメニュー></div><div class=title>図 51. 日付の設定</div></div><div class=paragraph><p>矢印キーを使って適切な日付を選択したら、 <b class=button>Set Date</b> を押してください。 <b class=button>Skip</b> を押すと日付の設定をスキップできます。</p></div><div id=bsdinstall-timezone-time class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-time.png alt=システムの時刻を設定するメニュー></div><div class=title>図 52. 時刻の設定</div></div><div class=paragraph><p>矢印キーを使って適切な時刻に設定したら、 <b class=button>Set Time</b> を押してください。 <b class=button>Skip</b> を押すと時刻の設定をスキップできます。</p></div></div><div class=sect3><h4 id=bsdinstall-sysconf>2.8.4. サービスを有効にする<a class=anchor href=#bsdinstall-sysconf></a></h4><div class=paragraph><p>次のメニューでは、システムが起動した時に、 起動するシステムサービスを設定します。 これらのサービスはすべてオプションです。 システムの機能として必要なサービスだけを起動するようにしてください。</p></div><div id=bsdinstall-config-serv class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-services.png alt=利用可能なサービスを表示しているメニュー></div><div class=title>図 53. 追加で有効にするサービスの選択</div></div><div class=paragraph><p>このメニューで有効にできるサービスは以下の通りです。</p></div><div class=ulist><ul><li><p><code>local_unbound</code> - DNS のローカル unbound を有効にします。この設定は、ローカルキャッシュフォワードリゾルバとしての利用のみを想定しています。ネットワーク全体のリゾルバを設定したいのであれば、 <a class=package href=https://cgit.freebsd.org/ports/tree/dns/unbound/>dns/unbound</a> をインストールしてください。</p></li><li><p><code>sshd</code> - セキュアシェル (SSH) デーモンは、 暗号化された接続上でリモートアクセスするために使われます。 システムがリモートログインを必要とする場合のみ、 このサービスを有効にしてください。</p></li><li><p><code>moused</code> - システムのコンソールで、 マウスを利用する時に、このサービスを有効にしてください。</p></li><li><p><code>ntpdate</code> - 起動時の自動時刻同期を有効にします。 この機能は、現在 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> デーモンでも利用できます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> ユーティリティは近々その役目を終える予定です。</p></li><li><p><code>ntpd</code> - 自動時刻同期のための The Network Time Protocol (NTP) デーモンを有効にします。リモートタイムサーバまたはプールとシステムの時刻を同期する場合は、このサービスを有効にしてください。</p></li><li><p><code>powerd</code> - 電源の管理およびエネルギーを節約するための電源コントロールユーティリティ</p></li><li><p><code>dumpdev</code> - システムのデバッグを行う上で、クラッシュダンプは有用なので、可能であれば有効にすると良いでしょう。</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-hardening>2.8.5. セキュリティを強化するオプションを有効にする<a class=anchor href=#bsdinstall-hardening></a></h4><div class=paragraph><p>次のメニューでは、 有効にするセキュリティオプションを設定します。 すべてはオプションですが、有効にすることが推奨されます。</p></div><div id=bsdinstall-hardening-options class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-hardening.png alt=セキュリティを強化するオプションを表示しているメニュー></div><div class=title>図 54. セキュリティを強化するオプションの設定</div></div><div class=paragraph><p>このメニューで有効にできるのは、以下のオプションです。</p></div><div class=ulist><ul><li><p><code>hide_uids</code> - 他のユーザが実行しているプロセス (UID) を隠します。
特権のないユーザが、他のユーザにより実行されているプロセスを見れないようにします。</p></li><li><p><code>hide_gids</code> - 他のグループが実行しているプロセスを隠します。
特権のないユーザが、他のグループ (GID) により実行されているプロセスを見れないようにします。</p></li><li><p><code>hide_jail</code> - jail で実行中のプロセスを隠します。
特権のないユーザが、jail の中で実行されているプロセスを見れないようにします。</p></li><li><p><code>read_msgbuf</code> - 権限のないユーザが、カーネルメッセージバッファを読めなくします。
権限のないユーザが、<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> を使ってカーネルログバッファのメッセージを見れないようにします。</p></li><li><p><code>proc_debug</code> - 権限のないユーザ対するプロセスデバッキング機能を無効にします。
<code>ptrace()</code> および <code>ktrace()</code> といった procfs 機能を含む、権限のないプロセス間のデバッキングサービスを無効にします。
このオプションによって、PHP などのスクリプト言語に対する組み込みのデバッキング機能と同様に、<a href="https://man.freebsd.org/cgi/man.cgi?query=lldb&amp;sektion=1&amp;format=html">lldb(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=truss&amp;sektion=1&amp;format=html">truss(1)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=procstat&amp;sektion=1&amp;format=html">procstat(1)</a> などの権限のないユーザによるデバッキングツールも無効になります。</p></li><li><p><code>random_pid</code> - プロセスの PID をランダム化します。</p></li><li><p><code>clear_tmp</code> - システムの起動時に <code>/tmp</code> を空にします。</p></li><li><p><code>disable_syslogd</code> - syslogd ネットワークソケットを閉じます。
デフォルトでは、FreeBSD は syslogd を <code>-s</code> を使った安全な方法で実行します。
これは、外からのポート 514 に対する UDP リクエストを待機しません。
このオプションを有効にすると、syslogd を <code>-ss</code> 付きで実行します。
これにより、syslogd は空いているどのポートからも受け付けません。
詳細は、<a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> をご覧ください。</p></li><li><p><code>disable_sendmail</code> - sendmail MTA を無効にします。</p></li><li><p><code>secure_console</code> - シングルユーザモードに入る際に、コマンドプロンプトに対して <code>root</code> パスワードが必要となります。</p></li><li><p><code>disable_ddtrace</code> - DTrace は、 実行中のカーネルに影響を及ぼすモードで実行できます。
破壊的なアクションは、明示的に有効にしない限りは利用できません。
このオプションを有効にするには、DTrace を実行する際に <code>-w</code> を使ってください。
詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=dtrace&amp;sektion=1&amp;format=html">dtrace(1)</a> をご覧ください。</p></li><li><p><code>enable_aslr</code> - アドレス空間配置のランダム化を有効にします。アドレス空間配置のランダム化の詳細については <a href=https://en.wikipedia.org/wiki/Address_space_layout_randomization>Wikipedia article</a> をご覧ください。</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-addusers>2.8.6. ユーザの追加<a class=anchor href=#bsdinstall-addusers></a></h4><div class=paragraph><p>次のメニューでは、少なくとも一人のユーザを追加してください。 システムには <code>root</code> ではなく、ユーザアカウントでログインすることが推奨されています。 <code>root</code> 権限でログインすると、実行に対して制限がなく、また、保護されません。 通常のユーザでログインすることにより、 安全でセキュリティ的に危険が少なくなります。</p></div><div class=paragraph><p><b class=button>Yes</b> を選択し、 新しいユーザを追加してください。</p></div><div id=bsdinstall-add-user1 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser1.png alt=システムにユーザを作成するか選択するメニュー></div><div class=title>図 55. 新しいユーザのアカウントの作成</div></div><div class=paragraph><p>プロンプトに従い、 ユーザアカウントの作成で必要となる情報を入力してください。 <a href=#bsdinstall-add-user2>ユーザ情報の入力</a> で示されている例では、<code>asample</code> ユーザアカウントを作成します。</p></div><div id=bsdinstall-add-user2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser2.png alt=追加するユーザの情報を入力しているメニュー></div><div class=title>図 56. ユーザ情報の入力</div></div><div class=paragraph><p>以下は、入力情報のまとめです。</p></div><div class=ulist><ul><li><p><code>Username</code> - ログイン時のユーザ名を入力します。一般的な慣習では、 ファーストネームの最初の文字とラストネームを、 ユーザ名がシステムで一意的になる長さで組み合わせます。 ユーザ名は、大文字と小文字を区別し、 空白を含んではいけません。</p></li><li><p><code>Full name</code> - ユーザのフルネーム。 空白を含むことは可能です。 また、この情報はユーザアカウントの説明の記述に使われます。</p></li><li><p><code>Uid</code> - ユーザ ID 番号。 通常は、システムが自動的に割り当てるように、 空欄のままにします。</p></li><li><p><code>Login group</code> - 新しいユーザのログイングループ。 空欄のままにすると、デフォルトに割り当てられます</p></li><li><p><code>Invite <em>user</em> into other groups?</code> - ユーザを別のグループのメンバーとして追加するかどうか。 ユーザが管理者としてのアクセス必要であれば、 ここで <code>wheel</code> を入力してください。</p></li><li><p><code>Login class</code> - 空欄にするとデフォルトの設定になります。</p></li><li><p><code>Shell</code> - 一覧の中から、ユーザのシェルを入力してください。 シェルに関する詳細については <a href=./#shells>シェル</a> をご覧ください。</p></li><li><p><code>Home directory</code> - ユーザのホームディレクトリ。 通常は、デフォルトの場所が適切です。</p></li><li><p><code>Home directory permissions</code> - ユーザのホームディレクトリの権限。 通常は、デフォルトが適切です。</p></li><li><p><code>Use password-based authentication?</code> - 通常は、ユーザがログイン時にパスワードの入力が要求されるように <code>yes</code> と入力してください。</p></li><li><p><code>Use an empty password?</code> - 空のパスワードは安全ではないので、通常は <code>no</code> です。</p></li><li><p><code>Use a random password?</code> - 通常は、次のプロンプトでユーザ自身のパスワードを入力できるように、 <code>no</code> です。</p></li><li><p><code>Enter password</code> - ユーザのパスワードです。入力している文字は画面に表示されません。</p></li><li><p><code>Enter password again</code> - 確認のため、パスワードをもう一度入力します。</p></li><li><p><code>Lock out the account after creation?</code> - 通常は、ユーザがログインできるようにするため、 <code>no</code> です。</p></li></ul></div><div class=paragraph><p>すべての詳細を入力したら、サマリが表示され、 正しいかどうかの確認を求められます。
入力した情報に間違いがあれば、 <code>no</code> を入力して修正してください。
すべてが正しく入力されていれば、 <code>yes</code> を入力して新しいユーザを作成してください。</p></div><div id=bsdinstall-add-user3 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser3.png alt=追加するユーザの情報が正しかを確認しているメニュー></div><div class=title>図 57. ユーザおよびグループの管理を終了する</div></div><div class=paragraph><p>さらにユーザを追加するのであれば、 <code>Add another user?</code> の質問に対し、 <code>yes</code> を入力してください。 <code>no</code> を入力すると、ユーザの追加が終わり、次に進みます。</p></div><div class=paragraph><p>ユーザの追加や、ユーザ管理の詳細については、 <a href=./#users-synopsis>ユーザと基本的なアカウント管理</a> を参照してください。</p></div></div><div class=sect3><h4 id=bsdinstall-final-conf>2.8.7. 最後の設定<a class=anchor href=#bsdinstall-final-conf></a></h4><div class=paragraph><p>すべてをインストールし、設定が終わった後に、 最後に設定を修正する機会が与えられます。</p></div><div id=bsdinstall-final-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-finalconfiguration.png alt=インストールを終わる前に、ユーザを追加したり、タイムゾーンなどを設定するためのメニュー></div></div><div class=paragraph><p>インストールを完了する前に、このメニューを使って変更、または、追加の設定を行なってください。</p></div><div class=ulist><div class=title>最終の設定オプション</div><ul><li><p><code>Add User</code> - <a href=#bsdinstall-addusers>ユーザの追加</a> で説明しています。</p></li><li><p><code>Root Password</code> - <a href=#bsdinstall-post-root><code>root</code> パスワードの設定</a> で説明しています。</p></li><li><p><code>Hostname</code> - <a href=#bsdinstall-hostname>ホスト名の設定</a> で説明しています。</p></li><li><p><code>Network</code> - <a href=#bsdinstall-config-network-dev>ネットワークインタフェースの設定</a> で説明しています。</p></li><li><p><code>Services</code> - <a href=#bsdinstall-sysconf>サービスを有効にする</a> で説明しています。</p></li><li><p><code>System Hardening</code> - <a href=#bsdinstall-hardening>セキュリティを強化するオプションを有効にする</a> で説明しています。</p></li><li><p><code>Time Zone</code> - <a href=#bsdinstall-timezone>タイムゾーンの設定</a> で説明しています。</p></li><li><p><code>Handbook</code> - FreeBSD ハンドブックのダウンロードとインストール。</p></li></ul></div><div class=paragraph><p>設定が完了したら、<b class=button>Exit</b> を選んでください。</p></div><div id=bsdinstall-final-modification-shell class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-modification-shell.png alt=インストールが終わり、追加でシェルを開いて手動で変更を行うかどうかを確認しているメニュー></div><div class=title>図 58. Manual Configuration</div></div><div class=paragraph><p>新しいシステムを再起動する前に、 bsdinstall は追加の設定が必要かどうかを尋ねてきます。
<b class=button>Yes</b> を選択して新しいシステムのシェルに入るか、または <b class=button>No</b> を選択して、インストールの最後のステップに進んでください。</p></div><div id=bsdinstall-final-main class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-mainexit.png alt="インストールが終了し、システムを再起動するか、Live CD にアクセスするかを選択するメニュー"></div><div class=title>図 59. インストールの終了</div></div><div class=paragraph><p>追加の設定や、特別なセットアップが必要であれば、 <b class=button>Live CD</b> を選んでインストールメディアを Live CD で起動してください。</p></div><div class=paragraph><p>インストールが終わったら、 <b class=button>Reboot</b> を選んで、 コンピュータを再起動し、新しい FreeBSD システムで起動してください。
再起動する前には、忘れずに FreeBSD インストールメディアを外してください。
さもないと、もう一度インストールメディアから起動してしまいます。</p></div><div class=paragraph><p>FreeBSD の起動時には、多くのメッセージが画面に表示されます。
システムの起動後には、ログインプロンプトが表示されます。
<code>login:</code> プロンプトで、インストール時に追加したユーザ名を入力してください。 <code>root</code> でのログインは避けてください。
管理者の権限が必要となった時に、スーパユーザになる方法については、<a href=./#users-superuser>スーパーユーザアカウント</a> を参照してください。</p></div><div class=paragraph><p>起動時に表示されていたメッセージは、 <kbd>Scroll-Lock</kbd> を押し、scroll-back buffer で見ることができます。
<kbd>PgUp</kbd>, <kbd>PgDn</kbd> そして矢印キーでメッセージをスクロールバックできます。
メッセージの確認が終わったら、<kbd>Scroll-Lock</kbd> をもう一度押すと、ディスプレイのロックを外し、 コンソールに戻ることができます。
何度かシステムを起動した後で、これらのメッセージを見るには、コマンドプロンプトから <code>less /var/run/dmesg.boot</code> と入力してください。
確認後に <kbd>q</kbd> を押すと、 コマンドラインに戻ります。</p></div><div class=paragraph><p><a href=#bsdinstall-config-serv>追加で有効にするサービスの選択</a> で sshd を有効に設定した場合には、最初の起動時にシステムが SSH ホストキーを生成するため、少々時間がかかるかもしれません。
その後の起動はより速くなるでしょう。
鍵のフィンガープリントは、以下の例のように表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Generating public/private rsa1 key pair.
Your identification has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.
Your public key has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.pub.
The key fingerprint is:
10:a0:f5:af:93:ae:a3:1a:b2:bb:3c:35:d9:5a:b3:f3 root@machine3.example.com
The key<span class=s1>&#39;s randomart image is:
+--[RSA1 1024]----+
|    o..          |
|   o . .         |
|  .   o          |
|       o         |
|    o   S        |
|   + + o         |
|o . + *          |
|o+ ..+ .         |
|==o..o+E         |
+-----------------+
Generating public/private dsa key pair.
Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
The key fingerprint is:
7e:1c:ce:dc:8a:3a:18:13:5b:34:b5:cf:d9:d1:47:b2 root@machine3.example.com
The key&#39;</span>s randomart image is:
+--[ DSA 1024]----+
|       ..     <span class=nb>.</span> .|
|      o  <span class=nb>.</span>   <span class=nb>.</span> + |
|     <span class=nb>.</span> ..   <span class=nb>.</span> E .|
|    <span class=nb>.</span> <span class=nb>.</span>  o o <span class=nb>.</span> <span class=nb>.</span> |
|     +  S <span class=o>=</span> <span class=nb>.</span>    |
|    +  <span class=nb>.</span> <span class=o>=</span> o     |
|     +  <span class=nb>.</span> <span class=k>*</span> <span class=nb>.</span>    |
|    <span class=nb>.</span> <span class=nb>.</span>  o <span class=nb>.</span>     |
|      .o. <span class=nb>.</span>      |
+-----------------+
Starting sshd.</code></pre></div></div><div class=paragraph><p>フィンガープリントおよび SSH についての詳細については、<a href=./#openssh>OpenSSH</a> をご覧ください。</p></div><div class=paragraph><p>FreeBSD はデフォルトでは、グラフィカルな環境をインストールしません。 グラフィカルなウィンドウマネージャのインストール、 および設定に関するより多くの情報については、 <a href=./#x11>X Window System</a> をご覧ください。</p></div><div class=paragraph><p>適切に FreeBSD をシャットダウンすることは、 ハードウェアをダメージから守ったり、データの保護につながります。 <em>システムを適切にシャットダウンする前に、 電源を落すということはしないでください!</em><code>wheel</code> グループのメンバとなっているユーザは、 コマンドラインから <code>su</code> と入力し、 <code>root</code> のパスワードを入力してスーパユーザとなってください。 その後、<code>shutdown -p now</code> と入力すると、システムは正しくシャットダウンし、 ハードウェアが対応していれば、電源が落ちます。</p></div></div></div><div class=sect2><h3 id=bsdinstall-install-trouble>2.9. トラブルシューティング<a class=anchor href=#bsdinstall-install-trouble></a></h3><div class=paragraph><p>この章では、インストールの際の、 これまで報告された共通の問題に対する解決のための情報が書いてあります。</p></div><div class=paragraph><p><a href=https://www.FreeBSD.org/ja/releases/>FreeBSD リリース情報</a> ページにあるインストールする FreeBSD のバージョンのハードウェアノートを調べて、 使用しているハードウェアに対応しているかどうかを確認してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>いくつかのインストール上の問題は、さまざまなハードウェア装置、 特にマザーボードのファームウェアのアップデートで回避または緩和することができます。 マザーボードのファームウェアは、通常 BIOS と呼ばれます。 多くのマザーボードまたはコンピュータ製造メーカーは、 アップデートやアップグレード情報を載せているウェブサイトを用意しています。</p></div><div class=paragraph><p>通常、製造メーカーは、 重要な更新のようなそれなりの理由がない限り、マザーボードの BIOS のアップグレードは行わないよう推奨しています。 アップデートの過程で失敗する<em>可能性があり</em>、 その場合 BIOS が不完全な状態になり、 コンピュータが動作しない原因となり得るからです。</p></div></td></tr></tbody></table></div><div class=paragraph><p>システムの起動時に、ハードウェアの検出中にシステムが固まったり、インストールプロセスでおかしな振る舞いをする場合には、ACPI が原因の可能性があります。
i386 および amd64 プラットフォームにおいて、 FreeBSD はシステムの設定を手助けするシステム ACPI サービスを、 起動時に検出された場合に広く使います。 残念ながら、まだいくつかの不具合が、 ACPI ドライバとシステムのマザーボードおよび BIOS ファームウェア両方に存在しています。 起動ステージ 3 において、ヒント情報 <code>hint.acpi.0.disabled</code> を以下のように設定すると ACPI を無効にできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nb>set </span>hint.acpi.0.disabled<span class=o>=</span><span class=s2>&#34;1&#34;</span></code></pre></div></div><div class=paragraph><p>この設定はシステムが起動するたびにリセットされるので、<code>/boot/loader.conf</code> ファイルに <code>hint.acpi.0.disabled="1"</code> を追加する必要があります。
ブートローダのより詳しい情報については <a href=./#boot-synopsis>FreeBSD の起動のプロセス</a> で説明します。</p></div></div><div class=sect2><h3 id=using-live-cd>2.10. Live CD を使う<a class=anchor href=#using-live-cd></a></h3><div class=paragraph><p><a href=#bsdinstall-choose-mode>ウェルカムメニュー</a> で示されている bsdinstall のウェルカムメニューは、 <b class=button>Live CD</b> オプションを提供します。 これは、 オペレーティングシステムに FreeBSD を使うべきかどうか迷っていて、 インストール前に機能を試して見たいと思っている方に有用です。</p></div><div class=paragraph><p><b class=button>Live CD</b> を使う際は、以下のことに気をつけてください。</p></div><div class=ulist><ul><li><p>システムにアクセスする際には、認証を求められます。 ユーザ名は <code>root</code>、 パスワードは空欄としてください。</p></li><li><p>システムはインストールメディアから直接起動するので、 ハードディスクにインストールされたシステムに比べ、 パフォーマンスはかなり遅い可能性があります。</p></li><li><p>このオプションのユーザインタフェースは、 コマンドプロンプトのみです。 グラフィカルなユーザインタフェースではありません。</p></li></ul></div></div></div></div><div class=sect1><h2 id=basics>Chapter 3. FreeBSD の基礎知識<a class=anchor href=#basics></a></h2><div class=sectionbody><div class=sect2><h3 id=basics-synopsis>3.1. この章では<a class=anchor href=#basics-synopsis></a></h3><div class=paragraph><p>この章では FreeBSD オペレーティングシステムの基本的なコマンドと機能について記述しています。
ここに書かれてあることのほとんどは、どんな UNIX® -like なオペレーティングシステムにもあてはまります。
FreeBSD の初心者であれば、この章を読んでおいた方がきっといいはずです。</p></div><div class=paragraph><p>この章を読んで分かることは、次のようなことです。</p></div><div class=ulist><ul><li><p>仮想コンソールの使い方と設定方法</p></li><li><p>FreeBSD システム上でユーザやグループを作成し管理する方法</p></li><li><p>UNIX® のファイルの許可属性の仕組みと FreeBSD のファイルフラグについて</p></li><li><p>FreeBSD のファイルシステムの構成</p></li><li><p>FreeBSD のディスク構成</p></li><li><p>ファイルシステムをマウント、アンマウントする方法</p></li><li><p>プロセス、デーモンとシグナルとはなにか</p></li><li><p>シェルとはなにか。 また、デフォルトのログイン環境を変える方法</p></li><li><p>テキストエディタの基本的な使い方</p></li><li><p>デバイスおよびデバイスノードとはなにか</p></li><li><p>さらに詳しい情報を得るためのマニュアルページの読み方</p></li></ul></div></div><div class=sect2><h3 id=consoles>3.2. 仮想コンソールと端末<a class=anchor href=#consoles></a></h3><div class=paragraph><p>起動時に自動的にグラフィカルな環境が起動するように FreeBSD を設定していなければ、システムが起動すると、以下のようなコマンドラインのログインプロンプトが表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>FreeBSD/amd64 <span class=o>(</span>pc3.example.org<span class=o>)</span> <span class=o>(</span>ttyv0<span class=o>)</span>

login:</code></pre></div></div><div class=paragraph><p>最初の行はシステムの情報です。
<code>amd64</code> は、このシステム上で 64 ビット版の FreeBSD が動作していることを示しています。
ホスト名は <code>pc3.example.org</code>、<code>ttyv0</code> は "システムコンソール" であることを示しています。
次の行はログインプロンプトです。</p></div><div class=paragraph><p>FreeBSD はマルチユーザシステムなので、ユーザを区別する何がしかの手段が必要です。
システム上のプログラムを実行できるようになるには、すべてのユーザに対してシステムにログインすることが義務付けられています。
すべてのユーザは、一意な "ユーザ名" と "パスワード" を持っています。</p></div><div class=paragraph><p>システムコンソールにログインするには、システムのインストール時に <a href=./#bsdinstall-addusers>ユーザの追加</a> で追加したユーザ名を入力して、<kbd>Enter</kbd> を押してください。
次にそのユーザのパスワードを入力して、<kbd>Enter</kbd> を押してください。
セキュリティの観点から、パスワードは <em>表示されません</em>。</p></div><div class=paragraph><p>パスワードを正確に入力したら、日々のメッセージ (MOTD) が表示され、
コマンドプロンプトが表示されます。
ユーザ作成時に選択したシェルに依存しますが、このプロンプトは <code>#</code>, <code>$</code> または <code>%</code> といった記号です。
プロンプトはユーザが FreeBSD のシステムコンソールへログインし、利用可能なコマンドを実行する準備ができていることを示しています。</p></div><div class=sect3><h4 id=consoles-virtual>3.2.1. 仮想コンソール<a class=anchor href=#consoles-virtual></a></h4><div class=paragraph><p>システムコンソールからシステムに対話的にコマンドを実行できますが、FreeBSD システム上でキーボードによりコマンドラインから利用しているユーザは、通常代わりに仮想コンソールにログインします。
デフォルトではシステムからのメッセージはシステムコンソールに出力され、これらのメッセージが、ユーザが作業しているコマンドまたはファイル上に表示されるため、ユーザが現在の作業に集中できなくなるためです。</p></div><div class=paragraph><p>デフォルトでは FreeBSD は、複数の仮想コンソールを表示してコマンドを入力できるように設定されています。
各仮想コンソールは、個別のログインプロンプトおよびシェルを持っており、簡単に仮想コンソール間の切り替えができます。
これにより、グラフィカルな環境において同時に複数のウィンドウを開いてコマンドラインの環境を提供できます。</p></div><div class=paragraph><p>FreeBSD では <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span> から <span class=keyseq><kbd>Alt</kbd>+<kbd>F8</kbd></span> までのキーの組み合わせが、仮想コンソール間の切り替えに予約されています。
システムコンソール (<code>ttyv0</code>) に切り替えるには、<span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span> を使ってください。
最初の仮想コンソール (<code>ttyv1</code>) にアクセスするには <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span>、2 番目の仮想コンソール (<code>ttyv2</code>) にアクセスするには <span class=keyseq><kbd>Alt</kbd>+<kbd>F3</kbd></span>、といったように使ってください。
Xorg をグラフィカルなコンソールとして使用しているときには、<span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd></span> の組み合わせを使用すると、テキストベースの仮想コンソールへ戻ります。</p></div><div class=paragraph><p>あるコンソールから他に切り替えるのに応じて、FreeBSD は画面への出力を管理します。
結果として、FreeBSD で動かすコマンドを入力するのに使える複数の画面とキーボードを仮想的に実現できるのです。
ある仮想コンソールで実行したプログラムは、ユーザが別の仮想コンソールに切り替えても実行を停止しません。</p></div><div class=paragraph><p>FreeBSD のコンソールおよびキーボードドライバに関するさらなる技術的な説明については、<a href="https://man.freebsd.org/cgi/man.cgi?query=kbdcontrol&amp;sektion=1&amp;format=html">kbdcontrol(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=atkbd&amp;sektion=4&amp;format=html">atkbd(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> を参照してください。</p></div><div class=paragraph><p>FreeBSD では以下の <code>/etc/ttys</code> のセクションのように複数の利用可能な仮想コンソールが設定されています。</p></div><div class="literalblock programlisting"><div class=content><pre># name    getty                         type  status comments
#
ttyv0   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
# Virtual terminals
ttyv1   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv2   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv3   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv4   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv5   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv6   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv7   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv8   &#34;/usr/X11R6/bin/xdm -nodaemon&#34;  xterm   off secure</pre></div></div><div class=paragraph><p>仮想コンソールを無効にするには、無効にしたい仮想コンソールの行をコメント記号 (<code>#</code>) から始まるように設定してください。
たとえば、利用可能な仮想コンソールを 8 つから 4 つに減らす場合には、<code>ttyv5</code> から <code>ttyv8</code> までの仮想コンソールを表す最後の 4 行の先頭に <code>#</code> を挿入してください。
システムコンソールを表す <code>ttyv0</code> から始まる行はコメントアウト <em>しないでください。</em>
最後の仮想コンソール (<code>ttyv8</code>) は、 <a href=./#x11>X Window System</a> で説明されているように Xrog がインストールされて設定されている場合に、グラフィカル環境にアクセスするために使用されます。</p></div><div class=paragraph><p>このファイルのそれぞれのカラムと仮想コンソールに設定可能なオプションの詳しい説明は、<a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> のマニュアルを参照してください。</p></div></div><div class=sect3><h4 id=consoles-singleuser>3.2.2. シングルユーザモード<a class=anchor href=#consoles-singleuser></a></h4><div class=paragraph><p>FreeBSD のブートメニューでは、"シングルユーザモード" と表示されているオプションが提供されています。
このオプションを選択すると、システムは "シングルユーザモード" と呼ばれる特別なモードで起動します。
このモードは、システムが起動しない場合に修正のため、または <code>root</code> のパスワードが分からなくなってしまいリセットするときなど、特別な状況で利用されます。
シングルユーザモードで動かしている場合は、ネットワークや他の仮想コンソールは利用できません。
しかし、システムへの完全な <code>root</code> 権限を利用でき、デフォルトの設定では <code>root</code> のパスワードは必要ありません。
このような理由のため、このモードで起動する場合には物理的なキーボードへのアクセスが必要であり、FreeBSD システムの安全性の観点からキーボードに物理的にアクセスできる人を決めておく事が必要です。
シングルユーザモードを管理する設定は、<code>/etc/ttys</code> ファイルの以下のセクションにあります。</p></div><div class="literalblock programlisting"><div class=content><pre># name  getty                           type  status  comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure</pre></div></div><div class=paragraph><p>デフォルトでは、status は <code>secure</code> に設定されています。
これは、キーボードへアクセスできるかユーザが誰であるかが重要ではない、もしくはアクセスできるユーザについては物理的なセキュリティポリシーでコントロールされていることが前提となっています。
この設定を <code>insecure</code> に変更するケースとしては、システムは安全ではなく、誰でもキーボードにアクセスできる環境が想定されます。
この行を <code>insecure</code> に変更すると、FreeBSD がシングルユーザモードで起動した場合に <code>root</code> のパスワードが要求されます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em><code>insecure</code> に変更する場合は十分注意してください! </em><code>root</code> のパスワードを忘れてしまうと、シングルユーザモードで起動することはできますが、FreeBSD の起動のプロセスに詳しくない人が起動できるようにするのは難しいかも知れません。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=consoles-vidcontrol>3.2.3. コンソールのビデオモードの変更<a class=anchor href=#consoles-vidcontrol></a></h4><div class=paragraph><p>FreeBSD のデフォルトのビデオモードは 1024x768 や 1280x1024 など、グラフィックチップおよびディスプレイが対応しているサイズに調整されます。
別のビデオモードを使うには、<code>VESA</code> モジュールをロードしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vesa</span></code></pre></div></div><div class=paragraph><p>その後、ハードウェアが対応しているビデオモードを <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> を使って確認してください。
以下を実行すると、対応しているビデオモードを調べることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol -i mode</span></code></pre></div></div><div class=paragraph><p>このコマンドは、使用しているハードウェアが対応しているビデオモードの一覧を表示します。
その後、<a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> を <code>root</code> ユーザで実行して、新しく使用するビデオモードを選択してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol MODE_279</span></code></pre></div></div><div class=paragraph><p>このビデオモードで良ければ、起動時に自動的に設定されるように <code>/etc/rc.conf</code> に以下のように追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>allscreens_flags=&#34;MODE_279&#34;</pre></div></div></div></div><div class=sect2><h3 id=users-synopsis>3.3. ユーザと基本的なアカウント管理<a class=anchor href=#users-synopsis></a></h3><div class=paragraph><p>FreeBSD は、複数のユーザが同時にコンピュータを使えるようにします。 スクリーンとキーボードの前に一度に座れるのはその中の一人だけですが ユーザは何人でもネットワークを通してログインできます。 システムを使うためには、 どのユーザもアカウントがなければなりません。</p></div><div class=paragraph><p>この章では、以下のことを説明します。</p></div><div class=ulist><ul><li><p>FreeBSD システムにおけるさまざまな種類のユーザアカウントについて</p></li><li><p>ユーザアカウントを追加、削除および変更する方法</p></li><li><p>ユーザやグループが利用できるリソースの上限を制御する方法</p></li><li><p>グループの作成、 およびグループにユーザをメンバとして追加する方法</p></li></ul></div><div class=sect3><h4 id=users-introduction>3.3.1. アカウントの種類<a class=anchor href=#users-introduction></a></h4><div class=paragraph><p>FreeBSD システムへアクセスするには、 かならずアカウントが使われ、 また、プロセスもすべてユーザによって実行されるので、 ユーザとアカウントの管理は、重要なものです。</p></div><div class=paragraph><p>アカウントには大きく分けて三種類あります。 システムアカウント (system accounts)、ユーザアカウント (user accounts)、 そしてスーパーユーザ (superuser) です。</p></div><div class=sect4><h5 id=users-system>3.3.1.1. システムアカウント<a class=anchor href=#users-system></a></h5><div class=paragraph><p>システムアカウントは、DNS、メール、 ウェブサーバといった各種サービスを運用するために使われます。 この目的は、セキュリティを確保するためです。 もしすべてのサービスがスーパーユーザで実行されていると、 それらのサービスはどんな動作でも可能となり、 適切な制限を適用することができません。</p></div><div class=paragraph><p>システムアカウントの具体例は、 <code>daemon</code>, <code>operator</code>, <code>bind</code>, <code>news</code> および <code>www</code> といったものです。</p></div><div class=paragraph><p><code>nobody</code> は通常の特権を持たないシステムアカウントです。 しかし、<code>nobody</code> を利用するサービスが増えれば増えるほど、 それに所属するファイルやプロセスも増え、 その特権も大きくなるということを忘れないようにしてください。</p></div></div><div class=sect4><h5 id=users-user>3.3.1.2. ユーザアカウント<a class=anchor href=#users-user></a></h5><div class=paragraph><p>ユーザアカウントは、 主に現実のユーザがシステムにアクセスする手段として用いられるものです。 システムにアクセスするすべてのユーザは、 それぞれ唯一のユーザアカウントを持つべきです。 こうすることで管理者は誰が何を行なっているかがわかりますし、 他の人の設定を壊してしまうようなことを避けることができます。</p></div><div class=paragraph><p>それぞれのユーザは快適にシステムを利用するため、 シェル、エディタ、キー設定、言語など、 各自の環境をセットアップすることができます。</p></div><div class=paragraph><p>FreeBSD システム上のどのアカウントにも、 以下のような情報がなにかしら結び付けられています。</p></div><div class=dlist><dl><dt class=hdlist1>ユーザ名</dt><dd><p><code>login:</code> プロンプトに対して入力するユーザの名前です。
各ユーザは一意なユーザ名を持つ必要があります。
有効なユーザ名を作成するには <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=5&amp;format=html">passwd(5)</a> に記載されているいくつもの規則があります。
アプリケーションの上位互換性を保つために、8 文字以下の小文字からなるユーザ名を使うことが推奨されています。</p></dd><dt class=hdlist1>パスワード</dt><dd><p>各アカウントにはパスワードがあります。</p></dd><dt class=hdlist1>ユーザ ID (UID)</dt><dd><p>ユーザ ID (UID) は、 FreeBSD システムがユーザを一意に識別するための数値です。 ユーザ名を指定できるコマンドは、 ユーザ名を UID に変換してから扱っています。
65535 より大きな UID は、ソフトウェアによっては互換性の問題を引き起こす可能性があるので、65535 以下の UID を使用することが推奨されています。</p></dd><dt class=hdlist1>グループ ID (GID)</dt><dd><p>グループ ID (GID) は、 ユーザが属する第一グループを一意に識別するための数値です。 グループは、UID ではなく、 ユーザの GID に基づいて資源へのアクセスを制御する仕組みです。 これは、ある種の設定ファイルのサイズを大幅に小さくします。 ユーザは、複数のグループに所属できます。 65535 より大きな GID は、ソフトウェアに問題を引き起こす可能性があるので、 65535 以下の GID を使うことを推奨します。</p></dd><dt class=hdlist1>ログインクラス</dt><dd><p>ログインクラスはグループの仕組みを拡張したもので、 別々のユーザに対してシステムを調整する時に、 さらなる柔軟性を提供します。ログインクラスの詳細については、 <a href=#users-limiting>ログインクラスの設定</a> で説明します。</p></dd><dt class=hdlist1>パスワードの有効期限</dt><dd><p>デフォルトでは、パスワードに有効期限は設定されていません。
しかしながら、パスワードの有効期限をユーザごとに設定し、一部またはすべてのユーザに、一定の時間がたったらパスワードを強制的に変更させることができます。</p></dd><dt class=hdlist1>アカウント失効時間</dt><dd><p>デフォルトでは、FreeBSD はアカウントを失効させません。 たとえば学校で生徒のアカウントがある場合など、 限られた期間だけのアカウントを作成するなら、 そのアカウントがいつ失効するか <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> を使って指定できます。 有効期間が経過したら、 そのアカウントのディレクトリやファイルは残っていますが、 システムへのログインはできなくなります。</p></dd><dt class=hdlist1>ユーザの氏名</dt><dd><p>FreeBSD ではユーザ名でアカウントを一意に識別しますが、 必ずしもユーザの本名を反映したものではありません。 この情報をアカウントに関連付けることもできます。 この情報は、コメントのように、空白、大文字、および 8 字以上で記載できます。</p></dd><dt class=hdlist1>ホームディレクトリ</dt><dd><p>ホームディレクトリは、システム中のディレクトリへのフルパスです。
これはユーザがログインした時に作業を開始するディレクトリです。
一般的な慣習は、すべてのユーザのホームディレクトリを <code>/home/username</code> か <code>/usr/home/username</code> の下に置くことです。
各ユーザは、個人のファイルやサブディレクトリを、ユーザのホームディレクトリに保存します。</p></dd><dt class=hdlist1>ユーザシェル</dt><dd><p>シェルは、 ユーザがシステムと対話するデフォルトの環境を提供します。 いろいろな種類のシェルがあり、 経験を積んだユーザはそれぞれ好みがあり、 それをアカウントの設定に反映できます。</p></dd></dl></div></div><div class=sect4><h5 id=users-superuser>3.3.1.3. スーパーユーザアカウント<a class=anchor href=#users-superuser></a></h5><div class=paragraph><p>スーパーユーザアカウントは通常 <code>root</code> と呼ばれ、 システム管理を行なうために使われ、権限に制限がありません。 そのため、このアカウントはメールのやりとり、システムの調査、 プログラミングといった日常的な作業を行なうために使われるべきものではありません。</p></div><div class=paragraph><p>その理由は、スーパーユーザが通常のユーザアカウントと異なり、 操作にまったく制限を受けないことによります。 そのためスーパーユーザアカウントで操作を間違えると、 システムに重大な影響を与えてしまう恐れがあるのです。 ユーザアカウントでは、 仮に操作を間違えてもシステムを壊してしまうようなことはできないようになっています。 そのため、ユーザアカウントでログインし、 高い権限が必要なコマンドを実行するときだけスーパーユーザになることが推奨されています。</p></div><div class=paragraph><p>スーパーユーザで実行するコマンドはいつでも、 二回、三回と確認してください。 なぜならスペースが多かったり、文字が欠けていたりするだけで、 取り返しのつかないデータの破壊につながる可能性があるからです。</p></div><div class=paragraph><p>スーパーユーザの権限を得るには、さまざまな方法があります。 <code>root</code> ユーザとしてログインする方法もありますが、 これはまったくお勧めできません。</p></div><div class=paragraph><p>スーパーユーザの権限を手に入れるには、かわりに <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> を使って下さい。 <code>-</code> オプションをつけて実行すると、 実行したユーザに root ユーザの環境が設定されます。 このコマンドは <code>wheel</code> グループに入ってるユーザのみが実行でき、他のユーザは実行出来ません。 また、実行時には <code>root</code> ユーザのパスワードを必要とします。</p></div><div class=paragraph><p>以下の例では、<code>make install</code> を行うときにスーパーユーザの権限が必要なので、 このコマンドを実行する時だけユーザはスーパーユーザになります。 コマンドを実行したら、ユーザは <code>exit</code> を実行してスーパーユーザからログアウトし、 通常のユーザアカウントの権限に戻ります。</p></div><div class=exampleblock><div class=title>例 2. スーパーユーザ権限でプログラムをインストールする</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% configure
% make
% su -
Password:
<span class=c># make install</span>
<span class=c># exit</span>
%</code></pre></div></div></div></div><div class=paragraph><p>1 人の管理者が一台のマシン、 もしくは小規模なネットワークを管理する場合には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> のフレームワークはうまく機能するでしょう。 この代わりとなるのは、 <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> package または port です。これはログ機能や、 スーパーユーザの権限で実行できるユーザやコマンドを設定できます。</p></div></div></div><div class=sect3><h4 id=users-modifying>3.3.2. アカウント情報の管理<a class=anchor href=#users-modifying></a></h4><div class=paragraph><p>FreeBSD は、ユーザアカウントを操作するためにさまざまなコマンドを用意しています。
もっとも一般的なコマンドが <a href=#users-modifying-utilities>ユーザアカウントを管理するためのユーティティ</a> にまとめられています。
その後で、各コマンドについて詳しい使用例を示します。
各ユーティリティの詳細や使用例についてはマニュアルページを参照してください。</p></div><table id=users-modifying-utilities class="tableblock frame-all grid-all stretch"><caption class=title>表 2. ユーザアカウントを管理するためのユーティティ</caption><col style=width:25%><col><tbody><tr><th class="tableblock halign-left valign-top"><p class=tableblock>コマンド</p></th><td class="tableblock halign-left valign-top"><p class=tableblock>要約</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>コマンドラインからユーザを追加するための推奨アプリケーション</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>コマンドラインからユーザを削除するための推奨アプリケーション</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザデータベースの情報を変更するための柔軟なツール</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザのパスワードを変更するコマンドラインツール</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザアカウントのあらゆる箇所を変更する強力で柔軟なツール</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=bsdconfig&amp;sektion=8&amp;format=html">bsdconfig(8)</a></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>システムの設定のためのユーティリティ。アカウント管理に対応しています。</p></td></tr></tbody></table><div class=sect4><h5 id=users-adduser>3.3.2.1. ユーザの追加<a class=anchor href=#users-adduser></a></h5><div class=paragraph><p>新しいユーザの登録に推奨されるプログラムは <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> です。
ユーザを追加すると、このプログラムは、<code>/etc/passwd</code> と <code>/etc/group</code> を自動的に更新します。
また、新規ユーザのホームディレクトリを作成し、<code>/usr/share/skel</code> から、デフォルトで使用される設定ファイルをコピーします。
また、新しく作成されたユーザに対して、ウェルカムメッセージをメールで送信することも可能です。
このユーティリティは、スーパーユーザ権限で実行する必要があります。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> は、新しいユーザアカウントを対話的に段階的に作成するユーティリティです。
<a href=#users-modifying-adduser>FreeBSD におけるユーザの追加</a> で示されているように、必要な情報を入力するか、括弧内に示されているデフォルトの値を <kbd>Return</kbd> を押して承認してください。
この例では、ユーザは <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> によってスーパユーザ権限を取得することが可能となる <code>wheel</code> グループに所属します。
操作が終了すると、ユーティリティは別のユーザを追加するか、終了するかを尋ねてきます。</p></div><div id=users-modifying-adduser class=exampleblock><div class=title>例 3. FreeBSD におけるユーザの追加</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser</span>
Username: jru
Full name: J. Random User
Uid <span class=o>(</span>Leave empty <span class=k>for </span>default<span class=o>)</span>:
Login group <span class=o>[</span>jru]:
Login group is jru. Invite jru into other <span class=nb>groups</span>? <span class=o>[]</span>: wheel
Login class <span class=o>[</span>default]:
Shell <span class=o>(</span>sh csh tcsh zsh nologin<span class=o>)</span> <span class=o>[</span>sh]: zsh
Home directory <span class=o>[</span>/home/jru]:
Home directory permissions <span class=o>(</span>Leave empty <span class=k>for </span>default<span class=o>)</span>:
Use password-based authentication? <span class=o>[</span><span class=nb>yes</span><span class=o>]</span>:
Use an empty password? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span> <span class=o>[</span>no]:
Use a random password? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span> <span class=o>[</span>no]:
Enter password:
Enter password again:
Lock out the account after creation? <span class=o>[</span>no]:
Username   : jru
Password   : <span class=k>****</span>
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>: <span class=nb>yes
</span>adduser: INFO: Successfully added <span class=o>(</span>jru<span class=o>)</span> to the user database.
Add another user? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>: no
Goodbye!</code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>入力したパスワードは画面に表示されませんので、 ユーザアカウントを作成する際には、 パスワードを間違えて入力してしまわないように注意してください。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-rmuser>3.3.2.2. ユーザの削除<a class=anchor href=#users-rmuser></a></h5><div class=paragraph><p>システムから完全にユーザを削除するには、スーパーユーザ権限で <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> を実行してください。
このコマンドは、次の手順を実行します。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>指定されたユーザの <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> エントリが存在する場合には削除。</p></li><li><p>指定されたユーザの <a href="https://man.freebsd.org/cgi/man.cgi?query=at&amp;sektion=1&amp;format=html">at(1)</a> ジョブをすべて削除。</p></li><li><p>指定されたユーザが所有するすべてのプロセスに対して SIGKILL シグナルを送信。</p></li><li><p>ローカルパスワードファイルから、 指定されたユーザのエントリを削除。</p></li><li><p>指定されたユーザのホームディレクトリを削除 (ディレクトリの所有者が指定されたユーザのものだった場合)。実際のホームディレクトリへのシンボリックリンクの削除も含まれます。</p></li><li><p><code>/var/mail</code> から、指定されたユーザの到着メールファイルを削除。</p></li><li><p><code>/tmp</code>, <code>/var/tmp</code>, および <code>/var/tmp/vi.recover</code> から、指定されたユーザの所有するファイルを削除。</p></li><li><p><code>/etc/group</code> にある すべてのグループから、指定されたユーザを削除します
(指定されたユーザと同じ名前のグループで、そのユーザが削除されると空のグループとなる場合は、そのグループ自体が削除されます。
これは <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> によってユーザごとに作成される、ユニークなグループに対応するものです)。</p></li><li><p>指定されたユーザが所有するすべてのメッセージキュー、共通メモリセグメントおよびセマフォを削除</p></li></ol></div></div></div><div class=paragraph><p>スーパユーザアカウントの削除に <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> を利用することはできません。 スーパユーザアカウントの削除はほとんどすべての場合、 大規模なシステムの破壊を意味するからです。</p></div><div class=paragraph><p>デフォルトでは、以下の例のような対話モードが使われます。</p></div><div class=exampleblock><div class=title>例 4. <code>rmuser</code> による対話的なアカウントの削除</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rmuser jru</span>
Matching password entry:
jru:<span class=k>*</span>:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user<span class=s1>&#39;s home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.</span></code></pre></div></div></div></div></div><div class=sect4><h5 id=users-chpass>3.3.2.3. ユーザ情報の変更<a class=anchor href=#users-chpass></a></h5><div class=paragraph><p>すべてのユーザは、<a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> を用いてデフォルトシェルやユーザアカウントに関連した個人情報を変更できます。
スーパユーザ権限に限り、このユーティリティを用いて他のユーザのアカウント情報も変更できます。</p></div><div class=paragraph><p>ユーザ名の他にオプションを指定しないと、 <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> はユーザ情報を編集するエディタを表示します。 ユーザがエディタを終了すると、 ユーザデータベースが新しい情報に更新されます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>スーパユーザ権限以外でこのユーティリティを実行した場合は、 エディタを抜けた後にユーザのパスワードを聞かれます。</p></div></td></tr></tbody></table></div><div class=paragraph><p><a href=#users-modifying-chpass-su>スーパユーザによる <code>chpass</code> の使用</a> では、スーパーユーザは <code>chpass jru</code> と入力し、このユーザに対して変更可能なフィールドが表示されています。
<code>jru</code> がこのコマンドを実行すると、最後の 6 フィールドのみが表示され編集が可能です。
この場合については、<a href=#users-modifying-chpass-ru>通常のユーザによる <code>chpass</code> の使用</a> で示されています。</p></div><div id=users-modifying-chpass-su class=exampleblock><div class=title>例 5. スーパユーザによる <code>chpass</code> の使用</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Login: jru
Password: <span class=k>*</span>
Uid <span class=o>[</span><span class=c>#]: 1001</span>
Gid <span class=o>[</span><span class=c># or name]: 1001</span>
Change <span class=o>[</span>month day year]:
Expire <span class=o>[</span>month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div id=users-modifying-chpass-ru class=exampleblock><div class=title>例 6. 通常のユーザによる <code>chpass</code> の使用</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=chfn&amp;sektion=1&amp;format=html">chfn(1)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a> コマンドはいずれも、<a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> へのリンクです。
また、<a href="https://man.freebsd.org/cgi/man.cgi?query=ypchpass&amp;sektion=1&amp;format=html">ypchpass(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchfn&amp;sektion=1&amp;format=html">ypchfn(1)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchsh&amp;sektion=1&amp;format=html">ypchsh(1)</a> も同様です。
NIS のサポートは自動的に行なわれますの、 コマンドの先頭に <code>yp</code> をつける必要はありません。
NIS の設定については、ネットワークサーバの章で説明されています。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-passwd>3.3.2.4. ユーザのパスワードの変更<a class=anchor href=#users-passwd></a></h5><div class=paragraph><p>いかなるユーザも <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> を使って簡単に自身のパスワードを変更できます。
誤って、または不正なパスワードの変更を避けるため、新しいパスワードを設定する前に、もとのパスワードの入力が求められます。</p></div><div class=exampleblock><div class=title>例 7. 自分のパスワードの変更</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class=paragraph><p>スーパーユーザは、<a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> をユーザ名を指定して実行することにより、いかなるユーザのパスワードを変更できます。
スーパーユーザの権限でこのユーティリティを実行する際には、もとのパスワードを入力する必要はありません。
そのため、ユーザが元のパスワードを忘れてしまっても、パスワードを変更できます。</p></div><div class=exampleblock><div class=title>例 8. スーパーユーザ権限での他のユーザのパスワード変更</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># passwd jru</span>
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> 同様、<a href="https://man.freebsd.org/cgi/man.cgi?query=yppasswd&amp;sektion=1&amp;format=html">yppasswd(1)</a> は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> へのリンクになっていますので、 NIS はどちらのコマンドでも動作します。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-pw>3.3.2.5. システムユーザおよびグループの作成、削除、変更および表示<a class=anchor href=#users-pw></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> は、ユーザやグループの作成、削除、変更および表示を行なうコマンドラインのユーティリティです。
これは、システムユーザファイルやシステムグループファイルのフロントエンドとして働きます。
<a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> はとても強力な一連のコマンドラインオプションを有しており、シェルスクリプトで使うのに向いていますが、新しいユーザは、この章で紹介されている他のコマンドに比べて難しいと感じるかもしれません。</p></div></div></div><div class=sect3><h4 id=users-groups>3.3.3. グループの管理<a class=anchor href=#users-groups></a></h4><div class=paragraph><p>グループとは、ユーザを羅列したものです。 グループは、グループ名と GID で識別されます。 FreeBSD では、 あるプロセスが何かするのを許可するかどうかをカーネルが判断する際に、 プロセスの UID とそのユーザが所属するグループの一覧を利用します。 ほとんどの場合、ユーザもしくはプロセスの GID は一覧の最初のグループを指しています。</p></div><div class=paragraph><p>グループ名から GID への写像は <code>/etc/group</code> にあります。
これは、コロンで区切られた 4 項目からなるテキストファイルです。
1 番目の項目はグループ名、2 番目は暗号化されたパスワード、3 番目が GID、4 番目がカンマで区切られたメンバの一覧です。
文法についての完全な説明は、<a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a> をご覧ください。</p></div><div class=paragraph><p>スーパーユーザは、<code>/etc/group</code> をテキストエディタで編集できます。
ただし、よくある間違いを見つけてくれる <a href="https://man.freebsd.org/cgi/man.cgi?query=vigr&amp;sektion=8&amp;format=html">vigr(8)</a> を用いてグループファイルを編集することが好ましいです。
もしくは、<a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> を使ってグループの追加や編集をできます。
たとえば、<code>teamtwo</code> というグループを追加して、その存在を確認するには、次のように使います。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>operator グループを使う時には、意図しないスーパーユーザへのアクセス権を与える可能性があるため注意が必要です。
シャットダウン、リブートおよびこのグループが所有する <code>/dev</code> のすべてにアクセスできるといったことが可能になってしまいます。</p></div></td></tr></tbody></table></div><div class=exampleblock><div class=title>例 9. <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> によるグループの追加</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd teamtwo</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:</code></pre></div></div></div></div><div class=paragraph><p>この例では、<code>1100</code> という番号は、 <code>teamtwo</code> の GID です。 この時点では、<code>teamtwo</code> にメンバはいません。 以下のコマンドは、 <code>jru</code> を <code>teamtwo</code> のメンバに追加します。</p></div><div class=exampleblock><div class=title>例 10. <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> により新しいグループにメンバを追加する</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod teamtwo -M jru</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:jru</code></pre></div></div></div></div><div class=paragraph><p><code>-M</code> の引数は、カンマで区切られた新しい (空の) グループに追加するもしくは存在するグループのメンバを置き換えるユーザの一覧です。
ユーザにとっては、このグループのメンバーシップはパスワードファイルに記載されているプライマリのグループとは異なります。
<a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> の <code>groupshow</code> コマンドを使った時は、そのユーザはグループの一員として表示されませんが、<a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> などのツールを使って情報を問い合わせれば、その情報を引き出せます。
ユーザをグループに追加をする際に、<a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> は <code>/etc/group</code> しか扱わず、 <code>/etc/passwd</code> から追加のデータを読んだりはしません。</p></div><div class=exampleblock><div class=title>例 11. <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> によるグループへのユーザ追加</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod teamtwo -m db</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:jru,db</code></pre></div></div></div></div><div class=paragraph><p>この例では、<code>-m</code> の引数は、 カンマで区切られたグループに追加するユーザの一覧です。
前の例と異なり、これらのユーザはグループに追加され、既存のグループのユーザを置き換えることはありません。</p></div><div class=exampleblock><div class=title>例 12. グループに所属しているユーザを調べるための <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> の使い方</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>id </span>jru
<span class=nv>uid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nb>groups</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span>, 1100<span class=o>(</span>teamtwo<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>この例では、<code>jru</code> は <code>jru</code> グループと <code>teamtwo</code> グループのメンバです。</p></div><div class=paragraph><p>このコマンドや <code>/etc/group</code> のフォーマットの詳細については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a> をご覧ください。</p></div></div></div><div class=sect2><h3 id=permissions>3.4. 許可属性<a class=anchor href=#permissions></a></h3><div class=paragraph><p>FreeBSD では、すべてのファイルおよびディレクトリは一組の許可属性を持っています。
これらの許可属性は、ユーティリティを使って確認したり変更できます。
許可属性がどのように機能するかを知ることで、ユーザが必要とするファイルにアクセスできるかどうか、オペレーティングシステムが使用しているファイルや他のユーザが所有するファイルにアクセスできないことを理解できるようになります。</p></div><div class=paragraph><p>この節では、FreeBSD で使用される伝統的な UNIX® の許可属性について説明します。
より細かいファイルシステムのアクセス制御に関しては、<a href=./#fs-acl>アクセス制御リスト</a> をご覧ください。</p></div><div class=paragraph><p>UNIX® では、基本の許可属性は 3 つのアクセスタイプ (読み・書き・実行) を使って割り当てられます。
これらのアクセスタイプを使って、ファイルの所有者 (owner)、グループ (group) その他 (others) に対するファイルアクセスを設定します。
読み、書き、実行に関する許可属性は、それぞれ <code>r</code>, <code>w</code>, および <code>x</code> 文字で表されます。
これらの許可属性を表す際に、オンかオフ (<code>0</code>) による 2 進数表記も使われます。
数字で表現する場合には、 <code>r</code> は <code>4</code>、<code>w</code> は <code>2</code> そして <code>x</code> は <code>1</code> の値を持つよう、<code>rwx</code> の順番で表されます。</p></div><div class=paragraph><p>以下は、許可属性を表す際に用いられる数字およびアルファベットをまとめた表です。
"ディレクトリの表示" カラムでは、<code>-</code> は許可属性がオフに設定されていることを表します。</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>表 3. UNIX® 許可属性</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">値</th><th class="tableblock halign-left valign-top">許可属性</th><th class="tableblock halign-left valign-top">ディレクトリの表示</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>読み込み不可、書き込み不可、実行不可</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>---</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>読み込み不可、書き込み不可、実行可能</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>--x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>読み込み不可、書き込み可能、実行不可</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-w-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>読み込み不可、書き込み可能、実行可能</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-wx</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>読み込み可能、書き込み不可、実行不可</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r--</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>読み込み可能、書き込み不可、実行可能</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r-x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>読み込み可能、書き込み可能、実行不可</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rw-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>読み込み可能、書き込み可能、実行可能</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rwx</code></p></td></tr></tbody></table><div class=paragraph><p>コマンドライン引数 <code>-l</code> とともに <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> を使うと、詳細なディレクトリリストを見ることができ、ファイルの所有者、グループ、その他への許可属性を示す欄があるのがわかります。
例えば、<code>ls -l</code> を実行して、 適当なディレクトリを表示させると以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=nt>-l</span>
total 530
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 myfile
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 otherfile
<span class=nt>-rw-r--r--</span>  1 root  wheel    7680 Sep  5 12:31 email.txt</code></pre></div></div><div class=paragraph><p><code>myfile</code> が含まれている行の一番目の列の最初の <code>(一番左の)</code> 文字は、そのファイルが普通のファイルなのか、ディレクトリなのか、キャラクタ型のデバイス特殊ファイルなのか、ソケットなのか、その他の特殊な疑似ファイルデバイスなのかといった種類を示す特別な文字です。
この例において、<code>-</code> という文字は、普通のファイルであることを示します。
その次に来る <code>rw-</code> と書かれた 3 文字は、そのファイルの所有者に許可を与えるものです。
その次の <code>r--</code> の 3 文字は、そのファイルが所属しているグループに許可を与えます。
最後の <code>r--</code> の 3 文字は、 システムに存在するその他のユーザに許可を与えます。
"-" は許可が与えられていないことを示します。
この例では、ファイルの所有者はこのファイルを読み書きでき、ファイルの所属しているグループに属するユーザはファイルを読むことだけでき、そのどちらでもないユーザは、 このファイルを読むだけできるように許可属性が与えられています。
上の表によれば、このファイルに与えられた許可属性は <code>644</code> となります。
ここで各数字は、このファイルの許可属性の 3 つの部分を表しています。</p></div><div class=paragraph><p>デバイスの場合の許可属性はどのようにコントロールされているのでしょうか?
FreeBSD は、大部分のハードウェアをファイルとして取り扱います。
そのため、プログラムからは普通のファイルとまったく同じようにオープンし、 データの読み書きができるようになっています。
これらのデバイス特殊ファイルは <code>/dev/</code> に収められています。</p></div><div class=paragraph><p>ディレクトリもまた、ファイルと同様に扱われます。
それは読み込み/書き込み/実行の許可属性を持ちます。
ディレクトリの実行ビットはファイルのそれとは少し違った意味を持ちます。
ディレクトリが実行可能になっているとき、<a href="https://man.freebsd.org/cgi/man.cgi?query=cd&amp;sektion=1&amp;format=html">cd(1)</a> を使ってそのディレクトリに移動することができます。
これは、そのディレクトリにあるファイルにアクセスできることを意味しています (ファイル自体の許可属性によります)。</p></div><div class=paragraph><p>ディレクトリの中の一覧を表示するには、そのディレクトリに読み込み属性が設定されていなければなりません。
名前が分かっているファイルを削除するには、そのファイルが含まれているディレクトリに 書き込み属性 <em>と</em> 実行属性 の両方が必要です。</p></div><div class=paragraph><p>この他にも許可属性ビットはありますが、いずれも setuid バイナリや sticky ディレクトリなどといった特殊な状況で使われます。
ファイルの許可属性そのものについて、また、それらの設定方法に関する詳しい情報は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> マニュアルページを参照してください。</p></div><div class=sect3><h4 id=_シンボリック表記>3.4.1. シンボリック表記<a class=anchor href=#_シンボリック表記></a></h4><div class=paragraph><p>シンボリック表記と呼ばれる許可属性を表す方法では、ファイルやディレクトリの許可属性を、8 進数ではなく記号を用いて設定します。
シンボリック表記による許可属性を表す方法では、(who), (action), (permissions) という書式が用いられます。
利用できる値は以下の通りです。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">オプション</th><th class="tableblock halign-left valign-top">文字</th><th class="tableblock halign-left valign-top">意味</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(who)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>u</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザ</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(who)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>g</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ファイルを所持しているグループ</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(who)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>o</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>その他</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(who)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>すべて ("world")</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(action)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>許可属性を与える</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(action)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>許可属性を取り除く</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(action)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>=</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>許可属性を指定したものにする</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissions)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>r</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>読み込み</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissions)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>w</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>書き込み</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissions)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>x</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>実行</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissions)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>t</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sticky ビット</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissions)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>s</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UID または GID を設定する</p></td></tr></tbody></table><div class=paragraph><p>これらの値は、これまでと同様に <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> で用いますが、数字ではなく文字で指定します。
たとえば、<em>FILE</em> に対して <em>FILE</em> のグループメンバーおよび自分以外のすべてのユーザからアクセスを一切受け付けたくない、というときには以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span><span class=nv>go</span><span class=o>=</span> FILE</code></pre></div></div><div class=paragraph><p>カンマ区切りで設定することで、ファイルの属性を一度に 2 つ以上変更できます。
以下の例では、<em>FILE</em> に対して自分以外のユーザから書き込みの権限を取り上げ、かわりにすべてのユーザが <em>FILE</em> を実行できるようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>go-w,a+x FILE</code></pre></div></div></div><div class=sect3><h4 id=_freebsd_のファイルフラグ>3.4.2. FreeBSD のファイルフラグ<a class=anchor href=#_freebsd_のファイルフラグ></a></h4><div class=paragraph><p>ファイルの許可属性に加え、FreeBSD では "ファイルフラグ" を使えます。
これはファイルにセキュリティや管理上の属性を追加するものですが、ディレクトリには追加しません。
ファイルフラグにより、<code>root</code> ユーザでさえ誤ってファイルを消去、変更してしまうことを防ぐことができます。</p></div><div class=paragraph><p>ファイルフラグは、<a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> を使って、簡単なインタフェースで設定できます。
例えば、<code>file1</code> というファイルにシステムレベルで消去不可のフラグを設定するには、以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags sunlink file1</span></code></pre></div></div><div class=paragraph><p>消去不可のフラグを削除するには、以下のように <code>sunlink</code> の前に "no" をつけて実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags nosunlink file1</span></code></pre></div></div><div class=paragraph><p>ファイルに設定されているフラグを確認するには、<code>-lo</code> と一緒に <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -lo file1</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</pre></div></div><div class=paragraph><p>いくつかのファイルフラグの追加、削除は <code>root</code> ユーザしかできません。
他のフラグは、ファイルの所有者が変更できます。
<a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=2&amp;format=html">chflags(2)</a> から、より詳細な情報を得ることをおすすめします。</p></div></div><div class=sect3><h4 id=_setuid_setgid_および_sticky_許可属性>3.4.3. setuid, setgid および sticky 許可属性<a class=anchor href=#_setuid_setgid_および_sticky_許可属性></a></h4><div class=paragraph><p>これまでに説明した許可属性のほかに、
すべての管理者が知っておくべき特別な設定が 3 つあります。
それは <code>setuid</code>, <code>setgid</code> および <code>sticky</code> 許可属性です。</p></div><div class=paragraph><p>これらの設定は、通常のユーザには許可されていない機能を提供するので、UNIX® の操作において重要となることがあります。
これらの許可属性を理解するためには、実ユーザ ID と実効ユーザ ID の違いに注意してください。</p></div><div class=paragraph><p>実ユーザ ID は、所有したりプロセスを開始する UID です。
実効 UID は、プロセスを実行するユーザ ID です。
たとえば、ユーザがパスワードを変更するときに利用する <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> は、実ユーザ ID で起動します。
しかしながら、パスワードデータベースのアップデートの際は、実効 ID の <code>root</code> ユーザの権限で実行されます。
この仕組みにより、<code>Permission Denied</code> エラーが表示されることなく、ユーザはパスワードを変更できます。</p></div><div class=paragraph><p>setuid 許可属性は、以下の例で示されているように、ユーザに対して <code>s</code> の許可属性をつけることで設定できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod u+s suidexample.sh</span></code></pre></div></div><div class=paragraph><p>setuid 許可属性は、以下の例で示されているように、指定する許可属性に数字の 4 をつけることでも設定できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 4755 suidexample.sh</span></code></pre></div></div><div class=paragraph><p>これで <code>suidexample.sh</code> の許可属性は以下のように設定されます。</p></div><div class="literalblock programlisting"><div class=content><pre>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</pre></div></div><div class=paragraph><p><code>s</code> は、許可属性のファイル所有者の実行可能ビットに置き換わって反映されます。
この設定により、<a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> といったユーティリティが権限を昇格することができます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>nosuid</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> オプションを使うと、このようなバイナリがユーザへの警告なしに権限を昇格できないように設定できます。
ただし <code>nosuid</code> ラッパにより回避できるため、このオプションを完全には信頼できません。</p></div></td></tr></tbody></table></div><div class=paragraph><p>リアルタイムに確認するために、2 つのターミナルを開いてください。
1 つのターミナル上で、通常のユーザ権限で <code>passwd</code> と入力してください。
パスワードの入力を待つ間に、もう一つのターミナル上で、プロセステーブルおよび <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> のユーザ情報を確認してください。</p></div><div class=paragraph><p>ターミナル A:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Changing <span class=nb>local </span>password <span class=k>for </span>trhodes
Old Password:</code></pre></div></div><div class=paragraph><p>ターミナル B:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps aux | grep passwd</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 <span class=nb>grep </span>passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</code></pre></div></div><div class=paragraph><p>通常のユーザ権限で <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> を実行したにもかかわらず、実効 UID の <code>root</code> が使われています。</p></div><div class=paragraph><p><code>setgid</code> 許可属性は <code>setuid</code> 許可属性と同様の機能を提供しますが、この許可属性はグループの設定を変更します。
この設定を行った上でアプリケーションまたはユーティリティを実行すると、プロセスを開始するユーザではなく、ファイルを所有するグループに対してこの許可属性を与えます。</p></div><div class=paragraph><p>記号を用いてファイルに <code>setgid</code> 許可属性を設定するには、<a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> で設定するグループに <code>s</code> の許可属性をつけて実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod g+s sgidexample.sh</span></code></pre></div></div><div class=paragraph><p>または、<a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> で設定する許可属性の先頭に 2 をつけて実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 2755 sgidexample.sh</span></code></pre></div></div><div class=paragraph><p>以下に示されるように、<code>s</code> がグループの許可属性に指定されています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-rwxr-sr-x</span>   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>上記の例において、対象としているシェルスクリプトが実行可能なファイルであっても、シェルスクリプトは <a href="https://man.freebsd.org/cgi/man.cgi?query=setuid&amp;sektion=2&amp;format=html">setuid(2)</a> システムコールにアクセスできないため、実効ユーザ ID では実行されません。</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>setuid</code> および <code>setgid</code> 許可属性ビットは、権限の昇格を許可するので、システムのセキュリティレベルを下げます。
一方 3 番目の特殊な許可属性 <code>sticky bit</code> は、システムのセキュリティを強化します。</p></div><div class=paragraph><p>ディレクトリに <code>sticky bit</code> を設定すると、ファイルの所有者のみがファイルを削除できるようになります。
<code>/tmp</code> といった共有のディレクトリにおいて、ファイルの所有者以外のユーザがファイルを削除できなくなるので有用です。
この許可属性を有効にするには、ファイルに対して <code>t</code> モードを追加してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod +t /tmp</span></code></pre></div></div><div class=paragraph><p>または、許可属性に 1 をつけて設定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 1777 /tmp</span></code></pre></div></div><div class=paragraph><p><code>sticky bit</code> が設定されていると、許可属性の最後に <code>t</code> が表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -al / | grep tmp</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</code></pre></div></div></div></div><div class=sect2><h3 id=dirstructure>3.5. ディレクトリ構造<a class=anchor href=#dirstructure></a></h3><div class=paragraph><p>FreeBSD のディレクトリ構造は、システム全体を理解するに当たって重要です。
最も重要なディレクトリは、ルートまたは "/" です。
このディレクトリは起動時に一番最初にマウントされ、オペレーティングシステムをマルチユーザで動作させるために必要なベースシステムが含まれています。
また、ルートディレクトリには、マルチユーザへの移行中に他のファイルシステムをマウントするためのマウントポイントも含まれます。</p></div><div class=paragraph><p>マウントポイントとは、追加するファイルシステムを接続する先の親のファイルシステム (普通はルートファイルシステム) のディレクトリのことです。
より詳細な説明は <a href=#disk-organization>ディスク構成</a> の節にあります。
標準的なマウントポイントには <code>/usr/</code>, <code>/var/</code>, <code>/tmp/</code>, <code>/mnt/</code> および <code>/cdrom/</code> があります。
通常これらのディレクトリについては、<code>/etc/fstab</code> というファイル中のエントリが参照されます。
このファイルは、さまざまなファイルシステムとマウントポイントの表であり、システムが参照します。
<code>/etc/fstab</code> に書かれたファイルシステムは <code>noauto</code> オプションが指定されていなければ、起動時に <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> スクリプトによって自動的にマウントされます。
詳細は <a href=#disks-fstab>fstab ファイル</a> の節をご覧ください。</p></div><div class=paragraph><p>ファイルシステム構造を網羅した説明は <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a> に書かれています。
以下の表は、もっともよく使われるディレクトリの簡単な概要です。</p></div><table class="tableblock frame-all grid-all stretch"><col style=width:25%><col><tbody><tr><th class="tableblock halign-left valign-top"><p class=tableblock>ディレクトリ</p></th><td class="tableblock halign-left valign-top"><p class=tableblock>説明</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>ファイルシステムのルートディレクトリ</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/bin/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>シングルユーザ環境とマルチユーザ環境の両方で重要な ユーザユーティリティ</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/boot/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>オペレーティングシステムの起動時に使われるプログラムと設定ファイル</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/boot/defaults/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>デフォルトの起動設定ファイル; <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> 参照</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/dev/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=4&amp;format=html">devfs(4)</a> により管理されるデバイスファイル</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/etc/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>システム設定ファイルとスクリプト</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/etc/defaults/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>デフォルトのシステム設定ファイル; 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 参照</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/etc/periodic/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 経由で毎日・毎週・毎月実行されるスクリプト; 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 参照</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/lib/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock><code>/bin</code> および <code>/sbin</code> にあるバイナリで必要とされる重要なシステムライブラリ</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/libexec/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>重要なシステムファイル</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/media/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>CD, USB ドライブおよびフロッピーディスクなどのリムーバブルメディアのマウントポイントとして使用されるサブディレクトリを含むディレクトリ</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/mnt/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>システム管理者が一時的なマウントポイントとしてよく使う空のディレクトリ</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/net/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>自動マウント NFS 共有。<a href="https://man.freebsd.org/cgi/man.cgi?query=auto_master&amp;sektion=5&amp;format=html">auto_master(5)</a> を参照</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/proc/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>プロセスファイルシステム; 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_procfs&amp;sektion=8&amp;format=html">mount_procfs(8)</a> 参照</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/rescue/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rescue&amp;sektion=8&amp;format=html">rescue(8)</a> で説明されている緊急時のために静的にリンクされているプログラム</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/root/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock><code>root</code> アカウントのホームディレクトリ</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/sbin/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>シングルユーザ環境とマルチユーザ環境の両方で重要なシステムプログラムと管理ユーティリティ</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/tmp/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>システムの再起動では通常保存 <em>されない</em> 一時的なファイル。
メモリファイルシステムはよく <code>/tmp</code> にマウントされます。
これは <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> の tmpmfs 関係の変数を使うか、<code>/etc/fstab</code> に設定項目を記入することで自動化できます。
詳しくは <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> を参照して下さい。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>大部分のユーザユーティリティとアプリケーション</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/bin/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>よく使うユーティリティとプログラミングツールとアプリケーション</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/include/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>C の標準ヘッダファイル</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/lib/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>ライブラリ</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/libdata/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>いろいろなユーティリティのデータファイル</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/libexec/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>他のプログラムから実行されるシステムデーモンとシステムユーティリティ</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/local/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>ローカルのプログラムやライブラリなど。
FreeBSD ports フレームワークのデフォルトインストール先としても使われます。
<code>/usr/local</code> 内では、 <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a> に書かれている <code>/usr</code> のための一般構造が使われます。
例外は man ディレクトリで、<code>/usr/local/share</code> の下ではなく <code>/usr/local</code> の下に直接置かれ、ports 関係文書は <code>share/doc/port</code> に置かれます。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/ports/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD Ports Collection (オプション)。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/sbin/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザにより実行されるシステムデーモンおよびシステムユーティリティ</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/share/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>アーキテクチャに依存しないファイル</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/usr/src/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>BSD のソースファイルまたはローカルのソースファイル、あるいは両方</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/var/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>さまざまな用途のログ・一時的なファイル・スプールファイル。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/var/log/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>いろいろなシステムログファイル</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>/var/tmp/</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>一時的なファイル。通常の設定では、ここにあるファイルはシステムが再起動しても失われません。</p></td></tr></tbody></table></div><div class=sect2><h3 id=disk-organization>3.6. ディスク構成<a class=anchor href=#disk-organization></a></h3><div class=paragraph><p>ファイルを見つけるために FreeBSD が使用する構成の一番小さな単位はファイル名です。
ファイル名は、大文字と小文字を区別します。
このことは <code>readme.txt</code> および <code>README.TXT</code> が異なる二つのファイルであることを意味します。
FreeBSD はそのファイルがプログラム、または文書、あるいはその他の形式かどうかを決定するために拡張子を使用しません。</p></div><div class=paragraph><p>ファイルはディレクトリ内に格納されます。
ディレクトリはファイルを一つも含んでいないかもしれせんし、または数百のファイルを含んでいるかもしれません。
ディレクトリはまた別のディレクトリを含むことができるので、
データを体系づけるディレクトリの階層構造を構築できます。</p></div><div class=paragraph><p>ファイルおよびディレクトリは、必要な他のディレクトリ名とスラッシュ (<code>/</code>) を後に続けてファイル名またはディレクトリ名を与えることによって参照されます。
たとえば、<code>foo</code> ディレクトリがあって、その中に <code>bar</code> ディレクトリがあるとします。
そして、その中に <code>readme.txt</code> があるとすると、ファイルへのフルネーム、または <em>パス</em> は <code>foo/bar/readme.txt</code> となります。
ファイルとディレクトリ名を分けるために <code>\</code> を使う Windows® とは違うことに注意してください。
FreeBSD は、パスの中にドライブレターまたは他のドライブ名を使いません。
たとえば、FreeBSD では <code>c:\foo\bar\readme.txt</code> とは書きません。</p></div><div class=sect3><h4 id=disks-file-systems>3.6.1. ファイルシステム<a class=anchor href=#disks-file-systems></a></h4><div class=paragraph><p>ディレクトリおよびファイルはファイルシステム内に格納されます。
どのファイルシステムも、そのファイルシステムのための <em>ルートディレクトリ</em> とよばれる、まさに頂点の位置にちょうど一つのディレクトリを含んでいます。
このルートディレクトリは他のディレクトリを含むことができます。
一つのファイルシステムは <em>ルートファイルシステム</em> または <code>/</code> として設計されています。
すべてのファイルシステムは、ルートファイルシステム以下に <em>マウント</em> されます。
FreeBSD システムでどんなに多くのディスクを使用しても、すべてのディレクトリは、同じディスクの一部であるように見えるので問題ありません。</p></div><div class=paragraph><p><code>A</code>, <code>B</code> および <code>C</code> と呼ばれる三つのファイルシステムがあるケースを考えます。
それぞれのファイルファイルシステムには一つのルートディレクトリがあり、<code>A1</code>, <code>A2</code> と呼ばれている二つの他のディレクトリを含んでいます (同様に <code>B1</code>, <code>B2</code> および <code>C1</code>, <code>C2</code> があります)。</p></div><div class=paragraph><p><code>A</code> をルートファイルシステムとします。
このディレクトリになにが含まれているか見るために <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> コマンドを使うと、<code>A1</code> および <code>A2</code> の二つのサブディレクトリが表示されるでしょう。
ディレクトリツリーは以下のようになります。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir1.png alt="ルートディレクトリおよび 2 つのサブツリーを持つディレクトリツリー"></div></div><div class=paragraph><p>ファイルシステムはマウント先のファイルシステム内のディレクトリにマウントしなければいけません。
それでは、<code>A1</code> ディレクトリに <code>B</code> ファイルシステムをマウントすると仮定します。
<code>B</code> のルートディレクトリは <code>A1</code> に置き換えられ、そして <code>B</code> 内のディレクトリがそれに応じて現れます。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir2.png alt="ルートディレクトリおよび 2 つのサブツリーを持つディレクトリツリー。さらに B1 および B2 サブディレクトリが  A1 にぶら下がっています"></div></div><div class=paragraph><p><code>B1</code> または <code>B2</code> 内にあるどんなファイルも、必要なときに <code>/A1/B1</code> または <code>/A1/B2</code> で到達できます。
<code>/A1</code> にあったすべてのファイルは一時的に隠されました。
それらは <code>B</code> が <code>A</code> から <em>アンマウント</em> されたら再び現れるでしょう。</p></div><div class=paragraph><p>もし <code>B</code> が <code>A2</code> にマウントされていたら、この図のようになります。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir3.png alt="ルートディレクトリおよび 2 つのサブツリーを持つディレクトリツリー。さらに B1 および B2 サブディレクトリが  A2 にぶら下がっています"></div></div><div class=paragraph><p>そして、パスはそれぞれ <code>/A2/B1</code> および <code>/A2/B2</code> となるでしょう。</p></div><div class=paragraph><p>ファイルシステムは互いのファイルシステム上にもマウントできます。
上記の最後の例に続けて、<code>C</code> ファイルシステム は <code>B</code> ファイルシステム内の <code>B1</code> ディレクトリ上にマウントできます。
次の図のようになります。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir4.png alt=複雑なディレクトリツリー。さまざまなサブディレクトリがルート以下にぶら下がっています。></div></div><div class=paragraph><p>または <code>C</code> を <code>A</code> ファイルシステムの <code>A1</code> ディレクトリの下に直接マウントできます。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir5.png alt=複雑なディレクトリツリー。さまざまなサブディレクトリがルート以下にぶら下がっています。></div></div><div class=paragraph><p>一つの大きなルートファイルシステムを用意し、他のファイルシステムを作成する必要としないことはまったくもって可能です。
この方法にはいくつかの短所と一つの利点があります。</p></div><div class=ulist><div class=title>マルチファイルシステムの利点</div><ul><li><p>異なったファイルシステムは異なった <em>マウントオプション</em> を使用できます。
たとえば、ルートファイルシステムを読みだし専用でマウントして、不注意によってユーザが重大なファイルを削除、または編集できないようにすることができます。
また、<code>/home</code> のようなユーザが書き込み可能なファイルシステムを他のファイルシステムと分けることによって、 <em>nosuid</em> でマウントすることが可能になります。
このオプションは、ファイルシステムに記録されている <em>suid</em>/<em>guid</em> の実行可能ビットを有効にしないので、安全性を高めることができるでしょう。</p></li><li><p>FreeBSD はファイルシステムがどのように使われているかによって、自動的にファイルシステム上のファイルの配置を最適化します。 したがって、連続的に書き込まれた多くの小さなファイルが含まれているファイルシステムは、より大きく少ないファイルが含まれているファイルシステムと異なる最適化をするでしょう。 一つの大きなファイルシステムを作成すると、この最適化は成り立たなくなります。</p></li><li><p>FreeBSD のファイルシステムはトラブルが起きても強固です。 しかしながら臨界点でのトラブルは、ファイルシステムの構造にまだ損害を与えるかもしれません。 マルチファイルシステムへデータを分割しておくことで、 必要なときにバックアップからレストアすることをより容易にして、まだシステムが回復するかもしれません。</p></li></ul></div><div class=ulist><div class=title>シングルファイルシステムの利点</div><ul><li><p>ファイルシステムは固定サイズです。 FreeBSD をインストールするときにファイルシステムを作成して、 固定サイズを割りあてたなら、 後になってそのパーティションをより大きくする必要があると気づくかもしれません。 パーティションのサイズを変更するには、 バックアップ、新しいサイズを指定したファイルシステムの再作成、 バックアップしたデータをリストアする作業が必要となるでしょう。</p><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>FreeBSD には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=growfs&amp;sektion=8&amp;format=html">growfs(8)</a> コマンドがあります。
このコマンドは、この制限を取り除いて、ファイルシステムのファイルを直ちに増加させることを可能にします。
ファイルシステムは、そのファイルシステムのあるパーティションの空いている領域に対してのみ拡張できます。
パーティションを分割した後、空いている領域があれば、<a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> を用いてパーティションを拡張できます。
仮想ディスクの最後のパーティションであれば、ディスクを大きくすると、パーティションを拡張できます。</p></div></td></tr></tbody></table></div></li></ul></div></div><div class=sect3><h4 id=disks-partitions>3.6.2. ディスクパーティション<a class=anchor href=#disks-partitions></a></h4><div class=paragraph><p>ファイルシステムは <em>パーティション</em> 内に含まれています。
ディスクは 1 つのパーティションスキーム (<a href=#bsdinstall-part-manual>Manual によるパーティションの分割</a>) を用いてパーティションに分割されます。
新しいスキームは GPT で、古い BIOS-ベースのコンピュータは MBR を使用します。
GPT は、サイズ、オフセットおよびタイプによるディスクのパーティション分割に対応しています。
多くのパーティションおよびパーティションタイプに対応しているため、GPT が利用できる場合はこのパーティションスキームを使用することが推奨されます。
GPT パーティションは、接尾語 <code>p1</code> が最初のパーティション、接尾語 <code>p2</code> が 2 番目のパーティションといったような接尾語を使います。
一方 MBR パーティションは少ない数のパーティションにのみ対応しています。
MBR パーティションは、FreeBSD では <code>スライス</code> として知られています。
スライスは他のオペレーティングシステムでも使うことができます。
FreeBSD のスライスはさらに、BSD ラベル (<a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> 参照) を用いてパーディションに分割できます。</p></div><div class=paragraph><p>スライス番号は 1 から始まり <code>s</code> を前につけられて、デバイス名の後に続きます。
したがって、"da0<em>s1</em>" は一番目の SCSI ドライブ上の一番目のスライスです。
ディスク上に存在できる物理スライスは、4 つまでですが、適切な種類の物理スライス内に論理スライスを作成できます。
これらの拡張されたスライス番号は 5 から始まります。
したがって、 "ada0<em>s5</em>" は、一番目の SATA ディスク上の一番目の拡張スライスです。
これらのデバイスは、スライスを占有することを予期するファイルシステムによって使用されます。</p></div><div class=paragraph><p>GPT または BSD の各パーティションは、一つのファイルシステムだけを含むことができます。
このことは、ファイルシステムがファイルシステムの階層上の典型的なマウントポイント、または含まれているパーティション名によって記述されることを意味します。</p></div><div class=paragraph><p>FreeBSD は <em>スワップ領域</em> にもまたディスク領域を使用します。
スワップ領域は FreeBSD に <em>仮想メモリ</em> を提供します。
これはあなたのコンピュータが、 実際に搭載している以上のメモリがあるかのように振舞います。
FreeBSD がメモリを使い果たしたときに、現在使用されていないデータのいくつかをスワップ領域に移動し、そのデータが必要となったときに (その他のデータをスワップ領域に移動させてから) メモリ内に移動しなおします。
これは <em>ページング</em> と呼ばれます。</p></div><div class=paragraph><p>いくつかの BSD パーティションはある慣習と関係づけられています。</p></div><table class="tableblock frame-all grid-all stretch"><col style=width:25%><col><tbody><tr><th class="tableblock halign-left valign-top"><p class=tableblock>パーティション</p></th><td class="tableblock halign-left valign-top"><p class=tableblock>慣習</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>a</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>通常、ルートパーティションを含みます。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>b</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>通常、スワップ領域を含みます。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>c</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>通常、スライス全体と同じサイズです。
これは、スライス全体にアクセス必要のあるユーティリティ (たとえば、ひどいブロックスキャナ) が、 <code>c</code> パーティションにアクセスすることを可能にします。
通常、このパーティション内にファイルシステムは作成されません。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>d</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock><code>d</code> パーティションは、 それに関連づけられた特別な意味を持っていましたが、 今は無いので、普通のパーティションとして動作するでしょう。</p></td></tr></tbody></table><div class=paragraph><p>スライスおよび "危険な専用" の物理ドライブ、 そして他のドライブは <code>a</code> から <code>h</code> までの文字として表される BSD パーティションを含んでいます。
この文字はデバイス名に追加されます。
したがって、 "da0<em>a</em>" は一番目の "危険な専用" <code>da</code> ドライブ上の <code>a</code> パーティションです。
"ada1s3<em>e</em>" は、 二番目の SATA ディスク上の 三番目のスライス内にある五番目のパーティションです。</p></div><div class=paragraph><p>最後に、システム上のそれぞれのディスクは識別されます。
ディスク名はどの種類のディスクであるかを示す記号ではじまり、どのディスクかを示す数字が続きます。
パーティションやスライスとは異なり、ディスクの番号づけは 0 から始まります。
共通の記号は <a href=#disks-naming>ディスクデバイス名</a> に示されます。</p></div><div class=paragraph><p>スライスにあるパーティションを参照するときには、ディスク名、<code>s</code>、スライス番号、そしてパーティション文字を含めてください。
<a href=#basics-disk-slice-part>ディスク名、スライス名、パーティション名のサンプル</a> に例があります。
GPT パーディションはディスク名、<code>p</code> そしてパーティション番号が含まれます。</p></div><div class=paragraph><p><a href=#basics-concept-disk-model>ディスクの概念的構成</a> は、MBR スライスを用いたディスク構成の概念のモデルを示します。</p></div><div class=paragraph><p>FreeBSD をインストールする際には、MBR を使用する場合にはディスクスライスを設定し、次に FreeBSD に用いるスライス内のパーティションを作成します。
GPT を使用する場合には、各ファイルシステムにパーティションを設定します。
どちらのケースでも、それぞれのパーティション内にファイルシステムまたはスワップ領域を作成し、ファイルシステムがどこにマウントされるか決定してください。
パーティションの操作についての詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> をご覧ください。</p></div><table id=disks-naming class="tableblock frame-none grid-all stretch"><caption class=title>表 4. ディスクデバイス名</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">ドライブタイプ</th><th class="tableblock halign-left valign-top">ドライブデバイス名</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SATA および IDE ハードドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ada</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI ハードドライブおよび USB ストレージデバイス</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>da</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>NVMe ストレージ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>nvd</code> または <code>nda</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SATA および IDE CD-ROM ドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI CD-ROM ドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>フロッピードライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI テープドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>sa</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RAID ドライバ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>aacd</code> (Adaptec® AdvancedRAID), <code>mlxd</code> および <code>mlyd</code> (Mylex®), <code>amrd</code> (AMI MegaRAID®), <code>idad</code> (Compaq Smart RAID), <code>twed</code> (3ware® RAID) など</p></td></tr></tbody></table><div class=exampleblock><div class=content><table id=basics-disk-slice-part class="tableblock frame-none grid-all stretch informaltable"><caption class=title>表 5. ディスク名、スライス名、パーティション名のサンプル</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">名前</th><th class="tableblock halign-left valign-top">意味</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ada0s1a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>一番目の SATA ディスク (<code>ada0</code>) 上の一番目のスライス (<code>s1</code>) 内の一番目のパーティション (<code>a</code>)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>da1s2e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>二番目の SCSI ディスク (<code>da1</code>) 上の二番目のスライス (<code>s2</code>) 内の五番目のパーティション (<code>e</code>)。</p></td></tr></tbody></table></div></div><div id=basics-concept-disk-model class=exampleblock><div class=title>例 13. ディスクの概念的構成</div><div class=content><div class=paragraph><p>これはシステムに接続された一番目の SATA ディスクの FreeBSD から見た図を示します。
ディスクサイズは 250 GB と仮定し、80 GB のスライス (MS-DOS® でいうパーティション) および 170 GB のスライスがあるとします。
一番目のスライスは Windows® NTFS ファイルシステム <code>C:</code> を含んでいます。
そして、二番目のスライスは FreeBSD のディスクを含んでいます。
これは FreeBSD インストーラが四つのデータパーティションと一つのスワップパーティションを作成した例です。</p></div><div class=paragraph><p>四つのパーティションはそれぞれファイルシステムを含んでいます。
パティション <code>a</code> はルートファイルシステム、<code>d</code> は <code>/var</code>, <code>e</code> は <code>/usr</code>、そして <code>f</code> は <code>/usr</code> に使用されています。
パーティション <code>c</code> はスライス全体を示しており、通常のパーティションとは異なる使われ方をします。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/disk-layout.png alt="Windows と FreeBSD を 1 つのドライブに共存させたレイアウト"></div></div></div></div></div></div><div class=sect2><h3 id=mount-unmount>3.7. ファイルシステムのマウントとアンマウント<a class=anchor href=#mount-unmount></a></h3><div class=paragraph><p>ファイルシステムは <code>/</code> をルート (根) とする木構造として考えると視覚的に理解しやすいでしょう。
ルートディレクトリにある <code>/dev</code> や <code>/usr</code>、その他のディレクトリは枝に相当し、それらには、<code>/usr/local</code> などのように、さらに枝分かれすることができます。</p></div><div class=paragraph><p>さまざまな理由がありますが、 ディレクトリをいくつかの異なるファイルシステム上に構築するのが良いでしょう。
たとえば <code>/var</code> には、 <code>log/</code> や <code>spool/</code> など、さまざまな種類の一時ファイルを置くディレクトリがあるため、あふれてしまう可能性があります。
ルートファイルシステムをあふれさせるのは得策ではありませんので、普通は <code>/var</code> を <code>/</code> から分離します。</p></div><div class=paragraph><p>また、次のような場合も、ディレクトリツリーを別のファイルシステムに置く理由として良くあげられます。
それは、たとえば物理的に別のディスクにディレクトリツリーを置く場合、 <a href=./#network-nfs>「ネットワークファイルシステム (NFS)」</a> で説明されているようにネットワークファイルシステムをマウントしたり、CDROM ドライブのような別の仮想ディスクに置くという場合です。</p></div><div class=sect3><h4 id=disks-fstab>3.7.1. fstab ファイル<a class=anchor href=#disks-fstab></a></h4><div class=paragraph><p><code>/etc/fstab</code> に書かれているファイルシステムは、<code>noauto</code> オプション指定されているエントリを除いて <a href=./#boot>起動プロセス</a> の途中で自動的にマウントされます。
このファイルは、 次のような書式で書かれたエントリを含んでいます。</p></div><div class="literalblock programlisting"><div class=content><pre>device       /mount-point fstype     options      dumpfreq     passno</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>device</code></dt><dd><p>デバイス名。<a href=./#disks-naming>「デバイス名」</a> に説明があります。</p></dd><dt class=hdlist1><code>mount-point</code></dt><dd><p>ファイルシステムがマウントするディレクトリ。</p></dd><dt class=hdlist1><code>fstype</code></dt><dd><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> に渡されるファイルシステムタイプ。 FreeBSD ファイルシステムのデフォルトは <code>ufs</code> です。</p></dd><dt class=hdlist1><code>options</code></dt><dd><p>読み書きするファイルシステムには <code>rw</code>、読み込み専用のファイルシステムには <code>ro</code> を、必要な他のオプションの前に指定します。 よく使われるオプションは <code>noauto</code> で、 起動時にはマウントされないファイルシステムに使います。 その他のオプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> マニュアルページに載っています。</p></dd><dt class=hdlist1><code>dumpfreq</code></dt><dd><p>これは <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> が使うもので、 どのファイルシステムにダンプが必要なのかを決めます。 この項目がなければ、0 であるものとみなされます。</p></dd><dt class=hdlist1><code>passno</code></dt><dd><p>これは再起動後に <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> がチェックする UFS ファイルシステムの順番を決めます。
ファイルシステムチェックを飛ばしたいファイルシステムには、<code>passno</code> を 0 に設定してください。
ルートファイルシステムはどれよりも先にチェックする必要があり、<code>passno</code> は 1 に設定してください。 他のファイルシステムの <code>passno</code> は 1 以上に設定してください。 同じ <code>passno</code> のファイルシステムがあった場合、 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> は可能であれば並行してファイルシステムのチェック を行なおうとします。</p></dd></dl></div><div class=paragraph><p><code>/etc/fstab</code> の書式やオプションに関しての詳細は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> をご覧ください。</p></div></div><div class=sect3><h4 id=disks-mount>3.7.2. <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> の使い方<a class=anchor href=#disks-mount></a></h4><div class=paragraph><p>ファイルシステムは <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> を用いてマウントされます。
基本な構文は以下のようになります。</p></div><div class=exampleblock><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount device mountpoint</span></code></pre></div></div></div></div><div class=paragraph><p><code>/etc/fstab</code> に記載されているファイルシステムについても、マウントポイントを指定することでマウントできます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> で説明されているように、このコマンドはたくさんのオプションを提供します。
最もよく使われるのは次のものです。</p></div><div class=dlist><div class=title>マウントオプション</div><dl><dt class=hdlist1><code>-a</code></dt><dd><p><code>/etc/fstab</code> にある全てのファイルシステムをマウントします。 例外は "noauto" の印がついているものと、 <code>-t</code> フラグで除外されたものと、 すでにマウントされているファイルシステムです。</p></dd><dt class=hdlist1><code>-d</code></dt><dd><p>実際にマウントシステムコールする以外のすべてのことをします。 このオプションは <code>-v</code> フラグと組み合わせて使い、 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> が実際なにをしようとしているのか調べるのに便利です。</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>クリーンでないファイルシステムを強制的にマウントします (危険です)。もしくは、ファイルシステムのマウント状態を 読み書き可能から読み込みのみに変更するとき、 書き込みアクセスを強制的に取り消します。</p></dd><dt class=hdlist1><code>-r</code></dt><dd><p>ファイルシステムを読み込み専用でマウントします。
<code>-o ro</code> を使うのと同じです。</p></dd><dt class=hdlist1><code>-t <em>fstype</em></code></dt><dd><p>指定のファイルシステムタイプでマウントします。 または、<code>-a</code> を使った場合、 指定したタイプのファイルシステムのみマウントします。
デフォルトのファイルシステムタイプは "ufs" です。</p></dd><dt class=hdlist1><code>-u</code></dt><dd><p>ファイルシステムのマウントオプションを更新します。</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>詳細な出力にします。</p></dd><dt class=hdlist1><code>-w</code></dt><dd><p>ファイルシステムを読み書き可能にマウントします。</p></dd></dl></div><div class=paragraph><p><code>-o</code> には、 次のようなオプションを複数カンマで区切って指定できます。</p></div><div class=dlist><dl><dt class=hdlist1>nosuid</dt><dd><p>そのファイルシステム上の setuid や setgid フラグを解釈しません。 これもセキュリティのために有用なオプションです。</p></dd></dl></div></div><div class=sect3><h4 id=disks-umount>3.7.3. <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> の使い方<a class=anchor href=#disks-umount></a></h4><div class=paragraph><p>ファイルシステムをアンマウントするには、<a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> を使ってください。
このコマンドは、パラメータとしてマウントポイントの一つ、 デバイス名、もしくは <code>-a</code> や <code>-A</code> といったオプションを取ります。</p></div><div class=paragraph><p>いずれの形式でも <code>-f</code> で強制的なアンマウントを行ない、 <code>-v</code> で詳細な出力を出します。
ただしほとんどの場合、<code>-f</code> は使わないほうがよいでしょう。
計算機がクラッシュしたりファイルシステム上部のデータが破壊されたりする恐れがあります。</p></div><div class=paragraph><p>マウントされているファイルシステムすべてをアンマウントするには、<code>-a</code> と <code>-A</code> を使ってください。
<code>-t</code> にファイルシステムタイプを指定すると、指定されたものだけがアンマウントされます。
<code>-A</code> を使うとルートファイルシステムはアンマウントしません。</p></div></div></div><div class=sect2><h3 id=basics-processes>3.8. プロセスおよびデーモン<a class=anchor href=#basics-processes></a></h3><div class=paragraph><p>FreeBSD はマルチタスクのオペレーティングシステムです。
動作中のプログラムはそれぞれ <em>プロセス</em> と呼ばれます。
すべてのコマンドは実行すると、最低でも 1 つの新しいプロセスを開始します。
FreeBSD により実行されているシステムプロセスもたくさんあります。</p></div><div class=paragraph><p>各プロセスは <em>プロセス ID</em> (PID) と呼ばれる数字でただ一つに識別されます。
ファイルのように各プロセスには所有者とグループがあり、
所有者とグループの許可属性は、そのプロセスが開けるファイルやデバイスを決定するために使われます。
多くのプロセスには親プロセスもあります。
親プロセスとは、そのプロセスをスタートさせたプロセスのことです。
例えば、シェルがプロセスで、シェルから起動されるコマンドは、シェルを親プロセスとするプロセスとなります。
例外は <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> という特別なプロセスです。
<code>init</code> は FreeBSD がスタートするときに起動される最初のプロセスで、PID は常に <code>1</code> です。</p></div><div class=paragraph><p>ユーザから始終入力があるように設計されていないプログラムがあり、そういったプログラムは最初から端末と切り離されています。
例えば、ウェブサーバはユーザからの入力ではなくウェブのリクエストを処理します。
メールサーバも、 こういった種類のアプリケーションの一例です。
このような種類のプログラムは、 <em>デーモン</em> と呼ばれます。
デーモンはギリシャ神話から来ており、目に見えないように役立つことをしてくれる善でも悪でもない実体を表します。
このため、BSD のマスコットはスニーカーをはいてフォークを携えたかわいらしい姿のデーモンなのです。</p></div><div class=paragraph><p>通常デーモンとして動作するプログラムには末尾に "d" を持った名前をつける慣習があります。
例えば、BIND は Berkeley Internet Name Domain ですが、 実際実行されるプログラムは <code>named</code> です。
また、Apache ウェブサーバのプログラムは <code>httpd</code>、ラインプリンタスプーリングデーモンは <code>lpd</code> です。
これは単なる命名に関する慣習です。
例えば、Sendmail アプリケーションの主なメールデーモンは <code>sendmail</code> で、<code>maild</code> ではありません。</p></div><div class=sect3><h4 id=_プロセスを確認する>3.8.1. プロセスを確認する<a class=anchor href=#_プロセスを確認する></a></h4><div class=paragraph><p>システム上で実行中のプロセスを確認するには、<a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> または <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> を使ってください。
現在動作中のプロセスのリスト、プロセスの PID やプロセスが使っているメモリの量、どういうコマンドラインで起動されたのかなどを表示させるには、<a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> を使ってください。
<a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> を使用すると、動作中の全てのプロセスを表示できます。
数秒ごとに表示を更新するので、計算機が何をしているのかインタラクティブに知ることができます。</p></div><div class=paragraph><p>デフォルトでは、<a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> はユーザにより動作中かつ所有のコマンドのみを表示します。
例えば:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> の出力はいくつかの列に整形されています。
<code>PID</code> の列はプロセス ID を表示します。
PID は 1 から順に 99999 まで割り当てられ、その後足りなくなると最初に戻って使い回されます。ただし、使用中の PID には割り当てられません。
<code>TT</code> の列はプログラムが動いている tty を示し、<code>STAT</code> はプログラムの状態を示します。
<code>TIME</code> はプログラムがその CPU 上で動いている時間の長さです。
通常はプログラムをスタートさせたときからの経過時間ではありません。
多くのプログラムは、CPU 上で時間を使う必要があるまでかなりの時間を費すためです。
最後に、<code>COMMAND</code> はそのプログラムを起動するのに使われたコマンドとなります。</p></div><div class=paragraph><p>表示する情報を変更するオプションが用意されています。
いちばん便利なのは <code>auxww</code> でしょう。
<code>a</code> はすべてのユーザの動作中のプロセス全部についての情報を表示します。
<code>u</code> はプロセスの所有者のユーザ名とメモリ使用量を表示します。
<code>x</code> はデーモンプロセスについての情報を表示し、<code>ww</code> で、スクリーンに入りきらないほど長くなったコマンドラインでも省略せず、<a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> に各プロセスの全コマンドラインを表示させます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> の出力も同様です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top
last pid:  9609<span class=p>;</span>  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% <span class=nb>nice</span>,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 <span class=nt>-21</span>  r31   136M 42296K <span class=k>select  </span>0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K <span class=k>select  </span>3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K <span class=k>select  </span>0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M <span class=k>select  </span>0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M <span class=k>select  </span>2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K <span class=k>select  </span>3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K <span class=k>select  </span>1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K <span class=k>select  </span>1   0:05  0.00% kdeinit4</code></pre></div></div><div class=paragraph><p>出力は2つのセクションに分かれています。
ヘッダ (最初の 5 または 6 行) は動作している最新のプロセスの PID、システムの平均負荷 (システムがどれくらい忙しいかの指標)、システムの稼働時間 (最後の再起動からの時間) と現在の時刻を示します。
ヘッダの中の他の数字は動作中のプロセスの数、使われているメモリとスワップ領域の量、そしてシステムが異なる CPU 状態に消費した時間と関係します。
ZFS ファイルシステムのモジュールをロードしている場合には、<code>ARC</code> 行にはディスクではなくメモリキャッシュから読み込んだデータ量が表示されます。</p></div><div class=paragraph><p>ヘッダの下には、PID、ユーザ名、消費 CPU 時間とプロセスを起動したコマンドといった <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> の出力と同じような情報を持った行が続きます。
<a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> を使うとデフォルトでプロセスが使っているメモリ容量を表示します。
メモリ使用量の欄は 2 項目に分かれており、 一方は合計使用量、 そしてもう一方は実使用量です。
合計使用量はアプリケーションが必要としているメモリ量で、実使用量はその時点で実際に使われているメモリ量です。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> は自動的に 2 秒ごとに画面を更新します。
<code>-s</code> 使うと更新間隔を変更することができます。</p></div></div><div class=sect3><h4 id=basics-daemons>3.8.2. プロセスの終了<a class=anchor href=#basics-daemons></a></h4><div class=paragraph><p>動作中のプロセスもしくはデーモンと通信する一つの方法は、<a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> を用いて <em>シグナル</em> を送信する方法です。
送信可能なシグナルはたくさんあります。
特別な意味があるものもあれば、アプリケーションの文章に説明されているものもあります。
ユーザは自分が所有者となっているプロセスにのみシグナルを送ることができます。
他人のプロセスにシグナルを送ると、permission denied というエラーになるでしょう。
この例外は <code>root</code> ユーザで、 ルートユーザは誰のプロセスに対してもシグナルを送ることができます。</p></div><div class=paragraph><p>オペレーティングシステムもプロセスにシグナルを送ることができます。
アプリケーションを下手に書いてしまい、予想外のメモリにアクセスしようとすると、FreeBSD はプロセスに "セグメンテーション違反" シグナル (<code>SIGSEGV</code>) を送ります。
ある程度の時間が経ったら <a href="https://man.freebsd.org/cgi/man.cgi?query=alarm&amp;sektion=3&amp;format=html">alarm(3)</a> システムコールを使って警告してもらうように書かれているアプリケーションには、"警告" シグナル (<code>SIGALRM</code>) が送信されます。</p></div><div class=paragraph><p>プロセスを止めるためには2つのシグナル、<code>SIGTERM</code> か <code>SIGKILL</code> を使います。
<code>SIGTERM</code> は穏かにプロセスを終了させる方法です。
プロセスはシグナルを受け取ることができ、開いているすべてのログファイルを閉じ、終了前にしていたことを終えるように試みることができます。
中断できない処理の途中だと、<code>SIGTERM</code> をプロセスが無視することもあるかもしれません。</p></div><div class=paragraph><p>プロセスは <code>SIGKILL</code> を無視することができません。
プロセスに <code>SIGKILL</code> を送ると、プロセスは通常その時点で止まります。</p></div><div class=paragraph><p>他に良く使われるシグナルには、<code>SIGHUP</code>、<code>SIGUSR1</code> と <code>SIGUSR2</code> があります。
これらは一般的な用途のシグナルなので、このシグナルが送信されたときの応答は、アプリケーション毎に異なります。</p></div><div class=paragraph><p>例として、ウェブサーバの設定ファイルを変更後、ウェブサーバに設定を再読み込みさせる必要があります。
<code>httpd</code> を再起動するとウェブサーバは一瞬ながら停止してしまいます。
その代わりに <code>SIGHUP</code> シグナルを送りましょう。
デーモンごとに行動が違うので、<code>SIGHUP</code> が期待する結果となるように、そのデーモンの文書を読んで確認してください。</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>システム上のランダムプロセスを終了させるのはよくありません。
特に、PID が 1 の <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> は特別です。
<code>/bin/kill -s KILL 1</code> は推奨されていませんが、実行するといとも簡単にシステムをシャットダウンさせることができます。
<kbd>Return</kbd> を押す <em>前</em> に <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> を実行する引数を二重にチェックする <em>癖</em> をつけてください。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=shells>3.9. シェル<a class=anchor href=#shells></a></h3><div class=paragraph><p><em>シェル</em> は、オペレーティングシステムを利用するためのコマンドラインインタフェースを提供します。
シェルは入力チャンネルからコマンドを受け取り、それらを実行します。
大部分のシェルは、日々の作業、ファイル管理やファイル名の展開、コマンドライン編集、コマンドマクロ、環境変数といった組み込みの機能を持ってます。
FreeBSD には Bourne Shell (<a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>) や 高機能 C-shell (<a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>) が含まれています。
また、これ以外にも <code>zsh</code> や <code>bash</code> などのシェルが FreeBSD Ports Collection から利用可能です。</p></div><div class=paragraph><p>どのシェルを使うかは、まったく趣味の問題です。
あなたが C のプログラマだったとすれば、<a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> のような C 風のシェルの方が落ち着くかもしれません。
Linux® ユーザであれば、<code>bash</code> を好まれるでしょう。
それぞれのシェルは、 ユーザの好みの作業環境で利用できる (もしくはできない) 独自の機能を持っているということ、そして、どのシェルを使うことにするかを決めるのはユーザ自身ということです。</p></div><div class=paragraph><p>シェルの一般的な機能の一つに、ファイル名の補完があります。
コマンドやファイル名の最初の数文字を入力して <kbd>Tab</kbd> を押すと、シェルにコマンドやファイル名の残りの部分を補完させることができます。
例として、<code>foobar</code> および <code>footbar</code> という二つのファイルがあるとします。
<code>foobar</code> を削除するために <code>rm foo</code> と入力し、<kbd>Tab</kbd> を押してファイル名を補完しようとします。</p></div><div class=paragraph><p>しかしシェルは <code>rm foo</code> とだけ出力します。
<code>foobar</code> および <code>football</code> のファイル名は、両方とも <code>foo</code> から始まるため、ファイル名の補完を完全には行なえませんでした。
一つ以上のファイル名にマッチした場合、ビープ音をらすシェルもあれば、選択できるすべてのファイル名を表示するシェルもあります。
この場合、希望するファイル名を同定するために、ユーザはさらに文字を入力する必要があります。
<code>t</code> を入力してもう一度 <kbd>Tab</kbd> を押すと、シェルはファイル名を確定でき、ファイル名の残りの部分が補完されます。</p></div><div class=paragraph><p>もう一つあげられるシェルの特徴として、環境変数があります。
環境変数とは、シェルの環境変数におけるキーと値とのペアです。
この環境変数は、そのシェルから起動されたプログラムから参照でき、それを利用してプログラムの設定を保存するのに利用されます。
<a href=#shell-env-vars>一般的な環境変数</a> は、一般的な環境変数とその意味の一覧です。
環境変数の名前は常に大文字です。</p></div><table id=shell-env-vars class="tableblock frame-all grid-all stretch"><caption class=title>表 6. 一般的な環境変数</caption><col style=width:25%><col><tbody><tr><th class="tableblock halign-left valign-top"><p class=tableblock>変数名</p></th><td class="tableblock halign-left valign-top"><p class=tableblock>意味</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>USER</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>現在のログインユーザのユーザ名。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>PATH</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>コロンで区切られた実行ファイル探索のための ディレクトリのリスト。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>DISPLAY</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>接続する Xorg ディスプレイのネットワーク名 (存在する場合のみ)。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>SHELL</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>現在のシェル。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>TERM</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザの端末種名。 端末のケーパビリティを決定するのに使われる。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>TERMCAP</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>種々の端末の機能を実現する端末のエスケープコードの データベースのエントリ。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>OSTYPE</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>オペレーティングシステムの種別。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>MACHTYPE</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>システムの CPU アーキテクチャ。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>EDITOR</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザの選んだテキストエディタ。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>PAGER</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザの選んだ画面上でテキストを見るためのユーティリティ。</p></td></tr><tr><th class="tableblock halign-left valign-top"><p class=tableblock><code>MANPATH</code></p></th><td class="tableblock halign-left valign-top"><p class=tableblock>コロンで区切られたマニュアルページ探索のための ディレクトリのリスト。</p></td></tr></tbody></table><div class=paragraph><p>環境変数を設定する方法は、シェルごとに多少異なります。
<a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> では <code>setenv</code> を使います。
<a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> や <code>bash</code> 等の Bourne シェルでは、<code>export</code> を使って現在の環境変数を設定します。
以下の例では、<code>tcsh</code> シェルでデフォルトの <code>EDITOR</code> を <code>/usr/local/bin/emacs</code> に設定します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv EDITOR /usr/local/bin/emacs</code></pre></div></div><div class=paragraph><p><code>bash</code> では次のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>export </span><span class=nv>EDITOR</span><span class=o>=</span><span class=s2>&#34;/usr/local/bin/emacs&#34;</span></code></pre></div></div><div class=paragraph><p>現在の設定を確認するために、コマンドライン中の変数名の前に <code>$</code> 文字を置くことで、環境変数を展開させることができます。
たとえば、<code>echo $TERM</code> は <code>$TERM</code> が セットされている内容を表示します。</p></div><div class=paragraph><p>シェルは特殊文字を、特別なデータを表すものとして扱います。
その特殊文字はメタキャラクタと呼ばれます。
もっとも一般的なメタキャラクタは <code>*</code> で、これはファイル名に含まれる、あらゆる文字を表します。
メタキャラクタはファイル名の展開に使われます。
たとえば、<code>echo *</code> と入力すると <code>ls</code> と入力したのとほとんど同じ結果を得られます。
これはシェルが <code>*</code> とマッチするすべてのファイルを受け取って <code>echo</code> はコマンドラインでそれらを表示するからです。</p></div><div class=paragraph><p>特殊文字をシェルに解釈させないようにするため、特殊文字の前にバックスラッシュ文字 (<code>\</code>) を置いてエスケープしてください。
例えば <code>echo $TERM</code> は端末の設定を表示し、<code>echo \$TERM</code> は <code>$TERM</code> とそのまま表示します。</p></div><div class=sect3><h4 id=changing-shells>3.9.1. シェルの変更<a class=anchor href=#changing-shells></a></h4><div class=paragraph><p>デフォルトのシェルを変更する一番簡単な方法は <code>chsh</code> を使うことです。
このコマンドを実行すると、環境変数 <code>EDITOR</code> で示されたエディタ (デフォルトでは <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> が設定されている) が立ち上がります。
<code>Shell:</code> の行を変更するシェルの絶対パスに変更してください。</p></div><div class=paragraph><p>代わりに <code>chsh -s</code> を使うと、エディタを起動せずにシェルを変更できます。
たとえば、シェルを <code>bash</code> に変えたいなら、次のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% chsh <span class=nt>-s</span> /usr/local/bin/bash</code></pre></div></div><div class=paragraph><p>プロンプトに対してパスワードを入力し、<kbd>Return</kbd> を押すと、シェルが変更されます。
新しいシェルを使うには、一度ログオフしてから再ログインしてください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>使おうと思っているシェルは<em>必ず</em> <code>/etc/shells</code> 中に書かれていなければなりません。
シェルを <a href=./#ports>アプリケーションのインストール - packages と ports</a> で説明されている FreeBSD の Ports Collection からインストールしたのであれば、自動的にこのファイルに追加されています。
もし書かれていなければ、以下のコマンドで、パスをシェルのパスに置き換えて使って追加してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/local/bin/bash &gt;&gt; /etc/shells</span></code></pre></div></div><div class=paragraph><p>その後 <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a> を実行してください。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_高度なシェルの機能>3.9.2. 高度なシェルの機能<a class=anchor href=#_高度なシェルの機能></a></h4><div class=paragraph><p>UNIX® のシェルは単なるコマンドインタプリタではなく、ユーザが実行したコマンドの出力をリダイレクトしたり、入力をリダイレクトすることによりコマンドをお互いに繋げることで、最終的なコマンドの出力結果を改良できます。
この機能をビルトインコマンドとともに用いることで、ユーザは最大化された効率の環境を入手できます。</p></div><div class=paragraph><p>シェルのリダイレクト機能を使うことで、コマンドの出力や入力を別のコマンドに送ったり、ファイルに送ることができます。
たとえば、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> コマンドの出力をキャプチャするには、
出力をファイルにリダイレクトしてください。
以下はその例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=o>&gt;</span> directory_listing.txt</code></pre></div></div><div class=paragraph><p>実行すると、現在の作業ディレクトリにあるファイルの一覧が <code>directory_listing.txt</code> に出力されます。
<a href="https://man.freebsd.org/cgi/man.cgi?query=sort&amp;sektion=1&amp;format=html">sort(1)</a> のようなコマンドは、入力を読み込むことができます。
先ほど得たファイルの一覧をソートするには、入力元をファイルにリダイレクトしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sort</span> &lt; directory_listing.txt</code></pre></div></div><div class=paragraph><p>入力された内容はソートされ画面に出力されます。
この出力を他のファイルにリダイレクトするには、リダイレクトの向きを混ぜるように <a href="https://man.freebsd.org/cgi/man.cgi?query=sort&amp;sektion=1&amp;format=html">sort(1)</a> の出力をリダイレクトしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sort</span> &lt; directory_listing.txt <span class=o>&gt;</span> sorted.txt</code></pre></div></div><div class=paragraph><p>これまでの例では、ファイルディスクリプタを用いてコマンドに対しリダイレクトを行っています。
すべての UNIX® システムは標準入力 (stdin)、標準出力 (stdout) および標準エラー (stderr) といったファイルディスクリプタを持っています。
それぞれに対象があり、
入力はキーボードまたはマウスなどの入力を提供するものが対象、出力はスクリーンであったりプリンタ用紙が対象です。
また、エラーは診断やエラーメッセージに用いられるものが対象です。
これらは、I/O ベースのファイルディスクリプタ、時にはストリームと考えられます。</p></div><div class=paragraph><p>これらのディスクリプタを使用することで、シェルは出力と入力についてさまざまなコマンドを経由させ、また、ファイルに対して出力し、もしくはファイルから読み込むようにリダイレクトできます。
リダイレクトの他の方法は、パイプの機能です。</p></div><div class=paragraph><p>UNIX® のパイプ記号 "|" は、コマンドの出力を他のプログラムに直接渡します。
基本的には、パイプはコマンドの標準出力を他のコマンドの標準出力に渡します。
以下はその例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>directory_listing.txt | <span class=nb>sort</span> | less</code></pre></div></div><div class=paragraph><p>この例では、<code>directory_listing.txt</code> の内容がソートされ、その結果が <a href="https://man.freebsd.org/cgi/man.cgi?query=less&amp;sektion=1&amp;format=html">less(1)</a> に渡されます。
このコマンドを実行すると、出力がスクロールして画面から見えなくなることをさけることができて、ユーザは出力を自分のペースでスクロールできます。</p></div></div></div><div class=sect2><h3 id=editors>3.10. テキストエディタ<a class=anchor href=#editors></a></h3><div class=paragraph><p>FreeBSD の設定の多くは、テキストファイルの編集で行われます。
そのため、テキストエディタの扱いに慣れると良いでしょう。
FreeBSD には、基本システムの一部として二、三提供されるものと、Ports Collection から利用できる、たくさんのテキストエディタが用意されています。</p></div><div class=paragraph><p>学習が簡単なエディタは、 easy editor の略で <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a> と呼ばれるものです。
このエディタを立ち上げるには、<code>ee <em>filename</em></code> と入力してください。
ここで <em>filename</em> は、 編集しようとしているファイルの名前です。
一旦このコマンドの中に入れば、 エディタの機能を操作するコマンドはすべてディスプレイの上部に表示されています。
キャレット (<code>^</code>) は <kbd>Ctrl</kbd> を意味するので、<code>^e</code> は <span class=keyseq><kbd>Ctrl</kbd>+<kbd>e</kbd></span> を押すという意味になります。
<a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a> を終了するには <kbd>Esc</kbd> を押し、そしてメインメニューから "leave editor" オプションを選択してください。
ファイルが更新されていたときは、エディタは変更をセーブするかどうかプロンプトを出します。</p></div><div class=paragraph><p>FreeBSD には、ベースシステムの一部として <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> といったより強力なテキストエディタが用意されています。
<a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> および <a class=package href=https://cgit.freebsd.org/ports/tree/editors/vim/>editors/vim</a> といった他のエディタは Ports Collection の一部として用意されています。
これらのエディタはやや学習が複雑ですが、より高い機能性を提供します。
しかし、あなたが多量のテキストを編集することを考えているなら、 vim や Emacs といった強力なエディタを習得することは、 より多くの時間を節約することでしょう。</p></div><div class=paragraph><p>ファイルを編集したり、文字入力を必要とするようなアプリケーションの多くは、自動的にテキストエディタを起動します。
<a href=#shells>シェル</a> の節で説明したように、デフォルトのエディタを変更するには <code>EDITOR</code> 環境変数に希望するエディタを設定してください。</p></div></div><div class=sect2><h3 id=basics-devices>3.11. デバイスとデバイスノード<a class=anchor href=#basics-devices></a></h3><div class=paragraph><p>デバイスとはシステム上のハードウェアに関するものに対してよく使われる用語で、ディスクやプリンタ、グラフィックカードやキーボードが含まれます。
FreeBSD が起動するとき、ブートメッセージの大部分は検出されたデバイスについてのものです。
ブートメッセージは <code>/var/run/dmesg.boot</code> に保存されています。</p></div><div class=paragraph><p>各デバイスはデバイス名と番号を持ちます。
例えば、<code>ada0</code> は最初の SATA CD-ROM ドライブで、<code>kbd0</code> はキーボードを表します。</p></div><div class=paragraph><p>FreeBSD におけるほとんどのデバイス、デバイスノードと呼ばれる <code>/dev</code> にあるスペシャルファイルを通してアクセスしなければなりません。</p></div></div><div class=sect2><h3 id=basics-more-information>3.12. マニュアルページ<a class=anchor href=#basics-more-information></a></h3><div class=paragraph><p>FreeBSD についてのもっとも包括的な文書は、 マニュアルページの形式になっているものです。
FreeBSD システム上のほとんどすべてのプログラムには、基本的な操作方法と利用可能な引数を説明しているリファレンスマニュアルが添付されています。
これらのマニュアルは <code>man</code> を使って見ることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man コマンド名</code></pre></div></div><div class=paragraph><p>ここで <code>コマンド名</code> のところには、知りたいコマンドの名前を入れます。
たとえば <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> について知りたい場合には、次のように入力します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>ls</span></code></pre></div></div><div class=paragraph><p>マニュアルは、トピックごとにセクション番号で分類されています。
FreeBSD では、以下のセクションがあります。</p></div><div class="olist arabic"><ol class=arabic><li><p>ユーザコマンド</p></li><li><p>システムコールとエラー番号</p></li><li><p>C のライブラリ関数</p></li><li><p>デバイスドライバ</p></li><li><p>ファイル形式</p></li><li><p>ゲームや娯楽</p></li><li><p>さまざまな情報</p></li><li><p>システムの管理と操作のためのコマンド</p></li><li><p>システムカーネルインタフェース</p></li></ol></div><div class=paragraph><p>時折、 同じトピックがオンラインマニュアルの複数のセクションに記載されている場合があります。
たとえば、<code>chmod</code> ユーザコマンドと <code>chmod()</code> システムコールの場合がそれに該当します。
<a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> にセクション番号を与えることで、 表示したいセクションを指定できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man 1 <span class=nb>chmod</span></code></pre></div></div><div class=paragraph><p>上のようにすれば、ユーザコマンド <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> のマニュアルページが表示されます。
オンラインマニュアルの特定セクションへの参照は、慣習的に書かれている文書で括弧の中に示されます。
すなわち、<a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> はユーザコマンドを、<a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=2&amp;format=html">chmod(2)</a> はシステムコールの方を示しています。</p></div><div class=paragraph><p>マニュアルページの名前を知らない場合には、<code>man -k</code> を使ってマニュアルページの解説 (description) からキーワードを検索してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nt>-k</span> mail</code></pre></div></div><div class=paragraph><p>このコマンドは、"mail" というキーワードをコマンド解説に含むコマンドの一覧を表示します。
これは <a href="https://man.freebsd.org/cgi/man.cgi?query=apropos&amp;sektion=1&amp;format=html">apropos(1)</a> と同等の機能です。</p></div><div class=paragraph><p><code>/usr/sbin</code> にあるすべてのコマンドの説明を読むには、以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/sbin
% man <span class=nt>-f</span> <span class=k>*</span> | more</code></pre></div></div><div class=paragraph><p>または、以下を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/sbin
% whatis <span class=k>*</span> |more</code></pre></div></div><div class=sect3><h4 id=basics-info>3.12.1. GNU の Info ファイル<a class=anchor href=#basics-info></a></h4><div class=paragraph><p>FreeBSD には Free Software Foundation (FSF) によるアプリケーションやユーティリティが含まれています。
これらのプログラムには、マニュアルページに加えて <code>info</code> ファイルと呼ばれるハイパーテキスト形式の文書が付属しています。
この文書は <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a>、あるいは <a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> をインストールしているなら emacs の info モードで読むことができます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a> を使うには、次のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% info</code></pre></div></div><div class=paragraph><p><code>h</code> と入力すると、 簡単な手引きを読むことができます。 クイックコマンドリファレンスは <code>?</code> を入力してください。</p></div></div></div></div></div><div class=sect1><h2 id=ports>Chapter 4. アプリケーションのインストール - packages と ports<a class=anchor href=#ports></a></h2><div class=sectionbody><div class=sect2><h3 id=ports-synopsis>4.1. この章では<a class=anchor href=#ports-synopsis></a></h3><div class=paragraph><p>FreeBSD の基本システムには数多くのシステムツールが含まれています。 FreeBSD は、サードパーティ製のソフトウェアの導入を支援するために、 ソースコードをコンパイルしてインストールする Ports Collection と、 コンパイル済みのバイナリをインストールする packages という相補的な 2 つの技術を提供しています。 どちらのシステムを用いても、 ローカルメディアやネットワーク上からソフトウェアをインストールできます。</p></div><div class=paragraph><p>この章を読むと、以下のことがわかります。</p></div><div class=ulist><ul><li><p>packages と ports の違い</p></li><li><p>FreeBSD に移植されたサードパーティ製のソフトウェアの探し方</p></li><li><p>pkg を用いてバイナリ package を管理する方法</p></li><li><p>Ports Collection を用いてサードパーティ製のソフトウェアをソースコードから構築する方法</p></li><li><p>インストール後の設定のために、 アプリケーションとともにインストールされたファイルを探す方法</p></li><li><p>ソフトウェアのインストールに失敗した場合に、どうしたらよいか</p></li></ul></div></div><div class=sect2><h3 id=ports-overview>4.2. ソフトウェアのインストール<a class=anchor href=#ports-overview></a></h3><div class=paragraph><p>UNIX® システムでは、 サードパーティ製ソフトウェアの典型的なインストール手順は以下のようになります。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>ソースコード、 またはバイナリ形式で配布されているソフトウェアを探し出し、 ダウンロードする。</p></li><li><p>配布時のフォーマットからソフトウェアを取り出す。 一般的には <a href="https://man.freebsd.org/cgi/man.cgi?query=compress&amp;sektion=1&amp;format=html">compress(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=bzip2&amp;sektion=1&amp;format=html">bzip2(1)</a> または、<a href="https://man.freebsd.org/cgi/man.cgi?query=xz&amp;sektion=1&amp;format=html">xz(1)</a> といったプログラムで圧縮された tarball です。</p></li><li><p><span class=filename>INSTALL</span> または <span class=filename>README</span> ファイル、あるいは <span class=filename>doc/</span> サブディレクトのファイルからドキュメントを探しだし、 ソフトウェアのインストール方法を調べる。</p></li><li><p>ソース形式でソフトウェアが配布されている場合はコンパイルを行う。 ここでは、<span class=filename>Makefile</span> の編集、 または、<code>configure</code> スクリプトの実行を伴うことがあります。</p></li><li><p>ソフトウェアの動作を確認し、インストールする。</p></li></ol></div></div></div><div class=paragraph><p>FreeBSD <em>port</em> は、 アプリケーションをソースコードからコンパイルする際の処理を自動化するように設計されたファイルの集まりです。 port を構成するファイルは、 自動的にアプリケーションをダウンロードし、展開、パッチ作業、 コンパイル、そしてインストールを行うために必要な情報を含んでいます。</p></div><div class=paragraph><p>ソフトウェアが、すでに FreeBSD に移植され、 FreeBSD 上で試験されていなければ、 適切にインストールが行われ、動作するように、 編集する必要があるかもしれません。</p></div><div class=paragraph><p>しかしながら、<a href=https://www.FreeBSD.org/ja/ports/>36000</a> を越えるサードパーティ製アプリケーションが FreeBSD に移植されています。 可能な場合は、これらのアプリケーションをコンパイル済みの <em>packages</em> としてダウンロードできます。</p></div><div class=paragraph><p>package は、package 管理コマンドで扱うことができます。</p></div><div class=paragraph><p>packages と ports は依存関係を理解します。 package または port を用いてアプリケーションをインストールすると、 依存するライブラリがまだインストールされていない場合には、 最初にライブラリが自動的にインストールされます。</p></div><div class=paragraph><p>FreeBSD の package は、コンパイル済みのアプリケーションの全コマンド、 各種設定ファイルやドキュメントを含んでいます。 pkg コマンドでは、<code>pkg install</code> といったコマンドで、 package を扱うことができます。</p></div><div class=paragraph><p>2 つの技術は類似していますが、 packages と ports にはそれぞれ独自の特徴があります。 それぞれのアプリケーションのインストールに対する必要要件に応じてどちらかを選択してください。</p></div><div class=ulist><div class=title>package の利点</div><ul><li><p>一般的に、あるアプリケーションの package の tarball は、 ソースコードを含む tarball より小さなサイズとなります。</p></li><li><p>packages はコンパイルの時間を必要としません。 このことは、遅いシステム上で Mozilla, KDE, または GNOME といった大きなアプリケーションを扱う場合に重要となります。</p></li><li><p>packages を用いれば、 ソフトウェアのコンパイルに関する知識は必要ありません。</p></li></ul></div><div class=ulist><div class=title>port の利点</div><ul><li><p>packages は、通常最も多くのシステムで実行できるように、 非常に保守的な設定で構築されています。 port からコンパイルすることで、 コンパイルオプションを指定できます。</p></li><li><p>アプリケーションのなかには、 どの機能をインストールするかをコンパイル時に設定するものがあります。 たとえば、Apache は多種多様な ビルトインオプションを設定できます。</p><div class=paragraph><p>設定を区別するために、同じアプリケーションに対して 複数の packages が存在することがあります。 たとえば、Ghostscript は Xorg がインストールされているかどうかにより、 <span class=filename>ghostscript</span> package と <span class=filename>ghostscript-nox11</span> package が選択可能となっています。 アプリケーションのコンパイルオプションが 1 つもしくは 2 つ以上になると、 複数の packages を用意することは困難になります。</p></div></li><li><p>ライセンス条項で、 バイナリでの配布を禁止しているソフトウェアがあります。 このようなソフトウェアはソースコードで配布される必要があり、 エンドユーザがコンパイルしなくてはなりません。</p></li><li><p>バイナリ配布を信用していない人や、 潜在的な問題点を見つけ出すためにソースコードを読むことを好む人がいます。</p></li><li><p>カスタマイズしたパッチを適用するためには、 ソースコードが必要になります。</p></li></ul></div><div class=paragraph><p>ports の更新状況を把握するために、 <a href=https://lists.FreeBSD.org/subscription/freebsd-ports>FreeBSD ports メーリングリスト</a> や <a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>FreeBSD ports bugs メーリングリスト</a> を購読するとよいでしょう。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>アプリケーションをインストールする前に、 そのアプリケーションに関連したセキュリティ上の問題がないことを <a href=https://vuxml.freebsd.org/ class=bare>https://vuxml.freebsd.org/</a> で確認するか、<code>pkg audit -F</code> と入力して、 インストールされているアプリケーションに既知の脆弱性がないことを確認してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この章では、packages と ports を用いた FreeBSD 上での サードパーティ製ソフトウェアのインストール方法や管理方法について説明します。</p></div></div><div class=sect2><h3 id=ports-finding-applications>4.3. ソフトウェアの探し方<a class=anchor href=#ports-finding-applications></a></h3><div class=paragraph><p>FreeBSD 上で利用可能なアプリケーションのリストは常に増えています。 インストールするソフトウェアを探す方法はたくさん用意されています。</p></div><div class=ulist><ul><li><p>FreeBSD ウェブサイトは、 利用可能なすべてのアプリケーションの最新の一覧を、検索できる形で <a href=https://www.FreeBSD.org/ja/ports/>https://www.FreeBSD.org/ja/ports/</a> において公開しています。 ports はアプリケーションの名前や、ソフトウェアのカテゴリで検索出来ます。</p></li><li><p>Dan Langille は、包括的な検索ユーティリティや Ports Collection にあるアプリケーションの変更点を追跡する <a href=http://www.FreshPorts.org/>FreshPorts.org</a> を公開しています。 登録したユーザは、監視している ports がアップデートされた時に、 そのことを自動的にメールで知らせてくれるような、 カスタマイズ可能な監視リストを使うことができます。</p></li><li><p>アプリケーションを見つけることが難しい場合には、<a href=http://www.sourceforge.net/>SourceForge.net</a> または <a href=http://www.github.com/>GitHub.com</a> のようなサイトで探してみてください。 その後、そのアプリケーションが ports で利用可能かどうかを <a href=https://www.FreeBSD.org/ja/ports/>FreeBSD サイト</a> で調べて下さい。</p></li><li><p>バイナリ package リポジトリでアプリケーションを探すには、 以下のように実行してください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg search subversion</span>
git-subversion-1.9.2
java-subversion-1.8.8_2
p5-subversion-1.8.8_2
py27-hgsubversion-1.6
py27-subversion-1.8.8_2
ruby-subversion-1.8.8_2
subversion-1.8.8_2
subversion-book-4515
subversion-static-1.8.8_2
subversion16-1.6.23_4
subversion17-1.7.16_2</code></pre></div></div><div class=paragraph><p>package 名にはバージョン番号が含まれます。 また、python ベースの ports では、 共に構築された python のバージョン番号も含まれます。 ports によっては、複数のバージョンを利用できるものがあります。 subversion では、 複数のバージョンを利用できますが、 異なるコンパイルオプションで構築されたものも利用できます。 インストールする package を指定する際には、 アプリケーションに、port ツリーのパスである、 port のオリジンを指定すると良いでしょう。 <code>pkg search</code> に <code>-o</code> オプションを付けて、実行してください。 各 package のオリジンの一覧が表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg search -o subversion</span>
devel/git-subversion
java/java-subversion
devel/p5-subversion
devel/py-hgsubversion
devel/py-subversion
devel/ruby-subversion
devel/subversion16
devel/subversion17
devel/subversion
devel/subversion-book
devel/subversion-static</code></pre></div></div><div class=paragraph><p><code>pkg search</code> は、 リポジトリデータベースの説明やその他のフィールドにおいて、 シェルグロブ、正規表現、完全一致にも対応しています。 詳細については、<a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg/>ports-mgmt/pkg</a> または <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg-devel/>ports-mgmt/pkg-devel</a> のインストール後、 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-search&amp;sektion=8&amp;format=html">pkg-search(8)</a> をご覧ください。</p></div></li><li><p>Ports Collection がすでにインストールされていれば、 ports ツリーのローカルバージョンを調べることができます。 port がどのカテゴリに分類されているのかを知りたければ、 <a href="https://man.freebsd.org/cgi/man.cgi?query=whereis&amp;sektion=1&amp;format=html">whereis(1)</a> コマンドで調べることができます。 <code>whereis <em>ファイル</em></code> と入力してください。<em>ファイル</em> の部分にはインストールを考えているプログラム名を入れます。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># whereis lsof</span>
lsof: /usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>さらに、以下の例のように <a href="https://man.freebsd.org/cgi/man.cgi?query=echo&amp;sektion=1&amp;format=html">echo(1)</a> を使って調べることもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/ports/*/*lsof*</span>
/usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>この方法では <span class=filename>/usr/ports/distfiles</span> 以下にダウンロードされたファイル名にもマッチします。</p></div></li><li><p>また、Ports Collection に備わっている検索機能を利用して port を検索する方法もあります。 この検索機能を利用するには、 cd コマンドを用いて <span class=filename>/usr/ports</span> ディレクトリに移動し、<code>make search name=プログラム名</code> と入力してください。 <em>プログラム名</em> の部分には検索したいソフトウェアの名前を入れてください。 たとえば、<code>lsof</code> を探すには次のようにします。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make search name=lsof</span>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span>
Maint:  ler@lerctr.org
Index:  sysutils
B-deps:
R-deps:</code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Ports Collection に用意されている検索のメカニズムでは、 インデックスファイルを利用して検索を行います。 もし <span class=filename>INDEX</span> が必要であるというメッセージが表示されたら、 <code>make fetchindex</code> を実行して、 最新のインデックスファイルをダウンロードしてください。 <span class=filename>INDEX</span> が用意されれば、 <code>make search</code> で検索を実行できるでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p>"Path:" という行は、 port がどこにあるかを示しています。</p></div><div class=paragraph><p>より絞られた情報を得るには、 <code>quicksearch</code> と呼ばれる機能を使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make quicksearch name=lsof</span>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span></code></pre></div></div><div class=paragraph><p>もっと詳しく検索するには、 <code>make search key=<em>string</em></code> または <code>make quicksearch key=<em>string</em></code> と入力してください。 <em>string</em> の部分には検索したいテキストを入れます。 プログラムの名前がわからない場合でも、 ある目的に関連した ports の検索に利用できるよう、 テキストの部分には、コメント、 説明文および依存情報を入れることができます。</p></div><div class=paragraph><p><code>search</code> および <code>quicksearch</code> を使う場合には、 検索文字列中の大文字と小文字を区別せずに検索が行われるので、 "LSOF" を検索した結果は、 "lsof" と同じ検索結果になります。</p></div></li></ul></div></div><div class=sect2><h3 id=pkgng-intro>4.4. pkg によるバイナリ package の管理<a class=anchor href=#pkgng-intro></a></h3><div class=paragraph><p>pkg は、FreeBSD における伝統的な package 管理ツールの置き換えとなる次世代の管理ツールで、 バイナリ packages をより早く、 より簡単に管理できるようにする数多くの機能を提供します。</p></div><div class=paragraph><p>FreeBSD のミラーサイトが提供する事前に構築されたバイナリ package のみを使いたいと考えているサイトでは、 pkg を使って package を管理するとよいでしょう。</p></div><div class=paragraph><p>しかしながら、 ソースまたは自分自身で用意したリポジトリから構築したサイトでは、<a href=#ports-upgrading-tools>port 管理ツール</a> が別に必要となります。</p></div><div class=paragraph><p>pkg はバイナリ package のみを扱うので、 そのような管理ツールの置き換えとはなりません。 これらのツールは、ソフトウェアをバイナリ packages と Ports Collection の両形式からインストールできますが、 pkg はバイナリ packages のみをインストールします。</p></div><div class=sect3><h4 id=pkgng-initial-setup>4.4.1. pkg 入門<a class=anchor href=#pkgng-initial-setup></a></h4><div class=paragraph><p>FreeBSD には、 pkg およびマニュアルページをインストールするブートストラップユーティリティが用意されています。 このユーティリティは、FreeBSD 10.<em>X</em> 以降で動作するように設計されています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>このブートストラッププロセスは、すべての FreeBSD バージョンおよびアーキテクチャに対応しているわけではありません。 現在対応している一覧は、 <a href=https://pkg.freebsd.org/ class=bare>https://pkg.freebsd.org/</a> で確認することができます。 対応していない場合には、 Ports Collection またはバイナリ package から pkg をインストールする必要があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>システムをブートストラップするには、 以下を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/pkg</span></code></pre></div></div><div class=paragraph><p>ブートストラッププロセスに成功するには、 インターネットへの接続が必要です。</p></div><div class=paragraph><p>port をインストールするには以下を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/pkg</span>
<span class=c># make</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>古い pkg_* ツールを用いたシステムをアップグレードする際には、 新しいツールがすでにインストールされている package を認識するよう、 データベースを新しいフォーマットへと変換する必要があります。 pkg をインストールしたら、 以下のコマンドを実行して、package データベースをこれまでの伝統的なフォーマットから新しいフォーマットへと変換してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg2ng</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>このステップは、 サードパーティ製ソフトウェアがまだインストールされていないような、 新しくインストールされた直後のシステムでは必要ありません。</p></div></td></tr></tbody></table></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>このステップは非可逆です。 一度 package データベースを pkg フォーマットへと変換したら、伝統的な pkg_* ツールを使うべきではありません。</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>package データベースを変換する際には、 新しいバージョンへのデータ変換に伴ったエラーが出力されることがあります。 通常、これらのエラーは無視して構いませんが、 <code>pkg2ng</code> 終了後、 変換に失敗したソフトウェアの一覧が表示されます。 これらのソフトウェアを手動で再インストールする必要があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>FreeBSD のバージョンが 10.<em>X</em> より前であれば、 以下の行を <span class=filename>/etc/make.conf</span> に追加して、 Ports Collection がソフトウェアの登録に、伝統的な package のデータベースではなく、pkg を用いるように設定してください。</p></div><div class="literalblock programlisting"><div class=content><pre>WITH_PKGNG=	yes</pre></div></div><div class=paragraph><p>デフォルトでは、pkg は FreeBSD の package ミラー (<em>リポジトリ</em>) のバイナリ package を用います。 カスタム package リポジトリの構築については、 <a href=#ports-poudriere>Poudriere を用いた package の構築</a> をご覧ください。</p></div><div class=paragraph><p>その他の pkg の設定オプションは、<a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a> に記述されています。</p></div><div class=paragraph><p>pkg の利用情報は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> マニュアルページや、 <code>pkg</code> を引数なしに実行すると表示されます。</p></div><div class=paragraph><p>各 pkg コマンドの引数は、 コマンドに固有なマニュアルページに記述されています。 たとえば、<code>pkg install</code> のマニュアルページを読むには、 以下のコマンドのどちらかを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg help install</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># man pkg-install</span></code></pre></div></div><div class=paragraph><p>以下の節では、pkg を用いた通常のバイナリ package の管理について説明します。 各コマンドでは、カスタマイズのために、 多くのオプションが使われています。 詳細や、他の例については、 コマンドのヘルプやマニュアルページを参照してください。</p></div></div><div class=sect3><h4 id=quarterly-latest-branch>4.4.2. Quarterly および Latest Ports ブランチ<a class=anchor href=#quarterly-latest-branch></a></h4><div class=paragraph><p><code>Quarterly</code> ブランチを使うと、 ユーザは、port および package のインストールおよびアップグレードを、 より予測可能で安定して行うことができます。 基本的には、このブランチでは機能のアップデートは行われません。 Quarterly ブランチの目的は、セキュリティに関連する修正 (バージョンアップデートやコミットのバックポートなど)、 バグの修正および ports のコンプライアンスおよびフレームワークの変更の入手です。 Quarterly ブランチは、毎年の毎四半期 (1 月、4 月、7 月および 10 月) のはじめに HEAD から作成されます。 ブランチには、作成された年 (YYYY) をよび四半期 (Q1-4) により名前がつけられます。 たとえば、2016 年 1 月に作成された quarterly ブランチの名前は 2016Q1 となります。 <code>Latest</code> ブランチは、 最新バージョンの package をユーザに提供します。</p></div><div class=paragraph><p>quarterly から latest ブランチに移行するには、 以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/pkg/FreeBSD.conf /usr/local/etc/pkg/repos/FreeBSD.conf</span></code></pre></div></div><div class=paragraph><p><span class=filename>/usr/local/etc/pkg/repos/FreeBSD.conf</span> ファイルを編集して、<code>url:</code> 行の <em>quarterly</em> 文字列を <em>latest</em> に変更してください。</p></div><div class=paragraph><p>編集後は、以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>FreeBSD: {
  url: &#34;pkg+http://pkg.FreeBSD.org/${ABI}/latest&#34;,
  mirror_type: &#34;srv&#34;,
  signature_type: &#34;fingerprints&#34;,
  fingerprints: &#34;/usr/shared/keys/pkg&#34;,
  enabled: yes
}</pre></div></div><div class=paragraph><p>最後に、以下のコマンドを実行して (latest) リポジトリのメタデータからアップデートしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg update -f</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-pkg-info>4.4.3. インストールされている package の情報を入手する<a class=anchor href=#pkgng-pkg-info></a></h4><div class=paragraph><p>オプションを使用しないで <code>pkg info</code> を実行すると、 システムにインストールされているすべての package もしくは、 ある特定の package の情報が得られます。</p></div><div class=paragraph><p>たとえば、インストールされている pkg の情報を調べるには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg info pkg</span>
pkg-1.1.4_1</code></pre></div></div></div><div class=sect3><h4 id=pkgng-installing-deinstalling>4.4.4. package のインストールと削除<a class=anchor href=#pkgng-installing-deinstalling></a></h4><div class=paragraph><p>バイナリ package をインストールするには、 以下のコマンドを使ってください。 ここで <em>packagename</em> は、インストールする package の名前です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install packagename</span></code></pre></div></div><div class=paragraph><p>このコマンドは、リポジトリデータを使用して、 インストールすべきソフトウェアのバージョン、および、 インストールされていない依存ソフトウェアがあるかどうかを調べます。 たとえば、curl をインストールするには以下を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install curl</span>
Updating repository catalogue
/usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

/usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

Updating repository catalogue
The following 2 packages will be installed:

        Installing ca_root_nss: 3.15.1_1
        Installing curl: 7.31.0_1

The installation will require 3 MB more space

0 B to be downloaded

Proceed with installing packages <span class=o>[</span>y/N]: y
Checking integrity... <span class=k>done</span>
<span class=o>[</span>1/2] Installing ca_root_nss-3.15.1_1... <span class=k>done</span>
<span class=o>[</span>2/2] Installing curl-7.31.0_1... <span class=k>done
</span>Cleaning up cache files...Done</code></pre></div></div><div class=paragraph><p>新しい package と依存関係から追加された package は、 インストール済み package 一覧に表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg info</span>
ca_root_nss-3.15.1_1	The root certificate bundle from the Mozilla Project
curl-7.31.0_1	Non-interactive tool to get files from FTP, GOPHER, HTTP<span class=o>(</span>S<span class=o>)</span> servers
pkg-1.1.4_6	New generation package manager</code></pre></div></div><div class=paragraph><p>必要のなくなった packages は、 <code>pkg delete</code> を使って削除できます。 たとえば、以下のようにして削除できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg delete curl</span>
The following packages will be deleted:

	curl-7.31.0_1

The deletion will free 3 MB

Proceed with deleting packages <span class=o>[</span>y/N]: y
<span class=o>[</span>1/1] Deleting curl-7.31.0_1... <span class=k>done</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-upgrading>4.4.5. インストールされている package のアップグレード<a class=anchor href=#pkgng-upgrading></a></h4><div class=paragraph><p>以下のコマンドを実行すると、 インストールされている packages が最新のバージョンにアップグレードされます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg upgrade</span></code></pre></div></div><div class=paragraph><p>このコマンドは、インストールされているソフトウェアのバージョンと、 リポジトリのカタログから利用できるバージョンとを比較し、 リポジトリからアップグレードします。</p></div></div><div class=sect3><h4 id=pkgng-auditing>4.4.6. インストールされている package の検証<a class=anchor href=#pkgng-auditing></a></h4><div class=paragraph><p>サードウェア製アプリケーションに対する脆弱性は、 定期的に見つかります。脆弱性を調べるために、 pkg は、検証機能を持っています。 システムにインストールされているソフトウェアに既知の脆弱性がないかどうかを調べるには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg audit -F</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-autoremove>4.4.7. 使われていない package の自動削除<a class=anchor href=#pkgng-autoremove></a></h4><div class=paragraph><p>package を削除すると、不必要な依存 package が残されることがあります。 依存のためにインストールされたが、 現在は不必要になった package (リーフ package) は、 以下のコマンドで自動的に検出され、削除されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg autoremove</span>
Packages to be autoremoved:
	ca_root_nss-3.15.1_1

The autoremoval will free 723 kB

Proceed with autoremoval of packages <span class=o>[</span>y/N]: y
Deinstalling ca_root_nss-3.15.1_1... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>依存によりインストールされた packages は、 <em>automatic</em> package と呼ばれます。 非 automatic packages、 すなわち他の package からの依存ではなく、 明示的にインストールした package の一覧は以下のようにして出力できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg prime-list</span>
nginx
openvpn
<span class=nb>sudo</span></code></pre></div></div><div class=paragraph><p><code>pkg prime-list</code> は、 <span class=filename>/usr/local/etc/pkg.conf</span> で設定されているエイリアスコマンドです。 他にもシステムの package データベースの問い合わせに用いることができる多くのコマンドが用意されています。 たとえば、<code>pkg prime-origins</code> コマンドを使うと、 上記で得られた port 一覧のオリジナルの port ディレクトリを知ることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg prime-origins</span>
www/nginx
security/openvpn
security/sudo</code></pre></div></div><div class=paragraph><p>この一覧と <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a> または <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/synth/>ports-mgmt/synth</a> といったツールを使うと、 システムにインストールされているすべての package を再構築できます。</p></div><div class=paragraph><p>インストールされた package に automatic のマーク付けをするには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -A 1 devel/cmake</span></code></pre></div></div><div class=paragraph><p>リーフ package や automatic としてマークされた package は、 <code>pkg autoremove</code> で選択されます。</p></div><div class=paragraph><p>インストールされた package を <em>非</em> automatic とマークするには、以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -A 0 devel/cmake</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-backup>4.4.8. package データベースのリストア<a class=anchor href=#pkgng-backup></a></h4><div class=paragraph><p>伝統的な package 管理システムとは異なり、 pkg には package データベースをバックアップするメカニズムがあります。 この機能はデフォルトで有効に設定されています。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>スクリプトによる定期的な package データベースのバックアップを無効にするには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic.conf&amp;sektion=5&amp;format=html">periodic.conf(5)</a> の中で、 <code>daily_backup_pkgdb_enable="NO"</code> と設定してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>過去にバックアップした package データベースの中身をリストアするには、 以下のコマンドを実行してください。 以下のコマンドの <em>/path/to/pkg.sql</em> については、バックアップのある場所に置き換えて実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg backup -r /path/to/pkg.sql</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>システムの定期的なスクリプトによって取得されたバックアップをリストアする場合には、 リストアの前に展開しておく必要があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>手動で pkg データベースをバックアップするには、以下のコマンドを実行してください。 以下のコマンドの <em>/path/to/pkg.sql</em> については、適切なファイル名と場所に置き換えて下さい。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg backup -d /path/to/pkg.sql</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-clean>4.4.9. 古くなった package の削除<a class=anchor href=#pkgng-clean></a></h4><div class=paragraph><p>デフォルトでは、pkg は、<a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a> の <code>PKG_CACHEDIR</code> 変数で定義されるキャッシュディレクトリにバイナリ packages を保存します。 インストールされている package の最新のコピーのみが保存されます。 古いバージョンの pkg では、 過去にインストールされたすべての package が保存されていました。 これらの古くなったバイナリ package を削除するには、 以下を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg clean</span></code></pre></div></div><div class=paragraph><p>キャッシュ全体を削除するには以下を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg clean -a</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-set>4.4.10. package メタデータの変更<a class=anchor href=#pkgng-set></a></h4><div class=paragraph><p>FreeBSD Ports Collection では、メジャーバージョン番号が変更になることがあります。 これに対応するために、pkg には、 package の情報をアップデートするコマンドが組み込まれています。 たとえば、<span class=filename>lang/php5</span> が、 バージョン <code>5.4</code> を表すようになり、 <span class=filename>lang/php5</span> を <span class=filename>lang/php53</span> と名前を変更する必要があるような場合に、有用です。</p></div><div class=paragraph><p>上記の例の package の情報を変更するには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o lang/php5:lang/php53</span></code></pre></div></div><div class=paragraph><p>別の例として、<a class=package href=https://cgit.freebsd.org/ports/tree/lang/ruby18/>lang/ruby18</a> を <a class=package href=https://cgit.freebsd.org/ports/tree/lang/ruby19/>lang/ruby19</a> にアップデートするには、 以下のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o lang/ruby18:lang/ruby19</span></code></pre></div></div><div class=paragraph><p>最後の例として、 <span class=filename>libglut</span> 共有ライブラリの情報を <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/libglut/>graphics/libglut</a> から <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/freeglut/>graphics/freeglut</a> へと変更するには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o graphics/libglut:graphics/freeglut</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>package の情報を変更したら、 情報が変更された package に依存している packages を再インストールすることが重要となります。 依存 packages を再インストールするには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install -Rf graphics/freeglut</span></code></pre></div></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=ports-using>4.5. Ports Collection の利用<a class=anchor href=#ports-using></a></h3><div class=paragraph><p>Ports Collection は、<span class=filename>Makefile</span>, 修正パッチ、 説明文などの一連のファイルのことです。 これらのファイルの各セットは、 個々のアプリケーションをコンパイルして FreeBSD にインストールするために用いられ、<em>port</em> と呼ばれています。</p></div><div class=paragraph><p>デフォルトでは、Ports Collection は、<span class=filename>/usr/ports</span> 以下のサブディレクトリに置かれます。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Ports Collection をインストールして使用する前に、一般的には、
ソフトウェアのインストールに、pkg でダウンロードしたバイナリパッケージと Ports Collection を組み合わせて使うことはあまり良いことではないことを知っておいてください。
pkg は、デフォルトでは ports ツリーの (HEAD ではなく) quarterly ブランチリリースを追いかけます。
HEAD の port と対応する quarterly ブランチの port の依存関係は異なる可能性があり、そのため pkg でインストールされた依存関係と Ports Collection の依存関係の間で競合が起きることがあります。
もし、Ports Collection と pkg を組み合わせて使用しなければならないのであれば、Ports Collection と pkg が同じ ports ツリーのブランチを使用していることを必ず確認してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ports Collection は、ソフトウェアのカテゴリを表すディレクトリを持ちます。
各カテゴリには、各アプリケーションのサブディレクトリがあります。
各アプリケーションのサブディレクトリには、プログラムを FreeBSD 上で正しくコンパイルしてインストールする方法を提供する、 <em>ports スケルトン</em> と呼ばれるファイルのセットが含まれています。
それぞれの port スケルトンには、次のファイルおよびディレクトリが含まれています。</p></div><div class=ulist><ul><li><p><span class=filename>Makefile</span>: このファイルにはアプリケーションのコンパイル方法やシステムのどこにインストールするかを指定する命令文が含まれています。</p></li><li><p><span class=filename>distinfo</span>: このファイルには、その port を構築するためにダウンロードする必要があるファイルのファイル名と、チェックサム情報が含まれています。</p></li><li><p><span class=filename>files</span>: このディレクトリには FreeBSD 上でプログラムをコンパイルし、インストールするための修正パッチが含まれています。このディレクトリには、その port の構築に必要なその他のファイルが入る場合もあります。</p></li><li><p><span class=filename>pkg-descr</span>: このファイルにはプログラムに関する、より詳しい説明文が含まれます。</p></li><li><p><span class=filename>pkg-plist</span>: これは、その port によってインストールされる全ファイルのリストです。これにはプログラムを削除する際に、どのファイルを削除すれば良いのかを ports システムに伝える役割もあります。</p></li></ul></div><div class=paragraph><p>これらの他に <span class=filename>pkg-message</span> や特殊な状況に対応するためのファイルを含む ports もあります。
これらのファイルについての詳細および ports の一般的な説明については、<a href=https://docs.freebsd.org/ja/books/porters-handbook/>port 作成者のためのハンドブック</a> をご覧下さい。</p></div><div class=paragraph><p>port は実際のソースコード (<span class=filename>distfile</span> とも呼ばれます) を含んではいません。
port の構築の展開部で、ダウンロードされたソースは自動的に <span class=filename>/usr/ports/distfiles</span> に保存されます。</p></div><div class=sect3><h4 id=ports-using-installation-methods>4.5.1. Ports Collection のインストール<a class=anchor href=#ports-using-installation-methods></a></h4><div class=paragraph><p>port を用いてアプリケーションをコンパイルできるようにするには、 まず最初に Ports Collection をインストールする必要があります。 FreeBSD のインストール時に Ports Collection をインストールしていない場合には、 以下の方法のどれかを用いてインストールしてください。</p></div><div id=ports-using-git-method class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Git を用いる方法</strong></p></div><div class=paragraph><p>ports ツリーの管理が必要な場合や、 ローカルで変更点をメンテナンスする必要がある場合、 および FreeBSD-CURRENT を使用している場合には、 Git を使って Ports Collection を取得する方法があります。
Git のより詳細な説明については、<a href=https://docs.freebsd.org/en/articles/committers-guide/#git-primer>Git Primer</a> を参照してください。</p></div><div class="olist arabic"><ol class=arabic><li><p>Git を使って ports ツリーをチェックアウトする前に、Git をインストールしておく必要があります。
ports ツリーがすでにインストールされていれば、 以下のようにして Git をインストールできます。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/devel/git</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>ports ツリーが利用できない場合や、 package の管理に pkg を使っているのであれば、package から Git をインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install git</span></code></pre></div></div></li><li><p>HEAD ブランチの ports ツリーをチェックアウトしてください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># git clone https://git.FreeBSD.org/ports.git /usr/ports</span></code></pre></div></div></li><li><p>または、quarterly ブランチをチェックアウトしてください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># git clone https://git.FreeBSD.org/ports.git -b 2020Q3 /usr/ports</span></code></pre></div></div></li><li><p>Git で最初のチェックアウトをした後は、必要に応じて <span class=filename>/usr/ports</span> をアップデートしてください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># git -C /usr/ports pull</span></code></pre></div></div></li><li><p>必要に応じて <span class=filename>/usr/ports</span> を別の quarterly ブランチにスイッチしてください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># git -C /usr/ports switch 2020Q4</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=_ports_のインストール>4.5.2. ports のインストール<a class=anchor href=#_ports_のインストール></a></h4><div class=paragraph><p>この節では、Ports Collection を利用してプログラムをインストールしたり、 システムから削除したりする基本的な手順について説明します。 利用可能な <code>make</code> のターゲットや環境変数についての詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a> をご覧ください。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>いかなる port でも、構築する前には、 前節に書かれているように、Ports Collection をアップデートしてください。 サードパーティ製のソフトウェアをインストールすると、 セキュリティの脆弱性を引き起こす可能性があります。 その port に関連したセキュリティ上の問題がないことを、まずは <a href=https://vuxml.freebsd.org/ class=bare>https://vuxml.freebsd.org/</a> で確認してください。または、 新しい port をインストールする前に、 <code>pkg audit -F</code> を実行してください。 毎日のシステムのセキュリティ確認時に、 自動的にセキュリティの検査およびデータベースの更新を行うようにこのコマンドを設定できます。 詳しくは、<a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-audit&amp;sektion=8&amp;format=html">pkg-audit(8)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> を参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ports Collection は、ネットワークに接続できることを想定しています。 また、superuser の権限も必要となります。</p></div><div class=paragraph><p>port をコンパイルしてインストールするには、 インストールしたい port のディレクトリに移動してください。 その後、プロンプトから <code>make install</code> と入力してください。 すると、次のような出力が現われるはずです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span>
<span class=c># make install</span>
<span class=o>&gt;&gt;</span> lsof_4.88D.freebsd.tar.gz doesn<span class=s1>&#39;t seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.88
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.88D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.88.d,8
===&gt;  Applying FreeBSD patches for lsof-4.88.d,8
===&gt;  Configuring for lsof-4.88.d,8
...
[configure output snipped]
...
===&gt;  Building for lsof-4.88.d,8
...
[compilation output snipped]
...
===&gt;  Installing for lsof-4.88.d,8

===&gt;  Installing for lsof-4.88.d,8
...
[installation output snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.88.d,8
===&gt;   Registering installation for lsof-4.88.d,8
===&gt;  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
#</span></code></pre></div></div><div class=paragraph><p><code>lsof</code> は高い権限で動作するプログラムなので、 インストールする時にセキュリティに関する警告が表示されます。 インストールが終わったら、プロンプトが戻ります。</p></div><div class=paragraph><p>シェルによってはコマンドの実行ファイルを探す時間を短縮するために、 環境変数 <code>PATH</code> に登録されている ディレクトリのコマンド一覧をキャッシュするものがあります。 <code>tcsh</code> シェルを使っているのであれば、 フルパスを指定することなく新しくインストールしたコマンドを利用できるように、 <code>rehash</code> を実行してください。 <code>sh</code> シェルを使っているのであれば かわりに <code>hash -r</code> を実行してください。 詳細については、 あなたの使っているシェルのドキュメントをご覧ください。</p></div><div class=paragraph><p>インストールの間に、作業用ディレクトリが作成されます。 このディレクトリにはコンパイル時に使用されるすべての一時ファイルが含まれています。 このディレクトリを削除することで、ディスク容量を節約でき、また port を新しいバージョンへアップデートする際に問題が起こる可能性を小さくします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make clean</span>
<span class=o>===&gt;</span>  Cleaning <span class=k>for </span>lsof-88.d,8
<span class=c>#</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>port を構築する際に、 <code>make install clean</code> と実行することで、 これらの余分な手順を省くことができます。</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_ports_のインストールのカスタマイズ>4.5.2.1. ports のインストールのカスタマイズ<a class=anchor href=#_ports_のインストールのカスタマイズ></a></h5><div class=paragraph><p>ports の中にはビルドオプションを指定できるものがあります。 このオプションを指定することで、 アプリケーションの機能の一部を有効もしくは無効にできます。 また、セキュリティオプションを設定したり、 その他のカスタマイズを行うことができます。 このようなアプリケーションには <span class=filename>www/firefox</span>, <span class=filename>security/gpgme</span> や <span class=filename>mail/sylpheed-claws</span> などがあります。 port が他のカスタマイズ可能なオプションを持つ ports に依存する場合には、デフォルトでは、ユーザに port のオプションをメニューから選択させる設定のため、 何度もユーザとの対話が起こり待たされることがあります。 これを避けるには、まず最初に port スケルトンで <code>make config-recursive</code> を実行して設定を一括で行い、その後 <code>make install [clean]</code> を実行して port を構築してインストールしてください。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><code>config-recursive</code> を実行する際、 <code>all-depends-list</code> を実行すると、設定すべき ports の一覧を得ることができます。 多くの場合は、すべての依存 ports のオプションが定義され、 ports オプションの画面が表示されなくなり、 すべてのオプションが設定されたことを確認できるまで <code>make config-recursive</code> を実行すると良いでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p>port の構築後、 再びこのメニューを表示させてオプションの追加や削除、 設定の変更を行う方法はたくさんあります。 一つ目は port のディレクトリに <code>cd</code> で移動し、 <code>make config</code> と入力する方法です。 別の方法は <code>make showconfig</code> を使う方法です。 他の方法は <code>make rmconfig</code> の実行です。 このコマンドを実行すると選択されているすべてのオプションが削除され、 設定をもう一度やり直すことができます。 これらの方法や他の方法についての詳細は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a> マニュアルで説明されています。</p></div><div class=paragraph><p>ports は、いくつかの環境変数を参照する <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> を用いてソースファイルをダウンロードします。 FreeBSD システムがファイアウォールの内側であったり、 FTP/HTTP プロキシを使う場合には、 <code>FTP_PASSIVE_MODE</code>, <code>FTP_PROXY</code>, <code>FTP_PASSWORD</code> の環境変数を設定することなります。 対応している環境変数の一覧については <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> をご覧ください。</p></div><div class=paragraph><p>インターネットに常時接続できないユーザのために <code>make fetch</code> コマンドが用意されています。 このコマンドを <span class=filename>/usr/ports</span> で実行してすべての distfiles をダウンロードするか、 <span class=filename>/usr/ports/net</span> といったカテゴリや、あるスケルトンにおいても実行できます。 ある port がライブラリやその他の ports に依存している場合には、 別のカテゴリの ports の distfiles はダウンロードされ<em>ない</em>ことに注意してください。 port が依存しているすべての distfiles をダウンロードしたければ、 <code>make fetch-recursive</code> を使ってください。</p></div><div class=paragraph><p>めったにないことかもしれませんが、 ローカルに distfiles のリポジトリがあるような場合に、 <code>MASTER_SITES</code> 変数を変更することで <span class=filename>Makefile</span> で指定されているダウンロードの場所を 変更することができます。 設定する場合には、変更先を以下のようにして指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/directory</span>
<span class=c># make MASTER_SITE_OVERRIDE= \</span>
ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/ fetch</code></pre></div></div><div class=paragraph><p><code>WRKDIRPREFIX</code> 変数と <code>PREFIX</code> 変数を変更することで、 作業ディレクトリやターゲットディレクトリをデフォルトのものから変更できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=/usr/home/example/ports install</span></code></pre></div></div><div class=paragraph><p>とすると、ports は <span class=filename>/usr/home/example/ports</span> でコンパイルされ、すべて <span class=filename>/usr/local</span> 以下にインストールされます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make PREFIX=/usr/home/example/local install</span></code></pre></div></div><div class=paragraph><p>この場合、port のコンパイルは <span class=filename>/usr/ports</span> でおこない、<span class=filename>/usr/home/example/local</span> にインストールします。そして</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=../ports PREFIX=../local install</span></code></pre></div></div><div class=paragraph><p>とすれば両者を組み合わせることが可能です。</p></div><div class=paragraph><p>これらを環境変数に設定する方法もあります。 どのように環境変数を設定するかについては、 あなたの使っているシェルのマニュアルページを参照してください。</p></div></div></div><div class=sect3><h4 id=ports-removing>4.5.3. インストールした ports の削除<a class=anchor href=#ports-removing></a></h4><div class=paragraph><p>インストールされた ports は、 <code>pkg delete</code> コマンドで削除できます。 このコマンドの使用例は、<a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-delete&amp;sektion=8&amp;format=html">pkg-delete(8)</a> マニュアルページにあります。</p></div><div class=paragraph><p>あるいは、port のディレクトリにて <code>make deinstall</code> を実行することでも削除できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span>
<span class=c># make deinstall</span>
<span class=o>===&gt;</span>  Deinstalling <span class=k>for </span>sysutils/lsof
<span class=o>===&gt;</span>   Deinstalling
Deinstallation has been requested <span class=k>for </span>the following 1 packages:

	lsof-4.88.d,8

The deinstallation will free 229 kB
<span class=o>[</span>1/1] Deleting lsof-4.88.d,8... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>port が削除されるときに表示されるメッセージを読むことをお勧めします。 もし削除した port に依存するアプリケーションがあった場合には、 その情報が表示されますが、port の削除は行われます。 そのようなケースでは、依存を直すためにアプリケーションを再インストールするとよいでしょう。</p></div></div><div class=sect3><h4 id=ports-upgrading>4.5.4. ports のアップグレード<a class=anchor href=#ports-upgrading></a></h4><div class=paragraph><p>ports のインストール後、時間が経過すると、Ports Collection で新しいバージョンのソフトウェアを利用できるようになります。 この章では、 どのようにしてアップグレードする必要のあるソフトウェアを判断するか、 そしてアップグレードの方法について説明します。</p></div><div class=paragraph><p>インストールされている ports の新しいバージョンを利用できるかどうかを知るには、まず、 最新の ports ツリーがインストールされていることを確認してください。 これには、<a href=#ports-using-git-method>「Git を用いる方法」</a> で書かれているアップデートのコマンドを使ってください。
FreeBSD 10 以降のシステム、または、pkg に変換されたシステムでは、 以下のコマンドを実行すると、現在利用可能なバージョンよりも古い ports の一覧が表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg version -l &#34;&lt;&#34;</span></code></pre></div></div><div class=paragraph><p>FreeBSD 9.<em>X</em> より前のシステムでは、 現在利用可能なバージョンよりも古い ports の一覧を表示されるには、以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_version -l &#34;&lt;&#34;</span></code></pre></div></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>アップグレードする前に <span class=filename>/usr/ports/UPDATING</span> を、ファイルの頭から、ports を最後にアップデートした日、 もしくはシステムをインストールをした日に最も近い日まで目を通してください このファイルには port をアップグレードする際にユーザが遭遇するであろう問題や、 追加で必要な作業などが記述されています。 例えば、ファイル形式の変更や設定ファイルの場所の変更、 前のバージョンと互換性がなくなったことなどが書かれています。 アップグレードする必要のある ports に関連した手順に注意し、 アップグレードする際にはこれらの手順に従ってください。</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=ports-upgrading-tools>4.5.4.1. ports のアップグレードおよび管理ツール<a class=anchor href=#ports-upgrading-tools></a></h5><div class=paragraph><p>Ports Collection には、 実際にアップグレードを行うためのユーティリティがいくつか用意されています。 それぞれのユーティリティは長所と短所を持っています。</p></div><div class=paragraph><p>歴史的に、最もインストールされ使われているのは、 Portmaster または Portupgrade です。 Synth は新しいユーティリティです。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>特定のシステムにおいて、 どのツールを選択するとベストかについては、 システム管理者によります。 これらのどのツールでも、使う前には、 データのバックアップをとることが推奨されます。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=portmaster>4.5.4.2. portmaster を用いた ports のアップグレード<a class=anchor href=#portmaster></a></h5><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> は、 インストールされている ports のアップグレードをおこなう、 とても小さなユーティリティです。 FreeBSD のベースシステムとしてインストールされているツールだけを使い、 他の ports やデータベースに依存しないように設計されています。 port からこのユーティリティをインストールするには以下のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portmaster</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Portmaster は、 ports を 4 つのカテゴリに分類します。</p></div><div class=ulist><ul><li><p>Root ports: 他の port に依存せず、 他の port からも依存されない ports。</p></li><li><p>Trunk ports: 他の port には依存しないが、 他の port から依存されている ports。</p></li><li><p>Branch ports: 他の port に依存し、 他の port からも依存されている ports。</p></li><li><p>Leaf ports: 他の port に依存するが、 他の port からは依存されない ports。</p></li></ul></div><div class=paragraph><p>これらのカテゴリの一覧や、アップデート可能な port の一覧を表示するには以下のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -L</span>
<span class=o>===&gt;&gt;&gt;</span> Root ports <span class=o>(</span>No dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> ispell-3.2.06_18
<span class=o>===&gt;&gt;&gt;</span> screen-4.0.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: screen-4.0.3_1
<span class=o>===&gt;&gt;&gt;</span> tcpflow-0.21_1
<span class=o>===&gt;&gt;&gt;</span> 7 root ports
...
<span class=o>===&gt;&gt;&gt;</span> Branch ports <span class=o>(</span>Have dependencies, are depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> apache22-2.2.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: apache22-2.2.8
...
<span class=o>===&gt;&gt;&gt;</span> Leaf ports <span class=o>(</span>Have dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> automake-1.9.6_2
<span class=o>===&gt;&gt;&gt;</span> bash-3.1.17
        <span class=o>===&gt;&gt;&gt;</span> New version available: bash-3.2.33
...
<span class=o>===&gt;&gt;&gt;</span> 32 leaf ports

<span class=o>===&gt;&gt;&gt;</span> 137 total installed ports
        <span class=o>===&gt;&gt;&gt;</span> 83 have new versions available</code></pre></div></div><div class=paragraph><p>以下のコマンドを使うと、 古くなった ports をすべてアップデートします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -a</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Portmaster のデフォルトの設定では、 インストールされている port を削除する前に、 バックアップ用の package が作成されます。 このバックアップは、 新しいバージョンのインストールに成功すると削除されます。 <code>-b</code> を使うと、 Portmaster の自動的なバックアップの削除は行いません。 <code>-i</code> を追加すると、 Portmaster をインタラクティブモードで使用できます。 このモードでは、各 port をアップグレードするかどうかの選択を対話的に行うことがでます。 多くのオプションが利用可能です。 <a href="https://man.freebsd.org/cgi/man.cgi?query=portmaster&amp;sektion=8&amp;format=html">portmaster(8)</a> マニュアルページから、 それらの使用方法に関する詳細な説明を読んでください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>アップグレードの過程でエラーに遭遇した場合には、 <code>-f</code> を使ってすべての ports のアップグレードや再構築を行なってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>Portmaster を使ってシステムに新しい ports をインストールしたり、 新しい port のコンパイルやインストール前に依存するすべての port をアップグレードできます。この機能を使う時には、 Ports Collection の場所を指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster shells/bash</span></code></pre></div></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> に関するより多くの情報は、<span class=filename>pkg-descr</span> にあります。</p></div></div><div class=sect4><h5 id=portupgrade>4.5.4.3. Portupgrade を用いた ports のアップグレード<a class=anchor href=#portupgrade></a></h5><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> は、 インストールした ports のアップグレードを行なうためのもう一つのユーティリティです。 このユーティリティは ports を管理するために用いられるアプリケーションのセットをインストールします。 Ruby に依存します。 port をインストールするには、以下を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portupgrade</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>このユーティリティを使ってアップグレードを行う前に、 <code>pkgdb -F</code> を使って、 インストールされている ports の一覧を調べてください。 矛盾が検出された場合には修復してください。</p></div><div class=paragraph><p>システムにインストールされている port の中で古くなったものをすべてアップデートするには <code>portupgrade -a</code> を実行してください。 もし、すべての ports に対して個別にアップグレードするかどうかを確認したいのであれば、 <code>-i</code> を追加してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -ai</span></code></pre></div></div><div class=paragraph><p>ports で利用可能なすべてのアプリケーションではなく、 ある特定のアプリケーションだけを更新したいのであれば、 <code>portupgrade <em>pkgname</em></code> を実行してください。 アップグレードするアプリケーションが依存しているすべての ports をまず先に更新したい場合には、 <code>-R</code> を使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -R firefox</span></code></pre></div></div><div class=paragraph><p><code>-P</code> オプションを使うと、 portupgrade は <code>PKG_PATH</code> に登録されているローカルディレクトリから、 利用可能な package を探します。 ローカルに利用可能な packages が見つからなければ、 リモートサイトから package のダウンロードを試みます。 packages をローカルに見つけることができず、 リモートサイトからもダウンロードできない場合には、 portupgrade は ports からインストールを行ないます。 ports を使用したくなければ、<code>-PP</code> オプションを指定してください。 この最後のオプションを設定すると、 もし package が利用できなければ Portupgrade は終了します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -PP gnome3</span></code></pre></div></div><div class=paragraph><p>また、ビルドやインストールを行なわず、 distfiles または packages だけをダウンロードしたければ、 <code>-F</code> オプションを指定してください。 利用可能なすべてのオプションについては、 <a href="https://man.freebsd.org/cgi/man.cgi?query=portupgrade&amp;sektion=1&amp;format=html">portupgrade(1)</a> のマニュアルを参照してください。</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> に関するより多くの情報は、<span class=filename>pkg-descr</span> にあります。</p></div></div></div><div class=sect3><h4 id=ports-disk-space>4.5.5. ports とディスク容量<a class=anchor href=#ports-disk-space></a></h4><div class=paragraph><p>Ports Collection を使い続けていると、 そのうちディスクを食いつぶしてしまうでしょう。 ports をビルドしてインストールした後、 ports スケルトンで <code>make clean</code> を実行すると、作業用の <span class=filename>work</span> ディレクトリを削除します。 Portmaster を使って port をインストールする場合には、<code>-K</code> を使わなければこのディレクトリは自動的に削除されます。 Portupgrade がインストールされている場合には、 以下のコマンドはローカルの Ports Collection に見つかったすべての <span class=filename>work</span> ディレクトリを削除します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -C</span></code></pre></div></div><div class=paragraph><p>さらに、時間が経つにつれ <span class=filename>/usr/ports/distfiles</span> には、古くなったソースファイルがたまっていきます。 Portupgrade を使って、どの ports からも使われていないすべての distfiles を削除するには次のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -D</span></code></pre></div></div><div class=paragraph><p>Portupgrade を使って、システムにインストールされている port から使われていない distfiles をすべて削除することができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -DD</span></code></pre></div></div><div class=paragraph><p>もし Portmaster がインストールされているのであれば、以下を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster --clean-distfiles</span></code></pre></div></div><div class=paragraph><p>デフォルトでは、このコマンドはインタラクティブに設定されているため、 ユーザに対して distfile を削除すべきかどうかを確認するプロンプトが表示されます。</p></div><div class=paragraph><p>これらのコマンドに加え、<span class=filename>ports-mgmt/pkg_cutleaves</span> は、 必要なくなった ports を削除する作業を自動化します。</p></div></div></div><div class=sect2><h3 id=ports-poudriere>4.6. Poudriere を用いた package の構築<a class=anchor href=#ports-poudriere></a></h3><div class=paragraph><p>poudriere は、FreeBSD package を作成したり、試験に用いられる BSD ライセンスのユーティリティです。 このユーティリティは、FreeBSD jails を用いて、 独立したコンパイル環境を構築します。 これらの jail を使って、 インストールされている FreeBSD のバージョンとは異なるバージョンの package を作成したり、ホストが amd64 のシステムでは、 i386 用の package を構築することもできます。 構築された package のレイアウトは公式のミラーと同じです。 これらの package は、<a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> や他の package 管理ツールで利用できます。</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a> package または port から poudriere をインストールしてください。 アプリケーションをインストールすると、サンプルの設定ファイルである <span class=filename>/usr/local/etc/poudriere.conf.sample</span> もインストールされます。 このファイルを <span class=filename>/usr/local/etc/poudriere.conf</span> にコピーして、 ローカルの環境に合わせて編集してください。</p></div><div class=paragraph><p>poudriere を実行するシステムで、 必ずしも ZFS を使う必要はありませんが、 有用です。ZFS を使う際には、 <span class=filename>/usr/local/etc/poudriere.conf</span> の中で <code>ZPOOL</code> を指定する必要があります。 そして、<code>FREEBSD_HOST</code> を最も近いミラーに設定してください。 <code>CCACHE_DIR</code> を定義することで、 <a class=package href=https://cgit.freebsd.org/ports/tree/devel/ccache/>devel/ccache</a> を使ったコンパイルのキャッシュが可能となり、 コンパイルで頻繁に使われるコードの構築時間を短縮できます。 poudriere データセットを <span class=filename>/poudriere</span> にマウントされた独立したツリーに置くと良いでしょう。 他の値はデフォルトの値で十分です。</p></div><div class=paragraph><p>同時に走らせるコンパイル数の定義には、 認識されたコアプロセッサの数が用いられます。 RAM もしくはスワップ空間のどちらかの仮想メモリを十分用意してください。 もし、仮想メモリを使い切ってしまったら、jail の構築は中断し、 異常なメッセージが表示されることでしょう。</p></div><div class=sect3><h4 id=poudriere-initialization>4.6.1. Jails および Port ツリーの初期化<a class=anchor href=#poudriere-initialization></a></h4><div class=paragraph><p>設定が終わったら、poudriere を初期化して、必要とする FreeBSD ツリーおよび jail、 そして ports ツリーをインストールしてください。 jail の名前を <code>-j</code>、 FreeBSD のバージョンを <code>-v</code> で指定してください。 FreeBSD/amd64 システムでは、 <code>-a</code> を使ってアーキテクチャに <code>i386</code> または <code>amd64</code> を設定できます。 デフォルトでは、<code>uname</code> で表示されるアーキテクチャに設定されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere jail -c -j 13amd64 -v 13.1-RELEASE</span>
<span class=o>[</span>00:00:00] Creating 13amd64 fs at /poudriere/jails/13amd64... <span class=k>done</span>
<span class=o>[</span>00:00:00] Using pre-distributed MANIFEST <span class=k>for </span>FreeBSD 13.1-RELEASE amd64
<span class=o>[</span>00:00:00] Fetching base <span class=k>for </span>FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/base.txz              125 MB 4110 kBps    31s
<span class=o>[</span>00:00:33] Extracting base... <span class=k>done</span>
<span class=o>[</span>00:00:54] Fetching src <span class=k>for </span>FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/src.txz               154 MB 4178 kBps    38s
<span class=o>[</span>00:01:33] Extracting src... <span class=k>done</span>
<span class=o>[</span>00:02:31] Fetching lib32 <span class=k>for </span>FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/lib32.txz              24 MB 3969 kBps    06s
<span class=o>[</span>00:02:38] Extracting lib32... <span class=k>done</span>
<span class=o>[</span>00:02:42] Cleaning up... <span class=k>done</span>
<span class=o>[</span>00:02:42] Recording filesystem state <span class=k>for </span>clean... <span class=k>done</span>
<span class=o>[</span>00:02:42] Upgrading using ftp
/etc/resolv.conf -&gt; /poudriere/jails/13amd64/etc/resolv.conf
Looking up update.FreeBSD.org mirrors... 3 mirrors found.
Fetching public key from update4.freebsd.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata signature <span class=k>for </span>13.1-RELEASE from update4.freebsd.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata index... <span class=k>done</span><span class=nb>.</span>
Fetching 2 metadata files... <span class=k>done</span><span class=nb>.</span>
Inspecting system... <span class=k>done</span><span class=nb>.</span>
Preparing to download files... <span class=k>done</span><span class=nb>.</span>
Fetching 124 patches.....10....20....30....40....50....60....70....80....90....100....110....120.. <span class=k>done</span><span class=nb>.</span>
Applying patches... <span class=k>done</span><span class=nb>.</span>
Fetching 6 files... <span class=k>done</span><span class=nb>.</span>
The following files will be added as part of updating to
13.1-RELEASE-p1:
/usr/src/contrib/unbound/.github
/usr/src/contrib/unbound/.github/FUNDING.yml
/usr/src/contrib/unbound/contrib/drop2rpz
/usr/src/contrib/unbound/contrib/unbound_portable.service.in
/usr/src/contrib/unbound/services/rpz.c
/usr/src/contrib/unbound/services/rpz.h
/usr/src/lib/libc/tests/gen/spawnp_enoexec.sh
The following files will be updated as part of updating to
13.1-RELEASE-p1:
<span class=o>[</span>…]
Installing updates...Scanning //usr/share/certs/blacklisted <span class=k>for </span>certificates...
Scanning //usr/share/certs/trusted <span class=k>for </span>certificates...
 <span class=k>done</span><span class=nb>.</span>
13.1-RELEASE-p1:
<span class=o>[</span>00:04:06] Recording filesystem state <span class=k>for </span>clean... <span class=k>done</span>
<span class=o>[</span>00:04:07] Jail 13amd64 13.1-RELEASE-p1 amd64 is ready to be used</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere ports -c -p local -m git+https</span>
<span class=o>[</span>00:00:00] Creating <span class=nb>local </span>fs at /poudriere/ports/local... <span class=k>done</span>
<span class=o>[</span>00:00:00] Checking out the ports tree... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>一つのコンピュータ上で、 複数の設定、複数の jails、異なる port ツリーから poudriere は port をビルドできます。 これらのコンビネーションのカスタム設定は <em>セット</em> と呼ばれます。 詳細については、<a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a> もしくは <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere-devel/>ports-mgmt/poudriere-devel</a> をインストール後、 <a href="https://man.freebsd.org/cgi/man.cgi?query=poudriere&amp;sektion=8&amp;format=html">poudriere(8)</a> の CUSTOMIZATION の章をご覧下さい。</p></div><div class=paragraph><p>ここで示される基本設定では、jail, ports そしてセット固有の <span class=filename>make.conf</span> を <span class=filename>/usr/local/etc/poudriere.d</span> に置いてください。
この例でのファイル名 <span class=filename>13amd64-local-workstation-make.conf</span> は、jail 名、port 名そして、セット名の組み合わせで付けられています。
システムの <span class=filename>make.conf</span> と、この新しいファイルは、ビルド時に結合され、構築した jail で用いられる <span class=filename>make.conf</span> を作成します。</p></div><div class=paragraph><p>ビルドする package を <span class=filename>13amd64-local-workstation-pkglist</span> に記載してください。</p></div><div class="literalblock programlisting"><div class=content><pre>editors/emacs
devel/git
ports-mgmt/pkg
...</pre></div></div><div class=paragraph><p>特定の ports に対し、 オプションや依存を設定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere options -j 13amd64 -p local -z workstation -f 13amd64-local-workstation-pkglist</span></code></pre></div></div><div class=paragraph><p>最後に packages を構築し、 package リポジトリを生成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere bulk -j 13amd64 -p local -z workstation -f 13amd64-local-workstation-pkglist</span></code></pre></div></div><div class=paragraph><p>このコマンドの実行中に <span class=keyseq><kbd>Ctrl</kbd>+<kbd>t</kbd></span> を押すと、現在のビルド状況が表示されます。 Poudriere は <span class=filename>/poudriere/logs/bulk/jailname</span> にあるファイルも構築します。 このファイルをウェブサーバと共に使うことで、 ビルド情報を表示できます。</p></div><div class=paragraph><p>これが終わると、poudriere リポジトリを package のインストールに利用できるようになります。</p></div><div class=paragraph><p>poudriere を利用する上でのより多くの情報については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=poudriere&amp;sektion=8&amp;format=html">poudriere(8)</a> およびメインのウェブサイトである <a href=https://github.com/freebsd/poudriere/wiki class=bare>https://github.com/freebsd/poudriere/wiki</a> を参照してください。</p></div></div><div class=sect3><h4 id=_poudriere_リポジトリを使うための_pkg_クライアントの設定>4.6.2. Poudriere リポジトリを使うための pkg クライアントの設定<a class=anchor href=#_poudriere_リポジトリを使うための_pkg_クライアントの設定></a></h4><div class=paragraph><p>カスタムリポジトリと公式のリポジトリの両方を並行して使用することは可能ですが、 公式リポジトリを無効にすると有用な場合があります。 このように設定するには、設定ファイルを作成し、 設定ファイルの中で公式リポジトリを無効にしてください。 <span class=filename>/usr/local/etc/pkg/repos/FreeBSD.conf</span> を作成して、以下を含めてください。</p></div><div class="literalblock programlisting"><div class=content><pre>FreeBSD: {
	enabled: no
}</pre></div></div><div class=paragraph><p>通常は、HTTP 経由で poudriere リポジトリをクライアントコンピュータに公開すると簡単です。
package ディレクトリ (たとえば、 <span class=filename>/usr/local/poudriere/data/packages/13amd64</span> ) を公開するようにウェブサーバを設定してください。
この例で <span class=filename>13amd64</span> は構築名です。</p></div><div class=paragraph><p>もし、package リポジトリの URL が <code><a href=http://pkg.example.com/13amd64 class=bare>http://pkg.example.com/13amd64</a></code> であれば、 リポジトリの設定ファイルである <span class=filename>/usr/local/etc/pkg/repos/custom.conf</span> は、 以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>custom: {
	url: &#34;http://pkg.example.com/13amd64&#34;,
	enabled: yes,
}</pre></div></div></div></div><div class=sect2><h3 id=ports-nextsteps>4.7. インストール後の作業<a class=anchor href=#ports-nextsteps></a></h3><div class=paragraph><p>バイナリ package もしくは port のどちらを用いてソフトウェアをインストールするかに関わらず、 サードパーティ製のアプリケーションの多くは、 インストール後にある程度の設定を必要とします。 以下のコマンドや場所の情報は、 アプリケーションとともに何がインストールされたかを知るための助けとなるでしょう。</p></div><div class=ulist><ul><li><p>多くのアプリケーションでは、 デフォルトの設定ファイルが、少なくとも一つは <span class=filename>/usr/local/etc</span> にインストールされます。 数多くの設定ファイルを持つようなアプリケーションでは、 それらのファイルを格納するためにサブディレクトリを作成するものもあります。 サンプルの設定ファイルは、しばしば <span class=filename>.sample</span> といった拡張子がついた名前でインストールされます。 設定ファイルを確認し、 必要に応じてシステムの要求に合うように編集してください。 最初にサンプルファイルを <span class=filename>.sample</span> を外した名前のファイルにコピーしてから、編集してください。</p></li><li><p>ドキュメントが付属しているアプリケーションは、ドキュメントを <span class=filename>/usr/local/share/doc</span> にインストールします。
また、多くのアプリケーションは、マニュアルページもインストールします。
これらのドキュメントは、アプリケーションを使い続ける前に見ておくべきものです。</p></li><li><p>ある種のアプリケーションでは、 サービスを実行するためには、 アプリケーションの起動前に、 <span class=filename>/etc/rc.conf</span> に追加する必要があります。 これらのアプリケーションでは、通常、 スタートアップスクリプトが <span class=filename>/usr/local/etc/rc.d</span> にインストールされます。詳細は、 <a href=./#configtuning-starting-services>サービスの起動</a> をご覧ください。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>設計上、インストールの際に、アプリケーションは、 スタートアップスクリプトを実行しませんし、 アンインストールやアップグレードの際には、 停止のためのスクリプトは実行されません。 起動や停止の決定は、各システム管理者に任されています。</p></div></td></tr></tbody></table></div></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> のユーザは、 <code>rehash</code> を実行して、 シェルの <code>PATH</code> のバイナリリストを再構築してください。</p></li><li><p><code>pkg info</code> を使って、アプリケーションと共にインストールされたファイル、 マニュアルページ、およびバイナリを調べることができます。</p></li></ul></div></div><div class=sect2><h3 id=ports-broken>4.8. うまく動作しない ports に遭遇した場合には<a class=anchor href=#ports-broken></a></h3><div class=paragraph><p>port をうまくコンパイルできなかったりインストールできない場合には、 以下を試してください。</p></div><div class="olist arabic"><ol class=arabic><li><p>その port に対する修正案が提出されていないかどうかを <a href=https://www.FreeBSD.org/ja/support/>障害報告 (Problem Report) データベース</a> で調べてください。 もし提案されていれば、 その提案されている修正によって問題を解決できるかもしれません。</p></li><li><p>port の保守担当者に対応してもらいましょう。
port スケルトンで <code>make maintainer</code> と入力するか、port の <span class=filename>Makefile</span> を読み、保守担当者の電子メールアドレスを調べてください。
保守担当者にメールを送る際には、エラーが出力されるまでの出力ログを忘れずに添付してください。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>特定の保守担当者が存在せず、かわりに <a href=https://docs.freebsd.org/en/articles/mailing-list-faq/>メーリングリスト</a> によるグループの管理者が保守している ports があります。 そのような場合には、メールアドレスは <a href=mailto:freebsd-listname@FreeBSD.org>freebsd-listname@FreeBSD.org</a> のようになります。 メールを送る際には、このことに気をつけてください。</p></div><div class=paragraph><p>特に <a href=mailto:ports@FreeBSD.org>ports@FreeBSD.org</a> が保守している ports には、保守担当者がいません。 そのかわり、 そのメーリングリストを購読する人々からなるコミュニティが、 修正や対応をおこなっています。 もっとボランティアが必要です!</p></div></td></tr></tbody></table></div><div class=paragraph><p>メールに対して返信がなければ、<a href=https://docs.freebsd.org/ja/articles/problem-reports/>FreeBSD 障害報告の書き方</a> に書かれている手順にしたがい、 Bugzilla を使ってバグレポートを提出してください。</p></div></li><li><p>自分で直しましょう! ports システムに関する詳細な情報は <a href=https://docs.freebsd.org/ja/books/porters-handbook/>port 作成者のためのハンドブック</a> にあります。 このセクションを読むと、壊れてしまった port を直したり、 自分で作った port を提出したりできるようになります!</p></li><li><p><a href=#pkgng-intro>pkg によるバイナリ package の管理</a> に書かれている手順にしたがって、 package をインストールしてください。</p></li></ol></div></div></div></div><div class=sect1><h2 id=x11>Chapter 5. X Window System<a class=anchor href=#x11></a></h2><div class=sectionbody><div class=sect2><h3 id=x11-synopsis>5.1. この章では<a class=anchor href=#x11-synopsis></a></h3><div class=paragraph><p>bsdinstall を用いた FreeBSD のインストールでは、 グラフィカルユーザインタフェースは自動的にはインストールされません。 この章では、グラフィカル環境で使われるオープンソースの X Window System を提供する Xorg のインストールおよび設定方法について説明します。 その後、 デスクトップ環境およびウィンドウマネージャの探し方およびインストール方法について説明します。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Xorg を自動的に設定するインストール方法を希望するユーザは、<a href=https://ghostbsd.org>GhostBSD</a>, <a href=https://www.midnightbsd.org>MidnightBSD</a> または <a href=https://nomadbsd.org/>NomadBSD</a> を参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>Xorg が対応するビデオハードウェアについてのより多くの情報は、 <a href=http://www.x.org/>x.org</a> のウェブサイトをご覧ください。</p></div><div class=paragraph><p>この章を読めば以下のことがわかります。</p></div><div class=ulist><ul><li><p>X Window System のさまざまなコンポーネントと、 それらが互いにどのように連携しているか。</p></li><li><p>Xorg のインストールおよび設定方法</p></li><li><p>さまざまなウィンドウマネージャおよびデスクトップ環境のインストールおよび設定方法</p></li><li><p>Xorg での TrueType® フォントの使い方</p></li><li><p>GUI ログイン (XDM) の設定方法</p></li></ul></div><div class=paragraph><p>この章を読み始める前に以下のことを理解しておく必要があります。</p></div><div class=ulist><ul><li><p><a href=./#ports>アプリケーションのインストール - packages と ports</a> で説明されているサードパーティ製ソフトウェアのインストール方法</p></li></ul></div></div><div class=sect2><h3 id=x-understanding>5.2. 用語の説明<a class=anchor href=#x-understanding></a></h3><div class=paragraph><p>X Window System のさまざまなコンポーネントについての詳細や、 それらがどのようにやり取りするかについてすべて理解する必要はありませんが、 これらのコンポーネントについて基本的なことを知っていると、 強力な武器になるでしょう。</p></div><div class=dlist><dl><dt class=hdlist1>X サーバ</dt><dd><p>X は最初からネットワークを意識してデザインされており、 "クライアント - サーバ" モデルを採用しています。 このモデルでは、"X サーバ" はキーボードやモニタ、 マウスが接続されたコンピュータ上で動きます。 このサーバはディスプレイの表示を管理したり、キーボード、 マウスからの入力を処理したり、 タブレットやビデオプロジェクタ等の他の装置からの入出力を処理します。 これは、ある人々を混乱させることがあります。 X での用語は彼らが想定するものとは正反対だからです。 彼らは "X サーバ" は地下にある大きなパワフルなマシンであり、 "X クライアント" が自分たちのデスク上にあると想像するのです。</p></dd><dt class=hdlist1>X クライアント</dt><dd><p>XTerm や Firefox などの各 X アプリケーションは、 "クライアント" になります。 クライアントは "この座標にウィンドウを描いてください" といったメッセージをサーバへ送り、サーバは "ユーザが OK ボタンを押しました" といったメッセージを送り返します。</p><div class=paragraph><p>家庭や小さなオフィスのような環境では、X サーバと X クライアントは通常同じコンピュータ上で動いています。 X サーバを非力なコンピュータで動かし、 X アプリケーションをより高性能なマシンで動かすことも可能です。 この場合、 X のクライアントとサーバの通信はネットワーク越しに行なわれます。</p></div></dd><dt class=hdlist1>ウィンドウマネージャ</dt><dd><p>X はスクリーン上でウィンドウがどのように見えるべきか、 マウスでそれらをどうやって動かすか、 ウィンドウ間を移動するのにどういうキーストロークを使うべきか、 各ウィンドウのタイトルバーはどのように見えるべきか、 クローズボタンを持つべきかどうか、 といったことは規定しません。そのかわりに、X ではそういったことを "ウィンドウマネージャ" と呼ばれるアプリケーションに任せます。<a href=http://www.xwinman.org/>ウィンドウマネージャはたくさん</a> あります。 これらのウィンドウマネージャの見た目や使い勝手はそれぞれ異なっています。 バーチャルデスクトップをサポートしているものもありますし、 デスクトップを操作するキーストロークをカスタマイズできたり、 "スタート" ボタンやそれに類するものを持っているものもあります。 テーマに対応しており、 デスクトップの見た目や使い勝手を完全に変えられるものもあります。 ウィンドウマネージャは Ports Collection の <span class=filename>x11-wm</span> カテゴリに用意されています。</p><div class=paragraph><p>それぞれのウィンドウマネージャは異なる設定機構を備えています。 手で設定ファイルを編集しなければならないものや、 設定作業のほとんどを GUI ツールで行うことができるものもあります。</p></div></dd><dt class=hdlist1>デスクトップ環境</dt><dd><p>KDE や GNOME は、デスクトップ環境です。 これらは、共通のデスクトップのタスクを実行するための完全なアプリケーションスイートを含んでいます。 オフィススイート、ウェブブラウザやゲームを含んでいるものもあります。</p></dd><dt class=hdlist1>フォーカスポリシ</dt><dd><p>ウィンドウマネージャは、 マウスのフォーカスポリシに責任を持ちます。 このポリシは、どのウィンドウがアクティブにキーストロークを 受け付けるようにするための方法を提供し、 そして、どのウィンドウがアクティブなのかを示します。</p><div class=paragraph><p>よく知られているフォーカスポリシは "click-to-focus" と呼ばれるものです。 このポリシは、 あるウィンドウ内でマウスをクリックすればそのウィンドウがアクティブになる、 というものです。 "focus-follows-mouse" ポリシでは、 マウスポインタの下にいるウィンドウがフォーカスされるというものです。 フォーカスを変えるには他のウィンドウにマウスポインタを動かすだけです。 マウスがルートウィンドウに移動した時には、 このウィンドウがフォーカスされます。 "sloppy-focus" モデルでは、 マウスがルートウィンドウに移動した時には、 直前に使われていたウィンドウがフォーカスされています。 sloppy-focus では、 ポインタが別のウィンドウに移った時のみフォーカスが変わり、 現在のウィンドウから出ただけでは変わりません。 "click-to-focus" ポリシでは、 マウスクリックによりアクティブなウィンドウが選択されます。 ウィンドウは前面に表示され、他のすべてのウィンドウの前にきます。 ポインタが別のウィンドウ上に移動した時でも、 すべてのキーストロークがこのウィンドウに届きます。</p></div><div class=paragraph><p>それぞれのウィンドウマネージャは、 それぞれのフォーカスポリシに対応しています。 すべてのものは click-to-focus をサポートしていますし、 多くのものは他の方法もサポートしています。 どのフォーカスモデルを利用可能かどうかについては、 ウィンドウマネージャのドキュメントをご覧ください。</p></div></dd><dt class=hdlist1>ウィジェット</dt><dd><p>ウィジェットはクリック可能であったり、 他の方法で操作可能なすべてのユーザインタフェース用アイテムを指す用語です。 ボタンやチェックボックス、ラジオボタン、アイコン、リスト、などがそうです。 ウィジェットツールキットはグラフィカルアプリケーションを作成するために使われます。 KDE で使われている Qt や GNOME プロジェクトで使われている GTK+ といった有名なウィジェットセットがあります。 そのため、アプリケーションのルックアンドフィールは、 アプリケーションを作成するのに使われたウィジェットツールキットに依存し、 異なります。</p></dd></dl></div></div><div class=sect2><h3 id=x-install>5.3. Xorg のインストール<a class=anchor href=#x-install></a></h3><div class=paragraph><p>FreeBSD では、Xorg を package または port からインストールできます。</p></div><div class=paragraph><p>バイナリ package を使うと早くインストールできますが、 カスタマイズのためのオプションは少なくなります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xorg</span></code></pre></div></div><div class=paragraph><p>Ports Collection からビルドしてインストールするには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/xorg</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>どちらの方法でも、完全な Xorg システムがインストールされます。 バイナリ package を用いる方法が、 ほとんどのユーザにとってはベストな選択となります。</p></div><div class=paragraph><p>経験のあるユーザ向けの最小の X システムは、<span class=filename>x11/xorg-minimal</span> です。 ほとんどのドキュメント、 ライブラリおよびアプリケーションはインストールされません。 アプリケーションによってはこれらの追加の要素が機能する上で必要となります。</p></div></div><div class=sect2><h3 id=x-config>5.4. Xorg の設定<a class=anchor href=#x-config></a></h3><div class=sect3><h4 id=x-config-quick-start>5.4.1. クィックスタート<a class=anchor href=#x-config-quick-start></a></h4><div class=paragraph><p>Xorg は、 標準的なほとんどのビデオカード、 キーボード、ポインティングデバイスに対応しています。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>ビデオカード、キーボード、入力デバイスは、 自動的に検出されるので、手動の設定は必要ありません。 自動認識に失敗したとき以外は、<span class=filename>xorg.conf</span> を作成したり、<code>-configure</code> プロセスの実行は行わないでください。</p></div></td></tr></tbody></table></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>もし、使用しているコンピュータですでに Xorg が使われているのであれば、 コンフィグレーションファイルを移動するか、削除してください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /etc/X11/xorg.conf ~/xorg.conf.etc</span>
<span class=c># mv /usr/local/etc/X11/xorg.conf ~/xorg.conf.localetc</span></code></pre></div></div></li><li><p>3D アクセラレータを利用できるシステムでは、 Xorg を実行するユーザを <code>video</code> または <code>wheel</code> グループに追加して、使用できるようにしてください。 ユーザ <em>jru</em> をどちらのグループでも利用できるようにするには以下のように実行してください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod video -m jru || pw groupmod wheel -m jru</span></code></pre></div></div></li><li><p>デフォルトでは twm ウィンドウマネージャがインストールされています。 Xorg が起動すると、 このウィンドウマネージャが立ち上がります。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% startx</code></pre></div></div></li><li><p>古いバージョンの FreeBSD では、 テキストコンソールに戻れるようにするために、 システムコンソールは <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> に設定する必要があります。 <a href=#x-config-kms>Kernel Mode Setting (KMS)</a> を参照してください。</p></li></ol></div></div></div></div><div class=sect3><h4 id=x-config-user-group>5.4.2. Accelerated Video のためのユーザグループ<a class=anchor href=#x-config-user-group></a></h4><div class=paragraph><p>ビデオカードの 3D アクセラレータを有効にするには、 <span class=filename>/dev/dri</span> へのアクセスが必要となります。 通常は、X を実行するユーザを <code>video</code> または <code>wheel</code> グループに追加するするだけです。 ここでは、<a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> を使ってユーザ <em>slurms</em> を <code>video</code> グループ、または <code>video</code> グループが存在しない時に、 <code>wheel</code> グループに追加しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod video -m slurms || pw groupmod wheel -m slurms</span></code></pre></div></div></div><div class=sect3><h4 id=x-config-kms>5.4.3. Kernel Mode Setting (KMS)<a class=anchor href=#x-config-kms></a></h4><div class=paragraph><p>コンピュータが、コンソールの表示から、 X 用の高解像度の表示へと切り替える時には、 ビデオの出力 <em>mode</em> が設定されている必要があります。 最近の Xorg では、 カーネル内部のシステムを使って効率的にこれらのモードの変換をしています。 古いバージョンの FreeBSD では、 KMS システムを用いない <a href="https://man.freebsd.org/cgi/man.cgi?query=sc&amp;sektion=4&amp;format=html">sc(4)</a> が使用されています。 X を閉じた後、システムコンソールは動作をしていても、 表示に黒になります。 新しい <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> コンソールではこの問題は起こりません。</p></div><div class=paragraph><p>以下の行を <span class=filename>/boot/loader.conf</span> に追加して <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> を有効にしてください。</p></div><div class="literalblock programlisting"><div class=content><pre>kern.vty=vt</pre></div></div></div><div class=sect3><h4 id=x-config-files>5.4.4. コンフィグレーションファイル<a class=anchor href=#x-config-files></a></h4><div class=paragraph><p>通常、この節で説明する手動の設定は必要ありません。 自動認識に失敗したとき以外は、 手動で設定ファイルを作成しないでください。</p></div><div class=sect4><h5 id=x-config-files-directory>5.4.4.1. ディレクトリ<a class=anchor href=#x-config-files-directory></a></h5><div class=paragraph><p>Xorg は、 複数のディレクトリから設定ファイルを探します。 FreeBSD において、設定ファイルのディレクトリは、 <span class=filename>/usr/local/etc/X11/</span> が推奨されます。 このディレクトリを使うことで、 アプリケーションのファイルをオペレーティングシステムとは区別する事になります。</p></div><div class=paragraph><p>昔のコンフィグレーションファイルの置き場である <span class=filename>/etc/X11/</span> も機能します。 しかしながら、この場所に置くと、アプリケーションファイルと FreeBSD システムのファイルが混ざってしまうため、推奨されません。</p></div></div><div class=sect4><h5 id=x-config-files-single-or-multi>5.4.4.2. 単一または複数ファイル<a class=anchor href=#x-config-files-single-or-multi></a></h5><div class=paragraph><p>複数のファイルを用いて、 各ファイルが特定の部分を設定するようにすると、 古い単一の <span class=filename>xorg.conf</span> を用いるよりも設定が簡単になります。 これらのファイルは、 メインのコンフィグレーションファイルのディレクトリの <span class=filename>xorg.conf.d/</span> サブディレクトリに置かれます。 フルパスは、一般的に <span class=filename>/usr/local/etc/X11/xorg.conf.d/</span> となります。</p></div><div class=paragraph><p>これらのファイルの例は、この節の後半で説明します。</p></div><div class=paragraph><p>古い単一の <span class=filename>xorg.conf</span> も機能しますが、 <span class=filename>xorg.conf.d/</span> サブディレクトリに複数のファイルで設定する形式に比べると、 柔軟ではなく、わかりにくいものとなります。</p></div></div></div><div class=sect3><h4 id=x-config-video-cards>5.4.5. ビデオカード<a class=anchor href=#x-config-video-cards></a></h4><div class=paragraph><p>Ports のフレームワークは、X11 が最近のハードウェア上で動作するために必要となる drm グラフィックドライバを提供します。
そのようなドライバとしては、<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/drm-kmod/>graphics/drm-kmod</a> で提供されるドライバがあります。
これらのドライバは、通常プライベートなカーネルのインタフェースを使用するため、<code>PORTS_MODULES</code> 変数を利用して ports システムのドライバを構築することが強く推奨されています。
<code>PORTS_MODULES</code> に設定されたカーネルモジュールを含む port は、カーネルを構築するたびに、アップデートされたソースに対応するよう再構築されます。
これにより、カーネルモジュールはカーネルと同期することが保証されます。
カーネルと ports ツリーは最大限に互換性を持つように共にアップデートされる必要があります。
<span class=filename>/etc/make.conf</span> ファイルで <code>PORTS_MODULES</code> を設定することで、カーネルを構築する際に、設定されたモジュールも再構築されるようになります。
上級のユーザの中には、カーネルコンフィグレーションファイルに <code>makeoptions</code> ディレクティブで追加するユーザもいます。
GENERIC を走らせていて、freebsd-update を使用している場合には、<code>freebsd-update install</code> 実行後に <span class=filename>graphics/drm-kmod</span> または <span class=filename>x11/nvidia-driver</span> port を構築してください。</p></div><div class=exampleblock><div class=content><div class=paragraph><p><span class=filename>/etc/make.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>SYSDIR=path/to/src/sys
PORTS_MODULES=graphics/drm-kmod x11/nvidia-driver</pre></div></div><div class=paragraph><p>この設定はすべてを再構築します。
使用している GPU /グラフィックカードに応じて、ひとつだけ選択したり、別のドライバを選択できます。</p></div></div></div><div id=x-config-video-cards-ports class=dlist><dl><dt class=hdlist1>Intel KMS driver</dt><dd><p>Intel® が提供しているほとんどの Intel KMS driver グラフィックカードは、2D および 3D アクセラレーションに対応しています。</p><div class=paragraph><p>ドライバ名: <code>i915kms</code></p></div><div class=paragraph><p>AMD® が提供している古い Radeon KMS driver グラフィックカードのほとんどは、2D および 3D アクセラレーションに対応しています。</p></div><div class=paragraph><p>ドライバ名: <code>radeonkms</code></p></div><div class=paragraph><p>AMD® が提供している新しい Radeon KMS driver グラフィックカードのほとんどは、2D および 3D アクセラレーションに対応しています。</p></div><div class=paragraph><p>ドライバ名: <code>amdgpu</code></p></div><div class=paragraph><p>参考として、対応している GPU 一覧を <a href=https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units</a> または <a href=https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units</a> でご覧ください。</p></div></dd></dl></div><div id=x-config-video-cards-intel class=dlist><dl><dt class=hdlist1>Intel®</dt><dd><p>Iron Lake (HD Graphics) および Sandy Bridge (HD Graphics 2000) を含む Ivy Bridge (HD Graphics 2500, 4000, および P4000) までのほとんどの Intel® グラフィックスは、3D acceleration に対応しています。</p><div class=paragraph><p>ドライバ名: <code>intel</code></p></div><div class=paragraph><p>参考情報については <a href=https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units</a> をご覧ください。</p></div></dd></dl></div><div id=x-config-video-cards-radeon class=dlist><dl><dt class=hdlist1>AMD® Radeon</dt><dd><p>ATI/Radeon: 2D および 3D acceleration は、 HD6000 シリーズまでのほとんどの Radeon カードで対応しています。</p><div class=paragraph><p>ドライバ名: <code>radeon</code></p></div><div class=paragraph><p>参考情報については <a href=https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units</a> をご覧ください。</p></div></dd></dl></div><div id=x-config-video-cards-nvidia class=dlist><dl><dt class=hdlist1>NVIDIA</dt><dd><p>NVIDIA: いくつかの NVIDIA ドライバが Ports Collection の <span class=filename>x11</span> カテゴリから利用できます。 ビデオカードのモデルに対応するドライバをインストールしてください。</p><div class=paragraph><p>参考情報については <a href=https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units</a> をご覧ください。</p></div><div class=paragraph><p>NVIDIA カードに対応しているカーネルは <span class=filename>x11/nvidia-driver</span> port または <span class=filename>x11/nvidia-driver-xxx</span> port にあります。
最新のカードは、前者の port を使います。
古いカードは、-xxx ports を使うことになります。
ここで xxx はドライバのバージョンを表す 304, 340 または 390 のどれかです。
これらのドライバを使うには、 <a href=http://download.nvidia.com/XFree86/FreeBSD-x86_64/465.19.01/README/>対応している NVIDIA GPU プロトコル</a> ページを参照して、<code>-xxx</code> の部分を埋めてください。
このページには、ドライバの各バージョンが対応しているデバイスの一覧があります。
昔のドライバは i386 および amd64 で動作します。
現在のドライバは amd64 のみに対応しています。
詳細については、 <a href=http://download.nvidia.com/XFree86/FreeBSD-x86_64/465.19.01/README/>NVIDIAドライバのインストールおよび設定</a> を参照してください。
ドライバが最大限に安全に動作するように、カーネルを再構築すたびにドライバを再構築することが推奨されていますが、このドライバはプライベートのカーネルインタフェースをほとんど使わないため、通常はカーネルがアップデートしても安全に使用できます。</p></div></dd></dl></div><div id=x-config-video-cards-hybrid class=dlist><dl><dt class=hdlist1>ハイブリッドグラフィックス</dt><dd><p>ノートブックコンピュータによっては、 チップセットまたはプロセッサに組み込まれているグラフィックプロセッサユニットの他に、 追加でそれらを持つものがあります。 <em>Optimus</em> は、 Intel® と NVIDIA ハードウェアを組み合わせています。 <em>Switchable Graphics</em> または、 <em>Hybrid Graphics</em> は、 Intel® または AMD® プロセッサと AMD® Radeon GPU を組み合わせています。</p><div class=paragraph><p>これらのハイブリッドなグラフィックシステムの実装は、 システムごとに異なるので、 FreeBSD の Xorg は、 これらのすべてのバージョンについて対応しているわけではありません。</p></div><div class=paragraph><p>コンピュータによっては、 片方のグラフィックアダプタを無効にしたり、 標準のビデオカードドライバの一つとともに使われる <em>discrete</em> モードを選択できるような BIOS オプションを提供しています。 たとえば、Optimus システムでは、NVIDIA GPU を無効にできるものがあります。 その後、Intel® ビデオカードは、 Intel® ドライバで利用できます。</p></div><div class=paragraph><p>BIOS の設定は、 コンピュータのモデルに依存します。 システムによっては、両方の GPU を有効にできますが、 そのようなシステムの機能を利用するには、 <code>Device</code> セッションにおいて、 メインの GPU のみを使用するようなコンフィグレーションファイルを作成ことで十分です。</p></div></dd></dl></div><div id=x-config-video-cards-other class=dlist><dl><dt class=hdlist1>他のビデオカード</dt><dd><p>Ports Collection の <span class=filename>x11-drivers</span> ディレクトリには、 あまり使用されないようなドライバも用意されています。</p><div class=paragraph><p>特定のドライバによりサポートされていないようなカードでも、 <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-vesa/>x11-drivers/xf86-video-vesa</a> で使用できるかもしれません。 このドライバは、<a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg/>x11/xorg</a> によりインストールされます。 手動でインストールするには、 <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-vesa/>x11-drivers/xf86-video-vesa</a> としてインストールしてください。 ビデオカードに対して、特定のドライバが見つからない場合には、 Xorg はこのドライバを使うことを試みます。</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-scfb/>x11-drivers/xf86-video-scfb</a> も同様に、多くの UEFI および ARM® コンピュータで動くような、 使用するカードを特定していないビデオドライバです。</p></div></dd></dl></div><div id=x-config-video-cards-file class=dlist><dl><dt class=hdlist1>ファイルでビデオドライバを設定する。</dt><dd><p>コンフィグレーションファイルにおいて Intel® ドライバを設定するには、以下のようにしてください。</p><div id=x-config-video-cards-file-intel class=exampleblock><div class=title>例 14. ファイルにおいて Intel® ビデオドライバを選択する。</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-intel.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;intel&#34;
	# BusID    &#34;PCI:1:0:0&#34;
EndSection</pre></div></div><div class=paragraph><p>１つ以上のビデオカードが存在する場合には、 <code>BusID</code> 行のコメントを外し、 希望するカードを選択するように設定できます。 ビデオカードバス ID は、 <code>pciconf -lv | grep -B3 display</code> で表示できます。</p></div></div></div><div class=paragraph><p>コンフィグレーションファイルで、Radeon ドライバを設定するには以下のようにしてください。</p></div><div id=x-config-video-cards-file-radeon class=exampleblock><div class=title>例 15. ファイルにおいて Radeon ビデオドライバを設定する。</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-radeon.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;radeon&#34;
EndSection</pre></div></div></div></div><div class=paragraph><p>コンフィグレーションファイルで VESA ドライバを設定するには、以下のようにしてください。</p></div><div id=x-config-video-cards-file-vesa class=exampleblock><div class=title>例 16. ファイルで VESA ビデオドライバを設定する。</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-vesa.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;vesa&#34;
EndSection</pre></div></div></div></div><div class=paragraph><p>UEFI または ARM® コンピュータを使うために <code>scfb</code> ドライバを設定するには、以下のように設定してください。</p></div><div id=x-config-video-cards-file-scfb class=exampleblock><div class=title>例 17. ファイルの中で <code>scfb</code> ビデオドライバを選択する。</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-scfb.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;scfb&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect3><h4 id=x-config-monitors>5.4.6. モニタ<a class=anchor href=#x-config-monitors></a></h4><div class=paragraph><p>ほとんどすべてのモニタは、Extended Display Identification Data standard (EDID) に対応しています。 Xorg は EDID を使ってモニタと通信し、 対応している解像度とリフレッシュレートを検出します。 そのため、モニタを使用するのに最も適切な設定が選択されます。</p></div><div class=paragraph><p>モニタにより対応している他の解像度は、 コンフィグレーションファイルに希望する解像度を設定する、 または X サーバを起動後、<a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> により選択が可能となります。</p></div><div id=x-config-monitors-xrandr class=dlist><dl><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> の使用</dt><dd><p>パラメータを与えずに <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> を実行すると、 ビデオ出力と検出されているモニタのモードを確認できます。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr
Screen 0: minimum 320 x 200, current 3000 x 1920, maximum 8192 x 8192
DVI-0 connected primary 1920x1200+1080+0 <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span> 495mm x 310mm
   1920x1200     59.95<span class=k>*</span>+
   1600x1200     60.00
   1280x1024     85.02    75.02    60.02
   1280x960      60.00
   1152x864      75.00
   1024x768      85.00    75.08    70.07    60.00
   832x624       74.55
   800x600       75.00    60.32
   640x480       75.00    60.00
   720x400       70.08
DisplayPort-0 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
HDMI-0 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span></code></pre></div></div><div class=paragraph><p>この出力からは、リフレッシュレート約 60 Hz で、 スクリーン解像度 1920x1200 ピクセルの表示に <code>DVI-0</code> 出力が使用されていることが分かります。 また、<code>DisplayPort-0</code> および <code>HDMI-0</code> インタフェースには、 モニタは接続されていません。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> を使用して、 他のディスプレイモードを選択できます。 たとえば、60 Hz で、1280x1024 の表示に変更するには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr <span class=nt>--output</span> DVI-0 <span class=nt>--mode</span> 1280x1024 <span class=nt>--rate</span> 60</code></pre></div></div><div class=paragraph><p>ノートブックコンピュータの外部出力を使用して、 ビデオプロジェクタに接続することがよく行われます。</p></div><div class=paragraph><p>出力端子のタイプおよび番号は、デバイスごとに異なります。 また、各端子の名前もドライバごとに異なります。 あるドライバが <code>HDMI-1</code> と呼ぶ出力が、 別のドライバでは <code>HDMI1</code> と呼ばれることもあります。 そのため、最初に <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> を実行して、 利用可能な出力のすべての一覧を表示してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr
Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192
LVDS1 connected 1366x768+0+0 <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span> 344mm x 193mm
   1366x768      60.04<span class=k>*</span>+
   1024x768      60.00
   800x600       60.32    56.25
   640x480       59.94
VGA1 connected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
   1280x1024     60.02 +  75.02
   1280x960      60.00
   1152x864      75.00
   1024x768      75.08    70.07    60.00
   832x624       74.55
   800x600       72.19    75.00    60.32    56.25
   640x480       75.00    72.81    66.67    60.00
   720x400       70.08
HDMI1 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
DP1 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span></code></pre></div></div><div class=paragraph><p>この出力からは、組み込みパネルの <code>LVDS1</code>, 外部出力の <code>VGA1</code>, <code>HDMI1</code>, そして <code>DP1</code> 端子の 4 つの出力を確認できます。</p></div><div class=paragraph><p>プロジェクタは <code>VGA1</code> 出力に接続されています。 情報を得られたので、<a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> を使ってプロジェクタの標準の解像度に設定し、 デスクトップの右側にスペースを追加できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr <span class=nt>--output</span> VGA1 <span class=nt>--auto</span> <span class=nt>--right-of</span> LVDS1</code></pre></div></div><div class=paragraph><p>この設定において、<code>--auto</code> は、 EDID により検出された解像度とリフレッシュレートを選択します。 解像度を正しく検出できていない場合には、 <code>--auto</code> のかわりに、 <code>--mode</code> を使うことで、 解像度を固定値を与えることにより設定できます。 たとえば、ほとんどのプロジェクタでは 1024x768 の解像度で使用できるので、 この場合には、<code>--mode 1024x768</code> のように設定できます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> は、X を起動する際に、 適切なモードを設定するように、しばしば <span class=filename>.xinitrc</span> から実行されます。</p></div></dd></dl></div><div id=x-config-monitors-files class=dlist><dl><dt class=hdlist1>モニタ解像度をファイルで設定する。</dt><dd><p>コンフィグレーションファイルでスクリーンの解像度を 1024x768 と設定するには以下のようにしてください。</p><div class=exampleblock><div class=title>例 18. スクリーンの解像度をファイルで設定する。</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/screen-resolution.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
	Identifier &#34;Screen0&#34;
	Device     &#34;Card0&#34;
	SubSection &#34;Display&#34;
	Modes      &#34;1024x768&#34;
	EndSubSection
EndSection</pre></div></div></div></div><div class=paragraph><p>EDID を持っていないモニタもあります。その場合には、 モニタが対応している周波数の範囲を、 <code>HorizSync</code> および <code>VertRefresh</code> で、指定することで設定できます。</p></div><div class=exampleblock><div class=title>例 19. 手動でモニタの周波数を設定する。</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/monitor0-freq.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
	Identifier   &#34;Monitor0&#34;
	HorizSync    30-83   # kHz
	VertRefresh  50-76   # Hz
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect3><h4 id=x-config-input>5.4.7. 入力デバイス<a class=anchor href=#x-config-input></a></h4><div class=sect4><h5 id=x-config-input-keyboard>5.4.7.1. キーボード<a class=anchor href=#x-config-input-keyboard></a></h5><div id=x-config-input-keyboard-layout class=dlist><dl><dt class=hdlist1>キーボードレイアウト</dt><dd><p>キーボード上の標準化されたキーの位置を <em>レイアウト</em> と呼びます。 レイアウトと他の調整可能なパラメータについては、 <a href="https://man.freebsd.org/cgi/man.cgi?query=xkeyboard-config&amp;sektion=7&amp;format=html">xkeyboard-config(7)</a> にまとめられています。</p><div class=paragraph><p>アメリカ合衆国のレイアウトがデフォルトです。 他のレイアウトを選択するには、 <code>InputClass</code> で、 <code>XkbLayout</code> および <code>XkbVariant</code> オプションを設定してください。 クラスに対応するすべての入力デバイスに適用できます。</p></div><div class=paragraph><p>以下の例では、 フランス語のキーボードレイアウトを選択しています。</p></div><div class=exampleblock><div class=title>例 20. キーボードレイアウトを選択する。</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/keyboard-fr.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;KeyboardDefaults&#34;
	MatchIsKeyboard	&#34;on&#34;
	Option		&#34;XkbLayout&#34; &#34;fr&#34;
EndSection</pre></div></div></div></div><div class=exampleblock><div class=title>例 21. 複数のキーボードレイアウトを選択する。</div><div class=content><div class=paragraph><p>アメリカ合衆国、スペイン、 ウクライナのキーボードレイアウトを、 <span class=keyseq><kbd>Alt</kbd>+<kbd>Shift</kbd></span> によって切り替えるようにするには以下のように設定します。 レイアウトスイッチングコントロールや現在のレイアウトインディケータを改良するには、 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xxkb/>x11/xxkb</a> または、 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/sbxkb/>x11/sbxkb</a> を使ってください。</p></div><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/kbd-layout-multi.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;All Keyboards&#34;
	MatchIsKeyboard	&#34;yes&#34;
	Option		&#34;XkbLayout&#34; &#34;us, es, ua&#34;
EndSection</pre></div></div></div></div></dd></dl></div><div id=x-config-input-keyboard-zap class=dlist><dl><dt class=hdlist1>キーボードから Xorg を終了する。</dt><dd><p>X をキーの組み合わせで終了できるように設定できます。 デフォルトでは、幾つかのアプリケーションで、 キーボードコマンドと衝突してしまう可能性があるため、 このキーの組み合わせは設定されていません。 このオプションを有効にするには、 キーボードの <code>InputDevice</code> セクションを変更してください。</p><div class=exampleblock><div class=title>例 22. キーボードからの X の終了を有効にする。</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/keyboard-zap.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;KeyboardDefaults&#34;
	MatchIsKeyboard	&#34;on&#34;
	Option		&#34;XkbOptions&#34; &#34;terminate:ctrl_alt_bksp&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect4><h5 id=x11-input-mice>5.4.7.2. マウスおよびポインティングデバイス<a class=anchor href=#x11-input-mice></a></h5><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>もし FreeBSD 12.1 において、 <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> を使わず、 <a class=package href=https://cgit.freebsd.org/ports/tree/xorg-server/>xorg-server</a> 1.20.8 以降を使用しているのであれば、 <span class=filename>/etc/sysctl.conf</span> に、 <code>kern.evdev.rcpt_mask=12</code> を追加してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>コンフィグレーションオプションにより、 多くのマウスパラメータを調整できます。 すべての一覧については、<a href="https://man.freebsd.org/cgi/man.cgi?query=mousedrv&amp;sektion=4&amp;format=html">mousedrv(4)</a> をご覧ください。</p></div><div id=x11-input-mice-buttons class=dlist><dl><dt class=hdlist1>マウスボタン</dt><dd><p><span class=filename>xorg.conf</span> のマウス <code>InputDevice</code> セクションで、 マウスのボタンの数を設定できます。 ボタンの数を 7 に設定するには、 以下のように設定してください。</p><div class=exampleblock><div class=title>例 23. マウスボタンの数を設定する。</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/mouse0-buttons.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
	Identifier  &#34;Mouse0&#34;
	Option      &#34;Buttons&#34; &#34;7&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div></div><div class=sect3><h4 id=x-config-manual-configuration>5.4.8. 手動による設定<a class=anchor href=#x-config-manual-configuration></a></h4><div class=paragraph><p>ハードウェアによっては、Xorg の自動設定で適切な設定が行われなかったり、 自動設定とは別の設定にしたいときがあります。 そのような場合のため、 カスタムコンフィグレーションファイルを作成できます。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>自動認識に失敗したとき以外は、 手動で設定ファイルを作成しないでください。 不必要な手動の設定を行った結果、 適切に動作しなくなるということがあります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>検出されたハードウェアをベースとした、 Xorg のコンフィグレーションファイルを作成できます。 このファイルは、 カスタムコンフィグレーションファイルの最初の出発点として有用です。</p></div><div class=paragraph><p>以下のようにすると <span class=filename>xorg.conf</span> が生成されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -configure</span></code></pre></div></div><div class=paragraph><p>このコンフィグレーションファイルは、 <span class=filename>/root/xorg.conf.new</span> として保存されます。 必要となる変更を行った後、このファイルを (バックグラウンドが表示されるように <code>-retro</code> を使って) テストしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -retro -config /root/xorg.conf.new</span></code></pre></div></div><div class=paragraph><p>新しい設定を調整してテストしたら、 ファイルに分割して、標準の場所である、 <span class=filename>/usr/local/etc/X11/xorg.conf.d/</span> に置いてください。</p></div></div></div><div class=sect2><h3 id=x-fonts>5.5. Xorg でのフォントの使用<a class=anchor href=#x-fonts></a></h3><div class=sect3><h4 id=type1>5.5.1. Type1 フォント<a class=anchor href=#type1></a></h4><div class=paragraph><p>Xorg に付いてくるデフォルトのフォントは、 通常のデスクトップパブリッシングアプリケーションにとっては理想的とは言えない程度のものです。 文字を大きくするとジャギーになりプロフェッショナルとは言えないようなものになりますし、 小さなフォントは頭が悪そうに見えます。 しかし、世の中には質の高い Type1 (PostScript®) フォントがいくつかあり、 Xorg ではそれらを簡単に利用することができます。 例えば、URW フォントコレクション (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/urwfonts/>x11-fonts/urwfonts</a>) には高品質の Type1 フォント (Times Roman™, Helvetica™, Palatino™ など) が含まれています。freefont コレクション (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/freefonts/>x11-fonts/freefonts</a>) にはもっとたくさんのフォントが含まれていますが、 それらは Gimp のようなグラフィックソフトウェアで使用するためのものであり、 スクリーンフォントとしては十分ではありません。 さらに、Xorg は簡単に TrueType® フォントを使うように設定することも可能です。 詳しくは、<a href="https://man.freebsd.org/cgi/man.cgi?query=X&amp;sektion=7&amp;format=html">X(7)</a> のマニュアルページか <a href=#truetype>TrueType® フォント</a> を参照してください。</p></div><div class=paragraph><p>上記の Type1 フォントコレクションをバイナリ package からインストールする場合には、次のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install urwfonts</span></code></pre></div></div><div class=paragraph><p>あるいは、Ports Collection から構築してインストールするには次のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-fonts/urwfonts</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>freefont や他のコレクションでも同じようにします。 X サーバがこれらのフォントを検出できるようにするには X サーバ設定ファイル (<span class=filename>/etc/X11/xorg.conf</span>) の適切な場所に次のような行を加えます。</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath &#34;/usr/local/share/fonts/urwfonts/&#34;</pre></div></div><div class=paragraph><p>別の方法としては、 X のセッション中に次のようなコマンドラインを実行します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/share/fonts/urwfonts
% xset fp rehash</code></pre></div></div><div class=paragraph><p>これは動くのですが、X のセッションが終了すると消えてしまいます。 消えないようにするには X の起動時に読み込まれるファイル (通常の <code>startx</code> セッションの場合は <span class=filename>~/.xinitrc</span>, XDM のようなグラフィカルなログインマネージャを通してログインする時は <span class=filename>~/.xsession</span>) に加えておきます。 三番目の方法は新しい <span class=filename>/usr/local/etc/fonts/local.conf</span> ファイルを使うことです。 これに関しては <a href=#antialias>フォントのアンチエイリアス</a> をご覧ください。</p></div></div><div class=sect3><h4 id=truetype>5.5.2. TrueType® フォント<a class=anchor href=#truetype></a></h4><div class=paragraph><p>Xorg には、 TrueType® フォントのレンダリング機能が組み込まれています。 この機能を実現するために 2 つの異なるモジュールがあります。 ここでは、freetype の方が他のフォントレンダリングバックエンドと整合性が高いので、 このモジュールを使うことにします。 freetype モジュールを使うためには <span class=filename>/etc/X11/xorg.conf</span> ファイルの <code>"Module"</code> セクションに以下の行を追加するだけです。</p></div><div class="literalblock programlisting"><div class=content><pre>Load  &#34;freetype&#34;</pre></div></div><div class=paragraph><p>さて、まずは TrueType® フォント用のディレクトリ (例えば <span class=filename>/usr/local/share/fonts/TrueType</span>) を作り、そこに TrueType® フォントをすべて放り込みましょう。 Apple® Mac® の TrueType® フォントは、そのままでは使うことができませんので注意してください。 Xorg で使うには UNIX®/MS-DOS®/Windows® 用のフォーマットでなければなりません。 ファイルを置いたら mkfontscale を使って <span class=filename>fonts.dir</span> ファイルを作り、 X のフォントレンダラが新しいファイルがイントールされたことを分かるようにしてください。 <code>mkfontscale</code> は package からインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mkfontscale</span></code></pre></div></div><div class=paragraph><p>その後、ディレクトリに X フォントファイルのインデックスを作成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/share/fonts/TrueType</span>
<span class=c># mkfontscale</span></code></pre></div></div><div class=paragraph><p>次に TrueType® フォントのディレクトリをフォントパスに追加します。 <a href=#type1>Type1 フォント</a> の場合と同じように、</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/share/fonts/TrueType
% xset fp rehash</code></pre></div></div><div class=paragraph><p>とするか、もしくは <span class=filename>xorg.conf</span> ファイルに <code>FontPath</code> 行を追加します。</p></div><div class=paragraph><p>これで Gimp や LibreOffice といったすべての X アプリケーションから TrueType® フォントを使うことができます。 (高解像度なディスプレイで見るウェブページ上のテキストみたいな) とても小さなフォントや (LibreOffice にあるような) 非常に大きなフォントもかなり綺麗に見えるようになることでしょう。</p></div></div><div class=sect3><h4 id=antialias>5.5.3. フォントのアンチエイリアス<a class=anchor href=#antialias></a></h4><div class=paragraph><p><span class=filename>/usr/local/share/fonts/</span> と <span class=filename>~/.fonts/</span> にあるすべての Xorg のフォントが、Xft に対応しているアプリケーションで自動的にアンチエイリアス表示できるようになりました。 KDE, GNOME および Firefox のような最新のアプリケーションは、Xft に対応しています。</p></div><div class=paragraph><p>どのフォントがアンチエイリアスされるかを制御するため、 もしくはアンチエイリアスの特性を設定するために、 <span class=filename>/usr/local/etc/fonts/local.conf</span> ファイルを作成 (すでに存在しているのなら編集) します。 多くの Xft フォントシステムの高度な機能をこのファイルを使って調整できます。 この節ではいくつか簡単なところだけを紹介します。 詳しくは、<a href="https://man.freebsd.org/cgi/man.cgi?query=fonts-conf&amp;sektion=5&amp;format=html">fonts-conf(5)</a> をご覧ください。</p></div><div class=paragraph><p>このファイルは XML 形式でなければなりません。 大文字小文字の区別に注意を払い、 すべてのタグが正しく閉じられているか確認してください。 ファイルは一般的な XML ヘッダで始まり、DOCTYPE 定義と <code>&lt;fontconfig></code> タグがその後にきます。</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34;?&gt;
        &lt;!DOCTYPE fontconfig SYSTEM &#34;fonts.dtd&#34;&gt;
        &lt;fontconfig&gt;</pre></div></div><div class=paragraph><p>すでに説明したように、 <span class=filename>/usr/local/share/fonts/</span> と <span class=filename>~/.fonts/</span> にあるすべてのフォントは Xft 対応のアプリケーションで利用できます。 これら 2 つのディレクトリ以外に別のディレクトリを追加したいなら、 <span class=filename>/usr/local/etc/fonts/local.conf</span> に以下のような行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;dir&gt;/path/to/my/fonts&lt;/dir&gt;</pre></div></div><div class=paragraph><p>新しいフォント、 特に新しいフォントディレクトリを追加したら、 フォントキャッシュを再構築してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fc-cache -f</span></code></pre></div></div><div class=paragraph><p>アンチエイリアスをかけることによって境界が少しぼやけ、 そのためにとても小さなテキストはさらに読みやすくなり、 大きなフォントでは "ギザギザ" が消えるのです。 しかし、普通のテキストにかけた場合には目が疲れてしまうこともあります。 14 ポイント以下のサイズのフォントについて、 アンチエイリアスをかけないようにするには次の行を加えます。</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;match target=&#34;font&#34;&gt;
            &lt;test name=&#34;size&#34; compare=&#34;less&#34;&gt;
                &lt;double&gt;14&lt;/double&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;antialias&#34; mode=&#34;assign&#34;&gt;
                &lt;bool&gt;false&lt;/bool&gt;
            &lt;/edit&gt;
        &lt;/match&gt;
        &lt;match target=&#34;font&#34;&gt;
            &lt;test name=&#34;pixelsize&#34; compare=&#34;less&#34; qual=&#34;any&#34;&gt;
                &lt;double&gt;14&lt;/double&gt;
            &lt;/test&gt;
            &lt;edit mode=&#34;assign&#34; name=&#34;antialias&#34;&gt;
                &lt;bool&gt;false&lt;/bool&gt;
            &lt;/edit&gt;
        &lt;/match&gt;</pre></div></div><div class=paragraph><p>いくつかの等幅フォントは、 アンチエイリアスをかけるとスペーシングがうまくいかなくなる場合があります。 特に KDE でその傾向があるようです。 解決策の一つとして、そういったフォントのスペーシングを 100 に設定する方法があります。 そうするためには次の行を加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>	&lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
            &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                &lt;string&gt;fixed&lt;/string&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
                &lt;string&gt;mono&lt;/string&gt;
            &lt;/edit&gt;
        &lt;/match&gt;
        &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
            &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                &lt;string&gt;console&lt;/string&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
                &lt;string&gt;mono&lt;/string&gt;
            &lt;/edit&gt;
        &lt;/match&gt;</pre></div></div><div class=paragraph><p>(これは固定サイズのフォントに <code>"mono"</code> という一般的な別名をつけます) そして以下を追加します。</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
            &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                &lt;string&gt;mono&lt;/string&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;spacing&#34; mode=&#34;assign&#34;&gt;
                &lt;int&gt;100&lt;/int&gt;
            &lt;/edit&gt;
        &lt;/match&gt;</pre></div></div><div class=paragraph><p>Helvetica の様なある種のフォントは、 アンチエイリアスすると問題が起こるでしょう。 たいてい、フォントが縦に半分に切られて表示されます。 最悪の場合、アプリケーションがクラッシュします。 これを回避するには、以下を <span class=filename>local.conf</span> に追加します。</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
            &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                &lt;string&gt;Helvetica&lt;/string&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
                &lt;string&gt;sans-serif&lt;/string&gt;
            &lt;/edit&gt;
        &lt;/match&gt;</pre></div></div><div class=paragraph><p><span class=filename>local.conf</span> の編集を終えたら、 ファイルの末尾が <code>&lt;/fontconfig></code> タグで終わるようにしてください。 これを行わなければ、変更は無視されるでしょう。</p></div><div class=paragraph><p>ユーザは自分だけの設定を各自の <span class=filename>~/.config/fontconfig/fonts.conf</span> に追加できます。 このファイルもこれまでの説明と同じく XML 形式を使います。</p></div><div class=paragraph><p>最後に一つ。LCD スクリーンではサブピクセルサンプリングが必要な場合があります。 これは、基本的には (水平方向に分かれている) 赤、緑、 青の各コンポーネントを別々に扱うことによって水平方向の解像度を良くするというもので、 劇的な結果が得られます。 これを有効にするには <span class=filename>local.conf</span> ファイルに次の行を加えます。</p></div><div class="literalblock programlisting"><div class=content><pre>	 &lt;match target=&#34;font&#34;&gt;
            &lt;test qual=&#34;all&#34; name=&#34;rgba&#34;&gt;
                &lt;const&gt;unknown&lt;/const&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;rgba&#34; mode=&#34;assign&#34;&gt;
                &lt;const&gt;rgb&lt;/const&gt;
            &lt;/edit&gt;
        &lt;/match&gt;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ディスプレイの種類にもよりますが、 <code>rgb</code> ではなく <code>bgr</code> や <code>vrgb</code>、もしくは <code>vbgr</code> の場合もあるので、 試してみて最も良いものを使ってください。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x-xdm>5.6. X ディスプレイマネージャ<a class=anchor href=#x-xdm></a></h3><div class=paragraph><p>Xorg は、 ログインセッションの管理に用いることのできる X ディスプレイマネージャ XDM を提供しています。XDM はどのディスプレイサーバに接続するかを選択でき、 ログイン名とパスワードの組み合わせなど認証情報を入力できるグラフィカルなインタフェースを提供しています。</p></div><div class=paragraph><p>この章では、FreeBSD 上での X ディスプレイマネージャの設定方法について説明します。 デスクトップ環境によっては、 各環境独自のグラフィカルログインマネージャを提供しています。 GNOME ディスプレイマネージャの設定方法については、<a href=#x11-wm-gnome>GNOME</a> を参照してください。 また、KDE ディスプレイマネージャの設定方法については、<a href=#x11-wm-kde>KDE</a> を参照してください。</p></div><div class=sect3><h4 id=_xdm_の設定>5.6.1. XDM の設定<a class=anchor href=#_xdm_の設定></a></h4><div class=paragraph><p>XDM をインストールするには、 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xdm/>x11/xdm</a> package または port を使ってください。
インストール後、コンピュータの起動時に、XDM を起動するように設定するには、<span class=filename>/etc/rc.conf</span> に以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>xdm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>デフォルトでは、XDM は 9 番目の仮想端末で起動します。</p></div><div class=paragraph><p>XDM の設定用ディレクトリは <span class=filename>/usr/local/etc/X11/xdm</span> です。
このディレクトリには XDM の振る舞いや見た目を変更するために用いられるファイルや、XDM の動作中にデスクトップを設定するためのスクリプトやプログラムがあります。
<a href=#xdm-config-files>XDM 設定ファイル</a> には、これらのフィアルの機能についてまとめられています。
これらのファイルの正確な文法や使用方法については、<a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=8&amp;format=html">xdm(8)</a> に記述されています。</p></div><table id=xdm-config-files class="tableblock frame-none grid-all stretch"><caption class=title>表 7. XDM 設定ファイル</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">ファイル</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xaccess</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>XDM に接続するためのプロトコルは X Display Manager Connection Protocol (XDMCP) と呼ばれます。 このファイルにはリモートのマシンからの XDMCP 接続をコントロールするためのルールセットが書かれます。 デフォルトでは、どのクライアントからの接続も拒否します。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xresources</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>このファイルは、XDM ディスプレイの chooser およびログインスクリーンを設定します。 デフォルトの設定は、シンプルな長方形のログインウィンドウで、 コンピュータのホスト名がログインウィンドウの上部に大きなフォントで表示され、 その下に "Login:" および "Password:" のプロンプトが表示されます。 このファイルのフォーマットは Xorg のドキュメントで記述されている app-defaults ファイルのものと同じです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xservers</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>これは、chooser がログインの選択肢として提供するローカルおよびリモートのディスプレイの一覧です。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsession</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザのログイン時に XDM により実行されるデフォルトのセッションスクリプトです。 <span class=filename>~/.xsession</span> に置かれているカスタマイズされたセッションスクリプトが優先されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsetup_</span>*</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>これらは chooser やログインインタフェースが表示される前に自動的に実行されるアプリケーションです。 それぞれのディスプレイに対して、<span class=filename>Xsetup_*</span> (<code>*</code> はローカルのディスプレイ番号) という名前のついたスクリプトがあります。 典型的な使い方は <code>xconsole</code> のようなバックグラウンドで動かすプログラムを一つか二つ起動することです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-config</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>このマシンで動いているすべてのディスプレイのグローバルな設定</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-errors</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>このファイルにはサーバプログラムからのエラーが書き出されます。 XDM が起動しようとしているディスプレイがなんらかの理由でハングした場合、 このファイルのエラーメッセージを見てください。 これらのメッセージは各ユーザの <span class=filename>~/.xsession-errors</span> ファイルにもセッション毎に書き出されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-pid</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>現在動いている XDM のプロセス ID。</p></td></tr></tbody></table></div><div class=sect3><h4 id=_リモートアクセスの設定>5.6.2. リモートアクセスの設定<a class=anchor href=#_リモートアクセスの設定></a></h4><div class=paragraph><p>デフォルトでは、XDM を使ってログインできるのは、同じシステムのユーザのみです。 あるディスプレイサーバに他のシステムのユーザが接続できるようにするためには、 アクセスコントロールのルールを編集し、 コネクションリスナを有効にする必要があります。</p></div><div class=paragraph><p>XDM が他のリモートコネクションを待ち受けるようにするためには、 <span class=filename>/usr/local/etc/X11/xdm/xdm-config</span> の <code>DisplayManager.requestPort</code> 行を、行頭に <code>!</code> を置くことでコメントアウトしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>!</span> SECURITY: <span class=k>do </span>not listen <span class=k>for </span>XDMCP or Chooser requests
<span class=o>!</span> Comment out this line <span class=k>if </span>you want to manage X terminals with xdm
DisplayManager.requestPort:     0</code></pre></div></div><div class=paragraph><p>変更点を保存して、XDM を再起動してください。
リモートアクセスを制限するには、<span class=filename>/usr/local/etc/X11/xdm/Xaccess</span> にある例を参考にしたり、詳細について <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=8&amp;format=html">xdm(8)</a> を参照してください。</p></div></div></div><div class=sect2><h3 id=x11-wm>5.7. デスクトップ環境<a class=anchor href=#x11-wm></a></h3><div class=paragraph><p>この節では、良く使われている 3 つのデスクトップ環境を FreeBSD 上でにインストールする方法について解説します。 デスクトップ環境とは、 単なるウィンドウマネージャから完全なデスクトップアプリケーションスイートまでカバーします。 Ports Collection の <span class=filename>x11-wm</span> カテゴリには、 100 を超えるデスクトップ環境が用意されています。</p></div><div class=sect3><h4 id=x11-wm-gnome>5.7.1. GNOME<a class=anchor href=#x11-wm-gnome></a></h4><div class=paragraph><p>GNOME はユーザフレンドリなデスクトップ環境です。 アプリケーションを起動したりステータスを表示するパネル、 デスクトップ、ツールおよびアプリケーション群、 そしてアプリケーションが互いにうまくやり取りできるような仕組みが含まれています。 FreeBSD 上の GNOME に関するもっと詳しい情報は、<a href=https://www.FreeBSD.org/gnome>https://www.FreeBSD.org/gnome</a> で見ることができます。 このウェブサイトには、FreeBSD での GNOME のインストール、設定、管理に関する多くの情報があります。</p></div><div class=paragraph><p>このデスクトップ環境は、package からインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnome</span></code></pre></div></div><div class=paragraph><p>ports から GNOME を構築するには、以下のコマンドを実行してください。 GNOME は大きなアプリケーションなので、 コンパイルには高速のコンピュータでも時間がかかります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/gnome</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>GNOME を使用するには、 <span class=filename>/proc</span> ファイルシステムをマウントする必要があります。 以下を <span class=filename>/etc/fstab</span> に追加して、 システムの起動中にこのファイルシステムをマウントするように設定してください。</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>GNOME は、メッセージバスおよびハードウェアアブストラクションに D-Bus を使います。
これらのアプリケーションは、GNOME の依存として自動的にインストールされます。
<span class=filename>/etc/rc.conf</span> の中で、システムの起動時にスタートするように有効にしてください。</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>インストール後、 GNOME を起動するように Xorg を設定してください。 最も簡単な方法は、GNOME ディスプレイマネージャ GDM を使うことです。 GDM は、 GNOME package または port の一部としてインストールされます。 有効にするには、以下の行を <span class=filename>/etc/rc.conf</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>gdm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>GNOME のすべてのサービスを、 起動するようにしておくと良いでしょう。 このように設定するには、以下の行を <span class=filename>/etc/rc.conf</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>gnome_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>システムを再起動すると、GDM が自動的に起動します。</p></div><div class=paragraph><p>GNOME を起動するもう一つの方法は、 <span class=filename>.xinitrc</span> を適切に設定した後で、 コマンドラインから <code>startx</code> と入力する方法です。 <span class=filename>.xinitrc</span> が既にある場合には、 ウィンドウマネージャを起動する行を <span class=filename>/usr/local/bin/gnome-session</span> を起動するように変更してください。 このファイルが存在しなければ、 次のコマンドで作成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>3 つめの方法は、XDM をディスプレイマネージャとして使う方法です。 この場合は、実行可能な <span class=filename>.xsession</span> というファイルを作成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div></div><div class=sect3><h4 id=x11-wm-kde>5.7.2. KDE<a class=anchor href=#x11-wm-kde></a></h4><div class=paragraph><p>KDE はもう一つの使いやすいデスクトップ環境です。 このデスクトップは、統一されたルックアンドフィール、 標準化されたメニューおよびツールバー、 キーバインディング、カラースキーム、国際化、 一元化されたダイアログベースのデスクトップ設定とともに、 アプリケーションのスイートを提供します。 KDE の詳細については <a href=http://www.kde.org/>http://www.kde.org/</a> をご覧ください。 KDE に関する FreeBSD 特有の情報については、<a href=http://freebsd.kde.org/>http://freebsd.kde.org</a> をご覧ください。</p></div><div class=paragraph><p>KDE package をインストールするには以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/kde5</span></code></pre></div></div><div class=paragraph><p>KDE port を構築するには、以下のコマンドを使ってください。 port のインストールでは、 インストールするアプリケーションを選択するためのメニューが表示されます。 KDE は大きなアプリケーションなので、 高速のコンピュータでもコンパイルには時間がかかります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/kde5</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>KDE では、 <span class=filename>/proc</span> ファイルシステムをマウントする必要があります。 以下の行を <span class=filename>/etc/fstab</span> に追加して、 システム起動時にこのファイルシステムが自動的にマウントされるように設定してください。</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>KDE は、 メッセージバスおよびハードウェアアブストラクションに D-Bus を使います。
これらのアプリケーションは、KDE の依存として自動的にインストールされます。
<span class=filename>/etc/rc.conf</span> の中で、システムの起動時にスタートするように有効にしてください。</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>KDE Plasma 5 から KDE のディスプレイマネージャ KDM の開発は終了しました。 かわりに推奨されているのが SDDM です。 インストールするには、以下を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/sddm</span></code></pre></div></div><div class=paragraph><p>その後、以下の行を <span class=filename>/etc/rc.conf</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>sddm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>KDE Plasma を起動するもう一つの方法は、 コマンドラインから <code>startx</code> を実行する方法です。 このコマンドを実行するには、<span class=filename>~/.xinitrc</span> に以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>exec ck-launch-session startplasma-x11</pre></div></div><div class=paragraph><p>KDE Plasma を起動する 3 つめの方法は、 XDM を利用する方法です。 この方法を使うには、以下のようにして実行可能な <span class=filename>~/.xsession</span> を作成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec ck-launch-session startplasma-x11&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div><div class=paragraph><p>KDE Plasma を起動した後は、 ビルトインヘルプシステムから、 さまざまなメニューおよびアプリケーションの使用方法などのより詳しい情報を参照できます。</p></div></div><div class=sect3><h4 id=x11-wm-xfce>5.7.3. Xfce<a class=anchor href=#x11-wm-xfce></a></h4><div class=paragraph><p>Xfce は GNOME で使われている GTK+ ツールキットをベースにしたデスクトップ環境ですが、より軽量、 シンプルでかつ効率的でありながら使いやすいデスクトップ環境です。 すべての設定が可能で、メニュー、 アプレットおよびアプリケーションランチャを含むメインパネル、 ファイルマネージャ、サウンドマネージャを提供し、 テーマに対応しています。 速くて軽く、効率的なため、古いマシンや遅いマシン、 メモリの限られたマシンに向いています。 Xfce に関する詳しい情報は <a href=http://www.xfce.org/>http://www.xfce.org</a> で得られます。</p></div><div class=paragraph><p>Xfce package をインストールするには、次のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xfce</span></code></pre></div></div><div class=paragraph><p>また、port を構築するには以下のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-wm/xfce4</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Xfce は、 メッセージバスに D-Bus を使います。 これらのアプリケーションは Xfce の依存として自動的にインストールされます。 <span class=filename>/etc/rc.conf</span> において、 システム起動時に起動するように有効にしてください。</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>GNOME や KDE とは異なり、 Xfce は、 ログインマネージャを提供していません。 コマンドラインから <code>startx</code> を実行して Xfce を起動するには、 以下のコマンドを使って、 <span class=filename>~/.xinitrc</span> を作成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;. /usr/local/etc/xdg/xfce4/xinitrc&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>もう一つの方法は XDM を用いる方法です。この方法を使うには、 実行可能な <span class=filename>.xsession</span> を作成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;. /usr/local/etc/xdg/xfce4/xinitrc&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div></div></div><div class=sect2><h3 id=x-compiz-fusion>5.8. Compiz Fusion のインストール<a class=anchor href=#x-compiz-fusion></a></h3><div class=paragraph><p>魅力的な 3D 効果を使うと、 デスクトップコンピュータを使う楽しさがさらに増えることでしょう。</p></div><div class=paragraph><p>Compiz Fusion のインストールは簡単ですが、設定の際には、port の文書には記載されていないような作業が必要となることがあります。</p></div><div class=sect3><h4 id=x-compiz-video-card>5.8.1. FreeBSD nVidia ドライバの設定<a class=anchor href=#x-compiz-video-card></a></h4><div class=paragraph><p>デスクトップ効果は、 グラフィックカードに極めて高い負荷をかけることがあります。 nVidia ベースのグラフィックカードにおいて、 良いパフォーマンスを出すには、 プロプリエタリなドライバが必要となります。 他のグラフィックカードを使っているユーザは、この節を飛ばし、 <span class=filename>xorg.conf</span> の設定に進んでください。</p></div><div class=paragraph><p>必要となる nVidia ドライバについては、 <a href=https://docs.freebsd.org/ja/books/faq/#idp59950544>この問題に関する FAQ</a> を参照して決めてください。</p></div><div class=paragraph><p>使用しているカードに対する適切なドライバが決まれば、 インストール作業は他の package をインストールするのと同じように簡単です。</p></div><div class=paragraph><p>たとえば、 最新のドライバをインストールするには以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/nvidia-driver</span></code></pre></div></div><div class=paragraph><p>このドライバはカーネルモジュールを作成するので、このモジュールをシステムの起動時に読み込むように設定する必要があります。
<a href="https://man.freebsd.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;format=html">sysrc(8)</a> を使用して起動時にモジュールを読み込むようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc kld_list+=&#34;nvidia&#34;</span></code></pre></div></div><div class=paragraph><p>または、以下の行を <span class=filename>/boot/loader.conf</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>nvidia_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>動作しているカーネルに、 カーネルモジュールを今すぐ読み込ませるには、 <code>kldload nvidia</code> のようなコマンドを実行してください。 しかしながら、Xorg のバージョンによっては、 起動時にドライバが読み込まれていないと正しく動かないもありますので、 注意してください。<span class=filename>/boot/loader.conf</span> を編集後は、再起動してください。
<span class=filename>/boot/loader.conf</span> を間違って設定してしまうと、システムは適切に起動しない可能性があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>読み込まれたカーネルモジュールを使うには、 通常は、<span class=filename>xorg.conf</span> ファイルの一つの行をプロプリエタリなドライバを使うように変更するだけです。</p></div><div class=paragraph><p><span class=filename>/etc/X11/xorg.conf</span> において、 以下の行を探し出してください。</p></div><div class="literalblock programlisting"><div class=content><pre>Driver      &#34;nv&#34;</pre></div></div><div class=paragraph><p>この行を以下のように変更してください。</p></div><div class="literalblock programlisting"><div class=content><pre>Driver      &#34;nvidia&#34;</pre></div></div><div class=paragraph><p>いつものように GUI を起動すると、nVidia のスプラッシュが表示されます。 すべてはこれまで通りに動作するはずです。</p></div></div><div class=sect3><h4 id=xorg-configuration>5.8.2. デスクトップ効果のための <code>xorg.conf</code> の設定<a class=anchor href=#xorg-configuration></a></h4><div class=paragraph><p>Compiz Fusion を有効にするには <span class=filename>/etc/X11/xorg.conf</span> を変更する必要があります。</p></div><div class=paragraph><p>コンポジット効果を有効にするには、 以下のセクションを追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Extensions&#34;
    Option         &#34;Composite&#34; &#34;Enable&#34;
EndSection</pre></div></div><div class=paragraph><p>以下のような "Screen" セクションの場所を見つけてください。</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
    Identifier     &#34;Screen0&#34;
    Device         &#34;Card0&#34;
    Monitor        &#34;Monitor0&#34;
    ...</pre></div></div><div class=paragraph><p>("Monitor" の後に) 次の二つの行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>DefaultDepth    24
Option         &#34;AddARGBGLXVisuals&#34; &#34;True&#34;</pre></div></div><div class=paragraph><p>あなたが使用したいと考えているスクリーン解像度に対応する "Subsection" を探してください。 たとえば、1280x1024 を使用する予定であれば、 次のようなセクションを探してください。 もし希望の解像度の subsection がなければ、 手動でそのエントリを追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>SubSection     &#34;Display&#34;
    Viewport    0 0
    Modes      &#34;1280x1024&#34;
EndSubSection</pre></div></div><div class=paragraph><p>デスクトップコンポジットで 24 ビットのカラーが必要であれば、上述の subsection を以下のように変更してください。</p></div><div class="literalblock programlisting"><div class=content><pre>SubSection     &#34;Display&#34;
    Viewport    0 0
    Depth       24
    Modes      &#34;1280x1024&#34;
EndSubSection</pre></div></div><div class=paragraph><p>最後に、"Module" セクションに "glx" および "extmod" モジュールが読み込まれるように設定されていることを確認してください。</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Module&#34;
    Load           &#34;extmod&#34;
    Load           &#34;glx&#34;
    ...</pre></div></div><div class=paragraph><p>前述の設定は、 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-xconfig/>x11/nvidia-xconfig</a> を (<code>root</code> 権限で) 実行することで自動的に設定できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nvidia-xconfig --add-argb-glx-visuals</span>
<span class=c># nvidia-xconfig --composite</span>
<span class=c># nvidia-xconfig --depth=24</span></code></pre></div></div></div><div class=sect3><h4 id=compiz-fusion>5.8.3. Compiz Fusion のインストールおよび設定<a class=anchor href=#compiz-fusion></a></h4><div class=paragraph><p>Compiz Fusion のインストールは、 他の package と同様に簡単です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11-wm/compiz-fusion</span></code></pre></div></div><div class=paragraph><p>インストールが終了したら、グラフィックデスクトップを起動して、 端末から以下のコマンドを通常のユーザで実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% compiz <span class=nt>--replace</span> <span class=nt>--sm-disable</span> <span class=nt>--ignore-desktop-hints</span> ccp &amp;
% emerald <span class=nt>--replace</span> &amp;</code></pre></div></div><div class=paragraph><p>使っているウィンドウマネージャ (GNOME では、Metacity) が、 Compiz Fusion に置き換えられるため、 画面は数秒間ちらつきます。 Emerald がウィンドウデコレーション (たとえば、閉じる、最小化、最大化ボタンタイトルバーなど) を取り扱います。</p></div><div class=paragraph><p>このコマンドをスクリプトに変換して、 (たとえば GNOME デスクトップの "Sessions" に追加して) 起動時に自動的に実行されるようにすることもできます。</p></div><div class="literalblock programlisting"><div class=content><pre>#! /bin/sh
compiz --replace --sm-disable --ignore-desktop-hints ccp &amp;
emerald --replace &amp;</pre></div></div><div class=paragraph><p>これを、たとえば <span class=filename>start-compiz</span> という名前でホームディレクトリに保存して、 以下のように実行可能にしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod</span> +x ~/start-compiz</code></pre></div></div><div class=paragraph><p>GUI を使って、このスクリプトを (GNOME デスクトップの <span class=guimenuitem>System</span>, <span class=guimenuitem>Preferences</span>, <span class=guimenuitem>Sessions</span> にある) <span class=guimenuitem>Startup Programs</span> に追加してください。</p></div><div class=paragraph><p>すべての希望する効果と設定を選択するには、 (もう一度通常のユーザで) Compiz Config Settings Manager を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ccsm</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>GNOME では、 <span class=guimenuitem>System</span>, <span class=guimenuitem>Preferences</span> メニューから選択することも出来ます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ビルドの際に "gconf support" を選択していたのであれば、 <code>gconf-editor</code> を使って <code>apps/compiz</code> 以下を見ることで、 これらの設定を確認することも出来ます。</p></div></div></div><div class=sect2><h3 id=x11-troubleshooting>5.9. トラブルシューティング<a class=anchor href=#x11-troubleshooting></a></h3><div class=paragraph><p>もしマウスが動作しなければ、 先へ進む前にマウスの設定を行う必要があります。 最近の Xorg では、デバイスの自動認識のため、 <span class=filename>xorg.conf</span> の <code>InputDevice</code> セクションは無視されます。 古い設定の記述を利用するには、 このファイルの <code>ServerLayout</code> もしくは、 <code>ServerFlags</code> セクションに以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;AutoAddDevices&#34; &#34;false&#34;</pre></div></div><div class=paragraph><p>これで、以前のバージョンのように、入力デバイスを (キーボードレイアウトの変更のように) 必要なオプションを用いて設定できるようになります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>この章には部分的に古くなった情報が含まれています。
FreeBSD のデスクトップ設定に HAL デーモン (hald) はもう使われません。</p></div></td></tr></tbody></table></div><div class=paragraph><p>すでに説明したように、デフォルトで hald デーモンがキーボードを自動的に認識します。 キーボードレイアウトやモデルを正しく認識しない場合でも、 GNOME, KDE もしくは Xfce のようなデスクトップ環境が、 キーボードの設定ツールを提供しています。 しかしながら、 <a href="https://man.freebsd.org/cgi/man.cgi?query=setxkbmap&amp;sektion=1&amp;format=html">setxkbmap(1)</a> ユーティリティや hald の設定ルールを利用することで、 キーボードのプロパティを直接設定できます。</p></div><div class=paragraph><p>たとえば、フランス語のレイアウトの PC 102 キーボードを使いたい場合には、 hald のキーボード設定ファイル <span class=filename>x11-input.fdi</span> を作成し、 <span class=filename>/usr/local/etc/hal/fdi/policy</span> ディレクトリに保存してください。 このファイルは以下を含んでいる必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;deviceinfo version=&#34;0.2&#34;&gt;
  &lt;device&gt;
    &lt;match key=&#34;info.capabilities&#34; contains=&#34;input.keyboard&#34;&gt;
	  &lt;merge key=&#34;input.x11_options.XkbModel&#34; type=&#34;string&#34;&gt;pc102&lt;/merge&gt;
	  &lt;merge key=&#34;input.x11_options.XkbLayout&#34; type=&#34;string&#34;&gt;fr&lt;/merge&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;</pre></div></div><div class=paragraph><p>このファイルがすでに存在する場合には、 キーボードの設定に関する部分をただ単にコピーし、 ファイルに追加してください。</p></div><div class=paragraph><p>hald がこのファイルを読み込むように、 コンピュータを再起動してください。</p></div><div class=paragraph><p>X 端末やスクリプトから以下のコマンドラインを実行することでも、 同様に設定できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setxkbmap <span class=nt>-model</span> pc102 <span class=nt>-layout</span> fr</code></pre></div></div><div class=paragraph><p><span class=filename>/usr/local/share/X11/xkb/rules/base.lst</span> には、利用可能なキーボード、 レイアウトおよびオプションの一覧があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>xorg.conf.new</span> 設定ファイルを好みに合うように調整できます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a> のようなテキストエディタでファイルを開いてください。 古いモニタや、通常とは異なるモデルで、 同期周波数の自動認識に対応していない場合には、 以下のような設定を <span class=filename>xorg.conf.new</span> の <code>"Monitor"</code> セクションの下に加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
        Identifier   &#34;Monitor0&#34;
        VendorName   &#34;Monitor Vendor&#34;
        ModelName    &#34;Monitor Model&#34;
        HorizSync    30-107
        VertRefresh  48-120
EndSection</pre></div></div><div class=paragraph><p>ほとんどのモニタは同期周波数の自動認識に対応しているので、 これらの値を手動で入力する必要はありません。 自動認識に対応していないモニタでは、 ダメージの可能性を避けるため、 メーカーが提供している値のみを入力してください。</p></div><div class=paragraph><p>X はモニタが対応していれば DPMS (Energy Star) 機能を使うことができます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=xset&amp;sektion=1&amp;format=html">xset(1)</a> プログラムでタイムアウトをコントロールしたり、 強制的にスタンバイ、サスペンドや電源オフにすることができます。 モニタの DPMS 機能を有効にしたい場合は、 <code>"Monitor"</code> セクションに次の行を加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>Option       &#34;DPMS&#34;</pre></div></div><div class=paragraph><p><span class=filename>xorg.conf.new</span> 設定ファイルはエディタで開いたままにしておき、 デフォルトの解像度と色数を好みで選んでください。 <code>"Screen"</code> セクションで定義されます。</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
        Identifier &#34;Screen0&#34;
        Device     &#34;Card0&#34;
        Monitor    &#34;Monitor0&#34;
        DefaultDepth 24
        SubSection &#34;Display&#34;
                Viewport  0 0
                Depth     24
                Modes     &#34;1024x768&#34;
        EndSubSection
EndSection</pre></div></div><div class=paragraph><p><code>DefaultDepth</code> というキーワードは 実行時のデフォルトの色数について記述するためのものです。 <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a> のコマンドラインスイッチ <code>-depth</code> が使用された場合はそちらが優先されます。 <code>Modes</code> というキーワードは、 与えられた色数におけるデフォルトの解像度を記述しておくためのものです。 ターゲットのシステムのグラフィックハードウェアによって定義されている、 VESA スタンダードモードのみがサポートされていることに注意してください。 上の例ではデフォルトの色数はピクセルあたり 24 ビットであり、 この色数での解像度は 1024 ピクセル× 768 ピクセルです。</p></div><div class=paragraph><p>最後に、設定ファイルを保存し、 上の例にあるようにテストしてみてください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>トラブルシューティングの過程で助けとなるツールのひとつに Xorg のログファイルがあります。 これには、Xorg サーバが検知したデバイスそれぞれについての情報があります。 Xorg のログファイル名は <span class=filename>/var/log/Xorg.0.log</span> という形式です。実際のログファイル名は <span class=filename>Xorg.0.log</span> から <span class=filename>Xorg.8.log</span> のように変わります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>すべてうまくいったなら、設定ファイルを <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a> が見つけることができる共通の場所に置きます。 これは、通常は <span class=filename>/etc/X11/xorg.conf</span> や <span class=filename>/usr/local/etc/X11/xorg.conf</span> です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp xorg.conf.new /etc/X11/xorg.conf</span></code></pre></div></div><div class=paragraph><p>これで Xorg の設定は完了です。
<a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a> ユーティリティで Xorg を起動できます。
<a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=8&amp;format=html">xdm(8)</a> を使って Xorg サーバを起動することもできます。</p></div><div class=sect3><h4 id=_intel_i810_グラフィックチップセットの設定>5.9.1. Intel® <code>i810</code> グラフィックチップセットの設定<a class=anchor href=#_intel_i810_グラフィックチップセットの設定></a></h4><div class=paragraph><p>Intel® i810 統合チップセットを設定するには、 Xorg にカードを制御させるために AGP プログラミングインタフェースである <span class=filename>agpgart</span> が必要になります。 詳しくは、<a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> ドライバのマニュアルページをご覧ください。</p></div><div class=paragraph><p>このドライバを用いることで、 他のグラフィックボードと同様に設定を行うことができるようになります。 カーネルに <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> ドライバが組み込まれていないシステムでは、 このモジュールを <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> を使って読み込もうとしても動作しないことに注意してください。 このドライバは、 起動時にカーネル内に存在するようにカーネル内部に組み込むか、 <span class=filename>/boot/loader.conf</span> を使わなければなりません。</p></div></div><div class=sect3><h4 id=_ワイドスクリーンフラットパネルの追加>5.9.2. ワイドスクリーンフラットパネルの追加<a class=anchor href=#_ワイドスクリーンフラットパネルの追加></a></h4><div class=paragraph><p>この節では、設定に関する幾分高度な知識を必要とします。 これまでに述べた標準ツールを使って設定に失敗する場合は、 ログファイルを参照してください。 ログファイルには、 設定のために有用な情報が十分含まれています。 テキストエディタを使用する必要があるでしょう。</p></div><div class=paragraph><p>現在のワイドスクリーン (WSXGA, WSXGA+, WUXGA, WXGA, WXGA+ など) は、 16:10 や 10:9 形式、または (問題を含む可能性のある) 他のアスペクト比に対応しています。 以下は、16:10 アスペクト比のスクリーン解像度の例です。</p></div><div class=ulist><ul><li><p>2560x1600</p></li><li><p>1920x1200</p></li><li><p>1680x1050</p></li><li><p>1440x900</p></li><li><p>1280x800</p></li></ul></div><div class=paragraph><p>これらの解像度のひとつを以下のように <code>"Screen" セクション</code> の 可能な <code>Mode</code> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
Identifier &#34;Screen0&#34;
Device     &#34;Card0&#34;
Monitor    &#34;Monitor0&#34;
DefaultDepth 24
SubSection &#34;Display&#34;
	Viewport  0 0
	Depth     24
	Modes     &#34;1680x1050&#34;
EndSubSection
EndSection</pre></div></div><div class=paragraph><p>Xorg は、I2C/DDC 情報を通してワイドスクリーンの解像度に関する情報を取得できるので、 モニタの周波数や解像度の範囲を把握しています。</p></div><div class=paragraph><p>もし、これらの <code>ModeLines</code> がドライバに存在しないのであれば、 Xorg にヒントを与えなけれならないでしょう。 <code>ModeLine</code> を手動で設定するのに十分な情報を <span class=filename>/var/log/Xorg.0.log</span> から得ることができます。 以下のような情報を探してください。</p></div><div class="literalblock programlisting"><div class=content><pre>(II) MGA(0): Supported additional Video Mode:
(II) MGA(0): clock: 146.2 MHz   Image Size:  433 x 271 mm
(II) MGA(0): h_active: 1680  h_sync: 1784  h_sync_end 1960 h_blank_end 2240 h_border: 0
(II) MGA(0): v_active: 1050  v_sync: 1053  v_sync_end 1059 v_blanking: 1089 v_border: 0
(II) MGA(0): Ranges: V min: 48  V max: 85 Hz, H min: 30  H max: 94 kHz, PixClock max 170 MHz</pre></div></div><div class=paragraph><p>これは EDID と呼ばれる情報です。 この情報を用いて <code>ModeLine</code> を作成するには、 正しい順番に数字を入力するだけです。</p></div><div class="literalblock programlisting"><div class=content><pre> ModeLine &lt;name&gt; &lt;clock&gt; &lt;4 horiz. timings&gt; &lt;4 vert. timings&gt;</pre></div></div><div class=paragraph><p>この例では <code>Monitor セクション</code> の <code>ModeLine</code> は以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
Identifier      &#34;Monitor1&#34;
VendorName      &#34;Bigname&#34;
ModelName       &#34;BestModel&#34;
ModeLine        &#34;1680x1050&#34; 146.2 1680 1784 1960 2240 1050 1053 1059 1089
Option          &#34;DPMS&#34;
EndSection</pre></div></div><div class=paragraph><p>以上の簡単な編集作業が終わったら、 新しいワイドスクリーンモニタ上で X が動作するでしょう。</p></div></div><div class=sect3><h4 id=compiz-troubleshooting>5.9.3. Compiz Fusion 使用時のトラブルシューティング<a class=anchor href=#compiz-troubleshooting></a></h4><div class=sect4><h5 id=_compiz_fusion_をインストールし説明されたようにコマンドを実行すると_ウィンドウのタイトルバーやボタンが表示されません_何が問題でしょうか>5.9.3.1. Compiz Fusion をインストールし、説明されたようにコマンドを実行すると、 ウィンドウのタイトルバーやボタンが表示されません。 何が問題でしょうか？<a class=anchor href=#_compiz_fusion_をインストールし説明されたようにコマンドを実行すると_ウィンドウのタイトルバーやボタンが表示されません_何が問題でしょうか></a></h5><div class=paragraph><p>おそらく <span class=filename>/etc/X11/xorg.conf</span> の設定が行われていていないのでしょう。 このファイルを詳細に確認してください。特に <code>DefaultDepth</code> および <code>AddARGBGLXVisuals</code> ディレクティブを確認してください。</p></div></div><div class=sect4><h5 id=_compiz_fusion_を起動するコマンドを実行するとx_サーバがクラッシュし_コンソールに戻ります何が問題でしょうか>5.9.3.2. Compiz Fusion を起動するコマンドを実行すると、X サーバがクラッシュし、 コンソールに戻ります。何が問題でしょうか？<a class=anchor href=#_compiz_fusion_を起動するコマンドを実行するとx_サーバがクラッシュし_コンソールに戻ります何が問題でしょうか></a></h5><div class=paragraph><p><span class=filename>/var/log/Xorg.0.log</span> ファイルを確認すると、 X の起動時のエラーメッセージを探し出すことができます。 多くの場合は、以下のようなものです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     Failed to initialize the GLX module<span class=p>;</span> please check <span class=k>in </span>your X
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     log file that the GLX module has been loaded <span class=k>in </span>your X
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     server, and that the module is the NVIDIA GLX module.  If
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     you <span class=k>continue </span>to encounter problems, Please try
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     reinstalling the NVIDIA driver.</code></pre></div></div><div class=paragraph><p>これは通常 Xorg をアップグレードした時に起きる現象です。 <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-driver/>x11/nvidia-driver</a> package をインストールして glx を再構築してください。</p></div></div></div></div></div></div><h1 id=common-tasks class=sect0>Part II: 日々の生活<a class=anchor href=#common-tasks></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>第 1 部では基礎的なことがらを説明したので、 ハンドブックの第 2 部では FreeBSD でよく使われる機能について説明します。 各章の内容は以下のとおりです。</p></div><div class=ulist><ul><li><p>ブラウザ、生産的なツール、ドキュメントビューアといった、 人気があって便利なデスクトップアプリケーションの紹介</p></li><li><p>FreeBSD で利用可能なマルチメディアツールの紹介</p></li><li><p>特別な機能を有効にするために、 カスタム FreeBSD カーネルを構築する手順の説明</p></li><li><p>デスクトップおよびネットワーク接続両方のプリンタの設定に関する、 印刷システムの詳細な説明</p></li><li><p>FreeBSD システムで Linux アプリケーションを実行する方法</p></li></ul></div><div class=paragraph><p>これらの章では、読み飛ばしを推奨しているものもあります。 これについてはそれぞれの章の始めにある概要に書かれています。</p></div></div></div><div class=sect1><h2 id=desktop>Chapter 6. デスクトップアプリケーション<a class=anchor href=#desktop></a></h2><div class=sectionbody><div class=sect2><h3 id=desktop-synopsis>6.1. この章では<a class=anchor href=#desktop-synopsis></a></h3><div class=paragraph><p>FreeBSD は性能や安定性によりサーバとして人気がある一方で、 日々のデスクトップとしての利用にも適しています。 packages や ports から 36000 を超えるアプリケーションを利用できるので、 さまざまなアプリケーションを動かせるようにカスタマイズしたデスクトップを作り上げることができます。 この章では、ウェブブラウザ、生産的なソフトウェア、ドキュメントビューア、 および財務管理ソフトウェアといった、 数多くのデスクトップアプリケーションのインストール方法について説明します。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>一から構築するのではなく、 事前に構築されたデスクトップバージョンの FreeBSD をお望みのユーザは、<a href=https://www.furybsd.org>FuryBSD</a>, <a href=https://ghostbsd.org>GhostBSD</a> および <a href=https://www.midnightbsd.org>MidnightBSD</a> をご覧ください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この章の読者は、以下のことを理解しておく必要があります。</p></div><div class=ulist><ul><li><p>package または ports を用いたサードパーティ製ソフトウェアのインストール方法 (<a href=./#ports>アプリケーションのインストール - packages と ports</a>)。</p></li><li><p>X およびウィンドウマネージャのインストール方法 (<a href=./#x11>X Window System</a>)。</p></li></ul></div><div class=paragraph><p>マルチメディア環境を整える方法については <a href=./#multimedia>マルチメディア</a> を参照してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この文書は英語で書かれている原文をそのまま邦訳したものです。 必ずしも各アプリケーションで日本語が扱えるとは限らないことに注意してください。 日本語に対応したアプリケーションは、Ports Collection の japanese ディレクトリにあるかもしれません。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=desktop-browsers>6.2. ブラウザ<a class=anchor href=#desktop-browsers></a></h3><div class=paragraph><p>FreeBSD では Web ブラウザは事前にインストールされていません。 そのかわり、Ports Collection の <a href=https://www.FreeBSD.org/ports/>www</a> カテゴリには数多くの Web ブラウザ が用意されており、 多くのプログラムを packages からインストールしたり、 Ports Collection からコンパイルできます。</p></div><div class=paragraph><p>KDE や GNOME デスクトップ環境には、 それぞれ HTML ブラウザが用意されています。 これらのデスクトップ環境を設定するための情報については <a href=./#x11-wm>「デスクトップ環境」</a> を参照してください。</p></div><div class=paragraph><p>軽量なブラウザには、 <a class=package href=https://cgit.freebsd.org/ports/tree/www/dillo2/>www/dillo2</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/www/links/>www/links</a>, および <a class=package href=https://cgit.freebsd.org/ports/tree/www/w3m/>www/w3m</a> といったものがあります。</p></div><div class=paragraph><p>この節では、広く使われている以下の web ブラウザのインストール方法について説明します。 もし、アプリケーションがリソースを大量に消費したり、 ports からのコンパイルに時間がかかったり、 他の ports に大きく依存する場合には、そのことについても触れます。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">アプリケーション名</th><th class="tableblock halign-left valign-top">必要なリソース</th><th class="tableblock halign-left valign-top">port からのインストール</th><th class="tableblock halign-left valign-top">備考</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>中</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD, Linux® および地域化されたバージョンを利用できます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Konqueror</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>中</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE ライブラリを必要とします。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chromium</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>中</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ を必要とします。</p></td></tr></tbody></table><div class=sect3><h4 id=_firefox>6.2.1. Firefox<a class=anchor href=#_firefox></a></h4><div class=paragraph><p>Firefox は、 標準に準拠した HTML 表示エンジン、タブブラウジング、ポップアップブロック、 拡張性、高い安全性などが特徴のオープンソースのブラウザです。 Firefox は Mozilla のコードベースから派生したブラウザです。</p></div><div class=paragraph><p>最新の Firefox の package をインストールするには以下のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install firefox</span></code></pre></div></div><div class=paragraph><p>Firefox 延長サポート版 (ESR: Extended Support Release) を利用したい場合には、 かわりに以下のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install firefox-esr</span></code></pre></div></div><div class=paragraph><p>かわりにソースコードから希望の firefox をコンパイルすることもできます。 この例では <a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a> をビルドしますが、 <code>firefox</code> の部分は、 インストールする ESR やローカライズに置き換えることもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/firefox</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_konqueror>6.2.2. Konqueror<a class=anchor href=#_konqueror></a></h4><div class=paragraph><p>Konqueror はブラウザであると同時に、 ファイルマネージャおよびマルチメディアビューアの役割も果たします。 Konqueror は、KHTML とともに WebKit にも対応しています。WebKit は Chromium など最近のブラウザの多くで採用されているレンダリングエンジンです。</p></div><div class=paragraph><p>Konqueror は、 以下のように入力して package からインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install konqueror</span></code></pre></div></div><div class=paragraph><p>Ports Collection からインストールするには、 以下のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-fm/konqueror/</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_chromium>6.2.3. Chromium<a class=anchor href=#_chromium></a></h4><div class=paragraph><p>Chromium は、 オープンソースのブラウザのプロジェクトで、 より安全かつより高速、 より安定したウェブブラウジングを目指しています。 Chromium は、タブブラウジング、 ポップアップブロック、拡張機能などの機能を持っています。 Chromium は、Google Chrome ウェブブラウザがベースとしているオープンソースのプロジェクトです。</p></div><div class=paragraph><p>Chromium は、 以下のように入力することで package からインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install chromium</span></code></pre></div></div><div class=paragraph><p>または、Ports Collection を用いて ソースから Chromium をコンパイルしてインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/chromium</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Chromium の実行可能ファイルは、 <span class=filename>/usr/local/bin/chrome</span> です。 <span class=filename>/usr/local/bin/chromium</span> ではありません。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=desktop-productivity>6.3. 生産的なアプリケーション<a class=anchor href=#desktop-productivity></a></h3><div class=paragraph><p>生産的なアプリケーションということになると、 ユーザはしばしばオフィススイートや、 使いやすい文書作成ソフトウェアを求めるでしょう。 デフォルトの生産的なアプリケーションはありませんが、 KDE のような <a href=./#x11-wm>デスクトップ環境</a> はオフィススイートを提供しています。 インストールされているウィンドウマネージャにかかわらず、FreeBSD では、 いくつものオフィススイート、 グラフィカルな文書作成ソフトウェアを利用できます。</p></div><div class=paragraph><p>この節では、 以下の人気のある生産的なソフトウェアのインストール方法について説明します。 もし、アプリケーションがリソースを大量に消費したり、 ports からのコンパイルに時間がかかったり、 もしくは他の ports に大きく依存する場合には、 そのことについても触れます。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">アプリケーション名</th><th class="tableblock halign-left valign-top">必要なリソース</th><th class="tableblock halign-left valign-top">port からのインストール</th><th class="tableblock halign-left valign-top">実行に必要となる主な環境</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Calligra</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AbiWord</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>軽</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ または GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gimp</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Apache OpenOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>莫大</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>JDK™ および Mozilla</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>LibreOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>やや多</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>莫大</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ または KDE/ GNOME または JDK™</p></td></tr></tbody></table><div class=sect3><h4 id=_calligra>6.3.1. Calligra<a class=anchor href=#_calligra></a></h4><div class=paragraph><p>KDE デスクトップには、 KDE 環境以外でも利用可能なオフィススイートがあります。 Calligra には、他のオフィススイートと同様に、 標準的なアプリケーションが含まれています。 Words は文書作成ソフトウェア、 Sheets は表計算ソフトウェア、 Stage はプレゼンテーションソフトウェア、そして Karbon は図形描画ソフトウェアです。</p></div><div class=paragraph><p>FreeBSD では package または port から <a class=package href=https://cgit.freebsd.org/ports/tree/editors/calligra/>editors/calligra</a> をインストール出来ます。 package からインストールするには次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install calligra</span></code></pre></div></div><div class=paragraph><p>package を入手できない場合は、かわりに Ports Collection を利用してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/calligra</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_abiword>6.3.2. AbiWord<a class=anchor href=#_abiword></a></h4><div class=paragraph><p>AbiWord は、Microsoft® Word のような見た目や操作感を持つフリーの文書作成ソフトウェアです。 速く、多くの機能を持ち、ユーザフレンドリです。</p></div><div class=paragraph><p>AbiWord は、 Microsoft® <span class=filename>.rtf</span> のような独自仕様を含む多くの形式のファイルを読み書きできます。</p></div><div class=paragraph><p>AbiWord package をインストールするには、以下のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install abiword</span></code></pre></div></div><div class=paragraph><p>package を入手できない場合は、 Ports Collection からコンパイルしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/abiword</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_gimp>6.3.3. GIMP<a class=anchor href=#_gimp></a></h4><div class=paragraph><p>画像を描画したり写真を修正することに関して、 GIMP は洗練された編集プログラムです。 単純にお絵かきソフトウェアとして使うこともできますし、 高品質な写真の加工ツールとしても使えます。 多くのプラグインに対応しており、 スクリプトインタフェースを特徴としています。 GIMP はさまざまな形式のファイルを読み書きでき、 スキャナやタブレットとのインタフェースにも対応しています。</p></div><div class=paragraph><p>package をインストールするには、以下のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gimp</span></code></pre></div></div><div class=paragraph><p>もしくは、Ports Collection を利用してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/gimp</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Ports Collection の graphics カテゴリ (<a href=https://www.FreeBSD.org/ja/ports/>freebsd.org/ja/ports/</a>) には、GIMP に関連したプラグイン、 ヘルプファイルおよびユーザマニュアルなどがあります。</p></div></div><div class=sect3><h4 id=_apache_openoffice>6.3.4. Apache OpenOffice<a class=anchor href=#_apache_openoffice></a></h4><div class=paragraph><p>Apache OpenOffice は、 Apache Software Foundation のインキュベータプロジェクトとして開発が行われているオープンソースのオフィススイートです。 Apache OpenOffice は、完全なオフィススイートに必須のアプリケーション (文書作成ソフトウェア、表計算ソフトウェア、 プレゼンテーションソフトウェア、そして図形描画ソフトウェア) をひととおり揃えています。 ユーザインタフェースは他のオフィススイートと似ており、 広く用いられているさまざまな形式のファイルを読み書きできます。 多くの言語で利用でき、インタフェース、スペルチェッカ、 辞書は国際化されています。</p></div><div class=paragraph><p>Apache OpenOffice の文書作成ソフトウェアは、ネイティブの XML ファイル形式を採用することでポータビリティや柔軟性を高めています。 表計算ソフトウェアにはマクロ機能があり、 外部データベースと接続することもできます。 Apache OpenOffice は、 Windows®, Solaris™, Linux®, FreeBSD および Mac OS® X において安定してネイティブに動作しています。 Apache OpenOffice についてのより詳しい情報は、 <a href=http://openoffice.org/>openoffice.org</a> をご覧ください。 また、<a href=http://porting.openoffice.org/freebsd/>porting.openoffice.org/freebsd/</a> から、FreeBSD 特有の情報を参照してください。</p></div><div class=paragraph><p>Apache OpenOffice package をインストールするには、以下のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install apache-openoffice</span></code></pre></div></div><div class=paragraph><p>package をインストールしたら、以下のコマンドを入力して Apache OpenOffice を起動してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% openoffice-X.Y.Z</code></pre></div></div><div class=paragraph><p>ここで <em>X.Y.Z</em> は、 インストールされている Apache OpenOffice のバージョン番号です。 Apache OpenOffice の初回起動時に、いくつかの質問が行われ、 ユーザのホームディレクトリに <span class=filename>.openoffice.org</span> フォルダが作成されます。</p></div><div class=paragraph><p>希望の Apache OpenOffice の packages を利用できない場合には、port を利用する方法もあります。 しかしながら、コンパイルには大きなディスクスペースと、 本当にかなり長い時間を必要とします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/openoffice-4</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>地域化されたバージョンをビルドするには、 上記のコマンドの代わりに以下を実行して下さい。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make LOCALIZED_LANG=your_language install clean</span></code></pre></div></div><div class=paragraph><p><em>your_language</em> を正しい言語 ISO コードに置き換えてください。 サポートされている言語コードは、同じ port ディレクトリにある <span class=filename>files/Makefile.localized</span> に書かれています。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_libreoffice>6.3.5. LibreOffice<a class=anchor href=#_libreoffice></a></h4><div class=paragraph><p>LibreOffice は、<a href=http://www.documentfoundation.org/>documentfoundation.org</a> が開発しているフリーソフトウェアのオフィススイートです。 他のメジャーなオフィススイートと互換性があり、 さまざまなプラットフォームで利用できます。 Apache OpenOffice.org からの新しいフォークで、 完全なオフィススイートに必須のアプリケーション (文書作成ソフトウェア、表計算ソフトウェア、 プレゼンテーションソフトウェア、図形描画ソフトウェア、 データベース管理ソフトウェア、数式エディタ) をすべて揃えています。 多くの言語で利用でき、 インタフェース、スペルチェッカ、辞書は国際化されています。</p></div><div class=paragraph><p>LibreOffice の文書作成ソフトウェアは、 ネイティブのファイル形式に XML を採用することで ポータビリティや柔軟性を高めています。 表計算ソフトウェアにはマクロ機能があり、 外部データベースと接続することもできます。 LibreOffice は、 Windows®, Solaris™, Linux®, FreeBSD, Mac OS® X において安定してネイティブに動作しています。 LibreOffice についての詳しい情報は、<a href=http://www.libreoffice.org/>libreoffice.org</a> をご覧ください。</p></div><div class=paragraph><p>英語版の LibreOffice package をインストールするには、以下のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install libreoffice</span></code></pre></div></div><div class=paragraph><p>Ports Collection の edtors カテゴリ (<a href=https://www.FreeBSD.org/ja/ports/>freebsd.org/ja/ports/</a>) カテゴリには、地域化された LibreOffice が用意されています。 地域化された package をインストールするには、 <code>libreoffice</code> を地域化された package 名に置き換えてください。</p></div><div class=paragraph><p>package をインストールしたら、以下のコマンドで LibreOffice を起動してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% libreoffice</code></pre></div></div><div class=paragraph><p>初回起動時には、いくつかの質問が行われ、 ユーザのホームディレクトリに <span class=filename>.libreoffice</span> フォルダが作成されます。</p></div><div class=paragraph><p>希望の LibreOffice の packages を利用できない場合には、port からコンパイルする方法もあります。 しかしながら、コンパイルには大きなディスクスペースと、 本当にかなり長い時間を必要とします。 以下の例では、英語版をコンパイルします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/libreoffice</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>地域化されたバージョンをビルドしたいのなら、 希望の言語の port ディレクトリに <code>cd</code> コマンドで移動してください。 対応している言語は、Ports Collection の editors カテゴリ (<a href=https://www.FreeBSD.org/ja/ports/>freebsd.org/ja/ports/</a>) にあります。</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=desktop-viewers>6.4. ドキュメントビューア<a class=anchor href=#desktop-viewers></a></h3><div class=paragraph><p>UNIX® の出現以降、 いくつかの新しい文書形式が広く使われるようになりました。 基本システムには、それらの文書が要求するビューアがないかもしれません。 この節ではそれらのドキュメントビューアのインストール方法について説明します。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">アプリケーション名</th><th class="tableblock halign-left valign-top">必要なリソース</th><th class="tableblock halign-left valign-top">port からのインストール</th><th class="tableblock halign-left valign-top">実行に必要になる主な環境</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Xpdf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>軽</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeType</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>軽</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Xaw3d</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Geeqie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>軽</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ または GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ePDFView</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>軽</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ または GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Okular</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect3><h4 id=_xpdf>6.4.1. Xpdf<a class=anchor href=#_xpdf></a></h4><div class=paragraph><p>FreeBSD 向けの軽い PDF ビューアを使いたいのなら Xpdf を試してみてください。 これは少ないリソースで動作するビューアで、軽くて効率的です。 標準の X フォントを利用し、 他の X ツールキットを必要としません。</p></div><div class=paragraph><p>Xpdf の package をインストールするには次のコマンドを入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xpdf</span></code></pre></div></div><div class=paragraph><p>package を入手できない場合は、 Ports Collection を利用してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/xpdf</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>インストールが完了したら xpdf を起動してください。 メニューを表示するにはマウスの右ボタンを押してください。</p></div></div><div class=sect3><h4 id=_gv>6.4.2. gv<a class=anchor href=#_gv></a></h4><div class=paragraph><p>gv は PostScript® と PDF のビューアです。これは ghostview をベースとしていますが、 Xaw3d ウィジットツールキットによってより良い外観になっています。 gv は向きや用紙のサイズ、 拡大縮小、アンチエイリアスなどたくさんの設定可能な機能を持っています。 ほとんどすべての操作をキーボードかマウスのどちらかだけで行なうことができます。</p></div><div class=paragraph><p>package から gv をインストールするには次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gv</span></code></pre></div></div><div class=paragraph><p>package を利用できない場合には、Ports Collection を使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/print/gv</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_geeqie>6.4.3. Geeqie<a class=anchor href=#_geeqie></a></h4><div class=paragraph><p>Geeqie は、 メンテナンスが行われていない GQView プロジェクトからのフォークで、開発を進めることと、 これまでに作成されたパッチを統合することを目指しています。 Geeqie は、 クリックひとつで画像ファイルを開いたり、外部エディタを起動したり、 サムネイル画像を作成できるような画像管理ソフトウェアです。 また、スライドショーや基本的なファイル操作機能も備えており、 画像のコレクションの管理や、 重複したファイルを見つけることが簡単にできます。 Geeqie は全画面表示、 および国際化にも対応しています。</p></div><div class=paragraph><p>Geeqie package をインストールするには次のコマンドを入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install geeqie</span></code></pre></div></div><div class=paragraph><p>package を入手できない場合は、 Ports Collection を利用してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/geeqie</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_epdfview>6.4.4. ePDFView<a class=anchor href=#_epdfview></a></h4><div class=paragraph><p>ePDFView は軽量な PDF ドキュメントビューアです。 このビューアは、 Gtk+ および Poppler ライブラリのみを使います。 このソフトウェアは、現在開発中ですが、ほぼすべての PDF ファイル (暗号化されたものを含む) を開くことが可能で、ドキュメントのコピーを保存でき、 CUPS を用いた印刷にも対応しています。</p></div><div class=paragraph><p>package から ePDFView をインストールするには以下のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install epdfview</span></code></pre></div></div><div class=paragraph><p>package が利用できないようでしたら、 Ports Collection を使ってインストールしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/epdfview</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_okular>6.4.5. Okular<a class=anchor href=#_okular></a></h4><div class=paragraph><p>Okular は、 KDE の KPDF をベースとした一般的なドキュメントビューアです。 このビューアは、PDF, PostScript®, DjVu, CHM, XPS, および ePub といった、多くの形式のファイルを開くことができます。</p></div><div class=paragraph><p>package で Okular をインストールするには、以下のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install okular</span></code></pre></div></div><div class=paragraph><p>package が利用できないようでしたら、 Ports Collection を使ってインストールしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/okular</span>
<span class=c># make install clean</span></code></pre></div></div></div></div><div class=sect2><h3 id=desktop-finance>6.5. 財務管理ソフトウェア<a class=anchor href=#desktop-finance></a></h3><div class=paragraph><p>FreeBSD のデスクトップで個人的な財務管理ができるように、 強力で簡単に使えるアプリケーションが用意されています。 それらのアプリケーションの中には Quicken や Excel などの広く行き渡った形式のファイルと互換性があるものもあります。</p></div><div class=paragraph><p>この節では次のアプリケーションについて説明します。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">アプリケーション名</th><th class="tableblock halign-left valign-top">必要なリソース</th><th class="tableblock halign-left valign-top">port からのインストール</th><th class="tableblock halign-left valign-top">実行に必要になる主な環境</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GnuCash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnumeric</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KMyMoney</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>少</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect3><h4 id=_gnucash>6.5.1. GnuCash<a class=anchor href=#_gnucash></a></h4><div class=paragraph><p>GnuCash は、 GNOME の一部で、 使いやすくかつ強力なアプリケーションとしてエンドユーザに提供されています。 GnuCash を使えば、 収入や支出、銀行口座、あるいは株を管理できます。 直観的なインタフェースを特徴としていますが、 高度な機能も提供しています。</p></div><div class=paragraph><p>GnuCash は洗練された登録機能、 階層構造の勘定システム、多くのキーボードショートカット、 自動補完機能を提供しています。 単一のトランザクションをより小さな要素に分解できます。 GnuCash は、 Quicken の QIF ファイルの読み込みやマージができます。 また、国際的な日付および通貨形式も扱えます。</p></div><div class=paragraph><p>GnuCash package をインストールするには次のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnucash</span></code></pre></div></div><div class=paragraph><p>package が手に入らなければ、Ports Collection を使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/gnucash</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_gnumeric>6.5.2. Gnumeric<a class=anchor href=#_gnumeric></a></h4><div class=paragraph><p>Gnumeric は、 GNOME コミュニティによって開発されている表計算ソフトウェアです。 セルの書式に従ってユーザの入力を自動的に推測する便利な機能や、 多くのシーケンスに対する自動補完機能があります。 Excel, Lotus 1-2-3, Quattro Pro といった広く行き渡っている多くの形式のファイルを読みこめます。 多くの関数を内蔵しており、 数値、通貨、日付、時間などのよく使うセルの書式が利用できます。</p></div><div class=paragraph><p>Gnumeric package をインストールするには次のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnumeric</span></code></pre></div></div><div class=paragraph><p>package が手に入らなければ、Ports Collection を使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/math/gnumeric</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_kmymoney>6.5.3. KMyMoney<a class=anchor href=#_kmymoney></a></h4><div class=paragraph><p>KMyMoney は、KDE コミュニティが作成している個人用財務管理アプリケーションです。 KMyMoney は、 商用の個人用財務管理ソフトウェアに見られる重要な機能を提供することを目指しています。 また、使いやすい複式簿記機能も特徴です。 KMyMoney は標準の Quicken QIF ファイルをインポート可能で、 投資履歴や複数通貨の取扱い、財政状況のレポートを提供します。</p></div><div class=paragraph><p>package から KMyMoney をインストールするには次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install kmymoney-kde4</span></code></pre></div></div><div class=paragraph><p>package が手に入らない場合は、 Ports Collection を使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/kmymoney-kde4</span>
<span class=c># make install clean</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=multimedia>Chapter 7. マルチメディア<a class=anchor href=#multimedia></a></h2><div class=sectionbody><div class=sect2><h3 id=multimedia-synopsis>7.1. この章では<a class=anchor href=#multimedia-synopsis></a></h3><div class=paragraph><p>FreeBSD は数多くの種類のサウンドカードに対応しており、 FreeBSD システムで原音に忠実な出力を楽しむことができます。 これには録音機能と、MPEG Audio Layer 3 (MP3) や Waveform Audio File (WAV), Ogg Vorbis などをはじめとした多くの形式の音楽の再生機能が含まれます。 加えて FreeBSD の Ports Collection には、 録音した音楽を編集したり、音響効果を加えたり、接続された MIDI 機器を制御するためのアプリケーションが用意されています。</p></div><div class=paragraph><p>FreeBSD ではビデオファイルおよび DVD の再生もできます。 FreeBSD の Ports Collection には、さまざまなビデオメディアをエンコード、 変換、再生するアプリケーションが用意されています。</p></div><div class=paragraph><p>この章では FreeBSD 上でサウンドカード、ビデオの再生、TV チューナカード、 スキャナを設定する方法について説明します。 また、これらのデバイスを使うためのアプリケーションについても説明します。</p></div><div class=paragraph><p>この章を読むと、以下のことがわかります。</p></div><div class=ulist><ul><li><p>FreeBSD でのサウンドカードの設定方法</p></li><li><p>サウンドの設定に関するトラブルシューティング</p></li><li><p>MP3 およびその他の形式の音声を再生、エンコードする方法</p></li><li><p>FreeBSD システムでのビデオ再生の準備</p></li><li><p>DVD, <span class=filename>.mpg</span> および <span class=filename>.avi</span> ファイルを再生する方法</p></li><li><p>CD および DVD の情報をファイルに抽出する方法</p></li><li><p>TV カードの設定方法</p></li><li><p>MythTV を FreeBSD にインストールして設定する方法</p></li><li><p>画像スキャナの設定方法</p></li><li><p>Bluetooth ヘッドホンの設定方法</p></li></ul></div><div class=paragraph><p>この章を読む前に、以下のことを理解しておく必要があります。</p></div><div class=ulist><ul><li><p>アプリケーションのインストール方法 (<a href=./#ports>アプリケーションのインストール - packages と ports</a>)</p></li></ul></div></div><div class=sect2><h3 id=sound-setup>7.2. サウンドカードの設定<a class=anchor href=#sound-setup></a></h3><div class=paragraph><p>設定をはじめる前に、サウンドカードのモデル、 そのカードが使用しているチップを確認してください。 FreeBSD は サウンドカードに幅広く対応しています。 使用しているカードが対応しているかどうか、 どの FreeBSD ドライバを使うかについて、 <a href=https://www.FreeBSD.org/releases/12.0R/hardware/>ハードウェアノート</a> の対応オーディオデバイスの一覧を確認してください。</p></div><div class=paragraph><p>サウンドデバイスを使うためには、 デバイスドライバを読み込まなければいけません。 もっとも簡単な方法は <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> を使ってサウンドカードのカーネルモジュールを読み込むことです。 次の例は、Intel 仕様のビルトインオーディオチップセットのドライバを読み込む例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_hda</span></code></pre></div></div><div class=paragraph><p>このドライバを起動時に読み込むように設定するためには、 <span class=filename>/boot/loader.conf</span> にドライバを追加してください。 このドライバの場合は以下の行になります。</p></div><div class="literalblock programlisting"><div class=content><pre>snd_hda_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>他に利用可能な読み込み可能なサウンドモジュールは <span class=filename>/boot/defaults/loader.conf</span> に記載されています。 どのドライバを利用すればいいか確かでなければ、 <span class=filename>snd_driver</span> モジュールを読み込んでください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_driver</span></code></pre></div></div><div class=paragraph><p><span class=filename>snd_driver</span> モジュールは、 一般に使用されるカードに対応したドライバをまとめて一度に読み込むメタドライバです。 このドライバを使用すれば、速やかに正しいドライバを探し出すことができます。 <span class=filename>/boot/loader.conf</span> ファイルを使用して、 すべてのサウンドドライバを読み込むこともできます。</p></div><div class=paragraph><p><span class=filename>snd_driver</span> メタドライバの読み込み後に、 どのドライバがサウンドカードに選択されたのかを知るには、 <code>cat /dev/sndstat</code> と入力してください。</p></div><div class=sect3><h4 id=_サウンドに対応したカスタムカーネルを設定する>7.2.1. サウンドに対応したカスタムカーネルを設定する<a class=anchor href=#_サウンドに対応したカスタムカーネルを設定する></a></h4><div class=paragraph><p>この節は、 サウンドカードのドライバをカーネルへ静的に組み込もうと考えているユーザ向けです。 カーネル再構築の詳細は <a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> を参照してください。</p></div><div class=paragraph><p>サウンドに対応したカスタムカーネルを使うときには、 オーディオフレームワークドライバをカーネルコンフィグレーションファイルに追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>device sound</pre></div></div><div class=paragraph><p>次に、サウンドカードに対応したドライバを追加します。 前節の Intel 仕様のビルトインオーディオチップセットの例では、 カスタムカーネルコンフィグレーションファイルに以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_hda</pre></div></div><div class=paragraph><p>ドライバのマニュアルページを読んで、 ドライバが使用するデバイス名を調べてください。</p></div><div class=paragraph><p>PnP 非対応の ISA サウンドカードでは、 IRQ および I/O ポートの設定を <span class=filename>/boot/device.hints</span>　 に指定する必要があるかもしれません。 システムの起動時に、<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> はこのファイルを読み、設定情報をカーネルに渡します。 たとえば、PnP 非対応の古い Creative SoundBlaster® 16 (ISA 接続) には <code>snd_sb16</code> とともに <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> ドライバを使用します。 このカードを使用する場合には、 カーネルコンフィグレーションファイルに以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_sbc
device snd_sb16</pre></div></div><div class=paragraph><p>もしカードが <code>0x220</code> I/O port と IRQ <code>5</code> を使用している場合には、 <span class=filename>/boot/device.hints</span> に以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>hint.sbc.0.at=&#34;isa&#34;
hint.sbc.0.port=&#34;0x220&#34;
hint.sbc.0.irq=&#34;5&#34;
hint.sbc.0.drq=&#34;1&#34;
hint.sbc.0.flags=&#34;0x15&#34;</pre></div></div><div class=paragraph><p><span class=filename>/boot/device.hints</span> に用いるべき構文は、<a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a> および、 サウンドカードの各ドライバのマニュアルページに記載されています。</p></div><div class=paragraph><p>これまでの設定はデフォルトのものです。 カードを使用する状況によっては、 IRQ やその他の設定を変更する必要があるかもしれません。 このカードについての詳細は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> をご覧ください。</p></div></div><div class=sect3><h4 id=sound-testing>7.2.2. サウンドのテスト<a class=anchor href=#sound-testing></a></h4><div class=paragraph><p>必要となるモジュールを読み込むか、カスタムカーネルで再起動すると、 サウンドカードが検出されます。 確認をするには、<code>dmesg | grep pcm</code> と実行してください。 この例は、ビルトイン Conexant CX20590 チップセットを搭載したシステムのものです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pcm0: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> at nid 5 on hdaa0
pcm1: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> at nid 6 on hdaa0
pcm2: &lt;Conexant CX20590 <span class=o>(</span>Analog 2.0+HP/2.0<span class=o>)&gt;</span> at nid 31,25 and 35,27 on hdaa1</code></pre></div></div><div class=paragraph><p>サウンドカードの状態は、 以下のコマンドを使用して確認することもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /dev/sndstat</span>
FreeBSD Audio Driver <span class=o>(</span>newpcm: 64bit 2009061500/amd64<span class=o>)</span>
Installed devices:
pcm0: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> <span class=o>(</span>play<span class=o>)</span>
pcm1: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> <span class=o>(</span>play<span class=o>)</span>
pcm2: &lt;Conexant CX20590 <span class=o>(</span>Analog 2.0+HP/2.0<span class=o>)&gt;</span> <span class=o>(</span>play/rec<span class=o>)</span> default</code></pre></div></div><div class=paragraph><p>この出力は、サウンドカードによって異なります。 <span class=filename>pcm</span> デバイスがなければ、 適切なデバイスドライバが読み込まれているか、 カーネルに追加されてコンパイルされているかどうかを確認してください。 次の節では、良くある問題とその解決方法をリストアップしています。</p></div><div class=paragraph><p>すべてうまくいけば、サウンドカードが FreeBSD で機能するでしょう。 CD または DVD ドライブのオーディオ出力端子がサウンドカードと適切に接続されていれば、 <a href="https://man.freebsd.org/cgi/man.cgi?query=cdcontrol&amp;sektion=1&amp;format=html">cdcontrol(1)</a> を使ってドライブ内のオーディオ CD を再生できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdcontrol <span class=nt>-f</span> /dev/acd0 play 1</code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>オーディオ CD は特別なエンコーディングが行われているため、 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> を使ってマウントすべきではありません。</p></div></td></tr></tbody></table></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/workman/>audio/workman</a> のように、 よりよいインタフェースを提供するさまざまなアプリケーションがあります。 <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> port をインストールして MP3 オーディオファイルを聞くことができます。</p></div><div class=paragraph><p>手っ取り早くカードをテストするには、 <span class=filename>/dev/dsp</span> デバイスにデータを送ってみてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>filename <span class=o>&gt;</span> /dev/dsp</code></pre></div></div><div class=paragraph><p>ここで <span class=filename>filename</span> は、どのような形式のファイルでも構いません。 このコマンドラインを実行すると雑音が発生するはずです。 これにより、サウンドカードが動作していることを確認できます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/dev/dsp*</span> デバイスノードは、 必要に応じて自動的に作成されます。 デバイスノードが使用されていない場合には存在せず、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> の出力に表示されません。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=bluetooth-headset>7.2.3. Bluetooth サウンドデバイスの設定<a class=anchor href=#bluetooth-headset></a></h4><div class=paragraph><p>Bluetooth デバイスへの接続についての説明は、この章の範囲外です。 詳細については <a href=./#network-bluetooth>Bluetooth</a> をご覧ください。</p></div><div class=paragraph><p>FreeBSD のサウンドシステムで Bluetooth サウンドシンクを動かすには、最初に <a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a> をインストールしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install virtual_oss</span></code></pre></div></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a> を使うには、 カーネルに <code>cuse</code> が読み込まれている必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload cuse</span></code></pre></div></div><div class=paragraph><p>システムのスタートアップ時に <code>cuse</code> を読み込むには、以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;cuse_load=yes&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a> でヘッドホンをサウンドシンクとして使うには、 Blueooth オーディオデバイスに接続後、 仮想デバイスを作成する必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># virtual_oss -C 2 -c 2 -r 48000 -b 16 -s 768 -R /dev/null -P /dev/bluetooth/headphones -d dsp</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この例において、 <em>headphones</em> は、 <span class=filename>/etc/bluetooth/hosts</span> に記載されているホスト名です。 代わりに <code>BT_ADDR</code> を使えます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>詳細については、<a href="https://man.freebsd.org/cgi/man.cgi?query=virtual_oss&amp;sektion=8&amp;format=html">virtual_oss(8)</a> をご覧ください。</p></div></div><div class=sect3><h4 id=troubleshooting>7.2.4. サウンドカードの問題についてのトラブルシューティング<a class=anchor href=#troubleshooting></a></h4><div class=paragraph><p><a href=#multimedia-sound-common-error-messages>良くあるエラーメッセージ</a> は、 良くあるエラーメッセージとその解決法の一覧です。</p></div><table id=multimedia-sound-common-error-messages class="tableblock frame-none grid-all stretch"><caption class=title>表 8. 良くあるエラーメッセージ</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">エラー</th><th class="tableblock halign-left valign-top">解決方法</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb_dspwr(XX) timed out</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>使用する I/O ポートが適切に設定されていません。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bad irq XX</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>使用する IRQ が正しく設定されていません。 サウンドカードの IRQ と設定した IRQ が同じかどうか確かめてください。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: gus pcm not attached, out of memory</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>デバイスを使用するのに十分なメモリを確保できません。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: can’t open /dev/dsp!</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fstat | grep dsp</code> と入力して、 他のアプリケーションがデバイスを使用しているか調べてください。 注目すべきトラブルメーカは esound と KDE のサウンド機能です。</p></td></tr></tbody></table><div class=paragraph><p>最近のグラフィックカードの中には、 HDMI を利用するため、 グラフィックカード自身がサウンドカードを持つものがあります。 このようなサウンドデバイスには、 時としてサウンドカードより若い番号が付けられることがあります。 そのような場合には、 サウンドカードをデフォルトプレイバックデバイスとして利用できません。 このことが原因かどうかを確認するには、dmesg を実行して <code>pcm</code> を探してください。 以下のような出力を得るかもしれません。</p></div><div class="literalblock programlisting"><div class=content><pre>...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 0 nid 1 on hdac0
pcm1: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 1 nid 1 on hdac0
pcm2: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 2 nid 1 on hdac0
pcm3: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: &lt;HDA Realtek ALC889 PCM #0 Analog&gt; at cad 2 nid 1 on hdac1
pcm5: &lt;HDA Realtek ALC889 PCM #1 Analog&gt; at cad 2 nid 1 on hdac1
pcm6: &lt;HDA Realtek ALC889 PCM #2 Digital&gt; at cad 2 nid 1 on hdac1
pcm7: &lt;HDA Realtek ALC889 PCM #3 Digital&gt; at cad 2 nid 1 on hdac1
...</pre></div></div><div class=paragraph><p>この例では、グラフィックカード (<code>NVidia</code>) には、サウンドカード (<code>Realtek ALC889</code>) より若い番号が付けられています。 サウンドカードをデフォルトのプレイバックデバイスとして利用するには、 <code>hw.snd.default_unit</code> をプレイバックで使用するユニット番号に変更してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.snd.default_unit=n</span></code></pre></div></div><div class=paragraph><p>ここで、<code>n</code> は使用するサウンドデバイスの番号です。 この例では <code>4</code> です。 <span class=filename>/etc/sysctl.conf</span> に以下の行を入れると、 設定の変更が常に反映されるようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>hw.snd.default_unit=4</pre></div></div></div><div class=sect3><h4 id=sound-multiple-sources>7.2.5. 複数音源の利用<a class=anchor href=#sound-multiple-sources></a></h4><div class=paragraph><p>同時に再生することのできる音源を複数実装していることは、 多くの場合望ましいことです。 FreeBSD では、"仮想サウンドチャネル" を使ってカーネル内でサウンドを合成することにより、 サウンドカードの再生を多重化することができます。</p></div><div class=paragraph><p>仮想チャネルの数を決めるのに三つの <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 変数を設定できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl dev.pcm.0.play.vchans=4</span>
<span class=c># sysctl dev.pcm.0.rec.vchans=4</span>
<span class=c># sysctl hw.snd.maxautovchans=4</span></code></pre></div></div><div class=paragraph><p>この例では四つの仮想チャネルを設定しています。 これは通常利用する上で十分実用的な数です。 <code>dev.pcm.0.play.vchans=4</code> と <code>dev.pcm.0.rec.vchans=4</code> は、 デバイスが取り付けられた後で設定できます。 これらは <span class=filename>pcm0</span> が再生や録音のために持っている仮想チャネルの数です。 <code>hw.snd.maxautovchans</code> は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> を用いて認識された新しいデバイスの仮想チャネル数です。 <span class=filename>pcm</span> モジュールはハードウェアドライバとは独立して読み込むことができるので、 <code>hw.snd.maxautovchans</code> は、オーディオデバイスが取り付けられた時に、 デバイスに与えられる仮想チャネルの数を表しています。 より詳細な情報については <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> を参照してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>デバイスを使用しているときに仮想チャンネルの数を変更することはできません。 まず、ミュージックプレーヤやサウンドデーモンといった デバイスを使用しているすべてのプログラムを終了してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>/dev/dsp0</span> を必要とするプログラムが意識しなくても、 適切な <span class=filename>pcm</span> デバイスが自動的に設定されます。</p></div></div><div class=sect3><h4 id=_ミキサチャネルの初期値を設定する>7.2.6. ミキサチャネルの初期値を設定する<a class=anchor href=#_ミキサチャネルの初期値を設定する></a></h4><div class=paragraph><p>各ミキサチャネルの初期値は <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> ドライバのソースコードにハードコーディングされています。 <a href="https://man.freebsd.org/cgi/man.cgi?query=mixer&amp;sektion=8&amp;format=html">mixer(8)</a> および他のサードパーティ製のアプリケーションやデーモンによって、 サウンドカードのミキサレベルを変更できますが、 永続的な解決方法ではありません。 そのかわり以下の例のように、 適切な値を <span class=filename>/boot/device.hints</span> ファイルに記述することによって、 ドライバレベルでミキサの初期値を設定することができます。</p></div><div class="literalblock programlisting"><div class=content><pre>hint.pcm.0.vol=&#34;50&#34;</pre></div></div><div class=paragraph><p>この例では、<a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> が読み込まれたと同時に、 ボリュームチャネルの初期値を <code>50</code> に設定します。</p></div></div></div><div class=sect2><h3 id=sound-mp3>7.3. MP3 オーディオ<a class=anchor href=#sound-mp3></a></h3><div class=paragraph><p>この節では、FreeBSD で利用できる MP3 プレイヤや、オーディオ CD トラックを吸い出す方法、 および MP3 のエンコード、 デコードの方法について説明します。</p></div><div class=sect3><h4 id=mp3-players>7.3.1. MP3 プレイヤ<a class=anchor href=#mp3-players></a></h4><div class=paragraph><p>Audacious は 人気のあるグラフィカルな MP3 プレイヤです。 Winamp スキンや追加のプラグインに対応しています。 Audacious のプレイリスト、 グラフィックイコライザ等のインタフェースは直感的です。 Winamp を使いなれている人は簡単に Audacious を使えるでしょう。 FreeBSD では、Audacious は <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/audacious/>multimedia/audacious</a> の port または package からインストールできます。 Audacious は、XMMS の子孫です。</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> package もしくは port は、 は代替となる コマンドライン上の MP3 プレイヤです。インストールしたら、再生する MP3 ファイルをコマンドラインから指定してください。 もしシステムが、複数のオーディオデバイスを搭載しているのであれば、 サウンドデバイスを同様に指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -a /dev/dsp1.0 Foobar-GreatesHits.mp3</span>
High Performance MPEG 1.0/2.0/2.5 Audio Player <span class=k>for </span>Layers 1, 2 and 3
        version 1.18.1<span class=p>;</span> written and copyright by Michael Hipp and others
        free software <span class=o>(</span>LGPL<span class=o>)</span> without any warranty but with best wishes

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo</code></pre></div></div><div class=paragraph><p>他の MP3 プレイヤも Ports Collection から利用できます。</p></div></div><div class=sect3><h4 id=rip-cd>7.3.2. CD オーディオトラックの抽出<a class=anchor href=#rip-cd></a></h4><div class=paragraph><p>CD 全体または CD トラックを MP3 に変換する前に、CD 上のオーディオデータをハードディスク上に抽出する必要があります。 これは raw CD Digital Audio (CDDA) データを WAV ファイルにコピーすることで行われます。</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> スイートからインストールされる <code>cdda2wav</code> ツールを用いて、CD からオーディオデータを抽出できます。</p></div><div class=paragraph><p>CD をドライブにいれて次のコマンドを <code>root</code> 権限で実行すると、 CD 全体をトラックごとに個々の WAV ファイルに抽出できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -B</span></code></pre></div></div><div class=paragraph><p>この例では、<code>-D <em>0,1,0</em></code> は SCSI デバイス <span class=filename>0,1,0</span> が抽出する CD を表します。 <code>cdrecord -scanbus</code> を使って、 システムの適切なデバイスパラメータを取得してください。</p></div><div class=paragraph><p>個々のトラックを抽出するには、 次のように <code>-t</code> でトラックを指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 7</span></code></pre></div></div><div class=paragraph><p>範囲を指定して、 一番目から七番目のトラックまで抽出したい場合、 次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 1+7</span></code></pre></div></div><div class=paragraph><p>ATAPI (IDE) CDROM ドライブから抽出するには、 SCSI ユニット番号をデバイス名に置き換えて指定します。 たとえば IDE ドライブから七番目のトラックを抽出するには、 次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D /dev/acd0 -t 7</span></code></pre></div></div><div class=paragraph><p>または、<a href=./#duplicating-audiocds>「オーディオ CD の複製」</a> で説明されているように、<code>dd</code> を使って ATAPI ドライブ上のオーディオトラックを展開できます。</p></div></div><div class=sect3><h4 id=mp3-encoding>7.3.3. MP3 のエンコードとデコード<a class=anchor href=#mp3-encoding></a></h4><div class=paragraph><p>lame は、 ポピュラーな MP3 エンコーダです。 <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a> port からインストールできます。 特許の問題から、package は利用できません。</p></div><div class=paragraph><p>次のコマンドを実行すると、抽出した WAV ファイル <span class=filename>audio01.wav</span> を使って <span class=filename>audio01.mp3</span> に変換します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lame -h -b 128 --tt &#34;曲名&#34; --ta &#34;アーティスト名&#34; --tl &#34;アルバム名&#34; \</span>
<span class=nt>--ty</span> <span class=s2>&#34;年&#34;</span> <span class=nt>--tc</span> <span class=s2>&#34;コメント&#34;</span> <span class=nt>--tg</span> <span class=s2>&#34;ジャンル&#34;</span> audio01.wav audio01.mp3</code></pre></div></div><div class=paragraph><p>ここで指定している 128 kbits は、MP3 の標準のビットレートです。 160 kbits または 192 kbits のビットレートは、 さらに高音質を提供します。 ビットレートが高くなるにつれて作成される MP3 ファイルは多くのディスク領域を消費します。 <code>-h</code> オプションを指定すると "低速高品質" モードとなります。 <code>--t</code> ではじまるオプションは ID3 タグを設定します。 このタグにはたいてい曲の情報が含まれており、 MP3 ファイルに格納されます。 Lame のマニュアルを参照すれば、 他のエンコーディングのオプションが見つかるでしょう。</p></div><div class=paragraph><p>MP3 からオーディオ CD を作成するには、 まず非圧縮のファイル形式に変換しなければなりません。 XMMS は WAV 形式へ変換できますが、 mpg123 は raw Pulse-Code Modulation (PCM) オーディオデータに変換します。</p></div><div class=paragraph><p>mpg123 を使って <span class=filename>audio01.mp3</span> を変換するには、PCM ファイルを指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -s audio01.mp3 &gt; audio01.pcm</span></code></pre></div></div><div class=paragraph><p>XMMS を使って MP3 を WAV 形式に変換するには、 以下の手順に従ってください。</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: XMMS を使って WAV 形式に変換する</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>XMMS を起動します。</p></li><li><p>右クリックで XMMS メニューを表示します。</p></li><li><p><code>Options</code> から <code>Preferences</code> を選択します。</p></li><li><p>Output Plugin を "Disk Writer Plugin" に変更します。</p></li><li><p><code>Configure</code> を押します。</p></li><li><p>非圧縮ファイルを書き出すディレクトリを入力、 または選択します。</p></li><li><p>普段通り XMMS へ MP3 ファイルを読み込みます。 音量は 100% でイコライザの設定はオフにします。</p></li><li><p><code>Play</code> を押します。 XMMS は MP3 を再生しているかのように表示しますが、 音声はきこえません。 実際には MP3 をファイルに出力しています。</p></li><li><p>終了したら、再び MP3 を聴けるように Output Plugin を以前のように元に戻すのを忘れないでください。</p></li></ol></div></div></div><div class=paragraph><p>WAV と PCM 形式は、 cdrecord で利用できます。 WAV ファイルを使用する場合、 それぞれのトラックの先頭に小さなノイズが入るのに気づくでしょう。 これは WAV ファイルのヘッダ情報です。 <a class=package href=https://cgit.freebsd.org/ports/tree/audio/sox/>audio/sox</a> port または package を使うとヘッダ情報を削除できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sox <span class=nt>-t</span> wav <span class=nt>-r</span> 44100 <span class=nt>-s</span> <span class=nt>-w</span> <span class=nt>-c</span> 2 track.wav track.raw</code></pre></div></div><div class=paragraph><p>FreeBSD での CD 作成の詳しい情報は <a href=./#creating-cds>「光メディア (CD & DVD) の作成と使用」</a> を参照してください。</p></div></div></div><div class=sect2><h3 id=video-playback>7.4. ビデオ再生<a class=anchor href=#video-playback></a></h3><div class=paragraph><p>ビデオ再生のための設定をはじめる前に、 ビデオカードのモデルおよびチップセットを確認する必要があります。 Xorg はさまざまなビデオカードに対応していますが、 すべてのカードがビデオ再生に性能を発揮できるとは限りません。 利用しているビデオカードの Xorg サーバが対応している拡張機能のリストを得るには、 Xorg を実行中に <code>xdpyinfo</code> を実行してください。</p></div><div class=paragraph><p>さまざまなプレイヤやオプションを試すのに、 テストファイルとして小さな MPEG ファイルを用意しておくのはよい考えです。 いくつかの DVD アプリケーションは DVD メディアを <span class=filename>/dev/dvd</span> として初期設定しているか、ハードコーディングしているので、 次のように適切なデバイスにシンボリックリンクを張っておくと便利かもしれません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -sf /dev/cd0 /dev/dvd</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> の仕様により、 このように手動で作成されたリンクはシステムを再起動すると消えてしまいます。 システムの起動時にこれらのシンボリックリンクを自動的に作成するには、 <span class=filename>/etc/devfs.conf</span> に下記の設定を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>link cd0 dvd</pre></div></div><div class=paragraph><p>特別な機能を必要とする DVD の抽出には、 DVD デバイスへの書き込み権限が必要です。</p></div><div class=paragraph><p>Xorg インタフェースの使う共有メモリを拡張するために、 以下の <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 変数の値を増やすことが推奨されています。</p></div><div class="literalblock programlisting"><div class=content><pre>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</pre></div></div><div class=sect3><h4 id=video-interface>7.4.1. ビデオ機能の決定<a class=anchor href=#video-interface></a></h4><div class=paragraph><p>Xorg においてビデオ表示性能を改善する方法はいくつかあり、 正しく動作するかどうかはハードウェアに大きく依存しています。 下記に説明したどの方法でも、 ハードウェアが変わると品質が変わるでしょう。</p></div><div class=paragraph><p>よく知られたビデオインタフェースは次の通りです。</p></div><div class="olist arabic"><ol class=arabic><li><p>Xorg: 共有メモリを用いた通常の出力</p></li><li><p>XVideo: 特別なアクセラレータによって、 drawable オブジェクトに直接ビデオを表示する Xorg インタフェースの拡張機能です。 この拡張を使うことで廉価なコンピュータでも高品質の再生が可能になります。 次の節では、 この拡張が動作していることの確認方法について説明します。</p></li><li><p>SDL: Simple Directmedia Layer は、 さまざまなオペレーティングシステムの間でサウンドとグラフィックスを効果的に利用したクロスプラットホームアプリケーションを開発することを目的としたレイヤです。 SDL はハードウェアに対する低レベルの抽象的概念を提供し、 時には Xorg インタフェースを使用するよりも効果的なことがあります。 FreeBSD では、SDL は、 <a class=package href=https://cgit.freebsd.org/ports/tree/devel/sdl20/>devel/sdl20</a> package または port によりインストールできます。</p></li><li><p>DGA: Direct Graphics Access は、 プログラムが Xorg サーバを介せず直接フレームバッファを変更することを可能にする Xorg の拡張機能です。 低レベルのメモリマッピングが実行できることを期待しているので、 この機能を使うプログラムは <code>root</code> 権限で実行されなければなりません。 DGA 機能拡張は <a href="https://man.freebsd.org/cgi/man.cgi?query=dga&amp;sektion=1&amp;format=html">dga(1)</a> によってテストとベンチマークができます。 <code>dga</code> 実行中はキーボードを押せばいつでもディスプレイ色が変更されます。 中止するには <kbd>q</kbd> を押します。</p></li><li><p>SVGAlib: 低レベルコンソールグラフィックレイヤ</p></li></ol></div><div class=sect4><h5 id=video-interface-xvideo>7.4.1.1. XVideo<a class=anchor href=#video-interface-xvideo></a></h5><div class=paragraph><p>この拡張機能が動作しているかどうかを調べるには、 <code>xvinfo</code> を使います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xvinfo</code></pre></div></div><div class=paragraph><p>以下のような結果が得られたならば、カードは XVideo に対応しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
  screen <span class=c>#0</span>
  Adaptor <span class=c>#0: &#34;Savage Streams Engine&#34;</span>
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      <span class=s2>&#34;XV_COLORKEY&#34;</span> <span class=o>(</span>range 0 to 16777215<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 2110<span class=o>)</span>
      <span class=s2>&#34;XV_BRIGHTNESS&#34;</span> <span class=o>(</span>range <span class=nt>-128</span> to 127<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
      <span class=s2>&#34;XV_CONTRAST&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_SATURATION&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_HUE&#34;</span> <span class=o>(</span>range <span class=nt>-180</span> to 180<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      <span class=nb>id</span>: 0x32595559 <span class=o>(</span>YUY2<span class=o>)</span>
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x32315659 <span class=o>(</span>YV12<span class=o>)</span>
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x30323449 <span class=o>(</span>I420<span class=o>)</span>
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x36315652 <span class=o>(</span>RV16<span class=o>)</span>
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      <span class=nb>id</span>: 0x35315652 <span class=o>(</span>RV15<span class=o>)</span>
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      <span class=nb>id</span>: 0x31313259 <span class=o>(</span>Y211<span class=o>)</span>
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</code></pre></div></div><div class=paragraph><p>リストにある形式、YUV2, YUV12 などが XVideo のすべての実装で存在するとは限りません。 対応している形式が少ないために、 あるプレイヤでは悪影響が出るかもしれないことにも注意してください。</p></div><div class=paragraph><p>出力が以下のような場合、</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen <span class=c>#0</span>
no adaptors present</code></pre></div></div><div class=paragraph><p>カードはおそらく XVideo に対応していないのでしょう。 このことはディスプレイでビデオを表示するのに、 ビデオカードおよびプロセッサによっては、 計算上の要求を満たすことがより困難になることを意味します。</p></div></div></div><div class=sect3><h4 id=video-ports>7.4.2. ビデオを扱う ports および packages<a class=anchor href=#video-ports></a></h4><div class=paragraph><p>この節では Ports Collection で利用可能な、 ビデオの再生に使用できるソフトウェアについて紹介します。</p></div><div class=sect4><h5 id=video-mplayer>7.4.2.1. MPlayer および MEncoder<a class=anchor href=#video-mplayer></a></h5><div class=paragraph><p>MPlayer はコマンドラインのビデオプレイヤで、 高速性と柔軟性をもたらすグラフィカルなインタフェースも持っています。 MPlayer の他のグラフィカルなフロントエンドも Ports Collection からインストールできます。</p></div><div class=paragraph><p>MPlayer は <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mplayer/>multimedia/mplayer</a> package または port からインストールできます。 いくつかのコンパイル時のオプションを設定することができ、また、 構築の際にさまざまなハードウェアのチェックがおこなわれます。 そのため、package からインストールを行わず、 port から構築することを好むユーザもいます。</p></div><div class=paragraph><p>port を構築する際に、メニューのオプションは、port にコンパイル時にオプションとしてどの形式に対応するかを決定するため、 見ておく必要があります。 オプションが選択されていなければ、 MPlayer はその形式のビデオ形式を表示することは出来ません。 矢印キーとスペースキーを使って必要な形式を選択してください。 選択が終わったら、<kbd>Enter</kbd> を押して、 port の構築とインストールを続けてください。</p></div><div class=paragraph><p>デフォルトでは、この packege または port は、 <code>mplayer</code> コマンドラインユーティリティと <code>gmplayer</code> グラフィカルユーティリティを構築します。 ビデオをエンコードする必要があれば、 <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mencoder/>multimedia/mencoder</a> port をコンパイルしてください。 ライセンスの制限のため、 MEncoder の package は利用できません。</p></div><div class=paragraph><p>MPlayer を初めて起動すると、 各自のホームディレクトリ内に <span class=filename>~/.mplayer</span> が作成されます。このサブディレクトリには、 ユーザ固有の設定ファイルのデフォルトバージョンが含まれています。</p></div><div class=paragraph><p>この節では、一般的な使用法についてのみ説明します。 数多くのオプションの完全な説明については、 mplayer(1) のマニュアルに記載されています。</p></div><div class=paragraph><p><span class=filename>testfile.avi</span> というファイルを再生するには、以下の例のように、 <code>-vo</code> とともに、 ビデオインタフェースを指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> xv testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> sdl testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> x11 testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo dga testfile.avi</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo &#39;sdl:dga&#39; testfile.avi</span></code></pre></div></div><div class=paragraph><p>ビデオ再生の相対的性能は多くの要因に依存し、 ハードウェアに応じて著しく変わると思われるので、 これらのオプションをすべて試してみる価値はあるでしょう。</p></div><div class=paragraph><p>DVD を再生するには、 <span class=filename>testfile.avi</span> を <code>dvd://<em>N</em> -dvd-device <em>DEVICE</em></code> に置き換えてください。 &lt;N> には再生するタイトル番号を、 <em>DEVICE</em> は DVD のデバイスノードを指定します。 たとえば、<span class=filename>/dev/dvd</span> から 2 番目のタイトルを再生するには以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo xv dvd://3 -dvd-device /dev/dvd</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>デフォルトの DVD デバイスは、 MPlayer port の構築時に <code>WITH_DVD_DEVICE=/path/to/desired/device</code> を追加することでで定義できます。 デフォルトでは、デバイスは <span class=filename>/dev/cd0</span> です。 詳細はこの port の <span class=filename>Makefile.options</span> をご覧ください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>停止、休止、 再生などをするにはキーバインディングを使ってください。 キーバインディングの一覧を見るには、<code>mplayer -h</code> を実行するか、もしくは、mplayer(1) を読んでください。</p></div><div class=paragraph><p>再生に関する追加のオプションがあります。 全画面モードにする <code>-fs -zoom</code> オプションと、 性能を向上させる <code>-framedrop</code> オプションです。</p></div><div class=paragraph><p>よく使用するオプションについては、各ユーザの <span class=filename>.mplayer/config</span> に以下のように追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>vo=xv
fs=yes
zoom=yes</pre></div></div><div class=paragraph><p><code>mplayer</code> を使って、 DVD タイトルを <span class=filename>.vob</span> に抽出できます。 DVD から 2 番目のタイトルをダンプするには次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd</span></code></pre></div></div><div class=paragraph><p>出力された <span class=filename>out.vob</span> ファイルは MPEG 形式です。</p></div><div class=paragraph><p>UNIX® ビデオについて、 高レベルのノウハウを得たいと考えている方は <a href=http://www.mplayerhq.hu/DOCS/>mplayerhq.hu/DOCS</a> をご覧ください。技術的な情報があります。 このドキュメントは、 バグを報告する前に、読むべきものです。</p></div><div class=paragraph><p><code>mencoder</code> を使う前に、<a href=http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html>mplayerhq.hu/DOCS/HTML/en/mencoder.html</a> を読んでオプションに慣れておくのはよい考えです。 品質向上、低ビットレート、形式変換をする方法が無数にあります。 これらの要素の調節具合で、性能が良かったり悪かったりするなど、 結果に違いが出るかもしれません。 コマンドラインオプションを不適切に組合せると、 <code>mplayer</code> でさえ再生できない出力ファイルを作成してしまいます。</p></div><div class=literalblock><div class=content><pre>はじめは単純なファイルのコピーです。</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> copy <span class=nt>-ovc</span> copy <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>したがって、単にファイルを抽出したいときには、 <code>mplayer</code> に <code>-dumpfile</code> をつけます。</p></div><div class=paragraph><p><span class=filename>input.avi</span> を音声に MPEG3 エンコードを使用して MPEG4 コーデックに変換するには、まず最初に <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a> port をインストールしてください。 ライセンスの制限により、package は利用できません。 インストールしたら、以下のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> mp3lame <span class=nt>-lameopts</span> <span class=nv>br</span><span class=o>=</span>192 <span class=se>\</span>
	 <span class=nt>-ovc</span> lavc <span class=nt>-lavcopts</span> <span class=nv>vcodec</span><span class=o>=</span>mpeg4:vhq <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>これは <code>mplayer</code> や <code>xine</code> といったアプリケーションで再生可能な出力ファイルを作成します。</p></div><div class=paragraph><p>DVD タイトルを直接再エンコードするためには、 上記のコマンドラインの <span class=filename>input.avi</span> を <code>dvd://1 -dvd-device /dev/dvd</code> に置き換えて、 <code>root</code> 権限で実行します。 期待する結果を得るには何度か繰り返すことになるので、 かわりにタイトルをファイルにダンプして、 ファイルに対して作業することをおすすめします。</p></div></div><div class=sect4><h5 id=video-xine>7.4.2.2. xine ビデオプレイヤ<a class=anchor href=#video-xine></a></h5><div class=paragraph><p>xine は、 再利用可能な基本ライブラリと、 プラグインで拡張できる実行可能なモジュールを提供するビデオプレイヤです。 <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xine/>multimedia/xine</a> package または port からインストールできます。</p></div><div class=paragraph><p>実用上、xine を使用するには高速なビデオカードとともに高速な CPU があるか、 またはビデオカードが XVideo 拡張に対応している必要があります。 XVideo インタフェースとともに xine ビデオプレイヤを使うのが最良です。</p></div><div class=paragraph><p>デフォルトでは、xine プレイヤは GUI 付きで起動するでしょう。 メニューを使用して特定のファイルを開くことができます。</p></div><div class=paragraph><p>xine は、 再生するファイル名を指定することで、 コマンドラインから実行することもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xine <span class=nt>-g</span> <span class=nt>-p</span> mymovie.avi</code></pre></div></div><div class=paragraph><p><a href=http://www.xine-project.org/faq>xine-project.org/faq</a> には、より多くの情報やトラブルシューティングがあります。</p></div></div><div class=sect4><h5 id=video-ports-transcode>7.4.2.3. Transcode ユーティリティ<a class=anchor href=#video-ports-transcode></a></h5><div class=paragraph><p>Transcode は、 ビデオおよびオーディオファイルを再エンコードするためのツール一式です。 Transcode を使えば、stdin/stdout ストリームインタフェースとともにコマンドラインツールを用いることで、 ビデオファイルの統合や、壊れたファイルの修復ができます。</p></div><div class=paragraph><p>FreeBSD では、Transcode は、 <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/transcode/>multimedia/transcode</a> package もしくは port からインストールできます。 多くのユーザは port からコンパイルすることを好みます。 port では、 コンパイルで有効にするサポートやコーデックを指定するコンパイルオプションのメニューを利用できるためです。 オプションを選択しないと、Transcode は、その形式をエンコード出来ないでしょう。 矢印キーとスペースバーを使って、 必要とするフォーマットを選択してください。 選択が終わったら、 <kbd>Enter</kbd> を押して、port のコンパイルとインストールを続けてください。</p></div><div class=paragraph><p>この例では、DivX ファイルを PAL MPEG-1 (PAL VCD) に変換する使用例を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% transcode <span class=nt>-i</span> input.avi <span class=nt>-V</span> <span class=nt>--export_prof</span> vcd-pal <span class=nt>-o</span> output_vcd
% mplex <span class=nt>-f</span> 1 <span class=nt>-o</span> output_vcd.mpg output_vcd.m1v output_vcd.mpa</code></pre></div></div><div class=paragraph><p>作成された MPEG ファイル、 <span class=filename>output_vcd.mpg</span> は、 MPlayer を使って再生できます。 また、<a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/vcdimager/>multimedia/vcdimager</a> および <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a> といったユーティリティを使って、 ファイルを CD メディアに書き込むことでビデオ CD も作成できます。</p></div><div class=paragraph><p><code>transcode</code> のマニュアルページに加え、<a href=http://www.transcoding.org/cgi-bin/transcode>transcoding.org/cgi-bin/transcode</a> から、更なる情報や使用例を得てください。</p></div></div></div></div><div class=sect2><h3 id=tvcard>7.5. TV カードの設定<a class=anchor href=#tvcard></a></h3><div class=paragraph><p>TV カードを使用することで、 TV 放送をコンピュータで見ることができます。 これらの多くのカードは RCA または S-video 入力端子を備えており、 FM ラジオチューナを装備したカードもあります。</p></div><div class=paragraph><p>FreeBSD は、Brooktree Bt848/849/878/879 をビデオキャプチャチップに採用した PCI TV カードに <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> ドライバで対応しています。 このドライバは、ほとんどの Pinnacle PCTV ビデオカードに対応しています。 TV カードを購入する前に、対応しているチューナの一覧について、 <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> を参照してください。</p></div><div class=sect3><h4 id=_ドライバを読み込む>7.5.1. ドライバを読み込む<a class=anchor href=#_ドライバを読み込む></a></h4><div class=paragraph><p>カードを使用するには、<a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> ドライバを読み込む必要があります。 起動時に自動的に読み込むためには、 <span class=filename>/boot/loader.conf</span> に以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>bktr_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>あるいは、カスタムカーネルに TV ビデオカードへのサポートを静的に組み込むこともできます。 この場合には、 次の行をカーネルコンフィギュレーションファイルに追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>device	 bktr
device	iicbus
device	iicbb
device	smbus</pre></div></div><div class=paragraph><p>カードコンポーネントは I2C バス経由で連結されているため、 <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> ドライバに加えてこれらのデバイスが必要になります。 編集したら新しいカーネルを構築し、インストールします。</p></div><div class=paragraph><p>チューナが適切に検出されたかどうかを確認するため、 システムを再起動してください。 起動時のメッセージに TV カードが以下のように認識されるでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</pre></div></div><div class=paragraph><p>これらのメッセージはハードウェアに応じて異なります。 必要であれば、<a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> や、 カーネルコンフィギュレーションファイルオプションで、 検知されたいくつかのパラメータを変更できます。 たとえば、チューナを Philips SECAM チューナとして検知されるようにするには、 カーネルコンフィギュレーションファイルに以下の行を追加します。</p></div><div class="literalblock programlisting"><div class=content><pre>options OVERRIDE_TUNER=6</pre></div></div><div class=paragraph><p>または、直接 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> を使用して変更します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.bt848.tuner=6</span></code></pre></div></div><div class=paragraph><p>利用可能な <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> パラメータおよびカーネルオプションについては <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> を参照してください。</p></div></div><div class=sect3><h4 id=_便利なアプリケーション>7.5.2. 便利なアプリケーション<a class=anchor href=#_便利なアプリケーション></a></h4><div class=paragraph><p>TV カードを使用するためには、 以下のアプリケーションの一つをインストールする必要があります。</p></div><div class=ulist><ul><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/fxtv/>multimedia/fxtv</a> はウィンドウ内に TV 映像を映します。 画像/音声/ビデオを取り込むこともできます。</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xawtv/>multimedia/xawtv</a> も同様の機能を持った TV アプリケーションです。</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/xmradio/>audio/xmradio</a> は TV カードに搭載された FM ラジオチューナを使用するためのアプリケーションです。</p></li></ul></div><div class=paragraph><p>他にも多くのアプリケーションが FreeBSD の Ports Collection に収録されています。</p></div></div><div class=sect3><h4 id=_トラブルシューティング>7.5.3. トラブルシューティング<a class=anchor href=#_トラブルシューティング></a></h4><div class=paragraph><p>TV カードに関する問題が起きたときには、<a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> が本当にビデオキャプチャチップおよびチューナに対応しているか、 オプションが正しく設定されているかどうかをまず確認してください。 TV カードに関するサポートや質問に関しては、 <a href=https://lists.FreeBSD.org/subscription/freebsd-multimedia>FreeBSD multimedia メーリングリスト</a> メーリングリストを参照してください。</p></div></div></div><div class=sect2><h3 id=mythtv>7.6. MythTV<a class=anchor href=#mythtv></a></h3><div class=paragraph><p>MythTV は、広く使われているオープンソースの Personal Video Recorder (PVR) アプリケーションです。 この節では、FreeBSD に MythTV をインストールし、 設定する方法について説明します。 MythTV の使用法に関するより詳細な情報については、<a href=http://www.mythtv.org/wiki/>mythtv.org/wiki</a> をご覧ください。</p></div><div class=paragraph><p>MythTV は、フロントエンドおよびバックエンドを必要とします。 これらは、同じシステム上でも、 異なるコンピュータ上でも動かすことが可能です。</p></div><div class=paragraph><p>フロントエンドについては、 <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv-frontend/>multimedia/mythtv-frontend</a> package または port から FreeBSD にインストールできます。 <a href=./#x11>X Window System</a> で説明されているように、 Xorg をインストールして設定する必要もあります。 このシステムは X-Video Motion Compensation (XvMC) に対応し、 オプションとして、Linux Infrared Remote Control (LIRC)-互換のリモートに対応したビデオカードを持っていることが理想的です。</p></div><div class=paragraph><p>FreeBSD にバックエンドとフロントエンドの両方をインストールするには、 <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv/>multimedia/mythtv</a> package または port を使ってください。 MySQL™ データベースサーバも必要となりますが、 自動的に依存でインストールされます。オプションで、 チューナカードと録音したデータを保存するためのストレージが必要です。</p></div><div class=sect3><h4 id=_ハードウェア>7.6.1. ハードウェア<a class=anchor href=#_ハードウェア></a></h4><div class=paragraph><p>MythTV は、 エンコーダやチューナなどのビデオ入力デバイスへのアクセスに Video for Linux (V4L) を用います。 FreeBSD では、USB DVB-S/C/T カードにおいて最もよく動作します。 なぜならば、このカードは、 V4L ユーザランドアプリケーションを提供する <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/webcamd/>multimedia/webcamd</a> package または port により良くサポートされているためです。 webcamd により対応している Digital Video Broadcasting (DVB) カードは、MythTV で動作するはずです。 動作することが知られているカードの一覧が <a href=http://wiki.freebsd.org/WebcamCompat>wiki.freebsd.org/WebcamCompat</a> にあります。 Hauppauge カードのドライバもまた、 <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/pvr250/>multimedia/pvr250</a> および <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/pvrxxx/>multimedia/pvrxxx</a> port として利用可能ですが、 標準的ではないドライバのインタフェースを提供しており、 0.23 より後の MythTV では動作しません。 ライセンスの制限により、package は利用できません。 そのため、これらの ports はコンパイルをしなければなりません。</p></div><div class=paragraph><p><a href=http://wiki.freebsd.org/HTPC>wiki.freebsd.org/HTPC</a> ページは、DVB ドライバのすべての一覧を提供しています。</p></div></div><div class=sect3><h4 id=_mythtv_バックエンドの設定>7.6.2. MythTV バックエンドの設定<a class=anchor href=#_mythtv_バックエンドの設定></a></h4><div class=paragraph><p>バイナリ package を使って MythTV をインストールしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mythtv</span></code></pre></div></div><div class=paragraph><p>あるいは、Ports Collection からインストールするには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/multimedia/mythtv</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>インストールが終わったら、 MythTV データベースを設定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mysql -uroot -p &lt; /usr/local/share/mythtv/database/mc.sql</span></code></pre></div></div><div class=paragraph><p>その後、バックエンドを設定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mythtv-setup</span></code></pre></div></div><div class=paragraph><p>最後にバックエンドを起動してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc mythbackend_enable=yes</span>
<span class=c># service mythbackend start</span></code></pre></div></div></div></div><div class=sect2><h3 id=scanners>7.7. 画像スキャナ<a class=anchor href=#scanners></a></h3><div class=paragraph><p>FreeBSD では、画像スキャナに対するアクセスは SANE (Scanner Access Now Easy) によって実現されており、 FreeBSD の Ports Collection で提供されています。 SANE はスキャナのハードウェアにアクセスするために FreeBSD デバイスドライバを使用します。</p></div><div class=paragraph><p>FreeBSD は SCSI 接続および USB 接続のスキャナのどちらにも対応しています。 スキャナのインタフェースに依存して、異なるドライバが必要となります。 設定を始める前に、 SANE がスキャナに対応していることを確認してください。 対応しているスキャナに関してのより詳細な情報については、<a href=http://www.sane-project.org/sane-supported-devices.html>http://www.sane-project.org/sane-supported-devices.html</a> をご覧ください。</p></div><div class=paragraph><p>この節では、FreeBSD がどのようにしてスキャナを認識するかについて説明します。 その後、FreeBSD システム上で SANE を設定して使用する方法の概要について説明します。</p></div><div class=sect3><h4 id=scanners-kernel-usb>7.7.1. スキャナの確認<a class=anchor href=#scanners-kernel-usb></a></h4><div class=paragraph><p><span class=filename>GENERIC</span> カーネルには USB スキャナに対応するためのデバイスドライバが搭載されています。 カスタムカーネルを使用する際には、 以下の行がカーネルコンフィグレーションファイルにあることを確認してください。</p></div><div class="literalblock programlisting"><div class=content><pre>device usb
device uhci
device ohci
device ehci
device xhci</pre></div></div><div class=paragraph><p>USB スキャナが認識されたかを確認するには、 スキャナを接続して、<code>dmesg</code> を利用し、 システムメッセージバッファで、 スキャナが認識されているかどうかを確認してください。 認識されていたら、以下のようなメッセージが表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ugen0.2: &lt;EPSON&gt; at usbus0</code></pre></div></div><div class=paragraph><p>この例では、EPSON Perfection® 1650 USB スキャナが <span class=filename>/dev/ugen0.2</span> 上で認識されています。</p></div><div class=paragraph><p>スキャナのインタフェースが SCSI であれば、 どの SCSI コントローラボードを使用するかを知ることが重要です。 使用する SCSI チップセットによって、 カスタムカーネルコンフィグレーションファイルを調整する必要があります。 <span class=filename>GENERIC</span> カーネルは、 一般に使用される SCSI コントローラのほとんどに対応しています。 <span class=filename>/usr/src/sys/conf/NOTES</span> ファイルを読んで、 適切な行をカーネルコンフィグレーションファイルに追加してください。 また、SCSI アダプタドライバに加えて、 以下の行をカスタムカーネルコンフィグレーションファイルに記述する必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus
device pass</pre></div></div><div class=paragraph><p>デバイスがメッセージバッファに出力されていることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</code></pre></div></div><div class=paragraph><p>システムを起動する際にスキャナの電源を入れてなければ、 <code>camcontrol</code> を使用して SCSI バスをスキャンし、 以下のように手動でデバイスを検出させることもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol rescan all</span>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</code></pre></div></div><div class=paragraph><p>すると、スキャナは SCSI デバイスの一覧に現れるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 <span class=o>(</span>pass0,da0<span class=o>)</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 <span class=o>(</span>pass1,da1<span class=o>)</span>
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 <span class=o>(</span>pass3<span class=o>)</span>
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 <span class=o>(</span>pass2,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>FreeBSD における SCSI デバイスについての詳細は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=scsi&amp;sektion=4&amp;format=html">scsi(4)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a> をご覧ください。</p></div></div><div class=sect3><h4 id=_sane_の設定>7.7.2. SANE の設定<a class=anchor href=#_sane_の設定></a></h4><div class=paragraph><p>SANE システムは、 バックエンド (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a>) を経由してスキャナに対するアクセスを提供します。 バックエンドが対応している画像スキャナについては、<a href=http://www.sane-project.org/sane-supported-devices.html>http://www.sane-project.org/sane-supported-devices.html</a> を参照してください。 グラフィカルなスキャニングインタフェースは、 Kooka (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/kooka/>graphics/kooka</a>) または XSane (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xsane/>graphics/xsane</a>) といったサードパーティ製のアプリケーションによって提供されています。 SANE のバックエンドは、 スキャナを試すには十分です。</p></div><div class=paragraph><p>バイナリ package から、バックエンドをインストールするには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install sane-backends</span></code></pre></div></div><div class=paragraph><p>あるいは、Ports Collection からインストールするには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/sane-backends</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a> port または package をインストールしたら、 <code>sane-find-scanner</code> コマンドを使用して、 SANE システムで検出されているスキャナを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sane-find-scanner -q</span>
found SCSI scanner <span class=s2>&#34;AGFA SNAPSCAN 600 1.10&#34;</span> at /dev/pass3</code></pre></div></div><div class=paragraph><p>この出力から、 スキャナインタフェースの種類と システムに接続されているスキャナが使用するデバイスノードがわかります。 ベンダ名や製品のモデル名は表示されないかも知れません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>いくつかの USB スキャナではファームウェアを読み込む必要がある場合があります。 詳細については、sane-find-scanner(1) および sane(7) を参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>次に、スキャナがフロントエンドで認識されるか調べてください。 SANE のバックエンドには <code>scanimage</code> が付属します。 このコマンドを使用すると、 デバイスの一覧を表示したり画像を取得することができます。 スキャナデバイスの一覧を表示するには、 <code>-L</code> オプションを使ってください。 以下の最初の例は、SCSI スキャナ用のもので、 次の例は、USB スキャナ用のものです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=sb>`</span>snapscan:/dev/pass3<span class=s1>&#39; is a AGFA SNAPSCAN 600 flatbed scanner
# scanimage -L
device &#39;</span>epson2:libusb:/dev/usb:/dev/ugen0.2<span class=s1>&#39; is a Epson GT-8200 flatbed scanner</span></code></pre></div></div><div class=paragraph><p>2 番目の出力において、 <code>epson2</code> がバックエンド名で、 <code>libusb:000:002</code> は <code>/dev/ugen0.2</code> を意味し、 スキャナが使用するデバイスノードです。</p></div><div class=paragraph><p><code>scanimage</code> がスキャナの認識に失敗した場合には、 以下のようなメッセージが表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged <span class=k>in</span>, turned on and detected by the
sane-find-scanner tool <span class=o>(</span><span class=k>if </span>appropriate<span class=o>)</span><span class=nb>.</span> Please <span class=nb>read </span>the documentation
which came with this software <span class=o>(</span>README, FAQ, manpages<span class=o>)</span>.</code></pre></div></div><div class=paragraph><p>このような場合には、<span class=filename>/usr/local/etc/sane.d/</span> にあるバックエンドの設定ファイルを編集して、 使用するスキャナデバイスを設定してください。 例えば、認識されなかったスキャナのモデルが、 EPSON Perfection® 1650 で、<code>epson2</code> バックエンドを使っているのであれば、 <span class=filename>/usr/local/etc/sane.d/epson2.conf</span> を編集してください。 編集作業を行う際には、 使用するインタフェースとデバイスノードを指定する行を追加します。 この例では、以下の行を追加します。</p></div><div class="literalblock programlisting"><div class=content><pre>usb /dev/ugen0.2</pre></div></div><div class=paragraph><p>編集を保存し、 適切なバックエンド名とデバイスノードでスキャナが認識されたかどうかを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=s1>&#39;epson2:libusb:000:002&#39;</span> is a Epson GT-8200 flatbed scanner</code></pre></div></div><div class=paragraph><p><code>scanimage -L</code> を実行してスキャナが認識されたことがわかれば、設定は終了です。 スキャナを使用する準備ができました。</p></div><div class=paragraph><p><code>scanimage</code> を使用してコマンドラインから画像を取得することができますが、 GUI を使用して画像を取得できることが望ましいでしょう。 Kooka や xsane といったアプリケーションは、 広く使われているスキャニングフロントエンドです。 これらには、さまざまなスキャニングモード、 色補正、バッチスキャンなど先進的な機能があります。 XSane は、GIMP のプラグインとして使用することもできます。</p></div></div><div class=sect3><h4 id=_スキャナの許可属性>7.7.3. スキャナの許可属性<a class=anchor href=#_スキャナの許可属性></a></h4><div class=paragraph><p>スキャナにアクセスするには、 ユーザはスキャナが使用するデバイスノードへの読み込み権限と書き込み権限が必要です。 今回の例では、USB スキャナは <span class=filename>/dev/ugen0.2</span> デバイスノードを使用しています。 このデバイスノードは、 <span class=filename>/dev/usb/0.2.0</span> へのシンボリックリンクです シンボリックリンクとデバイスノードは、 それぞれ <code>wheel</code> および <code>operator</code> グループが所有しています。 ユーザをこれらのグループに加えると、 スキャナを使用できるようになりますが、 ユーザを <code>wheel</code> に追加することは、セキュリティの観点からお勧めできません。 良い方法は、 スキャナデバイスにアクセスできるグループを作成することです。</p></div><div class=paragraph><p>この例では、<code><em>usb</em></code> という名前のグループを作成します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd usb</span></code></pre></div></div><div class=paragraph><p>その後、シンボリックリンク <span class=filename>/dev/ugen0.2</span> および、<span class=filename>/dev/usb/0.2.0</span> デバイスノードに対して、 <code>usb</code> グループが利用できるように書き込みの許可属性 <code>0660</code> または <code>0664</code> を設定してください。 <span class=filename>/etc/devfs.rules</span> に次の行を追加すれば設定できます。</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>デバイスを追加したり外すことにより、 デバイスノードが変わることがあります。 そのため、すべての USB デバイスにアクセスしたい場合には、 代わりに以下のルールセットを使ってください。</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path &#39;ugen*&#39; mode 0660 group usb
add path &#39;usb/*&#39; mode 0666 group usb</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>このファイルの詳細については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> を参照してください。</p></div><div class=paragraph><p>つぎに、/etc/rc.conf でルールセットを有効にしてください。</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;system&#34;</pre></div></div><div class=paragraph><p>そして、<a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> システムを再起動してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div><div class=paragraph><p>最後に、スキャナを利用するユーザを <code><em>usb</em></code> グループに追加してスキャナを利用できるようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod usb -m joe</span></code></pre></div></div><div class=paragraph><p>詳細については、<a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> をご覧ください。</p></div></div></div></div></div><div class=sect1><h2 id=kernelconfig>Chapter 8. FreeBSD カーネルのコンフィグレーション<a class=anchor href=#kernelconfig></a></h2><div class=sectionbody><div class=sect2><h3 id=kernelconfig-synopsis>8.1. この章では<a class=anchor href=#kernelconfig-synopsis></a></h3><div class=paragraph><p>カーネルは FreeBSD オペレーティングシステムの中核をなすものです。 カーネルは、メモリ管理、セキュリティ制御の強制、ネットワーク、 ディスクアクセスなどを担っています。 FreeBSD の大部分は動的に構成することができるようになっていますが、 まだ、時にはカスタムカーネルを設定してコンパイルする必要があります。</p></div><div class=paragraph><p>この章では、以下のことを扱っています。</p></div><div class=ulist><ul><li><p>いつカスタムカーネルの構築が必要になるか。</p></li><li><p>ハードウェア一覧の作成方法。</p></li><li><p>カーネルコンフィグレーションファイルのカスタマイズの方法。</p></li><li><p>カーネルコンフィグレーションファイルから新しいカーネルを構築する方法。</p></li><li><p>新しいカーネルのインストール方法。</p></li><li><p>うまく行かないときの問題解決法。</p></li></ul></div><div class=paragraph><p>この章で表示されているすべてのコマンドは、<code>root</code> 権限で実行する必要があります。</p></div></div><div class=sect2><h3 id=kernelconfig-custom-kernel>8.2. なぜカスタムカーネルを作るか?<a class=anchor href=#kernelconfig-custom-kernel></a></h3><div class=paragraph><p>伝統的に、FreeBSD はモノリシック (monolithic) カーネルを使っていました。 このカーネルは、単一の巨大なプログラムで、 扱えるデバイスは固定されていて、 カーネルの振る舞いを変えたければ構築してコンピュータを再起動し、 新しいカーネルを動かさなれければなりませんでした。</p></div><div class=paragraph><p>今日では、FreeBSD カーネルのかなりの機能はモジュールに含まれるようになり、 必要に応じて動的にカーネルに組み込んだり外したりできるようになりました。 この移行により、 動作しているカーネルが新しいハードウェアに迅速に対応したり、 カーネルに新たな機能を取り入れられるようになります。 このようなカーネルは、モジュラ (modular) カーネルと呼ばれます。</p></div><div class=paragraph><p>しかしながら、 いまだにいくらかは静的にカーネルを構成する必要があります。 機能がカーネルとあまりに密接に結びついているため、 動的に組み込むことができない場合があるためです。 環境によっては、セキュリティの観点から、 カーネルモジュールを読み込んだり外すことができず、 必要となる機能を静的にカーネルにコンパイルしなければならない場合もあります。</p></div><div class=paragraph><p>システムに合わせたカーネルを構築することは、多くの場合、 高度な知識を持つ BSD ユーザが避けて通ることのできない通過儀礼です。 この作業は多くの時間を必要としますが、FreeBSD システムに利益をもたらします。 広範囲のハードウェアをサポートしなければならない <span class=filename>GENERIC</span> カーネルとは異なり、カスタムカーネルは、 使用しているコンピュータのハードウェアのみをサポートするように、 必要のない機能を省くことができます。これは、 次にあげるような利益をもたらします。</p></div><div class=ulist><ul><li><p>素早く起動します。 カーネルはシステム上にあるハードウェアしか検出しないので、 システムの起動にかかる時間を短くできます。</p></li><li><p>メモリの消費量を減らすことができます。 システムに合わせたカーネルは、 使用しない機能やデバイスドライバを含まないので、 大抵 <span class=filename>GENERIC</span> カーネルより少ないメモリしか消費しません。 カーネルコードは常に物理メモリ上に存在し、 アプリケーションはその容量分のメモリを使用できないので、 これは重要なことです。 したがって、メモリが少ないシステムでは、 カーネルの再構築は重要です。</p></li><li><p>追加のハードウェアをサポートします。 カスタムカーネルは、<span class=filename>GENERIC</span> カーネルに存在しないデバイスのサポートを追加することができます。</p></li></ul></div><div class=paragraph><p>カスタムカーネルを構築する前に、再構築する理由を考えてください。 ある特定のハードウェアに対応する必要がある場合に、 そのハードウェアに対応するためのモジュールがすでに用意されていることがあります。</p></div><div class=paragraph><p>カーネルモジュールは <span class=filename>/boot/kernel</span> にあります。
モジュールによっては <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> により、すでに実行中のカーネルに動的に読み込まれています。
ほとんどのカーネルドライバには、読み込み可能なモジュールやマニュアルページが用意されています。
たとえば、<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> ワイヤレスネットワークドライバのマニュアルページには以下のような記述があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Alternatively, to load the driver as a module at boot <span class=nb>time</span>, place the
following line <span class=k>in </span>loader.conf<span class=o>(</span>5<span class=o>)</span>:

    <span class=nv>if_ath_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p><span class=filename>/boot/loader.conf</span> に <code>if_ath_load="YES"</code> を追加すると、 起動時にモジュールが読み込まれるようになります。</p></div><div class=paragraph><p>対応するモジュールが <span class=filename>/boot/kernel</span> に存在しないこともあります。 特定のサブシステムでは、ほとんど多くの場合存在しません。</p></div></div><div class=sect2><h3 id=kernelconfig-devices>8.3. システムのハードウェアについて知る<a class=anchor href=#kernelconfig-devices></a></h3><div class=paragraph><p>カーネルコンフィグレーションファイルの編集を始める前に、 コンピュータのハードウェア一覧を作成すると良いでしょう。 デュアルブートシステムでは、 現在インストールされている別のオペレーティングシステムの設定を調べることで、 一覧を作成できます。 たとえば、Microsoft® の デバイスマネージャ は、インストールされているデバイスに関する情報を持っています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Microsoft® Windows® のバージョンによっては、 システム アイコンを使って、 デバイスマネージャ にアクセスできます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>インストールされているオペレーティングシステムが FreeBSD だけであれば、<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> を使い、 起動時に検出されたハードウェアの一覧を調べてください。 FreeBSD のほとんどのデバイスドライバにはマニュアルページが用意され、 対応しているハードウェアの一覧を提供しています。 たとえば、以下の行は、<a href="https://man.freebsd.org/cgi/man.cgi?query=psm&amp;sektion=4&amp;format=html">psm(4)</a> ドライバがマウスを検出したことを示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: <span class=o>[</span>GIANT-LOCKED]
psm0: <span class=o>[</span>ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</code></pre></div></div><div class=paragraph><p>このハードウェアはシステムに存在するので、 カスタムカーネルコンフィグレーションファイルからこのドライバを外さないでください。</p></div><div class=paragraph><p><code>dmesg</code> が起動時の検出結果を表示しない場合には、 かわりに <span class=filename>/var/run/dmesg.boot</span> で出力を確認してください。</p></div><div class=paragraph><p>ハードウェアを見つけるためのもうひとつのツールは、 より冗長な出力を行う <a href="https://man.freebsd.org/cgi/man.cgi?query=pciconf&amp;sektion=8&amp;format=html">pciconf(8)</a> です。 たとえば、以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pciconf <span class=nt>-lv</span>
ath0@pci0:3:0:0:        <span class=nv>class</span><span class=o>=</span>0x020000 <span class=nv>card</span><span class=o>=</span>0x058a1014 <span class=nv>chip</span><span class=o>=</span>0x1014168c <span class=nv>rev</span><span class=o>=</span>0x01 <span class=nv>hdr</span><span class=o>=</span>0x00
    vendor     <span class=o>=</span> <span class=s1>&#39;Atheros Communications Inc.&#39;</span>
    device     <span class=o>=</span> <span class=s1>&#39;AR5212 Atheros AR5212 802.11abg wireless&#39;</span>
    class      <span class=o>=</span> network
    subclass   <span class=o>=</span> ethernet</code></pre></div></div><div class=paragraph><p>この出力は、<span class=filename>ath</span> ドライバがワイヤレスイーサネットデバイスにあることを示しています。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> を <code>-k</code> フラグで実行すると、 有用な情報を得ることができます。たとえば、 ある特定のデバイスブランドや名前を含むマニュアルページの一覧を表示するには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># man -k Atheros</span>
ath<span class=o>(</span>4<span class=o>)</span>                   - Atheros IEEE 802.11 wireless network driver
ath_hal<span class=o>(</span>4<span class=o>)</span>               - Atheros Hardware Access Layer <span class=o>(</span>HAL<span class=o>)</span></code></pre></div></div><div class=paragraph><p>ハードウェアの一覧を作成したら、 この一覧を利用して、 カスタムカーネルのコンフィグレーションファイルを編集している時に、 インストールされているハードウェアのドライバが削除されていないことを確認してください。</p></div></div><div class=sect2><h3 id=kernelconfig-config>8.4. コンフィグレーションファイル<a class=anchor href=#kernelconfig-config></a></h3><div class=paragraph><p>カスタムカーネルのコンフィグレーションファイルを作成し、 カスタムカーネルを構築するには、 FreeBSD の全ソースツリーがまずインストールされている必要があります。</p></div><div class=paragraph><p>もし <span class=filename>/usr/src/</span> が存在していなかったり、空であれば、 カーネルのソースはインストールされていません。
<a href=./#git>「Git の利用」</a> で説明した Git を使ってソースをインストールしてください。</p></div><div class=paragraph><p>ソースをインストールしたら、 <span class=filename>/usr/src/sys</span> を確認して下さい。 このディレクトリには、いくつものサブディレクトリがあります。 その中には、サポートされている各アーキテクチャ <span class=filename>amd64</span>, <span class=filename>i386</span>, <span class=filename>powerpc</span> および <span class=filename>sparc64</span> のサブディレクトリがあります。 各アーキテクチャのディレクトリ内部にあるファイルはすべてそのアーキテクチャでのみ使用されます。 残りのコードは、アーキテクチャに依存しない、 すべてのプラットフォームで共有されるコードです。 サポートされている各アーキテクチャには、 <span class=filename>conf</span> サブディレクトリがあり、 そのアーキテクチャ用の <span class=filename>GENERIC</span> カーネルコンフィグレーションファイルが用意されています。</p></div><div class=paragraph><p>この <span class=filename>GENERIC</span> は編集しないでください。 かわりに、このファイルを別名でコピーし、コピーを編集してください。 慣習として、この名前はすべて大文字でつづられます。もし、 いくつかの異なるハードウェアの FreeBSD マシンを扱うなら、 この名前にホスト名を含めるとよいでしょう。ここでは、例として <span class=filename>MYKERNEL</span> という名前の <code>amd64</code> アーキテクチャ用の <span class=filename>GENERIC</span> コンフィグレーションファイルのコピーを作成します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># cp GENERIC MYKERNEL</span></code></pre></div></div><div class=paragraph><p>これで、<span class=filename>MYKERNEL</span> を ASCII テキストエディタで編集できます。 初心者に対してより簡単なエディタである ee も FreeBSD とともにインストールされていますが、 デフォルトのエディタは vi です。</p></div><div class=paragraph><p>コンフィグレーションファイルのフォーマットはシンプルです。
各行はデバイスやサブシステム、引数、または簡単な説明を含んでいます。
<code>#</code> に続くテキストはすべてコメントとして扱われ、無視されます。
カーネルからデバイスもしくはサブシステムのサポートを外すには、対応する行の最初に <code>#</code> を入れてください。
理解していない行に対しては、<code>#</code> を追加したり削除しないでください。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>デバイスやオプションのサポートを外すことは簡単で、 その結果、カーネルを壊すことがあります。 たとえば <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a> ドライバをカーネルコンフィグレーションファイルから除くと、 ATA ディスクドライバを用いているシステムは起動しません。 確信が持てないものについては、 カーネルにサポートを残したままにしてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>このファイルで与えられる説明の他に、 そのアーキテクチャの <span class=filename>GENERIC</span> と同じディレクトリにある <span class=filename>NOTES</span> にも説明があります。 アーキテクチャに依存しないオプションについては、 <span class=filename>/usr/src/sys/conf/NOTES</span> をご覧ください。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>カーネルコンフィグレーションファイルの編集を終えたら、 ファイルのバックアップを <span class=filename>/usr/src</span> 以外の場所に保存してください。</p></div><div class=paragraph><p>または、カーネルコンフィグレーションファイルは他の場所において、 シンボリックリンクを張る方法もあります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># mkdir /root/kernels</span>
<span class=c># cp GENERIC /root/kernels/MYKERNEL</span>
<span class=c># ln -s /root/kernels/MYKERNEL</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>コンフィグレーションファイルでは <code>include</code> ディレクティブを利用できます。 コンフィグレーションファイルに他のファイルを取り込むことができるので、 すでに存在するファイルに対する小さな変更の管理が簡単にできます。 オプションやドライバの追加が少しだけの場合には、 以下の例のように <span class=filename>GENERIC</span> からの差分による管理が可能になります。</p></div><div class="literalblock programlisting"><div class=content><pre>include GENERIC
ident MYKERNEL

options         IPFIREWALL
options         DUMMYNET
options         IPFIREWALL_DEFAULT_TO_ACCEPT
options         IPDIVERT</pre></div></div><div class=paragraph><p>この方法では、ローカルのコンフィグレーションファイルには、 ローカルにある <span class=filename>GENERIC</span> カーネルとの差分が記述されています。 アップグレードが行われると、 <span class=filename>GENERIC</span> に追加された新しい機能は、 (<code>nooptions</code> や <code>nodevice</code> によって外されない限り) ローカルのカーネルにも反映されます。 コンフィグレーションの構成要素に関する包括的な一覧と説明は <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a> にあります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>利用可能なすべてのオプションを含むファイルを構築するには、 以下のコマンドを <code>root</code> 権限で実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/arch/conf &amp;&amp; make LINT</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kernelconfig-building>8.5. カスタムカーネルの構築とインストール<a class=anchor href=#kernelconfig-building></a></h3><div class=paragraph><p>カスタムコンフィグレーションファイルを編集して保存したら、 カーネルのソースコードを以下の手順でコンパイルしてください。</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: カーネルの構築</strong></p></div><div class=paragraph><p>+
. 以下のディレクトリに移動してください。</p></div><div class=paragraph><p>+</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div><div class=paragraph><p>+
. カスタムコンフィグレーションファイルの名前を指定して新しいカーネルをコンパイルします。</p></div><div class=paragraph><p>+</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=MYKERNEL</span></code></pre></div></div><div class=paragraph><p>+
. 指定したカーネルコンフィグレーションファイルでコンパイルされた新しいカーネルをインストールします。 以下のコマンドは、新しいカーネルを <span class=filename>/boot/kernel/kernel</span> に、 今までのカーネルを <span class=filename>/boot/kernel.old/kernel</span> という名前で保存します。</p></div><div class=paragraph><p>+</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make installkernel KERNCONF=MYKERNEL</span></code></pre></div></div><div class=paragraph><p>+
. 新しいカーネルを使うために、 システムをシャットダウンして再起動してください。 うまく行かない場合は、<a href=#kernelconfig-noboot>カーネルが起動しない</a> を参照してください。</p></div></div></div><div class=paragraph><p>デフォルトでは、カスタムカーネルを構築すると、 すべてのカーネルモジュールが再構築されます。 カーネルのアップデートをより早く行いたい、または、 カスタムモジュールのみを構築したいといった場合は、 カーネルの構築を開始する前に、以下のように <span class=filename>/etc/make.conf</span> を編集してください。</p></div><div class=paragraph><p>例として、以下の変数は、 デフォルトのすべてのモジュールを構築する設定を変更し、 構築するモジュール一覧を指定します。</p></div><div class="literalblock programlisting"><div class=content><pre>MODULES_OVERRIDE = linux acpi</pre></div></div><div class=paragraph><p>また、以下の変数は、構築を行わないモジュールを指定します。</p></div><div class="literalblock programlisting"><div class=content><pre>WITHOUT_MODULES = linux acpi sound</pre></div></div><div class=paragraph><p>他の変数については、<a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a> を参照してください。</p></div></div><div class=sect2><h3 id=kernelconfig-trouble>8.6. 問題が起きた場合には<a class=anchor href=#kernelconfig-trouble></a></h3><div class=paragraph><p>カスタムカーネルを作る際に起こりうるトラブルは、 次の 4 種類に分けられます。</p></div><div class=dlist><dl><dt class=hdlist1><code>config</code> コマンドの失敗</dt><dd><p><code>config</code> で失敗した時には、 トラブルの起きた行番号が出力されます。 たとえば、次のように出力された場合には、 17 行目が正しく入力されているかどうか、 <span class=filename>GENERIC</span> や <span class=filename>NOTES</span> と比較して修正してください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>config: line 17: syntax error</code></pre></div></div></dd><dt class=hdlist1><code>make</code> コマンドの失敗</dt><dd><p><code>make</code> が失敗した場合には、 通常、カーネルコンフィグレーションファイルにおいて、 <code>config</code> がとらえられなかったような間違いをしています。 コンフィグレーションファイルを見直してください。 それでも問題を解決することができなければ、 <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>FreeBSD general questions メーリングリスト</a> へカーネルコンフィグレーションファイルを添付して送ってください。</p></dd></dl></div><div id=kernelconfig-noboot class=dlist><dl><dt class=hdlist1>カーネルが起動しない</dt><dd><p>新しいカーネルが起動しなかったり、 デバイスの認識をしない場合でもあわてないでください! さいわい、FreeBSD には利用できないカーネルから復帰する洗練されたメカニズムがあります。 FreeBSD のブートローダで起動したいカーネルを選択してください。 システムの起動メニューが表示されている時に、 "Escape to a loader prompt" オプションを選択するとアクセスできます。 プロンプトで <code>boot <em>kernel.old</em></code> か他の正常に起動するカーネルを入力してください。</p><div class=paragraph><p>問題のないカーネルで起動した後、 コンフィグレー ションファイルを調べ、 再び構築を試みてください。 <span class=filename>/var/log/messages</span> にはすべての成功した起動時のカーネルメッセージの記録があり、 これは問題を解決するための助けになる情報の一つでしょう。また、 <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> は現在の起動時のカーネルメッセージを出力します。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>カーネルのトラブルシューティングを行う時には、 <span class=filename>GENERIC</span> といった正常に起動するカーネルのコピーを保存するようにしてください。
<em>kernel.old</em> は新しいカーネルをインストールする時に、その一つ前にインストールした、うまく動かないかもしれないカーネルで上書きされてしまうため、起動するカーネルを保存しておくことは重要です。
できる限り早く以下のようにして、正しく起動するカーネルを含むディレクトリ名に変更してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /boot/kernel /boot/kernel.bad</span>
<span class=c># mv /boot/kernel.good /boot/kernel</span></code></pre></div></div></td></tr></tbody></table></div></dd><dt class=hdlist1>カーネルは動きますが <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> は動きません!</dt><dd><p>システムユーティリティの構築されたバージョンと異るバージョンのカーネルをインストールした場合、 たとえば -CURRENT のソースから構築したカーネルを -RELEASE システム上にインストールするような場合には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=vmstat&amp;sektion=8&amp;format=html">vmstat(8)</a> のような多くのシステムステータスコマンドは動かなくなります。 修正するには、カーネルと同じバージョンのソースツリーで <a href=./#makeworld>world を再構築し、インストール</a> してください。 カーネルとそれ以外で異なるバージョンを組み合わせてオペレーティングシステムを使用することは推奨されていません。</p></dd></dl></div></div></div></div><div class=sect1><h2 id=printing>Chapter 9. プリンタの利用<a class=anchor href=#printing></a></h2><div class=sectionbody><div class=sect2><h3 id=printing-synopsis>9.1. この章では<a class=anchor href=#printing-synopsis></a></h3><div class=paragraph><p>FreeBSD は古いインパクトプリンタから最新のレーザープリンタまで幅広いプリンタが利用でき、 実行しているアプリケーションから高品質な印刷出力が行えます。</p></div><div class=paragraph><p>FreeBSD はネットワーク上のプリンタサーバとして動作するように設定することもできます。 この機能は、他の FreeBSD コンピュータや、Windows® や Mac OS® ホストから印刷ジョブを受け取ることができます。 FreeBSD は印刷ジョブを 1 つずつ処理することを保証します。 また、どのユーザやマシンが最も多く印刷しているかの統計を取り、 どの印刷物が誰の物か表示する "バナー" ページの作成などを行うことができます。</p></div><div class=paragraph><p>この章を読めば以下のことがわかります。</p></div><div class=ulist><ul><li><p>FreeBSD プリントスプーラの設定方法。</p></li><li><p>入力ドキュメントをプリンタが扱える印刷フォーマットへ変換するなどといった、 特別な印刷ジョブを別に取り扱うための印刷フィルタのインストール方法。</p></li><li><p>印刷物へのヘッダやバナーの適用方法。</p></li><li><p>他のコンピュータに接続されたプリンタで印刷する方法。</p></li><li><p>ネットワークに直接接続されたプリンタで印刷する方法。</p></li><li><p>印刷ジョブの上限サイズや特定のユーザからの印刷拒否といった、 プリンタの制限の制御方法。</p></li><li><p>印刷の統計とプリンタの使用状況の取得方法。</p></li><li><p>印刷問題のトラブルシューティング方法。</p></li></ul></div><div class=paragraph><p>この章を読み始める前に以下を済ませておいてください。</p></div><div class=ulist><ul><li><p>新しいカーネルの設定とインストール方法について理解すること (<a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a>)。</p></li></ul></div></div><div class=sect2><h3 id=printing-intro-spooler>9.2. はじめに<a class=anchor href=#printing-intro-spooler></a></h3><div class=paragraph><p>FreeBSD でプリンタを使うために、それらを LPD スプーリングシステム、 または単に LPD としても知られる Berkeley ラインプリンタスプーリングシステムで動作するように設定できます。 これは FreeBSD での標準的なプリンタ制御システムです。 この章では、LPD を紹介し、 その設定方法について説明します。</p></div><div class=paragraph><p>あなたがすでに LPD やその他のプリンタスプーリングシステムに詳しいのなら、 <a href=#printing-intro-setup>基本的な設定</a> まで読み飛ばしてもかまいません。</p></div><div class=paragraph><p>LPD はホストのプリンタに関するあらゆることを制御します。 ここで言う制御としては、次のことがあげられます。</p></div><div class=ulist><ul><li><p>ホストに接続されたプリンタ、 あるいはネットワーク上の他ホストに接続されたプリンタに対するアクセス制御を行ないます。</p></li><li><p>ファイルをプリントする要求に対して許可を与えます。 この要求は特に<em>ジョブ</em>と呼ばれています。</p></li><li><p>各々のプリンタの<em>キュー</em>を管理することにより、 複数のユーザがあるプリンタに対して同時にアクセスすることを防ぎます。</p></li><li><p><em>ヘッダページ</em> (<em>バナー</em>または <em>バースト</em>ページとしても知られています) をプリントすることができます。 これにより、 プリントアウトの山の中から自分がプリントしたジョブを見つけやすくなります。</p></li><li><p>シリアルポートに接続したプリンタ用に通信パラメータを管理します。</p></li><li><p>ネットワーク経由で他のホスト上の LPD スプーラにジョブを送ることができます。</p></li><li><p>様々なプリンタ言語やプリンタの能力に応じてジョブの形式を整えるため、 特別なフィルタを起動することができます。</p></li><li><p>プリンタの使用に対して課金を行なうことができます。</p></li></ul></div><div class=paragraph><p>設定ファイル (<span class=filename>/etc/printcap</span>) を通して、専用のフィルタプログラムを用いることにより、 多種多様なプリンタ機器に対して、上述の機能の全部または一部を LPD システムに行なわせることができます。</p></div><div class=sect3><h4 id=printing-intro-why>9.2.1. どうしてスプーラを使うべきなのか<a class=anchor href=#printing-intro-why></a></h4><div class=paragraph><p>あなたのシステムを利用するのがあなた一人だけだとしても、 スプーラは有用ですし、使用すべきです。その理由は以下のとおりです。</p></div><div class=ulist><ul><li><p>LPD はジョブをバックグラウンドで処理します。 データがプリンタに送信されるまで待つ必要がなくなります。</p></li><li><p>LPD ではジョブをフィルタを通してプリントすることが簡単にできます。 これにより、印刷物のヘッダに時刻や日付を入れたり、 特別なファイル形式 (TeX の DVI ファイルなど) をプリンタが処理できる形式に変更することができ、 これらの作業を手動で行なう必要がなくなります。</p></li><li><p>プリント処理を行なうフリー、 または商用のプログラムのほとんどは、 システムのスプーラとやりとりするように作られています。 スプーリングシステムをセットアップすることで、 今後加えるかもしれない、あるいは、 すでに持っている別のソフトウェアをより簡単にサポートすることができるでしょう。</p></li></ul></div></div></div><div class=sect2><h3 id=printing-intro-setup>9.3. 基本的な設定<a class=anchor href=#printing-intro-setup></a></h3><div class=paragraph><p>LPD スプーリングシステムを用いてプリンタを使用するためには、 プリンタ機器と LPD 用ソフトウェアの両方を準備する必要があります。 本文書では次の二段階のレベルに分けて説明をします。</p></div><div class=ulist><ul><li><p>プリンタを接続する方法、 プリンタにどのように通信するかを LPD に指示する方法や、 プレインテキストをプリンタで印字する方法については、 <a href=#printing-simple>プリンタの簡単な設定</a>をご覧ください。</p></li><li><p>様々な形式のファイルを印字する方法、 ヘッダページを印字する方法、 ネットワーク経由でプリンタに印字する方法、 プリンタを制御する方法、 プリンタの使用に対する課金を行なう方法については<a href=#printing-advanced>プリンタ設定上級編</a>をご覧ください。</p></li></ul></div><div class=sect3><h4 id=printing-simple>9.3.1. プリンタ設定導入編<a class=anchor href=#printing-simple></a></h4><div class=paragraph><p>この節では、プリンタ機器やプリンタを使用するための LPD 用ソフトウェアを設定する方法について述べます。 この節の概要は次のとおりです。</p></div><div class=ulist><ul><li><p><a href=#printing-hardware>プリンタ機器の設定</a>では、 プリンタをコンピュータに接続するためのヒントがいくつか書かれています。</p></li><li><p><a href=#printing-software>ソフトウェアの設定</a>では、 LPD のスプーラ設定ファイル (<span class=filename>/etc/printcap</span>) の設定方法について書かれています。</p></li></ul></div><div class=paragraph><p>データをプリンタに送るのにコンピュータのローカルインタフェースではなく、 ネットワークプロトコルを使用する場合は、 <a href=#printing-advanced-network-net-if>ネットワークにおけるデータストリームインタフェースを持つプリンタ</a>をご覧ください。</p></div><div class=paragraph><p>この節のタイトルは "プリンタ設定導入編" ですが、 実際の設定はかなり複雑です。 プリンタをコンピュータに接続し、 LPD スプーラを起動させることは一番困難な作業です。 ヘッダページを出力させたり課金したりするオプションの設定は、 一度プリンタがうまく動くようになればとても簡単です。</p></div><div class=sect4><h5 id=printing-hardware>9.3.1.1. プリンタ機器の設定<a class=anchor href=#printing-hardware></a></h5><div class=paragraph><p>この節では、プリンタに PC を接続するための様々な方法について説明しています。 ここでは、ポートやケーブルの種類、 FreeBSD がプリンタとの通信に必要なカーネルコンフィグレーションについても言及しています。</p></div><div class=paragraph><p>もしプリンタが既に接続されていて、 他のオペレーティングシステム上でプリンタからの印字に成功している場合は、 <a href=#printing-software>ソフトウェアの設定</a>まで読み飛ばすことが多分できるでしょう。</p></div><div class=sect5><h6 id=printing-ports>9.3.1.1.1. ポートとケーブル<a class=anchor href=#printing-ports></a></h6><div class=paragraph><p>今日 PC 用に売られているプリンタには通常、 次の 3 つのインタフェースのうち、どれか 1 つ以上がついてきます。</p></div><div class=ulist><ul><li><p><em>シリアル</em>インタフェース (RS-232 または COM ポートとも呼ばれます) は、 コンピュータにあるシリアルポートを使ってプリンタにデータを送信します。 シリアルインタフェースはコンピュータ業界で共通して使用されています。 そのケーブルは容易に手に入りますし、簡単に自作することもできます。 シリアルインタフェースの場合は時々、 特別なケーブルや何か複雑な通信方式選択の設定が必要になることがあります。 ほとんどの PC のシリアルポートは通信速度が最大で 115200 bps であり、 大きな画像を印刷するのには実用的ではありません。</p></li><li><p><em>パラレル</em>インタフェースではプリンタにデータを送信するために、 コンピュータにあるパラレルポートを使用します。 パラレルインタフェースは PC 業界ではよく使われており、 RS-232 シリアルよりも速いです。 ケーブルの入手は容易ですが、 自作するのはシリアルよりも困難です。 パラレルインタフェースには通常、通信方式の選択はなく、 設定は極めて単純です。</p><div class=paragraph><p>パラレルインタフェースは "セントロニクス" インタフェースとして知られています。 これは、プリンタ用のコネクタタイプとして採用された後に名付けられました。</p></div></li><li><p>USB インタフェースは、Universal Serial Bus (汎用シリアルバス) の略で、パラレルや RS-232 シリアルよりさらに速く動作します。 ケーブルは単純で安価です。USB は、印刷目的には RS-232 シリアルやパラレルよりも向いていますが、UNIX® システムでは十分対応されていません。 この問題を回避する手としては、多くのプリンタがそうですが、 USB とパラレルの両方のインタフェースを備えたプリンタを購入することが挙げられます。</p></li></ul></div><div class=paragraph><p>パラレルインタフェースでは、普通は (コンピュータからプリンタへの) 単方向通信のみを行なうのに対して、 シリアルおよび USB インタフェースは双方向通信を行ないます。 FreeBSD でも IEEE1284 準拠のケーブルを使えば、 最近のパラレルポート (EPP や ECP) とプリンタの多くで双方向通信を行なうことができます。</p></div><div class=paragraph><p>パラレルポート経由のプリンタとの双方向通信には、 通常 2 つの方法のどちらかが使われます。一つ目の方法は、 プリンタが使用しているプロプライエタリな言語を話す FreeBSD 用に作成されたプリンタドライバを使うものです。 これはインクジェットプリンタではよく使われる方法で、 インクの残量やその他の状態の情報を知らせるのに使えます。 二つ目の方法は、プリンタが PostScript® に対応している時に使われます。</p></div><div class=paragraph><p>PostScript® ジョブは、実際にはプリンタに送信されるプログラムです。 印字作業を行う必要は必ずしありませんし、 プログラムの結果を直接コンピュータに返してもよいのです。 PostScript® プリンタでは双方向通信を使って PostScript® プログラムのエラーや紙づまりといった問題をコンピュータに報告します。 ユーザはそれらの情報を知りたいと思うかも知れません。 また、PostScript® プリンタで課金作業をもっとも効率よく行なうためには、 双方向通信が必要となります。 この方法ではまず、プリンタの現在のページカウント (起動してから今まで何枚の紙を印字したか) の情報を得ます。 次に、ユーザのジョブを実行し、終了後、再びページカウントを得ます。 この二つの数を差によって、 課金対象となる紙の枚数を知ることができるのです。</p></div></div><div class=sect5><h6 id=printing-parallel>9.3.1.1.2. パラレルポート<a class=anchor href=#printing-parallel></a></h6><div class=paragraph><p>プリンタをパラレルインタフェースを使って接続する場合は、 セントロニクスケーブルでプリンタとコンピュータを接続してください。 詳しい説明はプリンタやコンピュータに付属する説明書に書かれているはずです。</p></div><div class=paragraph><p>その際、 どのパラレルポートを使用したかを覚えておいてください。 FreeBSD では最初のポートは <span class=filename>ppc0</span>、 二番目が <span class=filename>ppc1</span> であり、 三番目以降も同様に続きます。 プリンタのデバイス名にも同じ形式が使われており、 最初のパラレルポートに接続されたプリンタは <span class=filename>/dev/lpt0</span> などとなります。</p></div></div><div class=sect5><h6 id=printing-serial>9.3.1.1.3. シリアルポート<a class=anchor href=#printing-serial></a></h6><div class=paragraph><p>シリアルインタフェースを使ってプリンタを使う場合は、 適切なシリアルケーブルでプリンタとコンピュータを接続してください。 詳しい説明はプリンタ、コンピュータ、あるいは両方に付属する説 明書に書かれているはずです。</p></div><div class=paragraph><p>"適切なシリアルケーブル" が良くわからないときは、 次のどれかを試してみてください。</p></div><div class=ulist><ul><li><p><em>モデム</em>用ケーブルでは、 それぞれのピンは他方のコネクタの対応するピンと線でつながっています。 このタイプのケーブルは "DTE-DCE" 間ケーブルとしても知られています (訳注: 日本ではストレートケーブルという名前で売られています)。</p></li><li><p><em>ヌルモデム</em>用ケーブルでは、 あるピンは対応するピンとを接続していますが、 あるピン (たとえば、データ送信用とデータ受信用のピン) が交差して接続したり、 いくつかのピンは内部で短絡していたりします。 このタイプのケーブルは、 "DTE-DTE" 間ケーブルと呼ばれています (訳注: 日本ではクロスケーブルという名前で売られています)。</p></li><li><p>A <em>シリアルプリンタ</em>用ケーブルは、 ある特定のプリンタで必要とされるものです。 ヌルモデムケーブルと似ていますが、 内部で短絡させる代わりに、 ある信号を他方側に送るために使用しています。</p></li></ul></div><div class=paragraph><p>この他に、 プリンタ用の通信パラメータを設定する必要があります。 通常、プリンタのフロントパネルや DIP スイッチによって制御します。 コンピュータとプリンタの双方で設定できる最高の通信速度 [bps] (ビット/秒、 <em>ボーレート</em>と示されているときもある) を選んでください。そして、データビット (7 または 8)、 パリティ (偶/奇/なし)、ストップビット (1 または 2) を選んでください。 そして、フローコントロールの有無 (制御なし、または XON/XOFF ("イン・バンド" または "ソフトウェア" フローコントロールとも呼ばれる)) を選びます。 以下に続くソフトウェアの設定のために、 ここでの設定を覚えておいてください。</p></div></div></div><div class=sect4><h5 id=printing-software>9.3.1.2. ソフトウェアの設定<a class=anchor href=#printing-software></a></h5><div class=paragraph><p>本節では FreeBSD の LPD スプーリングシステムで印字をおこなうために 必要となるソフトウェアの設定について説明しています。</p></div><div class=paragraph><p>本節の概要は次のようになります。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>プリンタで使用するポートのために、必要があれば、 カーネルの書き変えをおこないます。「<a href=#printing-kernel>カーネルの変更</a>」で、 このためにしなくてはならないことを説明しています。</p></li><li><p>パラレルポートを使用している場合は、 パラレルポートのための通信モードを設定します。 詳細は、 「<a href=#printing-parallel-port-mode>パラレルポートの通信モードを設定する</a>」 で説明しています。</p></li><li><p>オペレーティングシステムからプリンタにデータが送ら れているかをテストします。「<a href=#printing-testing>プリンタとの通信状況を調べる</a>」で、 どのようにテストするかの提案をいくつかおこなっています。</p></li><li><p>ファイル<span class=filename>/etc/printcap</span>を変更し、 LPD の設定をおこないます。 この節で、どのように変更するかを説明しています。</p></li></ol></div></div></div><div class=sect5><h6 id=printing-kernel>9.3.1.2.1. カーネルの変更<a class=anchor href=#printing-kernel></a></h6><div class=paragraph><p>オペレーティングシステムのカーネルの コンパイルをおこなうことによって、 指定されたデバイスが機能するようになります。シリアル、 または、パラレルインタフェースをプリンタで使用する場合、 必要なデバイスがこの指定の中に含まれていなくてはなりません。 したがって、 必要なデバイスがカーネルに組み込まれていない場合、 追加のシリアル、または、パラレルポートをサポートするために、 カーネルの再コンパイルが必要となるかもしれません。</p></div><div class=paragraph><p>シリアルポートが現在使用しているカーネルで サポートされているかどうかを調べるためには、 次のように入力します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep sioN /var/run/dmesg.boot</span></code></pre></div></div><div class=paragraph><p>ここで、<em>N</em> はシリアルポートの番号を示し、この番号は 0 から始まります。 次のような出力があった場合、 カーネルはそのポートをサポートしています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sio2 at port 0x3e8-0x3ef irq 5 on isa
 sio2: <span class=nb>type </span>16550A</code></pre></div></div><div class=paragraph><p>パラレルポートが現在使用しているカーネルで サポートされているかどうかを調べるためには、 次のように入力します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep ppcN /var/run/dmesg.boot</span></code></pre></div></div><div class=paragraph><p>ここで、<em>N</em> はパラレルポートの番号を示し、この番号は 0 から始まります。 次のような出力があった場合、 カーネルはそのポートをサポートしています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppc0: &lt;Parallel port&gt; at port 0x378-0x37f irq 7 on isa0
ppc0: SMC-like chipset <span class=o>(</span>ECP/EPP/PS2/NIBBLE<span class=o>)</span> <span class=k>in </span>COMPATIBLE mode
ppc0: FIFO with 16/16/8 bytes threshold</code></pre></div></div><div class=paragraph><p>上記の出力が得られない場合、プリンタを使うため、 オペレーティングシステムにパラレル、または、 シリアルポートを認識し、使用できるようにするためには カーネルを変更する必要があります。</p></div><div class=paragraph><p>シリアルポートをサポートさせるには、「<a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a>」の節をご覧く ださい。パラレルポートをサポートさせる場合も、その節と、 <em>あわせて</em>、 この節に続く節もご覧ください。</p></div></div></div><div class=sect4><h5 id=printing-parallel-port-mode>9.3.1.3. パラレルポートの通信モードを設定する<a class=anchor href=#printing-parallel-port-mode></a></h5><div class=paragraph><p>パラレルインタフェースを使用している場合、FreeBSD では、 割り込み駆動型にするか、 プリンタとの通信の状況をカーネルに監視させるかのいずれかを選択できます。 FreeBSD の汎用プリンタデバイスドライバ (<a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a>) は <a href="https://man.freebsd.org/cgi/man.cgi?query=ppbus&amp;sektion=4&amp;format=html">ppbus(4)</a> システムを利用しています。 これは <a href="https://man.freebsd.org/cgi/man.cgi?query=ppc&amp;sektion=4&amp;format=html">ppc(4)</a> ドライバを使ってパラレルポートのチップセットを制御します。</p></div><div class=ulist><ul><li><p>GENERIC カーネルでは<em>割り込み駆動</em>方式がデフォルトになっています。 この方式では、 オペレーティングシステムはプリンタがデータを受け付けられるかどうかを調べるために、 IRQ ラインを一つ使用します。</p></li><li><p><em>監視</em>方式では、 オペレーティングシステムにプリンタがもっとデータを受け付けられるかどうかを繰り返し尋ねるように指示します。 そして、受け付けるという応答を受けたとき、 カーネルはさらなるデータを送信します。</p></li></ul></div><div class=paragraph><p>割り込み駆動方式は一般的にいくらか高速になりますが、貴重な IRQ ラインを一つ消費します。 HP の新しいプリンタの一部には、明らかに何かしらのタイミングの問題 (まだ正確にはわかっていません) で割り込みモードでは正常に動作しないものがあると言われています。 これらのプリンタにはポーリングモードが必要になります。 どちらかうまく機能する方を使ってください。 一部のプリンタはどちらの方式でも動作しますが、 割り込みモードでは苦痛を感じるほど低速です。</p></div><div class=paragraph><p>通信モードを設定するためには 2 つの方法があります。 1 つはカーネルを変更することで、もう一つは <a href="https://man.freebsd.org/cgi/man.cgi?query=lptcontrol&amp;sektion=8&amp;format=html">lptcontrol(8)</a> プログラムを使用する方法です。</p></div><div class=paragraph><p><em>カーネルを設定することによって、 通信モードを変更する。</em></p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>カーネルコンフィグレーションファイルを変更します。 <code>ppc0</code> のエントリを探してください。 2 番目のパラレルポートを設定するときは、代わりに <code>ppc1</code> を使います。 以下、3 番目のポートは <code>ppc2</code> となっていきます。</p><div class=ulist><ul><li><p>割り込み駆動方式にする場合は、 <span class=filename>/boot/device.hints</span> ファイルの以下の行を編集して、 <em>N</em> を適切な IRQ 番号に置き換えてください。</p><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.irq=&#34;N&#34;</pre></div></div><div class=paragraph><p>カーネルの設定ファイルには <a href="https://man.freebsd.org/cgi/man.cgi?query=ppc&amp;sektion=4&amp;format=html">ppc(4)</a> ドライバも入れなければなりません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>device ppc</code></pre></div></div></li><li><p>ポーリングモードを使用する場合は、 <span class=filename>/boot/device.hints</span> ファイルの以下の行を削除してください。</p><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.irq=&#34;N&#34;</pre></div></div><div class=paragraph><p>場合によっては、これだけでは FreeBSD でポートをポーリングモードにするには十分ではないことがあります。 多くの場合これは <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> ドライバと併せて動作します。 これはデバイスのプローブとアタッチを行うので、 プリンタポートへのアクセスモードを制御できます。 問題を修正するために <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> の設定を確認してください。</p></div></li></ul></div></li><li><p>ファイルをセーブし、config プログラムを起動し、 カーネルの構築、インストールをおこないます。そして、 リブートしてください。詳細は、「<a href=./#kernelconfig>FreeBSDカーネルのコンフィグレーション</a>」を参照 してください。</p></li></ol></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lptcontrol&amp;sektion=8&amp;format=html">lptcontrol(8)</a> <em>で通信モードを設定する場合</em></p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><code>lptN</code> をイベント駆動方式に設定する場合は、 次のように入力します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptcontrol -i -d /dev/lptN</span></code></pre></div></div></li><li><p><code>lptN</code> を監視方式に設定する場合は、次のように入力します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptcontrol -p -d /dev/lptN</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>これらのコマンドを <span class=filename>/etc/rc.local</span> ファイルに追加 しておくと、システムをブートする度に通信モードを設定する ことができます。詳細については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lptcontrol&amp;sektion=8&amp;format=html">lptcontrol(8)</a> をご覧ください。</p></div></div><div class=sect4><h5 id=printing-testing>9.3.1.4. プリンタとの通信状況を調べる<a class=anchor href=#printing-testing></a></h5><div class=paragraph><p>スプーリングシステムの設定に進む前に、オペレーティング システムがプリンタにデータを送ることに成功しているかどうか を確かめるべきでしょう。これにより、印字がうまくいかないと き、プリンタとの通信が問題なのか、スプーリングシステムが問 題なのかを分けて調べることがかなり容易になります。</p></div><div class=paragraph><p>プリンタをテストするためには、 プリンタに何かのテキストを送 信してみます。送信した文字をすぐに印字してくれるプリンタに は、<a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> コマンドを使うと有用です。このコマンドは印 字可能な 96 文字の ASCII 文字すべてを 96 行生成します。</p></div><div class=paragraph><p>PostScript® (または他の言語に対応した) プリンタの場合 は、もっと巧妙なテストが必要になります。次のような、簡単な PostScript® プログラムを使えば十分でしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>%!PS
100 100 moveto 300 300 lineto stroke
310 310 moveto
/Helvetica findfont 12 scalefont setfont
(Is this thing working?) show
showpage</pre></div></div><div class=paragraph><p>上の PostScript® コードはファイルに保存し、 以降の節で例として示されているように利用することができます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>このドキュメントでプリンタ用言語を参照するときは、 PostScript® のような言語を仮定しており、Hewlett Packard の PCL は考慮していません。PCL は非常に機能的なの ですが、 プレインテキストにエスケープシーケンスを混ぜること ができます。PostScript® ではプレインテキストを直接印字 することはできません。 このような種類のプリンタ言語に対しては、 特別な対応をおこなわなければなりません。</p></div></td></tr></tbody></table></div><div class=sect5><h6 id=printing-checking-parallel>9.3.1.4.1. パラレルポートのプリンタとの接続を調べる<a class=anchor href=#printing-checking-parallel></a></h6><div class=paragraph><p>この節では、FreeBSD がパラレルポートに接続されたプリ ンタと通信できているかどうかを調べる方法について説明し ています。</p></div><div class=paragraph><p><em>パラレルポートのプリンタをテストするために</em></p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> コマンドで <code>root</code> になります。</p></li><li><p>プリンタにデータを送ります。</p><div class=ulist><ul><li><p>プリンタがプレインテキストを印字できる場合、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> コマンドを使います。 次のように入力してください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptest &gt; /dev/lptN</span></code></pre></div></div><div class=paragraph><p>ここで、<em>N</em> はパラレルポートの番号で、番号は 0 から始まります。</p></div></li><li><p>プリンタが PostScript® か他のプリンタ 言語を使用している場合、そのプリンタに簡単なプロ グラムを送信してください。次のように入力します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat &gt; /dev/lptN</span></code></pre></div></div><div class=paragraph><p>そして、一行一行、 プログラムを<em>慎重に</em>入力して 下さい。RETUREN または ENTER キーを入力してしま うと、その行は編集できなくなります。プログラムの 入力が終わったら、CONTROL+D か、あなたが設定して いるファイル終了のキーを押してください。</p></div><div class=paragraph><p>もしくは、プログラムを入力したファイルがある 場合は、次のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat file &gt; /dev/lptN</span></code></pre></div></div><div class=paragraph><p>ここで、<em>file</em> はプログラムが格納されていて、 プリンタに送信するファイルの名前です。</p></div></li></ul></div></li></ol></div></div></div><div class=paragraph><p>これで何かが印刷されるはずです。 印字されたテキストがおかしくても心配は無用です。 それについては、後で修正します。</p></div></div><div class=sect5><h6 id=printing-checking-serial>9.3.1.4.2. シリアルポートのプリンタとの接続を調べる<a class=anchor href=#printing-checking-serial></a></h6><div class=paragraph><p>この節では、FreeBSD がシリアルポートに接続されたプリ ンタと通信できているかどうかを調べる方法について述べられ ています。</p></div><div class=paragraph><p><em>シリアルポートのプリンタをテストするために</em></p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> コマンドで <code>root</code> になります。</p></li><li><p><span class=filename>/etc/remote</span> ファイルを編集します。次のエントリを加えてください。</p><div class="literalblock programlisting"><div class=content><pre>printer:dv=/dev/port:br#bps-rate:pa=parity</pre></div></div><div class=paragraph><p>ここで、<em>port</em> シリアルポート (<code>ttyu0</code>、 <code>ttyu1</code> など) のデバイスエントリで、 <em>bps-rate</em>は プリンタとの通信の転送速度[bit/秒]、 <em>parity</em>はプリ ンタとの通信で必要とされるパリティ (<code>even</code>、<code>odd</code>、 <code>none</code>、 <code>zero</code>のいずれか) を表わしていま す。</p></div><div class=paragraph><p>次の例は、 プリンタをシリアルケーブルでパリティなし、転送速度 19200 bps で第 3 番目のシリアルポートに接続した場 合です。</p></div><div class="literalblock programlisting"><div class=content><pre>printer:dv=/dev/ttyu2:br#19200:pa=none</pre></div></div></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> コマンドでプリンタと接続します。 次のように入力してください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tip printer</span></code></pre></div></div><div class=paragraph><p>これがうまくいかなかった場合は、 <span class=filename>/etc/remote</span>を編集して、 <span class=filename>/dev/ttyuN</span> の代わりに <span class=filename>/dev/cuaaN</span> を試してみてください。</p></div></li><li><p>プリンタにデータを送ります。</p><div class=ulist><ul><li><p>プリンタがプレインテキストを印字できる場合、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> コマンドを使います。 次のように入力してください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nv>$lptest</span></code></pre></div></div></li><li><p>プリンタが PostScript® か他のプリンタ言語を使用している場合、 そのプリンタに簡単なプログラムを入力します。 一行一行、プログラムを<em>慎重に</em>入力してください。 バックスペースキーや他の編集用のキーは、 プリンタの制御コードに割り当てられているかもしれません。 プログラムが終了したことをプリンタに伝えるための特別なファイル終了キーを 入力する必要があるかもしれません。 PostScript® プリンタの場合、 <code>CONTROL+D</code> を入力します。</p><div class=paragraph><p>もしくは、プログラムを入力したファイルがある場合は、 次のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=o>&gt;</span>file</code></pre></div></div><div class=paragraph><p>ここで、<em>file</em> はプログラムが格納されているファイル名です。 <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> コマンドでファイルを送信した後は、 ファイル終了を表わすキーを入力する必要があります。</p></div></li></ul></div></li></ol></div></div></div><div class=paragraph><p>これで何かがプリントされることでしょう。 印字されたテキ ストがおかしくても心配しなくても構いません。 それについては、後で修正します。</p></div></div></div><div class=sect4><h5 id=printing-printcap>9.3.1.5. スプーラに許可を与える: <span class=filename>/etc/printcap</span> ファイル<a class=anchor href=#printing-printcap></a></h5><div class=paragraph><p>ここまでで、プリンタはコンピュータに接続され、(必要なら) プリンタと通信できるようにカーネルを変更し、 簡単なデータをプリンタに送信することができているはずです。 これで、LPD にプリンタへのアクセスを 制御させる設定をおこなう準備が整いました。</p></div><div class=paragraph><p>LPD の設定は <span class=filename>/etc/printcap</span> を編集することでおこないます。 LPD スプーリングシステムは スプーラが使われる毎にこのファイルを参照します。 そのため、ファイルを更新するとすぐにその変更が反映されます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> ファイルの書式は簡単です。 <span class=filename>/etc/printcap</span> の編集はお好みのテキストエディタをお 使いください。このファイルの書式は、 <span class=filename>/usr/shared/misc/termcap</span> や <span class=filename>/etc/remote</span> といった他のケイパビリティファイルと一致しています。 この書式 についての詳細な情報については <a href="https://man.freebsd.org/cgi/man.cgi?query=cgetent&amp;sektion=3&amp;format=html">cgetent(3)</a> をご覧ください。</p></div><div class=paragraph><p>スプーラの単純な設定法は、 次のステップでおこないます。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>プリンタに名前 (と簡単な別名 2 ～ 3 個) を付け、それを <span class=filename>/etc/printcap</span> ファイルに記述します。 これについては、「<a href=#printing-naming>プリンタに名前を付ける</a>」 を参照してください。</p></li><li><p><code>sh</code> の項目を追加することで、 ヘッダページの出力を禁止します (デフォルトは許可)。 これについては、「<a href=#printing-no-header-pages>ヘッダページの印字を禁止する</a>」 を参照してください。</p></li><li><p>スプール用のディレクトリを作成し、その位置を <code>sd</code> 項目で指定します。これについては、 「<a href=#printing-spooldir>スプーリングディレクトリの作成</a>」 を参照してください。</p></li><li><p>プリンタを使用するために <span class=filename>/dev</span> エントリを設定し、<span class=filename>/etc/printcap</span> の <code>lp</code> 項目でそのエントリを指定します。 これについては、「<a href=#printing-device>プリンタデバイスの特定</a>」 を参照してください。 プリンタをシリアルポートに接続した場合は、 <code>ms#</code> の項目を設定する必要があります。こちらについては、 「<a href=#printing-commparam>スプーラのための通信パラメータの設定</a>」 を参照してください。</p></li><li><p>プレインテキスト用の入力フィルタのインストールをおこないます。 「<a href=#printing-textfilter>テキストフィルタのインストール</a>」 を参照してください。</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> コマンドで何かを印字することで設定のテストをおこないます。 <a href=#printing-trying>印字してみよう</a> と <a href=#printing-troubleshooting>トラブルシューティング</a> を参照してください。</p></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>PostScript® プリンタのような、 プリンタ言語を使用しているプリンタには、 プレインテキストを直接印字させることができません。 上にアウトラインを示し、 以下の節で説明する簡単な設定方法の説明では、 そのようなプリンタを設置している場合は、 プリンタが認識できるファイルだけを印字の対象としているという 仮定をしています。</p></div></td></tr></tbody></table></div><div class=paragraph><p>多くの場合、 利用者はシステムに設置されているプリンタすべてで プレインテキストが印字できることを期待しています。 印字作業をおこなうために LPD のインタフェースを利用するプログラムでも、 通常、そのような仮定を置きます。 プリンタ言語を使用するプリンタを設置しており、 そのプリンタ言語で記述されたジョブと、 <em>これに加えて</em>、 プレインテキストのジョブも印字できるようにしたいならば、 上で示した簡単な設定方法に加えて、 さらなる設定をおこなうことを強くお勧めします。すなわち、 自動的にプレインテキストから PostScript® (もしくは、 他のプリンタ言語) に変換するプログラムをインストールしてください。「<a href=#printing-advanced-if-conversion>プレインテキストのジョブを PostScript® プリンタで印字する</a>」 で、それをどのようにおこなえばよいのかが説明されています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>日本語を印字したい場合は、プリンタ言語を使用し ていない「日本語プリンタ」についても、 プリンタ固有のエスケープシーケンスを送る必要があります。 また、漢字コードをプリン タが設定しているものに変換したりする必要があり、 各プリンタ毎に、日本語用のフィルタが必要になります。</p></div></td></tr></tbody></table></div><div class=sect5><h6 id=printing-naming>9.3.1.5.1. プリンタに名前を付ける<a class=anchor href=#printing-naming></a></h6><div class=paragraph><p>最初の (簡単な) ステップで、プリンタの名前を考えます。 プリンタには別名をいくつか付けることもできるので、 機能的な名前 でも風変わりな名前でもどちらを選んでもまったく 問題はありません。</p></div><div class=paragraph><p>少なくとも1つのプリンタには、 <span class=filename>/etc/printcap</span> の中で、 <code>lp</code> という別名を持たせるべきでしょう。 この名前はデフォルトのプリンタ名になっています。 ユーザが環境変数 <code>PRINTER</code> を設定しておらず、 かつ、LPD コマンドのコマンドラインで プリンタの名前が指定されていない場合、<code>lp</code> がデフォルトのプリンタ名となり、 そのプリンタに出力されます。</p></div><div class=paragraph><p>それから、これは共通の慣習ですが、 プリンタの最後の別名には、 メーカーやモデル名を含むプリンタの完全な名称をつけることに なっています。</p></div><div class=paragraph><p>名前と別名のいくつかを決めたら、 <span class=filename>/etc/printcap</span> ファイルに設定します。 プリンタ名は一番左のカラムから書き始めます。 別名はそれぞれ縦棒によって区切られ、 最後の別名の後ろにコロンを置きます。</p></div><div class=paragraph><p>次の例では、2 台のプリンタ (Diablo 630 ラインプリンタと Panasonic KX-P4455 PostScript® レーザライタプリンタ) が定義 されている <span class=filename>/etc/printcap</span> のスケルトンを記しています。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose
#
rattan|line|diablo|lp|Diablo 630 Line Printer:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:</pre></div></div><div class=paragraph><p>この例では、最初のプリンタに <code>rattan</code> という名前と別名として、<code>line</code>、 <code>diablo</code>、<code>lp</code> そして <code>Diablo 630 Line Printer</code> が付けられています。別名とし て <code>lp</code> があるので、このプリンタはデフォルトのプリンタとなっ ています。2 番目は <code>bamboo</code> と名付けられ、 別名として、<code>ps</code> と <code>PS</code>、<code>S</code>、 <code>panasonic</code>、<code>Panasonic KX-P4455 PostScript v51.4</code> が付けられています。</p></div></div><div class=sect5><h6 id=printing-no-header-pages>9.3.1.5.2. ヘッダページの印字を禁止する<a class=anchor href=#printing-no-header-pages></a></h6><div class=paragraph><p>LPD スプーリングシステムでは、 デフォルトでジョブ毎に <em>ヘッダページ</em>を印字します。 ヘッダページにはジョブを要求したユーザ名、 ジョブが送られたホスト名、そして、ジョブの名前が素晴 らしい大きな文字で印字されています。 残念なことに、この余分なテキストすべてが、 簡単なプリンタ設定法のデバッグの際に紛れ込んできてしまいます。 このため、ヘッダページの出力を禁止しておきます。</p></div><div class=paragraph><p>ヘッダページの出力を禁止するには、 <span class=filename>/etc/printcap</span> にあるプリンタのエントリに <code>sh</code> の項目を追加します。次に、<code>sh</code> を加えた <span class=filename>/etc/printcap</span> の例を示します。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - no header pages anywhere
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:</pre></div></div><div class=paragraph><p>この書式を正しく使うための注意をしておきます。 最初の行は左端のカラムから始めます。 それに続く行は字下げします。最後の行以外のすべての行は、 行末にバックスラッシュを記述します。</p></div></div><div class=sect5><h6 id=printing-spooldir>9.3.1.5.3. スプーリングディレクトリの作成<a class=anchor href=#printing-spooldir></a></h6><div class=paragraph><p>スプーラの簡単な設定の次のステップでは、 <em>スプーリングディレクトリ</em>を作成します。 プリンタに送られるジョブは、 その印字が終了するまでこのディレクトリに置かれます。また、 他のたくさんのスプーラもこのディレクトリにファイルを置きます。</p></div><div class=paragraph><p>様々な事情によりスプーリングディレクトリは、通常、慣例 として <span class=filename>/var/spool</span> の下に置きます。 また、スプーリングディレクトリの内容は バックアップをする必要はありません。 <a href="https://man.freebsd.org/cgi/man.cgi?query=mkdir&amp;sektion=1&amp;format=html">mkdir(1)</a> によってディレクトリを 作るだけでスプーリングディレクトリの復旧は完了します。</p></div><div class=paragraph><p>スプーリングディレクトリの名前は、これも慣例ですが、 次のようにプリンタの名前と同じにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/spool/printer-name</span></code></pre></div></div><div class=paragraph><p>しかしながら、ネットワーク上に使用可能なプリンタがたく さんあるならば、LPD で印字するための専用のディレクトリにスプーリングディレクトリを置きたくなるかもしれません。 例に出てきたプリンタ <code>rattan</code> と <code>bamboo</code> について、この方式を採用すると、 次のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/spool/lpd</span>
<span class=c># mkdir /var/spool/lpd/rattan</span>
<span class=c># mkdir /var/spool/lpd/bamboo</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>各ユーザが印字するジョブのプライバシを守りた いと考えているならば、スプーリングディレクトリを保護し て、これを誰からでもアクセスできないようにしたいと思う かもしれません。スプーリングディレクトリは、 <code>daemon</code> ユーザと <code>daemon</code> グループに所有され、 読み込み、書き込み、検 索可能であり、他からはアクセスできないようにするべきで す。例題のプリンタに対して、次のようにすることにしましょ う。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown daemon:daemon /var/spool/lpd/rattan</span>
<span class=c># chown daemon:daemon /var/spool/lpd/bamboo</span>
<span class=c># chmod 770 /var/spool/lpd/rattan</span>
<span class=c># chmod 770 /var/spool/lpd/bamboo</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>最後に、<span class=filename>/etc/printcap</span> ファイルで、 これらのディレクトリの位置を LPD に伝える必要があります。 スプーリングディレクトリのパス名は <code>sd</code> 項目で指定します。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - added spooling directories
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:</pre></div></div><div class=paragraph><p>プリンタ名が最初のカラムから始まっており、 そのプリンタに関して記述される他の項目は字下げされていること、 各行がバックスラッシュで終わっていることに注意してください。</p></div><div class=paragraph><p><code>sd</code> によりスプーリングディレクトリが指定されていない場合、 スプーリングシステムは <span class=filename>/var/spool/lpd</span> をデフォルト値として使用します。</p></div></div><div class=sect5><h6 id=printing-device>9.3.1.5.4. プリンタデバイスの特定<a class=anchor href=#printing-device></a></h6><div class=paragraph><p><a href=#printing-hardware>プリンタ機器の設定</a> の節では、FreeBSD でプリンタとの通信に使用されるポートおよび <span class=filename>/dev</span> ディレクトリ内のエントリを特定します。 そして、LPD にその情報を伝えます。 印字するジョブを受け取ると、スプーリングシステムは、 (プリンタにデータを渡す義務がある) フィルタプログラムに代わって指定されたデバイスをオープンします。</p></div><div class=paragraph><p><span class=filename>/etc/printcap</span> ファイルで <code>lp</code> 項目を使って <span class=filename>/dev</span> エントリを記入します。</p></div><div class=paragraph><p>ここでの例では、<code>rattan</code> は 1 番目のパラレルポートに、<code>bamboo</code> は 6 番目のシリアルポートに接続されていることにしましょう。 このとき、<span class=filename>/etc/printcap</span> には 次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - identified what devices to use
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyu5:</pre></div></div><div class=paragraph><p><span class=filename>/etc/printcap</span> でプリンタの <code>lp</code> 項目が指定されていない場合は、 LPD はデフォルトとして <span class=filename>/dev/lp</span> を使用します。<span class=filename>/dev/lp</span> は、現在の FreeBSD には存在していません。</p></div><div class=paragraph><p>設置したプリンタがパラレルポートに 接続されている場合は、 「<a href=#printing-textfilter>テキストフィルタのインストール</a>」 まで読み飛ばしてください。 そうでない場合は、次節の説明に続いてください。</p></div></div><div class=sect5><h6 id=printing-commparam>9.3.1.5.5. スプーラのための通信パラメータの設定<a class=anchor href=#printing-commparam></a></h6><div class=paragraph><p>シリアルポートにプリンタを接続した場合、 LPD は、プリンタにデータを送信するフィルタプログラムに代わり、 通信速度やパリティ、 その他のシリアル通信パラメータを設定することができます。 このことによる利点は、</p></div><div class=ulist><ul><li><p><span class=filename>/etc/printcap</span> を編集するだけで、 様々な通信パラメータを試してみることができます。 フィルタプログラムを再コンパイルする必要はありません。</p></li><li><p>スプーリングシステムで、 シリアル通信の設定が異なっているかもしれない複数のプリンタに 同じフィルタプログラムを使うことが可能になります。</p></li></ul></div><div class=paragraph><p>次の <span class=filename>/etc/printcap</span> の項目で、 <code>lp</code> で指定された デバイスのシリアル通信パラメータを制御できます。</p></div><div class=dlist><dl><dt class=hdlist1><code>br#bps-rate</code></dt><dd><p>デバイスの通信速度を <em>bps-rate</em> に設定します。 ここで、<em>bps-rate</em> は 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200 [bit/秒] のいずれかです。</p></dd><dt class=hdlist1><code>ms#stty-mode</code></dt><dd><p>デバイスをオープンした後にターミナルデバイスのオプションを設定します。 利用できるオプションについては <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> を参照してください。</p></dd></dl></div><div class=paragraph><p><code>lp</code> で指定されたデバイスをオープンするとき、 LPD は <code>ms#</code> で指定されたデバイスの特性を設定します。 特に関係があるのは、<code>parenb</code>, <code>parodd</code>, <code>cs5</code>, <code>cs6</code>, <code>cs7</code>, <code>cs8</code>, <code>cstopb</code>, <code>crtscts</code>, <code>ixon</code> モードです。 これらは <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> のマニュアルページで説明されています。</p></div><div class=paragraph><p>例題のプリンタで6番目のシリアルポートに接続された プリンタの設定を追加してみましょう。 通信速度は 38400bps に設定します。 モードとして、<code>-parenb</code> でパリティ無し、 <code>cs8</code> で 8 ビットキャラクタ、 <code>clocal</code> でモデム制御無し、 そして <code>crtscts</code> でハードウェアフロー制御を設定します。</p></div><div class="literalblock programlisting"><div class=content><pre>bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:</pre></div></div></div><div class=sect5><h6 id=printing-textfilter>9.3.1.5.6. テキストフィルタのインストール<a class=anchor href=#printing-textfilter></a></h6><div class=paragraph><p>ここまでで、 プリンタにジョブを送るために使うテキストフィルタを LPD に設定する準備が整いました。 <em>テキストフィルタ</em>とは、 <em>入力フィルタ</em>としても知られていますが、 印字するジョブがあるときに LPD が起動するプログラムです。 LPD がプリンタのためにテキストフィルタを起動するとき、 LPD はフィルタの標準入力からプリントするジョブを入力し、 フィルタの標準出力に項目 <code>lp</code> で指定されたプリンタデバイスを接続します。フィルタは、 標準入力からジョブを読み込み、 プリンタのための必要な変換をおこなった後、 その結果を標準出力に出力する、 これにより印字がなされることを期待されています。 テキストフィルタについての更に詳しい情報については、「<a href=#printing-advanced-filters>フィルタはどのように機能しているか</a>」 をご覧ください。</p></div><div class=paragraph><p>ここでの簡単なプリンタ設定では、 プリンタにジョブを送るため、<code>/bin/cat</code> を実行するだけの簡単なシェルスクリプトで間に合います。 FreeBSD に標準で付属している <code>lpf</code> というフィルタでは、バックスペース文字を使った 下線引きの動作をおこなう文字ストリームをうまく扱うことができない プリンタのための代替処理をおこなってくれます。 もちろん、 他のどんなフィルタプログラムを使っても構いません。 フィルタ <span class=filename>lpf</span> については、「<a href=#printing-advanced-lpf>テキストフィルタ lpf</a>」で詳しく説明します。</p></div><div class=paragraph><p>最初に、簡単なテキストフィルタであるシェルスクリプト <span class=filename>/usr/local/libexec/if-simple</span> を作ってみましょう。 次のテキストをお好みのテキストエディタでファイルに 書き込んでください。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# if-simple - Simple text input filter for lpd
# Installed in /usr/local/libexec/if-simple
#
# Simply copies stdin to stdout.  Ignores all filter arguments.

/bin/cat &amp;&amp; exit 0
exit 2</pre></div></div><div class=paragraph><p>そして、このファイルを実行可能にします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/if-simple</span></code></pre></div></div><div class=paragraph><p>LPD にこのテキストフィルタを使うことを設定するためには、 <span class=filename>/etc/printcap</span> に <code>if</code> 項目を使って指定します。これまでの <span class=filename>/etc/printcap</span> の例のプリンタ 2 台に、 このフィルタを加えてみましょう。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - added text filter
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\ :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:\
        :if=/usr/local/libexec/if-simple:</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>if-simple</span> スクリプトのコピーが <span class=filename>/usr/shared/examples/printing</span> ディレクトリにあります。</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_lpd_の起動>9.3.1.5.7. LPD の起動<a class=anchor href=#_lpd_の起動></a></h6><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> は <code>lpd_enable</code> 変数に従って <span class=filename>/etc/rc</span> から実行されます。この変数の デフォルト値は <code>NO</code> です。まだ そうしていなかったならば</p></div><div class="literalblock programlisting"><div class=content><pre>lpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>の行を <span class=filename>/etc/rc.conf</span> に追加して 計算機を再起動するか、そのまま <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> を 起動してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpd</span></code></pre></div></div></div><div class=sect5><h6 id=printing-trying>9.3.1.5.8. 印字してみよう<a class=anchor href=#printing-trying></a></h6><div class=paragraph><p>簡単な LPD 設定も終わりにたどり着きました。 残念ながら、設定はこれでおしまいというわけではありません。 なぜなら、さらに、設定をテストし、 すべての問題点を解決しなくてはならないからです。 設定をテストするために、 何かを印字してみましょう。 LPD システムで印字をするためには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> コマンドを使います。このコマンドは、 印字するためのジョブを投入する働きをします。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> コマンドを 「<a href=#printing-testing>プリンタとの通信状況を調べる</a>」で紹介した、 あるテスト用のテキストを生成してくれる <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> プログラムと一緒に使うこともできます。</p></div><div class=paragraph><p><em>簡単な LPD 設定のテスト</em></p></div><div class=paragraph><p>次のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptest 20 5 | lpr -Pprinter-name</span></code></pre></div></div><div class=paragraph><p>ここで、<em>printer-name</em> は <span class=filename>/etc/printcap</span> で指定したプリンタ名 (もしくはその別名) です。デフォルト のプリンタを使用する場合は、 <code>-P</code> 引数を付けないで <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> を打ち込んでください。もう一度述べますが、 PostScript® を期待しているプリンタをテストするならば、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> を使う代わりに PostScript® で書かれた プログラムをプリンタに送ってください。 プログラムを送るためには、プログラムをファイルに格納して、 <code>lpr file</code> と打ち込みます。</p></div><div class=paragraph><p>PostScript® プリンタの場合、 送信したプログラムによる結果が得られるでしょう。 <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> を使った場合は、 以下のような結果が見られるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>!</span><span class=s2>&#34;#</span><span class=nv>$%</span><span class=s2>&amp;&#39;()*+,-./01234
&#34;</span><span class=c>#$%&amp;&#39;()*+,-./012345</span>
<span class=c>#$%&amp;&#39;()*+,-./0123456</span>
<span class=nv>$%</span>&amp;<span class=s1>&#39;()*+,-./01234567
%&amp;&#39;</span><span class=o>()</span><span class=k>*</span>+,-./012345678</code></pre></div></div><div class=paragraph><p>更にプリンタをテストしたい場合は、 (言語ベースのプリンタのための) もっと大きなプログラムを送信するか、 引数を変えて <a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> を実行します。たとえば、<code>lptest 80 60</code> で、それぞれ 80 文字の行を 60 行生成します。</p></div><div class=paragraph><p>プリンタがうまく動かなかった場合は、次の節、「<a href=#printing-troubleshooting>トラブルシューティング</a>」をご覧ください。</p></div></div></div></div></div><div class=sect2><h3 id=printing-advanced>9.4. プリンタ設定上級編<a class=anchor href=#printing-advanced></a></h3><div class=paragraph><p>この節では、特殊な形式のファイルを印字するためのフィルタ、 ヘッダページ、ネットワーク越しのプリンタへの印字、そして、 プリンタ使用の制限や課金について説明しています。</p></div><div class=sect3><h4 id=printing-advanced-filter-intro>9.4.1. フィルタ<a class=anchor href=#printing-advanced-filter-intro></a></h4><div class=paragraph><p>LPD は、ネットワークプロトコル、キュー、アクセス制御などの 印刷にかかわるさまざまな点を扱いますが、 <em>実際の</em>作業のほとんどは <em>フィルタ</em>によっておこなわれています。 フィルタは、プリンタと通信し、 プリンタのデバイス依存性や特殊な要求を扱うプログラムです。 簡単なプリンタ設定では、 プレインテキストのためのフィルタをインストールしました。 このプレインテキストフィルタは、 ほとんどのプリンタで機能する極めて単純なものでした (「<a href=#printing-textfilter>テキストフィルタのインストール</a>」を参照)。</p></div><div class=paragraph><p>しかしながら、形式変換やプリンタ課金、特定のプリンタの癖、 など をうまく利用するためには、 フィルタがどのように機能するかという ことを理解しておくべきです。これらの側面を扱うことは、 最終的には、フィルタの責任であるからです。 そして、これは悪い情報ですが、ほとんどの場合において、 <em>あなた自身</em>が フィルタを供給する必要があるということです。また都合のよいことには、 たくさんのフィルタが一般的に利用できるということです。 もしフィルタがなかったとしても、 普通はフィルタを作るのは簡単です。</p></div><div class=paragraph><p>FreeBSD にも、プレインテキストを印字させることができる <span class=filename>/usr/libexec/lpr/lpf</span> というフィルタが 1 つ付いています (このフィルタはファイルに含まれるバックスペースやタブを扱います。 また、課金をすることもできますが、 できることはこれだけしかありません)。 いくつかのフィルタとフィルタの構成要素は FreeBSD Ports Collection にもあります。</p></div><div class=paragraph><p>この節で述べることは次の通りです。</p></div><div class=ulist><ul><li><p>「<a href=#printing-advanced-filters>フィルタはどのように機能しているか</a>」では、 印字の過程におけるフィルタの役割を概説します。 この節を読むことで、LPD がフィルタを使うときに、"見えないところで" 何が起こっているかが理解できるでしょう。このことを知っておくと、 プリンタそれぞれに様々なフィルタをインストールしたときに 遭遇するかもしれない問題を予期したり、 デバッグするときに役立つでしょう。</p></li><li><p>LPD は、すべてのプリンタがデフォルトでプレインテキストを印字できることを期待しています。 これは、プレインテキストを直接印字できない PostScript® (または他の言語対応の) プリンタで問題になります。「<a href=#printing-advanced-if-conversion>プレインテキストのジョブを PostScript® プリンタで印字する</a>」 で、 この問題を克服する方法について述べます。 PostScript® プリンタをお持ちの方は、 この節をお読みになることをおすすめします。</p></li><li><p>PostScript® は様々なプログラムのための有名な出力形式です。 PostScript® のコードを直接書いてしまう人すらいます。 残念ながら、PostScript® プリンタは高価です。「<a href=#printing-advanced-ps>非 PostScript® プリンタによる PostScript® のシミュレート</a>」節では、PostScript® データを<em>非 PostScript® プリンタ</em>に受けつけさせ、印字させるために、 どのようにしてプリンタ用のテキストフィルタをさらに変更すればよいのか、 ということについて説明しています。PostScript® プリンタを持っていない方は、 この節をお読みになることをおすすめします。</p></li><li><p>「<a href=#printing-advanced-convfilters>変換フィルタ</a>」では、 図形や組版データといった特定のファイル形式を、 プリンタが理解できる形式へ変換する作業を自動的におこなわせる方法について述べます。 この節を読むと、troff のデータを印字するには <code>lpr -t</code>, または、TeX DVI を印字するには <code>lpr -d</code>、 ラスタイメージデータを印字するには <code>lpr -v</code>、 などといったようにユーザが入力することができるように プリンタの設定をおこなうことができます。 この節もお読みになることをお薦めします。</p></li><li><p>「<a href=#printing-advanced-of>出力フィルタ</a>」 では、あまり使われない LPD の機能のすべて、すなわち、 出力フィルタに関することが記述されています。ヘッダページ (「<a href=#printing-advanced-header-pages>ヘッダページ</a>」参照) を印字させていない場合は、 多分、この節は飛ばしても構わないでしょう。</p></li><li><p>「<a href=#printing-advanced-lpf>テキストフィルタ lpf</a>」では、<code>lpf</code> についての説明が、ほぼ完全におこなわれています。これは FreeBSD に付属するラ インプリンタ (または、 ラインプリンタのように動作するレーザプリンタ) のための、 単純なテキストフィルタです。 プレインテキストを印字したことに対して課金をおこなう方法が 至急必要な場合、もしくは、バックスペース文字を印字しようと すると煙を発するプリンタを持っている場合は、絶対に <code>lpf</code> を検討するべきです。</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>以下で述べられているさまざまなスクリプトは、<span class=filename>/usr/shared/examples/printing</span> ディレクトリにあります。</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=printing-advanced-filters>9.4.1.1. フィルタはどのように機能しているか<a class=anchor href=#printing-advanced-filters></a></h5><div class=paragraph><p>既に言及したように、フィルタとは、プリンタにデータを送る際に、 デバイスに依存した部分を取り扱うために LPD によって起動される実行プログラムです。</p></div><div class=paragraph><p>LPD がジョブ中のファイルを印字しようとするとき、 LPD はフィルタプログラムを起動します。このとき、 フィルタの標準入力を印字するファイルに、 標準出力をプリンタに、そして、標準エラー出力を エラーログファイル (<span class=filename>/etc/printcap</span> 内の <code>lf</code> 項目で指定されたファイル、または、 指定されていない場合は、デフォルトとして <span class=filename>/dev/console</span>) にセットします。</p></div><div class=paragraph><p>LPD が起動するフィルタと、その引数が何であるかは、 <span class=filename>/etc/printcap</span> ファイルの内容と、ジョブの起動時にユーザが指定した <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> コマンドの引数に依存しています。 たとえば、ユーザが <code>lpr -t</code> と入力した場合は、 LPD は出力先のプリンタ用の <code>tf</code> 項目で指定されている troff 用のフィルタを起動させるでしょう。 ユーザがプレインテキストの印字を指示したときは、 <code>if</code> で指定されたフィルタが起動されるでしょう (このことはほとんどの場合にあてはまります。 詳細については、「<a href=#printing-advanced-of>出力フィルタ</a>」をご覧ください)。</p></div><div class=paragraph><p><span class=filename>/etc/printcap</span> で指定可能なフィルタは次の3種類があります。</p></div><div class=ulist><ul><li><p><em>テキストフィルタ</em> (LPD のドキュメントでは紛らわしいことに <em>入力フィルタ</em>と呼んでいますが) は一般のテキストの印字を扱います。これはデフォルトのフィルタと 考えてください。LPD では、すべてのプリンタに対して、 デフォルトでプレインテキストが印字できることを期待しています。 さらに、バックスペースやタブを正しく扱い、また、 他の特殊な文字が入力されてもプリンタに混乱を来さないように するのはテキストフィルタの仕事であると考えています。 プリンタの使用に対して課金をしなくてはならない環境にあ るときは、テキストフィルタが印字したページ数を数える作 業もしなくてはなりません。この作業は、通常、印字した行 数を数え、これをプリンタが 1 ページ当たりに印字できる行 数と比較することでおこなわれます。 テキストフィルタは、次のような引数を付けて起動されます。</p><div class=paragraph><p><code>filter-name [ -c ] -w <em>width</em> -l <em>length</em> -i <em>indent</em> -n <em>login</em> -h <em>host</em> <em>acct-file</em></code></p></div><div class=paragraph><p>ここで、</p></div><div class=dlist><dl><dt class=hdlist1><code>-c</code></dt><dd><p><code>lpr -l</code> によってジョブが入力されたときに与えられます。</p></dd><dt class=hdlist1><em>width</em></dt><dd><p><span class=filename>/etc/printcap</span> で指定された <code>pw</code> (page width) 項目の値が与えられます。デフォルトは、 132 です。</p></dd><dt class=hdlist1><em>length</em></dt><dd><p><code>pl</code> (page length) 項目で指定された値が与えられます。 デフォルトは 66 です。</p></dd><dt class=hdlist1><em>indent</em></dt><dd><p><code>lpr -i</code> によって与えられた字下げの量で、 デフォルトは 0 です。</p></dd><dt class=hdlist1><em>login</em></dt><dd><p>ファイルを印字したユーザのアカウント名が 与えられます。</p></dd><dt class=hdlist1><em>host</em></dt><dd><p>ジョブが入力されたホスト名が 与えられます。</p></dd><dt class=hdlist1><em>acct-file</em></dt><dd><p><code>af</code> 項目で指定されている課金データファイル の名前が与えられます。</p></dd></dl></div></li><li><p><em>変換フィルタ</em>は、 特定のファイル形式をプリンタ が紙に印字できるようなものに変換します。たとえば、 プリンタで ditroff 組版データを直接印字することはできません。 しかし、ditroff データをプリンタが消化し、 印字することができる形式へ変換するために、ditroff ファイル用フィルタをインストールすることができます。 「<a href=#printing-advanced-convfilters>変換フィルタ</a>」 で、これらに関するすべてについて説明します。 プリンタの課金をする必要がある場合は、 変換フィルタでも印字ページを数える作業が必要となります。 変換フィルタは次の引数をとって起動されます。</p><div class=paragraph><p><code>filter-name -x <em>pixel-width</em> -y <em>pixel-height</em> -n <em>login</em> -h <em>host</em> <em>acct-file</em></code></p></div><div class=paragraph><p>ここで、<em>pixel-width</em> は、 <code>px</code> 項目で指定された値 (デフォルトは 0)、 <em>pixel-height</em> は、 <code>py</code> 項目で指定された値 (デフォルトは 0) です。</p></div></li><li><p><em>出力フィルタ</em>は、 テキストフィルタが指定されて おらず、かつ、 ヘッダページの出力が許可されている場合にのみ使われます。 「<a href=#printing-advanced-of>出力フィルタ</a>」で、これらのことについて説明します。 出力フィルタに対する引数は次の 2 つだけです。</p><div class=paragraph><p><code>filter-name -w <em>width</em> -l <em>length</em></code></p></div><div class=paragraph><p>ここで、<code>-w</code> と <code>-l</code> は、 テキストフィルタの場合と同じです。</p></div></li></ul></div><div class=paragraph><p>フィルタは、次に示す終了状態をもってプログラムを <em>exit</em> するべきです。</p></div><div class=dlist><dl><dt class=hdlist1>exit 0</dt><dd><p>フィルタがファイルを正常に印字した場合。</p></dd><dt class=hdlist1>exit 1</dt><dd><p>フィルタはファイルの印字に失敗したが、 LPD に再度ファイルの印字を試みて欲しい場合。 この終了状態で終了した場合、LPD はフィルタを再スタートします。</p></dd><dt class=hdlist1>exit 2</dt><dd><p>フィルタはファイルの印字に失敗し、かつ、LPD に再出力を試みて欲しくない場合。この場合、LPD はそのファイルを放棄します。</p></dd></dl></div><div class=paragraph><p>FreeBSD に付属するテキストフィルタ <span class=filename>/usr/libexec/lpr/lpf</span> は、FORM FEED 文字が送られたときやプリンタ使用に対する課金をどのようにするかを決定するために、 ページ幅やページ長の引数を利用します。また、 課金用のエントリを作成するため、ログイン名、ホスト名、 課金ファイル名の引数を利用します。</p></div><div class=paragraph><p>もし、フィルタの購入を検討しているならば、LPD と互換性があるかどうかを確認してください。もしそうならば、 上述の引数リストをサポートしていなければなりません。 一般向けの使用のためにフィルタを作成する計画をしている場合は、 同じ引数リストと終了コードをサポートしてください。</p></div></div><div class=sect4><h5 id=printing-advanced-if-conversion>9.4.1.2. プレインテキストのジョブを PostScript® プリンタで印字する<a class=anchor href=#printing-advanced-if-conversion></a></h5><div class=paragraph><p>コンピュータと PostScript® (または、他の言語に対応した) プリンタをあなたしか使用しない場合は、プリンタにプレ インテキストを絶対に送らない、そして、 プリンタにプレインテキストを送りたがっている 様々なプログラムの機能を決して使わないことにしてください。そうすれば、 この節に書かれたことに心を煩わせる必要はまったくなくなります。</p></div><div class=paragraph><p>しかし、PostScript® とプレインテキストの両方のジョブをプリンタへ送りたいと思っている場合は、 プリンタ設定についての要求が増えるでしょう。 両者をプリンタへ送信するためには、 到着したジョブがプレインテキストであるか PostScript® であるかを検出するテキストフィルタが必要です。 PostScript® のジョブはすべて <code>%!</code> で始まらなければならないことになっています (他のプリンタ言語に関しては、 プリンタのドキュメントをご覧ください)。 ジョブの最初の 2 文字がこれならば、PostScript® であることが分かります。 したがって、 ジョブのそれ以降の部分をプリンタに直接送ることができます (訳注: PostScript® では、<em>%</em> 以降はコメントとして扱われるので、最初の <em>%!</em> の行を読み捨てても問題はない)。 最初の2文字が <em>%!</em> でない場合は、 フィルタはテキストを PostScript® に変換し、 その結果を使って印字をおこないます。</p></div><div class=paragraph><p>この作業をどうやってやればよいのでしょうか。</p></div><div class=paragraph><p>シリアルポートにプリンタを接続した場合は、 <code>lprps</code> をインストールすることをお勧めします。 <code>lprps</code> は PostScript® 用のフィルタで、 プリンタとの双方向通信をおこないます。 このフィルタでは、プリンタからの冗長な情報を得ることで、 プリンタの状況を示すファイルが更新されていきます。 したがって、ユーザや管理者は (<code>トナー残量少</code>や <code>紙詰まり</code>といった) プリンタの状況を正確に知ることができます。しかし、 もっと重要なことは、<code>psif</code> と呼ばれるプログラムが含まれているということです。 このプログラムは、 入力されたジョブがプレインテキストかどうかを検出し、 これを PostScript® に変換するために、<code>textps</code> (<code>lprps</code> に付属する別のプログラム) を呼び出します。そして、このジョブをプリンタに送るために、 <code>lprps</code> が使われます。</p></div><div class=paragraph><p><code>lprps</code> は FreeBSD Ports Collection に含まれています (<a href=./#ports>Ports Collection</a> を参照してください)。 紙のサイズに合わせて <a class=package href=https://cgit.freebsd.org/ports/tree/print/lprps-a4/>print/lprps-a4</a> または <a class=package href=https://cgit.freebsd.org/ports/tree/print/lprps-letter/>print/lprps-letter</a> port をインストールしてください。<code>lprps</code> をインストールした後は、<code>lprps</code> の一部である <code>psif</code> プログラムのパス名を指定するだけです。Ports Collection から <code>lprps</code> をインストールしたときは、 <span class=filename>/etc/printcap</span> の中のシリアル接続した PostScript® プリンタのエントリに対して、次を使ってください。</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/psif:</pre></div></div><div class=paragraph><p>LPD にプリンタをリード・ライトモードでオープンさせるために、 <code>rw</code> 項目も指定すべきです。</p></div><div class=paragraph><p>パラレルポート接続の PostScript® プリンタの場合 (すなわち、 <code>lprps</code> が 必要としているプリンタとの双方向通信ができない)、 テキストフィルタとして次のシェルスクリプトを使うことができます。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psif - Print PostScript or plain text on a PostScript printer
#  Script version; NOT the version that comes with lprps
#  Installed in /usr/local/libexec/psif
#

IFS=&#34;&#34; read -r first_line
first_two_chars=`expr &#34;$first_line&#34; : &#39;\(..\)&#39;`

if [ &#34;$first_two_chars&#34; = &#34;%!&#34; ]; then
   #
   #  PostScript job, print it.
   #
   echo &#34;$first_line&#34; &amp;&amp; cat &amp;&amp; printf &#34;\004&#34; &amp;&amp; exit 0
   exit 2
else
   #
   #  Plain text, convert it, then print it.
   #
   ( echo &#34;$first_line&#34;; cat ) | /usr/local/bin/textps &amp;&amp; printf &#34;\004&#34; &amp;&amp; exit 0
   exit 2
fi</pre></div></div><div class=paragraph><p>上記のスクリプトにおいて、<code>textps</code> はプレインテキストから PostScript® へ変換するために別にインストールしたプログラムです。 テキストから PostScript® へ変換するのには、 お好みのどんなプログラムでも使うことができます。FreeBSD Ports Collection (<a href=./#ports>Ports Collection</a> を参照してください) には、<code>a2ps</code> と呼ばれるテキストから PostScript® に変換するプログラムが入っています。</p></div></div><div class=sect4><h5 id=printing-advanced-ps>9.4.1.3. 非 PostScript® プリンタによる PostScript® のシミュレート<a class=anchor href=#printing-advanced-ps></a></h5><div class=paragraph><p>PostScript® は質の高い組版と印字をおこなうための <em>事実上の</em>標準です。しかしながら、PostScript® は、<em>高価な</em>標準です。ありがたいことに、 Aladdin Enterprises から Ghostscript と呼ばれる、 PostScript® 互換の動作をするフリーのプログラムが出されていて、 FreeBSD で動きます。 Ghostscript はほとんどの PostScript® ファイルを読むことができ、 これらの各ページを多くのブランドの非 PostScript® プリンタを含む 様々なデバイス用に変換することができます。 Ghostscript をインストールし、 プリンタ用の特別なテキストフィルタを使うことによって、 非 PostScript® プリンタをあたかも本物の PostScript® プリンタであるかのように動作させることができます。</p></div><div class=paragraph><p>Ghostscript は FreeBSD Ports Collection に入っています。 複数のバージョンがありますが、最も良く使われているバージョンは <a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript-gpl/>print/ghostscript-gpl</a> です。</p></div><div class=paragraph><p>PostScript® プリンタをシミュレートさせる場合は、 テキストフィルタに PostScript® ファイルを印字しようとしているかどうかを検出させます。 PostScript® ファイルでない場合は、 フィルタはそのファイルを直接プリンタに送ります (訳注: テキストファイルを直接印字できない場合は、もちろん、 変換フィルタを通す必要があります)。PostScript® の場合は、 まず、Ghostscript を使い、 ファイルをそのプリンタが理解できる形式へ変換します。</p></div><div class=paragraph><p>次の例のスクリプトは、Hewlett Packard DeskJet 500 プリンタ用 のテキストフィルタです。 他のプリンタで用いるときは、<code>-sDEVICE</code> 引数を <code>gs</code> (Ghostscript) コマンドに変えてください (<code>gs -h</code> と入力すると、現在インストールされている Ghostscript でサポートされているデバイスのリストが得られます)。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  ifhp - Print Ghostscript-simulated PostScript on a DeskJet 500
#  Installed in /usr/local/libexec/ifhp

#
#  Treat LF as CR+LF (to avoid the &#34;staircase effect&#34; on HP/PCL
#  printers):
#
printf &#34;\033&amp;k2G&#34; || exit 2

#
#  Read first two characters of the file
#
IFS=&#34;&#34; read -r first_line
first_two_chars=`expr &#34;$first_line&#34; : &#39;\(..\)&#39;`

if [ &#34;$first_two_chars&#34; = &#34;%!&#34; ]; then
    #
    #  It is PostScript; use Ghostscript to scan-convert and print it.
    #
    /usr/local/bin/gs -dSAFER -dNOPAUSE -q -sDEVICE=djet500 \
      -sOutputFile=- - &amp;&amp; exit 0

else
    #
    #  Plain text or HP/PCL, so just print it directly; print a form feed
    #  at the end to eject the last page.
    #
    echo &#34;$first_line&#34; &amp;&amp; cat &amp;&amp; printf &#34;\033&amp;l0H&#34; &amp;&amp;
    exit 0
fi

exit 2</pre></div></div><div class=paragraph><p>最後に、<code>if</code> 項目を通して、LPD にこのフィルタを教えてやる必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/ifhp:</pre></div></div><div class=paragraph><p>これでおしまいです。<code>lpr plain.text</code> とか <code>lpr whatever.ps</code> と入力してみましょう。どちらも正常に印字されるはずです。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>日本語を印字する場合は、 日本語対応の Ghostscript が必要です。日本語対応版の Ghostscript も Ports Collection に入っています。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=printing-advanced-convfilters>9.4.1.4. 変換フィルタ<a class=anchor href=#printing-advanced-convfilters></a></h5><div class=paragraph><p>「<a href=#printing-simple>プリンタ設定導入編</a>」 に書かれた簡単な設定が完了したら、最初に、 やってみたいと思うことは、多分 (プレイン ASCII テキストに加えて) 好みのファイル形式のための変換フィルタをインストールすることでしょう。</p></div><div class=sect5><h6 id=_なぜ変換フィルタをインストールするのか>9.4.1.4.1. なぜ、変換フィルタをインストールするのか?<a class=anchor href=#_なぜ変換フィルタをインストールするのか></a></h6><div class=paragraph><p>変換フィルタによって、 様々な種類のファイルを印字することが簡単になります。たとえば、TeX 組版システムでたくさんの仕事をしたと仮定しましょう。 そして、PostScript® プリンタが接続 されているとします。 すると、TeX で DVI ファイルを作成する度に、DVI ファイルを印字するために、 これを PostScript® ファイルに変換する必要があります。 このコマンドは次のようになるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% dvips seaweed-analysis.dvi
% lpr seaweed-analysis.ps</code></pre></div></div><div class=paragraph><p>DVI ファイル用の変換フィルタがインストールしてあると、 LPD に変換を肩代わりさせることで毎回毎回 おこなわなければならなかった面倒な変換作業を省くことができます。 つまり、DVI を生成したら、 次のようなコマンドを入力するだけで、これが印字されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-d</span> seaweed-analysis.dvi</code></pre></div></div><div class=paragraph><p>LPD に DVI ファイルの変換をさせるためには、 <code>-d</code> オプション を指定します。 変換オプションのリストは「<a href=#printing-lpr-options-format>整形と変換に関するオプション</a>」 に載せてあります。</p></div><div class=paragraph><p>変化のオプションのそれぞれをプリンタに サポートさせるためには、 <em>変換フィルタ</em>をインストールし、 そのパス名を <span class=filename>/etc/printcap</span> の中で指定しなくてはなりません。変換フィルタは、 プレインテキストを印字する代わりに、フィルタはファイルを プリンタが理解できる形式に変換するところを除けば、 「プリンタの簡単な設定」で説明したテキストファイル (「<a href=#printing-textfilter>テキストフィルタのインストール</a>」 を見て下さい) に似ています。</p></div></div><div class=sect5><h6 id=_どの変換フィルタをインストールすべきか>9.4.1.4.2. どの変換フィルタをインストールすべきか?<a class=anchor href=#_どの変換フィルタをインストールすべきか></a></h6><div class=paragraph><p>使いたいと思う変換フィルタをインストールすべきです。 DVI のデータを頻繁に印字するならば、DVI 変換フィルタ をインストールするのが適切でしょう。印字しなくてはなら ない troff を大量に抱えている場合は、多分、 troff フィルタが欲しくなるはずです。</p></div><div class=paragraph><p>次の表は、LPD で動作するフィルタと、 <span class=filename>/etc/printcap</span> ファイルでのエントリする項目、そして、 <code>lpr</code> コマンドで呼び出す方法をまとめたものです。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">ファイル形式</th><th class="tableblock halign-left valign-top">/etc/printcap項目</th><th class="tableblock halign-left valign-top">lpr オプション</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cifplot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-c</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DVI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>df</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-d</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>plot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-g</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ditroff</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>nf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-n</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>FORTRAN text</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-f</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>troff</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>tf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-f</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>raster</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>vf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-v</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>プレインテキスト</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>if</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>なし、<code>-p</code>、または <code>-l</code></p></td></tr></tbody></table><div class=paragraph><p>先の例のように、<code>lpr -d</code> を使うためには、出力先のプリンタの <span class=filename>/etc/printcap</span> 内のエントリで、 <code>df</code> 項目が必要であることが分かります。</p></div><div class=paragraph><p>反論はあるかも知れませんが、FORTRAN テキストや plot のような形式は、多分、廃れてていくでしょう。 あなたのサイトで、自前のフィルタをインストールするだけで、 プリントオプションのいくつか、あるいは、 全部に新しい意味を与えることができます。たとえば、 Printerleaf ファイル (Interleaf デスクトップパブリッシングプログラムによるファイル) を直接印字したいとします。 そして、Printerleaf 用の変換フィルタを <code>gf</code> 項目で 指定したパスにインストールすれば、<code>lpr -g</code> の意味は "Printerleaf ファイルを印字する" 意味だとユーザに教えることができます。</p></div></div><div class=sect5><h6 id=_変換フィルタのインストール>9.4.1.4.3. 変換フィルタのインストール<a class=anchor href=#_変換フィルタのインストール></a></h6><div class=paragraph><p>変換フィルタは FreeBSD の基本システムのインストールとは別にインストールするプログラムなので、 変換フィルタは、 <span class=filename>/usr/local</span> ディレクトリの下に置くべきでしょう。 フィルタは LPD だけが実行する特別なプログラム、 すなわち、一般ユーザが実行する必要すらないプログラムなので、 <span class=filename>/usr/local/libexec</span> ディレクトリに置くのが普通です。</p></div><div class=paragraph><p>変換フィルタを使用可能にするためには、 <span class=filename>/etc/printcap</span> の目的のプリンタの適切な項目に フィルタがあるパス名を指定します。</p></div><div class=paragraph><p>DVI 変換フィルタをプリンタ <code>bamboo</code> のエントリに加えてみましょう。プリンタ <code>bamboo</code> の <code>df</code> 項目を新たに加えた <span class=filename>/etc/printcap</span> ファイルの例を以下に再掲します。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - added df filter for bamboo
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>DVI フィルタは <span class=filename>/usr/local/libexec/psdf</span> という 名前のシェルスクリプトです。 このスクリプトは次のようになっています。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psdf - DVI to PostScript printer filter
#  Installed in /usr/local/libexec/psdf
#
#  Invoked by lpd when user runs lpr -d
#
exec /usr/local/bin/dvips -f | /usr/local/libexec/lprps &#34;$@&#34;</pre></div></div><div class=paragraph><p>このスクリプトでは、<code>dvips</code> をフィルタモード (引数 <code>-f</code>) で、 標準入力上で起動しています。標準入力は印字するジョブです。 それから、PostScript® プリンタ用フィルタ <code>lprps</code> (これについては「<a href=#printing-advanced-if-conversion>プレインテキストのジョブを PostScript® プリンタで印字する</a>」 を参照してください) を LPD に与えられた引数を付けて起動します。 <code>lprps</code> はこれらの引数を印字されたページ分の課金をおこなうために使われます。</p></div></div><div class=sect5><h6 id=_変換フィルタのその他の例>9.4.1.4.4. 変換フィルタのその他の例<a class=anchor href=#_変換フィルタのその他の例></a></h6><div class=paragraph><p>変換フィルタのインストールには決まったステップがないので、 この節では、例をもっと挙げることにします。 これを自分でフィルタを作る際のガイドにしてください。 適当な例があったら、それをそのまま使ってください。</p></div><div class=paragraph><p>次のスクリプト例は、Hewlett Packard LaserJet III-Si のための、raster (ええと・・実は、GIF ファイル) 用の変換フィルタです。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  hpvf - Convert GIF files into HP/PCL, then print
#  Installed in /usr/local/libexec/hpvf

PATH=/usr/X11R6/bin:$PATH; export PATH

giftopnm | ppmtopgm | pgmtopbm | pbmtolj -resolution 300 \
    &amp;&amp; exit 0 \
    || exit 2</pre></div></div><div class=paragraph><p>ここでは、GIF ファイルから PNM (portable anymap) 形式に変換し、次に PGM (portable graymap) 形式に変換してから、 LaserJet/PCL-互換データに変換しています。</p></div><div class=paragraph><p>上記のフィルタを使うプリンタのためのエントリを付け加えた <span class=filename>/etc/printcap</span> ファイルは次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host orchid
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sh:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/hpif:\
        :vf=/usr/local/libexec/hpvf:</pre></div></div><div class=paragraph><p>次のスクリプトは、PostScript® プリンタ <code>bamboo</code> のための groff 組版システムの troff データのための変換フィルタです。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  pstf - Convert groff&#39;s troff data into PS, then print.
#  Installed in /usr/local/libexec/pstf
#
exec grops | /usr/local/libexec/lprps &#34;$@&#34;</pre></div></div><div class=paragraph><p>上記のスクリプトではプリンタとの通信をおこなうため、 <code>lprps</code> をまた利用しています。 プリンタがパラレルポートに接続されている場合は、代わりに、 次のスクリプトを使うかもしれません。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  pstf - Convert groff&#39;s troff data into PS, then print.
#  Installed in /usr/local/libexec/pstf
#
exec grops</pre></div></div><div class=paragraph><p>これで完成しました。次に、フィルタを使用可能にするため に <span class=filename>/etc/printcap</span> に加える必要があるエントリを示します。</p></div><div class="literalblock programlisting"><div class=content><pre>:tf=/usr/local/libexec/pstf:</pre></div></div><div class=paragraph><p>次の例をみたら、FORTRAN のベテランは赤面するかもしれません。 この FORTRAN テキストフィルタは、 プレインテキストを直接印字できるすべてのプリンタで利用できます。 このフィルタをプリンタ <code>teak</code> にインストールすることにしましょう。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# hprf - FORTRAN text filter for LaserJet 3si:
# Installed in /usr/local/libexec/hprf
#

printf &#34;\033&amp;k2G&#34; &amp;&amp; fpr &amp;&amp; printf &#34;\033&amp;l0H&#34; &amp;&amp; exit 0
exit 2</pre></div></div><div class=paragraph><p>そして、このフィルタを使用可能にするため、以下の行を <span class=filename>/etc/printcap</span> のプリンタ <code>teak</code> のエントリに加えます。</p></div><div class="literalblock programlisting"><div class=content><pre>:rf=/usr/local/libexec/hprf:</pre></div></div><div class=paragraph><p>これが最後の、そして、若干複雑な例です。前に紹介した LaserJet プリンタ <code>teak</code> に、DVI フィルタを加える ことにしましょう。最初に、 簡単な部分をおこないます。すなわち、DVI フィルタの位置を <span class=filename>/etc/printcap</span> に書き加えます。</p></div><div class="literalblock programlisting"><div class=content><pre>:df=/usr/local/libexec/hpdf:</pre></div></div><div class=paragraph><p>さて、難しい部分であるフィルタの作成をおこないます。 このために、DVI から LaserJet/PCL への変換プログラムが必要です。FreeBSD の Ports Collection (<a href=./#ports>Ports Collection</a> を参照してください) には、それがあります。 <a class=package href=https://cgit.freebsd.org/ports/tree/dvi2xx/>dvi2xx</a> というのがその port の名前です。 これをインストールすると、必要なプログラム <code>dvilj2p</code> が使えます。このプログラムは DVI を LaserJet IIp、LaserJet III、そして LaserJet 2000 の互換コードへ変換してくれます。</p></div><div class=paragraph><p><code>dvilj2p</code> はフィルタ <code>hpdf</code> を極めて複雑にしています。 なぜなら、<code>dvilj2p</code> は標準入力からデータを読み込むことができないからです。 このプログラムを働かせるためには、ファイル名が必要です。 もっと悪いことに、ファイル名は <span class=filename>.dvi</span> で終わっている必要があり、標準入力の代わりに、 <span class=filename>/dev/fd/0</span> を使うのは問題があります。 この問題は、(<span class=filename>.dvi</span> で終わる) 一時的なファイル名から<span class=filename>/dev/fd/0</span> に (シンボリックな) リンクを張る ことで回避することができます。これで、 <code>dvilj2p</code> に強制的に標準入力からデータを読み込ませることができます。</p></div><div class=paragraph><p>もう1つの問題は、一時的なリンクを張るために <span class=filename>/tmp</span> ディレクトリを使うことができないという事実です。 シンボリックリンクはユーザ、グループが <code>bin</code> であるユーザに所有されています。フィルタはユーザ <code>daemon</code> として起動します。そして、 <span class=filename>/tmp</span> ディレクトリはスティッキービットが立っています。 フィルタはリンクを作ることができます。しかし、 リンクは別のユーザに所有されているため、 作業が終了したとき、このリンクを削除することができません。</p></div><div class=paragraph><p>その代わりに、シンボリックリンクは現在の作業ディレクトリ、 すなわち、スプーリングディレクトリ (<span class=filename>/etc/printcap</span> の <code>sd</code> 項目で指定する) に作ることにします。 フィルタが作業するにはここの場所は完璧な場所で、なぜなら、 特に、スプーリングディレクトリのディ スクの空き容量は (ときどき) <span class=filename>/tmp</span> ディレクトリよりもたくさんあるからです。</p></div><div class=paragraph><p>以下に示すのが最後のフィルタです。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  hpdf - Print DVI data on HP/PCL printer
#  Installed in /usr/local/libexec/hpdf

PATH=/usr/local/bin:$PATH; export PATH

#
#  Define a function to clean up our temporary files.  These exist
#  in the current directory, which will be the spooling directory
#  for the printer.
#
cleanup() {
   rm -f hpdf$$.dvi
}

#
#  Define a function to handle fatal errors: print the given message
#  and exit 2.  Exiting with 2 tells LPD to do not try to reprint the
#  job.
#
fatal() {
    echo &#34;$@&#34; 1&gt;&amp;2
    cleanup
    exit 2
}

#
#  If user removes the job, LPD will send SIGINT, so trap SIGINT
#  (and a few other signals) to clean up after ourselves.
#
trap cleanup 1 2 15

#
#  Make sure we are not colliding with any existing files.
#
cleanup

#
#  Link the DVI input file to standard input (the file to print).
#
ln -s /dev/fd/0 hpdf$$.dvi || fatal &#34;Cannot symlink /dev/fd/0&#34;

#
#  Make LF = CR+LF
#
printf &#34;\033&amp;k2G&#34; || fatal &#34;Cannot initialize printer&#34;

#
#  Convert and print.  Return value from dvilj2p does not seem to be
#  reliable, so we ignore it.

#
dvilj2p -M1 -q -e- dfhp$$.dvi

#
#  Clean up and exit
#
cleanup
exit 0</pre></div></div></div><div class=sect5><h6 id=printing-advanced-autoconv>9.4.1.4.5. 自動変換: その他の変換フィルタ<a class=anchor href=#printing-advanced-autoconv></a></h6><div class=paragraph><p>ここまでに述べてきたフィルタによって、 印字環境の能率が上がったことと思います。しかし、 これはどのフィルタを使うかを (<a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> のコマンドライン上で) ユーザが指定しなくてはならないという代価を支払って実現されています。 コンピュータの事情にあまり詳しくないユーザにとって、 フィルタのオプションを指定させられるということは いらいらさせられるものになるでしょう。更に悪いことに、 間違ったフィルタオプションを指定されると、 間違った形式のファイルがそのフィルタに適用されることになり、 その結果、何百枚もの紙を吐き出すことになるかもしれません。</p></div><div class=paragraph><p>そのような結果になるならば、 変換フィルタをインストールするよりもむしろ、 テキストフィルタ (これがデフォルトフィルタなので) に印字するよう要求されたファイルの形式を検出させ、自動的に、 適切な変換フィルタを起動するようにしたいと思うかもしれません。 ここでは <code>file</code> コマンドのようなツールを役立たせることができます。 もちろん、<em>いくつかの</em> ファイル形式の違いを見分けることは難しいことでしょう。 そして、もちろん、それらのファイルに対しては、 変換フィルタを提供するだけで済ますこともできるのです。</p></div><div class=paragraph><p>FreeBSD Ports Collection には、<code>apsfilter</code> (<a class=package href=https://cgit.freebsd.org/ports/tree/print/apsfilter/>print/apsfilter</a>) と呼ばれる自動変換をおこなうテキストフィルタがあります。 このフィルタは プレインテキスト、PostScript®, DVI など、ほとんどすべてのファイル形式を検出し、適当な変換をおこなった後、 データを印字することができます。</p></div></div></div><div class=sect4><h5 id=printing-advanced-of>9.4.1.5. 出力フィルタ<a class=anchor href=#printing-advanced-of></a></h5><div class=paragraph><p>LPD スプーリングシステムでは、 ここまでにまだ取り上げていないフィルタ形式、 出力フィルタをサポートしています。出力フィルタは、 テキストフィルタのように、 プレインテキストのみを印字するために意図されたものですが、 非常に簡単化されています。テキストフィルタを用いずに、 出力フィルタを使っている場合は、次のようになります。</p></div><div class=ulist><ul><li><p>LPD はジョブ中の各ファイルに一度ではなく、 ジョブ全体に対して一度だけ出力フィルタを起動します。</p></li><li><p>LPD は出力フィルタに対し、 ジョブ中のファイルの先頭や末尾を特定するための対策を 一切おこなっていません。</p></li><li><p>LPD はユーザのログイン名やホスト名をフィルタに渡しません。 したがって、課金の処理をおこなうことは考えていません。 実際、出力フィルタには、以下2つの引数しか与えられません。</p><div class=paragraph><p><code>filter-name -w<em>width</em> -l<em>length</em></code></p></div><div class=paragraph><p>ここで、<em>width</em> は対象となるプリンタの <code>pw</code> 項目、 <em>length</em> は <code>pl</code> 項目に指定された数です。</p></div></li></ul></div><div class=paragraph><p>出力フィルタの簡便さに誘惑されてはいけません。もし、 ジョブ中のそれぞれのファイルに別のページ番号を付加しようとしても、 出力フィルタは<em>うまく動作しないでしょう</em>。 そのような動作を期待しているならば、 (入力フィルタとしても知られている) テキストフィルタを使ってください。 詳しくは、「<a href=#printing-textfilter>テキストフィルタのインストール</a>」をご覧ください。 さらに、出力フィルタは、実のところ、 <em>もっと複雑</em>になっています。まず、 特殊なフラグ文字を検出するために、 フィルタに送られてくるバイトストリームを検査する必要があります。 また、LPD に代わって、 自分自身にシグナルを送らなければなりません。</p></div><div class=paragraph><p>しかしながら、ヘッダページの印字をおこないたくて、 エスケープシーケンスやヘッダページを印字できるようにするその他の初期化文字列を送信する必要がある場合は、 出力ファイルが<em>必要</em>です。 (しかし、 ヘッダページを要求したユーザに対して課金しようとするのもまた無駄なことです。 LPD は出力フィルタにユーザやホストの情報を渡しません)。</p></div><div class=paragraph><p>1 台のプリンタに対し、LPD では出力フィルタとテキストやその他のフィルタを両方使うことができます。 このような場合、LPD はヘッダページ (「<a href=#printing-advanced-header-pages>ヘッダページ</a>」 を参照してください) だけを印字させるために、出力フィルタを起動させます。 それから LPD では、出力フィルタに 2 バイトの文字 (ASCII 031 の次に ASCII 001) を送ることで、 出力フィルタが<em>自分自身を停止する</em>ことを期待しています。 2 バイト (031, 001) が出力フィルタに送られたとき、 出力フィルタは自分自身にシグナル <code>SIGSTOP</code> を送ることによって停止するはずです。 LPD がその他のフィルタを動かし終わると、 出力フィルタにシグナル <code>SIGCONT</code> を送って、出力フィルタを再起動します。</p></div><div class=paragraph><p>出力フィルタがあり、 テキストフィルタが<em>ない</em>場合、 LPD はプレインテキストジョブを扱う場合に、 出力フィルタを使います。前述したように、出力フィルタでは、 ジョブ中の各ファイルの間に FORM FEED 文字や紙を送る他の文字を入れることはしません。 この動作は多分、 あなたが求めているものとは<em>異なっている</em>でしょう。 ほとんどの場合において、テキストフィルタが必要なはずです。</p></div><div class=paragraph><p>プログラム <code>lpf</code> は、 テキストフィルタの項で既に紹介しましたが、 出力フィルタとしても動作させることができます。もし、 簡便で極悪な出力フィルタが必要で、かつ、 バイトストリームを検査したりシグナルを送るコードを書きたくないときには、 <code>lpf</code> をお試しください。 あるいは、プリントが要求する初期化コードを送るために、 <code>lpf</code> をシェルスクリプトに包んで使うこともできます。</p></div></div><div class=sect4><h5 id=printing-advanced-lpf>9.4.1.6. テキストフィルタ <code>lpf</code><a class=anchor href=#printing-advanced-lpf></a></h5><div class=paragraph><p>プログラム <span class=filename>/usr/libexec/lpr/lpf</span> は、 FreeBSD の バイナリ配布に付属しているテキストフィルタ (入力フィルタ) で、出力を字下げしたり (<code>lpr -i</code> でジョブが入力さ れたとき)、 文字を未処理のままプリンタに送ったり (<code>lpr -l</code> でジョブが入力されたとき)、 ジョブ中のバックスペースやタブの印字位置を調節したり、 印字したページに対して課金したりすることができます。また、 このフィルタは出力フィルタとしても動作させることができます。</p></div><div class=paragraph><p><code>lpf</code> フィルタは多くの印字環境において使用することに適しています。 このフィルタには、プリンタに初期化文字列を送る機能はありませんが、 必要とされる初期化をおこない、それから <code>lpf</code> を実行させるためのシェルスクリプトを作成するのはたやすいことです。</p></div><div class=paragraph><p><code>lpf</code> に対して、 印字ページへの課金を正確におこなわせるためには、 <span class=filename>/etc/printcap</span> ファイルの中の <code>pw</code> と <code>pl</code> の項目に正確な値を入れておく必要があります。これらの値は、 どのくらいの量のテキストがページにフィットするか、また、 ユーザのジョブが何ページあるのかを調べるために使われます。 プリンタの課金についての詳しい情報については、「<a href=#printing-advanced-acct>プリンタの利用に対する課金</a>」をご覧ください。</p></div></div></div><div class=sect3><h4 id=printing-advanced-header-pages>9.4.2. ヘッダページ<a class=anchor href=#printing-advanced-header-pages></a></h4><div class=paragraph><p>あなたが管理するシステムのユーザが <em>たくさん</em>おり、 ユーザ全員が様々なプリンタを使用する場合、多分、 必要悪である<em>ヘッダページ</em>を 印字させることを検討したいと思うかもしれません。</p></div><div class=paragraph><p>ヘッダページは、<em>バナー</em> とか <em>バーストページ</em> としても知られていますが、 出力されたジョブが誰によるものなのかを特定させる働きがあります。 印字結果の山の中において、 ユーザのジョブによって印字された本物のドキュメント部分よりも際立たせるために、 ヘッダページは、通常、多分、縁が装飾されている大きな太文字で印字されます。 ヘッダページにより、 ユーザは自分が出したジョブがどこにあるのかをすばやく見つけることができます。 ヘッダページの欠点は、明らかに、すべてのジョブに対して、 紙が 1 枚余分に印字されるということです。 この紙の有効期間は短く、2 ～ 3 分も続きません。最終的に、 これらの紙は再利用紙入れの中かくずの山に入れられることでしょう (ヘッダページはジョブ中の各ファイル毎に印字されるのではなく、 ジョブ毎に印字されるということに注意してください。したがって、 紙の消費はそれほどひどくはないかもしれません)。</p></div><div class=paragraph><p><em>もし</em>、 プリンタがプレインテキストを直接印字できるならば、LPD システムは印字物に対して自動的にヘッダページを付けることができます。 PostScript® プリンタを使っている場合は、 ヘッダページを生成する外部プログラムが必要になります。これについては、 「<a href=#printing-advanced-header-pages-ps>PostScript® プリンタでのヘッダページ</a>」をご覧ください。</p></div><div class=sect4><h5 id=printing-advanced-header-pages-enabling>9.4.2.1. ヘッダページの印字を許可する<a class=anchor href=#printing-advanced-header-pages-enabling></a></h5><div class=paragraph><p>「<a href=#printing-simple>プリンタ設定導入編 </a>」節では、<span class=filename>/etc/printcap</span> ファイルの <code>sh</code> (''suppress header'' : "ヘッダを供給しない" という意味) を指定して、 ヘッダページの印字を止めていました。 プリンタでのヘッダページの印字を許可するには、 <code>sh</code> 項目を取り除くだけでよいのです。</p></div><div class=paragraph><p>とても簡単そうに見えるけど、本当かな?</p></div><div class=paragraph><p>それは本当です。 プリンタに初期化文字列を送るための 出力フィルタを用意しなくてはならないかもしれません。次に、Hewlett Packard PCL 互換プリンタの例を挙げます。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  hpof - Output filter for Hewlett Packard PCL-compatible printers
#  Installed in /usr/local/libexec/hpof

printf &#34;\033&amp;k2G&#34; || exit 2
exec /usr/libexec/lpr/lpf</pre></div></div><div class=paragraph><p><code>of</code> 項目に出力フィルタのパス名を指定してください。 詳細については、「<a href=#printing-advanced-of>出力フィルタ</a>」節 をご覧ください。</p></div><div class=paragraph><p>次に、以前紹介したプリンタ <code>teak</code> のための <span class=filename>/etc/printcap</span> ファイルの例を示します。ここでは、 ヘッダページの印字を許可し、上記の出力フィルタを追加しました。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host orchid
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/hpif:\
        :vf=/usr/local/libexec/hpvf:\
        :of=/usr/local/libexec/hpof:</pre></div></div><div class=paragraph><p>さて、ユーザが <code>teak</code> からジョブを印字させたとき、 それぞれのジョブ毎にヘッダページが印字されます。 もし、ユーザが印字物を探すのに時間を費やしたいと思うなら、 <code>lpr -h</code> によってジョブを入力することで、 ヘッダページの印字を止めることができます。 これ以外の <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> のオプションについては、 「<a href=#printing-lpr-options-misc>ヘッダページ用オプション</a>」節をご覧ください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>LPD では、ヘッダページの最後に、 FORM FEED 文字が印字されます。 プリンタに紙排出をさせるために、別な文字、 もしくは、別な文字列が利用されている場合は、 <span class=filename>/etc/printcap</span> 中の <code>ff</code> 項目で指定することができます。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=printing-advanced-header-pages-controlling>9.4.2.2. ヘッダページを制御する<a class=anchor href=#printing-advanced-header-pages-controlling></a></h5><div class=paragraph><p>ヘッダページの印字が許可されていると、LPD は <em>長いヘッダ</em>を作ります。これには、 紙全面に大きな文字でユーザ名、ホスト名、 ジョブ名が書かれています。次に、このヘッダページの例を示 します (<code>kelly</code> がジョブ名 "outline" を <code>rose</code> というホストから印字 された場合)。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>      k                   ll       ll
      k                    l        l
      k                    l        l
      k   k     eeee       l        l     y    y
      k  k     e    e      l        l     y    y
      k k      eeeeee      l        l     y    y
      kk k     e           l        l     y    y
      k   k    e    e      l        l     y   yy
      k    k    eeee      lll      lll     yyy y
                                               y
                                          y    y
                                           yyyy

                                   ll
                          t         l        i
                          t         l
       oooo    u    u   ttttt       l       ii     n nnn     eeee
      o    o   u    u     t         l        i     nn   n   e    e
      o    o   u    u     t         l        i     n    n   eeeeee
      o    o   u    u     t         l        i     n    n   e
      o    o   u   uu     t  t      l        i     n    n   e    e
       oooo     uuu u      tt      lll      iii    n    n    eeee

      r rrr     oooo     ssss     eeee
      rr   r   o    o   s    s   e    e
      r        o    o    ss      eeeeee
      r        o    o      ss    e
      r        o    o   s    s   e    e
      r         oooo     ssss     eeee

                                              Job:  outline
                                              Date: Sun Sep 17 11:04:58 1995</code></pre></div></div><div class=paragraph><p>LPD はこのテキストの終わりに FORM FEED 文字を加えます ので、ジョブは新しいページから開始されます (ただし、 <span class=filename>/etc/printcap</span> で出力先のプリンタのエントリに <code>sf</code> (suppress form feeds) が指定されているときはこ の限りではありません)。</p></div><div class=paragraph><p>お望みならば、LPD に<em>短いヘッダページ</em>を出力させることもできます。 この場合は、 <span class=filename>/etc/printcap</span> ファイルの中で <code>sb</code> (short banner) を指定してください。 ヘッダページは次のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>rose:kelly  Job: outline  Date: Sun Sep 17 11:07:51 1995</code></pre></div></div><div class=paragraph><p>デフォルトでは、LPD はヘッダページを最初に印字し、次にジョブの印字をおこないます。 この順番を逆にするときは、 <span class=filename>/etc/printcap</span> で <code>hl</code> (header last) を指定してください。</p></div></div><div class=sect4><h5 id=printing-advanced-header-pages-accounting>9.4.2.3. ヘッダページに対する課金<a class=anchor href=#printing-advanced-header-pages-accounting></a></h5><div class=paragraph><p>LPD に備わっているヘッダページ出力機能を使うと、 入力されたジョブに対して課金をおこなうことができても、 ヘッダページは<em>無料</em>で提供しなくてはならない、 という特有のやり方を強要されます。</p></div><div class=paragraph><p>なぜでしょうか。</p></div><div class=paragraph><p>出力フィルタは単なる外部プログラムなので、 課金をするための制御をおこなうとすれば、 それはヘッダページを印字するときですが、出力フィルタには、 <em>ユーザ名とホスト名</em> の情報や課金情報を格納するファイルがどれな のかということが知らされません。それゆえ、出力ファイルには、 誰にプリンタ利用の課金をおこなえばよいのかが分からないのです。 テキストフィルタやその他の変換フィルタ (これらのフィルタはユーザやホストの情報が知らされます) が出力ページの枚数に "1 ページ分水増しする" だけでは十分ではありません。 なぜなら、ユーザは <code>lpr -h</code> に よってヘッダページの出力を止めることができるからです。 やみくもに 1 ページを水増しすると、 印字されてもいないヘッダページに対する 料金をとることになります。基本的に、<code>lpr -h</code> は環境に優しい心を持つユーザに好まれるオプションですが、 これを使うように奨励することもできません。</p></div><div class=paragraph><p>各々のフィルタに独自のヘッダページを生成させる (その結果、ヘッダページに課金することができる) という方法<em>でも十分であるとはいえません</em>。 この場合、LPD はフィルタに <code>-h</code> の情報を送りませんので、<code>lpr -h</code> によってヘッダページを印字しないオプションを選択したとしても、 依然としてヘッダページは印字され、 その分の課金がおこなわれてしまいます。</p></div><div class=paragraph><p>では、どのような選択肢があるのでしょうか。</p></div><div class=paragraph><p>ヘッダページへの課金に関しては、 次のことができます。</p></div><div class=ulist><ul><li><p>LPD のやり方を受け入れ、 ヘッダページは無料とする。</p></li><li><p>LPRng などの LPD の代替品をインストールする。 LPD と入れ替えが可能な他のスプーリングソフトウェアに関しては、 <a href=#printing-lpd-alternatives>標準スプーラの代替品</a> をご覧ください。</p></li><li><p><em>スマートな</em> 出力フィルタを作成する。通常、 出力フィルタはプリンタを初期化するか、 単純な文字列変換をする程度の働きしかしません。 (テキスト (入力) フィルタがない場合) 出力フィルタはヘッダページとプレインテキストの印字をおこなうのに適しています。 プレインテキストを印字するためのテキストフィルタがない場合、 LPD はヘッダページを印字するためだけの目的で出力フィルタを起動します。 そして、LPD が生成するヘッダページのテキストを解析することにより、 出力フィルタはヘッダページに課金するために必要なユーザ名と ホスト名を取得することができます。この方式の唯一の問題点は、 出力フィルタは課金情報を格納するデータファイルの名前を知ることが できないということです (<code>af</code> 項目で指定されたファイル名は 出力ファイルに渡されません)。しかし、既知の 名前の課金データファイルを使うのならば、 その名前を出力フィルタのプログラム中に埋め込むことができます。 解析の手順を簡単にするためには、 <span class=filename>/etc/printcap</span> で <code>sh</code> 項目 (短いヘッダを指定) を使うとよいでしょう。 そしてまた、 ここまでの方法は少なからぬトラブルを生じさせるかもしれません。 そうなれば、もちろんユーザはヘッダページを無料で 提供してくれる気前のよいシステム管理者に感謝することでしょう。</p></li></ul></div></div><div class=sect4><h5 id=printing-advanced-header-pages-ps>9.4.2.4. PostScript® プリンタでのヘッダページ<a class=anchor href=#printing-advanced-header-pages-ps></a></h5><div class=paragraph><p>これまでに述べたように、LPD ではプレインテキストのヘッダページをたくさんのプリンタに合うように生成することができます。 残念ながら、PostScript® プリンタは、 プレインテキストを直接印字することができません。ですから、 LPD のヘッダページ機能はまったく、 あるいはほとんどの場合、役に立ちません。</p></div><div class=paragraph><p>ヘッダページを出力するための自明な方法の1つに、 すべての変換フィルタとテキストフィルタにヘッダページを生成させる方法があります。 フィルタは、 適切なヘッダページを生成するために、 ユーザ名とホスト名の引数を使うべきです。この方法の欠点は、いつでも、 <code>lpr -h</code> によってジョブが入力された場合でさえも、 ヘッダページが印字されるということです。</p></div><div class=paragraph><p>この方法で試してみましょう。次のスクリプトは、3 つの引数 (ユーザ のログイン名、ホスト名、ジョブ名) をとり、簡単な PostScript® 用 のヘッダページを生成します。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  make-ps-header - make a PostScript header page on stdout
#  Installed in /usr/local/libexec/make-ps-header
#

#
#  These are PostScript units (72 to the inch).  Modify for A4 or
#  whatever size paper you are using:
#
page_width=612
page_height=792
border=72

#
#  Check arguments
#
if [ $# -ne 3 ]; then
    echo &#34;Usage: `basename $0` &lt;user&gt; &lt;host&gt; &lt;job&gt;&#34; 1&gt;&amp;2
    exit 1
fi

#
#  Save these, mostly for readability in the PostScript, below.
#
user=$1
host=$2
job=$3
date=`date`

#
#  Send the PostScript code to stdout.
#
exec cat &lt;&lt;EOF
%!PS

%
%  Make sure we do not interfere with user&#39;s job that will follow
%
save

%
%  Make a thick, unpleasant border around the edge of the paper.
%
$border $border moveto
$page_width $border 2 mul sub 0 rlineto
0 $page_height $border 2 mul sub rlineto
currentscreen 3 -1 roll pop 100 3 1 roll setscreen
$border 2 mul $page_width sub 0 rlineto closepath
0.8 setgray 10 setlinewidth stroke 0 setgray

%
%  Display user&#39;s login name, nice and large and prominent
%
/Helvetica-Bold findfont 64 scalefont setfont
$page_width ($user) stringwidth pop sub 2 div $page_height 200 sub moveto
($user) show

%
%  Now show the boring particulars
%
/Helvetica findfont 14 scalefont setfont
/y 200 def
[ (Job:) (Host:) (Date:) ] {
200 y moveto show /y y 18 sub def
} forall

/Helvetica-Bold findfont 14 scalefont setfont
/y 200 def
[ ($job) ($host) ($date) ] {
        270 y moveto show /y y 18 sub def
} forall

%
%  That is it
%
restore
showpage
EOF</pre></div></div><div class=paragraph><p>そして、変換フィルタやテキストフィルタがそれぞれ、 最初にこのスクリプトを起動することで、 ヘッダページが出力され、それから、 ユーザのジョブの印字をおこないます。次に、 このドキュメントの始めのほうで紹介した DVI 変換フィルタを、 ヘッダページを印字するように変更したものを示します。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psdf - DVI to PostScript printer filter
#  Installed in /usr/local/libexec/psdf
#
#  Invoked by lpd when user runs lpr -d
#

orig_args=&#34;$@&#34;

fail() {
    echo &#34;$@&#34; 1&gt;&amp;2
    exit 2
}

while getopts &#34;x:y:n:h:&#34; option; do
    case $option in
        x|y)  ;; # Ignore
        n)    login=$OPTARG ;;
        h)    host=$OPTARG ;;
        *)    echo &#34;LPD started `basename $0` wrong.&#34; 1&gt;&amp;2
              exit 2
              ;;
    esac
done

[ &#34;$login&#34; ] || fail &#34;No login name&#34;
[ &#34;$host&#34; ] || fail &#34;No host name&#34;

( /usr/local/libexec/make-ps-header $login $host &#34;DVI File&#34;
  /usr/local/bin/dvips -f ) | eval /usr/local/libexec/lprps $orig_args</pre></div></div><div class=paragraph><p>このフィルタがユーザ名やホスト名を決定するために 引数リストをどのように解析しなくてはならないかという点に注意してください。 この解析方法は他の変換フィルタに対しても同様です。 しかしながら、テキストフィルタについては、 引数の設定が少し異なっています (これについては、「<a href=#printing-advanced-filters>フィルタはどのように機能しているか</a>」 をご覧ください)。</p></div><div class=paragraph><p>前述の通り、上記の手法は、極めて単純なのにも関らず、 <code>lpr</code> で "ヘッダページを印字しない" オプション (<code>-h</code> オプション) が使えなくなっています。 ユーザが森林資源を (あるいは、 ヘッダページが課金されているならば、その僅かな金額を)、 節約したいと望んでいる場合でも、 すべてのフィルタがすべてのジョブ毎にヘッダページを印字 することになっているので、節約することはできません。</p></div><div class=paragraph><p>ジョブ毎に印字されるヘッダページを ユーザが抑制できるようにするためには、「<a href=#printing-advanced-header-pages-accounting>ヘッダページに対する課金</a>」で紹介したトリックを 使う必要があります。すなわち、LPD が生成するヘッダページの解析をおこない、PostScript® 版のヘッダページを出力させる出力フィルタを作るのです。 この場合、ユーザが <code>lpr -h</code> でジョブを入力すると、 LPD はヘッダページを生成しなくなり、また、 出力フィルタも起動されません。そうでないならば、 作成した出力フィルタが LPD からのテキストを読み込み、ヘッダページを印字する適当な PostScript® のコードがプリンタに送られるでしょう。</p></div><div class=paragraph><p>PostScript® プリンタがシリアルポートに接続されている場合、 出力フィルタとして <code>lprps</code> を、 上記の動作をおこなうものとして <code>psof</code> を使うことができます。ただし、<code>psof</code> はヘッダページに対して課金をおこないませんので注意してください。</p></div></div></div><div class=sect3><h4 id=printing-advanced-network-printers>9.4.3. リモートプリンタからの出力<a class=anchor href=#printing-advanced-network-printers></a></h4><div class=paragraph><p>FreeBSD では、ネットワーク越しの印字、すなわち、 ジョブをリモートプリンタに送ることをサポートしています。 リモートプリンタからの出力をするには、一般に、 次の 2 つを参照してください。</p></div><div class=ulist><ul><li><p>リモートホストに接続されたプリンタにアクセスする方法。 プリンタがあるホストのシリアル、 または、パラレルインタフェースに接続されている場合、 ネットワーク上の他のホストからこのプリンタにアクセスできるように LPD を設定します。「<a href=#printing-advanced-network-rm>リモートホストに 接続されたプリンタ</a>」 でどのようにするかを説明します。</p></li><li><p>ネットワークに直接接続されているプリンタにアクセスする方法。 プリンタに、旧来のシリアル、または、 パラレルインタフェースに加えて (もしくは、これらに代わって) ネットワーク用のインタフェースがある場合。 そのようなプリンタは次のように動作するでしょう。</p><div class=ulist><ul><li><p>そのプリンタが LPD のプロトコルを理解でき、リモートホストからのジョブを キューに入れることさえできる場合。この場合、 プリンタは、LPD が起動している一般のホストのように振る舞います。 そのようなプリンタを設定するために、 「<a href=#printing-advanced-network-rm>リモートホストに接続されたプリンタ</a>」 と同様の手順をおこなってください。</p></li><li><p>そのプリンタが、 データストリームによるネットワーク接続をサポートしている場合。 この場合、ネットワーク上の1つのホストとしてプリンタを "接続" します。 このホストは、ジョブをスプーリングする責任を負い、 スプーリングされたジョブはプリンタに送られます。 そのようなプリンタをインストールするためのいくつかの提案が 「<a href=#printing-advanced-network-net-if>ネットワークにおけるデータストリームの インタフェースを持つプリンタ</a>」にあります。</p></li></ul></div></li></ul></div><div class=sect4><h5 id=printing-advanced-network-rm>9.4.3.1. リモートホストに接続されたプリンタ<a class=anchor href=#printing-advanced-network-rm></a></h5><div class=paragraph><p>LPD スプーリングシステムでは LPD (または LPD 互換のシステム) が起動している他のホストへジョブを送る機能が 始めからサポートされています。この機能により、 あるホストに接続されたプリンタへ、 他のホストからアクセスできるようになります。また、 LPD プロトコルを理解するネットワークインタフェースを持ったプリンタに対しても、 この機能は働きます。</p></div><div class=paragraph><p>リモートプリンタへの出力を許可するためには、最初に、 あるホスト (これを、 <em>プリンタホスト</em>と呼びます) にプリンタを接続します。そして、「<a href=#printing-simple>プリンタ設定導入編</a>」 に書かれた簡単なプリンタの設定をおこなってください。 必要ならば、「<a href=#printing-advanced>プリンタ設定上級編</a>」 にある、更に進んだ設定をおこなってください。そして、 そのプリンタをテストしてうまく動作することを確認し、LPD に許可した機能がうまく働くかどうかを見てください。さらに <em>ローカルホスト</em>が <em>プリンタホスト</em>の LPD サービスの使用を許可されているか確認して下さい (「<a href=#printing-advanced-restricting-remote>リモートホストからの利用を制限する </a>」参照)。</p></div><div class=paragraph><p>LPD 互換のネットワークインタフェースを持つプリンタを使用している場合は、 そのプリンタ自身が以下で説明する <em>プリンタホスト</em>になります。そして、 <em>プリンタ名</em>とは、 そのプリンタに設定した名前のことを指します。 これについては、プリンタ、および (または)、 プリンタのネットワークインタフェースに付属するドキュメントを参照してください。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>ヒューレット・パッカード社の Laserjet シリーズを使用している場合には、 プリンタ名を <code>text</code> とすると、 自動的に LF から CRLF への変換が行なわれます。 そのため、<span class=filename>hpif</span> スクリプトは必要ありません。</p></div></td></tr></tbody></table></div><div class=paragraph><p>次に、 そのプリンタにアクセスしたいと思っている他ホストにおいて、 そのホストの <span class=filename>/etc/printcap</span> ファイルに次にあげるエントリを作ります。</p></div><div class="olist arabic"><ol class=arabic><li><p>名前のエントリ。どんな名前でもよいのですが、簡単のため、多分、 プリンタホストで設定されたプリンタ名や別名と同じものを使いたいと思うでしょう。</p></li><li><p><code>lp</code> 項目で指定されるデバイスは明示的に空にします (<code>:lp=:</code> とします)。</p></li><li><p>スプーリングディレクトリを作成し、 <code>sd</code> 項目でその位置を指定します。 LPD では、プリンタホストにジョブを送信するまでの間、 このディレクトリにジョブを格納します。</p></li><li><p><code>rm</code> 項目でプリンタホストの名前を指定します。</p></li><li><p><code>rp</code> 項目で <em>プリンタホスト</em>に接続したプリンタ名を指定します。</p></li></ol></div><div class=paragraph><p>これで終わりです。 変換フィルタやページの大きさやその他の事項を <span class=filename>/etc/printcap</span> に加える必要はありません。</p></div><div class=paragraph><p>次に、 リモートホストに接続されたプリンタで印字するための設定例を示します。 ホスト <code>rose</code> には 2 台のプリンタ <code>bamboo</code> と <code>rattan</code> が接続されています。これらのプリンタをホスト <code>orchid</code> のユーザが使えるようにしましょう。最初に <code>orchid</code> の <span class=filename>/etc/printcap</span> を示します (このファイルは、「<a href=#printing-advanced-header-pages-enabling>ヘッダページの出力を許可する</a>」 で参照することができます)。このファイルには、既に、プリンタ <code>teak</code> 用のエントリがありました。以下では、 これに、ホスト <code>rose</code> にある2台のプリンタ用のエントリが加えられています。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host orchid - added (remote) printers on rose
#

#
#  teak is local; it is connected directly to orchid:
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/ifhp:\
        :vf=/usr/local/libexec/vfhp:\
        :of=/usr/local/libexec/ofhp:

#
#  rattan is connected to rose; send jobs for rattan to rose:
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :lp=:rm=rose:rp=rattan:sd=/var/spool/lpd/rattan:

#
#  bamboo is connected to rose as well:
#
bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :lp=:rm=rose:rp=bamboo:sd=/var/spool/lpd/bamboo:</pre></div></div><div class=paragraph><p><code>orchid</code> で必要となる作業はスプーリングディレクトリを作ることだけです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /var/spool/lpd/rattan /var/spool/lpd/bamboo</span>
<span class=c># chmod 770 /var/spool/lpd/rattan /var/spool/lpd/bamboo</span>
<span class=c># chown daemon:daemon /var/spool/lpd/rattan /var/spool/lpd/bamboo</span></code></pre></div></div><div class=paragraph><p>これで、<code>orchid</code> のユーザが <code>rattan</code> と <code>bamboo</code> で印字することができるようになりました。 たとえば、<code>orchid</code> のユーザが次のように入力したとします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-P</span> bamboo <span class=nt>-d</span> sushi-review.dvi</code></pre></div></div><div class=paragraph><p>すると、<code>orchid</code> の LPD システムは、 ジョブをスプーリングディレクトリ <span class=filename>/var/spool/lpd/bamboo</span> にコピーし、これが DVI ファイルを印字するジョブであることを記録します。 ホスト <code>rose</code> の <code>bamboo</code> スプーリングディレクトリに十分な容量が確保でき次第、 両者の LPD は、ジョブのファイルを <code>rose</code> に転送します。 このファイルは、そのすべてが印字されるまで、<code>rose</code> のキューに留まります。 (<code>bamboo</code> は PostScript® プリンタなので) DVI から PostScript® への変換は <code>rose</code> でおこなわれます。</p></div></div><div class=sect4><h5 id=printing-advanced-network-net-if>9.4.3.2. ネットワークにおけるデータストリームの インタフェースを持つプリンタ<a class=anchor href=#printing-advanced-network-net-if></a></h5><div class=paragraph><p>プリンタのネットワークインタフェースカードは、 2 種類に分類することができます。 1 つはスプーラをエミュレートするもの (高価) で、もう 1 つはシリアルやパラレルポートを使うように プリンタにデータを送ることができるだけのもの (安価) です。この節では、 後者の使い方を説明します。前者のプリンタは、前節「<a href=#printing-advanced-network-rm>リモートホストに接続されたプリンタ</a>」 の方法が適用できます。</p></div><div class=paragraph><p><span class=filename>/etc/printcap</span> ファイルでは、 シリアルかパラレルのインタフェースのどちらを使うのか、 そして、(シリアルインタフェースを使う場合) そのボーレートはいくらであるか、フロー制御は使うのか、 タブのための遅延を加えるのか、 改行文字を変換するかなどの指定をおこなうことができます。 しかし、TCP/IP や他のネットワークポートからデータを受け取るプリンタを 接続するための指定をおこなうことはでき ません。</p></div><div class=paragraph><p>ネットワーク接続されたプリンタにデータを送るためには、 テキストフィルタと変換フィルタから呼び出すことができる 通信プログラムを開発する必要があります。以下に、 そのようなプログラムの例を示します。スクリプト <code>netprint</code> では、 標準入力から印字データをすべて受け取り、 ネットワーク接続されたプリンタにこれを送ります。 <code>netprint</code> の最初の引数でプリンタのホスト名を、 2 番目の引数で接続するポート番号を指定します。 このプログラムでは単方向通信 (FreeBSD からプリンタ) のみをサポートしていることに注意してください。 ネットワークプリンタの多くは双方向通信をサポートしていますので、 その恩恵 (プリンタの状態を得たり、 課金をおこなうなど) にあずかりたいと思われるかもしれません。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/usr/bin/perl
#
#  netprint - Text filter for printer attached to network
#  Installed in /usr/local/libexec/netprint
#

$#ARGV eq 1 || die &#34;Usage: $0 &lt;printer-hostname&gt; &lt;port-number&gt;&#34;;

$printer_host = $ARGV[0];
$printer_port = $ARGV[1];

require &#39;sys/socket.ph&#39;;

($ignore, $ignore, $protocol) = getprotobyname(&#39;tcp&#39;);
($ignore, $ignore, $ignore, $ignore, $address)
    = gethostbyname($printer_host);

$sockaddr = pack(&#39;S n a4 x8&#39;, &amp;AF_INET, $printer_port, $address);

socket(PRINTER, &amp;PF_INET, &amp;SOCK_STREAM, $protocol)
    || die &#34;Can&#39;t create TCP/IP stream socket: $!&#34;;
connect(PRINTER, $sockaddr) || die &#34;Can&#39;t contact $printer_host: $!&#34;;
while (&lt;STDIN&gt;) { print PRINTER; }
exit 0;</pre></div></div><div class=paragraph><p>このスクリプトは、 様々なフィルタが利用することができます。仮に、Diablo 750-N ラインプリンタを持っており、 これがネットワークに接続されているとしましょう。 プリンタはポート番号 5100 にて印字するデータを受け取ります。 プリンタのホスト名は <code>scrivener</code> とします。このとき、 このプリンタのテキストフィルタは次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  diablo-if-net - Text filter for Diablo printer `scrivener&#39; listening
#  on port 5100.  Installed in /usr/local/libexec/diablo-if-net
#

exec /usr/libexec/lpr/lpf &#34;$@&#34; | /usr/local/libexec/netprint scrivener 5100</pre></div></div></div></div><div class=sect3><h4 id=printing-advanced-restricting>9.4.4. プリンタの利用に制約を与える<a class=anchor href=#printing-advanced-restricting></a></h4><div class=paragraph><p>本節では、プリンタの利用に制約を与えるための情報を記しています。 LPD システムでは、プリンタ (ローカル、 リモートのいずれに接続されていても) にアクセスできる人を制限する機能、 複数部のコピーの印字の可否を制御する機能、 ジョブのサイズの最大値やプリンタキューに入る ジョブの最大個数を制御する機能を提供しています。</p></div><div class=sect4><h5 id=printing-advanced-restricting-copies>9.4.4.1. 複数部のコピーの印字を制限する<a class=anchor href=#printing-advanced-restricting-copies></a></h5><div class=paragraph><p>LPD システムではユーザが複数部のコピーの印字を簡単におこなう 機能を提供しています。ユーザが、(たとえば) <code>lpr -#5</code> コマンドを使ってジョブを印字すると、 ジョブのそれぞれのファイルのコピーを 5 部得ることができます。 これがよい機能であると思うかどうかは人それぞれでしょう。</p></div><div class=paragraph><p>複数部のコピーの印字によってプリンタが 必要以上に消耗してしまうと感じるならば、 <span class=filename>/etc/printcap</span> ファイルに <code>sc</code> 項目を加えてください。これにより、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> の <code>-<mark></mark></code> オプションの使用が禁止されます。 このオプションが指定されているにも関らず、 <code>-</code> オプションを使うと、 次のようなメッセージが表示され、 このオプションの利用できない旨を伝えます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>lpr: multiple copies are not allowed</code></pre></div></div><div class=paragraph><p>リモートホストからプリンタをアクセスできる 設定にしている場合 (この 設定については、「<a href=#printing-advanced-network-rm>リモートホストに接続されたプリンタ</a>」 をご覧ください)、そのリモートホストの <span class=filename>/etc/printcap</span> にも同じように <code>sc</code> 項目を追加する必要があることに注意してください。 そうしないと、ユーザは別なホストから複数部のコピーの 印字をすることができてしまいます。</p></div><div class=paragraph><p>例を使って説明しましょう。次に示す <span class=filename>/etc/printcap</span> ファイルは、ホスト <code>rose</code> のものです。プリンタ <code>rattan</code> は極めて頑丈なので、 複数部のコピーの印字は許可されています。しかし、 レーザプリンタの <code>bamboo</code> はもう少しデリケートで、 このプリンタから複数部のコピーを印字することを <code>sc</code> 項目を追加することで禁止しています。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - restrict multiple copies on bamboo
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>さらに、orchid の <span class=filename>/etc/printcap</span> にも</p></div><div class=literalblock><div class=content><pre>sc</pre></div></div><div class=paragraph><p>項目を追加する必要があります (<code>orchid</code> でこの編集をおこなっているときに、ついでに、プリンタ <code>teak</code> でも複数部のコピーの印字を禁止することにしましょう)。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host orchid - no multiple copies for local
#  printer teak or remote printer bamboo

teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:sc:\
        :if=/usr/local/libexec/ifhp:\
        :vf=/usr/local/libexec/vfhp:\
        :of=/usr/local/libexec/ofhp:

rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :lp=:rm=rose:rp=rattan:sd=/var/spool/lpd/rattan:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :lp=:rm=rose:rp=bamboo:sd=/var/spool/lpd/bamboo:sc:</pre></div></div><div class=paragraph><p><code>sc</code> 項目を指定することにより、 <code>lpr -#</code> の使用を防ぐことができます。しかし、この状態では <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> を複数回起動したり、 1 回のジョブで次のように同じファイルを複数個指定することを防ぐまでには至っていません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr forsale.sign forsale.sign forsale.sign forsale.sign forsale.sign</code></pre></div></div><div class=paragraph><p>このような悪用を防ぐ方法は (その指示を無視することも含めて) たくさんあります。 各自で調べてみてください。</p></div></div><div class=sect4><h5 id=printing-advanced-restricting-access>9.4.4.2. プリンタを使用できる人を限定する<a class=anchor href=#printing-advanced-restricting-access></a></h5><div class=paragraph><p>それぞれのプリンタを使用できる人を限定するには、UNIX® の グループ権限のメカニズムを利用し、さらに、 <span class=filename>/etc/printcap</span> で <code>rg</code> 項目を指定することでおこないます。 あるプリンタにアクセスさせてもよいと思うユーザすべてを グループのどれかに入れてください。そして、 そのグループ名を <code>rg</code> で指定します。</p></div><div class=paragraph><p>このとき、そのグループに含まれないユーザ (<code>root</code> も含みます) がプリントしようとすると、次のようなメッセージが表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>lpr: Not a member of the restricted group</code></pre></div></div><div class=paragraph><p><code>sc</code> (suppress multiple copies : 複数部のコピーの印字を禁止する) を指定するときと同様に、<code>rg</code> が指定されたプリンタがリモートホストからもアクセスでき (この設定については、 「<a href=#printing-advanced-network-rm>リモートホストに接続されたプリンタ</a>」 をご覧ください)、かつ、 そのホストでもプリンタを使用できる人を限定するのが 妥当であると思う場合は、 そのホストの <span class=filename>/etc/printcap</span> にも <em>rg</em> 指定をおこなう必要があります。</p></div><div class=paragraph><p>たとえば、プリンタ <code>rattan</code> は誰でも利用できるが、<code>bamboo</code> はグループ <code>artists</code> に属している人のみが利用できるようにしてみましょう。 以下に、もうお馴染みとなったホスト <code>rose</code> の <span class=filename>/etc/printcap</span> を示します。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose - restricted group for bamboo
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:rg=artists:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>これ以外の <span class=filename>/etc/printcap</span> ファイル (ホスト <code>orchid</code> のもの) はそのままにしておくことにします。もちろん、 <code>orchid</code> のユーザは全員 <code>bamboo</code> を利用することができます。これは、 <code>orchid</code> には特定のユーザのみにしかアクセスさせておらず、 そのユーザにはプリンタを利用させたいと思っているからなのかもしれませんし、 そうでないかもしれません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>1台のプリンタを複数グループのユーザに利用させることはできません。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=printing-advanced-restricting-sizes>9.4.4.3. 入力可能なジョブのサイズを制限する<a class=anchor href=#printing-advanced-restricting-sizes></a></h5><div class=paragraph><p>たくさんのユーザからプリンタが利用される場合には、多分、 ユーザが印字要求を出すことができるファイルのサイズに 上限値を置く必要が生じるでしょう。結局のところ、 スプーリングディレクトリ が置かれているファイルシステムの空き容量がその 上限値になる訳ですが、 あるユーザがこれを独占的に使用すること避けるために、 他ユーザからのジョブ用の空き容量を確保する必要もあります。</p></div><div class=paragraph><p>LPD では、<code>mx</code> 項目を指定することにより、 ジョブ中の個々のファイルのサイズの上限値を制限する機能を提供しています。 指定される ファイルサイズの単位は BUFSIZ ブロックで、1 <code>BUFSIZ</code> ブロックは 1024バイトを表わします。この <code>mx</code> 項目の値として 0 が指定されると、 ファイルサイズの制限はなくなります。 <code>mx</code> が指定されない場合は、 デフォルトの制限として 1000 ブロックが使われます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この制限はジョブ中の各 <em>ファイル</em>に対して適用されるものであり、 ジョブ全体のサイズ を制限するものでは<em>ありません</em>。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ところで、 プリンタに設定された上限値を超えるファイルサイズの ファイルが入力された場合でも、LPD はこれを拒否しません。その代わりに、このファイルは、 その先頭から上限値のファイルサイズまでしかキューに入れられません。 そして、その部分までが印字され、 残りの部分は捨てられます。 これが正しい動作といえるのかどうかは議論の余地があるところです。</p></div><div class=paragraph><p>それでは、設定例に登場しているプリンタ <code>rattan</code> と <code>bamboo</code> の印字可能なファイルサイズに制限を加えてみましょう。 <code>artists</code> グループの人達が作る PostScript® ファイルのサイズは 巨大になる傾向があるので、上限値を 5M バイトとします。 それから、 プレインテキスト用のラインプリンタは無制限とします。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host rose
#

#
#  No limit on job size:
#
rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:mx#0:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:

#
#  Limit of five megabytes:
#
bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:rg=artists:mx#5000:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>この場合もそうですが、この制限はローカル (ホスト rose) のユーザのみに適用されます。 リモートホストからプリンタを利用できるように設定している場合は、 そのリモートホストのユーザはこの制限を受けません。 これらのユーザにも制限を加える場合は、リモートホストの <span class=filename>/etc/printcap</span> の <code>mx</code> を指定する必要があります。 リモートホストから印字するための詳しい情報については、 「<a href=#printing-advanced-network-rm>リモートホストに接続されたプリンタ</a>」 を参照してください。</p></div><div class=paragraph><p>リモートホストに接続されたプリンタへのジョブの サイズを制限する特別な方法は他にもあります。これについては、 「<a href=#printing-advanced-restricting-remote>リモートホストからの利用を制限する</a>」 を参照してください。</p></div></div><div class=sect4><h5 id=printing-advanced-restricting-remote>9.4.4.4. リモートホストからの利用を制限する<a class=anchor href=#printing-advanced-restricting-remote></a></h5><div class=paragraph><p>LPD スプーリングシステムでは、 リモートホストから要求されたジョブの印字を制限するための方法がいくつか提供されています。</p></div><div class=dlist><dl><dt class=hdlist1>ホストの制限</dt><dd><p>ローカルの LPD が印字要求を受け付けるリモートホストは、ファイル <span class=filename>/etc/hosts.equiv</span> と <span class=filename>/etc/hosts.lpd</span> によって制御することができます。LPD では、あるホストから印字の要求がきたとき、 このホストの名前がこれら 2 つのファイルのどちらかに含まれている かどうかを調べます。これが含まれていない場合は、LPD はこの要求を拒否します。</p><div class=paragraph><p>これらのファイルの形式は単純です。 各行にホストの名前を 1つずつ書いていきます。ファイル <span class=filename>/etc/hosts.equiv</span> の方は <a href="https://man.freebsd.org/cgi/man.cgi?query=ruserok&amp;sektion=3&amp;format=html">ruserok(3)</a> プロトコルでも利用され、 <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a> といったプログラムの動作に影響するので注意が必要です。 <span class=filename>/etc/hosts.equiv</span> の記述は慎重におこないましょう。</p></div><div class=paragraph><p>例として、以下にホスト <code>rose</code> の <span class=filename>/etc/hosts.lpd</span> を示します。</p></div><div class="literalblock programlisting"><div class=content><pre>orchid
violet
madrigal.fishbaum.de</pre></div></div><div class=paragraph><p>この例では、<code>rose</code> はホスト <code>orchid</code>, <code>violet</code> そして <code>madrigal.fishbaum.de</code> からの要求を受け付けることになります。 その他のホストが <code>rose</code> の LPD にアクセスしようとしても、 LPD はそのジョブを拒否します (訳注: 拒否されるのは、そのホストが <span class=filename>/etc/hosts.equiv</span> にも含まれていない場合です)。</p></div></dd><dt class=hdlist1>サイズの制限</dt><dd><p>スプーリングディレクトリがある ファイルシステムに残しておく必要がある 空き容量の大きさを制御することができます。 ローカルプリンタ用のスプーリングディレクトリに <span class=filename>minfree</span> という名前のファイルを作成します。そして、 そのファイルの中にリモートホストからのジョブの 要求を受け付けるために必要な空き容量のディスクブロックサイズ (1 ディスクブロック = 512 バイト) を記します。</p><div class=paragraph><p>これで、 リモートホストのユーザにファイルシステムを満杯にされないことが保証されます。 この機能を使うと、 ローカルホストのユーザに対してある種の優先権を与えることもできます。 ローカルホストのユーザは、 <span class=filename>minfree</span> ファイルで指定された値よりもディスクの空き容量が下回った後でもずっと、 ジョブをキューに入れることができるのです。</p></div><div class=paragraph><p>たとえば、プリンタ <code>bamboo</code> 用の <span class=filename>minfree</span> を作ってみましょう。 このプリンタのスプーリングディレクトリを調べるために、 <span class=filename>/etc/printcap</span> を調べてみましょう。 以下に、<code>bamboo</code> のエントリ部分を示します。</p></div><div class="literalblock programlisting"><div class=content><pre>bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\
        :sh:sd=/var/spool/lpd/bamboo:sc:rg=artists:mx#5000:\
        :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:mx#5000:\
        :if=/usr/local/libexec/psif:\
        :df=/usr/local/libexec/psdf:</pre></div></div><div class=paragraph><p>スプーリングディレクトリは <code>sd</code> 項目で指定されます。LPD がリモートホストからのジョブを受け付けるために必要な ファイルシステムの空き容量を 3M バイト (= 6144 ディスクブロック) にすることにしましょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo 6144 &gt; /var/spool/lpd/bamboo/minfree</span></code></pre></div></div></dd><dt class=hdlist1>利用ユーザの制限</dt><dd><p><span class=filename>/etc/printcap</span> の <code>rs</code> 項目を指定することで、 ローカルプリンタを利用できるリモートホストのユーザを制限することができます。 ローカルホストに接続されたプリンタ用のエントリに <code>rs</code> 項目が指定されている場合、 LPD は、印字を要求したユーザのアカウントと同じログイン名が ローカルホストに登録されている<em>場合に限り</em>、 そのジョブを受け付けます。それ以外のジョブを LPD は拒否します。</p><div class=paragraph><p>この機能は、(たとえば) 複数の部署がネットワークを共有しており、 この内のあるユーザが部署の境界を越えて活動している場合には特に有用です。 そのようなユーザに対して、システムのアカウントを与えるだけで、 これらのユーザは自分が所属する部署のシステムから そのシステムに接続されているプリンタを使用することができます。 これらのユーザにはむしろ、 プリンタの使用<em>だけ</em>を認め、 その他のコンピュータ資源を利用させたくないときは、 それらのユーザにはホームディレクトリを与えず、 ログインシェルはシェルとしては何の役にも立たない <span class=filename>/usr/bin/false</span> などを指定して、 これらのユーザのアカウントはプリンタ用の "形式的な" ものとします。</p></div></dd></dl></div></div></div><div class=sect3><h4 id=printing-advanced-acct>9.4.5. プリンタの利用に対する課金<a class=anchor href=#printing-advanced-acct></a></h4><div class=paragraph><p>という訳で、印字するためには料金をとることが必要です。 取らない理由などありましょうか。紙やインクにはお金がかかります。 そして、プリンタの維持費もかかります。 プリンタには可動部分が搭載されており、 これらの部分は壊れやすいという傾向があります。 プリンタや、その利用形態、維持費について調査をし、1 ページ (1 フィート、1 メートルなど) 当たりにかかるコストを調べておいてください。 これに基づき、プリンタの利用に対する課金を、実際に、 どのように始めればよいのでしょうか。</p></div><div class=paragraph><p>さて、残念ながら、この部分に関しては LPD スプーリングシステムはほとんど役に立ちません。 課金は使用しているプリンタの種類、印字するもののファイルの形式、 プリンタの利用に対する課金での <em>あなた自身の</em>要求に大きく左右されます。</p></div><div class=paragraph><p>課金システムを実現するためには、プリンタのテキストフィルタ (プレインテキストのジョブに対して課金するため) と変換フィルタ (その他のファイル形式に対して課金するため) を変更して、 印字したページを数えたり、 プリンタに印字したページ数を取得するための要求を送る必要があります。 ただし、出力フィルタのみを利用している場合は、 課金をおこなうことができません。フィルタに関しては、 「<a href=#printing-advanced-filter-intro>フィルタ</a>」をご覧ください。</p></div><div class=paragraph><p>一般に、課金方式には次の 2 つがあります。</p></div><div class=ulist><ul><li><p><em>定期的に課金する方法</em> はよく利用される方法です。この理由は、 恐らく比較的簡単に実現できるからです。 誰かがジョブを印字する度に、フィルタはそのユーザ名、 ホスト名、印字したページ数を課金データファイルに記録します。 毎月、毎学期、毎年、その他お好みの時期に、 各プリンタの課金用ファイルを集め、 それぞれのユーザが印字したページ数を合計して その分の課金をおこないます。 次回の課金期間をデータを 0 にして課金を再開するために、 すべてのログファイルを削除します。</p></li><li><p><em>利用毎に課金する方法</em> はあまり利用されていません。これは、 実現するのが比較的難しいからです。この方式では、 プリンタを使用したらすぐに、 フィルタがユーザにその利用に対する課金をおこないます。 ディスククォータのように、課金作業は瞬時におこなわれます。 この方式では、ユーザのアカウントが赤字になる場合に、 ユーザが印字をおこなうことを拒否することができます。 また、ユーザに "プリンタ版 quota" を調べたり、 調整したりする方法を提供したいと思うかもしれ ません。 これを実現するためには、ユーザとその quota を追跡するために、 あるデータベース用のコードが必要となります。</p></li></ul></div><div class=paragraph><p>LPD スプーリングシステムでは、 どちらの方式にも簡単に対応できます。(ほとんどの場合は) フィルタを用意しなければならないので、 課金作業のためのコードも用意しなければなりません。 しかし、明るい面もあります。 それは、課金方式に関して、非常に大きな柔軟性が与えられたということです。 たとえば、「定期的に課金する方法」か、 「利用毎に課金する方法」のどちらかを選びまず、そして、 どんな情報 (ユーザ名、ホスト名、ジョブのタイプ、印字された頁数、 使用した紙の大きさ、印字をするために要した時間など) をログに記録するかを決めます。 以上のことをおこなうには、上記の情報を保持するために、 フィルタを変更しなくてはなりません。</p></div><div class=sect4><h5 id=_手軽なプリンタ課金方法>9.4.5.1. 手軽なプリンタ課金方法<a class=anchor href=#_手軽なプリンタ課金方法></a></h5><div class=paragraph><p>FreeBSD には、「定期的に課金する方法」による課金を すぐに設定できるように、2 個のプログラムを添付しています。 その内の1つはテキストフィルタ <code>lpf</code> で、 これについては、「<a href=#printing-advanced-lpf>テキストフィルタ lpf</a>」をご覧ください。もう1つは、 <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> で、 これはプリンタの課金データファイルからのエントリを集め、 これを合計するプログラムです。</p></div><div class=paragraph><p>「<a href=#printing-advanced-filters>フィルタはどのように機能しているか</a>」で述べたように、 LPD ではテキストフィルタや変換フィルタを起動しますが、 そのコマンドラインで使用している課金データファイルの名前が指定されます。 両フィルタはこの引数を使って、 どの課金データファイルのエントリに書き込めばよいのかを知ることができます。 このファイルの名前は <span class=filename>/etc/printcap</span> 中の <code>af</code> 項目によって指定されます。 このファイルが絶対パ スで指定されない場合は、 スプーリングディレクトリからの相対パスとして扱われます。</p></div><div class=paragraph><p>LPD は、紙のページの幅と行数 (<code>pw</code> と <code>pl</code> 項目で 指定される) を引数として <code>lpf</code> を起動します。<code>lpf</code> フィルタでは、 何ページ印字したかを決定するためにこれらの引数を使用します。 ファイルをプリンタに送った後、 課金情報を課金データファイルに書き込みます。 このファイルは次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>2.00 rose:andy
3.00 rose:kelly
3.00 orchid:mary
5.00 orchid:mary
2.00 orchid:zhang</pre></div></div><div class=paragraph><p>課金データファイルはプリンタ毎に分けて作るべきです。 これは、<code>lpf</code> にはファイルをロックする機構が組み込まれていないためです。 したがって、<code>lpf</code> が 2 つ起動されたとき、 同じファイルに同時に書き込みをおこなった場合、 お互いのエントリを破壊してしまうかもしれません。 課金用ファイルを各プリンタ毎に確実に分けるには、 <span class=filename>/etc/printcap</span> 中の <code>af=acct</code> 項目を使います。 そうすれば、それぞれの課金用ファイルがプリンタのスプーリングディレクトリに、 <span class=filename>acct</span> という名称で作成されます。</p></div><div class=paragraph><p>プリンタの利用に対してユーザに課金する準備ができたら、 <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> プログラムを実行してください (課金したいプリンタのスプーリングディレクトリに移動した後、 <code>pac</code> と入力してください)。 次のような、ドル中心主義の課金リストが表示されます (訳注: ドル中心主義という表現は、 表示がドルで出ることへの著者の皮肉でしょう。 セントがあるので小数点以下が表示されますが、 この機能も日本では邪魔ですね)。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  Login               pages/feet   runs    price
orchid:kelly                5.00    1   <span class=nv>$ </span> 0.10
orchid:mary                31.00    3   <span class=nv>$ </span> 0.62
orchid:zhang                9.00    1   <span class=nv>$ </span> 0.18
rose:andy                   2.00    1   <span class=nv>$ </span> 0.04
rose:kelly                177.00  104   <span class=nv>$ </span> 3.54
rose:mary                  87.00   32   <span class=nv>$ </span> 1.74
rose:root                  26.00   12   <span class=nv>$ </span> 0.52

total                     337.00  154   <span class=nv>$ </span> 6.74</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> が受け付ける引数には次のようなものがあります。</p></div><div class=dlist><dl><dt class=hdlist1><code>-P <em>printer</em></code></dt><dd><p>プリンタ <em>printer</em> の利用に対する課金リストを作成します。 このオプションは、<span class=filename>/etc/printcap</span> の <code>af</code> が絶対パスで指定されていた場合に限り、動作します。</p></dd><dt class=hdlist1><code>-c</code></dt><dd><p>ユーザ名のアルファベット順ではなく、 課金額の低い順にリストを並べます。</p></dd><dt class=hdlist1><code>-m</code></dt><dd><p>課金データファイルにあるホスト名を無視します。 このオプションを使用すると、ホスト <code>alpha</code> のユーザ <code>smith</code> とホスト <code>gamma</code> のユーザ <code>smith</code> は同一人物として扱われます。 このオプションが指定されない場合は、 両者は別なユーザとして扱います。</p></dd><dt class=hdlist1><code>-p <em>price</em></code></dt><dd><p><span class=filename>/etc/printcap</span> の <code>pc</code> 項目で指定された値、または、 デフォルトの値 (2 セント) に代わり、紙1ページ、または、 1フィート当たりの価格を指定します。 <em>price</em> として、 浮動小数点数を指定することができます。</p></dd><dt class=hdlist1><code>-r</code></dt><dd><p>リストの並べる順番を逆順にします。</p></dd><dt class=hdlist1><code>-s</code></dt><dd><p>課金リストを作成し、 課金データファイルを削除します。</p></dd><dt class=hdlist1><em>name…​</em></dt><dd><p>ユーザ <em>names</em> に対する課金情報のみを表示します。</p></dd></dl></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> が生成するデフォルトのリストには、 各ホストのユーザ別に印字ページ数が表示されます。 (ユーザがサイト内のすべてのホストを使用できるため) ホスト名の情報が意味を持たない場合、 <code>pac -m</code> を実行してください。次のようなリストが得られます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  Login               pages/feet   runs    price
andy                        2.00    1   <span class=nv>$ </span> 0.04
kelly                     182.00  105   <span class=nv>$ </span> 3.64
mary                      118.00   35   <span class=nv>$ </span> 2.36
root                       26.00   12   <span class=nv>$ </span> 0.52
zhang                       9.00    1   <span class=nv>$ </span> 0.18

total                     337.00  154   <span class=nv>$ </span> 6.74</code></pre></div></div><div class=paragraph><p>課金額を決めるために、 <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> は <span class=filename>/etc/printcap</span> ファイルの <code>pc</code> 項目で指定された値 (デフォルト値は 200、すなわち 1 ページ当たり 2 セント) を使います。この項目で、印字物に課金したい ファと思う 1 ページ当たり、 または、1 フィート当たりの価格を 100 分の 1 セント単位で指定します。 <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> を <code>-p</code> オプション付きで起動すると、 この値を置き換えることができます。 この <code>-p</code> オプションで指定する額の単位は、 100 分の 1 セント単位ではなく、ドル単位です。たとえば、次の指定では、 1 ページ当たりの単価が 1 ドル 50 セントになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pac -p1.50</span></code></pre></div></div><div class=paragraph><p>このオプションを使うと、 実際の課金額を集計することができます。</p></div><div class=paragraph><p>最後に、<code>pac -s</code> を起動すると、課金情報は課金データ累計ファイルに保存されます。 このファイルの名前は、プリンタの課金データファイルの後ろに <code>_sum</code> を付けたものとなります。そして、 課金データファイルは削除されます。次に <a href="https://man.freebsd.org/cgi/man.cgi?query=pac&amp;sektion=8&amp;format=html">pac(8)</a> が起動されると、 その時点までの累計金額を得るために、 課金データ累計ファイルが読み込まれ、 通常の課金データファイルからの情報に加算されます。</p></div></div><div class=sect4><h5 id=_印字されたページ数をどのように数えるか>9.4.5.2. 印字されたページ数をどのように数えるか?<a class=anchor href=#_印字されたページ数をどのように数えるか></a></h5><div class=paragraph><p>課金を、リモートホストからの印字でさえも、 正確におこなうためには、 ジョブで使用された紙が何ページであるかを特定できる必要があります。 このことは、プリンタ利用に対する課金をおこなう上の根本的な問題です。</p></div><div class=paragraph><p>プレインテキストのジョブの場合、 問題を解決するのはさほど難しくはありません。 ジョブが何行であったかを数え、プリンタがサポートしている紙 1 ページに印字できる最大の行数と比較すればよいのです。 重ね打ちするために利用されるファイル中のバックスペース文字や、 物理的に複数の行に渡る長い論理行に対する取り扱いを忘れずにおこなってください。</p></div><div class=paragraph><p>(「<a href=#printing-advanced-lpf>テキストフィルタ lpf</a>」で紹介した) テキストフィルタ <code>lpf</code> では、課金をおこなうときに、 これらの取り扱いをおこなってくれます。 課金をおこなうために必要なテキストフィルタを作成している方は、 <code>lpf</code> のソースコードが参考になるでしょう。</p></div><div class=paragraph><p>これに対して、他のファイル形式の処理はどのようにすれば よいのでしょうか。</p></div><div class=paragraph><p>まず、DVI から LaserJet, または、DVI から PostScript® への変換の場合、フィルタが <code>dvilj</code> や <code>dvips</code> の 出力メッセージを解析することで、 何ページ分の変換がおこなわれたかを知ることができます。 他のファイル形式とその変換プログラムに関しても、 同様のことができるかもしれません。</p></div><div class=paragraph><p>しかし、この方式には問題点があります。それは、 変換されたページがすべて印字されるとは限らないということです。 たとえば、プリンタが紙詰まりを起こしたり、トナー切れになったり、 はたまた、爆発したりするかもしれません。 そのような状況により印字が途中で中止されたとしても、この方式では、 ユーザは全ページ分の料金を課されてしまうのです。</p></div><div class=paragraph><p>それでは、どのような対策をたてることができるのでしょうか。</p></div><div class=paragraph><p><em>正確な</em> 課金をおこなうための唯一の<em>確実な</em>方法は、 何ページ印字したのかを知らせることができるプリンタを入手し、 これをシリアルポートかネットワークに接続することです。 ほとんどすべての PostScript® プリンタではこの概念がサポートされています。 他のプリンタも同様です (Imagen レーザプリンタをネットワーク接続するなど)。 それぞれのプリンタのフィルタを、 ジョブを印字した後で印字ページ数を得るように変更してください。 そして、課金情報はここで得られた値<em>のみに</em> 基づいて記録してください。行数を数えたり、 エラーが生じやすいファイルの調査は必要とされません。</p></div><div class=paragraph><p>もちろん、 気前よく印字料金をすべて無料にすることもできます。</p></div></div></div></div><div class=sect2><h3 id=printing-using>9.5. プリンタを使う<a class=anchor href=#printing-using></a></h3><div class=paragraph><p>この節では、FreeBSD で設定したプリンタを使う方法について説明します。 ここでは、ユーザレベルでのコマンドを概説します。</p></div><div class=dlist><dl><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a></dt><dd><p>印字をおこないます。</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a></dt><dd><p>プリンタキューを調べます。</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a></dt><dd><p>プリンタキューにあるジョブを削除します。</p></dd></dl></div><div class=paragraph><p>また、「<a href=#printing-lpc>プリンタの管理</a>」 節で説明されている管理者用コマンド <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> もあり、 プリンタやそのキューの制御のために用いられています。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>、<a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a>、そして <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> の 3 コマンドは、<code>-P <em>printer-name</em></code> オプションをとり、これによって、 <span class=filename>/etc/printcap</span> のように操作の対象となる プリンタやキューを指定します。 これによって、様々なプリンタに対してジョブを送る、 取り消す、調査することができます。 <code>-P</code> が使われなかった場合は、これらのコマンドは <code>PRINTER</code> 環境変数で指定されたプリンタを使用します。 そして、<code>PRINTER</code> 環境変数がなかった場合は、 これらのコマンドはデフォルトのプリンタ <code>lp</code> を使います。</p></div><div class=paragraph><p>以下では、<em>デフォルトプリンタ</em> という用語が意味するプリンタは、<code>PRINTER</code> 環境変数で指定されたプリンタ、もしくは、<code>PRINTER</code> 環境変数がない場合は、<code>lp</code> という名前のプリンタです。</p></div><div class=sect3><h4 id=printing-lpr>9.5.1. 印字する<a class=anchor href=#printing-lpr></a></h4><div class=paragraph><p>ファイルを印字するためには、 次のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr filename ...</code></pre></div></div><div class=paragraph><p>これにより、 入力されたファイルのそれぞれをデフォルトのプリンタ から印字します。ファイル名が与えられなかった場合、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> は標準入力から印字するデータを読み込みます。たとえば、 次のコマンドにより、ある重要なシステムファイルが印字されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr /etc/host.conf /etc/hosts.equiv</code></pre></div></div><div class=paragraph><p>印字させるプリンタを選択するためには、 次のように入力します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-P</span> printer-name filename ...</code></pre></div></div><div class=paragraph><p>次の例では、プリンタ <code>rattan</code> に、 カレントディレクトリにあるファイルの詳細なリストを印字しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=nt>-l</span> | lpr <span class=nt>-P</span> rattan</code></pre></div></div><div class=paragraph><p>上記の <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> コマンドではファイル名の指定がないので、 <code>lpr</code> は標準入力から印字するデータ、 この場合、<code>ls -l</code> コマンドの出力、を読み込みます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> コマンドでは、 出力の整形を制御したり、ファイル変換を適用したり、 複数部数のコピーを作成したり、 などといた様々な幅広いオプションを受け付けることもできます。 詳細については、 「<a href=#printing-lpr-options>その他の印字オプション</a>」をご覧ください。</p></div></div><div class=sect3><h4 id=printing-lpq>9.5.2. ジョブの処理状況を調べる<a class=anchor href=#printing-lpq></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> コマンドを使って印字をする場合、プリントしようと するデータは "プリントジョブ" と呼ばれる箱に一緒に置かれ、 これが LPD スプーリングシステムに送られます。 プリンタにはそれぞれジョブ用のキューがあり、 送られてきたジョブはあなたや他のユーザからの別のジョブと一緒にそのキューで並んで、 処理される順番を待ちます。 プリンタは到着順にこれらのジョブの印字をおこないます。</p></div><div class=paragraph><p>デフォルトプリンタのキューの状態を表示するには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> と入力します。プリンタを指定するときは、 <code>-P</code> オプションを使います。たとえば、次のコマンド</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq <span class=nt>-P</span> bamboo</code></pre></div></div><div class=paragraph><p>は、プリンタ <code>bamboo</code> のキューの状態を表示します。この <code>lpq</code> コマンドの出力結果の例を次に示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bamboo is ready and printing
Rank   Owner    Job  Files                              Total Size
active kelly    9    /etc/host.conf, /etc/hosts.equiv   88 bytes
2nd    kelly    10   <span class=o>(</span>standard input<span class=o>)</span>                   1635 bytes
3rd    mary     11   ...                                78519 bytes</code></pre></div></div><div class=paragraph><p>この例では、<code>bamboo</code> のキューに 3 つのジョブがあることが分かります。 最初のジョブはユーザ kelly からのものであり、 "ジョブ番号" 9 が割り当てられています。 プリンタのすべてのジョブには一意なジョブ番号が付けられています。 ほとんどの場合、このジョブ番号は無視することができますが、 ジョブをキャンセルするときにはこの番号が必要になります。 このことの詳細については、「<a href=#printing-lprm>ジョブの削除</a> 」をご覧ください。</p></div><div class=paragraph><p>ジョブ番号 9 のジョブは 2 つのファイルを処理します。すなわち、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> のコマンドラインに複数のファイル名が与えられたときは、 1つのジョブとして扱われるのです。このジョブは、現在、 アクティブジョブ ("Rank" の欄の <code>active</code> という後に注目) になっています。 これは、プリンタからそのジョブが現在印字されているはずであることを意味しています。 2 番目のジョブでは、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> コマンドに標準入力からデータが与えられています。 3番目のジョブはユーザ <code>mary</code> から与えられました。 このジョブのサイズはとても大きくなっています。 彼女がプリントしようとしたファイルのパス名はここで表示させるには長すぎるため、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> コマンドはドットを 3 つだけ表示しています。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> からの出力で一番最初の行もまた有益な情報を与えています。 この行から、プリンタが現在何をしているか (あるいは、少なくとも LPD がプリンタがしていると思っていること) が分かります。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> コマンドは <code>-l</code> オプションもサポートしています。 これにより、 詳しい情報が表示されます。 <code>lpq -l</code> の実行例を次に示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>waiting <span class=k>for </span>bamboo to become ready <span class=o>(</span>offline ?<span class=o>)</span>
kelly: 1st                               <span class=o>[</span>job 009rose]
       /etc/host.conf                    73 bytes
       /etc/hosts.equiv                  15 bytes

kelly: 2nd                               <span class=o>[</span>job 010rose]
       <span class=o>(</span>standard input<span class=o>)</span>                  1635 bytes

mary: 3rd                                <span class=o>[</span>job 011rose]
      /home/orchid/mary/research/venus/alpha-regio/mapping 78519 bytes</code></pre></div></div></div><div class=sect3><h4 id=printing-lprm>9.5.3. ジョブの削除<a class=anchor href=#printing-lprm></a></h4><div class=paragraph><p>印字するようジョブを 送った後で印字を中断したくなったときは、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> コマンドで、 キューの中からそのジョブを削除することができます。 大抵の場合、アクティブジョブでさえも <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> を使って削除することができますが、 そのジョブの一部またはすべてが印字されてしまうかもしれません。</p></div><div class=paragraph><p>デフォルトプリンタへのジョブを削除するためには、最初に、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> を使ってそのジョブ番号を調べます。 すなわち、それから、 次のように入力して、ジョブを削除します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lprm job-number</code></pre></div></div><div class=paragraph><p>特定のプリンタへのジョブを削除するときは、 <code>-P</code> オプションを使ってそのプリンタを指定します。 たとえば、プリンタ <code>bamboo</code> のキューからジョブ番号 10 のジョブを削除するには次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lprm <span class=nt>-P</span> bamboo 10</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> コマンドには略記法がいくつかあります。</p></div><div class=dlist><dl><dt class=hdlist1>lprm -</dt><dd><p>あなたが (デフォルトプリンタへ) 送ったジョブをすべて削除します。</p></dd><dt class=hdlist1>lprm <em>user</em></dt><dd><p>ユーザ <em>user</em> が (デフォルトプリンタへ) 送ったジョブをすべて削除します。 他のユーザのジョブを削除できるのはスーパユーザだけです。 あなたは、あなた自身のジョブしか削除することはできません。</p></dd><dt class=hdlist1>lprm</dt><dd><p>ジョブ番号もユーザ名もシンボル <code>-</code>も指定されないときは、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> は現在のアクティブジョブを、 そのジョブを送ったのがあなた自身であるときに限り、 デフォルトプリンタから削除します。ただし、 スーパユーザは任意のアクティブジョブを削除することができます。</p></dd></dl></div><div class=paragraph><p>上記の略記法をデフォルトプリンタではなく 特定のプリンタに対しておこなうときは、<code>-P</code> オプションでそのプリンタを指定するだけよいのです。たとえば、 プリンタ <code>rattan</code> のキューへあなたが送ったジョブを すべて削除するためには次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lprm <span class=nt>-P</span> rattan -</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ネットワーク環境で作業をしている場合、 あるホストから送られたプリンタジョブは、これを送ったホストで <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> を使った場合に限って、 これを削除することができます。 他のホストで同じプリンタを使えたとしても、 このジョブを削除することはできません。 次の例では、他ホストからジョブを削除することを試みています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-P</span> rattan myfile
% rlogin orchid
% lpq <span class=nt>-P</span> rattan
Rank   Owner      Job  Files                          Total Size
active seeyan     12    ...                           49123 bytes
2nd    kelly      13   myfile                         12 bytes
% lprm <span class=nt>-P</span> rattan 13
rose: Permission denied
% <span class=nb>logout</span>
% lprm <span class=nt>-P</span> rattan 13
dfA013rose dequeued
cfA013rose dequeued</code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=printing-lpr-options>9.5.4. その他の印字オプション<a class=anchor href=#printing-lpr-options></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> コマンドには、テキストの整形や、 図や他のファイル形式の変換、複数部コピーの生成、 ジョブの扱いなどを制御することができます。 この節では、これに関するオプションについて記しています。</p></div><div class=sect4><h5 id=printing-lpr-options-format>9.5.4.1. 整形と変換に関するオプション<a class=anchor href=#printing-lpr-options-format></a></h5><div class=paragraph><p>以下の <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> 用のオプションはジョブにおける ファイルの整形の制御に関するものです。 このオプションは、ジョブにプレインテキストが含まれない場合や <a href="https://man.freebsd.org/cgi/man.cgi?query=pr&amp;sektion=1&amp;format=html">pr(1)</a> ユーティリティを使ってプレインテキストを整形する場合に用いてください。</p></div><div class=paragraph><p>次の例では、プリンタ <code>bamboo</code> に (TeX 組版システムによる) DVI ファイル <span class=filename>fish-report.dvi</span> を印字しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-P</span> bamboo <span class=nt>-d</span> fish-report.dvi</code></pre></div></div><div class=paragraph><p>このオプションは、 ジョブに含まれるすべてのファイルに対して適用されます。 したがって、1 つのジョブに (たとえば) DVI ファイルと ditroff ファイルを混在させることはできません。その代わりに、 ファイルを形式毎に別々のジョブに分け、 それぞれのジョブでその形式用の変換オプションを使って印字してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>-p</code> と <code>-T</code> を除くすべてのオプションを使用 するためには、 出力先プリンタ用の変換フィルタが必要です。たとえば、 <code>-d</code> オプションを使用するには、DVI 用の変換フィルタが必要 です。詳細については、「<a href=#printing-advanced-convfilters>変換フィルタ</a>」で説明しています。</p></div></td></tr></tbody></table></div><div class=dlist><dl><dt class=hdlist1><code>-c</code></dt><dd><p>cifplot ファイルを印字します。</p></dd><dt class=hdlist1><code>-d</code></dt><dd><p>DVI ファイルを印字します。</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>FORTRAN プログラムを印字します。</p></dd><dt class=hdlist1><code>-g</code></dt><dd><p>plot のデータを印字します。</p></dd><dt class=hdlist1><code>-i <em>number</em></code></dt><dd><p>出力に対して、<em>number</em> カラム分の字下げをおこないます。 <em>number</em> が省略されると、 8 カラム分字下げされます。 このオプションはある変換フィルタと一緒の指定されたときのみに機能します。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>-i</code> と数字の間に空白を入れてはいけません。</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1><code>-l</code></dt><dd><p>制御文字を含む文字通りのテキストデータを印字します。</p></dd><dt class=hdlist1><code>-n</code></dt><dd><p>ditroff (device independent troff) データを印字します。</p></dd><dt class=hdlist1>-p</dt><dd><p>印字する前に <a href="https://man.freebsd.org/cgi/man.cgi?query=pr&amp;sektion=1&amp;format=html">pr(1)</a> によってプレインテキストを整形します。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=pr&amp;sektion=1&amp;format=html">pr(1)</a> をご覧ください。</p></dd><dt class=hdlist1><code>-T <em>title</em></code></dt><dd><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pr&amp;sektion=1&amp;format=html">pr(1)</a> コマンドにより生成されるヘッダを、 ファイル名の代わりに <em>title</em> とする。 このオプションは、<code>-p</code> と一緒に使ったときのみ機能する。</p></dd><dt class=hdlist1><code>-t</code></dt><dd><p>troff データを印字します。</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>ラスタのデータを印字します。</p></dd></dl></div><div class=paragraph><p>次の例では、<a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> のマニュアルを美しく整形したものをデフォルトプリンタで印字しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% zcat /usr/shared/man/man1/ls.1.gz | troff <span class=nt>-t</span> <span class=nt>-man</span> | lpr <span class=nt>-t</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=zcat&amp;sektion=1&amp;format=html">zcat(1)</a> コマンドで <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> のマニュアルのソースファイルの圧縮を復元し、これを <a href="https://man.freebsd.org/cgi/man.cgi?query=troff&amp;sektion=1&amp;format=html">troff(1)</a> コマンドに渡しています。 これによりソースファイルが整形され GNU troff の形式となります。 その結果は <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> に渡され、 LPD スプーラへジョブの要求が発せられます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> には <code>-t</code> オプションが使われているため、 スプーラでジョブを印字したときに GNU troff の形式から、デフォルトプリンタが解釈できる形式へと変換されます。</p></div></div><div class=sect4><h5 id=printing-lpr-options-job-handling>9.5.4.2. ジョブに関するオプション<a class=anchor href=#printing-lpr-options-job-handling></a></h5><div class=paragraph><p>以下のオプションは、<a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> によって、 そのジョブを特殊な扱いにするよう LPD に指示するためのものです。</p></div><div class=dlist><dl><dt class=hdlist1>-# <em>copies</em></dt><dd><p>ジョブに含まれるファイルのそれぞれを 1 部だけ印字するのではなく、 <em>copies</em> 部のコピーを生成させるものです。管理者によっては、 プリンタの消耗を避け、コピー機による複製を奨励するために このオプションの使用が禁止されているかもしれません。 これに関しては、「<a href=#printing-advanced-restricting-copies>複数部のコピーの印字を制限する </a>」をご覧ください。</p><div class=paragraph><p>次の例では、デフォルトプリンタで <span class=filename>parser.c</span> を 3 部コピーし、次に、 <span class=filename>parser.h</span> を 3 部コピーしています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr -#3 parser.c parser.h</code></pre></div></div></dd><dt class=hdlist1>-m</dt><dd><p>印字ジョブが完了した後で、メールを送ります。 このオプションを付けると、LPD システムはジョブの処理が終了したときに、 あなたのアカウントにメールを送ります。 メールのメッセージには、ジョブが正常終了したのか、あるいは、 何か異常があり、(しばしば) その異常が何であったのかが書かれています。</p></dd><dt class=hdlist1>-s</dt><dd><p>印字ファイルをスプールディレクトリにコピーせず、 代わりに、 シンボリックリンクを作成するよう指示します。</p><div class=paragraph><p>印字させるジョブのサイズが大きいとき、 このオプションを使うと便利かもしれません。このオプションにより、 スプー ルディレクトリの容量が節約されます (それに、 巨大なジョブのお陰でスプールディレクトリのあるファイルシステムの空き容量がなくなってしまうかもしれません)。 さらに、LPD がいちいちすべてのデータをコピーする必要がなくなりますので、 時間の節約にもなります。</p></div><div class=paragraph><p>ただし、欠点もあります。LPD はオリジナルのファイルを直接参照するので、 印字が終了するまでそのファイルを変更したり削除することができません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>リモートのプリンタで印字している場合、 LPD は、結局のところ、 ローカルホストからリモートホストにファイルをコピーする必要があります。 したがって、<code>-s</code> オプションはローカルのスプーリングディレクトリの空き容量を節約するだけで、 リモート側では節約されません。 それでも、このオプションは有用です。</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>-r</dt><dd><p>ジョブに含まれるファイルを、 スプーリングディレクトリに ファイルをコピーした後に削除します。もしくは、 <code>-s</code> オプションと一緒に使われた場合は、 印字終了後に削除されます。 このオプションの使用には十分注意して下さい。</p></dd></dl></div></div><div class=sect4><h5 id=printing-lpr-options-misc>9.5.4.3. ヘッダページ用オプション<a class=anchor href=#printing-lpr-options-misc></a></h5><div class=paragraph><p>以下のオプションにより、 ジョブのヘッダページに通常印字さ れるテキストを <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> に調整させることができます。 対象のプリンタからヘッダページが出力されない場合は、 これらのオプションは何の効力も持ちません。 ヘッダページの設定に関する情報については、 「<a href=#printing-advanced-header-pages>ヘッダページ</a>」を参照してください。</p></div><div class=dlist><dl><dt class=hdlist1>-C <em>text</em></dt><dd><p>ヘッダページに印字されるホスト名を <em>text</em> に置き換えます。なお、 ホスト名の場所には、通常、 ジョブの要求があったホストの名前が印字されます。</p></dd><dt class=hdlist1>-J <em>text</em></dt><dd><p>ヘッダページに印字されるジョブ名を <em>text</em> に置き換えます。 ジョブ名の場所には、通常、ジョブの最初のファイル名、 または、標準入力からデータが印字されたときは <span class=filename>stdin</span> が印字されます。</p></dd><dt class=hdlist1>-h</dt><dd><p>ヘッダページの出力を禁止します。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>サイトによっては、 そのヘッダページの生成方法により、 このオプションの効果が現れないかもしれません。 詳細は、「<a href=#printing-advanced-header-pages>ヘッダページ</a>」をご覧ください。</p></div></td></tr></tbody></table></div></dd></dl></div></div></div><div class=sect3><h4 id=printing-lpc>9.5.5. プリンタの管理<a class=anchor href=#printing-lpc></a></h4><div class=paragraph><p>プリンタの管理者として、プリンタの設置、設定、 そして、それらのテストをおこなう必要がありました。 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> コマンドにより、 これまでとは別な管理方法がプリンタと対話的におこなわれます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> により、次のことが可能となります。</p></div><div class=ulist><ul><li><p>プリンタの起動、停止をおこなう。</p></li><li><p>キューへの入力の許可、禁止をおこなう。</p></li><li><p>それぞれのキューにあるジョブの順番を変更する。</p></li></ul></div><div class=paragraph><p>最初に用語に関する注意をしておきます。 プリンタが<em>停止している</em>とは、 キューの中にあるどのジョブも印字されることがない状態 を言います。この状態においても、 ユーザはまだジョブの要求をおこなうことができますが、 これらのジョブはキューの中で、 プリンタが<em>スタートする</em>状態になるまで、 あるいは、キューの内容が削除されるまで待たされることになります。</p></div><div class=paragraph><p>キューが<em>禁止状態</em>にあると、 (<code>root</code> 以外の) すべてのユーザがプリンタにジョブを要求することができません。 キューが<em>許可状態にある</em>場合は、 ジョブの入力が許可されます。 キューが<em>禁止状態にある</em>場合でも、 プリンタを<em>スタートす る</em>状態にすることは可能です。この場合は、 キューが空になるまで、 キュー内のジョブの印字が続けられます。</p></div><div class=paragraph><p>一般的に、<a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> コマンドを使用するには <code>root</code> 権限を持っている必要があります。 一般のユーザも <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> コマンドを使うことはできますが、 プリンタの状態を取得することとハングしたプリンタ を再スタートすることだけに使用が制限されています。</p></div><div class=paragraph><p>以下に、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> コマンドに関する説明の要約を述べます。 ほとんどのコマンドでは、操作対象となるプリンタを指定するため <em>printer-name</em> 引数を与えます。 <em>printer-name</em> の代わりに <code>all</code> が与えられると、操作は <span class=filename>/etc/printcap</span> 内にある全プリンタに対しておこなわれることになります。</p></div><div class=dlist><dl><dt class=hdlist1><code>abort printer-name</code></dt><dd><p>現在のジョブをキャンセルし、プリンタを停止させます。 キューが許可状態にある場合は、 ユーザはまだジョブを入力することができます。</p></dd><dt class=hdlist1><code>clean printer-name</code></dt><dd><p>プリンタのスプーリングディレクトリから、 ジョブの古いファイルを削除します。状況によって、 とりわけ、印字途中でエラーが発生していたり、 管理操作が頻発していた場合には、 ジョブで作られたファイルを LPD が完全に削除しないことがあります。このコマンドでは、 スプーリングディレクトリに入っていないファイルを見つけ出し、 それを削除しています。</p></dd><dt class=hdlist1><code>disable printer-name</code></dt><dd><p>キューに新しいジョブを入れることを禁止します。 プリンタが動作しているときは、 キューに残っているジョブの印字は続けられます。ただし、 キューが禁止状態にあったとしても、スーパーユーザ (<code>root</code>) は常にジョブを入力することができます。</p><div class=paragraph><p>このコマンドは、 新しいプリンタやフィルタを設置している間に使用すると有用です。 すなわち、キューを禁止状態にしておくと、 <code>root</code> によるジョブのみが入力されます。 そして、他のユーザは、テストが完了し、 <code>enable</code> コマンドでキューが再度許可状態になるまで、 ジョブの入力はできなくなります。</p></div></dd><dt class=hdlist1><code>down printer-name message</code></dt><dd><p>プリンタをダウンさせます。これは、 <code>disable</code> をおこなった後で、 <code>stop</code> をおこなった場合と等価になります。 <em>message</em> は、ユーザが <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> コマンドでプリンタのキューの状態を調べたり、 <code>lpc status</code> でプリンタの状態を調べたときに、 プリンタの状況として表示されるメッセージです。</p></dd><dt class=hdlist1><code>enable printer-name</code></dt><dd><p>プリンタのキューを許可状態にします。 ユーザはジョブの入力ができるようになりますが、 プリンタがスタートの状態になるまでは、 プリンタからは何も印字されません。</p></dd><dt class=hdlist1><code>help command-name</code></dt><dd><p><em>command-name</em> コマンドのヘルプメッセージを表示します。 <em>command-name</em> が指定されなかった場合は、 利用できるコマンドの要約が表示されます。</p></dd><dt class=hdlist1><code>restart printer-name</code></dt><dd><p>プリンタをスタートさせます。通常のユーザは、 LPD がある異常な状況でハングしたときに限り、 このコマンドを使用することができます。しかし、 <code>stop</code> または <code>down</code> コマンドにより、 停止状態にあるプリンタをスタートさせることはできません。 <code>restart</code> コマンドは、 <code>abort</code> の後に <code>start</code> をおこなったことと同じになります。</p></dd><dt class=hdlist1><code>start printer-name</code></dt><dd><p>プリンタをスタートさせます。 プリンタのキューにあるジョブを印字することでしょう。</p></dd><dt class=hdlist1><code>stop printer-name</code></dt><dd><p>プリンタを停止します。プリンタは、 現在のジョブを終了させ、そして、 キューにあるその他のジョブは印字しません。 プリンタが停止状態にあったとしても、まだ、 許可状態にあるキューに対して、ジョブを送ることができます。</p></dd><dt class=hdlist1><code>topq printer-name job-or-username</code></dt><dd><p><em>printer-name</em> のキューに対して、ジョブ番号 <em>job</em> のジョブ、または、ユーザ <em>username</em> から送られたジョブを置き換えて、キューの先頭に持ってきます。 このコマンドに関しては、 <em>printer-name</em> の代わりに <code>all</code> を使用することはできません。</p></dd><dt class=hdlist1><code>up printer-name</code></dt><dd><p>プリンタをアップ状態にします。これの反対のコマンドが <code>down</code> です。<code>start</code> の次に <code>enable</code> をおこなったことと等しくなります。</p></dd></dl></div><div class=paragraph><p>コマンドラインから上記のコマンドを入力すると、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> はこれを受け付けます。コマンドが入力されなかった場合は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> は対話モードに入り、 <code>exit</code>、<code>quit</code>、 または、 ファイル終端文字が入力されるまでコマンドの入力ができます。</p></div></div></div><div class=sect2><h3 id=printing-lpd-alternatives>9.6. 標準スプーラの代替品<a class=anchor href=#printing-lpd-alternatives></a></h3><div class=paragraph><p>このマニュアルを最初から通読されている方ならば、ここまでで、 FreeBSD 付属の LPD スプーリングシステムに関して知っておくべきことすべてを学ばれたことと思います。 多分、このシステムにあるたくさんの欠点について認識できたことでしょう。 そこから "(FreeBSD 上で動作する) スプーリングシステムには他にどのようなものがあるのか" という疑問が自然と湧いてきます。</p></div><div class=dlist><dl><dt class=hdlist1>LPRng</dt><dd><p>"次世代 LPR" を称するLPRng は、 PLP を完全に書き換えたものです。 Patrick Powell と Justin Mason (PLP の主要な管理者) が共同で LPRng を作成しました。 LPRng の本サイトは <a href=http://www.lprng.org/>http://www.lprng.org/</a> です。</p></dd><dt class=hdlist1>CUPS</dt><dd><p>CUPS (the Common UNIX Printing System) は、UNIX® ベースのオペレーティングシステムに対して、 移植性の高い印刷レイヤを提供します。 CUPS は Easy Software Products によって、すべての UNIX® ベンダとユーザに、 標準的な印刷ソリューションを普及するために開発されています。</p><div class=paragraph><p>CUPS は、プリントジョブとキューを管理する基盤として Internet Printing Protocol (IPP) を使っています。機能は限定されますが、 ラインプリンタデーモン (LPD)、 サーバーメッセージブロック　(SMB) や AppSocket (JetDirect とも呼ばれています) プロトコルにも対応しています。 CUPS は、UNIX® に現実的なプリント機能を備えるため、 ネットワークプリンタの検索、 PostScript プリンタ記述言語 (PPD) に基づいた印刷オプションを追加します。</p></div><div class=paragraph><p>CUPS のメインサイトは <a href=http://www.cups.org/>http://www.cups.org/</a> です</p></div></dd><dt class=hdlist1>HPLIP</dt><dd><p>HPLIP (the HP Linux® Imaging and Printing system) は、 HP アプライアンス用に HP が開発した、 プリンタ、スキャナ、ファックスへの対応のためのプログラム群です。 このプログラムでは、印刷機能において CUPS 印刷システムをバックエンドとして利用しています。</p><div class=paragraph><p>HPLIP のメインサイトは、 <a href=http://hplipopensource.com/hplip-web/index.html>http://hplipopensource.com/hplip-web/index.html</a> です。</p></div></dd></dl></div></div><div class=sect2><h3 id=printing-troubleshooting>9.7. トラブルシューティング<a class=anchor href=#printing-troubleshooting></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=lptest&amp;sektion=1&amp;format=html">lptest(1)</a> を使った簡単なテストをおこなった結果、 正しい出 力を得られずに、以下に示すような出力が得られるかもしれません。</p></div><div class=dlist><dl><dt class=hdlist1>しばらくしたら出力される、または、 紙の全体が出てこない</dt><dd><p>プリンタは上で示されたような印字を おこなったのですが、しばらくして止まってしまい、 動かなくなってしまいました。 印字された結果をプリンタから取り出すためには、 プリンタにある PRINT REMAINING ボタン、または、FORM FEED ボタンを押す必要があるようです。</p><div class=paragraph><p>この場合は、 おそらくジョブはプリントをする前に 更にデータが送られてこないか待ち続けているのでしょう。 この問題を解決するためには、プリンタに FORM FEED 文字 (あるいは特定の必要な文字コード) を 送るテキストフィルタを使ってください。 プリンタ内部に残ったデータをプリンタにすぐに印字させるには、 普通はこれで十分です。 次のジョブが前のジョブの最終ページの中央の どこかから印字を開始させないためにも、 紙の途中で印字のジョブが終了したかどうかを確認するのは有益です。</p></div><div class=paragraph><p>シェルスクリプト <span class=filename>/usr/local/libexec/if-simple</span> を次のように変更して、プリンタへジョブを送信した後に FORM FEED 文字を印字させるようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# if-simple - Simple text input filter for lpd
# Installed in /usr/local/libexec/if-simple
#
# Simply copies stdin to stdout.  Ignores all filter arguments.
# Writes a form feed character (\f) after printing job.

/bin/cat &amp;&amp; printf &#34;\f&#34; &amp;&amp; exit 0
exit 2</pre></div></div></dd><dt class=hdlist1>"階段効果" が現れた</dt><dd><p>出力された紙には次のように印字されていました。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>!</span><span class=s2>&#34;#</span><span class=nv>$%</span><span class=s2>&amp;&#39;()*+,-./01234
                 &#34;</span><span class=c>#$%&amp;&#39;()*+,-./012345</span>
                                 <span class=c>#$%&amp;&#39;()*+,-./0123456</span></code></pre></div></div><div class=paragraph><p>あなたは<em>「階段効果」</em> の新たなる犠牲者になってしまいました。この原因は、 改行を表わすべき文字がなんであるか の解釈が混乱していることにあります。UNIX® スタイルのオペレーティングシステムでは、改行文字は ASCII コード 10 の line feed (LF) の 1 文字が使われています。MS-DOS® や OS/2® などは ASCII コード 10の LF <em>と</em>、ASCII コード 13 の文字 (carriage return または CR) をペアで使います (訳注: Macintosh では CR のみで表現されています)。大抵のプリンタでは、 改行を表わすために MS-DOS® の慣習にしたがいます。</p></div><div class=paragraph><p>FreeBSD で印字する場合、印字したテキストは LF 文字だけ が使われていました。プリンタでは LF 文字を見つけると、紙を 1 行分送り出しました。しかし、 次の文字を印字するた めの紙の水平方向の位置は維持されました。すなわち、CR 文字が意味することは、 次の文字を印字する位置を紙の左端に動かすことです。</p></div><div class=paragraph><p>FreeBSD がプリンタに動作をして欲しいと思っている動作を以下に示します。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>プリンタが CR を受け取ったとき</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CR 動作 (復帰) をおこなう</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>プリンタが LF を受け取ったとき</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CR + LF 動作 (復帰、改行) をおこなう</p></td></tr></tbody></table><div class=paragraph><p>このように動作させるための方法がいくつかあります。</p></div><div class=ulist><ul><li><p>これらの文字の解釈を変えるために、 プリンタの設定スイッチかコントロールパネルを操作する方法。 どのようにして設定をするかはプリンタのマニュアルを参照してください。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 以外のオペレーティングシステムを切り替えて使う場合、 CR と LF 文字の解釈をそのオペレーティングシステムで使われているようにプリンタを <em>再設定</em>する必要があるかもしれません。 以下に示す解決方法のいずれかを 選ぶのがよいかもしれませんね。</p></div></td></tr></tbody></table></div></li><li><p>自動的に LF を CR+LF に変換してくれる FreeBSD 用のシリアルドライバを入手する方法。 もちろん、このドライバはプリンタ専用に接続される シリアルポート <em>のみ</em>で動作します。 この機能を許可するためには、 <code>ms#</code> 項目を使い、 対象プリンタの <span class=filename>/etc/printcap</span> ファイルで<code>onlcr</code> モードを設定します。</p></li><li><p>LF 文字の扱いを一時的に変更するための <em>エスケープコード</em> をプリンタに送る方法。 プリンタがサポートしているかもしれないエスケープコード については、 プリンタのマニュアルを参照してください。 適切なエスケープコードが見つかったら、 最初にそのコードを送り、次にプリントジョブを送信 するようにテキストフィルタを変更してください。</p><div class=paragraph><p>次に、Hewlett Packard 社の PCL エスケープコードに対応しているプリンタのための テキストフィルタの例を示します。 このフィルタでは、プリンタ に LF 文字を LF と CR の2文字として扱わせます。 その後に、プリンタにジョブを送ります。最後に、 ジョブの最終ページの紙を排出するため、FROM FEED 文字を送ります。このフィルタは Hewlett Packard 社のほとんどすべてのプリンタで機能するはずです。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# hpif - Simple text input filter for lpd for HP-PCL based printers
# Installed in /usr/local/libexec/hpif
#
# Simply copies stdin to stdout.  Ignores all filter arguments.
# Tells printer to treat LF as CR+LF.  Ejects the page when done.

printf &#34;\033&amp;k2G&#34; &amp;&amp; cat &amp;&amp; printf &#34;\f&#34; &amp;&amp; exit 0
exit 2</pre></div></div><div class=paragraph><p>ホスト <code>orchid</code> の <span class=filename>/etc/printcap</span> の例を以下に示します。ここには、 一番目のパラレルポートにプリンタ (Hewlett Packard LaserJet 3Si) が一台接続されており、そのプリンタ名は <code>teak</code> です。</p></div><div class="literalblock programlisting"><div class=content><pre>#
#  /etc/printcap for host orchid
#
teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\
        :lp=/dev/lpt0:sh:sd=/var/spool/lpd/teak:mx#0:\
        :if=/usr/local/libexec/hpif:</pre></div></div></li></ul></div></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>LF を CR+LF に置き換える cat コマンドを作る方法も当然考えられます。 そして、このコマンドと、<em>if-simple</em> の cat の部分を置き換えればよいわけです。 具体的にどのようにするかは、 読者への練習問題としましょう。</p></div></td></tr></tbody></table></div><div class=dlist><dl><dt class=hdlist1>各行が重ね書きされてしまった</dt><dd><p>プリンタは紙送りをまったくしませんでした。 テキストすべての行がある行の上で重ねて印字されてしまいました。</p><div class=paragraph><p>この問題は、 階段現象とは "正反対" な問題で、 ほとんどまれにしか起こりません。FreeBSD では行末として扱われる LF 文字が、紙の左端に印字位置を復帰しますが、 紙送りはしない CR 文字として扱われています。</p></div><div class=paragraph><p>プリンタの設定スイッチかコントロールパネルを使って、 LF と CR の文字を次のような解釈をするようにしてください。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">プリンタが受け取ったとき</th><th class="tableblock halign-left valign-top">プリンタがおこなう</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CR 動作 (復帰)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>LF</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CR + LF (復帰、改行)</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>LF を CR+LF に置き換える cat コマンドを作る方法も当然考えられます。 そして、このコマンドと、 <span class=filename>if-simple</span> の cat の部分を置き換えればよいわけです。 具体的にどのようにするかは、 読者への練習問題としましょう。</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>プリンタが文字を紛失してしまう</dt><dd><p>印字しているのですが、 各行の 2 ～ 3 文字が印字されません。 プリンタを動かせば動かすほど、 もっとたくさんの文字が紛失されていき、 この問題は更に悪くなっていくかもしれませんでした。</p><div class=paragraph><p>この問題は、 シリアルポートを通してコンピュータから送られてくるデータの速度に、 プリンタがついていけないことに起因します (この問題は、パラレルポートに接続された プリンタでは発生することはありません)。 この問題を克服する方法が2つあります。</p></div><div class=ulist><ul><li><p>プリンタが XON/XOFF のフロー制御をサポート している場合は、項目 <code>ms#</code> で <code>ixon</code> モードをセットして、FreeBSD にこの機能を使用させてください。</p></li><li><p>プリンタが Request to Send / Clear to Send ハードウェアハンドシェイク (通称 <code>RTS/CTS</code>) をサポートして いる場合は、項目 <code>ms#</code> で <code>crtscts</code> モードをセットして下さい。それから、 プリンタとコンピュータを接続しているシリアルケーブルが ハードウェアフロー制御用に正しく配線されたものかどうかを確認してください。</p></li></ul></div></dd><dt class=hdlist1>プリンタは意味不明な文字列を印字した</dt><dd><p>プリンタはランダムなゴミのように 見えるものを印字しましたが、 意図したテキストは印字してくれませんでした。</p><div class=paragraph><p>この問題は、通常、 シリアルポートに接続したプリンタでの 通信パラメータの誤りからくる前項とは別の症状です。 <code>br</code> 項目の通信速度と <code>ms#</code> 項目を再確認してください。 また、プリンタでの設定が <span class=filename>/etc/printcap</span> ファイルで設定した 内容と一致しているかどうかも確認してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>simple-if のような単純なフィルタだけの状態で、 日本語を含むテキストを印字しようとした場合にも、 シリアルポート、パラレルポートの使用に関係なく、 このような症状は見られます。日本語プリンタの場合、 漢字コードそのもの を送信しただけでその漢字を印字してくれるものは、 少なくとも訳者は見たことがありません。 漢字を印字するための制御 コードを別途送信するフィルタが必要となります。 また、そのようなフィルタを使用していても、 そのフィルタが想定してる漢字コードと異なった文書を プリントしようとしたときもこのような症状は出ます。 もちろん、これはプリンタ用の 言語を持たないプリンタの話で、PostScript® プリンタ などにプレインテキストを送信しても、日本語対応、 非対応に関らず、意味不明な文字列が印字される (もしくは、何も印字されない) ことでしょう。</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>何も起きない</dt><dd><p>もしプリンタが何の動作もしないのであれば、 ハード的な問題ではなく、多分 FreeBSD の中に問題があります。 <span class=filename>/etc/printcap</span> ファイルで、 デバッグしているプリンタのエントリに (<code>lf</code> 項目で) ログファイルを取るように 設定を追加してください。たとえば、プリンタ <code>rattan</code> 用のエントリの項目 <code>lf</code> は次のようになります。</p><div class="literalblock programlisting"><div class=content><pre>rattan|line|diablo|lp|Diablo 630 Line Printer:\
        :sh:sd=/var/spool/lpd/rattan:\
        :lp=/dev/lpt0:\
        :if=/usr/local/libexec/if-simple:\
        :lf=/var/log/rattan.log</pre></div></div><div class=paragraph><p>次に、もう一度印字をおこなってみます。そして、 発生したと思われるエラーメッセージを見るためにログファイル (上記の例では、 <span class=filename>/var/log/rattan.log</span>) を調べます。そこで見られたメッセージを元に、 問題を解決してみてください。</p></div><div class=paragraph><p>項目 <code>lf</code> が指定されていない場合、LPD はデフォルトのログファイルとして <span class=filename>/dev/console</span> を使います。</p></div></dd></dl></div></div></div></div><div class=sect1><h2 id=linuxemu>Chapter 10. Linux® バイナリ互換機能<a class=anchor href=#linuxemu></a></h2><div class=sectionbody><div class=sect2><h3 id=linuxemu-synopsis>10.1. この章では<a class=anchor href=#linuxemu-synopsis></a></h3><div class=paragraph><p>FreeBSD は、Linux® とのバイナリ互換機能を提供しています。 このバイナリ互換機能を使うことで、ユーザは、ほとんどの Linux® バイナリを変更することなく、FreeBSD システム上にインストールして実行できるようになります。 ある状況においては Linux® バイナリを Linux® で動かすよりも FreeBSD で動かすほうが良いパフォーマンスが出るという報告もあります。</p></div><div class=paragraph><p>しかしながら、いくつかの Linux® に特有なオペレーティングシステムの機能は FreeBSD ではサポートされていません。たとえば、 仮想 8086 モードを有効にするような i386™ 特有の呼び出しを過度に使う Linux® バイナリは FreeBSD では動きません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>64 ビットの Linux® バイナリ互換機能は、 FreeBSD 10.3 で追加されました。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この章を読むと、以下のことがわかります。</p></div><div class=ulist><ul><li><p>FreeBSD システムで Linux® バイナリ互換機能を有効にする方法。</p></li><li><p>Linux® 共有ライブラリを追加する方法。</p></li><li><p>Linux® アプリケーションを FreeBSD システムにインストールする方法</p></li><li><p>FreeBSD における Linux® 互換機能の実装の詳細。</p></li></ul></div><div class=paragraph><p>この章を読む前に、以下のことを理解しておく必要があります。</p></div><div class=ulist><ul><li><p><a href=./#ports>サードパーティ製ソフトウェア</a> のインストール方法</p></li></ul></div></div><div class=sect2><h3 id=linuxemu-lbc-install>10.2. Linux® バイナリ互換機能の設定<a class=anchor href=#linuxemu-lbc-install></a></h3><div class=paragraph><p>Linux® ライブラリは、デフォルトでは FreeBSD にインストールされません。 また、Linux® バイナリ互換機能も、デフォルトでは有効ではありません。 Linux® ライブラリは、手動もしくは FreeBSD Ports Collection を使ってインストールできます。</p></div><div class=paragraph><p>port を構築する前に、 <code>linux</code> カーネルモジュールを読み込んでください。 このモジュールを読み込んでいないと、構築に失敗してしまいます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload linux</span></code></pre></div></div><div class=paragraph><p>64 ビットの互換機能を使うには、以下を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload linux64</span></code></pre></div></div><div class=paragraph><p>以下のようにしてモジュールが読み込まれていることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kldstat
      Id Refs Address    Size     Name
      1    2 0xc0100000 16bdb8   kernel
      7    1 0xc24db000 d000     linux.ko</code></pre></div></div><div class=paragraph><p>Linux® ライブラリおよびバイナリの基本セットを FreeBSD システムにインストールする最も簡単な方法は、 <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base-c7/>emulators/linux_base-c7</a> package または port を使う方法です。port をインストールするには、 以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install emulators/linux_base-c7</span></code></pre></div></div><div class=paragraph><p>起動時から Linux® 互換機能を有効にする場合には、 <span class=filename>/etc/rc.conf</span> に以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>linux_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>64 ビットのコンピュータでは、 <span class=filename>/etc/rc.d/abi</span> により 64 ビット互換のためのモジュールは自動的に読み込まれます。</p></div><div class=paragraph><p>Linux® バイナリ互換機能のレイヤには、(64 ビット x86 ホストにおける) 32 および 64 ビット Linux バイナリのサポートが追加されたため、 エミュレーション機能をカスタムカーネルに静的にリンクする必要はありません。</p></div><div class=sect3><h4 id=linuxemu-libs-manually>10.2.1. 手動によるライブラリの追加のインストール<a class=anchor href=#linuxemu-libs-manually></a></h4><div class=paragraph><p>Linux® バイナリ互換機能を設定した後に、Linux® アプリケーションが必要な共有ライブラリが存在しないというエラーを出した場合には、 Linux® バイナリがどの共有ライブラリを必要としているかを確認して、 手動でインストールしてください。</p></div><div class=paragraph><p>Linux® システムで、<code>ldd</code> を使うことにより、 アプリケーションが必要とする共有ライブラリを調べることができます。 たとえば、<code>linuxdoom</code> が必要とする共有ライブラリを調べるには、 Doom がインストールされている Linux® システム上で、以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ldd linuxxdoom
libXt.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libX11.so.3.1.0
libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> <span class=o>=&gt;</span> /lib/libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Linux® システムでの出力の最後のカラムに表示されているすべてのファイルを FreeBSD システムの <span class=filename>/compat/linux</span> の下にコピーしてください。コピーしたら、 最初のカラムに示されるファイル名でコピーしたファイルに対してシンボリックリンクを張ってください。 この例では、FreeBSD システムで以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p><code>ldd</code> の出力の最初のカラムに表示されているメジャーバージョンが同じ Linux® 共有ライブラリが既にインストールされている場合は、 最後のコラムにある名前のファイルを新たにコピーする必要はありません。 既にあるライブラリで動作するはずです。 ただ、新しいバージョンの共有ライブラリがある場合には、 コピーすることをお奨めします。 新しいライブラリにシンボリックリンクを変更したら、 古いライブラリは削除してかまいません。</p></div><div class=paragraph><p>たとえば、以下のライブラリがすでに FreeBSD システムに存在するとします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</code></pre></div></div><div class=paragraph><p>そして、<code>ldd</code> の出力が以下のように、 バイナリが新しいバージョンを必要とする場合を考えます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>存在しているライブラリの最後の番号が 1 つか 2 つ古いだけなので、 わずかに古いライブラリでもプログラムは動作するはずです。 しかしながら、<span class=filename>libc.so</span> を新しいバージョンに置き換えるのが安全です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>通常は、Linux® のバイナリが必要とする共有ライブラリを探す必要があるのは、 FreeBSD のシステムに Linux® のプログラムをインストールする最初の数回だけです。 それが過ぎれば、十分な Linux® の共有ライブラリがシステムに存在するので、 新しくインストールした Linux® のバイナリも追加の作業をせずに動作させることができるようになります。</p></div></div><div class=sect3><h4 id=_linux_の_elf_バイナリのインストール>10.2.2. Linux® の ELF バイナリのインストール<a class=anchor href=#_linux_の_elf_バイナリのインストール></a></h4><div class=paragraph><p>ELF のバイナリを使うためには、 追加の作業が必要です。 マークのない (unbranded) ELF バイナリを実行しようとすると、 以下のようなエラーメッセージが表示されてしまうことでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./my-linux-elf-binary
ELF binary <span class=nb>type </span>not known
Abort</code></pre></div></div><div class=paragraph><p>FreeBSD のカーネルが FreeBSD の ELF バイナリと Linux® のバイナリとを見分けられるようにするために、<a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a> を以下のようにして使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% brandelf <span class=nt>-t</span> Linux my-linux-elf-binary</code></pre></div></div><div class=paragraph><p>GNU のツール群が ELF バイナリに自動的に適切なマークを付加するようになったので、 この作業は通常必要ありません。</p></div></div><div class=sect3><h4 id=_linux_rpm_ベースのアプリケーションのインストール>10.2.3. Linux® RPM ベースのアプリケーションのインストール<a class=anchor href=#_linux_rpm_ベースのアプリケーションのインストール></a></h4><div class=paragraph><p>Linux® RPM ベースのアプリケーションをインストールするには、 最初に <a class=package href=https://cgit.freebsd.org/ports/tree/archivers/rpm4/>archivers/rpm4</a> package または port をインストールしてください。 インストールすると、このコマンドを <code>root</code> 権限で使うことで、 <span class=filename>.rpm</span> をインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /compat/linux</span>
<span class=c># rpm2cpio &lt; /path/to/linux.archive.rpm | cpio -id</span></code></pre></div></div><div class=paragraph><p>必要に応じて、インストールした ELF バイナリに <code>brandelf</code> を実行してください。 綺麗にアンインストールできないかもしれませんので注意してください。</p></div></div><div class=sect3><h4 id=_ホストネームリゾルバの設定>10.2.4. ホストネームリゾルバの設定<a class=anchor href=#_ホストネームリゾルバの設定></a></h4><div class=paragraph><p>DNS がうまく動作しなかったり、 以下のようなエラーメッセージが表示される場合は、 <span class=filename>/compat/linux/etc/host.conf</span> ファイルを以下のように設定する必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>resolv+: <span class=s2>&#34;bind&#34;</span> is an invalid keyword resolv+:
<span class=s2>&#34;hosts&#34;</span> is an invalid keyword</code></pre></div></div><div class=paragraph><p>ファイルの内容を以下のように設定してください。</p></div><div class="literalblock programlisting"><div class=content><pre>order hosts, bind
multi on</pre></div></div><div class=paragraph><p>この設定では <span class=filename>/etc/hosts</span> を最初に検索し、 次に DNS を検索するように指定します。 <span class=filename>/compat/linux/etc/host.conf</span> が存在しない場合には、 Linux® アプリケーションは <span class=filename>/etc/host.conf</span> を使用しようとし、 FreeBSD の文法とは互換性がないと警告を出力します。 <span class=filename>/etc/resolv.conf</span> を利用してネームサーバの設定をしていない場合には、 <code>bind</code> を削除してください。</p></div></div></div><div class=sect2><h3 id=linuxemu-advanced>10.3. 高度なトピックス<a class=anchor href=#linuxemu-advanced></a></h3><div class=paragraph><p>この節では、Linux® バイナリ互換機能がどのような仕組みで動作をしているかを説明します。 以下の文章は <a href=https://lists.FreeBSD.org/subscription/freebsd-chat>FreeBSD chat メーリングリスト</a> に投稿された Terry Lambert (<a href=mailto:tlambert@primenet.com>tlambert@primenet.com</a>) 氏のメール (Message ID: <code>&lt;<a href=mailto:199906020108.SAA07001@usr09.primenet.com>199906020108.SAA07001@usr09.primenet.com</a>></code>) をもとにしています。</p></div><div class=paragraph><p>FreeBSD は、"実行クラスローダ (execution class loader) " と呼ばれる抽象的な機構を持っています。これは <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> システムコールへの楔という形で実装されています。</p></div><div class=paragraph><p>歴史的には、UNIX® のローダはマジックナンバー (一般的にはファイルの先頭の 4 ないし 8 バイトの部分) の検査を行ない、システムで実行できるバイナリかどうかを検査し、 もしそうならバイナリローダを呼び出すというようになっていました。</p></div><div class=paragraph><p>もし、そのシステム用のバイナリでない場合には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> システムコールの呼び出しは失敗の戻り値を返し、 シェルがシェルコマンドとして実行しようと試みていたわけです。 この仮定は"現在利用しているシェルがどのようなものであっても"デフォルトでした。</p></div><div class=paragraph><p>後に <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> に変更が加えられ、先頭の 2 バイトを検査した結果 <code>:\n</code> であれば代わりに <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> を呼び出す、 というようになりました。</p></div><div class=paragraph><p>FreeBSD は、単一のローダではなく、ローダの一覧を走査します。 動作しているシェルインタプリタもしくはシェルスクリプトとして、 該当するものが存在しなければ、<code>#!</code> ローダが用いられます。</p></div><div class=paragraph><p>Linux® ABI をサポートするため、FreeBSD は ELF バイナリを示すマジックナンバを確認します。 ELF ローダは、特殊な<em>マーク (brand)</em> があるかどうか探します。 このマークとは、ELF イメージのコメントセクションのことです。 SVR4/Solaris™ の ELF バイナリには、このセクションは存在しません。</p></div><div class=paragraph><p>Linux® バイナリを実行するためには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a> を使って <code>Linux</code> のマークが<em>付けられて</em>いなければなりません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># brandelf -t Linux file</span></code></pre></div></div><div class=paragraph><p>ELF ローダが <code>Linux</code> マークを確認すると、 ローダは <code>proc</code> 構造体内の ある一つのポインタを置き換えます。システムコールは全て、 このポインタを通してインデックスされます。 さらに、そのプロセスには Linux® カーネルモジュールに必要なシグナルトランポリンコード (訳注: シグナルの伝播を実現するコード) 用の特殊なトラップベクタの設定や、 他の (細かな) 調整のための設定が行なわれます。</p></div><div class=paragraph><p>Linux® システムコールベクタは、 さまざまなデータに加えて <code>sysent[]</code> エントリーのリストを含んでおり、 それらのアドレスはカーネルモジュール内にあります。</p></div><div class=paragraph><p>Linux® バイナリがシステムコールを発行する際、トラップコードは <code>proc</code> 構造体を用いてシステムコール関数ポインタを 解釈します。そして FreeBSD ではなく Linux® 用のシステムコールエントリポイントを得るわけです。</p></div><div class=paragraph><p>Linux® モードは状況に応じて<em>ファイルシステム本来のルートマウントポイントを置き換えて</em>ファイルの参照を行ないます。 これは、<code>union</code> を指定してマウントされたファイルシステムが行なっていることと同じです。 ファイルを検索する際にはまず <span class=filename>/compat/linux/original-path</span> を調べます。見つけられなかったときには、 <span class=filename>/original-path</span> を調べます。 こうすることで、他のバイナリを要求するバイナリの実行を可能にしています。 たとえば、Linux® 用ツールチェインは Linux® ABI サポート環境下で完全に動作します。 またこれは、もし対応する Linux® バイナリが存在しない場合に Linux® バイナリが FreeBSD バイナリをロードしたり、 実行したりすることが可能であること、 その Linux® バイナリに自分自身が Linux® 上で実行されていないことを 気付かせないようにする目的で、<a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> コマンドを <span class=filename>/compat/linux</span> ディレクトリに置くことができる、 ということを意味します。</p></div><div class=paragraph><p>要するに、Linux® カーネルが FreeBSD カーネルの内部に存在しているわけです。 カーネルによって提供されるサービス全ての実装の基礎となるさまざまな関数は FreeBSD システムコールテーブルエントリと Linux® システムコールテーブルエントリの両方で共通に利用されています。 これらにはファイルシステム処理、仮想メモリ処理、シグナル伝送、 System V IPC が含まれますが、 FreeBSD バイナリは FreeBSD <em>グルー</em> (訳注: glue; 二者の間を仲介するという意味) 関数群、 そして Linux® バイナリは Linux® <em>グルー</em>関数群を用いる、 という点だけが異なります。 FreeBSD の<em>グルー</em>関数群は、 カーネルの中に静的にリンクされ、 Linux® の<em>グルー</em>関数群は静的にリンクすることも、 カーネルモジュールを介して利用することもできるようになっています。</p></div><div class=paragraph><p>技術的には、これはエミュレーションではなく、 ABI の実装です。 よく "Linux® エミュレーション"と呼ばれるのは、 この機能が初めて実装された頃、 この機能を表現する言葉がなかったためです。 コードをコンパイルしてはいないので、 FreeBSD 上で Linux® バイナリを実行するという表現は、 厳密に考えると適切ではありません。</p></div></div></div></div><h1 id=system-administration class=sect0>Part III: システム管理<a class=anchor href=#system-administration></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>以下の章では、 FreeBSD のシステム管理の面について書かれています。 各章のはじめでは、その章で学ぶ内容や、 読者が実際に取り組む前に知っておくべきことについて説明します。</p></div><div class=paragraph><p>各章は、必要になった時に個別に参照できるように構成されています。 どの順番で読んでも構いませんし、FreeBSD を使うのに、 すべてを読み通す必要がある、というわけでもありません。</p></div></div></div><div class=sect1><h2 id=config-tuning>Chapter 11. 設定とチューニング<a class=anchor href=#config-tuning></a></h2><div class=sectionbody><div class=sect2><h3 id=_この章では>11.1. この章では<a class=anchor href=#_この章では></a></h3><div class=paragraph><p>システムを正しく設定することは、 メンテナンスや将来の更新の際の作業の量を減らします。 この章では FreeBSD システムの管理上の設定の側面について記述します。</p></div><div class=paragraph><p>またこの章では FreeBSD システムのパフォーマンスを最適化する チューニングについても記述します。</p></div><div class=paragraph><p>この章を読むと、以下のことがわかります。</p></div><div class=ulist><ul><li><p><span class=filename>rc.conf</span> の設定と <span class=filename>/usr/local/etc/rc.d</span> スタートアップシステムの基礎</p></li><li><p>ネットワークデバイスに対する、仮想ホストの設定方法</p></li><li><p><span class=filename>/etc</span> ディレクトリ内のさまざまな設定ファ イルの使い方</p></li><li><p><code>sysctl</code> 変数を使った FreeBSD のチューニング方法</p></li><li><p>ディスク性能のチューニング方法と、カーネルの制限の変更方法</p></li></ul></div><div class=paragraph><p>この章を読む前に、以下のことをやっておくとよいでしょう。</p></div><div class=ulist><ul><li><p>Unix と FreeBSD の基本を理解する (<a href=./#basics>UNIX の基礎知識</a>)。</p></li><li><p>FreeBSD のソースコードを最新に保つこと (<a href=./#updating-upgrading>FreeBSD のアップデートとアップグレード</a>) と、 カーネルコンフィグレーションおよび構築の基礎 (<a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a>) に親しんでおく。</p></li></ul></div></div><div class=sect2><h3 id=configtuning-core-configuration>11.2. 中核となる設定<a class=anchor href=#configtuning-core-configuration></a></h3><div class=paragraph><p>システムの設定情報が収められている主な場所は <span class=filename>/etc/rc.conf</span> です。 このファイルにはシステムの起動時にシステムの設定を行なうものをはじめ 多岐に渡る設定情報が含まれています。 そのファイル名はダイレクトに、それが <span class=filename>rc*</span> ファイル群の設定情報であることを示しています。</p></div><div class=paragraph><p>管理者は <span class=filename>/etc/defaults/rc.conf</span> のデフォルトの設定を <span class=filename>rc.conf</span> ファイルにエン トリを作ることで上書きすべきです。 デフォルトのファイルをそのまま <span class=filename>/etc</span> にコピーするのはやめるべきです。 それはデフォルト値であってサンプルではないのです。 システム固有のすべての変更は <span class=filename>rc.conf</span> ファイ ルの中でするべきです。</p></div><div class=paragraph><p>管理の手間を減らす為、クラスター化されたアプリケーションには サイト共通の設定とシステム固有の設定を分離するさまざまな戦略が適用できます。 推奨されるアプローチは、サイト共通の設定は <span class=filename>/etc/rc.conf.site</span> のような別のファイルに置き、 それをシステム固有の設定情報しか含ませない <span class=filename>/etc/rc.conf</span> からインクルードすることです。</p></div><div class=paragraph><p><span class=filename>rc.conf</span> は <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> によって読み込まれているので、これはじつに簡単に達成できます。 たとえば、</p></div><div class=ulist><ul><li><p>rc.conf:</p><div class="literalblock programlisting"><div class=content><pre>	. rc.conf.site
	hostname=&#34;node15.example.com&#34;
	network_interfaces=&#34;fxp0 lo0&#34;
	ifconfig_fxp0=&#34;inet 10.1.1.1&#34;</pre></div></div></li><li><p>rc.conf.site:</p><div class="literalblock programlisting"><div class=content><pre>	defaultrouter=&#34;10.1.1.254&#34;
	saver=&#34;daemon&#34;
	blanktime=&#34;100&#34;</pre></div></div></li></ul></div><div class=paragraph><p><span class=filename>rc.conf.site</span> ファイルは <code>rsync</code> のようなプログラムを使うことで全システ ムに配布でき、一方 <span class=filename>rc.conf</span> ファイルはユニークなままを保つことができます。</p></div><div class=paragraph><p>システムを <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> や <code>make world</code> 等で 更新した場合 <span class=filename>rc.conf</span> ファイルは上書きされません。 なのでシステムの設定情報が失われることもありません。</p></div></div><div class=sect2><h3 id=configtuning-appconfig>11.3. アプリケーションの設定<a class=anchor href=#configtuning-appconfig></a></h3><div class=paragraph><p>基本的に、インストールされたアプリケーションには独自の文法を持つ 固有の設定ファイルがあります。 これらのファイルがベースシステムから分離されているということは重要で、 このためパッケージ管理ツールによる配置と管理が容易になっています。</p></div><div class=paragraph><p>基本的に、それらのファイルは <span class=filename>/usr/local/etc</span> にインストールされます。 設定ファイルの数が多数にのぼるアプリケーションに対しては、 それら用にサブディレクトリが作られます。</p></div><div class=paragraph><p>通常、ports やパッケージがインストールされると 設定ファイルのサンプルが一緒にインストールされます。 大抵、識別のためにサフィックスとして ".default" がついています。 アプリケーションのための設定ファイルがまだ存在していなければ、 .defaults ファイルをコピーすることで作成できます。</p></div><div class=paragraph><p><span class=filename>/usr/local/etc/apache</span> ディレクトリの例をご覧ください。</p></div><div class=literalblock><div class=content><pre>-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</pre></div></div><div class=paragraph><p>ファイルサイズの差から、<span class=filename>srm.conf</span> ファイルだけが変更されていることが分かります。 後に apache を更新した時にも、 この変更されたファイルは上書きされることはありません。</p></div></div><div class=sect2><h3 id=configtuning-starting-services>11.4. サービスの起動<a class=anchor href=#configtuning-starting-services></a></h3><div class=paragraph><p>一つのシステムでサービスをいくつも立ち上げているということは よくあることです。 それらには独自の立ち上げかたがあることがあり、 それぞれ有利な点があります。</p></div><div class=paragraph><p>Ports collection やパッケージからインストールしたソフトウェアは しばしば <span class=filename>/usr/local/etc/rc.d</span> にスクリプトを置き、 システムが起動した時には <code>start</code>、システムをシャッ トダウンする時には <code>stop</code> を引数にして実行します。 これは <code>root</code> で実行すべき、または <code>root</code> で起動することを期待されているシステム ワイドなサービスを起動する場合に推奨される方法です。 これらのスクリプトはパッケージの一部としてインストール時に記録され、 パッケージとともに削除されます。</p></div><div class=paragraph><p><span class=filename>/usr/local/etc/rc.d</span> にある 一般的なスクリプトは次のようなものです。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
echo -n &#39; FooBar&#39;

case &#34;$1&#34; in
start)
        /usr/local/bin/foobar
        ;;
stop)
        kill -9 `cat /var/run/foobar.pid`
        ;;
*)
        echo &#34;Usage: `basename $0` {start|stop}&#34; &gt;&amp;2
        exit 64
        ;;
esac

exit 0</pre></div></div><div class=paragraph><p>このスクリプトはその目的を果すべく起動時に <code>start</code>、 シャットダウン時に <code>stop</code> をつけて呼ばれます。</p></div><div class=paragraph><p>サービスの中には固有のポートに接続を受けたときに <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> から起動されるものもあります。 これはメールリーダサーバ (POP や IMAP 等) の場合によくあります。 これらのサービスは <span class=filename>/etc/inetd.conf</span> ファイルを編集することで有効化されます。 このファイルの編集に関する詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> を見てください。</p></div><div class=paragraph><p>これらの他に <span class=filename>/etc/rc.conf</span> による有効化/無効化がカバーされていないサービスもあります。 それらは伝統的に <span class=filename>/etc/rc.local</span> にコマンドを書き込むことで実行されていました。 FreeBSD 3.1 にはデフォルトの <span class=filename>/etc/rc.local</span> は存在していません。 もし管理者によって作られていれば、 その時は一般的なやりかたとして認められるべきでしょう。 <span class=filename>rc.local</span> は最後の場所と考えられているということを 知っておいてください。 サービスを起動させるのにもっといい場所があるなら そこから始めてください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/rc.conf</span> でその他のコマンドを実行<em>しないでください</em>。 そのかわり、デーモンの起動やブート時のコマンド実行は <span class=filename>/usr/local/etc/rc.d</span> にスクリプトを配置してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この他にサービスの起動に <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> を利用することもできます。 このアプローチには、<a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> がそのプロセスを <code>crontab</code> の所有者権限で実行したり、サービスが 非特権ユーザによって立ち上げられ管理されるなどといった有利な点が いくつもあります。</p></div><div class=paragraph><p>これで <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> の機能の利点を得ることができます。 日時の指定を <code>@reboot</code> で置き換えることでジョブは システムがブートした直後、<a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> が起動した時に実行されます。</p></div></div><div class=sect2><h3 id=configtuning-virtual-hosts>11.5. バーチャルホスト<a class=anchor href=#configtuning-virtual-hosts></a></h3><div class=paragraph><p>FreeBSD の非常にありふれた用途の一つにバーチャルサイトの ホスティングがあります。 これは一つのサーバがネットワークには複数のサーバとして現れるものです。 これは一つのネットワークインタフェイスに 複数のアドレスを割当てることで実現されます。</p></div><div class=paragraph><p>ネットワークインタフェイスは "真の" アドレスを 一つと "別名" のアドレスを複数持ちます。これらの別 名は通常 <span class=filename>/etc/rc.conf</span> に別名のエントリを置くことで追加されます。</p></div><div class=paragraph><p><span class=filename>fxp0</span> インタフェイスへの別名のエント リは以下の様なものです。</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>別名のエントリは alias0 から始まり昇順に命名されなければなり ません (たとえば、_alias1, _alias2 の様になります)。設定プロセス は最初に欠けた番号のところで停まります。</p></div><div class=paragraph><p>別名のネットマスクの計算は重要ですが、幸いなことに非常に簡単です。 個々のインタフェイスについてそのネットワークのネットマスクを正しく 表現しているアドレスが必ず一つ必要です。 そのネットワークに所属しているそれ以外のアドレスのネットマスクは すべて 1 でなければなりません。</p></div><div class=paragraph><p>例として、<span class=filename>fxp0</span> インタフェイスが二つ のネットワークに接続されているものを考えてみましょう。 一つはネットマスクが 255.255.255.0 である 10.1.1.0 ネットワークで、もう一つはネットマスクが 255.255.255.240 である 202.0.75.16 ネットワークです。 システムは 10.1.1.0 には 10.1.1.1 として、 202.0.75.20 には 202.0.75.17 として現れるようにします。</p></div><div class=paragraph><p>以下のエントリはネットワークインタフェイスを上述の環境に正しく 設定するものです。</p></div><div class="literalblock programlisting"><div class=content><pre> ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
 ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
 ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div></div><div class=sect2><h3 id=configtuning-configfiles>11.6. 設定ファイル<a class=anchor href=#configtuning-configfiles></a></h3><div class=sect3><h4 id=_etc_のレイアウト>11.6.1. <span class=filename>/etc</span> のレイアウト<a class=anchor href=#_etc_のレイアウト></a></h4><div class=paragraph><p>設定のための情報が含まれているディレクトリはたくさんあります。 それぞれ以下のものを含んでいます。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>システム全般の設定情報。 ここにあるデータはシステム 固有のものです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>デフォルトのシステム設定ファイル。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>追加的な <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> の設定、他の MTA の設定ファイル。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザモード、およびカーネルモードの ppp プログラムの設定。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> のデータのデフォルトの置場。通常 boot ファイルはここに置かれ、 <span class=filename>/var/db</span> に置かれた他のデータを 参照するディレクティブを含みます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>インストールされたアプリケーションの設定ファイル。 アプリケーションごとのサブディレクトリを含んでいることがあります。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>インストールされたアプリケーションの起動/停止スクリプト。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>永続的なシステム固有のデータファイル。 たとえば <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> のゾーンファイル、データベースファイル等。</p></td></tr></tbody></table></div><div class=sect3><h4 id=_ホスト名>11.6.2. ホスト名<a class=anchor href=#_ホスト名></a></h4><div class=sect4><h5 id=_etcresolv_conf>11.6.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h5><div class=paragraph><p><span class=filename>/etc/resolv.conf</span> は FreeBSD に インターネットドメインネームシステム (DNS) にどのようにアクセスするかを指定します。</p></div><div class=paragraph><p><span class=filename>resolv.conf</span> の最もよくあるエントリは</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>リゾルバが問い合わせるべきネームサーバの IP アドレス。 サーバはリストの順に 3 番目まで問い合わせられます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ホスト名をルックアップするための検索リスト。 通常、ローカルなホスト名のドメインから決定されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ローカルドメイン名。</p></td></tr></tbody></table><div class=paragraph><p>基本的な <span class=filename>resolv.conf</span>。</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>search</code> オプションと <code>domain</code> オプションは、 どちらか一方しか使ってはいけません。</p></div></td></tr></tbody></table></div><div class=paragraph><p>DHCP を利用している場合、<a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> は通常 <span class=filename>resolv.conf</span> を DHCP サーバから受け取っ た情報で書き換えます。</p></div></div><div class=sect4><h5 id=_etchosts>11.6.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h5><div class=paragraph><p><span class=filename>/etc/hosts</span> は古きインターネットを 偲ばせるシンプルなテキストのデータベースです。 これはホスト名と IP アドレスをマッピングする DNS や NIS と組み合わせて使われます。 LAN でつながれているローカルな計算機は、 名前引きを簡単にするために <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> サーバを立ち上げるかわりにここに書くことができます。 さらに <span class=filename>/etc/hosts</span> はインターネット名のローカルなレコードを提供し、 よくアクセスされる名前を外部に問い合わせるのを減らすためにも使えます。</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates&#39;).
#</pre></div></div><div class=paragraph><p><span class=filename>/etc/hosts</span> は、 次のようなごく簡単なフォーマットになっています。</p></div><div class="literalblock programlisting"><div class=content><pre>[インターネットアドレス] [正式なホスト名] [別名1] [別名2] ...</pre></div></div><div class=paragraph><p>例:</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>これ以上の情報は <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> をあたってください。</p></div></div></div><div class=sect3><h4 id=_ログファイルに関係する設定>11.6.3. ログファイルに関係する設定<a class=anchor href=#_ログファイルに関係する設定></a></h4><div class=sect4><h5 id=_syslog_conf>11.6.3.1. <span class=filename>syslog.conf</span><a class=anchor href=#_syslog_conf></a></h5><div class=paragraph><p><span class=filename>syslog.conf</span> は <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> プログラムのための設定ファイルです。 これはどのタイプの <code>syslog</code> メッセージを対応する ログファイルに記録するかを指定します。</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</pre></div></div><div class=paragraph><p>これ以上の情報は <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> のマニュアルページに あたってください。</p></div></div><div class=sect4><h5 id=_newsyslog_conf>11.6.3.2. <span class=filename>newsyslog.conf</span><a class=anchor href=#_newsyslog_conf></a></h5><div class=paragraph><p><span class=filename>newsyslog.conf</span> は、通常 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> によって予定を決めて実行されるプログラム <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> のための設定ファイルです。 <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> は、 ログファイルをいつ保存して再編するかを決定します。 <span class=filename>logfile</span> は <span class=filename>logfile.0</span> に移され、<span class=filename>logfile.0</span> は <span class=filename>logfile.1</span> に、そして以下同様に移されます。 また、ログファイルを <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a> 形式で保存することもできます。 この場合ファイル名は <span class=filename>logfile.0.gz</span>, <span class=filename>logfile.1.gz</span> の様になります。</p></div><div class=paragraph><p><span class=filename>newsyslog.conf</span> はどのログファイルが管理され、どのくらいの期間保存され、 そしていつ touch されるかを指定します。 ログファイルはあるサイズに到達するか、ある決められた時刻・ 日時で再編されあるいは保存されます。</p></div><div class="literalblock programlisting"><div class=content><pre># configuration file for newsyslog
# $FreeBSD$
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</pre></div></div><div class=paragraph><p>これ以上の情報は <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> のマニュアルページに あたってください。</p></div></div></div><div class=sect3><h4 id=_sysctl_conf>11.6.4. <span class=filename>sysctl.conf</span><a class=anchor href=#_sysctl_conf></a></h4><div class=paragraph><p><span class=filename>sysctl.conf</span> は <span class=filename>rc.conf</span> によく似ています。 値は<code>変数=値</code>のかたちでセットされます。 指定された値はシステムがマルチユーザモードに移行した後でセットされます。 すべての変数がこのモードで設定可能というわけではありません。</p></div><div class=paragraph><p>以下は <span class=filename>sysctl.conf</span> のサンプルで 致命的なシグナルを記録しないように、また Linux プログラムに それらが実際は FreeBSD 上で動いていることを知らせる様に チューニングしています。</p></div><div class="literalblock programlisting"><div class=content><pre>kern.logsigexit=0       # Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=FreeBSD
compat.linux.osrelease=4.3-STABLE</pre></div></div></div></div><div class=sect2><h3 id=configtuning-sysctl>11.7. sysctl によるチューニング<a class=anchor href=#configtuning-sysctl></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> は稼働中の FreeBSD システムに変更を加えるためのインタフェイスです。 これには経験を積んだ管理者用の TCP/IP スタックや 仮想メモリシステムのパフォーマンスを劇的に改善する 先進的なオプションが含まれます。 500 を越えるシステム変数を <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> で読んだり セットしたりできます。</p></div><div class=paragraph><p>本質的には <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> の機能は次の二つ、 システムの設定を読むことと変更することです。</p></div><div class=paragraph><p>読み取り可能なすべての変数を表示するには以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>個々の変数、たとえば <code>kern.maxproc</code> を読むには以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>特定の変数をセットするには、直感的な文法 <em>変数</em>=<em>値</em> を使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>sysctl 変数の値は通常、文字列、数値、真偽値のいずれかです。 (真偽値は yes の場合には <code>1</code> で no の場合には <code>0</code> です)。</p></div></div><div class=sect2><h3 id=configtuning-disk>11.8. ディスクのチューニング<a class=anchor href=#configtuning-disk></a></h3><div class=sect3><h4 id=_sysctl_変数>11.8.1. sysctl 変数<a class=anchor href=#_sysctl_変数></a></h4><div class=sect4><h5 id=_vfs_vmiodirenable>11.8.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h5><div class=paragraph><p><code>vfs.vmiodirenable</code> sysctl 変数のデフォルトは 1 (オン) で、 0 (オフ) または 1 (オン) にセットすることができます。 このパラメータはディレクトリがシステムによってどのように キャッシュされるかを制御します。 ほとんどのディレクトリは小さく、 ファイルシステムにおいては単一フラグメント (典型的には 1K) であり、バッファキャッシュではさらに小さくなっています (典型的には 512 バイト)。 しかしデフォルトモードで動作している時は、 大量のメモリを搭載していても バッファキャッシュは固定数のディレクトリしかキャッシュしません。 この sysctl をオンにすると、バッファキャッシュが VM ページキャッシュを、 ディレクトリをキャッシュするために使うことを可能にします。 これによる利点は、全てのメモリがディレクトリを キャッシュするのに使えるようになるということです。 欠点は、キャッシュに使われる最小のメモリの大きさが 512 バイトではなく 物理ページサイズ (大抵は 4K) になることです。 多数のファイルを操作するサービスを稼動しているなら、 常にこのオプションをオンにすることを推奨します。 そのようなサービスには、web キャッシュや大規模なメールシステム、 ニューズシステムなどが含まれます。 このオプションは一般にメモリを消費しますが、 性能を削減することはありません。 ただし実験して調べてみるべきでしょう。</p></div></div><div class=sect4><h5 id=_hw_ata_wc>11.8.1.2. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h5><div class=paragraph><p>FreeBSD 4.3 では IDE のライトキャッシュがオフになりました。 これは IDE ディスクへの書き込み帯域幅を減らしてしまうことになりますが、 ハードドライブベンダに起因するデータの一貫性に関する 重大な問題のために必要なことだと考えられました。 基本的には、書き込み完了時期について IDE ドライブが嘘をつくという問題です。 IDE ライトキャッシュがオンであると IDE ハードドライブはデータを順番に書きこまないばかりか、 ディスクの負荷が高い時にはいくつかのブロックの書き込みを 無期限に延期してしまいます。 クラッシュや電源故障の場合、 ファイルシステムの重大な破壊をもたらします。 したがって私たちはデフォルトを安全側に変更しました。 残念ながらこれは大変な性能の低下をもたらし、 私たちはあきらめてこのリリース後にオンに戻しました。 <code>hw.ata.wc</code> sysctl 変数を見てデフォルトを チェックしてみるべきです。 もし IDE ライトキャッシュがオフになっていたら、 hw.ata.wc カーネル変数を 1 に戻すことでオンに戻すことができます。 これはブート時にブートローダから行わなければなりません。 カーネルがブートした後に行っても効果はありません。</p></div><div class=paragraph><p>詳しくは <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a> を見てください。</p></div></div></div><div class=sect3><h4 id=_ソフトアップデート>11.8.2. ソフトアップデート<a class=anchor href=#_ソフトアップデート></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> プログラムはファイルシステムを細かくチュー ニングするのに使えます。このプログラムにはさまざまなオプションがありま すが、ここではソフトアップデートをオンオフすることだけを考えま す。以下の様にして切り替えます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>ファイルシステムはマウントされているあいだは <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> で変更することができません。 ソフトアップデートを有効にする いい機会はシングルユーザモードでどのパーティションもマウント されていない時です。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 4.5 からは、ファイルシステム生成時に <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> の <code>-U</code> オプションを使って ソフトアップデートを有効化できるようになりました。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ソフトアップデートはメタデータの性能、 主にファイルの作成と削除の性能を劇的に改善します。 すべてのファイルシステムでソフトアップデートを有効にすることを推奨します。 ソフトアップデートに関して、2 つの欠点を意識すべきです。 1 つめは、ソフトアップデートはクラッシュ時におけるファイルシス テムの一貫性は保証しますが、 物理ディスクの更新が何秒か (1 分に達することもあります!) 遅れる可能性が高いことです。 システムがクラッシュした場合、より多くの作業結果が消えてしまうかもしれません。 2 つめは、ソフトアップデート はファイルシステムブロックを解放するのを遅らせるということです。 あるファイルシステム (たとえばルートファイルシステム) が満杯近くの時に それに対する大規模な更新、たとえば <code>make installworld</code> をすると、空き領域を使い果たして更新が失敗してしまうことがあります。</p></div></div></div><div class=sect2><h3 id=configtuning-kernel-limits>11.9. Kernel 制限のチューニング<a class=anchor href=#configtuning-kernel-limits></a></h3><div class=sect3><h4 id=_fileprocess_制限>11.9.1. File/Process 制限<a class=anchor href=#_fileprocess_制限></a></h4><div class=sect4><h5 id=_kern_maxfiles>11.9.1.1. <code>kern.maxfiles</code><a class=anchor href=#_kern_maxfiles></a></h5><div class=paragraph><p><code>kern.maxfiles</code> はあなたのシステムの要求に 応じて増減させることができます。 この変数はあなたのシステムのファイル記述子の最大値を示します。 ファイル記述子テーブルが溢れるような時には、システムメッセー ジバッファに頻繁に <code>file: table is full</code> と表示されます。これは、 <code>dmesg</code> コマンドで確認できます。</p></div><div class=paragraph><p>ファイル、ソケット、パイプ (fifo) は それぞれオープンされるとファイル記述子を一つ消費します。 大規模なプロダクションサーバでは その時実行されているサービスの種類や数に応じては あっさり数千のファイル記述子が必要になります。</p></div><div class=paragraph><p><code>kern.maxfile</code> のデフォルト値はカーネル コンフィグレーションファイルの <code>MAXUSERS</code> オ プションで決まります。<code>kern.maxfiles</code> は <code>MAXUSERS</code> の値に比例して増加します。 カスタムカーネルをコンパイルする際は、このカーネルコンフィグ レーションオプションをシステムの利用法に合わせて設定するとよ いでしょう。カーネルは、この数値からほとんどの制限の初期値を 決定します。業務用マシンに、実際に 256 名のユーザが一度に接 続することはないかもしれませんが、大規模なウェブサーバに必要 なリソースは同程度になります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 4.5 からは、 カーネルコンフィグレーションファイルで <code>MAXUSERS</code> を <code>0</code> に設定すると、システムの RAM 容量に基づいて適切なデフォルト値が選択されます。</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_ネットワークの制限>11.9.2. ネットワークの制限<a class=anchor href=#_ネットワークの制限></a></h4><div class=paragraph><p>カーネルコンフィグレーションオプション <code>NMBCLUSTERS</code> は、そのシステムで利用可能なネッ トワーク mbuf の量を決定します。通信量の多いサーバで MBUF の量 が少ないと、FreeBSD の性能が低下してしまいます。クラスタ一つは およそ 2kB のメモリに対応しているので、1024 だとカーネルメモリ から約 2 MB をネットワークバッファに予約することになります。ど れだけ必要になるかを、簡単な計算で出すことができます。同時に最 大 1000 接続までゆくウェブサーバがあり、それぞれの接続によって 受信バッファ 16kB と送信バッファ 16kB が消費されるなら、ウェ ブサーバをまかなうのに 32MB 程度のネットワークバッファが必要 になります。経験的に有用な値は、それを 2 倍したものなので、 32MBx2 = 64MB/2K = 32768 になります。</p></div></div></div></div></div><div class=sect1><h2 id=boot>Chapter 12. FreeBSD の起動のプロセス<a class=anchor href=#boot></a></h2><div class=sectionbody><div class=sect2><h3 id=boot-synopsis>12.1. この章では<a class=anchor href=#boot-synopsis></a></h3><div class=paragraph><p>計算機を起動しオペレーティングシステムをロードするプロセスは、 "ブートストラッププロセス" もしくは "ブート" と呼ばれます。 FreeBSD の起動プロセスを使えば、 システムをスタートするときに起きることをかなり柔軟にカスタマイズできます。 同じ計算機にインストールされた別のオペレーティングシステムを選択することもできますし、 同じオペレーティングシステムの異なるバージョンを選択することも、 インストールされた別のカーネルを選択することさえできます。</p></div><div class=paragraph><p>この章では、指定できる設定オプションついて詳しく説明します。 FreeBSD カーネルがスタートし、デバイスを検出し、 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> を起動するまでに起きることすべてを含む FreeBSD の起動プロセスのカスタマイズ方法について説明します。 これは、起動メッセージのテキストの色が、 明るい白から灰色に変わるまでに起きています。</p></div><div class=paragraph><p>この章を読むと、以下のことが分かります。</p></div><div class=ulist><ul><li><p>FreeBSD のブートストラップシステムの構成およびそれらが互いにどう関係しているのか</p></li><li><p>起動プロセスを制御するために FreeBSD のブートストラップの各要素に付加できるオプション</p></li><li><p>device hints の基本的な記述方法</p></li><li><p>シングルユーザもしくはマルチユーザモードでの起動方法、 および FreeBSD システムのシャットダウンの方法</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この章では Intel x86 および amd64 システム上で動作する FreeBSD の起動プロセスだけを扱います。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=boot-introduction>12.2. FreeBSD の起動プロセス<a class=anchor href=#boot-introduction></a></h3><div class=paragraph><p>計算機の電源を入れ、オペレーティングシステムをスタートさせるのには、 おもしろいジレンマがあります。定義により、 計算機は、オペレーティングシステムが起動するまでは、 ディスクからプログラムを動かすことも含めて、 何をどうすればよいかまったく知りません。 計算機はオペレーティングシステムなしにディスクからプログラムを実行することができず、 オペレーティングシステムのプログラムがディスク上にあるのなら、 どうやってオペレーティングシステムを起動するのでしょうか?</p></div><div class=paragraph><p>この問題はほらふき男爵の冒険 という本の中に書かれている問題ととてもよく似ています。 登場人物がマンホールの下に半分落っこちて、 靴紐 (ブートストラップ) をつかんで自分を引っぱり、持ち上げるのです。 計算機の黎明期には、<em>ブートストラップ</em> という用語でオペレーティングシステムをロードする機構のことを指していました。 いまはこれを縮めて "ブート (起動)" と言います。</p></div><div class=paragraph><p>x86 ハードウェアでは、基本入出力システム (Basic Input/Output System: BIOS) にオペレーティングシステムをロードする責任があります。 BIOS はハードディスク上のマスターブートレコード (Master Boot Record: MBR) を探します。 MBR はハードディスク上の特定の場所になければなりません。 BIOS には MBR をロードし起動するのに十分な知識があり、 オペレーティングシステムをロードするために必要な作業の残りは、 場合によっては BIOS の助けを得た上で MBR が実行できることを仮定しています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD は古い標準の MBR、 または新しい GUID Partition Table (GPT) から起動できます。 GPT パーティションは、Unified Extensible Firmware Interface (UEFI) に対応したコンピュータで良く用いられます。 しかしながら、FreeBSD はレガシーな BIOS にのみに対応したコンピュータからも、<a href="https://man.freebsd.org/cgi/man.cgi?query=gptboot&amp;sektion=8&amp;format=html">gptboot(8)</a> により、 GPT パーティションから起動できます。 UEFI からの直接の起動への対応は進行中です。</p></div></td></tr></tbody></table></div><div class=paragraph><p>MBR 内部のコードは、 一般的に <em>ブートマネージャ</em> と呼ばれます。
とりわけユーザとの対話がある場合にそう呼ばれます。
通常ブートマネージャのもっと多くのコードが、ディスクの最初のトラック、またはファイルシステム上におかれます。
ブートマネージャの例としては、Boot Easy とも呼ばれる FreeBSD 標準のブートマネージャの boot0、多くの Linux® ディストリビューションが採用している GNU Grub 等があります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>GRUB のユーザは <a href=https://www.gnu.org/software/grub/grub-documentation.html>GNU-provided documentation</a> を参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ディスク上にインストールされているオペレーティングシステムが 1 つの時は、MBR はディスク上の最初の起動可能な (アクティブな) スライスを探し、 そのスライスにあるコードを起動してオペレーティングシステムの残りをロードします。 ディスク上に複数のオペレーティングシステムが存在しているのなら、 複数のオペレーティングシステムの一覧を表示できて、 起動するオペレーティングシステムを選択できるような、 別のブートマネージャをインストールすることもできます。</p></div><div class=paragraph><p>FreeBSD のブートストラップシステムの残りは 3 段階に分かれます。 第 1 ステージは、 計算機を特定の状態にするために必要なことだけを知っていて、 第 2 ステージを起動します。 第 2 ステージでは、第 3 ステージを起動する前に、 もう少しできることがあります。 第 3 ステージでオペレーティングシステムのロード作業を完了します。 起動作業が 3 段階に分かれているのは、 MBR がステージ 1 とステージ 2 で実行できるプログラムのサイズに制限を課しているからです。 これらの作業をつなぎ合わせることによって、 FreeBSD はより柔軟なローダ (loader) を提供しているのです。</p></div><div class=paragraph><p>その後カーネルが起動し、デバイスの検出と初期化を開始します。 そしてカーネルの起動が終わると、制御はユーザープロセスの <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> へ移されます。<a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> はディスクが利用可能であることを確認し、 ファイルシステムのマウント、 ネットワークで利用するネットワークカードのセットアップ、 そしてブート時に起動されるように設定されたプロセスの起動、 といったユーザーレベルでのリソース (資源) 設定を行ないます。</p></div><div class=paragraph><p>この章では、これらのステージについてより詳細に、また、FreeBSD ブートプロセスにおける対話的な設定方法について説明します。</p></div><div class=sect3><h4 id=boot-boot0>12.2.1. ブートマネージャ<a class=anchor href=#boot-boot0></a></h4><div class=paragraph><p>MBR のブートマネージャのコードは起動プロセスの_第 0 ステージ_と呼ばれることがあります。 デフォルトでは、FreeBSD は boot0 を使います。</p></div><div class=paragraph><p>FreeBSD のインストーラがインストールする MBR は、 <span class=filename>/boot/boot0</span> を基にしています。 boot0 のサイズと機能は、 スライステーブルおよび MBR 末尾の識別子 <code>0x55AA</code> のため、 446 バイトの大きさに制限されます。 もし、boot0 と複数のオペレーティングシステムをインストールした場合、 起動時に以下のようなメッセージが表示されます。</p></div><div id=boot-boot0-example class=exampleblock><div class=title>例 24. <span class=filename>boot0</span> のスクリーンショット</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>F1 Win
F2 FreeBSD

Default: F2</code></pre></div></div></div></div><div class=paragraph><p>他のオペレーティングシステムは、 FreeBSD の後にインストールを行うと、既存の MBR を上書きしてしまいます。 もしそうなってしまったら、 もしくは既存の MBR を FreeBSD の MBR で置き換えるには、 次のコマンドを使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdisk -B -b /boot/boot0 device</span></code></pre></div></div><div class=paragraph><p><em>device</em> は起動するデバイス名で、 たとえば 1 番目の IDE ディスクは <span class=filename>ad0</span>、2 番目の IDE コントローラに接続されている 1 番目の IDE ディスクは <span class=filename>ad2</span>、 1 番目の SCSI ディスクは <span class=filename>da0</span> などとなります。 MBR の設定をカスタマイズしたい場合は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a> を参照してください。</p></div></div><div class=sect3><h4 id=boot-boot1>12.2.2. 起動ステージ 1 と起動ステージ 2<a class=anchor href=#boot-boot1></a></h4><div class=paragraph><p>概念上、第 1 ステージと第 2 ステージはハードディスクの同じ領域上の同一のプログラムの部分部分です。 スペースの制約のため 2 つに分割されていますが、 いつも一緒にインストールされます。 FreeBSD のインストーラまたは <code>bsdlabel</code> は、 両者を 1 つにまとめた <span class=filename>/boot/boot</span> をコピーします。</p></div><div class=paragraph><p>これらの 2 つのステージは、ファイルシステムの外部、 起動スライスの最初のトラックに置かれ、 先頭が最初のセクタにきます。 boot0 またはその他のブートマネージャは、 起動プロセスを続けるために必要なプログラムがそこにあると想定しています。</p></div><div class=paragraph><p>最初のステージの <span class=filename>boot1</span> は、 512 バイトの大きさでなければならないという制限があるので、 非常に単純なプログラムです。 このプログラムは <span class=filename>boot2</span> を検索して実行するため、そのスライスの情報を保持する FreeBSD の <em>BSD ラベル</em> に関する最低限の情報だけを持っています。</p></div><div class=paragraph><p>次のステージの <span class=filename>boot2</span> はもう少し高機能です。 これは FreeBSD のファイルシステム上でファイルを見つける機能を持ちます。 実行するカーネルやローダを指定するための簡単なインタフェースを提供します。 <span class=filename>boot2</span> により起動される loader はさらに高機能で、 起動設定が行なえる手段を提供します。 ステージ 2 で起動プロセス中断した時には、 次のようながインタラクティブなが画面が表示されます。</p></div><div id=boot-boot2-example class=exampleblock><div class=title>例 25. <span class=filename>boot2</span> のスクリーンショット</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div></div></div><div class=paragraph><p>インストールされた <span class=filename>boot1</span> と <span class=filename>boot2</span> を変更するには、 <code>bsdlabel</code> を使ってください。 以下の例では、<em>diskslice</em> は起動するディスクとスライスで、たとえば最初の IDE ディスクの 1 番目のスライスは <span class=filename>ad0s1</span> となります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -B diskslice</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><span class=filename>ad0</span> のようにディスク名だけを指定すると、 <code>bsdlabel</code> は、スライスを持たない "危険な専用モード"を作成してしまいます。 これはおそらく、あなたが望んでいることではないでしょうから、 <kbd>Return</kbd> キーを押す前に、 <em>diskslice</em> の部分を二重にチェックしてください。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-loader>12.2.3. 起動ステージ 3<a class=anchor href=#boot-loader></a></h4><div class=paragraph><p>loader は三段階の起動プロセスの最終段階です。 これは通常、ファイルシステム上の <span class=filename>/boot/loader</span> として存在しています。</p></div><div class=paragraph><p>loader は、 よりさまざまなコマンド群をサポートした強力なインタプリタによって提供される組み込みコマンド群を利用することで、 インタラクティブな設定手段となるように設計されています。</p></div><div class=paragraph><p>loader は初期化の際にコンソールとディスクの検出を行ない、 どのディスクから起動しているかを調べます。 そして必要な変数を設定してからインタプリタを起動し、 スクリプトからコマンドを送ったり手でコマンドを入力したりできます。</p></div><div class=paragraph><p>loader は次に <span class=filename>/boot/loader.rc</span> を読み込み、通常、変数の標準値を定義した <span class=filename>/boot/defaults/loader.conf</span> と、そのコンピュータにローカルに変数を定義した <span class=filename>/boot/loader.conf</span> を読み込みます。 <span class=filename>loader.rc</span> はそれらの変数にもとづき、 選択されたモジュールとカーネルをロードします。</p></div><div class=paragraph><p>loader は最後に、 標準設定で 10 秒のキー入力待ち時間を用意し、 入力がなければカーネルを起動します。 入力があった場合、コマンド群が使えるプロンプトが表示され、 ユーザは変数を調整したり、すべてのモジュールをアンロードしたり、 モジュールをロードしたりすることができます。 その後、最終的な起動や再起動へ移行します。 <a href=#boot-loader-commands>ローダの組み込みコマンド</a>では、 もっともよく使われる loader のコマンドをまとめています。 利用可能なコマンドをすべて知りたい場合には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> を参照してください。</p></div><table id=boot-loader-commands class="tableblock frame-none grid-all stretch"><caption class=title>表 9. ローダの組み込みコマンド</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">変数</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>autoboot <em>seconds</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><em>seconds</em> で与えられた時間内に入力がなければ、 カーネルの起動へと進みます。 カウントダウンを表示します。標準設定では 10 秒間です。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>boot <code>[<em>-options</em>] [<em>kernelname]</em></code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>すぐにカーネルの起動へ進みます。 オプション、カーネル名が指定されている場合は、 それらが使われます。 <em>unload</em> を実行後、 カーネル名をコマンドラインから指定することができます。 <em>unload</em> を実行しないと、 一度読み込まれたカーネルが使われます。 <em>kernelname</em> でパスが指定されていない時には、 <em>/boot/kernel</em> および <em>/boot/modules</em> から調べられます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>boot-conf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>すべてのモジュールの設定を、 起動時と同じように指定された変数 (最も多いのは <code>kernel</code>) にもとづいて自動的に行ないます。 このコマンドは、変数を変更する前に、 最初に <code>unload</code> を行なった場合にのみ有効に働きます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>help <code>[<em>topic</em>]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/loader.help</span> を読み込み、ヘルプメッセージを表示します。 topic に <code>index</code> が指定された場合、 利用可能な topic の一覧を表示します。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>include <em>filename</em> …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>指定されたファイルを読み込み、行単位で解釈します。 エラーが発生した場合、 <code>include</code> の実行は直ちに停止します。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>load <code>[-t <em>type</em>]</code> <em>filename</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>指定されたファイル名のカーネル、 カーネルモジュール、あるいは type に指定された種類のファイルをロードします。 <em>filename</em> 以降に指定された引数はファイルへと渡されます。 <em>filename</em> でパスが指定されていない時には、 <em>/boot/kernel</em> および <em>/boot/modules</em> から調べられます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ls [-l] <code>[<em>path</em>]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>指定された <em>path</em> にあるファイルを表示します。 <em>path</em> が指定されていなければ、ルートディレクトリを表示します。 <code>-l</code> が指定されていればファイルサイズも表示されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lsdev [-v]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>モジュールがロード可能なすべてのデバイスを表示します。 もし <code>-v</code> が指定されていれば、 より詳細な出力がされます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lsmod [-v]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ロード済みのモジュールを表示します。 <code>-v</code> が指定されていれば、 より詳細な内容が出力されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>more <em>filename</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>LINES</code> 行を表示するごとに停止しながら指定されたファイルを表示します。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>reboot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>すぐにシステムを再起動します。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>set <em>variable</em>, set <em>variable</em>=<em>value</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ローダの環境変数を設定します。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>unload</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>すべてのロード済みモジュールを削除します。</p></td></tr></tbody></table><div class=paragraph><p>次にあげるのは、ローダの実践的な使用例です。 普段使っているカーネルをシングルユーザモードで起動します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nt>-s</span></code></pre></div></div><div class=paragraph><p>普段使っているカーネルとモジュールをアンロードし、 古いもしくは別のカーネルをロードするには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>unload
load /path/to/kernelfile</code></pre></div></div><div class=paragraph><p>インストール時のデフォルトカーネルを指定するには、完全修飾の <span class=filename>/boot/GENERIC/kernel</span> を使ってください。
また、システムをアップグレードしたり、 もしくはカスタムカーネルを設定した場合に、 直前にインストールされていたカーネルは、 <span class=filename>/boot/kernel.old/kernel</span> で指定できます。</p></div><div class=paragraph><p>普段のカーネルで使っているモジュールを指定したカーネルでロードする場合は、 次のようにします。
この場合は、完全修飾名を使う必要はありません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>unload
<span class=nb>set </span><span class=nv>kernel</span><span class=o>=</span><span class=s2>&#34;mykernel&#34;</span>
boot-conf</code></pre></div></div><div class=paragraph><p>カーネルの自動設定スクリプトをロードします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> load <span class=nt>-t</span> userconfig_script /boot/kernel.conf</code></pre></div></div></div><div class=sect3><h4 id=boot-init>12.2.4. 最終ステージ<a class=anchor href=#boot-init></a></h4><div class=paragraph><p>カーネルがデフォルトの loader もしくは loader を迂回して boot2 によって読み込まれると、 起動フラグが調べられ、それに応じて動作が調整されます。<a href=#boot-kernel>起動時のカーネルオプション</a> には、 良く使われる起動フラグがまとめられています。 他の起動フラグの詳細については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> を参照してください。</p></div><table id=boot-kernel class="tableblock frame-none grid-all stretch"><caption class=title>表 10. 起動時のカーネルオプション</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">オプション</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>カーネル初期化中に、 ルートファイルシステムとしてマウントするデバイスを尋ねます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-C</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CDROM からルートファイルシステムを起動します。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-s</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シングルユーザモードで起動します。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-v</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>カーネル起動時に、より詳細な情報を表示します。</p></td></tr></tbody></table><div class=paragraph><p>カーネルの起動が完了すると、<a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> というユーザプロセスに制御が移されます。 これは <span class=filename>/sbin/init</span>、 もしくは <code>loader</code> の <code>init_path</code> 変数で指定される場所にあります。 これは起動プロセスの最終ステージです。</p></div><div class=paragraph><p>起動シーケンスでは、 システム上で利用できるファイルシステムの一慣性を確認します。 もし UFS ファイルシステムにに問題があって <code>fsck</code> が不一致を修復できなければ、 管理者が問題を直接解決できるように、init はシステムをシングルユーザモードへと移行させます。 問題がなければ、システムはマルチユーザモードに移行します。</p></div><div class=sect4><h5 id=boot-singleuser>12.2.4.1. シングルユーザモード<a class=anchor href=#boot-singleuser></a></h5><div class=paragraph><p>このモードには、ユーザが起動時に <code>-s</code> を指定した場合、あるいは loader で <code>boot_single</code> 変数を設定することによって移行します。 マルチユーザモードから <code>shutdown now</code> を呼び出すことでもこのモードに移行できます。 シングルユーザモードは、以下のメッセージで開始します。</p></div><div class="literalblock programlisting"><div class=content><pre>Enter full pathname of shell or RETURN for /bin/sh:</pre></div></div><div class=paragraph><p>ユーザが <kbd>Enter</kbd> を入力すると、 システムは Bourne シェルを起動します。 別のシェルを使うには、シェルのフルパスを入力してください。</p></div><div class=paragraph><p>シングルユーザモードは、 通常ファイルシステムの一貫性に問題があって起動できないシステムを修復したり、 起動設定ファイルの間違いを修正するために使われます。 また、<code>root</code> パスワードがわからなくなった場合に、 リセットするために使うことも出来ます。 シングルユーザモードのプロンプトは、 ローカルファイルシステムおよび設定ファイルへのアクセスを与えてくれますが、 ネットワーク接続は出来ません。</p></div><div class=paragraph><p>シングルユーザモードは、システムの修復には有用ですが、 システムが物理的に安全な場所になければ、 セキュリティのリスクがもたらされます。 デフォルトでは、システムに物理的にアクセス可能なユーザは、 シングルユーザモードで起動後はシステムをすべてコントロールできます。</p></div><div class=paragraph><p><span class=filename>/etc/ttys</span> でシステムの <code>console</code> が <code>insecure</code> に設定されている場合、 システムはシングルユーザモードに移行する前に <code>root</code> のパスワードを入力するように求めます。 <code>root</code> パスワードがわからなくなった場合のリセット機能が無効になっている間は、 セキュリティ対策が必要となります。</p></div><div id=boot-insecure-console class=exampleblock><div class=title>例 26. <span class=filename>/etc/ttys</span> の insecure コンソール</div><div class=content><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</pre></div></div></div></div><div class=paragraph><p><code>insecure</code> コンソールとは、 コンソールが物理的に安全でない (insecure) と考えられるため、 <code>root</code> のパスワードを知る人だけがシングルユーザモードを使えるという意味です。</p></div></div><div class=sect4><h5 id=boot-multiuser>12.2.4.2. マルチユーザモード<a class=anchor href=#boot-multiuser></a></h5><div class=paragraph><p>init がファイルシステムが正常であると判断するか、 ユーザがシングルユーザモードでのコマンドを終了し、 <code>exit</code> を入力してシングルユーザモードを終了すると、 システムはマルチユーザモードへ移行し、 システムのリソースの設定を開始します。</p></div><div class=paragraph><p>リソース設定システムはデフォルト設定を <span class=filename>/etc/defaults/rc.conf</span> から、 また、システム独自の細かな設定を <span class=filename>/etc/rc.conf</span> から読み込みます。 そして <span class=filename>/etc/fstab</span> に記述されるシステムファイルシステムをマウントします。 その後、ネットワークサービス、さまざまなシステムデーモン、 そして最後に、ローカルにインストールされた package の起動スクリプトを実行します。</p></div><div class=paragraph><p>リソース設定システムについてもっと知りたい場合には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> を参照してください。また、<span class=filename>/etc/rc.d</span> にあるスクリプトを実行してみてください。</p></div></div></div></div><div class=sect2><h3 id=device-hints>12.3. Device Hints<a class=anchor href=#device-hints></a></h3><div class=paragraph><p>システムの最初のスタートアップ時に、<a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> は <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a> を読み込みます。 このファイルにはカーネル起動の環境変数が格納されており、 これらの環境変数は "device hints" と呼ばれることがあります。デバイスドライバは、 デバイスを設定するために "device hints" を使用します。</p></div><div class=paragraph><p><a href=#boot-loader>起動ステージ 3</a> で説明されているように device hints はステージ 3 ブートローダプロンプトでも設定できます。 変数は <code>set</code> を用いて追加したり、 <code>unset</code> を用いて削除できます。 <code>show</code> を用いて一覧を見ることもできます。 <span class=filename>/boot/device.hints</span> に設定されている変数は、 上書きすることもできます。 ブートローダで設定した device hints の効果は一時的なものなので、 次回起動するときには無効になります。</p></div><div class=paragraph><p>システムが起動すると、<a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a> コマンドですべてのカーネル環境変数をダンプすることができます。</p></div><div class=paragraph><p><span class=filename>/boot/device.hints</span> は 1 行につき一つの変数を設定でき、行頭の "#" はその行がコメントであることを示しています。 書式は次の通りです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> hint.driver.unit.keyword<span class=o>=</span><span class=s2>&#34;value&#34;</span></code></pre></div></div><div class=paragraph><p>ステージ 3 ブートローダ で設定するときの書式は次の通りです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set </span>hint.driver.unit.keyword<span class=o>=</span>value</code></pre></div></div><div class=paragraph><p>ここで、<code>driver</code> はデバイスドライバの名前、 <code>unit</code> はデバイスドライバのユニット番号、 <code>keyword</code> はヒントキーワードです。 キーワードは以下のようなオプションです。</p></div><div class=ulist><ul><li><p><code>at</code>: デバイスがどのバスに接続されているか指定します。</p></li><li><p><code>port</code>: 使用する I/O ポートの開始アドレスを指定します。</p></li><li><p><code>irq</code>: 使用する IRQ を指定します。</p></li><li><p><code>drq</code>: 使用する DMA チャネルを指定します。</p></li><li><p><code>maddr</code>: 使用する物理メモリアドレスを指定します。</p></li><li><p><code>flags</code>: デバイスに対してさまざまなフラグを設定します。</p></li><li><p><code>disabled</code>: <code>1</code> が設定されていると、そのデバイスは無効になります。</p></li></ul></div><div class=paragraph><p>デバイスドライバはこのリスト以外の変数を設定できるかもしれませんし、 このリスト以外の変数を必要とするかもしれないので、 ドライバのマニュアルを読むことをおすすめします。 より多くの情報を知りたければ、<a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> を参照してください。</p></div></div><div class=sect2><h3 id=boot-shutdown>12.4. シャットダウン動作<a class=anchor href=#boot-shutdown></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> を用いてシステムを意図的にシャットダウンした場合、 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> は <span class=filename>/etc/rc.shutdown</span> というスクリプトの実行を試みます。 そして、すべてのプロセスへ <code>TERM</code> シグナルを送り、続いてうまく終了できなかったプロセスへ <code>KILL</code> シグナルを送ります。</p></div><div class=paragraph><p>電源管理機能を持ったシステムで稼働している FreeBSD では <code>shutdown -p now</code> によって、 直ちに電源を落とすことができます。FreeBSD システムを再起動するには、 <code>shutdown -r now</code> を実行してください。 <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> を実行するには、 <code>root</code> か、<code>operator</code> のメンバでなければなりません。<a href="https://man.freebsd.org/cgi/man.cgi?query=halt&amp;sektion=8&amp;format=html">halt(8)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=reboot&amp;sektion=8&amp;format=html">reboot(8)</a> を利用することもできます。 より多くの情報を得るために、それらのマニュアルページや <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> を参照してください。</p></div><div class=paragraph><p>グループのメンバを変更するには、 <a href=./#users-synopsis>「この章では」</a> を参照してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>電源管理機能には <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> がモジュールとして読み込まれるか、 カスタムカーネルにコンパイルされて静的に組み込まれている必要があります。</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=security>Chapter 13. セキュリティ<a class=anchor href=#security></a></h2><div class=sectionbody><div class=sect2><h3 id=security-synopsis>13.1. この章では<a class=anchor href=#security-synopsis></a></h3><div class=paragraph><p>物理的もしくは仮想的に関わらず、 セキュリティは幅広いトピックであり、 業界全体がセキュリティとともに成長しています。 システムおよびネットワークを安全にする標準的な方法は数多く文書化されており、 FreeBSD のユーザも、 攻撃や侵入者から守る方法を理解しなければなりません。</p></div><div class=paragraph><p>この章では、セキュリティの基礎や技術について説明します。 FreeBSD システムは、複数のレイヤに関連するセキュリティを提供します。 そして、安全性を高めるためにサードパーティ製のユーティリティを利用することもできます。</p></div><div class=paragraph><p>この章を読むと、以下のことがわかります。</p></div><div class=ulist><ul><li><p>FreeBSD における基本的なシステムセキュリティの考え方</p></li><li><p>FreeBSD で利用できるさまざまな暗号化手法</p></li><li><p>ワンタイムパスワード認証の設定方法</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> と組み合わせて TCP Wrappers を設定する方法</p></li><li><p>FreeBSD における Kerberos の設定方法</p></li><li><p>IPsec を設定して VPN を構築する方法</p></li><li><p>FreeBSD にける OpenSSH の設定および使用方法</p></li><li><p>ファイルシステム ACL (アクセス制御リスト) の使用方法</p></li><li><p>Ports Collection からインストールされたサードパーティ製ソフトウェア packages を Portaudit を使って監査する方法</p></li><li><p>FreeBSD セキュリティ勧告の利用方法</p></li><li><p>プロセスアカウンティングがどのようなものか、 FreeBSD 上で有効にする方法について</p></li><li><p>リソース制限データベースとは何か、 この仕組みを使ったユーザ資源の管理方法</p></li></ul></div><div class=paragraph><p>この章を読む前に、次のことが必要になります。</p></div><div class=ulist><ul><li><p>FreeBSD およびインターネットの基本概念の理解</p></li></ul></div></div><div class=sect2><h3 id=security-intro>13.2. はじめに<a class=anchor href=#security-intro></a></h3><div class=paragraph><p>セキュリティを高めることはすべての人の責任です。 システムに弱い侵入ポイントが存在すると、侵入者は重要な情報を得たり、 ネットワーク全体に被害を及ぼすことができるようになります。 多くのセキュリティのトレーニングでは、 情報システムの機密性 (confidentiality)、 完全性 (integrity) および可用性 (availability) を意味するセキュリティの 3 要素である CIA が取り扱われます。</p></div><div class=paragraph><p>CIA の 3 要素は、 コンピュータセキュリティの基本となる考えです。 顧客やエンドユーザは、データのプライバシーを期待します。 彼らは、データが変更されないことや、 情報が隠されていることを期待します。 彼らはまた、いつでも情報にアクセスできることを期待します。 これらは、システムの機密性、完全性、可用性を構成します。</p></div><div class=paragraph><p>セキュリティのプロフェッショナルは、CIA を守るために、多層防衛の戦略を採用します。 この多層防衛戦略ではセキュリティのレイアを複数用意することで、 一つのレイヤが破られても、 セキュリティシステム全体が破られることを防ぎます。 システムの管理者は、ファイアウォールを単に有効にするだけではなく、 ネットワークもしくはシステムを安全に保つ必要があります。 アカウントを監査し、バイナリの完全性、 悪意のあるツールがインストールされていないことを確認する必要があります。 このために、 管理者は脅威がどのようなものかを理解する必要があります。</p></div><div class=sect3><h4 id=security-threats>13.2.1. 脅威<a class=anchor href=#security-threats></a></h4><div class=paragraph><p>コンピュータセキュリティおける脅威とは何でしょうか？ 長年、脅威はリモートの攻撃者、 すなわち遠隔からの許可のないシステムへのアクセスを企てる人々と考えられていました。 今日では、この定義は従業員、悪意のあるソフトウェア、 不正なネットワークデバイス、自然災害、セキュリティの脆弱性、 そして競合する会社でさえも含めるように拡張されています。</p></div><div class=paragraph><p>毎日、数千ものシステムおよびネットワークが攻撃され、 数百ものシステムが許可なくアクセスされています。 簡単なアクシデントといったものから、リモートからの攻撃、 産業スパイであったり、以前働いていた従業員からの攻撃といったケースもあります。 システムのユーザとしては、 間違いがセキュリティ違反に繋がった場合には、 可能性のある問題をセキュリティチームに報告することが重要です。 管理者としては、脅威を把握し、 その脅威の影響を小さくするように準備をしておくことが重要です。</p></div></div><div class=sect3><h4 id=security-groundup>13.2.2. ボトムアップアプローチ<a class=anchor href=#security-groundup></a></h4><div class=paragraph><p>セキュリティを考える上で、 しばしばボトムアップアプローチが一番良い方法となります。 この考えでは、管理者が基本的なアカウント、システム設定を行ってから、 サードパーティ製ユーティリティの設定、 そしてネットワークレイヤに設定を広げていきます。 システムポリシーおよび手続きを行う上では、 このような設定の側面があります。</p></div><div class=paragraph><p>ビジネスの多くの環境では、 使用するデバイスの設定に対するセキュリティポリシがすでに策定されています。 このポリシには、最低限エンドユーザのワークステーション、 デスクトップ、携帯電話やラップトップといったモバイルデバイス、および 製品および開発サーバの両方に対するセキュリティの設定が含まれているべきです。 多くの場合には、コンピュータのセキュリティを考える際に、 標準作業手続書 (SOP) がすでに存在します。 わからなければ、セキュリティチームに尋ねてください。</p></div></div><div class=sect3><h4 id=security-accounts>13.2.3. システムおよびユーザアカウント<a class=anchor href=#security-accounts></a></h4><div class=paragraph><p>システムを安全にするにあたり、最も適切な出発点は、 アカウントの監査です。 ルートアカウントのパスワードが強力であること、 シェルアクセスを必要としないアカウントは無効にすることを確実におこなってください。 また、権限を必要とするユーザに対しては、 <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> をインストールして、 アクセスが必要となるアプリケーションのみにアクセスを許可するようにしてください。 root ユーザのパスワードは、決して共有すべきではありません。</p></div><div class=paragraph><p>アカウントへのアクセスを無効にする方法は二通りあります。 一つ目の方法は、アカウントをロックする方法です。例として、 toor アカウントをロックする方法を以下に示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw lock toor</span></code></pre></div></div><div class=paragraph><p>このコマンドは、アカウントの設定を "toor:*:0:0::0:0:Bourne-again Superuser:/root:" から "toor:*LOCKED**:0:0::0:0:Bourne-again Superuser:/root:" へと変更します。</p></div><div class=paragraph><p>ときには (おそらく追加のサービスのために)、 この方法が使えない場合があります。 そのような場合には、以下の例のように、 シェルを /sbin/nologin に変更することで、 ログインアクセスを拒否できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chsh -s /usr/sbin/nologin toor</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>他のユーザのシェルは、スーパーユーザのみが変更できます。 通常のユーザが行おうとすると失敗します。</p></div></td></tr></tbody></table></div><div class=paragraph><p>アカウント情報は、以下のように最後のエントリが "nologin" シェルとなります。</p></div><div class="literalblock programlisting"><div class=content><pre>toor:*:0:0::0:0:Bourne-again Superuser:/root:/usr/sbin/nologin</pre></div></div><div class=paragraph><p><span class=filename>/usr/sbin/nologin</span> シェルは、 <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> コマンドがこのユーザにシェルを割り当てることをブロックします。</p></div></div><div class=sect3><h4 id=security-sudo>13.2.4. アカウントの権限を拡大する<a class=anchor href=#security-sudo></a></h4><div class=paragraph><p>場合によっては、 システム管理者へのアクセスを他のユーザと共有する必要があります。 FreeBSD はこのために二つの方法を用意しています。 第一の方法は推奨されませんが、 ルートのパスワードを共有し、ユーザを <code>wheel</code> グループに加える方法です。 これを行うにには、<span class=filename>/etc/group</span> を編集し、 最初のグループの最後にユーザを追加してください。 ユーザはカンマ区切りで管理されています。</p></div><div class=paragraph><p>権限の拡大をする適切な方法は、 <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> port を使う方法です。 この port は、追加の監査、よりきめ細かいユーザ管理、および ユーザを <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> のような権限が与えられたコマンのみの実行に制限することもできます。</p></div><div class=paragraph><p>インストールが終わったら、 <code>visudo</code> インタフェースを使って <span class=filename>/usr/local/etc/sudoers</span> ファイルを編集してください。 以下の例では、新しく webadmin グループが作成され、 <code>trhodes</code> ユーザがこのグループに追加されます。 その後、ユーザに <a class=package href=https://cgit.freebsd.org/ports/tree/apache24/>apache24</a> を再起動するアクセス権限を与えます。 この手続きは以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd webadmin -M trhodes -g 6000</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># visudo</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>%webadmin ALL=(ALL) /usr/sbin/service apache24 *</pre></div></div><div class=paragraph><p>ローカルのユーザ管理において、 <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> は、 非常に貴重なリソースを提供します。 また、パスワードを不必要にして、デフォルトを <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> 鍵の方法だけにすることもできます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 経由のパスワードによるログインを無効にし、 <code>sudo</code> へのローカルパスワードのみを使うようにするには、 <a href=#openssh>OpenSSH</a> をご覧ください。</p></div></div><div class=sect3><h4 id=security-passwords>13.2.5. パスワード<a class=anchor href=#security-passwords></a></h4><div class=paragraph><p>パスワードは、テクノロジーにおける必要悪です。 パスワードは極めて複雑であるだけではなく、 パスワードを保護する強力なハッシュメカニズムもまた必要となります。 この文書を書いている時点では、 FreeBSD は <code>crypt()</code> ライブラリで DES, MD5, Blowfish, SHA256 および SHA512 に対応しています。 デフォルトは SHA512 であり、 強度の弱い暗号へは変更すべきではありません。 しかしながら、Blowfish を好むユーザもおります。 DES を除く各メカニズムでは、 開始の文字、使用しているハッシュメカニズムを識別可能な特徴を持っています。 MD5 メカニズムでは、シンボルは "$" の符号です。 SHA256 または、 SHA512 では、シンボルは "$6$"、 そして Blowfish は "$2a$" です。 暗号強度の弱いパスワードを使用している場合には、 次回のログイン時にユーザが <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> を実行して再ハッシュ化することを促すべきです。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この文書を書いている時点で、Blowfish は AES でなければ、 FIPS (Federal Information Processing Standards) に準拠もしていません。 そのため、使用できない環境があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ネットワークに接続しているシステムについては、 二要素認証を使用すべきです。 この認証では、通常あなたが所有する要素と知っている要素が用いられます。 FreeBSD のベースシステムに含まれている OpenSSH および ssh-keys では、 ネットワークへのすべてのログインにおける二要素認証の交換で、 パスワードを使用すべきではありません。 より詳細な情報については、ハンドブックの <a href=#openssh>OpenSSH</a> 節をご覧ください。 Kerberose のユーザは、ネットワークで OpenSSH を実装するために追加の変更が必要になるでしょう。</p></div></div><div class=sect3><h4 id=security-rkhunter>13.2.6. バックドアおよびルートキット<a class=anchor href=#security-rkhunter></a></h4><div class=paragraph><p>バックドアおよびルートキットは、 それらがインストールされた後に脅威となります。 インストールされると、この悪意のあるソフトウェアは、 攻撃者のために侵入口を設置します。 実際的には、システムが一度汚染された後に、調査が行われ、 消去されます。 慎重なセキュリティやシステムエンジニアでさえも、 攻撃者が残したソフトウェアを見逃してしまうという恐ろしいリスクが存在しています。</p></div><div class=paragraph><p>バックドアまたはルートキットソフトウェアは、 管理者にとって役に立つことが一つあります。 それは、一度検出すると、 システムのどこかが危険に冒されていることの痕跡となります。 しかし、通常この種のアプリケーションは、とてもうまく隠れています。 バックドアおよびルートキットを検出するツールが存在しており、 それうちの一つが、 <a class=package href=https://cgit.freebsd.org/ports/tree/security/rkhunter/>security/rkhunter</a> です。</p></div><div class=paragraph><p>インストール後、以下のコマンドでシステムをチェックできます。 実行すると多くの情報が出力されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rkhunter -c</span></code></pre></div></div><div class=paragraph><p>このプロセスを実行中に <kbd>ENTER</kbd> キーを何度か押す必要があります。 完了すると、ステータスメッセージが画面に表示されます。 このメッセージは、チェックしたファイルの量、疑わしいファイルの数、 可能性のあるルートキット等の情報を含みます。 チェックの最中、隠されたファイル、 OpenSSH プロトコルの選択、そして、 時には、インストールされているソフトウェアの漸弱性のバージョンに関する一般的なセキュリティの警告が出力されます。 すぐに、もしくはより詳細な解析が行われた後に、対応が可能です。</p></div><div class=paragraph><p>管理者は皆、 担当しているシステム上で何が実行されているかを把握している必要があります。 rkhunter, lsof や <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> といったネイティブのツールは、 システムに関するかなり多くの情報を与えてくれます。 正常な状態がどのような状態であるかを把握しておき、 本来と違う状況になった場合には、質問をしたり、 疑い深くなってください。 セキュリティが破られることを避けることは理想ですが、 破られたことを把握することは必須です。</p></div></div><div class=sect3><h4 id=security-ids>13.2.7. バイナリ検証<a class=anchor href=#security-ids></a></h4><div class=paragraph><p>システムファイルおよびバイナリの検証は、 システム管理者およびセキュリティチームに対して、 システムの変更に関する情報を提供してくれるため重要です。 いかなるシステムにおいても、システム管理チームの知らないところで、 内部のコマンドやアプリケーションは変更すべきではありません。 システムの変更ををモニタリングするソフトウェアアプリケーションは、 侵入検知システム (Intrusion Detection System) または IDS と呼ばれます。</p></div><div class=paragraph><p>FreeBSD は、基本的な IDS システムをネイティブで提供しています。 実際に、毎晩の <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> セキュリティに関するメールの中では、 管理者に変更点を通知します。 情報はローカルに保存されているので、 悪意のあるユーザが変更し、情報を "欺く" 可能性があります。 そのため、バイナリの署名の別のセットを作成して、 読み取り専用の root 所有のディレクトリ、できれば、 USB ディスクまたは rsync サーバといったシステムとは別のシステムに保存してください。</p></div><div class=paragraph><p>まず最初に、シードを生成する必要があります。 これは、数値定数で、ハッシュ値の生成やハッシュ値の検証で使われます。 このシードがないと、 ファイルのチェックサムの値を偽ったり検証が可能になります。 以下の例では、シードは <code>-s</code> フラグで指定されています。 最初に以下のコマンドを用いて <span class=filename>/bin</span> のハッシュ値およびチェックサムを生成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mtree -s 3483151339707503 -c -K cksum,sha256digest -p /bin &gt; bin_chksum_mtree</span></code></pre></div></div><div class=paragraph><p>このコマンドの出力は以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mtree: /bin checksum: 3427012225</span></code></pre></div></div><div class=paragraph><p><span class=filename>bin_cksum_mtree</span> ファイルを見ると、 以下のような出力となります。</p></div><div class="literalblock programlisting"><div class=content><pre>#          user: root
#       machine: dreadnaught
#          tree: /bin
#          date: Mon Feb  3 10:19:53 2014
# .
/set type=file uid=0 gid=0 mode=0555 nlink=1 flags=none
.               type=dir mode=0755 nlink=2 size=1024 \
                time=1380277977.000000000
    \133        nlink=2 size=11704 time=1380277977.000000000 \
                cksum=484492447 \
                sha256digest=6207490fbdb5ed1904441fbfa941279055c3e24d3a4049aeb45094596400662a
    cat         size=12096 time=1380277975.000000000 cksum=3909216944 \
                sha256digest=65ea347b9418760b247ab10244f47a7ca2a569c9836d77f074e7a306900c1e69
    chflags     size=8168 time=1380277975.000000000 cksum=3949425175 \
                sha256digest=c99eb6fc1c92cac335c08be004a0a5b4c24a0c0ef3712017b12c89a978b2dac3
    chio        size=18520 time=1380277975.000000000 cksum=2208263309 \
                sha256digest=ddf7c8cb92a58750a675328345560d8cc7fe14fb3ccd3690c34954cbe69fc964
    chmod       size=8640 time=1380277975.000000000 cksum=2214429708 \
                sha256digest=a435972263bf814ad8df082c0752aa2a7bdd8b74ff01431ccbd52ed1e490bbe7</pre></div></div><div class=paragraph><p>コンピュータのホスト名、現在の日付と時間、<a href="https://man.freebsd.org/cgi/man.cgi?query=mtree&amp;sektion=8&amp;format=html">mtree(8)</a> を実行したユーザの情報すべてがこのレポートには含まれています。 また、各バイナリに対するチェックサム、サイズ、タイムスタンプおよび SHA256 ダイジェストも含まれています。</p></div><div class=paragraph><p>バイナリ署名の検証のために、 以下のコマンドを実行すると、現在の署名のリストを読み込み、 結果を出力します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mtree -s 3483151339707503 -p /bin &lt; bin_chksum_mtree &gt;&gt; bin_chksum_output</span></code></pre></div></div><div class=paragraph><p>このコマンドを実行すると、すでにチェックサムを生成している <span class=filename>/bin</span> に対して、同様のチェックサムを生成します。 このコマンドを実行してから変更が行われていないので、 <span class=filename>bin_chksum_output</span> への主力は空となります。 変更が行われた場合をシミュレートするために、 <span class=filename>/bin/cat</span> ファイルの日付を <a href="https://man.freebsd.org/cgi/man.cgi?query=touch&amp;sektion=1&amp;format=html">touch(1)</a> を使って変更して、 再度検証のコマンドを実行してみます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /bin/cat</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mtree -s 3483151339707503 -p /bin &lt; bin_chksum_mtree &gt;&gt; bin_chksum_output</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat bin_chksum_output</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>cat changed
	modification time expected Fri Sep 27 06:32:55 2013 found Mon Feb  3 10:28:43 2014</pre></div></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/security/aide/>security/aide</a> のような、 より高度な IDS システムもありますが、 ほとんどのケースにおいて、 <a href="https://man.freebsd.org/cgi/man.cgi?query=mtree&amp;sektion=8&amp;format=html">mtree(8)</a> は管理者が必要とする機能を提供します。 悪意のあるユーザが、 シード値およびチェックサムの出力を見れないようにすることが重要です。</p></div></div><div class=sect3><h4 id=security-tuning>13.2.8. セキュリティのためのシステムの調整<a class=anchor href=#security-tuning></a></h4><div class=paragraph><p>システムの機能の多くは、<a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> を使って調整できます。 Denial of Service (DOS) スタイルの攻撃を避けるためのセキュリティ機能に対しても同様です。 この節では、より重要な調整についても触れています。 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> により、設定が変更された時はいつでも、 望まない危害が起こる可能性は高まり、 システムの可用性に影響します。 システム全体の設定を変更する時には、 システムの CIA を考える必要があります。</p></div><div class=paragraph><p>以下では、<a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> の一覧、 および変更がシステムにどのように影響するかを説明します。</p></div><div class=paragraph><p>デフォルトでは、FreeBSD のカーネルはセキュリティレベル -1 で起動します。 このセキュリティレベルは、 変更不可のファイルフラグを外したり、 すべてのデバイスに対して読み込みおよび書き込みができたりするので、 "insecure mode" と呼ばれます。 このセキュアレベルは、管理者または <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> による起動時のスクリプトにより変更されない限り -1 のままです。 <span class=filename>/etc/rc.conf</span> において、 <code>kern_securelevel_enable</code> を <code>YES</code> とし、 <code>kern_securelevel</code> に必要とする値を設定することで、 システム起動時にセキュアレベルを高めることができます。 これらの設定についてのより詳細な情報については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=security&amp;sektion=7&amp;format=html">security(7)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> をご覧ください。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><code>securelevel</code> を大きくしすぎると、 Xorg が動かなくなったり、他の問題が起きる可能性があります。 デバッグの心づもりをしてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>つぎに変更を検討すべき <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> は、 net.inet.tcp.blackhole および net.inet.udp.blackhole です。 これらを設定すると、閉じたポートに対して届く SYN パケットはドロップされ、 RST レスポンスを返しません。 通常は、RST を返し、 そのポートが閉じられていることを伝えます。 これにより、システムに対する "ステルス" スキャンに対し、ある程度の防御となります。 net.inet.tcp.blackhole を "2"、 net.inet.udp.blackhole を "1" に設定してください。 詳細な情報について <a href="https://man.freebsd.org/cgi/man.cgi?query=blackhole&amp;sektion=4&amp;format=html">blackhole(4)</a> をご覧ください。</p></div><div class=paragraph><p>さらに、net.inet.icmp.drop_redirect および net.inet.ip.redirect も設定すべきです。 これら 2 つの <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> は、リダイレクト攻撃を防ぐ助けとなるでしょう。 リダイレクト攻撃は、 故意に通常のネットワークでは必要としないような大量の ICMP タイプ 5 のパケットを発生します。 そのため net.inet.icmp.drop_redirect を "1"、 net.inet.ip.redirect を "0" に設定して下さい。</p></div><div class=paragraph><p>ソースルーティングは、 内部ネットワーク上でルーティングできないアドレスを検出したりアクセスするための方法です。 通常ルーティングできないアドレスは、 意図してルーティングできないようにしているので、 この設定はおそらく無効にすべきです。 この機能を無効にするには、 net.inet.ip.sourceroute および net.inet.ip.accept_sourceroute を "0" に設定してください。</p></div><div class=paragraph><p>ブロードキャストアドレスに対するすべての ICMP エコーリクエストは、ドロップしてください。 ネットワーク上のコンピュータがサブネットにあるすべてのホストにメッセージを送る必要がある場合には、 メッセージはブロードキャストアドレスに送られます。 外部のホストについては、 このような送信をする必要はないので、 外部からブロードキャストへのリクエストをすべて拒否するように、 net.inet.icmp.bmcastecho を "0" に設定してください。</p></div><div class=paragraph><p>まだ多くの <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> が <a href="https://man.freebsd.org/cgi/man.cgi?query=security&amp;sektion=7&amp;format=html">security(7)</a> で説明されています。 さらに多くの情報を調べることが推奨されます。</p></div></div></div><div class=sect2><h3 id=one-time-passwords>13.3. ワンタイムパスワード<a class=anchor href=#one-time-passwords></a></h3><div class=paragraph><p>デフォルトで、FreeBSD は One-time Passwords In Everything (OPIE) に対応しています。 OPIE はデフォルトでは MD5 ハッシュを使用します。</p></div><div class=paragraph><p>三種類の異なる「パスワード」があります。 まず一つ目は、通常の UNIX® スタイル、もしくは Kerberos のパスワードです。 二つ目は、<a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> によって生成され、 <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> およびログインプロンプトが受け付けるワンタイムパスワードです。 三つ目のパスワードは、<a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> と場合により <code>opiepasswd</code> に対してワンタイムパスワードを生成するのに使われる "秘密のパスワード" です。</p></div><div class=paragraph><p>秘密のパスワードは、UNIX® パスワードと何の関連性もありません。 両者を同一に設定することは可能ですが、お奨めしません。古い UNIX® パスワードは長さが 8 文字に制限されていました 。 これに対し、OPIE の秘密のパスワードには 8 文字の制限はありません。 6 語から 7 語からなるパスフレーズがふつうです。ほとんどの部分で、 OPIE システムは UNIX® のパスワードシステムと完全に独立して動作するようになっています。</p></div><div class=paragraph><p>パスフレーズに加え、OPIE システムにとって重要な 2 種類のデータがあります。一つは "シード (seed: 種)" または "キー (key: 鍵)" と呼ばれるもので、2 つの文字と 5 つの数字で構成されます。もう一つは "シーケンス番号 (iteration count)" で、1 から 100 までの整数です。 OPIE はここまでに述べたデータを利用してワンタイムパスワードを生成します。 その方法は、まずシードと秘密のパスフレーズを連結し、 それに対してシーケンス番号の回数だけ MD5 ハッシュを繰り返し計算します。 そしてその結果を 6 つの短い英単語に変換します。 この 6 つの英単語がワンタイムパスワードです。 認証システム (主は PAM) は、 前回最後に受け付けたワンタイムパスワードを記録しています。 そして、その前回のワンタイムパスワードと、 ユーザが入力したワンタイムパスワードを 1 回ハッシュ関数にかけた結果とが一致した場合に、 このユーザは認証されます。 一方向ハッシュ関数を使っているので、 もし正しく認証されたワンタイムパスワードが一回盗聴されたとしても、 次回以降に使われる複数のワンタイムパスワードを生成することは不可能です。 シーケンス番号はログインが成功するたびに一つずつ減らされて、 ユーザとログインプログラムの間で同期が取られます。 シーケンス番号が 1 まで減ったら、 OPIE を再度初期化する必要があります。</p></div><div class=paragraph><p>このプロセスに関連するいくつかのプログラムがあります。 <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> は、シーケンス番号と、シードと、 秘密のパスフレーズを受け付けて、ワンタイムパスワード 1 つ、 または一連のワンタイムパスワードの一覧を生成します。 <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> は、OPIE の初期化に加え、パスワード、 シーケンス番号やシードを変更するためにも使用されます。 このプログラムを実行するには、秘密のパスフレーズか、 または、シーケンス番号とシードとワンタイムパスワードの 1 組かの、どちらかを与えます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=opieinfo&amp;sektion=1&amp;format=html">opieinfo(1)</a> は、 認証ファイル (<span class=filename>/etc/opiekeys</span>) を調べて、 プログラムを起動したユーザの現在のシーケンス番号とシードを表示します。</p></div><div class=paragraph><p>4 種類の異なる操作があります。 1 つ目は、<a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> を信頼できる通信路上で利用して、 最初にワンタイムパスワードを設定したり、 秘密のパスフレーズやシードを変更する操作です。 2 つ目は、同じことを行うために <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> を信頼できない通信路上で利用する操作です。 この場合は信頼できる通信路経由の <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> を併用します。3 つ目は、<a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> を使い、信頼できない通信路を通じてログインする操作です。 4 番目は、<a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> を使って複数のワンタイムパスワードを一気に生成する操作です。 ここで生成した複数のワンタイムパスワードは、 メモしたり印刷したりして携帯し、 信頼できる通信路が一切ないところからの接続に利用できます。 (訳注: ワンタイムパスワードを記録した紙をなくさないこと! 電話番号や IP アドレス、ユーザ名を一緒にメモしていたら最悪です!!)</p></div><div class=sect3><h4 id=_信頼できる通信路での初期化>13.3.1. 信頼できる通信路での初期化<a class=anchor href=#_信頼できる通信路での初期化></a></h4><div class=paragraph><p>OPIE を初めて初期化するには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd <span class=nt>-c</span>
<span class=o>[</span>grimreaper] ~ <span class=nv>$ </span>opiepasswd <span class=nt>-f</span> <span class=nt>-c</span>
Adding unfurl:
Only use this method from the console<span class=p>;</span> NEVER from remote. If you are using
telnet, xterm, or a dial-in, <span class=nb>type</span> ^C now or <span class=nb>exit </span>with no password.
Then run opiepasswd without the <span class=nt>-c</span> parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:

ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</code></pre></div></div><div class=paragraph><p><code>Enter new secret pass phrase:</code> または <code>Enter secret password:</code> というプロンプトに対して、 パスワードまたはパスフレーズを入力してください。 このパスワードは、 ログインするときに使うワンタイムパスワードを生成するために使うものであり、 ログインのためのパスワードではありません。 "ID" から始まる行は、1 回分のパラメータで、 ログイン名とシーケンス番号とシードです。 ログインするときには、 システム側がこれらのパラメータを覚えていて表示してくれるので、 これらのパラメータを覚えておく必要はありません。 最後の行が、今述べたパラメータと入力された秘密のパスワードから計算されたワンタイムパスワードです。 次にログインするときに打ち込むべきワンタイムパスワードがこれです。</p></div></div><div class=sect3><h4 id=_信頼できない通信路での初期化>13.3.2. 信頼できない通信路での初期化<a class=anchor href=#_信頼できない通信路での初期化></a></h4><div class=paragraph><p>信頼できない通信路を使って秘密のパスフレーズを初期化または変更するためには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> を実行するための信頼できる通信路を用意しておく必要があります。 たとえばそれは、 信頼できるマシンのシェルプロンプトだったりするでしょう。 (訳注: ここでの通信路とはマシンそのものになります。 信頼できるマシンとは、 信頼できる人がしっかり管理しているマシンということです)。 他に準備しておくものとして、シーケンス番号 (100 は適切な値といえるでしょう) と、場合によっては自分で考えた、 またはランダムに生成されたシードがあります。 信頼できない通信路を使うときには、<a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> を使ってコンピュータを初期化してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
	otp-md5 498 to4268 ext
	Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
	otp-md5 499 to4269
	Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</code></pre></div></div><div class=paragraph><p>デフォルトのシードで構わなければ、<kbd>Return</kbd> を押してください。アクセスパスワードを入れる前に、 あらかじめ用意しておいた信頼できる通信路へ移って、 先ほどと同じパラメータを入力します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</code></pre></div></div><div class=paragraph><p>信頼できない通信路の方に戻って、 生成されたワンタイムパスワードをコピーして対応するプログラムに入力します。</p></div></div><div class=sect3><h4 id=_ワンタイムパスワードを一つ生成する>13.3.3. ワンタイムパスワードを一つ生成する<a class=anchor href=#_ワンタイムパスワードを一つ生成する></a></h4><div class=paragraph><p>OPIE を初期化したら、 ログイン時には以下のようなプロンプトが出てくるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>example.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;ユーザ名&gt;
otp-md5 498 gr4269 ext
Password:</code></pre></div></div><div class=paragraph><p>OPIE のプロンプトには便利な機能が備わっています。 パスワードプロンプトに対して、 <kbd>Return</kbd> を押すとエコーモードに切り替わり、 タイプした文字がそのまま見えるようになるのです。 これは、 紙に印刷していたりするワンタイムパスワードを手で入力しなければならない場合に役立つ機能です。</p></div><div class=paragraph><p>次に、 このログインプロンプトに対して入力するワンタイムパスワードを生成してください。 これは、<a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> プログラムを使える信頼できるマシン上で行わなければなりません。 このプログラムには Windows®, Mac OS® および FreeBSD 版があります。 どちらも、 コマンドラインからシーケンス番号とシードを指定しなければなりません。 ログインしようとしているマシンのログインプロンプトから直接カットアンドペーストすると楽でしょう。</p></div><div class=paragraph><p>信頼できるシステムで</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</code></pre></div></div><div class=paragraph><p>ワンタイムパスワードが生成されたので、 ログインを続けてください。</p></div></div><div class=sect3><h4 id=_複数のワンタイムパスワードを生成する>13.3.4. 複数のワンタイムパスワードを生成する<a class=anchor href=#_複数のワンタイムパスワードを生成する></a></h4><div class=paragraph><p>都合によっては、 信頼できるマシンや信頼できる通信路が一切確保できないようなことがあるでしょう。 このような場合には、<a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> を使って複数のワンタイムパスワードを生成できます。 たとえば</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey <span class=nt>-n</span> 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: &lt;secret password&gt;
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</code></pre></div></div><div class=paragraph><p><code>-n 5</code> という引数によって 5 個のワンタイムパスワードを順に生成します。 また <code>30</code> は、 最後のシーケンス番号となるべき数字です。出力は使う順番とは <em>逆</em> に出力されていることに注意してください (訳注: 一番最初に使うワンタイムパスワードは一番最後に出力されたものです)。 もしあなたがセキュリティに偏執するなら、 この結果を紙と鉛筆を使って手で書き移した方がよいかもしれません。 そうでなければ、この結果を印刷すると良いでしょう。 ここで、 出力の各行はシーケンス番号とそれに対応する一回分のワンタイムパスワードです。 消費済みのワンタイムパスワードをペンで消していってください。</p></div></div><div class=sect3><h4 id=_unix_パスワードの利用を制限する>13.3.5. UNIX® パスワードの利用を制限する<a class=anchor href=#_unix_パスワードの利用を制限する></a></h4><div class=paragraph><p>OPIE は、ログインセッションの IP アドレスをベースとした UNIX® パスワードの使用を制限できます。 関連ファイルは、<span class=filename>/etc/opieaccess</span> で、 デフォルトで用意されています。 このファイルの詳細や、 このファイルを使用する際に考慮すべきセキュリィについては <a href="https://man.freebsd.org/cgi/man.cgi?query=opieaccess&amp;sektion=5&amp;format=html">opieaccess(5)</a> を確認してください。</p></div><div class=paragraph><p>以下は <span class=filename>opieaccess</span> の例です。</p></div><div class="literalblock programlisting"><div class=content><pre>permit 192.168.0.0 255.255.0.0</pre></div></div><div class=paragraph><p>この行では、(なりすましされやすい) IP ソースアドレスが、 ある値やマスクにマッチするユーザに対して、 UNIX® パスワードをいつでも許可します。</p></div><div class=paragraph><p>もし <span class=filename>opieaccess</span> のどのルールにも一致しなければ、 デフォルトでは非 OPIE ログインは使えません。</p></div></div></div><div class=sect2><h3 id=tcpwrappers>13.4. TCP Wrappers<a class=anchor href=#tcpwrappers></a></h3><div class=paragraph><p>TCP Wrappers は、 すべてのサーバデーモンに対するサポートをその管理下で提供できるように、 <a href=./#network-inetd>「inetd 「スーパサーバ」」</a> の機能を拡張します。 この方法を使うことで、ログへの対応、 接続に対してメッセージを返したり、 内部の接続だけを許可するようにデーモンを設定することが可能となります。 これらの機能のいくつかはファイアウォールでも実装できますが、 TCP Wrappers は、 システムを守るためのレイヤを追加し、 ファイアウォールが提供する以上の管理機能を提供します。</p></div><div class=paragraph><p>TCP Wrappers は、 適切に設定されたファイアウォールの置き換えと考えるべきではありません。 TCP Wrappers は、 ファイアウォールや他のセキュリティ強化のツールと組み合わせて使うべきです。</p></div><div class=sect3><h4 id=_初期設定>13.4.1. 初期設定<a class=anchor href=#_初期設定></a></h4><div class=paragraph><p>FreeBSD 上で TCP Wrappers を有効にするには、 <span class=filename>rc.conf</span> から <code>-Ww</code> オプションで <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> サーバが起動されることを確認してください。 その後、<span class=filename>/etc/hosts.allow</span> を適切に設定してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>他の TCP Wrappers の実装と異なり、 <span class=filename>hosts.deny</span> は廃止されました。 すべての設定オプションは <span class=filename>/etc/hosts.allow</span> に書かれている必要があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>最も簡単な設定におけるデーモンの接続ポリシは、 <span class=filename>/etc/hosts.allow</span> の中で、 オプションごとに許可またはブロックするように設定するというものです。 FreeBSD のデフォルトの設定では、<a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> から起動されたすべてのデーモンの接続を許可します。</p></div><div class=paragraph><p>基本的な設定は、通常 <code>daemon : address : action</code> という形式です。ここで、 <code>daemon</code> は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> が起動するデーモンの名前です。 <code>address</code> の部分は、有効なホスト名、 IP アドレスまたは、 括弧 ([ ]) で囲まれた IPv6 アドレスです。 <code>action</code> は、 <code>allow</code> または <code>deny</code> です。 TCP Wrappers は、 最初にマッチしたルールが適用されます。 これは、設定ファイルに対するルールにマッチするかどうかのスキャンは、 昇順に行われることを意味しています。 マッチすると、ルールが適用され、 検索のプロセスは終了します。</p></div><div class=paragraph><p>例として、POP3 の接続を <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a> デーモン経由で許可するには、以下の行を <span class=filename>hosts.allow</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre></div></div><div class=paragraph><p>この行を追加したら、 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> を再起動してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd restart</span></code></pre></div></div></div><div class=sect3><h4 id=_高度な設定>13.4.2. 高度な設定<a class=anchor href=#_高度な設定></a></h4><div class=paragraph><p>TCP Wrappers は、 接続を取り扱う以上の制御を行う高度な設定も提供しています。 ある時は、 接続しているホストまたはデーモンにコメントを返すことが適切であることがあります。 別の場合では、おそらくログエントリを記録したり、 管理者にメールで送る必要があることもあるでしょう。 またその他の状況としては、 サービスをローカルの接続のみの使用に制限する必要がある場合もあります。 これらはすべて、<code>ワイルドカード</code> と呼ばれる設定のオプション (拡張文字および外部コマンドの実行) で可能となります。</p></div><div class=sect4><h5 id=_外部コマンド>13.4.2.1. 外部コマンド<a class=anchor href=#_外部コマンド></a></h5><div class=paragraph><p>接続は拒否しなければならないが、 その理由を接続の確立を試みた相手に送りたい状況を考えてください。 このアクションは、<code>twist</code> を使うことで実現可能です。 接続が試みられると、<code>twist</code> はシェルコマンドまたはスクリプトを実行します。 この場合の例は、 <span class=filename>hosts.allow</span> に書かれています。</p></div><div class="literalblock programlisting"><div class=content><pre># The rest of the daemons are protected.
ALL : ALL \
	: severity auth.info \
	: twist /bin/echo &#34;You are not welcome to use %d from %h.&#34;</pre></div></div><div class=paragraph><p>この例では、 "You are not allowed to use <code>daemon</code> from <code>hostname</code>." というメッセージを、 アクセスファイルの中で設定されていないすべてのデーモンに対して返します。 接続元に対し、 確立された接続が破棄された直後に返答することは有効です。 返信に使われるメッセージは、引用符 (<code>"</code>) で囲む <em>必要</em> があります。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>攻撃者や攻撃者のグループは、 これらのデーモンの接続のリクエストであふれさせることにより、 サーバに対して DoS 攻撃を仕掛けることができます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>他の可能性は <code>spawn</code> を使うことです。 <code>twist</code> と同様に、 <code>spawn</code> は、暗黙のうちに接続を拒否し、 外部のシェルコマンドやスクリプトを実行できます。 <code>twist</code> と異なり、<code>spawn</code> は、 接続を確立した相手に対し、返事を返すことはありません。 たとえば、以下のような設定の行を考えてみてください。</p></div><div class="literalblock programlisting"><div class=content><pre># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</pre></div></div><div class=paragraph><p>この行は、<code>*.example.com</code> からの接続をすべて拒否します。 ホスト名、IP アドレスおよびアクセスを試みたデーモンが、 <span class=filename>/var/log/connections.log</span> に記録されます。</p></div><div class=paragraph><p>この例では、置換文字 <code>%a</code> および <code>%h</code> が使われています。 置換文字の完全な一覧は <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> をご覧ください。</p></div></div><div class=sect4><h5 id=_ワイルドカードオプション>13.4.2.2. ワイルドカードオプション<a class=anchor href=#_ワイルドカードオプション></a></h5><div class=paragraph><p><code>ALL</code> オプションは、 デーモン、ドメインまたは IP アドレスのすべてのインスタンスのどれかにマッチするかどうかに使われます。 他のワイルドカードは、偽造された IP アドレスを提供するホストにマッチするかどうかに用いられる <code>PARANOID</code> です。 たとえば、<code>PARANOID</code> を使うことで、 ホスト名と異なる IP アドレスからの接続があった時のアクションを定義できます。 以下の例では、ホスト名から検索される IP アドレスと異なる IP アドレスを持つ <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> への接続のすべてのリクエストを拒否します。</p></div><div class="literalblock programlisting"><div class=content><pre># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</pre></div></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>クライアントもしくはサーバの DNS の設定が間違っている場合に、 <code>PARANOID</code> ワイルドカードを使うと、 サーバがとても使いづらくなります。 管理者の慎重さが求められます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ワイルドカードおよび関連する機能についてもっと知りたい場合には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> をご覧ください。</p></div><div class=paragraph><p>上記の設定が動作するには、<span class=filename>hosts.allow</span> の中で、 最初の設定の行がコメントアウトされている必要があります。</p></div></div></div></div><div class=sect2><h3 id=kerberos5>13.5. Kerberos5<a class=anchor href=#kerberos5></a></h3><div class=paragraph><p>Kerberos は、 サーバのサービスによってユーザが安全に認証を受けられるようにするための、 ネットワークの付加システムおよびプロトコルです。 Kerberos は、 身元確認プロキシシステムや、 信頼される第 3 者認証システムとも説明されます。 ユーザが Kerberos を使って認証を行った後は、 通信は暗号化され、 プライバシおよびデータの完全性を保証することができます。</p></div><div class=paragraph><p>Kerberos の唯一の機能は、 ネットワーク上のユーザの安全な認証を提供することです。 承認 (どのユーザが許可されているか) や監査 (ユーザがどのような作業を行っているか) の機能は提供しません。 Kerberos を使う際は、 承認および監査サービスを提供する他のセキュリティの手段との利用が、 推奨されます。</p></div><div class=paragraph><p>この節では、FreeBSD 用として配布されている Kerberos をセットアップする際のガイドを提供します。 完全な説明が必要な場合には、 マニュアルページを参照してください。</p></div><div class=paragraph><p>この節における Kerberos のインストールのデモでは、以下のような名前空間が使われます。</p></div><div class=ulist><ul><li><p>DNS ドメイン ("ゾーン") は、 <code>example.org</code> です。</p></li><li><p>Kerberos の領域は、 <code>EXAMPLE.ORG</code> です。</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Kerberos の設定では、 内部での使用でも実際のドメイン名を使ってください。 DNS の問題を避けることができ、 他の Kerberos のレルム (realm) との相互運用を保証します。</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_歴史>13.5.1. 歴史<a class=anchor href=#_歴史></a></h4><div class=paragraph><p>Kerberos は、 ネットワークのセキュリティ問題を解決するために、 MIT で開発されました。 Kerberos プロトコルは、 必ずしも安全ではないインターネット接続においても、 サーバに対して (逆もまた同様に)、 強い暗号を使って身元を証明します。</p></div><div class=paragraph><p>Kerberos は、 ネットワーク認証プロトコルの名前であり、 Kerberos telnet のように、 このプログラムを実装しているプログラムを表すための形容詞でもあります。 プロトコルの現在のバージョンはバージョン 5 で、 RFC 1510 として文書化されています。</p></div><div class=paragraph><p>このプロトコルのいくつものフリーの実装が、 さまざまなオペレーティングシステムで利用できます。 最初の Kerberos を開発したマサチューセッツ工科大学 (MIT) は、 開発した Kerberos パッケージを継続的に保守しています。 アメリカ合衆国では暗号製品として良く使われていますが、 歴史的には、 アメリカ合衆国 の輸出規制により制限されてきました。 MIT で実装された Kerberos は、 <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a> package または port から利用できます。 バージョン 5 のもう一つの実装が、 Heimdal Kerberos です。 この実装は、アメリカ合衆国の外で開発されたため、 輸出の制限を避けることができます。 Heimdal Kerberos は <a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a>> package または port からインストールできますが、最小構成は FreeBSD の base インストールに含まれています。</p></div><div class=paragraph><p>以下の説明では FreeBSD に含まれている Heimdal ディストリビューションの使用を想定しています。</p></div></div><div class=sect3><h4 id=_heimdal_kdc_の設定>13.5.2. Heimdal KDC の設定<a class=anchor href=#_heimdal_kdc_の設定></a></h4><div class=paragraph><p>鍵配布センター (KDC) は、 Kerberos が提供する中心的な認証サービスで、 Kerberos チケットを発行するコンピュータです。 KDC は、 Kerberos のレルムの中のすべてのコンピュータから "信頼"されています。 そのため、厳重なセキュリティに対する配慮が必要となります。</p></div><div class=paragraph><p>Kerberos サーバの実行にコンピュータのリソースはほとんど必要ありませんが、 セキュリティの観点から、KDC としてのみ機能する専用のコンピュータが推奨されます。</p></div><div class=paragraph><p>KDC を設定するにあたって、 KDC として動作するために、 適切に <span class=filename>/etc/rc.conf</span> が設定されていることを確認してください。 必要に応じて、 システムの設定を反映するようにパスを調整する必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>kerberos5_server_enable=&#34;YES&#34;
kadmind5_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>次に、<span class=filename>/etc/krb5.conf</span> を以下のように編集してください。</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</pre></div></div><div class=paragraph><p><span class=filename>/etc/krb5.conf</span> の中で、 KDC は、 完全修飾されたホスト名 <code>kerberos.example.org</code> を使うことが想定されています。 KDC が異なるホスト名を持つ場合には、 名前の解決が行われるように、適切に CNAME (エイリアス) エントリをゾーンファイルに追加してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>適切に DNS サーバが設定されている大きなネットワークでは、 上記の例は、以下のように整理されます。</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
      default_realm = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>そして、<code>example.org</code> ゾーンファイルには、以下の行が付け加えられます。</p></div><div class="literalblock programlisting"><div class=content><pre>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</pre></div></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>クライアントが、 Kerberos サービスを見つけるためには、 <span class=filename>/etc/krb5.conf</span> を完全に設定するか、 <span class=filename>/etc/krb5.conf</span> を最低限に設定し、 <em>さらに</em> DNS サーバを適切に設定する <em>必要</em> があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>次に Kerberos データベースを作成してください。 このデータベースには、 マスター鍵により暗号化されたすべてのプリンシパルの鍵が含まれています。 このパスワードは、 <span class=filename>/var/heimdal/m-key</span> に保存されるため、 覚える必要はありません。 マスター鍵を作成するには、<a href="https://man.freebsd.org/cgi/man.cgi?query=kstash&amp;sektion=8&amp;format=html">kstash(8)</a> を実行して、 パスワードを入力してください。</p></div><div class=paragraph><p>マスター鍵を作成したら、<code>kadmin -l</code> を使ってデータベースを初期化してください。 このオプションを使うと、<a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmind&amp;sektion=8&amp;format=html">kadmind(8)</a> ネットワークサービスを使わず、 ローカルのデータベースファイルを直接変更します。 これにより、 データベースを作成する前に、データベースへの接続を試みてしまうという、 卵が先か鶏が先かという問題を回避できます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> プロンプトで、 <code>init</code> を使って、 レルムに関する初期のデータベースを作成してください。</p></div><div class=paragraph><p>最後に、<a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> プロンプトで <code>add</code> を使って最初のプリンシパルを作成して下さい。 差し当たりは、 プリンシパルに対するデフォルトのオプションに従ってください。 後で <code>modify</code> を使うことで、 変更することができます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> プロンプトで <code>?</code> と入力すると、 利用可能なオプションを確認できます。</p></div><div class=paragraph><p>データベース作成のセッションの例は以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>
Master key: xxxxxxxx
Verifying password - Master key: xxxxxxxx

<span class=c># kadmin -l</span>
kadmin&gt; init EXAMPLE.ORG
Realm max ticket life <span class=o>[</span>unlimited]:
kadmin&gt; add tillman
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx</code></pre></div></div><div class=paragraph><p>次に KDC サービスを起動してください。 <code>service kerberos start</code> および <code>service kadmind start</code> を実行してサービスを起動してください。 この時点で、kerberos 化されたデーモンが走っていなくても、 KDC のコマンドラインから、作成したばかりの (ユーザ) プリンシパルのチケットを入手したり、 一覧を表示することができることを確認できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit tillman
tillman@EXAMPLE.ORG<span class=s1>&#39;s Password:

% klist
Credentials cache: FILE:/tmp/krb5cc_500
	Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</span></code></pre></div></div><div class=paragraph><p>必要がなくなった時には、チケットを破棄できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kdestroy</code></pre></div></div></div><div class=sect3><h4 id=_heimdal_kerberos_サービスを有効にする>13.5.3. Heimdal Kerberos サービスを有効にする。<a class=anchor href=#_heimdal_kerberos_サービスを有効にする></a></h4><div class=paragraph><p>最初に <span class=filename>/etc/krb5.conf</span> を KDC からクライアントコンピュータへ、 <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> または物理的にリムーバブルディスクを使うといった安全な方法でコピーしてください。</p></div><div class=paragraph><p>次に <span class=filename>/etc/krb5.keytab</span> を作成してください。 これが Kerberos 化されたデーモンを提供するサーバとワークステーションの間での大きな違いです: サーバには <span class=filename>keytab</span> が置かれている必要があります。 このファイルには、サーバのホスト鍵が含まれています。 この鍵により、ホストおよび KDC が他の身元の検証ができます。 鍵が公開されてしまうと、 サーバのセキュリティが破られてしまうため、 このファイルは安全にサーバに転送しなければなりません。</p></div><div class=paragraph><p>一般的には、<a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> を使って、 <span class=filename>keytab</span> をサーバに転送します。 ホストプリンシパル (KDC 側の <span class=filename>krb5.keytab</span>) も <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> を使って作成するので便利です。</p></div><div class=paragraph><p>すでにチケットを入手し、そのチケットは、 <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> インタフェースで使用できることが <span class=filename>kadmind.acl</span> で許可されている必要があります。 アクセスコントロールリストの設計の詳細については、 <code>info heimdal</code> の "Remote administration" というタイトルの章をご覧ください。 リモートからの <code>kadmin</code> アクセスを有効にする代わりに、 管理者は、ローカルコンソールまたは <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> を用いて安全に KDC に接続し、 <code>kadmin -l</code> を使用して、 ローカルで管理作業を行うことができます。</p></div><div class=paragraph><p><span class=filename>/etc/krb5.conf</span> をインストールしたら、 Kerberos サーバから <code>add --random-key</code> を使ってください。 このコマンドは、サーバのホストプリンシパルを追加します。 そして、<code>ext</code> を用いて、 サーバのホストプリンシパルを keytab に抽出してください。 以下は、使用例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>

kadmin&gt; add <span class=nt>--random-key</span> host/myserver.example.org
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
kadmin&gt; ext host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p><code>ext</code> は、デフォルトでは、抽出された鍵を <span class=filename>/etc/krb5.keytab</span> に保存します。</p></div><div class=paragraph><p>KDC 上で <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmind&amp;sektion=8&amp;format=html">kadmind(8)</a> を走らせていない場合で、 リモートから <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> に接続出来ない場合には、 ホストプリンシパル (<code>host/myserver.EXAMPLE.ORG</code>) を直接 KDC 上で追加し、 その後、以下のように KDC 上の <span class=filename>/etc/krb5.keytab</span> の上書きを避けるため、 一時ファイルに抽出してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; ext <span class=nt>--keytab</span><span class=o>=</span>/tmp/example.keytab host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>その後、<a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> またはリムーバブルディスクを使って、 keytab を安全にサーバコンピュータにコピーしてください。 KDC 上の keytab を上書きすることを避けるため、 デフォルトとは異なる名前を指定してください。</p></div><div class=paragraph><p>これでサーバは、 <span class=filename>krb5.conf</span> を使って KDC と通信ができるようになりました。 そして、<span class=filename>krb5.keytab</span> によって身元を証明できるようになったので、 Kerberos サービスを有効にする準備が出来ました。 この例では、 <a href="https://man.freebsd.org/cgi/man.cgi?query=telnetd&amp;sektion=8&amp;format=html">telnetd(8)</a> サービスが <span class=filename>/etc/inetd.conf</span> で有効に設定され、 <code>service inetd restart</code> によって、 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> サービスを再起動します。</p></div><div class="literalblock programlisting"><div class=content><pre>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</pre></div></div><div class=paragraph><p>重要な変更箇所は、<code>-a</code> 認証がユーザに設定されていることです。 詳細については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=telnetd&amp;sektion=8&amp;format=html">telnetd(8)</a> を参照してください。</p></div></div><div class=sect3><h4 id=_heimdal_kerberos_クライアントを有効にする>13.5.4. Heimdal Kerberos クライアントを有効にする<a class=anchor href=#_heimdal_kerberos_クライアントを有効にする></a></h4><div class=paragraph><p>クライアントコンピュータの設定は簡単です。 <span class=filename>/etc/krb5.conf</span> のみが必要です。 このファイルをセキュリティ的に安全な方法で、KDC からクライアントコンピュータへコピーしてください。</p></div><div class=paragraph><p>クライアントから、<a href="https://man.freebsd.org/cgi/man.cgi?query=kinit&amp;sektion=1&amp;format=html">kinit(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=klist&amp;sektion=1&amp;format=html">klist(1)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=kdestroy&amp;sektion=1&amp;format=html">kdestroy(1)</a> を使用し、 上記で作成したプリンシパルに対するチケットの入手、表示、 削除を行い、クライアントコンピュータを試験してください。 Kerberos アプリケーションを使って Kerberos が有効なサーバに接続することもできるはずです。 もしうまく機能しない場合でも、チケットを入手できるのであれば、 問題はおそらくサーバにあり、 クライアントまたは KDC の問題ではないと考えられます。</p></div><div class=paragraph><p>Kerberos 化されたアプリケーションを試験する際には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> といったパケットスニファを使用して、 パスワードが平文で送られていないことを確認してください。</p></div><div class=paragraph><p>コア以外の さまざまな Kerberos クライアントアプリケーションが利用可能です。 FreeBSD の "最小" インストールでは、 インストールされる Kerberos 化された唯一のサービスは、<a href="https://man.freebsd.org/cgi/man.cgi?query=telnetd&amp;sektion=8&amp;format=html">telnetd(8)</a> です。</p></div><div class=paragraph><p>Heimdal port は、 Kerberos 化されている <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rshd&amp;sektion=8&amp;format=html">rshd(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogind&amp;sektion=8&amp;format=html">rlogind(8)</a> および他のあまり一般的ではないプログラムをインストールします。 MIT port も、すべての Kerberos クライアントアプリケーションをインストールします。</p></div></div><div class=sect3><h4 id=_ユーザ設定ファイル_k5login_および_k5users>13.5.5. ユーザ設定ファイル: <span class=filename>.k5login</span> および <span class=filename>.k5users</span><a class=anchor href=#_ユーザ設定ファイル_k5login_および_k5users></a></h4><div class=paragraph><p>レルムのユーザは、一般的には、 ローカルユーザアカウントに対応する Kerberos プリンシパルを持ちます。 しかしながら、時々 Kerberos プリンシパルに対応しないローカルユーザアカウントへのアクセスが必要となることがあります。 たとえば、 <code>tillman@EXAMPLE.ORG</code> が、ローカルユーザアカウント <code>webdevelopers</code> へのアクセスが必要となることがあります。そして、 他のプリンシパルが同じローカルアカウントにアクセスが必要になることもあります。</p></div><div class=paragraph><p>ユーザのホームディレクトリに置かれた <span class=filename>.k5login</span> および <span class=filename>.k5users</span> ファイルを使うことで、 この問題を解決出来ます。 たとえば、以下の行を含む <span class=filename>.k5login</span> を <code>webdevelopers</code> のホームディレクトリに置くと、 一覧にある両方のプリンシパルは、 共有のパスワードを必要としなくても、 このアカウントにアクセス出来ます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>tillman@example.org
jdoe@example.org</code></pre></div></div><div class=paragraph><p><span class=filename>.k5users</span> の詳細については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> を参照してください。</p></div></div><div class=sect3><h4 id=_kerberos_tips_tricks_およびトラブルシューティング>13.5.6. Kerberos Tips, Tricks, およびトラブルシューティング<a class=anchor href=#_kerberos_tips_tricks_およびトラブルシューティング></a></h4><div class=ulist><ul><li><p>Heimdal または MITKerberos ports のどちらを使う場合でも、 <code>PATH</code> は、 Kerberos 版のクライアント アプリケーションが、 システムにあるアプリケーションより先に見つかるように設定されていることを確認してください。</p></li><li><p>レルムにあるすべてのコンピュータの間で時刻が同期していないと、 認証に失敗してしまいます。 NTP を用いた、時刻の同期方法については、 <a href=./#network-ntp>「NTP」</a> をご覧ください。</p></li><li><p>MIT および Heimdal 間の運用は、 標準化されていない <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> を除けばうまく機能します。</p></li><li><p>ホスト名が変更された場合は、 <code>host/</code> プリンシパルを変更し、keytab をアップデートする必要があります。 Apache の <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_auth_kerb/>www/mod_auth_kerb</a> で使われる <code>www/</code> プリンシパルのような特別な keytab エントリでも必要となります。</p></li><li><p>レルムの中のすべてのホストは、DNS、 もしくは、最低限 <span class=filename>/etc/hosts</span> において正引きおよび逆引き両方で名前解決できる必要があります。 CNAME は動作しますが、A および PTR レコードは、 正しく適切な位置に記述されている必要があります。 名前が解決できない場合のエラーメッセージは、 次の例のように、直感的に原因が分かるようなものではありません。 <code>Kerberos5 refuses authentication because Read req failed: Key table entry not found</code>.</p></li><li><p>KDC に対しクライアントとして振る舞うオペレーティングシステムの中には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> に対して、 <code>root</code> 権限に setuid を許可しないものがあります。 この設定では、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> は動作しないことを意味します。 これは KDC のエラーではありません。</p></li><li><p>MITKerberos において、 プリンシパルが、デフォルトの 10 時間を超えるチケットの有効期限としたい場合には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> のプロンプトで <code>modify_principal</code> を使って、 対象のプリンシパルおよび <code>krbtgt</code> プリンシパル両方の有効期限の最大値を変更してください。 プリンシパルは、 <code>kinit -l</code> を使用して、 長い有効期限のチケットを要求できます。
*</p></li></ul></div><div class=exampleblock><div class=content><div class=paragraph><p>トラブルシューティングのために、 KDC でパケットスニファを走らせ、 一方で、ワークステーションにおいて <a href="https://man.freebsd.org/cgi/man.cgi?query=kinit&amp;sektion=1&amp;format=html">kinit(1)</a> を実行すると、 <a href="https://man.freebsd.org/cgi/man.cgi?query=kinit&amp;sektion=1&amp;format=html">kinit(1)</a> を実行するやいなや、 パスワードを入力し終わる前でも、 Ticket Granting Ticket (TGT) が送られてきます。 これに関する説明は、以下の通りです。 Kerberos サーバは、 いかなる未承認のリクエストに対して、 自由に TGT を送信します。 しかしながら、すべての TGT は、 ユーザのパスワードから生成された鍵により、暗号化されています。 そのため、ユーザがパスワードを入力した時には、 パスワードは KDC には送られません。 その代わりこのパスワードは、<a href="https://man.freebsd.org/cgi/man.cgi?query=kinit&amp;sektion=1&amp;format=html">kinit(1)</a> がすでに入手した TGT の復号化に使われます。 もし、復号化の結果、 有効なチケットで有効なタイムスタンプの場合には、 ユーザは、有効な Kerberos クレデンシャルを持ちます。 このクレデンシャルには、 Kerberos サーバ自身の鍵により暗号化された実際の TGT とともに、将来 Kerberos サーバと安全な通信を確立するためのセッション鍵が含まれています。 この暗号の 2 番目のレイヤは、 Kerberos サーバが、 各 TGT の真偽の検証を可能にしている部分です。</p></div></div></div><div class=ulist><ul><li><p>たとえば一週間といった長い有効期限のチケットを使いたい場合で、 OpenSSH を使って、 チケットが保存されているコンピュータに接続しようとする場合は、 Kerberos <code>TicketCleanup</code> が <span class=filename>sshd_config</span> において <code>no</code> と設定されているか、 チケットが、ログアウト時に削除されることを確認してください。</p></li><li><p>ホストプリンシパルは長い有効期限のチケットを持つことができます。 もし、ユーザプリンシパルが 1 週間の有効期限を持ち、 接続しているホストが、9 時間の有効期限を持っている場合には、 ユーザキャッシュは有効期限が切れたホストプリンシパルを持つことになり、 想定したように、 チケットキャッシュが振る舞わないことが起こりえます。</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=kadmind&amp;sektion=8&amp;format=html">kadmind(8)</a> で説明されているような、 特定の問題のあるパスワードが使われることを避けるために <span class=filename>krb5.dict</span> を設定する時には、 パスワードポリシが割り当てられたプリンシパルにのみ適用されることを覚えていてください。 <span class=filename>krb5.dict</span> で使われている形式では、 一行に一つの文字列が置かれています。 <span class=filename>/usr/share/dict/words</span> にシンボリックリンクを作成することは、有効です。</p></li></ul></div></div><div class=sect3><h4 id=_mit_port_との違いについて>13.5.7. MIT port との違いについて<a class=anchor href=#_mit_port_との違いについて></a></h4><div class=paragraph><p>MIT と Heimdal 版の大きな違いは、 <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> に関連しています。 このプログラムは、異なる (ただし等価な) コマンド群を持ち、そして、 異なるプロトコルを使用します。 もし KDC に MIT を使用している場合には、 Heimdal 版の <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> を使って KDC をリモートから (逆も同様に) 管理できないことを意味しています。</p></div><div class=paragraph><p>クライアントアプリケーションでは、同じタスクを行う際に、 若干異なるコマンドラインのオプションが使われることもあります。 MIT Kerberos <a href=http://web.mit.edu/Kerberos/www/>ウェブサイト</a> に書かれているガイドに従うことが推奨されます。 path の問題について注意してください。 MIT port はデフォルトで <span class=filename>/usr/local/</span> にインストールします。 そのため、もし <code>PATH</code> においてシステムのディレクトが最初に書かれている場合には、 MIT 版ではなく、"通常の" システムアプリケーションが起動してしまいます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD の MIT<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a> port において、 <a href="https://man.freebsd.org/cgi/man.cgi?query=telnetd&amp;sektion=8&amp;format=html">telnetd(8)</a> および <code>klogind</code> 経由でのログインが奇妙な振る舞いをすることを理解するには、 port からインストールされる <span class=filename>/usr/local/share/doc/krb5/README.FreeBSD</span> を読んで下さい。 "incorrect permissions on cache file" の振る舞いを修正するには、 フォワードされたクレデンシャリングの所有権を適切に変更できるように、 <code>login.krb5</code> バイナリが認証に使われる必要があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>rc.conf</span> を以下のように変更する必要もあります。</p></div><div class="literalblock programlisting"><div class=content><pre>kerberos5_server=&#34;/usr/local/sbin/krb5kdc&#34;
kadmind5_server=&#34;/usr/local/sbin/kadmind&#34;
kerberos5_server_flags=&#34;&#34;
kerberos5_server_enable=&#34;YES&#34;
kadmind5_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>これを行うのは、 MIT Kerberos のアプリケーションは、 <span class=filename>/usr/local</span> 構造の下にインストールされるためです。</p></div></div><div class=sect3><h4 id=_kerberos_で見つかった制限を緩和する>13.5.8. Kerberos で見つかった制限を緩和する<a class=anchor href=#_kerberos_で見つかった制限を緩和する></a></h4><div class=sect4><h5 id=_kerberos_はall_or_nothing_アプローチです>13.5.8.1. Kerberos は、All or Nothing アプローチです。<a class=anchor href=#_kerberos_はall_or_nothing_アプローチです></a></h5><div class=paragraph><p>ネットワーク上で有効なすべてのサービスは、 Kerberos 化されるか、 または、ネットワーク攻撃に対して安全であるべきです。 さもないと、ユーザのクレデンシャルが盗まれ、 利用されることが起きるかもしれません。 この例は、 Kerberos 化されたすべてのリモートシェルです。 パスワードを平文で送るような POP3 メールサーバは変換していません。</p></div></div><div class=sect4><h5 id=_kerberos_は_シングルユーザのワークステーションでの使用を想定しています>13.5.8.2. Kerberos は、 シングルユーザのワークステーションでの使用を想定しています。<a class=anchor href=#_kerberos_は_シングルユーザのワークステーションでの使用を想定しています></a></h5><div class=paragraph><p>マルチユーザの環境では、 Kerberos は安全ではありません。 チケットは <span class=filename>/tmp</span> に保管され、 このチケットは、すべてのユーザが読むことができるためです。 もし、ユーザがコンピュータを他のユーザと同時に共有していると、 他のユーザは、そのユーザのチケットを盗んだり、 コピーが出来てしまいます。</p></div><div class=paragraph><p>この問題は、<code>-c</code> コマンドラインオプションまたは、好ましくは <code>KRB5CCNAME</code> 環境変数によって克服されます。 この問題への対応には、 チケットをユーザのホームディレクトリに保存し、 ファイルの許可属性を設定することが一般的に行われます。</p></div></div><div class=sect4><h5 id=_kdc_は単一障害点である>13.5.8.3. KDC は、単一障害点である<a class=anchor href=#_kdc_は単一障害点である></a></h5><div class=paragraph><p>設計上、KDC は、 マスターパスワードのデータベースと同様に安全である必要があります。 KDC では、 絶対に他のサービスを走らせるべきではありませんし、 物理的に安全であるべきです。 Kerberos は、 KDC 上で、ファイルとして保存されている同じ "マスター" 鍵で暗号化されたすべてのパスワードを保存しているので、 非常に危険です。</p></div><div class=paragraph><p>マスター鍵が漏洩しても、 懸念するほど悪いことにはなりません。 マスター鍵は、Kerberos データベースの暗号時にのみ、 乱数を生成するためのシードとして使われます。 KDC へのアクセスが安全である限りにおいては、 マスター鍵を用いて、それほど多くのことはできません。</p></div><div class=paragraph><p>さらに、KDC が利用できないと、 認証ができないため、ネットワークサービスを利用できなくなります。 この攻撃による被害は、 ひとつのマスタ KDC とひとつまたはそれ以上のスレーブ、 そして、セカンダリもしくは PAM を用いたフォールバック認証を注意深く実装することにより軽減できます。</p></div></div><div class=sect4><h5 id=_kerberos_の欠点>13.5.8.4. Kerberos の欠点<a class=anchor href=#_kerberos_の欠点></a></h5><div class=paragraph><p>Kerberos は、 ユーザ、ホストおよびサービスの間での認証を可能にしますが、 KDC とユーザ、 ホストまたはサービスとの間の認証のメカニズムは提供しません。 これは、トロイの木馬の <a href="https://man.freebsd.org/cgi/man.cgi?query=kinit&amp;sektion=1&amp;format=html">kinit(1)</a> が、 すべてのユーザ名とパスワードを記録できることを意味しています。 <a class=package href=https://cgit.freebsd.org/ports/tree/security/tripwire/>security/tripwire</a> のような、ファイルシステムの完全性を確認するためのツールにより、 この危険性を軽減することができます。</p></div></div></div><div class=sect3><h4 id=_kerberos_および_ssh1_を用いたアクセスの問題>13.5.9. Kerberos および <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> を用いたアクセスの問題<a class=anchor href=#_kerberos_および_ssh1_を用いたアクセスの問題></a></h4><div class=paragraph><p>Kerberos と <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> を使う場合には、 両者に関して知っておかねばならない問題がいくつかあります。 Kerberos は大変優れた認証プロトコルですが、Kerberos 化された <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a> には、 バイナリストリームを扱うのに不向きになるようなバグがあります。 デフォルトでは、Kerberos は <code>-x</code> を使わない限りセッションを暗号化してくれません。 一方 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> では、 デフォルトですべてを暗号化してくれます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> はとても良く動作しますが、 デフォルトで暗号鍵を転送してしまいます。 このため、<a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> を安全なワークステーションから、 安全でないマシンへのアクセスに使っているユーザに、 セキュリティリスクを引き起こします。 鍵そのものが見えてしまうわけではありませんが、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> は login している間、転送用ポートを作ります。 攻撃者が安全でないマシンの <code>root</code> を破ったら、 このポートを使って、 この暗号鍵でロックが外れる他のマシンへのアクセスを得てしまいます。</p></div><div class=paragraph><p>可能な時はいつでも、スタッフのログインには Kerberos を組み合せた <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> を使用することを勧めます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> は、Kerberos 対応機能と一緒にコンパイルできます。 このようにすることで、見えてしまう可能性のある SSH 鍵への依存を減らし、 一方で、Kerberos 経由によりパスワードが保護されます。 鍵は、安全なマシンからの自動化されたタスクのみに使用すべきです。 Kerberos はこの用途には不向きです。 また、SSH の設定で鍵転送をしないようにするか、 あるいは <span class=filename>authorized_keys</span> の <code>from=IP/DOMAIN</code> を使用して、 特定のマシンからログインしてきたときのみ鍵が有効にすることをお勧めします。</p></div></div><div class=sect3><h4 id=_リソースおよび他の情報源>13.5.10. リソースおよび他の情報源<a class=anchor href=#_リソースおよび他の情報源></a></h4><div class=ulist><ul><li><p><a href=http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html>The Kerberos FAQ</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/dialogue.html>Designing an Authentication System: a Dialog in Four Scenes</a></p></li><li><p><a href="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510, The Kerberos Network Authentication Service (V5)</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/>MIT Kerberos home page</a></p></li><li><p><a href=http://www.pdc.kth.se/heimdal/>Heimdal Kerberos home page</a></p></li></ul></div></div></div><div class=sect2><h3 id=openssl>13.6. OpenSSL<a class=anchor href=#openssl></a></h3><div class=paragraph><p>FreeBSD には、OpenSSL ツールキットが含まれています。 OpenSSL は、 通常の通信層の上位にあるトランスポート層を暗号化し、 多くのネットワークアプリケーションおよびサービスと組み合わせて使用できます。</p></div><div class=paragraph><p>OpenSSL は、 メールクライアントの暗号化された認証、 クレジットカードでの支払いといったウェブベースの取引などで使われます。 <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> および <a class=package href=https://cgit.freebsd.org/ports/tree/mail/claws-mail/>mail/claws-mail</a> といった多くの port では、 OpenSSL とともに構築するコンパイルに対応しています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>多くの場合、Ports Collection は、 make の <code>WITH_OPENSSL_BASE</code> が明示的に "yes" に設定されていないと、 <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssl/>security/openssl</a> port の構築を試みます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>FreeBSD に含まれている OpenSSL 　のバージョンは、Secure Sockets Layer v2/v3 (SSLv2/SSLv3) および Transport Layer Security v1 (TLSv1) ネットワークセキュリティプロトコルに対応しており、 多目的な暗号化ライブラリとして使うことができます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>OpenSSL は、 IDEA アルゴリズムに対応していますが、 合衆国の特許により、デフォルトでは無効になっています。 もし使用したいのであれば、ライセンス条項を必ず確認し、 ライセンス条項に合致するのであれば、 <span class=filename>/etc/make.conf</span> において <code>MAKE_IDEA</code> 変数を設定してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>最も一般的な OpenSSL の利用方法のひとつは、 ソフトウェアアプリケーションが使えるように証明書を提供することです。 これらの証明書により、会社または個人の公開鍵が、 改ざんやなりすましが行われていないことを確認できます。 もし問題となっている証明書が、"認証局" (CA) により検証されなければ、 警告が表示されます。 CA は、<a href=http://www.verisign.com>VeriSign</a> のような会社で、個人または会社の公開鍵の検証を行えるように、 証明書に署名を行います。 証明書を作成するには費用がかかり、 証明書の使用は必要条件ではありませんが、 証明書を使うことで、 ユーザを安心させることができます。</p></div><div class=sect3><h4 id=_証明書の作成>13.6.1. 証明書の作成<a class=anchor href=#_証明書の作成></a></h4><div class=paragraph><p>以下のコマンドにより、証明書を作成できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -nodes -out req.pem -keyout cert.pem</span>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to <span class=s1>&#39;cert.pem&#39;</span>
<span class=nt>-----</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>eg, YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org

Please enter the following <span class=s1>&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class=o>[]</span>:SOME PASSWORD
An optional company name <span class=o>[]</span>:Another Name</code></pre></div></div><div class=paragraph><p>"Common Name" プロンプト直後に表示されているのは、 ドメイン名です。 このプロンプトでは、検証するサーバ名の入力が必要となります。 ドメイン名以外を入力すると、役に立たない証明書が作成されます。 他のオプションとして、有効期限を指定したり、 別の暗号化アルゴリズムを選択することができます。 オプションの完全なリストは、 <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a> で説明されています。</p></div><div class=paragraph><p>このコマンドを実行したディレクトリには、 2 つのファイルが作成されているはずです。 1 つは、証明書要求 <span class=filename>req.pem</span> です。 このファイルを CA に送ると、 CA は含まれている内容を検証し、 検証に成功すると、証明書要求に署名を行い、 作成された証明書を送り返します。 もうひとつ、<span class=filename>cert.pem</span> と呼ばれるファイルが生成されます。 これは証明書の秘密鍵であり、 どのようなことがあっても保護しなくてはなりません。 もし、他の人の手に渡ると、手に入れた人は、 ユーザまたはサーバになりすますことができてしまいます。</p></div><div class=paragraph><p>CA の署名が必要ない場合には、 自己署名証明書を作成できます。 最初に RSA の鍵を生成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl dsaparam -rand -genkey -out myRSA.key 1024</span></code></pre></div></div><div class=paragraph><p>次に、CA 鍵を生成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl gendsa -des3 -out myca.key myRSA.key</span></code></pre></div></div><div class=paragraph><p>この鍵を使って証明書を作成してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -x509 -days 365 -key myca.key -out new.crt</span></code></pre></div></div><div class=paragraph><p>新しく 2 つのファイルがこのディレクトリに作成されます。 プライベート鍵 <span class=filename>myca.key</span> および 証明書 <span class=filename>new.crt</span> です。 これらのファイルを、好ましくは <span class=filename>/etc</span> 以下で、 <code>root</code> のみが読むことのできるディレクトリに置く必要があります。 許可属性は 0700 が適切です。 許可属性は <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> を使って設定できます。</p></div></div><div class=sect3><h4 id=_証明書の使用>13.6.2. 証明書の使用<a class=anchor href=#_証明書の使用></a></h4><div class=paragraph><p>証明書の一つの利用方法は、SendmailMTA への接続を暗号化することです。 これにより、 ローカルの MTA 経由でメールを送信するユーザが、 テキスト認証を使用しなくてもすむようになります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>いくつかの MUA は、 ユーザが証明書をローカルにインストールしていないと、 エラーを出力します。 証明書のインストールに関する詳細な情報については、 ソフトウェアに付随の文書を参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>Sendmail を設定するには、以下の行をローカルの <span class=filename>.mc</span> ファイルに含めてください。</p></div><div class="literalblock programlisting"><div class=content><pre>dnl SSL Options
define(`confCACERT_PATH&#39;,`/etc/certs&#39;)dnl
define(`confCACERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_CERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_KEY&#39;,`/etc/certs/myca.key&#39;)dnl
define(`confTLS_SRV_OPTIONS&#39;, `V&#39;)dnl</pre></div></div><div class=paragraph><p>この例では、 ローカルで証明書および鍵ファイルは、ローカルの <span class=filename>/etc/certs/</span> に置かれています。 ファイルの編集を保存し終わったら、 <span class=filename>/etc/mail</span> において <code>make install</code> と入力することで、ローカルの <span class=filename>.cf</span> ファイルを再構築する必要があります。 その後、<code>make restart</code> と入力して、Sendmail デーモンを再起動してください。</p></div><div class=paragraph><p>すべてがうまくいっていれば、 <span class=filename>/var/log/maillog</span> にはエラーメッセージは出力されず、 Sendmail がプロセスの一覧に表示されます。</p></div><div class=paragraph><p>以下は簡単な試験の例で、<a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> を使って、 メールサーバに接続しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># telnet example.com 25</span>
Trying 192.0.34.166...
Connected to  example.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
220 example.com ESMTP Sendmail 8.12.10/8.12.10<span class=p>;</span> Tue, 31 Aug 2004 03:41:22 <span class=nt>-0400</span> <span class=o>(</span>EDT<span class=o>)</span>
ehlo example.com
250-example.com Hello example.com <span class=o>[</span>192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 example.com closing connection
Connection closed by foreign host.</code></pre></div></div><div class=paragraph><p>出力に "STARTTLS" 行が表示されれば、 すべてが適切に機能しています。</p></div></div></div><div class=sect2><h3 id=ipsec>13.7. VPN over IPsec<a class=anchor href=#ipsec></a></h3><div class=sect3><h4 id=_ipsec_を理解する>13.7.1. IPsec を理解する<a class=anchor href=#_ipsec_を理解する></a></h4><div class=paragraph><p>この節では、IPsec を設定する過程を説明します。 IPsec を設定するためには、 カスタムカーネルの構築方法をよく知っている必要があります (<a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> をご覧ください)。</p></div><div class=paragraph><p><em>IPsec</em> は、インターネットプロトコル (IP) レイヤのトップにあるプロトコルです。 二つもしくはそれ以上のホスト間で安全に通信することを可能にします。 FreeBSD の IPsec "ネットワークスタック" は、 IPv4 および IPv6 の両方に対応している <a href=http://www.kame.net/>KAME</a> 実装をベースとしています。</p></div><div class=paragraph><p>IPsec は二つのサブプロトコルから構成されます。</p></div><div class=ulist><ul><li><p><em>Encapsulated Security Payload (ESP)</em>: このプロトコルは、Blowfish, 3DES といった対称暗号アルゴリズムを使ってデータを暗号化することで、 サードパーティのインタフェースから IP パケットデータを保護します。</p></li><li><p><em>Authentication Header AH(AH)</em>: このプロトコルは、暗号チェックサムを計算し、IP パケットのヘッドフィールドを安全なハッシュ関数でハッシュ化することで、 IP パケットヘッダをサードパーティのインタフェースやなりすましから守ります。 ハッシュを含む追加のヘッダが追加され、 パケット情報の検証が可能になります。</p></li></ul></div><div class=paragraph><p>ESP および AH は、使用する環境に合わせて、 一緒に使うことも別々に使うこともできます。</p></div><div class=paragraph><p>IPsec は、直接二つのホスト間のトラフィックを暗号化する <em>Transport Mode</em>、もしくは "virtual tunnels" を構築する <em>Tunnel Mode</em> のどちらでも用いることができます。 後者のモードはより一般的には、 <em>Virtual Private Network (VPN)</em> として知られています。 FreeBSD での IPsec サブシステムに関するより詳細な情報については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> を参照してください。</p></div><div class=paragraph><p>カーネルに IPsec のサポートを追加するには、 カスタムカーネルコンフィグレーションファイルに以下のオプションを追加してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC        <span class=c>#IP security</span>
device    crypto</code></pre></div></div><div class=paragraph><p>IPsec のデバッグサポートが必要であれば、 以下のカーネルオプションを追加してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_DEBUG  <span class=c>#debug for IP security</span></code></pre></div></div></div><div class=sect3><h4 id=_家庭と会社間の_vpn>13.7.2. 家庭と会社間の VPN<a class=anchor href=#_家庭と会社間の_vpn></a></h4><div class=paragraph><p>VPN の構成についての標準はありません。 VPN は、数多くの技術と共に実装することが可能です。 その各技術には、それ自身の長所と短所があります。 この節では、以下のシナリオに対して VPN を実装する戦略について説明します。</p></div><div class=ulist><ul><li><p>少なくとも 2 つのサイトがあり、 それぞれのサイトは内部で IP を使っています。</p></li><li><p>2 つのサイトは、FreeBSD で運用されているゲートウェイを通して、 インターネットに接続しています。</p></li><li><p>それぞれのネットワークのゲートウェイは、 少なくとも一つのパブリック IP アドレスを持っています。</p></li><li><p>2 つのネットワークの内部アドレスは、 パブリックでもプライベート IP アドレスでも構いません。 しかしながら、アドレス空間は衝突してはいけません。 たとえば、両方のネットワークが <code>192.168.1.x</code> を使ってはいけません。</p></li></ul></div><div class=sect4><h5 id=_freebsd_上で_ipsec_を設定する>13.7.2.1. FreeBSD 上で IPsec を設定する。<a class=anchor href=#_freebsd_上で_ipsec_を設定する></a></h5><div class=paragraph><p>最初に Ports Collection から <a class=package href=https://cgit.freebsd.org/ports/tree/security/ipsec-tools/>security/ipsec-tools</a> をインストールしてください。 このソフトウェアは、 設定をサポートする数多くのアプリケーションを提供します。</p></div><div class=paragraph><p>次に、パケットをトンネリングし、 両方のネットワークが適切に通信するように、 2 つの <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> 疑似デバイスを作成します。 <code>root</code> 権限で以下のコマンドを実行してください。 ただし、実行する際には、以下のコマンドの中の <em>internal</em> および <em>external</em> を、 2 つのゲートウェイの内部および外部インタフェースの実際の IP アドレスに置き換えてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 internal1 internal2</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 tunnel external1 external2</span></code></pre></div></div><div class=paragraph><p>この例では、会社の LAN の外部 IP アドレスを <code>172.16.5.4</code>、 内部 IP アドレスを <code>10.246.38.1</code> とします。また、家庭 LAN の外部 IP アドレスを <code>192.168.1.12</code>、 内部のプライベート IP アドレスを <code>10.0.0.5</code> とします。</p></div><div class=paragraph><p>この説明で分かりにくい場合は、以下の <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> コマンドの出力例をご覧ください。</p></div><div class="literalblock programlisting"><div class=content><pre>Gateway 1:

gif0: flags=8051 mtu 1280
tunnel inet 172.16.5.4 --&gt; 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
inet 10.246.38.1 --&gt; 10.0.0.5 netmask 0xffffff00

Gateway 2:

gif0: flags=8051 mtu 1280
tunnel inet 192.168.1.12 --&gt; 172.16.5.4
inet 10.0.0.5 --&gt; 10.246.38.1 netmask 0xffffff00
inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4</pre></div></div><div class=paragraph><p>設定が完了したら、両方の内部 IP アドレスは、<a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> で到達できるようになっているはずです。</p></div><div class="literalblock programlisting"><div class=content><pre>priv-net# ping 10.0.0.5
PING 10.0.0.5 (10.0.0.5): 56 data bytes
64 bytes from 10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms
64 bytes from 10.0.0.5: icmp_seq=1 ttl=64 time=19.255 ms
64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms
--- 10.0.0.5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms

corp-net# ping 10.246.38.1
PING 10.246.38.1 (10.246.38.1): 56 data bytes
64 bytes from 10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms
64 bytes from 10.246.38.1: icmp_seq=1 ttl=64 time=42.917 ms
64 bytes from 10.246.38.1: icmp_seq=2 ttl=64 time=127.525 ms
64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms
64 bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms
--- 10.246.38.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms</pre></div></div><div class=paragraph><p>予想通り、プライベートアドレスを使って、 両方のネットワークから ICMP パケットを送受信できます。 次に、どちらのネットワークからもメッセージを送信できるように、 パケットのルーティング情報を両方のゲートウェイに設定する必要があります。 これは以下のコマンドで設定できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># corp-net# route add 10.0.0.0 10.0.0.5 255.255.255.0</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># corp-net# route add net 10.0.0.0: gateway 10.0.0.5</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># priv-net# route add 10.246.38.0 10.246.38.1 255.255.255.0</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># priv-net# route add host 10.246.38.0: gateway 10.246.38.1</span></code></pre></div></div><div class=paragraph><p>これで、ネットワーク内のコンピュータは、 ゲートウェイおよびゲートウェイの奥のコンピュータから到達可能となっています。 もう一度 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> で確認してください。</p></div><div class="literalblock programlisting"><div class=content><pre>corp-net# ping 10.0.0.8
PING 10.0.0.8 (10.0.0.8): 56 data bytes
64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
--- 10.0.0.8 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

priv-net# ping 10.246.38.107
PING 10.246.38.1 (10.246.38.107): 56 data bytes
64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
--- 10.246.38.107 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms</pre></div></div><div class=paragraph><p>トンネリングの設定は以上のように簡単ですが、 リンクを安全にするには、もう少し掘り下げた設定が必要となります。 以下の設定では、事前共有 (PSK) RSA 鍵を使います。 IP アドレスを除けば、両方のゲートウェイの <span class=filename>/usr/local/etc/racoon/racoon.conf</span> は同じで、以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>path    pre_shared_key  &#34;/usr/local/etc/racoon/psk.txt&#34;; #location of pre-shared key file
log     debug;	#log verbosity setting: set to &#39;notify&#39; when testing and debugging is complete

padding	# options are not to be changed
{
        maximum_length  20;
        randomize       off;
        strict_check    off;
        exclusive_tail  off;
}

timer	# timing options. change as needed
{
        counter         5;
        interval        20 sec;
        persend         1;
#       natt_keepalive  15 sec;
        phase1          30 sec;
        phase2          15 sec;
}

listen	# address [port] that racoon will listen on
{
        isakmp          172.16.5.4 [500];
        isakmp_natt     172.16.5.4 [4500];
}

remote  192.168.1.12 [500]
{
        exchange_mode   main,aggressive;
        doi             ipsec_doi;
        situation       identity_only;
        my_identifier   address 172.16.5.4;
        peers_identifier        address 192.168.1.12;
        lifetime        time 8 hour;
        passive         off;
        proposal_check  obey;
#       nat_traversal   off;
        generate_policy off;

                        proposal {
                                encryption_algorithm    blowfish;
                                hash_algorithm          md5;
                                authentication_method   pre_shared_key;
                                lifetime time           30 sec;
                                dh_group                1;
                        }
}

sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)	# address $network/$netmask $type address $network/$netmask $type ( $type being any or esp)
{								# $network must be the two internal networks you are joining.
        pfs_group       1;
        lifetime        time    36000 sec;
        encryption_algorithm    blowfish,3des,des;
        authentication_algorithm        hmac_md5,hmac_sha1;
        compression_algorithm   deflate;
}</pre></div></div><div class=paragraph><p>利用可能なオプションの説明については、 racoon のマニュアルページを参照してください。</p></div><div class=paragraph><p>FreeBSD および racoon がホスト間のネットワークトラフィックを暗号化、 復号化できるようにするには、 Security Policy Database (SPD) の設定が必要です。</p></div><div class=paragraph><p>これは、会社のゲートウェイ上で、 以下のようなシェルスクリプトで設定できます。 このファイルをシステムの初期化中に使われるようにするには、 <span class=filename>/usr/local/etc/racoon/setkey.conf</span> に保存する必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>flush;
spdflush;
# To the home network
spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
spdadd 10.0.0.0/24 10.246.38.0/24 any -P in ipsec esp/tunnel/192.168.1.12-172.16.5.4/use;</pre></div></div><div class=paragraph><p>設定ファイルを適切に置くと、以下のコマンドにより、 両方のゲートウェイ上で racoon を起動できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log</span></code></pre></div></div><div class=paragraph><p>出力は以下のようになるでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
Foreground mode.
2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
n2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=28496098(0x1b2d0e2)
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=47784998(0x2d92426)
2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=124397467(0x76a279b)
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=175852902(0xa7b4d66)</pre></div></div><div class=paragraph><p>トンネリングが適切に行われているかどうかを確認するため、 別のコンソール上で <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> を使い、 以下のようなコマンドでネットワークの通信を確認してください。 ただし、以下の例の <code>em0</code> の部分は、 必要に応じて使用しているネットワークインタフェースに置き換えてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tcpdump -i em0 host 172.16.5.4 and dst 192.168.1.12</span></code></pre></div></div><div class=paragraph><p>以下のようなデータがコンソールに表示されます。 もし、表示されない場合は、設定に何か問題があるので、 表示されるデータを使ってデバッグする必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>01:47:32.021683 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
01:47:33.022442 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
01:47:34.024218 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)</pre></div></div><div class=paragraph><p>これで 2 つのネットワークは、 1 つのネットワークのように利用できます。 多くの場合、 両方のネットワークはファイアウォールにより保護されています。 両方を流れる通信を許可するには、 パケットが両方を行き来できるようにルールを追加する必要があります。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> を使ったファイアウォールの場合は、 ファイアウォールの設定ファイルに、以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 00201 allow log esp from any to any
ipfw add 00202 allow log ah from any to any
ipfw add 00203 allow log ipencap from any to any
ipfw add 00204 allow log udp from any 500 to any</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ルール番号は、 現在のホストの設定によっては変更する必要があるでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pf&amp;sektion=4&amp;format=html">pf(4)</a> または <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> を使用しているシステムでは、 以下のルールで上手くいくでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>pass in quick proto esp from any to any
pass in quick proto ah from any to any
pass in quick proto ipencap from any to any
pass in quick proto udp from any port = 500 to any port = 500
pass in quick on gif0 from any to any
pass out quick proto esp from any to any
pass out quick proto ah from any to any
pass out quick proto ipencap from any to any
pass out quick proto udp from any port = 500 to any port = 500
pass out quick on gif0 from any to any</pre></div></div><div class=paragraph><p>最後に、システムの初期化中に VPN が起動するように、以下の行を <span class=filename>/etc/rc.conf</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>ipsec_enable=&#34;YES&#34;
ipsec_program=&#34;/usr/local/sbin/setkey&#34;
ipsec_file=&#34;/usr/local/etc/racoon/setkey.conf&#34; # allows setting up spd policies on boot
racoon_enable=&#34;yes&#34;</pre></div></div></div></div></div><div class=sect2><h3 id=openssh>13.8. OpenSSH<a class=anchor href=#openssh></a></h3><div class=paragraph><p>OpenSSH はリモートマシンへのセキュアなアクセスに使われるネットワーク接続ツールの集合です。 また、TCP/IP 接続を OpenSSH 接続経由でセキュアにトンネル/フォワードすることもできます。 OpenSSH はすべてのトラフィックを暗号化し、 盗聴や接続の乗っ取り等のネットワークレベルの攻撃を事実上無効化します。</p></div><div class=paragraph><p>OpenSSH は OpenBSD プロジェクトによって維持管理されており、 FreeBSD にはデフォルトでインストールされています。 OpenSSH は、 SSH バージョン 1 と 2 の両方に互換性があります。</p></div><div class=sect3><h4 id=_openssh_を使うことの利点>13.8.1. OpenSSH を使うことの利点<a class=anchor href=#_openssh_を使うことの利点></a></h4><div class=paragraph><p>データがネットワークを平文で流れてしまうと、 ネットワークをクライアントとサーバの間のどこかで盗聴することで、 あなたのユーザ/パスワード情報やセション中を流れるデータを盗むことが可能です。 OpenSSH はこれらを予防する為にさまざまな認証と暗号化の方法を提供します。</p></div></div><div class=sect3><h4 id=_ssh_サーバを有効にする>13.8.2. SSH サーバを有効にする<a class=anchor href=#_ssh_サーバを有効にする></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> が有効になっているかどうかを確認するには、 <span class=filename>/etc/rc.conf</span> の以下の行を確認してください。</p></div><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>この設定により、次のシステムの初期化時に OpenSSH のデーモンプログラムである <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> が起動します。 もしくは <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> を使って、すぐに OpenSSH を起動することもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd start</span></code></pre></div></div></div><div class=sect3><h4 id=_ssh_クライアント>13.8.3. SSH クライアント<a class=anchor href=#_ssh_クライアント></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> を使って、 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> が動いているシステムに接続するには、 ログインをするユーザ名とホストを指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ssh user@example.com</span>
Host key not found from the list of known hosts.
Are you sure you want to <span class=k>continue </span>connecting <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>? <span class=nb>yes
</span>Host <span class=s1>&#39;example.com&#39;</span> added to the list of known hosts.
user@example.com<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>SSH はクライアントが接続した時、 サーバの信頼性の検証のために鍵指紋システム (key fingerprint system) を利用します。 初めての接続の際に、ユーザは <code>yes</code> と入力することを要求されます。 これ以降の login では保存されていた鍵指紋を照合することで検証が行われ、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> クライアントは保存されていた鍵指紋が login しようとした際に送られてきたものと異なっていた場合には警告を表示します。 指紋は <span class=filename>~/.ssh/known_hosts</span> に保存されます。</p></div><div class=paragraph><p>デフォルトでは、<a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> の最近の版では SSH v2 の接続のみを受け付けるように設定されています。 クライアントは可能であればバージョン 2 を用い、 バージョン 1 にフォールバックします。 クライアントは、プロトコル v1 と v2 についてそれぞれ、引数 <code>-1</code> または <code>-2</code> を渡すことで、利用するプロトコルを指定できます。 クライアントにおけるバージョン 1 への互換性は、 古いバージョンへの上位互換のために維持されています。</p></div></div><div class=sect3><h4 id=_secure_copy>13.8.4. Secure copy<a class=anchor href=#_secure_copy></a></h4><div class=paragraph><p>ローカルのファイルをリモートマシンへ、 あるいはリモートマシンのファイルをローカルに安全な方法でコピーするには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> を使用してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  scp user@example.com:/COPYRIGHT COPYRIGHT</span>
user@example.com<span class=s1>&#39;s password: *******
COPYRIGHT            100% |*****************************|  4735
00:00
#</span></code></pre></div></div><div class=paragraph><p>前回の例でこのホストの指紋がすでに保存されていれば この <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> を使う時に検証が行なわれます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> に渡される引数は、<a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a> のものと似ており、コピーするファイル (1 つまたは複数) が 1 つめの引数になり、コピー先が 2 つめの引数になります。 ファイルはネットワーク越しに SSH 接続を通して送られるので、 引数に指定するファイルに <code>user@host:&lt;path_to_remote_file></code> という形式をとるものがあります。</p></div></div><div class=sect3><h4 id=_設定>13.8.5. 設定<a class=anchor href=#_設定></a></h4><div class=paragraph><p>システム全体の設定ファイルは、OpenSSH デーモン、クライアントの両方とも <span class=filename>/etc/ssh</span> にあります。</p></div><div class=paragraph><p><span class=filename>ssh_config</span> はクライアントの動作設定、 <span class=filename>sshd_config</span> はデーモンの動作設定を行ないます。 それぞれのファイル毎にマニュアルページが用意されており、 利用可能な設定オプションについて説明されています。</p></div></div><div class=sect3><h4 id=security-ssh-keygen>13.8.6. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a><a class=anchor href=#security-ssh-keygen></a></h4><div class=paragraph><p>パスワードの代わりに <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> を使ってユーザの認証用の DSA または RSA 暗号鍵を作ることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-keygen <span class=nt>-t</span> dsa
Generating public/private dsa key pair.
Enter file <span class=k>in </span>which to save the key <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>:
Created directory <span class=s1>&#39;/home/user/.ssh&#39;</span><span class=nb>.</span>
Enter passphrase <span class=o>(</span>empty <span class=k>for </span>no passphrase<span class=o>)</span>:
Enter same passphrase again:
Your identification has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.
Your public key has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> は認証に使う為の公開鍵と秘密鍵のペアを作ります。 DSA または RSA 鍵に応じて、 秘密鍵は <span class=filename>~/.ssh/id_dsa</span> または <span class=filename>~/.ssh/id_rsa</span> に保存され、 公開鍵は <span class=filename>~/.ssh/id_dsa.pub</span> または <span class=filename>~/.ssh/id_rsa.pub</span> にそれぞれ保存されます。 公開鍵はセットアップのために、 DSA または RSA のどちらを使う場合にも、 リモートマシンの <span class=filename>~/.ssh/authorized_keys</span> に含まれてなければなりません。</p></div><div class=paragraph><p>この設定により、パスワードに代わり、 SSH 鍵を使ってリモートマシンに接続できるようになります。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>多くのユーザは、鍵が設計上安全と信じ、 パスフレーズなしに鍵を利用しています。 このような使用方法は <em>危険</em> です。 管理者が鍵にパスフレーズが設定されているかを確認する方法は、 手動で鍵を調べる方法です。 秘密鍵のファイルに <code>ENCRYPTED</code> という単語が含まれている場合には、 鍵の所有者は、パスフレーズを使用しています。 弱いパスフレーズが使われている間、 少なくともシステムが危険にさらされているときには、 他のサイトへのアクセスには、 あるレベルでのパスワード類推が必要となります。 さらに、公開鍵ファイルに <code>from</code> を含めることで、 エンドユーザをより安全にできます。 たとえば、 <code>ssh-rsa</code> または <code>rsa-dsa</code> の前に、 <code>from="192.168.10.5</code> を加えることで、 この IP を持つホストからのユーザのみがアクセスできるようになります。</p></div></td></tr></tbody></table></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> でパスフレーズを使っている場合は、 秘密鍵を使うためにユーザは毎回パスフレーズを入力する必要があります。 長いパスフレーズを毎回入力しなくてはならない負担は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> を使うと軽減できます。 これについては、 <a href=#security-ssh-agent>SSH Agent による鍵のキャッシュ</a> で説明されています。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>OpenSSH のバージョンによって、 オプションやファイルに違いが出てくることがあります。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> を参照して、 問題が起こることを避けてください。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=security-ssh-agent>13.8.7. SSH Agent による鍵のキャッシュ<a class=anchor href=#security-ssh-agent></a></h4><div class=paragraph><p>パスフレーズを毎回入力することなしに、 SSH 鍵を利用できるようにメモリに読み込むには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> を使用してください。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> は、 読み込まれた秘密鍵による認証を取り扱います。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> は他のアプリケーションの起動に用いられる必要があります。 基本的なレベルではシェル、 またはウィンドウマネージャを起動します。</p></div><div class=paragraph><p>シェル上で <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> を使うには、 引数としてシェルを起動してください。 次に、<a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> を実行し、 秘密鍵のパスフレーズを入力することにより、 鍵を追加してください。 一度この過程を終えてしまえば、ユーザは、 対応する公開鍵が置かれているホストに <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> でログインできるようになります。 以下はその例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-agent csh
% ssh-add
Enter passphrase <span class=k>for</span> /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>
%</code></pre></div></div><div class=paragraph><p>Xorg 上で <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> を使うには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> への呼び出しが <span class=filename>~/.xinitrc</span> に置かれている必要があります。 これにより、Xorg 上で起動されるすべてのプログラムにおいて、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> サービスが提供されるようになります。 <span class=filename>~/.xinitrc</span> の例は以下となります。</p></div><div class="literalblock programlisting"><div class=content><pre>exec ssh-agent startxfce4</pre></div></div><div class=paragraph><p>これで、Xorg を開始するときにはいつでも <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> が起動され、 このプログラムから XFCE が起動されます。 Xorg を再起動した後は有効になりますので、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> を実行して、 すべての SSH 鍵を読み込ませてください。</p></div></div><div class=sect3><h4 id=security-ssh-tunneling>13.8.8. SSH トンネリング<a class=anchor href=#security-ssh-tunneling></a></h4><div class=paragraph><p>OpenSSH は暗号化されたセッションの中に他のプロトコルをカプセル化するトンネルを作ることができます。</p></div><div class=paragraph><p>以下のコマンドは <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> で <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> 用のトンネルを作成します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5023:localhost:23 user@foo.example.com
%</code></pre></div></div><div class=paragraph><p>この例では、以下のオプションを使っています。</p></div><div class=dlist><dl><dt class=hdlist1><code>-2</code></dt><dd><p>サーバへの接続に <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> バージョン 2 を使うことを指示します。</p></dd><dt class=hdlist1><code>-N</code></dt><dd><p>はトンネルだけでコマンドはないことを示します。 省略されると <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> は通常のセッションを開始します。</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> にバックグラウンド実行を強制します。</p></dd><dt class=hdlist1><code>-L</code></dt><dd><p>ローカルトンネルを <em>localport:remotehost:remoteport</em> という形式で指定します。</p></dd><dt class=hdlist1><code>user@foo.example.com</code></dt><dd><p>指定したリモート SSH サーバへログインに用いるログイン名。</p></dd></dl></div><div class=paragraph><p>SSH のトンネルは <code>localhost</code> の指定されたポートに listen するソケットを作ることで実現されています。 SSH はローカルのホスト/ポートで受けた接続すべてを SSH 接続経由で指定されたリモートホストのポートへ転送します。</p></div><div class=paragraph><p>この例では、<code>localhost</code> のポート <em>5023</em> がリモートマシンの <code>localhost</code> のポート <em>23</em> に転送されるようになっています。 <em>23</em> は <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> で用いられるので、これは SSH トンネルを通る暗号化された man.telnet.1; セッションを作ります。</p></div><div class=paragraph><p>このようにして SMTP や POP3 および FTP といったセキュアではない TCP プロトコルをカプセル化できます。</p></div><div class=exampleblock><div class=title>例 27. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> を用いた SMTP 用の安全なトンネルの作成</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com<span class=s1>&#39;s password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;</span>^]<span class=s1>&#39;.
220 mailserver.example.com ESMTP</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> と別のユーザアカウントを組み合わせて使うことでより透過的な SSH のトンネル環境を作ることができます。 パスワードを入力するところで暗号鍵を使い、 トンネルは別のユーザ権限で実行することが可能です。</p></div></div></div><div class=sect4><h5 id=_実用的な_ssh_トンネルの例>13.8.8.1. 実用的な SSH トンネルの例<a class=anchor href=#_実用的な_ssh_トンネルの例></a></h5><div class=sect5><h6 id=_pop3_サーバへの安全な接続>13.8.8.1.1. POP3 サーバへの安全な接続<a class=anchor href=#_pop3_サーバへの安全な接続></a></h6><div class=paragraph><p>ここでの例は、外部からの接続を受ける SSH サーバがあるとします。 同じネットワークには、POP3 サーバが動いているメールサーバがあるとします。 電子メールを安全なやり方で見るようにするには、 SSH サーバへの SSH 接続を行い、 メールサーバへのトンネルを作成することです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com<span class=s1>&#39;s password: ******</span></code></pre></div></div><div class=paragraph><p>トンネルが作成されて動作したら、 メールクライアントに対し <code>localhost</code> のポート 2110 に POP3 リクエストを送るように指示してください。 そこへの接続は、トンネルを経由して安全に <code>mail.example.com</code> に転送されます。</p></div></div><div class=sect5><h6 id=_厳格なファイアウォールをすり抜ける>13.8.8.1.2. 厳格なファイアウォールをすり抜ける<a class=anchor href=#_厳格なファイアウォールをすり抜ける></a></h6><div class=paragraph><p>内向けおよび外向きの接続両方をフィルタするファイアウォールルールを課すネットワーク管理者もいます。 たとえば、 リモートのマシンからのアクセスに、<a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> および web サーフィンのための 22 番および 80 番ポートにしか接続させてもらえないかもしれません。 この場合 22 または 80 番以外を使う他のサービスへのアクセスを妨げます。</p></div><div class=paragraph><p>それに対する解決策は、 あなたが接続しているネットワークのファイアウォールの外部にあるマシンに対して SSH 接続を行い、 希望するサービスへのトンネルに利用することです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 8888:music.example.com:8000 user@unfirewalled-system.example.org
user@unfirewalled-system.example.org<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>この例では、ストリーミング Ogg Vorbis クライアントを <code>localhost</code> の 8888 番ポートに向けると、 <code>music.example.com</code> の 8000 番ポートに転送され、ファイアウォールをすり抜けられます。</p></div></div></div></div><div class=sect3><h4 id=_allowusers_オプション>13.8.9. <code>AllowUsers</code> オプション<a class=anchor href=#_allowusers_オプション></a></h4><div class=paragraph><p>ログインできるユーザや接続元を <code>AllowUsers</code> を使って制限することは、通常は良い考えです。 たとえば、 <code>root</code> が <code>192.168.1.32</code> からのみログインできるようにするには、 以下の行を <span class=filename>/etc/ssh/sshd_config</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32</pre></div></div><div class=paragraph><p><code>admin</code> がどこからでもログインできるようにするには、 ユーザ名そのものを記述してください。</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers admin</pre></div></div><div class=paragraph><p>複数のユーザは、以下のように同じ行に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32 admin</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>注意すべきことは、 このコンピュータにログインする必要のあるすべてのユーザを指定することです。 設定されていないと、そのユーザはログインできなくなります。</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>/etc/ssh/sshd_config</span> への変更が終わったら、 以下を実行して、設定ファイルを <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> に読み込ませてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd reload</span></code></pre></div></div></div><div class=sect3><h4 id=_もっと詳しく知りたい人へ>13.8.10. もっと詳しく知りたい人へ<a class=anchor href=#_もっと詳しく知りたい人へ></a></h4><div class=paragraph><p><a href=http://www.openssh.com/>OpenSSH</a> ウェブサイト</p></div><div class=paragraph><p>クライアントオプションについて <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh_config&amp;sektion=5&amp;format=html">ssh_config(5)</a></p></div><div class=paragraph><p>サーバオプションについて <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp-server&amp;sektion=8&amp;format=html">sftp-server(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a></p></div></div></div><div class=sect2><h3 id=fs-acl>13.9. ファイルシステムアクセス制御リスト (ACL)<a class=anchor href=#fs-acl></a></h3><div class=paragraph><p>アクセス制御リスト (ACL) は、標準的な UNIX® のパーミッションモデルを、 POSIX®.1e に互換する方法で拡張しています。 これにより、管理者がより洗練されたセキュリティモデルを利用し、 その恩恵を受けられるようになります。</p></div><div class=paragraph><p>FreeBSD の <span class=filename>GENERIC</span> カーネルは、 UFS ファイルシステム用の ACL サポートを提供します。 カスタムカーネルをコンパイルして使用するユーザは、 カスタムカーネルのコンフィグレーションファイルに以下を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>options UFS_ACL</pre></div></div><div class=paragraph><p>もしこのオプションが組み込まれていなければ、ACL に対応したファイルシステムをマウントしようとすると、 警告が表示されます。ACL は、ファイルシステムの拡張属性が有効になっていることに依存しています。 拡張属性は、UFS2 でネイティブ対応されています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>UFS1 に拡張属性を付すように設定するのは、 UFS2 よりも高いレベルの管理オーバヘッドが必要になります。 また、UFS2 における拡張属性のパフォーマンスも大きく上がっています。 そのため、アクセス制御リストを利用する上では UFS2 を使うことが推奨されます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ACL は、マウント時の管理フラグ <code>acls</code> で有効にされます。 これは <span class=filename>/etc/fstab</span> に記述できます。 マウント時のフラグは、<a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> を使って、ファイルシステムヘッダのスーパブロックにある ACL フラグを変更するという方法で、 常に自動で設定されるようになります。一般的には、 下記の理由からスーパブロックフラグを使う方がよいでしょう。</p></div><div class=ulist><ul><li><p>マウント時に指定した ACL フラグは <code>mount -u</code> による再マウントでは変更できません。 完全に <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> した上で、新たに <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> するしかありません。これは、起動後にルートファイルシステムで ACL を有効にできないことを意味します。 また、ファイルシステムを利用し始めた後では、 その配列を変えられないことも意味しています。</p></li><li><p>スーパブロックフラグを設定すると、<span class=filename>fstab</span> に記述されていなかったり、デバイスの順番が変わってしまっても、常に ACL が有効な状態でマウントされます。 こうすることで、ファイルシステムを ACL を有効にしないままマウントしてしまい、ACL が正しくないかたちで強制されるセキュリティの問題を防ぎます。</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>予期せず ACL を有効にしないでマウントしてしまうことを防ぐことが望まれます。 ACL を有効にし、その後無効にしてから、 拡張属性を取り消さないでまた有効にしてしまうと、 大変な状況になってしまいます。 一般的には、一度ファイルシステムで ACL を有効にしたら、無効にすべきではありません。そうしてしまうと、 ファイル保護がシステムのユーザの意図と齟齬をきたす可能性があるばかりか、 ACL を再度有効にすると、 それまでパーミッションが変更されてきたファイルに古い ACL を割り当ててしまい、 予想しない動作につながることも考えられます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ACL を有効にしたファイルシステムは、 パーミッション設定の表示に <code>+</code> (プラス) 記号がつきます。例えば、次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</pre></div></div><div class=paragraph><p>この例では、ディレクトリ <span class=filename>directory1</span>, <span class=filename>directory2</span> および <span class=filename>directory3</span> のすべてで ACL が働いています。 一方 <span class=filename>public_html</span> は対象外です。</p></div><div class=sect3><h4 id=_acl_を利用する>13.9.1. ACL を利用する<a class=anchor href=#_acl_を利用する></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a> は、 ファイルシステムの ACL を表示します。 たとえば、<span class=filename>test</span> の ACL 設定を表示するには、 以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% getfacl <span class=nb>test</span>
	<span class=c>#file:test</span>
	<span class=c>#owner:1001</span>
	<span class=c>#group:1001</span>
	user::rw-
	group::r--
	other::r--</code></pre></div></div><div class=paragraph><p>このファイルの ACL 設定を変更するには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a> を使用してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-k</span> <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>ファイルまたはファイルシステムから、 現在設定されている ACL をすべて取り除くには、<code>-k</code> を使ってください。 しかしながら、より好ましい方法は、 <code>-b</code> を使う方法です。 このオプションを使うと、ACL が動作するのに必要な基本のフィールドは残ります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-m</span> u:trhodes:rwx,group:web:r--,o::--- <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>この例では、<code>-m</code> は、デフォルト ACL エントリを修正するために使われています。 先ほどのコマンドで設定は削除されたため、 定義されたエントリはありません。 このコマンドは、デフォルトオプションに戻し、 指定したオプションを割り当てます。 システムに存在しないユーザまたはグループを追加すると、 <code>Invalid argument</code> エラーが出力されてしまいます。</p></div></div></div><div class=sect2><h3 id=security-portaudit>13.10. サードパーティ製ソフトウェアのセキュリティ問題を監視する<a class=anchor href=#security-portaudit></a></h3><div class=paragraph><p>近年、セキュリティの分野では、 脆弱性の評価方法に関して多くの改善が行わています。 今日ではどのオペレーティングシステムにおいても、 システムへの侵入の脅威は、 サードパーティ製ユーティリティをインストールし、 設定するほどに増加していきます。</p></div><div class=paragraph><p>脆弱性を評価することは、セキュリティにおいて主要な要素です。 FreeBSD は、ベースシステムに対して勧告を発行していますが、 すべてのサードパーティ製ユーティリティに対して勧告を発行することは、 FreeBSD プロジェクトの能力を超えています。 サードパーティ製ユーティリティに関わる脆弱性を軽減し、 管理者に対し、既知のセキュリティ問題について警告する方法が存在します。 FreeBSD には、portaudit と呼ばれる追加のユーティリティが、 この目的のために用意されています。</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portaudit/>ports-mgmt/portaudit</a> port は、FreeBSD セキュリティチームおよび ports 開発者がアップデートし、管理している、 既知のセキュリティ問題に対するデータベースを入手します。</p></div><div class=paragraph><p>Ports Collection から portaudit をインストールするには、以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portaudit &amp;&amp; make install clean</span></code></pre></div></div><div class=paragraph><p>インストールの途中で、 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> の設定ファイルはアップデートされ、 毎日のセキュリティに関するスクリプトの実行中に portaudit が出力するように設定されます。 毎日のセキュリティに関するスクリプトの実行結果のメールが読めることを確認してください。 このメールは、<code>root</code> アカウントに送られます。 他の設定は必要ありません。</p></div><div class=paragraph><p>インストールが終わったら、管理者は以下のコマンドを実行することで、 データベースをアップデートし、インストールされている package の脆弱性を調べることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -Fda</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>データベースは、 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> の実行中に自動的にアップデートされます。 先程のコマンドの実行は任意で、 データベースを手動で直ちにアップデートするときに使われます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ports Collection からインストールされたサードパーティ製ユーティリティを監査するには、 管理者は以下のコマンドを実行する必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -a</span></code></pre></div></div><div class=paragraph><p>portaudit は、インストールされている package の中で、 脆弱性のあるものについて以下のようなメッセージを出力します。</p></div><div class="literalblock programlisting"><div class=content><pre>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</pre></div></div><div class=paragraph><p>表示されている URL をウェブブラウザで開くと、管理者は、 脆弱性についてより多くの情報を得ることができます。 ここでの出力では、影響するバージョンが FreeBSD の port バージョンにより示され、 セキュリティ勧告を含む他のウェブサイトが含まれています。</p></div><div class=paragraph><p>portaudit は強力で、 portmaster port と共に使うときわめて有用なユーティリティです。</p></div></div><div class=sect2><h3 id=security-advisories>13.11. FreeBSD セキュリティ勧告<a class=anchor href=#security-advisories></a></h3><div class=paragraph><p>多くの高品質なオペレーティングシステムのプロジェクト同様、 FreeBSD プロジェクトはセキュリティチームを持っています。
このチームは責任をもって、各 FreeBSD リリースに対する保守終了 (End-of-Life (EoL)) 日を決めたり、サポートされているリリースに対して、EoL までセキュリティアップデートを提供しています。
FreeBSD セキュリティチームおよびサポートされているリリースについての情報は、<a href=https://www.FreeBSD.org/ja/security>FreeBSD セキュリティページ</a> で提供されています。</p></div><div class=paragraph><p>セキュリティチームの仕事の 1 つは FreeBSD オペレーティングシステムのセキュリティ脆弱性に対応することです。
脆弱性が確認されると、セキュリティチームは脆弱性を修正するために必要となる手続きを検証し、修正を含めるようにソースコードをアップデートします。
その後、詳細を "セキュリティ勧告" として発行しています。
セキュリティ勧告は、 <a href=https://www.FreeBSD.org/ja/security/advisories/>FreeBSD ウェブサイト</a> で公開され、 <a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>FreeBSD security notifications メーリングリスト</a>, <a href=https://lists.FreeBSD.org/subscription/freebsd-security>FreeBSD security メーリングリスト</a>, および <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>FreeBSD announcements メーリングリスト</a> メーリングリストに投稿されます。</p></div><div class=paragraph><p>この章では、セキュリティ勧告とはどのようなものか説明します。</p></div><div class=sect3><h4 id=_セキュリティ勧告はどのようなものか>13.11.1. セキュリティ勧告はどのようなものか？<a class=anchor href=#_セキュリティ勧告はどのようなものか></a></h4><div class=paragraph><p>以下は FreeBSD セキュリティ勧告の例です。</p></div><div class="literalblock programlisting"><div class=content><pre>=============================================================================
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

=============================================================================
FreeBSD-SA-14:04.bind                                       Security Advisory
                                                          The FreeBSD Project

Topic:          BIND remote denial of service vulnerability

Category:       contrib
Module:         bind
Announced:      2014-01-14
Credits:        ISC
Affects:        FreeBSD 8.x and FreeBSD 9.x
Corrected:      2014-01-14 19:38:37 UTC (stable/9, 9.2-STABLE)
                2014-01-14 19:42:28 UTC (releng/9.2, 9.2-RELEASE-p3)
                2014-01-14 19:42:28 UTC (releng/9.1, 9.1-RELEASE-p10)
                2014-01-14 19:38:37 UTC (stable/8, 8.4-STABLE)
                2014-01-14 19:42:28 UTC (releng/8.4, 8.4-RELEASE-p7)
                2014-01-14 19:42:28 UTC (releng/8.3, 8.3-RELEASE-p14)
CVE Name:       CVE-2014-0591

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit &lt;URL:http://security.FreeBSD.org/&gt;.

I.   Background

BIND 9 is an implementation of the Domain Name System (DNS) protocols.
The named(8) daemon is an Internet Domain Name Server.

II.  Problem Description

Because of a defect in handling queries for NSEC3-signed zones, BIND can
crash with an &#34;INSIST&#34; failure in name.c when processing queries possessing
certain properties.  This issue only affects authoritative nameservers with
at least one NSEC3-signed zone.  Recursive-only servers are not at risk.

III. Impact

An attacker who can send a specially crafted query could cause named(8)
to crash, resulting in a denial of service.

IV.  Workaround

No workaround is available, but systems not running authoritative DNS service
with at least one NSEC3-signed zone using named(8) are not vulnerable.

V.   Solution

Perform one of the following:

1) Upgrade your vulnerable system to a supported FreeBSD stable or
release / security branch (releng) dated after the correction date.

2) To update your vulnerable system via a source code patch:

The following patches have been verified to apply to the applicable
FreeBSD release branches.

a) Download the relevant patch from the location below, and verify the
detached PGP signature using your PGP utility.

[FreeBSD 8.3, 8.4, 9.1, 9.2-RELEASE and 8.4-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch.asc
# gpg --verify bind-release.patch.asc

[FreeBSD 9.2-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch.asc
# gpg --verify bind-stable-9.patch.asc

b) Execute the following commands as root:

# cd /usr/src
# patch &lt; /path/to/patch

Recompile the operating system using buildworld and installworld as
described in &lt;URL:https://www.FreeBSD.org/handbook/makeworld.html&gt;.

Restart the applicable daemons, or reboot the system.

3) To update your vulnerable system via a binary patch:

Systems running a RELEASE version of FreeBSD on the i386 or amd64
platforms can be updated via the man:freebsd-update[8] utility:

# freebsd-update fetch
# freebsd-update install

VI.  Correction details

The following list contains the correction revision numbers for each
affected branch.

Branch/path                                                      Revision
- -------------------------------------------------------------------------
stable/8/                                                         r260646
releng/8.3/                                                       r260647
releng/8.4/                                                       r260647
stable/9/                                                         r260646
releng/9.1/                                                       r260647
releng/9.2/                                                       r260647
- -------------------------------------------------------------------------

To see which files were modified by a particular revision, run the
following command, replacing NNNNNN with the revision number, on a
machine with Subversion installed:

# svn diff -cNNNNNN --summarize svn://svn.freebsd.org/base

Or visit the following URL, replacing NNNNNN with the revision number:

&lt;URL:https://svnweb.freebsd.org/base?view=revision&amp;revision=NNNNNN&gt;

VII. References

&lt;URL:https://kb.isc.org/article/AA-01078&gt;

&lt;URL:http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0591&gt;

The latest revision of this advisory is available at
&lt;URL:http://security.FreeBSD.org/advisories/FreeBSD-SA-14:04.bind.asc&gt;
-----BEGIN PGP SIGNATURE-----

iQIcBAEBCgAGBQJS1ZTYAAoJEO1n7NZdz2rnOvQP/2/68/s9Cu35PmqNtSZVVxVG
ZSQP5EGWx/lramNf9566iKxOrLRMq/h3XWcC4goVd+gZFrvITJSVOWSa7ntDQ7TO
XcinfRZ/iyiJbs/Rg2wLHc/t5oVSyeouyccqODYFbOwOlk35JjOTMUG1YcX+Zasg
ax8RV+7Zt1QSBkMlOz/myBLXUjlTZ3Xg2FXVsfFQW5/g2CjuHpRSFx1bVNX6ysoG
9DT58EQcYxIS8WfkHRbbXKh9I1nSfZ7/Hky/kTafRdRMrjAgbqFgHkYTYsBZeav5
fYWKGQRJulYfeZQ90yMTvlpF42DjCC3uJYamJnwDIu8OhS1WRBI8fQfr9DRzmRua
OK3BK9hUiScDZOJB6OqeVzUTfe7MAA4/UwrDtTYQ+PqAenv1PK8DZqwXyxA9ThHb
zKO3OwuKOVHJnKvpOcr+eNwo7jbnHlis0oBksj/mrq2P9m2ueF9gzCiq5Ri5Syag
Wssb1HUoMGwqU0roS8+pRpNC8YgsWpsttvUWSZ8u6Vj/FLeHpiV3mYXPVMaKRhVm
067BA2uj4Th1JKtGleox+Em0R7OFbCc/9aWC67wiqI6KRyit9pYiF3npph+7D5Eq
7zPsUdDd+qc+UTiLp3liCRp5w6484wWdhZO6wRtmUgxGjNkxFoNnX8CitzF8AaqO
UWWemqWuz3lAZuORQ9KX
=OQzQ
-----END PGP SIGNATURE-----</pre></div></div><div class=paragraph><p>すべてのセキュリティ勧告は以下のフォーマットに基づいています。</p></div><div class=ulist><ul><li><p>各セキュリティ勧告には、セキュリティオフィサの PGP 鍵により署名されています。セキュリティオフィサの公開鍵は、<a href=./#pgpkeys>OpenPGP 鍵</a> で検証できます。</p></li><li><p>FreeBSD のセキュリティ勧告の名前は常に <code>FreeBSD-SA-</code> で始まり、次に年を表す 2 桁の数字 (<code>14:</code>)、年毎の勧告の番号 (<code>04.</code>) 、そして影響するアプリケーションまたはサブシステムの名前 (<code>bind</code>) が続きます。この例は、2014 年の 4 番目の勧告で BIND に影響する脆弱性に対する勧告を意味しています。</p></li><li><p><code>Topic</code> フィールドでは、脆弱性について明記されています。</p></li><li><p><code>Category</code> では、脆弱性がシステムのどの部分に影響するかを示します。 <code>core</code>, <code>contrib</code> または <code>ports</code> のどれかが示されます。 <code>core</code> カテゴリは、 FreeBSD オペレーティングシステムの <code>core</code> コンポーネントに影響する脆弱性であることを意味します。 <code>contrib</code> カテゴリは、BIND のように FreeBSD に取り込まれているソフトウェアに影響する脆弱性であることを意味します。 <code>ports</code> カテゴリは、Ports Collection からインストールされるソフトウェアに影響する脆弱性であることを示しています。</p></li><li><p><code>Module</code> フィールドは、 影響するコンポーネントについて言及します。 この例では <code>bind</code> モジュールに影響することがわかります。 そのため、この脆弱性は、オペレーティングシステムとともにインストールされたアプリケーションに影響します。</p></li><li><p><code>Announced</code> フィールドには、セキュリティ勧告が発行された日が記載されています。 セキュリティチームによりこの問題が存在することが確認され、パッチが FreeBSD ソースコードリポジトリにコミットされたことを意味します。</p></li><li><p><code>Credits</code> フィールドは、脆弱性を発見し、報告した個人または組織を示します。</p></li><li><p><code>Affects</code> フィールドは、この脆弱性がどの FreeBSD リリースに影響するかを示しています。</p></li><li><p><code>Corrected</code> フィールドには、脆弱性が修正された日、時間、タイムゾーン、およびリリースが示されます。この括弧の中では、修正がマージされた各ブランチ、およびそのブランチで対応するリリースのバージョン番号が示されています。リリースの識別子には、バージョン番号、可能な場合はパッチレベルが含まれています。パッチレベルは <code>p</code> に番号が続いたものです。この番号はパッチのシーケンス番号で、この番号を確認することで、ユーザはどのパッチまでがシステムに適用されているかを追跡できます。</p></li><li><p><code>CVE Name</code> フィールドは、該当する脆弱性が <a href=http://cve.mitre.org>cve.mitre.org</a> セキュリティ脆弱性データベースに存在する場合に、脆弱性の番号一覧を示します。</p></li><li><p><code>Background</code> フィールドは、影響しているモジュールに関する情報を示します。</p></li><li><p><code>Problem Description</code> フィールドは、脆弱性について説明します。 問題のあるコードの情報や、このユーティリティがどのように悪意のある使われ方をされうるかといったことが示されます。</p></li><li><p><code>Impact</code> フィールドは、 この問題がシステムに対して、 どのような形式の影響を与えるかについて示します。</p></li><li><p><code>Workaround</code> フィールドは、何らかの理由により、すぐにシステムにパッチを当てることのできないシステム管理者に対して、回避方法が存在する場合にその方法を提供します。</p></li><li><p><code>Solution</code> フィールドは、影響のあるシステムにパッチを当てる手順を提供します。ここではステップごとにシステムにパッチを当て、安全に動作するように、試験され検証された方法が記載されます。</p></li><li><p><code>Correction Details</code> フィールドは、影響する各 Subversion ブランチに対する修正されたコードが取り込まれたリビジョン番号をを示します。</p></li><li><p><code>References</code> フィールドは、脆弱性に関連する他の情報へのソースを提供します。</p></li></ul></div></div></div><div class=sect2><h3 id=security-accounting>13.12. プロセスアカウンティング<a class=anchor href=#security-accounting></a></h3><div class=paragraph><p>プロセスアカウンティングは、 管理者が使用されているシステムのリソースを記録したり、 リソースのユーザへの割り当て、 システムのモニタリングおよびユーザのコマンドの最低限の記録を提供します。</p></div><div class=paragraph><p>これは実際には、長所と短所があります。 長所の一つは、侵入を入り口の時点で絞ることができます。 短所は、プロセスアカウンティングにより生成されるログの量で、 多くのディスク容量を必要とします。この節では、 管理者を対象にプロセスアカウンティングの基礎を説明します。</p></div><div class=sect3><h4 id=_プロセスアカウンティングを有効にする>13.12.1. プロセスアカウンティングを有効にする<a class=anchor href=#_プロセスアカウンティングを有効にする></a></h4><div class=paragraph><p>プロセスアカウンティングを使用する前に、 以下のコマンドを使って、 プロセスアカウンティングを有効にしておく必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/account/acct</span>
<span class=c># chmod 600 /var/account/acct</span>
<span class=c># accton /var/account/acct</span>
<span class=c># echo &#39;accounting_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span></code></pre></div></div><div class=paragraph><p>一度有効に設定すると、アカウンティングは、 CPU の統計、 実行されたコマンドの情報の追跡を開始します。 すべてのアカウンティングログは、 人が読めるような形式ではなく、 <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> を使って見ることができます。 オプションを設定せずに実行すると、 <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> はユーザコールの数、全経過時間 (分)、 全 CPU、ユーザの時間 (分)、および I/O 操作の平均数などを出力します。</p></div><div class=paragraph><p>実行されたコマンドに関する情報を見るには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a> を使ってください。 このコマンドは、 ユーザが特定の <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> で実行したコマンドを出力します。 たとえば、以下のコマンドは <code>ttyp1</code> ターミナル上で <code>trhodes</code> が実行した <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> の使用について、記録されているすべて示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lastcomm ls trhodes ttyp1</span></code></pre></div></div><div class=paragraph><p>他にも有用なオプションが多くあり、 <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> で説明されています。</p></div></div></div><div class=sect2><h3 id=security-resourcelimits>13.13. リソースの制限<a class=anchor href=#security-resourcelimits></a></h3><div class=paragraph><p>FreeBSD は、個々のユーザが利用できるシステムのリソース容量を制限する方法をいくつも用意しています。
ディスククォータはユーザが使用できるディスク容量を制限します。
クォータについては <a href=./#quotas>「ディスククォータ」</a> で説明されています。</p></div><div class=paragraph><p>その他のリソースの制限とは、ユーザが消費できる CPU、メモリなどのリソースを制限する手段のことです。
フラットファイルまたはコマンドによりリソースの制限に関わるデータベースを管理できます。
伝統的な方法では、ログインクラスを <span class=filename>/etc/login.conf</span> を編集することにより定義します。
この方法は、現在でも使われていますが、変更を行うには、このファイルの編集、リソースデータベースの再構築、 <span class=filename>/etc/master.passwd</span> への必要な変更、さらに、パスワードデータベースの再構築といった、複数回に渡るプロセスが必要です。
この複数回に渡るプロセスは、 多くのユーザについて設定する必要がある場合には、 大変な時間の浪費につながる可能性があります。</p></div><div class=paragraph><p><code>rctl</code> を用いると、よりきめ細かにリソースの制限を管理する方法を提供できます。
このコマンドは、ユーザだけではなく、プロセスおよび jails に対してもリソースを制限できます。</p></div><div class=paragraph><p>この節では、リソースを管理する方法について伝統的な方法と高度な方法の両方について説明します。</p></div><div class=sect3><h4 id=users-limiting>13.13.1. ログインクラスの設定<a class=anchor href=#users-limiting></a></h4><div class=paragraph><p>伝統的な方法では、ログインクラスおよびログインクラスに適用するリソースの制限は <span class=filename>/etc/login.conf</span> で定義します。
各ユーザアカウントにはログインクラスが割り当てられています (デフォルトでは <code>default</code> です)。
それぞれのログインクラスには関連するログインケーパビリティの集合が割り当てられています。
ログインケーパビリティとは、 <code>名称=値</code> の組のことで、<em>名称</em> は周知の識別子、<em>値</em> は、<em>名称</em> に応じて処理される任意の文字列です。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/login.conf</span> を編集する時には <span class=filename>/etc/login.conf.db</span> を次のコマンドを実行してアップデートする必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>リソースの制限は、 2 つの点で標準的なログインケーパビリティと異なっています。
第一に、どの制限についても、 <em>ソフト</em> リミットと _ハード _リミットがあります。
ソフトリミットは、ユーザやアプリケーションが調整できますが、 ハードリミットを超えることはできません。
ユーザはハードリミットを下げることはできますが、 上げることはスーパユーザのみができます。
第二に、ほとんどのリソースの制限は特定のユーザに対してプロセス毎に適用されるものです。</p></div><div class=paragraph><p><a href=#resource-limits>ログインクラスのリソースの制限</a> が最もよく使われるリソースの制限です。
利用可能なすべてのリソースの制限およびのログインケーパビリティの詳細については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> に書かれています。</p></div><table id=resource-limits class="tableblock frame-none grid-all stretch"><caption class=title>表 11. ログインクラスのリソースの制限</caption><col style=width:20%><col style=width:80%><thead><tr><th class="tableblock halign-left valign-top">リソースの制限</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>coredumpsize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>プログラムが生成する core ファイルのサイズにかかる制限は、 <code>filesize</code> やディスククォータなどの、 ほかのディスク使用に関する制限に従属します。
この制限は、ディスク領域の消費を制御するあまり厳しくない手段としてよく使われています。
ユーザは core ファイルを自分で生成するわけではなく、削除しないことも多いので、 これを設定すれば大きなプログラムが異常終了してもディスクの空きがなくならずに済みます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cputime</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>そのユーザのプロセスが消費できる CPU 時間の上限です。
これを超えたプロセスは、カーネルにより終了されます。
これは、消費される CPU <em>時間</em> についての制限であって、<code>top</code> や <code>ps</code> のフィールドで表示される CPU の割合に関するものではありません。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>filesize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザが所有できるファイルの大きさの上限です。
ディスククォータ (crossref:disks[quotas,「ディスククォータ」) と違い、この制限はユーザのファイルをすべてまとめた集合にではなく、個々のファイルにかかります。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>maxproc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザが実行できるフォアグラウンドとバックグラウンドプロセス数の上限です。
この上限は、<code>kern.maxproc</code> で指定されたシステムの制限を超えることはできません。
この値をあまり小さな値に設定すると、大きなプログラムをコンパイルする場合のように、複数のプロセスが実行されるようなタスクにおいて、ユーザの生産性が悪化する可能性があります。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>memorylocked</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1 つのプロセスが <a href="https://man.freebsd.org/cgi/man.cgi?query=mlock&amp;sektion=2&amp;format=html">mlock(2)</a> によりメインメモリにロックされることを要求できるメモリの最大容量です。
<a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> のようなシステムで重要なプログラムは、 メインメモリへロックして、システムがスワップする際に、 ディスクのスラッシングを引き起こさないようにします。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>memoryuse</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>どの時点かを問わず、あるプロセスが消費できる最大のメモリ容量です。
これは、メインメモリとスワップの使用量を合わせたものです。
メモリ消費を抑えるための包括的な制限ではありませんが、手始めにはよいでしょう。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>openfiles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>あるプロセスが開いておける最大のファイル数です。
FreeBSD では、ファイルは、ソケットや IPC チャンネルを表わすのにも使われているので、あまり低い値に設定しないよう注意してください。
これに対応するシステム全体の制限は <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> <code>kern.maxfiles</code> で定義されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>sbsize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>あるユーザが消費できるネットワークメモリの上限の量です。
これは、ネットワーク通信を制限するのに使えます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>stacksize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>プロセスのスタックサイズの上限です。
あるプログラムが使用しうるメモリの量を制限するには、これだけでは十分ではないので、他の制限と組み合わせて使わなければなりません。</p></td></tr></tbody></table><div class=paragraph><p>リソースの制限を設定するにあたり、ほかにもいくつか覚えておかなければならないことがあります。</p></div><div class=ulist><ul><li><p>システム起動時に <span class=filename>/etc/rc</span> から起動されたプロセスは、<code>daemon</code> ログインクラスに割り当てられます。</p></li><li><p>システムに付属している <span class=filename>/etc/login.conf</span> はほとんどの制限について妥当な値になっていますが、すべてのシステムにおいてふさわしいというわけではありません。
制限をあまり緩くするとシステムを悪用しやすくしてしまいますし、厳しくしすぎると生産性を悪化させてしまいます。</p></li><li><p>Xorg は多くのリソースを使うだけでなく、より多くのプログラムを並行して使うことをユーザに促します。</p></li><li><p>多くの制限は個々のプロセスにかかるもので、一人のユーザにまとめてかかるものではありません。
例えば、<code>openfiles</code> を 50 に設定することは、ユーザが動かすそれぞれのプロセスが最大 50 個のファイルを開けるということです。
あるユーザが開けるファイルの総数は、 <code>openfiles</code> の値に <code>maxproc</code> をかけたものになります。
同じことがメモリ消費量にもあてはまります。</p></li></ul></div><div class=paragraph><p>リソースの制限と、ログインクラス、 ログインケーパビリティ一般についての詳しい情報は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=cap.mkdb&amp;sektion=1&amp;format=html">cap.mkdb(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getrlimit&amp;sektion=2&amp;format=html">getrlimit(2)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> をご覧ください。</p></div></div><div class=sect3><h4 id=_リソースの制限を有効にして設定する>13.13.2. リソースの制限を有効にして設定する<a class=anchor href=#_リソースの制限を有効にして設定する></a></h4><div class=paragraph><p><code>kern.racct.enable</code> をゼロ以外の値に設定してください。
カスタムカーネルには以下のような特別な設定が必要となります。</p></div><div class="literalblock programlisting"><div class=content><pre>options         RACCT
options         RCTL</pre></div></div><div class=paragraph><p>システムを再起動して新しいカーネルで立ち上げると、<code>rctl</code> を用いてシステムにルールを設定できるようになります。</p></div><div class=paragraph><p>ルールの構文は、 subject, subject-id, resource および action を使って管理されます。
以下のルールの例を参照してください。</p></div><div class="literalblock programlisting"><div class=content><pre>user:trhodes:maxproc:deny=10/user</pre></div></div><div class=paragraph><p>この例では、subject は <code>user</code>、subject-id は <code>trhodes</code>、resource の <code>maxproc</code> はプロセスの最大数、そして action は <code>deny</code> と設定されており、 新しいプロセスの生成がブロックされます。
これは、ユーザ <code>trhodes</code> のプロセスは <code>10</code> 個に制限され、それ以上のプロセスは作成できないことを意味しています。
他には、コンソールにログを出力したり、 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> に対し通知したり、プロセスに sigterm を送ったりといった action も利用できます。</p></div><div class=paragraph><p>ルールを追加する際には、注意すべき点がいくつかあります。
上の例では、プロセスの数が <code>10</code> に制限されているため、ログインして <code>screen</code> セッションを実行してしまうと、ユーザによる他のタスクの実行はブロックされてしまうでしょう。
リソースの制限が適応されると、エラーが出力されます。
この例では以下のような出力が行われます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>test</span>
    /usr/bin/man: Cannot fork: Resource temporarily unavailable
<span class=nb>eval</span>: Cannot fork: Resource temporarily unavailable</code></pre></div></div><div class=paragraph><p>他の例としては、jail がメモリの制限を超えることを防ぐことができます。
このルールは以下のように書くことができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -a jail:httpd:memoryuse:deny=2G/jail</span></code></pre></div></div><div class=paragraph><p>ルールを <span class=filename>/etc/rctl.conf</span> に追加すると、再起動してもルールは持続します。
フォーマットは、ルールから最初のコマンドの部分を除いたものとなります。
たとえば、上のルールを追加するには、以下のように追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre># Block jail from using more than 2G memory:
jail:httpd:memoryuse:deny=2G/jail</pre></div></div><div class=paragraph><p>ルールを削除するには、<code>rctl</code> に対し、リストから削除するように指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -r user:trhodes:maxproc:deny=10/user</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> には、ルールをすべて削除する方法が記載されています。
しかしながら、特定のユーザのルールをすべて削除するには、以下のようなコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -r user:trhodes</span></code></pre></div></div><div class=paragraph><p><code>subjects</code> をコントロールするリソースは他にも多く用意されています。
これらについて知るには、<a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> をご覧ください。</p></div></div></div></div></div><div class=sect1><h2 id=disks>Chapter 14. ストレージ<a class=anchor href=#disks></a></h2><div class=sectionbody><div class=sect2><h3 id=disks-synopsis>14.1. この章では<a class=anchor href=#disks-synopsis></a></h3><div class=paragraph><p>この章では、FreeBSD におけるディスクの使用方法を説明します。 これにはメモリディスク、ネットワークに接続されたディスク、 および標準的な SCSI/IDE 記憶デバイスが含まれます。</p></div><div class=paragraph><p>この章では、以下の分野について説明します。</p></div><div class=ulist><ul><li><p>物理ディスク上のデータ構成 について記述するために FreeBSD が使用する用語 (パーティションおよびスライス)</p></li><li><p>システムにハードディスクを追加する方法</p></li><li><p>メモリディスクのような仮想ファイルシステムを設定する方法</p></li><li><p>使用できるディスク容量を制限するためにクォータを設定する方法</p></li><li><p>攻撃者から保護するためにディスクを暗号化する方法</p></li><li><p>FreeBSD で CD や DVD を作成する方法</p></li><li><p>バックアップのためのさまざまな記憶メディアオプション</p></li><li><p>FreeBSD で利用できるバックアッププログラムの使用方法</p></li><li><p>フロッピーディスクにバックアップする方法</p></li><li><p>スナップショットとは何か、そしてそれを効果的に使用する方法</p></li></ul></div></div><div class=sect2><h3 id=disk-naming>14.2. デバイス名<a class=anchor href=#disk-naming></a></h3><div class=paragraph><p>以下は、FreeBSD で対応している物理記憶デバイスとそれに対応するデバイス名のリストです。</p></div><table id=disk-naming-physical-table class="tableblock frame-all grid-all stretch"><caption class=title>表 12. 物理ディスクへの名前付け</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">ドライブの種類</th><th class="tableblock halign-left valign-top">ドライブのデバイス名</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>IDE ハードドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ad</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>IDE CD-ROM ドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>acd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI ハードドライブおよび USB 大容量記憶デバイス</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>da</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI CD-ROM ドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>その他の非標準的 CD-ROM ドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ミツミ CD-ROM は <code>mcd</code>, Sony CD-ROM は <code>scd</code>, 松下/パナソニック CD-ROM は <code>matcd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>フロッピードライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI テープドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>sa</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>IDE テープドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ast</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>フラッシュドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DiskOnChip® フラッシュデバイスは <code>fla</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RAID ドライブ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Adaptec® AdvancedRAID は <code>aacd</code>, Mylex® は <code>mlxd</code> および <code>mlyd</code>, AMI MegaRAID® は <code>amrd</code>, Compaq Smart RAID は <code>idad</code>, 3ware® RAID は<code>twed</code></p></td></tr></tbody></table></div><div class=sect2><h3 id=disks-adding>14.3. ディスクの追加<a class=anchor href=#disks-adding></a></h3><div class=paragraph><p>現在一つしかドライブがない計算機に新しく SCSI ディスクを追加したいとしましょう。まずコンピュータの電源を切り、 コンピュータやコントローラ、 ドライブの製造元の説明書に従ってドライブを取り付けます。 このあたりの手順は非常に多岐にわたるため、 詳細はこの文書の範囲外です。</p></div><div class=paragraph><p><code>root</code> ユーザでログインします。 ドライブの取り付け後は <span class=filename>/var/run/dmesg.boot</span> を調べて新しいディスクが見つかっていることを確認しておきます。 この例では、新しく付けたドライブは <span class=filename>da1</span> で、 我々はそれを <span class=filename>/1</span> にマウントしたいとしましょう (もし IDE ドライブを付けようとしているのなら、デバイス名は 4.0 以前のシステムでは <span class=filename>wd1</span>, ほとんどの 4.x システムでは <span class=filename>ad1</span> になるでしょう)。</p></div><div class=paragraph><p>FreeBSD は IBM-PC 互換のコンピュータで動くため、 PC BIOS のパーティションを考慮に入れる必要があります。 これは従来の BSD パーティションとは異なります。PC ディスクは 4 つまでの BIOS パーティションエントリを持つことができます。 もしそのディスクを本当に FreeBSD 専用にしたい場合には <em>専用</em> モードで用いることもできます。 そうでない場合には、FreeBSD は PC BIOS パーティションのどれか一つの中に入れることになります。 FreeBSD では、従来の BSD パーティションと混乱しないように PC BIOS パーティションのことを<em>スライス</em>と呼びます。 また、別の OS がインストールされていたコンピュータで使われていたが FreeBSD 専用にするディスク上でもスライスを用いることができます。 これは、他の OS の <code>fdisk</code> ユーティリティを混乱させないためです。</p></div><div class=paragraph><p>スライスの場合、ドライブは <span class=filename>/dev/da1s1e</span> として加えられるでしょう。これは、SCSI ディスクでユニット番号は 1 (二つめの SCSI ディスク), スライスは 1 (PC BIOS のパーティションが 1) で BSD パーティション <span class=filename>e</span>, と読みます。 専用ディスクの場合だと単純に <span class=filename>/dev/da1e</span> として加えられるでしょう。</p></div><div class=sect3><h4 id=_sysinstall8_の利用>14.3.1. <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> の利用<a class=anchor href=#_sysinstall8_の利用></a></h4><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>sysinstall の操作</p><div class=paragraph><p><code>sysinstall</code> の使い易いメニューを利用して、 新しいディスクのパーティション分けやラベル付けを行なうことができます。 <code>root</code> ユーザでログインするか <code>su</code> コマンドを用いるかして root 権限を取得します。 <code>/stand/sysinstall</code> を実行して <code>Configure</code> メニューに入ります。<code>FreeBSD Configuration Menu</code> の中でスクロールダウンして <code>Fdisk</code> の項目を選びます。</p></div></li><li><p>fdisk パーティションエディタ</p><div class=paragraph><p>fdisk では、ディスク全体を FreeBSD で使うために <code>A</code> を入力します。 "remain cooperative with any future possible operating systems" と聞かれたら <code>YES</code> と答えます。 <code>W</code> で変更をディスクに書き込みます。ここで <code>q</code> と入力して FDISK エディタを抜けます。 次にマスタブートレコードについて聞かれます。 ここでは既に動いているシステムにディスクを追加しようとしているので <code>None</code> を選びます。</p></div></li><li><p>ディスクラベルエディタ</p><div class=paragraph><p>次に sysinstall を終了し、 もう一度起動する必要があります。同じ手順を踏んで今度は <code>Label</code> オプションを選択し、 <code>Disk Label Editor</code> に入ります。 ここでは従来の BSD パーティションを作成します。 一つのディスクは <code>a</code> から <code>h</code> までのラベルがついた最大 8 つのパーティションを持つことができます。 いくつかのパーティションラベルは特別な用途に用いられます。 <code>a</code> パーティションはルートパーティション (<span class=filename>/</span>) です。したがって、システムディスク (つまり起動ディスク) のみに <code>a</code> パーティションがあるべきです。<code>b</code> パーティションはスワップパーティションに用いられ、 複数のディスクにスワップパーティションを作ることができます。 <code>c</code> は専用モードにおけるディスク全体、 もしくはスライスモードにおけるスライス全体を指します。 他のパーティションは汎用的に用いられます。</p></div><div class=paragraph><p>sysinstall のラベルエディタ は、ルートパーティションでもスワップパーティションでもないパーティションには、<code>e</code> パーティションを採用しようとします。ラベルエディタでファイルシステムを作成するには <code>C</code> を入力してください。 FS (ファイルシステム) かスワップかを聞かれたら <code>FS</code> を選びマウントポイント (たとえば <span class=filename>/mnt</span>) を入力します。 インストール後のモードでディスクを追加する場合、 sysinstall は <span class=filename>/etc/fstab</span> にエントリを追加しないため、 ここで指定するマウントポイントはそれほど重要ではありません。</p></div><div class=paragraph><p>さて、ディスクに新しいラベルを書き込み、 そこにファイルシステムを作る準備が整いました。早速 <code>W</code> を叩いて実行しましょう。 sysinstall からの、 新しいパーティションをマウントできない、 というエラーは無視してください。Label Editor から抜け、 sysinstall を終了します。</p></div></li><li><p>終了</p><div class=paragraph><p>最後に <span class=filename>/etc/fstab</span> を編集し、 新しいディスクのエントリを追加します。</p></div></li></ol></div></div></div></div><div class=sect3><h4 id=_コマンドラインユーティリティの利用>14.3.2. コマンドラインユーティリティの利用<a class=anchor href=#_コマンドラインユーティリティの利用></a></h4><div class=sect4><h5 id=_スライスの利用>14.3.2.1. スライスの利用<a class=anchor href=#_スライスの利用></a></h5><div class=paragraph><p>このセットアップ方法では、 すでにコンピュータに他のオペレーティングシステムがインストールされていても 正しく協調動作することが可能で、他のオペレーティングシステムの <code>fdisk</code> ユーティリティを混乱させることもありません。 新しいディスクにインストールする場合は、 この方法を用いることが推奨されています。 後述する <code>専用モード</code> は、 そうしなければならない理由がある時にのみ、 利用するようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/da1 bs=1k count=1</span>
<span class=c># fdisk -BI da1 # 新しいディスクの初期化</span>
<span class=c># disklabel -B -w -r da1s1 auto # ディスクにラベルを付ける</span>
<span class=c># disklabel -e da1s1 # 作成したディスクラベルを編集し、パーティションを追加する</span>
<span class=c># mkdir -p /1</span>
<span class=c># newfs /dev/da1s1e # 作成したすべてのパーティションに対してこれを繰り返す</span>
<span class=c># mount /dev/da1s1e /1 # パーティションをマウントする</span>
<span class=c># vi /etc/fstab # /etc/fstab に適切なエントリを追加する</span></code></pre></div></div><div class=paragraph><p>IDE ディスクを使う場合は <span class=filename>da</span> の部分を <span class=filename>ad</span> とします。4.X より前のシステムでは、 (訳注: <span class=filename>ad</span> ではなく) <span class=filename>wd</span> としてください。</p></div></div><div class=sect4><h5 id=_専用モード>14.3.2.2. 専用モード<a class=anchor href=#_専用モード></a></h5><div class=paragraph><p>新しいドライブを他の OS と共有しない場合には <code>専用</code> モードを用いることもできます。 このモードはマイクロソフトの OS を混乱させることを憶えておいてください (しかし、それらによって壊されることはありません)。 一方、IBM の OS/2® はどんなパーティションでも見つけたら理解できなくても "専有" します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/da1 bs=1k count=1</span>
<span class=c># disklabel -Brw da1 auto</span>
<span class=c># disklabel -e da1 # `e&#39; パーティションの作成</span>
<span class=c># newfs -d0 /dev/da1e</span>
<span class=c># mkdir -p /1</span>
<span class=c># vi /etc/fstab # /dev/da1e エントリの追加</span>
<span class=c># mount /1</span></code></pre></div></div><div class=paragraph><p>もう一つの方法は次の通り。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/da1 count=2</span>
<span class=c># disklabel /dev/da1 | disklabel -BrR da1 /dev/stdin</span>
<span class=c># newfs /dev/da1e</span>
<span class=c># mkdir -p /1</span>
<span class=c># vi /etc/fstab # /dev/da1e エントリの追加</span>
<span class=c># mount /1</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.1-RELEASE から、従来の <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> プログラムは <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> ユーティリティに置き換えられました。<a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> では、 使用されていない数多くのオプションやパラメタが削除されました。 たとえば <code>-r</code> オプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> では取り除かれました。詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> のマニュアルページを参照してください。</p></div></td></tr></tbody></table></div></div></div></div><div class=sect2><h3 id=raid>14.4. RAID<a class=anchor href=#raid></a></h3><div class=sect3><h4 id=raid-soft>14.4.1. ソフトウェア RAID<a class=anchor href=#raid-soft></a></h4><div class=sect4><h5 id=ccd>14.4.1.1. Concatenated Disk Driver (CCD) の設定<a class=anchor href=#ccd></a></h5><div class=paragraph><p>大容量記録に関する解決法を選択する際にもっとも重視すべき要素は、 速度、信頼性、そして費用です。 三つを同時にバランスよく実現することは稀です。 通常、速くて信頼性のある大容量記録装置は高価であり、 費用を抑えようとすると速度または信頼性のどちらかが犠牲になります。</p></div><div class=paragraph><p>ここで例にあげるシステムの設計においては、 費用が最も重要な要素として、次に速度、最後に信頼性が選択されています。 このシステムでのデータ転送速度は結局のところネットワークによって制限されます。 信頼性は大変重要です。ただし、以下で説明する CCD ドライブは、 データ自体はすでに CD-R に完全にバックアップしてあるもの (したがって交換は簡単にできます) の、オンラインデータの役割をさせています。</p></div><div class=paragraph><p>あなた自身の要求事項を決定することは、 大容量記録に関する解決法を選択することの最初の段階です。 もしあなたの要求事項が費用より速度または信頼性を優先するなら、 解決法はこのシステムとは違うものになるでしょう。</p></div><div class=sect5><h6 id=ccd-installhw>14.4.1.1.1. ハードウェアのインストール<a class=anchor href=#ccd-installhw></a></h6><div class=paragraph><p>IDE システムディスクに加えて、Western Digital 製の 30GB, 5400RPM の IDE ディスク三台を使って、 以下に説明されているような約 90GB のオンラインストレージとなる CCD ディスクを作成しました。各 IDE ディスクがそれぞれの IDE コントローラとケーブルをもっていることが理想的ですが、 費用を最低限にするために、 IDE コントローラを追加していません。その代わり、それぞれの IDE コントローラがマスタデバイスを一つ、 スレーブデバイスを一つ持つように、 ディスクはジャンパを使って設定されています。</p></div><div class=paragraph><p>再起動の際に、システム BIOS が接続されたディスクを自動的に検出するように設定されました。 より重要なことは、FreeBSD が再起動の際にそれらを検出することです。</p></div><div class="literalblock programlisting"><div class=content><pre>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD がディスクをすべて検出しないときは、 ジャンパを正しく設定してあるか確認してください。多くの IDE ドライブは "ケーブルセレクト" ジャンパを持っています。 これはマスタ/スレーブの関係を設定するジャンパでは <em>ありません</em>。ドライブの文書を参照して、 正しいジャンパ設定を見つけてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>次に、ファイルシステムの一部分として、 それらをどのように接続するのかを考慮します。<a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> の両方を検討すべきでしょう。この設定では、<a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> を選択しました。</p></div></div><div class=sect5><h6 id=ccd-setup>14.4.1.1.2. CCD の設定<a class=anchor href=#ccd-setup></a></h6><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> ドライバは、いくつかの同じディスクを使って、 一つの論理的ファイルシステムに連結することができます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> を使用するためには、カーネルが <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> に対応している必要があります。 次の行をカーネルコンフィギュレーションファイルに追加して、 カーネルを再構築し、再インストールしてください。</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device   ccd     4</pre></div></div><div class=paragraph><p>5.X システムでは、 上記の代わりに次の行を追加しなければなりません。</p></div><div class="literalblock programlisting"><div class=content><pre>device   ccd</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.X では <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> デバイスの数を指定する必要はありません。<a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> デバイスドライバは自己複製するようになりました - 新しいデバイスインスタンスは、 必要に応じてその都度自動的に作成されます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>FreeBSD 3.0 以降では、 カーネルモジュールを読み込んで <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> に対応することもできます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> を設定するために、まず <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> を使用してディスクにラベルを書き込まなくてはなりません。</p></div><div class="literalblock programlisting"><div class=content><pre>disklabel -r -w ad1 auto
disklabel -r -w ad2 auto
disklabel -r -w ad3 auto</pre></div></div><div class=paragraph><p>このコマンドはディスク全体を示す <span class=filename>ad1c</span>, <span class=filename>ad2c</span> および <span class=filename>ad3c</span> に対するディスクラベルを作成します。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.1-RELEASE から、従来の <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> プログラムは <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> ユーティリティに置き換えられました。<a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> では、 使用されていない数多くのオプションやパラメタが削除されました。 たとえば <code>-r</code> オプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> では取り除かれました。詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> のマニュアルページを参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>次に、ディスクラベルのタイプを変更します。 <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> を使用してディスクラベルを編集してください。</p></div><div class="literalblock programlisting"><div class=content><pre>disklabel -e ad1
disklabel -e ad2
disklabel -e ad3</pre></div></div><div class=paragraph><p>このコマンドは <code>EDITOR</code> 環境変数に設定されているエディタ (一般的には <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>) でそれぞれのディスクの現在のディスクラベルを開きます。</p></div><div class=paragraph><p>変更されていないディスクラベルは以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> で使用する <code>e</code> パーティションを作成します。通常では <code>c</code> パーティションの行をコピーすれば良いでしょう。しかし、 <code>fstype</code> は <code>4.2BSD</code> でなければ <em>なりません</em>。 ディスクラベルは以下のようになるでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</pre></div></div></div><div class=sect5><h6 id=ccd-buildingfs>14.4.1.1.3. ファイルシステムの構築<a class=anchor href=#ccd-buildingfs></a></h6><div class=paragraph><p><span class=filename>ccd0c</span> デバイスノードはまだ存在していないかも知れません。 そのときは、次のコマンドを実行して作成してください。</p></div><div class="literalblock programlisting"><div class=content><pre>cd /dev
sh MAKEDEV ccd0</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.0 では <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> が <span class=filename>/dev</span> 以下のデバイスノードを自動的に管理するので、 <code>MAKEDEV</code>を使用する必要はありません。</p></div></td></tr></tbody></table></div><div class=paragraph><p>すべてのディスクにラベルを書き込んだので、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> を構築してください。 これを行うためには、以下のようなオプションで <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a> を使います。</p></div><div class="literalblock programlisting"><div class=content><pre>ccdconfig ccd0 32 0 /dev/ad1e /dev/ad2e /dev/ad3e</pre></div></div><div class=paragraph><p>各オプションの使用法と意味は以下の通りです。
* 一番目の引数は設定するデバイスです。この例の場合は <span class=filename>/dev/ccd0c</span> です。 <span class=filename>/dev/</span> の部分はオプションです。
* ファイルシステムに対するインタリーブです。インタリーブは、 ディスクブロック内のストライプサイズを定義します。 ディスクブロックは通常 512 バイトです。したがって 32 インタリーブは 16,384 バイトとなります。
* これは <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a> に対するフラグです。 ドライブミラーリングを有効にしたい場合、 ここにフラグを指定します。 この設定では <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> に対するミラーリングは提供しませんので、 0 (ゼロ) を指定しています。
* この <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a> に対する最後の引数は、 アレイ内に置くデバイスです。 それぞれのデバイスに対する完全なパス名を使用します。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a> を実行すると <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> が設定されます。 これでファイルシステムをインストールすることが可能です。 オプションについて <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> を参照するか、 次のように実行してください。</p></div><div class="literalblock programlisting"><div class=content><pre>newfs /dev/ccd0c</pre></div></div></div><div class=sect5><h6 id=ccd-auto>14.4.1.1.4. 自動的に設定する<a class=anchor href=#ccd-auto></a></h6><div class=paragraph><p>一般的に、再起動するたびに <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> をマウントしたいと思うでしょう。これを行うために、 まず設定をしなければなりません。次のコマンドを用いて、 現在の設定を <span class=filename>/etc/ccd.conf</span> に書き出します。</p></div><div class="literalblock programlisting"><div class=content><pre>ccdconfig -g &gt; /etc/ccd.conf</pre></div></div><div class=paragraph><p><span class=filename>/etc/ccd.conf</span> が存在すると、 再起動の際に <code>/etc/rc</code> スクリプトが <code>ccdconfig -C</code> を実行します。これにより、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> は自動的に設定された後、マウントされます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>シングルユーザモードで起動している場合には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> を <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> する前に、 アレイを設定するために次のコマンドを実行する必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>ccdconfig -C</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>自動的に <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> をマウントするには、 <span class=filename>/etc/fstab</span> に <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> のエントリ追加します。このように設定すると起動時にマウントされます。</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ccd0c              /media       ufs     rw      2       2</pre></div></div></div></div><div class=sect4><h5 id=vinum>14.4.1.2. Vinum ボリュームマネージャ<a class=anchor href=#vinum></a></h5><div class=paragraph><p>Vinum ボリュームマネージャは、 仮想ディスクドライブを実装したブロックデバイスドライバです。 Vinum は、ディスクハードウェアをブロックデバイスインタフェースから 分離し、データを配置します。 その結果、ディスク記憶装置を従来のスライスで扱うのと比較して、 柔軟性、性能および信頼性が向上しています。 <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a> は RAID-0, RAID-1 および RAID-5 モデル、 そしてそれぞれの組合せを実装しています。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a> の詳細については Vinum ボリュームマネジャ を参照してください。</p></div></div></div><div class=sect3><h4 id=raid-hard>14.4.2. ハードウェア RAID<a class=anchor href=#raid-hard></a></h4><div class=paragraph><p>FreeBSD は、さまざまなハードウェア RAID コントローラにも対応しています。これらのデバイスはアレイを制御するための 特別なソフトウェアを FreeBSD で必要することなく、 RAID サブシステムを制御します。</p></div><div class=paragraph><p>カード上の BIOS を使用して、 カードはそれ自身でディスク操作のほとんどを制御します。以下は Promise IDE RAID コントローラを使用した設定の簡単な説明です。 このカードがインストールされ、システムが起動したときには、 情報の入力を促すプロンプトを表示します。 指示にしたがってカードの設定画面に進んでください。 接続されたドライブを組み合わせるように設定することができます。 設定後、ディスクは FreeBSD に対して単一のドライブのように見えます。 他の RAID レベルは適宜設定できます。</p></div></div><div class=sect3><h4 id=_ata_raid1_アレイの再構築>14.4.3. ATA RAID1 アレイの再構築<a class=anchor href=#_ata_raid1_アレイの再構築></a></h4><div class=paragraph><p>FreeBSD はアレイ内の障害ディスクを動作中に交換できます。 ただし、再起動前にそれを検知していることが必要です。</p></div><div class=paragraph><p><span class=filename>/var/log/messages</span> または <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> の出力に次のような行があるでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11) status=59 error=40
ar0: WARNING - mirror lost</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=atacontrol&amp;sektion=8&amp;format=html">atacontrol(8)</a> を使用して詳細を調べてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol list</span>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

<span class=c># atacontrol status ar0</span>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</code></pre></div></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>ディスクを安全に取り外すために、 まずアレイから切り離します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol detach 3</span></code></pre></div></div></li><li><p>ディスクを取り外します。</p></li><li><p>スペアのディスクを取り付けます。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol attach 3</span>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</code></pre></div></div></li><li><p>アレイを再構築します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol rebuild ar0</span></code></pre></div></div></li><li><p>再構築コマンドは完了するまで他の操作を受け付けません。しかし、 もう一つ別のターミナルを (<span class=keyseq><kbd>Alt</kbd>+<kbd>Fn</kbd></span> を押して) 開き、 次のコマンドを実行すると進行状態を確認することができます。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | tail -10</span>
<span class=o>[</span>output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

<span class=c># atacontrol status ar0</span>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</code></pre></div></div></li><li><p>操作が完了するまでお待ちください。</p></li></ol></div></div></div></div></div><div class=sect2><h3 id=creating-cds>14.5. 光メディア (CD & DVD) の作成と使用<a class=anchor href=#creating-cds></a></h3><div class=sect3><h4 id=_はじめに>14.5.1. はじめに<a class=anchor href=#_はじめに></a></h4><div class=paragraph><p>CD は他の一般的なディスクと異なる様々な特徴を持っています。 そもそもユーザが書き込むことができません。 また遅延なしで連続的に読み出せるように、 トラック間をヘッドが移動しないですむようにデザインされています。 さらにこのサイズのメディアの中ではシステムをまたぐデータの 移動が比較的簡単でもあります。</p></div><div class=paragraph><p>CD はトラックの概念を持っていますが、 これはデータを連続的に読み出すためのものであってディスクの物理特性ではありません。 FreeBSD で CD を作成するには、まず CD のトラックとなるデータファイルを用意し、 そのトラックを CD に書き込みます。</p></div><div class=paragraph><p>ISO 9660 ファイルシステムはこの様な差異を扱うべく設計されました。 その結果、ファイルシステムは一般的に使用するのに差しつかえない程度に 制限されて標準化されています。幸いなことに、ISO 9660 ファイルシステムには拡張機構が提供されています。適切に書かれた CD は、 拡張機構に対応したシステムでは拡張を利用して、そうでないシステムでは 拡張機構を使用しない範囲で動作するようになっています。</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/mkisofs/>sysutils/mkisofs</a> プログラムは ISO 9660 ファイルシステムを含むデータファイルを作成するのに使われます。 これには様々な拡張をサポートするオプションがあり、 以下で説明します。 このソフトウェアは、ports の <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/mkisofs/>sysutils/mkisofs</a> からインストールすることができます。</p></div><div class=paragraph><p>CD に書き込むためのツールは、お使いの CD ライタが ATAPI 接続か否かにも依存します。ATAPI CD ライタなら、ベースシステムの一部である <code>burncd</code> プログラムを使います。SCSI や USB の CD ライタなら、ports の <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrecord/>sysutils/cdrecord</a> をインストールして <code>cdrecord</code> プログラムを使うべきでしょう。</p></div><div class=paragraph><p><code>burncd</code> が対応しているドライブは限定されています。 ドライブが対応されているかどうかを確認するには、 <a href=http://www.freebsd.dk/ata/>CD-R/RW supported drives</a> にある一覧を見てください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.X または FreeBSD 4.8-RELEASE 以降のバージョンを使用している場合、 <a href=#atapicam>ATAPI/CAM モジュール</a> を使用すると ATAPI ハードウェア上で SCSI ドライブ用の <code>cdrecord</code> および他のツールを使用できるようになります。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mkisofs>14.5.2. mkisofs<a class=anchor href=#mkisofs></a></h4><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/mkisofs/>sysutils/mkisofs</a> は UNIX® ファイルシステムの名前空間におけるディレクトリツリーのイメージとして ISO 9660 ファイルシステムを作成します。 最も簡単な使い方は以下の通りです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -o imagefile.iso /path/to/tree</span></code></pre></div></div><div class=paragraph><p>このコマンドは <em>/path/to/tree</em> 以下のディレクトリツリーのコピーである ISO 9660 ファイルシステムを含んだ <em>imagefile.iso</em> ファイルを作成します。この過程において、ファイル名は標準的な ISO 9660 ファイルシステムの制限に適合するようなファイル名に対応づけられ、 ISO ファイルシステムでファイル名を文字化できないファイルは除外されます。</p></div><div class=paragraph><p>この制限を回避するために利用できるオプションはいくつもあります。 特に <code>-R</code> オプションは UNIX® システムで標準的な Rock Ridge 拡張を有効にします。<code>-J</code> オプションは Microsoft のシステムで標準的な Joliet 拡張を有効にし、 <code>-hfs</code> オプションは Mac OS® で使用されている HFS ファイルシステムを作成するために使われます。</p></div><div class=paragraph><p>FreeBSD でしか使わないのであれば、<code>-U</code> オプションを使用するとあらゆるファイル名制限を無効にできます。 さらに <code>-R</code> オプションとともに使うことで FreeBSD と同一のファイルシステムイメージを作成できますが、 これは ISO 9660 標準の多くを無視しています。</p></div><div class=paragraph><p>一般的に使われる最後のオプションは <code>-b</code> オプションです。 これは "El Torito" ブータブル CD を作成するのに使う起動イメージのありかを指定します。 このオプションは引数として起動イメージへのパスを、 CD に書き込まれるディレクトリツリーの頂点からの相対位置で取ります。 したがって <span class=filename>/tmp/myboot</span> がブート可能な FreeBSD システムで <span class=filename>/tmp/myboot/boot/cdboot</span> にブートイメージがあるならば、以下のようにすることで ISO 9660 ファイルシステムのイメージを <span class=filename>/tmp/bootable.iso</span> に作成することができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -U -R -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</span></code></pre></div></div><div class=paragraph><p>この後、カーネルで <span class=filename>vn</span> (FreeBSD 4.X) または <span class=filename>md</span> (FreeBSD 5.X) が設定されていれば、 ファイルシステムを以下のようにしてマウントすることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vnconfig -e vn0c /tmp/bootable.iso</span>
<span class=c># mount -t cd9660 /dev/vn0c /mnt</span></code></pre></div></div><div class=paragraph><p>FreeBSD 4.X および FreeBSD 5.X に対しては以下の通りです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p><span class=filename>/mnt</span> と <span class=filename>/tmp/myboot</span> が同一かどうか確認してください。</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/mkisofs/>sysutils/mkisofs</a> には挙動を細かく制御するために他にもたくさんのオプションがあります。 特に、ISO 9660 レイアウトの変更や Joliet および HFS ディスク作成などの 詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> のマニュアルページをご覧ください。</p></div></div><div class=sect3><h4 id=burncd>14.5.3. burncd<a class=anchor href=#burncd></a></h4><div class=paragraph><p>あなたが持っているのが ATAPI CD ライタなら、CD に ISO イメージを書き込むために <code>burncd</code> コマンドが使えます。 <code>burncd</code> はベースシステムの一部で <span class=filename>/usr/sbin/burncd</span> としてインストールされています。 使い方はとても単純でオプションも少ししかありません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f cddevice data imagefile.iso fixate</span></code></pre></div></div><div class=paragraph><p>以上のコマンドは <em>imagefile.iso</em> のコピーを <em>cddevice</em> に書き込みます。 デフォルトのデバイスは <span class=filename>/dev/acd0c</span> です。 書き込み速度や操作完了後に CD を自動的に取り出す方法、 オーディオデータの書き込みなどのオプションについては <a href="https://man.freebsd.org/cgi/man.cgi?query=burncd&amp;sektion=8&amp;format=html">burncd(8)</a> を見てください。</p></div></div><div class=sect3><h4 id=cdrecord>14.5.4. cdrecord<a class=anchor href=#cdrecord></a></h4><div class=paragraph><p>あなたが持っている CD ライタが ATAPI ではなければ、 CD を書き込むのに <code>cdrecord</code> を使う必要があります。 <code>cdrecord</code> はベースシステムの一部ではなく、 <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> の port または 適切な package を利用してインストールしなければなりません。 なお、ベースシステムを変更するとバイナリに矛盾が発生し、 "コースター" を作ってしまうおそれがあります。 したがって、システムをアップグレードする度にこの port も作り直すか、 あるいは FreeBSD の安定版を追いかけているのならば、 新しいバージョンが利用できるようになった時に ports をアップグレードする必要があります。</p></div><div class=paragraph><p><code>cdrecord</code> にはたくさんのオプションがありますが、 基本的な使い方は <code>burncd</code> よりもさらに簡単です。 ISO 9660 イメージを書き込むには以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord dev=device imagefile.iso</span></code></pre></div></div><div class=paragraph><p><code>cdrecord</code> のトリッキーな部分は、使用する <code>dev</code> を見つけるところにあります。 適切な設定を見つけるためには <code>cdrecord</code> の <code>-scanbus</code> フラグを使います。 たとえば、以下のような結果が出力されるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord -scanbus</span>
Cdrecord 1.9 <span class=o>(</span>i386-unknown-freebsd4.2<span class=o>)</span> Copyright <span class=o>(</span>C<span class=o>)</span> 1995-2000 Jörg Schilling
Using libscg version <span class=s1>&#39;schily-0.1&#39;</span>
scsibus0:
        0,0,0     0<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39236LW       &#39;</span> <span class=s1>&#39;0004&#39;</span> Disk
        0,1,0     1<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39173W        &#39;</span> <span class=s1>&#39;5958&#39;</span> Disk
        0,2,0     2<span class=o>)</span> <span class=k>*</span>
        0,3,0     3<span class=o>)</span> <span class=s1>&#39;iomega  &#39;</span> <span class=s1>&#39;jaz 1GB         &#39;</span> <span class=s1>&#39;J.86&#39;</span> Removable Disk
        0,4,0     4<span class=o>)</span> <span class=s1>&#39;NEC     &#39;</span> <span class=s1>&#39;CD-ROM DRIVE:466&#39;</span> <span class=s1>&#39;1.26&#39;</span> Removable CD-ROM
        0,5,0     5<span class=o>)</span> <span class=k>*</span>
        0,6,0     6<span class=o>)</span> <span class=k>*</span>
        0,7,0     7<span class=o>)</span> <span class=k>*</span>
scsibus1:
        1,0,0   100<span class=o>)</span> <span class=k>*</span>
        1,1,0   101<span class=o>)</span> <span class=k>*</span>
        1,2,0   102<span class=o>)</span> <span class=k>*</span>
        1,3,0   103<span class=o>)</span> <span class=k>*</span>
        1,4,0   104<span class=o>)</span> <span class=k>*</span>
        1,5,0   105<span class=o>)</span> <span class=s1>&#39;YAMAHA  &#39;</span> <span class=s1>&#39;CRW4260         &#39;</span> <span class=s1>&#39;1.0q&#39;</span> Removable CD-ROM
        1,6,0   106<span class=o>)</span> <span class=s1>&#39;ARTEC   &#39;</span> <span class=s1>&#39;AM12S           &#39;</span> <span class=s1>&#39;1.06&#39;</span> Scanner
        1,7,0   107<span class=o>)</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>リストにあるデバイスに対する適切な <code>dev</code> の値がここに示されています。あなたの CD ライタをこのリストから見つけ、 カンマで区切られた 3 つの数値を <code>dev</code> の値として使ってください。この例では CRW デバイスは 1,5,0 なので、適切な入力は <code>dev=1,5,0</code> となります。 値を明示するもっと簡単な方法もあります。詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a> を見てください。そこにはオーディオトラックを書き込む方法や、 書き込み速度その他を操作する方法も書かれています。</p></div></div><div class=sect3><h4 id=duplicating-audiocds>14.5.5. オーディオ CD の複製<a class=anchor href=#duplicating-audiocds></a></h4><div class=paragraph><p>CD からオーディオデータを連続したファイルに展開し、ブランク CD にこれらのファイルを書き込むことで、オーディオ CD を複製することができます。 この手順は ATAPI および SCSI ドライブの間で少し異なります。</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: SCSI ドライブ</strong></p></div><div class="olist arabic"><ol class=arabic><li><p><code>cdda2wav</code> を使用してオーディオを展開します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdda2wav <span class=nt>-v255</span> <span class=nt>-D2</span>,0 <span class=nt>-B</span> <span class=nt>-Owav</span></code></pre></div></div></li><li><p><code>cdrecord</code> を使用して <span class=filename>.wav</span> ファイルに書き出します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdrecord <span class=nt>-v</span> <span class=nv>dev</span><span class=o>=</span>2,0 <span class=nt>-dao</span> <span class=nt>-useinfo</span>  <span class=k>*</span>.wav</code></pre></div></div><div class=paragraph><p><a href=#cdrecord>cdrecord</a> に説明されているように <em>2.0</em> が適切に指定されていることを確かめてください。</p></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: ATAPI ドライブ</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>ATAPI CD ドライバでは、それぞれのトラックを <span class=filename>/dev/acddtnn</span> のように利用できます。 ここで <em>d</em> はドライブ番号であり、 <em>nn</em> は二桁十進のトラック番号です。 一桁の場合 0 を前に付加する必要があります。 したがって、一番目のディスクの一番目のトラックは <span class=filename>/dev/acd0t01</span>、二番目のトラックは <span class=filename>/dev/acd0t02</span>、三番目のトラックは <span class=filename>/dev/acd0t03</span> などとなります。</p><div class=paragraph><p>適切なデバイスファイルが <span class=filename>/dev</span> に存在することを確かめてください。 存在しなければ、たとえば次のようにして作成します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># sh MAKEDEV acd0t99</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.0 では <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> が <span class=filename>/dev</span> にエントリを自動的に作成、 管理するので、<code>MAKEDEV</code> を使用する必要はありません。</p></div></td></tr></tbody></table></div></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> を使用して各トラックを展開します。 ファイルを展開する際、ブロックサイズを指定しなければなりません。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/acd0t01 of=track1.cdr bs=2352</span>
<span class=c># dd if=/dev/acd0t02 of=track2.cdr bs=2352</span>
...</code></pre></div></div></li><li><p><code>burncd</code> を使用して、 展開したファイルをディスクに書き込みます。 これらがオーディオファイルであること、 そして書き込みが終了したときに <code>burncd</code> がディスクを固定 (fixate) することを明示しなければなりません。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f /dev/acd0c audio track1.cdr track2.cdr ... fixate</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=imaging-cd>14.5.6. データ CD の複製<a class=anchor href=#imaging-cd></a></h4><div class=paragraph><p>データ CD を、<a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/mkisofs/>sysutils/mkisofs</a> を用いて作成されたイメージファイルと機能的に等価なイメージファイルにコピーできます。 これを使用して、すべてのデータ CD を複製することができます。 ここでの例は CDROM デバイスが <span class=filename>acd0</span> であるとしています。あなたの CDROM デバイスに読み替えてください。 CDROM の場合には、パーティション全体またはディスク全体 を指定するために <code>c</code> をデバイス名の後に追加しなければなりません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/acd0c of=file.iso bs=2048</span></code></pre></div></div><div class=paragraph><p>これでディスクイメージを取り出すことができました。 すでに説明した方法を用いて CD に書き込むことができます。</p></div></div><div class=sect3><h4 id=mounting-cd>14.5.7. データ CD の使用<a class=anchor href=#mounting-cd></a></h4><div class=paragraph><p>さて、標準的なデータ CDROM を作成したので、 おそらく次はそれをマウントしてデータを読み出したいと思うでしょう。 デフォルトでは <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> は、ファイルシステムタイプを <code>ufs</code> としています。 次のように実行しようとすると、</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/cd0c /mnt</span></code></pre></div></div><div class=paragraph><p><code>Incorrect super block</code> というエラーが返されてマウントできないでしょう。 CDROM は <code>UFS</code> ファイルシステムではないために、 このような手順でマウントしようすると失敗します。 ファイルシステムのタイプが <code>ISO9660</code> であると <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> に教えさえすれば、すべてはうまく動作します。 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> に <code>-t cd9660</code> オプションを指定することでこれを行います。 たとえば <span class=filename>/dev/cd0c</span> の CDROM デバイスを <span class=filename>/mnt</span> にマウントしたい場合は、 以下のように実行します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0c /mnt</span></code></pre></div></div><div class=paragraph><p>使用している CDROM インタフェースによっては、 デバイス名 (この例では <span class=filename>/dev/cd0c</span>) が異なるかもしれないことに注意してください。 また、<code>-t cd9660</code> オプションは、単に <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a> を実行します。 この例を以下のように短縮することもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_cd9660 /dev/cd0c /mnt</span></code></pre></div></div><div class=paragraph><p>一般的にこの方法では、すべてのメーカの データ CDROM を使用することができます。しかしながら、特定の ISO 9660 拡張が施されたディスクでは奇妙な動作をするかもしれません。 たとえば Joliet ディスクは、 すべてのファイル名を 2 バイトの Unicode 文字で格納します。 FreeBSD カーネルは (まだ) Unicode を理解できないので、 非英語文字はクエスチョンマークで表示されます (FreeBSD 4.3 以降を使用している場合、CD9660 ドライバには適切な Unicode 変換表を読み込むための急ごしらえのフックが含まれています。 いくつかの共通のエンコードに対するモジュールは <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cd9660_unicode/>sysutils/cd9660_unicode</a> port から利用可能です)。</p></div><div class=paragraph><p>CDROM をマウントしようとする時に、 <code>Device not configured</code> と表示されるかもしれません。これは、ディスクがトレーにないと CDROM ドライブが判断しているか、 ドライブがバス上に認識できないことを通常意味します。 ディスクが挿入されたことを CDROM ドライブが認識するには数秒かかりますので、 辛抱強く待ってください。</p></div><div class=paragraph><p>バスのリセットに返答するためのタイムアウトが短いために、時々 SCSI CDROM は認識に失敗するかもしれません。SCSI CDROM を持っている場合は、 次のオプションをカーネルコンフィギュレーションファイルに追加して、 <a href=./#kernelconfig-building>カーネルを再構築してください</a>。</p></div><div class="literalblock programlisting"><div class=content><pre>options SCSI_DELAY=15000</pre></div></div><div class=paragraph><p>これより、SCSI バスを起動時に 15 秒間停止させて、 CDROM ドライブがバスリセットに応答する機会を与えます。</p></div></div><div class=sect3><h4 id=rawdata-cd>14.5.8. Raw データ CD の書き込み<a class=anchor href=#rawdata-cd></a></h4><div class=paragraph><p>ISO 9660 ファイルシステムを作成すること無く、 ファイルを直接 CD に書き込むこともできます。 この方法をバックアップ目的に使用している人もいます。 これは、標準 CD を書き込むよりもさらに速く実行することができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f /dev/acd1c -s 12 data archive.tar.gz fixate</span></code></pre></div></div><div class=paragraph><p>このように CD に書き込まれたデータを取得するには、 raw デバイスノードからデータを読み込まなくてはなりません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /dev/acd1c</span></code></pre></div></div><div class=paragraph><p>このディスクを通常の CDROM としてマウントすることはできません。 このような CDROM は FreeBSD を除いて、 他のすべてのオペレーティングシステムでは読み込むことはできません。 CD をマウントしたいか、 その他のオペレーティングシステムとデータを共有したい場合は、 上記に説明したように <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/mkisofs/>sysutils/mkisofs</a> を使用しなくてはなりません。</p></div></div><div class=sect3><h4 id=atapicam>14.5.9. ATAPI/CAM ドライバの使用<a class=anchor href=#atapicam></a></h4><div class=paragraph><p>このドライバは、ATAPI デバイス (CD-ROM, CD-RW, DVD ドライブなど) へ SCSI サブシステムを通じてアクセスすることを可能にします。 これにより、<a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a> または <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a> のようなアプリケーションが使用できるようになります。</p></div><div class=paragraph><p>このドライバを使用するためには、 カーネルコンフィギュレーションファイルに次の行を追加する必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>device atapicam
device scbus
device cd
device pass</pre></div></div><div class=paragraph><p>次の行もカーネルコンフィギュレーションファイルに必要です。</p></div><div class="literalblock programlisting"><div class=content><pre>device ata
device atapicd</pre></div></div><div class=paragraph><p>両方がすでに存在しなければなりません。</p></div><div class=paragraph><p>それから再構築し、新しいカーネルをインストールし、 コンピュータを再起動します。 起動プロセス中にディスクライタは以下のように表示されるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</code></pre></div></div><div class=paragraph><p>ドライブは <span class=filename>/dev/cd0</span> デバイスを通じてアクセスすることが可能となります。 たとえば、次のようにして CD-ROM を <span class=filename>/mnt</span> にマウントします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0c /mnt</span></code></pre></div></div><div class=paragraph><p><code>root</code> 権限で次のコマンドを実行して、 ライタの SCSI アドレスを得ることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 <span class=o>(</span>pass0,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>したがって、<code>1,0,0</code> が <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a> およびその他の SCSI アプリケーションで使用する SCSI アドレスです。</p></div><div class=paragraph><p>ATAPI/CAM および SCSI システムの詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=atapicam&amp;sektion=4&amp;format=html">atapicam(4)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=cam&amp;sektion=4&amp;format=html">cam(4)</a> マニュアルページを参照してください。</p></div></div></div><div class=sect2><h3 id=floppies>14.6. フロッピーディスクの作成と使用<a class=anchor href=#floppies></a></h3><div class=paragraph><p>フロッピーディスクにデータを格納することはしばしば役にたちます。 たとえば、ある人が他のリムーバブル記録メディアを何も持っていないときや、 小さなデータを他のコンピュータに移動させる必要があるときです。</p></div><div class=paragraph><p>この節では、FreeBSD におけるフロッピーディスクの使用方法を説明します。 主に 3.5 インチの DOS フロッピーのフォーマットと操作方法を扱いますが、 他のフロッピーディスクの形式についても概念は似ています。</p></div><div class=sect3><h4 id=_フロッピーのフォーマット>14.6.1. フロッピーのフォーマット<a class=anchor href=#_フロッピーのフォーマット></a></h4><div class=sect4><h5 id=_デバイス>14.6.1.1. デバイス<a class=anchor href=#_デバイス></a></h5><div class=paragraph><p>他のデバイスと同様に、フロッピーディスクは <span class=filename>/dev</span> にあるエントリを通じてアクセスされます。4.X およびそれ以前のリリースにおいて raw フロッピーディスクにアクセスするには <span class=filename>/dev/fdN</span> または <span class=filename>/dev/fdNX</span> を使用します。<em>N</em> はドライブ番号を表し、 大抵は 0 です。<em>X</em> は文字を表します。</p></div><div class=paragraph><p>5.0 およびそれ以降のリリースでは、単に <span class=filename>/dev/fdN</span> を使用します。</p></div><div class=sect5><h6 id=_4_x_およびそれ以前のリリースでのディスクサイズ>14.6.1.1.1. 4.X およびそれ以前のリリースでのディスクサイズ<a class=anchor href=#_4_x_およびそれ以前のリリースでのディスクサイズ></a></h6><div class=paragraph><p><span class=filename>/dev/fdN.size</span> というデバイスもあります。 <em>size</em> はフロッピーディスクのサイズをキロバイトで示したものです。 これらのエントリは低レベルフォーマットの際に、 ディスクサイズを決定するのに使用されます。 1440kB は以下の例で使用されるサイズです。</p></div><div class=paragraph><p>時々 <span class=filename>/dev</span> 下のエントリは (再) 作成されなければなりません。次のコマンドでこれを行います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev &amp;&amp; ./MAKEDEV &#34;fd*&#34;</span></code></pre></div></div></div><div class=sect5><h6 id=_5_x_およびそれ以降のリリースでのディスクサイズ>14.6.1.1.2. 5.X およびそれ以降のリリースでのディスクサイズ<a class=anchor href=#_5_x_およびそれ以降のリリースでのディスクサイズ></a></h6><div class=paragraph><p>FreeBSD 5.0 では <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> が <span class=filename>/dev</span> 内のエントリを自動的に管理するので、 <code>MAKEDEV</code>を使用する必要はありません。</p></div><div class=paragraph><p>所望のディスクサイズは <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a> に <code>-f</code> フラグを通して渡されます。対応しているサイズは <a href="https://man.freebsd.org/cgi/man.cgi?query=fdcontrol&amp;sektion=8&amp;format=html">fdcontrol(8)</a> のマニュアルページに掲載されていますが、最良に動作するのは 1440kB だと助言しておきます。</p></div></div></div><div class=sect4><h5 id=_フォーマット>14.6.1.2. フォーマット<a class=anchor href=#_フォーマット></a></h5><div class=paragraph><p>フロッピーディスクは、 使用前に低レベルフォーマットをする必要があります。 通常、ベンダは低レベルフォーマット済みのディスクを出荷していますが、 フォーマットはメディアの品質を確認するよい方法です。 より大きな (または小さな) ディスクサイズにすることも可能ですが、 ほとんどのフロッピーディスクのサイズは 1440kB で動作するように設計されています。</p></div><div class=paragraph><p>フロッピーディスクを低レベルフォーマットするには <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a> を使用する必要があります。 このユーティリティは引数としてデバイス名を指定します。</p></div><div class=paragraph><p>ディスクが良好かあるいは不良であるかを決定するのに役立つので、 エラーメッセージをすべてメモに取っておいてください。</p></div><div class=sect5><h6 id=_4_x_以前のリリースでのフォーマット>14.6.1.2.1. 4.X 以前のリリースでのフォーマット<a class=anchor href=#_4_x_以前のリリースでのフォーマット></a></h6><div class=paragraph><p><span class=filename>/dev/fdN.size</span> デバイスを使ってフロッピーをフォーマットします。 新しい 3.5 インチフロッピーディスクをドライブに挿入し、 以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat /dev/fd0.1440</span></code></pre></div></div></div><div class=sect5><h6 id=_5_0_以降のリリースでのフォーマット>14.6.1.2.2. 5.0 以降のリリースでのフォーマット<a class=anchor href=#_5_0_以降のリリースでのフォーマット></a></h6><div class=paragraph><p><span class=filename>/dev/fdN</span> デバイスを使用してフロッピーをフォーマットします。 新しい 3.5 インチフロッピーディスクをドライブに挿入し、 以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat -f 1440 /dev/fd0</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_ディスクラベル>14.6.2. ディスクラベル<a class=anchor href=#_ディスクラベル></a></h4><div class=paragraph><p>ディスクを低レベルフォーマットしたら、 次にディスクラベルを作成する必要があります。 ディスクラベルは後で破棄されますが、 システムがディスクのサイズとジオメトリを決定するのに必要になります。</p></div><div class=paragraph><p>新しいディスクラベルはディスク全体を引き継ぎ、 フロッピーのジオメトリに関する適切な情報のすべてが含まれます。 ディスクラベルに対するジオメトリの値は <span class=filename>/etc/disktab</span> に掲載されています。</p></div><div class=paragraph><p>次のように <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> を実行できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/disklabel -B -r -w /dev/fd0 fd1440</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.1-RELEASE から、従来の <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> プログラムは <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> ユーティリティに置き換えられました。<a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> では、 使用されていないオプションおよびパラメタの数多くが削除されました。 たとえば <code>-r</code> オプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> では取り除かれました。詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> マニュアルページを参照してください。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_ファイルシステム>14.6.3. ファイルシステム<a class=anchor href=#_ファイルシステム></a></h4><div class=paragraph><p>これでフロッピーを高レベルフォーマットする準備ができました。これは FreeBSD がディスクを読み書きする新しいファイルシステムを作成します。 新しいファイルシステムを作成するとディスクラベルは破棄されます。 したがって、ディスクを再フォーマットするときには、 ディスクラベルを再作成しなくてはなりません。</p></div><div class=paragraph><p>フロッピーのファイルシステムには UFS または FAT を使用できます。 フロッピーに対しては FAT が一般的によりよい選択です。</p></div><div class=paragraph><p>フロッピー上に新しいファイルシステムを作成するには次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/newfs_msdos /dev/fd0</span></code></pre></div></div><div class=paragraph><p>これでディスクが使用できるようになりました。</p></div></div><div class=sect3><h4 id=_フロッピーの使用>14.6.4. フロッピーの使用<a class=anchor href=#_フロッピーの使用></a></h4><div class=paragraph><p>フロッピーを使用するために、<a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdos&amp;sektion=8&amp;format=html">mount_msdos(8)</a> (4.X 以前のリリース) または <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> (5.0 以後のリリース) を用いてマウントします。 Ports Collection から <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> を使用することもできます。</p></div></div></div><div class=sect2><h3 id=backups-tapebackups>14.7. データテープの作成と使用<a class=anchor href=#backups-tapebackups></a></h3><div class=paragraph><p>一般的なテープメディアには 4mm, 8mm, QIC, ミニカートリッジ、 DLT があります。</p></div><div class=sect3><h4 id=backups-tapebackups-4mm>14.7.1. 4mm (DDS: Digital Data Storage)<a class=anchor href=#backups-tapebackups-4mm></a></h4><div class=paragraph><p>4mm テープはワークステーションのバックアップメディアとして QIC に取って代わりつつあります。この傾向は QIC ドライブの主要なメーカであった Archive を Conner が買収し QIC ドライブの製造を中止したことで加速しました。 4mm ドライブは小型で静かですが 8mm ドライブが持っている信頼性ほど、その評判は良くありません。 また、4mm カートリッジは 8mm カートリッジよりも安価で小型 (3 x 2 x 0.5 インチ、76 x 51 x 12 mm) になっています。 ただし、8mm と同様に、4mm のヘッドはヘリカルスキャン方式 (訳注: VTR と同様の回転ヘッドを使う方式) を採用しているため、比較的寿命が短いです。</p></div><div class=paragraph><p>ドライブのデータスループットは、150 kB/s から 最大で 500 kB/s 程度です。 データ容量は 1.3 GB から 2.0 GB です。 ドライブのほとんどで利用可能なハードウェア圧縮を使用すると、 容量が約 2 倍になります。 マルチドライブテープライブラリユニットは 1 つの筐体に 6 つのドライブを収容可能で、自動的にテープの交換ができます。 ライブラリの容量は 240 GB に達します。</p></div><div class=paragraph><p>現在の DDS-3 標準は 12 GB (圧縮時 24 GB) までのテープ容量に対応しています。</p></div><div class=paragraph><p>8mm ドライブと同様に 4mm ドライブはヘリカルスキャンを使用します。 ヘリカルスキャン方式の利点および欠点はすべて 4mm および 8mm ドライブの両方に当てはまります。</p></div><div class=paragraph><p>テープは 2,000 回のパスあるいは 100 回フルバックアップした後には交換するべきです。</p></div></div><div class=sect3><h4 id=backups-tapebackups-8mm>14.7.2. 8mm (Exabyte)<a class=anchor href=#backups-tapebackups-8mm></a></h4><div class=paragraph><p>8mm テープは SCSI テープドライブとして最もよく使われているもので、 データ交換用として最良の選択です。ほとんどのサイトには Exabyte 2 GB 8mm テープドライブがあるでしょう。8mm ドライブは信頼性が高く、使いやすく、静かです。 カートリッジは安価で小型です (4.8 x 3.3 x 0.6 インチ、122 x 84 x 15 mm)。8mm テープの欠点は、テープとヘッドの相対的な速度が高速なために、 比較的ヘッドとテープの寿命が短いことです。</p></div><div class=paragraph><p>データスループットは 250 kB/s から 500 kB/s 程度です。データ容量は 300 MB から 7 GB です。 ほとんどのドライブで利用可能なハードウェア圧縮を利用すると、 容量が約 2 倍になります。 これらのドライブは、単一のユニットから 6 つのドライブと 120 本のテープを一つの筐体に収容したマルチドライブテープライブラリまで利用可能です。 テープはユニットによって自動的に取り換えられます。 ライブラリの容量は 840 GB 以上に達します。</p></div><div class=paragraph><p>Exabyte の "Mammoth" モデルはテープ 1 本あたり 12 GB (圧縮時 24 GB) に対応し、 従来のテープドライブと比べ費用は約 2 倍になります。</p></div><div class=paragraph><p>データはヘリカルスキャンを用いてテープに記録されます。 ヘッダはメディアに対してある傾き (約 6 度) に配置されます。 テープはヘッドのある円筒の周の 270 度にわたって接触します。 テープが円筒面を走行する間、円筒は回転しています。 この結果、高密度のデータのつまったトラックは、 狭い間隔でテープの上端と下端の間を斜めに横切ります。</p></div></div><div class=sect3><h4 id=backups-tapebackups-qic>14.7.3. QIC<a class=anchor href=#backups-tapebackups-qic></a></h4><div class=paragraph><p>QIC-150 テープとドライブは、 おそらく最も一般的に使われているドライブとメディアでしょう。 QIC テープドライブは "現実的な" バックアップドライブとしては最も高価でないものです。 欠点はメディアのコストです。QIC テープは 8mm や 4mm テープと比較して GB あたりのデータの保存で 5 倍ほど高価です。 しかし、あなたの必要とする量が半ダース程のテープで十分であれば、 QIC は正しい選択かもしれません。QIC は <em>最も</em>一般的なテープドライブです。 すべてのサイトに QIC ドライブのどれかの容量のものがあります。問題は、 QIC は同じようなテープ (まったく同じ場合もある) に多様な記録密度があることです。QIC ドライブは静かではありません。 これらのドライブはデータ記録を開始する前に音をたててシークしますし、 リード、ライト、シークの時にはっきりと聞こえる音を出します。 QIC テープの大きさは (6 x 4 x 0.7 インチ、152 x 102 x 17 mm) です。 1/4 インチ幅のテープも使用している <a href=#backups-tapebackups-mini>ミニカートリッジ</a> は別に議論します。テープライブラリやチェンジャはありません。</p></div><div class=paragraph><p>データスループットは ~1500 kB/s から ~5000 kB/s 程度です。データ容量は 400 MB から 150 GB です。 ハードウェア圧縮が最近のドライブの多くで利用できます。 QIC ドライブは DAT ドライブに置き換えられつつあり、 あまり頻繁には使用されなくなっています。</p></div><div class=paragraph><p>データは複数のトラックに分かれてテープに記録されます。 トラックはテープメディアの長さ方向の一端からもう一方の端までです (訳注: 1 トラックの read/write が終わるとテープの走行方向を反転させ 次のトラックの read/write を行います)。トラックの数と、 それに対応するトラックの幅はテープの容量によって変わります。 すべてではありませんが、 最近のドライブはほとんど、少なくとも読み出しについては (場合によっては書き込みも) 下位互換性があります。 QIC はデータの安全性についてはよいといわれています (ヘリカルスキャンドライブに比べて機構は単純でより丈夫です)。</p></div><div class=paragraph><p>テープは 5000 回のバックアップで寿命となるでしょう。</p></div></div><div class=sect3><h4 id=backups-tapebackups-mini>14.7.4. XXX* ミニカートリッジ<a class=anchor href=#backups-tapebackups-mini></a></h4></div><div class=sect3><h4 id=backups-tapebackups-dlt>14.7.5. DLT<a class=anchor href=#backups-tapebackups-dlt></a></h4><div class=paragraph><p>DLT はここに示したドライブのタイプの中で最高速のデータ転送レートを発揮します。 1/2 インチ (12.5mm) テープが単リールのカートリッジ (4 x 4 x 1 インチ、100 x 100 x 25 mm) に入っています。 カートリッジのひとつの側面全体がスイングゲートになっています。 ドライブの機構がこのゲートを開け、テープリーダを引き出します。 テープリーダには楕円形の穴があり、 ドライブがテープを "引っ掛ける" のに使います。 巻き取りのためのリールはドライブの中にあります。 ここに挙げた他のカートリッジはすべて (9 トラックテープは唯一の例外です) 送り出しリールと巻き取りリールの両方がカートリッジの中にあります。</p></div><div class=paragraph><p>データスループットは約 1.5 MB/s で、4mm, 8mm, QIC テープドライブの 3 倍です。データ容量は単一のドライブで 10 GB から 20 GB の範囲です。マルチテープチェンジャ、 マルチテープドライブ、5 から 900 巻のテープを 1 から 20 ドライブで扱うマルチドライブテープライブラリがあり、 50 GB から 9 TB の容量が得られます。</p></div><div class=paragraph><p>圧縮によって、DLT Type IV フォーマットは 70 GB までの容量に対応しています。</p></div><div class=paragraph><p>データは (QICテープのように) テープの走行方向と平行に複数あるトラックへ記録されます。 2 つのトラックに同時書き込みを行います。 read/write ヘッドの寿命は比較的長いと言えます。 テープの走行が止まればヘッドとテープの間の相対運動は無いからです。</p></div></div><div class=sect3><h4 id=_ait>14.7.6. AIT<a class=anchor href=#_ait></a></h4><div class=paragraph><p>AIT は、Sony が発表した新しいフォーマットで、 テープ 1 本あたり 50 GB (圧縮時) まで格納できます。 テープにはメモリチップが搭載されており、 テープの内容の索引情報を保持しています。 他のテープではテープ上のファイルの位置を把握するのに数分必要とするのですが、 このテープドライブでは索引情報を読んで直ちに決定することができます。 SAMS:Alexandria のようなソフトウェアは、40 を超える ATI テープライブラリを操作できるのはもちろんのこと、 テープのメモリチップと直接通信して、スクリーンに内容を表示し、 どのファイルがどのテープにバックアップされたかを調べて、 正しいテープを見つけ、読み込み、 テープからデータを復元することができます。</p></div><div class=paragraph><p>このようなライブラリは大体 $20,000 くらいするので、 愛好家が購入できる価格帯からは外れてしまいます。</p></div></div><div class=sect3><h4 id=_新品のテープを初めて使う場合>14.7.7. 新品のテープを初めて使う場合<a class=anchor href=#_新品のテープを初めて使う場合></a></h4><div class=paragraph><p>全く新品の空テープを読もうとしたり書き込もうとすると、 処理は失敗するでしょう。 次のようなメッセージがコンソールに出力されるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sa0<span class=o>(</span>ncr1:4:0<span class=o>)</span>: NOT READY asc:4,1
sa0<span class=o>(</span>ncr1:4:0<span class=o>)</span>:  Logical unit is <span class=k>in </span>process of becoming ready</code></pre></div></div><div class=paragraph><p>テープに識別ブロック (Identifier Block:block number 0) がありません。QIC-525 標準を採用したすべての QIC テープドライブは識別ブロックをテープに書き込みます。 2 つの解決方法があります。</p></div><div class=ulist><ul><li><p><code>mt fsf 1</code> によりテープドライブはテープに識別ブロックを書き込みます。</p></li><li><p>フロントパネルのボタンを押してテープを取り出します。</p><div class=paragraph><p>再びテープを挿入し、データをテープに <code>dump</code> します。</p></div><div class=paragraph><p><code>dump</code> は <code>DUMP: End of tape detected</code> と報告し、 コンソールには <code>HARDWARE FAILURE info:280 asc:80,96</code> と表示されるでしょう。</p></div><div class=paragraph><p><code>mt rewind</code> を使ってテープを巻戻します。</p></div><div class=paragraph><p>次からはテープの操作はうまくいくでしょう。</p></div></li></ul></div></div></div><div class=sect2><h3 id=backups-floppybackups>14.8. フロッピーディスクへのバックアップ<a class=anchor href=#backups-floppybackups></a></h3><div class=sect3><h4 id=floppies-using>14.8.1. データをバックアップするのにフロッピーは使えますか?<a class=anchor href=#floppies-using></a></h4><div class=paragraph><p>フロッピーディスクは以下の理由によって、 実際にバックアップをつくるための適切なメディアではありません。</p></div><div class=ulist><ul><li><p>メディアの信頼性が (特に長期間の場合) 低い。</p></li><li><p>バックアップとリストアがとても遅い。</p></li><li><p>容量が非常に小さい (1 ダースかそこらのフロッピーディスクに ハードディスク全体をバックアップしていた時代は、 はるか遠くに過ぎ去りました)。</p></li></ul></div><div class=paragraph><p>しかしながら、データをバックアップする他の手段がないのなら、 バックアップを取らないよりもフロッピーディスクを使う方がましでしょう。</p></div><div class=paragraph><p>フロッピーディスクを使用せざるを得ないときは、 品質のよいディスクを使用してください。 事務所のその辺に数年転がっていたフロッピーは使わない方が良いでしょう。 評判のよいメーカの新しいディスクを使用することが理想です。</p></div></div><div class=sect3><h4 id=floppies-creating>14.8.2. それではどうやってデータをフロッピーにバックアップするのですか?<a class=anchor href=#floppies-creating></a></h4><div class=paragraph><p>フロッピーにバックアップする最もよい方法は、 <code>-M</code> (マルチボリューム) オプション付きで <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> コマンドを使用することです。これで、 複数のフロッピーにわたってバックアップすることが可能になります。</p></div><div class=paragraph><p>カレントディレクトリとサブディレクトリ内のすべてのファイルをバックアップするには、 以下のコマンドを (<code>root</code> 権限で) 使用します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar Mcvf /dev/fd0 *</span></code></pre></div></div><div class=paragraph><p>1 枚目のフロッピーが一杯になると、 <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> は次のボリュームを挿入するように要求します (<a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> はさまざまなメディアを扱えるので、 ボリュームと表示します。この文脈ではフロッピーディスクのことです)。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Prepare volume 2 <span class=k>for</span> /dev/fd0 and hit <span class=k>return</span>:</code></pre></div></div><div class=paragraph><p>指定したファイルがすべて保存されるまで (ボリューム番号を増やしながら) これが繰り返されます。</p></div></div><div class=sect3><h4 id=floppies-compress>14.8.3. バックアップを圧縮することはできませんか?<a class=anchor href=#floppies-compress></a></h4><div class=paragraph><p>残念なことに <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> はマルチボリュームアーカイブに対して、 <code>-z</code> オプションを使うことができません。 もちろん、すべてのファイルを <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a> で圧縮し、 それらを <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> を用いてフロッピーに保存して、 それから再び <a href="https://man.freebsd.org/cgi/man.cgi?query=gunzip&amp;sektion=1&amp;format=html">gunzip(1)</a> することはできます。</p></div></div><div class=sect3><h4 id=floppies-restoring>14.8.4. どのようにしてバックアップをリストアしたらいいのでしょうか?<a class=anchor href=#floppies-restoring></a></h4><div class=paragraph><p>すべてのアーカイブをリストアするには以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar Mxvf /dev/fd0</span></code></pre></div></div><div class=paragraph><p>特定のファイルだけをリストアするには 2 つの方法があります。 1 つ目は、1 枚目のフロッピーを用いて以下のようにするものです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar Mxvf /dev/fd0 filename</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> ユーティリティは、 必要なファイルを見つけるまで次のディスクを挿入するように要求します。</p></div><div class=paragraph><p>もう 1 つは、 必要なファイルがどのフロッピーに保存されているか分かっている場合、 そのフロッピーを挿入して上記と同じコマンドを使用するだけでもよいです。 あるフロッピー上にある 1 番目のファイルが、 その前のフロッピーから続いている場合は、 そのファイルのリストアを要求していなくても <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> はそれをリストアできないと警告することに注意してください!</p></div></div></div><div class=sect2><h3 id=backup-basics>14.9. バックアップの基本<a class=anchor href=#backup-basics></a></h3><div class=paragraph><p>主なバックアッププログラムは <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> の三つです。</p></div><div class=sect3><h4 id=_ダンプとリストア>14.9.1. ダンプとリストア<a class=anchor href=#_ダンプとリストア></a></h4><div class=paragraph><p>伝統的な UNIX® のバックアッププログラムは <code>dump</code> と <code>restore</code> です。 これらはファイルシステムによって作成されるファイル、リンク、 ディレクトリといった抽象の下位にある、 ディスクブロックの集合としてドライブを操作します。 <code>dump</code> はデバイス上のファイルシステム全体をバックアップします。 ファイルシステムの一部分だけ、 または二つ以上のファイルシステムにわたるディレクトリツリーをバックアップすることはできません。 <code>dump</code> はファイルおよびディレクトリをテープに書き込まずに、 ファイルおよびディレクトリを含んだ raw データブロックを書き込みます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ルートディレクトリで <code>dump</code> を使った場合、 <span class=filename>/home</span>, <span class=filename>/usr</span> など、他の多くのディレクトリはバックアップされません。 これらのディレクトリは通常、 他のファイルシステムへのマウントポイントであったり、 シンボリックリンクとなっているためです。</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>dump</code> には AT&amp;T UNIX のバージョン 6 (およそ 1975 年) の初期から残っている癖があります。 デフォルトのパラメタは、現在利用可能な高密度メディア (最大 62,182 ftpi) ではなく、9 トラックテープ (6250 bpi) に最適な値となっています。 現在のテープドライブの容量を利用するために、 これらのデフォルト値をコマンドラインで上書きしなければなりません。</p></div><div class=paragraph><p><code>rdump</code> と <code>rrestore</code> を用いて他のコンピュータに接続されているテープドライブにネットワーク経由でデータをバックアップすることも可能です。 どちらのプログラムもリモートのテープドライブにアクセスするために <code>rcmd</code> および <code>ruserok</code> に依存しています。 したがって、バックアップを実行するユーザがリモートコンピュータの <span class=filename>.rhosts</span> ファイルに書かれていなければなりません。 <code>rdump</code> および <code>rrestore</code> の引数はリモートコンピュータに適切なものを用いなければなりません。 FreeBSD コンピュータから <code>komodo</code> と呼ばれる Sun に接続されている Exabyte テープへ <code>rdump</code> するには以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&amp;1</span></code></pre></div></div><div class=paragraph><p>注意: <span class=filename>.rhosts</span> 認証を許可することには、セキュリティに関する暗黙の仮定があります。 あなたの置かれている状況を注意深く調べてください。</p></div><div class=paragraph><p><code>ssh</code> 越しに <code>dump</code> と <code>restore</code> をより安全な形で使うこともできます。</p></div><div class=exampleblock><div class=title>例 28. ssh 越しの <code>dump</code> の利用</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dump -0uan -f - /usr | gzip -2 | ssh1 -c blowfish \</span>
          targetuser@targetmachine.example.com <span class=nb>dd </span><span class=nv>of</span><span class=o>=</span>/mybigfiles/dump-usr-l0.gz</code></pre></div></div></div></div><div class=paragraph><p>または、環境変数 <code>RSH</code> を設定して、 <code>dump</code> の組み込み機能を利用する。</p></div><div class=exampleblock><div class=title>例 29. <code>RSH</code> を設定した ssh 越しの <code>dump</code> を利用</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_tar>14.9.2. <code>tar</code><a class=anchor href=#_tar></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> は AT&amp;T UNIX の バージョン 6 (1975 年ごろ) にまで遡ることができます。<code>tar</code> はファイルシステムと協調して動作し、 ファイルとディレクトリをテープに書き込みます。<code>tar</code> は <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> で使用可能なフルレンジのオプションには対応していませんが、 <code>tar</code> には <code>cpio</code> が使用するような奇妙なコマンドパイプラインは必要ありません。</p></div><div class=paragraph><p><code>tar</code> の多くの版はネットワーク経由のバックアップには対応していません。 FreeBSD が使用している GNU 版の <code>tar</code> は、 <code>rdump</code> と同じ構文でリモートデバイスに対応しています。 <code>komodo</code> と呼ばれる Sun に接続された Exabyte テープドライブに対して <code>tar</code> を実行するには以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/bin/tar cf komodo:/dev/nsa8 . 2&gt;&amp;1</span></code></pre></div></div><div class=paragraph><p>リモートデバイスに対応していない版に対しては、パイプラインと <code>rsh</code> を使用してリモートテープドライブにデータを送ることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar cf - . | rsh hostname dd of=tape-device obs=20b</span></code></pre></div></div><div class=paragraph><p>ネットワークを越えたバックアップのセキュリティを懸念しているなら、 <code>rsh</code> の代わりに <code>ssh</code> を使うべきです。</p></div></div><div class=sect3><h4 id=_cpio>14.9.3. <code>cpio</code><a class=anchor href=#_cpio></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> は本来 UNIX® ファイルを磁気メディアで交換するためのプログラムです。 <code>cpio</code> はバイトスワッピング、 多くの異なるアーカイブフォーマットの書き込みオプションがあり (それ以外にも多数のオプションがあります)、 パイプで他のプログラムにデータを渡すこともできます。 この最後にあげた特徴が、<code>cpio</code> をインストールメディアとしては優れた選択肢にしています。 <code>cpio</code> はディレクトリツリーの探索の機能はなく、ファイルリストは <span class=filename>stdin</span> からの入力でなくてはなりません。</p></div><div class=paragraph><p><code>cpio</code> はネットワーク経由のバックアップには対応していません。 以下のようにパイプラインと <code>rsh</code> を用いてリモートテープドライブにデータを送ることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for f in directory_list; do</span>
find <span class=nv>$f</span> <span class=o>&gt;&gt;</span> backup.list
<span class=k>done</span>
<span class=c># cpio -v -o --format=newc &lt; backup.list | ssh user@host &#34;cat &gt; backup_device&#34;</span></code></pre></div></div><div class=paragraph><p><em>directory_list</em> はバックアップしたいディレクトリのリストで、 <em>user</em>@<em>host</em> はバックアップを実行したいユーザとホスト名の組であり、 <em>backup_device</em> はバックアップを書き込みたいデバイスです (たとえば <span class=filename>/dev/nsa0</span>)。</p></div></div><div class=sect3><h4 id=_pax>14.9.4. <code>pax</code><a class=anchor href=#_pax></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a> は <code>tar</code> と <code>cpio</code> に対する IEEE/POSIX® の回答です。長年の間、さまざまな版の <code>tar</code> と <code>cpio</code> は互いにわずかに非互換になってきていました。 それらをしらみ潰しに標準化する代わりに、POSIX® は新しいアーカイブユーティリティを作りました。 <code>pax</code> は、いくつもの <code>cpio</code> や <code>tar</code> のフォーマットの読み書きに対応しようと試みているほか、 専用に新しいフォーマットを開発しました。 コマンド群は <code>tar</code> よりも <code>cpio</code> の方にいくぶん似ています。</p></div></div><div class=sect3><h4 id=backups-programs-amanda>14.9.5. Amanda<a class=anchor href=#backups-programs-amanda></a></h4><div class=paragraph><p>Amanda (Advanced Maryland Network Disk Archiver) は単一のプログラムではなく、 クライアント/サーバ型のバックアップシステムです。 Amanda サーバは、 Amanda クライアントを有する ネットワークに接続されたコンピュータからデータを受け取り、 備え付けられたテープドライブにバックアップします。 いくつもの大容量ディスクを備えたサイトでの共通の問題は、 データディレクトリをテープにバックアップするのに時間がかかりすぎることです。 Amanda はこの問題を解決します。 Amanda は "ホールディングディスク" を使用して、 同時に複数のファイルシステムのバックアップを行うことができます。 Amanda の設定ファイルにかかれたすべてのファイルシステムのフルバックアップを特定の間隔でとるために "アーカイブセット" と呼ばれるテープグループを作成します。 "アーカイブセット" には 夜間に作成されるすべてのファイルシステムの増分 (または差分) のバックアップも含まれます。 障害が起きたファイルシステムのリストアには、 最も新しいフルバックアップと増分のバックアップが必要です。</p></div><div class=paragraph><p>設定ファイルでは、バックアップの制御と Amanda によるネットワークトラフィック量を設定します。 Amanda は上記のバックアッププログラムのいずれかを使ってデータをテープに書き込みます。 Amanda は port または package として利用可能です。デフォルトではインストールされていません。</p></div></div><div class=sect3><h4 id=_何もしない>14.9.6. 何もしない<a class=anchor href=#_何もしない></a></h4><div class=paragraph><p>"何もしない" というのはコンピュータのプログラムではありませんが、 バックアップの戦略として最も広く採用されています。 これには初期投資が必要ありません。 従わなければならないバックアップスケジュールもありません。 ただ何もしないだけです。データに何か起きたら苦笑いして耐えてください!</p></div><div class=paragraph><p>あなたにとって時間やデータの価値が少ないか、 あるいはまったくないのであれば "何もしない" のはあなたのコンピュータに最も適したバックアッププログラムでしょう。 しかし注意してください。UNIX® は便利なツールです。 6 ヶ月も使用していれば、 あなたにとって価値のあるファイルの山が出来上がっているでしょう。</p></div><div class=paragraph><p>"何もしない" ことはコンピュータが同じものをもう一度作り直すことのできる <span class=filename>/usr/obj</span> やその他のディレクトリツリーについては適切なバックアップ方法です。 一例として、このハンドブックの HTML 版 または PostScript® 版を構成するファイルがあります。 これらの文書形式は SGML ファイルから作成されたものです。 HTML または PostScript® ファイルのバックアップは必要ありません。 SGML ファイルは定期的にバックアップされています。</p></div></div><div class=sect3><h4 id=_どのバックアッププログラムが最適ですか>14.9.7. どのバックアッププログラムが最適ですか?<a class=anchor href=#_どのバックアッププログラムが最適ですか></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> です。<em>以上。</em> Elizabeth D. Zwicky はここで検討したプログラムすべてについて拷問的なテストを行いました。 すべてのデータと UNIX® ファイルシステムの状態すべてを保存するのに最適なのは、明らかに <code>dump</code> です。 Elizabeth は多種多様の特異な状態 (いくつかはあまり珍しくないものもあります) を含むファイルシステムを作成し、 それらのファイルシステムのバックアップとリストアを行って、 それぞれのプログラムのテストを行いました。特異な状態とは、 ホールがあるファイル、ホールとヌルブロックがあるファイル、 奇妙な文字をファイル名に持つファイル、読み取り不可、 書き込み不可のファイル、デバイスファイル、 バックアップ中のファイルのサイズ変更、 バックアップ中のファイルの作成および削除、などです。 彼女は 1991 年 10 月の LISA V で結果を発表しています。 <a href=http://berdmann.dyndns.org/zwicky/testdump.doc.html>torture-testing Backup and Archive Programs</a> を参照してください。</p></div></div><div class=sect3><h4 id=_緊急時のリストア手順>14.9.8. 緊急時のリストア手順<a class=anchor href=#_緊急時のリストア手順></a></h4><div class=sect4><h5 id=_惨事が起きる前に>14.9.8.1. 惨事が起きる前に<a class=anchor href=#_惨事が起きる前に></a></h5><div class=paragraph><p>発生する可能性があるどのような惨事に対しても、 備えるのに必要な手順は以下の 4 ステップだけです。</p></div><div class=paragraph><p>最初に、 各ディスクのディスクラベルとファイルシステムテーブル (<span class=filename>/etc/fstab</span>)、 ブートメッセージ全体をそれぞれ 2 枚ずつ印刷します (たとえば <code>disklabel da0 | lpr</code>)。</p></div><div class=paragraph><p>2 番目に、ブートフロッピーと fix-it フロッピー (<span class=filename>boot.flp</span> および <span class=filename>fixit.flp</span>) にそのシステムのデバイスがすべて含まれているか確認します。 最も簡単に確認する方法は、フロッピーをドライブに入れてマシンをリブートしてブートメッセージを確認することです。 あなたのシステムのデバイスのすべてが含まれ、 機能していれば 3 番目の手順に進んでください。</p></div><div class=paragraph><p>さもなければ、 そのシステムのすべてのディスクをマウントでき、 テープドライブにもアクセスできるカーネルを備えた カスタムブートフロッピーを 2 枚作成する必要があります。 これらのフロッピーディスクには <code>fdisk</code>, <code>disklabel</code>, <code>newfs</code>, <code>mount</code> と、利用するバックアッププログラムが入っていなければなりません。 これらのプログラムはスタティックリンクされていなければなりません。 <code>dump</code> を使用するのなら、このフロッピーには <code>restore</code> も含まれていなければなりません。</p></div><div class=paragraph><p>3 番目に、定期的にバックアップテープを作成します。 最後のバックアップの後で行われた変更は、回復できずに失われます。 バックアップテープにライトプロテクトを施してください。</p></div><div class=paragraph><p>4 番目に、フロッピーディスク (<span class=filename>boot.flp</span> と <span class=filename>fixit.flp</span>、 か、第 2 段階で作成した 2 枚のカスタムブートフロッピーディスクのどちらか) およびバックアップテープのテストをします。 手順のメモを作りましょう。 このメモはブートフロッピー、印刷した紙、 バックアップテープと一緒に保存しておきます。 リストアを行うときには、 このメモがバックアップテープを壊すのを防ぐくらい取り乱しているかもしれません (どのように? <code>tar xvf /dev/sa0</code> の代わりに、うっかり <code>tar cvf /dev/sa0</code> と入力してバックアップテープを上書きしてしまうかもしれません)。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>訳注</div><div class=paragraph><p>上書きはライトプロテクトをしておけば防げますが、 何らかの原因でプロテクトがはずれているかもしれません。 ちなみに訳者の経験から言えば、 上のようなミスタイプは結構起きます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>安全性を増すために、毎回、 ブートフロッピーを作成し、 2 巻のバックアップテープを取ります。 一方を離れた場所に保管します。 離れた場所は同じ事務所の建物の地下室ではいけません。 世界貿易センタービルにあった数多くの会社は、 苦い経験によりこの教訓を得ました。離れた場所とは、 コンピュータやディスクドライブから十分な距離を取って 物理的に分離されていなければなりません。</p></div><div class=exampleblock><div class=title>例 30. ブートフロッピーを作成するスクリプト</div><div class=content><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# create a restore floppy
#
# format the floppy
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
	 echo &#34;Bad floppy, please use a new one&#34;
	 exit 1
fi

# place boot blocks on the floppy
#
disklabel -w -B /dev/fd0c fd1440

#
# newfs the one and only partition
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# mount the new floppy
#
mount /dev/fd0a /mnt

#
# create required directories
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# for the root partition
mkdir /mnt/tmp
mkdir /mnt/var

#
# populate the directories
#
if [ ! -x /sys/compile/MINI/kernel ]
then
	 cat &lt;&lt; EOM
The MINI kernel does not exist, please create one.
Here is an example config file:
#
# MINI - A kernel to get FreeBSD onto a disk.
#
machine         &#34;i386&#34;
cpu             &#34;I486_CPU&#34;
ident           MINI
maxusers        5

options         INET                    # needed for _tcp _icmpstat _ipstat
                                        #            _udpstat _tcpstat _udb
options         FFS                     #Berkeley Fast File System
options         FAT_CURSOR              #block cursor in syscons or pccons
options         SCSI_DELAY=15           #Be pessimistic about Joe SCSI device
options         NCONS=2                 #1 virtual consoles
options         USERCONFIG              #Allow user configuration with -c XXX

config          kernel	root on da0 swap on da0 and da1 dumps on da0

device          isa0
device          pci0

device          fdc0	at isa? port &#34;IO_FD1&#34; bio irq 6 drq 2 vector fdintr
device          fd0	at fdc0 drive 0

device          ncr0

device          scbus0

device          sc0	at isa? port &#34;IO_KBD&#34; tty irq 1 vector scintr
device          npx0	at isa? port &#34;IO_NPX&#34; irq 13 vector npxintr

device          da0
device          da1
device          da2

device          sa0

pseudo-device   loop            # required by INET
pseudo-device   gzip            # Exec gzipped a.out&#39;s
EOM
	 exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init &gt; /mnt/sbin/init
gzip -c -best /sbin/fsck &gt; /mnt/sbin/fsck
gzip -c -best /sbin/mount &gt; /mnt/sbin/mount
gzip -c -best /sbin/halt &gt; /mnt/sbin/halt
gzip -c -best /sbin/restore &gt; /mnt/sbin/restore

gzip -c -best /bin/sh &gt; /mnt/bin/sh
gzip -c -best /bin/sync &gt; /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# create the devices nodes
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# create minimum file system table
#
cat &amp;gt; /mnt/etc/fstab &amp;lt;&amp;lt;EOM
/dev/fd0a    /    ufs    rw  1  1
EOM

#
# create minimum passwd file
#
cat &gt; /mnt/etc/passwd &lt;&lt;EOM
root:*:0:0:Charlie &amp;:/root:/bin/sh
EOM

cat &gt; /mnt/etc/master.passwd &lt;&lt;EOM
root::0:0::0:0:Charlie &amp;:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# umount the floppy and inform the user
#
/sbin/umount /mnt
echo &#34;The floppy has been unmounted and is now ready.&#34;</pre></div></div></div></div></div><div class=sect4><h5 id=_惨事の後は>14.9.8.2. 惨事の後は<a class=anchor href=#_惨事の後は></a></h5><div class=paragraph><p>重要な問題は、ハードウェアが生き残ったかどうかです。 定期的にバックアップを取っていれば、 ソフトウェアについて心配する必要はありません。</p></div><div class=paragraph><p>ハードウェアに障害があれば、 コンピュータを使用する前にその部品を交換してください。</p></div><div class=paragraph><p>ハードウェアに問題が無ければ、フロッピーを確認してください。 カスタムブートフロッピーディスクを使用しているのであれば、 シングルユーザモードでブートして (<code>boot:</code> プロンプトで <code>-s</code> を入力します)、 次の段落は飛ばしてください。</p></div><div class=paragraph><p><span class=filename>boot.flp</span> と <span class=filename>fixit.flp</span> を使用しているのであればこのまま読み進めてください。 <span class=filename>boot.flp</span> フロッピーをフロッピードライブに入れて、 コンピュータを起動してください。 本来のインストールメニューが画面に表示されます。 <code>Fixit—​Repair mode with CDROM or floppy.</code> オプションを選択します。指示された通り <span class=filename>fixit.flp</span> をいれてください。 <code>restore</code> とその他必要となるプログラムは <span class=filename>/mnt2/stand</span> にあります。</p></div><div class=paragraph><p>そして、ファイルシステムを一つずつ回復します。</p></div><div class=paragraph><p>最初のディスクのルートパーティションを <code>mount</code> してみてください (たとえば <code>mount /dev/da0a /mnt</code>)。 ディスクラベルが破壊されている場合は、<code>disklabel</code> を用いてあらかじめ印刷して保存しておいた通りにパーティションを作り直し、ディスクラベルを作成してください。 <code>newfs</code> を使用してファイルシステムを作り直します。 ルートパーティションを読み書き可能にマウントし直します (<code>mount -u -o rw /mnt</code>)。 バックアッププログラムとバックアップテープを使用して、 このファイルシステムのデータを回復します (たとえば <code>restore vrf /dev/sa0</code>)。 ファイルシステムをアンマウントします (たとえば <code>umount /mnt</code>)。 障害を受けたファイルシステムそれぞれについて繰り返してください。</p></div><div class=paragraph><p>システムが動き出したら、 新しいテープにデータをバックアップしてください。 どのような理由で再び事故が起きたり、データが失われるかわかりません。 これに数時間を費すことで、後々の災難から救われます。</p></div></div></div></div><div class=sect2><h3 id=disks-virtual>14.10. ネットワーク、メモリ、そしてファイルベースのファイルシステム<a class=anchor href=#disks-virtual></a></h3><div class=paragraph><p>FreeBSD にはフロッピーや CD, ハードディスクなどの手元の計算機に取り付けたディスクの他に、 別の形態のディスク、<em>仮想ディスク</em>、もあります。</p></div><div class=paragraph><p>これには、<a href=./#network-nfs>Network File System</a> のようなネットワークファイルシステムや Coda, メモリベースのファイルシステムおよびファイルベースのファイルシステムがあります。</p></div><div class=paragraph><p>稼働させている FreeBSD のバージョンによって、 ファイルベースおよびメモリベースのファイルシステムを作成したり操作するために、異なるツールを使用しなければならないでしょう。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 4.X の使用者は必要なデバイスを作成するために <a href="https://man.freebsd.org/cgi/man.cgi?query=MAKEDEV&amp;sektion=8&amp;format=html">MAKEDEV(8)</a> を使用しなければならないでしょう。FreeBSD 5.0 以降では、<a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> がデバイスノードを自動的に割り当ててくれるので、 使用者が意識する必要はありません。</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=disks-vnconfig>14.10.1. FreeBSD 4.X でファイル中に構築されるファイルシステム<a class=anchor href=#disks-vnconfig></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a> ユーティリティを使えば擬似ディスクデバイスを設定し、 有効にすることができます。 <em>vnode</em> とはファイルの内部的な表現方法であり、 ファイルに関する操作の中心となるものです。つまり、<a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a> はファイルシステムを生成したり操作したりするためにファイルを用いるのです。 一つ例を挙げると、 ファイルに収められたフロッピーや CD-ROM のイメージをマウントするために用いることができます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a> を使用するためには、 カーネルが <a href="https://man.freebsd.org/cgi/man.cgi?query=vn&amp;sektion=4&amp;format=html">vn(4)</a> デバイスに対応している必要があります。 そうでなければ、カーネルコンフィギュレーションファイルに 次の行を追加してカーネルを再構築し、システムを再起動してください。</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device vn</pre></div></div><div class=paragraph><p>既にあるファイルシステムイメージのマウント</p></div><div class=exampleblock><div class=title>例 31. FreeBSD 4.X での vnconfig を用いた既存のファイルシステムイメージのマウント</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vnconfig vn0 diskimage</span>
<span class=c># mount /dev/vn0c /mnt</span></code></pre></div></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a> を用いたファイルシステムイメージの新規作成</p></div><div class=exampleblock><div class=title>例 32. <code>vnconfig</code> を用いたファイルベースディスクの新規作成</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># vnconfig -s labels -c vn0 newimage</span>
<span class=c># disklabel -r -w vn0 auto</span>
<span class=c># newfs vn0c</span>
Warning: 2048 sector<span class=o>(</span>s<span class=o>)</span> <span class=k>in </span>last cylinder unallocated
/dev/vn0c:     10240 sectors <span class=k>in </span>3 cylinders of 1 tracks, 4096 sectors
        5.0MB <span class=k>in </span>1 cyl <span class=nb>groups</span> <span class=o>(</span>16 c/g, 32.00MB/g, 1280 i/g<span class=o>)</span>
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 32
<span class=c># mount /dev/vn0c /mnt</span>
<span class=c># df /mnt</span>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt</code></pre></div></div></div></div></div><div class=sect3><h4 id=disks-mdconfig>14.10.2. FreeBSD 5.X でファイル中に構築されるファイルシステム<a class=anchor href=#disks-mdconfig></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> ユーティリティは FreeBSD 5.X において メモリディスク (<a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>) を設定し、有効にするために使用されます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> を使用するためには <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> モジュールを読み込むか、 カーネルコンフィギュレーションファイルに <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> デバイスを追加してカーネルを再構築し、システムを再起動してください。</p></div><div class="literalblock programlisting"><div class=content><pre>device md</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> コマンドは、 三つのタイプのメモリベース仮想ディスクに対応しています。 <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> を用いて割り当てられたメモリディスク、 ファイルをベースにしたメモリディスク、 およびスワップ領域をベースにしたメモリディスクです。 想定される使用法は、ファイル内に保持されたフロッピーイメージまたは CD イメージをマウントすることです。</p></div><div class=paragraph><p>既にあるファイルシステムイメージのマウント</p></div><div class=exampleblock><div class=title>例 33. FreeBSD 5.X での <code>mdconfig</code> を用いた既存のファイルシステムイメージのマウント</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f diskimage -u 0</span>
<span class=c># mount /dev/md0c /mnt</span></code></pre></div></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> を用いたファイルシステムイメージの新規作成</p></div><div class=exampleblock><div class=title>例 34. <code>mdconfig</code> を用いたファイルシステムイメージの新規作成</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># mdconfig -a -t vnode -f newimage -u 0</span>
<span class=c># disklabel -r -w md0 auto</span>
<span class=c># newfs md0c</span>
/dev/md0c: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
	using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 256 inodes.
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 32, 2624, 5216, 7808
<span class=c># mount /dev/md0c /mnt</span>
<span class=c># df /mnt</span>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4846        2     4458     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p><code>-u</code> オプションを用いて ユニット番号を指定しない場合、<a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> は未使用のデバイスを自動的に選択するために <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> デバイスの auto-unit 機能を使用します。 割り当てられたユニットの名前は <span class=filename>md4</span> のように標準出力に出力されます。<a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> の詳細についてはマニュアルページを参照してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.1-RELEASE から、従来の <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> プログラムは <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> ユーティリティに置き換えられました。<a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> では、 使用されていないオプションおよびパラメタの数多くが削除されました。 たとえば <code>-r</code> オプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> では取り除かれました。詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> マニュアルページを参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> ユーティリティは大変役に立ちますが、 ファイルベースのファイルシステムを作成するために、 多くのコマンドの入力が必要となります。FreeBSD 5.0 では <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> と呼ばれるツールも用意されています。このプログラムは <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> を用いて <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> ディスクを設定し、<a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> を用いて UFS ファイルシステムを作成し、<a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> を用いてマウントします。たとえば、上記と同じファイルシステムを作成し、 マウントしたい場合は、下記のように入力するだけです。</p></div><div class=exampleblock><div class=title>例 35. <code>mdmfs</code> を用いたファイルベースディスクの設定とマウント</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># mdmfs -F newimage -s 5m md0 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4846    2  4458     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p>ユニット番号を指定せずに <code>md</code> オプションを使用した場合、<a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> は未使用のデバイスを自動的に選択するために <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> デバイスの auto-unit 機能を使用します。<a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> についての詳細はマニュアルページを参照してください。</p></div></div><div class=sect3><h4 id=disks-md-freebsd4>14.10.3. FreeBSD 4.X でのメモリベースのファイルシステム<a class=anchor href=#disks-md-freebsd4></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> ドライバは FreeBSD 4.X においてメモリファイルシステムを作成するために単純で効果的な手段です。 メモリを割り当てるために <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> 関数が使用されます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a> を用いて作成したファイルシステムを例に取ると、 以下のようにします。</p></div><div class=exampleblock><div class=title>例 36. FreeBSD 4.X での md メモリディスク</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=newimage of=/dev/md0</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># mount /dev/md0c /mnt</span>
<span class=c># df /mnt</span>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p>詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> マニュアルページを参照してください。</p></div></div><div class=sect3><h4 id=disks-md-freebsd5>14.10.4. FreeBSD 5.X でのメモリベースのファイルシステム<a class=anchor href=#disks-md-freebsd5></a></h4><div class=paragraph><p>メモリベースおよびファイルベースのファイルシステムに対しても 同じツール (<a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> または <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>) を使用できます。 メモリベースのファイルシステムに対する記憶領域は <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> 関数を用いて割り当てられます。</p></div><div class=exampleblock><div class=title>例 37. <code>mdconfig</code> を用いたメモリベースディスクの新規作成</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t malloc -s 5m -u 1</span>
<span class=c># newfs -U md1</span>
/dev/md1: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
	using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 256 inodes.
	with soft updates
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 32, 2624, 5216, 7808
<span class=c># mount /dev/md1 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4846    2  4458     0%    /mnt</code></pre></div></div></div></div><div class=exampleblock><div class=title>例 38. <code>mdmfs</code> を用いたメモリベースディスクの新規作成</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -M -s 5m md2 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> のコマンドラインの <code>malloc</code> を <code>swap</code> に置き換えることで、<a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> 関数によるファイルシステムを使用する代わりに スワップ領域を使用することが可能です。デフォルトでは <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> ユーティリティはスワップベースのディスクを作成します (<code>-M</code> なし)。詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> マニュアルページを参照してください。</p></div></div><div class=sect3><h4 id=_システムからメモリディスクを切り離す>14.10.5. システムからメモリディスクを切り離す<a class=anchor href=#_システムからメモリディスクを切り離す></a></h4><div class=paragraph><p>メモリベースまたはファイルベースのファイルシステムが使用されていない場合、 すべてのリソースをシステムに開放するべきです。 はじめにファイルシステムをアンマウントします。 次にシステムからディスクを切り離し、リソースを開放するために <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> を使用します。</p></div><div class=paragraph><p>たとえば <span class=filename>/dev/md4</span> によって使用されたすべてのリソースを切り離し、開放するには以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p><code>mdconfig -l</code> コマンドを使用することによって、 設定された <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> デバイスについての情報を表示することが可能です。</p></div><div class=paragraph><p>FreeBSD 4.X では <a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a> はデバイスを切り離すのに使用されます。たとえば <span class=filename>/dev/vn4</span> によって使用されたすべてのリソースを切り離し、開放するには以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vnconfig -u vn4</span></code></pre></div></div></div></div><div class=sect2><h3 id=snapshots>14.11. ファイルシステムのスナップショット<a class=anchor href=#snapshots></a></h3><div class=paragraph><p>FreeBSD 5.0 は Soft Updates と協調するファイルシステムスナップショットという新しい機能を提供します。</p></div><div class=paragraph><p>スナップショットは指定したファイルシステムのイメージを作成し、 また、ファイルとして扱うことができるようになります。 スナップショットファイルはアクションが実行されるファイルシステム内で作成されなければなりません。 また、ユーザは一つのファイルシステムあたり 20 までスナップショットを作成することができます。 有効なスナップショットはスーパーブロック内に記録されるので、 リブートしてから永続的にアンマウントおよびリマウントを記録します。 スナップショットが必要無くなったときは、 標準の <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a> コマンドを用いて削除することができます。 スナップショットはどんな順番で削除してもよいのですが、 その他のスナップショットが開放されたブロックのうちいくらかをおそらく必要とするので、 使用されていたすべてのスペースを得られるとは限りません。</p></div><div class=paragraph><p>初めてスナップショットを作成すると、<code>root</code> でさえも書き込めないように <code>schg</code> フラグ (<a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> のマニュアルページを参照) が設定されます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=1&amp;format=html">unlink(1)</a> コマンドは、スナップショットに <code>schg</code> フラグが設定されていてもそれらを削除することのできる例外です。 したがって、スナップショットファイルを削除する前に、 <code>schg</code> フラグをクリアする必要はありません。</p></div><div class=paragraph><p>スナップショットは <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> コマンドを用いて作成されます。 <span class=filename>/var</span> のスナップショットを <span class=filename>/var/snapshot/snap</span> に作成したいときは、 以下のコマンドを使用します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o snapshot /var/snapshot/snap /var</span></code></pre></div></div><div class=paragraph><p>また、スナップショットを作成するのに <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> も使えます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mksnap_ffs /var /var/snapshot/snap</span></code></pre></div></div><div class=paragraph><p>スナップショットにはいくつかの利用法があります。</p></div><div class=ulist><ul><li><p>スナップショットをバックアップ目的に使用する管理者もいます。 なぜならスナップショットは CD やテープに転送できるからです。</p></li><li><p>ファイルの完全性を検証するために、 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> をスナップショットに実行してもよいでしょう。 スナップショットをマウントしたときにそのファイルシステムがクリーンであったとすると、 そのスナップショットをマウントするときはいつでもクリーンな (そして変更のない) 結果を得るでしょう。 これは本質的には バックグラウンド <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> が行うことです。</p></li><li><p>スナップショット上で <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> ユーティリティを実行すると、 スナップショットのファイルシステムとタイムスタンプが一致するダンプが返されるでしょう。 <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> は <code>-L</code> オプションを使用することで、 一つのコマンドでスナップショットをとり、ダンプイメージを作成して、スナップショットを削除することが可能です。</p></li><li><p>ファイルシステムの "凍結された" イメージとしてスナップショットを <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> します。 <span class=filename>/var/snapshot/snap</span> のスナップショットを <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> するには以下のようにします。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /var/snapshot/snap -u 4</span>
<span class=c># mount -r /dev/md4 /mnt</span></code></pre></div></div></li></ul></div><div class=paragraph><p>これで <span class=filename>/mnt</span> にマウントした 凍結状態の <span class=filename>/var</span> ファイルシステム構造を探索できます。 すべてがスナップショットが作成された時と同じ状態になるはずです。ただし、 以前に作成されたスナップショットがサイズ 0 のファイルとして現れることが唯一の例外です。 スナップショットの使用を終えた場合、以下のようにアンマウントできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p><code>softupdates</code> およびファイルシステムスナップショットに関する詳細については、 <a href=http://www.mckusick.com/>http://www.mckusick.com/</a> にある Marshall Kirk McKusick のウェブサイトを参照してください。 ここには技術的な論文もあります。</p></div></div><div class=sect2><h3 id=quotas>14.12. ファイルシステムクォータ<a class=anchor href=#quotas></a></h3><div class=paragraph><p>クォータは OS の持っているオプショナルな機能であり、 ファイルシステム毎にユーザやグループのメンバが使用するディスク容量やファイルの数を制限することができます。 この機能は、あるユーザやグループに割り当てられるリソースの量を制限することが望ましいようなタイムシェアリングシステムにおいてよく用いられます。 この機能を用いることによって使用可能なディスク容量の全てを一人のユーザやユーザのグループが使ってしまうことを防ぐことができます。</p></div><div class=sect3><h4 id=_ディスククォータを使うためのシステム設定>14.12.1. ディスククォータを使うためのシステム設定<a class=anchor href=#_ディスククォータを使うためのシステム設定></a></h4><div class=paragraph><p>ディスククォータの設定を始める前に、 まずはカーネルにクォータが組み込まれていることを確認しましょう。 カーネルのコンフィグレーションファイルに次の行を入れます。</p></div><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>標準の <span class=filename>GENERIC</span> カーネルでは、 この機能は有効になっていませんので、 ディスククォータを利用するためには上記を設定後カーネルを構築しなおし、 作成されたカスタムカーネルをインストールしなければいけません。 カーネルのコンフィグレーションに関しては <a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> をご覧ください。</p></div><div class=paragraph><p>次に <span class=filename>/etc/rc.conf</span> でディスククォータを有効にする必要があります。 次の行を加えましょう。</p></div><div class="literalblock programlisting"><div class=content><pre>enable_quotas=&#34;YES&#34;</pre></div></div><div class=paragraph><p>起動時の動作をさらに細かくコントロールするためにもう一つ設定用の変数があります。 通常、起動時には <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a> によりそれぞれのファイルシステムのクォータの整合性がチェックされます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a> の役割は、 クォータデータベースのデータが正しくファイルシステム上のデータを反映しているか確認することです。 これはかなり時間を食う処理であり、 起動にかかる時間に大きな影響を及ぼします。 このステップをとばしたい人のために <span class=filename>/etc/rc.conf</span> に次の変数が用意されています。</p></div><div class="literalblock programlisting"><div class=content><pre>check_quotas=&#34;NO&#34;</pre></div></div><div class=paragraph><p>もし 3.2-RELEASE よりも前の FreeBSD を使っているならば設定はもっと単純で、一つの変数のみです。 次の行を <span class=filename>/etc/rc.conf</span> で設定してください。</p></div><div class="literalblock programlisting"><div class=content><pre>check_quotas=&#34;YES&#34;</pre></div></div><div class=paragraph><p>最後に、ファイルシステム毎にディスククォータを有効にするために <span class=filename>/etc/fstab</span> を編集する必要があります。 ここでユーザもしくはグループ、 あるいはその両方にクォータを設定することができるのです。</p></div><div class=paragraph><p>あるファイルシステム上にユーザ毎のクォータを有効にする場合には、 <span class=filename>/etc/fstab</span> 中でクォータを有効にしたいファイルシステムエントリのオプション部に <code>userquota</code> を加えます。 例えば次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g   /home    ufs rw,userquota 1 2</pre></div></div><div class=paragraph><p>同様に、グループクォータを有効にするには <code>userquota</code> キーワードの代わりに <code>groupquota</code> を用います。 ユーザとグループの両方のクォータを有効にするには次のようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</pre></div></div><div class=paragraph><p>デフォルトでは、 クォータファイルはそのファイルシステムのルートディレクトリに ユーザ用、グループ用それぞれ <span class=filename>quota.user</span>, <span class=filename>quota.group</span> という名前で置かれます。さらに詳しい情報は <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> をご覧ください。<a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> マニュアルには別の場所を指定することができると書いてはありますが、 あまり勧められません。なぜなら、 様々なクォータ関係のユーティリティがそれにうまく対処できるようにないためです。</p></div><div class=paragraph><p>この時点で、 一度システムを再起動して新しいカーネルで立ち上げましょう。 <span class=filename>/etc/rc</span> が自動的に適当なコマンドを実行し、 <span class=filename>/etc/fstab</span> で有効にした全てのクォータ用に初期ファイルを作ってくれます。 従って、空のクォータファイルを手で作る必要は一切ありません。</p></div><div class=paragraph><p>通常の運用では <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaon&amp;sektion=8&amp;format=html">quotaon(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaoff&amp;sektion=8&amp;format=html">quotaoff(8)</a> といったコマンドを手で動かす必要はないのですが、 慣れるためにもこれらのマニュアルは読んでおきましょう。</p></div></div><div class=sect3><h4 id=_クォータリミットの設定>14.12.2. クォータリミットの設定<a class=anchor href=#_クォータリミットの設定></a></h4><div class=paragraph><p>一旦クォータを有効にしたら本当に有効になっているのか確認しておきましょう。簡単な方法は次のコマンドを実行することです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># quota -v</span></code></pre></div></div><div class=paragraph><p>ディスクの使用状況と、クォータが有効になっているファイルシステムのクォータリミットが一行にまとめて出力されるでしょう。</p></div><div class=paragraph><p>さあ、<a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a> でクォータリミットを設定する準備ができました。</p></div><div class=paragraph><p>ユーザやグループが使用できるディスク容量や作成できるファイルの数に制限をかけるにはいくつかのオプションがあります。割り当てディスク容量を制限 (ブロッククォータ) することもファイル数を制限 (inode クォータ) することも、両者を組み合わせることもできるのです。 これらの制限はそれぞれさらに二つのカテゴリ、 ハードリミットとソフトリミット、に分けることができます。</p></div><div class=paragraph><p>ハードリミットを越えることはできません。 あるユーザが一旦ハードリミットにたっした場合、 そのファイルシステムではそれ以上の割り当ては望めません。 例えばあるファイルシステム上に 500 ブロックのハードリミットが設定されており現在 490 ブロックを使用している場合、さらに 10 ブロックしか使えないのです。 11 ブロックを使おうとすると失敗します。</p></div><div class=paragraph><p>一方、 ソフトリミットはある限られた時間内であれば越えることができます。 この時間は猶予期間として知られており、デフォルトでは 1 週間です。 あるユーザが自分のソフトリミットを猶予期間よりも長い間越えているとソフトリミットはハードリミットに変わり、それ以上使用することはできなくなります。 ユーザがソフトリミットよりも減らせば猶予期間はリセットされます。</p></div><div class=paragraph><p>以下は <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a> コマンドを実行した時に見ることになるであろう例です。 <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a> コマンドが起動されると環境変数 <code>EDITOR</code> で指定されるエディタに入ります。 <code>EDITOR</code> が設定されていない場合には vi が起動されます。 ここでクォータリミットを編集します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -u test</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>Quotas for user test:
/usr: blocks in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: blocks in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</pre></div></div><div class=paragraph><p>通常、クォータが有効になっているファイルシステム毎に 2 行あります。 一つはブロックリミット用でもう一つは inode リミット用です。 クォータリミットを変更したいところを書き変えるだけでかまいません。 たとえばこのユーザのブロックリミットを、ソフトリミットは 50 から 500 へ、ハードリミットは 75 から 600 に変更する場合、</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: blocks in use: 65, limits (soft = 50, hard = 75)</pre></div></div><div class=paragraph><p>から</p></div><div class="literalblock programlisting"><div class=content><pre> /usr: blocks in use: 65, limits (soft = 500, hard = 600)</pre></div></div><div class=paragraph><p>へ書き換えます。新しいクォータリミットはエディタを終了すれば設定されます。</p></div><div class=paragraph><p>ある範囲の UID に対してクォータリミットを設定したい場合がありますが、このような時には <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a> コマンドの <code>-p</code> オプションを使うといいでしょう。まず、 あるユーザに割り当てたいクォータリミットを設定し、次に <code>edquota -p protouser startuid-enduid</code> を実行するのです。例えばユーザ <code>test</code> にお望みのクォータリミットが付いているとしましょう。 次のコマンドにより 10,000 から 19,999 の間の UID に対して同じクォータリミットを付けることができるのです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -p test 10000-19999</span></code></pre></div></div><div class=paragraph><p>さらに詳しいことは <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a> のマニュアルページをご覧ください。</p></div></div><div class=sect3><h4 id=_クォータリミットとディスク使用状況のチェック>14.12.3. クォータリミットとディスク使用状況のチェック<a class=anchor href=#_クォータリミットとディスク使用状況のチェック></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> または <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a> といったコマンドを使ってクォータリミットやディスクの利用状況を確認することができます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> コマンドは個々のユーザやグループのクォータやディスク利用状況を確認するのに使えます。 ユーザは自身のクォータ、そして所属するグループのグループのみ確認することができます。 スーパーユーザのみが他のユーザや所属していないグループのクォータと利用状況を見ることができます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a> コマンドを使うと、クォータが有効になっているファイルシステム用の全てのクォータやディスク容量のサマリを得ることができます。</p></div><div class=paragraph><p>以下は二つのファイルシステムにクォータ制限がかけられているユーザに対する<code>quota -v</code> コマンドの出力例です。</p></div><div class="literalblock programlisting"><div class=content><pre>Disk quotas for user test (uid 1002):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</pre></div></div><div class=paragraph><p>上の例で、<span class=filename>/usr</span> ファイルシステム上ではこのユーザは現在 50 ブロックというソフトリミットを 15 ブロックオーバーし 5 日間の猶予期間が残っています。アスタリスク <code>*</code> はクォータリミットを越えているユーザを示していることに注意してください。</p></div><div class=paragraph><p>通常、そのユーザが全く使っていないファイルシステムは、 クォータリミットが付けられているとしても <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> コマンドの出力には現われません。 <code>-v</code> オプションを用いればそのようなファイルシステム、 上の例では <span class=filename>/usr/var</span>、 を表示することができます。</p></div></div><div class=sect3><h4 id=_nfs_上の_クォータ>14.12.4. NFS 上の クォータ<a class=anchor href=#_nfs_上の_クォータ></a></h4><div class=paragraph><p>クォータは NFS サーバ上のクォータサブシステムにより実行されます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.rquotad&amp;sektion=8&amp;format=html">rpc.rquotad(8)</a> デーモンにより、NFS クライアント上の <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> コマンドは情報を得ることができ、クライアントマシン上のユーザが自分のクォータの統計を見ることができます。</p></div><div class=paragraph><p><span class=filename>/etc/inetd.conf</span> において以下のように <code>rpc.rquotad</code> を有効にしましょう。</p></div><div class="literalblock programlisting"><div class=content><pre>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</pre></div></div><div class=paragraph><p>そして以下のように <code>inetd</code> を再起動します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/inetd.pid`</span></code></pre></div></div></div></div><div class=sect2><h3 id=disks-encrypting>14.13. ディスクパーティションの暗号化<a class=anchor href=#disks-encrypting></a></h3><div class=paragraph><p>FreeBSD は無許可のデータアクセスに対する優れたオンライン保護機能を提供します。 ファイルのパーミッションおよび強制的アクセスコントロール (MAC: Mandatory Access Control) (Mandatory Access Control (MAC) を参照) は、コンピュータが動作中で、OS が実行中であるときに、 無許可の第三者がデータにアクセスするのを防ぐことに役立ちます。 しかしながら、攻撃者がコンピュータに物理的にアクセスし、 機密データをコピーし分析するためにコンピュータのハードドライブを別のシステムに移動させることができれば、 OS によって強化された許可属性は意味をなさなくなります。</p></div><div class=paragraph><p>攻撃者が電源の落ちたコンピュータや ハードドライブを手にいれる手段にかかわらず、 GEOM ベースのディスク暗号化 (gbde: GEOM Based Disk Encryption) は、著しい資源を持ち本気で攻撃を仕掛けるつもりでやってきた攻撃者からさえもコンピュータのファイルシステム上にあるデータを保護することができます。 個々のファイルだけを暗号化する煩わしい方法と異なり、 gbde は全ファイルシステムを透過的に暗号化します。 平文テキストは決してハードドライブのプラッタに関係しません。</p></div><div class=sect3><h4 id=_カーネルで_gbde_を有効にする>14.13.1. カーネルで gbde を有効にする<a class=anchor href=#_カーネルで_gbde_を有効にする></a></h4><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><code>root</code> になる</p><div class=paragraph><p>gbde の設定をするにはスーパユーザの権限が必要になります。 以下のコマンドを実行して、 <code>root</code> になってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su -
Password:</code></pre></div></div></li><li><p>オペレーティングシステムのバージョンを確かめる</p><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> が動作するには FreeBSD 5.0 以降が必要です。 以下のコマンドを実行して、 オペレーティングシステムのバージョンを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># uname -r</span>
5.0-RELEASE</code></pre></div></div></li><li><p>カーネルコンフィギュレーションファイルに <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> 対応を追加する</p><div class=paragraph><p>お好みのテキストエディタを使用して、 以下の行をカーネルコンフィギュレーションファイルに加えます。</p></div><div class=paragraph><p><code>options GEOM_BDE</code></p></div><div class=paragraph><p>FreeBSD カーネルを設定、再コンパイル、インストールします。 この手順は <a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> で説明されています。</p></div><div class=paragraph><p>新しいカーネルで再起動します。</p></div></li></ol></div></div></div></div><div class=sect3><h4 id=_暗号化されたハードドライブの準備>14.13.2. 暗号化されたハードドライブの準備<a class=anchor href=#_暗号化されたハードドライブの準備></a></h4><div class=paragraph><p>以下の例では、システムに新しいハードディスクを追加しようとしています。このシステムは単一の暗号化されたパーティションを保持することになります。 このパーティションは <span class=filename>/private</span> としてマウントされます。gbde は <span class=filename>/home</span> および <span class=filename>/var/mail</span> を暗号化するのにも使用できますが、 より複雑な指示を必要となるのでこの解説の範疇を越えています。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>新しいハードドライブを追加する</p><div class=paragraph><p><a href=#disks-adding>ディスクの追加</a> で説明されている通りに新しいドライブをシステムに設置します。 この例では、新しいハードドライブは <span class=filename>/dev/ad4s1c</span> パーティションに 加えられたものとします。 <span class=filename>/dev/ad0s1*</span> デバイスは、この例のシステム上に存在する標準的な FreeBSD パーティションを表します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</code></pre></div></div></li><li><p>gbde ロックファイルを保持するディレクトリを作成する</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /etc/gbde</span></code></pre></div></div><div class=paragraph><p>gbde ロックファイルには、 暗号化されたパーティションにアクセスするのに必要となる情報が格納されています。 ロックファイルにアクセスしない場合、 gbde は 膨大な手動による介在なしには (ソフトウェアは対応していません)、暗号化されたパーティションに含まれるデータを解読することはできないでしょう。 それぞれの暗号化されたパーティションは別々のロックファイルを使用します。</p></div></li><li><p>gbde パーティションを初期化する</p><div class=paragraph><p>gbde パーティションは使用する前に初期化されなければなりません。 この初期化は一度だけ実行される必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c</span></code></pre></div></div><div class=paragraph><p>エディタが開くので、 テンプレートをもとにさまざまなオプションを設定してください。 UFS1 または UFS2 で使用するには、sector_size を 2048 に設定してください。</p></div><div class="literalblock programlisting"><div class=content><pre>$FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> はデータを保護するのに使用するパスフレーズを二度尋ます。 パスフレーズはそれぞれ同じでなければなりません。 データを保護する gbde の能力は、 あなたが選択したパスフレーズの品質に完全に依存します。</p></div><div class=paragraph><p><code>gbde init</code> コマンドは gbde パーティションに対するロックファイルを作成します。この例では <span class=filename>/etc/gbde/ad4s1c</span> に格納されます。</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>gbde ロックファイルは、 すべての暗号化されたパーティションの内容とともにバックアップされなければ <em>なりません</em>。 ロックファイルだけを削除している間、 ロックファイルなしでは信念の固い攻撃者が gbde パーティションを解読することを防ぐことができない一方で、 正当な所有者は、<a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> およびこの設計者にまったく支持されない膨大な量の作業なしには、 暗号化されたパーティション上のデータにアクセスすることができないでしょう。</p></div></td></tr></tbody></table></div></li><li><p>カーネルに暗号化されたパーティションを接続する</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</span></code></pre></div></div><div class=paragraph><p>暗号化されたパーティションを初期化する際に選択したパスフレーズを入力するように求められます。 新しい暗号化デバイスは <span class=filename>/dev</span> に <span class=filename>/dev/device_name.bde</span> として現れます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</code></pre></div></div></li><li><p>暗号化デバイス上にファイルシステムを作成する</p><div class=paragraph><p>カーネルに暗号化デバイスが接続されると、 デバイス上にファイルシステムを作成できます。 暗号化デバイス上にファイルシステムを作成するには <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> を使用します。従来の UFS1 ファイルシステムで初期化するより、 新しい UFS2 ファイルシステムで初期化した方が高速なので、 <code>-O2</code> オプションとともに <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> を使用することが推奨されています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.1-RELEASE 以降では、<code>-O2</code> オプションはデフォルトです。</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U -O2 /dev/ad4s1c.bde</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> は、デバイス名に <span class=filename>*.bde</span> 拡張子によって認識される、 接続された gbde パーティションに対して実行されなければなりません。</p></div></td></tr></tbody></table></div></li><li><p>暗号化パーティションをマウントする</p><div class=paragraph><p>暗号化ファイルシステムに対するマウントポイントを作成します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /private</span></code></pre></div></div><div class=paragraph><p>暗号化ファイルシステムをマウントします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div></li><li><p>暗号化ファイルシステムが利用可能か確かめる</p><div class=paragraph><p>これで暗号化ファイルシステムは <a href="https://man.freebsd.org/cgi/man.cgi?query=df&amp;sektion=1&amp;format=html">df(1)</a> で見ることができ、 利用する準備ができました。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>df</span> <span class=nt>-H</span>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=_存在する暗号化ファイルシステムをマウントする>14.13.3. 存在する暗号化ファイルシステムをマウントする<a class=anchor href=#_存在する暗号化ファイルシステムをマウントする></a></h4><div class=paragraph><p>システムを起動する度に、すべての暗号化ファイルシステムは 使用前にカーネルに接続し、 エラーの有無をチェックし、マウントする必要があります。 必要なコマンドは <code>root</code> ユーザとして実行されなければなりません。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>カーネルに gbde パーティションを接続する</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</span></code></pre></div></div><div class=paragraph><p>パーティションの暗号化を初期化する際に選択したパスフレーズを入力するように求められるでしょう。</p></div></li><li><p>ファイルシステムのエラーをチェックする</p><div class=paragraph><p>暗号化ファイルシステムを自動的にマウントするために <span class=filename>/etc/fstab</span> に設定を掲載することはまだできないため、 マウントする前に <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> を実行して、 ファイルシステムのエラーをチェックしなければなりません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -p -t ffs /dev/ad4s1c.bde</span></code></pre></div></div></li><li><p>暗号化ファイルをマウントする</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div><div class=paragraph><p>これで暗号化ファイルシステムが利用できるようになりました。</p></div></li></ol></div></div></div><div class=sect4><h5 id=_暗号化パーティションを自動的にマウントする>14.13.3.1. 暗号化パーティションを自動的にマウントする<a class=anchor href=#_暗号化パーティションを自動的にマウントする></a></h5><div class=paragraph><p>スクリプトを作成して、暗号化パーティションを自動的に接続、 チェック、マウントすることは可能です。しかしながら、 安全上の理由によりスクリプトに <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> パスワードを含めるべきではありません。その代わりに、コンソールまたは <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> による接続からパスワードを入力するようなスクリプトが手動で実行されることが推奨されます。</p></div></div></div><div class=sect3><h4 id=_gbde_が採用した暗号の保護>14.13.4. gbde が採用した暗号の保護<a class=anchor href=#_gbde_が採用した暗号の保護></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> は 128bit AES の CBC モードを使用してセクタペイロードを暗号化します。 ディスク上のそれぞれのセクタは異なる AES 鍵で暗号化されます。 セクタ鍵がユーザが入力したパスフレーズからどのように導き出されるかを含め、 gbde の暗号手法の設計についての詳細は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> を参照してください。</p></div></div><div class=sect3><h4 id=_互換性に関する問題>14.13.5. 互換性に関する問題<a class=anchor href=#_互換性に関する問題></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> は gbde 暗号化デバイスと互換性がありません。 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> を実行する前に <span class=filename>*.bde</span> デバイスはすべてカーネルから切断されなければなりません。 そうしないと、<a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> が初めにデバイスを走査する際にクラッシュしてしまうでしょう。 暗号化デバイスを切断するには、以下のコマンドを使用します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde detach /dev/ad4s1c</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=l10n>Chapter 15. 地域化 (localization) - i18n/L10n の利用と設定<a class=anchor href=#l10n></a></h2><div class=sectionbody><div class=sect2><h3 id=l10n-synopsis>15.1. この章では<a class=anchor href=#l10n-synopsis></a></h3><div class=paragraph><p>FreeBSD は、 ユーザーおよび貢献者が世界中に分散したプロジェクトです。 そのため、FreeBSD は多くの言語への地域化に対応しており、 ユーザは、英語以外の言語を見たり、入力したり、処理したりできます。 中国語、ドイツ語、日本語、韓国語、フランス語、ロシア語、 ベトナム語など、主要な言語のほとんどから選ぶことができますが、 これらに限定されるわけではありません。</p></div><div class=paragraph><p>internationalization は、i18n と短縮して表記されます。 これは <code>internationalization</code> の最初と最後の間の文字数に由来します。 L10n も同じ命名法を用いて <code>localization</code> を縮めたものです。 i18n/L10n された (すなわち国際化/地域化された) 手法、プロトコル、アプリケーションは、 自分達の好みの言語を使うことを可能にしてくれます。</p></div><div class=paragraph><p>この章では、FreeBSD の国際化 (internationalization) と地域化 (localization) 機能について解説します。 この章では、以下の分野について説明します。</p></div><div class=ulist><ul><li><p>ロケール名がどのように定義されるか。</p></li><li><p>ログインシェルでロケールを設定するにはどうするか。</p></li><li><p>コンソールを英語以外の言語用に設定するにはどうするか。</p></li><li><p>様々な言語で Xorg を設定するにはどうすればよいか。</p></li><li><p>国際化 (i18n) されたアプリケーションの見つけ方。</p></li><li><p>特定の言語に設定するための情報はどこにあるか。</p></li></ul></div><div class=paragraph><p>この章を読む前に、以下のことを理解しておく必要があります。</p></div><div class=ulist><ul><li><p><a href=./#ports>サードパーティ製アプリケーションのインストール方法</a></p></li></ul></div></div><div class=sect2><h3 id=using-localization>15.2. 地域化の利用<a class=anchor href=#using-localization></a></h3><div class=paragraph><p>地域化の設定は、言語コード、 国コード、エンコーディングという三つの要素を基本とします。 ロケール名はこれらから以下のように構成されます。</p></div><div class="literalblock programlisting"><div class=content><pre>言語コード_国コード.エンコーディング</pre></div></div><div class=paragraph><p><em>言語コード</em> および <em>国コード</em> は、 国と言語を特定するために用いられます。 <a href=#locale-lang-country>言語および国コード</a> では、 <em>言語コード___国コード</em> の例を示します</p></div><table id=locale-lang-country class="tableblock frame-none grid-all stretch"><caption class=title>表 13. 言語および国コード</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">言語_国コード</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>en_US</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>英語、合衆国</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ru_RU</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ロシア語、ロシア</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>zh_TW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>繁体字中国語、台湾</p></td></tr></tbody></table><div class=paragraph><p>利用可能なすべてのロケールを調べるには、 以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% locale <span class=nt>-a</span> | more</code></pre></div></div><div class=paragraph><p>現在のロケールの設定を調べるには、 以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% locale</code></pre></div></div><div class=paragraph><p>言語固有の、C 言語の char で表現できる ISO8859-1, ISO8859-15, KOI8-R, CP437 といったシングルバイトの文字セットについては、 <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a> を参照してください。 現在有効な文字セットのリストは、<a href=http://www.iana.org/assignments/character-sets>IANA Registry</a> で確認できます。</p></div><div class=paragraph><p>いくつかの言語 (例えば中国語や日本語) は、 ASCII 文字では表すことができないので、 ワイド文字や多バイト文字を用いた拡張された言語のエンコードが必要となります。 ワイド/多バイトのエンコーディングの例は、EUC および Big5 です。 古いアプリケーションの中には、 これらのエンコードを誤ってコントロール文字として認識するものがありますが、 最近のアプリケーションは、大抵これらの文字を認識します。 実装方法にも依りますが、アプリケーションのコンパイル時もしくは configure 時に、ワイド/多バイト文字のサポートを指定する必要があるかも知れません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD では、Xorg 互換のロケール符号を用いています。</p></div></td></tr></tbody></table></div><div class=paragraph><p>以下では、FreeBSD システムにおいてロケールを設定する方法について説明します。 次の節では、i18n に対応するアプリケーションの見つけ方およびコンパイル方法について説明します。</p></div><div class=sect3><h4 id=setting-locale>15.2.1. ログインシェルでロケールを設定する<a class=anchor href=#setting-locale></a></h4><div class=paragraph><p>ロケールの設定は、ユーザの <span class=filename>~/.login_conf</span>、 またはユーザのシェルの初期設定ファイルである <span class=filename>~/.profile</span>, <span class=filename>~/.bashrc</span> または <span class=filename>~/.cshrc</span> で行います。</p></div><div class=paragraph><p>以下の二つの環境変数を設定する必要があります。</p></div><div class=ulist><ul><li><p><code>LANG</code>: ロケールを設定します。</p></li><li><p><code>MM_CHARSET</code>: アプリケーションで使用される MIME 文字セットを指定します。</p></li></ul></div><div class=paragraph><p>これらの変数は、ユーザのシェルの設定ファイルに加え、 アプリケーション固有の設定ファイル、 および Xorg の設定ファイルにおいても指定される必要があります。</p></div><div class=paragraph><p>必要な変数を割り当てるには、二つの方法があります。 <a href=#login-class>ログインクラス</a> において割り当てる方法 (推奨される方法です)、および <a href=#startup-file>初期化ファイル</a> で指定する方法です。 次の 2 つの節では、この両方の方法について説明します。</p></div><div class=sect4><h5 id=login-class>15.2.1.1. ログインクラスを用いる方法<a class=anchor href=#login-class></a></h5><div class=paragraph><p>最初に説明する方法は、 すべてのシェルにおいて必要なロケール名と MIME 文字セットを環境変数に割り当てます。 これは推奨される方法です。 この割り当て方法としては、各ユーザが行う方法と、 スーパーユーザがすべてのユーザに対して設定する 2 つの方法があります。</p></div><div class=paragraph><p>以下の簡単な例では、 各ユーザのホームディレクトリの <span class=filename>.login_conf</span> で、両方の変数に Latin-1 エンコーディングを設定します。</p></div><div class="literalblock programlisting"><div class=content><pre>me:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:</pre></div></div><div class=paragraph><p>これは、BIG-5 エンコーディングされた繁体字中国語用の環境変数を設定するユーザの <span class=filename>~/.login_conf</span> の一例です。 中国語、日本語、 韓国語用のロケール変数を正しく認識しないソフトウェアに対応するため、 より多くの変数に対する設定が行われています。</p></div><div class="literalblock programlisting"><div class=content><pre>#Users who do not wish to use monetary units or time formats
#of Taiwan can manually change each variable
me:\
	:lang=zh_TW.Big5:\
	:setenv=LC_ALL=zh_TW.Big5,LC_COLLATE=zh_TW.Big5,LC_CTYPE=zh_TW.Big5,LC_MESSAGES=zh_TW.Big5,LC_MONETARY=zh_TW.Big5,LC_NUMERIC=zh_TW.Big5,LC_TIME=zh_TW.Big5:\
	:charset=big5:\
	:xmodifiers=&#34;@im=gcin&#34;: #Set gcin as the XIM Input Server</pre></div></div><div class=paragraph><p>もう一つの方法では、 スーパーユーザがシステム上のすべてのユーザに対する地域化を設定します。 <span class=filename>/etc/login.conf</span> の以下の変数により、ロケールおよび MIME 文字セットを設定します。</p></div><div class="literalblock programlisting"><div class=content><pre>language_name|Account Type Description:\
	:charset=MIME_charset:\
	:lang=locale_name:\
	:tc=default:</pre></div></div><div class=paragraph><p>よって、先ほどの例における Latin-1 に対する設定は、 以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>german|German Users Accounts:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:\
	:tc=default:</pre></div></div><div class=paragraph><p>詳細に関しては <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> を参照してください。 なお、<em>russian</em> クラスはあらかじめ定義されています。</p></div><div class=paragraph><p><span class=filename>/etc/login.conf</span> を編集したら、 忘れずに以下のコマンドを実行してケイパビリティデータベースをアップデートしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>エンドユーザは、変更を反映させるために、各自の <span class=filename>~/.login_conf</span> に対して <code>cap_mkdb</code> コマンドを実行する必要があります。</p></div></td></tr></tbody></table></div><div class=sect5><h6 id=_ログインクラスを変更するユーティリティ>15.2.1.1.1. ログインクラスを変更するユーティリティ<a class=anchor href=#_ログインクラスを変更するユーティリティ></a></h6><div class=paragraph><p><span class=filename>/etc/login.conf</span> を手動により編集する方法に加え、 新たに作成するユーザのロケールを設定するためのユーティリティがあります。</p></div><div class=paragraph><p><code>vipw</code> を使って新しいユーザを追加する際には、使用する言語を <em>language</em> に指定してください。</p></div><div class="literalblock programlisting"><div class=content><pre>user:password:1111:11:language:0:0:User Name:/home/user:/bin/sh</pre></div></div><div class=paragraph><p><code>adduser</code> を使って新しいユーザを追加する場合に、 すべてのユーザに対するデフォルトの言語は事前に設定でき、 個々のユーザに対する言語を指定できます。</p></div><div class=paragraph><p>新しく追加するすべてのユーザが同じ言語を使う場合には、 <span class=filename>/etc/adduser.conf</span> で <code>defaultclass=<em>language</em></code> と設定してください。</p></div><div class=paragraph><p>新しいユーザを作成するときに、この設定を変更するには、 以下のプロンプトにおいて希望するロケールを指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter login class: default <span class=o>[]</span>:</code></pre></div></div><div class=paragraph><p>もしくは、<code>adduser</code> を実行する際にロケールを指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser -class language</span></code></pre></div></div><div class=paragraph><p><code>pw</code> を使って新しいユーザを追加する場合には、 以下のようにしてロケールを指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd user_name -L language</span></code></pre></div></div><div class=paragraph><p>すでに存在するユーザのログインクラスを変更するには、 <code>chpass</code> を使用してください。 引数として変更するユーザ名を与えて、 スーパーユーザの権限で実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chpass user_name</span></code></pre></div></div></div></div><div class=sect4><h5 id=startup-file>15.2.1.2. シェルの初期化ファイルによる方法<a class=anchor href=#startup-file></a></h5><div class=paragraph><p>この 2 番目の方法は、 使用するシェルごとに手動での設定が必要なため、推奨されません。 シェル毎に設定ファイルが存在し、その構文はシェルに依存します。 たとえば、<code>sh</code> シェルに対するドイツ語の設定では、 そのユーザのシェルを設定するためだけに、 <span class=filename>~/.profile</span> に以下の行を追加ます。 これらの行を <span class=filename>/etc/profile</span> または、 <span class=filename>/usr/share/skel/dot.profile</span> に追加すると、 すべてのユーザのシェルを設定することが可能です。</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG
MM_CHARSET=ISO-8859-1; export MM_CHARSET</pre></div></div><div class=paragraph><p>しかしながら、<code>csh</code> シェルでは、 設定ファイルの名前や構文は異なります。 <span class=filename>~/.login</span>, <span class=filename>/etc/csh.login</span> または <span class=filename>/usr/share/skel/dot.login</span> では同じ設定です。</p></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1
setenv MM_CHARSET ISO-8859-1</pre></div></div><div class=paragraph><p>さらに面倒なことに、 Xorg を設定するための <span class=filename>~/.xinitrc</span> における構文は、 使用しているシェルに依存します。 以下の例において、最初は <code>sh</code> シェルに対するもので、2 番目が <code>csh</code> シェルに対するものです。</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG</pre></div></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1</pre></div></div></div></div><div class=sect3><h4 id=setting-console>15.2.2. コンソールの設定<a class=anchor href=#setting-console></a></h4><div class=paragraph><p>コンソールで利用可能な地域化されたフォントがあります。 利用できるフォントの一覧を調べるには、 <code>ls /usr/share/syscons/fonts</code> と入力してください。 コンソールのフォントを設定するには、 <span class=filename>.fnt</span> という拡張子を除いた <em>フォント名</em> を、 <span class=filename>/etc/rc.conf</span> に設定してください。</p></div><div class="literalblock programlisting"><div class=content><pre>font8x16=フォント名
font8x14=フォント名
font8x8=フォント名</pre></div></div><div class=paragraph><p>以下を <span class=filename>/etc/rc.conf</span> に追加することで、 キーマップおよびスクリーンマップを指定できます。</p></div><div class="literalblock programlisting"><div class=content><pre>scrnmap=スクリーンマップ名
keymap=キーマップ名
keychange=&#34;ファンクションキー番号の並び&#34;</pre></div></div><div class=paragraph><p>利用可能なスクリーンマップの一覧を調べるには、 <code>ls /usr/share/syscons/scrnmaps</code> と入力してください。 <span class=filename>/etc/rc.conf</span> で <em>スクリーンマップ名</em> を指定する時は、 <span class=filename>.csm</span> という拡張子を除いてください。 スクリーンフォントが bit 8 列を使っている時に文字を疑似グラフィクス領域から外に移動するように、 VGA アダプタがフォント文字マトリクスで bit 8 を bit 9 に拡張することに対処するため、 フォントに適切にマップされたスクリーンマップが必要となります。</p></div><div class=paragraph><p>利用可能なキーマップの一覧を調べるには、 <code>ls /usr/share/syscons/keymaps</code> と入力してください。 <span class=filename>/etc/rc.conf</span> で <em>キーマップ名</em> を指定する時には、 <span class=filename>.kbd</span> という拡張子を除いてください。 再起動せずにキーマップを試すには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdmap&amp;sektion=1&amp;format=html">kbdmap(1)</a> を使ってください。</p></div><div class=paragraph><p>ファンクションキーの並びはキーマップで定義されていないので、 端末タイプに合わせたファンクションキーを設定するために <code>keychange</code> のエントリが必要となります。</p></div><div class=paragraph><p>次に <span class=filename>/etc/ttys</span> の中のすべての仮想端末のエントリに対して、 正しいコンソール端末タイプを設定してください。<a href=#locale-charset>文字セットに対する定義済みの端末タイプ</a> は、 利用可能な端末タイプの一覧です。</p></div><table id=locale-charset class="tableblock frame-none grid-all stretch"><caption class=title>表 14. 文字セットに対する定義済みの端末タイプ</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">文字セット</th><th class="tableblock halign-left valign-top">端末タイプ</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-1 もしくは ISO8859-15</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l7</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-R</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25r</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25u</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CP437 (VGA のデフォルト)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>US-ASCII</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25w</code></p></td></tr></tbody></table><div class=paragraph><p>ワイド/多バイト文字の言語については、 その言語に対するコンソールを FreeBSD Ports Collection からインストールしてください。 利用可能な ports は、<a href=#locale-console>Ports Collection で利用可能なコンソール</a> にまとめてあります。 インストール後、各 port の <span class=filename>pkg-message</span> または、マニュアルページを参照して、 設定や使用方法を調べてください。</p></div><table id=locale-console class="tableblock frame-none grid-all stretch"><caption class=title>表 15. Ports Collection で利用可能なコンソール</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">言語</th><th class="tableblock halign-left valign-top">port の位置</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>繁体字中国語 (BIG-5)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/big5con/>chinese/big5con</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中国語/日本語/韓国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/cce/>chinese/cce</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中国語/日本語/韓国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/zhcon/>chinese/zhcon</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/kon2/>chinese/kon2</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-14dot/>japanese/kon2-14dot</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-16dot/>japanese/kon2-16dot</a></p></td></tr></tbody></table><div class=paragraph><p><span class=filename>/etc/rc.conf</span> において moused を有効にしている場合には、 追加の設定が必要となるでしょう。 デフォルトでは、<a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> ドライバのマウスカーソルはキャラクタセット中の <code>0xd0</code>-<code>0xd3</code> の範囲を占めています。そのため、 利用している言語がこの範囲のキャラクタセットを使っている場合、 次の行を <span class=filename>/etc/rc.conf</span> に追加して カーソルの占める範囲を移動してください。</p></div><div class="literalblock programlisting"><div class=content><pre>mousechar_start=3</pre></div></div></div><div class=sect3><h4 id=_xorg_の設定>15.2.3. Xorg の設定<a class=anchor href=#_xorg_の設定></a></h4><div class=paragraph><p>Xorg のインストールおよび設定方法は、 <a href=./#x11>X Window System</a> で説明されています。 Xorg を地域化するための追加のフォントおよび入力方法は、 FreeBSD Ports Collection から利用できます。 フォント、メニューなどのアプリケーション固有の国際化 (i18n) の設定は、 <span class=filename>~/.Xresources</span> において指定でき、 グラフィカルアプリケーションのメニューが選んだ言語で表示されます。</p></div><div class=paragraph><p>X Input Method (XIM) プロトコルは、Xorg で非英字文字を入力するための標準規格です。 FreeBSD Ports Collection から利用可能なインプットメソッドについては、 <a href=#locale-xim>利用可能なインプットメソッド</a> にまとめられています。 追加の Fcitx および Uim アプリケーションも利用できます。</p></div><table id=locale-xim class="tableblock frame-none grid-all stretch"><caption class=title>表 16. 利用可能なインプットメソッド</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">言語</th><th class="tableblock halign-left valign-top">インプットメソッド</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/gcin/>chinese/gcin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/ibus-chewing/>chinese/ibus-chewing</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/ibus-pinyin/>chinese/ibus-pinyin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/oxim/>chinese/oxim</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-fcitx/>chinese/scim-fcitx</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-pinyin/>chinese/scim-pinyin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>中国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-tables/>chinese/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-anthy/>japanese/ibus-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-mozc/>japanese/ibus-mozc</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-skk/>japanese/ibus-skk</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/im-ja/>japanese/im-ja</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kinput2/>japanese/kinput2</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-anthy/>japanese/scim-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-canna/>japanese/scim-canna</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka/>japanese/scim-honoka</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka-plugin-romkan/>japanese/scim-honoka-plugin-romkan</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka-plugin-wnn/>japanese/scim-honoka-plugin-wnn</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-prime/>japanese/scim-prime</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-skk/>japanese/scim-skk</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-tables/>japanese/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-tomoe/>japanese/scim-tomoe</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-uim/>japanese/scim-uim</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/skkinput/>japanese/skkinput</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/skkinput3/>japanese/skkinput3</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/uim-anthy/>japanese/uim-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/ibus-hangul/>korean/ibus-hangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/imhangul/>korean/imhangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/nabi/>korean/nabi</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/scim-hangul/>korean/scim-hangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓国語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/scim-tables/>korean/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ベトナム語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/vietnamese/xvnkb/>vietnamese/xvnkb</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ベトナム語</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/vietnamese/x-unikey/>vietnamese/x-unikey</a></p></td></tr></tbody></table></div></div><div class=sect2><h3 id=l10n-compiling>15.3. 国際化 (i18n) に対応したアプリケーションを見つける<a class=anchor href=#l10n-compiling></a></h3><div class=paragraph><p>国際化 (i18n) されたアプリケーションは、ライブラリとして i18n 化キットを用いてプログラミングされます。 これは開発者が単純なファイルを書いて、 表示されるメニューやテキストを各国語に翻訳できるようにしてくれます。</p></div><div class=paragraph><p><a href=https://www.FreeBSD.org/ja/ports/>FreeBSD Ports Collection </a>の多くのアプリケーションは、 いくつかの言語向けのワイド/多バイト文字への対応を組み込んでいます。 そのようなアプリケーションの名前には、 容易に認識できるように、<code>-i18n</code> と付いています。しかしながら、 それらのアプリケーションが必要とする言語に対応しているとは限りません。</p></div><div class=paragraph><p>いくつかのアプリケーションでは、 特定の文字セットを使うようにコンパイルできます。 これは大抵 <span class=filename>Makefile</span> の中で 対処されているか、configure に値を渡すことで対応しています。 必要な configure の値や port の構築時に使用するコンパイルオプションを決めるための port の <span class=filename>Makefile</span> に関するより詳細な情報については、 各 FreeBSD port のソースにある i18n 文書を参照してください。</p></div></div><div class=sect2><h3 id=lang-setup>15.4. 特定の言語にロケールを設定する<a class=anchor href=#lang-setup></a></h3><div class=paragraph><p>この節では、FreeBSD システムをロシア語へ地域化するための設定例を示します。 後半では、他の言語への地域化に関する情報を提供します。</p></div><div class=sect3><h4 id=ru-localize>15.4.1. ロシア語 (KOI8-R エンコーディング)<a class=anchor href=#ru-localize></a></h4><div class=paragraph><p>この節では、FreeBSD システムをロシア語へ地域化するための設定例を示します。 各設定に関するより詳しい説明については、 <a href=#using-localization>地域化の利用</a> を参照してください。</p></div><div class=paragraph><p>このロケールをログインシェルに設定するには、 以下の行を各ユーザの <span class=filename>~/.login_conf</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>me:My Account:\
	:charset=KOI8-R:\
	:lang=ru_RU.KOI8-R:</pre></div></div><div class=paragraph><p>コンソールを設定するには、 <span class=filename>/etc/rc.conf</span> に以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>keymap=&#34;ru.utf-8&#34;
scrnmap=&#34;utf-82cp866&#34;
font8x16=&#34;cp866b-8x16&#34;
font8x14=&#34;cp866-8x14&#34;
font8x8=&#34;cp866-8x8&#34;
mousechar_start=3</pre></div></div><div class=paragraph><p><span class=filename>/etc/ttys</span> の各 <code>ttyv</code> エントリにおいて、 端末タイプとして <code>cons25r</code> を指定してください。</p></div><div class=paragraph><p>プリンタの設定を行うには、 ロシア語用の文字を搭載したほとんどのプリンタはハードウェアコードページ CP866 を使っているため、KOI8-R を CP866 に変換する専用の出力フィルタが必要となります。 この目的のため、FreeBSD はデフォルトフィルタを <span class=filename>/usr/libexec/lpr/ru/koi2alt</span> にインストールします。 このフィルタを使うには、<span class=filename>/etc/printcap</span> に以下のエントリを追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>lp|Russian local line printer:\
	:sh:of=/usr/libexec/lpr/ru/koi2alt:\
	:lp=/dev/lpt0:sd=/var/spool/output/lpd:lf=/var/log/lpd-errs:</pre></div></div><div class=paragraph><p>より詳細な説明については <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> を参照してください。</p></div><div class=paragraph><p>マウントされた MS-DOS® ファイルシステムにおいてロシア語ファイル名を使えるように設定するには、 <span class=filename>/etc/fstab</span> にエントリを追加するときに、 以下のように <code>-L</code> とロケール名を含めてください。</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ad0s2      /dos/c  msdos   rw,-Lru_RU.KOI8-R 0 0</pre></div></div><div class=paragraph><p>詳しくは、<a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> を参照してください。</p></div><div class=paragraph><p>Xorg にロシア語のフォントを設定するには、 <a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/xorg-fonts-cyrillic/>x11-fonts/xorg-fonts-cyrillic</a> パッケージをインストールしてください。 その後、<span class=filename>/etc/X11/xorg.conf</span> の <code>"Files"</code> セクションを確認してください。 既存の <code>FontPath</code> エントリの_前に_以下の行を追加しなければなりません。</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath   &#34;/usr/local/lib/X11/fonts/cyrillic&#34;</pre></div></div><div class=paragraph><p>他の Cyrillic フォントは、 Ports Collection から利用できます。</p></div><div class=paragraph><p>ロシア語のキーボードを使えるようにするには、 以下の行を <span class=filename>xorg.conf</span> の <code>"Keyboard"</code> セクションに追加します。</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbLayout&#34;   &#34;us,ru&#34;
Option &#34;XkbOptions&#34;  &#34;grp:toggle&#34;</pre></div></div><div class=paragraph><p>このファイルの中で <code>XkbDisable</code> がコメントアウトされていることを確認してください。</p></div><div class=paragraph><p><code>grp:toggle</code> では <kbd>Right Alt</kbd> を使い、 <code>grp:ctrl_shift_toggle</code> では <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Shift</kbd></span> を使います。 <code>grp:caps_toggle</code> では、 <kbd>CapsLock</kbd> を使います。 従来の <kbd>CapsLock</kbd> の機能は、 ラテン文字モードの時のみ <span class=keyseq><kbd>Shift</kbd>+<kbd>CapsLock</kbd></span> で使うことができます。 Xorg では、理由は不明ですが <code>grp:caps_toggle</code> は動作しません。</p></div><div class=paragraph><p>キーボードに "Windows®" キーがあり、 そのキーにいくつかの非英字キーが割り当てられているようなら、 <span class=filename>xorg.conf</span> に以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbVariant&#34; &#34;,winkeys&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ロシア語の XKB キーボードは、 地域化されていないアプリケーションではうまく動かないかも知れません。 地域化されたアプリケーションは少なくともプログラムの最初の方で <code>XtSetLanguageProc (NULL, NULL, NULL);</code> を呼び出すべきです。</p></div></td></tr></tbody></table></div><div class=paragraph><p>Xorg アプリケーションを地域化する方法については、<a href=http://koi8.pp.ru/xwin.html>http://koi8.pp.ru/xwin.html</a> を参照してください。 KOI8-R エンコーディングの詳細については、<a href=http://koi8.pp.ru/>http://koi8.pp.ru/</a> を参照してください。</p></div></div><div class=sect3><h4 id=_言語固有のリソース>15.4.2. 言語固有のリソース<a class=anchor href=#_言語固有のリソース></a></h4><div class=paragraph><p>この節では、 他言語へのロケールの設定に関するリソースの一覧を示します。</p></div><div class=dlist><dl><dt class=hdlist1>台湾向けの繁体字中国語への地域化</dt><dd><p>FreeBSD-Taiwan プロジェクトは、 FreeBSD を中国語化するための手引き <a href=http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/>http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/</a> を提供しています。</p></dd><dt class=hdlist1>ギリシャ語への地域化</dt><dd><p>FreeBSD におけるギリシャ語のサポートについての記事は、 公式の FreeBSD ギリシャ語ドキュメンテーションの一部として <a href=https://docs.FreeBSD.org/el/articles/greek-language-support/>ここ</a> で読むことができます。 この文書は、ギリシャ語で書かれています。</p></dd><dt class=hdlist1>日本語/韓国語への地域化</dt><dd><p>日本語に関しては <a href=http://www.jp.FreeBSD.org/>http://www.jp.FreeBSD.org/</a> を、韓国語に関しては <a href=http://www.kr.FreeBSD.org/>http://www.kr.FreeBSD.org/</a> を参照してください。</p></dd><dt class=hdlist1>英語以外の FreeBSD ドキュメント</dt><dd><p>FreeBSD の文書の一部を他の言語に翻訳してくれている貢献者たちがいます。 これらは <a href=https://www.FreeBSD.org/ja/>FreeBSD ウェブサイト</a> のリンクを辿るか <span class=filename>/usr/share/doc</span> から入手できます。</p></dd></dl></div></div></div></div></div><div class=sect1><h2 id=updating-upgrading>Chapter 16. FreeBSD のアップデートとアップグレード<a class=anchor href=#updating-upgrading></a></h2><div class=sectionbody><div class=sect2><h3 id=updating-upgrading-synopsis>16.1. この章では<a class=anchor href=#updating-upgrading-synopsis></a></h3><div class=paragraph><p>あるリリースから次のリリースまでの期間にも、 FreeBSD の開発は休みなく続けられています。
最新の開発ツリーと同期することを好む人がいる一方で、公式のリリース版を好んで使う方もいます。
しかしながら、公式のリリースといえども、 セキュリティや他の重要な修正のため、時にはアップデートが必要となります。
FreeBSD は手元のシステムを最新の開発ツリーと同期するために必要なツールをすべて用意しているので、使用しているバージョンに関わらず、これらのツールを使って簡単にシステムのバージョンをアップグレードできます。
この章では、開発ブランチを追いかける方法、および、FreeBSD システムをアップデートする基本的なツールについて解説します。</p></div><div class=paragraph><p>この章では以下について説明します。</p></div><div class=ulist><ul><li><p>freebsd-update もしくは Git を使った FreeBSD システムの更新方法</p></li><li><p>インストールされているシステムと、変更が行われていない状態との比較方法</p></li><li><p>Git またはドキュメント用の ports を使って、 インストールされているドキュメントを最新版にアップデートする方法</p></li><li><p>2 つの開発ブランチ、FreeBSD-STABLE と FreeBSD-CURRENT の違いについて</p></li><li><p>ベースシステム全体を再構築しインストールする方法</p></li></ul></div><div class=paragraph><p>この章を読む前に、以下の準備をしましょう。</p></div><div class=ulist><ul><li><p>ネットワーク接続の適切な設定 (<a href=./#advanced-networking>高度なネットワーク</a>)</p></li><li><p>サードパーティ製のソフトウェアのインストール方法の習得 (<a href=./#ports>アプリケーションのインストール - packages と ports</a>)</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この章を通じて、FreeBSD のソースコードのダウンロードやアップデートに <code>git</code> が使われています。
必要に応じて <a class=package href=https://cgit.freebsd.org/ports/tree/devel/git/>devel/git</a> port または package が使われることもあります。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=updating-upgrading-freebsdupdate>16.2. FreeBSD Update<a class=anchor href=#updating-upgrading-freebsdupdate></a></h3><div class=paragraph><p>すみやかにセキュリティパッチを適用し、 オペレーティングシステムをアップグレードして、 最新のリリースに保つことは、システム管理における重要な側面です。
これらの処理を行うために FreeBSD には <code>freebsd-update</code> と呼ばれるユーティリティが用意されています。</p></div><div class=paragraph><p>このユーティリティを用いると、FreeBSD のセキュリティおよび eratta アップデートをバイナリによって行うことができます。
手動でパッチもしくは新しいカーネルをコンパイルし、インストールする必要はありません。
バイナリアップデートは、セキュリティチームがサポートしているすべてのアーキテクチャとリリースで利用できます。
<a href=https://www.FreeBSD.org/ja/security/>https://www.FreeBSD.org/ja/security/</a> には、サポートが行われているリリースや保守終了予定日の一覧があります。</p></div><div class=paragraph><p>このユーティリティは、マイナーリリースであったり、他のリリースブランチへのアップグレードにも対応しています。
新しいリリースにアップデートする前に、アップデートしようとしているリリースのアナウンスに目を通し、重要な情報がないかどうかを確認してください。
リリースのアナウンスは <a href=https://www.FreeBSD.org/ja/releases/>https://www.FreeBSD.org/ja/releases/</a> で確認できます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>もし <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> の中に <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> の機能が含まれていたら、 オペレーティングシステムのアップグレード作業を終えるまでは無効にしてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この節では、<code>freebsd-update</code> で使われる設定ファイルの説明、 セキュリティパッチの適応方法のデモンストレーション、 オペレーティングシステムをアップグレードする際に考慮すべき点について説明します。</p></div><div class=sect3><h4 id=freebsdupdate-config-file>16.2.1. 設定ファイル<a class=anchor href=#freebsdupdate-config-file></a></h4><div class=paragraph><p><code>freebsd-update</code> のデフォルトの設定ファイルは、そのままでも用いることができます。
<span class=filename>/etc/freebsd-update.conf</span> の設定をデフォルトからきめ細かく調整して、 アップデートプロセスを制御するユーザもいます。
利用可能なオプションについてはこのファイルのコメントで説明されていますが、以下の項目については補足が必要でしょう。</p></div><div class="literalblock programlisting"><div class=content><pre># Components of the base system which should be kept updated.
Components world kernel</pre></div></div><div class=paragraph><p>このパラメータは、FreeBSD のどの部分を最新に維持するかを設定します。
デフォルトでは、ベースシステム全体、そしてカーネルをアップデートします。
<code>src/base</code> や <code>src/sys</code> のように、個々の項目を指定することもできます。
この部分についてはデフォルトのままにしておき、アップデートする項目をユーザがリストに加える形にするのがベストでしょう。
ソースコードとバイナリが同期していないと、長い年月の間に悲惨な結果がもたらされる可能性があります。</p></div><div class="literalblock programlisting"><div class=content><pre># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths /boot/kernel/linker.hints</pre></div></div><div class=paragraph><p><span class=filename>/bin</span> や <span class=filename>/sbin</span> 等の特定のディレクトリをアップデートで変更しないように、これらのパスを追加してください。
このオプションは、ローカルの変更点を <code>freebsd-update</code> が上書きすることを防ぐ目的にも利用できます。</p></div><div class="literalblock programlisting"><div class=content><pre># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</pre></div></div><div class=paragraph><p>このオプションは、指定したディレクトリにある設定ファイルを、ローカルで変更されていない場合のみアップデートします。
ユーザがこれらのファイルを変更していると、変更されたファイルの自動アップデートは行われません。
他に、<code>KeepModifiedMetadata</code> という別のオプションが存在します。
このオプションは、<code>freebsd-update</code> がマージ中に変更点を保存するようにします。</p></div><div class="literalblock programlisting"><div class=content><pre># When upgrading to a new FreeBSD release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints</pre></div></div><div class=paragraph><p><code>freebsd-update</code> がマージすべきファイルが存在するディレクトリの一覧です。
ファイルのマージのプロセスは、<a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> と同様 <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> パッチの連続ですが、選択肢は少なく、マージを承認するか、エディタを起動するか、<code>freebsd-update</code> を中断するかどうかを選んでください。
もし、心配な点があれば、<span class=filename>/etc</span> をバックアップしてからマージを承認してください。
<code>mergemaster</code> の詳細な情報については、<a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> で確認してください。</p></div><div class="literalblock programlisting"><div class=content><pre># Directory in which to store downloaded updates and temporary
# files used by FreeBSD Update.
# WorkDir /var/db/freebsd-update</pre></div></div><div class=paragraph><p>ここではすべてのパッチや一次ファイルを置くディレクトリを指定しています。
バージョンをアップグレードするのであれば、この場所には少なくともギガバイトの空き容量が必要です。</p></div><div class="literalblock programlisting"><div class=content><pre># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which FreeBSD Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</pre></div></div><div class=paragraph><p>このオプションを <code>yes</code> に設定すると、<code>freebsd-update</code> は <code>Components</code> のリストが完全に正しいと判断し、このリスト以外の変更点については取り扱いません。
<code>freebsd-update</code> は、効率的に <code>Components</code> リストに属するファイルをアップデートします。</p></div><div class=paragraph><p>詳細については、<a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update.conf&amp;sektion=5&amp;format=html">freebsd-update.conf(5)</a> を参照してください。</p></div></div><div class=sect3><h4 id=freebsdupdate-security-patches>16.2.2. セキュリティパッチの適用<a class=anchor href=#freebsdupdate-security-patches></a></h4><div class=paragraph><p>FreeBSD のセキュリティパッチを適用する過程は簡単になりました。
管理者は <code>freebsd-update</code> を使うことで、 システムを完全にパッチがあたった状態に保つ事ができます。
FreeBSD セキュリティ勧告の詳細については、<a href=./#security-advisories>FreeBSD セキュリティ勧告</a> の節で説明されています。</p></div><div class=paragraph><p>以下のコマンドを実行すると、FreeBSD のセキュリティパッチがダウンロードされ、インストールされます。
最初のコマンドは、未対応のパッチがあるかどうかを調べます。
もし未対応のパッチがある場合には、パッチが当てられた際に変更されるファイルのリストが作成されます。
2 番目のコマンドはパッチを適用します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update fetch</span>
<span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>アップデートによってカーネルにパッチが適用された場合には、システムを再起動して新しいカーネルで起動する必要があります。
もし、実行中のバイナリにパッチが適用された場合には、パッチが当てられたバイナリが使われるように、影響するアプリケーションを再起動する必要があります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>通常、ユーザはシステムを再起動する必要があります。
カーネルアップデートによりシステムの再起動が必要かどうかを調べるには、<code>freebsd-version -k</code> と <code>uname -r</code> を実行してください。
これら 2 つのコマンドの結果が異なる場合には、システムを再起動してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>毎日一度アップデートがないかどうかを自動的に確認するように設定するには、 以下のエントリを <span class=filename>/etc/crontab</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>@daily                                  root    freebsd-update cron</pre></div></div><div class=paragraph><p>パッチが存在すると、自動的にダウンロードされますが、適用はされません。
<code>root</code>宛てにメールで、ダウンロードされたパッチを確認し、<code>freebsd-update install</code> とともに手動でインストールする必要のあることが通知されます。</p></div><div class=paragraph><p>うまく行かなかった場合には、<code>freebsd-update</code> を以下のように実行すると、最後の変更までロールバックできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update rollback</span>
Uninstalling updates... <span class=k>done</span>.</code></pre></div></div><div class=paragraph><p>カーネルまたはカーネルモジュールがアップデートされた場合には、 完了後にもう一度システムを再起動して、 影響のあったバイナリを再起動してください。</p></div><div class=paragraph><p><code>freebsd-update</code> ユーティリティが自動的にアップデートするカーネルは <span class=filename>GENERIC</span> のみです。
カスタムカーネルをインストールしている場合には、<code>freebsd-update</code> によりインストールした後、カーネルを再構築し、もう一度インストールする必要があります。
デフォルトのカーネルの名前は <em>GENERIC</em> です。
<a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> コマンドを使ってインストールされているかどうかを確認できます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>GENERIC</span> カーネルを、常に <span class=filename>/boot/GENERIC</span> に置いておいてください。
さまざまな問題を解決する際や、バージョンをアップグレードする際に助けとなります。
<span class=filename>GENERIC</span> カーネルを用意する方法については、<a href=#freebsd-update-custom-kernel-9x>FreeBSD 9.X 以降のシステムにおけるカスタムカーネル</a> を参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>/etc/freebsd-update.conf</span> のデフォルトの設定を変更しない限り、<code>freebsd-update</code> は、他の更新と共にカーネルソースをアップデートします。
新しいカスタムカーネルの再構築と再インストールは、通常通り行うことができます。</p></div><div class=paragraph><p><code>freebsd-update</code> は、常にカーネルをアップデートするとは限りません。
<code>freebsd-update install</code> によってカーネルソースが変更されなかった場合には、カスタムカーネルを再構築する必要はありません。
しかしながら <code>freebsd-update</code> は、<span class=filename>/usr/src/sys/conf/newvers.sh</span> を常にアップデートします。
これは、現在のシステムのパッチレベルを <code>uname -r</code> が <code>-p</code> で表示する時にこのファイルが参照されます。
そのため、何も変更されていない場合でも、カスタムカーネルを再構築することにより、<code>uname</code> がシステムの正確なパッチレベルを報告するようになります。
各システムにインストールされているアップデートをすばやく把握できるようになるので、特に複数のシステムを管理するときに助けとなります。</p></div></div><div class=sect3><h4 id=freebsdupdate-upgrade>16.2.3. メジャーおよびマイナーバージョンのアップグレード<a class=anchor href=#freebsdupdate-upgrade></a></h4><div class=paragraph><p>FreeBSD のマイナーバージョン間のアップグレード、たとえば、FreeBSD 9.0 から FreeBSD 9.1 へのアップグレードは、<em>マイナーバージョン</em> アップグレードと呼ばれます。
<em>メジャーバージョン</em> アップグレードは、FreeBSD 9.X から FreeBSD 10.X へのアップグレードといった、FreeBSD のメジャーバージョンが変わるようなアップグレードのことです。
どちらのアップグレードも、<code>freebsd-update</code> のターゲットにリリース番号を指定する事で実行できます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>カスタムカーネルを使っているシステムでは、アップグレードを行う前に <span class=filename>GENERIC</span> カーネルが、<span class=filename>/boot/GENERIC</span> に置かれている事を確認してください。
<span class=filename>GENERIC</span> カーネルを用意する方法については、<a href=#freebsd-update-custom-kernel-9x>FreeBSD 9.X 以降のシステムにおけるカスタムカーネル</a> を参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>以下のコマンドを実行すると、FreeBSD 9.0 のシステムを FreeBSD 9.1 にアップグレードします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -r 9.1-RELEASE upgrade</span></code></pre></div></div><div class=paragraph><p>コマンドを実行すると、<code>freebsd-update</code> は設定ファイルと現在のシステムを評価し、 アップデートするために必要な情報を収集します。
画面には、どのコンポーネントが認識され、どのコンポーネントが認識されていないといったリストが表示されます。
たとえば以下のように表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature <span class=k>for </span>9.0-RELEASE from update1.FreeBSD.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata index... <span class=k>done</span><span class=nb>.</span>
Inspecting system... <span class=k>done</span><span class=nb>.</span>

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD <span class=k>do </span>not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable <span class=o>(</span>y/n<span class=o>)</span>? y</code></pre></div></div><div class=paragraph><p>ここで、<code>freebsd-update</code> はアップグレードに必要なすべてのファイルをダウンロードします。
何をインストールし、どのように進むかといった質問をされることもあります。</p></div><div class=paragraph><p>カスタムカーネルを使っていると、上記のステップ中に以下のような警告が表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>WARNING: This system is running a <span class=s2>&#34;MYKERNEL&#34;</span> kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running <span class=s2>&#34;/usr/sbin/freebsd-update install&#34;</span></code></pre></div></div><div class=paragraph><p>この時点ではこの警告を無視してもかまいません。
アップデートされた <span class=filename>GENERIC</span> カーネルは、アップグレードプロセスの途中で利用されます。</p></div><div class=paragraph><p>すべてのパッチがローカルシステムへダウンロードされたら、次にパッチが適用されます。
このプロセスには時間がかかります。
この時間はコンピュータの性能およびワークロードに依存します。
その後、設定ファイルがマージされます。
このプロセスでは、ユーザはファイルをマージするか、画面上にエディタを立ち上げて手動でマージするかを尋ねられます。
プロセスが進むごとに、成功したマージのすべての結果の情報がユーザに示されます。
マージに失敗したり、無視した場合には、プロセスが中断します。
ユーザによっては <span class=filename>/etc</span> のバックアップを取り、<span class=filename>master.passwd</span> や <span class=filename>group</span> のような重要なファイルを後で手動でマージする方もいます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>すべてのパッチは別のディレクトリでマージされており、まだ、システムには反映されていません。
すべてのパッチが正しく適用され、すべての設定ファイルがマージされてプロセスがスムーズに進んだら、ユーザは以下のコマンドを用いて、変更点をディスクに反映してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>パッチは最初にカーネルとカーネルモジュールに対して当てられます。
システムがカスタムカーネルを実行している場合には、<a href="https://man.freebsd.org/cgi/man.cgi?query=nextboot&amp;sektion=8&amp;format=html">nextboot(8)</a> を使って次回の再起動時のカーネルを、アップデートされた <span class=filename>/boot/GENERIC</span> に設定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nextboot -k GENERIC</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><span class=filename>GENERIC</span> カーネルで再起動する前に、カーネルにシステムが適切に起動するために必要なすべてのドライバが含まれていること、もしアップデートしているコンピュータがリモートでアクセスしているのであれば、ネットワーク接続に必要なすべてのドライバも含まれていることを確認してください。
特に、これまで実行しているカスタムカーネルが、カーネルモジュールとして提供されているビルドインの機能を含んでいるのであれば、これらのモジュールを一時的に <span class=filename>/boot/loader.conf</span> の機能を用いて、<span class=filename>GENERIC</span> に読み込んでください。
アップグレードプロセスが終わるまでは、重要ではないサービスを無効にするとともに、必要のないディスクやネットワークのマウントなども避けることが推奨されています。</p></div></td></tr></tbody></table></div><div class=paragraph><p>アップデートされたカーネルでコンピュータを再起動してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>システムがオンラインに戻ったら、以下のコマンドを使って <code>freebsd-update</code> を再び実行してください。
アップデートプロセスの状態は保存されているので、<code>freebsd-update</code> を実行すると、古い共有ライブラリおよびオブジェクトファイルを削除するステップに進みます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>使用しているライブラリのバージョン番号の付けられ方によって、 3 つのインストールフェーズが 2 つになる場合もあります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>アップグレードはこれで終了です。
もしメジャーアップグレードを行った場合には、<a href=#freebsdupdate-portsrebuild>メジャーバージョンアップグレード後の package のアップグレード</a> で説明されているようにすべての ports および package を再構築してください。</p></div><div class=sect4><h5 id=freebsd-update-custom-kernel-9x>16.2.3.1. FreeBSD 9.X 以降のシステムにおけるカスタムカーネル<a class=anchor href=#freebsd-update-custom-kernel-9x></a></h5><div class=paragraph><p><code>freebsd-update</code> を使う前に、<span class=filename>GENERIC</span> カーネルが <span class=filename>/boot/GENERIC</span> に置かれていることを確認してください。
ただ一度だけカスタムカーネルを構築したのであれば、<span class=filename>/boot/kernel.old</span> は <span class=filename>GENERIC</span> カーネルそのものです。
このディレクトリの名前を <span class=filename>/boot/GENERIC</span> へと変更してください。</p></div><div class=paragraph><p>もし、2 回以上カスタムカーネルを構築した後であったり、カスタムカーネルを構築した回数がわからなければ、現在のオペレーティングシステムのバージョンの <span class=filename>GENERIC</span> カーネルを入手してください。
コンピュータへの物理的なアクセスが可能であれば、インストールメディアから <span class=filename>GENERIC</span> カーネルをインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span>
<span class=c># cd /cdrom/usr/freebsd-dist</span>
<span class=c># tar -C/ -xvf kernel.txz boot/kernel/kernel</span></code></pre></div></div><div class=paragraph><p>別な方法としては、 <span class=filename>GENERIC</span> カーネルをソースから再構築して、 インストールしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</span></code></pre></div></div><div class=paragraph><p><code>freebsd-update</code> がこのカーネルを <span class=filename>GENERIC</span> カーネルとして認識するために、<span class=filename>GENERIC</span> コンフィグレーションファイルは、とにかく変更してはいけません。
また、特別なオプションを指定しないで構築してください。</p></div><div class=paragraph><p><code>freebsd-update</code> は、<span class=filename>/boot/GENERIC</span> が存在する事だけを必要とするので、<span class=filename>GENERIC</span> カーネルで再起動する必要はありません。</p></div></div><div class=sect4><h5 id=freebsdupdate-portsrebuild>16.2.3.2. メジャーバージョンアップグレード後の package のアップグレード<a class=anchor href=#freebsdupdate-portsrebuild></a></h5><div class=paragraph><p>一般的に、マイナーバージョンアップグレードの後では、インストールされているアプリケーションは、問題なく動作するでしょう。
メジャーバージョンが異なるとアプリケーションバイナリーインタフェース (ABI) が異なるため、サードパーティ製のアプリケーションの多くは動作しなくなるでしょう。
メジャーバージョンアップグレード後には、インストールされているすべての packages, ports をアップグレードする必要があります。
package は、<code>pkg upgrade</code> を使ってアップグレードできます。
インストールされている ports をアップグレードする場合には、<a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> といったユーティリティを使ってください。</p></div><div class=paragraph><p>すべての package の強制的なアップグレードでは、バージョン番号が上がらない package に対しても、リポジトリから最新のバージョンで、インストールされている package を置き換えます。
FreeBSD のメージャーバージョンが変わるようなアップグレードでは、ABI のバージョンも変わるため、このようなアップグレードが必要になります。
強制的なアップグレードを行うには、以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg-static upgrade -f</span></code></pre></div></div><div class=paragraph><p>インストールされているすべてのアプリケーションを再構築するには、以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>このコマンドを実行すると、設定を変更するオプションを持つアプリケーションは、設定変更のスクリーンを表示し、ユーザからの指示待ちの状態で停止します。
この振る舞いをやめ、デフォルトのオプションを使用するには、上記のコマンドに <code>-G</code> を含めてください。</p></div><div class=paragraph><p>ソフトウェアのアップグレードが終わったら、最後にもう一度 <code>freebsd-update</code> を実行して、すべてのアップグレードプロセスのやり残し作業を行い、アップグレードのプロセスを完了してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p><span class=filename>GENERIC</span> カーネルを一時的に読み込んでいたのであれば、<a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> に書かれている手順に従って、新しいカスタムを構築し、インストールしてください。</p></div><div class=paragraph><p>コンピュータを再起動し、新しい FreeBSD を立ち上げてください。
これでアップグレードのプロセスは完了です。</p></div></div></div><div class=sect3><h4 id=freebsdupdate-system-comparison>16.2.4. システムの状態の比較<a class=anchor href=#freebsdupdate-system-comparison></a></h4><div class=paragraph><p><code>freebsd-update</code> を用いて、インストールされている FreeBSD の状態と、正しく動作することが分かっている状態とを比較できます。
このコマンドは、現在のシステムのユーティリティ、ライブラリ、設定ファイルを評価するので、組み込みの侵入検知システム (IDS) として使うことができます。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>このコマンドは、<a class=package href=https://cgit.freebsd.org/ports/tree/security/snort/>security/snort</a> のような本当の IDS の置き換えになるものではありません。
<code>freebsd-update</code> はデータをディスクに保存するので、不正な変更が行われる可能性があります。
<code>kern.securelevel</code> と、<code>freebsd-update</code> のデータを使用しないときに、読み取りのみの許可属性に設定されているファイルシステムに置くことで、不正な変更の可能性を低くできますが、よりよい解決方法は、DVD または安全に保存されている外部 USB ディスクのような安全なディスクとシステムを比較することです。
組み込まれているユーティリティを用いた、別の方法による IDS 機能については、<a href=./#security-ids>FreeBSD バイナリによる検出</a> の節をご覧ください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>比較を行うには、 結果の出力先のファイル名を指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update IDS &gt;&gt; outfile.ids</span></code></pre></div></div><div class=paragraph><p>システムは検査され、リリースファイルの SHA256 ハッシュ値と現在インストールされているファイルのハッシュ値がファイルの一覧と共に、指定した出力先のファイルに送られます。</p></div><div class=paragraph><p>これらの行は極めて長いのですが、出力形式は簡単にすぐに解析できます。
たとえば、これらのリリースで異なっているすべてのファイルを知りたいのであれば、以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat outfile.ids | awk &#39;{ print $1 }&#39; | more</span>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</code></pre></div></div><div class=paragraph><p>上の表示例では出力は切り捨てられており、実際にはもっと多くのファイルが存在します。
これらのファイルには、運用中に変更されるファイルがあります。
たとえば、<span class=filename>/etc/passwd</span> はユーザがシステムに追加されると変更されます。
また、カーネルモジュールは、<code>freebsd-update</code> によりアップデートされるため、変更されます。
このような特別なファイルやディレクトリを除外するには、それらを <span class=filename>/etc/freebsd-update.conf</span> の <code>IDSIgnorePaths</code> オプションに追加してください。</p></div></div></div><div class=sect2><h3 id=updating-bootcode>16.3. ブートコードのアップデート<a class=anchor href=#updating-bootcode></a></h3><div class=paragraph><p>ブートコードおよびブートローダのアップデートプロセスについては、
<a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gptboot&amp;sektion=8&amp;format=html">gptboot(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gptzfsboot&amp;sektion=8&amp;format=html">gptzfsboot(8)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.efi&amp;sektion=8&amp;format=html">loader.efi(8)</a> のマニュアルを参照してください。</p></div></div><div class=sect2><h3 id=updating-upgrading-documentation>16.4. ドキュメントのアップデート<a class=anchor href=#updating-upgrading-documentation></a></h3><div class=paragraph><p>ドキュメントは、FreeBSD オペレーティングシステムの必須要素です。
FreeBSD ドキュメントの最新バージョンは、FreeBSD ウェブサイト (<a href=https://docs.FreeBSD.org/>Documentation Portal</a>) から入手できますが、 FreeBSD ウェブサイト、ハンドブック、FAQ および文書の最新版をローカルに用意しておくと便利です。</p></div><div class=paragraph><p>この章では、ソースまたは Ports Collection を使って、ローカルの FreeBSD ドキュメントを最新に保つ方法を説明します。</p></div><div class=paragraph><p>ドキュメントを編集したり、ドキュメントの誤りを報告する方法については、新しい貢献者のための FreeBSD ドキュメンテーションプロジェクト入門 (<a href=https://docs.freebsd.org/en/books/fdp-primer/>FreeBSD Documentation Project Primer</a>) をご覧ください。</p></div><div class=sect3><h4 id=updating-installed-documentation>16.4.1. ソースから FreeBSD ドキュメントをインストールする<a class=anchor href=#updating-installed-documentation></a></h4><div class=paragraph><p>ソースから FreeBSD ドキュメントを構築するのに必要なツールは、FreeBSD のベースシステムには含まれていません。
必要なツールは、新しい貢献者のための FreeBSD ドキュメンテーションプロジェクト入門で <a href=https://docs.freebsd.org/en/books/fdp-primer/#overview-quick-start>説明されているステップ</a> に従ってインストールしてください。</p></div><div class=paragraph><p>インストールしたら、git を使って、ドキュメントのソースをダウンロードしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># git clone https://git.FreeBSD.org/doc.git /usr/doc</span></code></pre></div></div><div class=paragraph><p>最初にドキュメントのソースをダウンロードするには少し時間がかかります。
ダウンロードが終わるまでお待ちください。</p></div><div class=paragraph><p>ダウンロードしたドキュメントのソースをアップデートするには、 以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># git pull</span></code></pre></div></div><div class=paragraph><p>最新のドキュメントのソースのスナップショットを <span class=filename>/usr/doc</span> に用意できたら、インストールされているドキュメントをアップデートする準備はすべて整いました。</p></div><div class=paragraph><p>ドキュメントをアップデートするには、以下のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make</span></code></pre></div></div></div></div><div class=sect2><h3 id=current-stable>16.5. 開発ブランチを追いかける<a class=anchor href=#current-stable></a></h3><div class=paragraph><p>FreeBSD には二つの開発ブランチがあります。 それは FreeBSD-CURRENT と FreeBSD-STABLE です。</p></div><div class=paragraph><p>この節ではそれぞれのブランチと対象としている読者についての説明と、 どのようにしてシステムの対応するブランチを最新の状態に保つかについて説明します。</p></div><div class=sect3><h4 id=current>16.5.1. FreeBSD-CURRENT を使う<a class=anchor href=#current></a></h4><div class=paragraph><p>FreeBSD-CURRENT とは FreeBSD の開発の "最前線" なので、FreeBSD-CURRENT のユーザは高い技術力を持つことが要求されます。
そこまでの技術力を持っていないが、開発ブランチを追いかけたいと考えているユーザは、かわりに FreeBSD-STABLE を追いかけると良いでしょう。</p></div><div class=paragraph><p>FreeBSD-CURRENT は FreeBSD の最新のソースコードであり、中には現在開発途上のソフトウェア、実験的な変更、あるいは過渡的な機能などが含まれています。
また、この中に入っている機能がすべて、次の公式リリースに入るとは限りません。
FreeBSD-CURRENT をソースからほぼ毎日コンパイルしている人はたくさんいますが、短い期間ではコンパイルさえできない状態になっている時期もあります。
これらの問題は可能な限り迅速に解決されますが、FreeBSD-CURRENT が不幸をもたらすか、それとも新しい機能をもたらすかは、まさにソースコードを同期した瞬間によるのです!</p></div><div class=paragraph><p>FreeBSD-CURRENT は、次の 3 つの重要なグループを対象としています。</p></div><div class="olist arabic"><ol class=arabic><li><p>ソースツリーのある部分に関して活発に作業している FreeBSD コミュニティのメンバ。</p></li><li><p>活発にテストしている FreeBSD コミュニティのメンバ。 彼らは、種々の問題を解決するのに時間を惜しまない人々であり、 さまざまな変更に関する提案や FreeBSD の大まかな方向付けを行ないたいと思っている人々でもあり、 パッチも提出します。</p></li><li><p>さまざまな事に目を向け、 参考のために最新のソースを使いたいと思っていたり、 時々コメントやコードを寄稿したいと考えているユーザ。</p></li></ol></div><div class=paragraph><p>FreeBSD-CURRENT は、次のリリースの前に、最も早く新しい機能を入手する手段として、期待しては<em>いけません</em>。
リリース前の機能は十分にテストされていないため、バグを含んでいる可能性が大いにあるためです。
また、バグを修正するための素早い方法でもありません。
いかなるコミットは、元からあるバグを修正するのと同じく、新しいバグを生み出すおそれがあります。
FreeBSD-CURRENT には "公式のサポート" はありません。</p></div><div class=paragraph><p>FreeBSD-CURRENT を追いかけるには</p></div><div class="olist arabic"><ol class=arabic><li><p><a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT メーリングリスト</a> と <a href=https://lists.FreeBSD.org/subscription/dev-commits-src-main>Commit messages for the main branch of the src repository</a> メーリングリストに加わってください。
さまざまな人がシステムの現在の状態について述べているコメントを見たり、FreeBSD-CURRENT の現在の状態に関する重要な情報を見逃さないために、 <em>必須の</em> ことです。</p><div class=paragraph><p><a href=https://lists.FreeBSD.org/subscription/dev-commits-src-main>Commit messages for the main branch of the src repository</a> メーリングリストでは、それぞれの変更についての commit ログが記録されています。
また、それに関して起こり得る副作用の情報を得ることができますので、参加する価値のあるメーリングリストです。</p></div><div class=paragraph><p>これらのメーリングリストに入るには、 <a href=https://lists.freebsd.org>FreeBSD リストサーバ</a> をたどって参加したいメーリングリストをクリックし、手順の説明にしたがってください。
FreeBSD-CURRENT だけでなく、ソースツリー全体の変更点を追いかけるのであれば、 <a href=https://lists.FreeBSD.org/subscription/dev-commits-src-all>Commit messages for all branches of the src repository</a> メーリングリストを購読してください。</p></div></li><li><p>FreeBSD-CURRENT のソースを同期してください。
通常は <code>git</code> を使って FreeBSD Git リポジトリの <code>main</code> ブランチから -CURRENT コードをチェックアウトしてください (<a href=./#git>「Git を使う」</a> を参照してください)。</p></li><li><p>リポジトリのサイズが大きいため、興味のある部分や、パッチを当てる部分のソースのみを同期するユーザもいます。
しかしながら、ソースからオペレーティングシステムをコンパイルしようと思っているユーザは、一部分だけではなく、FreeBSD-CURRENT の <em>すべて</em> をダウンロードする必要があります。</p><div class=paragraph><p>FreeBSD-CURRENT をコンパイルする前に <span class=filename>/usr/src/Makefile</span> を注意深く読み、<a href=#makeworld>ソースを用いた FreeBSD のアップデート</a> に書かれている手順に従ってください。
<a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT メーリングリスト</a> と <span class=filename>/usr/src/UPDATING</span> を読めば、次のリリースへ向けて移ってゆくに当たって、ときどき必要となる既存システムからの新システムの構築手順についての最新情報が得られるでしょう。</p></div></li><li><p>アクティブになってください! FreeBSD-CURRENT のユーザには、 拡張やバグ潰しに関して提案することが勧められています。 コードを伴う提案はいつでも歓迎されます!</p></li></ol></div></div><div class=sect3><h4 id=stable>16.5.2. FreeBSD-STABLE を使う<a class=anchor href=#stable></a></h4><div class=paragraph><p>FreeBSD-STABLE とは定期的に公開されるリリースを作成するための開発ブランチです。
このブランチに加えられる変更は FreeBSD-CURRENT よりゆっくりで、原則として、事前に FreeBSD-CURRENT で試験ずみであるという特徴があります。
ただ<em>そうであっても</em>、これは開発用ブランチの一つであり、ある時点における FreeBSD-STABLE のソースがどんな場合にも使えるものであるとは限りません。
このブランチはもう一つの開発の流れというだけであって、エンドユーザ向けのものではありません。
もし試験をする資源的な余裕がない場合は、代わりに最新の FreeBSD リリースを使ってください。</p></div><div class=paragraph><p>FreeBSD の開発プロセスに興味があったり、それに対する貢献を考えていて、特にそれが次回の FreeBSD のリリースに関係するものであるなら FreeBSD-STABLE を追うことを考えると良いでしょう。</p></div><div class=paragraph><p>FreeBSD-STABLE ブランチはいつもコンパイルができ、安定に動作すべきですが、それが保証されているというわけではありません。
FreeBSD-STABLE のユーザは FreeBSD-CURRENT よりも多いため、FreeBSD-CURRENT で発見されなかったバグが FreeBSD-STABLE で発見され、ときどきそれが問題となることがあるのは避けることができません。
このような理由から、盲目的に FreeBSD-STABLE を追いかけるべきではありません。
特に、開発環境もしくはテスト環境でコードを十分に試験せずに、プロダクション品質が要求されるサーバを FreeBSD-STABLE にアップグレードしては<em>いけません</em>。</p></div><div class=paragraph><p>FreeBSD-STABLE を追いかけるには</p></div><div class="olist arabic"><ol class=arabic><li><p>FreeBSD-STABLE の構築に関連する事柄や、その他の注意すべき点 に関する情報を得るために、 <a href=https://lists.FreeBSD.org/subscription/freebsd-stable>FreeBSD-STABLE; メーリングリスト</a> メーリングリストに加わってください。
また開発者は議論の余地がある修正や変更を考えている場合に、このメーリングリストで公表し、提案された変更に関して問題が生じるかどうかを返答する機会をユーザに与えます。</p><div class=paragraph><p>追いかけているブランチに関連する git メーリングリストに参加してください。
たとえば、14-STABLE ブランチを追いかけているユーザは <a href=https://lists.FreeBSD.org/subscription/dev-commits-src-branches>Commit messages for the stable branches of the src repository</a> メーリングリストに参加してください。
このリストでは、変更がなされるごとに作成される commit log やそれに伴う起こりうる副作用についての情報が記録されています。</p></div><div class=paragraph><p>これらのメーリングリストに入るには、 <a href=https://lists.freebsd.org>FreeBSD リストサーバ</a> をたどって参加したいメーリングリストをクリックし、手順の説明にしたがってください。
ソースツリー全体の変更点を追いかけるには、 <a href=https://lists.FreeBSD.org/subscription/dev-commits-src-all>Commit messages for all branches of the src repository</a> メーリングリストを購読してください。</p></div></li><li><p>新しい FreeBSD-STABLE システムをインストールするには、 <a href=./#mirrors>ミラーサイト</a> から最近の FreeBSD-STABLE リリースをインストールするか、毎月公開されている FreeBSD-STABLE からビルドされたスナップショットを使ってください。
スナップショットの詳細については、<a href=https://www.FreeBSD.org/ja/snapshots/>www.freebsd.org/ja/snapshots</a> をご覧ください。</p><div class=paragraph><p>既に FreeBSD が動いているシステムを FreeBSD-STABLE にアップグレードするには、<code>git</code> を使って、希望する開発ブランチのソースをチェックアウしてください。
<code>stable/9</code> といったブランチ名は、<a href=https://www.FreeBSD.org/releng/>www.freebsd.org/releng</a> で説明されています。</p></div></li><li><p>FreeBSD-STABLE をコンパイルしたり FreeBSD-STABLE へとアップグレードする前に、 <span class=filename>/usr/src/Makefile</span> を注意深く読み、 <a href=#makeworld>ソースを用いた FreeBSD のアップデート</a> に書かれている手順に従ってください。
<a href=https://lists.FreeBSD.org/subscription/freebsd-stable>FreeBSD-STABLE; メーリングリスト</a> と <span class=filename>/usr/src/UPDATING</span> を読んで、次のリリースへ向けて移ってゆくに当たって、ときどき必要となる既存システムからの新システムの構築手順についての最新情報を得てください。</p></li></ol></div></div><div class=sect3><h4 id=translate-n-number>16.5.3. n-番号<a class=anchor href=#translate-n-number></a></h4><div class=paragraph><p>バグを追跡する際は、問題が発生したシステムの構築に用いられたソースコードのバージョンを把握することが重要となります。
FreeBSD は、バージョン情報をカーネルのコンパイル時に埋め込みます。
<a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> を使ってこの情報を調べることができます。以下はその例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>uname</span> <span class=nt>-v</span>
FreeBSD 14.0-CURRENT <span class=c>#112 main-n247514-031260d64c18: Tue Jun 22 20:43:19 MDT 2021     fred@machine:/usr/home/fred/obj/usr/home/fred/git/head/amd64.amd64/sys/FRED</span></code></pre></div></div><div class=paragraph><p>最後のフィールドから、カーネル名、ビルドを行ったユーザ、およびコンパイルを行った場所がわかります。
また、4 番目のフィールドは、いくつかの要素から構成されていることがわかります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>main-n247514-031260d64c18

main		<i class=conum data-value=1></i><b>(1)</b>
n247514		<i class=conum data-value=2></i><b>(2)</b>
031260d64c18	<i class=conum data-value=3></i><b>(3)</b>
		<i class=conum data-value=4></i><b>(4)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Git ブランチ名。
注意: n-番号の比較は、FreeBSD プロジェクトで作成されたブランチ
(<code>main</code>, <code>stable/XX</code> および <code>releng/XX</code>) でのみ有効です。
ローカルブランチでは、親ブランチのコミットと n-番号が重複してしまいます。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>n-番号は、ハッシュ値が含まれるようになった git リポジトリの使用開始からのコミットを数えたものです。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>チェックアウトしたツリーのハッシュ値。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td><code>-dirty</code> が表示されることがあります。
変更点がコミットされていないツリーでカーネルが構築された場合に表示されます。
この例では、チェックアウトから変更なく FRED カーネルが構築されたため、出力されていません。</td></tr></tbody></table></div><div class=paragraph><p><code>git rev-list</code> コマンドを使って、ハッシュ値に対応する n-番号を調べることができます。
以下はその例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git rev-list <span class=nt>--first-parent</span> <span class=nt>--count</span> 031260d64c18 <i class=conum data-value=1></i><b>(1)</b>
247514 <i class=conum data-value=2></i><b>(2)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>変換する git ハッシュ値 (ここでは先の例のハッシュ値を使用しています)</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>n-番号</td></tr></tbody></table></div><div class=paragraph><p>この数字は通常それほど重要ではありません。
しかしながら、バグの修正がコミットされた時には、この数字を使うことで、使用しているシステムでバグが修正されているかどうかを簡単に調べることができます。
ハッシュ値は簡単に目にする識別子である一方で n-番号はそうではありません。
そのため、開発者は通常 n-番号ではなくコミットのハッシュ値
(または、ハッシュ値を含む URL) を参照します。
セキュリティ勧告および errata 情報では n-番号が示されており、使用しているシステムの番号と直接比較できます。
<code>git rev-list</code> コマンドは、レポジトリのリビジョンをすべてカウントしますが、git の shallow clone はその情報を取得しないため、shallow clone を使用しなければならない場合には、n-番号は信頼できません。</p></div></div></div><div class=sect2><h3 id=makeworld>16.6. ソースを用いた FreeBSD のアップデート<a class=anchor href=#makeworld></a></h3><div class=paragraph><p>ソースをコンパイルしてFreeBSD をアップデートする方法は、 バイナリを用いたアップデートに比べ、いくつもの利点があります。 特定のハードウェアをうまく利用するためのオプションを設定してコードを構築できます。
ベースシステムの特定の箇所の設定をデフォルトの設定から変更したり、必要がない部分を完全に削除して構築することもできます。
システムを構築することによるアップデートは、バイナリアップデートをインストールするだけのアップデートに比べ時間がかかりますが、利用環境に合わせた FreeBSD を作成するような完全なカスタマイズが可能です。</p></div><div class=sect3><h4 id=updating-src-quick-start>16.6.1. クィックスタート<a class=anchor href=#updating-src-quick-start></a></h4><div class=paragraph><p>以下は FreeBSD をソースから構築してアップデートする典型的な方法についてのクイックリファレンスです。
その後の節では、各プロセスをより詳細に説明します。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> から <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> に移行する際に、初めて <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> を実行すると、変更点が不適切にマージされ、衝突が起きてしまうことがあります。
これを避けるには、ソースを更新して新しく buildworld を行う <strong>前に</strong> 以下のステップを行ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># etcupdate extract </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># etcupdate diff </span><i class=conum data-value=2></i><b>(2)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><span class=filename>/etc</span> ファイルを保存するデータベースをブートストラップしてください。
詳細については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> を参照してください。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>ブートストラップ後、差分を確認してください。
不必要なローカルでの変更点をなくし、将来的なアップデートにおいて、衝突が起きる可能性が低くなるようにしてください。</td></tr></tbody></table></div></td></tr></tbody></table></div><div class="exampleblock procedure"><div class=content><div class=ulist><ul><li><p>アップデートおよびビルド</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># git pull /usr/src  </span><i class=conum data-value=1></i><b>(1)</b>
/usr/src/UPDATING の確認 <i class=conum data-value=2></i><b>(2)</b>
<span class=c># cd /usr/src          </span><i class=conum data-value=3></i><b>(3)</b>
<span class=c># make -j4 buildworld  </span><i class=conum data-value=4></i><b>(4)</b>
<span class=c># make -j4 kernel      </span><i class=conum data-value=5></i><b>(5)</b>
<span class=c># shutdown -r now      </span><i class=conum data-value=6></i><b>(6)</b>
<span class=c># etcupdate -p         </span><i class=conum data-value=7></i><b>(7)</b>
<span class=c># cd /usr/src          </span><i class=conum data-value=8></i><b>(8)</b>
<span class=c># make installworld    </span><i class=conum data-value=9></i><b>(9)</b>
<span class=c># etcupdate -B         </span><i class=conum data-value=10></i><b>(10)</b>
<span class=c># shutdown -r now      </span><i class=conum data-value=11></i><b>(11)</b></code></pre></div></div></li></ul></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>最新版のソースを入手してください。 ソースの入手およびアップデートに関する情報については <a href=#updating-src-obtaining-src>ソースコードのアップデート</a> をご覧ください。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>ソースの構築の前後で必要となる手動の作業について、 <span class=filename>/usr/src/UPDATING</span> を確認してください。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>ソースが置かれているディレクトリに移動してください。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>world (カーネルを除くすべて) をコンパイルしてください。</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>カーネルをコンパイルしてインストールしてください。 ここに書かれているコマンドは、<code>make buildkernel installkernel</code> と同じです。</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>新しいカーネルを使うため、 システムを再起動してください。</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>installworld を行う前に、<span class=filename>/etc/</span> に置かれている設定ファイルのアップデートとマージを行ってください。</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>ソースが置かれているディレクトリに移動してください。</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>world をインストールしてください。</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td><span class=filename>/etc/</span> に置かれている設定ファイルのアップデートとマージを行ってください。</td></tr><tr><td><i class=conum data-value=11></i><b>11</b></td><td>新しく構築された world およびカーネルを利用するため、 システムを再起動してください。</td></tr></tbody></table></div></div></div></div><div class=sect3><h4 id=updating-src-preparing>16.6.2. ソースを用いたアップデートのための準備<a class=anchor href=#updating-src-preparing></a></h4><div class=paragraph><p><span class=filename>/usr/src/UPDATING</span> を読んでください。 このファイルには、 アップデートの前後で必要となる手動の作業について書かれています。</p></div></div><div class=sect3><h4 id=updating-src-obtaining-src>16.6.3. ソースコードのアップデート<a class=anchor href=#updating-src-obtaining-src></a></h4><div class=paragraph><p>FreeBSD のソースコードは <span class=filename>/usr/src/</span> に置かれています。
このソースコードのアップデートには、Git バージョン管理システムを利用する方法が推奨されています。
まず、ソースコードがバージョン管理下にあることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># git remote --v</span>
origin  https://git.freebsd.org/src.git <span class=o>(</span>fetch<span class=o>)</span>
origin  https://git.freebsd.org/src.git <span class=o>(</span>push<span class=o>)</span></code></pre></div></div><div class=paragraph><p>この結果は、<span class=filename>/usr/src/</span> がバージョン管理下にあり、<a href="https://man.freebsd.org/cgi/man.cgi?query=git&amp;sektion=1&amp;format=html">git(1)</a> を使ってアップデートできることを示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># git pull /usr/src</span></code></pre></div></div><div class=paragraph><p>このディレクトリをアップデートしていない期間が長いと、アップデートのプロセスには時間がかかります。
このプロセスが終わると、ソースコードは最新となり、次節以降で説明する構築のプロセスを実行できます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>ソースコードの入手</div><div class=paragraph><p><code>fatal: not a git repository</code> と出力された場合には、ファイルがなかったり、別な方法によりインストールされているので、新しくソースコードをチェックアウトする必要があります。</p></div><table id=updating-src-obtaining-src-repopath class="tableblock frame-all grid-all stretch"><caption class=title>表 17. FreeBSD のバージョンおよびリポジトリブランチ</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">uname -r の出力</th><th class="tableblock halign-left valign-top">リポジトリパス</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X.Y</em>-RELEASE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>releng/<em>X.Y</em></code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>このリリースバージョンに対する重大なセキュルティへの対応およびバグの修正パッチのみが適用されています。 このブランチは、ほとんどのユーザに推奨されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X.Y</em>-STABLE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>stable/<em>X</em></code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>リリースバージョンに対し、そのブランチにおけるすべての開発の成果が反映されたものです。
<em>STABLE</em> では、Applications Binary Interface (ABI) は変更されないため、このブランチのシステムであれば、以前のバージョンでコンパイルされたソフトウェアを実行できます。
たとえば、FreeBSD 10.1 で実行するようにコンパイルされたソフトウェアは、その後構築された FreeBSD 10-STABLE 上でも実行できます。</p><p class=tableblock>STABLE ブランチは、 時期によってはユーザに影響するようなバグや非互換性を持つことがあります。 これらは通常すぐに修正されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X</em>-CURRENT</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>main</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>リリースが行われていない最新の FreeBSD の開発バージョンです。 CURRENT ブランチは大きなバグや非互換があることもあるので、 高度な知識を持ったユーザのみ使用が推奨されます。</p></td></tr></tbody></table><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> を使って FreeBSD のバージョンを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># uname -r</span>
10.3-RELEASE</code></pre></div></div><div class=paragraph><p><a href=#updating-src-obtaining-src-repopath>FreeBSD のバージョンおよびリポジトリブランチ</a> から分かるように、<code>10.3-RELEASE</code> のアップデートのためのソースコードのパスは、<code>releng/10.3</code> です。
このパスは、ソースコードをチェックアウトする時に使います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /usr/src /usr/src.bak  </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># git clone --branch releng/10.3 https://git.FreeBSD.org/src.git /usr/src </span><i class=conum data-value=2></i><b>(2)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>この古いディレクトリを、 邪魔にならないように移動してください。 このディレクトリ以下に対して変更を行ってなければ、 削除しても構わないでしょう。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>リポジトリの URL に <a href=#updating-src-obtaining-src-repopath>FreeBSD のバージョンおよびリポジトリブランチ</a> に記載されているパスを追加します。 3 番目のパラメータには、 ローカルシステム上でソースコードが置かれるディレクトリを指定します。</td></tr></tbody></table></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=updating-src-building>16.6.4. ソースからの構築<a class=anchor href=#updating-src-building></a></h4><div class=paragraph><p>まず最初に <em>world</em> (カーネルを除くオペレーティングシステムのすべて) をコンパイルします。
このステップを最初に実行するのは、カーネルの構築を最新のツールを使って行うようにするためです。
このステップが終わったら、カーネルそのものを構築します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildworld</span>
<span class=c># make buildkernel</span></code></pre></div></div><div class=paragraph><p>コンパイルされたコードは <span class=filename>/usr/obj</span> に書き出されます。</p></div><div class=paragraph><p>これは基本のステップです。
構築をコントロールする追加のオプションについては、 以下で説明します。</p></div><div class=sect4><h5 id=updating-src-building-clean-build>16.6.4.1. クリーンビルドの実行<a class=anchor href=#updating-src-building-clean-build></a></h5><div class=paragraph><p>FreeBSD ビルドシステムのいくつかのバージョンは、オブジェクトが一時的に置かれるディレクトリ <span class=filename>/usr/obj</span> に前回のコンパイルされたコードを残します。
これにより、変更されていないコードを再コンパイルせずにすむので、その後の構築時間を短縮できます。
すべてを再構築するには、構築を開始する前に、<code>cleanworld</code> を実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make cleanworld</span></code></pre></div></div></div><div class=sect4><h5 id=updating-src-building-jobs>16.6.4.2. ジョブの数の設定<a class=anchor href=#updating-src-building-jobs></a></h5><div class=paragraph><p>マルチコアプロセッサを搭載するシステムでは、構築のためのジョブの数を増やすことで、構築にかかる時間を短縮できます。
<code>sysctl hw.ncpu</code> を使って、コアの数を確認してください。
ジョブの数がどのように構築の速さに影響するかを確実に知るには、プロセッサにより異なりますし、FreeBSD のバージョンにより使用されるビルドシステムも変わるため、実際に試してみるしか方法はありません。
試してみる最初のジョブの数の候補としては、コアの数の半分から倍の数の間で検討してみてください。
ジョブの数は、<code>-j</code> を使って指定します。</p></div><div id=updating-src-building-jobs-example class=exampleblock><div class=title>例 39. 構築のジョブの数を増やす</div><div class=content><div class=paragraph><p>以下は 4 つのジョブで world とカーネルを構築する例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -j4 buildworld buildkernel</span></code></pre></div></div></div></div></div><div class=sect4><h5 id=updating-src-building-only-kernel>16.6.4.3. カーネルのみを構築する<a class=anchor href=#updating-src-building-only-kernel></a></h5><div class=paragraph><p>ソースコードが変更された場合には、<code>buildworld</code> を完了しなければいけません。
その後、いつでも <code>buildkernel</code> でカーネルを構築できます。
カーネルだけを構築するには、以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildkernel</span></code></pre></div></div></div><div class=sect4><h5 id=updating-src-building-custom-kernel>16.6.4.4. カスタムカーネルの構築<a class=anchor href=#updating-src-building-custom-kernel></a></h5><div class=paragraph><p>FreeBSD 標準のカーネルは、<span class=filename>GENERIC</span> と呼ばれる <em>カーネルコンフィグレーションファイル</em> に基づいています。
<span class=filename>GENERIC</span> カーネルには、最も良く使われるデバイスドライバやオプションが含まれています。
しかしながら、特定の目的に合わせてデバイスドライバやオプションを削除したり追加するためには、カスタムカーネルを構築することが有用であったり、必要となることがあります。</p></div><div class=paragraph><p>たとえば、極端に RAM が制限されているような小さな組み込みのコンピュータを開発しているユーザであれば、 必要のないデバイスドライバやオプションを削除することで、 カーネルを少しでも小さくできるでしょう。</p></div><div class=paragraph><p>カーネルのコンフィグレーションファイルは、 <span class=filename>/usr/src/sys/arch/conf/</span> に置かれています。ここで、 <em>arch</em> は <code>uname -m</code> の出力です。 ほとんどのコンピュータは <code>amd64</code> であり、 コンフィグレーションファイルが置かれているディレクトリは <span class=filename>/usr/src/sys/amd64/conf/</span> です。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><span class=filename>/usr/src</span> は、削除されたり作り直されたりする可能性があるため、カスタムカーネルのコンフィグレーションファイルは、<span class=filename>/root</span> のような別のディレクトリで管理することが好ましいです。
カーネルコンフィグレーションファイルは、<span class=filename>conf</span> ディレクトリにリンクします。
このディレクトリが削除されたり、上書きされた場合には、カーネルコンフィグレーションファイルを新しいディレクトリにもう一度リンクしてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>カスタムコンフィグレーションファイルは、<span class=filename>GENERIC</span> コンフィグレーションファイルをコピーして作成できます。
たとえば、ストレージサーバ用の <span class=filename>STORAGESERVER</span> という名前の新しいカスタムカーネルは、以下のようにして作成できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /usr/src/sys/amd64/conf/GENERIC /root/STORAGESERVER</span>
<span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># ln -s /root/STORAGESERVER .</span></code></pre></div></div><div class=paragraph><p>その後 <span class=filename>/root/STORAGESERVER</span> を編集し、 <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a> で示されるデバイスやオプションを追加したり削除してください。</p></div><div class=paragraph><p>コマンドラインからカーネルコンフィグレーションファイルを <code>KERNCONF</code> に指定することで、 カスタムカーネルを構築できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=STORAGESERVER</span></code></pre></div></div></div></div><div class=sect3><h4 id=updating-src-installing>16.6.5. コンパイルされたコードのインストール<a class=anchor href=#updating-src-installing></a></h4><div class=paragraph><p><code>buildworld</code> および <code>buildkernel</code> が完了したら、 新しいカーネルと world をインストールしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make installkernel</span>
<span class=c># shutdown -r now</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld</span>
<span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>カスタムカーネルを構築した場合は、 新しいカスタムカーネルを <code>KERNCONF</code> に設定して実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make installkernel KERNCONF=STORAGESERVER</span>
<span class=c># shutdown -r now</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld</span>
<span class=c># shutdown -r now</span></code></pre></div></div></div><div class=sect3><h4 id=updating-src-completing>16.6.6. アップデートの完了<a class=anchor href=#updating-src-completing></a></h4><div class=paragraph><p>アップデートの完了までに、いくつかの最終作業が残されています。
デフォルトから変更した設定ファイルを新しいバージョンのファイルにマージし、古くなったライブラリを見つけて削除した後に、システムを再起動します。</p></div><div class=sect4><h5 id=updating-src-completing-merge-etcupdate>16.6.6.1. <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> を用いた設定ファイルのマージ<a class=anchor href=#updating-src-completing-merge-etcupdate></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> は、<span class=filename>/etc/</span> 以下のファイルのように installworld のプロセスで更新されないファイルをアップデートするツールです。
このツールは、ローカルにあるファイルに対する変更点を 3-way マージでアップデートします。
<a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> の対話的なプロンプトと対照的に、このツールはユーザによる操作を最小限になるように設計されています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>一般的に、<a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> は、実行する際に特定の引数を必要としません。
しかしながら、<a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> を最初に使用した際に、どのようなアップデートが行われたかの健全性をチェックする便利なコマンドがあります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># etcupdate diff</span></code></pre></div></div><div class=paragraph><p>このコマンドにより、ユーザは設定の変更を検証できます。</p></div></td></tr></tbody></table></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> が自動的にファイルをマージできない場合には、
以下を実行することで、手動の操作により衝突を解決できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># etcupdate resolve</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> から <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> に移行する際に、
最初に <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> を実行すると、不適切に変更点がマージされ、誤った衝突が起こる可能性があります。
これを避けるには、ソースを更新して新しく buildworld を行う <strong>前に</strong> 以下のステップを行ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># etcupdate extract </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># etcupdate diff </span><i class=conum data-value=2></i><b>(2)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><span class=filename>/etc</span> ファイルを保存するデータベースをブートストラップしてください。
詳細については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> を参照してください。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>ブートストラップ後、差分を確認してください。
不必要なローカルでの変更点をなくし、将来的なアップデートにおいて、衝突が起きる可能性が低くなるようにしてください。</td></tr></tbody></table></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=updating-src-completing-merge-mergemaster>16.6.6.2. <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> を用いた設定ファイルのマージ<a class=anchor href=#updating-src-completing-merge-mergemaster></a></h5><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> を用いることで、システムの設定ファイルに行われている変更を、これらのファイルの新しいバージョンにマージできます。
<a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> は、設定ファイルのアップデートで推奨されている <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> の代価のツールです。
<code>-Ui</code> オプションを使って <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> を実行すると、 ユーザが手を加えていないファイルのアップデートおよび新しく追加されたファイルのインストールを自動的に行います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -Ui</span></code></pre></div></div><div class=paragraph><p>ファイルのマージを手動で行う必要がある時は、ファイルの中で残す箇所の選択を対話的におこなうようなインタフェースが表示さます。
詳細については、<a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> をご覧ください。</p></div></div><div class=sect4><h5 id=updating-src-completing-check-old>16.6.6.3. 使われなくなったファイルやライブラリの確認<a class=anchor href=#updating-src-completing-check-old></a></h5><div class=paragraph><p>アップデート後に、使われなくなったファイルやディレクトリが残ることがあります。
これらのファイルは、</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make check-old</span></code></pre></div></div><div class=paragraph><p>で確認でき、以下のようにして削除できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make delete-old</span></code></pre></div></div><div class=paragraph><p>同様に使われなくなったライブラリが残ることもあります。 これらのライブラリは、</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make check-old-libs</span></code></pre></div></div><div class=paragraph><p>で確認でき、以下のようにして削除できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make delete-old-libs</span></code></pre></div></div><div class=paragraph><p>これらの古いライブラリを利用しているプログラムは、ライブラリが削除されると動かなくなります。
これらのプログラムは、古いライブラリを削除した後に、再構築もしくは置き換える必要があります。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>古いファイルとディレクトリのすべてを削除しても問題ないことを確認したら、コマンドに <code>BATCH_DELETE_OLD_FILES</code> を設定することで、各ファイルを削除する際に <kbd>y</kbd> および <kbd>Enter</kbd> を押さなくても済むようにできます。
以下はその例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make BATCH_DELETE_OLD_FILES=yes delete-old-libs</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=updating-src-completing-restart>16.6.6.4. アップデート後の再起動<a class=anchor href=#updating-src-completing-restart></a></h5><div class=paragraph><p>コンピュータを再起動して、すべての変更を反映させることが、 アップデートの最後におこなう作業です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=small-lan>16.7. 複数のマシンで追いかける<a class=anchor href=#small-lan></a></h3><div class=paragraph><p>複数のコンピュータで同じソースツリーを追いかけていて、全部のマシンにソースをダウンロードして全部を再構築するのは、ディスクスペース、ネットワーク帯域、そして CPU サイクルの無駄使いです。
解決策は 1 つのマシンに仕事のほとんどをさせ、残りのマシンは NFS 経由でそれをマウントする、というものです。
このセクションではそのやり方を概観します。NFS の使い方の詳細については、<a href=./#network-nfs>「NFS」</a> をご覧下さい。</p></div><div class=paragraph><p>まず初めに、同じバイナリで動かそうとするマシンたちを決めます。
このマシンたちのことを<em>ビルドセット</em>と呼びます。
それぞれのマシンはカスタムカーネルを持っているかもしれませんが、同じユーザランドバイナリを動かそうというのです。
このビルドセットから、 <em>ビルドマシン</em>となるマシンを 1 台選びます。
ベースシステムとカーネルを構築するのはこのマシンになります。
理想的には、このマシンは <code>make buildworld</code> と <code>make buildkernel</code> を実行するのに十分な CPU を持った速いマシンであるべきです。</p></div><div class=paragraph><p><em>テストマシン</em> となるべきマシンも選んでください。
更新されたソフトウェアを使う前にそのマシンでテストするのです。
テストマシンはかなり長い時間落ちていても だいじょうぶなマシン<em>であったほうがいいでしょう</em>。
ビルドマシンでもかまいませんが、ビルドマシンである必要はありません。</p></div><div class=paragraph><p>このビルドセットのマシンはすべて <span class=filename>/usr/obj</span> と <span class=filename>/usr/src</span> をビルドマシンから FTP 経由でマウントする必要があります。
ビルドセット自体が複数ある場合は、<span class=filename>/usr/src</span> はひとつのビルドマシン上にあるべきです。
他のマシンからはそれを NFS マウントするようにしましょう。</p></div><div class=paragraph><p>ビルドセットのすべてのマシン上の <span class=filename>/etc/make.conf</span> と <span class=filename>/etc/src.conf</span> がビルドマシンと一致していることを確認してください。
つまり、ビルドマシンはビルドセットのどのマシンもインストールしようとしているベースシステムを全部ビルドしなければならないということです。
また、各ビルドマシンは <span class=filename>/etc/make.conf</span> にそれぞれのビルドマシンのカーネル名を <code>KERNCONF</code> で指定し、ビルドマシンは自分自身のカーネルから順に全部のカーネル名を <code>KERNCONF</code> にリストアップしてください。
ビルドマシンは各マシンのカーネル設定ファイルを <span class=filename>/usr/src/sys/arch/conf</span> に持っていなければなりません。</p></div><div class=paragraph><p>ビルドマシンにて、<a href=#makeworld>ソースを用いた FreeBSD のアップデート</a> に書いてあるようにカーネルとベースシステムを構築してください。
でも、まだビルドマシンにはインストールしないでください。
そのかわり、ビルドしたカーネルをテストマシンにインストールしてください。
FTP 経由で <span class=filename>/usr/src</span> および <span class=filename>/usr/obj</span> をテストマシンにマウントしてください。
その後、<code>shutdown now</code> を実行してシングルユーザモードに移行し、新しいカーネルとベースシステムをインストールし、いつもするように <code>mergemaster</code> を実行してください。
終わったら、再起動して通常のマルチユーザ動作に戻します。</p></div><div class=paragraph><p>テストマシンにあるものすべてがちゃんと動いている確信が得られたら、同じ手順でビルドセットの他のマシンにも新しいソフトウェアをインストールします。</p></div><div class=paragraph><p>ports ツリーにも同じ方法が使えます。
最初のステップは、ビルドセットのすべてのマシンが NFS 経由で <span class=filename>/usr/ports</span> をマウントすることです。
そして、distfiles を共有するように <span class=filename>/etc/make.conf</span> を設定します。
NFS マウントによってマップされる <code>root</code> ユーザが何であれ、<code>DISTDIR</code> はそのユーザが書き込める共通の共有ディレクトリに設定する必要があります。
ports をローカルでビルドする場合には、各マシンは <code>WRKDIRPREFIX</code> を自分のマシンのビルドディレクトリに設定しなければなりません。
また、ビルドシステムが packages をビルドしてビルドセットのコンピュータに配布するのであれば、<code>DISTDIR</code> と同じようにビルドシステム上の <code>PACKAGES</code> ディレクトリも設定してください。</p></div></div></div></div><h1 id=network-communication class=sect0>Part IV: ネットワーク通信<a class=anchor href=#network-communication></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>FreeBSD は、 高性能なネットワークサーバとして最も広く使用されているオペレーティングシステムの 1 つです。 各章の内容は以下の通りです。</p></div><div class=ulist><ul><li><p>シリアル通信</p></li><li><p>PPP と PPP オーバイーサネット (PPPoE)</p></li><li><p>電子メール</p></li><li><p>ネットワークサーバの運用</p></li><li><p>ファイアウォール</p></li><li><p>その他の高度なネットワークに関する話題</p></li></ul></div><div class=paragraph><p>各章は、必要になった時に個別に参照できるように構成されています。 どの順番で読んでも構いませんし、ネットワーク環境で FreeBSD を使うのに、 すべてを読み通す必要がある、というわけでもありません。</p></div></div></div><div class=sect1><h2 id=serialcomms>Chapter 17. シリアル通信<a class=anchor href=#serialcomms></a></h2><div class=sectionbody><div class=sect2><h3 id=serial-synopsis>17.1. この章では<a class=anchor href=#serial-synopsis></a></h3><div class=paragraph><p>Unix は現在に至るまで、常にシリアル通信機能をサポートしていました。 実際、本当に初期の Unix マシンは、ユーザとの入出力にシリアル通信を使っていました。 10 文字毎秒のシリアルプリンタ、 キーボードから構成された "端末(terminal)" が広く使われていた当時とは、 何もかもがすっかり変わっています。この章では、FreeBSD でシリアル通信を行なういくつかの方法について説明しています。</p></div><div class=paragraph><p>この章を読むと、以下のことがわかります。</p></div><div class=ulist><ul><li><p>FreeBSD システムへの端末の接続方法</p></li><li><p>リモートホストへダイヤルするためのモデムの使い方</p></li><li><p>リモートのユーザがモデムでシステムにログインできるようにする方法</p></li><li><p>シリアルコンソールからのシステム起動方法</p></li></ul></div><div class=paragraph><p>この章を読む前に、以下のことを行っておくべきです。</p></div><div class=ulist><ul><li><p>新しいカーネルを構成してインストールする方法を覚える (<a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a>)。</p></li><li><p>Unix のパーミッションとプロセスについて理解する (<a href=./#basics>UNIX の基礎知識</a>)。</p></li><li><p>FreeBSD で使おうとしているシリアルハードウェア (モデムまたはマルチポートカード) のテクニカルマニュアルを読めるようにする。</p></li></ul></div></div><div class=sect2><h3 id=serial>17.2. はじめに<a class=anchor href=#serial></a></h3><div class=sect3><h4 id=serial-terminology>17.2.1. 用語解説<a class=anchor href=#serial-terminology></a></h4><div class=dlist><dl><dt class=hdlist1>bps</dt><dd><p>Bits per Second の略で、 データの転送速度を表す単位。</p></dd><dt class=hdlist1>DTE</dt><dd><p>Data Terminal Equipment の略。 たとえばコンピュータ本体のこと</p></dd><dt class=hdlist1>DCE</dt><dd><p>Data Communications Equipment の略で、具体的にはモデムのこと。</p></dd><dt class=hdlist1>RS-232</dt><dd><p>EIA (米電気産業協会) のハードウェアシリアル通信の標準規格</p></dd></dl></div><div class=paragraph><p>通信におけるデータ転送速度に関して、 このセクションでは "ボー" (baud) という用語は使いません。 ボーというのは一定時間に生じうる電気的状態の変化の数を表すにすぎず、 "bps" (bits per second) という単位の方が<em>正しい</em>からです (少なくとも、こういう表現をしておけば、 意地の悪い人に怒られることもないのではないかと思います)。</p></div></div><div class=sect3><h4 id=serial-cables-ports>17.2.2. ケーブルとポート<a class=anchor href=#serial-cables-ports></a></h4><div class=paragraph><p>モデムまたはシリアル端末を FreeBSD システムに接続するためには、 コンピュータ上のシリアルポートと、 シリアルデバイスに接続する適切なケーブルが必要です。 ハードウェアとそれが必要とするケーブルについてよく理解しているなら、 この節は飛ばしても問題ありません。</p></div><div class=sect4><h5 id=term-cables>17.2.2.1. ケーブル<a class=anchor href=#term-cables></a></h5><div class=paragraph><p>シリアルケーブルにはさまざまな種類があります。 我々の目的にあうもっとも一般的な 2 種類は、 ヌルモデムケーブル と、スタンダード (ストレート) RS-232 ケーブルです ハードウェアの説明文書に必要なケーブルの種類が記載されているはずです。</p></div><div class=sect5><h6 id=term-cables-null>17.2.2.1.1. ヌルモデムケーブル<a class=anchor href=#term-cables-null></a></h6><div class=paragraph><p>ヌルモデムケーブル (またはリバースケーブルあるいはクロ スケーブル) は、たとえば "signal ground" 信号のように、いくつかの信 号はそのまま通しますが、 他の信号は途中で入れ替えて通します。たとえば、"send data" 信号のピンは、反対側のコネクタの "receive data" 信号の ピンと繋がっています。</p></div><div class=paragraph><p>自分で使うケーブルは自分で作りたいということであれば、 端末で使うヌルモデムケーブルを作成できます。この表では、 RS-232C の信号線の名前と、DB-25 コネクタ上のピンの番 号を示しています。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Signal</th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top">Signal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TxD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RxD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RxD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TxD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>connects to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>DCD と RST では、コネクタ内部でピン4を5に接続し、 そして逆側のコネクタのピン8と接続します。</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=term-cables-std>17.2.2.1.2. スタンダード RS-232C ケーブル<a class=anchor href=#term-cables-std></a></h6><div class=paragraph><p>スタンダードシリアルケーブル (またはストレートケーブル) の場合は、すべての RS-232C 信号をそのまま通します。つまり、片方の "send data" 信号のピンは、逆側の "send data" 信号のピンと繋がっています。モデムを FreeBSD に接続するときや、一部の端末を接続するときにこのタイプの ケーブルを使用します。</p></div></div></div><div class=sect4><h5 id=term-ports>17.2.2.2. ポート<a class=anchor href=#term-ports></a></h5><div class=paragraph><p>シリアルポートは、FreeBSDが動作しているホスト コンピュータと端 末の間でデータのやりとりを行うために用いるデバイスです。 ここでは、現在存在するポートの種類と FreeBSD でのポートのアクセス方法について解 説します。</p></div><div class=sect5><h6 id=term-portkinds>17.2.2.2.1. ポートの種類<a class=anchor href=#term-portkinds></a></h6><div class=paragraph><p>シリアルポートには何種類かのものがあります。 ケーブルを購 入したり自作したりする前に、 そのケーブルのコネクタの形状が端末および FreeBSD システムのポートの形状と一致していることを 確認してください。</p></div><div class=paragraph><p>ほとんどの端末は DB25 ポートを搭載しています。 FreeBSDが動作しているも のを含めて、PCは DB25 または DB9 ポートを搭載しています。マルチポート のシリアルカードの場合は、RJ-12 や RJ-45 のポートを搭載しているかもし れません。</p></div><div class=paragraph><p>利用されているポートの種類に関しては、 ハードウェアについてきたドキュメントを参照してください。 また、多くの場合、ポートの形状から判断することもできるでしょう。</p></div></div><div class=sect5><h6 id=term-portnames>17.2.2.2.2. ポートの名前<a class=anchor href=#term-portnames></a></h6><div class=paragraph><p>FreeBSDでは、<span class=filename>/dev</span> ディレクトリ内のエントリを介 してシリアルポートへのアクセスがおこなわれます。 2種類の異なったエン トリがあります。</p></div><div class=ulist><ul><li><p>着信用のポートの名前は、 <span class=filename>/dev/ttydN</span> (<em>N</em> は 0から始まるポート番号) となっています。一般に端末の接続には 着信用ポートを用います。着信用のポートでは、 シリアルラインのデータ キャリア検出 (DCD) 信号がオンになっている必要があります。</p></li><li><p>発信用のポートの名前は、 <span class=filename>/dev/cuaaN</span> となっています。 発信用のポートは普通モデムの接続に用い、端末の接続には 利用しません。ただ、 ケーブルまたは端末がキャリア検出信号を使えない タイプのものの場合は、 発信用のポートを使うとよいでしょう。</p></li></ul></div><div class=paragraph><p>たとえば、端末を一つ目のシリアルポート (MS-DOS でいうところの <span class=filename>COM1</span>) に接 続したとすると、<span class=filename>/dev/ttyd0</span> がこの端末を指すことになります。また、 二つ目のシリアルポート (<span class=filename>COM2</span>) ならば <span class=filename>/dev/ttyd1</span> となり、 以下この形式のデバイスエントリを使います。</p></div></div></div></div><div class=sect3><h4 id=_カーネルの設定>17.2.3. カーネルの設定<a class=anchor href=#_カーネルの設定></a></h4><div class=paragraph><p>デフォルトでは、FreeBSD は 4 つのシリアルポートに対応しています。MS-DOS の世界では、 <span class=filename>COM1</span>, <span class=filename>COM2</span>, <span class=filename>COM3</span> および <span class=filename>COM4</span> と呼ばれています。 FreeBSD では、現在のところ BocaBoard の 1008 や 2016 などの、 "単純な"マルチポートシリアルインタフェースや、 Digiboard や Stallion Technologies が製造しているよりインテリジェントなマルチポートカードにも対応しています。 しかしながら、デフォルトのカーネルは、標準の COM ポートしか見ません。</p></div><div class=paragraph><p>搭載されているシリアルポートのいずれかを、 カーネルが認識しているかどうか確認したい場合は、 カーネルの起動時のメッセージを注意深く見るか、あるいは <code>/sbin/dmesg</code> コマンドを使って、 起動時の出力メッセージを確認してください。特に、 <code>sio</code> で始まるメッセージをよく見てください。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>以下のコマンドで <code>sio</code> という文字列を含むメッセージだけを表示できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dmesg | grep &#39;sio&#39;</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>たとえば、シリアルポートを四つ持つシステムの場合は、 以下のようなシリアルポートに関するメッセージがカーネルによって表示されます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: <span class=nb>type </span>16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: <span class=nb>type </span>16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: <span class=nb>type </span>16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: <span class=nb>type </span>16550A</code></pre></div></div><div class=paragraph><p>もし、カーネルに正常に認識されないポートがある場合は、 おそらくカスタマイズした FreeBSD カーネルを構築する必要があるでしょう。 カーネルコンフィグレーションの詳細については <a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> をご覧ください。</p></div><div class=paragraph><p>カーネルコンフィグレーションの該当するデバイス行は、 次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>device		sio0	at isa? port &#34;IO_COM1&#34; tty irq 4 vector siointr
device		sio1	at isa? port &#34;IO_COM2&#34; tty irq 3 vector siointr
device		sio2	at isa? port &#34;IO_COM3&#34; tty irq 5 vector siointr
device		sio3	at isa? port &#34;IO_COM4&#34; tty irq 9 vector siointr</pre></div></div><div class=paragraph><p>システムに搭載されていないデバイスに関する記述は、 コメントアウトまたは削除してしまってかまいません。 <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> のマニュアルを見て、 マルチポートのボードのためのコンフィグレーションファイルの記述の仕方を確認してください。 デバイスのフラグの指定方法がバージョンによって異なりますので、 別のバージョンの FreeBSD で利用していたコンフィグレーションファイルを流用する場合には十分注意してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>なお、<code>port "IO_COM1"</code>, <code>IO_COM2</code>, <code>IO_COM3</code> および <code>IO_COM4</code> は、 それぞれのポートの一般的なアドレスである <code>0x3f8</code>, <code>0x2f8</code>, <code>0x3e8</code> および <code>0x2e8</code> を表します。また、割り込み番号 4, 3, 5 と 9 は、それぞれ <span class=filename>COM1:</span> から <span class=filename>COM4:</span> のポートで一般的に使用される IRQ です。また、ISA バスのコンピュータの場合、 一般的なシリアルポートは複数のポートで一つの IRQ を共有することが <em>できません</em>ので注意が必要です (マルチポートのシリアルボードの場合は、複数の 16550A ベースのポートで一つまたは二つの IRQ を共有するための機構を備えています)。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_デバイススペシャルファイル>17.2.4. デバイススペシャルファイル<a class=anchor href=#_デバイススペシャルファイル></a></h4><div class=paragraph><p>カーネルに組み込まれているほとんどのデバイスは、 <span class=filename>/dev</span> ディレクトリにある、 "デバイススペシャルファイル"を介してアクセスされます。 <span class=filename>sio</span> デバイスの場合は、着信用の <span class=filename>/dev/ttydN</span> および、発信用の <span class=filename>/dev/cuaaN</span> が利用されます。さらに、FreeBSD は、初期化デバイス (<span class=filename>/dev/ttyidN</span> と <span class=filename>/dev/cuai0N</span>) およびロッキングデバイス (<span class=filename>/dev/ttyldN</span> と <span class=filename>/dev/cual0N</span>) も用意しています。 初期化デバイスは、通信ポートがオープンされる度に、 そのポートの初期設定を行うために使われます。たとえば、 <code>RTS/CTS</code> によるフロー制御を行うモデムが接続されている場合の <code>crtscts</code> などのパラメータの初期化が行われます。 ロッキングデバイスは、ポートの設定をロックし、 他のユーザやプログラムにこれらを変更されることのないようにするために利用されます。 通信ポートの設定、デバイスのロックと初期化および設定の変更に関しては、 それぞれ <a href="https://man.freebsd.org/cgi/man.cgi?query=termios&amp;sektion=4&amp;format=html">termios(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> のマニュアルをご覧ください。</p></div><div class=sect4><h5 id=_デバイススペシャルファイルの作成>17.2.4.1. デバイススペシャルファイルの作成<a class=anchor href=#_デバイススペシャルファイルの作成></a></h5><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.0 には、 必要に応じてデバイスノードを自動的に作成する <code>devfs</code> ファイルシステムがあります。 <code>devfs</code> が有効になっているバージョンの FreeBSD を動かしているなら、 この節は飛ばしてかまいません。</p></div></td></tr></tbody></table></div><div class=paragraph><p>デバイススペシャルファイルの管理は、ディレクトリ <span class=filename>/dev</span> にあるシェルスクリプト <code>MAKEDEV</code> で行います。 <code>MAKEDEV</code> を使って、 <span class=filename>COM1</span> (ポート 0) をダイアルアップのポートとして利用するための デバイススペシャルファイルを作るには、 <span class=filename>/dev</span> に <code>cd</code> してから、 <code>MAKEDEV ttyd0</code> と実行してください。 同様に、<code>MAKEDEV ttyd1</code> とすることで、 <span class=filename>COM2</span> (ポート 1) 用のデバイススペシャルファイルを作成できます。</p></div><div class=paragraph><p><code>MAKEDEV</code> は、 <span class=filename>/dev/ttydN</span> のデバイススペシャルファイルだけでなく、 <span class=filename>/dev/cuaaN</span>, <span class=filename>/dev/cuaiaN</span>, <span class=filename>/dev/cualaN</span>, <span class=filename>/dev/ttyldN</span> および <span class=filename>/dev/ttyidN</span> ノードも作成します。</p></div><div class=paragraph><p>デバイススペシャルファイルの作成後、 これらのファイルの許可属性が適切に設定されていて、 これらのデバイスを利用してもよいユーザのみが読み書きできるようになっていることを確認してください (特に <span class=filename>/dev/cua*</span> の許可属性には注意を払ってください)。 この確認を怠ると、 一般のユーザがあなたのモデムを使うことができるようなことになりかねません。 デフォルトの <span class=filename>/dev/cua*</span> の許可属性は、以下のようになっていて、 たいていの場合適切なものだと思います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>crw-rw----    1 uucp     dialer    28, 129 Feb 15 14:38 /dev/cuaa1
crw-rw----    1 uucp     dialer    28, 161 Feb 15 14:38 /dev/cuaia1
crw-rw----    1 uucp     dialer    28, 193 Feb 15 14:38 /dev/cuala1</code></pre></div></div><div class=paragraph><p>上の設定では、ユーザ <code>uucp</code> と、グループ <code>dialer</code> に属するユーザが発信用のデバイスを利用できます。</p></div></div></div><div class=sect3><h4 id=serial-hw-config>17.2.5. シリアルポートの設定<a class=anchor href=#serial-hw-config></a></h4><div class=paragraph><p><span class=filename>ttydN</span> (または <span class=filename>cuaaN</span>) デバイスは、 アプリケーション上でシリアルポートをオープンする時に使用する、 標準的なデバイスです。プロセスがデバイスをオープンする際、端末 I/O 設定のデフォルトセットが適用されます。これらの設定内容は、 次のコマンドで確認することができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -a -f /dev/ttyd1</span></code></pre></div></div><div class=paragraph><p>このデバイスの設定を変更した場合、 その設定はデバイスがクローズされるまで有効です。 デバイスが再びオープンされる時、デフォルトの設定値に戻ります。 デフォルトの設定を変更するためには、"初期状態" を設定したいデバイスをオープンして調節できます。 たとえば、<span class=filename>ttyd5</span> というデバイスに対して、デフォルトで <code>CLOCAL</code> モード, 8 bits, <code>XON/XOFF</code> フロー制御を設定したい場合は、 次のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyid5 clocal cs8 ixon ixoff</span></code></pre></div></div><div class=paragraph><p>システム全体のシリアルデバイス初期化は <span class=filename>/etc/rc.serial</span> で制御されています。 このファイルは、シリアルデバイスのデフォルトの設定を決めます。</p></div><div class=paragraph><p>また、"ロック状態"のデバイスに調節を加えることで、 アプリケーションがある種の設定を変更してしまうことを防げます。 たとえば、<span class=filename>ttyd5</span> の速度を 57600 bps に固定したい場合には、次のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyld5 57600</span></code></pre></div></div><div class=paragraph><p>これで、<span class=filename>ttyd5</span> をオープンして、 シリアルポートの転送スピードを変更しようとするアプリケーションは 57600 bps で頭打ちになります。</p></div><div class=paragraph><p>本来、初期状態やロックされているデバイスに書き込めるのは <code>root</code> アカウントだけにすべきです。</p></div></div></div><div class=sect2><h3 id=term>17.3. シリアル端末<a class=anchor href=#term></a></h3><div class=paragraph><p>シリアル端末を利用することで、 コンピュータのコンソールのそばにいないときや、 手近にネットワーク接続されているコンピュータがないときでも、 FreeBSD の機能を便利に、かつ安価に利用することができます。 ここでは、FreeBSD にシリアル端末を接続する方法を解説します。</p></div><div class=sect3><h4 id=term-uses>17.3.1. 端末の種類と利用方法<a class=anchor href=#term-uses></a></h4><div class=paragraph><p>もともと Unix システムにはコンソールがありませんでした。 ユーザはコンピュータのシリアルポートに接続された端末からログインしてプログラムを利用していました。 ちょうどモデムと通信ソフトを使ってリモートのコンピュータにログインし、 テキストベースのプログラムを利用するのとよく似ています。</p></div><div class=paragraph><p>最近の PC は、 高品質の画像を表示できるコンソールを搭載していますが、 ほとんどすべての Unix 系 OS には未だにシリアルポートを使ってログインするための機能があり、 FreeBSD でもこの機能がサポートされています。 現在使用されていないシリアルポートに端末を接続することでシステムにログインし、 通常はコンソールや X ウィンドウシステムの <code>xterm</code> のウィンドウ上で起動しているテキストベースのプログラムであれば何でも利用できます。</p></div><div class=paragraph><p>職場での利用ということで考えるならば、FreeBSD が動作しているコンピュータに接続された何台ものシリアル端末を各社員の机に配置するというようなことが可能です。 また、家庭での利用方法としては、余っている古い IBM PC や Macintosh を FreeBSD が動いているパワフルなコンピュータの端末として利用できます。 普通ならシングルユーザのコンピュータを、 パワフルなマルチユーザのシステムに変えることができるのです。</p></div><div class=paragraph><p>FreeBSD では、以下に挙げる 3 種類の端末が利用できます。</p></div><div class=ulist><ul><li><p><a href=#term-dumb>ダム (dumb) 端末</a></p></li><li><p><a href=#term-pcs>PCを利用した端末</a></p></li><li><p><a href=#term-x>X 端末</a></p></li></ul></div><div class=paragraph><p>以下は、それぞれについての解説です。</p></div><div class=sect4><h5 id=term-dumb>17.3.1.1. ダム端末<a class=anchor href=#term-dumb></a></h5><div class=paragraph><p>ダム端末は、 シリアルライン経由でのコンピュータとの接続専用のハードウェアです。 ダム端末は、テキストの送受信および表示ができる程度の計算能力しかもっていないので、 "dumb" (間抜け) というように呼ばれています。 この端末上でプログラムを実行することはできません。 テキストエディタ、コンパイラ、E-mail、 ゲームなどなどのプログラムを実行するのは、 ダム端末を接続しているコンピュータの方です。</p></div><div class=paragraph><p>Digital Equipment 社の VT-100 や、Wyse 社の WY-75 を初めとして、多くのメーカが何百種類ものダム端末を作っています。 ほとんどどんな種類のダム端末でも FreeBSD に接続して使用できます。さらに、 高性能の端末の中には画像を取り扱えるものもありますが、 限られた数のソフトウェアパッケージしかこういった機能には対応していません。</p></div><div class=paragraph><p>ダム端末は、 X ウィンドウシステムで提供されるようなグラフィックアプリケーションを必要としない職場で広く用いられています。</p></div></div><div class=sect4><h5 id=term-pcs>17.3.1.2. PC を端末として利用する<a class=anchor href=#term-pcs></a></h5><div class=paragraph><p><a href=#term-dumb>ダム端末</a> がテキストの表示および送受信の機能をそなえただけのものならば、 言うまでもなく、どんな PC もダム端末になり得ます。 必要なものは適切なケーブルと、その PC の上で動作する<em>端末エミュレーション</em> を行うソフトウェアのみです。</p></div><div class=paragraph><p>このような環境は、家庭においてよく利用されます。 たとえば、あなたの同居人が FreeBSD のコンソールを専有している時などに、 あまりパワーのないコンピュータを FreeBSD システムにシリアル端末として接続し、 その端末上でテキストだけを用いる作業をおこなうことができます。</p></div></div><div class=sect4><h5 id=term-x>17.3.1.3. X 端末<a class=anchor href=#term-x></a></h5><div class=paragraph><p>X 端末は、 既存のものの中で最も洗練された種類の端末といえます。 X 端末は、たいていの場合シリアルポートではなく、 イーサネットのようなネットワークを利用した接続をおこないます。 また、アプリケーションの利用においても、 テキストベースのものだけでなく、 X アプリケーションの利用が可能です。</p></div><div class=paragraph><p>ここでは、参考までに端末について紹介しただけで、 X 端末の設定や利用についての解説は <em>おこないません</em>。</p></div></div></div><div class=sect3><h4 id=term-config>17.3.2. 設定<a class=anchor href=#term-config></a></h4><div class=paragraph><p>ここでは、端末からのログインを可能にするために必要な FreeBSD 側の設定について解説します。 既に端末を接続するポートが利用できるように kernel の設定をおこない、端末が接続されているものと考えて、解説を進め ます。</p></div><div class=paragraph><p><a href=./#boot>FreeBSD の起動のプロセス</a> で述べたように <code>init</code> プロセスは、 システム起動時にすべてのプロセス管理や初期化をおこなっています。 <code>init</code> が行っている仕事の一つは、 <span class=filename>/etc/ttys</span> ファイルを読んで、利用可能な端末上で <code>getty</code> プロセスを起動することです。 <code>getty</code> プロセスは、 ログイン名を読み込み <code>login</code> プログラムを起動します。</p></div><div class=paragraph><p>したがって、FreeBSD の端末を設定するには、 <code>root</code> で次の手順を踏まなければなりません。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>端末を接続するポートの <span class=filename>/dev</span> のエントリが含ま れている行がまだ存在しなければ、これを <span class=filename>/etc/ttys</span> に追加してく ださい。</p></li><li><p><code>/usr/libexec/getty</code> が対象となるポートに対して 実行されるように指定してください。また、 <span class=filename>/etc/gettytab</span> ファイ ル内の適切な <em>getty</em> タイプのエントリを指定してください。</p></li><li><p>デフォルトのターミナルタイプを指定してください。</p></li><li><p>対象となるポートを "on" に設定してください。</p></li><li><p>そのポートが "secure" であるかどうかを指定してください。</p></li><li><p><code>init</code> に <span class=filename>/etc/ttys</span> を読み込みなおさせてく ださい。</p></li></ol></div></div></div><div class=paragraph><p>また、必要に応じて <span class=filename>/etc/gettytab</span> を変更し、上の 2で使用する <em>getty</em> のエントリを追加してください。 この章ではこの方法については特に解説しませんので、<a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> のマニュアルをご覧ください。</p></div><div class=sect4><h5 id=term-etcttys>17.3.2.1. <span class=filename>/etc/ttys</span> へのエントリの追加<a class=anchor href=#term-etcttys></a></h5><div class=paragraph><p><span class=filename>/etc/ttys</span> には、 FreeBSDシステム上のログインを許可するすべての ポートを記述します。たとえば、一つ目の仮想コンソール <span class=filename>ttyv0</span> のエン トリもこのファイルにあります。このエントリのおかげで、 コンソールからの ログインが可能になっています。 このファイルには、他の仮想コンソール、シ リアルポートおよび仮想端末のエントリも含まれています。 端末を接続する場合は、そのポートの <span class=filename>/dev</span> のエントリを、 <span class=filename>/dev</span> の部分を省略して記述します (たとえば <span class=filename>/dev/ttyv0</span> については、 <span class=filename>ttyv0</span> として記述します)。</p></div><div class=paragraph><p>FreeBSD のデフォルトのインストール状態では、 <span class=filename>ttyd0</span> から <span class=filename>ttyd3</span> までの、初めの 4 つのシリアルポートに対応した <span class=filename>/etc/ttys</span> ファイルが置かれています。 これらのポートのいずれかに端末を接続する場合は、 新たにエントリを追加する必要はありません。</p></div><div id=ex-etc-ttys class=exampleblock><div class=title>例 40. 端末の項目を <span class=filename>/etc/ttys</span> に追加する</div><div class=content><div class=paragraph><p>システムに 2 台の端末、Wyse-50 と、VT-100 端末をエミュレートしている Procomm 端末ソフトウェアを動かしている古い 286 IBM PC をシステムに接続しようとしていると考えてください。 Wyse は 2 番目のシリアルポートに、286 は 6 番目のシリアルポート (マルチポートシリアルカード上のポート) に接続します。 <span class=filename>/etc/ttys</span> 内の対応する項目は次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd1  &#34;/usr/libexec/getty std.38400&#34;  wy50  on  insecure
ttyd5   &#34;/usr/libexec/getty std.19200&#34;  vt100  on  insecure</pre></div></div><div class=ulist><ul><li><p>最初のフィールドには、通常 <span class=filename>/dev</span> にある端末のスペシャルファイル名を指定します。</p></li><li><p>2 番目のフィールドは、 この回線に対して実行するコマンドで、通常は <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> です。<code>getty</code> は、回線を初期化して開き、速度を設定して、 ユーザ名を入力するプロンプトを出して <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> プログラムを実行します。<code>getty</code> プログラムは、 コマンドラインから (省略可能な) パラメータ <em>getty</em> タイプを受け取ります。 <em>getty</em> タイプは、 bps レートやパリティのような端末回線の特性を示します。 <code>getty</code> プログラムは、 これらの特性を <span class=filename>/etc/gettytab</span> ファイルから読み込みます。<span class=filename>/etc/gettytab</span> ファイルには、 端末回線について新旧多くの項目があります。 ほとんどの場合、<code>std</code> で始まる項目は、ケーブルで接続された端末に働きます。 これらの項目はパリティを無視します。110 から 115200 までの間の bps レートそれぞれに対して一つ <code>std</code> 項目があります。もちろん、 このファイルに独自の項目を加えてもかまいません。 <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> のマニュアルに詳しい情報が載っています。<span class=filename>/etc/ttys</span> ファイルに <em>getty</em> タイプを設定する時は、 端末の通信設定が対応していることを確かめましょう。たとえば、Wyse-50 はパリティなしで、38400 bps で接続します。286 PC はパリティなしで、19200 bps で接続します。</p></li><li><p>第 3 フィールドは、その tty 回線に通常つながる端末の種別です。 ダイアルアップポートでは、実際、 ユーザがどんな種類の端末やソフトウェアで接続してくることもありうるので、 このフィールドには <code>unknown</code> または <code>dialup</code> がよく使われています。 ケーブルで配線された端末については、 端末種別は変わりませんので、<a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a> データベースファイルから実際の端末種別を、 このフィールドに記入できます。我々の例では、Wyse-50 には実際の端末種別を使っていますが、 Procomm を動かしている 286 PC は、VT-100 をエミュレートするように設定します。</p></li><li><p>4 番目のフィールドは、 ポートを有効にすべきかどうかを指定します。 ここに <code>on</code> と記入すると、 <code>init</code> プロセスが 2 番目のフィールドに記載されているプログラム、 <code>getty</code> を起動します。 このフィールドを <code>off</code> にすると、 <code>getty</code> は動かず、 そのポートからはログインできません。</p></li><li><p>最後のフィールドは、 そのポートが安全かどうか指定します。 あるポートが安全だということは、そのポートから <code>root</code> (またはその他の UID が 0 の) アカウントのログインを許可してよいと信頼しているということです。 安全でないポートからは、<code>root</code> のログインは許可されません。安全でないポートでは、 ユーザは特権を持たないアカウントでログインした後に、 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> や類似の仕組みを使ってスーパユーザ特権を獲得します。鍵のかかる部屋にある端末であっても、"insecure" にしておくことが強く推奨されます。 スーパユーザ特権が必要なら、ログインしてから <code>su</code> を使うのは十分簡単です。</p></li></ul></div></div></div></div><div class=sect4><h5 id=term-hup>17.3.2.2. <code>init</code> にファイル <span class=filename>/etc/ttys</span> の再読み込みをさせる<a class=anchor href=#term-hup></a></h5><div class=paragraph><p>必要な変更を <span class=filename>/etc/ttys</span> ファイルに加えたら、SIGHUP (ハングアップ) シグナルを <code>init</code> プロセスに送って設定ファイルを強制的に再読み込みさせます。 たとえば</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>init</code> は、システムで最初に起動するプロセスなので、 PID は常に 1 です。</p></div></td></tr></tbody></table></div><div class=paragraph><p>すべての設定が正しくおこなわれ、 すべてのケーブルがただしく接続されていて、 かつ端末の電源が入っていれば、この時点で各端末で <code>getty</code> プロセスが動いていて、 ログインプロンプトが表示されているはずです。</p></div></div></div><div class=sect3><h4 id=term-debug>17.3.3. 接続のトラブルシューティング<a class=anchor href=#term-debug></a></h4><div class=paragraph><p>細心の注意を払って設定をおこなっても、 ときには端末の接続がう まくいかない場合があるでしょう。以下に、 よく見られる問題とその解決方法 を示します。</p></div><div class=sect4><h5 id=_ログインプロンプトが表示されない>17.3.3.1. ログインプロンプトが表示されない<a class=anchor href=#_ログインプロンプトが表示されない></a></h5><div class=paragraph><p>端末の電源が接続され、 スイッチが入っていることを確認してください。もし、PC を端末として利用している場合は、 通信ソフトが適切なシリアルポー トを利用する設定になっているかどうか確かめてください。</p></div><div class=paragraph><p>ケーブルがしっかりと端末と FreeBSDが動作しているコンピュータの両方に接続され ていることを確認してください。また、 正しい種類のケーブルを利用している か確かめてください。</p></div><div class=paragraph><p>端末と FreeBSD の間の通信速度とパリティの設定が一致していることを確認 してください。 出力をモニタに表示するタイプの端末の場合は、モニタ のコントラストと明るさの設定を確認してください。また、 出力が印刷 されるタイプの端末の場合は、 紙とインクが十分にあるかどうかを確かめてく ださい。</p></div><div class=paragraph><p><code>getty</code> が動いていて、 端末を認識していることを確認してください。 たとえば、動作中の <code>getty</code> プロセスの一覧を <code>ps</code> で取得するには、以下のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps -axww|grep getty</span></code></pre></div></div><div class=paragraph><p>その端末に対応する項目が表示されるはずです。 たとえば、以下の表示例は、<code>getty</code> は 2 番目のシリアルポート (<code>ttyd1</code>) に対して <span class=filename>/etc/gettytab</span> 中の <code>std.38400</code> エントリを使って動作しているということを示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1</code></pre></div></div><div class=paragraph><p>もし、<code>getty</code> プロセスが一つも動いていないようであれば、 <span class=filename>/etc/ttys</span> の中で、 そのポートを利用可能にする設定をしたかどうか確かめてください。 また、<span class=filename>ttys</span> ファイルを変更したら、<code>kill -HUP 1</code> を実行するのを忘れないでください。</p></div></div><div class=sect4><h5 id=_ログインプロンプトの代わりにゴミが表示される>17.3.3.2. ログインプロンプトの代わりにゴミが表示される<a class=anchor href=#_ログインプロンプトの代わりにゴミが表示される></a></h5><div class=paragraph><p>端末と FreeBSD の間の通信速度およびパリティの設定が一致していることを確 かめてください。また、<code>getty</code> プロセスの情報を調べて、適切な <em>getty</em> のタイプが使用されていることを確認してください。間違った <em>getty</em> タイプが使用されている場合は、 <span class=filename>/etc/ttys</span> を修正し てから、 <code>kill -HUP 1</code> を実行してください。</p></div></div><div class=sect4><h5 id=_文字が重複して表示される入力したパスワードが表示される>17.3.3.3. 文字が重複して表示される、入力したパスワードが表示される<a class=anchor href=#_文字が重複して表示される入力したパスワードが表示される></a></h5><div class=paragraph><p>端末または通信ソフトの設定で、"半二重 (half duplex)" あるいは "ローカ ルエコー" となっているところを、"全二重 (full duplex)" に変更してください。</p></div></div></div></div><div class=sect2><h3 id=dialup>17.4. ダイアルインサービス<a class=anchor href=#dialup></a></h3><div class=paragraph><p><em>訳: . 6 September 1996.</em></p></div><div class=paragraph><p>FreeBSD システムをダイアルインサービス用に設定することは、 端末の代わりにモデムを扱うこと以外は、 端末の接続によく似ています。</p></div><div class=sect3><h4 id=_外づけモデムと内蔵モデムについて>17.4.1. 外づけモデムと内蔵モデムについて<a class=anchor href=#_外づけモデムと内蔵モデムについて></a></h4><div class=paragraph><p>ダイアルアップのサービスに関していえば、 外づけのモデムの方が適している ようです。これは、 多くの外づけのモデムは設定を不揮発ラムに書き込んで半 永久的に保存することができますし、また RS-232 に関する重要な情報を知る ための点滅するライトによるインディケータが 搭載されているからです。点滅 するライトは、 システムを見に来た訪問者に強い印象を与えるという効果だけ でなく、モデムが適切に動作しているかどうかを知るためにも 有効です。</p></div><div class=paragraph><p>一方、たいていの内蔵型のモデムには 不揮発性ラムが搭載されていないため、ディップ スイッチの変更以外に設定を保存する方法がありません。また、も しインディケータがついていても、おそらくコンピュータのケース カバーが 外されていなければその状態を確認するのは 難しいでしょう。</p></div><div class=sect4><h5 id=_モデムとケーブル>17.4.1.1. モデムとケーブル<a class=anchor href=#_モデムとケーブル></a></h5><div class=paragraph><p>外付けモデムを使用しているなら、 それにあったケーブルが必要です。 通常の信号が全て接続されている限り、標準的な RS-232C ケーブルで十分でしょう。</p></div><div class=ulist><ul><li><p>Transmitted Data (SD)</p></li><li><p>Received Data (RD)</p></li><li><p>Request to Send (RTS)</p></li><li><p>Clear to Send (CTS)</p></li><li><p>Data Set Ready (DSR)</p></li><li><p>Data Terminal Ready (DTR)</p></li><li><p>Carrier Detect (CD)</p></li><li><p>Signal Ground (SG)</p></li></ul></div><div class=paragraph><p>FreeBSD で 2400bps 以上の転送速度を利用する場合には、 フロー制御のため に RTS 信号と CTS 信号が必要です。また、 接続の確立と回線の切 断を検出するために CD 信号を利用します。さらに、 DTR 信号を使っ て回線切断後のモデムのリセットを行います。ケーブルの中には、 総ての必要 な信号線が接続されていないものもありますので、 たとえば、回線切断後でも ログイン セッションが残ってしまうといった問題が発生した場合などには、 ケーブルに問題がある可能性もあります。</p></div><div class=paragraph><p>FreeBSD も他の Unix 系 OS と同様、回線の接続およ び切断の検出や回線の切断および回線切断後の モデムの初期化にハードウェア シグナルを利用します。FreeBSD は、モデムに対するコマンドの送信やモデ ムの状態の監視を行いません。パソコンで運用されている BBS への接続に慣 れている方にとっては、 ちょっとめんどうかもしれませんね。</p></div></div></div><div class=sect3><h4 id=_シリアル_インタフェースについて>17.4.2. シリアル インタフェースについて<a class=anchor href=#_シリアル_インタフェースについて></a></h4><div class=paragraph><p>FreeBSD では、NS8250-、NS16450-、NS16550- および NS16550A- に基づ いた EIA RS-232C (CCITT V.24) 規格のシリアル インタフェースをサポート しています。8250 および 16450 ベースのディバイスには1文字のキャラクタ バッファが搭載されています。また、16550 系のディバイスには、 16文字分 のバッファが搭載されていて、 はるかによいパフォーマンスを得られます (ただし、無印の 16550 では、バグがあって 16 文字バッファが利用できませ んので、可能であれば 16550A 系のディバイスを利用してください)。1文字 のバッファの物は、 16550 系のものと比べて OS にかける負荷が大きいので、16550A 系ディバイスの利用を強く推奨します。多数のシリアル ポートを利 用する場合や、負荷の高いシステムにおいては、 16550A 系ディバイスを使う ことで、 エラー発生率を低く押さえることができます。</p></div></div><div class=sect3><h4 id=_概要>17.4.3. 概要<a class=anchor href=#_概要></a></h4><div class=paragraph><p>端末に関しては、 ダイアルイン接続に割り当てられたそれぞれのシリアルポートに対して、 <code>init</code> が <code>getty</code> を起動します。たとえば、モデムが <span class=filename>/dev/ttyd0</span> に割り当てられていたら、<code>ps ax</code> コマンドを実行すると、以下のような出力が得られるはずです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0</code></pre></div></div><div class=paragraph><p>ユーザがモデムに電話をかけ、モデム同士が接続されると、 モデムの CD (Carrier Detect) が検出されます。その結果、 kernel がキャリア信号を検出して、<code>getty</code> によるポートのオープンの処理が終了します。 <code>getty</code> は、<code>login:</code> プロンプトを指定されている初期回線速度で送信します。 <code>getty</code> は、 正常に文字列を受信できるかどうか監視し、通常の設定では、 もし異常な文字列を検出した場合 (理由としては、 <code>getty</code> の速度とモデ ムの接続速度が異なっているような場合が考えられます)、 正常に文字列が 受信できるまで、<code>getty</code> は速度を変え続けます。</p></div><div class=paragraph><p>ユーザがログイン名を入力すると、 <code>getty</code> は <span class=filename>/usr/bin/login</span> を起動して、 パスワードの入力を要求し、その 後ユーザのシェルを起動します。</p></div></div><div class=sect3><h4 id=_設定ファイル>17.4.4. 設定ファイル<a class=anchor href=#_設定ファイル></a></h4><div class=paragraph><p>FreeBSD のシステムへのダイアルアップによるアクセスを実現するために編集が必要と思われる設定ファイルが、 <span class=filename>/etc</span> ディレクトリに 3 つあります。まず、 <span class=filename>/etc/gettytab</span> には、 <span class=filename>/usr/libexec/getty</span> デーモンの設定を記述します。つぎに、 <span class=filename>/etc/ttys</span> に保存されている情報から、 <span class=filename>/sbin/init</span> はどの <span class=filename>tty</span> デバイスに対して <code>getty</code> のプロセスを実行するべきか判断します。 最後に、<span class=filename>/etc/rc.serial</span> スクリプトに、 シリアルポートの初期化のためのコマンドを記述することができます。</p></div><div class=paragraph><p>Unix にダイアルアップモデムを接続する方法には、 二つの考え方があります。一つの方法は、 ダイアルインしてくるユーザの接続速度に関係なく、 常にモデムとローカルのコンピュータの RS-232 インタフェースの接続速度を一定に保つように設定する方法です。 この設定の長所は、ユーザがダイアルインして接続されると、 即座にシステムからのログインプロンプトが送信されるということです。 短所は、システムが実際のモデム間の速度を知ることができないために、 Emacs のようなフルスクリーンのプログラムが、 端末との接続速度が遅い場合でも、 そのような場合に効果的な方法で画面出力を行わない点です。</p></div><div class=paragraph><p>もう一つは、モデムの RS-232 インタフェースとコンピュータの接続速度を、 モデム間の接続速度に応じて変化させるような設定です。たとえば、 モデム間 の接続が V.32bis (14.4 Kbps) ならば、 モデムとコンピュータの間の接続を 19.2 Kbps とし、 モデム間の接続が 2400 bps の時には、モデムとコンピュータ間も 2400 bps で接続するような設定をします。この場合、 <code>getty</code> は、モデムが返すリザルトコードからモデムとコンピュータの接続速度を認識することができませんので、 <code>getty</code> は、まず初期速度で <code>login:</code> という文字列を送信して、それに対する応答の文字列を監視します。 ここで、ユーザ側の端末に無意味な文字列が表示された場合、 ユーザは意味のある文字列を受信するまで Enter キーを繰り返し押さなければならないということを知っていると仮定しています。 もし接続速度が間違っている場合、<code>getty</code> は、 ユーザから送られた文字を無意味な文字列として扱い、 次の速度を試します。そして、ここで再度 <code>login:</code> プロンプトを送信します。 この一連の動作が異常な回数繰り返されることも考えられますが、 普通は 1 度か 2 度のキー入力があれば、 ユーザはまともなプロンプトを受信できます。 このログインの動作が前者の固定速度による方法に比べて美しくないのは明らかですが、 この方法では、低速度で接続しているユーザに対するフルスクリーンのプログラムからのレスポンスが改善されます。</p></div><div class=paragraph><p>このセクションでは、両方の設定方法について解説しますが、 どちらかというとモデム間の速度に応じて RS-232 インタフェースの速度が変化するような 設定の方に偏った説明になってしまうと思います。</p></div><div class=sect4><h5 id=_etcgettytab>17.4.4.1. <span class=filename>/etc/gettytab</span><a class=anchor href=#_etcgettytab></a></h5><div class=paragraph><p><span class=filename>/etc/gettytab</span> は、<a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> の設定ファイルで、<a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a> と同様の形式で記述されます。ファイルのフォーマットや定 義できる機能についての詳細については、<a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> のマニュアルを ご覧ください。</p></div><div class=sect5><h6 id=_固定速度の設定>17.4.4.1.1. 固定速度の設定<a class=anchor href=#_固定速度の設定></a></h6><div class=paragraph><p>モデムとコンピュータ間の通信速度を固定して使う場合、 おそらく <span class=filename>/etc/gettytab</span> に特に変更を加える必要はないはずです。</p></div></div><div class=sect5><h6 id=_可変速度の設定>17.4.4.1.2. 可変速度の設定<a class=anchor href=#_可変速度の設定></a></h6><div class=paragraph><p><code>getty</code> が利用するモデムとコンピュータの接続速度に関する情報を <span class=filename>/etc/gettytab</span> に記述する必要があります。もし、2400 bps のモ デムをお使いになるのであれば、既存の <code>D2400</code> のエントリがそのまま利 用できるでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</pre></div></div><div class=paragraph><p>高速モデムをお使いの場合は、おそらく <span class=filename>/etc/gettytab</span> に新たなエントリを追加する必要があります。 以下の例は、14.4 Kbps のモデムを、 最大インタフェース速度を 19.2 Kbps として利用するためのエントリです。</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</pre></div></div><div class=paragraph><p>上記の例を利用した場合、 パリティなし、8ビットの接続が行われます。</p></div><div class=paragraph><p>上記の例では、まず 19.2 Kbps (V.32bis) によるモデムとコンピュータ間の接続を試み、続いて 9600 bps (V.32)、2400 bps、1200 bps、300 bpsと順に試み、再び 19.2 Kbps による接続を試みるという循環に入ります。 この接続速度の循環は、<code>nx=</code>("next table") の機能で実現されています。また、 各行はそれぞれ <code>tc=</code>("table continuation") の機能を使って、 その他の接続速度に依存した "標準的な" 設定を取り込んでいます。</p></div><div class=paragraph><p>もし、お使いのモデムが 28.8 Kbps であったり、14.4 Kbps の圧縮転送の機能を有効に利用したい場合は、19.2 Kbps よりも速い速度を利用するように設定する必要があります。 以下に 57.6 Kbps から接続を試みる <span class=filename>gettytab</span> の設定例を示しておきます。</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</pre></div></div><div class=paragraph><p>もし、お使いの CPU が低速のものであったり、CPU に対する負荷が高い場合で、16550A 系のシリアルポートをお使いでない場合、 57.6 Kbps の接続において、<code>sio</code> の "silo" エラーが発生するかもしれません。</p></div></div></div><div class=sect4><h5 id=dialup-ttys>17.4.4.2. <span class=filename>/etc/ttys</span><a class=anchor href=#dialup-ttys></a></h5><div class=paragraph><p><span class=filename>/etc/ttys</span> ファイルの設定は、<a href=#ex-etc-ttys>端末の項目を <span class=filename>/etc/ttys</span> に追加する</a> で扱われています。 モデムの設定も似たようなものですが、<code>getty</code> に異なる引数を渡して、異なる端末種別を指定しなければなりません。 固定速度および可変速度両方に共通する形式は次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd0   &#34;/usr/libexec/getty xxx&#34;   dialup on</pre></div></div><div class=paragraph><p>1 番目の項目は、このエントリで対象とするデバイススペシャルファイルです。 上の例では <code>ttyd0</code> として、 <span class=filename>/dev/ttyd0</span> を <code>getty</code> に監視させることを表しています。2 番目の項目 <code>"/usr/libexec/getty xxx"</code> (<em>xxx</em> は初期段階で使われる <span class=filename>gettytab</span> のエントリに置き換えてください) が、<code>init</code> がこのディバイスに対して起動するプロセスです。3 番目の <code>dialup</code> は、デフォルトのターミナルタイプです。 4 番目の <code>on</code> は、 この行が有効であることを <code>init</code> に対して示しています。5 番目の項目に <code>secure</code> を指定することもできますが、これは、 たとえばシステムのコンソールのように、 物理的に安全な端末に対してのみ指定するようにしてください。</p></div><div class=paragraph><p>デフォルトのターミナルタイプ (上記の例では <code>dialup</code>) は、ローカルのユーザの好みによって異なってきます。 ユーザがログインスクリプトをカスタマイズして、ターミナルタイプが <code>dialup</code> の時には自動的に他のターミナルタイプを設定できるように、 ダイアルアップのポートのデフォルトのターミナルタイプには <code>dialup</code> が伝統的に用いられています。 しかし、筆者のサイトでは、ほとんどのユーザが VT102 エミュレーションを使っているので、 ダイアルアップのポートのデフォルトターミナルタイプとして <code>vt102</code> を指定しています。</p></div><div class=paragraph><p><span class=filename>/etc/ttys</span> の修正がすんだら、 以下のようなコマンドを使って <code>init</code> プロセスに HUP シグナルを送り、<span class=filename>/etc/ttys</span> を読み込み直させてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>ただ、もし初めてシステムを設定しているのであれば、 モデムが適切に設定されて接続されるまでは、 <code>init</code> に対してシグナルを送らない方がいいかもしれません。</p></div><div class=sect5><h6 id=_固定速度の設定_2>17.4.4.2.1. 固定速度の設定<a class=anchor href=#_固定速度の設定_2></a></h6><div class=paragraph><p>速度を固定する設定では、<span class=filename>/etc/ttys</span> の中で、<code>getty</code> に対し て固定速度のエントリを指定する必要があります。たとえば、 以下の例はポートのスピードが 19.2 Kbps に固定されたモデムのための <span class=filename>ttys</span> のエントリです。</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd0   &#34;/usr/libexec/getty std.19200&#34;   dialup on</pre></div></div><div class=paragraph><p>モデムが異なる速度で固定されている場合は、 <code>std.19200</code> のかわりに <code>std.speed</code> を適切な値に置き換えたものにしてください。 <span class=filename>/etc/gettytab</span> に挙がっている適切な種類を使うようにしてください。</p></div></div><div class=sect5><h6 id=_可変速度の設定_2>17.4.4.2.2. 可変速度の設定<a class=anchor href=#_可変速度の設定_2></a></h6><div class=paragraph><p>可変速度の設定では、<span class=filename>ttys</span> のエントリが、<span class=filename>/etc/gettytab</span> の中の適切な "自動速度調整" の初期設定のエントリを参照していなければな りません。 たとえば、もし前述の 19.2 Kbps から接続を試みる可変速度の設定例 (<code>V19200</code> の <span class=filename>gettytab</span> エントリ)をそのまま <em>ttys</em> に追加したのであれば、 <span class=filename>ttys</span> エントリは以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd0   &#34;/usr/libexec/getty V19200&#34;   dialup on</pre></div></div></div></div><div class=sect4><h5 id=_etcrc_serial>17.4.4.3. <span class=filename>/etc/rc.serial</span><a class=anchor href=#_etcrc_serial></a></h5><div class=paragraph><p>V.32、V.32bis または V.34 モデムのような高速モデムを利用する場合、ハードウェア (<span class=filename>RTS/CTS</span>) フロー制御を行う必要があります。FreeBSD kernel のモデムポートにハードウェアフロー制御のフラグを設定するための <code>stty</code> コマンドを、 <span class=filename>/etc/rc.serial</span> に記述できます。</p></div><div class=paragraph><p>たとえば、シリアルポート 1 番 (<span class=filename>COM2</span>) のダイヤルインおよびダイヤルアウト初期化デバイスに <code>termios</code> フラグ <code>crtscts</code> を設定するには、次の行を <span class=filename>/etc/rc.serial</span> に追加するとよいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre># Serial port initial configuration
stty -f /dev/ttyid1 crtscts
stty -f /dev/cuai01 crtscts</pre></div></div></div></div><div class=sect3><h4 id=_モデムの設定>17.4.5. モデムの設定<a class=anchor href=#_モデムの設定></a></h4><div class=paragraph><p>もし、あなたのモデムがパラメータを不揮発ラムに 保存できるタイプならば、MS-DOS 上の Telix や FreeBSD 上の <code>tip</code> などのような通信プログラム を使って、 パラメータを設定してください。<code>getty</code> が利用する初期速度でモデムに接続して、以下の条件を満たすよ うに不揮発ラムの設定を変更してください。</p></div><div class=ulist><ul><li><p>接続時に CD 信号がオンになる</p></li><li><p>接続時に DTR がオンになり、 オフで回線を切断しモ デムをリセットする。</p></li><li><p>送信時フロー制御には CTS を利用。</p></li><li><p>XON/XOFF によるフロー制御を行わない。</p></li><li><p>受信時のフロー制御は RTS を使用。</p></li><li><p>Quiet mode (リザルト コードを返さない)</p></li><li><p>コマンド エコーを返さない。</p></li></ul></div><div class=paragraph><p>これらを実現するためのコマンドやディップ スイッチの設定に関しては、モ デムのマニュアルを参照してください。</p></div><div class=paragraph><p>以下に、USRobotics Sportster の 14,400 bps の外づけモデムの設定例を示 しておきます。</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
ATC1D2H1I0R2W</pre></div></div><div class=paragraph><p>ことのついでに、たとえば、V42.bis や MNP5 のデータ圧縮を使用するかど うかなどのモデムの他の設定について確認、 調整しておくのもよいかもしれま せん。</p></div><div class=paragraph><p>さらに、USRobotics Sportster の 14,400 bps の外づけモデムでは、以下の ようなディップ スイッチの設定も必要です。他のモデムをお使いの方も、以 下の例を設定の参考にしてください。</p></div><div class=ulist><ul><li><p>スイッチ 1: UP - DTR 標準</p></li><li><p>スイッチ 2: N/A (リザルトコードを単語形式にするか数値形式にするか)</p></li><li><p>スイッチ 3: UP - リザルトコードを返さない</p></li><li><p>スイッチ 4: DOWN - コマンドエコーを返さない</p></li><li><p>スイッチ 5: UP - 自動着信</p></li><li><p>スイッチ 6: UP - CD 標準</p></li><li><p>スイッチ 7: UP - 不揮発ラムからデフォルト値をロードする</p></li><li><p>スイッチ 8: N/A (Smart Mode/Dumb Mode)</p></li></ul></div><div class=paragraph><p>リザルト コードを返さないように設定しておかないと、 <code>getty</code> が誤っ て <code>login:</code> プロンプトをコマンド モードのモデムに送信してしまった場 合に、 モデムがこの入力をエコーしたり、この入力に対するリザルト コード を返してしまったりすることになります。この結果として、 モデムと <code>getty</code> の間で延々と無意味なやりとりが続いてしまう可能性があります。</p></div><div class=sect4><h5 id=_固定速度の設定_3>17.4.5.1. 固定速度の設定<a class=anchor href=#_固定速度の設定_3></a></h5><div class=paragraph><p>固定速度の設定では、 モデムとコンピュータ間の通信速度をモデムとモデム間 の接続速度に関係なく、常に一定に保つように、 モデムを設定する必要があり ます。USRobotics Sportster の 14,400 bps 外づけモデムの場合、以下のコ マンドで、 モデムとコンピュータ間の速度が、コマンド送信時の速度に固定さ れます。</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
ATB1W</pre></div></div></div><div class=sect4><h5 id=_可変速度の設定_3>17.4.5.2. 可変速度の設定<a class=anchor href=#_可変速度の設定_3></a></h5><div class=paragraph><p>可変速度の設定では、シリアル ポートの速度が、 着信速度に応じて変化する ように設定しなければいけません。 USRobotics Sporster の 14,400 bps 外 づけモデムの場合、 以下のコマンドで、エラー訂正機能を利用した通信の場合 は、 コマンドを送信した時の通信速度にシリアル ポートの速度を固定し、エ ラー訂正機能を利用しない接続では、 シリアル ポートの速度が変化するよう に設定されます。</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
ATB2W</pre></div></div></div><div class=sect4><h5 id=_モデムの設定の確認>17.4.5.3. モデムの設定の確認<a class=anchor href=#_モデムの設定の確認></a></h5><div class=paragraph><p>ほとんどの高速モデムには、 現在の設定をある程度人間にも理解できる形式に して表示させるコマンドがあります。USRobotics Sporster の 14,400 bps 外づけモデムの場合は、<code>ATI5</code> コマンドで、現在の不揮発ラムの設定を 表示することができます。 さらに、ディップ スイッチの設定も含めた現在の 設定を確認するためには、<code>ATZ</code> コマンドを送信してから、<code>ATI4</code> コマンドを送信してください。</p></div><div class=paragraph><p>他のメーカーのモデムをお使いの場合は、 モデムのマニュアルで設定値の確認 方法を確認してください。</p></div></div></div><div class=sect3><h4 id=_トラブルシューティング_2>17.4.6. トラブルシューティング<a class=anchor href=#_トラブルシューティング_2></a></h4><div class=paragraph><p>以下の手順でダイアル アップ モデムの動作を確認することができます。</p></div><div class=sect4><h5 id=_freebsd_システムの動作確認>17.4.6.1. FreeBSD システムの動作確認<a class=anchor href=#_freebsd_システムの動作確認></a></h5><div class=paragraph><p>モデムを FreeBSD システムに接続し、 システムをブートします。あなたのモ デムにモデムの状態を確認するためのインジケータがあれば、 DTR のイ ンジケータの状態に注目してください。もし、 システムのコンソールに <code>login:</code> プロンプトが表示された時に、DTR のインジケータが点灯 すれば、FreeBSD が適切なポートに対して <code>getty</code> を起動し、モデムへ の着信を待っている状態であることを意味しています。</p></div><div class=paragraph><p>もし DTR のインジケータが点灯しない場合は、システムのコンソールから FreeBSD にログインして、<code>ps ax</code> を実行し、 FreeBSD が適切なポートに対して<code>getty</code> プロセスを起動しようとしているのかどうか確認してください。 プロセスに関する情報の中に、 以下のような行が表示されるはずです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1</code></pre></div></div><div class=paragraph><p>モデムにまだ着信がない状態の時に、 以下のように上とは異なる出力があった 場合、<code>getty</code> は既にモデム ポートのオープンを終了したということに なります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0</code></pre></div></div><div class=paragraph><p><code>getty</code> は、CD (carrier detect) 信号がオンの状態になるまで、 ポートのオープンを完了することはできませんので、 この場合は接続に問題が あるか、あるいはモデムの設定に問題があることが考えられます。</p></div><div class=paragraph><p>もし、期待した <span class=filename>ttydN</span> ポートをオープンしようとしている <code>getty</code> が見あたらない場合は、再度 <span class=filename>/etc/ttys</span> の内容を確認し、 書式などに誤りがないか 調べてみてください。また、ログ ファイル <span class=filename>/var/log/messages</span> に <code>init</code> および <code>getty</code> から何か出力がないかどうかも確認してみてく ださい。 もし何かメッセージが記録されていたら、再度 <span class=filename>/etc/ttys</span>、 <span class=filename>/etc/gettytab</span> の二つの設定ファイルと、 ディバイス スペシャルファイル <span class=filename>/dev/ttydN</span> を確認し、 記述に誤りがないか、足りないエントリがないか、 足りないディバイス スペシャルファイルがないかといった 点について調べてみてください。</p></div></div><div class=sect4><h5 id=_モデムで接続してみる>17.4.6.2. モデムで接続してみる<a class=anchor href=#_モデムで接続してみる></a></h5><div class=paragraph><p>実際にモデムを使って別のコンピュータから 接続してみてください。この時、8 ビット、パリティなし、 1 ストップビットで接続するようにしてください。 接続後すぐにプロンプトが返ってこない場合や、 無意味な文字列が表示される 場合は、1秒に1回くらいの割合で Enter キーを押してみてください。 しばらくたって、なおも <code>login:</code> プロンプトが現れない場合 は、<code>BREAK</code> 信号を送信してみてください。この時、端末側で使って いるモデムが高速モデムならば、 このモデムのインタフェースの接続速度を固 定してから、 再度ダイアル インしてみてください。(たとえば、USRobotics Sportster の場合は、<code>ATB1</code>)</p></div><div class=paragraph><p>それでもまだ <code>login:</code> プロンプトが表示されない場合は、 <span class=filename>/etc/gettytab</span> の以下の点について再度確認してみてください。</p></div><div class=ulist><ul><li><p><span class=filename>/etc/ttys</span> の対応する行の 2番目の項目で、<span class=filename>/etc/gettytab</span> の中で定義されているエントリが指定されているか</p></li><li><p>各 <code>nx=</code> で <span class=filename>/etc/gettytab</span> の中で定義されているもの が指定されているか</p></li><li><p>各 <code>tc=</code> で <span class=filename>/etc/gettytab</span> の中で定義されているもの が指定されているか</p></li></ul></div><div class=paragraph><p>もしダイアル インしても、FreeBSD システム側のモデムが応答しない場合は、FreeBSD 側のモデムが DTR がオンになった時に電話にでるように設定さ れているかを確認してください。 もしモデムの設定に問題がなさそうならば、 モデムのインジケータ (がもしあれば) で、 DTR がオンになっているか を確認してください。</p></div><div class=paragraph><p>この確認のステップを数回繰り返しても うまくいかない場合は、一度休憩して、 しばらくたってから挑戦してみましょう。それでもだめなら、 おそらく <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>FreeBSD general questions メーリングリスト</a> にあなたのモデムについての情報と問題を書いたメールを送れ ば、 メーリング リストのメンバーが問題の解決を助けるべく努力してくれる でしょう。</p></div></div></div></div><div class=sect2><h3 id=dialout>17.5. ダイアルアウトサービス<a class=anchor href=#dialout></a></h3><div class=paragraph><p>以下はモデムを利用して他のコンピュータと 接続する方法を説明しています。 これはリモートホストとターミナル接続を確立するための 適切な方法です。</p></div><div class=paragraph><p>これは BBS に接続するときによく使います。</p></div><div class=paragraph><p>この種の接続は PPP 接続に問題がある場合、Internet 上にあるファイルを 転送するのに非常に役に立ちます。FTP で何らかのファイルを転送したいのに PPP 接続を確立できない場合は、ファイルを FTP 転送するためにターミナルセッション を利用します。そして ZMODEM を利用してファイルを転送します。</p></div><div class=sect3><h4 id=_私の_hayes_モデムはサポートされていません_どうすればよいでしょう>17.5.1. 私の Hayes モデムはサポートされていません、 どうすればよいでしょう?<a class=anchor href=#_私の_hayes_モデムはサポートされていません_どうすればよいでしょう></a></h4><div class=paragraph><p>実際、<code>tip</code> の マニュアルページは古くなっています。既に Hayes ダイアラが組み込まれています。<span class=filename>/etc/remote</span> ファイル中で <code>at=hayes</code> を使ってください。</p></div><div class=paragraph><p>Hayes ドライバは、最近のモデムの新しい機能である <code>BUSY</code>、<code>NO DIALTONE</code>、 <code>CONNECT 115200</code>などのメッセージを 認識できるほど賢くはなく、単に混乱を起こすだけです。 <code>tip</code>を使う場合には、 (<code>ATX0W</code> とするなどして) これらの メッセージを表示させないようにしなくてはいけません。</p></div><div class=paragraph><p>また、<code>tip</code> のダイアルのタイムアウトは 60秒です。モデムの タイムアウト設定はそれより短くすべきであり、 そうしないと <code>tip</code> は通信に問題があると判断するでしょう。 <code>ATS7=45W</code> を実行してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>デフォルトの <code>tip</code> は、 Hayes モデムに完全に対応しているわけではありません。解決方法は <span class=filename>/usr/src/usr.bin/tip/tip</span> の下の <span class=filename>tipconf.h</span> を変更することです。 もちろんこれにはソース配布ファイルが必要です。</p></div><div class=paragraph><p><code>#define HAYES 0</code> と記述されている行を <code>#define HAYES 1</code> と変更し、そして <code>make</code>, <code>make install</code> を実行します。これでうまく動作するでしょう。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=direct-at>17.5.2. これらの AT コマンドを入力するには?<a class=anchor href=#direct-at></a></h4><div class=paragraph><p><span class=filename>/etc/remote</span> ファイルの中で "direct" エントリを作ります。たとえばモデムが 1番目のシリアルポートである <span class=filename>/dev/cuaa0</span> に接続されている場合、次のようにします:</p></div><div class="literalblock programlisting"><div class=content><pre>cuaa0:dv=/dev/cuaa0:br#19200:pa=none</pre></div></div><div class=paragraph><p>モデムがサポートする最大の bps レートを br フィールドに使います。そして <code>tip cuaa0</code> を実行すると、モデムが利用できるようになります。</p></div><div class=paragraph><p><span class=filename>/dev/cuaa0</span> がシステムに存在しない場合は、次のようにします:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># sh MAKEDEV cuaa0</span></code></pre></div></div><div class=paragraph><p>または <code>root</code> になって以下のように <code>cu</code> コマンドを実行します:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -lline -sspeed</span></code></pre></div></div><div class=paragraph><p><em>line</em> にはシリアルポートを指定します (例えば <span class=filename>/dev/cuaa0</span>)。そして <em>speed</em> には接続する速度を指定します (例えば <code>57600</code>)。その後 AT コマンドを実行したら、<kbd>~.</kbd> と入力すれば終了します。</p></div></div><div class=sect3><h4 id=_pn_機能の_記号が使えません>17.5.3. pn 機能の <code>@</code> 記号が使えません!<a class=anchor href=#_pn_機能の_記号が使えません></a></h4><div class=paragraph><p>電話番号 (pn) 機能の中での <code>@</code> 記号は、 tip に <span class=filename>/etc/phone</span> にある電話番号を参照するように伝えます。しかし <code>@</code> の文字は <span class=filename>/etc/remote</span> のような 設定ファイルの中では特殊文字となります。 バックスラッシュを使ってエスケープをおこないます:</p></div><div class="literalblock programlisting"><div class=content><pre>pn=\@</pre></div></div></div><div class=sect3><h4 id=_コマンドラインから電話番号を指定するには>17.5.4. コマンドラインから電話番号を指定するには?<a class=anchor href=#_コマンドラインから電話番号を指定するには></a></h4><div class=paragraph><p>"generic" エントリと呼ばれるものを <span class=filename>/etc/remote</span> に追加します。 例えば次のようにします:</p></div><div class="literalblock programlisting"><div class=content><pre>tip115200|Dial any phone number at 115200 bps:\
	    :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600bps:\
	    :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>そして</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tip -115200 5551234</span></code></pre></div></div><div class=paragraph><p>のように利用できます。 <code>tip</code> より <code>cu</code> を使いたい場合、 <code>cu</code> の generic エントリを使います。</p></div><div class="literalblock programlisting"><div class=content><pre>cu115200|Use cu to dial any number at 115200bps:\
	:dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>そして</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu 5551234 -s 115200</span></code></pre></div></div><div class=literalblock><div class=content><pre>と実行します。</pre></div></div></div><div class=sect3><h4 id=_毎回_bps_レートを入力しなければいけませんか>17.5.5. 毎回 bps レートを入力しなければいけませんか?<a class=anchor href=#_毎回_bps_レートを入力しなければいけませんか></a></h4><div class=paragraph><p><code>tip1200</code> や <code>cu1200</code> 用のエントリを記述し、適切な通信速度を br フィールドに設定します。<code>tip</code> は 1200 bps が正しいデフォルト値であるとみなすので、 <code>tip1200</code> エントリを参照します。もちろん 1200 bps を使わなければならないわけではありません。</p></div></div><div class=sect3><h4 id=_ターミナルサーバを経由して複数のホストへアクセスしたいです>17.5.6. ターミナルサーバを経由して複数のホストへアクセスしたいです<a class=anchor href=#_ターミナルサーバを経由して複数のホストへアクセスしたいです></a></h4><div class=paragraph><p>毎回接続されるのを待って <code>CONNECT host</code> と入力する かわりに、tip の <code>cm</code> 機能を使います。 例えば、<span class=filename>/etc/remote</span> に次のようなエントリを追加します:</p></div><div class="literalblock programlisting"><div class=content><pre>pain|pain.deep13.com|Forrester&#39;s machine:\
	:cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank&#39;s machine:\
	:cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
	:dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:</pre></div></div><div class=paragraph><p>これで、<code>tip pain</code> や <code>tip muffin</code> と実行すると pain や muffin のホストに接続することができ、 <code>tip deep13</code> を実行するとターミナルサーバに接続します。</p></div></div><div class=sect3><h4 id=_tip_を使ってそれぞれのサイトの_複数の回線に接続できますか>17.5.7. tip を使ってそれぞれのサイトの 複数の回線に接続できますか?<a class=anchor href=#_tip_を使ってそれぞれのサイトの_複数の回線に接続できますか></a></h4><div class=paragraph><p>これは大学に電話回線がいくつかあって 数千人の学生が接続しようとする 場合によくある問題です。</p></div><div class=paragraph><p>あなたの大学のエントリを <span class=filename>/etc/remote</span> ファイルに作成して、<code>pn</code> のフィールドには <code>@</code> を使います:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university:\
	:pn=\@:tc=dialout
dialout:\
	:dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</pre></div></div><div class=paragraph><p>そして <span class=filename>/etc/phone</span> ファイルに大学の電話番号の一覧を書きます:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</pre></div></div><div class=paragraph><p><code>tip</code> は一連の電話番号を試みて、 最終的に接続できなければあきらめます。 リトライを続けさせたい場合は、<code>tip</code> を while ループに入れて 実行します。</p></div></div><div class=sect3><h4 id=_ctrlp_を_1_回送るために_ctrlp_を_2_度押す必要があるのはなぜ>17.5.8. <span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> を 1 回送るために <span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> を 2 度押す必要があるのはなぜ?<a class=anchor href=#_ctrlp_を_1_回送るために_ctrlp_を_2_度押す必要があるのはなぜ></a></h4><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> はデフォルトの "force (強制)" 文字であり、 <code>tip</code> に次の文字が リテラルデータであることを伝えます。force 文字は "変数の設定" を意味する <code>~s</code> エスケープによって他の文字にすることができます。</p></div><div class=paragraph><p><code>~sforce=single-char</code> と入力して改行します。<em>single-char</em> は、任意の 1 バイト文字です。 <em>single-char</em> を省略すると NUL 文字になり、これは <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> や <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Space</kbd></span> を押しても入力できます。また、 <em>single-char</em> に <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span> を割り当てる方法を使っているターミナルサーバもあります。</p></div><div class=paragraph><p><span class=filename>$HOME/.tiprc</span> に次のように定義することで、任意の文字を force 文字として利用できます:</p></div><div class="literalblock programlisting"><div class=content><pre>force=single-char</pre></div></div></div><div class=sect3><h4 id=_打ち込んだ文字が突然すべて大文字になりました>17.5.9. 打ち込んだ文字が突然すべて大文字になりました??<a class=anchor href=#_打ち込んだ文字が突然すべて大文字になりました></a></h4><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span> を押してしまい、caps-lock キーが壊れている場合のために設計された <code>tip</code> の "raise character" モードに入ったのでしょう。 既に述べたように <code>~s</code> を使って、 <code>raisechar</code> をより適切な値に 変更してください。もしこれら両方の機能を使用しないのであれば、 force 文字と同じ設定にすることもできます。</p></div><div class=paragraph><p>以下は <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> や <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span> などを頻繁に使う必要のある Emacs ユーザにうってつけの .tiprc ファイルのサンプルです。</p></div><div class="literalblock programlisting"><div class=content><pre>force=^^
raisechar=^^</pre></div></div><div class=paragraph><p>^^ は <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span> です。</p></div></div><div class=sect3><h4 id=_tip_でファイルを転送するには>17.5.10. <code>tip</code> でファイルを転送するには?<a class=anchor href=#_tip_でファイルを転送するには></a></h4><div class=paragraph><p>もし他の Unix のシステムと接続しているなら、 <code>~p</code>(put) や <code>~t</code>(take) でファイルの送受信ができます。これらのコマンドは 相手のシステムの上で <code>cat</code> や <code>echo</code> を実行することで 送受信をします。 書式は以下のようになります:
<code>~p</code> ローカルのファイル名 [ リモートのファイル名 ]
<code>~t</code> リモートのファイル名 [ ローカルのファイル名 ]</p></div><div class=paragraph><p>この方法ではエラーチェックをおこないませんので、zmodem などの他のプロトコルを使った方がよいでしょう。</p></div></div><div class=sect3><h4 id=_tip_から_zmodem_を実行するには>17.5.11. <code>tip</code> から zmodem を実行するには?<a class=anchor href=#_tip_から_zmodem_を実行するには></a></h4><div class=paragraph><p>ファイルを受信するには、 リモート側で送信プログラムを起動します。そして <code>~C rz</code> と入力すると、ローカル側へのファイルの受信が 始まります。</p></div><div class=paragraph><p>ファイルを送信するには、 リモート側で受信プログラムを起動します。そして <code>~C sz files</code> と入力すると、 リモート側への ファイルの送信が始まります。</p></div></div></div><div class=sect2><h3 id=serialconsole-setup>17.6. シリアルコンソールの設定<a class=anchor href=#serialconsole-setup></a></h3><div class=sect3><h4 id=serialconsole-intro>17.6.1. 導入<a class=anchor href=#serialconsole-intro></a></h4><div class=paragraph><p>FreeBSD は、 コンソールとしてシリアルポート上のダム端末しか持たないシステムでも起動します。 この様な構成はきっと次のような二種類の人達に便利でしょう。それは、 キーボードやモニタのないマシンに FreeBSD をインストールしたいシステム管理者と、 カーネルやデバイスドライバをデバッグしたい開発者です。</p></div><div class=paragraph><p><a href=./#boot>FreeBSD の起動のプロセス</a> で説明されているように、 FreeBSD は 3 ステージ構成のブートストラップを用いています。 最初の 2 つのステージは、 ブートディスクにある FreeBSD スライスの最初に格納されている、 ブートブロックのコードが行います。 それからブートブロックは、第 3 ステージのコードとしてブートローダ (<span class=filename>/boot/loader</span>) を読み込み、実行します。</p></div><div class=paragraph><p>シリアルコンソールを設定するためには、ブートブロックコード、 ブートローダコード、カーネルを設定する必要があります。</p></div></div><div class=sect3><h4 id=serialconsole-howto>17.6.2. シリアルコンソールの設定<a class=anchor href=#serialconsole-howto></a></h4><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>シリアルケーブルを用意してください。</p><div class=paragraph><p>ヌルモデムケーブル、 もしくは標準シリアルケーブルとヌルモデムアダプタが必要となります。 シリアルケーブルについては <a href=#serial-cables-ports>ケーブルとポート</a> をご覧ください。</p></div></li><li><p>キーボードをはずして下さい。</p><div class=paragraph><p>たいていの PC システムは Power-On Self-Test (POST) の間にキーボードを検出し、もし見つからなければエラーと なります。また、キーボードがないことを大きな音で知らせ、 キーボードが接続されるまでは起動を中断するようなマシンもあります。</p></div><div class=paragraph><p>コンピュータがエラーを表示していても、 とにかく起動するなら特別な対応は必要ありません (Phoenix BIOS を搭載しているマシンには、 <code>Keyboard failed</code> と表示されても、正常に起動するものがあります)。</p></div><div class=paragraph><p>あなたのコンピュータがキーボードを接続していない状態で 起動しないようなら、(もし可能ならば) エラーを無視するように BIOS を設定する必要があります。設定方法の詳細については、 マザーボードのマニュアルを調べてください。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>BIOS の設定でキーボードを "Not installed" にするということは、キーボードを使えないということを 意味しているわけでは<em>ありません</em>。これは、BIOS がキーボードがなくても文句を言わないように、電源投入時には キーボードを探すな、と指示するだけです。このフラグを "Not installed" にしていてもキーボードを 接続したままにできますし、ちゃんと動作します。</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>あなたのシステムが PS/2 マウスを使っているなら、 おそらくマウスもキーボード同様にはずす必要があるでしょう。 というのは、PS/2 マウスは部分的にキーボードとハードウェアを 共有しており、マウスを接続したままにしていると、 キーボードも存在する、と誤って検出してしまう可能性があるからです。 AMI BIOS を持つ Gateway 2000 Pentium 90MHz システム はこれに該当すると言われています。 一般的にこれは問題ではありません。なぜなら、どっちにしても マウスはキーボードなしではたいして役に立たないからです。</p></div></td></tr></tbody></table></div></li><li><p><span class=filename>COM1</span> (<span class=filename>sio0</span>) にダム端末を接続してください。</p><div class=paragraph><p>ダム端末がなければ、かわりに古い PC/XT でモデム プログラムを走らせて使ったり、シリアルポートに他の Unix マシンを繋いだりできます。もしも <span class=filename>COM1</span> (<span class=filename>sio0</span>) がなければ、作成してください。 今のところ、<span class=filename>COM1</span> 以外のポートを 選択するためにはブートブロックの再コンパイルが必要です。 すでに <span class=filename>COM1</span> を他の装置に 使っていた場合は、一時的にその装置をはずして いったん FreeBSD がうまく動作してから、 新しいブートブロックとカーネルをインストールしてください。 (上記はとにかくファイル/演算/端末サーバの <span class=filename>COM1</span> が利用可能であると仮定して います。あなたが本当に何かのために <span class=filename>COM1</span> が必要 (で、なおかつその何かを <span class=filename>COM2</span> (<span class=filename>sio1</span>) に付け替えることができない) ならば、多分、そもそも 悩んでる場合ではありません。)</p></div></li><li><p>カーネルコンフィグファイルの <span class=filename>COM1</span> (<span class=filename>sio0</span>) に適切なフラグを 設定していることを確認してください。</p><div class=paragraph><p>関連するフラグ:</p></div><div class=dlist><dl><dt class=hdlist1><code>0x10</code></dt><dd><p>このポートのコンソールサポートを有効にします。 このフラグが設定されない場合、他のフラグは無視されます。 現在のところ、一つのポートしかコンソールサポートを有効に できません。(config ファイルに書かれた順番で) 最初にこのフラグを 指定されたポートが選択されます。 なお、このオプションを指定するだけでシリアルポートが コンソールとして使えるわけではありません。 このフラグと一緒に、以下のフラグも指定するかもしくは <code>-h</code> オプションも使ってください。</p></dd><dt class=hdlist1><code>0x20</code></dt><dd><p>後述される <code>-h</code> オプション を無視して、(他に優先度の高いコンソールがない限り) このポートをコンソールとして指定します。 このフラグは FreeBSD バージョン 2.<em>X</em> の <code>COMCONSOLE</code> オプションに対応するものです。 フラグ <code>0x20</code> は必ず フラグ <code>0x10</code> と一緒に指定されなければなりません。</p></dd><dt class=hdlist1><code>0x40</code></dt><dd><p>(<code>0x10</code> と組み合わせることで) このポートを予約し、通常のアクセスができない ようにします。 このフラグは、シリアルコンソールとして使いたいポートに 指定すべきではありません。 唯一の使い道は、ユニットがカーネルのリモートデバッグ用 であることを指定することです。 リモートデバッグの詳細については <a href=https://docs.freebsd.org/en/books/developers-handbook/>The Developer’s Handbook</a> を参照してください。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 4.0 以降では、 フラグ <code>0x40</code> の意味が若干異なり、 シリアルポートにリモートデバッグを指定するためには、 別のフラグを使います。</p></div></td></tr></tbody></table></div><div class=paragraph><p>例:</p></div><div class="literalblock programlisting"><div class=content><pre>device sio0 at isa? port &#34;IO_COM1&#34; tty flags 0x10 irq 4</pre></div></div><div class=paragraph><p>詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> のマニュアルを参照してください。</p></div><div class=paragraph><p>もしこれらのフラグがセットされていなければ、(別のコンソールで) UserConfig を実行するか、 カーネルを再コンパイルする必要があります。</p></div></dd></dl></div></li><li><p>ブートドライブの <code>a</code> パーティションの ルートディレクトリに <span class=filename>boot.config</span> を作成してください。</p><div class=paragraph><p>このファイルは、ブートブロックコードに対してどのように システムを起動したいかを教えます。 シリアルコンソールを活かすためには、以下のオプションを幾つか - 複数の場合も一行で、設定する必要があります:</p></div><div class=dlist><dl><dt class=hdlist1><code>-h</code></dt><dd><p>内蔵コンソールとシリアルコンソールの切替えを行います。 これを使用してコンソールデバイスを変更できます。 例えば、内蔵 (ビデオ) コンソールからブートした場合、 カーネルとブートローダがコンソールデバイスとして シリアルポートを使用するようにするため、 <code>-h</code> を使って指示できます。 反対に、シリアルポートからブートした場合、 ブートローダとカーネルがコンソールとして代わりに ビデオディスプレイを使用するようにするため、 <code>-h</code> を使用できます。</p></dd><dt class=hdlist1><code>-D</code></dt><dd><p>シングルとデュアルのコンソール設定を切り替えます。 シングル設定では、上記の <code>-h</code> オプションの状態によって、コンソールは内蔵コンソール (ビデオディスプレイ)かシリアルポートのいずれかになります。 デュアルコンソール設定では、ビデオディスプレイと シリアルポートの両方が、<code>-h</code> オプションの状態によらず、同時にコンソールになります。 しかし、デュアルコンソール設定は、ブートブロックが 実行されている間でしか効果を持ちません。 一旦ブートローダに制御が移ると、<code>-h</code> オプションによって指定されたコンソールが 唯一のコンソールになります。</p></dd><dt class=hdlist1><code>-P</code></dt><dd><p>ブートブロックがキーボードを検出するようにします。 キーボードが発見できなかった場合には、 <code>-D</code> と <code>-h</code> オプションが自動的にセットされます。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>現バージョンのブートブロックでは容量の制限により、 <code>-P</code> オプションは拡張キーボードしか 検出できません。キーが 101 個より少ない (そして F11 と F12 がない) キーボードは検出されない可能性があります。 この制限から、いくつかのラップトップコンピュータの キーボードは正しく検出されないでしょう。 もし、あなたのシステムがこのようなキーボードを使っているのであれば、 <code>-P</code> オプションを外してください。 残念ながら、この問題の回避策はありません。</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>-P</code> オプションを使ってコンソールを 自動的に選ぶか、<code>-h</code> オプションを使って シリアルコンソールを有効にしてください。</p></div><div class=paragraph><p>さらに <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> で説明されている他のオプションも使う ことができます。</p></div><div class=paragraph><p><code>-P</code> 以外のオプションはブートローダ (<span class=filename>/boot/loader</span>) に渡されます。 ブートローダは、<code>-h</code> オプションだけの状態を 調べることで内蔵ビデオとシリアルポートのどちらがコンソールに なるのか決めます。 つまり、<span class=filename>/boot.config</span> の中で <code>-D</code> オプションを指定して <code>-h</code> オプションを指定しなかった場合、 ブートブロック実行中でのみシリアルポートをコンソールとして 使うことができます。ブートローダは内蔵ビデオディスプレイを コンソールとして使います。</p></div></dd></dl></div></li><li><p>マシンを起動する。</p><div class=paragraph><p>FreeBSD を起動したとき、ブートブロックは <span class=filename>/boot.config</span> の内容をコンソールに表示 します。例えば、</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/boot.config: <span class=nt>-P</span>
Keyboard: no</code></pre></div></div><div class=paragraph><p>行の二番目は、 <span class=filename>/boot.config</span> にオプション <code>-P</code> が指定してあるときだけ表示され、 キーボードが存在するかどうかを表します。 これらのメッセージは、シリアルか内蔵のいずれか、 あるいはその両方のコンソールに表示されます。 どちらに表示されるかは、 <span class=filename>/boot.config</span> の設定によって変わります。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">オプション指定</th><th class="tableblock halign-left valign-top">メッセージの表示される場所</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>なし</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアルと内蔵の両方</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアルと内蔵の両方</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>、キーボードが存在する場合</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>、キーボードが存在しない場合</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr></tbody></table><div class=paragraph><p>このメッセージが表示された後、 ブートブロックがブートローダのロードを再開し、 他の全てのメッセージがコンソールに表示されるまで、 若干時間がかかります。通常の環境では、ブートブロックに 割り込みをかける必要はありませんが、 ちゃんとセットアップされているかどうか確かめるために、 割り込みをかけることができるようになっています。</p></div><div class=paragraph><p>ブートプロセスに割り込みをかけるには、 コンソールの (Enter 以外の) キーをたたいて下さい。 ブートブロックはその時、操作を指定するためのプロンプトを表示します。 こんな風に表示されるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:wd<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div><div class=paragraph><p>上に示したメッセージが、シリアルか内蔵、 あるいはその両方といった、<span class=filename>/boot.config</span> で指定したとおりのコンソールに表示されることを確認して下さい。 メッセージが正しいコンソールに表示されたら、 Enter キーを押してブートプロセスを継続してください。</p></div><div class=paragraph><p>もし、シリアルコンソールを利用するように設定しているのに シリアル端末にプロンプトが出てこない場合は、 設定のどこかに間違いがあります。 ブートブロック(とブートローダ、カーネル)に対して シリアルポートをコンソールに使うことを伝えるため、 割り込みをかけた時に <code>-h</code> を入力し、 (可能ならば) Enter/Return キーを押して下さい。そして、 一度システムを起動させてから、どこが悪いのかをチェックして下さい。</p></div></li></ol></div></div></div><div class=paragraph><p>ブートローダがロードされ、ブートプロセスの第三ステージに いる時には、まだ内蔵コンソールとシリアルコンソールを切り替えることができます。 それにはブートローダの環境変数を適切に設定すれは良いのですが、 詳細については <a href=#serialconsole-loader>ブートローダからコンソールを変更するには</a> を参照してください。</p></div></div><div class=sect3><h4 id=serialconsole-summary>17.6.3. まとめ<a class=anchor href=#serialconsole-summary></a></h4><div class=paragraph><p>このセクションで扱ったさまざまな設定と、 最終的に選択されるコンソールに関するまとめです。</p></div><div class=sect4><h5 id=_case_1_sio0_の_flags_に_0x10_をセットした場合>17.6.3.1. Case 1: <span class=filename>sio0</span> の flags に 0x10 をセットした場合<a class=anchor href=#_case_1_sio0_の_flags_に_0x10_をセットした場合></a></h5><div class="literalblock programlisting"><div class=content><pre>device sio0 at isa? port &#34;IO_COM1&#34; tty flags 0x10 irq 4</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">/boot.config 内のオプション</th><th class="tableblock halign-left valign-top">ブートブロック実行中のコンソール</th><th class="tableblock halign-left valign-top">ブートローダ実行中のコンソール</th><th class="tableblock halign-left valign-top">カーネルのコンソール</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>なし</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵、シリアルの両方</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵、シリアルの両方</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>、キーボードが存在する場合</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>、キーボードが存在しない場合</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵、シリアルの両方</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr></tbody></table></div><div class=sect4><h5 id=_case_2_sio0_の_flags_に_0x30_をセットした場合>17.6.3.2. Case 2: sio0 の flags に 0x30 をセットした場合<a class=anchor href=#_case_2_sio0_の_flags_に_0x30_をセットした場合></a></h5><div class="literalblock programlisting"><div class=content><pre>device sio0 at isa? port &#34;IO_COM1&#34; tty flags 0x30 irq 4</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">/boot.config 内のオプション</th><th class="tableblock halign-left valign-top">ブートブロック実行中のコンソール</th><th class="tableblock halign-left valign-top">ブートローダ実行中のコンソール</th><th class="tableblock halign-left valign-top">カーネルのコンソール</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>なし</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵、シリアルの両方</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵、シリアルの両方</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>、キーボードが存在する場合</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>、キーボードが存在しない場合</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>内蔵、シリアルの両方</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>シリアル</p></td></tr></tbody></table></div></div><div class=sect3><h4 id=serialconsole-tips>17.6.4. シリアルコンソールを利用する上で役に立つ情報<a class=anchor href=#serialconsole-tips></a></h4><div class=sect4><h5 id=_シリアルポートの通信速度をもっと速いものに設定するには>17.6.4.1. シリアルポートの通信速度をもっと速いものに設定するには<a class=anchor href=#_シリアルポートの通信速度をもっと速いものに設定するには></a></h5><div class=paragraph><p>デフォルトのシリアルポート通信速度は、9600 ボー、 8 ビット、パリティなし、ストップビット 1 です。 通信速度を変更したい場合には、少なくとも ブートブロックの再コンパイルが必要になります。 <span class=filename>/etc/make.conf</span> に次のような行を追加して、 新しくブートブロックをコンパイルして下さい。</p></div><div class="literalblock programlisting"><div class=content><pre>BOOT_COMCONSOLE_SPEED=19200</pre></div></div><div class=paragraph><p>もし、シリアルコンソールがブート時の <code>-h</code> オプション以外の方法で設定されていたり、 カーネルが利用するシリアルコンソールが ブートブロック実行中のものと異なる場合には、 カーネルコンフィグレーションファイルに次のオプションを追加して、 新しくカーネルをコンパイルしなければなりません。</p></div><div class="literalblock programlisting"><div class=content><pre>options CONSPEED=19200</pre></div></div></div><div class=sect4><h5 id=serialconsole-com2>17.6.4.2. <span class=filename>sio0</span> 以外のシリアルポートを コンソールとして使うには<a class=anchor href=#serialconsole-com2></a></h5><div class=paragraph><p><span class=filename>sio0</span> 以外のポートをコンソールとして使うには、再コンパイルが必要です。 それがどんな理由であれ、他のポートを使用する場合には ブートブロック、ブートローダ、カーネルを 次のようにして再コンパイルして下さい。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>カーネルソースを取得する (<a href=./#updating-upgrading>FreeBSD のアップデートとアップグレード</a> をご覧ください)。</p></li><li><p><span class=filename>/etc/make.conf</span> を編集し、 <code>BOOT_COMCONSOLE_PORT</code> に 使用したいポートのアドレス(0x3F8、0x2F8、0x3E8 or 0x2E8)を 設定してください。使用可能なのは <span class=filename>sio0</span> から <span class=filename>sio3</span> (<span class=filename>COM1</span> から <span class=filename>COM4</span>) までで、 マルチポートシリアルカードは使えません。 また、ここで割り込みの設定をする必要はありません。</p></li><li><p>設定を変更するために新たなカーネルコンフィグレーションファイルを作成し、 使いたいシリアルポートのフラグを適切に設定します。 例えば、<span class=filename>sio1</span> (<span class=filename>COM2</span>) をコンソールにしたければ、</p><div class="literalblock programlisting"><div class=content><pre>device sio1 at isa? port &#34;IO_COM2&#34; tty flags 0x10 irq 3</pre></div></div><div class=paragraph><p>または、</p></div><div class="literalblock programlisting"><div class=content><pre>device sio1 at isa? port &#34;IO_COM2&#34; tty flags 0x30 irq 3</pre></div></div><div class=paragraph><p>とします。その際、 他のシリアルポートにコンソールフラグをつけてはいけません。</p></div></li><li><p>ブートブロックを再コンパイルし、インストールする。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/boot/i386/boot2</span>
<span class=c># make</span>
<span class=c># make install</span></code></pre></div></div></li><li><p>ブートローダを再コンパイルし、インストールする。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/boot/i386/loader</span>
<span class=c># make</span>
<span class=c># make install</span></code></pre></div></div></li><li><p>カーネルを再構築し、インストールする。</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> を使ってブートブロックをブートディスクに書き込み、 新しいカーネルから起動する。</p></li></ol></div></div></div></div><div class=sect4><h5 id=_シリアルポートから_ddb_デバッガを起動するには>17.6.4.3. シリアルポートから DDB デバッガを起動するには<a class=anchor href=#_シリアルポートから_ddb_デバッガを起動するには></a></h5><div class=paragraph><p>シリアルコンソールからカーネルデバッガを起動したい(これは リモートで診断する際に便利ですが、もしおかしな BREAK 信号がシリアルポートに送られるような場合には危険です!) 場合には、次のオプションを使ってカーネルをコンパイルして下さい。</p></div><div class="literalblock programlisting"><div class=content><pre>options BREAK_TO_DEBUGGER
options DDB</pre></div></div></div><div class=sect4><h5 id=_シリアルコンソールにログインプロンプトを表示させるには>17.6.4.4. シリアルコンソールにログインプロンプトを表示させるには<a class=anchor href=#_シリアルコンソールにログインプロンプトを表示させるには></a></h5><div class=paragraph><p>シリアルコンソールからブートメッセージを確認したり、 シリアルコンソールを経由してカーネルデバッグセッションに入ることが できるので、これは必要がないかもしれませんが、 <em>login</em> プロンプトをシリアルポートに 出力するように設定することもできます。 これには、次のようにします。</p></div><div class=paragraph><p>エディタで <span class=filename>/etc/ttys</span> というファイルを開き、 次に示す行に移動して下さい。</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd0 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyd1 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyd2 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyd3 &#34;/usr/libexec/getty std.9600&#34; unknown off secure</pre></div></div><div class=paragraph><p><code>ttyd0</code> から <code>ttyd3</code> は、 <span class=filename>COM1</span> から <span class=filename>COM4</span> に対応しています。 設定したいポートの <code>off</code> を <code>on</code> に変更して下さい。 また、もしシリアルポートの通信速度を変更しているなら、 <code>std.9600</code> が実際の通信速度になるように、 例えば <code>std.19200</code> のように変更して下さい。</p></div><div class=paragraph><p>さらに、実際のシリアル端末に合わせて、 端末タイプを <code>unknown</code> から変更することも可能です。</p></div><div class=paragraph><p>ファイルの編集が終了したら、 変更を有効化するために <code>kill -HUP 1</code> を実行しなければなりません。</p></div></div></div><div class=sect3><h4 id=serialconsole-loader>17.6.5. ブートローダからコンソールを変更するには<a class=anchor href=#serialconsole-loader></a></h4><div class=paragraph><p>前セクションは、ブートブロックの設定を変更することでシリアルコンソールを セットアップする方法について解説していました。 このセクションでは、ブートローダへのコマンド入力と環境変数設定で コンソールの指定を行なう方法を紹介します。 ブートローダがブートブロックの後、 ブートプロセスの第三ステージで呼び出されたとき、 ブートローダの設定には、ブートブロックの設定がそのまま使われます。</p></div><div class=sect4><h5 id=_シリアルコンソールをセットアップする>17.6.5.1. シリアルコンソールをセットアップする<a class=anchor href=#_シリアルコンソールをセットアップする></a></h5><div class=paragraph><p>ブートローダとカーネルに対して シリアルコンソールを使用するように設定するには、 単に <span class=filename>/boot/loader.rc</span> のファイルに、次のような一行を書くだけで実現できます。</p></div><div class="literalblock programlisting"><div class=content><pre>set console=comconsole</pre></div></div><div class=paragraph><p>これは、前セクションで扱ったブートブロックの設定に 全く関係なく機能します。</p></div><div class=paragraph><p>上に示した行は、 <span class=filename>/boot/loader.rc</span> の最初の行に書き込まなくてはいけません。 これはできるだけ早く、ブートメッセージをシリアルコンソールに 出力させるために必要なことです。</p></div><div class=paragraph><p>同様にして、次のように内蔵コンソールを指定することもできます。</p></div><div class="literalblock programlisting"><div class=content><pre>set console=vidconsole</pre></div></div><div class=paragraph><p>もし、ブートローダの環境変数 <code>console</code> が設定されていない場合、 ブートローダ、そしてその次に起動するカーネルは ブートブロックで指定された <code>-h</code> オプションに 示されたコンソールを使用します。</p></div><div class=paragraph><p>3.2 以降のバージョンにおいては <span class=filename>/boot/loader.rc</span> ではなく、 <span class=filename>/boot/loader.conf.local</span> や <span class=filename>/boot/loader.conf</span> にコンソール指定を書き込みます。 その場合、 <span class=filename>/boot/loader.rc</span> は次のようになっていなければなりません。</p></div><div class="literalblock programlisting"><div class=content><pre>include /boot/loader.4th
start</pre></div></div><div class=paragraph><p>それから、<span class=filename>/boot/loader.conf.local</span> を作成して、次の行をそこに追加して下さい。</p></div><div class="literalblock programlisting"><div class=content><pre>console=comconsole</pre></div></div><div class=paragraph><p>か、もしくは</p></div><div class="literalblock programlisting"><div class=content><pre>console=vidconsole</pre></div></div><div class=paragraph><p>です。詳細については、<a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> を参照して下さい。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>その際、ブートローダはオプション指定なし (ブートブロックに <code>-P</code> オプションが指定されたのと等価)になり、 キーボードの存在を調べて 内蔵コンソールとシリアルコンソールを自動的に選択する機能は働きません。</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_sio0_以外のシリアルポートを_コンソールとして使うには>17.6.5.2. <span class=filename>sio0</span> 以外のシリアルポートを コンソールとして使うには<a class=anchor href=#_sio0_以外のシリアルポートを_コンソールとして使うには></a></h5><div class=paragraph><p><span class=filename>sio0</span> 以外のシリアルポートを コンソールとして使うには、ブートローダを再コンパイルする必要があります。 それには、 <a href=#serialconsole-com2><span class=filename>sio0</span> 以外のシリアルポートを コンソールとして使うには</a> に書かれている説明にしたがって下さい。</p></div></div></div><div class=sect3><h4 id=serialconsole-caveats>17.6.6. 注意<a class=anchor href=#serialconsole-caveats></a></h4><div class=paragraph><p>シリアルコンソールというアイデアは、 グラフィック出力用のハードウェアやキーボードが接続されていない 専用サーバのセットアップを可能にするためのものです。 ほとんどのシステムはキーボードなしで起動できますが、 不幸にも、グラフィックアダプタなしでは起動できないシステムはたくさんあります。 AMI BIOS を採用しているマシンでは、CMOS 設定の <code>graphics adapter</code> を <code>Not Installed</code> にするだけで、 グラフィックアダプタがなくとも起動できるように設定することができます。</p></div><div class=paragraph><p>しかしながら、多くのマシンはこのようなオプションを持っていませんし、 ディスプレイハードウェアがシステムに存在しないと起動しないように なっています。そのようなマシンでは、 モニタを接続する必要がなかったとしても、 適当なグラフィックカード(モノクロのジャンク品でも構いません)を 挿入したままにしておく必要があるでしょう。 また、AMI BIOS をインストールする、という手もあります。</p></div></div></div></div></div><div class=sect1><h2 id=ppp-and-slip>Chapter 18. PPP と SLIP<a class=anchor href=#ppp-and-slip></a></h2><div class=sectionbody><div class=sect2><h3 id=_この章では_2>18.1. この章では<a class=anchor href=#_この章では_2></a></h3><div class=paragraph><p>もしあなたがモデムを使ってインターネットに接続したり, 他の人々に FreeBSD によるインターネットへのダイヤルアップ接続を 提供しようとしているのでしたら, PPP または SLIP 接続を選択することができます.</p></div><div class=paragraph><p>この節では 3 種類の PPP について説明しています. それは <em>ユーザ</em>, <em>カーネル</em>, そして <em>PPPoE</em> (PPP オーバイーサネット) です. また SLIP のクライアントとサーバの設定についても記述しています.</p></div><div class=paragraph><p>最初に説明するのは, ユーザ PPP です. ユーザ PPP は FreeBSD に 2.0.5-RELEASE の時に, 既に存在していたカーネル実装の PPP に加えて導入されました.</p></div><div class=paragraph><p>ユーザ PPP とカーネル PPP の主な違いは何かと疑問に思われるかも 知れませんが, その答えは簡単です. ユーザ PPP はデーモンとしては実行されず 必要に応じて実行されるのです. PPP インタフェイスを組み込んだカーネルは 必要ではなく, ユーザプロセスとして実行されカーネルとのデータの やり取りにはトンネルデバイスドライバ (<span class=filename>tun</span>) を 使用します.</p></div><div class=paragraph><p>この節ではこれ以降ユーザ PPP のことは, <code>pppd</code> のような他の PPP ソフトウエアと特に区別する必要がある場合を除いて, 単に ppp と記述します. またこの節に記述されているコマンドは すべて root で実行されなければなりません.</p></div></div><div class=sect2><h3 id=userppp>18.2. ユーザ ppp の利用<a class=anchor href=#userppp></a></h3><div class=sect3><h4 id=_ユーザ_ppp>18.2.1. ユーザ PPP<a class=anchor href=#_ユーザ_ppp></a></h4><div class=sect4><h5 id=_前提条件>18.2.1.1. 前提条件<a class=anchor href=#_前提条件></a></h5><div class=paragraph><p>以下の情報を手に入れておく必要があるでしょう:</p></div><div class=ulist><ul><li><p>PPP で接続するインターネットサービスプロバイダ (ISP) のアカウント. さらに, 接続済みのモデム (またはその他のデバイス) があり, プロバイダとの接続が可能なように正しく設定されている.</p></li><li><p>プロバイダの電話番号.</p></li><li><p>ログイン名とパスワード. これは通常の unix 形式のログイン名と パスワードの組という場合もありますし, PPP PAP または CHAP の ログイン名とパスワードの組という場合もあります.</p></li><li><p>一つ以上のネームサーバの IP アドレス. 通常, プロバイダから IP アドレスを二つ指示されている はずです. 一つすら提供されていないならば, <span class=filename>ppp.conf</span> ファイル中で <code>enable dns</code> コマンドを使って ppp にネームサーバを設定するよう 指示できます.</p></li></ul></div><div class=paragraph><p>プロバイダからは以下の情報が提供されているはずですが, どうしても必要というわけではありません:</p></div><div class=ulist><ul><li><p>プロバイダのゲートウェイの IP アドレス. ゲートウェイとは, あなたがそこに接続をおこなって, <em>デフォルトルート</em> として設定することになるマシンです. プロバイダがこのアドレスを明示していなくても, 最初は 適当に設定しておいて, 接続時にプロバイダの PPP サーバから 正しいアドレスを教えてもらうことができます.</p><div class=paragraph><p>このアドレスは, ppp から <code>HISADDR</code>として参照されます.</p></div></li><li><p>プロバイダのネットマスク設定. プロバイダが明示していないとしても, ネットマスクとして <code>255.255.255.0</code> を使用しておけば問題ありません.</p></li><li><p>もしプロバイダから固定の IP アドレスとホスト名の割り当てを 受けていれば, その情報を指定しておくこともできます. 割り当てを受けていなければ, 接続先から適切な IP アドレスを指定してもらいます.</p></li></ul></div><div class=paragraph><p>もし, 必要な情報が不足していれば, プロバイダに連絡を取って 確認しておいてください.</p></div></div><div class=sect4><h5 id=_ppp_対応カーネルの構築>18.2.1.2. ppp 対応カーネルの構築<a class=anchor href=#_ppp_対応カーネルの構築></a></h5><div class=paragraph><p>説明でも述べているように, <code>ppp</code> はカーネルの <span class=filename>tun</span> デバイスを使います. 使っているカーネルがどれであっても, <span class=filename>tun</span> デバイスを設定しなければなりません. FreeBSDに付属しているデフォルトの <span class=filename>GENERIC</span> カーネルに合うように <span class=filename>tun</span> デバイスは前もって設定されています. しかしながら, 自分で修正したカーネルをインストールするのであれば, pppが正しく動くよう, カーネルが設定されているか確認しなくてはいけません.</p></div><div class=paragraph><p>これを確認するには, カーネルコンパイルディレクトリ (<span class=filename>/sys/i386/conf</span> または <span class=filename>/sys/pc98/conf</span>) に移動して, カーネルコンフィグレーションファイルを調べます. 以下の行がどこかに含まれている必要があります.</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device tun 1</pre></div></div><div class=paragraph><p>この行がカーネルコンフィグレーションファイルに 含まれていない場合, この行を追加して カーネルの再コンパイルとインストールをおこなう必要があります. 元々の <span class=filename>GENERIC</span> カーネルは 標準でこれを含んでいますので, カスタムカーネルをインストールしているのではなかったり, <span class=filename>/sys</span> ディレクトリが存在しないのであれば, 何も変更する必要はありません. カーネルコンフィグレーションの詳細については, <a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> を参照してください.</p></div><div class=paragraph><p>以下のコマンドを実行することで, 現在のカーネルにトンネルデバイスが いくつ組み込まれているかを調べることができます:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig -a</span>
tun0: <span class=nv>flags</span><span class=o>=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
	inet 200.10.100.1 <span class=nt>--</span><span class=o>&gt;</span> 203.10.100.24 netmask 0xffffffff
tun1: <span class=nv>flags</span><span class=o>=</span>8050&lt;POINTOPOINT,RUNNING,MULTICAST&gt; mtu 576
tun2: <span class=nv>flags</span><span class=o>=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
	inet 203.10.100.1 <span class=nt>--</span><span class=o>&gt;</span> 203.10.100.20 netmask 0xffffffff
tun3: <span class=nv>flags</span><span class=o>=</span>8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 4.0やより最近のリリースでは, すでに使われている <span class=filename>tun</span> デバイスしか見つけることが できないでしょう. これは, <em>全く</em> <span class=filename>tun</span> デバイスを見つけることが できないかもしれないということです. しかし, もしこうなって しまっても, 心配することはありません. そのデバイスは <code>ppp</code> が使おうとする時に動的に作られるはず だからです.</p></div></td></tr></tbody></table></div><div class=paragraph><p>この例ではトンネルデバイスが四つ存在し, そのうち二つに 設定がおこなわれ, 使用中であることがわかります. 上の例で <code>RUNNING</code> フラグがオンになっている ものがありますが, これは そのインタフェースが何かに使用されていることを示している だけであるということに注意してください. つまり, <code>RUNNING</code> になっていない インタフェースがあったとしても, それはエラーではありません.</p></div><div class=paragraph><p>トンネルデバイスがカーネルに組み込まれておらず, 何らかの理由で カーネルの再構築ができない場合でも, 方法がないわけではありません. 動的にデバイスをロードすることができるはずです. 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=modload&amp;sektion=8&amp;format=html">modload(8)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=lkm&amp;sektion=4&amp;format=html">lkm(4)</a> など, 適切なマニュアルを参照してください.</p></div></div><div class=sect4><h5 id=_tun_デバイスの確認>18.2.1.3. tun デバイスの確認<a class=anchor href=#_tun_デバイスの確認></a></h5><div class=paragraph><p>ほとんどのユーザは <span class=filename>tun</span> デバイス (<span class=filename>/dev/tun0</span>) が一つあれば充分でしょう. より多くのデバイスを使う場合 (すなわち, カーネルコンフィグレーション ファイルで <code>pseudo-device tun</code> の行に <code>1</code> 以外の数値を指定している場合), 以下で <span class=filename>tun0</span> と書かれている部分をすべて, あなたが使うデバイスの番号に あわせて読みかえてください.</p></div><div class=paragraph><p><span class=filename>tun0</span> デバイスが正しく作成されていることを確認する最も簡単な方法は, それを作り直すことです. そのためには, 以下のコマンドを実行します:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV tun0</span></code></pre></div></div><div class=paragraph><p>カーネルに 16 個のトンネルデバイスを組み込んだのであれば, <span class=filename>tun0</span> だけでなく他の tun デバイスも作成しておく必要があるでしょう:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV tun15</span></code></pre></div></div><div class=paragraph><p>また, カーネルが正しく設定されているかどうかを調べるために 以下のコマンドを実行して, このような出力が得られることを確認します:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig tun0</span>
tun0: <span class=nv>flags</span><span class=o>=</span>8050&lt;POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500</code></pre></div></div><div class=paragraph><p>まだ <code>RUNNING</code> フラグがセットされていない場合もあります. その時は以下のような出力が得られるでしょう:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig tun0</span>
tun0: <span class=nv>flags</span><span class=o>=</span>8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</code></pre></div></div><div class=paragraph><p>前述したように, FreeBSD 4.0 以降のリリースでは <span class=filename>tun</span> デバイスは要求に応じて 作られるので, もしそのデバイスがまだ使われていなければ, 見つけられないかもしれないということを思い出してください.</p></div></div><div class=sect4><h5 id=_名前の解決に関する設定>18.2.1.4. 名前の解決に関する設定<a class=anchor href=#_名前の解決に関する設定></a></h5><div class=paragraph><p>リゾルバ (resolver) はシステムの一部分で, IP アドレスとホスト名との 変換をおこないます. IP アドレスとホスト名を対応させるためのマップを, 二つの場所のうちの一つから探すように設定できます. 一つめは <span class=filename>/etc/hosts</span> (<code>man 5 hosts</code>) と呼ばれるファイルです. 二つめはインターネット ドメインネームサービス (DNS) と呼ばれる 分散データベースですが, これに関する議論は このドキュメントで扱う範囲を 越えていますので, これについての説明はおこないません.</p></div><div class=paragraph><p>リゾルバは名前のマッピングを おこなうシステムコールの集合体です. ただし どこからマッピング情報を見つけるのかは, 最初に指示しておく必要があります. これは まず <span class=filename>/etc/host.conf</span> ファイルを編集することでおこないます. 混乱の元になりますので, このファイルを <span class=filename>/etc/hosts.conf</span>と 呼んだりしては<em>いけません</em> (余分な <code>s</code> がついていますね).</p></div><div class=sect5><h6 id=_etchost_conf_ファイルの編集>18.2.1.4.1. <span class=filename>/etc/host.conf</span> ファイルの編集<a class=anchor href=#_etchost_conf_ファイルの編集></a></h6><div class=paragraph><p>このファイルには 以下の 2 行が (この順番で) 書かれているはずです:</p></div><div class="literalblock programlisting"><div class=content><pre>hosts
bind</pre></div></div><div class=paragraph><p>これは, 最初に <span class=filename>/etc/hosts</span> ファイルを調べ, そこで目的の名前が 見つけられなかった場合に DNS を引きにいくようリゾルバに指示します.</p></div></div><div class=sect5><h6 id=_etchosts5_ファイルの編集>18.2.1.4.2. /etc/hosts(5) ファイルの編集<a class=anchor href=#_etchosts5_ファイルの編集></a></h6><div class=paragraph><p>このファイルはローカルネットワーク上に存在するマシンの IP アドレスと ホスト名を含んでいるはずです. 最低でも ppp を動作させるマシンのエントリが 含まれている必要があります. そのマシンのホスト名が <code>foo.bar.com</code> で, IP アドレスが <code>10.0.0.1</code> であると仮定すると, <span class=filename>/etc/hosts</span> は 以下の行を含んでいなければいけません:</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1	localhost.bar.com	localhost
127.0.0.1	localhost.bar.com.
10.0.0.1	foo.bar.com		foo
10.0.0.1	foo.bar.com.</pre></div></div><div class=paragraph><p>一つめの行は <code>localhost</code> を現在のマシンの別名として定義しています. マシン固有の IP アドレスが何であっても, この行の IP アドレスは 常に <code>127.0.0.1</code> でなければいけません. 二つめの行はホスト名 <code>foo.bar.com</code> (と, その省略形 <code>foo</code>) を IP アドレス <code>10.0.0.1</code> にマップします.</p></div><div class=paragraph><p>もしプロバイダから固定の IP アドレスとホスト名を割り当てられて いるのであれば, それを <code>10.0.0.1</code> エントリのかわりに使ってください.</p></div></div><div class=sect5><h6 id=_etcresolv_conf_ファイルの編集>18.2.1.4.3. <span class=filename>/etc/resolv.conf</span> ファイルの編集<a class=anchor href=#_etcresolv_conf_ファイルの編集></a></h6><div class=paragraph><p><span class=filename>/etc/resolv.conf</span> はリゾルバの振舞いを指定します. もし自前の DNS サーバを走らせているのなら, このファイルは空のままに しておくこともできます. 通常は, 以下のように書いておく必要があるでしょう:</p></div><div class="literalblock programlisting"><div class=content><pre>domain bar.com
nameserver x.x.x.x
nameserver y.y.y.y</pre></div></div><div class=paragraph><p><code><em>x.x.x.x</em></code> と <code><em>y.y.y.y</em></code> はプロバイダから指示されたアドレスで, 接続するプロバイダが提供しているネームサーバを すべて書いてください. <code>domain</code> に指定するのは このマシンのデフォルトのドメイン名で, おそらく 書かなくても問題は無いでしょう. このファイルの各エントリの詳細については, <span class=filename>resolv.conf</span> のマニュアルページを参照してください.</p></div><div class=paragraph><p>バージョン 2 以降の ppp を使用している場合には, <code>enable dns</code> コマンドを使用してネームサーバのアドレスを プロバイダに問い合わせるように指示することができます. 上の指定とは異なるアドレスをプロバイダが指定してきた場合 (または <span class=filename>/etc/resolv.conf</span> でネームサーバが指定されていない場合), ppp はプロバイダが指定したアドレスで <span class=filename>resolv.conf</span> を書きかえます.</p></div></div></div><div class=sect4><h5 id=_ppp_の設定>18.2.1.5. <code>ppp</code> の設定<a class=anchor href=#_ppp_の設定></a></h5><div class=paragraph><p>ユーザ ppp と <code>pppd</code> (カーネルレベルの PPP 実装) は どちらも <span class=filename>/usr/shared/examples/ppp</span> ディレクトリに置かれた設定ファイルを使います. ここには設定ファイルのサンプルが用意されていて, ユーザ ppp の設定を おこなう際に大変参考になりますので, 削除したりしないでください.</p></div><div class=paragraph><p><code>ppp</code> の設定をするためには, 必要に応じていくつかのファイルを編集する必要が あります. 書き込む内容は, プロバイダが静的に IP アドレスを割り当てる (つまり, 固定の IP アドレスを一つ与えられて, 常にそれを使う) か, または動的に IP アドレスを割り当てる (つまり, PPP セッションごとに IP アドレスが変化する可能性がある) かということに ある程度依存します.</p></div><div class=sect5><h6 id=userppp-staticIP>18.2.1.5.1. 静的 IP アドレスによる PPP 接続<a class=anchor href=#userppp-staticIP></a></h6><div class=paragraph><p>まず <span class=filename>/etc/ppp/ppp.conf</span> という設定ファイルを作成する必要があります. これは以下の例とほとんど同じようなものになるでしょう.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>:</code> で終る行は 1 カラム目から始め, その他の行はスペースまたはタブで以下の例のように 段をつける (インデントする) 必要があります.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>1     default:
2       set device /dev/cuaa0
3       set speed 115200
4       set dial &#34;ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \&#34;\&#34; ATE1Q0 OK-AT-OK \\dATDT\\TTIMEOUT 40 CONNECT&#34;
5     provider:
6       set phone &#34;(123) 456 7890&#34;
7       set login &#34;TIMEOUT 10 \&#34;\&#34; \&#34;\&#34; gin:--gin: foo word: bar col: ppp&#34;
8       set timeout 300
9       set ifaddr x.x.x.x y.y.y.y 255.255.255.0 0.0.0.0
10      add default HISADDR
11      enable dns</pre></div></div><div class=paragraph><p>ファイルでは行番号を取り除いておいてください. これは解説の際に参照する行を示すためにつけたものです.</p></div><div class=dlist><dl><dt class=hdlist1>Line 1</dt><dd><p>デフォルトエントリを指定します. このエントリ中のコマンドは ppp が起動された際に自動的に実行されます.</p></dd><dt class=hdlist1>Line 2</dt><dd><p>モデムが接続されているデバイスを指定します. <span class=filename>COM1:</span> は <span class=filename>/dev/cuaa0</span> に, <span class=filename>COM2:</span> は <span class=filename>/dev/cuaa1</span> になります.</p></dd><dt class=hdlist1>Line 3</dt><dd><p>通信速度 (DTE 速度) を指定します. もし 115200 が使えない (最近のモデムなら大抵使えるはずですが) 場合には, かわりに 38400 を指定してみてください.</p></dd><dt class=hdlist1>Line 4</dt><dd><p>ダイアルスクリプトを指定します. ユーザ PPP は <a href="https://man.freebsd.org/cgi/man.cgi?query=chat&amp;sektion=8&amp;format=html">chat(8)</a> 言語に似た, 受信待ち文字列と 送信文字列の対からなるスクリプトを使用します. この言語の機能に関しては, マニュアルページを参照してください.</p></dd><dt class=hdlist1>Line 5</dt><dd><p>接続するプロバイダの名前 "provider" を エントリ名として指定します.</p></dd><dt class=hdlist1>Line 6</dt><dd><p>このプロバイダの電話番号を指定します. 複数の電話番号を <code>:</code> や <code>|</code> で区切って指定することができます. これら区切り文字の違いについては, <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> に 詳しく書かれています. 要約すると, 毎回違う番号に かけたいのであれば <code>:</code> を使います. 常に まず先頭の番号にかけてみて, つながらない時にだけ 2 番目以降の番号に かけたいのであれば <code>|</code> を使います. 例に示されているように, 常に電話番号全体を引用符で くくって (クォートして) おきます.</p></dd><dt class=hdlist1>Line 7</dt><dd><p>ダイアルスクリプトと同様に, ログインスクリプトも chat 言語風の記述をおこないます. この例は, 以下のようなログインセッションを使用する プロバイダのためのものです:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>J. Random Provider
login: foo
password: bar
protocol: ppp</code></pre></div></div><div class=paragraph><p>このスクリプトは必要に応じて 書きかえなければならないでしょう. 初めてスクリプトを書く時には, 予想した通りに 処理が進んだかどうかを確認するため, "chat" ログを とるようにしておいた方が良いでしょう.</p></div><div class=paragraph><p>PAP や CHAP を使用する場合には, ここでログインすることは ありませんから, ログイン文字列は空白のままにしておくべきです. 詳細については <a href=#userppp-PAPnCHAP>PAP および CHAP による認証</a>を参照してください.</p></div></dd><dt class=hdlist1>Line 8</dt><dd><p>デフォルトの接続タイムアウト時間を (秒数で) 指定します. この例では, 300 秒間 通信がおこなわれなければ 自動的に接続を切るように指定しています. タイムアウトさせたくない場合には, この値を 0 に設定します.</p></dd><dt class=hdlist1>Line 9</dt><dd><p>インタフェースのアドレスを指定します. 文字列 <em>x.x.x.x</em> は プロバイダに割り当てられた IP アドレスで置きかえてください. 文字列 <em>y.y.y.y</em> はプロバイダから指示されたゲートウェイ (接続先となるマシン) の IP アドレスで置きかえてください. プロバイダがゲートウェイのアドレスを 指示していない場合は, <code>10.0.0.2/0</code> を使用しておいてください. もし "仮の" アドレスを使用する必要がある場合には, <a href=#userppp-dynamicIP>動的 IP アドレスによる PPP 接続</a>に関する指示に従って, <span class=filename>/etc/ppp/ppp.linkup</span> にエントリを作成していることを 確認してください. この行が省略されている場合, ppp を <code>-auto</code> モードで動作させることはできません.</p></dd><dt class=hdlist1>Line 10</dt><dd><p>プロバイダのゲートウェイへの経路を デフォルトルートとして 追加します. 特殊文字列 <code>HISADDR</code> は, 9 行目で指定された ゲートウェイのアドレスで置きかえられます. <code>HISADDR</code> は 9 行目までは初期化されていませんので, その行よりも後でしか使えないことに 注意してください.</p></dd><dt class=hdlist1>Line 11</dt><dd><p>ネームサーバのアドレスが正しいか どうかを確認するため, プロバイダに問い合わせをおこなうよう ppp に指示します. プロバイダがこの機能をサポートしていれば, ppp は <span class=filename>/etc/resolv.conf</span> のネームサーバエントリを 正しいアドレスに更新することができます.</p></dd></dl></div><div class=paragraph><p>静的な IP アドレスを持っていて, 接続が完了する前にルーティングテーブルの エントリが正しく設定されているのであれば, <span class=filename>ppp.linkup</span> に エントリを追加する必要はありません. しかし, この場合でもエントリを追加して, 接続が完了した時点で プログラムを呼び出したいことがあるかもしれません. これについては後ほど sendmail を例として説明します.</p></div><div class=paragraph><p>これらの設定ファイルのサンプルが <span class=filename>/usr/shared/examples/ppp</span> ディレクトリに 置かれています.</p></div></div><div class=sect5><h6 id=userppp-dynamicIP>18.2.1.5.2. 動的 IP アドレスによる PPP 接続<a class=anchor href=#userppp-dynamicIP></a></h6><div class=paragraph><p>プロバイダが静的な IP アドレスの割り当てをおこなっていない場合, <code>ppp</code> が相手側のホスト (ゲートウェイ) と交渉して, こちら側と相手側のアドレスを 決めるように設定することができます. これは, 起動時には"仮の"アドレスを使っておいて, 接続後に IP コンフィグレーション プロトコル (IPCP) を使用して <code>ppp</code> が IP アドレスを正しく設定できるようにすることで実現されます. <a href=#userppp-staticIP>静的 IP アドレスによる PPP 接続</a>に 以下の変更を加える以外は, <span class=filename>ppp.conf</span> の設定は同じです:</p></div><div class="literalblock programlisting"><div class=content><pre>9       set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0</pre></div></div><div class=paragraph><p>繰り返しますが, 行番号は取り除いておいてください. これは解説の際に参照する行を示すためにつけたものです. なお, 少なくともスペース 1 個分の段づけ (インデント) が必要です.</p></div><div class=dlist><dl><dt class=hdlist1>Line 9</dt><dd><p><code>/</code> 文字の後ろの数字は, アドレス交渉の際に固定しておきたい ビットの数です. 場合によっては, もっと適切な IP アドレスを 指定しておきたいこともあるかもしれませんが, ほとんどの場合には 上の例の通りで問題ありません.</p><div class=paragraph><p>最後の引数 (<code>0.0.0.0</code>) は, アドレスの交渉の際に <code>10.0.0.1</code> ではなく <code>0.0.0.0</code> を使用するよう ppp に指示するためのものです. <code>set ifaddr</code> コマンドの最初の引数として <code>0.0.0.0</code> を指定してはいけません. さもないと, <code>-auto</code> モードで動作させる際に 初期経路を設定することができなくなります.</p></div></dd></dl></div><div class=paragraph><p>バージョン 1.X の ppp を使用する場合, <span class=filename>/etc/ppp/ppp.linkup</span> にもエントリを作成しておく必要があります. <span class=filename>ppp.linkup</span> は接続が確立された後に使用されます. この時点では, <code>ppp</code> は<em>実際に</em>どの IP アドレスを使うべきなのか わかっているはずです. 以下のエントリは存在する仮の経路を削除し, 正しい経路を作成します:</p></div><div class="literalblock programlisting"><div class=content><pre>1     provider:
2       delete ALL
3       add default HISADDR</pre></div></div><div class=dlist><dl><dt class=hdlist1>Line 1</dt><dd><p>接続を確立する際に, <code>ppp</code> は以下のルールに従って <span class=filename>ppp.linkup</span> のエントリを検索します: まず <span class=filename>ppp.conf</span> で使用されたのと同じラベルを探します. もし見つからなければ, ゲートウェイの IP アドレスのエントリを 探します. このエントリは 4 オクテットの IP アドレス形式の ラベルです. それでも まだエントリが見つからなければ, <code>MYADDR</code> エントリを探します.</p></dd><dt class=hdlist1>Line 2</dt><dd><p>この行は, 使用する tun インタフェースに関する既存の経路を (ダイレクトルートのエントリを除き) すべて削除するよう <code>ppp</code> に指示します.</p></dd><dt class=hdlist1>Line 3</dt><dd><p>この行は <code>HISADDR</code> への経路をデフォルトルートとして 追加するように ppp に指示します. <code>HISADDR</code> は IPCP で 決定されたゲートウェイの IP アドレスで置きかえられます.</p></dd></dl></div><div class=paragraph><p>詳細なサンプルについては, <span class=filename>/usr/shared/examples/ppp/ppp.conf.sample</span> ファイル中のpmdemand エントリと <span class=filename>/usr/shared/examples/ppp/ppp.linkup.sample</span> を参照してください.</p></div><div class=paragraph><p>バージョン 2 の ppp から "sticky routes" が導入されました. <code>MYADDR</code> や <code>HISADDR</code> を含む <code>add</code> コマンドと <code>delete</code> コマンドを記憶して, <code>MYADDR</code> や <code>HISADDR</code> の アドレスが変化した際には経路の再設定をおこないます. したがって, これらのコマンドを <span class=filename>ppp.linkup</span> に 繰り返し記述する必要は無くなりました.</p></div></div><div class=sect5><h6 id=_かかってきた電話を_ppp_で受けるには>18.2.1.5.3. かかってきた電話を <code>ppp</code> で受けるには<a class=anchor href=#_かかってきた電話を_ppp_で受けるには></a></h6><div class=paragraph><p>かかってきた電話を <code>ppp</code> が受けるように設定する際に, そのマシンが LAN に接続されているのであれば, パケットを LAN に転送するかどうかを決定する必要があります. 転送をおこなう場合には, その LAN のサブネットから IP アドレスを ppp クライアントに割り当て, 以下のコマンドを指定するのが良いでしょう.</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=YES</pre></div></div><div class=sect6><h7 id=_どの_getty_を使いますか>18.2.1.5.3.1. どの getty を使いますか?<a class=anchor href=#_どの_getty_を使いますか></a></h7><div class=paragraph><p>getty でダイアルアップサービスをおこなう場合の優れた解説が <a href=./#dialup>FreeBSD でダイアルアップサービスをおこなうための設定</a>にあります.</p></div><div class=paragraph><p><code>getty</code> に代わるものとしては, <a href=http://www.leo.org/~doering/mgetty/index.html>mgetty</a> があります. これは <code>getty</code> をより柔軟にしたもので, ダイアルアップ回線での使用を意図して 設計されています.</p></div><div class=paragraph><p><code>mgetty</code> を使う場合の利点は, <code>mgetty</code> が積極的にモデムと<em>通信する</em> ということです. つまり, もし <span class=filename>/etc/ttys</span> でポートを閉じている場合, モデムは電話をとらなくなります.</p></div><div class=paragraph><p>最近のバージョンの <code>mgetty</code> (0.99beta 以降) では, PPP ストリームの 自動検出もサポートされています. これにより, クライアント側で スクリプトを準備しなくてもサーバに アクセスすることができます.</p></div><div class=paragraph><p><code>mgetty</code> に関する, より詳細な情報については <a href=#userppp-mgetty>Mgetty と AutoPPP</a> を参照してください.</p></div></div><div class=sect6><h7 id=_ppp_の実行許可>18.2.1.5.3.2. ppp の実行許可<a class=anchor href=#_ppp_の実行許可></a></h7><div class=paragraph><p><code>ppp</code> は通常, ID 0 のユーザ (root) として動作しなければいけませんが, 以下で説明するように, <code>ppp</code> を通常のユーザとしてサーバモードで実行させたい 場合には, そのユーザを <span class=filename>/etc/group</span> の <code>network</code> グループに 追加して, ppp を実行する許可を与えておかなければいけません.</p></div><div class=paragraph><p>また, そのユーザが設定ファイル内の目的のエントリに アクセスできるように, 以下のように <code>allow</code> コマンドで許可を与えておく必要があります:</p></div><div class="literalblock programlisting"><div class=content><pre>allow users fred mary</pre></div></div><div class=paragraph><p>このコマンドがデフォルトエントリに 書かれている場合には, 指定されたユーザは すべてのエントリをアクセスできるようになります.</p></div></div><div class=sect6><h7 id=_動的_ip_ユーザのための_ppp_シェルの設定>18.2.1.5.3.3. 動的 IP ユーザのための ppp シェルの設定<a class=anchor href=#_動的_ip_ユーザのための_ppp_シェルの設定></a></h7><div class=paragraph><p><span class=filename>/etc/ppp/ppp-shell</span> という名前で, 以下のような内容のファイルを 作成します:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
IDENT=`echo $0 | sed -e &#39;s/^.*-\(.*\)$/\1/&#39;`
CALLEDAS=&#34;$IDENT&#34;
TTY=`tty`

if [ x$IDENT = xdialup ]; then
	IDENT=`basename $TTY`
fi

echo &#34;PPP for $CALLEDAS on $TTY&#34;
echo &#34;Starting PPP for $IDENT&#34;

exec /usr/sbin/ppp -direct $IDENT</pre></div></div><div class=paragraph><p>このスクリプトには実行可能属性をつけておきます. 次に, 以下のコマンドを実行し, <span class=filename>ppp-dialup</span> という名前で このスクリプトへのリンクを作成します:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s ppp-shell /etc/ppp/ppp-dialup</span></code></pre></div></div><div class=paragraph><p>すべてのダイアルアップ ppp ユーザのログイン<em>シェル</em>として このスクリプトを使用します. 以下は <code>pchilds</code> というユーザ名の ダイアルアップユーザを <span class=filename>/etc/password</span> へ登録した場合の例です. (パスワードファイルを直接エディタで編集したりせず, <code>vipw</code> を使ってください)</p></div><div class="literalblock programlisting"><div class=content><pre>pchilds:*:1011:300:Peter Childs PPP:/home/ppp:/etc/ppp/ppp-dialup</pre></div></div><div class=paragraph><p>任意のユーザが読むことのできる, <span class=filename>/home/ppp</span> ディレクトリを 作成します. <span class=filename>/etc/motd</span> が表示されないようにするため, このディレクトリには以下のように大きさが 0 バイトのファイルを 作成しておきます.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-r--r--r--</span>   1 root     wheel           0 May 27 02:23 .hushlogin
<span class=nt>-r--r--r--</span>   1 root     wheel           0 May 27 02:22 .rhosts</code></pre></div></div></div><div class=sect6><h7 id=_静的_ip_ユーザのための_ppp_シェルの設定>18.2.1.5.3.4. 静的 IP ユーザのための PPP シェルの設定<a class=anchor href=#_静的_ip_ユーザのための_ppp_シェルの設定></a></h7><div class=paragraph><p>上記と同じように <span class=filename>ppp-shell</span> ファイルを作成し, 静的な IP アドレスを割り当てるアカウントそれぞれについて <span class=filename>ppp-shell</span> へのシンボリックリンクを作成します.</p></div><div class=paragraph><p>例えば, クラス C ネットワークの経路制御を必要とする, 三人のダイアルアップユーザ <code>fred</code>, <code>sam</code>, <code>mary</code> がいるとすると, 以下のコマンドを実行することになります:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-fred</span>
<span class=c># ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-sam</span>
<span class=c># ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-mary</span></code></pre></div></div><div class=paragraph><p>これらのユーザのダイアルアップアカウントでは, 上で作成した それぞれのシンボリックリンクを ログインシェルとして設定しておきます. (つまり, ユーザ <code>mary</code> のログインシェルは <span class=filename>/etc/ppp/ppp-mary</span> に なります).</p></div></div><div class=sect6><h7 id=_動的_ip_ユーザのための_ppp_conf_の設定>18.2.1.5.3.5. 動的 IP ユーザのための ppp.conf の設定<a class=anchor href=#_動的_ip_ユーザのための_ppp_conf_の設定></a></h7><div class=paragraph><p><span class=filename>/etc/ppp/ppp.conf</span> ファイルは, 大体以下のような内容になるでしょう:</p></div><div class="literalblock programlisting"><div class=content><pre>default:
  set debug phase lcp chat
  set timeout 0

ttyd0:
  set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
  enable proxy

ttyd1:
  set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
  enable proxy</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>上の例のように段をつける (インデントする) 必要があることに注意してください.</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>default:</code> エントリはセッションごとにロードされます. <span class=filename>/etc/ttys</span> で有効にしてある各ダイアルアップ回線ごとに一つ, 上記の <code>ttyd0:</code> のようなエントリを作成します. 各行の相手側アドレスとして, それぞれ別の IP アドレスを 動的 IP ユーザのための IP アドレスのプールから割り当てておく必要があります.</p></div></div><div class=sect6><h7 id=_静的_ip_ユーザのための_ppp_conf_の設定>18.2.1.5.3.6. 静的 IP ユーザのための <span class=filename>ppp.conf</span> の設定<a class=anchor href=#_静的_ip_ユーザのための_ppp_conf_の設定></a></h7><div class=paragraph><p>上のサンプルの <span class=filename>/usr/shared/examples/ppp/ppp.conf</span> の内容に加えて, 静的に IP を割り当てられたダイアルアップユーザ それぞれのためのエントリを追加する必要があります. ここでも <code>fred</code>, <code>sam</code>, <code>mary</code> の例を使うことにしましょう.</p></div><div class="literalblock programlisting"><div class=content><pre>fred:
  set ifaddr 203.14.100.1 203.14.101.1 255.255.255.255

sam:
  set ifaddr 203.14.100.1 203.14.102.1 255.255.255.255

mary:
  set ifaddr 203.14.100.1 203.14.103.1 255.255.255.255</pre></div></div><div class=paragraph><p>必要であれば, それぞれの静的 IP ユーザに対する経路制御情報も <span class=filename>/etc/ppp/ppp.linkup</span> ファイルに書いておくべきでしょう. 以下の例ではクライアントの PPP リンクを経由する, クラス C の <code>203.14.101.0</code> ネットワークへの経路を追加しています.</p></div><div class="literalblock programlisting"><div class=content><pre>fred:
  add 203.14.101.0 netmask 255.255.255.0 HISADDR

sam:
  add 203.14.102.0 netmask 255.255.255.0 HISADDR

mary:
  add 203.14.103.0 netmask 255.255.255.0 HISADDR</pre></div></div></div></div><div class=sect5><h6 id=_mgetty_autoppp_マイクロソフト拡張の詳細>18.2.1.5.4. <code>mgetty</code>, AutoPPP, マイクロソフト拡張の詳細<a class=anchor href=#_mgetty_autoppp_マイクロソフト拡張の詳細></a></h6><div class=sect6><h7 id=userppp-mgetty>18.2.1.5.4.1. <code>mgetty</code> と AutoPPP<a class=anchor href=#userppp-mgetty></a></h7><div class=paragraph><p><code>AUTO_PPP</code> オプションつきでコンパイルした <code>mgetty</code> を使えば, <code>mgetty</code> が PPP 接続の LCP フェーズを検出して, 自動的に PPP シェルを起動するように 設定することができます. しかし この場合, デフォルトの login/password シーケンスは発生しないので, ユーザの認証は PAP または CHAP を使っておこなう必要があります.</p></div><div class=paragraph><p>このセクションでは, ユーザ (あなた) が問題なく <code>AUTO_PPP</code> オプションつきの <code>mgetty</code> (v0.99beta またはそれ以降) の設定, コンパイル, インストールができているものと仮定しています.</p></div><div class=paragraph><p><span class=filename>/usr/local/etc/mgetty+sendfax/login.config</span> ファイルが 以下の行を含んでいることを確認してください:</p></div><div class="literalblock programlisting"><div class=content><pre>/AutoPPP/ -     -       /etc/ppp/ppp-pap-dialup</pre></div></div><div class=paragraph><p>これにより, PPP 接続を検出したら <code>mgetty</code> が <span class=filename>ppp-pap-dialup</span> スクリプトを実行するようになります.</p></div><div class=paragraph><p><span class=filename>/etc/ppp/ppp-pap-dialup</span> という名前で, 以下のような内容のファイルを 作成します (このファイルには実行可能属性を つけておく必要があります):</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
exec /usr/sbin/ppp -direct pap</pre></div></div><div class=paragraph><p>さらに, かかってきた電話すべてを自分で扱うエントリを <span class=filename>/etc/ppp/ppp.conf</span> に作成します.</p></div><div class="literalblock programlisting"><div class=content><pre>pap:
  enable pap
  set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
  enable proxy</pre></div></div><div class=paragraph><p>この方法でログインする それぞれのユーザは, PAP によるユーザ認証を おこなうために <span class=filename>/etc/ppp/ppp.secret</span> ファイルにユーザ名とパスワードを 書いておくか, または <span class=filename>/etc/password</span> ファイルを使うように,</p></div><div class="literalblock programlisting"><div class=content><pre>enable passwdauth</pre></div></div><div class=paragraph><p>ユーザに静的な IP アドレスを割り当てる場合には, そのアドレスを <span class=filename>/etc/ppp/ppp.secret</span> の第三引数として指定することができます. サンプルについては, <span class=filename>/usr/shared/examples/ppp/ppp.secret.sample</span> を参照してください.</p></div></div><div class=sect6><h7 id=_マイクロソフト拡張>18.2.1.5.4.2. マイクロソフト拡張<a class=anchor href=#_マイクロソフト拡張></a></h7><div class=paragraph><p>クライアントからの要求に応じて, ppp が DNS や NetBIOS ネームサーバの アドレスを通知するように 設定をおこなうこともできます.</p></div><div class=paragraph><p>バージョン 1.X の ppp で これらの拡張機能を有効にするには, 以下の行を <span class=filename>/etc/ppp/ppp.conf</span> の適切なセクションに追加する必要があるでしょう.</p></div><div class="literalblock programlisting"><div class=content><pre>enable msext
set ns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>バージョン 2 以降の ppp では, 以下のようになります:</p></div><div class="literalblock programlisting"><div class=content><pre>accept dns
set dns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>これにより, クライアントはプライマリと セカンダリのネームサーバアドレス および NetBIOS ネームサーバホストを知ることができます.</p></div><div class=paragraph><p>バージョン 2 以降の ppp では, <code>set dns</code> の行を省略した場合には <span class=filename>/etc/resolv.conf</span> に書かれているネームサーバのアドレスを使用します.</p></div></div></div><div class=sect5><h6 id=userppp-PAPnCHAP>18.2.1.5.5. PAP および CHAP による認証<a class=anchor href=#userppp-PAPnCHAP></a></h6><div class=paragraph><p>いくつかのプロバイダでは, PAP または CHAP のいずれかの認証メカニズムを 使用して接続時の認証をおこなうように システムを設定しています. この場合, プロバイダは接続の際に <code>login:</code> プロンプトを送信せず, 最初から PPP で通信を始めようとするでしょう.</p></div><div class=paragraph><p>PAP ではパスワードがそのまま送られてしまうため, CHAP に比べると安全性が 低くなりますが, このパスワードはシリアル回線のみを通して送られます. そのため, クラッカーが "盗み聞き" する余地は多くないので, 通常ここの セキュリティは問題にはなりません.</p></div><div class=paragraph><p><a href=#userppp-staticIP>静的 IP アドレスによる PPP 接続</a>または <a href=#userppp-dynamicIP>動的 IP アドレスによる PPP 接続</a>の セクションに戻って, 以下の変更をおこないます:</p></div><div class="literalblock programlisting"><div class=content><pre>7       set login
...
12      set authname MyUserName
13      set authkey MyPassword</pre></div></div><div class=paragraph><p>これまでと同様に, 行番号は取り除いておいてください. これは解説の際に参照する行を示すためにつけたものです. なお, 少なくともスペース 1 個分の段づけ (インデント) が必要です.</p></div><div class=dlist><dl><dt class=hdlist1>Line 7</dt><dd><p>PAP または CHAP を使用する場合, 通常 プロバイダはサーバへの ログインを必要としません. そのため, "set login" 文字列を 無効にしておかなければいけません.</p></dd><dt class=hdlist1>Line 12</dt><dd><p>この行は PAP/CHAP ユーザ名を指定します. <em>MyUserName</em> に 正しい値を入れておく必要があります.</p></dd><dt class=hdlist1>Line 13</dt><dd><p>この行は PAP/CHAP パスワードを指定します. <em>MyPassword</em> に 正しい値を入れておく必要があります. PAP と CHAP はデフォルトで両方とも 受け付けられるようになって いますが, PAP や CHAP を使用するという 意思を明示するために,</p><div class="literalblock programlisting"><div class=content><pre>15      accept PAP</pre></div></div><div class=paragraph><p>または</p></div></dd></dl></div><div class="literalblock programlisting"><div class=content><pre>15      accept CHAP</pre></div></div><div class=literalblock><div class=content><pre>という行を追加しておくのも良いでしょう.</pre></div></div></div><div class=sect5><h6 id=_動作中の_ppp_の設定変更>18.2.1.5.6. 動作中の ppp の設定変更<a class=anchor href=#_動作中の_ppp_の設定変更></a></h6><div class=paragraph><p>適切な診断ポートが設定されている場合には, バックグラウンドで動作中の <code>ppp</code> プログラムと通信することができます. この設定をおこなうためには, 以下の行を設定ファイルに追加しておきます:</p></div><div class="literalblock programlisting"><div class=content><pre>set server /var/run/ppp-tun%d DiagnosticPassword 0177</pre></div></div><div class=paragraph><p>これにより, ppp は指定された unix ドメインの ソケットをモニタして, クライアントから正しいパスワードを受け取った後に アクセスを許可します. このソケット名に含まれる <code>%d</code> は, この ppp が使用している <span class=filename>tun</span> デバイスの デバイス番号で置きかえられます.</p></div><div class=paragraph><p>一旦ソケットの設定が終了したら, スクリプト中で <a href="https://man.freebsd.org/cgi/man.cgi?query=pppctl&amp;sektion=8&amp;format=html">pppctl(8)</a> を 使用して, 動作中の ppp を操作することができるでしょう.</p></div></div></div><div class=sect4><h5 id=userppp-final>18.2.1.6. システムの最終設定<a class=anchor href=#userppp-final></a></h5><div class=paragraph><p>これで <code>ppp</code> の設定は終りました. しかし <code>ppp</code> を動かす前に, まだ少し必要なことがあります. それらの設定は, すべて <span class=filename>/etc/rc.conf</span> ファイルを 編集することでおこないます. (このファイルは以前には <span class=filename>/etc/sysconfig</span> と呼ばれていました)</p></div><div class=paragraph><p>このファイルを上から順に設定していきます. まずは <code>hostname=</code> の行が設定されていることを確認します. 例えば以下のように:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;foo.bar.com&#34;</pre></div></div><div class=paragraph><p>もしプロバイダが静的な IP アドレスとホスト名を割り当てているのなら, ホスト名としてそれを使うのが おそらくベストでしょう.</p></div><div class=paragraph><p>次に <code>network_interfaces</code> 変数を調べます. 必要に応じて (on demand) プロバイダにダイアルするようにシステムを設定したい場合には, <span class=filename>tun0</span> デバイスがこのリストに追加されていることを確認しておきます. それ以外の場合には, tun0 デバイスをリストから削除しておきます.</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 tun0&#34; ifconfig_tun0=</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>ifconfig_tun0</code> 変数が空で, <span class=filename>/etc/start_if.tun0</span> という名前の ファイルが作成されていなければなりません. このファイルの内容は以下のようになります.</p></div><div class="literalblock programlisting"><div class=content><pre>ppp -auto mysystem</pre></div></div><div class=paragraph><p>このスクリプトはネットワークの設定時に実行され, ppp デーモンを自動モードで立ち上げます. このマシンがもし LAN のゲートウェイであれば, <code>-alias</code> スイッチも使用したいと思うかもしれません. 詳細に関しては, マニュアルページを参照してください.</p></div></td></tr></tbody></table></div><div class=paragraph><p>以下のようにルータプログラムを <code>NO</code> に設定します.</p></div><div class="literalblock programlisting"><div class=content><pre>router_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p><code>routed</code> は, <code>ppp</code> が作成したデフォルトのルーティングテーブル エントリを削除してしまう場合がありますので, (初期設定では起動されるようになっている) <code>routed</code> デーモンが 起動されないようにしておくことが重要です.</p></div><div class=paragraph><p><code>sendmail_flags</code> 行が <code>-q</code> オプションを含まないように 設定しておいた方がよいでしょう. さもないと, <code>sendmail</code> が アドレスを調べようとして発信をおこなってしまう場合があります. 以下のような設定で良いでしょう:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_flags=&#34;-bd&#34;</pre></div></div><div class=paragraph><p>この結果, PPP リンクを立ち上げた時には いつでも以下のコマンドを実行して, キューにたまっているメールを <code>sendmail</code> に送信させる作業が必要になるでしょう.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/sendmail -q</span></code></pre></div></div><div class=paragraph><p><span class=filename>ppp.linkup</span> 中で <code>!bg</code> コマンドを使用することで, これを自動的に おこなうこともできます:</p></div><div class="literalblock programlisting"><div class=content><pre>1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m</pre></div></div><div class=paragraph><p>こうするのが嫌であれば, SMTP トラフィックをブロックするように "dfilter" を設定しておくこともできます. 詳細についてはサンプルファイルを参照してください.</p></div><div class=paragraph><p>後はマシンをリブートするだけです.</p></div><div class=paragraph><p>リブートが終ったら,</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp</span></code></pre></div></div><div class=paragraph><p>コマンドを実行し, 続いて PPP セッションを開始させるために <code>dial provider</code> と入力することもできますし, (<span class=filename>start_if.tun0</span> スクリプトを作成していない場合に), 外部へのトラフィックが発生した時に, <code>ppp</code> が自動的に セッションを確立してくれるようにしたいのであれば, 以下のコマンドを実行することもできます.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -auto provider</span></code></pre></div></div></div><div class=sect4><h5 id=_まとめ>18.2.1.7. まとめ<a class=anchor href=#_まとめ></a></h5><div class=paragraph><p>要約すると, 初めて ppp を設定する際には, 以下のステップが不可欠です:</p></div><div class=paragraph><p>クライアント側:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>カーネルに <span class=filename>tun</span> デバイスが組み込まれていることを確認.</p></li><li><p><span class=filename>/dev</span> ディレクトリに <span class=filename>tunX</span> デバイスファイルが 存在することを確認.</p></li><li><p><span class=filename>/etc/ppp/ppp.conf</span> にエントリを作成. ほとんどのプロバイダでは, <span class=filename>pmdemand</span> の例で充分でしょう.</p></li><li><p>動的 IP アドレスを使用するなら, <span class=filename>/etc/ppp/ppp.linkup</span> に エントリを作成.</p></li><li><p><span class=filename>/etc/rc.conf</span> (または <span class=filename>sysconfig</span>) ファイルを更新.</p></li><li><p>必要に応じてダイヤル (demand dialing) したいのであれば, <span class=filename>start_if.tun0</span> スクリプトを作成.</p></li></ol></div></div></div><div class=paragraph><p>サーバ側:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>カーネルに <span class=filename>tun</span> デバイスが組み込まれていることを確認.</p></li><li><p><span class=filename>/dev</span> ディレクトリに <span class=filename>tunX</span> デバイスファイルが 存在することを確認.</p></li><li><p>(<a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> コマンドを使って) <span class=filename>/etc/passwd</span> にエントリを作成.</p></li><li><p>このユーザのホームディレクトリに <code>ppp -direct direct-server</code> か何かを実行するプロファイルを作成.</p></li><li><p><span class=filename>/etc/ppp/ppp.conf</span> にエントリを作成. <span class=filename>direct-server</span> の例で充分でしょう.</p></li><li><p><span class=filename>/etc/ppp/ppp.linkup</span> にエントリを作成.</p></li><li><p><span class=filename>/etc/rc.conf</span>ファイルを更新.</p></li></ol></div></div></div></div></div></div><div class=sect2><h3 id=ppp>18.3. カーネル PPP の利用<a class=anchor href=#ppp></a></h3><div class=sect3><h4 id=_カーネル_ppp_の設定>18.3.1. カーネル PPP の設定<a class=anchor href=#_カーネル_ppp_の設定></a></h4><div class=paragraph><p>PPP の設定を始める前に, <code>pppd</code> が <span class=filename>/usr/sbin</span> にあり, また <span class=filename>/etc/ppp</span> という ディレクトリが存在することを確認してください.</p></div><div class=paragraph><p><code>pppd</code> はふたつのモードで動作します.</p></div><div class="olist arabic"><ol class=arabic><li><p>"クライアント" モード. シリアル接続やモデムを利用して, そのマシンを 外部のネットワークに PPP 接続したい場合に用います.</p></li><li><p>"サーバ" モード. そのマシンがネットワーク上にあるときに, PPP を使って ほかのコンピュータを接続する際に用います.</p></li></ol></div><div class=paragraph><p>どちらの場合でも, オプションファイルを設定する必要があります (<span class=filename>/etc/ppp/options</span> または, そのマシン上で PPP を使用する人が 複数いる場合には <span class=filename>~/.ppprc</span>).</p></div><div class=paragraph><p>また, ダイヤルとリモートホストへの接続をおこなうために, シリアル接続やモデムを 操作する, なんらかのソフトウェアが必要です (kermit が適しているでしょう).</p></div></div><div class=sect3><h4 id=_ppp_クライアントとしての動作>18.3.2. PPP クライアントとしての動作<a class=anchor href=#_ppp_クライアントとしての動作></a></h4><div class=paragraph><p>わたしは, CISCO ターミナルサーバの PPP 回線に接続するために, 下記のような <span class=filename>/etc/ppp/options</span> を使用しています.</p></div><div class="literalblock programlisting"><div class=content><pre>crtscts         # enable hardware flow control
modem           # modem control line
noipdefault     # remote PPP server must supply your IP address.
                # if the remote host doesn&#39;t send your IP during IPCP
                # negotiation , remove this option
passive         # wait for LCP packets
domain ppp.foo.com      # put your domain name here

:&lt;remote_ip&gt;    # put the IP of remote PPP host here
                # it will be used to route packets via PPP link
                # if you didn&#39;t specified the noipdefault option
                # change this line to &lt;local_ip&gt;:&lt;remote_ip&gt;

defaultroute    # put this if you want that PPP server will be your
                # default router</pre></div></div><div class=paragraph><p>接続方法:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>kermit (またはその他のモデム操作プログラム) を使ってリモートホストに ダイヤルし, 接続してください. そして, あなたのユーザ名とパスワード (必要 であれば, その他にもリモートホストで PPP を有効にするための操作) を入力 します.</p></li><li><p>kermit を抜けてください. (回線を切断せずに)</p></li><li><p>下記のように入力します:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/src/usr.sbin/pppd.new/pppd /dev/tty01 19200</span></code></pre></div></div><div class=paragraph><p>(通信速度とデバイス名には, あなたの環境に適したものを入れてください)</p></div></li></ol></div></div></div><div class=paragraph><p>これでこのコンピュータは PPP で接続されました. もし, なんらかの理由で 接続に失敗したならば, <span class=filename>/etc/ppp/options</span> ファイルに <code>debug</code> オプションを追加して, 問題点を突き止めるために, コンソールに表示される メッセージを調べてください.</p></div><div class=paragraph><p>下記の <span class=filename>/etc/ppp/pppup</span> スクリプトは, 上記の作業を すべて自動的におこないます:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.dial
pppd /dev/tty01 19200</pre></div></div><div class=paragraph><p><span class=filename>/etc/ppp/kermit.dial</span> は kermit 用のスクリプトで, ダイヤルして, リモートホストでの認証に必要なすべての処理をおこないます. (そのようなスクリプトの例は この文書の終わりに添付してあります)</p></div><div class=paragraph><p>PPP 接続を切断するには, 下記のような <span class=filename>/etc/ppp/pppdown</span> スクリプトを 使用します:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ X${pid} != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill -TERM ${pid}
fi

ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

/sbin/ifconfig ppp0 down
/sbin/ifconfig ppp0 delete
kermit -y /etc/ppp/kermit.hup
/etc/ppp/ppptest</pre></div></div><div class=paragraph><p>PPP が動作中かどうかを調べます (<span class=filename>/usr/etc/ppp/ppptest</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pid=`ps ax| grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ X${pid} != &#34;X&#34; ] ; then
        echo &#39;pppd running: PID=&#39; ${pid-NONE}
else
        echo &#39;No pppd running.&#39;
fi
set -x
netstat -n -I ppp0
ifconfig ppp0</pre></div></div><div class=paragraph><p>モデム回線を切断します (<span class=filename>/etc/ppp/kermit.hup</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>set line /dev/tty01	; put your modem device here
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
echo \13
exit</pre></div></div><div class=paragraph><p>次は <code>kermit</code> の代わりに <code>chat</code> を使う方法です.</p></div><div class=paragraph><p>pppd 接続を確立するためには, 次の二つのファイルの設定だけで十分です.</p></div><div class=paragraph><p><span class=filename>/etc/ppp/options</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/cuaa1 115200

crtscts		# enable hardware flow control
modem		# modem control line
connect &#34;/usr/bin/chat -f /etc/ppp/login.chat.script&#34;
noipdefault	# remote PPP serve must supply your IP address.
	        # if the remote host doesn&#39;t send your IP during
                # IPCP negotiation, remove this option
passive         # wait for LCP packets
domain &lt;your.domain&gt;	# put your domain name here

:		# put the IP of remote PPP host here
	        # it will be used to route packets via PPP link
                # if you didn&#39;t specified the noipdefault option
                # change this line to &lt;local_ip&gt;:&lt;remote_ip&gt;

defaultroute	# put this if you want that PPP server will be
	        # your default router</pre></div></div><div class=paragraph><p><span class=filename>/etc/ppp/login.chat.script</span>:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>(実際には一行になります.)</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>ABORT BUSY ABORT &#39;NO CARRIER&#39; &#34;&#34; AT OK ATDT&lt;phone.number&gt;
 CONNECT &#34;&#34; TIMEOUT 10 ogin:-\\r-ogin: &lt;login-id&gt;
 TIMEOUT 5 sword: &lt;password&gt;</pre></div></div><div class=paragraph><p>正しくインストールし編集した後は, 必要な事はこれだけです</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pppd</span></code></pre></div></div><div class=paragraph><p>このサンプルは主に Trev Roydhouse &lt;<a href=mailto:Trev.Roydhouse@f401.n711.z3.fidonet.org>Trev.Roydhouse@f401.n711.z3.fidonet.org</a>> から寄せられた情報に基づいており, 承諾を得て使用しています.</p></div></div><div class=sect3><h4 id=_ppp_サーバとしての動作>18.3.3. PPP サーバとしての動作<a class=anchor href=#_ppp_サーバとしての動作></a></h4><div class=paragraph><p><span class=filename>/etc/ppp/options</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>crtscts                         # Hardware flow control
netmask 255.255.255.0           # netmask ( not required )
192.114.208.20:192.114.208.165  # ip&#39;s of local and remote hosts
                                # local ip must be different from one
                                # you assigned to the ethernet ( or other )
                                # interface on your machine.
                                # remote IP is ip address that will be
                                # assigned to the remote machine
domain ppp.foo.com              # your domain
passive                         # wait for LCP
modem                           # modem line</pre></div></div><div class=paragraph><p>下記のような <span class=filename>/etc/ppp/pppserv</span> スクリプトで, そのマシンを PPP サーバにすることができます.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

# reset ppp interface
ifconfig ppp0 down
ifconfig ppp0 delete

# enable autoanswer mode
kermit -y /etc/ppp/kermit.ans

# run ppp
pppd /dev/tty01 19200</pre></div></div><div class=paragraph><p>PPP サーバを終了するには, この <span class=filename>/etc/ppp/pppservdown</span> スクリプト を使用します:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi
ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.noans</pre></div></div><div class=paragraph><p>下記の kermit スクリプトは, モデムの自動応答機能を有効, または無効にします (<span class=filename>/etc/ppp/kermit.ans</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>set line /dev/tty01
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
inp 5 OK
echo \13
out ATS0=1\13   ; change this to out ATS0=0\13 if you want to disable
                ; autoanswer mod
inp 5 OK
echo \13
exit</pre></div></div><div class=paragraph><p>この <span class=filename>/etc/ppp/kermit.dial</span> スクリプトは, リモートホストに ダイヤルし, 認証手続きをするのに使用します. あなたは必要に応じて, これを 変更しないといけないでしょう. あなたのユーザ名とパスワードをこの スクリプトに書かなければいけませんし, モデムやリモートホストからの 応答によっては, 入力待ちの文を変更する必要もあります.</p></div><div class="literalblock programlisting"><div class=content><pre>;
; put the com line attached to the modem here:
;
set line /dev/tty01
;
; put the modem speed here:
;
set speed 19200
set file type binary            ; full 8 bit file xfer
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none
set modem hayes
set dial hangup off
set carrier auto                ; Then SET CARRIER if necessary,
set dial display on             ; Then SET DIAL if necessary,
set input echo on
set input timeout proceed
set input case ignore
def \%x 0                       ; login prompt counter
goto slhup

:slcmd                          ; put the modem in command mode
echo Put the modem in command mode.
clear                           ; Clear unread characters from input buffer
pause 1
output +++                      ; hayes escape sequence
input 1 OK\13\10                ; wait for OK
if success goto slhup
output \13
pause 1
output at\13
input 1 OK\13\10
if fail goto slcmd              ; if modem doesn&#39;t answer OK, try again

:slhup                          ; hang up the phone
clear                           ; Clear unread characters from input buffer
pause 1
echo Hanging up the phone.
output ath0\13                  ; hayes command for on hook
input 2 OK\13\10
if fail goto slcmd              ; if no OK answer, put modem in command mode

:sldial                         ; dial the number
pause 1
echo Dialing.
output atdt9,550311\13\10               ; put phone number here
assign \%x 0                    ; zero the time counter

:look
clear                           ; Clear unread characters from input buffer
increment \%x                   ; Count the seconds
input 1 {CONNECT }
if success goto sllogin
reinput 1 {NO CARRIER\13\10}
if success goto sldial
reinput 1 {NO DIALTONE\13\10}
if success goto slnodial
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if &lt; \%x 60 goto look
else goto slhup

:sllogin                        ; login
assign \%x 0                    ; zero the time counter
pause 1
echo Looking for login prompt.

:slloop
increment \%x                   ; Count the seconds
clear                           ; Clear unread characters from input buffer
output \13
;
; put your expected login prompt here:
;
input 1 {Username: }
if success goto sluid
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if &lt; \%x 10 goto slloop         ; try 10 times to get a login prompt
else goto slhup                 ; hang up and start again if 10 failures

:sluid
;
; put your userid here:
;
output ppp-login\13
input 1 {Password: }
;
; put your password here:
;
output ppp-password\13
input 1 {Entering SLIP mode.}
echo
quit

:slnodial
echo \7No dialtone.  Check the telephone line!\7
exit 1

; local variables:
; mode: csh
; comment-start: &#34;; &#34;
; comment-start-skip: &#34;; &#34;
; end:</pre></div></div></div></div><div class=sect2><h3 id=pppoe>18.4. PPP オーバイーサネット (PPPoE) の利用<a class=anchor href=#pppoe></a></h3><div class=paragraph><p>以下の解説は, PPPoE として知られる, PPP オーバイーサネットの設定法です.</p></div><div class=sect3><h4 id=_必要なもの>18.4.1. 必要なもの<a class=anchor href=#_必要なもの></a></h4><div class=paragraph><p>あなたのシステムで PPPoE を適切に機能させるためには, 以下のものが必要です.</p></div><div class=ulist><ul><li><p>FreeBSD 3.4やそれより新しいバージョンのカーネルソース</p></li><li><p>FreeBSD 3.4やそれより新しいバージョンのppp</p></li></ul></div></div><div class=sect3><h4 id=_カーネルコンフィギュレーション>18.4.2. カーネルコンフィギュレーション<a class=anchor href=#_カーネルコンフィギュレーション></a></h4><div class=paragraph><p>以下に示すオプションをカーネルコンフィギュレーションファイルに 追加して, その後 <a href=./#kernelconfig>新しいカーネルを コンパイルする</a>必要があります.</p></div><div class=ulist><ul><li><p>options NETGRAPH</p></li></ul></div><div class=paragraph><p>以下は任意</p></div><div class=ulist><ul><li><p>options NETGRAPH_PPPOE</p></li><li><p>options NETGRAPH_SOCKET</p></li></ul></div><div class=paragraph><p>この機能は実行時には有効ではありませんが, 要求に応じて ppp は関係のあるモジュールを 読み込みます.</p></div></div><div class=sect3><h4 id=_ppp_conf_の設定>18.4.3. <span class=filename>ppp.conf</span> の設定<a class=anchor href=#_ppp_conf_の設定></a></h4><div class=paragraph><p>これは動作している <span class=filename>ppp.conf</span> の 例です:</p></div><div class="literalblock programlisting"><div class=content><pre>default: # or name_of_service_provider
  set device PPPoE:xl1 # replace xl1 with your ethernet device
  set mru 1492
  set mtu 1492
  set authname YOURLOGINNAME
  set authkey YOURPASSWORD
  set log Phase tun command # you can add more detailed logging if you wish
  set dial
  set login
  set ifaddr 10.0.0.1/0 10.0.0.2/0
  add default HISADDR
  nat enable yes # if you want to enable nat for your local net

papchap:
  set authname YOURLOGINNAME
  set authkey YOURPASSWORD</pre></div></div><div class=paragraph><p><a href=https://docs.freebsd.org/ja/books/faq/#PPPoEwithNAT>-nat オプションを付けてPPPoE</a>を起動する際には注意するべきです.</p></div></div><div class=sect3><h4 id=_ppp_の起動>18.4.4. PPP の起動<a class=anchor href=#_ppp_の起動></a></h4><div class=paragraph><p>以下を root 権限において実行することで, 起動させることができます:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -ddial name_of_service_provider</span></code></pre></div></div></div><div class=sect3><h4 id=_システム起動時に_ppp_を立ち上げる>18.4.5. システム起動時に PPP を立ち上げる<a class=anchor href=#_システム起動時に_ppp_を立ち上げる></a></h4><div class=paragraph><p><span class=filename>/etc/rc.conf</span> ファイルに以下の行を追加 してください:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp_enable=&#34;YES&#34;
ppp_mode=&#34;ddial&#34;
ppp_nat=&#34;YES&#34;
ppp_profile=&#34;default&#34; # or your provider</pre></div></div></div></div><div class=sect2><h3 id=slip>18.5. SLIP の利用<a class=anchor href=#slip></a></h3><div class=sect3><h4 id=slipc>18.5.1. SLIPクライアントのセットアップ<a class=anchor href=#slipc></a></h4><div class=paragraph><p>ここには FreeBSD マシンを静的アドレスのネットワークにつなげる場合の SLIPのセットアップの一つの方法を書いてあります. ホスト名を動的に割り当てる(つまり, ダイヤルアップするたびにアドレスが かわる)ためには, おそらくもっと凝ったことが必要です.</p></div><div class=paragraph><p>まず, モデムがどのシリアルポートにつながっているか決めましょう. 私は <span class=filename>/dev/cuaa1</span> から <span class=filename>/dev/modem</span>へというシンボリックリンクを張り, コンフィグレーションではその名前だけを使っています. <span class=filename>/etc</span> や<span class=filename>.kermrc</span> など, システム全体に散らばっているファイルを修正する 必要がでるとまったく煩わしいのです!</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ここで, <span class=filename>/dev/cuaa0</span>は <span class=filename>COM1</span>であり, <span class=filename>cuaa1</span>は<span class=filename>COM2</span>です.</p></div></td></tr></tbody></table></div><div class=paragraph><p>カーネルのコンフィグレーションファイルに</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device   sl      1</pre></div></div><div class=paragraph><p>という記述があるのを確認してください. これは <span class=filename>GENERIC</span> カーネルに含まれている ので削除していない限り大丈夫でしょう.</p></div><div class=sect4><h5 id=_最初の設定>18.5.1.1. 最初の設定<a class=anchor href=#_最初の設定></a></h5><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><span class=filename>/etc/hosts</span> ファイルにあなたのマシンのゲートウェイとネームサーバ を加えてください. 私のは以下のようになっています.</p><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost loghost
136.152.64.181          silvia.HIP.Berkeley.EDU silvia.HIP silvia
136.152.64.1            inr-3.Berkeley.EDU inr-3 slip-gateway
128.32.136.9            ns1.Berkeley.edu ns1
128.32.136.12           ns2.Berkeley.edu ns2</pre></div></div></li><li><p><span class=filename>/etc/host.conf</span> ファイル中で <code>hosts</code>が<code>bind</code> よりも前にあること を確認してください. さもないとヘンなことが起こるかもしれません.</p></li><li><p><span class=filename>/etc/rc.conf</span> ファイルを編集してください. なお, お使いの FreeBSD が 2.2.2 よりも前のバージョンのものの場合は, <span class=filename>/etc/sysconfig</span> を編集してください.</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>行</p><div class="literalblock programlisting"><div class=content><pre>hostname=myname.my.domain</pre></div></div><div class=paragraph><p>を編集してホスト名をセットしてください. 完全なInternetホスト名を与えるべきです.</p></div></li><li><p>行</p><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0&#34;</pre></div></div><div class=paragraph><p>を</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 sl0&#34;</pre></div></div><div class=paragraph><p>へ変更することにより ネットワークインタフェースのリストに sl0 を加えてください.</p></div></li><li><p>行</p><div class="literalblock programlisting"><div class=content><pre>ifconfig_sl0=&#34;inet ${hostname} slip-gateway netmask 0xffffff00 up&#34;</pre></div></div><div class=paragraph><p>を加えて sl0 のスタートアップフラグをセットしてください.</p></div></li><li><p>行</p><div class="literalblock programlisting"><div class=content><pre>defaultrouter=NO</pre></div></div><div class=paragraph><p>を</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=slip-gateway</pre></div></div><div class=paragraph><p>へ変更してデフォルトのルータを 指定してください.</p></div></li></ol></div></li><li><p>次の</p><div class="literalblock programlisting"><div class=content><pre>domain HIP.Berkeley.EDU
nameserver 128.32.136.9
nameserver 128.32.136.12</pre></div></div><div class=paragraph><p>という内容を含むファイル <span class=filename>/etc/resolv.conf</span> を作ってください. 見ればわかるように, これらはネームサーバホストを設定しています. もちろん, 実際のドメイン名やアドレスは あなたの環境に依存します.</p></div></li><li><p>root と toor (及びパスワードを持っていない他のアカウントすべて) のパスワード を設定してください. passwdコマンドを使いましょう. <span class=filename>/etc/passwd</span> や <span class=filename>/etc/master.passwd</span> といったファイルを編集してはいけません!</p></li><li><p>マシンを再起動して正しいホスト名で 立ち上がることを確認してください.</p></li></ol></div></div></div></div><div class=sect4><h5 id=_slip接続をおこなう>18.5.1.2. SLIP接続をおこなう<a class=anchor href=#_slip接続をおこなう></a></h5><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>モデムを起動, つながったらプロンプトで <code>slip</code>とタイプし, マシン名と パスワードを入力してください. 入力する必要があるものは環境に よって異なります. 私は次のようなスクリプトでkermitを使っています.</p><div class="literalblock programlisting"><div class=content><pre># kermit setup
set modem hayes
set line /dev/modem
set speed 115200
set parity none
set flow rts/cts
set terminal bytesize 8
set file type binary
# The next macro will dial up and login
define slip dial 643-9600, input 10 =&gt;, if failure stop, -
output slip\x0d, input 10 Username:, if failure stop, -
output silvia\x0d, input 10 Password:, if failure stop, -
output ***\x0d, echo \x0aCONNECTED\x0a</pre></div></div><div class=paragraph><p>(もちろん, ホスト名とパスワードは変える必要があります). 接続するためには kermit のプロンプトで <code>slip</code>とタイプするだけです.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ファイルシステムのどんなところにもプレインテキスト にパスワードを書いておくのは一般的にはよくありません. 覚悟の上で やってください. 私は単に不精なだけです.</p></div></td></tr></tbody></table></div></li><li><p>ここでkermitから抜け出し (<code>z</code>でkermitをサスペンドできます), root で</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># slattach -h -c -s 115200 /dev/modem</span></code></pre></div></div><div class=paragraph><p>と入力しましょう. もしルータの向う側のホストへ <code>ping</code> できるなら接続成功です! もしうまく いかなければslattachへの引数として <code>-c</code> の代わりに<code>-a</code>とやってみてください.</p></div></li></ol></div></div></div></div><div class=sect4><h5 id=_接続の切り方>18.5.1.3. 接続の切り方<a class=anchor href=#_接続の切り方></a></h5><div class=paragraph><p>slattachを殺すためにrootで</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -INT `cat /var/run/slattach.modem.pid`</span></code></pre></div></div><div class=paragraph><p>とタイプしてください. そして kermit に戻り (もしkermitをサスペンドしていたなら <code>fg</code>), kermitから抜けてください (<code>q</code>).</p></div><div class=paragraph><p>slattachのマニュアルページにはインタフェースを落すために <code>ifconfig sl0 down</code>をしなければいけないと書いていますが, 私には差がないように見えます. (<code>ifconfig sl0</code>とやっても同じ結果が得られる.)</p></div><div class=paragraph><p>時にはモデムがキャリアを落すのを 拒絶するかもしれません(私のは よくそうなります). その時は単にkermitをスタートしてまた終了 してください. 普通は2回目で落ちます.</p></div></div><div class=sect4><h5 id=_トラブルシューティング_3>18.5.1.4. トラブルシューティング<a class=anchor href=#_トラブルシューティング_3></a></h5><div class=paragraph><p>もし動かなければ自由に私に質問してください. 今までいろんな人がつまずいた のは次のようなことです.</p></div><div class=ulist><ul><li><p>slattach で <code>-c</code> や <code>-a</code> を使わなかった(私はなぜこれが致命的になり得るのか わかりませんが, このフラグを付けることで少なくとも一人の 問題は解決しました.)</p></li><li><p><code>sl0</code> の代わりに <code>s10</code> を使った(いくつかのフォントでは見分けるのは難しい かもしれません).</p></li><li><p>インタフェースの状態を見るために <code>ifconfig sl0</code> をやってみてください. 私は,</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig sl0</span>
sl0: <span class=nv>flags</span><span class=o>=</span>10&lt;POINTOPOINT&gt;
        inet 136.152.64.181 <span class=nt>--</span><span class=o>&gt;</span> 136.152.64.1 netmask ffffff00</code></pre></div></div><div class=paragraph><p>となります.</p></div></li><li><p>また, pingが "no route to host" というメッセージを返す時には <code>netstat -r</code>でルーティングテーブルを確認しましょう. 私のは,</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># netstat -r</span>
Routing tables
Destination      Gateway            Flags     Refs     Use  IfaceMTU    Rtt
Netmasks:
<span class=o>(</span>root node<span class=o>)</span>
<span class=o>(</span>root node<span class=o>)</span>

Route Tree <span class=k>for </span>Protocol Family inet:
<span class=o>(</span>root node<span class=o>)</span> <span class=o>=&gt;</span>
default          inr-3.Berkeley.EDU UG          8   224515  sl0 -      -
localhost.Berkel localhost.Berkeley UH          5    42127  lo0 -       0.438
inr-3.Berkeley.E silvia.HIP.Berkele UH          1        0  sl0 -      -
silvia.HIP.Berke localhost.Berkeley UGH        34 47641234  lo0 -       0.438
<span class=o>(</span>root node<span class=o>)</span></code></pre></div></div><div class=paragraph><p>となります. (これはたくさんのファイルを転送した後でのもので, あなたの見る数字はもっと小さいかも しれません).</p></div></li></ul></div></div></div><div class=sect3><h4 id=slips>18.5.2. SLIPサーバのセットアップ方法<a class=anchor href=#slips></a></h4><div class=paragraph><p>この文書の目的は, SLIPサーバ機能を FreeBSDシステムのもとで設定するため の助言を提供することです. SLIPサーバ機能を設定するということは, リモー トの SLIPクライアントがログインできるようにするために, 自動的に接続処 理をおこなうようにすることです. この文書は著者の経験に基づいておりますが, 実際のシステム構成や要望は異なりますから, すべての疑問にこの文書が答え ることはできません. なお, ここでの助言を試みた結果, あなたのシステムへ の悪影響やデータの損失が生じたとしても, 著者が責任を持つことはできませ んのでご了解をお願いします.</p></div><div class=sect4><h5 id=slips-prereqs>18.5.2.1. 前提<a class=anchor href=#slips-prereqs></a></h5><div class=paragraph><p>この文書の内容はテクニカルなものなので, 前提知識が必要です. すなわち, TCP/IPネットワークプロトコルについての知識, 特に, ネットワークとノード のアドレス指定をはじめ, ネットワークアドレスマスク, サブネット化, ルー ティング, および RIPなどのルーティングプロトコルなどに関する知識を前提 としています. ダイヤルアップサーバで SLIP機能を設定するためには, これ らの概念についての知識が必要ですから, もし不案内であると思われる方は, O’Reilly & Associates, Inc.から出版されている Craig Hunt氏の <em>TCP/IP Network Administration</em> (ISBN 0-937175-82-X)か, または Douglas Comer氏の TCP/IPプロトコルに関する一連の書籍をお読みください.</p></div><div class=paragraph><p>前提知識に加え, さらに, モデムの設定が完了しており, そのモデムを経由し てログインできるように, システムファイル群が適切に記述できているものと 仮定しています. もしモデムの準備ができていないときには, あらかじめダイヤ ルアップ機能の設定についてのチュートリアルをお読みください. Webブラ ウザが使えるのであれば <a href=http://www.FreeBSD.org/>http://www.FreeBSD.org/ </a>におけるチュー トリアルの一覧を調べてください. あるいは, この文書を見つけた場所を調べ て, <span class=filename>dialup.txt</span> やそれに類似した名前の文書をお読みください. 関連す るマニュアルページとしては, シリアルポート向けデバイスドライバについて の <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> をはじめ, モデムからのログインを 受理できるようにシステ ムを設定するための <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> など, さらには, シリアルポート関連パラメータ ( たと えば直接接続シリアルインタフェースの <code>clocal</code> ) についての <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> なども助けになるかもしれません.</p></div></div><div class=sect4><h5 id=_概要_2>18.5.2.2. 概要<a class=anchor href=#_概要_2></a></h5><div class=paragraph><p>一般的な設定内容で FreeBSDを SLIPサーバとして利用すると, その動作は次 のようになります. まず, SLIPユーザが FreeBSD による SLIPサーバへ電話し て, SLIP専用IDでログインします. なお, このIDを持ったユーザはシェルとし て <span class=filename>/usr/sbin/sliplogin</span> を使います. この <code>sliplogin</code> は, ファイル <span class=filename>/etc/sliphome/slip.hosts</span> の中から, ログインIDと一致する 記述行を探します. もし一致する行があれば, ログインしたシリアル回線を, 利用可能な SLIPインタフェースへ接続し, その後にシェルスクリプト <span class=filename>/etc/sliphome/slip.login</span> で SLIPインタフェースを設定します.</p></div><div class=sect5><h6 id=_slipサーバへのログイン例>18.5.2.2.1. SLIPサーバへのログイン例<a class=anchor href=#_slipサーバへのログイン例></a></h6><div class=paragraph><p>仮に SLIPユーザIDが <code>Shelmerg</code> とします. すると, <span class=filename>/etc/master.passwd</span> における <code>Shelmerg</code> のエントリは次のよ うなものになります (実際には一つの行に続いている) .</p></div><div class="literalblock programlisting"><div class=content><pre>Shelmerg:password:1964:89::0:0:Guy Helmer - SLIP:/usr/users/Shelmerg:/usr/sbin/sliplogin</pre></div></div><div class=paragraph><p><code>Shelmerg</code> がログインすると, <code>sliplogin</code> は, ファイル <span class=filename>/etc/sliphome/slip.hosts</span> からユーザIDと一致する行を探しま す. いま仮に, <span class=filename>/etc/sliphome/slip.hosts</span> に次のような記述がなされていたとします.</p></div><div class="literalblock programlisting"><div class=content><pre>Shelmerg        dc-slip sl-helmer       0xfffffc00      autocomp</pre></div></div><div class=paragraph><p><code>sliplogin</code> が上記のエントリを見つけると, <em>Shelmerg</em> が使用して いるシリアル回線を, 利用可能な SLIPインタフェースのなかの最初のものへ 接続し, 次の内容の <span class=filename>/etc/sliphome/slip.login</span> を実行します.</p></div><div class="literalblock programlisting"><div class=content><pre>/etc/sliphome/slip.login 0 19200 Shelmerg dc-slip sl-helmer 0xfffffc00 autocomp</pre></div></div><div class=paragraph><p>もし上記の手順が正常に処理されると, <span class=filename>/etc/sliphome/slip.login</span> は, <code>sliplogin</code> が割り当てた SLIPインタフェース (この例では <span class=filename>slip.login</span> で与えられたパラメータのうちで最初の値である SLIP インタフェース0である) に対して <code>ifconfig</code> を実行し, ローカル IPアドレス (<code>dc-slip</code>)をはじめ, リモート IPアドレス (<code>sl-helmer</code>), SLIPインタフェースへのネットワークマスク (<code>0xfffffc00</code>), およびその他のフラグ (<code>autocomp</code>)を設定 します. 逆に, さきほどの手順が正常に終了しなかった場合, 通常は <code>sliplogin</code> は十分な情報を syslog の <code>daemon</code> 機能経由で <span class=filename>/var/log/messages</span> へ記録します ( <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> のマニュアルページを参照のうえ, さらに <span class=filename>/etc/syslog.conf</span> を調べて <code>syslogd</code> がどのファイルへ記 録するかを確認のこと) .</p></div><div class=paragraph><p>例はこのくらいにして, さっそくシステムのセットアップを始めてみましょう.</p></div></div></div><div class=sect4><h5 id=_カーネルのコンフィグレーション>18.5.2.3. カーネルのコンフィグレーション<a class=anchor href=#_カーネルのコンフィグレーション></a></h5><div class=paragraph><p>FreeBSD のデフォルトのカーネルには, 通常, 二つの SLIPインタフェースが 準備されています (<span class=filename>sl0</span> と <span class=filename>sl1</span>) . これらのインタフェー スが使用中のカーネルに準備されているかどうかを調べるには, <code>netstat -i</code> を実行してください.</p></div><div class=paragraph><p><code>netstat -i</code> の出力例</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Name  Mtu   Network     Address            Ipkts Ierrs    Opkts Oerrs  Coll
ed0   1500  &lt;Link&gt;0.0.c0.2c.5f.4a         291311     0   174209     0   133
ed0   1500  138.247.224 ivory             291311     0   174209     0   133
lo0   65535 &lt;Link&gt;                            79     0       79     0     0
lo0   65535 loop        localhost             79     0       79     0     0
sl0<span class=k>*</span>  296   &lt;Link&gt;                             0     0        0     0     0
sl1<span class=k>*</span>  296   &lt;Link&gt;                             0     0        0     0     0</code></pre></div></div><div class=paragraph><p><code>netstat -i</code> の出力に <span class=filename>sl0</span> と <span class=filename>sl1</span> のインタフェー スが含まれているということから, カーネルには二つの SLIPインタフェー スが組み込まれているということを示しています. (<code>sl0</code> と <code>sl1</code> に付いたアスタリスクは, <code>netstat -i</code> の実行時点で はインタフェースが "ダウン" していることを表しています. )</p></div><div class=paragraph><p>なお, パケットのフォワード機能は FreeBSD のデフォルトのカーネルでは設定 されていません (すなわちルータとしては動作しない) . もしインターネット 接続ホストについての RFC要件 ( RFC 1009 [Requirements for Internet Gateways] と 1122 [Requirements for Internet Hosts - Communication Layers], おそらく 1127 [A Perspective on the Host Requirements RFCs] も ) に準拠して, FreeBSDによる SLIPサー バをルータとして動作させたいときには, <span class=filename>/etc/rc.conf</span> (バージョ ン 2.2.2 より前の FreeBSD では <span class=filename>/etc/sysconfig</span>) ファイル の <code>gateway_enable</code> 変数を <code>YES</code> としてください. もし古いシステ ムで <span class=filename>/etc/sysconfig</span> ファイルすらないときには, 次のコマン ドを <span class=filename>/etc/rc.local</span> へ追加してください.</p></div><div class="literalblock programlisting"><div class=content><pre>sysctl -w net.inet.ip.forwarding = 1</pre></div></div><div class=paragraph><p>この新しい設定を有効とするには, リブートする必要があります.</p></div><div class=paragraph><p>デフォルトのカーネルコンフィグレーションファイル (<span class=filename>/sys/i386/conf/GENERIC</span>) の最後の部分に, 次のような行がありま す.</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device sl 2</pre></div></div><div class=paragraph><p>この行によって, 使用可能な SLIPデバイスの総数が決まります. すなわち, 行 末の数値が, 同時に動作可能な SLIP接続の最大数となります.</p></div><div class=paragraph><p>カーネルの再構築については, <a href=./#kernelconfig>FreeBSDカー ネルのコンフィグレーション</a> を参照ください.</p></div></div><div class=sect4><h5 id=_sliploginのコンフィグレーション>18.5.2.4. Sliploginのコンフィグレーション<a class=anchor href=#_sliploginのコンフィグレーション></a></h5><div class=paragraph><p>すでにご説明したように, <span class=filename>/usr/sbin/sliplogin</span> のコンフィグレー ションのために, 3種類のファイルが<span class=filename>/etc/sliphome</span> ディレクトリに あります (<code>sliplogin</code> についての実際のマニュアルページとしては <a href="https://man.freebsd.org/cgi/man.cgi?query=sliplogin&amp;sektion=8&amp;format=html">sliplogin(8)</a> を参照のこと) . ファイル <span class=filename>slip.hosts</span> は SLIPユーザおよびその IPアドレスを決めます. 通常, ファイル <span class=filename>slip.login</span> は, SLIPインタフェースを設定することだけに使 用します. <span class=filename>slip.logout</span> はオプションのファイルで, <span class=filename>slip.login</span> で設定した内容を, シリアル接続が終了した時点で解除 するときに使用します.</p></div><div class=sect5><h6 id=_slip_hosts_のコンフィグレーション>18.5.2.4.1. <span class=filename>slip.hosts</span> のコンフィグレーション<a class=anchor href=#_slip_hosts_のコンフィグレーション></a></h6><div class=paragraph><p><span class=filename>/etc/sliphome/slip.hosts</span> には, 少なくとも 4 つの項目をホワイ トスペース (スペースやタブ) で区切って指定します.</p></div><div class=ulist><ul><li><p>SLIPユーザのログインID</p></li><li><p>SLIPリンクのローカル (SLIPサーバ側) アドレス</p></li><li><p>SLIPリンクのリモートアドレス</p></li><li><p>ネットワークマスク</p></li></ul></div><div class=paragraph><p>ホスト名をローカルおよびリモートのアドレスとして 記述できます (IPアドレ スの決定は, <span class=filename>/etc/host.conf</span> の指定内容に応じて, <span class=filename>/etc/hosts</span> か DNSのいずれかによって決定される) . また, ネット ワークマスクも <span class=filename>/etc/networks</span> ファイルに記述された名前を参照す ることで, 指定することもできると思います. これまでの例としてあげたシス テムでの <span class=filename>/etc/sliphome/slip.hosts</span> は次のようになります.</p></div><div class="literalblock programlisting"><div class=content><pre>#
# login local-addr      remote-addr     mask            opt1    opt2
#                                               (normal,compress,noicmp)
#
Shelmerg  dc-slip       sl-helmerg      0xfffffc00      autocomp</pre></div></div><div class=paragraph><p>それぞれの行の最後には, 次に示すオプションを一つ以上指定できます.</p></div><div class=ulist><ul><li><p><code>normal</code> - ヘッダを圧縮しない</p></li><li><p><code>compress</code> - ヘッダを圧縮する</p></li><li><p><code>autocomp</code> - リモートの設定に応じて, ヘッダを圧縮する</p></li><li><p><code>noicmp</code> - ICMPパケットを禁止する ( "ping" パケットは送出されず, バンド幅を占有しない)</p></li></ul></div><div class=paragraph><p>なお, FreeBSDバージョン2の初期リリースの <code>sliplogin</code> は, 旧 FreeBSD 1.xでは有効であった上記のオプションを無視していましたので, <code>normal</code>, <code>compress</code>, <code>autocomp</code>, そして <code>noicmp</code> などのオプションは FreeBSD 2.2でサポートされるまでは効果がありませんでした (た だしこれらのフラグを使うためには <span class=filename>slip.login</span> スクリプトへ記述する 必要がある) .</p></div><div class=paragraph><p>SLIPリンクでのローカルとリモート向けのアドレスの 選び方は, TCP/IPサブネッ トを専用に割り当てるか, または "プロキシ ARP" を SLIPサーバへ用いるかによって違います ( "プロキシ ARP" という用語のここでの使い方は本来のものではないが, 説明のためにこの用語を使う) . もし, どちらの方式を選ぶべきか判らなかったり, IPアドレスの割り当て方が不明のときには, 上述の <a href=#slips-prereqs>前提</a> の節で紹介した TCP/IP関連書籍を参考になさるか, またはあなたの IPネットワークを管理している方に相談なさると よいでしょう.</p></div><div class=paragraph><p>独立したサブネットを SLIPクライアントへ適用するときには, すでに割り当てられている IPネットワーク番号の範囲からサブネット番号を割り当て, 同 時にそのサブネットの範囲内で有効な IPアドレスを SLIPクライアントの IP 番号として割り当てる必要があります. さらに, この SLIPサブネットから SLIPサーバを経由して最も近い IPルータへの経路を静的に設定するか, または <code>gated</code> を FreeBSDによる SLIPサーバへインストールして, 適当 なルーティングプロトコルを使って, SLIPサーバ経由のサブネットへの経路情 報をルータ群へ通知できるように設定するか, のいずれかをおこなう必要があります.</p></div><div class=paragraph><p>"プロキシ ARP" 方式を採用するときには, SLIPクライアント向けの IPアドレス として, SLIPサーバのサブネットの範囲から 選んで割り当てるとともに, <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a> コマンドを使うために <span class=filename>/etc/sliphome/slip.login</span> と<span class=filename>/etc/sliphome/slip.logout</span> のスクリプトを修正して, SLIPサー バにおける ARPテーブル内のプロキシ ARPエントリへ 反映させる必要がありま す.</p></div></div><div class=sect5><h6 id=_slip_login_のコンフィグレーション>18.5.2.4.2. <span class=filename>slip.login</span> のコンフィグレーション<a class=anchor href=#_slip_login_のコンフィグレーション></a></h6><div class=paragraph><p>ファイル <span class=filename>/etc/sliphome/slip.login</span> の一般的な内容は次にようになります.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#	@(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6</pre></div></div><div class=paragraph><p>この <span class=filename>slip.login</span> ファイルの役目は単に, SLIPインタフェースにつ いてのローカルとリモートのアドレス, およびそのネットワークマスクを <code>ifconfig</code> コマンドで設定することです.</p></div><div class=paragraph><p>もし "プロキシ ARP" 方式を採用する (SLIPクライアントへ独立したサブネットを使わない) ときには, ファイル <span class=filename>/etc/sliphome/slip.login</span> は次のような内容になります.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#	@(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6
# Answer ARP requests for the SLIP client with our Ethernet addr
/usr/sbin/arp -s $5 00:11:22:33:44:55 pub</pre></div></div><div class=paragraph><p>この <span class=filename>slip.login</span> で追加された行 <code>arp -s $5 00:11:22:33:44:55 pub</code> は, SLIPサーバにおける ARPテーブルへ新たなエントリを作ります. SLIPサーバ は, この ARPエントリが作られると, SLIPクライアントの IPアドレスと話し たい他の IPノードが要求してきたときにはいつも, SLIPサーバ の Ethernet MACアドレスを返すようになります.</p></div><div class=paragraph><p>上記の例を実際に流用なさるときには, 例にある Ethernet MACアドレス (<code>00:11:22:33:44:55</code>) を, あなたのシステムの実際のEthernetカー ドの MACアドレスと置き換えなければ "プロキシ ARP" はうまく動作しません! SLIPサーバの Ethernet MACアドレスを調べるには <code>netstat -i</code> コマ ンドを利用してください. 実行結果の第2行は次のようなものになるはずです.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ed0   1500  &lt;Link&gt;0.2.c1.28.5f.4a         191923     0   129457     0   116</code></pre></div></div><div class=paragraph><p>この例での Ethernet MACアドレスは <code>00:02:c1:28:5f:4a</code> であると 読みます. なお <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a> における MAC アドレスの指定に際しては, コマンド <code>netstat -i</code> が付けた Ethernet MACアドレスのピリオド記 号をコロン記号と置き換え, かつ単一桁の 16 進数にはゼロを先頭に加える必 要があります. この指定についての正確な情報は <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a> を参照く ださい.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/sliphome/slip.login</span> と <span class=filename>/etc/sliphome/slip.logout</span> を作成したならば, ファイル属性の "実行" ビット (すなわち <code>chmod 755 /etc/sliphome/slip.login /etc/sliphome/slip.logout</code>) を 設定しなければなりません. さもなければ <code>sliplogin</code> が うまく実行されません.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_slip_logout_のコンフィグレーション>18.5.2.4.3. <span class=filename>slip.logout</span> のコンフィグレーション<a class=anchor href=#_slip_logout_のコンフィグレーション></a></h6><div class=paragraph><p>ファイル <span class=filename>/etc/sliphome/slip.logout</span> は必ずしも必要なものではあ りません (ただし "プロキシ ARP" を利用する場合を除く) . もしこのファイルを 作成するときには, 次に示す標準的な <span class=filename>slip.logout</span> スクリプト例を 参考にしてください.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#	slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down</pre></div></div><div class=paragraph><p>"プロキシ ARP" を利用する場合, この <span class=filename>/etc/sliphome/slip.logout</span> を 使って, 特定の SLIPクライアント向けの ARPエントリを削除したくなるようなときがあります.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       @(#)slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down
# Quit answering ARP requests for the SLIP client
/usr/sbin/arp -d $5</pre></div></div><div class=paragraph><p>コマンド <code>arp -d $5</code> は, SLIPクライアントがログインした 際に, "プロキシ ARP" を使った <span class=filename>slip.login</span> によって追加され た ARPエントリを削除します.</p></div><div class=paragraph><p>これによって, 繰り返して利用することができるわけです. 必ず, <span class=filename>/etc/sliphome/slip.logout</span> を作成した後に, 実行ビットを設定し てください ( <code>chmod 755 /etc/sliphome/slip.logout</code> ) .</p></div></div></div><div class=sect4><h5 id=_ルーティングについての考慮点>18.5.2.5. ルーティングについての考慮点<a class=anchor href=#_ルーティングについての考慮点></a></h5><div class=paragraph><p>"プロキシ ARP" 方式を利用せずに SLIPクライアントとその他のネットワーク (Internetも含む) の構成要素との間でパケットをルーティングするときには, SLIPサーバ経由で SLIPクライアントが属するサブネットまでの経路を, 最も 近いデフォルトのルータ群へ静的な経路情報として 追加しなければならないか, または <code>gated</code> を FreeBSDによる SLIPサーバへインストールして, SLIP サブネットについての経路情報を, 適当なルーティングプロトコルでルー タ群へ通知できるように設定するか, のどちらかをおこなわなければなりません.</p></div><div class=sect5><h6 id=_静的な経路>18.5.2.5.1. 静的な経路<a class=anchor href=#_静的な経路></a></h6><div class=paragraph><p>静的な経路を最も近いデフォルトの ルータ群へ追加することが困難なことがあ ります (経路情報を追加できる権限がなければそもそも不可能となる). もし あなたの組織に複数のルータで構成された ネットワークがあるならば, ある種 のルータ (たとえば Ciscoや Proteonなど) は, 静的な経路を SLIPサブネッ トへ使うようにルータを設定しなければならないだけでなく, その静的経路を 他のどのルータへ知らせるのかもあらかじめ 指定しておく必要がありますから, 静的経路に基づくルーティングを軌道に乗せるには それなりの専門的技術やト ラブルシューティングやコツが必要だと思います.</p></div></div><div class=sect5><h6 id=_gatedの稼働>18.5.2.5.2. <code>gated</code>の稼働<a class=anchor href=#_gatedの稼働></a></h6><div class=paragraph><p>静的経路についての頭痛への代替手段は, <code>gated</code> を FreeBSDによる SLIPサー バへインストールして, 適切なルーティングプロトコル (RIP/OSPF/BGP/EGP) を使って SLIPサブネットについての経路情報を他のルータへ知らせるように 設定することです. <a href=./#ports>ports コレクション</a>から <code>gated</code> を用いることもできますし, <a href=ftp://ftp.gated.merit.edu/research.and.development/gated/>GateD 匿名 FTP サイト</a> から探して自分自身で構築することもで きます. この文章を執筆時点の最新バージョンは <span class=filename>gated-R3_5Alpha_8.tar.Z</span> であり, このファイル "だけで" FreeBSDで 動作させることができます. <code>gated</code> についてのすべての情報と文書 は <a href=http://www.gated.merit.edu/>Merit GateD コンソーシアム</a> からはじまる Web 上で入手でき ます. <code>gated</code> のコンパイルとインストールを行ったならば, 独自の 設定のために <span class=filename>/etc/gated.conf</span> ファイルを記述してください. 次の 例は, 筆者が FreeBSDによる SLIP サーバで使っている内容と類似のものです.</p></div><div class="literalblock programlisting"><div class=content><pre>#
# gated configuration file for dc.dsu.edu; for gated version 3.5alpha5
# Only broadcast RIP information for xxx.xxx.yy out the ed Ethernet interface
#
#
# tracing options
#
traceoptions &#34;/var/tmp/gated.output&#34; replace size 100k files 2 general ;

rip yes {
 interface sl noripout noripin ;
 interface ed ripin ripout version 1 ;
 traceoptions route ;
} ;

#
# Turn on a bunch of tracing info for the interface to the kernel:
kernel {
 traceoptions remnants request routes info interface ;
} ;

#
# Propagate the route to xxx.xxx.yy out the Ethernet interface via RIP
#

export proto rip interface ed {
        proto direct {
                xxx.xxx.yy mask 255.255.252.0 metric 1; # SLIP connections
        } ;
} ;

#
# Accept routes from RIP via ed Ethernet interfaces

import proto rip interface ed {
        all ;
} ;</pre></div></div><div class=paragraph><p>この <span class=filename>gated.conf</span> ファイルの例では, SLIPのサブネット <em>xxx.xxx.yy</em> についての経路情報を RIPを使って Ethernetへブロー ドキャストしています. もし <span class=filename>ed</span> ドライバ以外の Ethernetドライバを使うのであれば, <span class=filename>ed</span> インタフェースの記述を適切なものに置き換えてくだ さい. またこの例では, <code>gated</code>の動作をデバッグするために, <span class=filename>/var/tmp/gated.output</span> へトレース情報を出力するように指示して います. <code>gated</code> が希望通りに動作したならば, このトレースオプショ ンを止めることができます. なお, 例における <em>xxx.xxx.yy</em> を, あ なた自身の SLIPサブネットのネットワークアドレスに換えてください (また <code>proto direct</code> 部分のネットワークマスクも換えることを忘れないこ と) .</p></div><div class=paragraph><p><code>gated</code> のコンパイルとインストールが終了し, コンフィグレーショ ンファイルの作成も完了したら, FreeBSDシステムではデフォルトの <code>routed</code>に代わって <code>gated</code> を起動してください. そのため には, <span class=filename>/etc/netstart</span> の <span class=filename>routed/gated</span> 起動パラメータを 適切な値に設定してください. <code>gated</code> のコマンドラインパラメータにつ いての情報は, <code>gated</code> のマニュアルページを参照してください.</p></div></div></div></div></div></div></div><div class=sect1><h2 id=mail>Chapter 19. 電子メール<a class=anchor href=#mail></a></h2><div class=sectionbody><div class=sect2><h3 id=mail-synopsis>19.1. この章では<a class=anchor href=#mail-synopsis></a></h3><div class=paragraph><p>"電子メール"、email としてのほうが知られているでしょう、 は現代で最も広く利用されているコミュニケーション手段の一つです。 この章では FreeBSD 上でメールサーバを実行するための基本的な導入を説明します。 しかし、この文書は完璧な参考文献ではなく、 実際のところ考慮すべき重要な点の多くが省略されています。 この件について、より網羅したものについては <a href=./#bibliography>参考図書</a> に掲載されている多くの優れた書籍を参照してください。</p></div><div class=paragraph><p>この章では、以下の分野について説明します。</p></div><div class=ulist><ul><li><p>電子メールの送受信に関係しているソフトウェアの構成要素</p></li><li><p>FreeBSD における sendmail の基本的な設定ファイルのある場所</p></li><li><p>スパマーがあなたのメールサーバを踏台として不正に使用することを防ぐ方法</p></li><li><p>あなたのシステムに sendmail の置き換えとなる代替の MTA をインストールして設定する方法</p></li><li><p>メールサーバにまつわる共通の問題の解決法</p></li><li><p>UUCP とともに SMTP を使う方法</p></li><li><p>ダイアルアップ接続でメールを使う方法</p></li><li><p>セキュリティを向上するために SMTP 認証を設定する方法</p></li></ul></div><div class=paragraph><p>この章を読む前に、以下のことを理解しておく必要があります。</p></div><div class=ulist><ul><li><p>ネットワーク接続の適切な設定方法 (<a href=./#advanced-networking>高度なネットワーク</a>)</p></li><li><p>あなたのメールホストに対する DNS 情報の適切な設定方法 (<a href=./#advanced-networking>高度なネットワーク</a>)</p></li><li><p>サードパーティ製ソフトウェアのインストール方法 (<a href=./#ports>アプリケーションのインストール - packages と ports</a>)</p></li></ul></div></div><div class=sect2><h3 id=mail-using>19.2. 電子メールを使う<a class=anchor href=#mail-using></a></h3><div class=paragraph><p>email の交換には 5 つの主要な部分があります。 それらは <a href=#mail-mua>ユーザープログラム</a>、 <a href=#mail-mta>サーバーデーモン</a>、 <a href=#mail-dns>DNS</a>、 <a href=#mail-receive>POP もしくは IMAP のデーモン</a>、 そしてもちろん <a href=#mail-host>メールホスト</a>です。</p></div><div class=sect3><h4 id=mail-mua>19.2.1. ユーザープログラム<a class=anchor href=#mail-mua></a></h4><div class=paragraph><p>いくつか名前を挙げれば、 mutt, pine, elm そして mail といったコマンドラインプログラムや balsa, xfmail のような GUI プログラム、WWW ブラウザーのようにさらに "洗練された" ものまであります。 これらのプログラムは、email の処理を <a href=#mail-mta>server daemons</a> を呼び出したり TCP 経由で渡したり、といった手段でローカルの <a href=#mail-host>"メールホスト"</a> に任せるだけです。</p></div></div><div class=sect3><h4 id=mail-mta>19.2.2. メールホストサーバデーモン<a class=anchor href=#mail-mta></a></h4><div class=paragraph><p>通常、これは sendmail (FreeBSD のデフォルト) や qmail, postfix もしくは exim といった他のメールサーバーデーモンの一つです。 他にもあるのですが、以上のものが広く使われています。</p></div><div class=paragraph><p>サーバーデーモンは通常 2 つの機能 - やってくるメールを受け取るのと出ていくメールを配送する、 を持っています。メールを読むために POP や IMAP で接続する、 ということはできません。 そのためにはもう一つ<a href=#mail-receive>デーモン</a>が必要なのです。</p></div><div class=paragraph><p>いくつかの古いバージョンの sendmail には深刻なセキュリティ問題がありますが、 現在のバージョンを使っていれば特に問題ないことに注意してください。 例のごとく、 どんなソフトウェアを利用する時にも最新の状態にしておくのが大事なのです。</p></div></div><div class=sect3><h4 id=mail-dns>19.2.3. Email と DNS<a class=anchor href=#mail-dns></a></h4><div class=paragraph><p>Domain Name System (DNS) とそのデーモンである <code>named</code> は email の配送において大変重要な役割を担ってます。 あなたのサイトからもう一つのサイトへメールを配送するためには、 サーバーデーモンは DNS からそのサイトを探し、 メールの受け取り先のホストを決定します。</p></div><div class=paragraph><p>メールがあなたに送られた場合にも同じような仕組みになっています。 DNS にはホスト名と IP アドレス、ホスト名とメールホストをマッピングするデータベースがあります。 IP アドレスは A レコードで指定されます。 MX (Mail eXchanger) レコードはあなた宛のメールを受け取るホストを指定します。 あなたのホスト名に対する MX レコードがない場合には、 メールは直接あなたのホストに配送されます。</p></div></div><div class=sect3><h4 id=mail-receive>19.2.4. メールの受け取り<a class=anchor href=#mail-receive></a></h4><div class=paragraph><p>メールはメールホストが受け取ります。 このホストは送られてきたメールを集め、 (ユーザーが) 読んだりピックアップしたりするために保存します。 保存されているメールをピックアップするにはメールホストに接続する必要があります。 これは POP や IMAP を用いて行なわれます。 メールホスト上で直接メールを読みたい時は POP や IMAP のサーバーは必要ありません。</p></div><div class=paragraph><p>POP や IMAP のサーバーを走らせるためには 2 つのことをやらなければいけません。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>POP や IMAP のデーモンを <a href=https://www.FreeBSD.org/ports/>ports コレクション</a> からインストールします。</p></li><li><p><span class=filename>/etc/inetd.conf</span> を修正して POP や IMAP のサーバーが起動されるように設定します。</p></li></ol></div></div></div></div><div class=sect3><h4 id=mail-host>19.2.5. メールホスト<a class=anchor href=#mail-host></a></h4><div class=paragraph><p>メールホストとは責任をもってメールを配送したり、 あなたのホストや、もしかするネットワークも、に宛てたメールを受け取ったりするホストに与えられる名前です。</p></div></div></div><div class=sect2><h3 id=sendmail>19.3. sendmail の設定<a class=anchor href=#sendmail></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> は FreeBSD のデフォルトの メールトランスファエージェント (MTA) です。 sendmail の仕事はメールユーザエージェント (MUA) からのメールを受け取り、 それを設定ファイルで定義された適当なメーラに届けることです。 sendmail はネットワーク接続を受け入れて、 ローカルのメールボックスにメールを届けたり 別のプログラムにメールを渡したりもできます。</p></div><div class=paragraph><p>sendmail は次の設定ファイルを使用します。</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">ファイル名</th><th class="tableblock halign-left valign-top">機能</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/access</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sendmail アクセスデータベースファイル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/aliases</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>メールボックスエイリアス</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/local-host-names</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sendmail が受け付ける配送先ホストのリスト</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/mailer.conf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>メーラプログラムの設定</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/mailertable</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>メーラ配送表</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/sendmail.cf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sendmail の主設定ファイル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/virtusertable</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>仮想ユーザおよび仮想ドメイン表</p></td></tr></tbody></table><div class=sect3><h4 id=_etcmailaccess>19.3.1. <span class=filename>/etc/mail/access</span><a class=anchor href=#_etcmailaccess></a></h4><div class=paragraph><p>アクセスデータベースは、 どのホストまたは IP アドレスがローカルメールサーバに接続できるか、 そして接続の種類は何か、ということを定義します。 ホストは <code>OK</code>, <code>REJECT</code>, <code>RELAY</code> として指定できます。 または、メーラエラーを指定することで、 単に sendmail の エラー処理ルーチンに渡されます。 <code>OK</code> として指定されたホスト (これはデフォルトです) は、 メールの最終宛先がローカルマシンである限り、 このホストへメールを送ることを認められます。 <code>REJECT</code> として指定されたホストは、 すべてのメール接続を拒絶されます。 ホスト名に対して <code>RELAY</code> オプションを指定されたホストは、 このメールサーバを通過して任意の宛先へメールを送ることを認められます。</p></div><div class=exampleblock><div class=title>例 41. sendmail アクセスデータベースの設定</div><div class=content><div class="literalblock programlisting"><div class=content><pre>cyberspammer.com                550 We don&#39;t accept mail from spammers
FREE.STEALTH.MAILER@            550 We don&#39;t accept mail from spammers
another.source.of.spam          REJECT
okay.cyberspammer.com           OK
128.32                          RELAY</pre></div></div></div></div><div class=paragraph><p>この例では五つのエントリがあります。 表の左側に当てはまるメール送信者は、表の右側の動作に支配されます。 はじめの二つの例は、エラーコードを sendmail のエラー処理ルーチンに渡します。 メールが表の左側に当てはまると、リモートホストにそのメッセージが表示されます。 次のエントリは <code>another.source.of.spam</code> というインターネット上の特定のホストからのメールを拒絶します。 次のエントリは <code>okay.cyberspammer.com</code> からのメール接続を受け入れます。 このエントリは上にある <code>cyberspammer.com</code> という行よりもさらに厳密です (厳密に一致すればするほど、そうでないものより優先されます)。 最後のエントリは <code>128.32</code> から始まる IP アドレスのホストからの電子メールのリレーを認めます。 これらのホストは他のメールサーバに到達できるこのメールサーバを使ってメールを送ることができるでしょう。</p></div><div class=paragraph><p>このファイルを変更したら、 データベースを更新するために <span class=filename>/etc/mail/</span> ディレクトリで <code>make</code> コマンドを実行する必要があります。</p></div></div><div class=sect3><h4 id=_etcmailaliases>19.3.2. <span class=filename>/etc/mail/aliases</span><a class=anchor href=#_etcmailaliases></a></h4><div class=paragraph><p>エイリアスデータベースには、 他のユーザ、ファイル、プログラムまたは他のエイリアスに展開される 仮想的なメールボックスの一覧が記載されています。 <span class=filename>/etc/mail/aliases</span> において使用できる例をいくつかあげます。</p></div><div class=exampleblock><div class=title>例 42. メールエイリアス</div><div class=content><div class="literalblock programlisting"><div class=content><pre>root: localuser
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: &#34;|/usr/local/bin/procmail&#34;</pre></div></div></div></div><div class=paragraph><p>ファイル形式はシンプルです。 コロンの左側にあるメールボックス名は、右側のターゲットに展開されます。 はじめの例は単純に <code>root</code> のメールボックスを <code>localuser</code> のメールボックスに展開し、 それからエイリアスデータベースをもう一度調べます。 一致するエントリがなければメッセージはローカルユーザである <code>localuser</code> に配送されます。 次の例はメールリストです。 <code>ftp-bugs</code> のメールボックスへのメールは <code>joe</code>, <code>eric</code> および <code>paul</code> の三つのローカルメールボックスに展開されます。 リモートメールボックスは <code>user@example.com</code> のように指定できることに注意してください。 次の例はメールをファイル、この場合 <span class=filename>/dev/null</span> に書き込みます。 最後の例はメールをプログラムに送ります。 この場合メールのメッセージは UNIX® パイプを通じて <span class=filename>/usr/local/bin/procmail</span> の標準入力に書き込まれます。</p></div><div class=paragraph><p>このファイルを変更したら、 データベースを更新するために<span class=filename>/etc/mail/</span> ディレクトリで <code>make</code> コマンドを実行する必要があります。</p></div></div><div class=sect3><h4 id=_etcmaillocal_host_names>19.3.3. <span class=filename>/etc/mail/local-host-names</span><a class=anchor href=#_etcmaillocal_host_names></a></h4><div class=paragraph><p>これは <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> がローカルホスト名として認めるホスト名のリストです。 sendmail がメールを受け取るすべてのドメインやホストにこのファイルを置いてください。 たとえば、このメールサーバは <code>example.com</code> というドメインおよび <code>mail.example.com</code> というホストへのメールを受け取るとすると、 <span class=filename>local-host-names</span> ファイルの内容は次のようになるでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>example.com
mail.example.com</pre></div></div><div class=paragraph><p>このファイルを更新したら、変更を読み込むために <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> を再起動する必要があります。</p></div></div><div class=sect3><h4 id=_etcmailsendmail_cf>19.3.4. <span class=filename>/etc/mail/sendmail.cf</span><a class=anchor href=#_etcmailsendmail_cf></a></h4><div class=paragraph><p>sendmail の主設定ファイルである <span class=filename>sendmail.cf</span> は、電子メールアドレスの書き換えから、 リモートメールサーバへ拒絶メッセージを送ることまで sendmail の全般的な動作をすべて制御します。 当然、そのようなさまざまな役割によりこの設定ファイルは大変複雑で、 その詳細についてはこの節の少し範囲外です。好運なことに、 標準的な構成のメールサーバではこのファイルをめったに変更する必要はありません。</p></div><div class=paragraph><p>sendmail の主設定ファイルは sendmail の機能と動作を決定する <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> マクロから構築できます。 詳細については <span class=filename>/usr/src/contrib/sendmail/cf/README</span> を参照してください。</p></div><div class=paragraph><p>このファイルを更新したら、その変更を反映するために sendmail を再起動する必要があります。</p></div></div><div class=sect3><h4 id=_etcmailvirtusertable>19.3.5. <span class=filename>/etc/mail/virtusertable</span><a class=anchor href=#_etcmailvirtusertable></a></h4><div class=paragraph><p><span class=filename>virtusertable</span> は仮想ドメインおよび仮想メールボックスに対するアドレスを実際のメールボックスと対応づけます。 これらのメールボックスにはローカル、リモート、 <span class=filename>/etc/mail/aliases</span> に定義されたエイリアス、 またはファイルを使用できます。</p></div><div class=exampleblock><div class=title>例 43. 仮想ドメインメール対応表の例</div><div class=content><div class="literalblock programlisting"><div class=content><pre>root@example.com                root
postmaster@example.com          postmaster@noc.example.net
@example.com                    joe</pre></div></div></div></div><div class=paragraph><p>上の例では <code>example.com</code> ドメインへの対応づけをしています。 このファイルはファイルの下までファーストマッチ (訳注: 一致するルールが複数ある場合、 一番最初に一致したルールが適用されること) で処理されます。 はじめの行では <code>root@example.com</code> を ローカルの <code>root</code> メールボックスに対応づけています。 次のエントリでは <code>postmaster@example.com</code> を <code>noc.example.net</code> ホスト上の <code>postmaster</code> メールボックスに対応づけています。 最後に、今までのところでは <code>example.com</code> に関して何も一致しない場合、最後のエントリと一致するでしょう。 これは <code>example.com</code> の誰かに送ったすべてのメールが一致します。これは <code>joe</code> のローカルメールボックスに対応づけられています。</p></div></div></div><div class=sect2><h3 id=mail-changingmta>19.4. MTA の変更<a class=anchor href=#mail-changingmta></a></h3><div class=paragraph><p>すでに述べたように、FreeBSD には MTA (Mail Transfer Agent) として、 sendmail がすでにインストールされています。 したがって、デフォルトではこれがメールの送受信を担当しています。</p></div><div class=paragraph><p>しかしながら、さまざまな理由によって、 システムの MTA を変更しようと考えるシステム管理者もいるかもしれません。 その理由は、単に他の MTA を試してみたいというものから 他のメーラに依存する特定の機能やパッケージが必要だといったものまで、 多岐にわたることでしょう。 幸い、理由がどんなものであれ、FreeBSD では簡単に変更できます。</p></div><div class=sect3><h4 id=_新しい_mta_のインストール>19.4.1. 新しい MTA のインストール<a class=anchor href=#_新しい_mta_のインストール></a></h4><div class=paragraph><p>さまざまな MTA が利用できます。 <a href=./#ports>FreeBSD Ports Collection</a> から探しはじめるのがよいでしょう。 もちろん、どんな場所からでも、あなたが利用したい MTA が FreeBSD で動作する限りすべて自由に使えます。</p></div><div class=paragraph><p>新しい MTA をインストールすることからはじめましょう。 新しい MTA をインストールすると、 あなたの要求が実際に実現したかどうか決める機会が与えられます。さらに、 サービスを sendmail から引き継ぐ前に 新しいソフトウェアを設定する機会が与えられます。これを行う場合、 新しいソフトウェアが <span class=filename>/usr/bin/sendmail</span> のようなシステムバイナリを上書きしようとしないことを確認してください。 そうしないとあなたが設定する前に新しいメールソフトウェアが本格的に動作しはじめてしまいます。</p></div><div class=paragraph><p>あなたが選択したソフトウェアを設定する方法についての情報は、 その MTA の文書を参照してください。</p></div></div><div class=sect3><h4 id=_sendmail_を無効にする>19.4.2. sendmail を無効にする<a class=anchor href=#_sendmail_を無効にする></a></h4><div class=paragraph><p>sendmail を起動するために使用されていた手続きは、 4.5-RELEASE と 4.6-RELEASE の間で著しく変更されました。 したがって、それを無効にするための手続きは微妙に違います。</p></div><div class=sect4><h5 id=_2002_年_4_月_4_日より前の_freebsd_4_5_stable_4_5_release_とそれ以前のバージョンが該当>19.4.2.1. 2002 年 4 月 4 日より前の FreeBSD 4.5-STABLE (4.5-RELEASE とそれ以前のバージョンが該当)<a class=anchor href=#_2002_年_4_月_4_日より前の_freebsd_4_5_stable_4_5_release_とそれ以前のバージョンが該当></a></h5><div class=paragraph><p><span class=filename>/etc/rc.conf</span> に次の行を加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>これは sendmail のメール受信機能を無効にします。 しかし <span class=filename>/etc/mail/mailer.conf</span> (下記参照) が変更されていなければ、sendmail はメールの送信にまだ使われるでしょう。</p></div></div><div class=sect4><h5 id=_2002_年_4_月_4_日以降の_freebsd_4_5_stable_4_6_release_とそれ以降のバージョンが該当>19.4.2.2. 2002 年 4 月 4 日以降の FreeBSD 4.5-STABLE (4.6-RELEASE とそれ以降のバージョンが該当)<a class=anchor href=#_2002_年_4_月_4_日以降の_freebsd_4_5_stable_4_6_release_とそれ以降のバージョンが該当></a></h5><div class=paragraph><p>sendmail を完全に無効にするためには <span class=filename>/etc/rc.conf</span> に次の行を加えなくてはいけません。</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NONE&#34;</pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>もしこの方法で sendmail のメール送信機能を無効にしたのなら、 完全に動作する代替メール配送システムと置き換えることが重要です。 さもなければ、<a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> などのシステム機能は、 それらの結果を通常想定しているようにメールで配送することができなくなるでしょう。 システムの多くの部分が sendmail 互換のシステムがあることを想定しているかもしれません。 もしそれらを無効にした後に、 アプリケーションがメールを送ろうとするために sendmail のバイナリを使用し続ければ、 メールは使われていない sendmail のキューに入り、そして決して配送されないでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p>もし sendmail のメール受信機能だけを無効にしたいのなら <span class=filename>/etc/rc.conf</span> に以下の行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>sendmailの起動オプションに関する詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.sendmail&amp;sektion=8&amp;format=html">rc.sendmail(8)</a> マニュアルをご覧ください。</p></div></div></div><div class=sect3><h4 id=_起動時に新しい_mta_を起動する>19.4.3. 起動時に新しい MTA を起動する<a class=anchor href=#_起動時に新しい_mta_を起動する></a></h4><div class=paragraph><p>起動時に新しい MTA を起動するには二つの選択肢があります。 ここでも、あなたが稼働させている FreeBSD のバージョンに依存します</p></div><div class=sect4><h5 id=_2002_年_4_月_11_日より前の_freebsd_4_5_stable_4_5_release_とそれ以前のバージョンが該当>19.4.3.1. 2002 年 4 月 11 日より前の FreeBSD 4.5-STABLE (4.5-RELEASE とそれ以前のバージョンが該当)<a class=anchor href=#_2002_年_4_月_11_日より前の_freebsd_4_5_stable_4_5_release_とそれ以前のバージョンが該当></a></h5><div class=paragraph><p><span class=filename>/usr/local/etc/rc.d/</span> ディレクトリに、 ファイル名が <span class=filename>.sh</span> でおわり、 <code>root</code> によって実行可能なスクリプトを追加します。 このスクリプトは <code>start</code> および <code>stop</code> パラメータを引数として受け付けるようにします。 起動時にシステムスクリプトは次のコマンドを実行するでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/etc/rc.d/supermailer.sh start</pre></div></div><div class=paragraph><p>これは手動でサーバを起動するためにも使用できます。 システム終了時にはシステムスクリプトは <code>stop</code> オプションを使用して、次のコマンドを実行するでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/etc/rc.d/supermailer.sh stop</pre></div></div><div class=paragraph><p>これはシステムが稼働している間に手動でサーバを停止するためにも使えます。</p></div></div><div class=sect4><h5 id=_2002_年_4_月_11_日以降の_freebsd_4_5_stable_4_6_release_とそれ以降のバージョンが該当>19.4.3.2. 2002 年 4 月 11 日以降の FreeBSD 4.5-STABLE (4.6-RELEASE とそれ以降のバージョンが該当)<a class=anchor href=#_2002_年_4_月_11_日以降の_freebsd_4_5_stable_4_6_release_とそれ以降のバージョンが該当></a></h5><div class=paragraph><p>より新しいバージョンの FreeBSD では、 上記の方法または次の行を <span class=filename>/etc/rc.conf</span> に設定できます。</p></div><div class="literalblock programlisting"><div class=content><pre>mta_start_script=&#34;filename&#34;</pre></div></div><div class=paragraph><p><em>filename</em> は、あなたが MTA を立ち上げるために起動時に実行するスクリプト名です。</p></div></div></div><div class=sect3><h4 id=_システムのデフォルトメーラとして_sendmail_を置き換える>19.4.4. システムのデフォルトメーラとして sendmail を置き換える<a class=anchor href=#_システムのデフォルトメーラとして_sendmail_を置き換える></a></h4><div class=paragraph><p>sendmail プログラムは UNIX® システム上の標準ソフトウェアとして本当にどこでも利用できるので、 これがすでにインストールおよび設定されているとみなしている ソフトウェアもあるかもしれません。 この理由により、代替となる MTA の多くは sendmail コマンドラインインタフェースと 互換性のある実装を提供しています。 これを "差し込む" ことによって、 sendmail の置き換えとして代替 MTA を使用することが容易になります。</p></div><div class=paragraph><p>したがって、あなたが互換メーラを使用しているときには、 <span class=filename>/usr/bin/sendmail</span> のような標準 sendmail バイナリを実行しようとするソフトウェアが、 実際にはその代わりにあなたの選択したメーラを実行しているということを 確かめる必要があるでしょう。 好運なことに、FreeBSD はこの仕事をする <a href="https://man.freebsd.org/cgi/man.cgi?query=mailwrapper&amp;sektion=8&amp;format=html">mailwrapper(8)</a> と呼ばれるシステムを提供しています。</p></div><div class=paragraph><p>インストールされたまま sendmail が稼働しているときには <span class=filename>/etc/mail/mailer.conf</span> には以下のような記述があるでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail    /usr/libexec/sendmail/sendmail
send-mail   /usr/libexec/sendmail/sendmail
mailq       /usr/libexec/sendmail/sendmail
newaliases  /usr/libexec/sendmail/sendmail
hoststat    /usr/libexec/sendmail/sendmail
purgestat   /usr/libexec/sendmail/sendmail</pre></div></div><div class=paragraph><p>このことは、これらのうちどの共通コマンド (<span class=filename>sendmail</span> 自身のような) が実行されても、 システムは <span class=filename>mailer.conf</span> を確認して、 代わりに <span class=filename>/usr/libexec/sendmail/sendmail</span> を実行する <span class=filename>sendmail</span> という名前の mailwapper のコピーを呼び出すことを意味します。 このようなシステムでは、デフォルトの <span class=filename>sendmail</span> が呼び出されたときに、 どのバイナリが実際に実行されるかを変更するのが簡単になります。</p></div><div class=paragraph><p>したがって、sendmail の代わりに <span class=filename>/usr/local/supermailer/bin/sendmail-compat</span> を実行させたいのなら、次のように <span class=filename>/etc/mail/mailer.conf</span> を変更してください。</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail    /usr/local/supermailer/bin/sendmail-compat
send-mail   /usr/local/supermailer/bin/sendmail-compat
mailq       /usr/local/supermailer/bin/mailq-compat
newaliases  /usr/local/supermailer/bin/newaliases-compat
hoststat    /usr/local/supermailer/bin/hoststat-compat
purgestat   /usr/local/supermailer/bin/purgestat-compat</pre></div></div></div><div class=sect3><h4 id=_完了>19.4.5. 完了<a class=anchor href=#_完了></a></h4><div class=paragraph><p>あなたのやりたいようにすべてを設定しおえたら、 もはや必要のない sendmail のプロセスを終了して新しいソフトウェアに関するプロセスを起動するか、 単に再起動してください。 再起動することによって、新しい MTA が起動時に正しく立ち上がるように システムが設定されているかどうか確認することもできるでしょう。</p></div></div></div><div class=sect2><h3 id=mail-trouble>19.5. トラブルシュート<a class=anchor href=#mail-trouble></a></h3><div class=sect3><h4 id=_どうして自分のサイトのホストなのに_fqdn_を使わなければいけないのですか>19.5.1. どうして自分のサイトのホストなのに FQDN を使わなければいけないのですか?<a class=anchor href=#_どうして自分のサイトのホストなのに_fqdn_を使わなければいけないのですか></a></h4><div class=paragraph><p>恐らく、そのホストは実際には別のドメインにあるのでしょう。 例えば <code>foo.bar.edu</code> ドメインにいて、 <code>bar.edu</code> というドメイン内の <code>mumble</code> というホストにアクセスしたいとします。 この時は単に <code>mumble</code> ではなく <code>mumble.bar.edu</code> と FQDN で参照しなければなりません。</p></div><div class=paragraph><p>そもそも、BSD BIND のリゾルバー (resolver) ではこのようなことが可能でしたが、 FreeBSD に入っている最新版の BIND では自分のドメイン以外に対する FQDN でない省略形は許されません。 従ってホストを <code>mumble</code> と曖昧に指定した場合は <code>mumble.foo.bar.edu</code> という名前があればそれになり、 そうでなければ root ドメインから検索されます。</p></div><div class=paragraph><p>これは、 <code>mumble.bar.edu</code> と <code>mumble.edu</code> ということなったドメイン名に対してホスト名のサーチがおこなわれていた以前の振る舞いとは異なったものです。 このような事が悪い例もしくはセキュリティホールとみなされる理由については RFC 1535 を見てください。</p></div><div class=paragraph><p><span class=filename>/etc/resolv.conf</span> で</p></div><div class="literalblock programlisting"><div class=content><pre>domain foo.bar.edu</pre></div></div><div class=paragraph><p>と書いてある行を</p></div><div class="literalblock programlisting"><div class=content><pre>search foo.bar.edu bar.edu</pre></div></div><div class=paragraph><p>と書き換えることで上のようなことができます。 しかし、RFC 1535 にあるように検索順序が "内部 (local) と外部 (public) の管理の境界" をまたがないようにしてください。</p></div></div><div class=sect3><h4 id=_sendmail_が_mail_loops_back_to_myself_というメッセージを出すのですが>19.5.2. sendmail が mail loops back to myself というメッセージを出すのですが。<a class=anchor href=#_sendmail_が_mail_loops_back_to_myself_というメッセージを出すのですが></a></h4><div class=paragraph><p>sendmail FAQ に次のように書いてあります。</p></div><div class="literalblock programlisting"><div class=content><pre>Local configuration error というメッセージが出ます。例えば、

553 relay.domain.net config error: mail loops back to myself
554 &lt;user@domain.net&gt;... Local configuration error

のような感じですが、どうしたら解決できますか?

これは、例えば domain.net のようなドメイン宛てのメールを
MX レコードで特定のホスト(ここでは
relay.domain.net) に送ろうとしたのに、
そのホストでは domain.net
宛てのメールを受け取れるような設定になっていない場合です。
設定の際に
FEATURE(use_cw_file) を指定してある場合には
/etc/mail/local-host-names の中に domain.net を追加してください。
もしくは、/etc/mail/sendmail.cf の中に Cw domain.net
を追加してください。</pre></div></div><div class=paragraph><p>sendmail FAQ は <a href=http://www.sendmail.org/faq>http://www.sendmail.org/faq</a> にありますので、 メールの設定に "おかしなこと" があれば常に読んでください。</p></div></div><div class=sect3><h4 id=_ダイアルアップ_ppp_ホストでメールサーバを実行するにはどうしたらいいの>19.5.3. ダイアルアップ PPP ホストでメールサーバを実行するにはどうしたらいいの?<a class=anchor href=#_ダイアルアップ_ppp_ホストでメールサーバを実行するにはどうしたらいいの></a></h4><div class=paragraph><p>LAN 上にある FreeBSD マシンを、 インターネットに接続したいとします。FreeBSD マシンは、その LAN でのメールゲートウェイになります。FreeBSD マシンは専用線接続ではありません (訳注: ダイアルアップ接続など)。</p></div><div class=paragraph><p>これには、少なくとも二つの方法があります。 一つは UUCP を使うことです。</p></div><div class=paragraph><p>もう一つの方法は、あなたのドメインに対するセカンダリ MX サービスを提供する常時稼働のインターネットサーバを用意することです。 たとえば、あなたの会社のドメインが <code>example.com</code> で、 ISP があなたのドメインに セカンダリ MX サービスを提供するために <code>example.net</code> ドメインを 用意するとしたら次のようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>example.com.	MX	10	example.com.
MX	20	example.net.</pre></div></div><div class=paragraph><p>最終的なメール受信先としては、 一つのホストだけが定義されるべきです (<code>example.com</code> 上の <span class=filename>/etc/mail/sendmail.cf</span> ファイルに、 <code>Cw example.com</code> を追加します)。</p></div><div class=paragraph><p>送信側の <code>sendmail</code> が、 メールを配送しようとしている時、モデムの接続を介してあなたのところ (<code>example.com</code>) に接続しようとします。大抵の場合、 あなたのマシンがオンラインでないために、 接続はタイムアウトしてしまうでしょう。 <code>sendmail</code> プログラムは自動的に、 たとえばあなたのインターネットプロバイダなどのセカンダリの MX サイト (<code>example.net</code>) にメールを配送するでしょう。 セカンダリ MX サイトは定期的にあなたのホストに接続し、 プライマリ MX ホスト (<code>example.com</code>) にメールを配送しようとするでしょう。</p></div><div class=paragraph><p>ログインスクリプトとして、 このようなものを使うとよいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Put me in /usr/local/bin/pppmyisp
( sleep 60 ; /usr/sbin/sendmail -q ) &amp;
/usr/sbin/ppp -direct pppmyisp</pre></div></div><div class=paragraph><p>ユーザごとにログインスクリプトを作りたい場合には、 上記のスクリプトの代わりに、 <code>sendmail -qRexample.com</code> を使用することもできます。 このようにすると、 キューの中の <code>example.com</code> に対するすべてのメールは、すぐに強制的に処理されます。</p></div><div class=paragraph><p>さらに、次のような改良もできます。</p></div><div class=paragraph><p>以下は、<a href=https://lists.FreeBSD.org/subscription/freebsd-isp>FreeBSD Internet service provider’s メーリングリスト</a> から抜粋してきたメッセージです。</p></div><div class="literalblock programlisting"><div class=content><pre>&gt; 私たちはお客様に対して、セカンダリ MX を提供しています。
&gt; お客様は一日に何回か私たちのサービスに接続し、メールを彼らのプライマリ MX
&gt; に受け取ります (彼らのドメインに対するメールが到着した時には、
&gt; 私たちは彼らのサイトを呼び出しません)。
&gt; 私たちの sendmail は、30 分ごとにメールキューに溜っているメールを配送します。
&gt; ちょうどその時に、すべてのメールがプライマリ MX に送られたかどうかを確かめるためには、
&gt; 彼らは 30 分は オンラインでいなければなりません。
&gt;
&gt; すべてのメールを今すぐ送るために sendmail を初期化するコマンドはあるでしょうか?
&gt; もちろん私たちのマシン上には、ユーザはルート (root) 権限を持っていません。

sendmail.cf の privacy flags セクションに、
Opgoaway,restrictqrun の定義があります。

root 以外のユーザがキューを処理できるようにするには、
restrictqrun を削除してください。また、MX の再調整が必要かもしれません。
あなたがたは、顧客のサイトに対する一番優先度の高い MX なので、
次のように定義します。

# If we are the best MX for a host, try directly instead of generating
# local config error.
OwTrue

このようにすると、リモートサイトからのメールが、
顧客のマシンと接続しようとせず、直接あなたがたのホストマシンに配送されるようになります。
ホストマシンに配送されたメールは、続いて顧客のマシンに送られます。
これはホスト名にのみ有効なので、顧客のメールマシンに、
host.customer.com とは別に、customer.com も定義する必要があります。
DNS 上で、customer.com に対する A レコードを定義してください。</pre></div></div></div><div class=sect3><h4 id=_なぜ他のホストにメールを送ろうとするといつも_relaying_denied_と怒られてしまうの>19.5.4. なぜ他のホストにメールを送ろうとすると、いつも Relaying Denied と怒られてしまうの ?<a class=anchor href=#_なぜ他のホストにメールを送ろうとするといつも_relaying_denied_と怒られてしまうの></a></h4><div class=paragraph><p>FreeBSD がインストールされたデフォルトの状態では、 sendmail は動作しているホストからのメールだけを送るように設定されています。 たとえば POP3 サーバがインストールされているとすると、 ユーザは学校や職場など他のリモートの場所からメールを確認することが できます。しかし、彼らは外部からそのホスト以外へのメールを 送ることはやはりできません。 通常、メールを送ろうとしてから少しすると、 <code>5.7 Relaying Denied</code> というエラーメッセージの書かれたメールが MAILER-DAEMON から送られてくるでしょう。</p></div><div class=paragraph><p>これを解決する方法はいくつかあります。 一番の正攻法は <span class=filename>/etc/mail/relay-domains</span> リレードメインファイルにあなたの ISP のアドレスを書くことです。 これをするのに簡単な方法は次のとおりです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;your.isp.example.com&#34; &gt; /etc/mail/relay-domains</span></code></pre></div></div><div class=paragraph><p>このファイルを作成または編集したら、 sendmail を再起動してください。 もしあなたがサーバ管理者でメールをローカルに送りたくないか、 ポイントを使用して他のマシン (や、さらに他の ISP) の クライアントまたはシステムへ送りたい時は、とても効果があります。 さらに、あなたが一つあるいは二つだけのメールアカウントを 設定している場合でもこれは非常に有用です。 追加すべきアドレスがたくさんある場合には、 単にこのファイルをあなたの好きなテキストエディタで開いて、 そして一行に一つずつドメインを追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>your.isp.example.com
other.isp.example.net
users-isp.example.org
www.example.org</pre></div></div><div class=paragraph><p>これで、リストに掲載されているすべてのホスト (ユーザがあなたのシステムにアカウントを持っていると規定する) からあなたのシステムを通るすべてのメールは送信に成功するでしょう。 これはあなたのシステムから SPAM を送ることを認めることなく、 リモートであなたのシステムからメールを送ることをユーザに 認めるためのとてもよい方法です。</p></div></div></div><div class=sect2><h3 id=mail-advanced>19.6. 先進的なトピックス<a class=anchor href=#mail-advanced></a></h3><div class=paragraph><p>これからのセクションでは、 メールの設定やドメイン全体のためのメールの設定といったさらに突込んだ話題について触れます。</p></div><div class=sect3><h4 id=mail-config>19.6.1. 基本事項<a class=anchor href=#mail-config></a></h4><div class=paragraph><p>あなたのマシンに FreeBSD を普通にインストールして、 <span class=filename>/etc/resolv.conf</span> ファイルを設定するか、 またはネームサーバを走らせれば、 他のホストへ電子メールを送ることができるようになります。 あなたのホスト宛のメールをあなた自身の FreeBSD ホスト上の MTA (たとえば sendmail) に配送するようにしたい場合には、次の二つの方法があります。</p></div><div class=ulist><ul><li><p>自身でネームサーバーを実行し、 自分のドメインを持つ。例えば <code>FreeBSD.org</code>。</p></li><li><p>あなたのホストへ直接メールが配送されるようにする。 これはメールがあなたのマシンの現在の DNS 名に直接配送されるようにすることにより実現できます。 たとえば <code>example.FreeBSD.org</code>。</p></li></ul></div><div class=paragraph><p>上のどちらを選ぶ場合でも、自分のホストに直接メールが配送されるようにするには恒久的で 静的 な IP アドレス (ほとんどの PPP ダイアルアップ設定で用いられる動的なアドレスではなく) を持っていなければなりません。 もしファイアウォールの中にいるならば、 SMTP トラフィックが通過してくれないといけません。 もし自分のホストでメールを直接受け取りたいならば、 次の二つのうちのどちらかができていることを確認してください。</p></div><div class=ulist><ul><li><p>自分のドメインでの (一番値の小さい) MX レコードが自分のホストの IP アドレスを差していることを確認する。</p></li><li><p>自分のドメインの中に自分のホスト用の MX エントリがないことを確認する。</p></li></ul></div><div class=paragraph><p>上のどちらかが設定されていれば、 自分のホストでメールを受け取ることができるでしょう。</p></div><div class=paragraph><p>次のコマンドを実行してみてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hostname</span>
example.FreeBSD.org
<span class=c># host example.FreeBSD.org</span>
example.FreeBSD.org has address 204.216.27.XX</code></pre></div></div><div class=paragraph><p>もしあなたのマシンが上記のメッセージだけを出力したならば、 <a href=mailto:yourlogin@example.FreeBSD.org>yourlogin@example.FreeBSD.org</a> へのメールは問題なく配送されるでしょう (sendmail が <code>example.FreeBSD.org</code> 上で正しく動作していると仮定します)。</p></div><div class=paragraph><p>上記のメッセージの代わりに、</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># host example.FreeBSD.org</span>
example.FreeBSD.org has address 204.216.27.XX
example.FreeBSD.org mail is handled <span class=o>(</span><span class=nv>pri</span><span class=o>=</span>10<span class=o>)</span> by hub.FreeBSD.org</code></pre></div></div><div class=paragraph><p>というメッセージが出力された場合は、 あなたのホスト (<code>example.FreeBSD.org</code>) に宛てたメールは全て直接配送されずに <code>hub</code> 上の同じユーザー名に配送されます。</p></div><div class=paragraph><p>上の情報は DNS サーバーが扱います。 メールルーティング情報をもつ DNS レコードは、 <em>M</em>ail e<em>X</em>change エントリーです。 MX エントリが存在しない場合には、IP アドレスにしたがって、 直接宛先ホストに配送されます。</p></div><div class=paragraph><p><code>freefall.FreeBSD.org</code> の現時点での MX エントリは、次のようになっています。</p></div><div class="literalblock programlisting"><div class=content><pre>freefall		MX	30	mail.crl.net
freefall		MX	40	agora.rdrop.com
freefall		MX	10	freefall.FreeBSD.org
freefall		MX	20	who.cdrom.com</pre></div></div><div class=paragraph><p><code>freefall</code> は多くの MX エントリを持っています。 一番 MX の値の小さいホストが利用可能な場合は直接メールを受け取ります。 もしなにかの理由でアクセスができない時には、 他のホスト (ときどき "バックアップ MX" と呼ばれます) が一時的にメールを受け取ります。そして、 より値の小さいホストが利用可能になったときにメールを渡し、 最終的に一番値の小さいホストに渡ります。</p></div><div class=paragraph><p>使い勝手をよくするためには、代替の MX サイトは、それぞれ 別の経路でインターネットへ接続しているとよいでしょう。 インターネットプロバイダまたは他の関連サイトが、このサービスを 提供することができます。</p></div></div><div class=sect3><h4 id=mail-domain>19.6.2. あなたのドメインに対するメール設定<a class=anchor href=#mail-domain></a></h4><div class=paragraph><p>"メールホスト" (メールサーバーとしても知られています) をセットアップするためには、 いろいろなワークステーションに宛てた全てのメールを受ける必要があります。 基本的には、あなたのドメイン内 (この場合だと <code>*.FreeBSD.org</code>) のすべてのホスト名宛てのすべてのメールを "受け取って"、 そのメールをあなたのメールサーバーに配送し、 ユーザーがマスタメールサーバ上でメールをチェックできるようにします。</p></div><div class=paragraph><p>話を簡単にするために、あるユーザーのアカウントはどのマシンでも同じ<em>ユーザー名</em>にすべきです。 そのためには <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> を使ってください。</p></div><div class=paragraph><p>使用する予定のメールホストは、 各ワークステーションごとにメール交換が できるように設定されていなければなりません。 これは DNS の設定で次のように行なうことができます。</p></div><div class="literalblock programlisting"><div class=content><pre>example.FreeBSD.org	A	204.216.27.XX		; ワークステーション
MX	10 hub.FreeBSD.org	; メールホスト</pre></div></div><div class=paragraph><p>これは、ワークステーションの A レコードがどこを指していようとも そのワークステーション宛てのメールをメールホストに転送する、というものです。</p></div><div class=paragraph><p>自前で DNS サーバを運用しているのでなければ、 この作業は自分では行えません。自分で DNS サーバを運用しないとかできないという場合は、 あなたの DNS を提供しているインターネットプロバイダなどに依頼して 作業を行ってもらってください。</p></div><div class=paragraph><p>もしバーチャル電子メールホストを運用するなら次の情報が役に立つでしょう。 例として、あなたには自分のドメイン、ここでは <code>customer1.org</code>、 を持っている顧客がいるとしましょう。 あなたは <code>customer1.org</code> 宛ての全てのメールを <code>mail.myhost.com</code> というメールホストに集めたいとします。 DNS エントリーは次のようになるでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>customer1.org		MX	10 mail.myhost.com</pre></div></div><div class=paragraph><p><code>customer1.org</code> に対して電子メールを送りたいだけなら、 A レコードは必要<em>ありません</em>。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>customer1.org</code> に対して ping を実行しても、 A レコードが存在しない限りうまくいかないことに留意しておいてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>やらなければいけない最後のことは、 メールホスト上の sendmail に対してどんなドメインやホスト宛のメールを受け取るのか、 を教えることです。いくつかの方法がありますが次のどちらかでいいでしょう。</p></div><div class=ulist><ul><li><p><code>FEATURE(use_cw_file)</code> を使っているなら、 <span class=filename>/etc/mail/local-host-names</span> ファイルにホストを加えます。 もし sendmail のバージョンが 8.10 より前であれば該当ファイルは <span class=filename>/etc/sendmail.cw</span> です。</p></li><li><p><span class=filename>/etc/sendmail.cf</span> もしくは sendmail 8.10 以降なら <span class=filename>/etc/mail/sendmail.cf</span> といったファイルに <code>Cwyour.host.com</code> という行を加えます。</p></li></ul></div></div></div><div class=sect2><h3 id=SMTP-UUCP>19.7. UUCP とともに SMTP を使う<a class=anchor href=#SMTP-UUCP></a></h3><div class=paragraph><p>FreeBSD とともに出荷されている sendmail の設定は、 サイトがインターネットに直接接続しているものとして設計されています。 UUCP 経由でメールを交換したいサイトは、 他の sendmail 設定ファイルをインストールしなければいけません。</p></div><div class=paragraph><p><span class=filename>/etc/mail/sendmail.cf</span> を手動で調整することは先進的なトピックです。 sendmail のバージョン 8 は設定ファイルを <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> プリプロセッサから生成します。 これにより、高度に抽象化された設定を行うことができます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> による設定ファイルは <span class=filename>/usr/src/usr.sbin/sendmail/cf</span> 以下にあります。</p></div><div class=paragraph><p>もしシステムをすべてのソースとともにインストールしていなければ、 sendmail の設定材料は分割された個別のソース tarball を取得してください。 FreeBSD のソースコードが入った CDROM をマウントしているのなら、</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /cdrom/src</span>
<span class=c># cat scontrib.?? | tar xzf - -C /usr/src/contrib/sendmail</span></code></pre></div></div><div class=paragraph><p>と展開してください (展開してもたった数百 KB 程度です)。 <span class=filename>cf</span> ディレクトリの <span class=filename>README</span> ファイルは <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> による設定の基本的な手引として役に立つでしょう。</p></div><div class=paragraph><p>UUCP 配送に対応するための一番よい方法は <code>mailertable</code> 機能を使用することです。 これは経路を決定するために sendmail が使用できるデータベースを作成します。</p></div><div class=paragraph><p>まずはじめに <span class=filename>.mc</span> ファイルを作成しなければいけません。 <span class=filename>/usr/src/usr.sbin/sendmail/cf/cf</span> にいくつか例があります。<span class=filename>foo.mc</span> という名前のファイルをあなたが作成したとすると、 有効な <span class=filename>sendmail.cf</span> ファイルへ変換するには次のようにするだけです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.sbin/sendmail/cf/cf</span>
<span class=c># make foo.cf</span>
<span class=c># cp foo.cf /etc/mail/sendmail.cf</span></code></pre></div></div><div class=paragraph><p>典型的な <span class=filename>.mc</span> ファイルは次のようになるでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`Your version number&#39;) OSTYPE(bsd4.4)

FEATURE(accept_unresolvable_domains)
FEATURE(nocanonify)
FEATURE(mailertable, `hash -o /etc/mail/mailertable&#39;)

define(`UUCP_RELAY&#39;, your.uucp.relay)
define(`UUCP_MAX_SIZE&#39;, 200000)
define(`confDONT_PROBE_INTERFACES&#39;)

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    your.alias.host.name
Cw    youruucpnodename.UUCP</pre></div></div><div class=paragraph><p><code>accept_unresolvable_domains</code>, <code>nocanonify</code> および <code>confDONT_PROBE_INTERFACES</code> 機能を含んでいる行は、 メール配送時にまったく DNS を使用しません。 <code>UUCP_RELAY</code> の記述は UUCP 配送に対応するのに必要です。 そこにインターネットホスト名を単に書くだけで .UUCP pseudo ドメインアドレスを扱うことができるようになります。 大抵の場合、あなたの ISP のメールリレーをそこに入力するでしょう。</p></div><div class=paragraph><p>次に、 <span class=filename>/etc/mail/mailertable</span> が必要になります。 メールを配送するリンクが外界との間に一つだけの場合は、 次のようにファイルを記述するだけで十分でしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
.                             uucp-dom:your.uucp.relay</pre></div></div><div class=paragraph><p>次はさらに複雑な例です。</p></div><div class="literalblock programlisting"><div class=content><pre>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</pre></div></div><div class=paragraph><p>はじめの三行はドメインで宛先を指定されたメールが、 配送路を "近道" するために、 デフォルトルートではなく代わりにいくつかの UUCP 隣接ホストへ送られる特別な場合を扱います。 次の行はメールを SMTP で配送可能なローカルイーサネットドメインへ送ります。 最後に <code>uucp-neighbor !recipient</code> がデフォルトルートを上書きすることを許可するための UUCP 隣接ホストは .UUCP 仮想ドメイン記法で言及されます。 最後の行は常に他のすべてが当てはまるシングルドットです。 これは UUCP 隣接ホストへの UUCP 配送をすることで、 世界に向けたあなたの普遍的メールゲートウェイとして役に立ちます。 <code>uucp-dom:</code> キーワードの後ろにあるノード名はすべて、 <code>uuname</code> コマンドを使用することで確かめられる正しい UUCP 隣接ホストである必要があります。</p></div><div class=paragraph><p>このファイルは、実際に使用する前に DBM データベース形式に変換する必要があることに注意してください。 これを実行するコマンドラインは <span class=filename>mailertable</span> ファイルの先頭にコメントとして書かれています。 <span class=filename>mailertable</span> を変更するたびにいつもこのコマンドを実行する必要があります。</p></div><div class=paragraph><p>最後のアドバイス: もし、 いくつかのメールルーティングがうまく動いているかどうか分からないときは sendmail に <code>-bt</code> オプションをつけることを覚えておいてください。 これは sendmail を <em>アドレステストモード</em> で起動します。 あなたがテストしたいメールルーティングのアドレスを後につけて、 単純に <code>3,0</code> と入力してください。 最後の行は、内部で使われたメールエージェント、 このエージェントが呼び出された目的地ホスト、および (もしかしたら変換された) アドレスを表示します。 このモードを終了するには <span class=keyseq><kbd>Ctrl</kbd>+<kbd>D</kbd></span> を入力します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sendmail <span class=nt>-bt</span>
ADDRESS TEST MODE <span class=o>(</span>ruleset 3 NOT automatically invoked<span class=o>)</span>
Enter &lt;ruleset&gt; &lt;address&gt;
<span class=o>&gt;</span> 3,0 foo@example.com
canonify           input: foo @ example <span class=nb>.</span> com
...
parse            returns: <span class=nv>$# </span>uucp-dom <span class=nv>$@</span> your.uucp.relay <span class=nv>$:</span> foo &lt; @ example <span class=nb>.</span> com <span class=nb>.</span> <span class=o>&gt;</span>
<span class=o>&gt;</span> ^D</code></pre></div></div></div><div class=sect2><h3 id=SMTP-dialup>19.8. ダイアルアップ接続でメールを使う<a class=anchor href=#SMTP-dialup></a></h3><div class=paragraph><p>あなたが固定 IP アドレスを持っているのなら、 デフォルトから何も変更する必要はありません。 割りあてられたインターネット名をホスト名に設定すれば、 sendmail が残りをやってくれます。</p></div><div class=paragraph><p>あなたが動的に割り当てられた IP アドレスを持っていて、 インターネットに接続するのにダイアルアップ PPP を使用しているのなら、 おそらく ISP のメールサーバにメールボックスがあるでしょう。 ここでは、あなたの ISP のドメインが <code>example.net</code>, あなたのユーザ名が <code>user</code>, あなたのマシンは <code>bsd.home</code> と呼ばれているものとします。 また、ISP から、メールリレーとして <code>relay.example.net</code> を使用してよいと通知されているとします。</p></div><div class=paragraph><p>(訳注: ISP 上の) メールボックスからメールを取得するためには、 取得アプリケーションをインストールしないといけません。 fetchmail ユーティリティは、 さまざまなプロトコルの多くに対応しているのでよい選択肢です。 通常、あなたの ISP は POP3 を提供しています。 このプログラムは、<a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a> package または Ports Collection からインストールできます。 あなたが ユーザ PPP を使用しているなら、次のエントリを <span class=filename>/etc/ppp/ppp.linkup</span> に追加することで、 インターネット接続が確立したときに自動的にメールを取得することができます。</p></div><div class="literalblock programlisting"><div class=content><pre>MYADDR:
 !bg su user -c fetchmail</pre></div></div><div class=paragraph><p>あなたがローカルではないアカウントへのメールを配送するために (下記のような) sendmail を使用しているなら、 インターネット接続が確立するとすぐに、 sendmail があなたのメールキューを処理して欲しいとおそらく考えるでしょう。 これを行うには、<span class=filename>/etc/ppp/ppp.linkup</span> ファイルの <code>fetchmail</code> コマンドの後に次のコマンドを追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre> !bg su user -c &#34;sendmail -q&#34;</pre></div></div><div class=paragraph><p><code>bsd.home</code> 上に <code>user</code> というアカウントを所有しているとします。 <code>bsd.home</code> 上の <code>user</code> のホームディレクトリに <span class=filename>.fetchmailrc</span> ファイルを作成します。</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.net protocol pop3 fetchall pass MySecret</pre></div></div><div class=paragraph><p>このファイルはパスワード <code>MySecret</code> を含んでいるので、<code>user</code> を除く他の誰にも読めるようになっていてはいけません。</p></div><div class=paragraph><p>正しい <code>from:</code> ヘッダでメールを送るためには、 sendmail が <code>user@bsd.home</code> ではなく <code>user@example.net</code> を使用するようにしなくてはいけません。 また、素早くメール送信をするために sendmail にすべてのメールを <code>relay.example.net</code> 経由で送るようにもしたいかもしれません。</p></div><div class=paragraph><p>次の <span class=filename>.mc</span> ファイルで十分でしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`bsd.home.mc version 1.0&#39;)
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net&#39;)dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST&#39;, `relay.example.net&#39;)
Dmbsd.home
define(`confDOMAIN_NAME&#39;,`bsd.home&#39;)dnl
define(`confDELIVERY_MODE&#39;,`deferred&#39;)dnl</pre></div></div><div class=paragraph><p><span class=filename>.mc</span> ファイルを <span class=filename>sendmail.cf</span> ファイルに変換する方法の詳細については前の節を参照してください。 また、<span class=filename>sendmail.cf</span> ファイルを変更した後は、 sendmail を再起動し忘れないでください。</p></div></div><div class=sect2><h3 id=SMTP-Auth>19.9. SMTP 認証<a class=anchor href=#SMTP-Auth></a></h3><div class=paragraph><p>メールサーバ上で SMTP 認証を行うと、 多くの利益があります。 SMTP 認証は sendmail にもう一つのセキュリティ層を追加することができます。 さらに、ホストを切りかえるモバイルユーザにとっては、 その都度メールクライアントの設定を変更せずとも 同じメールサーバを利用できるようになります。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>ports から <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a> をインストールします。 この port は <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a> にあります。 <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a> にはここで使用する方法に対する多くのコンパイルオプションがあり、 確実に <code>pwcheck</code> オプションを選択してください。</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a> をインストールした後に <span class=filename>/usr/local/lib/sasl/Sendmail.conf</span> を編集して (もし無ければ作成して) 次の行を追加してください。</p><div class="literalblock programlisting"><div class=content><pre>pwcheck_method: passwd</pre></div></div><div class=paragraph><p>この方法は sendmail があなたの FreeBSD の <span class=filename>passwd</span> データベースに対して認証することを可能にします。 この方法は SMTP 認証に必要となる、 それぞれのユーザに対する一組の新しいユーザ名とパスワードを 作成する際のトラブルを減らし、 ログインパスワードとメールパスワードを同じままにします。</p></div></li><li><p>ここで <span class=filename>/etc/make.conf</span> 編集し、 次の行を加えます。</p><div class="literalblock programlisting"><div class=content><pre>SENDMAIL_CFLAGS=-I/usr/local/include/sasl1 -DSASL
SENDMAIL_LDFLAGS=-L/usr/local/lib
SENDMAIL_LDADD=-lsasl</pre></div></div><div class=paragraph><p>これらの行は sendmail に対して、 コンパイルするときに <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl/>cyrus-sasl</a> とリンクするための適切な設定オプションを与えるものです。 sendmail を再コンパイルする前に <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl/>cyrus-sasl</a> がインストールされていることを確かめてください。</p></div></li><li><p>次のコマンドを入力して sendmail を再コンパイルしてください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.sbin/sendmail</span>
<span class=c># make cleandir</span>
<span class=c># make obj</span>
<span class=c># make</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>sendmail のコンパイルは <span class=filename>/usr/src</span> が大幅に変更されていなくて、 必要な共有ライブラリが利用可能であれば何の問題も起こらないでしょう。</p></div></li><li><p>sendmail をコンパイルして再インストールした後は、 <span class=filename>/etc/mail/freebsd.mc</span> ファイル (またはあなたが <span class=filename>.mc</span> ファイルとして使用しているファイル。 多くの管理者は唯一の名前を用いるために <a href="https://man.freebsd.org/cgi/man.cgi?query=hostname&amp;sektion=1&amp;format=html">hostname(1)</a> の出力を <span class=filename>.mc</span> として使用することを選んでいます) を編集してください。 次の行を加えてください。</p><div class="literalblock programlisting"><div class=content><pre>dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confAUTH_MECHANISMS&#39;, `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confDEF_AUTH_INFO&#39;, `/etc/mail/auth-info&#39;)dnl</pre></div></div><div class=paragraph><p>これらのオプションは、ユーザを認証するために sendmail が利用可能な異なる方法を設定します。 もし pwcheck 以外の方法を使用したいのならドキュメントを参照してください。</p></div></li><li><p>最後に <span class=filename>/etc/mail</span> で <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> を実行してください。 これにより、新しい <span class=filename>.mc</span> ファイルから <span class=filename>freebsd.cf</span> という名前 (またはあなたの <span class=filename>.mc</span> に使用している名前) の <span class=filename>.cf</span> ファイルが作成されます。 それから <code>make install restart</code> コマンドを実行してください。 新しい <span class=filename>.cf</span> ファイルが <span class=filename>sendmail.cf</span> にコピーされ、 sendmail が適切に再起動されるでしょう。 この手続きについての詳細は <span class=filename>/etc/mail/Makefile</span>を参照してください。</p></li></ol></div></div></div><div class=paragraph><p>すべてがうまくいけば、ログイン情報をメールクライアントに入力し、 テストメッセージを送ることができるでしょう。 より詳細に調べるには sendmail の <code>LogLevel</code> を 13 に設定し、 すべてのエラーについて <span class=filename>/var/log/maillog</span> を見てください。</p></div><div class=paragraph><p>このサービスがシステムを起動した後にいつでも利用可能となるように、 <span class=filename>/etc/rc.conf</span> に次の行を追加しておくとよいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>sasl_pwcheck_enable=&#34;YES&#34;
sasl_pwcheck_program=&#34;/usr/local/sbin/pwcheck&#34;</pre></div></div><div class=paragraph><p>これにより、システムの起動時に SMTP_AUTH が確実に初期化されるでしょう。</p></div><div class=paragraph><p>詳細については <a href=http://www.sendmail.org/~ca/email/auth.html>SMTP 認証</a> に関する sendmail の文書を参照してください。</p></div></div></div></div><div class=sect1><h2 id=advanced-networking>Chapter 20. 高度なネットワーク<a class=anchor href=#advanced-networking></a></h2><div class=sectionbody><div class=sect2><h3 id=advanced-networking-synopsis>20.1. この章では<a class=anchor href=#advanced-networking-synopsis></a></h3><div class=paragraph><p>この章では UNIX® システム上で良く利用されるネットワークサービスについて説明します。 FreeBSD が利用するすべてのネットワークサービスをどのように定義し、 設定し、テストし、そして保守するのかを扱います。さらに、 本章を通してあなたの役に立つ設定例が載っています。</p></div><div class=paragraph><p>この章を読めば以下のことが分かります。</p></div><div class=ulist><ul><li><p>ゲートウェイと経路の基本</p></li><li><p>FreeBSD をブリッジとして動作させる方法</p></li><li><p>ネットワークファイルシステム (NFS) の設定方法</p></li><li><p>ディスクレスマシンのネットワークブートの設定方法</p></li><li><p>ユーザアカウントを共有するためのネットワークインフォメーションサーバ (NIS) の設定方法</p></li><li><p>DHCP を用いて自動的にネットワーク設定を行う方法</p></li><li><p>ドメインネームサーバ (DNS) の設定方法</p></li><li><p>NTP プロトコルを用いて日時を同期してタイムサーバを設定する方法</p></li><li><p>ネットワークアドレス変換 (NAT) の設定方法</p></li><li><p><code>inetd</code> デーモンの管理方法</p></li><li><p>PLIP 経由で二台のコンピュータを接続する方法</p></li><li><p>FreeBSD で IPv6 を設定する方法</p></li></ul></div><div class=paragraph><p>この章を読む前に、以下のことを行っておくべきです。</p></div><div class=ulist><ul><li><p><span class=filename>/etc/rc</span> スクリプトの基本を理解していること</p></li><li><p>基礎的なネットワーク用語に精通していること</p></li></ul></div></div><div class=sect2><h3 id=network-routing>20.2. ゲートウェイと経路<a class=anchor href=#network-routing></a></h3><div class=paragraph><p>あるマシンがネットワーク上で他のマシンをみつけることができるようにするには、 あるマシンから他のマシンへどのようにたどり着くかを記述する適切な仕組みが必要です。 この仕組みを<em>ルーティング</em>と呼びます。 "経路" (route) は "送信先" (destination) と "ゲートウェイ" の 2 つのアドレスの組で定義します。この組合せは、この <em>送信先</em> へたどり着こうとする場合は、その <em>ゲートウェイ</em> を通じて通信することを示しています。 送信先には個々のホスト、サブネット、"デフォルト" の 3 つの型があります。 "デフォルトルート" は他のどの経路も適用できない場合に使われます。 デフォルトルートについてはのちほどもう少し詳しく述べます。 また、ゲートウェイには、個々のホスト、インタフェース ("リンク" とも呼ばれます)、 イーサネットハードウェアアドレス (MAC アドレス) の 3 つの型があります。</p></div><div class=sect3><h4 id=_例>20.2.1. 例<a class=anchor href=#_例></a></h4><div class=paragraph><p>以下に示す <code>netstat</code> の例を使って、ルーティングのさまざまな状態を説明します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1             UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>最初の 2 行はデフォルトルート (<a href=#network-routing-default>次節</a>で扱います) と、 <code>localhost</code> への経路を示しています。</p></div><div class=paragraph><p><code>localhost</code> に割り当てるインタフェース (<code>Netif</code> 欄) としてこのルーティングテーブルが指定しているのは <span class=filename>lo0</span> で、これはループバックデバイスともいいます。 これは結局のところ出たところに戻るだけなので、 この送信先あてのトラフィックは、LAN に送られずに、すべて内部的に処理されます。</p></div><div class=paragraph><p>次の行では <code>0:e0:</code> から始まるアドレスに注目しましょう。 これはイーサネットハードウェアアドレスで、MAC アドレスともいいます。 FreeBSD はローカルなイーサネット上の任意のホスト (この例では <code>test0</code>) を自動的に認識し、 イーサネットインタフェース <span class=filename>ed0</span> にそのホストへの直接の経路をつけ加えます。 この種の経路には、タイムアウト時間 (<code>Expire</code> 欄) も結びつけられており、 指定された時間内にホストからの応答がないことを判断するのに用いられます。 その場合、そのホストへの経路情報は自動的に削除されます。 これらのホストは RIP (Routing Information Protocol) という、 最短パス判定に基づいてローカルなホストへの経路を決定する仕組みを利用して認識されます。</p></div><div class=paragraph><p>さらに FreeBSD ではローカルサブネットへの経路情報も加えることができます (<code>10.20.30.255</code> は <code>10.20.30</code> というサブネットに対するブロードキャストアドレスで、 <code>example.com</code> はこのサブネットに結びつけられているドメイン名)。 <code>link#1</code> という名称は、 このマシンの一つ目のイーサネットカードのことをさします。 これらについては、 何も追加インタフェースが指定されていないことがわかります。</p></div><div class=paragraph><p>これら 2 つのグループ (ローカルネットワークホストとローカルサブネット) は、両方とも routed というデーモンによって自動的に経路が設定されます。 routed を動かさなければ、静的に定義した (つまり明示的に設定した) 経路のみが存在することになります。</p></div><div class=paragraph><p><code>host1</code> の行は私たちのホストのことで、 イーサネットアドレスで示されています。送信側のホストの場合、 FreeBSDはイーサネットインタフェースへ送るのではなく、 ループバックインタフェース (<span class=filename>lo0</span>) を使います。</p></div><div class=paragraph><p>2 つある <code>host2</code> の行は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> のエイリアスを使ったときにどのようになるかを示す例です (このようなことをする理由については Ethernet の節を参照してください)。 <span class=filename>lo0</span> の後にある <code>⇒</code> は、 インタフェースが (このアドレスがローカルなホストを参照しているので) ループバックを使っているというだけでなく、 エイリアスになっていることも示しています。 このような経路はエイリアスに対応しているホストにのみ現れます。 ローカルネットワーク上の他のすべてのホストでは、 それぞれの経路に対して単に<code>link#1</code> となります。</p></div><div class=paragraph><p>最後の行 (送信先サブネット <code>224</code>) はマルチキャストで扱うものですが、これは他の節で説明します。</p></div><div class=paragraph><p>最後に <code>Flags</code> (フラグ) 欄にそれぞれの経路のさまざまな属性が表示されます。 以下にフラグの一部と、それが何を意味しているかを示します。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Up: この経路はアクティブです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Host: 経路の送信先が単一のホストです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gateway: この送信先へ送られると、 どこへ送ればよいかを明らかにして、 そのリモートシステムへ送られます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Static: この経路はシステムによって自動的に生成されたのではなく、 手動で作成されました。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clone: マシンに接続したときにこの経路に基づく新しい経路が作られます。 この型の経路は通常はローカルネットワークで使われます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>WasCloned: ローカルエリアネットワーク (LAN) の (Clone) 経路に基づいて自動的に生成された経路であることを示します。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Link: イーサネットハードウェアへの参照を含む経路です。</p></td></tr></tbody></table></div><div class=sect3><h4 id=network-routing-default>20.2.2. デフォルトルート<a class=anchor href=#network-routing-default></a></h4><div class=paragraph><p>ローカルシステムからリモートホストにコネクションを張る必要がある場合、 既知の経路が存在するかどうかを確認するためにルーティングテーブルをチェックします。 到達するための経路を知っているサブネットの内部にリモートホストがある場合 (Cloned routes)、 システムはそのインタフェースから接続できるかどうか確認します。</p></div><div class=paragraph><p>知っているパスがすべて駄目だった場合でも、 システムには最後の手段として "デフォルト" ルートがあります。このルートはゲートウェイルート (普通はシステムに 1 つしかありません) の特別なものです。そして、 フラグ欄には必ず <code>c</code> が表示されています。このゲートウェイは、LAN 内のホストにとって、どのマシンでも外部へ (PPP リンク、DSL、ケーブルモデム、T1、 またはその他のネットワークインタフェースのいずれかを経由して) 直接接続するために設定されるものです。</p></div><div class=paragraph><p>外部に対するゲートウェイとして機能するマシンでデフォルトルートを設定する場合、 デフォルトルートはインターネットサービスプロバイダ (ISP) のサイトのゲートウェイマシンになるでしょう。</p></div><div class=paragraph><p>それではデフォルトルートの一例を見てみましょう。 一般的な構成を示します。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/net-routing.png alt="net routing"></div></div><div class=paragraph><p>ホスト <code>Local1</code> とホスト <code>Local2</code> はあなたのサイト内にあります。<code>Local1</code> はダイアルアップ PPP 接続経由で ISP に接続されています。 この PPP サーバコンピュータは、その ISP のインターネットへの接続点に向けた外部インタフェースを備えた他のゲートウェイコンピュータへ LAN を通じて接続しています。</p></div><div class=paragraph><p>あなたのマシンのデフォルトルートはそれぞれ次のようになります。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">ホスト</th><th class="tableblock halign-left valign-top">デフォルトゲートウェイ</th><th class="tableblock halign-left valign-top">インタフェース</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ethernet</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PPP</p></td></tr></tbody></table><div class=paragraph><p>"なぜ (あるいは、どうやって) デフォルトゲートウェイを、<code>Local1</code> が接続されている ISP のサーバではなく、<code>T1-GW</code> に設定するのか" という質問がよくあります。</p></div><div class=paragraph><p>PPP 接続で、あなたのサイト側の PPP インタフェースは、 ISP のローカルネットワーク上のアドレスを用いているため、 ISP のローカルネットワーク上のすべてのマシンへの経路は 自動的に生成されています。 つまりあなたのマシンは、どのようにして <code>T1-GW</code> に到達するかという経路を既に知っていることになりますから、 ISP サーバにトラフィックを送るのに、 中間的な段階を踏む必要はありません。</p></div><div class=paragraph><p>一般的にローカルネットワークでは <code>X.X.X.1</code> というアドレスをゲートウェイアドレスとして使います。ですから (同じ例を用います)、あなたの class-C のアドレス空間が <code>10.20.30</code> で ISP が <code>10.9.9</code> を用いている場合、 デフォルトルートは次のようになります。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">ホスト</th><th class="tableblock halign-left valign-top">デフォルトルート</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local2 (10.20.30.2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Local1 (10.20.30.1, 10.9.9.30)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>T1-GW (10.9.9.1)</p></td></tr></tbody></table><div class=paragraph><p>デフォルトルートは <span class=filename>/etc/rc.conf</span> ファイルで簡単に定義できます。この例では、 <code>Local2</code> マシンで <span class=filename>/etc/rc.conf</span> に次の行を追加しています。</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> コマンドを使ってコマンドラインから直接実行することもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>経路情報を手動で操作する方法について詳しいことは <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> のマニュアルページをご覧ください。</p></div></div><div class=sect3><h4 id=_デュアルホームホスト>20.2.3. デュアルホームホスト<a class=anchor href=#_デュアルホームホスト></a></h4><div class=paragraph><p>ここで扱うべき種類の設定がもう一つあります。 それは 2 つの異なるネットワークにまたがるホストです。 技術的にはゲートウェイとして機能するマシン (上の例では PPP コネクションを用いています) はすべてデュアルホームホストです。 しかし実際にはこの言葉は、2 つの LAN 上のサイトであるマシンを指す言葉としてのみ使われます。</p></div><div class=paragraph><p>2 枚のイーサネットカードを持つマシンが、 別のサブネット上にそれぞれアドレスを持っている場合があります。 あるいは、イーサネットカードが 1 枚しかないマシンで、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> のエイリアスを使っているかもしれません。 物理的に分かれている 2 つのイーサネットのネットワークが使われているならば前者が用いられます。 後者は、物理的には 1 つのネットワークセグメントで、 論理的には 2 つのサブネットに分かれている場合に用いられます。</p></div><div class=paragraph><p>どちらにしても、 このマシンがお互いのサブネットへのゲートウェイ (inbound route) として定義されていることが分かるように、 おのおののサブネットでルーティングテーブルを設定します。このマシンが 2 つのサブネットの間のルータとして動作するという構成は、 パケットのフィルタリングを実装する必要がある場合や、 一方向または双方向のファイアウォールを利用したセキュリティを構築する場合によく用いられます。</p></div><div class=paragraph><p>このマシンが二つのインタフェース間で実際にパケットを受け渡すようにしたい場合は、 FreeBSD でこの機能を有効にしないといけません。 くわしい手順については次の節をご覧ください。</p></div></div><div class=sect3><h4 id=network-dedicated-router>20.2.4. ルータの構築<a class=anchor href=#network-dedicated-router></a></h4><div class=paragraph><p>ネットワークルータは単にあるインタフェースから別のインタフェースへパケットを転送するシステムです。 インターネット標準およびすぐれた技術的な慣習から、 FreeBSD プロジェクトは FreeBSD においてこの機能をデフォルトでは有効にしていません。 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 内で次の変数を <code>YES</code> に変更することでこの機能を有効にできます。</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=YES          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>このオプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 変数の <code>net.inet.ip.forwarding</code> を <code>1</code> に設定します。 一時的にルーティングを停止する必要があるときには、 この変数を一時的に <code>0</code> に設定しなおせます。</p></div><div class=paragraph><p>次に、トラフィックの宛先を決めるために、 そのルータには経路情報が必要になります。 ネットワークが十分簡素なら、静的経路が利用できます。 また、FreeBSD は BSD の標準ルーティングデーモンである <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a> を備えています。これは RIP (バージョン 1 および 2) および IRDP を扱えます。 BGP バージョン 4、OSPF バージョン2、 その他洗練されたルーティングプロトコルは <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a> package を用いれば対応できます。 また、より複雑なネットワークルーティングソリューションには、 GateD® のような商用製品も利用可能です。</p></div><div class=paragraph><p>このように FreeBSD を設定したとしても、 ルータに対するインターネット標準要求を完全に満たすわけではありません。 しかし、通常利用に関しては十分といえます。</p></div></div><div class=sect3><h4 id=_静的な経路の設定>20.2.5. 静的な経路の設定<a class=anchor href=#_静的な経路の設定></a></h4><div class=sect4><h5 id=_手動による経路の設定>20.2.5.1. 手動による経路の設定<a class=anchor href=#_手動による経路の設定></a></h5><div class=paragraph><p>以下のようなネットワークが存在すると仮定します。</p></div><div class=literalblock><div class=content><pre>   INTERNET
      | (10.0.0.1/24) Default Router to Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (FreeBSD gateway)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Internal Net 1      | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Internal Net 2</pre></div></div><div class=paragraph><p>このシナリオでは、FreeBSD マシンの <code>RouterA</code> がインターネットに向けられたルータとして動作します。 ルータは外側のネットワークへ接続できるように <code>10.0.0.1</code> へ向けたデフォルトルートを保持しています。 <code>RouterB</code> はすでに適切に設定されており、 どこへ向かう必要があるか、 行き着く方法を知っていると仮定します (この例では、図のように簡単です。 <code>192.168.1.1</code> をゲートウェイとして <code>RouterB</code> にデフォルトルートを追加するだけです)。</p></div><div class=paragraph><p><code>RouterA</code> のルーティングテーブルを確認すると、 以下のような出力を得ます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1/24       <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>現在のルーティングテーブルでは、<code>RouterA</code> はまだ Internal Net 2 には到達できないでしょう。 <code>192.168.2.0/24</code> の経路を保持していないからです。 解決するための一つの方法は、経路を手動で追加することです。 以下のコマンドで <code>RouterA</code> のルーティングテーブルに <code>192.168.1.2</code> を送り先として、Internal Net 2 ネットワークを追加します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>これにより、<code>RouterA</code> は、 <code>192.168.2.0/24</code> ネットワーク上のホストに到達出来ます。</p></div></div><div class=sect4><h5 id=_永続的な設定>20.2.5.2. 永続的な設定<a class=anchor href=#_永続的な設定></a></h5><div class=paragraph><p>上記の例は、 起動しているシステム上に静的な経路を設定する方法としては完全です。 しかしながら、FreeBSD マシンを再起動した際にルーティング情報が残らないという問題が一つあります。 静的な経路を追加するには、<span class=filename>/etc/rc.conf</span> ファイルにルートを追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p><code>static_routes</code> の設定変数は、 スペースによって分離される文字列のリストです。 それぞれの文字列は経路名として参照されます。 上記の例では <code>static_routes</code> は一つの文字列のみを持ちます。 その文字列は <em>internalnet2</em> です。その後、 <code>route_internalnet2</code> という設定変数を追加し、 <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> コマンドに与えるすべての設定パラメータを指定しています。 前節の例では、以下のコマンド</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>を用いたので、 <code>"-net 192.168.2.0/24 192.168.1.2"</code> が必要になります。</p></div><div class=paragraph><p>上記のように <code>static_routes</code> は一つ以上の文字列を持つことが出来るので、 多数の静的な経路を作ることができます。 以下の行は <code>192.168.0.0/24</code> および <code>192.168.1.0/24</code> ネットワークを、 仮想ルータ上に静的な経路として追加する例です。</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div></div><div class=sect3><h4 id=_ルーティングの伝搬>20.2.6. ルーティングの伝搬<a class=anchor href=#_ルーティングの伝搬></a></h4><div class=paragraph><p>外部との経路をどのように定義したらよいかはすでに説明しました。 しかし外部から私たちのマシンをどのようにして見つけるのかについては説明していません。</p></div><div class=paragraph><p>ある特定のアドレス空間 (この例では class-C のサブネット) におけるすべてのトラフィックが、 到着したパケットを内部で転送するネットワーク上の特定のホストに送られるようにルーティングテーブルを設定することができるのは分かっています。</p></div><div class=paragraph><p>あなたのサイトにアドレス空間を割り当てる場合、 あなたのサブネットへのすべてのトラフィックがすべて PPP リンクを通じてサイトに送ってくるようにサービスプロバイダはルーティングテーブルを設定します。 しかし、国境の向こう側のサイトはどのようにしてあなたの ISP へ送ることを知るのでしょうか?</p></div><div class=paragraph><p>割り当てられているすべてのアドレス空間の経路を維持する (分散している DNS 情報とよく似た) システムがあり、 そのインターネットバックボーンへの接続点を定義しています。 "バックボーン" とは国を越え、 世界中のインターネットのトラフィックを運ぶ主要な信用できる幹線のことです。 どのバックボーンマシンも、 あるネットワークから特定のバックボーンのマシンへ向かうトラフィックと、 そのバックボーンのマシンからあなたのネットワークに届くサービスプロバイダまでのチェーンのマスタテーブルのコピーを持っています。</p></div><div class=paragraph><p>あなたのサイトが接続 (プロバイダからみて内側にあることになります) したということを、 プロバイダからバックボーンサイトへ通知することはプロバイダの仕事です。 これが経路の伝搬です。</p></div></div><div class=sect3><h4 id=_トラブルシューティング_4>20.2.7. トラブルシューティング<a class=anchor href=#_トラブルシューティング_4></a></h4><div class=paragraph><p>経路の伝搬に問題が生じて、 いくつかのサイトが接続をおこなうことができなくなることがあります。 ルーティングがどこでおかしくなっているかを明らかにするのに最も有効なコマンドはおそらく <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> コマンドでしょう。 このコマンドは、あなたがリモートマシンに対して接続をおこなうことができない (たとえば <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> に失敗するような) 場合も、同じように有効です。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> コマンドは、 接続を試みているリモートホストを引数にして実行します。 試みている経路が経由するゲートウェイホストを表示し、 最終的には目的のホストにたどり着くか、 コネクションの欠如によって終ってしまうかのどちらかになります。</p></div><div class=paragraph><p>より詳しい情報は、<a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> のマニュアルページをみてください。</p></div></div><div class=sect3><h4 id=_マルチキャストルーティング>20.2.8. マルチキャストルーティング<a class=anchor href=#_マルチキャストルーティング></a></h4><div class=paragraph><p>FreeBSD はマルチキャストアプリケーションとマルチキャストルーティングの両方にネイティブ対応しています。 マルチキャストアプリケーションを動かすのに FreeBSD で特別な設定をする必要は一切ありません。 アプリケーションは普通はそのままで動くでしょう。 マルチキャストルーティングに対応するには、 下のオプションを追加してカーネルをコンパイルする必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>さらに、<span class=filename>/etc/mrouted.conf</span> を編集してルーティングデーモン <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a> を設定し、トンネルと DVMRP を設置する必要があります。 マルチキャスト設定についての詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a> のマニュアルページを参照してください。</p></div></div></div><div class=sect2><h3 id=network-wireless>20.3. 無線ネットワーク<a class=anchor href=#network-wireless></a></h3><div class=sect3><h4 id=_はじめに_2>20.3.1. はじめに<a class=anchor href=#_はじめに_2></a></h4><div class=paragraph><p>常にネットワークケーブルをつないでいるという面倒なことをせずに、 コンピュータを使用できることは、とても有用でしょう。 FreeBSD は無線のクライアントとして、 さらに "アクセスポイント" としても使えます。</p></div></div><div class=sect3><h4 id=_無線の動作モード>20.3.2. 無線の動作モード<a class=anchor href=#_無線の動作モード></a></h4><div class=paragraph><p>802.11 無線デバイスの設定には、BSS と IBSS の二つの方法があります。</p></div><div class=sect4><h5 id=_bss_モード>20.3.2.1. BSS モード<a class=anchor href=#_bss_モード></a></h5><div class=paragraph><p>BSS モードは一般的に使われているモードです。 BSS モードはインフラストラクチャモードとも呼ばれています。 このモードでは、 多くの無線アクセスポイントが 1 つの有線ネットワークに接続されます。 それぞれのワイヤレスネットワークは固有の名称を持っています。 その名称はネットワークの SSID と呼ばれます。</p></div><div class=paragraph><p>無線クライアントはこれらの無線アクセスポイントに接続します。 IEEE 802.11 標準は無線ネットワークが接続するのに使用するプロトコルを規定しています。 SSID が設定されているときは、 無線クライアントを特定のネットワークに結びつけることができます。 SSID を明示的に指定しないことにより、 無線クライアントを任意のネットワークに接続することもできます。</p></div></div><div class=sect4><h5 id=_ibss_モード>20.3.2.2. IBSS モード<a class=anchor href=#_ibss_モード></a></h5><div class=paragraph><p>アドホックモードとも呼ばれる IBSS モードは、 一対一通信のために設計された通信方式です。 実際には二種類のアドホックモードがあります。 一つは IBSS モードで、アドホックモード、または IEEE アドホックモードとも呼ばれます。 このモードは IEEE 802.11 標準に規定されています。 もう一つはデモアドホックモードもしくは Lucent アドホックモード (そして時々、紛らわしいことに、アドホックモード) と呼ばれるモードです。 このモードは古く、802.11 が標準化する以前のアドホックモードで、 これは古い設備でのみ使用されるべきでしょう。 ここでは、どちらのアドホックモードについてもこれ以上言及しません。</p></div></div></div><div class=sect3><h4 id=_インフラストラクチャーモード>20.3.3. インフラストラクチャーモード<a class=anchor href=#_インフラストラクチャーモード></a></h4><div class=sect4><h5 id=_アクセスポイント>20.3.3.1. アクセスポイント<a class=anchor href=#_アクセスポイント></a></h5><div class=paragraph><p>アクセスポイントは一つ以上の無線クライアントが、 そのデバイスをセントラルハブとして利用できるようにする無線ネットワークデバイスです。 アクセスポイントを使用している間、 すべてのクライアントはアクセスポイントを介して通信します。 家屋や職場、または公園などの空間を無線ネットワークで完全にカバーするために、 複数のアクセスポイントがよく使われます。</p></div><div class=paragraph><p>アクセスポイントは一般的に複数のネットワーク接続 (無線カードと、 その他のネットワークに接続するための一つ以上の有線イーサネットアダプタ) を持っています。</p></div><div class=paragraph><p>アクセスポイントは、出来合いのものを購入することもできますし、 FreeBSD と対応している無線カードを組み合わせて、 自分で構築することもできます。 いくつものメーカが、 さまざまな機能をもった無線アクセスポイントおよび無線カードを製造しています。</p></div></div><div class=sect4><h5 id=_freebsd_のアクセスポイントの構築>20.3.3.2. FreeBSD のアクセスポイントの構築<a class=anchor href=#_freebsd_のアクセスポイントの構築></a></h5><div class=sect5><h6 id=_要件>20.3.3.2.1. 要件<a class=anchor href=#_要件></a></h6><div class=paragraph><p>FreeBSD で無線アクセスポイントを設定するためには、 互換性のある無線カードが必要です。 現状では Prism チップセットのカードのみに対応しています。 また FreeBSD に対応している有線ネットワークカードも必要になるでしょう (これを見つけるのは難しくないでしょう。 FreeBSD は多くの異なるデバイスに対応しているからです) 。 この手引きでは、 無線デバイスと有線ネットワークカードに接続しているネットワーク間のトラフィックを <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> したいと仮定します。</p></div><div class=paragraph><p>FreeBSD がアクセスポイントを実装するのに使用する hostap 機能はファームウェアの特定のバージョンで一番よく性能を発揮します。 Prism 2 カードは、 1.3.4 以降のバージョンのファームウェアで使用すべきです。 Prism 2.5 および Prism 3 カードでは、バージョン 1.4.9 のバージョンのファームウェアで使用すべきです。 それより古いバージョンのファームウェアは、 正常に動くかもしれませんし、動かないかもしれません。 現時点では、カードのファームウェアを更新する唯一の方法は、 カードの製造元から入手できる Windows® 用ファームウェアアップデートユーティリティを使うものです。</p></div></div><div class=sect5><h6 id=_設定_2>20.3.3.2.2. 設定<a class=anchor href=#_設定_2></a></h6><div class=paragraph><p>はじめにシステムが無線カードを認識していることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig -a</span>
wi0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/2Mbps<span class=o>)</span>
        status: no carrier
        ssid <span class=s2>&#34;&#34;</span>
        stationname <span class=s2>&#34;FreeBSD Wireless node&#34;</span>
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</code></pre></div></div><div class=paragraph><p>細かいことは気にせず、 無線カードがインストールされていることを示す何かが表示されていることを確かめてください。 PC カードを使用していて、無線インタフェースを認識できない場合、 詳しい情報を得るために <a href="https://man.freebsd.org/cgi/man.cgi?query=pccardc&amp;sektion=8&amp;format=html">pccardc(8)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=pccardd&amp;sektion=8&amp;format=html">pccardd(8)</a> のマニュアルページを調べてみてください。</p></div><div class=paragraph><p>次に、アクセスポイント用に FreeBSD のブリッジ機能を担う部分を有効にするために、 モジュールを読み込む必要があるでしょう。 <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> モジュールを読み込むには、 次のコマンドをそのまま実行します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload bridge</span></code></pre></div></div><div class=paragraph><p>モジュールを読み込む時には、何もエラーはでないはずです。 もしもエラーがでたら、カーネルに <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> のコードを入れてコンパイルする必要があるかもしれません。 ハンドブックの<a href=#network-bridging>ブリッジ</a>の節が、 この課題を成し遂げる手助けをになるかもしれません。</p></div><div class=paragraph><p>ブリッジ部分が準備できたので、 どのインタフェース間をブリッジするのかを FreeBSD カーネルに指定する必要があります。 これは、<a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> を使って行います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.link.ether.bridge=1</span>
<span class=c># sysctl net.link.ether.bridge_cfg=&#34;wi0,xl0&#34;</span>
<span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>FreeBSD 5.2-RELEASE 以降では、次のように指定しなければなりません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.link.ether.bridge.enable=1</span>
<span class=c># sysctl net.link.ether.bridge.config=&#34;wi0,xl0&#34;</span>
<span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>さて、無線カードを設定するときです。 次のコマンドはカードをアクセスポイントとして設定します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 ssid my_net channel 11 media DS/11Mbps mediaopt hostap up stationname &#34;FreeBSD AP&#34;</span></code></pre></div></div><div class=paragraph><p>この <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> コマンド行は <span class=filename>wi0</span> インタフェースを up 状態にし、SSID を <em>my_net</em> に設定し、 ステーション名を <em>FreeBSD AP</em> に設定します。 <code>media DS/11Mbps</code> オプションはカードを 11Mbps モードに設定し、また <code>mediaopt</code> を実際に有効にするのに必要です。 <code>mediaopt hostap</code> オプションはインタフェースをアクセスポイントモードにします。 <code>channel 11</code> オプションは使用するチャネルを 802.11b に設定します。 各規制地域 (regulatory domain) で有効なチャネル番号は <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a> マニュアルページに載っています。</p></div><div class=paragraph><p>さて、 これで完全に機能するアクセスポイントが立ち上がり、動作しています。 より詳しい情報については、<a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a> のマニュアルを読むとよいでしょう。</p></div><div class=paragraph><p>また、下記の暗号化に関する節を読むこともおすすめします。</p></div></div><div class=sect5><h6 id=_ステータス情報>20.3.3.2.3. ステータス情報<a class=anchor href=#_ステータス情報></a></h6><div class=paragraph><p>一度アクセスポイントが設定されて稼働すると、 管理者はアクセスポイントを利用しているクライアントを見たいと思うでしょう。 いつでも管理者は以下のコマンドを実行できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wicontrol -l</span>
1 station:
00:09:b7:7b:9d:16  <span class=nv>asid</span><span class=o>=</span>04c0, <span class=nv>flags</span><span class=o>=</span>3&lt;ASSOC,AUTH&gt;, <span class=nv>caps</span><span class=o>=</span>1&lt;ESS&gt;, <span class=nv>rates</span><span class=o>=</span>f&lt;1M,2M,5.5M,11M&gt;, <span class=nv>sig</span><span class=o>=</span>38/15</code></pre></div></div><div class=paragraph><p>これは一つの局が、 表示されているパラメータで接続していることを示します。 表示された信号は、 相対的な強さを表示しているだけのものとして扱われるべきです。 dBm やその他の単位への変換結果は、 異なるファームウェアバージョン間で異なります。</p></div></div></div><div class=sect4><h5 id=_クライアント>20.3.3.3. クライアント<a class=anchor href=#_クライアント></a></h5><div class=paragraph><p>無線クライアントはアクセスポイント、 または他のクライアントに直接アクセスするシステムです。</p></div><div class=paragraph><p>典型的には、 無線クライアントが有しているネットワークデバイスは、 無線ネットワークカード 1 枚だけです。</p></div><div class=paragraph><p>無線クライアントを設定するにはいくつか方法があります。 それぞれは異なる無線モードに依存していますが、 一般的には BSS (アクセスポイントを必要とするインフラストラクチャーモード) か、 IBSS (アドホック、またはピアツーピアモード) のどちらかです。 ここでは、アクセスポイントと通信をするのに、 両者のうちで最も広まっている BSS モードを使用します。</p></div><div class=sect5><h6 id=_要件_2>20.3.3.3.1. 要件<a class=anchor href=#_要件_2></a></h6><div class=paragraph><p>FreeBSD を無線クライアントとして設定するのに、 本当に必要なものはたった 1 つだけです。 FreeBSD が対応している無線カードが必要です。</p></div></div><div class=sect5><h6 id=_無線_freebsd_クライアントの設定>20.3.3.3.2. 無線 FreeBSD クライアントの設定<a class=anchor href=#_無線_freebsd_クライアントの設定></a></h6><div class=paragraph><p>設定をはじめる前に、 あなたが接続しようとする無線ネットワークについていくつか知っておかなければなりません。 この例では、<em>my_net</em> という名前で暗号化は無効になっているネットワークに接続しようとしています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この例では暗号化を行っていないのですが、 これは危険な状況です。次の節で、暗号化を有効にする方法と、 なぜそれが重要で、 暗号技術によっては完全にはあなたを保護することができないのはなぜか、 ということを学ぶでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p>カードが FreeBSD に認識されていることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig -a</span>
wi0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect <span class=o>(</span>DS/2Mbps<span class=o>)</span>
        status: no carrier
        ssid <span class=s2>&#34;&#34;</span>
        stationname <span class=s2>&#34;FreeBSD Wireless node&#34;</span>
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</code></pre></div></div><div class=paragraph><p>それでは、このカードをネットワークに合わせて設定しましょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net</span></code></pre></div></div><div class=paragraph><p><code>192.168.0.20</code> と <code>255.255.255.0</code> を有線ネットワークで有効な IP アドレスとネットマスクに置き換えてください。 アクセスポイントは無線ネットワークと有線ネットワークの間でデータをブリッジしているため、 ネットワーク上の他のデバイスには、このデバイスが、他と同様に、 有線ネットワーク上にあるかのように見えることに注意してください。</p></div><div class=paragraph><p>これを終えると、 あなたは標準的な有線接続を使用しているかのように、 有線ネットワーク上のホストに ping を送ることができるでしょう。</p></div><div class=paragraph><p>無線接続に関する問題がある場合は、 アクセスポイントに接続されていることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0</span></code></pre></div></div><div class=paragraph><p>いくらか情報が表示されるはずです。 その中に以下の表示があるはずです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>status: associated</code></pre></div></div><div class=paragraph><p>もし <code>associated</code> と表示されなければ、 アクセスポイントの範囲外かもしれないし、 暗号化が有効になっているかもしれないし、 または設定の問題を抱えているのかもしれません。</p></div></div></div><div class=sect4><h5 id=_暗号化>20.3.3.4. 暗号化<a class=anchor href=#_暗号化></a></h5><div class=paragraph><p>無線ネットワークを暗号化することが重要なのは、 十分保護された領域にネットワークを留める能力がもはやないからです。 無線データはその周辺全体にわたって放送されるので、 それを読みたいと思う人はだれでも読むことができます。 そこで暗号化が役に立ちます。 電波に載せて送られるデータを暗号化することによって、 興味を抱いた者が空中からデータを取得することをずっと難しくします。</p></div><div class=paragraph><p>クライアントとアクセスポイント間のデータを暗号化するもっとも一般的な方法には、 WEP と <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> の二種類があります。</p></div><div class=sect5><h6 id=_wep>20.3.3.4.1. WEP<a class=anchor href=#_wep></a></h6><div class=paragraph><p>WEP は Wired Equivalency Protocol (訳注: 直訳すると、有線等価プロトコル) の略語です。WEP は無線ネットワークを有線ネットワークと同程度に安全で確実なものにしようとする試みです。 残念ながら、これはすでに破られており、 破るのはそれほど苦労しません。 これは、機密データを暗号化するという場合に、 これに頼るものではないということも意味します。</p></div><div class=paragraph><p>なにも無いよりはましなので、 次のコマンドを使って、あなたの新しい FreeBSD アクセスポイント上で WEP を有効にしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet up ssid my_net wepmode on wepkey 0x1234567890 media DS/11Mbps mediaopt hostap</span></code></pre></div></div><div class=paragraph><p>クライアントについては次のコマンドで WEP を有効にできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net wepmode on wepkey 0x1234567890</span></code></pre></div></div><div class=paragraph><p><em>0x1234567890</em> をより特異なキーに変更すべきであることに注意してください。</p></div></div><div class=sect5><h6 id=_ipsec>20.3.3.4.2. IPsec<a class=anchor href=#_ipsec></a></h6><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> はネットワーク上で交わされるデータを暗号化するための、 はるかに頑健で強力なツールです。 これは無線ネットワーク上のデータを暗号化する明らかに好ましい方法です。 ハンドブック内の <a href=./#ipsec>IPsec</a> 節で <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> セキュリティ、 およびその実装方法の詳細を読むことができます。</p></div></div></div><div class=sect4><h5 id=_ツール>20.3.3.5. ツール<a class=anchor href=#_ツール></a></h5><div class=paragraph><p>無線ネットワークをデバッグしたり設定するのに使うツールがわずかばかりあります。 ここでその一部と、それらが何をしているか説明します。</p></div><div class=sect5><h6 id=_bsd_airtools_パッケージ>20.3.3.5.1. bsd-airtools パッケージ<a class=anchor href=#_bsd_airtools_パッケージ></a></h6><div class=paragraph><p>bsd-airtools パッケージは、 WEP キークラッキング、 アクセスポイント検知などの無線通信を監査するツールを含む完備されたツール集です。</p></div><div class=paragraph><p>bsd-airtools ユーティリティは <a class=package href=https://cgit.freebsd.org/ports/tree/net/bsd-airtools/>net/bsd-airtools</a> port からインストールできます。 ports のインストールに関する情報はこのハンドブックの <a href=./#ports>アプリケーションのインストール - packages と ports</a> を参照してください。</p></div><div class=paragraph><p><code>dstumbler</code> プログラムは、 アクセスポイントの発見および S/N 比のグラフ化をできるようにするパッケージツールです。 アクセスポイントを立ち上げて動かすのに苦労しているなら、 <code>dstumbler</code> はうまく行く手助けになるかもしれません。</p></div><div class=paragraph><p>無線ネットワークの安全性をテストするのに、 "dweputils" (<code>dwepcrack</code>, <code>dwepdump</code> および <code>dwepkeygen</code>) を使用することで、 WEP があなたの無線安全性への要求に対する正しい解決策かどうか判断するのを助けられるかもしれません。</p></div></div><div class=sect5><h6 id=_wicontrol_ancontrol_および_raycontrol_ユーティリティ>20.3.3.5.2. <code>wicontrol</code>, <code>ancontrol</code> および <code>raycontrol</code> ユーティリティ<a class=anchor href=#_wicontrol_ancontrol_および_raycontrol_ユーティリティ></a></h6><div class=paragraph><p>これらは、無線ネットワーク上で無線カードがどのように動作するかを制御するツールです。 上記の例では、無線カードが <span class=filename>wi0</span> インタフェースであるので、<a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a> を使用することに決めました。 もし Cisco の無線デバイスを持っている場合は、それは <span class=filename>an0</span> として動作するでしょうから、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ancontrol&amp;sektion=8&amp;format=html">ancontrol(8)</a> を使うことになるでしょう。</p></div></div><div class=sect5><h6 id=_ifconfig_コマンド>20.3.3.5.3. <code>ifconfig</code> コマンド<a class=anchor href=#_ifconfig_コマンド></a></h6><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> は <a href="https://man.freebsd.org/cgi/man.cgi?query=wicontrol&amp;sektion=8&amp;format=html">wicontrol(8)</a> と同じオプションの多くを処理できますが、 いくつかのオプションを欠いています。 コマンドライン引数とオプションについて <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> を参照してください。</p></div></div></div><div class=sect4><h5 id=_対応しているカード>20.3.3.6. 対応しているカード<a class=anchor href=#_対応しているカード></a></h5><div class=sect5><h6 id=_アクセスポイント_2>20.3.3.6.1. アクセスポイント<a class=anchor href=#_アクセスポイント_2></a></h6><div class=paragraph><p>現在のところ (アクセスポイントとして) BSS モードに対応した唯一のカードは Prism 2, 2.5 または 3 チップセットを利用したデバイスです。 <a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a> に完全な一覧があります。</p></div></div><div class=sect5><h6 id=_クライアント_2>20.3.3.6.2. クライアント<a class=anchor href=#_クライアント_2></a></h6><div class=paragraph><p>現在、FreeBSD では、ほとんどすべての 802.11b 無線カードに対応しています。 Prism, Spectrum24, Hermes, Aironet または Raylink のチップセットを利用したほとんどのカードは、 (アドホック、ピアツーピア、そして BSS の) IBSS モードで無線ネットワークカードとして動作するでしょう。</p></div></div></div></div></div><div class=sect2><h3 id=network-bluetooth>20.4. Bluetooth<a class=anchor href=#network-bluetooth></a></h3><div class=sect3><h4 id=_はじめに_3>20.4.1. はじめに<a class=anchor href=#_はじめに_3></a></h4><div class=paragraph><p>Bluetooth は免許のいらない 2.4 GHz の帯域を利用して、 10 m 程度のパーソナルネットワークを作る無線技術です。 ネットワークはたいていの場合、その場その場で、携帯電話や PDA やノートパソコンなどの携帯デバイスから形成されます。 Wi-Fi などの他の有名な無線技術とは違い、 Bluetooth はより高いレベルのサービスを提供します。 たとえば、FTP のようなファイルサーバ、ファイルのプッシュ、 音声伝送、シリアル線のエミュレーションなどのサービスです。</p></div><div class=paragraph><p>FreeBSD 内での Bluetooth スタックは Netgraph フレームワーク (<a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a> 参照) を使って実現されています。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> ドライバは、 多種多様な Bluetooth USB ドングルに対応しています。 Broadcom BCM2033 チップを搭載した Bluetooth デバイスは <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> ドライバによって対応されています。 3Com Bluetooth PC カード 3CRWB60-A は <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a> ドライバによって対応されています。 シリアルおよび UART を搭載した Bluetooth デバイスは <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a> ドライバによって対応されています。 この節では USB Bluetooth ドングルの使用法について説明します。 Bluetooth に対応しているのは FreeBSD 5.0 以降のシステムです。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>5.0, 5.1 Release ではカーネルモジュールは利用可能ですが、 種々のユーティリティとマニュアルは標準でコンパイルされていません。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_デバイスの挿入>20.4.2. デバイスの挿入<a class=anchor href=#_デバイスの挿入></a></h4><div class=paragraph><p>デフォルトでは Bluetooth デバイスドライバはカーネルモジュールとして利用できます。 デバイスを接続する前に、 カーネルにドライバを読み込む必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>Bluetooth デバイスがシステム起動時に存在している場合、 <span class=filename>/boot/loader.conf</span> からモジュールを読み込んでください。</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>USB ドングルを挿してください。コンソールに (または syslog に) 下記のような表示が現れるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class=paragraph><p><span class=filename>/usr/shared/examples/netgraph/bluetooth/rc.bluetooth</span> を <span class=filename>/etc/rc.bluetooth</span> のようなどこか便利な場所にコピーしてください。 このスクリプトは Bluetooth スタックを開始および終了させるのに使われます。 デバイスを抜く前にスタックを終了するのはよい考えですが、 (たいていの場合) しなくても致命的ではありません。 スタックを開始するときに、下記のような出力がされます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></div><div class=sect3><h4 id=_ホストコントローラインタフェース_hci>20.4.3. ホストコントローラインタフェース (HCI)<a class=anchor href=#_ホストコントローラインタフェース_hci></a></h4><div class=paragraph><p>ホストコントローラインタフェース (HCI) は、 ベースバンドコントローラおよびリンクマネージャへのコマンドインタフェースを提供し、 ハードウェアステータスおよびコントロールレジスタへアクセスします。 このインタフェースは Bluetooth ベースバンド機能へアクセスする画一的な方法を提供します。 ホストの HCI 層は Bluetooth ハードウェア上の HCI ファームウェアと、 データとコマンドをやり取りします。 ホストコントローラトランスポート層 (つまり物理的なバス) のドライバは、 両方の HCI 層に相互に情報を交換する能力を与えます。</p></div><div class=paragraph><p>一つの Bluetooth デバイスにつき、<em>hci</em> タイプの Netgraph ノードが一つ作成されます。 HCI ノードは通常 Bluetooth デバイスドライバノード (下流) と L2CAP ノード (上流) に接続されます。 すべての HCI 動作はデバイスドライバノード上ではなく、 HCI ノード上で行われなくてはいけません。 HCI ノードのデフォルト名は "devicehci" です。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a> マニュアルを参照してください。</p></div><div class=paragraph><p>最も一般的なタスクの一つに、無線通信的に近傍にある Bluetooth デバイスの発見があります。 この動作は <em>inquiry (問い合わせ)</em> と呼ばれています。 Inquiry や他の HCI に関連した動作は <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a> ユーティリティによってなされます。 下記の例は、どの Bluetooth デバイスが通信圏内にあるかを知る方法を示しています。 デバイスのリストが表示されるには数秒かかります。 リモートデバイスは <em>discoverable (発見可能な)</em> モードにある場合にのみ inquiry に返答するということに注意してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p><code>BD_ADDR</code> は Bluetooth デバイスに固有のアドレスです。 これはネットワークカードの MAC アドレスに似ています。 このアドレスはデバイスとの通信を続けるのに必要となります。 BD_ADDR に人間が判読しやすい名前を割り当てることもできます。 <span class=filename>/etc/bluetooth/hosts</span> ファイルには、 既知の Bluetooth ホストに関する情報が含まれています。 次の例はリモートデバイスに割り当てられている、 人間が判読しやすい名前を得る方法を示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>リモートの Bluetooth デバイス上で inquiry を実行すると、 あなたのコンピュータは "your.host.name (ubt0)" と認識されます。 ローカルデバイスに割り当てられた名前はいつでも変更できます。</p></div><div class=paragraph><p>Bluetooth システムは一対一接続 (二つの Bluetooth ユニットだけが関係します) または一対多接続を提供します。 一対多接続では、接続はいくつかの Bluetooth デバイス間で共有されます。 次の例は、ローカルデバイスに対するアクティブなベースバンド接続のリストを得る方法を示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p><em>connection handle</em> はベースバンド接続の終了が必要とされるときに便利です。 もっとも、通常はこれを手動で行う必要はありません。 Bluetooth スタックはアクティブでないベースバンド接続を自動的に終了します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>利用可能な HCI コマンドの完全な一覧を得るには、 <code>hccontrol help</code> を参照してください。 HCI コマンドのほとんどはスーパユーザ権限を必要としません。</p></div></div><div class=sect3><h4 id=_ロジカルリンクコントロールおよびアダプテーションプロトコル_l2cap>20.4.4. ロジカルリンクコントロールおよびアダプテーションプロトコル (L2CAP)<a class=anchor href=#_ロジカルリンクコントロールおよびアダプテーションプロトコル_l2cap></a></h4><div class=paragraph><p>ロジカルリンクコントロールおよびアダプテーションプロトコル (L2CAP) は、プロトコル多重化ケーパビリティおよび分割・再編成動作を備えた、 上位層プロトコルへのコネクション指向およびコネクションレスデータサービスを提供します。 L2CAP は上位層プロトコルおよびアプリケーションが 64 KB までの長さの L2CAP データパケットを送受信することを可能にします。</p></div><div class=paragraph><p>L2CAP は <em>チャネル</em> の概念に基づいています。 チャネルはベースバンド接続の上位に位置する論理的な接続です。 それぞれのチャネルは多対一の方法で一つのプロトコルに結びつけられます。 複数のチャネルを同じプロトコルに結びつけることは可能ですが、 一つのチャネルを複数のプロトコルに結びつけることはできません。 チャネル上で受け取られたそれぞれの L2CAP パケットは、 適切なより上位のプロトコルに渡されます。 複数のチャネルは同じベースバンド接続を共有できます。</p></div><div class=paragraph><p>一つの Bluetooth デバイスに対して、<em>l2cap</em> タイプの Netgraph ノードが一つ作成されます。 L2CAP ノードは通常 Bluetooth HCI ノード (下流) と Bluetooth ソケットノード (上流) に接続されます。 L2CAP ノードのデフォルト名は "devicel2cap" です。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a> マニュアルを参照してください。</p></div><div class=paragraph><p>便利なコマンドに、他のデバイスに ping を送ることができる <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a> があります。Bluetooth 実装によっては、 送られたデータすべては返さないことがあります。 したがって次の例で <em>0 バイト</em> は正常です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> ユーティリティは L2CAP ノード上でさまざまな操作を行うのに使われます。 この例は、ローカルデバイスに対する論理的な接続 (チャネル) およびベースバンド接続の一覧を得る方法を示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>別の診断ツールが <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a> です。 これは <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> と同様の作業を、Bluetooth ネットワークに関するデータ構造についての行います。 下記の例は上の <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> と同じ論理的な接続を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect3><h4 id=_rfcomm_プロトコル>20.4.5. RFCOMM プロトコル<a class=anchor href=#_rfcomm_プロトコル></a></h4><div class=paragraph><p>RFCOMM プロトコルは L2CAP プロトコルを介してシリアルポートのエミュレーションを提供します。 このプロトコルは ETSI (訳注: 欧州電気通信標準化機構) 標準 TS 07.10 に基づいています。 RFCOMM プロトコルは、単純な伝送プロトコルに RS-232 (EIATIA-232-E) シリアルポートの 9 本の結線をエミュレートする項目を加えたものです。 RFCOMM プロトコルは、二つの Bluetooth デバイス間で、最大 60 までの同時接続 (RFCOMM チャネル) に対応しています。</p></div><div class=paragraph><p>RFCOMM の目的から、完全な通信経路は、異なるデバイス上 (通信の端点) で動作している二つのアプリケーションと、 その間の通信セグメントを含んでいます。RFCOMM は、それが動いているデバイスのシリアルポートを利用するアプリケーションをカバーするためのものです。 通信セグメントはあるデバイスから他のデバイスへの Bluetooth リンクです (直接接続)。</p></div><div class=paragraph><p>RFCOMM は直接接続している場合のデバイス間の接続、 またはネットワークの場合のデバイスとモデムの間の接続にだけ関係があります。 RFCOMM は、一方が Bluetooth 無線技術で通信し、 もう一方で有線インタフェースを提供するモジュールのような、 他の構成にも対応できます。</p></div><div class=paragraph><p>FreeBSD では RFCOMM プロトコルは Bluetooth ソケット層に実装されています。</p></div></div><div class=sect3><h4 id=_デバイスのペアリング>20.4.6. デバイスのペアリング<a class=anchor href=#_デバイスのペアリング></a></h4><div class=paragraph><p>デフォルトでは Bluetooth 通信は認証されておらず、 すべてのデバイスが他のすべてのデバイスと通信できます。 Bluetooth デバイス (たとえば携帯電話) は特定のサービス (たとえばダイアルアップサービス) を提供するために、 認証を要求することも選択できます。 Bluetooth 認証は通常 <em>PIN コード</em> で行われます。 PIN コードは最長 16 文字のアスキー文字列です。 ユーザは両デバイスで同じ PIN コードを入力することを要求されます。 一度 PIN コードを入力すると、 両デバイスは <em>リンクキー</em> を作成します。 その後、リンクキーはそのデバイス自身または、 不揮発性記憶デバイス内に格納できます。 次の機会には、両デバイスは前に作成されたリンクキーを使用するでしょう。 このような手続きを<em>ペアリング (pairing)</em> と呼びます。いずれかのデバイス上でリンクキーが失われたときには、 ペアリングをやり直さなければならないことに注意してください。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> デーモンが Bluetooth 認証要求のすべてを扱う責任を負っています。 デフォルトの設定ファイルは <span class=filename>/etc/bluetooth/hcsecd.conf</span> です。 PIN コードが "1234" に設定された携帯電話に関する例は以下の通りです。</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>PIN コードには (長さを除いて) 制限はありません。 いくつかのデバイス (たとえば Bluetooth ヘッドフォン) には固定的な PIN コードが組み込まれているかもしれません。 <code>-d</code> オプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> デーモンがフォアグラウンドで動作するように強制するため、 何が起きているのか確認しやすくなります。 リモートデバイスがペアリングを受け取るように設定して、 リモートデバイスへの Bluetooth 接続を開始してください。 リモートデバイスはペアリングが受け入れらた、と応答して PIN コードを要求するでしょう。 <span class=filename>hcsecd.conf</span> 内にあるのと同じ PIN コードを入力してください。 これであなたの PC とリモートデバイスがペアとなりました。 また、リモートデバイスからペアリングを開始することもできます。 以下は <code>hcsecd</code> の出力例です。</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect3><h4 id=_サービスディスカバリプロトコル_sdp>20.4.7. サービスディスカバリプロトコル (SDP)<a class=anchor href=#_サービスディスカバリプロトコル_sdp></a></h4><div class=paragraph><p>サービスディスカバリプロトコル (SDP) は、 クライアントアプリケーションが、 サーバアプリケーションが提供するサービスの存在とその属性を発見する手段を提供します。 サービスの属性には提示されているサービスのタイプまたはクラス、 および、サービスを利用するのに必要な仕組みまたはプロトコルの情報が含まれます。</p></div><div class=paragraph><p>SDP には SDP サーバと SDP クライアント間の通信が含まれます。 SDP サーバは、サーバに関連づけられたサービスの特性について記述しているサービスレコードの一覧を維持しています。 各サービスレコードにはそれぞれ 1 つのサービスの情報が書かれています。 クライアントは SDP リクエストを出すことによって、 SDP サーバが維持しているサービスレコードから情報を検索できます。 クライアントまたはクライアントに関連づけられたアプリケーションがサービスを利用することにしたら、 サービスを利用するためには、 サービスプロバイダへの接続を別途開かなければなりません。 SDP はサービスとそれらの属性を発見するための仕組みを提供しますが、 そのサービスを利用するための仕組みは提供しません。</p></div><div class=paragraph><p>通常 SDP クライアントは希望するサービスの特性に基づいてサービスを検索します。 しかしながら、サービスに関する事前の情報なしに、 どのタイプのサービスが SDP サーバのサービスレコードに記述されているか知ることが望ましいことがあります。 この、提供されている任意のサービスを閲覧する手順を、 <em>ブラウジング (browsing)</em> と呼びます。</p></div><div class=paragraph><p>現在のところ Bluetooth SDP サーバおよびクライアントは、 <a href=http://www.geocities.com/m_evmenkin/>ここ</a> からダウンロードできる第三者パッケージ sdp-1.5 で実装されています。 sdptool はコマンドラインの SDP クライアントです。 次の例は SDP ブラウズの問い合わせ方法を示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdptool browse 00:80:37:29:19:a4</span>
Browsing 00:80:37:29:19:A4 ...
Service Name: Dial-up Networking
Protocol Descriptor List:
 <span class=s2>&#34;L2CAP&#34;</span> <span class=o>(</span>0x0100<span class=o>)</span>
 <span class=s2>&#34;RFCOMM&#34;</span> <span class=o>(</span>0x0003<span class=o>)</span>
   Channel: 1

Service Name: Fax
Protocol Descriptor List:
 <span class=s2>&#34;L2CAP&#34;</span> <span class=o>(</span>0x0100<span class=o>)</span>
 <span class=s2>&#34;RFCOMM&#34;</span> <span class=o>(</span>0x0003<span class=o>)</span>
   Channel: 2

Service Name: Voice gateway
Service Class ID List:
 <span class=s2>&#34;Headset Audio Gateway&#34;</span> <span class=o>(</span>0x1112<span class=o>)</span>
 <span class=s2>&#34;Generic Audio&#34;</span> <span class=o>(</span>0x1203<span class=o>)</span>
Protocol Descriptor List:
 <span class=s2>&#34;L2CAP&#34;</span> <span class=o>(</span>0x0100<span class=o>)</span>
 <span class=s2>&#34;RFCOMM&#34;</span> <span class=o>(</span>0x0003<span class=o>)</span>
   Channel: 3</code></pre></div></div><div class="olist lowerroman"><ol class=lowerroman type=i><li><p>等々。 それぞれのサービスは属性の一覧 (たとえば RFCOMM チャネル) を持っていることに注意してください。サービスによっては、 属性のリストの一部についてメモをとっておく必要があるかもしれません。 Bluetooth 実装のいくつかは、サービスブラウジングに対応しておらず、 空の一覧を返してくるかもしれません。この場合、 特定のサービスを検索をすることは可能です。下記の例は OBEX オブジェクトプッシュ (OPUSH) サービスを検索する方法です。</p></li></ol></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdptool search --bdaddr 00:07:e0:00:0b:ca OPUSH</span></code></pre></div></div><div class=paragraph><p>FreeBSD 上における Bluetooth クライアントへのサービス提供は sdpd サーバが行います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpd</span></code></pre></div></div><div class=paragraph><p>sdptool は、ローカル SDP サーバにサービスを登録するのにも用いられます。 下記の例は PPP (LAN) サービスを備えたネットワークアクセスを登録する方法を示しています。 一部のサービスでは属性 (たとえば RFCOMM チャネル) を要求することに注意してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdptool add --channel=7 LAN</span></code></pre></div></div><div class=paragraph><p>ローカル SDP サーバに登録されたサービスの一覧は SDP ブラウザの問い合わせを "特別な" BD_ADDR に送ることで得られます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdptool browse ff:ff:ff:00:00:00</span></code></pre></div></div></div><div class=sect3><h4 id=_ダイアルアップネットワーク_dun_および_ppp_lan_を用いたネットワークアクセスプロファイル>20.4.8. ダイアルアップネットワーク (DUN) および PPP (LAN) を用いたネットワークアクセスプロファイル<a class=anchor href=#_ダイアルアップネットワーク_dun_および_ppp_lan_を用いたネットワークアクセスプロファイル></a></h4><div class=paragraph><p>ダイアルアップネットワーク (DUN) プロファイルはほとんどの場合、 モデムや携帯電話とともに使用されます。 このプロファイルが対象とする場面は以下のものです。</p></div><div class=ulist><ul><li><p>コンピュータから携帯電話またはモデムを、 ダイアルアップインターネットアクセスサーバへの接続、 または他のダイアルアップサービスを利用するための無線モデムとして使うこと</p></li><li><p>データ呼び出しを受けるための、 コンピュータによる携帯電話またはモデムの使用</p></li></ul></div><div class=paragraph><p>PPP (LAN) によるネットワークアクセスプロファイルは、 次の状況で利用できます。</p></div><div class=ulist><ul><li><p>単一の Bluetooth デバイスへの LAN アクセス</p></li><li><p>マルチ Bluetooth デバイスへの LAN アクセス</p></li><li><p>(シリアルケーブルエミュレーション上の PPP ネットワーク接続を使用した) PC から PC への接続</p></li></ul></div><div class=paragraph><p>FreeBSD ではどちらのプロファイルも <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> (RFCOMM Bluetooth 接続を PPP が制御可能なように変換するラッパ) で実装されています。 いずれかのプロファイルが使用可能となる前に、 <span class=filename>/etc/ppp/ppp.conf</span> 内に新しい PPP ラベルが作成されていなければなりません。 例については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> のマニュアルページを参照してください。</p></div><div class=paragraph><p>次の例では、DUN RFCOMM チャネル上で BD_ADDR が 00:80:37:29:19:a4 のリモートデバイスへの RFCOMM 接続を開くのに <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> が使われます。実際の RFCOMM チャネル番号は SDP を介してリモートデバイスから得ます。 手動で RFCOMM チャネルを指定することもでき、その場合 <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> は SDP 問い合わせを実行しません。 リモートデバイス上の RFCOMM チャネルを見つけるには、 sdptool を使ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>PPP (LAN) サービスでネットワークアクセスを提供するためには、 sdpd サーバが動いていなければなりません。 これはローカル SDP サーバに LAN サービスを登録するのにも必要です。 LAN サービスは RFCOMM チャネル属性を必要とすることに注意してください。 <span class=filename>/etc/ppp/ppp.conf</span> ファイル内に LAN クライアントの新しいエントリを作成しなければなりません。 例については <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> のマニュアルページを参照してください。 最後に、RFCOMM PPP サーバが実行され、 ローカル SDP サーバに登録されているのと同じ RFCOMM チャネルで待ち受けていなければなりません。 次の例は RFCOMM PPP サーバを起動する方法を示しています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect3><h4 id=_obex_プッシュ_opush_プロファイル>20.4.9. OBEX プッシュ (OPUSH) プロファイル<a class=anchor href=#_obex_プッシュ_opush_プロファイル></a></h4><div class=paragraph><p>OBEX はモバイルデバイス間で広く使われている単純なファイル転送プロトコルです。 これは主に赤外線通信で利用されており、ノートパソコンや PDA 間の汎用的なファイル転送、および PIM アプリケーションを搭載した携帯電話その他のデバイス間で名刺やカレンダーエントリを転送するのに用いられます。</p></div><div class=paragraph><p>OBEX サーバおよびクライアントは、 <a href=http://www.geocities.com/m_evmenkin/>ここ</a> からダウンロードできる obexapp-1.0 という第三者のパッケージとして実装されています。 このパッケージは openobex ライブラリ (上記の obexapp に含まれます) および <a class=package href=https://cgit.freebsd.org/ports/tree/devel/glib12/>devel/glib12</a> port を必要とします。 なお、obexapp はルート権限を必要としません。</p></div><div class=paragraph><p>OBEX クライアントは OBEX サーバとの間でオブジェクトを渡したり (プッシュ) および受け取ったり (プル) するのに使用されます。 オブジェクトは、たとえば名刺や予定などになります。 OBEX クライアントは RFCOMM チャネル番号を SDP によってリモートデバイスから得ることができます。 これは RFCOMM チャネル番号の代わりにサービス名を指定することによって行うことができます。 対応しているサービス名は IrMC, FTRN および OPUSH です。 RFCOMM チャネルを番号で指定することもできます。 下記は、デバイス情報オブジェクトを携帯電話から受け取り、 新しいオブジェクト (名刺) が携帯電話に渡される場合の OBEX セッションの例です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get
get: remote file&gt; telecom/devinfo.txt
get: <span class=nb>local </span>file&gt; devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put
put: <span class=nb>local </span>file&gt; new.vcf
put: remote file&gt; new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>OBEX プッシュサービスを提供するためには、 sdpd サーバが実行されていなければなりません。 また OPUSH サービスをローカル SDP サーバに登録することも必要です。 なお、OPUSH サービスには RFCOMM チャネル属性が必要です。 渡されるオブジェクトをすべて格納するルートフォルダを作成しなければいけません。 ルートフォルダのデフォルトパスは <span class=filename>/var/spool/obex</span> です。 最後に OBEX サーバが実行され、 ローカル SDP サーバに登録されているのと同じ RFCOMM チャネルで待ち受けていなければなりません。 下記の例は OBEX サーバの起動方法を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect3><h4 id=_シリアルポート_sp_プロファイル>20.4.10. シリアルポート (SP) プロファイル<a class=anchor href=#_シリアルポート_sp_プロファイル></a></h4><div class=paragraph><p>シリアルポート (SP) プロファイルは Bluetooth デバイスが RS232 (または同様の) シリアルケーブルエミュレーションを行えるようにします。 このプロファイルが対象とする場面は、 レガシーアプリケーションが、仮想シリアルポート抽象を介して Bluetooth をケーブルの代替品として使うところです。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> ユーティリティはシリアルポートプロファイルを実装します。 Pseudo tty が仮想シリアルポート抽象概念として用いられます。 下記の例はリモートデバイスのシリアルポートサービスへ接続する方法を示します。 なお、RFCOMM チャネルを指定する必要はありません。- <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> は SDP を介してリモートデバイスからその情報を得ることができます。 これを上書きしたい場合にはコマンドラインで RFCOMM チャネルを指定してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</span>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</code></pre></div></div><div class=paragraph><p>接続された pseudo tty はシリアルポートとして利用することができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l ttyp6</span></code></pre></div></div></div><div class=sect3><h4 id=_トラブルシューティング_5>20.4.11. トラブルシューティング<a class=anchor href=#_トラブルシューティング_5></a></h4><div class=sect4><h5 id=_リモートデバイスが接続できません>20.4.11.1. リモートデバイスが接続できません<a class=anchor href=#_リモートデバイスが接続できません></a></h5><div class=paragraph><p>古い Bluetooth デバイスのなかにはロールスイッチング (role switching) に対応していないものがあります。 デフォルトでは FreeBSD が新しい接続を受け付けるときに、 ロールスイッチを実行してマスタになろうとします。 これに対応していないデバイスは接続できないでしょう。 なお、ロールスイッチングは新しい接続が確立されるときに実行されるので、 ロールスイッチングに対応しているかどうかリモートデバイスに問い合わせることはできません。 ローカル側でロールスイッチングを無効にする HCI オプションがあります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div></div><div class=sect4><h5 id=_何かがうまくいっていないみたいです_何が実際に起こっているか確認できますか>20.4.11.2. 何かがうまくいっていないみたいです。 何が実際に起こっているか確認できますか?<a class=anchor href=#_何かがうまくいっていないみたいです_何が実際に起こっているか確認できますか></a></h5><div class=paragraph><p>できます。 <a href=http://www.geocities.com/m_evmenkin/>ここ</a> からダウンロードできる第三者パッケージ hcidump-1.5 を使ってください。 hcidump ユーティリティは <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> と似ています。 これはターミナル上の Bluetooth パケットの内容の表示および Bluetooth パケットをファイルにダンプするのに使えます。</p></div></div></div></div><div class=sect2><h3 id=network-bridging>20.5. ブリッジ<a class=anchor href=#network-bridging></a></h3><div class=sect3><h4 id=_はじめに_4>20.5.1. はじめに<a class=anchor href=#_はじめに_4></a></h4><div class=paragraph><p>IP サブネットを作成して、 それらのセグメントをルータを使って接続することなしに、 (Ethernet セグメントのような) 一つの物理ネットワークを二つのネットワークセグメントに分割することはとても有効な場合があります。 この方法で二つのネットワークを繋ぐデバイスは "ブリッジ" と呼ばれます。 二つのネットワークインタフェースカードを持つ FreeBSD システムは、ブリッジとして動作することができます。</p></div><div class=paragraph><p>ブリッジは、各ネットワークインタフェイスに繋がるデバイスの MAC 層のアドレス (Ethernet アドレス) を記憶することにより動作します。 ブリッジはトラフィックの送信元と受信先が異なったネットワーク上にある場合にのみトラフィックを転送します。</p></div><div class=paragraph><p>多くの点で、ブリッジはポート数の少ない Ethernet スイッチのようなものといえます。</p></div></div><div class=sect3><h4 id=_ブリッジがふさわしい状況>20.5.2. ブリッジがふさわしい状況<a class=anchor href=#_ブリッジがふさわしい状況></a></h4><div class=paragraph><p>今日ブリッジが活躍する場面は大きく分けて二つあります。</p></div><div class=sect4><h5 id=_トラフィックの激しいセグメント>20.5.2.1. トラフィックの激しいセグメント<a class=anchor href=#_トラフィックの激しいセグメント></a></h5><div class=paragraph><p>ひとつは、 物理ネットワークセグメントがトラフィック過剰になっているが、 なんらかの理由によりネットワークをサブネットに分け、 ルータで接続することができない場合です。</p></div><div class=paragraph><p>編集部門と製作部門がおなじサブネットに同居している新聞社を例に考えてみましょう。 編集部門のユーザはファイルサーバとして全員サーバ <code>A</code> を利用し、 製作部門のユーザはサーバ <code>B</code> を利用します。 すべてのユーザを接続するのには Ethernet が使われており、 高負荷となったネットワークは遅くなってしまいます。</p></div><div class=paragraph><p>もし編集部門のユーザを一つのネットワークセグメントに分離することができ、 製作部門のユーザも同様にできるのなら、 二つのネットワークセグメントをブリッジで繋ぐことができます。 ブリッジの "反対" 側へ向かうネットワークトラフィックだけが転送され、 各ネットワークセグメントの混雑は緩和されます。</p></div></div><div class=sect4><h5 id=_パケットフィルタ帯域制御用ファイアウォール>20.5.2.2. パケットフィルタ/帯域制御用ファイアウォール<a class=anchor href=#_パケットフィルタ帯域制御用ファイアウォール></a></h5><div class=paragraph><p>もうひとつはネットワークアドレス変換 (NAT) を使わずにファイアウォール機能を利用したい場合です。</p></div><div class=paragraph><p>ここでは DSL もしくは ISDN で ISP に接続している小さな会社を例にとってみましょう。 この会社は ISP からグローバル IP アドレスを 13 個割り当てられており、ネットワーク上には 10 台の PC が存在します。 このような状況では、サブネット化にまつわる問題から、 ルータを用いたファイアウォールを利用することは困難です。</p></div><div class=paragraph><p>ブリッジを用いたファイアウォールなら、 IP アドレスの問題を気にすること無く、 DSL/ISDN ルータの下流側に置くように設定できます。</p></div></div></div><div class=sect3><h4 id=_ブリッジを設定する>20.5.3. ブリッジを設定する<a class=anchor href=#_ブリッジを設定する></a></h4><div class=sect4><h5 id=_ネットワークインタフェースカードの選択>20.5.3.1. ネットワークインタフェースカードの選択<a class=anchor href=#_ネットワークインタフェースカードの選択></a></h5><div class=paragraph><p>ブリッジを利用するには少なくとも 2 枚のネットワークカードが必要です。 残念なことに FreeBSD 4.0 ではすべてのネットワークインタフェースカードがブリッジ機能に対応しているわけではありません。 カードに対応しているかどうかについては <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> を参照してください。</p></div><div class=paragraph><p>以下に進む前に、 二枚のネットワークカードをインストールしてテストしてください。</p></div></div><div class=sect4><h5 id=_カーネルコンフィグレーションの変更>20.5.3.2. カーネルコンフィグレーションの変更<a class=anchor href=#_カーネルコンフィグレーションの変更></a></h5><div class=paragraph><p>カーネルでブリッジ機能を有効にするには</p></div><div class="literalblock programlisting"><div class=content><pre>options BRIDGE</pre></div></div><div class=paragraph><p>という行をカーネルコンフィグレーションファイルに追加して カーネルを再構築してください。</p></div></div><div class=sect4><h5 id=_ファイアウォール対応>20.5.3.3. ファイアウォール対応<a class=anchor href=#_ファイアウォール対応></a></h5><div class=paragraph><p>ファイアウォールとしてブリッジを利用しようとしている場合には <code>IPFIREWALL</code> オプションも指定する必要があります。 ブリッジをファイアウォールとして設定する際の一般的な情報に関しては、 ファイアウォールの章 を参照してください。</p></div><div class=paragraph><p>IP 以外のパケット (ARP など) がブリッジを通過するようにするためには、 ファイアウォール用オプションを設定しなければなりません。 このオプションは <code>IPFIREWALL_DEFAULT_TO_ACCEPT</code> です。この変更により、 デフォルトではファイアウォールがすべてのパケットを受け入れるようになることに注意してください。 この設定を行う前に、 この変更が自分のルールセットにどのような影響をおよぼすかを把握しておかなければなりません。</p></div></div><div class=sect4><h5 id=_帯域制御機能>20.5.3.4. 帯域制御機能<a class=anchor href=#_帯域制御機能></a></h5><div class=paragraph><p>ブリッジで帯域制御機能を利用したい場合、 カーネルコンフィグレーションで <code>DUMMYNET</code> オプションを加える必要があります。 詳しい情報に関しては <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> を参照してください。</p></div></div></div><div class=sect3><h4 id=_ブリッジを有効にする>20.5.4. ブリッジを有効にする<a class=anchor href=#_ブリッジを有効にする></a></h4><div class=paragraph><p>ブリッジを有効にするには、 <span class=filename>/etc/sysctl.conf</span> に以下の行を加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge=1</pre></div></div><div class=paragraph><p>指定したインタフェースでブリッジを可能にするには以下を加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge_cfg=if1,if2</pre></div></div><div class=paragraph><p>(<em>if1</em> および <em>if2</em> は二つのネットワークインタフェースの名前に置き換えてください)。 ブリッジを経由したパケットを <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> でフィルタしたい場合には、 以下の行も付け加える必要があります</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge_ipfw=1</pre></div></div><div class=paragraph><p>FreeBSD 5.2-RELEASE 以降では、かわりに以下の行を使用してください。</p></div><div class="literalblock programlisting"><div class=content><pre>net.link.ether.bridge.enable=1
 net.link.ether.bridge.config=if1,if2
 net.link.ether.bridge.ipfw=1</pre></div></div></div><div class=sect3><h4 id=_その他の情報>20.5.5. その他の情報<a class=anchor href=#_その他の情報></a></h4><div class=paragraph><p>ネットワークからブリッジに <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> したい場合、 ネットワークカードの一つに IP アドレスを割り当てるのが正しいです。 一般的に、両方のカードに IP アドレスを割り当てるのはよい考えではないとされています。</p></div><div class=paragraph><p>ネットワーク内に複数のブリッジを設置する場合、 任意のワークステーション間で一つ以上の経路を持つことはできません。 技術的には、 これはスパニングツリーのリンク制御はサポートされていない、 ということを意味します。</p></div><div class=paragraph><p>ブリッジは、<a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> にかかる時間を遅らせることがあります。特に、 一方のセグメントからもう一方へのトラフィックでそうなります。</p></div></div></div><div class=sect2><h3 id=network-nfs>20.6. NFS<a class=anchor href=#network-nfs></a></h3><div class=paragraph><p>FreeBSD がサポートしている多くのファイルシステムの中には、 NFS とも呼ばれているネットワークファイルシステムがあります。 NFS はあるマシンから他のマシンへと、 ネットワークを通じてディレクトリとファイルを共有することを可能にします。 NFS を使うことで、 ユーザやプログラムはリモートシステムのファイルを、 それがローカルファイルであるかのようにアクセスすることができます。</p></div><div class=paragraph><p>NFS が提供可能な最も特筆すべき利点いくつかは以下のものです。</p></div><div class=ulist><ul><li><p>一般的に使われるデータを単一のマシンに納めることができ、 ユーザはネットワークを通じてデータにアクセスできるため、 ローカルワークステーションが使用するディスク容量が減ります。</p></li><li><p>ネットワーク上のすべてのマシンに、 ユーザが別々にホームディレクトリを持つ必要がありません。 NFS サーバ上にホームディレクトリが設定されれば、 ネットワークのどこからでもアクセス可能です。</p></li><li><p>フロッピーディスクや CDROM ドライブ、 ZIP ドライブなどのストレージデバイスを、 ネットワーク上の他のマシンで利用することができます。 ネットワーク全体のリムーバブルドライブの数を減らせるかもしれません。</p></li></ul></div><div class=sect3><h4 id=_nfs_はどのように動作するのか>20.6.1. NFS はどのように動作するのか<a class=anchor href=#_nfs_はどのように動作するのか></a></h4><div class=paragraph><p>NFS は最低二つの主要な部分、 サーバと一つ以上のクライアントからなります。 クライアントはサーバマシン上に格納されたデータにリモートからアクセスします。 これが適切に機能するには、 いくつかのプロセスが設定されて実行されていなければなりません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.X では <code>portmap</code> ユーティリティは rpcbind ユーティリティに置き換わりました。 したがって FreeBSD 5.X では、ユーザは下記の例で、 portmap の例のすべてを <code>rpcbind</code> に置き換える必要があります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>サーバは以下のデーモンを動作させなければなりません。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">デーモン</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nfsd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NFS クライアントからのリクエストを処理する NFS デーモン</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>mountd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=nfsd&amp;sektion=8&amp;format=html">nfsd(8)</a> から渡されたリクエストを実際に実行する NFS マウントデーモン</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>portmap</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NFS サーバの利用しているポートを NFS クライアントから取得できるようにするためのポートマッパデーモン</p></td></tr></tbody></table><div class=paragraph><p>クライアント側では nfsiod というデーモンも実行できます。 nfsiod デーモンは NFS サーバからのリクエストを処理します。 これは任意であり、性能を改善しますが、 通常の正しい動作には必要としません。詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=nfsiod&amp;sektion=8&amp;format=html">nfsiod(8)</a> マニュアルページを参照してください。</p></div></div><div class=sect3><h4 id=network-configuring-nfs>20.6.2. NFS の設定<a class=anchor href=#network-configuring-nfs></a></h4><div class=paragraph><p>NFS の設定は比較的素直な工程です。 動かさなければならないプロセスは <span class=filename>/etc/rc.conf</span> ファイルを少し変更すれば起動時に実行させられます。</p></div><div class=paragraph><p>NFS サーバでは <span class=filename>/etc/rc.conf</span> ファイルの中で、 以下のオプションが設定されていることを確かめてください。</p></div><div class="literalblock programlisting"><div class=content><pre>portmap_enable=&#34;YES&#34;
nfs_server_enable=&#34;YES&#34;
mountd_flags=&#34;-r&#34;</pre></div></div><div class=paragraph><p><code>mountd</code> は NFS サーバが有効になっていれば、 自動的に実行されます。</p></div><div class=paragraph><p>クライアント側では <span class=filename>/etc/rc.conf</span> 内に以下の設定があることを確認してください。</p></div><div class="literalblock programlisting"><div class=content><pre>nfs_client_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p><span class=filename>/etc/exports</span> ファイルは NFS サーバがどのファイルシステムをエクスポート (ときどき "共有" と呼ばれます) するのかを指定します。 <span class=filename>/etc/exports</span> ファイル中の各行は、 エクスポートするファイルシステム、 およびそのファイルシステムにアクセスできるマシンを指定します。 ファイルシステムにアクセスできるマシンとともに、 アクセスオプションも指定できます。 このファイルで指定できるオプションはたくさんありますが、 ここではほんの少しだけ言及します。<a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> マニュアルページを読めば、 他のオプションは簡単にみつけられるでしょう。</p></div><div class=paragraph><p>いくつか <span class=filename>/etc/exports</span> の設定例を示します。</p></div><div class=paragraph><p>以下の例はファイルシステムのエクスポートの考え方を示しますが、 あなたの環境とネットワーク設定に応じて設定は少し変わるでしょう。 たとえば次の行は <span class=filename>/cdrom</span> ディレクトリを、サーバと同じドメイン名か (そのため、いずれもドメイン名がありません)、 <span class=filename>/etc/hosts</span> に記述されている三つの例となるマシンに対してエクスポートします。 <code>-ro</code> フラグは共有されるファイルシステムを読み込み専用にします。 このフラグにより、 リモートシステムは共有されたファイルシステムに対して何の変更も行えなくなります。</p></div><div class="literalblock programlisting"><div class=content><pre>/cdrom -ro host1 host2 host3</pre></div></div><div class=paragraph><p>以下の設定は IP アドレスで指定した 3 つのホストに対して <span class=filename>/home</span> をエクスポートします。 この設定はプライベートネットワークで DNS が設定されていない場合に便利でしょう。 内部のホスト名に対して <span class=filename>/etc/hosts</span> を設定するという手段もあります。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> を参照してください。 <code>-alldirs</code> フラグはサブディレクトリがマウントポイントとなることを認めます。 言い替えると、これはサブディレクトリをマウントしませんが、 クライアントが要求するか、 または必要とするディレクトリだけをマウントできるようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</pre></div></div><div class=paragraph><p>以下の設定は、サーバとは異なるドメイン名の 2 台のクライアントがアクセスできるように <span class=filename>/a</span> をエクスポートします。 <code>-maproot=root</code> フラグは、リモートシステムの <code>root</code> ユーザが、 エクスポートされたファイルシステムに <code>root</code> として書き込むことを許可します。 <code>-maproot=root</code> フラグが無ければ、 リモートマシンの <code>root</code> 権限を持っていても、 共有されたファイルシステム上のファイルを変更することはできないでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>/a  -maproot=root  host.example.com box.example.org</pre></div></div><div class=paragraph><p>クライアントがエクスポートされたファイルシステムにアクセスするためには、 そうする権限が与えられていなければなりません。 <span class=filename>/etc/exports</span> ファイルに クライアントが含まれているかどうか確認してください。</p></div><div class=paragraph><p><span class=filename>/etc/exports</span> ファイルでは、 それぞれの行が一つのファイルシステムを一つのホストにエクスポートすることを表します。 リモートホストはファイルシステム毎に一度だけ指定することができ、 それに加えて一つのデフォルトエントリを置けます。たとえば <span class=filename>/usr</span> が単一のファイルシステムであると仮定します。 次の <span class=filename>/etc/exports</span> は無効です。</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src   client
/usr/ports client</pre></div></div><div class=paragraph><p>単一のファイルシステムである <span class=filename>/usr</span> は、2 行に渡って、同じホスト <code>client</code> へエクスポートされています。 この場合、正しい書式は次のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src /usr/ports  client</pre></div></div><div class=paragraph><p>あるホストにエクスポートされるある 1 つのファイルシステムのプロパティは、 1 行ですべて指定しなければなりません。 クライアントの指定のない行は、単一のホストとして扱われます。 これはファイルシステムをエクスポートできる方法を制限しますが、 多くの場合これは問題になりません。</p></div><div class=paragraph><p>下記は、 <span class=filename>/usr</span> および <span class=filename>/exports</span> がローカルファイルシステムである場合の、 有効なエクスポートリストの例です。</p></div><div class="literalblock programlisting"><div class=content><pre># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</pre></div></div><div class=paragraph><p>変更が有効となるように、 <span class=filename>/etc/exports</span> が変更されたら <code>mountd</code> を再起動しなければなりません。 これは <code>mountd</code> プロセスに HUP シグナルを送ることで実行できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/mountd.pid`</span></code></pre></div></div><div class=paragraph><p>他には、再起動すれば、FreeBSD はすべてを適切に設定します。 しかしながら、再起動は必須ではありません。 <code>root</code> 権限で以下のコマンドを実行すれば、すべてが起動するでしょう。</p></div><div class=paragraph><p>NFS サーバでは</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmap</span>
<span class=c># nfsd -u -t -n 4</span>
<span class=c># mountd -r</span></code></pre></div></div><div class=paragraph><p>NFS クライアントでは</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nfsiod -n 4</span></code></pre></div></div><div class=paragraph><p>これでリモートのファイルシステムを実際にマウントする準備がすべてできました。 この例では、サーバの名前は <code>server</code> で、 クライアントの名前は <code>client</code> とします。 リモートファイルシステムを一時的にマウントするだけ、 もしくは設定をテストするだけなら、クライアント上で <code>root</code> 権限で以下のコマンドを実行するだけです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount server:/home /mnt</span></code></pre></div></div><div class=paragraph><p>これで、サーバの <span class=filename>/home</span> ディレクトリが、クライアントの <span class=filename>/mnt</span> にマウントされます。もしすべてが正しく設定されていれば、 クライアントの /mnt に入り、 サーバにあるファイルすべてを見れるはずです。</p></div><div class=paragraph><p>リモートファイルシステムを起動のたびに自動的にマウントしたいなら、 ファイルシステムを <span class=filename>/etc/fstab</span> ファイルに追加してください。 例としてはこのようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>server:/home	/mnt	nfs	rw	0	0</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> マニュアルページに利用可能なオプションがすべて掲載されています。</p></div></div><div class=sect3><h4 id=_実用的な使い方>20.6.3. 実用的な使い方<a class=anchor href=#_実用的な使い方></a></h4><div class=paragraph><p>NFS には実用的な使用法がいくつもあります。 ここで典型的な使用法をいくつか紹介しましょう。</p></div><div class=ulist><ul><li><p>何台ものマシンで CDROM などのメディアを共有するように設定します。 これは安上がりで、たいていは、 複数のマシンにソフトウェアをインストールするのにより便利な方法です。</p></li><li><p>大規模なネットワークでは、 すべてのユーザのホームディレクトリを格納するメイン NFS サーバを構築すると、ずっと便利でしょう。 どのワークステーションにログインしても、 ユーザがいつでも同じホームディレクトリを利用できるように、 これらのホームディレクトリはネットワークに向けてエクスポートされます。</p></li><li><p>何台ものマシンで <span class=filename>/usr/ports/distfiles</span> ディレクトリを共有できます。こうすると、 何台ものマシン上に port をインストールする必要がある時に、 それぞれのマシンでソースコードをダウンロードすることなく、 直ちにソースにアクセスできます。</p></li></ul></div></div><div class=sect3><h4 id=network-amd>20.6.4. amd による自動マウント<a class=anchor href=#network-amd></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> (自動マウントデーモン) は、 ファイルシステム内のファイルまたはディレクトリがアクセスされると、 自動的にリモートファイルシステムをマウントします。 また、一定の間アクセスされないファイルシステムは amd によって自動的にアンマウントされます。 amd を使用することは、通常 <span class=filename>/etc/fstab</span> 内に記述する恒久的なマウントに対する、 単純な代替案となります。</p></div><div class=paragraph><p>amd はそれ自身を NFS サーバとして <span class=filename>/host</span> および <span class=filename>/net</span> ディレクトリに結びつけることによって動作します。 このディレクトリ内のどこかでファイルがアクセスされると、 amd は対応するリモートマウントを調べて、 自動的にそれをマウントします。 <span class=filename>/net</span> が、エクスポートされたファイルシステムを IP アドレスで指定してマウントするのに利用される一方で、 <span class=filename>/host</span> は、エクスポートされたファイルシステムをリモートホスト名で指定してマウントするのに利用されます。</p></div><div class=paragraph><p><span class=filename>/host/foobar/usr</span> 内のファイルにアクセスすると、 amd はホスト <code>foobar</code> からエクスポートされた <span class=filename>/usr</span> をマウントします。</p></div><div class=exampleblock><div class=title>例 44. amd によるエクスポートされたファイルシステムのマウント</div><div class=content><div class=paragraph><p><code>showmount</code> コマンドを用いて、 リモートホストのマウントで利用できるものが見られます。 たとえば、<code>foobar</code> と名付けられたホストのマウントを見るために次のように利用できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% showmount <span class=nt>-e</span> foobar
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
% <span class=nb>cd</span> /host/foobar/usr</code></pre></div></div></div></div><div class=paragraph><p>例のように <code>showmount</code> はエクスポートとして <span class=filename>/usr</span> を表示します。 <span class=filename>/host/foobar/usr</span> にディレクトリを変更すると、 amd はホスト名 <code>foobar</code> を解決し、お望みのエクスポートをマウントしようと試みます。</p></div><div class=paragraph><p>amd は <span class=filename>/etc/rc.conf</span> 内に次の行を記述すれば、 起動スクリプトによって起動されます。</p></div><div class="literalblock programlisting"><div class=content><pre>amd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>さらに <code>amd_flags</code> オプションによって amd にフラグをカスタマイズして渡せます。デフォルトでは <code>amd_flags</code> は次のように設定されています。</p></div><div class="literalblock programlisting"><div class=content><pre>amd_flags=&#34;-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map&#34;</pre></div></div><div class=paragraph><p><span class=filename>/etc/amd.map</span> ファイルは、 エクスポートがマウントされるデフォルトオプションを決定します。 <span class=filename>/etc/amd.conf</span> ファイルは、 amd のより高度な機能の一部を設定します。</p></div><div class=paragraph><p>詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=amd.conf&amp;sektion=8&amp;format=html">amd.conf(8)</a> マニュアルページを参照してください。</p></div></div><div class=sect3><h4 id=network-nfs-integration>20.6.5. 他のシステムとの統合についての問題<a class=anchor href=#network-nfs-integration></a></h4><div class=paragraph><p>ISA バス用のイーサネットアダプタの中には性能が悪いため、 ネットワーク、特に NFS で深刻な問題がおきるものがあります。 これは FreeBSD に限ったことではありませんが FreeBSD でも起こり得ます。</p></div><div class=paragraph><p>この問題は (FreeBSD を使用した) PC がシリコングラフィックス社やサン・マイクロシステムズ社などの高性能なワークステーションにネットワーク接続されている場合に頻繁に起こります。 NFS マウントはうまく動作するでしょう。 また、いくつかの操作もうまく動作するかもしれませんが、 他のシステムに対する要求や応答は続いていても、 突然サーバがクライアントの要求に対して応答しなくなります。これは、 クライアントが FreeBSD か上記のワークステーションであるときにクライアント側に起きる現象です。 多くのシステムでは、いったんこの問題が現われると、 行儀良くクライアントを終了する手段はありません。 NFS がこの状態に陥ってしまうと正常に戻すことはできないため、 多くの場合クライアントをリセットすることが唯一の解決法となります。</p></div><div class=paragraph><p>"正しい" 解決法は、より高性能のイーサネットアダプタを FreeBSD システムにインストールすることですが、 満足に動作させる簡単な方法があります。 FreeBSD システムが <em>サーバ</em> になるのなら、 クライアントからのマウント時に <code>-w=1024</code> オプションをつけて下さい。FreeBSD システムが <em>クライアント</em> になるのなら、 NFS ファイルシステムを <code>-r=1024</code> オプションつきでマウントして下さい。 これらのオプションは自動的にマウントをおこなう場合には クライアントの <span class=filename>fstab</span> エントリの 4 番目のフィールドに指定してもよいですし、 手動マウントの場合は mount コマンドの <code>-o</code> パラメータで指定してもよいでしょう。</p></div><div class=paragraph><p>NFS サーバとクライアントが別々のネットワーク上にあるような場合、 これと間違えやすい他の問題が起きることに注意して下さい。 そのような場合は、ルータが必要な UDP 情報をきちんとルーティングしているかを確かめて下さい。 していなければ、たとえあなたが何をしようと解決できないでしょう。</p></div><div class=paragraph><p>次の例では <code>fastws</code> は高性能ワークステーションのホスト (インタフェース) 名で、 <code>freebox</code> は低性能のイーサネットアダプタを備えた FreeBSD システムのホスト (インタフェース) 名です。 また <span class=filename>/sharedfs</span> はエクスポートされる NFS ファイルシステムであり (<a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> を参照) 、 <span class=filename>/project</span> はエクスポートされたファイルシステムの、 クライアント上のマウントポイントとなります。 すべての場合において、アプリケーションによっては <code>hard</code> や <code>soft</code>, <code>bg</code> といった追加オプションがふさわしいかもしれないことに注意して下さい。</p></div><div class=paragraph><p>クライアント側 FreeBSD システム (<code>freebox</code>) の <span class=filename>/etc/fstab</span> の例は以下のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>fastws:/sharedfs /project nfs rw,-r=1024 0 0</pre></div></div><div class=paragraph><p><code>freebox</code> 上で手動で mount コマンドを実行する場合は次のようにして下さい。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs -o -r=1024 fastws:/sharedfs /project</span></code></pre></div></div><div class=paragraph><p>サーバ側 FreeBSD システム (<code>fastws</code>) の <span class=filename>/etc/fstab</span> の例は以下のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>freebox:/sharedfs /project nfs rw,-w=1024 0 0</pre></div></div><div class=paragraph><p><code>fastws</code> 上で手動で mount コマンドで実行する場合は次のようにして下さい。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs -o -w=1024 freebox:/sharedfs /project</span></code></pre></div></div><div class=paragraph><p>近いうちにどのような 16 ビットのイーサネットアダプタでも、上記の読み出し、 書き込みサイズの制限なしで操作できるようになるでしょう。</p></div><div class=paragraph><p>失敗が発生したとき何が起きているか関心のある人に、 なぜ回復不可能なのかも含めて説明します。NFS は通常 (より小さいサイズへ分割されるかもしれませんが) 8 K の "ブロック" サイズで動作します。 イーサネットのパケットサイズは最大 1500 バイト程度なので、 上位階層のコードにとっては 1 つのユニットであって、 NFS "ブロック" は複数のイーサネットパケットに分割されるものの、 上位階層のコードにとっては 1 つのユニットであって、 ユニットとして受信され、組み立て直され、 <em>肯定応答</em> (ACK) されなければなりません。 高性能のワークステーションは次々に NFS ユニットを構成するパケットを、 標準の許す限り間隔を詰めて次々に送り出すことができます。 小さく、容量の低いカードでは、 同じユニットの前のパケットがホストに転送される前に、 後のパケットがそれを踏みつぶしてしまいます。 このため全体としてのユニットは、再構成も肯定応答もできません。 その結果、 ワークステーションはタイムアウトして再送を試みますが、 8 K のユニット全体を再送しようとするので、 このプロセスは際限無く繰り返されてしまいます。</p></div><div class=paragraph><p>ユニットサイズをイーサネットのパケットサイズの 制限以下に抑えることにより、 受信した完全なイーサネットパケットについて個々に肯定応答を返せることが保証されるので、 デッドロック状態を避けられるようになります。</p></div><div class=paragraph><p>それでも、高性能なワークステーションが力任せに次々と PC システムにデータを送ったときには踏みつぶしが起きるかもしれません。 しかし、高性能のカードを使っていれば、NFS "ユニット" で必ずそのような踏みつぶしが起きるとは限りません。 踏みつぶしが起きたら、影響を受けたユニットは再送されて、 受信され、組み立てられ、肯定応答される十分な見込みがあります。</p></div></div></div><div class=sect2><h3 id=network-diskless>20.7. ディスクレス稼働<a class=anchor href=#network-diskless></a></h3><div class=paragraph><p>FreeBSD マシンはネットワークを通じて起動でき、 そして NFS サーバからマウントしたファイルシステムを使用して、 ローカルディスクなしで動作することができます。 標準の設定ファイルを変更する以上の、システムの修正は必要ありません。 必要な要素のすべてが用意されているので、 このようなシステムを設定するのは簡単です。</p></div><div class=ulist><ul><li><p>ネットワークを通じてカーネルを読み込む方法は、 少なくとも二つあります。</p><div class=ulist><ul><li><p>PXE: Intel® の Preboot Execution Environment システムは、 一部のネットワークカードまたはマザーボードに組み込まれた、 スマートなブート ROM の一形態です。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=pxeboot&amp;sektion=8&amp;format=html">pxeboot(8)</a> を参照してください。</p></li><li><p>port の etherboot (<a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a>) は、 ネットワークを通じてカーネルを起動する ROM 化可能なコードを提供します。 コードはネットワークカード上のブート PROM に焼き付けるか、 あるいはローカルフロッピー (ハード) ディスクドライブ、 または動作している MS-DOS® システムから読み込むことができます。 多くのネットワークカードに対応しています。</p></li></ul></div></li><li><p>サンプルスクリプト (<span class=filename>/usr/shared/examples/diskless/clone_root</span>) はサーバ上で、 ワークステーションのルートファイルシステムの作成と維持をやり易くします。 このスクリプトは少し書き換えないといけないでしょうが、 早く取り掛かれるようにします。</p></li><li><p>ディスクレスシステム起動を検知しサポートする標準のシステム起動ファイルが <span class=filename>/etc</span> 内にあります。</p></li><li><p>必要なら、NFS ファイルまたはローカルディスクのどちらかにスワップできます。</p></li></ul></div><div class=paragraph><p>ディスクレスワークステーションを設定する方法はいろいろあります。 多くの要素が関わっており、 その多くはローカルの状況に合わせてカスタマイズできます。下記は、 単純さと標準の FreeBSD 起動スクリプトとの互換性を強調した完全なシステムの設定を説明します。 記述されているシステムの特徴は次のとおりです。</p></div><div class=ulist><ul><li><p>ディスクレスワークステーションは、 共有された読み取り専用の <span class=filename>ルート</span>ファイルシステムと、 共有された読み取り専用の <span class=filename>/usr</span> を使用します。</p><div class=paragraph><p><span class=filename>ルート</span> ファイルシステムは、 標準的な FreeBSD (典型的にはサーバの) のルートのコピーで、 一部の設定ファイルが、ディスクレス稼働、 また場合によってはそのワークステーションに特有のもので上書きされています。</p></div><div class=paragraph><p>書き込み可能でなければならない <span class=filename>ルート</span> の部分は <a href="https://man.freebsd.org/cgi/man.cgi?query=mfs&amp;sektion=8&amp;format=html">mfs(8)</a> ファイルシステムで覆われます。 システムが再起動するときにはすべての変更が失われるでしょう。</p></div></li><li><p>カーネルは DHCP (または BOOTP) および TFTP を用いて etherboot によって読み込まれます。</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>記述されているとおり、 このシステムは安全ではありません。 ネットワークの保護された範囲で使用されるべきであり、 他のホストから信頼されてはいけません。</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_セットアップの手順>20.7.1. セットアップの手順<a class=anchor href=#_セットアップの手順></a></h4><div class=sect4><h5 id=_dhcpbootp_の設定>20.7.1.1. DHCP/BOOTP の設定<a class=anchor href=#_dhcpbootp_の設定></a></h5><div class=paragraph><p>ネットワークを通じて設定を取得し、 ワークステーションを起動するために一般的に使用されるプロトコルには、 BOOTP と DHCP の 2 つがあります。 それらはワークステーションのブートストラップ時に何ヵ所かで使用されます。</p></div><div class=ulist><ul><li><p>etherboot はカーネルを見つけるために DHCP (デフォルト) または BOOTP (設定オプションが必要) を使用します (PXE は DHCP を使用します) 。</p></li><li><p>NFS ルートの場所を定めるためにカーネルは BOOTP を使用します。</p></li></ul></div><div class=paragraph><p>BOOTP だけを使用するようにシステムを設定することもできます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=bootpd&amp;sektion=8&amp;format=html">bootpd(8)</a> サーバプログラムは FreeBSD のベースシステムに含まれています。</p></div><div class=paragraph><p>しかしながら、DHCP には BOOTP に勝る点が多々あります。 (よりよい設定ファイル、PXE が使えること、 そしてディスクレス稼働には直接関係しない多くの長所) ここでは BOOTP だけ利用する場合と、 BOOTP と DHCP を組み合わせた設定を扱います。特に ISC DHCP ソフトウェアパッケージを利用する後者の方法に重点をおきます。</p></div><div class=sect5><h6 id=_isc_dhcp_を使用する設定>20.7.1.1.1. ISC DHCP を使用する設定<a class=anchor href=#_isc_dhcp_を使用する設定></a></h6><div class=paragraph><p>isc-dhcp サーバは、 BOOTP および DHCP リクエストの両方に答えることができます。</p></div><div class=paragraph><p>4.4-RELEASE の時点で isc-dhcp 3.0 はベースシステムの一部では無くなりました。 まずはじめに <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port または対応する package をインストールする必要があるでしょう。 ports および package に関する一般的な情報については <a href=./#ports>アプリケーションのインストール - packages と ports</a> を参照してください。</p></div><div class=paragraph><p>isc-dhcp がインストールされると、 動作するために設定ファイルを必要とします (通常 <span class=filename>/usr/local/etc/dhcpd.conf</span> が指定されます) 。 下記にコメントを含めた例を示します。</p></div><div class="literalblock programlisting"><div class=content><pre>          default-lease-time 600;
          max-lease-time 7200;
          authoritative;

          option domain-name &#34;example.com&#34;;
          option domain-name-servers 192.168.4.1;
          option routers 192.168.4.1;

          subnet 192.168.4.0 netmask 255.255.255.0 {
            use-host-decl-names on; <i class=conum data-value=1></i><b>(1)</b>
            option subnet-mask 255.255.255.0;
            option broadcast-address 192.168.4.255;

            host margaux {
              hardware ethernet 01:23:45:67:89:ab;
              fixed-address margaux.example.com;
              next-server 192.168.4.4;<i class=conum data-value=2></i><b>(2)</b>
              filename &#34;/tftpboot/kernel.diskless&#34;;<i class=conum data-value=3></i><b>(3)</b>
              option root-path &#34;192.168.4.4:/data/misc/diskless&#34;;<i class=conum data-value=4></i><b>(4)</b>
            }
          }</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>このオプションは <code>host</code> 宣言の値を、 ディスクレスホストへのホスト名として送るように <code>dhcpd</code> に指示します。 別の方法として、ホスト宣言内に <code>option host-name margaux</code> を加えるものがあります。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>TFTP サーバを <code>next-server</code> ディレクティブに指定します (デフォルトは DHCP サーバと同じホストを使います)。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>カーネルとして etherboot が読み込むファイルを <code>filename</code> ディレクティブに指定します。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>ルートファイルシステムへのパスを、 通常の NFS 書式で <code>root-path</code> オプションに指定します。</td></tr></tbody></table></div></div><div class=sect5><h6 id=_bootp_を使用する設定>20.7.1.1.2. BOOTP を使用する設定<a class=anchor href=#_bootp_を使用する設定></a></h6><div class=paragraph><p>続けて、<code>bootpd</code> で同等のことをする設定です。 これは <span class=filename>/etc/bootptab</span> におきます。</p></div><div class=paragraph><p>BOOTP を使用するために、デフォルトではない <code>NO_DHCP_SUPPORT</code> オプション付きで etherboot をコンパイルしなければならないことと、PXE は DHCP を <em>必要</em> とすることに注意してください。 bootpd の唯一明白な利点は、 これがベースシステムに存在するということです。</p></div><div class="literalblock programlisting"><div class=content><pre>          .def100:\
            :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
            :sm=255.255.255.0:\
            :ds=192.168.4.1:\
            :gw=192.168.4.1:\
            :hd=&#34;/tftpboot&#34;:\
            :bf=&#34;/kernel.diskless&#34;:\
            :rp=&#34;192.168.4.4:/data/misc/diskless&#34;:

          margaux:ha=0123456789ab:tc=.def100</pre></div></div></div></div><div class=sect4><h5 id=_etherboot_を用いるブートプログラムの準備>20.7.1.2. Etherboot を用いるブートプログラムの準備<a class=anchor href=#_etherboot_を用いるブートプログラムの準備></a></h5><div class=paragraph><p><a href=http://etherboot.sourceforge.net>Etherboot のウェブサイト</a> には主に Linux システムについて述べた<a href=http://etherboot.sourceforge.net/doc/html/userman/t1.html> 広範囲の文書</a> が含まれています。 しかし、それにもかかわらず有用な情報を含んでいます。 下記は FreeBSD システム上での etherboot の使用法についての概観を示します。</p></div><div class=paragraph><p>まずはじめに <a class=package href=https://cgit.freebsd.org/ports/tree/net/etherboot/>net/etherboot</a> の package または port をインストールしなければなりません。 etherboot port は通常 <span class=filename>/usr/ports/net/etherboot</span> にあります。 ports ツリーがシステムにインストールされている場合、 このディレクトリ内で <code>make</code> を実行すれば、よきに計らってくれます。 ports および packages に関する情報は <a href=./#ports>アプリケーションのインストール - packages と ports</a> を参照してください。</p></div><div class=paragraph><p>ここで説明している方法では、ブートフロッピーを使用します。 他の方法 (PROM または DOS プログラム) については etherboot の文書を参照してください。</p></div><div class=paragraph><p>ブートフロッピーを作成するためには、 etherboot をインストールしたマシンのドライブにフロッピーディスクを挿入します。 それからカレントディレクトリを etherboot ツリー内の <span class=filename>src</span> ディレクトリにして次のように入力します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmake bin32/devicetype.fd0</span></code></pre></div></div><div class=paragraph><p><em>devicetype</em> は ディスクレスワークステーションのイーサネットカードタイプに依存します。 正しい <em>devicetype</em> を決定するために、 同じディレクトリ内の <span class=filename>NIC</span> ファイルを参照してください。</p></div></div><div class=sect4><h5 id=_tftp_および_nfs_サーバの設定>20.7.1.3. TFTP および NFS サーバの設定<a class=anchor href=#_tftp_および_nfs_サーバの設定></a></h5><div class=paragraph><p>TFTP サーバ上で <code>tftpd</code> を有効にする必要があります。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><code>tftpd</code> が提供するファイルを置くディレクトリ (たとえば <span class=filename>/tftpboot</span>) を作成してください。</p></li><li><p><span class=filename>/etc/inetd.conf</span> ファイルに以下の行を追加してください。</p><div class="literalblock programlisting"><div class=content><pre>tftp    dgram   udp     wait    root  /usr/libexec/tftpd    tftpd -s /tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>少なくとも PXE のいくつかのバージョンが TCP 版の TFTP を要求するようです。その場合 <code>dgram udp</code> を <code>stream tcp</code> に置き換えた 2 番目の行を追加してください。</p></div></td></tr></tbody></table></div></li><li><p><code>inetd</code> に設定ファイルを再読み込みさせてください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/inetd.pid`</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p><span class=filename>tftpboot</span> ディレクトリはサーバ上のどこにでも置けます。 その場所が <span class=filename>inetd.conf</span> および <span class=filename>dhcpd.conf</span> の両方に設定されていることを確かめてください。</p></div><div class=paragraph><p>さらに NFS を有効にして NFS サーバの適切なファイルシステムをエクスポートする必要があります。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>この行を <span class=filename>/etc/rc.conf</span> に追加してください。</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>下記を <span class=filename>/etc/exports</span> に加えることで、 ディスクレスマシンのルートディレクトリが位置するファイルシステムをエクスポートしてください (ボリュームのマウントポイントを適当に調節し、 <em>margaux</em> をディスクレスワークステーションの名前に置き換えてください)。</p><div class="literalblock programlisting"><div class=content><pre>/data/misc -alldirs -ro margaux</pre></div></div></li><li><p><code>mountd</code> に設定ファイルを再読み込みさせてください。 <span class=filename>/etc/rc.conf</span> 内で NFS をはじめて有効にする必要があったのなら、 代わりに再起動した方がよいかもしれません。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/mountd.pid`</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect4><h5 id=_ディスクレス用のカーネル構築>20.7.1.4. ディスクレス用のカーネル構築<a class=anchor href=#_ディスクレス用のカーネル構築></a></h5><div class=paragraph><p>次のオプションを (通常のものに) 追加した、 ディスクレスクライアント用のカーネルコンフィグレーションファイルを作成してください。</p></div><div class="literalblock programlisting"><div class=content><pre>          options     BOOTP          # Use BOOTP to obtain IP address/hostname
          options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info
          options     BOOTP_COMPAT   # Workaround for broken bootp daemons.</pre></div></div><div class=paragraph><p><code>BOOTP_NFSV3</code> および <code>BOOTP_WIRED_TO</code> を利用してもよいかもしれません (<span class=filename>LINT</span> を参照してください)。</p></div><div class=paragraph><p>カーネルを構築して (<a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> を参照)、 <span class=filename>dhcpd.conf</span> に記述した名称で tftp ディレクトリにコピーしてください。</p></div></div><div class=sect4><h5 id=_ルートファイルシステムの準備>20.7.1.5. ルートファイルシステムの準備<a class=anchor href=#_ルートファイルシステムの準備></a></h5><div class=paragraph><p><span class=filename>dhcpd.conf</span> に <code>root-path</code> として記載された ディスクレスワークステーションのためのルートファイルシステムを作成する必要があります。</p></div><div class=paragraph><p>これを行う最も簡単な方法は <span class=filename>/usr/shared/examples/diskless/clone_root</span> シェルスクリプトを使用することです。 このスクリプトは、少なくともファイルシステムが作成される場所 (<code>DEST</code> 変数) を調節するために変更する必要があります。</p></div><div class=paragraph><p>説明についてはスクリプトの一番上にあるコメントを参照してください。 ベースシステムをどのように構築するか、 またファイルがどのようにディスクレス稼働、サブネット、 または個々のワークステーションに固有のバージョンによって、 選択的にオーバライドできるかを説明します。 また、ディスクレスな場合の <span class=filename>/etc/fstab</span> ファイルおよび <span class=filename>/etc/rc.conf</span> ファイルの例を示します。</p></div><div class=paragraph><p><span class=filename>/usr/shared/examples/diskless</span> 内の <span class=filename>README</span> ファイルには、多くの興味深い背景情報が書かれています。 しかし <span class=filename>diskless</span> ディレクトリ内の他の例と同じく、 <span class=filename>clone_root</span> と <span class=filename>/etc/rc.diskless[12]</span> で実際に使われているものとは異なる設定方法が説明されています。 ここに書かれている方法は <span class=filename>rc</span> スクリプトの変更が必要になりますが、 こちらの方が気に入ったというのでなければ、 参照にとどめてください。</p></div></div><div class=sect4><h5 id=_スワップの設定>20.7.1.6. スワップの設定<a class=anchor href=#_スワップの設定></a></h5><div class=paragraph><p>必要なら、サーバに置かれたスワップファイルに NFS 経由でアクセスできます。 <span class=filename>bootptab</span> または <span class=filename>dhcpd.conf</span> の正確なオプションは、 現時点では明確には文書化されていません。 下記の設定例は isc-dhcp 3.0rc11 を使用して動作したと報告されているものです。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><span class=filename>dhcpd.conf</span> に下記の行を追加してください。</p><div class="literalblock programlisting"><div class=content><pre>              # Global section
              option swap-path code 128 = string;
              option swap-size code 129 = integer 32;

              host margaux {
                ... # Standard lines, see above
                option swap-path &#34;192.168.4.4:/netswapvolume/netswap&#34;;
                option swap-size 64000;
              }</pre></div></div><div class=paragraph><p>これは、少なくとも FreeBSD クライアントにおいては、 DHCP/BOOTP オプションコードの 128 は NFS スワップファイルへのパスで、オプションコード 129 は KB 単位のスワップサイズだということです。 もっと古いバージョンの <code>dhcpd</code> では <code>option option-128 "…​</code> という書式が受け付けられましたが、 もはや対応していません。</p></div><div class=paragraph><p>代わりに、<span class=filename>/etc/bootptab</span> では次の書式を使います。</p></div><div class=paragraph><p><code>T128="192.168.4.4:/netswapvolume/netswap":T129=0000fa00</code></p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/bootptab</span> では、スワップの大きさは 16 進数で表さなければなりません。</p></div></td></tr></tbody></table></div></li><li><p>NFS スワップファイルサーバ側でスワップファイルを作成します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /netswapvolume/netswap</span>
<span class=c># cd /netswapvolume/netswap</span>
<span class=c># dd if=/dev/zero bs=1024 count=64000 of=swap.192.168.4.6</span>
<span class=c># chmod 0600 swap.192.168.4.6</span></code></pre></div></div><div class=paragraph><p><em>192.168.4.6</em> はディスクレスクライアントの IP アドレスです。</p></div></li><li><p>NFS スワップファイルサーバ上で <span class=filename>/etc/exports</span> に下記の行を追加してください。</p><div class="literalblock programlisting"><div class=content><pre>	      /netswapvolume  -maproot=0:10 -alldirs margaux</pre></div></div><div class=paragraph><p>それから、上述したように mountd にエクスポートファイルを再読み込みさせてください。</p></div></li></ol></div></div></div></div><div class=sect4><h5 id=_雑多な問題>20.7.1.7. 雑多な問題<a class=anchor href=#_雑多な問題></a></h5><div class=sect5><h6 id=_読み取り専用の_usr_で動作させる>20.7.1.7.1. 読み取り専用の <span class=filename>/usr</span> で動作させる<a class=anchor href=#_読み取り専用の_usr_で動作させる></a></h6><div class=paragraph><p>ディスクレスワークステーションが X を起動するように設定されている場合、 xdm 設定ファイルを調整しなければならないでしょう。 これはデフォルトでエラーファイルを <span class=filename>/usr</span> に置きます。</p></div></div><div class=sect5><h6 id=_freebsd_ではないサーバを使用する>20.7.1.7.2. FreeBSD ではないサーバを使用する<a class=anchor href=#_freebsd_ではないサーバを使用する></a></h6><div class=paragraph><p>ルートファイルシステムを提供するサーバが FreeBSD で動作していない場合、 FreeBSD マシン上でルートファイルシステムを作成し、 <code>tar</code> または <code>cpio</code> を利用して置きたい場所にコピーしなければならないでしょう。</p></div><div class=paragraph><p>この状況では、major/minor 整数サイズが異なっていることにより <span class=filename>/dev</span> 内のスペシャルファイルに関する問題が時々おこります。 この問題を解決するには、非 FreeBSD サーバからディレクトリをエクスポートして、 そのディレクトリを FreeBSD マシンでマウントし、 FreeBSD マシン上で <code>MAKEDEV</code> を実行して正しいデバイスエントリを作成します (FreeBSD 5.0 およびそれ以降では、<a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> を使用してユーザに意識させずにデバイスノードを割り当てるので、 これらのバージョンでは <code>MAKEDEV</code> は必要ありません)。</p></div></div></div></div></div><div class=sect2><h3 id=network-isdn>20.8. ISDN<a class=anchor href=#network-isdn></a></h3><div class=paragraph><p>ISDN 技術とハードウェアに関しては、 <a href=http://www.alumni.caltech.edu/~dank/isdn/>Dan Kegel’s ISDN Page</a> がよい参考になるでしょう。</p></div><div class=paragraph><p>手軽な ISDN の導入手順は以下のようになります。</p></div><div class=ulist><ul><li><p>ヨーロッパ在住の方は ISDN カードの節に進んでください。</p></li><li><p>ダイヤルアップ専用でない回線上で、 インターネットプロバイダをつかってインターネットに接続するために ISDN を使用することを第一に考えている場合は、 ターミナルアダプタの使用を考えてみてください。 この方法はもっとも柔軟性があり、 プロバイダを変更した場合の問題も少ないでしょう。</p></li><li><p>2 つの LAN を接続する場合や、 ISDN 専用線を使用する場合には、 スタンドアロンなルータまたはブリッジの使用を勧めます。</p></li></ul></div><div class=paragraph><p>費用はどの解決法を選ぶかを決める重要な要因です。 以下に、最も安価な方法から、高価な方法まで順に説明していきます。</p></div><div class=sect3><h4 id=network-isdn-cards>20.8.1. ISDN カード<a class=anchor href=#network-isdn-cards></a></h4><div class=paragraph><p>FreeBSD の ISDN 実装は、パッシブカードを使用した DSS1/Q.931 (または Euro-ISDN) 標準だけに対応しています。FreeBSD 4.4 からは、ファームウェアが他の信号プロトコルにも対応している 一部のアクティブカードにも対応しました。 その中には、はじめて対応された一次群速度インタフェース (PRI) ISDN カードもあります。</p></div><div class=paragraph><p>isdn4bsd は IP over raw HDLC または同期 PPP を利用して他の ISDN ルータに接続できるようにします。 PPP では、カーネル PPP を <a href="https://man.freebsd.org/cgi/man.cgi?query=sppp&amp;sektion=4&amp;format=html">sppp(4)</a> ドライバを修正した <code>isppp</code> ドライバとともに利用するか、または ユーザプロセス <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> を利用するかのどちらかになります。ユーザ <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> を利用すると、二つ以上の ISDN B チャネルを併せて利用できます。 ソフトウェア 300 ボーモデムのような多くのユーティリティとともに、 留守番電話アプリケーションも利用可能です。</p></div><div class=paragraph><p>FreeBSD が対応している PC ISDN カードの数は増加しており、 ヨーロッパ全域や世界のその他多くの地域でうまく使えることが報告されています。</p></div><div class=paragraph><p>対応しているパッシブ ISDN カードのほとんどは Infineon (前身は Siemens) の ISAC/HSCX/IPAC ISDN チップセットを備えたカードですが、 Cologne Chip から供給されたチップを備えた ISDN カード (ISA バスのみ)、Winbond W6692 チップを備えた PCI カード、 Tiger300/320/ISAC チップセットを組み合わたカードの一部、 および AVM Fritz!Card PCI V.1.0 や AVM Fritz!Card PnP のようなベンダ独自のチップセットに基づいたカードもあります。</p></div><div class=paragraph><p>現在のところ、対応しているアクティブカードは AVM B1 (ISA および PCI) BRI カードと AVM T1 PCI PRI カードです。</p></div><div class=paragraph><p>isdn4bsd についての文書は FreeBSD システム内の <span class=filename>/usr/shared/examples/isdn/</span> ディレクトリまたは <a href=http://www.freebsd-support.de/i4b/>isdn4bsd のウェブサイト</a>を参照してください。 そこにはヒントや正誤表や <a href=http://people.FreeBSD.org/~hm/>isdn4bsd ハンドブック</a>のような、 さらに多くの文書に対するポインタがあります。</p></div><div class=paragraph><p>異なる ISDN プロトコルや、現在対応されていない ISDN PC カードに対応することや、その他 isdn4bsd を拡張することに興味があるなら、Hellmuth Michaelis &lt;<a href=mailto:hm@FreeBSD.org>hm@FreeBSD.org</a>> に連絡してください。</p></div><div class=paragraph><p>isdn4bsd のインストール、設定、 そしてトラブルシューティングに関して質問があれば <a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a> メーリングリストが利用可能です。</p></div></div><div class=sect3><h4 id=_isdn_ターミナルアダプタ>20.8.2. ISDN ターミナルアダプタ<a class=anchor href=#_isdn_ターミナルアダプタ></a></h4><div class=paragraph><p>ターミナルアダプタ (TA) は ISDN で、 通常の電話線におけるモデムに相当するものです。</p></div><div class=paragraph><p>ほとんどの TA は、標準のヘイズ AT コマンドセットを使用しているので、 単にモデムと置き換えて使うことができます。</p></div><div class=paragraph><p>TA は、基本的にはモデムと同じように動作しますが、 接続方法は異なり、通信速度も古いモデムよりはるかに速くなります。 <a href=./#ppp>PPP</a> の設定を、 モデムの場合と同じように行ってください。 特にシリアル速度を使用できる最高速度に設定するのを忘れないでください。</p></div><div class=paragraph><p>プロバイダへの接続に TA を使用する最大のメリットは、動的 PPP を行えることです。 最近 IP アドレス空間がますます不足してきているため、 ほとんどのプロバイダは、 固定 IP アドレスを割り当てないようになっています。 ほとんどのスタンドアローンルータは、動的 IP アドレス割り当てに対応していません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>最近の ISDN ルータでは IP アドレスの動的割り当てに対応しているものも多いようです。 ただし制限がある場合もありますので、 詳しくはメーカに問い合わせてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>TA を使用した場合の機能や接続の安定性は、使用している PPP デーモンに完全に依存します。そのため、FreeBSD で PPP の設定が完了していれば、使用している既存のモデムを ISDN の TA に簡単にアップグレードすることができます。ただし、それまでの PPP のプログラムに問題があった場合、その問題は TA に置き換えてもそのまま残ります。</p></div><div class=paragraph><p>最高の安定性を求めるのであれば、 <a href=./#userppp>ユーザランド PPP</a> ではなく、カーネル <a href=./#ppp>PPP</a>を使用してください。</p></div><div class=paragraph><p>以下の TA は、FreeBSD で動作確認ずみです。</p></div><div class=ulist><ul><li><p>Motorola BitSurfer および Bitsurfer Pro</p></li><li><p>Adtran</p></li></ul></div><div class=paragraph><p>他の TA もほとんどの場合うまく動作するでしょう。TA のメーカーでは、TA がほとんどの標準モデム AT コマンドセットを受け付けるようにするよう努力しているようです。</p></div><div class=paragraph><p>外部 TA を使う際の最大の問題点は、 モデムの場合と同じく良いシリアルカードが必要であるということです。</p></div><div class=paragraph><p>シリアルデバイスの詳細と、 非同期シリアルポートと同期シリアルポートの差を理解するには、<a href=https://docs.freebsd.org/en/articles/serial-uart/>FreeBSD シリアルハードウェア</a>チュートリアルを参照してください。</p></div><div class=paragraph><p>標準の PC シリアルポート (非同期) に接続された TA は 128 Kbs の接続を行っていても、最大通信速度が 115.2 Kbs に制限されてしまいます。128 Kbs の ISDN の性能を最大限に生かすためには TA を同期シリアルカードに接続しなければなりません。</p></div><div class=paragraph><p>内蔵 TA を購入すれば、 同期/非同期問題を回避できるとは思わないでください。内蔵 TA には、 単に標準 PC シリアルポートのチップが内蔵されているだけです。 内蔵 TA の利点といえば、 シリアルケーブルを買わなくていいということと、 電源コンセントが一つ少なくて済むということくらいでしょう。</p></div><div class=paragraph><p>同期カードと TA の組合せでも、スタンドアロンのルータと同程度の速度は確保できます。 さらに、386 の FreeBSD マシンと組合せると、 より柔軟な設定が可能です。</p></div><div class=paragraph><p>同期カード/TA を選ぶか、スタンドアロンルータを選ぶかは、 多分に宗教的な問題です。 メーリングリストでもいくつか議論がありました。議論の全容については、 <a href=https://www.FreeBSD.org/search/>アーカイブ</a> を検索してください。</p></div></div><div class=sect3><h4 id=_スタンドアロン_isdn_ブリッジルータ>20.8.3. スタンドアロン ISDN ブリッジ/ルータ<a class=anchor href=#_スタンドアロン_isdn_ブリッジルータ></a></h4><div class=paragraph><p>ISDN ブリッジあるいはルータは、 FreeBSD あるいは他の OS に特有のものでは皆目ありません。 ルーティングやブリッジング技術に関する詳細は、 ネットワークの参考書をご覧ください。</p></div><div class=paragraph><p>この節では、 ルータとブリッジのどちらでもあてはまるように記述します。</p></div><div class=paragraph><p>ローエンド ISDN ルータ/ブリッジ製品は、 価格が下がってきていることもあり、 より広く選択されるようになるでしょう。ISDN ルータは、 ローカルイーサネットネットワークに直接接続し、 自身で他のブリッジ/ルータとの接続を制御する小さな箱です。PPP や他の広く使用されているプロトコルをつかって通信するためのソフトウェアが組み込まれています。</p></div><div class=paragraph><p>ルータは、完全な同期 ISDN 接続を使用するため、通常の TA と比較してスループットが大幅に向上します。</p></div><div class=paragraph><p>ISDN ルータ/ブリッジを使用する場合の最大の問題点は、 各メーカーの製品間に相性の問題がまだ存在することです。 インターネットプロバイダとの接続を考えている場合には、 プロバイダと相談することをお勧めします。</p></div><div class=paragraph><p>事務所の LAN と家庭の LAN の間など、二つの LAN セグメントの間を接続しようとしている場合は、 これはもっともメンテナンスが簡単で、安くあがる解決方法です。 接続の両側の機材を購入するので、 リンクがうまくいくであろうことを保証できます。</p></div><div class=paragraph><p>たとえば、 家庭のコンピュータや支店のネットワークを本社のネットワークに接続するためには、 以下のような設定が使用できます。</p></div><div class=exampleblock><div class=title>例 45. 支店または家庭のネットワーク</div><div class=content><div class=paragraph><p>ネットワークは 10 Base 2 イーサネット ("thinnet") のバス型トポロジを用いています。ルータとネットワークの間は、 必要に応じて AUI/10BT トランシーバを使って接続してください。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-bus.png alt="10 Base 2 イーサネット"></div></div><div class=paragraph><p>家庭/支店で一台しかコンピュータを使用しないのであれば、 クロスのツイストペアケーブルを使用して、 直接スタンドアロンルータに接続することも可能です。</p></div></div></div><div class=exampleblock><div class=title>例 46. 本社 LAN や他の LAN</div><div class=content><div class=paragraph><p>ネットワークは 10 base T イーサネット ("Twisted Pair") のスター型トポロジを用いています。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/isdn-twisted-pair.png alt="ISDN ネットワークダイアグラム"></div></div></div></div><div class=paragraph><p>ほとんどのルータ/ブリッジの大きな利点は、 別々の二つのサイトに対して、<em>同時</em> にそれぞれ<em>独立した</em>二つの PPP 接続が可能であることです。 これは、シリアルポートを 2 つもった特定の (通常は高価な) モデルを除いて、通常の TA では対応していません。 チャネルボンディングや MPP などと混同しないでください。</p></div><div class=paragraph><p>たとえば、事務所で専用線 ISDN 接続を使用していて、 別の ISDN 回線を購入したくないときには大変便利な機能です。この場合、 事務所のルータは、インターネットに接続するための一つの専用線 B チャネル接続 (64 Kbs) を管理し、 別の B チャネルを他のデータ接続に使用できます。 2 つ目の B チャネルは他の場所とのダイアルイン、 ダイアルアウトに使用したり、バンド幅を増やすために、 1 つ目の B チャネルと動的に結合すること (MPPなど) ができます。</p></div><div class=paragraph><p>またイーサネットブリッジは、IP パケット以外も中継できます。 IPX/SPX など、使用するすべてのプロトコルを送ることが可能です。</p></div></div></div><div class=sect2><h3 id=network-nis>20.9. NIS/YP<a class=anchor href=#network-nis></a></h3><div class=sect3><h4 id=_nisyp_とは>20.9.1. NIS/YP とは?<a class=anchor href=#_nisyp_とは></a></h4><div class=paragraph><p>NIS とは Network Information Services の略で Sun Microsystems によって UNIX® の (もともとは SunOS™ の) 集中管理のために開発されました。現在では事実上の業界標準になっており、 主要な UNIX® ライクシステム (Solaris™, HP-UX, AIX®, Linux, NetBSD, OpenBSD, FreeBSD、等々) はすべてこれをサポートしています。</p></div><div class=paragraph><p>NIS は元々、イエローページといっていましたが、 商標問題から Sun はその名前を変えました。 古い用語 (および yp) はまだよく見られ、使用されています。</p></div><div class=paragraph><p>NIS は RPC を使ったクライアント/サーバシステムです。 これを使うと NIS ドメイン内のマシン間で、 共通の設定ファイルを共有することができます。 また NIS を使うことでシステム管理者は最小限の設定データで NIS クライアントを立ち上げることができ、 1 ヶ所から設定データの追加、削除、変更が可能です。</p></div><div class=paragraph><p>NIS は Windows NT® のドメインシステムに似ています。 内部の実装は似ても似つかないものですが、 基本的な機能を対比することはできます。</p></div></div><div class=sect3><h4 id=_知っておくべき用語_プロセス>20.9.2. 知っておくべき用語 / プロセス<a class=anchor href=#_知っておくべき用語_プロセス></a></h4><div class=paragraph><p>NIS サーバの立ち上げや NIS クライアントの設定など、 NIS を FreeBSD に導入するにあたって、 目にするであろう用語や重要なユーザプロセスがいくつかあります。</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">用語</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>NIS ドメイン名</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS マスタサーバとそのクライアントすべて (スレーブサーバを含む) には NIS ドメイン名がついています。 Windows NT® ドメイン名と同様に、NIS ドメイン名は DNS とは何の関係もありません。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>portmap</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RPC (Remote Procedure Call, NIS で使用されるネットワークプロトコル) を利用するために実行しておかなければなりません。 <code>portmap</code> が動作していなければ、 NIS サーバを起動することも、 NIS クライアントとして動作させることもできません。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ypbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS クライアントを NIS サーバに "結びつけ" ます。 これは NIS ドメイン名をシステムから取得し RPC を用いてサーバに接続します。<code>ypbind</code> は NIS 環境におけるクライアントとサーバ間の通信の中枢です。 クライアントマシンの <code>ypbind</code> が停止した場合は、NIS サーバへアクセスすることができなくなります。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ypserv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>は NIS サーバでのみ実行されるべきもので、 NIS サーバプロセスそのものです。<a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> が停止した場合、サーバはもはや NIS リクエストに応答することができなくなるでしょう (できれば、後を引き継ぐスレーブサーバがあるとよいでしょう)。 今まで使っていたサーバが機能を停止したとき、 別のサーバに再接続しに行かない NIS の実装もいくつかあります (FreeBSD のものは違います)。 そのような場合に復帰するための唯一の方法は、 サーバプロセス (あるいはサーバ全体)、もしくはクライアントの <code>ypbind</code> プロセスを再スタートすることです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpc.yppasswdd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS マスターサーバで動かすべき、 もう一つのプロセスです。これは NIS クライアントが NIS パスワードを変更することを可能にするデーモンです。 このデーモンが動作していないときは、 ユーザは NIS マスタサーバにログインし、 そこでパスワードを変更しなければなりません。</p></td></tr></tbody></table></div><div class=sect3><h4 id=_動作のしくみ>20.9.3. 動作のしくみ<a class=anchor href=#_動作のしくみ></a></h4><div class=paragraph><p>NIS 環境にあるホストは、 マスターサーバ、スレーブサーバ、クライアントの 3 種類に分類されます。 サーバは、ホストの設定情報の中心的な情報格納庫の役割をします。 マスターサーバは元となる信頼できる情報を保持し、 スレーブサーバは冗長性を確保するためこの情報をミラーします。 そしてクライアントは、サーバから情報の提供を受けて動作します。</p></div><div class=paragraph><p>この方法を用いることで、数多くのファイルにある情報が共有できます。 よく NIS で共有されるのは、 <span class=filename>master.passwd</span> や <span class=filename>group</span>, <span class=filename>hosts</span> といったファイルです。 クライアント上のプロセスが、 通常ならローカルのファイルにある情報を必要とするときは、 クライアントは代わりに接続している NIS サーバに問い合わせを行います。</p></div><div class=sect4><h5 id=_マシンの分類>20.9.3.1. マシンの分類<a class=anchor href=#_マシンの分類></a></h5><div class=ulist><ul><li><p><em>NIS マスターサーバ</em>。 このサーバは Windows NT® で言うところのプライマリドメインコントローラにあたります。 すべての NIS クライアントで利用されるファイルを保守します。 <span class=filename>passwd</span> や <span class=filename>group</span>、 その他 NIS クライアントが参照するファイルは、 マスターサーバにあります。</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>一つのマシンが一つ以上の NIS ドメインのマスターサーバになることは可能です。 しかし、ここでは比較的小規模の NIS 環境を対象としているため、 そのような場合については扱いません。</p></div></td></tr></tbody></table></div></li><li><p><em>NIS スレーブサーバ</em>。 Windows NT® のバックアップドメインコントローラに似たもので、 NIS スレーブサーバは NIS マスターサーバのデータファイルのコピーを保持します。 NIS スレーブサーバは重要な環境で必要とされる冗長性を提供し、 マスターサーバの負荷のバランスをとります。 NIS クライアントは常に最初にレスポンスを返したサーバを NIS サーバとして接続しますが、 これにはスレーブサーバも含まれます。</p></li><li><p><em>NIS クライアント</em>。 NIS クライアントは大部分の Windows NT® ワークステーションのように、ログオンに際して NIS サーバ (Windows NT® ワークステーションの場合は Windows NT® ドメインコントローラ) に接続して認証します。</p></li></ul></div></div></div><div class=sect3><h4 id=_nisyp_を使う>20.9.4. NIS/YP を使う<a class=anchor href=#_nisyp_を使う></a></h4><div class=paragraph><p>この節では NIS 環境の立ち上げ例を取り上げます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この節ではあなたが FreeBSD 3.3 以降を使っているものとします。 ここで与えられる指示は <em>おそらく</em> FreeBSD の 3.0 以降のどのバージョンでも機能するでしょうが、 それを保証するものではありません。</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_計画を立てる>20.9.4.1. 計画を立てる<a class=anchor href=#_計画を立てる></a></h5><div class=paragraph><p>あなたが大学の小さな研究室の管理人であるとしましょう。 この研究室は 15 台の FreeBSD マシンからなっていて、 現在はまだ集中管理されていません。 すなわち、各マシンは <span class=filename>/etc/passwd</span> と <span class=filename>/etc/master.passwd</span> を各々が持っています。 これらのファイルは手動でお互いに同期させています。 つまり現時点では、新しいユーザをあなたが追加するとき、 <code>adduser</code> を 15 ヶ所すべてで実行しなければなりません。 これは明らかに変える必要があるため、 あなたはこのうち 2 台をサーバにして NIS を導入することを決めました。</p></div><div class=paragraph><p>その結果、研究室の設定はこのようなものになります。</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">マシンの名前</th><th class="tableblock halign-left valign-top">IP アドレス</th><th class="tableblock halign-left valign-top">役割</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ellington</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS マスタ</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>coltrane</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.3</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS スレーブ</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>basie</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.4</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>教員用のワークステーション</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bird</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.5</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>クライアントマシン</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cli[1-11]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.[6-17]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>その他のクライアントマシン</p></td></tr></tbody></table><div class=paragraph><p>もし NIS によるシステム管理の設定を行なうのが初めてなら、 どのようにしたいのか、 ひととおり最後まで考えてみることをお勧めします。 ネットワークの規模によらず、 いくつか決めるべきことがあるからです。</p></div><div class=sect5><h6 id=_nis_ドメイン名を決める>20.9.4.1.1. NIS ドメイン名を決める<a class=anchor href=#_nis_ドメイン名を決める></a></h6><div class=paragraph><p>ここでいうドメイン名は、今まであなたが使っていた、 いわゆる "ドメイン名" と呼んでいたものとは違います。 正確には "NIS ドメイン名" と呼ばれます。 クライアントがサーバに情報を要求するとき、 その要求には自分が属する NIS ドメインの名前が含まれています。 これは 1 つのネットワークに複数のサーバがある場合に、 どのサーバが要求を処理すれば良いかを決めるために使われます。 NIS ドメイン名とは、 関連のあるホストをグループ化するための名前である、 と考えると良いでしょう。</p></div><div class=paragraph><p>組織によってはインターネットのドメイン名を NIS ドメイン名に使っているところがあります。 これはネットワークのトラブルをデバッグするときに混乱の原因となるため、 お勧めできません。 NIS ドメイン名はネットワーク内で一意なければいけません。そして、 ドメイン名がドメインに含まれるマシンを表すようなものであれば分かり易いです。 たとえば Acme 社のアート (Art) 部門であれば NIS ドメイン名を "acme-art" とすれば良いでしょう。この例では NIS ドメイン名として <em>test-domain</em> を使用します。</p></div><div class=paragraph><p>しかしながらオペレーティングシステムによっては (特に SunOS™)、 NIS ドメイン名をネットワークドメイン名として使うものもあります。 あなたのネットワークにそのような制限のあるマシンが 1 台でもあるときは、NIS のドメイン名としてインターネットのネットワークドメイン名を使わなければ <em>いけません</em>。</p></div></div><div class=sect5><h6 id=_サーバマシンの物理的必要条件>20.9.4.1.2. サーバマシンの物理的必要条件<a class=anchor href=#_サーバマシンの物理的必要条件></a></h6><div class=paragraph><p>NIS サーバとして使うマシンを選ぶ際には、 いくつか注意すべき点があります。 NIS に関する困ったことの一つに、 クライアントのサーバへの依存度があります。 クライアントが自分の NIS ドメインのサーバに接続できないと、 マシンが使用不能になることがあまりに多いのです。 もし、ユーザやグループに関する情報が得られなければ、 ほとんどのシステムは一時的に停止してしまいます。 こういったことを念頭に置いて、頻繁にリブートされるマシンや、 開発に使われそうなマシンを選ばないようにしなければなりません。 理想的には NIS サーバはスタンドアロンで NIS サーバ専用のマシンにするべきです。 ネットワークの負荷が重くなければ、 他のサービスを走らせているマシンを NIS サーバにしてもかまいません。 ただし NIS サーバが使えなくなると、 <em>すべての</em> クライアントに影響をおよぼす、 という点には注意しなければなりません。</p></div></div></div><div class=sect4><h5 id=_nis_サーバ>20.9.4.2. NIS サーバ<a class=anchor href=#_nis_サーバ></a></h5><div class=paragraph><p>元となるすべての NIS 情報は、 NIS マスターサーバと呼ばれる 1 台のマシンに格納されます。 この情報が格納されるデータベースを NIS マップと呼びます。 FreeBSD では、このマップは <span class=filename>/var/yp/[domainname]</span> に置かれます。 <span class=filename>[domainname]</span> は、 サーバがサービスする NIS ドメインです。 1 台の NIS サーバが複数のドメインをサポートすることも可能です。 つまり、このディレクトリを各々のドメインごとに作ることができます。 それぞれのドメインは、 独立したマップの集合を持つことになります。</p></div><div class=paragraph><p>NIS のマスターサーバとスレーブサーバ上では、 <code>ypserv</code> デーモンがすべての NIS 要求を処理します。 <code>ypserv</code> は NIS クライアントからの要求を受け付け、 ドメイン名とマップ名を対応するデータベースファイルへのパスに変換し、 データをクライアントに返送します。</p></div><div class=sect5><h6 id=_nis_マスターサーバの設定>20.9.4.2.1. NIS マスターサーバの設定<a class=anchor href=#_nis_マスターサーバの設定></a></h6><div class=paragraph><p>やりたいことにもよりますが NIS マスターサーバの設定は比較的単純です。 FreeBSD は初期状態で NIS に対応しています。 必要なのは以下の行を <span class=filename>/etc/rc.conf</span> に追加することだけで、 あとは FreeBSD がやってくれます。</p></div><div class="exampleblock procedure"><div class=content><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;</pre></div></div><div class="olist arabic"><ol class=arabic><li><p>この行はネットワークの設定後に (たとえば再起動後に) NIS のドメイン名を <em>test-domain</em> に設定します。</p><div class="literalblock programlisting"><div class=content><pre>nis_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>これは FreeBSD に次にネットワークが立ち上がったとき NIS のサーバプロセスを起動させます。</p><div class="literalblock programlisting"><div class=content><pre>nis_yppasswdd_enable=&#34;YES&#34;</pre></div></div></li><li><p>これは <code>rpc.yppasswdd</code> デーモンを有効にします。上述したようにこれはユーザが NIS のパスワードをクライアントのマシンから変更することを可能にします。</p></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>NIS の設定によっては、 さらに他のエントリを付け加える必要があるかもしれません。 詳細については、下記の <a href=#network-nis-server-is-client>NIS クライアントとしても動作している NIS サーバ</a> 節を参照してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>さて、あとはスーパユーザ権限で <code>/etc/netstart</code> コマンドを実行するだけです。 これにより <span class=filename>/etc/rc.conf</span> で定義された値を使ってすべての設定が行なわれます。</p></div></div><div class=sect5><h6 id=_nis_マップの初期化>20.9.4.2.2. NIS マップの初期化<a class=anchor href=#_nis_マップの初期化></a></h6><div class=paragraph><p><em>NIS マップ</em> とは <span class=filename>/var/yp</span> ディレクトリにあるデータベースファイルです。 これらは NIS マスタの <span class=filename>/etc</span> ディレクトリの設定ファイルから作られます。 唯一の例外は <span class=filename>/etc/master.passwd</span> ファイルです。これは <code>root</code> や他の管理用アカウントのパスワードまでその NIS ドメインのすべてのサーバに伝えたくないという、 もっともな理由によるものです。このため NIS マップの初期化の前に以下を行う必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/master.passwd /var/yp/master.passwd</span>
<span class=c># cd /var/yp</span>
<span class=c># vi master.passwd</span></code></pre></div></div><div class=paragraph><p>システムに関するアカウント (<code>bin</code>, <code>tty</code>, <code>kmem</code>, <code>games</code> など) や、NIS クライアントに伝えたくないアカウント (たとえば <code>root</code> や他の UID が 0 (スーパユーザ) のアカウント) をすべて NIS マップから取り除かなければなりません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/var/yp/master.passwd</span> が グループまたは誰もが読めるようになっていないようにしてください (モード 600)! 必要なら <code>chmod</code> コマンドを使ってください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>すべてが終わったら NIS マップを初期化します! FreeBSD には、これを行うために <code>ypinit</code> という名のスクリプトが含まれています (詳細はそのマニュアルページをご覧ください)。 このスクリプトはほとんどの UNIX® OS に存在しますが、 すべてとは限らないことを覚えておいてください。 Digital Unix/Compaq Tru64 UNIX では <code>ypsetup</code> と呼ばれています。NIS マスタのためのマップを作るためには <code>-m</code> オプションを <code>ypinit</code> に与えます。上述のステップを完了しているなら、以下を実行して NIS マップを生成します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# ypinit <span class=nt>-m</span> test-domain
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n] n
Ok, please remember to go back and redo manually whatever fails.
If you don<span class=s1>&#39;t, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server   :  ellington
next host to add:  coltrane
next host to add:  ^D
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] y

[..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</span></code></pre></div></div><div class=paragraph><p><code>ypinit</code> は <span class=filename>/var/yp/Makefile</span> を <span class=filename>/var/yp/Makefile.dist</span> から作成します。 作成された時点では、そのファイルはあなたが FreeBSD マシンだけからなるサーバが 1 台だけの NIS 環境を扱っていると仮定しています。 <em>test-domain</em> はスレーブサーバを一つ持っていますので <span class=filename>/var/yp/Makefile</span> を編集しなければなりません。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# vi /var/yp/Makefile</code></pre></div></div><div class=paragraph><p>以下の行を (もし既にコメントアウトされていないならば) コメントアウトしなければなりません。</p></div><div class="literalblock programlisting"><div class=content><pre>NOPUSH = &#34;True&#34;</pre></div></div></div><div class=sect5><h6 id=_nis_スレーブサーバの設定>20.9.4.2.3. NIS スレーブサーバの設定<a class=anchor href=#_nis_スレーブサーバの設定></a></h6><div class=paragraph><p>NIS スレーブサーバの設定はマスターサーバの設定以上に簡単です。 スレーブサーバにログオンし <span class=filename>/etc/rc.conf</span> ファイルを前回と同様に編集します。唯一の違うところは <code>ypinit</code> の実行に <code>-s</code> オプションを使わなければいけないことです。 <code>-s</code> オプションは NIS マスターサーバの名前を要求し、 コマンドラインは以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>coltrane# ypinit <span class=nt>-s</span> ellington test-domain

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If you don<span class=s1>&#39;t, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don&#39;</span>t forget to update map ypservers on ellington.</code></pre></div></div><div class=paragraph><p>この例の場合 <span class=filename>/var/yp/test-domain</span> というディレクトリが必要になります。 NIS マスターサーバのマップファイルのコピーは、 このディレクトリに置いてください。 これらを確実に最新のものに維持する必要があります。 次のエントリをスレーブサーバの <span class=filename>/etc/crontab</span> に追加することで、最新のものに保つことができます。</p></div><div class="literalblock programlisting"><div class=content><pre>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</pre></div></div><div class=paragraph><p>この二行はスレーブサーバにあるマップファイルを、 マスターサーバのマップファイルと同期させるものです。 このエントリは必須というわけではありませんが、マスターサーバは NIS マップに対する変更をスレーブサーバに伝えようとしますし、 サーバが管理するシステムにとってパスワード情報はとても重要なので、 強制的に更新してしまうことはよい考えです。特に、 マップファイルの更新がきちんと行なわれるかどうかわからないくらい混雑するネットワークでは、 重要になります。</p></div><div class=paragraph><p>スレーブサーバ上でも <code>/etc/netstart</code> コマンドを実行して、NIS サーバを再起動してください。</p></div></div></div><div class=sect4><h5 id=_nis_クライアント>20.9.4.3. NIS クライアント<a class=anchor href=#_nis_クライアント></a></h5><div class=paragraph><p>NIS クライアントは <code>ypbind</code> デーモンを使って、特定の NIS サーバとの間に結合 (binding) と呼ばれる関係を成立させます。 <code>ypbind</code> はシステムのデフォルトのドメイン (<code>domainname</code> コマンドで設定されます) を確認し、RPC 要求をローカルネットワークにブロードキャストします。 この RPC 要求により <code>ypbind</code> が結合を成立させようとしているドメイン名が指定されます。 要求されているドメイン名に対してサービスするよう設定されたサーバが ブロードキャストを受信すると、 サーバは <code>ypbind</code> に応答し<code>ypbind</code> は応答のあったサーバのアドレスを記録します。複数のサーバ (たとえば一つのマスターサーバと、複数のスレーブサーバ) が利用可能な場合、<code>ypbind</code> は、 最初に応答したサーバのアドレスを使用します。 これ以降、クライアントのシステムは、 すべての NIS の要求をそのサーバに向けて送信します。 <code>ypbind</code> は、 サーバが順調に動作していることを確認するため、 時々 "ping" をサーバに送ります。 反応が戻ってくるべき時間内に ping に対する応答が来なければ、 <code>ypbind</code> は、そのドメインを結合不能 (unbound) として記録し、別のサーバを見つけるべく、 再びブロードキャストパケットの送信を行います。</p></div><div class=sect5><h6 id=_nis_クライアントの設定>20.9.4.3.1. NIS クライアントの設定<a class=anchor href=#_nis_クライアントの設定></a></h6><div class=paragraph><p>FreeBSD マシンを NIS クライアントにする設定は非常に単純です。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>ネットワークの起動時に NIS ドメイン名を設定して <code>ypbind</code> を起動させるために <span class=filename>/etc/rc.conf</span> ファイルを編集して以下の行を追加します。</p><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;
nis_client_enable=&#34;YES&#34;</pre></div></div></li><li><p>NIS サーバから、 利用可能なパスワードエントリをすべて取り込むため、 <span class=filename>/etc/master.passwd</span> からすべてのユーザアカウントを取り除いて、 <code>vipw</code> コマンドで以下の行を <span class=filename>/etc/master.passwd</span> の最後に追加します。</p><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この行によって NIS サーバのパスワードマップにアカウントがある人全員にアカウントが与えられます。 この行を変更すると、 さまざまな NIS クライアントの設定を行なうことが可能です。 詳細は <a href=#network-netgroups>ネットグループ</a> を、さらに詳しい情報については、O’Reilly の <code>Managing NFS and NIS</code> を参照してください。</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/master.passwd</span> 内に少なくとも一つのローカルアカウント (つまり NIS 経由でインポートされていないアカウント) を置くべきです。 また、このアカウントは <code>wheel</code> グループのメンバーであるべきです。 NIS がどこか調子悪いときには、 リモートからこのアカウントでログインし、 root になって修復するのに利用できます。</p></div></td></tr></tbody></table></div></li><li><p>NIS サーバにあるすべてのグループエントリを取り込むため、 以下の行を <span class=filename>/etc/group</span> に追加します。</p><div class="literalblock programlisting"><div class=content><pre>+:*::</pre></div></div></li></ol></div></div></div><div class=paragraph><p>上記の手順がすべて完了すれば、 <code>ypcat passwd</code> によって NIS サーバの passwd マップが参照できるようになっているはずです。</p></div></div></div></div><div class=sect3><h4 id=_nis_セキュリティ>20.9.5. NIS セキュリティ<a class=anchor href=#_nis_セキュリティ></a></h4><div class=paragraph><p>一般にドメイン名さえ知っていれば、 どこにいるリモートユーザでも <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> に RPC を発行して NIS マップの内容を引き出すことができます。 こういった不正なやりとりを防ぐため、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> には securenets と呼ばれる機能があります。これは、 アクセスを決められたホストだけに制限するのに使える機能です。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> は起動時に <span class=filename>/var/yp/securenets</span> ファイルから securenets に関する情報を読み込みます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>上記のパス名は <code>-p</code> オプションで指定されたパス名によって変わります。このファイルは、 空白で区切られたネットワーク指定とネットマスクのエントリからなっていて、 "#" で始まる行はコメントとみなされます。 簡単な securenets ファイルの例を以下に示します。</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
10.0.0.0      255.255.240.0</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> が上記のルールの一つと合致するアドレスからの要求を受け取った場合、 処理は正常に行なわれます。 もしアドレスがルールに合致しなければ、 その要求は無視されて警告メッセージがログに記録されます。 また <span class=filename>/var/yp/securenets</span> が存在しない場合、 <code>ypserv</code> はすべてのホストからの接続を受け入れます。</p></div><div class=paragraph><p><code>ypserv</code> は Wietse Venema 氏による tcpwrapper パッケージもサポートしています。 そのため <span class=filename>/var/yp/securenets</span> の代わりに tcpwrapper の設定ファイルを使ってアクセス制御を行なうことも可能です。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>これらのアクセス制御機能は一定のセキュリティを提供しますが、 どちらも特権ポートのテストのような "IP spoofing" 攻撃に対して脆弱です。すべての NIS 関連のトラフィックはファイアウォールでブロックされるべきです。</p></div><div class=paragraph><p><span class=filename>/var/yp/securenets</span> を使っているサーバは、古い TCP/IP 実装を持つ正当なクライアントへのサービスに失敗することがあります。 これらの実装の中にはブロードキャストのホストビットをすべて 0 でセットしてしまったり、 ブロードキャストアドレスの計算でサブネットマスクを見落としてしまったりするものがあります。 これらの問題にはクライアントの設定を正しく行なえば解決できるものもありますが、 問題となっているクライアントシステムを引退させるか、 <span class=filename>/var/yp/securenets</span> を使わないようにしなければならないものもあります。</p></div><div class=paragraph><p>このような古風な TCP/IP の実装を持つサーバで <span class=filename>/var/yp/securenets</span> を使うことは実に悪い考えであり、 あなたのネットワークの大部分において NIS の機能喪失を招きます。</p></div><div class=paragraph><p>tcpwrapper パッケージを使うとあなたの NIS サーバのレイテンシ (遅延) が増加します。特に混雑したネットワークや遅い NIS サーバでは、遅延の増加によって、 クライアントプログラムのタイムアウトが起こるかもしれません。 一つ以上のクライアントシステムがこれらの兆候を示したなら、 あなたは問題となっているクライアントシステムを NIS スレーブサーバにして自分自身に結び付くように強制すべきです。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_何人かのユーザのログオンを遮断する>20.9.6. 何人かのユーザのログオンを遮断する<a class=anchor href=#_何人かのユーザのログオンを遮断する></a></h4><div class=paragraph><p>わたしたちの研究室には <code>basie</code> という、 教員専用のマシンがあります。わたしたちはこのマシンを NIS ドメインの外に出したくないのですが、 マスタ NIS サーバの <span class=filename>passwd</span> ファイルには教員と学生の両方が載っています。 どうしたらいいでしょう?</p></div><div class=paragraph><p>当該人物が NIS のデータベースに載っていても、 そのユーザがマシンにログオンできないようにする方法があります。 そうするには <em>-username</em> をクライアントマシンの <span class=filename>/etc/master.passwd</span> ファイルの末尾に付け足します。 <em>username</em> はあなたがログインさせたくないと思っているユーザのユーザ名です。 これは <code>vipw</code> で行うべきです。 <code>vipw</code> は <span class=filename>/etc/master.passwd</span> への変更をチェックし、編集終了後パスワードデータベースを再構築します。 たとえば、ユーザ <em>bill</em> が <code>basie</code> にログオンするのを防ぎたいなら、以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>basie# vipw
<span class=o>[</span>add <span class=nt>-bill</span> to the end, <span class=nb>exit</span><span class=o>]</span>
vipw: rebuilding the database...
vipw: <span class=k>done

</span>basie# <span class=nb>cat</span> /etc/master.passwd

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:<span class=k>*</span>:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:<span class=k>*</span>:2:5::0:0:System &amp;:/:/sbin/nologin
bin:<span class=k>*</span>:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
<span class=nb>tty</span>:<span class=k>*</span>:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:<span class=k>*</span>:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:<span class=k>*</span>:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:<span class=k>*</span>:8:8::0:0:News Subsystem:/:/sbin/nologin
man:<span class=k>*</span>:9:9::0:0:Mister Man Pages:/usr/shared/man:/sbin/nologin
<span class=nb>bind</span>:<span class=k>*</span>:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:<span class=k>*</span>:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:<span class=k>*</span>:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:<span class=k>*</span>:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:<span class=k>*</span>:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
<span class=nt>-bill</span>

basie#</code></pre></div></div></div><div class=sect3><h4 id=network-netgroups>20.9.7. ネットグループの利用<a class=anchor href=#network-netgroups></a></h4><div class=paragraph><p>前節までに見てきた手法は、 極めて少ないユーザ/マシン向けに個別のルールを必要としている場合にはうまく機能します。 しかし大きなネットワークでは、 ユーザに触られたくないマシンへログオンを防ぐのを <em>忘れるでしょう</em> し、 そうでなくとも各マシンを個別に設定して回らなければならず、 <em>集中</em>管理という NIS の恩恵を失ってしまいます。</p></div><div class=paragraph><p>NIS の開発者はこの問題を <em>ネットグループ</em> と呼ばれる方法で解決しました。 その目的と意味合いは UNIX® のファイルシステムで使われている一般的なグループと比較できます。 主たる相違は数値 ID が存在しないことと、 ユーザアカウントと別のネットグループを含めたネットグループを定義できることです。</p></div><div class=paragraph><p>ネットグループは百人/台以上のユーザとマシンを含む、 大きく複雑なネットワークを扱うために開発されました。 あなたがこのような状況を扱わなければならないなら便利なものなのですが、 一方で、この複雑さは単純な例でネットグループの説明をすることをほとんど不可能にしています。 この節の残りで使われている例は、この問題を実演しています。</p></div><div class=paragraph><p>あなたの行なった、 研究室への NIS の導入の成功が上司の目に止ったとしましょう。 あなたの次の仕事は、あなたの NIS ドメインをキャンパスの他のいくつものマシンを覆うものへ拡張することです。 二つの表は新しいユーザと新しいマシンの名前とその説明を含んでいます。</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">ユーザの名前</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>alpha, beta</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IT 学科の通常の職員</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>charlie, delta</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IT 学科の新しい見習い</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>echo, foxtrott, golf, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>一般の職員</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>able, baker, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>まだインターン</p></td></tr></tbody></table><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">マシンの名前</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>war, death, famine, pollution</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>最も重要なサーバ。IT 職員だけがログオンを許されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>pride, greed, envy, wrath, lust, sloth</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>あまり重要でないサーバ。 IT 学科の全員がログオンを許されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>one, two, three, four, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>通常のワークステーション。 <em>本当の</em> 職員だけがログオンを許されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>trashcan</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重要なデータの入っていないひどく古いマシン。 インターンでもこのマシンの使用を許されます。</p></td></tr></tbody></table><div class=paragraph><p>もしあなたがこの手の制限を各ユーザを個別にブロックする形で実装するなら、 あなたはそのシステムにログオンすることが許されていない各ユーザについて -<em>user</em> という 1 行を、各システムの <span class=filename>passwd</span> に追加しなければならなくなるでしょう。 もしあなたが 1 エントリでも忘れればトラブルに巻き込まれてしまいます。 最初のセットアップの時にこれを正しく行えるのはありえることかも知れませんが、 遂には連日の業務の間に例の行を追加し<em>忘れてしまうでしょう</em>。 結局マーフィーは楽観主義者だったのです。</p></div><div class=paragraph><p>この状況をネットグループで扱うといくつかの有利な点があります。 各ユーザを別個に扱う必要はなく、 ユーザを一つ以上のネットグループに割り当て、 ネットグループの全メンバのログインを許可したり禁止したりすることができます。 新しいマシンを追加するときはネットグループへログインの制限を定義するだけ、 新しいユーザを追加するときはそのユーザを一つ以上のネットグループへ追加するだけで、 それぞれ行なうことができます。 これらの変更は互いに独立なので、 "ユーザとマシンの組合わせをどうするか" は存在しなくなります。 あなたの NIS のセットアップが注意深く計画されていれば、 マシンへのアクセスを認めるにも拒否するにも中心の設定をたった一カ所変更するだけです。</p></div><div class=paragraph><p>最初のステップは NIS マップネットグループの初期化です。 FreeBSD の <a href="https://man.freebsd.org/cgi/man.cgi?query=ypinit&amp;sektion=8&amp;format=html">ypinit(8)</a> はこのマップをデフォルトで作りませんが、 その NIS の実装はそれが作られさえすればそれをサポートするものです。 空のマップを作るには、単に</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# vi /var/yp/netgroup</code></pre></div></div><div class=paragraph><p>とタイプして内容を追加していきます。 わたしたちの例では、すくなくとも IT 職員、IT 見習い、一般職員、 インターンの 4 つのネットグループが必要です。</p></div><div class="literalblock programlisting"><div class=content><pre>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
	(,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</pre></div></div><div class=paragraph><p><code>IT_EMP</code>, <code>IT_APP</code> 等はネットグループの名前です。 それぞれの括弧で囲まれたグループが一人以上のユーザアカウントをそれに登録しています。 グループの 3 つのフィールドは</p></div><div class="olist arabic"><ol class=arabic><li><p>その記述が有効なホスト (群) の名称。 ホスト名を特記しなければそのエントリはすべてのホストで有効です。 もしあなたがホスト名を特記するなら、 あなたは闇と恐怖と全き混乱の領域に入り込んでしまうでしょう。</p></li><li><p>このネットグループに所属するアカウントの名称。</p></li><li><p>そのアカウントの NIS ドメイン。 もしあなたが一つ以上の NIS ドメインの不幸な仲間なら、 あなたは他の NIS ドメインからあなたのネットグループにアカウントを導入できます。</p></li></ol></div><div class=paragraph><p>各フィールドには、ワイルドカードが使えます。 詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=netgroup&amp;sektion=5&amp;format=html">netgroup(5)</a> をご覧ください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>8 文字以上のネットグループ名は、特にあなたの NIS ドメインで他のオペレーティングシステムを走らせているときは使うべきではありません。 名前には大文字小文字の区別があります。 そのためネットグループ名に大文字を使う事は、 ユーザやマシン名とネットグループ名を区別する簡単な方法です。</p></div><div class=paragraph><p>(FreeBSD 以外の) NIS クライアントの中には 多数のエントリを扱えないものもあります。 たとえば SunOS™ の古い版では 15 以上の <em>エントリ</em> を含むネットグループはトラブルを起こします。 この制限は 15 ユーザ以下のサブネットグループをいくつも作り、 本当のネットグループはこのサブネットグループからなるようにすることで回避できます。</p></div><div class="literalblock programlisting"><div class=content><pre>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</pre></div></div><div class=paragraph><p>単一のネットグループに 225 人以上のユーザをいれたいときは、 このやり方を繰り返すことができます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>新しい NIS マップの有効化と配布は簡単です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# <span class=nb>cd</span> /var/yp
ellington# make</code></pre></div></div><div class=paragraph><p>これで新しい 3 つの NIS マップ <span class=filename>netgroup</span>, <span class=filename>netgroup.byhost</span>, <span class=filename>netgroup.byuser</span> ができるはずです。 新しい NIS マップが利用できるか確かめるには <a href="https://man.freebsd.org/cgi/man.cgi?query=ypcat&amp;sektion=1&amp;format=html">ypcat(1)</a> を使います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington% ypcat <span class=nt>-k</span> netgroup
ellington% ypcat <span class=nt>-k</span> netgroup.byhost
ellington% ypcat <span class=nt>-k</span> netgroup.byuser</code></pre></div></div><div class=paragraph><p>最初のコマンドの出力は <span class=filename>/var/yp/netgroup</span> の内容に似ているはずです。 2 番目のコマンドはホスト別のネットグループを作っていなければ出力されません。 3 番目のコマンドはユーザに対するネットグループのリストを得るのに使えます。</p></div><div class=paragraph><p>クライアント側の設定は非常に簡単です。 サーバ <em>war</em> を設定するには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> を実行して以下の行</p></div><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class=paragraph><p>を</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::</pre></div></div><div class=paragraph><p>に入れ替えるだけです。</p></div><div class=paragraph><p>今、ネットグループ <em>IT_EMP</em> で定義されたユーザのデータだけが <em>war</em> のパスワードデータベースに読み込まれ、 そのユーザだけがログインを許されています。</p></div><div class=paragraph><p>残念ながらこの制限はシェルの ~ の機能や、 ユーザ名や数値の ユーザ ID の変換ルーチンにも影響します。 つまり、 <code>cd ~user</code> はうまく動かず、 <code>ls -l</code> はユーザ名のかわりに数値の ID を表示し <code>find . -user joe -print</code> は "No such user" で失敗します。 これを避けるためには、すべてのユーザのエントリを <em>サーバにログインすることを許さずに</em> 読み込まなければなりません。</p></div><div class=paragraph><p>これはもう一行を <span class=filename>/etc/master.passwd</span> に追加することで実現できます。その行は以下の</p></div><div class=paragraph><p><code>+:::::::::/sbin/nologin</code> を含んでおり、 これは "すべてのエントリを読み込むが、読み込まれたエントリのシェルは <span class=filename>/sbin/nologin</span> で置き換えられる" ということを意味します。passwd エントリの他のフィールドを <span class=filename>/etc/master.passwd</span> の既定値から置き換えることも可能です。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><code>:::::::::/sbin/nologin` の行が `@IT_EMP:::::::::</code> の行より後ろに位置することに注意してください。 さもないと NIS から読み込まれた全ユーザが /sbin/nologin をログインシェルとして持つことになります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この変更の後では、新しい職員が IT 学科に参加しても NIS マップを一つ書き換えるだけで済みます。 同様にして、あまり重要でないサーバのローカルの <span class=filename>/etc/master.passwd</span> のかつての <code>+:::::::::</code> 行を以下のように置き換えます。</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>この行は、一般のワークステーションでは以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>これでしばらく順調に運用していましたが、 数週間後、ポリシに変更がありました。 IT 学科はインターンを雇い始め、IT インターンは一般のワークステーションと余り重要ではないサーバを使うことが許され、 IT 見習いはメインサーバへのログインが許されました。 あなたは新たなネットグループ IT_INTERN を追加して新しい IT インターンたちをそのグループに登録し、 すべてのマシンの設定を変えて回ることにしました。 古い諺にこうあります。 "集中管理における過ちは、大規模な混乱を導く"。</p></div><div class=paragraph><p>いくつかのネットグループから新たなネットグループを作るという NIS の機能は、このような状況に対処するために利用できます。 その方法の一つは、役割別のネットグループを作ることです。 たとえば、重要なサーバへのログイン制限を定義するために <em>BIGSRV</em> というネットグループを作り あまり重要ではないサーバへは <em>SMALLSRV</em> というネットグループを、そして一般のワークステーション用に <em>USERBOX</em> という第 3 のネットグループを 作ることができます。これらのネットグループの各々は、 各マシンにログインすることを許されたネットグループを含みます。 あなたの NIS マップネットグループの新しいエントリは、 以下のようになるはずです。</p></div><div class="literalblock programlisting"><div class=content><pre>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</pre></div></div><div class=paragraph><p>このログイン制限の定義法は、 同一の制限を持つマシンのグループを定義できるときには便利なものです。 残念ながらこのようなケースは例外的なものです。 ほとんどの場合、 各マシンに基づくログイン制限の定義機能が必要となるでしょう。</p></div><div class=paragraph><p>マシンごとのネットグループの定義は、 上述したようなポリシの変更を扱うことができるもうひとつの方法です。 このシナリオでは、各マシンの <span class=filename>/etc/master.passwd</span> は "+" で始まる 2 つの行からなります。 最初のものはそのマシンへのログインを許されたアカウントを追加するもので、 2 番目はその他のアカウントを <span class=filename>/sbin/nologin</span> をシェルとして追加するものです。 マシン名をすべて大文字で記述したものをネットグループの名前として使うのは良い考えです。 言い換えれば、件の行は次のようになるはずです。</p></div><div class="literalblock programlisting"><div class=content><pre>+@BOXNAME:::::::::
+:::::::::/sbin/nologin</pre></div></div><div class=paragraph><p>一度、各マシンに対してこの作業を済ませてしまえば、 二度とローカルの <span class=filename>/etc/master.passwd</span> を編集する必要がなくなります。 以降のすべての変更は NIS マップの編集で扱うことができます。 以下はこのシナリオに対応するネットグループマップに、 いくつかの便利な定義を追加した例です。</p></div><div class="literalblock programlisting"><div class=content><pre># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION  BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]</pre></div></div><div class=paragraph><p>もしユーザアカウントを管理するのにデータベースの類を使っているなら、 データベースのレポートツールからマップの最初の部分を作れるようにするべきです。 そうすれば、新しいユーザは自動的にマシンにアクセスできるでしょう。</p></div><div class=paragraph><p>最後に使用上の注意を: マシン別のネットグループを使うことが常に賢明というわけではありません。 あなたが数ダースから数百の同一の環境のマシンを学生の研究室に配置しているのならば、 NIS マップのサイズを手頃な範囲に押さえるために、 マシン別のネットグループのかわりに役割別のネットグループを使うべきです。</p></div></div><div class=sect3><h4 id=_忘れてはいけないこと>20.9.8. 忘れてはいけないこと<a class=anchor href=#_忘れてはいけないこと></a></h4><div class=paragraph><p>NIS 環境にある今、 今までとは違ったやり方が必要なことがいくつかあります。</p></div><div class=ulist><ul><li><p>研究室にユーザを追加するときは、それをマスター NIS サーバに <em>だけ</em> 追加しなければならず、さらに <em>NIS マップを再構築することを忘れてはいけません</em>。 これを忘れると新しいユーザは NIS マスタ以外のどこにもログインできなくなります。 たとえば、新しくユーザ "jsmith" をラボに登録したいときは以下のようにします。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd jsmith</span>
<span class=c># cd /var/yp</span>
<span class=c># make test-domain</span></code></pre></div></div><div class=paragraph><p><code>pw useradd jsmith</code> のかわりに <code>adduser jsmith</code> を使うこともできます。</p></div></li><li><p><em>管理用アカウントを NIS マップから削除してください</em>。 管理用アカウントやパスワードを、 それらのアカウントへアクセスさせてはいけないユーザが居るかも知れないマシンにまで伝えて回りたいとは思わないでしょう。</p></li><li><p><em>NIS のマスタとスレーブをセキュアに、 そして機能停止時間を最短に保ってください</em>。 もし誰かがこれらのマシンをクラックしたり、 あるいは単に電源を落としたりすると、 彼らは実質的に多くの人を研究室へログインできなくしてしまえます。</p><div class=paragraph><p>これはどの集中管理システムにとってももっとも大きな弱点でしょう。 あなたの NIS サーバを守らなければ怒れるユーザと対面することになるでしょう!</p></div></li></ul></div></div><div class=sect3><h4 id=_nis_v1_との互換性>20.9.9. NIS v1 との互換性<a class=anchor href=#_nis_v1_との互換性></a></h4><div class=paragraph><p>FreeBSD の ypserv は、 NIS v1 クライアントを部分的にサポートしています。 FreeBSD の NIS 実装は NIS v2 プロトコルのみを使用していますが、 ほかの実装では、古いシステムとの下位互換性を持たせるため v1 プロトコルをサポートしているものもあります。 そのようなシステムに付いている ypbind デーモンは、 必要がないにもかかわらず NIS v1 のサーバとの結合を成立させようとします (しかも v2 サーバからの応答を受信した後でも、 ブロードキャストをし続けるかも知れません)。 FreeBSD の ypserv は、 クライアントからの通常のリクエストはサポートしていますが、 v1 のマップ転送リクエストはサポートしていないことに注意してください。 つまり FreeBSD の ypserv を、 v1 だけをサポートするような古い NIS サーバと組み合わせて マスターやスレーブサーバとして使うことはできません。 幸いなことに、現在、そのようなサーバが使われていることは ほとんどないでしょう。</p></div></div><div class=sect3><h4 id=network-nis-server-is-client>20.9.10. NIS クライアントとしても動作している NIS サーバ<a class=anchor href=#network-nis-server-is-client></a></h4><div class=paragraph><p>複数のサーバが存在し、サーバ自身が NIS クライアントでもあるようなドメインで ypserv が実行される場合には注意が必要です。 一般的に良いとされているのは、 他のサーバと結合をつくるようにブロードキャストさせるのではなく、 サーバをそれ自身に結合させることです。 もし、サーバ同士が依存関係を持っていて、一つのサーバが停止すると、 奇妙なサービス不能状態に陥ることがあります。 その結果、すべてのクライアントはタイムアウトを起こして 他のサーバに結合しようと試みますが、 これにかかる時間はかなり大きく、 サーバ同士がまた互いに結合してしまったりすると、 サービス不能状態はさらに継続することになります。</p></div><div class=paragraph><p><code>ypbind</code> に <code>-S</code> オプションフラグを指定して実行することで、 ホストを特定のサーバに結合することが可能です。 NIS サーバを再起動するたびに、これを手動で行いたくないなら、 次の行を <span class=filename>/etc/rc.conf</span> に追加すればよいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>nis_client_enable=&#34;YES&#34;	# run client stuff as well
nis_client_flags=&#34;-S NIS domain,server&#34;</pre></div></div><div class=paragraph><p>詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a> を参照してください。</p></div></div><div class=sect3><h4 id=_パスワード形式>20.9.11. パスワード形式<a class=anchor href=#_パスワード形式></a></h4><div class=paragraph><p>NIS を実装しようする人の誰もがぶつかる問題の一つに、 パスワード形式の互換性があります。 NIS サーバが DES 暗号化パスワード使っている場合には、 同様に DES を使用しているクライアントしか対応できません。 たとえば Solaris™； の NIS クライアントがネットワーク内にある場合、 ほぼ確実に DES 暗号化パスワードを使用しなければならないでしょう。</p></div><div class=paragraph><p>サーバとクライアントがどのライブラリを使用しているかは、 <span class=filename>/etc/login.conf</span> を確認してください。 ホストが DES 暗号パスワードを使用するように設定されている場合、 <code>default</code> クラスには以下のようなエントリが含まれます。</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
    :passwd_format=des:\
    :copyright=/etc/COPYRIGHT:\
    [Further entries elided]</pre></div></div><div class=paragraph><p><code>passwd_format</code> 特性について他に利用可能な値は <code>blf</code> および <code>md5</code> (それぞれ Blowfish および MD5 暗号化パスワード) です。</p></div><div class=paragraph><p><span class=filename>/etc/login.conf</span> を変更したときは、 ログイン特性データベースも再構築しなければなりません。 これは <code>root</code> 権限で下記のようにコマンドを実行すればできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>すでに <span class=filename>/etc/master.passwd</span> 内に記録されているパスワード形式は、 ログイン特性データベースが再構築された<em>後</em>、 ユーザが彼らのパスワードをはじめて変更するまで変更されないでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p>次に、 パスワードが選択した形式で暗号化されることを確実にするために、 さらに <span class=filename>/etc/auth.conf</span> 内の <code>crypt_default</code> において、 選択したパスワード形式に高い優先順位がついていることも確認してください。 そうするためには、選択した形式をリストの先頭に置いてください。 たとえば DES 暗号化されたパスワードを使用するときは、 エントリは次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>crypt_default	=	des blf md5</pre></div></div><div class=paragraph><p>FreeBSD 上の各 NIS サーバおよびクライアントにおいて上記の手順に従えば、 ネットワーク内でどのパスワード形式が使用されるかが それらのマシン間で整合されているということを確信できます。 NIS クライアント上で問題があれば、 ここから問題となりそうな部分を探すと良いでしょう。 覚えておいてください: 異種混在ネットワークに NIS サーバを配置したいときには、 DES が最大公約数的な標準となるでしょうから、 すべてのシステムで DES を使用しなければならないかもしれません。</p></div></div></div><div class=sect2><h3 id=network-dhcp>20.10. DHCP<a class=anchor href=#network-dhcp></a></h3><div class=sect3><h4 id=_dhcp_とは何でしょうか>20.10.1. DHCP とは何でしょうか?<a class=anchor href=#_dhcp_とは何でしょうか></a></h4><div class=paragraph><p>DHCP (Dynamic Host Configuration Protocol) は、 システムをネットワークに接続するだけで、 ネットワークでの通信に必要な情報を入手することができる仕組みです。 FreeBSD では ISC (Internet Software Consortium) による DHCP の実装を使用しています。したがって、 ここでの説明のうち実装によって異なる部分は ISC のもの用になっています。</p></div></div><div class=sect3><h4 id=_この節で説明していること>20.10.2. この節で説明していること<a class=anchor href=#_この節で説明していること></a></h4><div class=paragraph><p>この節は ISC DHCP システムのクライアント側およびサーバ側の構成要素の両方について説明します。 クライアント側のプログラムである <code>dhclient</code> は FreeBSD のベースシステム内に含まれています。そして、サーバ側の要素は <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port から利用可能です。下記の説明の他に、 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a> マニュアルページが役にたつ情報源です。</p></div></div><div class=sect3><h4 id=_dhcp_の動作>20.10.3. DHCP の動作<a class=anchor href=#_dhcp_の動作></a></h4><div class=paragraph><p>クライアントとなるマシン上で、 DHCP のクライアントである <code>dhclient</code> を実行すると、 まず設定情報の要求をブロードキャストします。デフォルトでは、 このリクエストには UDP のポート 68 を使用します。 サーバは UDP のポート 67 で応答し、クライアントの IP アドレスと、 ネットマスクやルータ、DNS サーバなどの関連する情報を提供します。 これらの情報のすべては DHCP の "リース" の形で送られ、DHCP サーバ管理者によって決められたある一定の時間内でのみ有効になります。 これによって、ネットワークに存在しなくなったホストの IP アドレスは自動的に回収されることになります。</p></div><div class=paragraph><p>DHCP クライアントはサーバから非常に多くの情報を取得することができます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a> に非常に大きなリストが載っています。</p></div></div><div class=sect3><h4 id=_freebsd_への組み込み>20.10.4. FreeBSD への組み込み<a class=anchor href=#_freebsd_への組み込み></a></h4><div class=paragraph><p>FreeBSD は ISC の DHCP クライアントである <code>dhclient</code> を完全に組み込んでいます。 DHCP クライアントはインストーラと基本システムの両方で提供されています。 ですから DHCP サーバを走らせているネットワーク上ではネットワーク関係の設定についての詳細な知識は必要になりません。 <code>dhclient</code> は、3.2 以降のすべての FreeBSD の配布物に含まれています。</p></div><div class=paragraph><p>DHCP は sysinstall で対応されており、sysinstall でのネットワークインタフェイス設定の際は、 "このインタフェイスの設定として DHCP を試してみますか? (Do you want to try DHCP configuration of this interface?)" という質問が最初になされます。 これに同意することで <code>dhclient</code> が実行され、 それが成功すればネットワークの設定情報は自動的に取得されます。</p></div><div class=paragraph><p>システム起動時に DHCP を使ってネットワーク情報を取得するように するには、次の二つを行なう必要があります。</p></div><div class=ulist><ul><li><p><span class=filename>bpf</span> デバイスがカーネルに組み込まれていることを確認します。 これを組み込むには、カーネルコンフィグレーションファイルに <code>pseudo-device bpf</code> という行を追加し、カーネルを再構築します。 カーネルの構築に関する詳細は、 <a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> を参照してください。</p><div class=paragraph><p><span class=filename>bpf</span> デバイスは、 FreeBSD にはじめから用意されている <span class=filename>GENERIC</span> カーネルに組み込まれていますので、 自分で設定を変えたカスタムカーネルを使っているのでなければ、 DHCP を動作させるためにカーネルを再構築する必要はありません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>セキュリティに関心のある方向けに注意しておきます。 <span class=filename>bpf</span> デバイスは、パケットスニファ (盗聴プログラム) を動作させることができる (ただし <code>root</code> 権限が必要) デバイスです。 <span class=filename>bpf</span> は DHCP を動作させるために <em>かならず</em>必要ですが、 セキュリティが非常に重要な場面では DHCP をいつか使うかもしれないというだけで <span class=filename>bpf</span> デバイスをカーネルに追加すべきではないでしょう。</p></div></td></tr></tbody></table></div></li><li><p><span class=filename>/etc/rc.conf</span> を編集して、 次の行を追加してください。</p><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;DHCP&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>で説明されているように <code>fxp0</code> の部分を、 動的に設定したいインタフェースの名前で置き換えることを忘れないようにしてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>もし、使っている <code>dhclient</code> の場所を変更していたり、<code>dhclient</code> にフラグを渡したい場合は、 同様に下のように書き加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>dhcp_program=&#34;/sbin/dhclient&#34;
dhcp_flags=&#34;&#34;</pre></div></div></li></ul></div><div class=paragraph><p>DHCP サーバ <code>dhcpd</code> は、Ports Collection に <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> の一部として収録されています。 この port には ISC DHCP サーバと文書が含まれています。</p></div></div><div class=sect3><h4 id=_関連ファイル>20.10.5. 関連ファイル<a class=anchor href=#_関連ファイル></a></h4><div class=ulist><ul><li><p><span class=filename>/etc/dhclient.conf</span></p><div class=paragraph><p><code>dhclient</code> は設定ファイル <span class=filename>/etc/dhclient.conf</span> を必要とします。 大抵の場合、このファイルはコメントだけであり、 デフォルトが通常使いやすい設定になっています。 この設定ファイルは <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a> マニュアルページで説明しています。</p></div></li><li><p><span class=filename>/sbin/dhclient</span></p><div class=paragraph><p><code>dhclient</code> は静的にリンクされており、 <span class=filename>/sbin</span> に置かれています。<a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> マニュアルページで <code>dhclient</code> コマンドについてより詳しく説明しています。</p></div></li><li><p><span class=filename>/sbin/dhclient-script</span></p><div class=paragraph><p><code>dhclient-script</code> は FreeBSD 特有の、 DHCP クライアント設定スクリプトです。これについては <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient-script&amp;sektion=8&amp;format=html">dhclient-script(8)</a> マニュアルページで説明されていますが、 これを編集する必要はほとんど発生しないでしょう。</p></div></li><li><p><span class=filename>/var/db/dhclient.leases</span></p><div class=paragraph><p>DHCP クライアントはこのファイルに有効なリースのデータベースをログとして記録します。 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.leases&amp;sektion=5&amp;format=html">dhclient.leases(5)</a> にもうすこし詳しい解説があります。</p></div></li></ul></div></div><div class=sect3><h4 id=_参考になる文献>20.10.6. 参考になる文献<a class=anchor href=#_参考になる文献></a></h4><div class=paragraph><p>DHCP のプロトコルは <a href=http://www.freesoft.org/CIE/RFC/2131/>RFC 2131</a> に完全に記述されています。また <a href=http://www.dhcp.org/>dhcp.org</a> にも有用な情報源が用意されています。</p></div></div><div class=sect3><h4 id=network-dhcp-server>20.10.7. DHCP サーバのインストールと設定<a class=anchor href=#network-dhcp-server></a></h4><div class=sect4><h5 id=_この節で説明していること_2>20.10.7.1. この節で説明していること<a class=anchor href=#_この節で説明していること_2></a></h5><div class=paragraph><p>この節は DHCP の ISC (Internet Software Consortium) 実装を用いて FreeBSD システムを DHCP サーバとして動作させる方法の情報を提供します。</p></div><div class=paragraph><p>DHCP のサーバ部分は FreeBSD の一部として提供されません。 したがって、このサービスを提供するために <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port をインストールする必要があるでしょう。 Ports Collection を使用する情報についての詳細は <a href=./#ports>アプリケーションのインストール - packages と ports</a> を参照してください。</p></div></div><div class=sect4><h5 id=_dhcp_サーバのインストール>20.10.7.2. DHCP サーバのインストール<a class=anchor href=#_dhcp_サーバのインストール></a></h5><div class=paragraph><p>FreeBSD システムを DHCP サーバとして設定するために、<a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> デバイスがカーネルに組み込まれていることを保証する必要があります。 そうするためには、カーネルコンフィギュレーションファイルに <code>pseudo-device bpf</code> を追加して、 カーネルを再構築してください。 カーネルの構築に関する詳細は <a href=./#kernelconfig>FreeBSD カーネルのコンフィグレーション</a> を参照してください。</p></div><div class=paragraph><p><span class=filename>bpf</span> デバイスは、 FreeBSD にはじめから用意されている <span class=filename>GENERIC</span> カーネルの一部なので、DHCP を動作させるためにカスタムカーネルを作成する必要はありません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>セキュリティを特に意識する人は、<span class=filename>bpf</span> <span class=filename>bpf</span> はパケットスニファ (盗聴プログラム) が正常に (このようなプログラムはさらに特権アクセスを必要としますが) 動作することを可能にするデバイスでもあることに注意してください。 <span class=filename>bpf</span> は DHCP を使用するために必要 <em>です</em>。 しかし、セキュリティをとても気にしているなら、 DHCP をいつか使うかもしれないというだけで <span class=filename>bpf</span> デバイスをカーネルに含めるべきではないでしょう。</p></div></td></tr></tbody></table></div><div class=paragraph><p>次に行わねばならないのは、 <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port によってインストールされた <span class=filename>dhcpd.conf</span> のサンプルを編集することです。 デフォルトでは、これは <span class=filename>/usr/local/etc/dhcpd.conf.sample</span> で、 編集する前にこれを <span class=filename>/usr/local/etc/dhcpd.conf</span> にコピーするべきでしょう。</p></div></div><div class=sect4><h5 id=_dhcp_サーバの設定>20.10.7.3. DHCP サーバの設定<a class=anchor href=#_dhcp_サーバの設定></a></h5><div class=paragraph><p><span class=filename>dhcpd.conf</span> はサブネットおよびホストに関する宣言で構成されます。 例を使って説明するのが最も簡単でしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>option domain-name &#34;example.com&#34;;<i class=conum data-value=1></i><b>(1)</b>
option domain-name-servers 192.168.4.100;<i class=conum data-value=2></i><b>(2)</b>
option subnet-mask 255.255.255.0;<i class=conum data-value=3></i><b>(3)</b>

default-lease-time 3600;<i class=conum data-value=4></i><b>(4)</b>
max-lease-time 86400;<i class=conum data-value=5></i><b>(5)</b>
ddns-update-style none;<i class=conum data-value=6></i><b>(6)</b>

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<i class=conum data-value=7></i><b>(7)</b>
  option routers 192.168.4.1;<i class=conum data-value=8></i><b>(8)</b>
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<i class=conum data-value=9></i><b>(9)</b>
  fixed-address mailhost.example.com;<i class=conum data-value=10></i><b>(10)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>このオプションは、 デフォルト探索ドメインとしてクライアントに渡されるドメインを指定します。 これが意味するところの詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> を参照してください。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>このオプションはクライアントが使用する、 コンマで区切られた DNS サーバのリストを指定します。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>クライアントに渡されるネットマスクです。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>クライアントは特定のリース期限を要求することもできます。 それ以外の場合は、サーバはこのリース期限値 (秒) でリースを割り当てるでしょう。</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>これはサーバがリースする時間の最大値です。 クライアントがこれより長いリースを要求しても、 <code>max-lease-time</code> 秒だけしか有効にならないでしょう。</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>このオプションは、リースが受理、またはリリースされたときに DHCP サーバが DNS を更新しようとするかどうかを指定します。 ISC 実装では、このオプションは <em>必須</em> です。</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>これはどの範囲の IP アドレスが、 クライアントに割り当てるために予約されたプールに使用されるかを示します。 この範囲に含まれている IP アドレスはクライアントに渡されます。</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>クライアントに供給されるデフォルトゲートウェイを宣言します。</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>(リクエストが生じた時に DHCP サーバがホストを認識できるように) ホストのハードウェア MAC アドレスを指定します。</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>ホストに常に同じ IP アドレスを付与することを指定します。 DHCP サーバはリース情報を返す前にホスト名の名前解決をするので、 ここにホスト名を書いても構いません。</td></tr></tbody></table></div><div class=paragraph><p><span class=filename>dhcpd.conf</span> を書き終えたら以下のコマンドでサーバを起動できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/isc-dhcpd.sh start</span></code></pre></div></div><div class=paragraph><p>今後サーバの設定に変更を加える必要が生じた時には、 <code>SIGHUP</code> シグナルを dhcpd に送っても、 多くのデーモンがそうであるようには、 設定ファイルが再読み込み <em>されない</em> ことに注意してください。 <code>SIGTERM</code> シグナルを送ってプロセスを停止し、 それから上記のコマンドを用いて再起動させる必要があります。</p></div></div><div class=sect4><h5 id=_ファイル>20.10.7.4. ファイル<a class=anchor href=#_ファイル></a></h5><div class=ulist><ul><li><p><span class=filename>/usr/local/sbin/dhcpd</span></p><div class=paragraph><p>dhcpd は静的にリンクされ <span class=filename>/usr/local/sbin</span> に置かれます。 dhcpd に関するそれ以上の情報は port とともにインストールされる <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd&amp;sektion=8&amp;format=html">dhcpd(8)</a> マニュアルページにあります。</p></div></li><li><p><span class=filename>/usr/local/etc/dhcpd.conf</span></p><div class=paragraph><p>dhcpd はクライアントへのサービス提供をはじめる前に設定ファイル <span class=filename>/usr/local/etc/dhcpd.conf</span> を必要とします。このファイルは、 サーバの稼働に関する情報に加えて、 サービスされているクライアントに提供される情報のすべてを含む必要があります。 この設定ファイルについての詳細は、 port によってインストールされる <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.conf&amp;sektion=5&amp;format=html">dhcpd.conf(5)</a> マニュアルページを参照してください。</p></div></li><li><p><span class=filename>/var/db/dhcpd.leases</span></p><div class=paragraph><p>DHCP サーバは発行したリースのデータベースをこのファイルにログとして保持します。 port によってインストールされる <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.leases&amp;sektion=5&amp;format=html">dhcpd.leases(5)</a> にはもう少し詳しい説明があります。</p></div></li><li><p><span class=filename>/usr/local/sbin/dhcrelay</span></p><div class=paragraph><p>dhcrelay は、DHCP サーバがクライアントからのリクエストを、 別のネットワーク上にある DHCP サーバに転送する高度な環境下で使用されます。 この機能が必要なら、<a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp3-server/>net/isc-dhcp3-server</a> port をインストールしてください。 port とともに提供される <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcrelay&amp;sektion=8&amp;format=html">dhcrelay(8)</a> マニュアルページにはより詳細な情報が含まれます。</p></div></li></ul></div></div></div></div><div class=sect2><h3 id=network-dns>20.11. DNS<a class=anchor href=#network-dns></a></h3><div class=sect3><h4 id=_概観>20.11.1. 概観<a class=anchor href=#_概観></a></h4><div class=paragraph><p>FreeBSD はデフォルトでは DNS プロトコルの最も一般的な実装である BIND (Berkeley Internet Name Domain) を使用します。DNS はホスト名を IP アドレスに、そして IP アドレスをホスト名に関連づけるプロトコルです。 たとえば <code>www.FreeBSD.org</code> に対する問い合わせは The FreeBSD Project の ウェブサーバの IP アドレスを受け取るでしょう。 その一方で <code>ftp.FreeBSD.org</code> に対する問い合わせは、 対応する FTP マシンの IP アドレスを返すでしょう。 同様に、その逆のことも可能です。 IP アドレスに対する問い合わせを行うことで、 そのホスト名を解決することができます。 DNS 検索を実行するために、 システム上でネームサーバを動作させる必要はありません。</p></div><div class=paragraph><p>DNS は、 個々のドメイン情報を格納およびキャッシュした、 権威のあるルートサーバおよび他の小規模なネームサーバによる多少複雑なシステムによって、 インターネット全体にわたって協調して動作します。</p></div><div class=paragraph><p>この文書は FreeBSD で安定版として利用されている BIND 8.x について説明します。 FreeBSD では BIND 9.x を <a class=package href=https://cgit.freebsd.org/ports/tree/net/bind9/>net/bind9</a> port からインストールできます。</p></div><div class=paragraph><p>RFC1034 および RFC1035 は DNS プロトコルを定義しています。</p></div><div class=paragraph><p>現在のところ BIND は <a href=http://www.isc.org/>Internet Software Consortium (www.isc.org)</a> によって保守されています。</p></div></div><div class=sect3><h4 id=_用語>20.11.2. 用語<a class=anchor href=#_用語></a></h4><div class=paragraph><p>この文書を理解するには DNS 関連の用語をいくつか理解しなければいけません。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">用語</th><th class="tableblock halign-left valign-top">定義</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>正引き DNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ホスト名から IP アドレスへの対応です。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>オリジン (origine)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>特定のゾーンファイルによってカバーされるドメインへの参照です。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>named, BIND, ネームサーバ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 内の BIND ネームサーバパッケージの一般名称です。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>リゾルバ (resolver)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>マシンがゾーン情報についてネームサーバに問い合わせるシステムプロセスです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>逆引き DNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>正引き DNS の逆です。つまり IP アドレスからホスト名への対応です。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ルートゾーン</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>インターネットゾーン階層の起点です。 すべてのゾーンはルートゾーンの下に属します。 これはファイルシステムのすべてのファイルがルートディレクトリの下に属することと似ています。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ゾーン</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>同じ権威によって管理される個々の DNS ドメイン、 DNS サブドメイン、あるいは DNS の一部分です。</p></td></tr></tbody></table><div class=paragraph><p>ゾーンの例:</p></div><div class=ulist><ul><li><p><code>.</code> はルートゾーンです。</p></li><li><p><code>org.</code> はルートゾーンの下のゾーンです。</p></li><li><p><code>example.org</code> は <code>org.</code> ゾーンの下のゾーンです。</p></li><li><p><code>foo.example.org.</code> はサブドメインで、 <code>example.org.</code> の下のゾーンです。</p></li><li><p><code>1.2.3.in-addr.arpa</code> は 3.2.1.* の IP 空間に含まれるすべての IP アドレスを参照するゾーンです。</p></li></ul></div><div class=paragraph><p>見て分かるように、ホスト名のより詳細な部分はその左側に現れます。 たとえば <code>example.org.</code> は <code>org.</code> より限定的です。同様に <code>org.</code> はルートゾーンより限定的です。 ホスト名の各部分のレイアウトはファイルシステムに非常に似ています。 たとえば <span class=filename>/dev</span> はルートの下であることなどです。</p></div></div><div class=sect3><h4 id=_ネームサーバを実行する理由>20.11.3. ネームサーバを実行する理由<a class=anchor href=#_ネームサーバを実行する理由></a></h4><div class=paragraph><p>ネームサーバは通常二つの形式があります: 権威のあるネームサーバとキャッシュネームサーバです。</p></div><div class=paragraph><p>権威のあるネームサーバは以下の場合に必要です。</p></div><div class=ulist><ul><li><p>問い合わせに対して信頼できる返答をすることで、 ある人が DNS 情報を世界に向けて発信したいとき。</p></li><li><p><code>example.org</code> といったドメインが登録されており、 その下にあるホスト名に IP アドレスを割り当てる必要があるとき。</p></li><li><p>IP アドレスブロックが (IP からホスト名への) 逆引き DNS エントリを必要とするとき。</p></li><li><p>プライマリサーバがダウンしているかまたはアクセスできない場合に、 代わりに問い合わせに対してスレーブと呼ばれるバックアップネームサーバが返答しなければならないとき。</p></li></ul></div><div class=paragraph><p>キャッシュネームサーバは以下の場合に必要です。</p></div><div class=ulist><ul><li><p>ローカルのネームサーバが、 外部のネームサーバに問い合わせするよりも、 キャッシュしてより速く返答できるとき。</p></li><li><p>ネットワークトラフィックの総量を減らしたいとき (DNS のトラフィックはインターネットトラフィック全体の 5% 以上を占めることが測定されています)</p></li></ul></div><div class=paragraph><p><code>www.FreeBSD.org</code> に対する問い合わせを発したとき、 リゾルバは大体の場合上流の ISP のネームサーバに問い合わせをして返答を得ます。 ローカルのキャッシュ DNS サーバがあれば、 問い合わせはキャッシュ DNS サーバによって外部に対して一度だけ発せられます。 情報がローカルに蓄えられるので、 追加の問い合わせはいずれもローカルネットワークの外側にまで確認しなくてもよくなります。</p></div></div><div class=sect3><h4 id=_動作のしくみ_2>20.11.4. 動作のしくみ<a class=anchor href=#_動作のしくみ_2></a></h4><div class=paragraph><p>FreeBSD では BIND デーモンは自明な理由から named と呼ばれます。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">ファイル</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>named</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BIND デーモン</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ndc</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ネームデーモンコントロールプログラム</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BIND のゾーン情報が置かれるディレクトリ</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb/named.conf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>デーモンの設定ファイル</p></td></tr></tbody></table><div class=paragraph><p>ゾーンファイルは通常 <span class=filename>/etc/namedb</span> ディレクトリ内に含まれており、ネームサーバによって処理される DNS ゾーン情報を含んでいます。</p></div></div><div class=sect3><h4 id=_bind_の起動>20.11.5. BIND の起動<a class=anchor href=#_bind_の起動></a></h4><div class=paragraph><p>BIND はデフォルトでインストールされているので、 すべてを設定することは比較的単純です。</p></div><div class=paragraph><p>named デーモンが起動時に開始されることを保証するには、 <span class=filename>/etc/rc.conf</span> に以下の変更をいれてください。</p></div><div class="literalblock programlisting"><div class=content><pre>named_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>デーモンを手動で起動するためには (設定をした後で)</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndc start</span></code></pre></div></div></div><div class=sect3><h4 id=_設定ファイル_2>20.11.6. 設定ファイル<a class=anchor href=#_設定ファイル_2></a></h4><div class=sect4><h5 id=_make_localhost_の利用>20.11.6.1. <code>make-localhost</code> の利用<a class=anchor href=#_make_localhost_の利用></a></h5><div class=paragraph><p>次のコマンドが</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/namedb</span>
<span class=c># sh make-localhost</span></code></pre></div></div><div class=paragraph><p>ローカル逆引き DNS ゾーンファイルを <span class=filename>/etc/namedb/localhost.rev</span> に適切に作成することを確認してください。</p></div></div><div class=sect4><h5 id=_etcnamedbnamed_conf>20.11.6.2. <span class=filename>/etc/namedb/named.conf</span><a class=anchor href=#_etcnamedbnamed_conf></a></h5><div class="literalblock programlisting"><div class=content><pre>// $FreeBSD$
//
// 詳細については named(8) マニュアルページを参照してください。プライマリサーバ
// を設定するつもりなら、DNS がどのように動作するかの詳細を確実に理解してくださ
// い。単純な間違いであっても、影響をうける相手に対する接続を壊したり、無駄な
// インターネットトラフィックを大量に引き起こし得ます。

options {
        directory &#34;/etc/namedb&#34;;

// &#34;forwarders&#34; 節に加えて次の行を有効にすることで、ネームサーバに決して自発的
// に問い合わせを発せず、常にそのフォワーダにたいして尋ねるように強制すること
// ができます:
//
//      forward only;

// あなたが上流のプロバイダ周辺の DNS サーバを利用できる場合、その IP アドレス
// をここに入力し、下記の行を有効にしてください。こうすれば、そのキャッシュの
// 恩恵にあやかることができ、インターネット全体の DNS トラフィックが減るでしょう。
/*
        forwarders {
                127.0.0.1;
        };
*/</pre></div></div><div class=paragraph><p>コメントが言っている通り、上流のキャッシュの恩恵を受けるために <code>forwarders</code> をここで有効にすることができます。 通常の状況では、ネームサーバはインターネットの特定のネームサーバを調べて、 探している返答を見つけるまで再帰的に問い合わせを行います。 これが有効になっていれば、まず上流のネームサーバ (または 与えられたネームサーバ) に問い合わせて、 そのキャッシュを利用するでしょう。 問い合わせをする上流のネームサーバが極度に通信量が多く、 高速であった場合、これを有効にする価値があるかもしれません。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>ここに <code>127.0.0.1</code> を指定しても動作 <em>しません</em>。 上流のネームサーバの IP アドレスに変更してください。</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>        /*
         * あなたと利用したいネームサーバとの間にファイアウォールがある場合、
         * 下記の quiery-source 指令を有効にする必要があるでしょう。
         * 過去の BIND のバージョンは常に 53 番ポートに問い合わせをしますが、
         * BIND 8.1 はデフォルトで非特権ポートを使用します。
         */
        // query-source address * port 53;

        /*
         * 砂場内で動作させている場合、ダンプファイルのために異なる場所を指定
         * しなければならないかもしれません。
         */
        // dump-file &#34;s/named_dump.db&#34;;
};

// 注意: 下記は将来のリリースで対応されるでしょう。
/*
host { any; } {
        topology {
                127.0.0.0/8;
        };
};
*/

// セカンダリを設定することはより簡単な方法で、そのおおまかな姿が下記で説明さ
// れています。
//
// ローカルネームサーバを有効にする場合、このサーバが最初に尋ねられるように
// /etc/resolv.conf に 127.0.0.1 を入力することを忘れないでください。さらに、
// /etc/rc.conf 内で有効にすることも確認してください。

zone &#34;.&#34; {
        type hint;
        file &#34;named.root&#34;;
};

zone &#34;0.0.127.IN-ADDR.ARPA&#34; {
        type master;
        file &#34;localhost.rev&#34;;
};

zone
&#34;0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.INT&#34; {
        type master;
        file &#34;localhost.rev&#34;;
};

// 注意: 下記の IP アドレスを使用しないでください。これはダミーでありデモや文書
// だけを目的としたものです。
//
// セカンダリ設定の例です。少なくともあなたのドメインが属するゾーンに対するセカ
// ンダリになることは便利かもしれません。プライマリの責を負っている IP アドレス
// をネットワーク管理者に尋ねてください。
//
// 逆引き参照ゾーン (IN-ADDR.ARPA) を含めることを決して忘れないでください!
// (これは &#34;.IN-ADDR.ARPA&#34; を付け加えられたそれぞれの IP アドレスの最初のバイト
// の逆順です。)
//
// プライマリゾーンの設定をはじめる前に DNS および BIND がどのように動作するか
// 完全に理解してください。時々自明でない落し穴があります。それに比べるとセカン
// ダリを設定するのは単純です。
//
// 注意: 下記の例を鵜呑みにして有効にしないでください。:-) 実際の名前とアドレス
// を代わりに使用してください。
//
// 注意!!! FreeBSD は bind を砂場のなかで動かします (rc.conf 内の named_flags
// を参照してください)。セカンダリゾーンを含んだディレクトリは、bind によって
// 書き込み可能でなければなりません。次の手順が推奨されます:
//
//      mkdir /etc/namedb/s
//      chown bind:bind /etc/namedb/s
//      chmod 750 /etc/namedb/s</pre></div></div><div class=paragraph><p>BIND を砂場 (sandbox) で (訳注: chroot をもちいて) 動作させるための詳細は <a href=#network-named-sandbox>砂場で named を実行する</a> を参照してください。</p></div><div class="literalblock programlisting"><div class=content><pre>/*
zone &#34;example.com&#34; {
        type slave;
        file &#34;s/example.com.bak&#34;;
        masters {
                192.168.1.1;
        };
};

zone &#34;0.168.192.in-addr.arpa&#34; {
        type slave;
        file &#34;s/0.168.192.in-addr.arpa.bak&#34;;
        masters {
                192.168.1.1;
        };
};
*/</pre></div></div><div class=paragraph><p><span class=filename>named.conf</span> の中で、 上記は転送と逆引きゾーンのためのスレーブエントリの例です。</p></div><div class=paragraph><p>新しくサービスするそれぞれのゾーンについて、新規のエントリを <span class=filename>named.conf</span> に加えなければいけません。</p></div><div class=paragraph><p>たとえば <code>example.org</code> に対する最もシンプルなゾーンエントリは以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>zone &#34;example.org&#34; {
	type master;
	file &#34;example.org&#34;;
};</pre></div></div><div class=paragraph><p>このゾーンは <code>type</code> 命令で示されているようにマスタで、ゾーン情報を <code>file</code> 命令で指示された <span class=filename>/etc/namedb/example.org</span> ファイルに保持しています。</p></div><div class="literalblock programlisting"><div class=content><pre>zone &#34;example.org&#34; {
	type slave;
	file &#34;example.org&#34;;
};</pre></div></div><div class=paragraph><p>スレーブの場合、 ゾーン情報は特定のゾーンのマスタネームサーバから転送され、 指定されたファイルに保存されます。 マスタサーバが停止するか到達できない場合には、 スレーブサーバが転送されたゾーン情報を保持していて、 サービスできるでしょう。</p></div></div><div class=sect4><h5 id=_ゾーンファイル>20.11.6.3. ゾーンファイル<a class=anchor href=#_ゾーンファイル></a></h5><div class=paragraph><p><code>example.org</code> に対するマスタゾーンファイル (<span class=filename>/etc/namedb/example.org</span> に保持されます) の例は以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>$TTL 3600

example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        86400 )         ; Minimum TTL

; DNS Servers
@       IN NS           ns1.example.org.
@       IN NS           ns2.example.org.

; Machine Names
localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30

; Aliases
www             IN CNAME        @

; MX Record
@               IN MX   10      mail.example.org.</pre></div></div><div class=paragraph><p>"." が最後についているすべてのホスト名は正確なホスト名であり、 一方で "." で終了しないすべての行はオリジンが参照されることに注意してください。 たとえば <code>www</code> は <code>www + オリジン</code> に展開されます。この架空のゾーンファイルでは、 オリジンは <code>example.org.</code> なので <code>www</code> は <code>www.example.org.</code> に展開されます。</p></div><div class=paragraph><p>ゾーンファイルの書式は次のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>recordname      IN recordtype   value</pre></div></div><div class=paragraph><p>DNS レコードに使われる最も一般的なものは以下のとおりです。</p></div><div class=dlist><dl><dt class=hdlist1>SOA</dt><dd><p>ゾーン権威の起点</p></dd><dt class=hdlist1>NS</dt><dd><p>権威のあるネームサーバ</p></dd><dt class=hdlist1>A</dt><dd><p>ホストのアドレス</p></dd><dt class=hdlist1>CNAME</dt><dd><p>別名としての正規の名称</p></dd><dt class=hdlist1>MX</dt><dd><p>メールエクスチェンジャ</p></dd><dt class=hdlist1>PTR</dt><dd><p>ドメインネームポインタ (逆引き DNS で使用されます)</p></dd></dl></div><div class="literalblock programlisting"><div class=content><pre>example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        86400 )         ; Minimum TTL of 1 day</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>example.org.</code></dt><dd><p>このゾーンのオリジンでもあるドメイン名</p></dd><dt class=hdlist1><code>ns1.example.org.</code></dt><dd><p>このゾーンに対して権威のあるプライマリネームサーバ</p></dd><dt class=hdlist1><code>admin.example.org.</code></dt><dd><p>このゾーンの責任者。@ を置き換えた電子メールアドレスを指定します。 (<a href=mailto:admin@example.org>admin@example.org</a> は <code>admin.example.org</code> になります)</p></dd><dt class=hdlist1><code>5</code></dt><dd><p>ファイルのシリアル番号です。 これはファイルが変更されるたびに増加させる必要があります。 現在では多くの管理者は <code>yyyymmddrr</code> という形式をシリアル番号として使用することを好みます。 2001041002 は最後に修正されたのが 2001/04/10 で、後ろの 02 はその日で二回目に修正されたものであるということを意味するでしょう。 シリアル番号は、 それが更新されたときにスレーブネームサーバに対してゾーンを通知するので重要です。</p></dd></dl></div><div class="literalblock programlisting"><div class=content><pre>@       IN NS           ns1.example.org.</pre></div></div><div class=paragraph><p>これは <code>NS</code> エントリです。 このゾーンに対して権威のある返答を返すネームサーバはすべて、 このエントリを一つ有していなければなりません。 ここにある <code>@</code> は <code>example.org.</code> を意味します。 <code>@</code> はオリジンに展開されます。</p></div><div class="literalblock programlisting"><div class=content><pre>localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30</pre></div></div><div class=paragraph><p><code>A</code> レコードはマシン名を示します。 上記のように <code>ns1.example.org</code> は <code>3.2.1.2</code> に結びつけられるでしょう。 ふたたびオリジンを示す <code>@</code> がここに使用されていますが、これは <code>example.org</code> が <code>3.2.1.30</code> に結び付けられることを意味しています。</p></div><div class="literalblock programlisting"><div class=content><pre>www             IN CNAME        @</pre></div></div><div class=paragraph><p><code>CNAME</code> レコードは通常マシンに別名を与えるときに使用されます。 例では <code>www</code> はオリジン、すなわち <code>example.org</code> (<code>3.2.1.30</code>) のアドレスをふられたマシンへの別名を与えます。 <code>CNAME</code> はホスト名の別名、 または複数のマシン間で一つのホスト名をラウンドロビン (訳注: 問い合わせがあるたびに別の IP アドレスを返すことで、 一台にアクセスが集中することを防ぐ手法) するときに用いられます。</p></div><div class="literalblock programlisting"><div class=content><pre>@               IN MX   10      mail.example.org.</pre></div></div><div class=paragraph><p><code>MX</code> レコードは、 ゾーンに対してどのメールサーバがやってきたメールを扱うことに責任を持っているかを示します。 <code>mail.example.org</code> はメールサーバのホスト名で、10 はメールサーバの優先度を示します。</p></div><div class=paragraph><p>優先度が 3,2 または 1 などのメールサーバをいくつも置くことができます。 <code>example.org</code> へ送ろうとしているメールサーバははじめに一番優先度の高いメールサーバに接続しようとします。 そして接続できない場合、二番目に優先度の高いサーバに接続しようとし、 以下、メールが適切に配送されるまで同様に繰り返します。</p></div><div class=paragraph><p>in-addr.arpa ゾーンファイル (逆引き DNS) に対しても <code>A</code> または <code>CNAME</code> の代わりに <code>PTR</code> エントリが用いられることを除けば、 同じ書式が使われます。</p></div><div class="literalblock programlisting"><div class=content><pre>$TTL 3600

1.2.3.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        3600 )          ; Minimum

@       IN NS   ns1.example.org.
@       IN NS   ns2.example.org.

2       IN PTR  ns1.example.org.
3       IN PTR  ns2.example.org.
10      IN PTR  mail.example.org.
30      IN PTR  example.org.</pre></div></div><div class=paragraph><p>このファイルは上記の架空のドメインの IP アドレスからホスト名への対応を与えます。</p></div></div></div><div class=sect3><h4 id=_キャッシュネームサーバ>20.11.7. キャッシュネームサーバ<a class=anchor href=#_キャッシュネームサーバ></a></h4><div class=paragraph><p>キャッシュネームサーバはどのゾーンに対しても権威をもたないネームサーバです。 キャッシュネームサーバは単に自分で問い合わせをし、 後で使えるように問い合わせの結果を覚えておきます。 これを設定するには、ゾーンを何も含まずに、 通常通りネームサーバを設定してください。</p></div></div><div class=sect3><h4 id=network-named-sandbox>20.11.8. 砂場で named を実行する<a class=anchor href=#network-named-sandbox></a></h4><div class=paragraph><p>セキュリティを強めるために <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> を非特権ユーザで実行し、 砂場のディレクトリ内に <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> して実行したいと思うかもしれません。 こうすると named デーモンは砂場の外にはまったく手を出すことができません。 named が乗っ取られたとしても、 これによって起こりうる損害が小さくなるでしょう。 FreeBSD にはデフォルトで、そのための <code>bind</code> というユーザとグループがあります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>多くの人々は named を <code>chroot</code> するように設定する代わりに、 <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 環境内で named を実行することを奨めるでしょう。 この節ではそれは扱いません。</p></div></td></tr></tbody></table></div><div class=paragraph><p>named は砂場の外 (共有ライブラリ、ログソケットなど) にアクセスできないので、 named を正しく動作させるためにいくつもの段階を経る必要があります。 下記のチェックリストにおいては、砂場のパスは <span class=filename>/etc/namedb</span> で、 このディレクトリの内容には何も手を加えていないと仮定します。 <code>root</code> 権限で次のステップを実行してください。</p></div><div class=ulist><ul><li><p>named が存在することを期待しているディレクトリをすべて作成します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/namedb</span>
<span class=c># mkdir -p bin dev etc var/tmp var/run master slave</span>
<span class=c># chown bind:bind slave var/* </span><i class=conum data-value=1></i><b>(1)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>これらのディレクトリに対して named が必要なのは書き込み権限だけなので、それだけを与えます。</td></tr></tbody></table></div></li><li><p>基本ゾーンファイルと設定ファイルの編集と作成を行います。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/localtime etc </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># mv named.conf etc &amp;&amp; ln -sf etc/named.conf</span>
<span class=c># mv named.root master</span>

<span class=c># sh make-localhost &amp;&amp; mv localhost.rev localhost-v6.rev master</span>
<span class=c># cat &gt; master/named.localhost</span>
<span class=nv>$ORIGIN</span> localhost.
<span class=nv>$TTL</span> 6h
@	IN	SOA	localhost. postmaster.localhost. <span class=o>(</span>
			1	<span class=p>;</span> serial
			3600	<span class=p>;</span> refresh
			1800	<span class=p>;</span> retry
			604800	<span class=p>;</span> expiration
			3600 <span class=o>)</span>	<span class=p>;</span> minimum
	IN	NS	localhost.
	IN	A		127.0.0.1
^D</code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>これは named が <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> に正しい時刻でログを書き込むことを可能にします。</td></tr></tbody></table></div></li><li><p>4.9-RELEASE より前のバージョンの FreeBSD を使用している場合、 静的リンクされた named-xfer を構築し、砂場にコピーしてください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/lib/libisc</span>
<span class=c># make cleandir &amp;&amp; make cleandir &amp;&amp; make depend &amp;&amp; make all</span>
<span class=c># cd /usr/src/lib/libbind</span>
<span class=c># make cleandir &amp;&amp; make cleandir &amp;&amp; make depend &amp;&amp; make all</span>
<span class=c># cd /usr/src/libexec/named-xfer</span>
<span class=c># make cleandir &amp;&amp; make cleandir &amp;&amp; make depend &amp;&amp; make NOSHARED=yes all</span>
<span class=c># cp named-xfer /etc/namedb/bin &amp;&amp; chmod 555 /etc/namedb/bin/named-xfer</span><i class=conum data-value=1></i><b>(1)</b></code></pre></div></div><div class=paragraph><p>静的リンクされた <code>named-xfer</code> をインストールしたら、 ソースツリーの中にライブラリまたはプログラムの古くなったコピーを残さないように、 掃除する必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/lib/libisc</span>
<span class=c># make cleandir</span>
<span class=c># cd /usr/src/lib/libbind</span>
<span class=c># make cleandir</span>
<span class=c># cd /usr/src/libexec/named-xfer</span>
<span class=c># make cleandir</span></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>このステップは時々失敗することが報告されています。 もし失敗した場合、次のコマンドを実行してください。そして <span class=filename>/usr/obj</span> ツリーを削除します。これはソースツリーからすべての "がらくた" を一掃します。 もう一度上記の手順を行うと、今度はうまく動作するでしょう。<div class=paragraph><p>バージョン 4.9-RELEASE 以降の FreeBSD を使用している場合 <span class=filename>/usr/libexec</span> にある <code>named-xfer</code> のコピーはデフォルトで静的リンクされています。 砂場にコピーするために単純に <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a> が使えます。</p></div></td></tr></tbody></table></div></li><li><p>named が見ることができ、 書き込むことのできる <span class=filename>dev/null</span> を作成します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/namedb/dev &amp;&amp; mknod null c 2 2</span>
<span class=c># chmod 666 null</span></code></pre></div></div></li><li><p><span class=filename>/etc/namedb/var/run/ndc</span> から <span class=filename>/var/run/ndc</span> へのシンボリックリンクを作成します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -sf /etc/namedb/var/run/ndc /var/run/ndc</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>これは単に <a href="https://man.freebsd.org/cgi/man.cgi?query=ndc&amp;sektion=8&amp;format=html">ndc(8)</a> を実行するたびに <code>-c</code> オプションを指定しなくてもよいようにするだけです。 /var/run の中身は起動時に削除されるため、 これが有用だと思うなら、このコマンドをルートの crontab に <code>@reboot</code> オプションを指定して追加してください。 詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> を参照してください。</p></div></td></tr></tbody></table></div></li><li><p>named が書き込める追加の <span class=filename>log</span> ソケットを作成するように <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> を設定します。 これを行うためには、<span class=filename>/etc/rc.conf</span> 内の <code>syslogd_flags</code> 変数に <code>-l /etc/namedb/dev/log</code> を加えてください。</p></li><li><p>次の行を <span class=filename>/etc/rc.conf</span> に加えて named が起動し、 自身を砂場内に <code>chroot</code> するように調整します</p><div class="literalblock programlisting"><div class=content><pre>named_enable=&#34;YES&#34;
named_flags=&#34;-u bind -g bind -t /etc/namedb /etc/named.conf&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>設定ファイル <em>/etc/named.conf</em> は <em>砂場のディレクトリに対して相対的な</em> フルパスで表されることに注意してください。 つまり、上記の行で示されたファイルは実際には <span class=filename>/etc/namedb/etc/named.conf</span> です。</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>次のステップは named がどのゾーンを読み込むか、 そしてディスク上のどこにゾーンファイルがあるのかを知るために <span class=filename>/etc/namedb/etc/named.conf</span> を編集することです。 下記に例をコメントを加えて示します (ここで特にコメントされていない内容については、 砂場の中で動作させない DNS サーバの設定と同じです)。</p></div><div class="literalblock programlisting"><div class=content><pre>options {
        directory &#34;/&#34;;<i class=conum data-value=1></i><b>(1)</b>
        named-xfer &#34;/bin/named-xfer&#34;;<i class=conum data-value=2></i><b>(2)</b>
        version &#34;&#34;;		// Don&#39;t reveal BIND version
        query-source address * port 53;
};
// ndc control socket
controls {
        unix &#34;/var/run/ndc&#34; perm 0600 owner 0 group 0;
};
// Zones follow:
zone &#34;localhost&#34; IN {
        type master;
        file &#34;master/named.localhost&#34;;<i class=conum data-value=3></i><b>(3)</b>
        allow-transfer { localhost; };
        notify no;
};
zone &#34;0.0.127.in-addr.arpa&#34; IN {
        type master;
        file &#34;master/localhost.rev&#34;;
        allow-transfer { localhost; };
        notify no;
};
zone &#34;0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.int&#34; {
	type master;
	file &#34;master/localhost-v6.rev&#34;;
	allow-transfer { localhost; };
	notify no;
};
zone &#34;.&#34; IN {
        type hint;
        file &#34;master/named.root&#34;;
};
zone &#34;private.example.net&#34; in {
        type master;
        file &#34;master/private.example.net.db&#34;;
	allow-transfer { 192.168.10.0/24; };
};
zone &#34;10.168.192.in-addr.arpa&#34; in {
        type slave;
        masters { 192.168.10.2; };
        file &#34;slave/192.168.10.db&#34;;<i class=conum data-value=4></i><b>(4)</b>
};</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>directory</code> は <span class=filename>/</span> を指定します。 named が必要とするファイルはすべてこのディレクトリにあります。 (この指定は "通常の" (訳注: 砂場内で動作させない) ユーザにとっての <span class=filename>/etc/namedb</span> と等価です)。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td><code>named-xfer</code> バイナリへの (named にとっての) フルパスを指定します。 named はデフォルトで <code>named-xfer</code> を <span class=filename>/usr/libexec</span> から探すようにコンパイルされているので、これが必要です</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>このゾーンに対するゾーンファイルを named が見つけられるようにファイル名を (上記と同様に <code>directory</code> からの相対パスで) 指定します。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>このゾーンに対するゾーン情報がマスタサーバからが転送されたあとに、 named がゾーンファイルのコピーを書き込むファイル名を (上記と同様に <code>directory</code> からの相対パスで) 指定します。これが、上記のように設定段階で <span class=filename>slave</span> ディレクトリの所有者を <code>bind</code> に変更する理由です。</td></tr></tbody></table></div><div class=paragraph><p>上記のステップを完了したら、サーバを再起動するか <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> を再起動し、<a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> を起動してください。その際、 <code>syslogd_flags</code> および <code>named_flags</code> に新たに指定したオプションが有効になっていることを確かめてください。 これで named を砂場のなかで動作させることができているはずです!</p></div></div><div class=sect3><h4 id=_セキュリティ>20.11.9. セキュリティ<a class=anchor href=#_セキュリティ></a></h4><div class=paragraph><p>BIND は DNS の最も一般的な実装ではありますが、 常にセキュリティ問題を抱えています。 問題になり得る、また悪用可能なセキュリティホールが時々みつかります。</p></div><div class=paragraph><p>現在のインターネットおよび FreeBSD のセキュリティ問題について常に最新の情報を得るために <a href=http://www.cert.org/>CERT</a> および <a href=./#eresources-mail>freebsd-security-notifications</a> を購読するとよいでしょう。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>問題が生じたとしても、 最新のソースからビルドした named を用意しておけば、 問題にならないかもしれません。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_さらなる情報源>20.11.10. さらなる情報源<a class=anchor href=#_さらなる情報源></a></h4><div class=paragraph><p>BIND/named のマニュアルページ: <a href="https://man.freebsd.org/cgi/man.cgi?query=ndc&amp;sektion=8&amp;format=html">ndc(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=named.conf&amp;sektion=8&amp;format=html">named.conf(8)</a></p></div><div class=ulist><ul><li><p><a href=http://www.isc.org/products/BIND/>ISC Bind 公式ページ</a></p></li><li><p><a href="http://www.nominum.com/getOpenSourceResource.php?id=6">BIND FAQ</a></p></li><li><p><a href=http://www.oreilly.com/catalog/dns4/>O’Reilly DNS and BIND 4th Edition</a></p></li><li><p><a href=ftp://ftp.isi.edu/in-notes/rfc1034.txt>RFC1034 - Domain Names - Concepts and Facilities</a> (ドメイン名、その概念と基盤)</p></li><li><p><a href=ftp://ftp.isi.edu/in-notes/rfc1035.txt>RFC1035 - Domain Names - Implementation and Specification</a> (ドメイン名、その実装と仕様)</p></li></ul></div></div></div><div class=sect2><h3 id=network-ntp>20.12. NTP<a class=anchor href=#network-ntp></a></h3><div class=sect3><h4 id=_概説>20.12.1. 概説<a class=anchor href=#_概説></a></h4><div class=paragraph><p>時間の経過とともに、コンピュータの時計はずれてしまいがちです。 時間が経つと、コンピュータの時計は正確でなくなってゆきます。 NTP (Network Time Protocol) は時計が正確であることを保証する方法の一つです。</p></div><div class=paragraph><p>インターネットサービスの多くは、 コンピュータの時計が正確であることに依存しているか、 あるいは多くを負っています。 たとえば web サーバ は、 あるファイルがある時刻以降に修正されていたらそのファイルを送ってほしいという要求を受け取るかもしれません。 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> のようなサービスは所定の時間にコマンドを実行します。 時計が正確でない場合、 これらのコマンドは期待したとおりには実行されないかもしれません。</p></div><div class=paragraph><p>FreeBSD は <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> NTP サーバを搭載しています。これは、 マシンの時計を合わせるために他の NTP サーバに問い合わせをしたり、 他のマシンに対して時刻を報じるために使用できます。</p></div></div><div class=sect3><h4 id=_適切な_ntp_サーバの選択>20.12.2. 適切な NTP サーバの選択<a class=anchor href=#_適切な_ntp_サーバの選択></a></h4><div class=paragraph><p>時刻を同期するために利用する NTP サーバを、 一つ以上見つける必要があります。 ネットワーク管理者、または ISP はこの目的のために NTP サーバを設定しているかもしれません - 本当にそうなのか確かめるためにドキュメントを確認してください。 あなたの近くの NTP サーバを探せる <a href=http://www.eecis.udel.edu/~mills/ntp/servers.html>公にアクセス可能な NTP サーバのリスト</a> があります。 どのサーバを選択するとしても、そのサーバの運営ポリシを理解し、 要求されているなら利用許可を求めることを忘れないでください。</p></div><div class=paragraph><p>使用しているサーバのうちのどれかが到達不能になるか、 その時計の信頼性が低い場合、無関係の NTP サーバをいくつか選択するとよいでしょう。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> は他のサーバから受け取った応答を賢く利用します - 信頼できないサーバより信頼できるサーバを重視します。</p></div></div><div class=sect3><h4 id=_マシンの設定>20.12.3. マシンの設定<a class=anchor href=#_マシンの設定></a></h4><div class=sect4><h5 id=_基本設定>20.12.3.1. 基本設定<a class=anchor href=#_基本設定></a></h5><div class=paragraph><p>マシンが起動するときだけ時計を同期させたい場合は <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> が使えます。頻繁に再起動され、 たまに同期すれば十分なデスクトップマシンには適切かもしれません。 しかしほとんどのマシンでは <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> を実行するべきです。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> を動かしているマシンでも、起動時に <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> を使用するのはよい考えです。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> プログラムは時計を徐々に変更します。しかし <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> は正しい時刻と現在設定されているマシンの時刻がどんなに離れていようとも時計を設定します。</p></div><div class=paragraph><p>起動時に <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> を有効にするためには、 <code>ntpdate_enable="YES"</code> を <span class=filename>/etc/rc.conf</span> に追加してください。 さらに、同期したいすべてのサーバおよび、<a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> に渡すあらゆるフラグを <code>ntpdate_flags</code> に指定する必要があるでしょう。</p></div></div><div class=sect4><h5 id=_一般設定>20.12.3.2. 一般設定<a class=anchor href=#_一般設定></a></h5><div class=paragraph><p>NTP は <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a> に記述された書式の <span class=filename>/etc/ntp.conf</span> ファイルによって設定されます。 簡単な例を以下に示します。</p></div><div class="literalblock programlisting"><div class=content><pre>server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift</pre></div></div><div class=paragraph><p><code>server</code> オプションは、 使用するサーバを一行に一つずつ指定します。サーバが上記の <code>ntplocal.example.com</code> のように <code>prefer</code> 引数とともに指定された場合、 このサーバは他のサーバより優先されます。 優先されたサーバからの応答は、 他のサーバの応答と著しく異なる場合は破棄されますが、 そうでなければ他の応答を考慮することなく使用されます。 <code>prefer</code> 引数は、通常、 特別な時間モニタハードウェアを備えているような非常に正確であるとされている NTP サーバに対して使用されます。</p></div><div class=paragraph><p><code>driftfile</code> オプションはシステム時計の周波数オフセットを格納するために使用するファイルを指定します。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> プログラムは、 時計の自然変動を自動的に補正するためにこれを用います。 これにより、一定時間外部の時刻ソースから切り離されたとしても、 十分正確な時刻を維持することを可能にします。</p></div><div class=paragraph><p><code>driftfile</code> オプションは、使用している NTP サーバから過去に受け取った応答に関する情報を格納するために、 どのファイルが使用されるか指定します。 このファイルは NTP に関する内部情報を含んでいます。 これは他のプロセスによって修正されてはいけません。</p></div></div><div class=sect4><h5 id=_サーバへのアクセス制御>20.12.3.3. サーバへのアクセス制御<a class=anchor href=#_サーバへのアクセス制御></a></h5><div class=paragraph><p>デフォルトでは NTP サーバはインターネット上のすべてのホストからアクセスが可能です。 <span class=filename>/etc/ntp.conf</span> 内で <code>restrict</code> オプションを指定することによって、 どのマシンがサーバにアクセスできるかを制御できるようにします。</p></div><div class=paragraph><p>NTP サーバにアクセスするマシンのすべてを拒否したいのなら、 以下の行を <span class=filename>/etc/ntp.conf</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>restrict default ignore</pre></div></div><div class=paragraph><p>あなたのネットワーク内のマシンにだけサーバに接続して時計を同期することを認めたいが、 それらからサーバに対して設定を行うのを許さず、 同期する端末としても利用されないようにしたいのなら、 以下を加えてください。</p></div><div class="literalblock programlisting"><div class=content><pre>restrict 192.168.1.0 mask 255.255.255.0 notrust nomodify notrap</pre></div></div><div class=paragraph><p><code>192.168.1.0</code> をあなたのネットワークの IP アドレスに <code>255.255.255.0</code> をあなたのネットワークのネットマスクに置き換えてください。</p></div><div class=paragraph><p><span class=filename>/etc/ntp.conf</span> には複数の <code>restrict</code> オプションを置けます。 詳細に付いては <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a> の <code>Access Control Support</code> サブセクションを参照してください。</p></div></div></div><div class=sect3><h4 id=_ntp_サーバの実行>20.12.4. NTP サーバの実行<a class=anchor href=#_ntp_サーバの実行></a></h4><div class=paragraph><p>NTP サーバが起動時に実行されることを保証するために、 <code>xntpd_enable="YES"</code> を <span class=filename>/etc/rc.conf</span> に加えてください。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> にフラグを追加したい場合は <span class=filename>/etc/rc.conf</span> 内の <code>xntpd_flags</code> パラメータを編集してください。</p></div><div class=paragraph><p>マシンを再起動することなくサーバを実行したいときは、 <span class=filename>/etc/rc.conf</span> 内の <code>xntpd_flags</code> で追加されたパラメータをすべて指定して <code>ntpd</code> を実行してください。以下に例を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ntpd -p /var/run/ntpd.pid</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.X では <span class=filename>/etc/rc.conf</span> 内のさまざまなオプションの名前が変わりました。 したがって、上記の <code>xntpd</code> に関するオプションは <code>ntpd</code> に置き換えてください。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_一時的なインターネット接続で_ntpd_を使用する>20.12.5. 一時的なインターネット接続で ntpd を使用する<a class=anchor href=#_一時的なインターネット接続で_ntpd_を使用する></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> プログラムは正しく機能するために、 インターネットへの常時接続を必要としません。しかしながら、 オンデマンドでダイアルアップされるように設定された一時的な接続の場合、 NTP トラフィックがダイアルを引き起こしたり、 接続を維持し続けるようなことを避けるようにした方がよいでしょう。 ユーザ PPP を使用している場合、以下の例のように <span class=filename>/etc/ppp/ppp.conf</span> 内で <code>filter</code> ディレクティブが使用できます。</p></div><div class="literalblock programlisting"><div class=content><pre> set filter dial 0 deny udp src eq 123
 # Prevent NTP traffic from initiating dial out
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Prevent incoming NTP traffic from keeping the connection open
 set filter alive 1 deny udp dst eq 123
 # Prevent outgoing NTP traffic from keeping the connection open
 set filter alive 2 permit 0/0 0/0</pre></div></div><div class=paragraph><p>詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 内の <code>PACKET FILTERING</code> セクション、および <span class=filename>/usr/shared/examples/ppp/</span> 内の例を参照してください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>小さい番号のポートをブロックするインターネットアクセスプロバイダでは、 応答があなたのマシンに到達しないので NTP がきちんと動作しない場合もあります。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_さらなる情報源_2>20.12.6. さらなる情報源<a class=anchor href=#_さらなる情報源_2></a></h4><div class=paragraph><p>NTP サーバに関する文書は HTML 形式で <span class=filename>/usr/shared/doc/ntp/</span> にあります。</p></div></div></div><div class=sect2><h3 id=network-natd>20.13. ネットワークアドレス変換 (NAT)<a class=anchor href=#network-natd></a></h3><div class=sect3><h4 id=network-natoverview>20.13.1. 概要<a class=anchor href=#network-natoverview></a></h4><div class=paragraph><p>一般に <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> として知られている FreeBSD ネットワークアドレス変換デーモンは、 raw IP パケットを受信して、 ソースアドレスをローカルマシンに変更し、 そのパケットを外向きの IP パケットの流れに再注入するデーモンです。 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> は、 データが戻ってきたときに、データの本来の場所を判別し、 もともと要求した相手へデータを返すことができるようにソース IP アドレスとポートを変更します。</p></div><div class=paragraph><p>NAT の最も一般的な使用法は、 一般的にはインターネット接続共有として知られているものを実行することです。</p></div></div><div class=sect3><h4 id=network-natsetup>20.13.2. 設定<a class=anchor href=#network-natsetup></a></h4><div class=paragraph><p>IPv4 の IP 空間が足りなくなりつつあること、および、 ケーブルや DSL のような高速の加入者回線利用者の増加によって、 人々はますますインターネット接続を共有する手段を必要としています。 一つの接続および IP アドレスを通していくつものコンピュータを回線に接続する能力がある <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> が合理的な選択になります。</p></div><div class=paragraph><p>もっともよくあるのは、ユーザが 1 つの IP アドレスでケーブルまたは DSL 回線に接続されたマシンを持っており、 インターネットへのアクセスを LAN 経由でいくつかのコンピュータに提供するのに、 この接続されたコンピュータを使用したいという場合です。</p></div><div class=paragraph><p>そのためには、インターネットに接続されている FreeBSD マシンはゲートウェイとして動作しなければなりません。 このゲートウェイマシンは 2 つの NIC が必要です (1 つはインターネットルータへ接続するためで、もう 1 つは LAN に接続するためです)。 LAN 上のすべてのマシンはハブまたはスイッチを通して接続されます。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/natd.png alt=ネットワークレイアウト></div></div><div class=paragraph><p>インターネット接続を共有するために、 このような設定がよく使用されています。 LAN 内のマシンの 1 台がインターネットに接続しています。 残りのマシンはその "ゲートウェイ" マシンを通してインターネットにアクセスします。</p></div></div><div class=sect3><h4 id=network-natdkernconfiguration>20.13.3. 設定<a class=anchor href=#network-natdkernconfiguration></a></h4><div class=paragraph><p>次のオプションがカーネルコンフィギュレーションファイルに必要です。</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL
options IPDIVERT</pre></div></div><div class=paragraph><p>さらに、次のオプションを入れてもよいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</pre></div></div><div class=paragraph><p>下記の設定を <span class=filename>/etc/rc.conf</span> で行わなければなりません。</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
firewall_enable=&#34;YES&#34;
firewall_type=&#34;OPEN&#34;
natd_enable=&#34;YES&#34;
natd_interface=&#34;fxp0&#34;
natd_flags=&#34;&#34;</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gateway_enable="YES"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>マシンがゲートウェイとして動作するように設定します。 <code>sysctl net.inet.ip.forwarding=1</code> コマンドを実行しても同じ効果がえられます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>firewall_enable="YES"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/rc.firewall</span> にあるファイアウォールルールを起動時に有効にします。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>firewall_type="OPEN"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>これはあらかじめ定義されている、 すべてのパケットを通すファイアウォールルールセットを指定します。 他のタイプについては <span class=filename>/etc/rc.firewall</span> を参照してください。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>natd_interface="fxp0"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>パケットを転送するインタフェースを指定します (インターネットに接続されたインタフェース)。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>natd_flags=""</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>起動時に <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> に渡される追加の引数</p></td></tr></tbody></table><div class=paragraph><p><span class=filename>/etc/rc.conf</span> に前述したオプションを定義すると、起動時に <code>natd -interface fxp0</code> が実行されます。 これは手動でも実行できます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>オプションの定義に <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> のコンフィグレーションファイルを使うこともできます。 この場合には、<span class=filename>/etc/rc.conf</span> に以下の行を追加し、 コンフィグレーションファイルを定義してください。</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class=paragraph><p><span class=filename>/etc/natd.conf</span> ファイルでは、一行ごとにオプションを設定します。たとえば、 次節の例では以下のような行を含むファイルを用意してください。</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>コンフィグレーションファイルに関する、より詳細な情報については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> マニュアルページの <code>-f</code> オプションを調べてください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>LAN にぶら下がっているマシンおよびインタフェースのそれぞれには <a href=ftp://ftp.isi.edu/in-notes/rfc1918.txt>RFC 1918</a> で定義されているプライベートネットワーク空間の IP アドレス番号を割り当て、デフォルトゲートウェイアドレスを natd マシンの内側の IP アドレスにすべきです。</p></div><div class=paragraph><p>たとえば LAN 側のクライアント <code>A</code> および <code>B</code> は IP アドレス <code>192.168.0.2</code> および <code>192.168.0.3</code> を割り当てられており、 natd マシンの LAN インタフェースは IP アドレス <code>192.168.0.1</code> を割り当てられています。 クライアント <code>A</code> および <code>B</code> のデフォルトゲートウェイは natd マシンの <code>192.168.0.1</code> に設定されなければなりません。 natd マシンの外部、 またはインターネットインタフェースは <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> の動作に際して特別の修正を必要としません。</p></div></div><div class=sect3><h4 id=network-natdport-redirection>20.13.4. ポート転送<a class=anchor href=#network-natdport-redirection></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> の短所は、インターネットから LAN 内のクライアントにアクセスできないということです。 LAN 内のクライアントは外部に向けて接続を行うことはできますが、 入って来るものを受け取ることができません。これは、LAN クライアントのどれかでインターネットサービスを動かそうとした場合に、 問題になります。これを何とかする単純な方法は natd マシンから LAN クライアントへ、 選択したインターネットポートを転送することです。</p></div><div class=paragraph><p>たとえばクライアント <code>A</code> で実行されている IRC サーバがあり、 クライアント <code>B</code> 上で実行されている web サーバがあるとします。 これが正しく動作するには、ポート 6667 (IRC) および 80 (web) への接続を対応するマシンに転送しなければなりません。</p></div><div class=paragraph><p><code>-redirect_port</code> に適切なオプションを加えて <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> に渡さなければなりません。 書式は以下のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>上記の例では、引数は以下のようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>これで適切な <em>tcp</em> ポートが LAN クライアントマシンに転送されます。</p></div><div class=paragraph><p><code>-redirect_port</code> 引数は個々のポートを対応させるポート範囲を示すのに使えます。 たとえば <em>tcp 192.168.0.2:2000-3000 2000-3000</em> は 2000 番から 3000番ポートに受け取られたすべての接続を、 クライアント <code>A</code> 上の 2000 番から 3000 番に転送します。</p></div><div class=paragraph><p>これらのオプションは <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> を直接実行するか、 <span class=filename>/etc/rc.conf</span> 内の <code>natd_flags=""</code> オプションで設定するか、 もしくはコンフィグレーションファイルから渡してください。</p></div><div class=paragraph><p>設定オプションの詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> をご覧ください。</p></div></div><div class=sect3><h4 id=network-natdaddress-redirection>20.13.5. アドレス転送<a class=anchor href=#network-natdaddress-redirection></a></h4><div class=paragraph><p>複数の IP アドレスが利用可能ですが、 それらが 1 台のマシン上になければならないときには、 アドレス転送が便利です。 これを用いれば <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> は LAN クライアントのそれぞれに外部 IP アドレスを割り当てることができます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> は LAN クライアントから外部へ出て行くパケットを適切な外部の IP アドレスで書き直し、 そして特定の IP アドレスに対してやって来るトラフィックのすべてを、 指定された LAN クライアントに転送します。 これは静的 NAT としても知られています。 たとえば <code>128.1.1.1</code>, <code>128.1.1.2</code> および <code>128.1.1.3</code> の IP アドレスが、 natd ゲートウェイマシンに属しているとします。 <code>128.1.1.2</code> および <code>128.1.1.3</code> は LAN クライアントの <code>A</code> および <code>B</code> に転送される一方で、<code>128.1.1.1</code> は natd ゲートウェイマシンの外部 IP アドレスとして使用することができます。</p></div><div class=paragraph><p><code>-redirect_address</code> の書式は以下のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address localIP publicIP</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>localIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>LAN クライアントの内部 IP アドレス</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>publicIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>LAN クライアントに対応する外部 IP アドレス</p></td></tr></tbody></table><div class=paragraph><p>上記の例では引数は以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p><code>-redirect_port</code> と同様に、これらの引数は <span class=filename>/etc/rc.conf</span> 内の <code>natd_flags=""</code> オプションで設定するか、 コンフィグレーションファイルから渡すことで指定できます。 アドレス転送では、 特定の IP アドレスで受け取られたデータはすべて転送されるので、 port 転送は必要ありません。</p></div><div class=paragraph><p>natd マシン上の外部 IP アドレスは、 アクティブで外部インタフェースにエイリアスされていなければなりません。 やりかたは <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> を参照してください。</p></div></div></div><div class=sect2><h3 id=network-inetd>20.14. inetd"スーパサーバ"<a class=anchor href=#network-inetd></a></h3><div class=sect3><h4 id=network-inetd-overview>20.14.1. 概観<a class=anchor href=#network-inetd-overview></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> は複数のデーモンに対する接続を制御するので、 "インターネットスーパサーバ" と呼ばれます。 ネットワークサービスを提供するプログラムは、 一般的にデーモン呼ばれます。inetd は他のデーモンを管理するサーバを努めます。 接続が inetd によって受け付けられると、 inetd は接続がどのデーモンに対するものか判断して、 そのデーモンを起動し、ソケットを渡します。 inetd を 1 つ実行することにより、 それぞれのデーモンをスタンドアロンモードで実行することに比べ、 全体としてのシステム負荷を減らします。</p></div><div class=paragraph><p>基本的に、inetd は他のデーモンを起動するために使用されます。しかし、 chargen, auth および daytime のようなささいなプロトコルは直接扱われます。</p></div><div class=paragraph><p>この節ではコマンドラインオプションおよび設定ファイル <span class=filename>/etc/inetd.conf</span> による inetd の設定の基本を説明します。</p></div></div><div class=sect3><h4 id=network-inetd-settings>20.14.2. 設定<a class=anchor href=#network-inetd-settings></a></h4><div class=paragraph><p>inetd は <span class=filename>/etc/rc.conf</span> の仕組によって初期化されます。 デフォルトでは <code>inetd_enable</code> オプションは "NO" に設定されています。 しかし多くの場合、sysinstall でセキュリティプロファイルを medium に設定することにより、有効化されます。</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>または</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>を <span class=filename>/etc/rc.conf</span> に置くことで、起動時に inetd を有効または無効にできます。</p></div><div class=paragraph><p>さらに <code>inetd_flags</code> オプションによって、 いろいろなコマンドラインオプションを inetd に渡すことができます。</p></div></div><div class=sect3><h4 id=network-inetd-cmdline>20.14.3. コマンドラインオプション<a class=anchor href=#network-inetd-cmdline></a></h4><div class=paragraph><p>inetd 書式</p></div><div class=paragraph><p><code>inetd [-d] [-l] [-w] [-W] [-c maximum] [-C rate] [-a address | hostname] [-p filename] [-R rate] [configuration file]</code></p></div><div class=dlist><dl><dt class=hdlist1>-d</dt><dd><p>デバッグモードにします。</p></dd><dt class=hdlist1>-l</dt><dd><p>成功した接続のログをとります。</p></dd><dt class=hdlist1>-w</dt><dd><p>外部サービスに対して TCP Wrapper を有効にします (デフォルト)。</p></dd><dt class=hdlist1>-W</dt><dd><p>inetd 組み込みの内部サービスに対して TCP Wrapper を有効にします (デフォルト)。</p></dd><dt class=hdlist1>-c maximum</dt><dd><p>サービス毎に同時に起動可能な最大値のデフォルトを指定します。 デフォルトでは無制限です。サービスごとに指定する <code>max-child</code> パラメータで上書きできます。</p></dd><dt class=hdlist1>-C rate</dt><dd><p>1 分間にひとつの IP アドレスから起動されるサービスの、 最大値のデフォルトを指定します。デフォルトは無制限です。 サービスごとに指定する <code>max-connections-per-ip-per-minute</code> パラメータで上書きできます。</p></dd><dt class=hdlist1>-R rate</dt><dd><p>あるサービスを 1 分間に起動できる最大の数を指定します。 デフォルトは 256 です。rate に 0 を指定すると、 起動可能な数は無制限になります。</p></dd><dt class=hdlist1>-a</dt><dd><p>バインドする IP アドレスを一つ指定します。 代わりにホスト名も指定できます。この場合、ホスト名に対応する IPv4 または IPv6 アドレスが使用されます。通常 inetd が <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 内で起動される時点で、ホスト名が指定されます。この場合、 ホスト名は <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 環境に対応するものです。</p><div class=paragraph><p>ホスト名指定が使用され、 IPv4 および IPv6 両方にバインドしたい場合、 <span class=filename>/etc/inetd.conf</span> の各サービスに対して、 各バインドに対する適切なプロトコルのエントリが必要です。 たとえば TCP ベースのサービスは、 ひとつはプロトコルに "tcp4" を使用し、 もう一つは "tcp6" を使用する、 2 つのエントリが必要です。</p></div></dd><dt class=hdlist1>-p</dt><dd><p>デフォルトとは異なる PID を保持するファイルを指定します。</p></dd></dl></div><div class=paragraph><p><span class=filename>/etc/rc.conf</span> 内の <code>inetd_flags</code> オプションを用いて、これらのオプションを inetd に渡すことができます。デフォルトでは <code>inetd_flags</code> は "-wW" に設定されており、 これは inetd の内部および外部サービスに対して TCP wrapper を有効にします。 初心者ユーザはこれらのパラメータを変更する必要は通常ありませんし、 <span class=filename>/etc/rc.conf</span> に入力する必要もありません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>外部サービスは、接続を受け取ったときに起動される inetd の外部にあるデーモンで、 それに対して、内部サービスは inetd 自身が提供する内部のデーモンです。</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=network-inetd-conf>20.14.4. <span class=filename>inetd.conf</span><a class=anchor href=#network-inetd-conf></a></h4><div class=paragraph><p>inetd の設定は <span class=filename>/etc/inetd.conf</span> ファイルによって制御されます。</p></div><div class=paragraph><p><span class=filename>/etc/inetd.conf</span> が変更されたときは、 以下のように inetd プロセスに HangUP シグナルを送ることにより、inetd に設定ファイルを再読み込みさせられます。</p></div><div id=network-inetd-hangup class=exampleblock><div class=title>例 47. inetd への HangUP シグナル送付</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/inetd.pid`</span></code></pre></div></div></div></div><div class=paragraph><p>設定ファイルのそれぞれの行は、 個々のデーモンについての指示になります。 ファイル内のコメントは "#" が先頭につきます。 <span class=filename>/etc/inetd.conf</span> の書式は以下のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]
user[:group][/login-class]
server-program
server-program-arguments</pre></div></div><div class=paragraph><p>IPv4 を利用する ftpd デーモンのエントリの例です。</p></div><div class="literalblock programlisting"><div class=content><pre>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</pre></div></div><div class=dlist><dl><dt class=hdlist1>service-name</dt><dd><p>これは特定のデーモンのサービス名です。 これは <span class=filename>/etc/services</span> 内のサービスリストに対応していなければなりません。 これは inetd がどのポートで受け付けなければならないかを決定します。 新しいサービスが作成された場合、まずはじめに <span class=filename>/etc/services</span> 内に記載しなければなりません。</p></dd><dt class=hdlist1>socket-type</dt><dd><p><code>stream</code>, <code>dgram</code>, <code>raw</code> または <code>seqpacket</code> のどれかを指定します。 <code>stream</code> はコネクションに基づいた TCP デーモンに使用しなければならず、 一方で <code>dgram</code> は UDP 転送プロトコルを利用したデーモンに対して使用されます。</p></dd><dt class=hdlist1>protocol</dt><dd><p>次のうちのどれか 1 つを指定します。</p><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">プロトコル</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp, tcp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp, udp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv4 および v6 の両方</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv4 および v6 の両方</p></td></tr></tbody></table></dd><dt class=hdlist1>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]</dt><dd><p><code>wait|nowait</code> は inetd から起動したデーモンが、 自分のソケットを管理できるかどうかを示します。 通常マルチスレッド化されている stream ソケットデーモンは <code>nowait</code> を使用するべきである一方、 <code>dgram</code> ソケットタイプは wait オプションを使用しなければなりません。 <code>nowait</code> は新しいソケット毎に子のデーモンを起動する一方で、 <code>wait</code> は通常複数のソケットを 1 つのデーモンに渡します。</p><div class=paragraph><p>inetd が起動できる子のデーモンの最大数は <code>max-child</code> オプションで設定できます。 特定のデーモンに対して、起動する数が 10 までという制限が必要な場合、 <code>nowait</code> の後に <code>/10</code> を置きます。</p></div><div class=paragraph><p><code>max-child</code> に加えて、他にある 1 つの場所から特定のデーモンへの最大接続数を制限するオプションが利用できます。 <code>max-connections-per-ip-per-minute</code> がそれです。ここに 10 を指定すると、特定の IP アドレスからの特定のサービスへの接続を 1 分間につき 10 回に制限します。 これは故意または故意でない資源の浪費および、 マシンへのサービス不能 (DoS) 攻撃を防ぐのに有用です。</p></div><div class=paragraph><p><code>wait</code> または <code>nowait</code> はこの欄に必ず必要です。 <code>max-child</code> および <code>max-connections-per-ip-per-minute</code> は任意です。</p></div><div class=paragraph><p><code>max-child</code> または <code>max-connections-per-ip-per-minute</code> 制限をかけない stream タイプのマルチスレッドデーモンの設定は <code>nowait</code> になります。</p></div><div class=paragraph><p>作成できる子プロセスの上限が 10 である同じデーモンの設定は <code>nowait/10</code> になります。</p></div><div class=paragraph><p>さらに、 1 分間に IP アドレスあたりの接続制限が 20、 子プロセスの上限が 10 である同じデーモンの設定は <code>nowait/10/20</code> になります。</p></div><div class=paragraph><p>以下のように、これらのオプションはすべて fingerd デーモンのデフォルト設定に使われています。</p></div><div class="literalblock programlisting"><div class=content><pre>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</pre></div></div></dd><dt class=hdlist1>user</dt><dd><p>user はあるデーモンが実行するときのユーザ名を指定します。 一般的にデーモンは <code>root</code> ユーザとして実行します。セキュリティを考慮して、 いくつかのサーバは <code>daemon</code> ユーザ、 または最低の権限が与えられている <code>nobody</code> ユーザとして実行することも多く見られます。</p></dd><dt class=hdlist1>server-program</dt><dd><p>接続を受け取ったときに実行するデーモンのフルパスです。 デーモンが inetd によって内部的に提供されるサービスの場合 <code>internal</code> を使用します。</p></dd><dt class=hdlist1>server-program-arguments</dt><dd><p>ここには、起動するときにデーモンに渡される、 argv[0] から始まる引数を指定して、 <code>server-program</code> と協調して動作します。 mydaemon -d がコマンドラインの場合、 <code>server program arguments</code> の値に <code>mydaemon -d</code> を指定します。 また、デーモンが内部サービスの場合、ここに <code>internal</code> を指定します。</p></dd></dl></div></div><div class=sect3><h4 id=network-inetd-security>20.14.5. セキュリティ<a class=anchor href=#network-inetd-security></a></h4><div class=paragraph><p>インストールの時に選択したセキュリティプロファイルによっては、 多くの inetd のデーモンがデフォルトで有効になっているかもしれません。 あるデーモンが特に必要でない場合には、それを無効にしてください! 問題となっているデーモンが記述されている行の先頭に "#" をおいて <a href=#network-inetd-hangup>inetd にハングアップシグナル</a>を送ってください。 fingerd のようないくつかのデーモンは、 動かそうとすべきではないかもしれません。なぜなら、 それらは攻撃者に対してあまりにも多くの情報を与えるからです。</p></div><div class=paragraph><p>セキュリティをあまり考慮せず、 接続試行に対してタイムアウトまでの時間が長いか、 タイムアウトしないデーモンもあります。 これは、特定のデーモンに攻撃者がゆっくり接続要求を送ることによって、 利用可能なリソースを飽和させることを可能にします。ある種のデーモンに <code>ip-per-minute</code> および <code>max-child</code> 制限を設けることはよい考えかもしれません。</p></div><div class=paragraph><p>TCP wrapper はデフォルトで有効です。 inetd から起動されるさまざまなデーモンに対して TCP 制限を設けることの詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> マニュアルページを参照してください。</p></div></div><div class=sect3><h4 id=network-inetd-misc>20.14.6. その他<a class=anchor href=#network-inetd-misc></a></h4><div class=paragraph><p>daytime, time, echo, discard, chargen および auth はすべて inetd が内部的に提供するサービスです。</p></div><div class=paragraph><p>auth サービスは identity (ident, identd) ネットワークサービスを提供し、 ある程度設定可能です。</p></div><div class=paragraph><p>詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> マニュアルを参照してください。</p></div></div></div><div class=sect2><h3 id=network-plip>20.15. パラレルライン IP (PLIP)<a class=anchor href=#network-plip></a></h3><div class=paragraph><p>PLIP はパラレルポート間で TCP/IP 通信を可能にします。 これはネットワークカードの無いマシンやノートパソコンにインストールするときに役に立ちます。 この節では以下について説明します。</p></div><div class=ulist><ul><li><p>パラレル (ラップリンク または パラレルクロス) ケーブルの作成。</p></li><li><p>2 台のコンピュータの PLIP による接続。</p></li></ul></div><div class=sect3><h4 id=network-create-parallel-cable>20.15.1. パラレル (クロス) ケーブルの作成<a class=anchor href=#network-create-parallel-cable></a></h4><div class=paragraph><p>コンピュータ用品店のほとんどでパラレル (クロス) ケーブルを購入することができます。 購入することができないか、 単にケーブルがどのような構造であるか知りたい場合は、 次の表に通常のパラレルプリンタケーブルをもとに作成する方法が示されています。</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>表 18. ネットワーク向けのパラレル (クロス) ケーブル結線</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">A-名称</th><th class="tableblock halign-left valign-top">A-端</th><th class="tableblock halign-left valign-top">B-端</th><th class="tableblock halign-left valign-top">説明</th><th class="tableblock halign-left valign-top">Post/Bit</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA0
-ERROR
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
2
15
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
15
2
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x01
1/0x08
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA1
+SLCT
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
3
13
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
13
3
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x02
1/0x10
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA2
+PE
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
4
12
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
12
4
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x04
1/0x20
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA3
-ACK
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
5
10
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
10
5
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Strobe</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x08
1/0x40
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA4
BUSY
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
6
11
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
11
6
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x10
1/0x80
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>GND</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>GND</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>-</pre></div></td></tr></tbody></table></div><div class=sect3><h4 id=network-plip-setup>20.15.2. PLIP の設定<a class=anchor href=#network-plip-setup></a></h4><div class=paragraph><p>はじめに、ラップリンクケーブルを入手しなければなりません。 次に、両方のコンピュータのカーネルが <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> ドライバ対応であることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep lp /var/run/dmesg.boot</span>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</code></pre></div></div><div class=paragraph><p>パラレルポートは割り込み駆動ポートでなければなりません。 FreeBSD 4.X では、 以下のような行がカーネルコンフィギュレーションファイル内になければならないでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>device ppc0 at isa? irq 7</pre></div></div><div class=paragraph><p>FreeBSD 5.X では <span class=filename>/boot/device.hints</span> ファイルに以下の行がなければならないでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>hint.ppc.0.at=&#34;isa&#34;
hint.ppc.0.irq=&#34;7&#34;</pre></div></div><div class=paragraph><p>それからカーネルコンフィギュレーションファイルに <code>device plip</code> という行があるか、または <span class=filename>plip.ko</span> カーネルモジュールが読み込まれていることを確認してください。 どちらの場合でも <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> コマンドを直接実行したときに、 パラレルネットワークインタフェースが現れるはずです。 FreeBSD 4.X ではこのようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lp0</span>
lp0: <span class=nv>flags</span><span class=o>=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</code></pre></div></div><div class=paragraph><p>FreeBSD 5.X ではこのようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0</span>
plip0: <span class=nv>flags</span><span class=o>=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>パラレルインタフェースに対して用いられるデバイス名は FreeBSD 4.X (<span class=filename>lpX</span>) と FreeBSD 5.X (<span class=filename>plipX</span>) 間で異なります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>両方のコンピュータのパラレルインタフェースにラップリンクケーブルを接続します。</p></div><div class=paragraph><p>両方のネットワークインタフェースパラメータを <code>root</code> で設定します。 たとえば、FreeBSD 4.X を動作させている <code>host1</code> と FreeBSD 5.X を動作させている <code>host2</code> の両ホストを接続したい場合は次のようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>                 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</pre></div></div><div class=paragraph><p>次のコマンドで <code>host1</code> 上のインタフェースを設定します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lp0 10.0.0.1 10.0.0.2</span></code></pre></div></div><div class=paragraph><p>次のコマンドで <code>host2</code> 上のインタフェースを設定します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig plip0 10.0.0.2 10.0.0.1</span></code></pre></div></div><div class=paragraph><p>さて、これで接続が確立したはずです。詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=lp&amp;sektion=4&amp;format=html">lp(4)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> マニュアルページをご覧ください。</p></div><div class=paragraph><p>さらに<span class=filename>/etc/hosts</span> に両ホストを加えるとよいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain</pre></div></div><div class=paragraph><p>接続がうまくいっているか確かめるために、 両方のホスト上で互いを ping してください。 たとえば <code>host1</code> で以下を実行します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lp0</span>
lp0: <span class=nv>flags</span><span class=o>=</span>8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 <span class=nt>--</span><span class=o>&gt;</span> 10.0.0.2 netmask 0xff000000
<span class=c># netstat -r</span>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       lp0
<span class=c># ping -c 4 host2</span>
PING host2 <span class=o>(</span>10.0.0.2<span class=o>)</span>: 56 data bytes
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.774 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.530 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.556 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.714 ms

<span class=nt>---</span> host2 ping statistics <span class=nt>---</span>
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 2.530/2.643/2.774/0.103 ms</code></pre></div></div></div></div><div class=sect2><h3 id=network-ipv6>20.16. IPv6<a class=anchor href=#network-ipv6></a></h3><div class=paragraph><p>IPv6 (IPng "IP next generation" とも呼ばれます) は、著名な IP プロトコル (IPv4 とも呼ばれます) の新しいバージョンです。 他の最新の *BSD システムと同様に FreeBSD は KAME IPv6 リファレンス実装を含んでいます。したがって、あなたの FreeBSD システムには IPv6を試すために必要なものすべてが備わっています。 この節では IPv6 の設定と実行に関して説明します。</p></div><div class=paragraph><p>1990 年代のはじめには、人々は IPv4 アドレス空間が急速に縮小していることに気づくようになりました。 インターネットの成長率が増大するにしたがって、 2 つの心配ごとがでてきました。</p></div><div class=ulist><ul><li><p>アドレスの枯渇。 今日では、プライベートアドレス空間 (<code>10.0.0.0/8</code>, <code>192.168.0.0/24</code> など) およびネットワークアドレス変換 (NAT) が使用されているので、それほど心配されていません。</p></li><li><p>ルーティングテーブルのエントリが大きくなりすぎていました。 これは今でも心配な事柄です。</p></li></ul></div><div class=paragraph><p>IPv6 は以下の、そしてその他多くの問題を扱います。</p></div><div class=ulist><ul><li><p>128 bit アドレス空間。言い換えると、理論上 340,282,366,920,938,463,463,374,607,431,768,211,456 個のアドレスが利用可能です。これは地球上の一平方メータあたり、 およそ 6.67 * 10^27 個の IPv6 アドレスがあることを意味します。</p></li><li><p>ルータは、 ルーティングテーブル内にネットワーク集約アドレスだけを格納することで、 ルーティングテーブルの平均を 8192 項目程度に減らします。</p></li></ul></div><div class=paragraph><p>他にも以下のように IPv6 の便利な機能がたくさんあります。</p></div><div class=ulist><ul><li><p>アドレス自動設定 (RFC2462)</p></li><li><p>エニーキャスト (anycast) アドレス ("one-out-of many" 訳注: 複数の異なるノードが応答する 1 つのアドレス。 RFC2526 を参照してください)。</p></li><li><p>強制マルチキャストアドレス</p></li><li><p>IPsec (IP セキュリティ)</p></li><li><p>シンプルなヘッダ構造</p></li><li><p>モバイル IP</p></li><li><p>IPv4 から IPv6 への移行手段</p></li></ul></div><div class=paragraph><p>詳細については下記を参照してください。</p></div><div class=ulist><ul><li><p><a href=http://www.sun.com>Sun.com</a> の IPv6 概観</p></li><li><p><a href=http://www.ipv6.org>IPv6.org</a></p></li><li><p><a href=http://www.kame.net>KAME.net</a></p></li><li><p><a href=http://www.6bone.net>6bone.net</a></p></li></ul></div><div class=sect3><h4 id=_ipv6_アドレスの背景>20.16.1. IPv6 アドレスの背景<a class=anchor href=#_ipv6_アドレスの背景></a></h4><div class=paragraph><p>いくつか違うタイプの IPv6 アドレスがあります。 ユニキャスト (Unicast)、エニーキャスト (Anycast) およびマルチキャスト (Multicast) です。</p></div><div class=paragraph><p>ユニキャストアドレスは周知のアドレスです。 ユニキャストアドレスへ送られたパケットは、 まさにそのアドレスに属するインターフェースに到着します。</p></div><div class=paragraph><p>エニーキャストアドレスはユニキャストアドレスと構文上判別不可能ですが、 インタフェース群に宛てられています。 エニーキャストアドレスに送られたパケットは (ルータメトリック的に) 最も近いインタフェースに到着します。 エニーキャストアドレスはルータでしか使ってはいけません。</p></div><div class=paragraph><p>マルチキャストアドレスはインタフェース群を識別します。 マルチキャストアドレスに送られたパケットは、 マルチキャスト群に属するすべてのインタフェースに到着します。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>IPv4 のブロードキャストアドレス (通常 <code>xxx.xxx.xxx.255</code>) は、IPv6 ではマルチキャストアドレスで表現されます。</p></div></td></tr></tbody></table></div><table class="tableblock frame-none grid-all stretch"><caption class=title>表 19. 予約された IPv6 アドレス</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">IPv6 アドレス</th><th class="tableblock halign-left valign-top">プレフィックス長 (ビット)</th><th class="tableblock halign-left valign-top">説明</th><th class="tableblock halign-left valign-top">備考</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>不特定</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 の <code>0.0.0.0</code> 参照</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ループバックアドレス</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 の <code>127.0.0.1</code> 参照</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 埋め込みアドレス</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>下位の 32 ビットは IPv4 アドレスです。 "IPv4 互換 IPv6 アドレス" とも呼ばれます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 射影 IPv6 アドレス</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>下位の 32 ビットは IPv4 アドレスです。 IPv6 に対応していないホストに対するアドレスです。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::</code> - <code>feb::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>リンクローカル</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 のループバックアドレス参照</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fec0::</code> - <code>fef::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>サイトローカル</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>マルチキャスト</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>001</code> (基数 2)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 ビット</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>グローバルユニキャスト</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>すべてのグローバルユニキャストアドレスはこのプールから割り当てられます。 はじめの 3 ビットは "001" です。</p></td></tr></tbody></table></div><div class=sect3><h4 id=_ipv6_アドレスを読む>20.16.2. IPv6 アドレスを読む<a class=anchor href=#_ipv6_アドレスを読む></a></h4><div class=paragraph><p>正規の書式では <code>x:x:x:x:x:x:x:x</code> と表されます。それぞれの "x" は 16 ビットの 16 進数です。たとえば <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code> となります。</p></div><div class=paragraph><p>すべてゼロの長い部分文字列がアドレス内によく現れます。 そのため、そのような部分文字列は "::" に短縮することができます。 たとえば、<code>fe80::1</code> は正規形の <code>fe80:0000:0000:0000:0000:0000:0000:0001</code> に対応します。</p></div><div class=paragraph><p>3 番目の形式は、最後の 32 ビットの部分を "." を分割文字として使う、 なじみ深い IPv4 (10 進) 形式で書くことです。 たとえば <code>2002::10.0.0.1</code> は (16 進) 正規形の <code>2002:0000:0000:0000:0000:0000:0a00:0001</code> に対応し、同時に <code>2002::a00:1</code> と書くこととも等価です。</p></div><div class=paragraph><p>ここまで来れば、下記を理解することができるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre></div></div><div class=paragraph><p><code>fe80::200:21ff:fe03:8e1%rl0</code> は自動的に設定されたリンクローカルアドレスです。 これは自動設定の一環として、 イーサネット MAC アドレスを変換したものを含んでいます。</p></div><div class=paragraph><p>IPv6 アドレス構造についての詳細は RFC3513 をご覧ください。</p></div></div><div class=sect3><h4 id=_接続>20.16.3. 接続<a class=anchor href=#_接続></a></h4><div class=paragraph><p>現在、他の IPv6 ホストおよびネットワークに接続するためには 4 つの方法があります。</p></div><div class=ulist><ul><li><p>6bone 実験ネットワークに参加する。</p></li><li><p>上流のプロバイダから IPv6 ネットワークの割り当てを受ける。 手順については、インターネットプロバイダに問い合わせてください。</p></li><li><p>IPv6 over IPv4 によるトンネル。</p></li><li><p>ダイアルアップ接続の場合 freenet6 port を使用する。</p></li></ul></div><div class=paragraph><p>ここでは、現在もっともよく使われている方法と思われる 6bone へ接続する方法を説明します。</p></div><div class=paragraph><p>はじめに 6bone サイトをみて、 あなたに最も近い 6bone 接続先を見つけてください。 責任者に連絡すると、少しばかり運がよければ、 接続を設定する方法についての指示を受けられるでしょう。 多くのばあい、これには GRE (gif) トンネルの設定が含まれます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>6bone は <code>3ffe::</code> (16 ビット) という IPv6 アドレスを割り振られた実験目的のネットワークでしたが、 2006 年 6 月に運用を停止することになっています。 他の商用や試験的な IPv6 接続サービスを探してください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ここに <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> トンネルを設定する典型的な例を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0</span>
gif0: <span class=nv>flags</span><span class=o>=</span>8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
<span class=c># ifconfig gif0 tunnel MY_IPv4_ADDR  HIS_IPv4_ADDR</span>
<span class=c># ifconfig gif0 inet6 alias MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</span></code></pre></div></div><div class=paragraph><p>大文字になっている単語を、 上流の 6bone ノードから受け取った情報に置き換えてください。</p></div><div class=paragraph><p>これでトンネルが確立されます。<a href="https://man.freebsd.org/cgi/man.cgi?query=ping6&amp;sektion=8&amp;format=html">ping6(8)</a> を <code>ff02::1%gif0</code> に送ることによって、トンネルが動作しているか確かめてください。 ping の応答を 2 つ受け取るはずです。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>ff02:1%gif0</code> というアドレスに興味をそそられている場合のために説明すると、 これはマルチキャストアドレスです。 <code>%gif0</code> は、ネットワークインタフェース <span class=filename>gif0</span> 上のマルチキャストアドレスが使用されるということを示しています。 マルチキャストアドレスに対して <code>ping</code> を送ったので、トンネルのもう一方の端も応答します。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ここまで来ると 6bone アップリンクに経路設定することは比較的簡単でしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -inet6 default -interface gif0</span>
<span class=c># ping6 -n MY_UPLINK</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># traceroute6 www.jp.FreeBSD.org</span>
<span class=o>(</span>3ffe:505:2008:1:2a0:24ff:fe57:e561<span class=o>)</span> from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1  atnet-meta6  14.147 ms  15.499 ms  24.319 ms
     2  6bone-gw2-ATNET-NT.ipv6.tilab.com  103.408 ms  95.072 ms <span class=k>*</span>
     3  3ffe:1831:0:ffff::4  138.645 ms  134.437 ms  144.257 ms
     4  3ffe:1810:0:6:290:27ff:fe79:7677  282.975 ms  278.666 ms  292.811 ms
     5  3ffe:1800:0:ff00::4  400.131 ms  396.324 ms  394.769 ms
     6  3ffe:1800:0:3:290:27ff:fe14:cdee  394.712 ms  397.19 ms  394.102 ms</code></pre></div></div><div class=paragraph><p>この出力はマシンによって異なります。 これで、あなたが <a class=package href=https://cgit.freebsd.org/ports/tree/www/mozilla/>www/mozilla</a> のような IPv6 が利用可能なブラウザを持っていれば、 IPv6 サイト <a href=http://www.kame.net>www.kame.net</a> にいって踊るカメを見ることができるでしょう。</p></div></div><div class=sect3><h4 id=_ipv6_世界の_dns>20.16.4. IPv6 世界の DNS<a class=anchor href=#_ipv6_世界の_dns></a></h4><div class=paragraph><p>IPv6 のための新しい DNS レコードが 2 種類あります。</p></div><div class=ulist><ul><li><p>AAAA レコード</p></li><li><p>A6 レコード</p></li></ul></div><div class=paragraph><p>AAAA レコードは簡単に使えます。</p></div><div class="literalblock programlisting"><div class=content><pre>MYHOSTNAME           AAAA    MYIPv6ADDR</pre></div></div><div class=paragraph><p>上記をプライマリゾーン DNS ファイルに加えて、 もらったばかりの IPv6 アドレスにホスト名を割り当ててください。 あなた自身で DNS ゾーンを管理していない場合は、 DNS プロバイダに頼んでください。 bind の最新バージョン (バージョン 8.3 および 9) は AAAA レコードに対応しています。</p></div></div></div></div></div><h1 id=appendices class=sect0>Part V: 付録<a class=anchor href=#appendices></a></h1><div class=sect1><h2 id=_freebsd_の入手方法>付録 A: FreeBSD の入手方法<a class=anchor href=#_freebsd_の入手方法></a></h2><div class=sectionbody><div class=sect2><h3 id=mirrors>A.1. Mirrors<a class=anchor href=#mirrors></a></h3><div class=paragraph><p>FreeBSD の公式のミラーサイトは、プロジェクトクラスタの管理者により運用されている数多くのコンピュータから構成されています。
GeoDNS により、ユーザには近くの利用可能なミラーが提供されます。
現在ミラーサイトが置かれている地域は、オーストラリア、ブラジル、ドイツ、日本 (2 つのサイト)、マレーシア、オランダ、南アフリカ、台湾、英国、アメリカ合衆国 (カリフォルニア、ニュージャージーおよびワシントン) です。</p></div><div class=paragraph><p>公式のミラーサービス:</p></div><table class="tableblock frame-all grid-all stretch"><col style=width:20%><col style=width:20%><col style=width:60%><thead><tr><th class="tableblock halign-left valign-top">サービス名</th><th class="tableblock halign-left valign-top">プロトコル</th><th class="tableblock halign-left valign-top">備考</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><strong>download.FreeBSD.org</strong></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://download.FreeBSD.org/>https</a> <a href=ftp://download.FreeBSD.org/pub/FreeBSD/>ftp</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ftp.FreeBSD.org</code> と同じ内容です。<code>ftp</code> は古い名前なので、<code>download.FreeBSD.org</code> が推奨されます。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><strong>git.FreeBSD.org</strong></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>https</code> および <code>ssh</code> 経由の git</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>詳細については、<a href=https://docs.freebsd.org/ja/books/handbook/mirrors/#git>git の利用</a> の節を参照してください。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><strong>pkg.FreeBSD.org</strong></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>http</code> および <code>https</code> 経由の <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> プログラムにより利用される公式の FreeBSD package リポジトリ</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><strong>vuxml.FreeBSD.org</strong> / <strong>www.VuXML.org</strong></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://www.vuxml.org/>https</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD プロジェクトの VuXML ウェブページ。<code>pkg audit</code> はこのサービスから脆弱性に関する一覧をダウンロードします。</p></td></tr></tbody></table><div class=paragraph><p>すべての公式のミラーは、IPv4 および IPv6 に対応しています。</p></div><div class=paragraph><p>FreeBSD のウェブサイト (<a href=https://www.FreeBSD.org class=bare>https://www.FreeBSD.org</a> および <a href=https://docs.FreeBSD.org class=bare>https://docs.FreeBSD.org</a>) は、GeoDNS インフラストラクチャでは運用されていません。
この実装は、進行中の課題です。</p></div><div class=paragraph><p><a href=http://ftp-archive.FreeBSD.org class=bare>http://ftp-archive.FreeBSD.org</a> は GeoDNS インフラストラクチャではなく、一つ地域 (US) でのみ運用されています。</p></div><div class=paragraph><p>プロジェクトでは、新しい地域やスポンサーを募集しています。
クラスター管理チームまで連絡してください。</p></div><div class=paragraph><p>コミュニティおよび他の会社により管理されているミラーの一覧:</p></div><table class="tableblock frame-all grid-all stretch"><col style=width:20%><col style=width:20%><col style=width:60%><thead><tr><th class="tableblock halign-left valign-top">国</th><th class="tableblock halign-left valign-top">ホスト名</th><th class="tableblock halign-left valign-top">プロトコル</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>オーストラリア <span class=icon><a class=image href=mailto:hostmaster@au.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.au.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.au.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.au.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=rsync://ftp.au.FreeBSD.org>rsync</a> <a href=rsync://ftp.au.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp3.au.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp3.au.FreeBSD.org/pub/FreeBSD>http</a> <a href=ftp://ftp3.au.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp3.au.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>オーストリア <span class=icon><a class=image href=mailto:hostmaster@at.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.at.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/>http</a> <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/>http_v6</a> <a href=ftp://ftp.at.FreeBSD.org/pub/FreeBSD/>ftp</a> <a href=ftp://ftp.at.FreeBSD.org/pub/FreeBSD/>ftp_v6</a> <a href=rsync://ftp.at.FreeBSD.org/pub/FreeBSD/>rsync</a> <a href=rsync://ftp.at.FreeBSD.org/pub/FreeBSD/>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ブラジル <span class=icon><a class=image href=mailto:hostmaster@br.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp2.br.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp2.br.FreeBSD.org/FreeBSD>http</a> <a href=rsync://ftp2.br.FreeBSD.org>rsync</a> <a href=rsync://ftp2.br.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp3.br.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp3.br.FreeBSD.org/pub/FreeBSD>http</a> <a href=ftp://ftp3.br.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp3.br.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ブルガリア <span class=icon><a class=image href=mailto:mirror@telepoint.bg><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.bg.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=ftp://ftp.bg.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.bg.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp.bg.FreeBSD.org>rsync</a> <a href=rsync://ftp.bg.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>チェコ共和国 <span class=icon><a class=image href=mailto:hostmaster@cz.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.cz.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=rsync://ftp.cz.FreeBSD.org>rsync</a> <a href=rsync://ftp.cz.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>デンマーク <span class=icon><a class=image href=mailto:staff@dotsrc.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.dk.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.dk.FreeBSD.org/FreeBSD/>http</a> <a href=http://ftp.dk.FreeBSD.org/FreeBSD/>http_v6</a> <a href=ftp://ftp.dk.FreeBSD.org/FreeBSD/>ftp</a> <a href=ftp://ftp.dk.FreeBSD.org/FreeBSD/>ftp_v6</a> <a href=rsync://ftp.dk.FreeBSD.org/FreeBSD/>rsync</a> <a href=rsync://ftp.dk.FreeBSD.org/FreeBSD/>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>フィンランド <span class=icon><a class=image href=mailto:hostmaster@fi.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.fi.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=ftp://ftp.fi.FreeBSD.org/pub/FreeBSD>ftp</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>フランス <span class=icon><a class=image href=mailto:hostmaster@fr.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.fr.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.fr.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.fr.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp.fr.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.fr.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp.fr.FreeBSD.org>rsync</a> <a href=rsync://ftp.fr.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp3.fr.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD>ftp</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp6.fr.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp6.fr.FreeBSD.org/pub/FreeBSD>http</a> <a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp6.fr.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ドイツ <span class=icon><a class=image href=mailto:de-bsd-hubs@de.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.de.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=ftp://ftp.de.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.de.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp.de.FreeBSD.org>rsync</a> <a href=rsync://ftp.de.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp1.de.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp1.de.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp1.de.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp1.de.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp1.de.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp1.de.FreeBSD.org>rsync</a> <a href=rsync://ftp1.de.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp2.de.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp2.de.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp2.de.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp2.de.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp2.de.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp2.de.FreeBSD.org>rsync</a> <a href=rsync://ftp2.de.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp5.de.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=ftp://ftp5.de.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp5.de.FreeBSD.org/pub/FreeBSD>ftp_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp7.de.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp7.de.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp7.de.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp7.de.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp7.de.FreeBSD.org/pub/FreeBSD>ftp_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ギリシャ <span class=icon><a class=image href=mailto:hostmaster@gr.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.gr.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.gr.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.gr.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp.gr.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.gr.FreeBSD.org/pub/FreeBSD>ftp_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp2.gr.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp2.gr.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp2.gr.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp2.gr.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>日本 <span class=icon><a class=image href=mailto:hostmaster@jp.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.jp.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.jp.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.jp.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp.jp.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.jp.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp.jp.FreeBSD.org>rsync</a> <a href=rsync://ftp.jp.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp2.jp.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp2.jp.FreeBSD.org>rsync</a> <a href=rsync://ftp2.jp.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp3.jp.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp3.jp.FreeBSD.org/pub/FreeBSD>http</a> <a href=rsync://ftp3.jp.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp4.jp.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD>ftp</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp6.jp.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp6.jp.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp6.jp.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp6.jp.FreeBSD.org>rsync</a> <a href=rsync://ftp6.jp.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>韓国 <span class=icon><a class=image href=mailto:hostmaster@kr.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.kr.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.kr.FreeBSD.org/pub/FreeBSD>http</a> <a href=https://ftp.kr.FreeBSD.org/pub/FreeBSD>https</a> <a href=ftp://ftp.kr.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp.kr.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp2.kr.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=rsync://ftp2.kr.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ラトビア <span class=icon><a class=image href=mailto:hostmaster@lv.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.lv.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.lv.FreeBSD.org/freebsd>http</a> <a href=ftp://ftp.lv.FreeBSD.org/freebsd>ftp</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>オランダ <span class=icon><a class=image href=mailto:hostmaster@nl.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.nl.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.nl.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.nl.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp.nl.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.nl.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp.nl.FreeBSD.org>rsync</a> <a href=rsync://ftp.nl.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp2.nl.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp2.nl.FreeBSD.org/pub/FreeBSD>http</a> <a href=ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp2.nl.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ニュージーランド <span class=icon><a class=image href=mailto:hostmaster@nz.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.nz.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.nz.FreeBSD.org/pub/FreeBSD>http</a> <a href=ftp://ftp.nz.FreeBSD.org/pub/FreeBSD>ftp</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ノルウェー <span class=icon><a class=image href=mailto:hostmaster@no.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.no.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=ftp://ftp.no.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.no.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp.no.FreeBSD.org>rsync</a> <a href=rsync://ftp.no.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ポーランド <span class=icon><a class=image href=mailto:hostmaster@pl.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.pl.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.pl.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.pl.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp.pl.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp.pl.FreeBSD.org>rsync</a> <a href=rsync://ftp.pl.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ロシア <span class=icon><a class=image href=mailto:hostmaster@ru.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.ru.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.ru.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.ru.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp.ru.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.ru.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp.ru.FreeBSD.org>rsync</a> <a href=rsync://ftp.ru.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp2.ru.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://ftp2.ru.FreeBSD.org/pub/FreeBSD>https</a> <a href=ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp2.ru.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>スロベニア <span class=icon><a class=image href=mailto:hostmaster@si.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.si.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.si.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.si.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp.si.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.si.FreeBSD.org/pub/FreeBSD>ftp_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>南アフリカ <span class=icon><a class=image href=mailto:hostmaster@za.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.za.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://ftp.za.FreeBSD.org/pub/FreeBSD>https</a> <a href=https://ftp.za.FreeBSD.org/pub/FreeBSD>https_v6</a> <a href=rsync://ftp.za.FreeBSD.org>rsync</a> <a href=rsync://ftp.za.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp2.za.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp2.za.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp2.za.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp2.za.FreeBSD.org/pub/FreeBSD>ftp_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp4.za.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp4.za.FreeBSD.org/pub/FreeBSD>http</a> <a href=ftp://ftp4.za.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp4.za.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>スウェーデン <span class=icon><a class=image href=mailto:hostmaster@se.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.se.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.se.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.se.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp.se.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.se.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp.se.FreeBSD.org>rsync</a> <a href=rsync://ftp.se.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>台湾 <span class=icon><a class=image href=mailto:hostmaster@tw.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp4.tw.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://ftp4.tw.FreeBSD.org/pub/FreeBSD>https</a> <a href=ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp4.tw.FreeBSD.org>rsync</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp5.tw.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp5.tw.FreeBSD.org/pub/FreeBSD>http</a> <a href=ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD>ftp</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ウクライナ <span class=icon><a class=image href=mailto:hostmaster@ua.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.ua.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.ua.FreeBSD.org/pub/FreeBSD>http</a> <a href=ftp://ftp.ua.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.ua.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp.ua.FreeBSD.org>rsync</a> <a href=rsync://ftp.ua.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>英国 <span class=icon><a class=image href=mailto:hostmaster@uk.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp.uk.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp.uk.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp.uk.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp.uk.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp.uk.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp.uk.FreeBSD.org>rsync</a> <a href=rsync://ftp.uk.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp2.uk.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp2.uk.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp2.uk.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=https://ftp2.uk.FreeBSD.org/pub/FreeBSD>https</a> <a href=https://ftp2.uk.FreeBSD.org/pub/FreeBSD>https_v6</a> <a href=ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD>ftp_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>アメリカ合衆国 <span class=icon><a class=image href=mailto:hostmaster@us.FreeBSD.org><i class="fa fa-envelope" title="mirror contact"></i></a></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp11.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp11.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp11.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp11.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp11.FreeBSD.org/pub/FreeBSD>ftp_v6</a> <a href=rsync://ftp11.FreeBSD.org>rsync</a> <a href=rsync://ftp11.FreeBSD.org>rsync_v6</a></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp14.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=ftp://ftp14.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=rsync://ftp14.FreeBSD.org>rsync</a> (Former official tier 1)</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>ftp5.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://ftp5.FreeBSD.org/pub/FreeBSD>http</a> <a href=http://ftp5.FreeBSD.org/pub/FreeBSD>http_v6</a> <a href=ftp://ftp5.FreeBSD.org/pub/FreeBSD>ftp</a> <a href=ftp://ftp5.FreeBSD.org/pub/FreeBSD>ftp_v6</a></p></td></tr></tbody></table><div class=paragraph><p>コミュニティのミラーによりサポートされているプロトコル一覧は、2022-01-31 に更新されました。
この一覧は保証されているわけではありません。</p></div></div><div class=sect2><h3 id=git>A.2. Git の利用<a class=anchor href=#git></a></h3><div class=sect3><h4 id=git-intro>A.2.1. はじめに<a class=anchor href=#git-intro></a></h4><div class=paragraph><p>2020 年 12 月、FreeBSD はソースコード、ドキュメントのすべてを管理するメインのバージョン管理システムを git に移行しました。
2021 年 4 月、FreeBSD は Ports Collection のすべてを管理するバージョン管理システムを git に移行しました。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>一般的には Git は開発用ツールです。
ユーザは好みに合わせて、FreeBSD ベースシステムのアップデートに <code>freebsd-update</code> (<a href=./#updating-upgrading-freebsdupdate>“FreeBSD Update”</a>)、
FreeBSD Ports Collection のアップデートに <code>git</code> (<a href=./#ports-using>“Ports Collection の利用”</a>を使用できます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この章では、FreeBSD への Git のインストール方法および FreeBSD ソースコードリポジトリのローカルコピーの作成方法について説明します。</p></div></div><div class=sect3><h4 id=git-install>A.2.2. インストール<a class=anchor href=#git-install></a></h4><div class=paragraph><p>Ports Collection または package を使って Git をインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install git</span></code></pre></div></div></div><div class=sect3><h4 id=git-usage>A.2.3. Git の実行<a class=anchor href=#git-usage></a></h4><div class=paragraph><p>ソースコードをローカルディレクトリに新しくコピーするには、<code>git clone</code> を使ってください。
このファイルのあるディレクトリのことを <em>ワークツリー</em> と呼びます。</p></div><div class=paragraph><p>Git は、リポジトリの指定に URL を用います。
リポジトリには <code>base</code>, <code>doc</code> および <code>ports</code> の 3 種類あります。
<code>base</code> は FreeBSD ベースシステムのソースコード、<code>doc</code> はドキュメント、そして <code>ports</code> は FreeBSD Ports Collection のリポジトリです。
これら 3 つのリポジトリはすべて HTTPS および SSH という 2 つの異なるプロトコル経由でアクセスできます。
たとえば、<code><a href=https://git.FreeBSD.org/src.git class=bare>https://git.FreeBSD.org/src.git</a></code> という URL は、<code>https</code> プロトコルによる <code>src</code> リポジトリの main ブランチを示します。</p></div><table id=git-url-table class="tableblock frame-all grid-all stretch"><caption class=title>表 20. FreeBSD Git リポジトリの URL テーブル</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">項目</th><th class="tableblock halign-left valign-top">Git URL</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>HTTPS 経由の読み取り専用 src リポジトリ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code><a href=https://git.FreeBSD.org/src.git class=bare>https://git.FreeBSD.org/src.git</a></code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Anonymous ssh による読み取り専用 src リポジトリ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ssh://anongit@git.FreeBSD.org/src.git</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>HTTPS 経由の読み取り専用 doc リポジトリ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code><a href=https://git.FreeBSD.org/doc.git class=bare>https://git.FreeBSD.org/doc.git</a></code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Anonymous ssh による読み取り専用 doc リポジトリ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ssh://anongit@git.FreeBSD.org/doc.git</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>HTTPS 経由の読み取り専用 ports リポジトリ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code><a href=https://git.FreeBSD.org/ports.git class=bare>https://git.FreeBSD.org/ports.git</a></code></p></td></tr></tbody><tfoot><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Anonymous ssh による読み取り専用 ports リポジトリ</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ssh://anongit@git.FreeBSD.org/ports.git</code></p></td></tr></tfoot></table><div class=paragraph><p>プロジェクトのメンバーが管理する外部のミラーも存在します。
<a href=#external-mirrors>外部ミラー</a> の節を参照してください。</p></div><div class=paragraph><p>FreeBSD システムのソースコードリポジトリを clone するには、以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># git clone -o freebsd https://git.FreeBSD.org/src.git /usr/src</span></code></pre></div></div><div class=paragraph><p>ここで <code>-o freebsd</code> オプションは origin を指定します。
FreeBSD のドキュメントの慣例で、origin は <code>freebsd</code> とします。
初めてチェックアウトする際には、リモートリポジトリのすべてのブランチをダウンロードするので時間がかかります。</p></div><div class=paragraph><p>ワーキングツリーには最初、CURRENT に対応する <code>main</code> ブランチのソースコードがダウンロードされます。
13-STABLE に変更するには以下のように実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># git checkout stable/13</span></code></pre></div></div><div class=paragraph><p>ワーキングツリーは、<code>git pull</code> によりアップデートできます。
上記の例で作成された <span class=filename>/usr/src</span> をアップデートするには、以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># git pull --rebase</span></code></pre></div></div><div class=paragraph><p>チェックアウトと比較すると、このアップデートでは変更点のあるファイルのみが転送されるので高速です。</p></div></div><div class=sect3><h4 id=_ウェブベースのリポジトリブラウザ>A.2.4. ウェブベースのリポジトリブラウザ<a class=anchor href=#_ウェブベースのリポジトリブラウザ></a></h4><div class=paragraph><p>FreeBSD プロジェクトは、現在 cgit をウェブベースのリポジトリブラウザ (<a href=https://cgit.FreeBSD.org/>https://cgit.FreeBSD.org/</a>) として使用しています。</p></div></div><div class=sect3><h4 id=_開発者向けの説明>A.2.5. 開発者向けの説明<a class=anchor href=#_開発者向けの説明></a></h4><div class=paragraph><p>リポジトリへの書き込みアクセスについてはの詳細は、<a href=https://docs.freebsd.org/en/articles/committers-guide/#git-mini-primer>Committer’s Guide</a> をご覧ください。</p></div></div><div class=sect3><h4 id=external-mirrors>A.2.6. 外部ミラー<a class=anchor href=#external-mirrors></a></h4><div class=paragraph><p>FreeBSD.org は以下のミラーを管理していませんが、プロジェクトのメンバーが現在も維持しています。
ユーザおよび開発者は自由にこれらのミラーのリポジトリを pull したりブラウザで見ることができます。
<code>doc</code> GitHub リポジトリへの pull request は accept されますが、
それ以外について、これらのミラーとのプロジェクトワークフローは議論中です。</p></div><div class=dlist><dl><dt class=hdlist1>Codeberg</dt><dd><div class=ulist><ul><li><p>doc: <a href=https://codeberg.org/FreeBSD/freebsd-doc class=bare>https://codeberg.org/FreeBSD/freebsd-doc</a></p></li><li><p>ports: <a href=https://codeberg.org/FreeBSD/freebsd-ports class=bare>https://codeberg.org/FreeBSD/freebsd-ports</a></p></li><li><p>src: <a href=https://codeberg.org/FreeBSD/freebsd-src class=bare>https://codeberg.org/FreeBSD/freebsd-src</a></p></li></ul></div></dd><dt class=hdlist1>GitHub</dt><dd><div class=ulist><ul><li><p>doc: <a href=https://github.com/freebsd/freebsd-doc class=bare>https://github.com/freebsd/freebsd-doc</a></p></li><li><p>ports: <a href=https://github.com/freebsd/freebsd-ports class=bare>https://github.com/freebsd/freebsd-ports</a></p></li><li><p>src: <a href=https://github.com/freebsd/freebsd-src class=bare>https://github.com/freebsd/freebsd-src</a></p></li></ul></div></dd><dt class=hdlist1>GitLab</dt><dd><div class=ulist><ul><li><p>doc: <a href=https://gitlab.com/FreeBSD/freebsd-doc class=bare>https://gitlab.com/FreeBSD/freebsd-doc</a></p></li><li><p>ports: <a href=https://gitlab.com/FreeBSD/freebsd-ports class=bare>https://gitlab.com/FreeBSD/freebsd-ports</a></p></li><li><p>src: <a href=https://gitlab.com/FreeBSD/freebsd-src class=bare>https://gitlab.com/FreeBSD/freebsd-src</a></p></li></ul></div></dd></dl></div></div><div class=sect3><h4 id=_メーリングリスト>A.2.7. メーリングリスト<a class=anchor href=#_メーリングリスト></a></h4><div class=paragraph><p>FreeBSD プロジェクトにおける git の一般的な使用方法や質問についてのメインのメーリングリストは <a href=https://lists.freebsd.org/subscription/freebsd-git>freebsd-git</a> です。
コミットメッセージの一覧などの詳細については、<a href=./#eresources-mail>メーリングリスト</a> の章をご覧ください。</p></div></div><div class=sect3><h4 id=_ssh_ホスト鍵>A.2.8. SSH ホスト鍵<a class=anchor href=#_ssh_ホスト鍵></a></h4><div class=ulist><ul><li><p>gitrepo.FreeBSD.org ホスト鍵のフィンガープリント:</p><div class=ulist><ul><li><p>ECDSA 鍵のフィンガープリントは <code>SHA256:seWO5D27ySURcx4bknTNKlC1mgai0whP443PAKEvvZA</code> です。</p></li><li><p>ED25519 鍵のフィンガープリントは <code>SHA256:lNR6i4BEOaaUhmDHBA1WJsO7H3KtvjE2r5q4sOxtIWo</code> です。</p></li><li><p>RSA 鍵のフィンガープリントは <code>SHA256:f453CUEFXEJAXlKeEHV+ajJfeEfx9MdKQUD7lIscnQI</code> です。</p></li></ul></div></li><li><p>git.FreeBSD.org ホスト鍵のフィンガープリント:</p><div class=ulist><ul><li><p>ECDSA 鍵のフィンガープリントは <code>SHA256:/UlirUAsGiitupxmtsn7f9b7zCWd0vCs4Yo/tpVWP9w</code> です。</p></li><li><p>ED25519 鍵のフィンガープリントは <code>SHA256:y1ljKrKMD3lDObRUG3xJ9gXwEIuqnh306tSyFd1tuZE</code> です。</p></li><li><p>RSA 鍵のフィンガープリントは <code>SHA256:jBe6FQGoH4HjvrIVM23dcnLZk9kmpdezR/CvQzm7rJM</code> です。</p></li></ul></div></li></ul></div><div class=paragraph><p>これらは DNS の SSHFP レコードとしても公開されています。</p></div></div></div><div class=sect2><h3 id=svn>A.3. Subversion の利用<a class=anchor href=#svn></a></h3><div class=sect3><h4 id=svn-intro>A.3.1. はじめに<a class=anchor href=#svn-intro></a></h4><div class=paragraph><p>2020 年 12 月より、FreeBSD のソースコード、ドキュメントのすべてを管理するメインのバージョン管理システムは git に移行しました。
git リポジトリの <code>stable/11</code>, <code>stable/12</code> および関連するリリースのブランチは、subversion リポジトリにエクスポートされます。
このエクスポートは、各ブランチの保守終了予定日まで行われる予定です。
2012 年 7 月から 2021 年 3 月までの間 FreeBSD は、FreeBSD Ports Collection のすべてを管理するバージョン管理システムに Subversion を使用していました。
2021 年 4 月より、FreeBSD の Ports Collection のすべてを管理するメインのバージョン管理システムは git に移行しました。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>-一般的には Subversion は開発者向けのツールです。
ユーザは好みに応じて、FreeBSD のベースシステムのアップデートに <code>freebsd-update</code> (<a href=./#updating-upgrading-freebsdupdate>「FreeBSD Update」</a>)、Ports Collection のアップデートには <code>git</code> (<a href=./#ports-using>「Ports Collection の利用」</a>) を使用できます。
2021 年 3 月以降、subversion はレガシーブランチ (<code>stable/11</code> および <code>stable/12</code>) でのみ使用されます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この節では、FreeBSD システムへの Subversion のインストール方法、および FreeBSD リポジトリをローカルに作成する方法について説明します。
さらに Subversion を利用するための情報についても紹介します。</p></div></div><div class=sect3><h4 id=svn-svnlite>A.3.2. Svnlite<a class=anchor href=#svn-svnlite></a></h4><div class=paragraph><p>FreeBSD には、Subversion より軽い <code>svnlite</code> がインストールされています。
Subversion の port または package は、Python もしくは Perl API が必要な時や、最新の Subversion を使用したい時のみ必要となります。</p></div><div class=paragraph><p>通常の Subversion と、 <code>svnlite</code> との違いは、 使用する時のコマンド名が異なるだけです。</p></div></div><div class=sect3><h4 id=svn-install>A.3.3. インストール<a class=anchor href=#svn-install></a></h4><div class=paragraph><p><code>svnlite</code> を利用できない場合や、 フルバージョンの Subversion を使いたいのであれば、 事前に Subversion をインストールしておく必要があります。</p></div><div class=paragraph><p>Subversion は Ports Collection からインストールできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/devel/subversion</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>package を使って Subversion をインストールすることもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install subversion</span></code></pre></div></div></div><div class=sect3><h4 id=svn-usage>A.3.4. Subversion の実行<a class=anchor href=#svn-usage></a></h4><div class=paragraph><p>ローカルディレクトリにソースコードをダウンロードするには、 <code>svn</code> コマンドを使ってください。
このディレクトリにあるファイルを、 <em>ローカル作業コピー</em> と呼びます。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><code>checkout</code> をはじめて使う前に、 ローカルディレクトリを移動するか削除してください。
<code>svn</code> 以外の方法で用意されたディレクトリでチェックアウトすると、 すでに存在するファイルと、 リポジトリから持ってきたファイルとの間で衝突が起きてしまいます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>Subversion では、リポジトリの指定に <em>protocol://hostname/path</em> 形式の URL を用います。
以下に記載されているように、 アクセスする FreeBSD リポジトリは、パス (path) の最初で指定します。
リポジトリは 3 つあります。
<code>base</code> は FreeBSD ベースシステムのソースコード、<code>ports</code> は Ports Collection、 そして <code>doc</code> はドキュメントのリポジトリです。
たとえば、<code><a href=https://svn.FreeBSD.org/base/head/ class=bare>https://svn.FreeBSD.org/base/head/</a></code> という URL は、<code>https</code> プロトコルによる src リポジトリのメインブランチを示しています。</p></div><div class=paragraph><p>以下のように入力して、リポジトリからチェックアウトしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/repository/branch lwcdir</span></code></pre></div></div><div class=paragraph><p>ここで、<em>repository</em>, <em>branch</em> および <em>root</em> は以下のとおりです。</p></div><div class=ulist><ul><li><p><em>repository</em> には、 プロジェクトリポジトリの <code>base</code>, <code>ports</code> または <code>doc</code> のどれかひとつを指定します。</p></li><li><p><em>branch</em> は、使うリポジトリによります。 <code>ports</code> および <code>doc</code> では、ほとんどの変更が <code>head</code> ブランチで行われます。 <code>base</code> リポジトリでは、<code>head</code> ブランチで -CURRENT の最新バージョンを管理しています。 -STABLE ブランチの最新バージョンは、 11.<em>x</em> は <code>stable/11</code>, そして 12.<em>x</em> は <code>stable/12</code> で管理しています。</p></li><li><p><em>lwcdir</em> は、 指定したブランチの中身が置かれるターゲットのディレクトリです。 通常 <code>ports</code> は <span class=filename>/usr/ports</span>、 <code>base</code> は <span class=filename>/usr/src</span>、 そして <code>doc</code> では <span class=filename>/usr/doc</span> と指定します。</p></li></ul></div><div class=paragraph><p>以下の例では、ソースツリーを FreeBSD リポジトリから HTTPS プロトコルを使ってチェックアウトします。
それらは、<span class=filename>/usr/src</span> のローカル作業コピーに置かれます。
もし <span class=filename>/usr/src</span> がすでに存在していて、それが <code>svn</code> によって生成されたものでなければ、チェックアウトする前に、名前を変更するか削除してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/base/head /usr/src</span></code></pre></div></div><div class=paragraph><p>初めてチェックアウトする際には、 リモートリポジトリのすべてのブランチをダウンロードする必要があるので、時間がかかります。
我慢してください。</p></div><div class=paragraph><p>初めてのチェックアウト後は、 以下を実行することでローカル作業コピーをアップデートできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update lwcdir</span></code></pre></div></div><div class=paragraph><p>この例で作成された <span class=filename>/usr/src</span> をアップデートするには、 以下のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update /usr/src</span></code></pre></div></div><div class=paragraph><p>アップデートはチェックアウトにくらべ、 変更点のあるファイルのみが転送されるので高速です。</p></div><div class=paragraph><p>チェックアウト後、ローカル作業コピーをアップデートするもうひとつの方法は、 <span class=filename>/usr/ports</span>, <span class=filename>/usr/src</span> または <span class=filename>/usr/doc</span> ディレクトリの <span class=filename>Makefile</span> で提供されています。
<code>SVN_UPDATE</code> を設定して <code>update</code> ターゲットを使ってください。
たとえば、<span class=filename>/usr/src</span> をアップデートするには、以下のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make update SVN_UPDATE=yes</span></code></pre></div></div></div><div class=sect3><h4 id=svn-mirrors>A.3.5. Subversion ミラーサイト<a class=anchor href=#svn-mirrors></a></h4><div class=paragraph><p>FreeBSD Subversion リポジトリは、</p></div><div class="literalblock programlisting"><div class=content><pre>svn.FreeBSD.org</pre></div></div><div class=paragraph><p>です。これは、公にアクセス可能なミラーネットワークで、 GeoDNS を用いて適切なバックエンドサーバを選択しています。
ブラウザを用いて FreeBSD の Subversion リポジトリを参照するには、<a href=https://svnweb.FreeBSD.org/>https://svnweb.FreeBSD.org/</a> を利用してください。</p></div><div class=paragraph><p>HTTPS は推奨されているプロトコルです。 自動的に証明書を検証するために、<a class=package href=https://cgit.freebsd.org/ports/tree/security/ca_root_nss/>security/ca_root_nss</a> port をインストールする必要があります。</p></div></div><div class=sect3><h4 id=_より詳しい情報>A.3.6. より詳しい情報<a class=anchor href=#_より詳しい情報></a></h4><div class=paragraph><p>Subversion の利用に関する他の情報は、 <a href=http://svnbook.red-bean.com/>Version Control with Subversion</a> や <a href=http://subversion.apache.org/docs/>Subversion Documentation</a> といった "Subversion Book" をご覧ください。</p></div></div></div><div class=sect2><h3 id=mirrors-cdrom>A.4. CD および DVD セット<a class=anchor href=#mirrors-cdrom></a></h3><div class=paragraph><p>FreeBSD の CD および DVD のセットは以下のオンライン業者から入手できます。</p></div><div class=ulist><ul><li><p>FreeBSD Mall, Inc.<br>1164 Claremont Dr<br>Brentwood, CA<br>94513<br>USA<br>Phone: +1 925 240-6652<br>Fax: +1 925 674-0821<br>Email: <a href=mailto:info@freebsdmall.com>info@freebsdmall.com</a><br>WWW: <a href=https://www.freebsdmall.com class=bare>https://www.freebsdmall.com</a></p></li><li><p>Getlinux<br>WWW: <a href=https://www.getlinux.fr/ class=bare>https://www.getlinux.fr/</a></p></li><li><p>Dr. Hinner EDV<br>Schäftlarnstr. 10 // 4. Stock<br>D-81371 München<br>Germany<br>Phone: +49 171 417 544 6<br>Email: <a href=mailto:infow@hinner.de>infow@hinner.de</a><br>WWW: <a href=http://www.hinner.de/linux/freebsd.html class=bare>http://www.hinner.de/linux/freebsd.html</a></p></li></ul></div></div></div></div><div class=sect1><h2 id=bibliography>付録 B: 参考図書<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p><em>訳: Yukihiro Nakai &lt;<a href=mailto:nakai@FreeBSD.org>nakai@FreeBSD.org</a>>, 1996 年 10 月 12 日。</em></p></div><div class=paragraph><p>FreeBSD オペレーティングシステムの個々の部分については マニュアルページで定義のような説明がなされていますが, どうやってその部分どうしをつなぎあわせて オペレーティングシステム全体を円滑に動作させるかについては, ほとんど説明されていません。 それを補うためにはのよい本や, UNIX® システム管理についての 利用者向けのマニュアルが欠かせません。</p></div><div class=sect2><h3 id=bibliography-freebsd>B.1. FreeBSD 専門の書籍<a class=anchor href=#bibliography-freebsd></a></h3><div class=paragraph><p><em>非英語文化圏の書籍:</em></p></div><div class=ulist><ul><li><p><a href=http://jdli.tw.FreeBSD.org/publication/book/freebsd2/index.htm>FreeBSD 入門與應用</a> (繁体字中国語)。 <a href=http://www.drmaster.com.tw/>Drmaster</a> 発行, 1997. ISBN 9-578-39435-7.</p></li><li><p>FreeBSD Unleashed (簡体字中国語訳), <a href=http://www.hzbook.com/>China Machine Press</a> 発行. ISBN 7-111-10201-0.</p></li><li><p>FreeBSD From Scratch Second Edition (簡体字中国語), China Machine Press 発行. ISBN 7-111-10286-X.</p></li><li><p>FreeBSD ハンドブック第 2 版 (簡体字中国語訳), <a href=http://www.ptpress.com.cn/>Posts & Telecom Press</a> 発行. ISBN 7-115-10541-3.</p></li><li><p>FreeBSD & Windows (簡体字中国語), <a href=http://www.tdpress.com/>China Railway Publishing House</a> 発行. ISBN 7-113-03845-X</p></li><li><p>FreeBSD Internet Services HOWTO (簡体字中国語), China Railway Publishing House 発行. ISBN 7-113-03423-3</p></li><li><p>FreeBSD入門キット AT互換機版 第二版。 宮嵜忠臣 著。 秀和システム。 ISBN 4-87966-535-5 C3055 2900 円。</p></li><li><p>ここまでできる FreeBSD パワーガイド。 霜山 滋, 仲道 嘉夫, 山中 右次 著。 秀和システム。 ISBN 4-87966-637-8 2600円。</p></li><li><p><a href="http://www.shoeisha.co.jp/book/Detail.asp?bid=650">FreeBSD徹底入門</a>。 あさだ たくや / 天川 修平 / 衛藤 敏寿 / 浜田 直樹 / 細川 達己 / 三田 吉郎 著。 <a href=http://www.shoeisha.co.jp/>翔泳社</a>。 ISBN 4-88135-473-6 3600 円。</p></li><li><p><a href=http://www.ascii.co.jp/pb/book1/shinkan/detail/1322785.html>パーソナル UNIX スターターキット FreeBSD</a>。 民田 雅人 / 古場 正行 / 増田 佳泰 / 天池 健 / 宮川 晋 共著。 <a href=http://www.ascii.co.jp/>アスキー</a>。 ISBN 4-7561-1733-3 3000 円。</p></li><li><p>FreeBSD ハンドブック (日本語版)。 <a href=http://www.ascii.co.jp/>アスキー</a>。 ISBN 4-7561-1580-2 3800 円。</p></li><li><p>FreeBSD mit Methode (ドイツ語版)。 <a href=http://www.cul.de>Computer und Literatur Verlag</a>/Vertrieb Hanser 発行。1998。 ISBN 3-932311-31-0</p></li><li><p><a href=http://www.mitp.de/vmi/mitp/detail/pWert/1343/>FreeBSD de Luxe</a> (ドイツ語), <a href=http://www.mitp.de>Verlag Modere Industrie</a> 発行, 2003 年。ISBN 3-8266-1343-0.</p></li><li><p><a href=http://www.pc.mycom.co.jp/FreeBSD/install-manual.html>FreeBSD インストール & 活用マニュアル</a>, <a href=http://www.pc.mycom.co.jp/>毎日コミュニケーションズ</a>発行。1998 年. ISBN 4-8399-0112-0.</p></li><li><p>Onno W Purbo, Dodi Maryanto, Syahrial Hubbany, Widjil Widodo 著 <em><a href=http://maxwell.itb.ac.id/>FreeBSD を使ったインターネットサーバの構築 (Building Internet Server with FreeBSD)</a></em> (インドネシア語), <a href=http://www.elexmedia.co.id/>Elex Media Komputindo</a> 発行。</p></li><li><p>Absolute BSD: The Ultimate Guide to FreeBSD (繁体字中国語訳) <a href=http://www.grandtech.com.tw/>GrandTech Press</a> 発行 (2003 年)。ISBN 986-7944-92-5.</p></li><li><p><a href=http://www.twbsd.org/cht/book/>The FreeBSD 6.0 Book</a> (繁体字中国語), Drmaster 発行 (2006 年)。ISBN 9-575-27878-X.</p></li></ul></div><div class=paragraph><p><em>英語の書籍:</em></p></div><div class=ulist><ul><li><p><a href=http://www.absoluteFreeBSD.com/>Absolute FreeBSD, 2nd Edition: The Complete Guide to FreeBSD</a>, <a href=http://www.nostarch.com/>No Starch Press</a> 刊、2007 年。ISBN: 978-1-59327-151-0</p></li><li><p><a href=http://www.freebsdmall.com/cgi-bin/fm/bsdcomp>The Complete FreeBSD</a>, <a href=http://www.oreilly.com/>O’Reilly</a>、 2003 年。ISBN: 0596005164</p></li><li><p><a href=http://www.freebsd-corp-net-guide.com/>The FreeBSD Corporate Networker’s Guide</a>, <a href=http://www.awl.com/aw/>Addison-Wesley</a> 刊、 2000 年。ISBN: 0201704811</p></li><li><p><a href=http://andrsn.stanford.edu/FreeBSD/introbook/>FreeBSD: An Open-Source Operating System for Your Personal Computer</a>、The Bit Tree Press 刊、2001 年。 ISBN: 0971204500</p></li><li><p>Teach Yourself FreeBSD in 24 Hours, <a href=http://www.samspublishing.com/>Sams</a> 刊、 2002 年。ISBN: 0672324245</p></li><li><p>FreeBSD 6 unleashed, <a href=http://www.samspublishing.com/>Sams</a> 刊、 2006 年。ISBN: 0672328755</p></li><li><p>FreeBSD: The Complete Reference, <a href=http://books.mcgraw-hill.com>McGrawHill</a> 刊、 2003 年。ISBN: 0072224096</p></li></ul></div></div><div class=sect2><h3 id=bibliography-userguides>B.2. 利用者向けのガイド<a class=anchor href=#bibliography-userguides></a></h3><div class=ulist><ul><li><p>オハイオ州立大学による <a href=http://www.cs.duke.edu/csl/docs/unix_course/>UNIX Introductory Course</a>。 オンラインで HTML 版と PostScript 版が利用可能。</p><div class=paragraph><p>FreeBSD イタリア語ドキュメンテーションプロジェクトの一環 として、このドキュメントの <a href=https://www.FreeBSD.org/doc/it/books/unix-introduction/>イタリア語訳</a> が用意されています。</p></div></li><li><p><a href=http://www.jp.FreeBSD.org/>FreeBSD 友の会 jpman プロジェクト</a>。FreeBSD User’s Reference Manual (日本語訳)。 <a href=http://www.pc.mycom.co.jp/>毎日コミュニケーションズ</a>, 1998。ISBN4-8399-0088-4 P3800E。</p></li><li><p><a href=http://www.ed.ac.uk/>Edinburgh University</a> による UNIX 環境の初心者向け <a href=http://www.ed.ac.uk/information-services/help-consultancy/is-skills/catalogue/program-op-sys-catalogue/unix1>オンラインガイド</a>。</p></li></ul></div></div><div class=sect2><h3 id=bibliography-adminguides>B.3. 管理者向けのガイド<a class=anchor href=#bibliography-adminguides></a></h3><div class=ulist><ul><li><p><a href=http://www.jp.FreeBSD.ORG/>FreeBSD 友の会 jpman プロジェクト</a>。FreeBSD System Administrator’s Manual (日本語訳)。 <a href=http://www.pc.mycom.co.jp/>毎日コミュニケーションズ</a>, 1998. ISBN4-8399-0109-0 P3300E.</p></li><li><p>Dreyfus, Emmanuel. <a href=http://www.eyrolles.com/Informatique/Livre/9782212114638/>Cahiers de l’Admin: BSD</a> 第 2 版。(フランス語、「管理者ノート」)、Eyrolles, 2004. ISBN 2-212-11463-X</p></li></ul></div></div><div class=sect2><h3 id=_プログラマ向けのガイド>B.4. プログラマ向けのガイド<a class=anchor href=#_プログラマ向けのガイド></a></h3><div class=ulist><ul><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Reference Manual</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-078-3</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Supplementary Documents</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-079-1</p></li><li><p>Harbison, Samuel P. and Steele, Guy L. Jr. <em>C: A Reference Manual</em>. 4th Ed. Prentice Hall, 1995. ISBN 0-13-326224-3 (訳注: 邦訳は以下のものが出版されています。 斎藤 信男監訳。 <em>新・詳説 C 言語リファレンス [H&amp;Sリファレンス]</em>。 ソフトバンク, 1994。 ISBN 4-89052-506-8 原本は第 4 版だが, 訳出は第 3 版のみ。)</p></li><li><p>Kernighan, Brian and Dennis M. Ritchie. <em>The C Programming Language</em>. 2nd Ed. PTR Prentice Hall, 1988. ISBN 0-13-110362-8 (訳注: 邦訳は以下のものが出版されています。 石田 晴久 訳。 <em>プログラミング言語 C 第 2 版(訳書訂正版)</em> 共立出版, 1989。 ISBN 4-320-02692-6)</p></li><li><p>Lehey, Greg. <em>Porting UNIX Software</em>. O’Reilly & Associates, Inc., 1995. ISBN 1-56592-126-7</p></li><li><p>Plauger, P. J. <em>The Standard C Library</em>. Prentice Hall, 1992. ISBN 0-13-131509-9 (訳注: 邦訳は以下のものが出版されています。 福富 寛 / 門倉 明彦 / 清水 恵介 訳。 <em>標準 C ライブラリ ANSI/ISO/JIS C規格</em>. トッパン, 1995。 ISBN 4-8101-8541-9)</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codereading/>Code Reading: The Open Source Perspective</a>. Addison-Wesley, 2003. ISBN 0-201-79940-5</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codequality/>Code Quality: The Open Source Perspective</a>. Addison-Wesley, 2006. ISBN 0-321-16607-8</p></li><li><p>Stevens, W. Richard and Stephen A. Rago. <em>Advanced Programming in the UNIX Environment</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 2005. ISBN 0-201-43307-9 (訳注: 第 1 版の邦訳は以下のものが出版されています。 大木 敦雄 訳。 <em>詳解 UNIX プログラミング</em>。トッパン, 1994。 ISBN 4-89052-524-6)</p></li><li><p>Stevens, W. Richard. <em>UNIX Network Programming</em>. 2nd Ed. PTR Prentice Hall, 1998. ISBN 0-13-949876-1 (訳注: 第 1 版の邦訳は以下のものが出版されています. 篠田 陽一 訳. <em>UNIX ネットワークプログラミング</em>。 トッパン, 1992. ISBN 4-8101-8509-5) 第 2 版の邦訳は以下のものが出版されています。 篠田 陽一 訳. <em>UNIX ネットワークプログラミング 第 2 版 Vol.1</em>。 トッパン, 1999。 ISBN 4-8101-8612-1)</p></li></ul></div></div><div class=sect2><h3 id=_オペレーティングシステム内部>B.5. オペレーティングシステム内部<a class=anchor href=#_オペレーティングシステム内部></a></h3><div class=ulist><ul><li><p>Andleigh, Prabhat K. <em>UNIX System Architecture</em>. Prentice-Hall, Inc., 1990. ISBN 0-13-949843-5</p></li><li><p>Jolitz, William. "Porting UNIX to the 386". <em>Dr. Dobb’s Journal</em>. January 1991-July 1992.</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, Michael J Karels and John Quarterman <em>The Design and Implementation of the 4.3BSD UNIX Operating System</em>. Reading, Mass. : Addison-Wesley, 1989. ISBN 0-201-06196-1 (訳注: 邦訳は以下のものが出版されています。 中村 明 / 相田 仁 / 計 宇生 / 小池 汎平 訳。 <em>UNIX 4.3BSDの設計と実装</em>。丸善, 1991。 ISBN 4-621-03607-6)</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, <em>The Design and Implementation of the 4.3BSD UNIX Operating System: Answer Book</em>. Reading, Mass. : Addison-Wesley, 1991. ISBN 0-201-54629-9 (訳注: 邦訳は以下のものが出版されています。 相田 仁 / 計 宇生 / 小池 汎平 訳。 <em>UNIX 4.3BSDの設計と実装</em>。 アンサーブック, トッパン, 1991。 ISBN 4-8101-8039-5)</p></li><li><p>McKusick, Marshall Kirk, Keith Bostic, Michael J Karels, and John Quarterman. <em>The Design and Implementation of the 4.4BSD Operating System</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-54979-4</p><div class=paragraph><p>(この本の第二章が FreeBSD ドキュメンテーションプロジェクト の一部として <a href=https://docs.freebsd.org/ja/books/design-44bsd/>オンライン</a> で公開されています。)</p></div></li><li><p>Marshall Kirk McKusick, George V. Neville-Neil <em>The Design and Implementation of the FreeBSD Operating System</em>. Boston, Mass. : Addison-Wesley, 2004. ISBN 0-201-70245-2</p></li><li><p>Marshall Kirk McKusick, George V. Neville-Neil, Robert N. M. Watson <em>The Design and Implementation of the FreeBSD Operating System, 2nd Ed.</em>. Westford, Mass. : Pearson Education, Inc., 2014. ISBN 0-321-96897-2</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 1: The Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63346-9</p></li><li><p>Schimmel, Curt. <em>Unix Systems for Modern Architectures</em>. Reading, Mass. : Addison-Wesley, 1994. ISBN 0-201-63338-8</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63495-3 (訳注: 邦訳は以下のものが出版されています。 中本 幸一 / 石川 裕次 / 田中 伸佳 訳。 <em>詳解 TCP/IP Vol.3: トランザクション TCP, HTTP, NNTP, UNIX ドメインプロトコル</em>, アジソンウェスレイパブリッシャーズジャパン, 1998。 ISBN 4-8101-8039-5)</p></li><li><p>Vahalia, Uresh. <em>UNIX Internals — The New Frontiers</em>. Prentice Hall, 1996. ISBN 0-13-101908-2 (訳注: 邦訳は以下のものが出版されています。 徳田 英幸 / 中村 明 / 戸辺 義人 / 津田 悦幸 訳。 <em>最前線UNIXのカーネル</em>, ピアソンエデュケーション, 2000。 ISBN 4-89471-189-3)</p></li><li><p>Wright, Gary R. and W. Richard Stevens. <em>TCP/IP Illustrated, Volume 2: The Implementation</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63354-X</p></li><li><p>Messmer, Hans-Peter. <em>The Indispensable PC Hardware Book</em>, 4th Ed. Reading, Mass : Addison-Wesley Pub. Co., 2002. ISBN 0-201-59616-4</p></li></ul></div></div><div class=sect2><h3 id=_セキュリティの参考資料>B.6. セキュリティの参考資料<a class=anchor href=#_セキュリティの参考資料></a></h3><div class=ulist><ul><li><p>Cheswick, William R. and Steven M. Bellovin. <em>Firewalls and Internet Security: Repelling the Wily Hacker</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63357-4 (訳注: 邦訳は以下のものが出版されています。 川副 博 監訳。<em>ファイアウォール</em>。 ソフトバンク, 1995。 ISBN 4-89052-672-2)</p></li><li><p>Garfinkel, Simson. <em>PGP Pretty Good Privacy</em> O’Reilly & Associates, Inc., 1995. ISBN 1-56592-098-8</p></li></ul></div></div><div class=sect2><h3 id=bibliography-hardware>B.7. ハードウェアの参考資料<a class=anchor href=#bibliography-hardware></a></h3><div class=ulist><ul><li><p>Anderson, Don and Tom Shanley. <em>Pentium Processor System Architecture</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40992-5</p></li><li><p>Ferraro, Richard F. <em>Programmer’s Guide to the EGA, VGA, and Super VGA Cards</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-62490-7</p></li><li><p>Intel Corporation は、自社の CPU やチップセットに関する文書を自社の <a href=http://developer.intel.com/>開発者向け Web サイト</a> で公開しています。文書のフォーマットは通常 PDF です。</p></li><li><p>Shanley, Tom. <em>80486 System Architecture</em>. 3rd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40994-1</p></li><li><p>Shanley, Tom. <em>ISA System Architecture</em>. 3rd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40996-8</p></li><li><p>Shanley, Tom. <em>PCI System Architecture</em>. 4th Ed. Reading, Mass. : Addison-Wesley, 1999. ISBN 0-201-30974-2</p></li><li><p>Van Gilluwe, Frank. <em>The Undocumented PC</em>, 2nd Ed. Reading, Mass: Addison-Wesley Pub. Co., 1996. ISBN 0-201-47950-8</p></li></ul></div></div><div class=sect2><h3 id=bibliography-history>B.8. UNIX® の歴史<a class=anchor href=#bibliography-history></a></h3><div class=ulist><ul><li><p>Lion, John <em>Lion’s Commentary on UNIX, 6th Ed. With Source Code</em>. ITP Media Group, 1996. ISBN 1573980137</p></li><li><p>Raymond, Eric s. <em>The New Hacker’s Dictionary, 3rd edition</em>. MIT Press, 1996. ISBN 0-262-68092-0 これは <a href=http://www.catb.org/~esr/jargon/html/index.html>ジャーゴンファイル (Jargon File)</a> として知られています。</p></li><li><p>Saulus, Peter H. <em>A quarter century of UNIX</em>. Addison-Wesley Publishing Company, Inc., 1994. ISBN 0-201-54777-5</p></li><li><p>Simon Garfinkel, Daniel Weise, Steven Strassmann. <em>The UNIX-HATERS Handbook</em>. IDG Books Worldwide, Inc., 1994. ISBN 1-56884-203-1. 絶版となりましたが、<a href=http://www.simson.net/ref/ugh.pdf>オンライン</a> で入手できます。</p></li><li><p>Don Libes, Sandy Ressler <em>Life with UNIX</em> - special edition. Prentice-Hall, Inc., 1989. ISBN 0-13-536657-7 (訳注: 邦訳は以下のものが出版されています。 坂本 文 監訳. <em>Life with UNIX</em>. アスキー, 1990。 ISBN 4-7561-0783-4 邦訳が Special 版の訳出か否かは不明)</p></li><li><p><em>BSD 系 OS の系譜図</em>。 <a href="https://svnweb.freebsd.org/base/head/share/misc/bsd-family-tree?view=co">https://svnweb.freebsd.org/base/head/share/misc/bsd-family-tree?view=co</a> か、もしくは、FreeBSD マシンにある <a href=file://localhost/usr/share/misc/bsd-family-tree>/usr/share/misc/bsd-family-tree</a>。</p></li><li><p><em>Networked Computer Science Technical Reports Library</em>.</p></li><li><p><em>Computer Systems Research group (CSRG) からの古い BSD リリース集</em>。<a href=http://www.mckusick.com/csrg/>http://www.mckusick.com/csrg/</a>: この 4 枚 CD セットには、1BSD から 4.4BSD までと 4.4BSD-Lite2 が含まれます (残念ながら 2.11BSD は含まれていません)。 また 4 枚目の CD には、最終ソースおよび SCCS ファイルが含まれています。</p></li><li><p>Kernighan, Brian <em>Unix: A History and a Memoir</em>. Kindle Direct Publishing, 2020. ISBN 978-169597855-3</p></li></ul></div></div><div class=sect2><h3 id=bibliography-journals>B.9. 定期刊行物、雑誌およびジャーナル<a class=anchor href=#bibliography-journals></a></h3><div class=ulist><ul><li><p><a href=http://www.admin-magazin.de/>Admin Magazin</a> (in German), published by Medialinx AG. ISSN: 2190-1066</p></li><li><p><a href=http://www.bsdmag.org/>BSD Magazine</a>, published by Software Press Sp. z o.o. SK. ISSN: 1898-9144</p></li><li><p><a href=http://www.bsdnow.tv/>BSD Now - Video Podcast</a>, published by Jupiter Broadcasting LLC</p></li><li><p><a href=http://bsdtalk.blogspot.com/>BSD Talk Podcast</a>, by Will Backman</p></li><li><p><a href=http://freebsdjournal.com/>FreeBSD Journal</a>, published by S&amp;W Publishing, sponsored by The FreeBSD Foundation. ISBN: 978-0-615-88479-0</p></li></ul></div></div></div></div><div class=sect1><h2 id=eresources>付録 C: インターネット上のリソース<a class=anchor href=#eresources></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD の進歩は急速であり、 印刷したメディアは最新の開発をフォローするのに実用的ではありません。 それだけしかない、というわけではありませんが、 最新情報を入手する方法としては電子的なリソースがベストです。 FreeBSD はボランティアの努力によって、ユーザコミュニティ自体が、 一種の "テクニカルサポート部門" としての役割も通常果たしており、 電子メール、ウェブフォーラムおよび Usenet のニュースがこれらのコミュニティにたどり着く最も効果的な方法になっています。</p></div><div class=paragraph><p>以下に、FreeBSD ユーザコミュニティに連絡を取る場合の最も重要な点についての概略を示します。 ここに書かれていない他のリソースをご存知であれば、 それらをここに含めることができるように、 <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD documentation project メーリングリスト</a> にお知らせください。</p></div><div class=sect2><h3 id=eresources-www>C.1. ウェブサイト<a class=anchor href=#eresources-www></a></h3><div class=ulist><ul><li><p><a href=https://forums.FreeBSD.org/>The FreeBSD Forums</a> は、FreeBSD の質問および技術的な議論のためのウェブベースのフォーラムです。</p></li><li><p><a href=http://www.youtube.com/bsdconferences>BSDConferences YouTube Channel</a> は、世界中で開催されている BSD カンファレンスでのプレゼンテーションの高品質のビデオです。 主要な開発者による FreeBSD の新しい進展についてのプレゼンテーションをぜひともご覧ください。</p></li></ul></div></div><div class=sect2><h3 id=eresources-mail>C.2. メーリングリスト<a class=anchor href=#eresources-mail></a></h3><div class=paragraph><p>メーリングリストは、FreeBSD の関係者に対し質問を投稿したり、 技術的な議論を行うのに、最も直接的な方法です。 さまざまな FreeBSD の関連トピックに対し、 幅広いメーリングリストが存在しています。 質問を適切なメーリングリストに投稿すれば、 早く、的確な反応がいつでも得られることでしょう。</p></div><div class=paragraph><p>さまざまなメーリングリストの憲章をこのドキュメントの最後に記載します。 <em>私たちは、メーリングリストの質、 特に技術面に関する質を高く保つために努力しているので、 メーリングリストに参加する前にその憲章を読んでください。 </em>私たちのメーリングリストの参加者のほとんどは、 非常にたくさんの FreeBSD に関連したメッセージを毎日受け取っており、 メーリングリストの利用に関する憲章やルールは、 メーリングリストの S/N 比を高く保つためのものです。 そうしないと、結果的に、 メーリングリストがプロジェクトにとって事実上のコミュニケーションの手段になってしまうでしょう。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>FreeBSD メーリングリストにメールを送信できるかどうかを確認するには、 <a href=https://lists.FreeBSD.org/subscription/freebsd-test>FreeBSD test メーリングリスト</a> にテストメッセージを送信してください。</em> 他のメーリングリストには、 テストメッセージを送信しないでください。</p></div></td></tr></tbody></table></div><div class=paragraph><p>どのメーリングリストに質問を投稿すべきか迷った場合には、 <a href=https://docs.freebsd.org/en/articles/freebsd-questions/>How to get best results from the FreeBSD-questions mailing list</a> をご覧ください。</p></div><div class=paragraph><p>どこのメーリングリストに投稿する場合でも、メーリングリストを最大限に活用する方法を理解しておいてください。
たとえば、 <a href=https://docs.freebsd.org/en/articles/mailing-list-faq/>Mailing List Frequently Asked Questions</a> (FAQ) 文書を読んで、 繰り返し行われる議論を避ける方法を理解してください。</p></div><div class=paragraph><p>メーリングリストはいずれもアーカイブされており、それらは <a href=https://www.FreeBSD.org/search/>FreeBSD World Wide Web server</a> で検索することができます。 キーワード検索可能なアーカイブの提供は、 良くある質問に対する回答を見つけるすぐれた方法ですから、 質問を投稿する前に調べてみるべきでしょう。 このことは、FreeBSD メーリングリストに送信されたメッセージは、 ずっとアーカイブされることを意味しています。 プライバシーの保護が問題になるような場合には、 使い捨てのメールアドレスを用い、公な情報のみを送ってください。</p></div><div class=sect3><h4 id=eresources-summary>C.2.1. メーリングリストの概説<a class=anchor href=#eresources-summary></a></h4><div class=paragraph><p><em>一般的なメーリングリスト:</em> 以下のものは誰でも自由に参加できる (そしておすすめの) 一般的なものです。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">リスト</th><th class="tableblock halign-left valign-top">目的</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-advocacy>freebsd-advocacy</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の福音伝道</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-announce>FreeBSD announcements メーリングリスト</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>重要なイベントやプロジェクトのマイルストン (モデレータ制)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-arch>freebsd-arch</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>アーキテクチャ、設計に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bugbusters>freebsd-bugbusters</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 障害報告データベースおよび関連するツールの管理に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>freebsd-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>バグレポート</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-chat>freebsd-chat</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD コミュニティに関連する技術的ではない話題</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-chromium>freebsd-chromium</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD に固有の Chromium の問題について</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT メーリングリスト</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-CURRENT の使用に関連する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-isp>freebsd-isp</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD を用いている インターネットサービスプロバイダの話題</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-jobs>freebsd-jobs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 関連の雇用機会に関する話題</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href={freebsd-quarterly-calls-url}>freebsd-quarterly-calls</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>四半期開発進捗レポートの呼びかけ (モデレータ制)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザからの質問と技術サポート</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>FreeBSD security notifications メーリングリスト</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>セキュリティに関する通知 (モデレータ制)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-stable>FreeBSD-STABLE; メーリングリスト</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD-STABLE の使用に関連する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-test>FreeBSD test メーリングリスト</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>メッセージの送信試験を行なうために、 実際のメーリングリストの代わりに使うアドレス</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-women>freebsd-women</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の女性支援</p></td></tr></tbody></table><div class=paragraph><p><em>技術的なメーリングリスト:</em> 以下のメーリングリストは、技術的な 議論のためのものです。 それらの利用や内容のためにしっかりとしたガイドラインがあるので、 これらのメーリングリストに入ったり、 どれか一つにメール を送ったりする前には、 それらのメーリングリストの憲章を注意深く読んでください。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">リスト</th><th class="tableblock halign-left valign-top">目的</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI メーリングリスト</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ACPI および電源管理の開発</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-fortran>freebsd-fortran</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD での Fortran</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-amd64>freebsd-amd64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の AMD64 システムへの移植 (モデレータ制)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-apache>freebsd-apache</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Apache に関連した ports についての議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-arm>freebsd-arm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の ARM® プロセッサへの移植</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-atm>freebsd-atm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD での ATM ネットワーク使用に関する話題</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-bluetooth>freebsd-bluetooth</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD で Bluetooth® 技術の使用</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-cloud>freebsd-cloud</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>クラウドプラットフォーム (EC2, GCE, Azure など) での FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-cluster>freebsd-cluster</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD のクラスタ環境での利用</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-database>freebsd-database</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 上でのデータベースの利用や開発に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-desktop>freebsd-desktop</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>デスクトップでの FreeBSD の利用や改良について</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-ci>dev-ci</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>継続的インテグレーションサーバからのビルドおよび試験レポート</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-reviews>dev-reviews</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD レビューシステムからの通知</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-doc>freebsd-doc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 関連ドキュメントの作成</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-drivers>freebsd-drivers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD のデバイスドライバの書き方について</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-dtrace>freebsd-dtrace</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD における Dtrace の利用と開発</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-eclipse>freebsd-eclipse</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eclipse IDE, ツール、 リッチクライアントアプリケーションの FreeBSD ユーザおよび ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-elastic>freebsd-elastic</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 固有の ElasticSearch に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>組み込みアプリケーションにおける FreeBSD の利用</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-emulation>freebsd-emulation</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Linux/MS-DOS®/Windows® のような他のシステムのエミュレーション</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-enlightenment>freebsd-enlightenment</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enlightenment および Enlightenment アプリケーションの移植</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-erlang>freebsd-erlang</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 固有の Erlang に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-firewire>freebsd-firewire</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD FireWire® (iLink, IEEE 1394) に関する技術的な議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-fs>freebsd-fs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ファイルシステム</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-games>freebsd-games</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD でのゲームのサポート</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-gecko>freebsd-gecko</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gecko レンダリングエンジン に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-geom>freebsd-geom</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GEOM に関連した議論と実装</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-git>freebsd-git</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD プロジェクトでの git の使用に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-gnome>freebsd-gnome</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME および GNOME アプリケーションの移植</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>freebsd-hackers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>一般的な技術の議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-haskell>freebsd-haskell</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 固有の Haskell に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hardware>freebsd-hardware</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の走るハードウェアの一般的な議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-i18n>freebsd-i18n</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の国際化</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-infiniband>freebsd-infiniband</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD での Infiniband の使用</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ipfw>freebsd-ipfw</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IP firewall コードの再設計に関する技術的議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ISDN 開発者</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-jail>freebsd-jail</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-java>freebsd-java</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Java™ 開発者や、FreeBSD へ JDK™ を移植する人たち</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://mail.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE および KDE アプリケーションの移植</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mips>freebsd-mips</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の MIPS® への移植</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-mono>freebsd-mono</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD における Mono および C# アプリケーション</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-new-bus>freebsd-new-bus</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>バスアーキテクチャに関する技術的な議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-net>freebsd-net</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ネットワークおよび TCP/IP ソースコードに関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-numerics>freebsd-numerics</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>高品質な libm 機能の実装に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ocaml>freebsd-ocaml</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 固有の OCaml に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-office>freebsd-office</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD でのオフィスアプリケーションについて</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-performance>freebsd-performance</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ハイパフォーマンス / 高負荷での導入のためのパフォーマンスチューニングに関する質問</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-perl>freebsd-perl</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>数多く存在する Perl に関連する port の管理について</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pkg>freebsd-pkg</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>バイナリ package 管理および package ツールについての議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pf>freebsd-pf</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>パケットフィルタファイアウォールシステムに関する議論および質問</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pkg>freebsd-pkg</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>バイナリ package 管理および package 関連ツールの議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pkg-fallout>freebsd-pkg-fallout</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>package ビルドに失敗したログ</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-pkgbase>freebsd-pkgbase</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD ベースシステムの pkg 化</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-platforms>freebsd-platforms</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Intel® 以外のアーキテクチャのプラットフォームへの移植</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports>freebsd-ports</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ports Collection に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-announce>freebsd-ports-announce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ports Collection に関する重要なニュースと案内 (モデレータ制)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>freebsd-ports-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ports のバグや PR についての議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ppc>freebsd-ppc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の PowerPC® への移植</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-proliant>freebsd-proliant</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>HP ProLiant サーバプラットフォーム上での FreeBSD に関する技術的な議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-python>freebsd-python</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 固有の Python に関する話題</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-rc>freebsd-rc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>rc.d</span> システムおよび開発に関連した議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-realtime>freebsd-realtime</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 用のリアルタイム拡張の開発に関する話題</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-riscv>freebsd-riscv</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の RISC-V® システムへの移植</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-ruby>freebsd-ruby</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 固有の Ruby に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-scsi>freebsd-scsi</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SCSI サブシステム</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-security>FreeBSD security メーリングリスト</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD に影響するセキュリティに関する話題</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-snapshots>freebsd-snapshots</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 開発スナップショットのアナウンス</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-sparc64>freebsd-sparc64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の SPARC® ベースシステムへの移植</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-standards>freebsd-standards</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>C99 および POSIX® 標準への FreeBSD の適合について</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-sysinstall>freebsd-sysinstall</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> の開発</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-tcltk>freebsd-tcltk</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 固有の Tcl/Tk に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-testing>freebsd-testing</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD における試験</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-tex>freebsd-tex</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TeX および関連アプリケーションの FreeBSD への移植</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-threads>freebsd-threads</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD のスレッドについて</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-tokenring>freebsd-tokenring</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD でのトークンリングのサポート</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-toolchain>freebsd-toolchain</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の統合されたツールチェインのメンテナンス</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-translators>freebsd-translators</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD 文書およびプログラムの翻訳</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-transport>freebsd-transport</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD でのトランスポートレベルネットワークプロトコルに関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-usb>freebsd-usb</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の USB 対応に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-virtualization>freebsd-virtualization</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD によりサポートされているさまざまな仮想化技術についての議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-vuxml>freebsd-vuxml</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>VuXML インフラストラクチャに関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-wireless>freebsd-wireless</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>802.11 スタック、 ツールおよびデバイスドライバの開発に関する議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-x11>freebsd-x11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD での X11 のメンテナンスとサポート</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-xen>freebsd-xen</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の Xen™ への移植 - 実装および利用についての議論</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-xfce>freebsd-xfce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>XFCE の FreeBSD への移植や保守について</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-zope>freebsd-zope</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zope の FreeBSD への移植や保守について</p></td></tr></tbody></table><div class=paragraph><p><em>制限されているメーリングリスト:</em> 以下のメーリングリストはより特化された (そしてより厳しい) メンバーのためのものであり、 一般的な興味を惹くようなものではありません。 このようなメーリングリストに参加する前に、 技術的なメーリングリストで自らの存在感をアピールするのは良い考えです。 そうすることにより、 議論の際のエチケットを学ぶことができるでしょう。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">メーリングリスト</th><th class="tableblock halign-left valign-top">目的</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-hubs>freebsd-hubs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ミラーサイトを運営している人達 (基盤のサポート)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-user-groups>freebsd-user-groups</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ユーザグループの調整</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/freebsd-wip-status>freebsd-wip-status</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD の進行中のプロジェクトに関する状況</p></td></tr></tbody></table><div class=paragraph><p><em>メーリングリストのダイジェスト版:</em> 上述のメーリングリストのすべてでダイジェスト版を利用できます。 メーリングリストに登録すると、アカウントのオプションセクションで、 ダイジェストのオプションを変更できます。</p></div><div class=paragraph><p><em>コミットメッセージリスト:</em> 以下のメーリングリストは、 ソースツリーのさまざまな領域に対する変更に対するログメッセージを見ることに興味のある人向けです。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">メーリングリスト</th><th class="tableblock halign-left valign-top">ソースの範囲</th><th class="tableblock halign-left valign-top">(ソースの) 範囲の説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-commits-doc-all>dev-commits-doc-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>doc リポジトリへ加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-commits-ports-all>dev-commits-ports-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ports リポジトリへ加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-commits-ports-main>dev-commits-ports-main</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ports リポジトリの "main" ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-commits-ports-branches>dev-commits-ports-branches</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ports リポジトリの四半期ごとのブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-commits-src-all>dev-commits-src-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src リポジトリへ加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-commits-src-main>dev-commits-src-main</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src リポジトリの "main" ブランチ (FreeBSD-CURRENT ブランチ) に加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/subscription/dev-commits-src-branches>dev-commits-src-branches</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src リポジトリのすべての stable ブランチに加えられたすべての変更</p></td></tr></tbody></table><div class=paragraph><p><em>SVN メーリングリスト:</em> 以下のメーリングリストは、 ソースツリーのさまざまな領域に対する変更の SVN ログメッセージを見ることに興味のある人向けです。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>SVN ログメッセージのみが SVN のメーリングリストに送られます。
SVN から Git への移行後は、以下のメーリングリストには、新しいコミットメッセージは送られませんし、購読もできません。
以下の一覧のリンクは、各メーリングリストのアーカイブへのリンクです。</p></div></td></tr></tbody></table></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">メーリングリスト</th><th class="tableblock halign-left valign-top">ソースの範囲</th><th class="tableblock halign-left valign-top">(ソースの) 範囲の説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-doc-all>svn-doc-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>doc subversion リポジトリへ加えられたすべての変更 (<span class=filename>user</span>, <span class=filename>projects</span> および <span class=filename>translations</span> を除く)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-doc-head>svn-doc-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>doc subversion リポジトリの "head" ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-doc-projects>svn-doc-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>doc subversion リポジトリの <span class=filename>projects</span> に加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-doc-svnadmin>svn-doc-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>doc subversion リポジトリの管理用スクリプト、 フックおよび他のコンフィグレーションデータに対して加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-ports-all>svn-ports-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ports subversion リポジトリへ加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-ports-head>svn-ports-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ports subversion リポジトリの "head" ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-ports-svnadmin>svn-ports-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ports subversion リポジトリの管理用スクリプト、 フックおよび他のコンフィグレーションデータに対して加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-all>SVN commit messages for the entire src tree (except for "user" and "projects")</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリへ加えられたすべての変更 (<span class=filename>user</span> および <span class=filename>projects</span> を除く)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-head>SVN commit messages for the src tree for head/-current</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの "head" ブランチ (FreeBSD-CURRENT ブランチ) に加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-projects>svn-src-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>projects</span> に加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-release>svn-src-release</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>releases</span> に加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-releng>svn-src-releng</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>releng</span> ブランチ (セキュリティ / リリースエンジニアリングブランチ) に加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-stable>svn-src-stable</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリのすべての stable ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-stable-6>svn-src-stable-6</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>stable/6</span> ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-stable-7>svn-src-stable-7</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>stable/7</span> ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-stable-8>svn-src-stable-8</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>stable/8</span> ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-stable-9>9-stable ソースツリーの SVN コミットメッセージ</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>stable/9</span> ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-stable-10>svn-src-stable-10</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>stable/10</span> ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-stable-11>svn-src-stable-11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>stable/11</span> ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-stable-12>svn-src-stable-12</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>stable/12</span> ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-stable-other>svn-src-stable-other</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの古い <span class=filename>stable</span> ブランチに加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-svnadmin>svn-src-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの管理用スクリプト、 フックおよび他のコンフィグレーションデータに対して加えられたすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-user>svn-src-user</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの <span class=filename>user</span> に加えられた実験的なすべての変更</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://lists.FreeBSD.org/pipermail/svn-src-vendor>svn-src-vendor</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src subversion リポジトリの vender に加えられたすべての変更</p></td></tr></tbody></table></div><div class=sect3><h4 id=eresources-subscribe>C.2.2. 参加方法<a class=anchor href=#eresources-subscribe></a></h4><div class=paragraph><p>メーリングリストに参加するには、https://lists.freebsd.org で、 希望のメーリングリストをクリックしてください。 表示されるページには、 各メーリングリストに登録するために必要な手順が書かれています。</p></div><div class=paragraph><p>メーリングリストにメールを送るには、 <a href=mailto:listname@FreeBSD.org>listname@FreeBSD.org</a> にメールを送ってください。すると、 メーリングリストに登録されている世界中のメンバに再配布されます。</p></div><div class=paragraph><p>メーリングリストから登録を解除する場合は、メーリングリストで配信されているメールの最後にある URL をクリックしてください。
または、 <a href=mailto:listname+unsubscribe@FreeBSD.org>listname+unsubscribe@FreeBSD.org</a> にメールを送信することでも登録を解除できます。</p></div><div class=paragraph><p>技術的なメーリングリストでは、 技術的な議論を保つようにすることが重要です。 もし、重要なアナウンスのみを受け取りたいのであれば、 <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>FreeBSD announcements メーリングリスト</a> への参加をお勧めします。 ここには、あまりたくさんのメールは流れません。</p></div></div><div class=sect3><h4 id=eresources-charters>C.2.3. メーリングリストの憲章<a class=anchor href=#eresources-charters></a></h4><div class=paragraph><p><em>すべて</em> FreeBSD メーリングリストは誰でもそれらを利用することに固守しなければいけないという一定の簡単なルールがあります。 これらのルールに従わないと、結果として FreeBSD の Postmaster <a href=mailto:postmaster@FreeBSD.org>postmaster@FreeBSD.org</a> から 2 回までは警告を受けます。 3 回違反すると、投稿者はすべての FreeBSD のメーリングリストから削除され、 そのメーリングリストへのさらなる投稿から締め出されるでしょう。 これらのルールや対策が必要なのは残念です。 しかし、今日のインターネットはずいぶんいやらしい環境になっており、 一般の人々は、その (対策の) メカニズムがいかにもろいかという事すら認識する事が出来ていないと思われます。</p></div><div class=paragraph><p>道標</p></div><div class=ulist><ul><li><p>いかなる投稿記事もそのメーリングリストの基本的な憲章を守るべきです。 そのメーリングリストが技術的な問題に関するものであれば、 技術的な議論を含む投稿でなければなりません。 現在継続中の不適切な憲章やフレイムは、 所属しているすべての人に対してメーリングリストの価値を下げてしまうだけですし、 許される行為ではないでしょう。 とくに話題のない自由形式の議論に対しては <a href=https://lists.FreeBSD.org/subscription/freebsd-chat>FreeBSD chat メーリングリスト</a> が自由に認可されているので、 かわりに使うべきでしょう。</p></li><li><p>一度に 3 つ以上のメーリングリストには決して投稿すべきではありません。 2 つのメーリングリストには双方に明確な必要性がある場合にのみ投稿すべきです。 どのリストに対しても、 (メーリングリストの)参加者は (複数のメーリングリストに) 重複して参加しており、関連する部分が少ない (たとえば、 "-stable" と "-scsi") メーリングリストを除いては、 一度に複数のメーリングリストに投稿する理由は全くありません。 <code>Cc</code> に複数のメーリングリストが含まれたメッセージを受信した場合には、 そのメールに返事を出す前に、 <code>Cc</code> の部分を編集してください。 <em>元記事を書いたのが誰であっても、 返信する方にもクロスポストの責任があります。</em></p></li><li><p>ユーザであれ開発者であれ、(議論の中で) 個人を攻撃したり冒涜したりすることは許されません。 個人的なメールを引用したり再投稿したりする許可をもらえなかったり、 もらえそうにない時に、 それをおこなう ようなネチケット (訳注: ネットワークにおけるエチケット) に対するひどい違反は好まれませんが、 してはならないと特別に定められている わけではありません。 <em>しかしながら</em>、 そのような内容がメーリングリストの憲章に沿う場合はほとんどありません。 このため、メーリングリストの憲章に違反しているということだけで警告 (または禁止) に値するものと考えていいでしょう。</p></li><li><p>FreeBSD 以外の関連する製品やサービスの広告は、 絶対に禁止し、spam による違反者が宣伝していることが明確であったら、 すぐに禁止します。</p></li></ul></div><div class=paragraph><p><em>個々のメーリングリストの憲章:</em></p></div><div class=dlist><dl><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>FreeBSD ACPI メーリングリスト</a></dt><dd><p><em>ACPI および電源管理開発</em></p></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-fortran>freebsd-fortran</a></dt><dd><p><em>FreeBSD での Fortran</em></p><div class=paragraph><p>FreeBSD での Fortran に関連した ports の議論のためのメーリングリストです。 ラップトップから HPC クラスタまで、 コンパイラ、ライブラリ、 科学および工学のアプリケーションが対象です。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-announce>FreeBSD announcements メーリングリスト</a></dt><dd><p><em>重要なイベント/マイルストン</em></p><div class=paragraph><p>これは、単にたまに発表される重要な FreeBSD のイベントに関心がある人のためのメーリングリストです。 これは、 スナップショットやその他のリリースについてのアナウンスを含みます。 そのアナウンスは新しい FreeBSD の機能のアナウンスを含んでいます。 ボランティア等の呼びかけがあるかもしれません。 これは流通量の少ないメーリングリストで、 完全なモデレートメーリングリストです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-arch>freebsd-arch</a></dt><dd><p><em>アーキテクチャと設計の議論</em></p><div class=paragraph><p>これは、FreeBSD のアーキテクチャに関する議論を行なうためのメーリングリストです。 当然、その内容は原則的に技術的なものに限定されます。 このメーリングリストにふさわしい話題は以下のようなものです。</p></div><div class=ulist><ul><li><p>複数のカスタマイズされたビルドを同時に行うには、 ビルドシステムをどういじり直せばよいか</p></li><li><p>VFS で Heidemann レイヤを動作させるには、 何を修正する必要があるか</p></li><li><p>同一のデバイスドライバを多数のバス、 アーキテクチャに共通で使えるようにするには、 デバイスドライバインタフェースをどう改変すれば良いか</p></li><li><p>ネットワークドライバの書き方</p></li></ul></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bluetooth>freebsd-bluetooth</a></dt><dd><p><em>FreeBSD 上での Bluetooth®</em></p><div class=paragraph><p>FreeBSD の Bluetooth® ユーザが集まるフォーラムです。 デザイン、実装の詳細、パッチ、障害報告、開発進捗レポート、 機能の要求、Bluetooth® に関連したすべての事柄が対象です。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bugbusters>freebsd-bugbusters</a></dt><dd><p><em>障害報告の取り扱いに関する調整</em></p><div class=paragraph><p>このメーリングリストは、 バグマイスター、バグバスター、 および他の障害報告データベースに純粋に興味を持っているグループの調整や議論についてのフォーラムです。 このメーリングリストは、個別のバグ、パッチ、 障害報告について議論を行うためのものではありません。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>freebsd-bugs</a></dt><dd><p><em>バグレポート</em></p><div class=paragraph><p>これは、FreeBSD のバグレポートのためのメーリングリストです。 可能である場合はいつでも、バグは <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> を使うか、 <a href=https://bugs.freebsd.org/bugzilla/enter_bug.cgi>web interface</a>を用いて送られる必要があります。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-chat>freebsd-chat</a></dt><dd><p><em>FreeBSD のコミュニティに関する技術的ではない話題</em></p><div class=paragraph><p>このメーリングリストは技術的ではなく、 社会的な情報について、 他のメーリングリストでは取り扱わない話題を含みます。 これは、Jordan がシロイタチに似ているかどうか、 大文字で打つかどうか、誰がたくさんコーヒーを飲むか、 どこのビールが一番うまいか、 誰が地下室でビールを作っているか、 などについての議論を含みます。時々重要なイベント (将来開催されるパーティーや、結婚式、誕生日、 新しい仕事など) のお知らせが、 技術的なメーリングリストからでてきます。しかし、 フォローは直接 -chatメーリングリストにするべきです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-chromium>freebsd-chromium</a></dt><dd><p><em>FreeBSD 固有の Chromium の問題</em></p><div class=paragraph><p>FreeBSD における Chromium のサポートについて議論を行うためのメーリングリストです。 Chromium の開発およびインストールに関して議論を行う技術的なメーリングリストです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-cloud>freebsd-cloud</a></dt><dd><p><em>さまざまなクラウドプラットフォームでの FreeBSD の実行</em></p><div class=paragraph><p>このメーリングリストでは、FreeBSD を Amazon EC2, Google Compute Engine, Microsoft Azure およびその他のクラウドコンピューティングプラットフォームでの使用について議論を行います。</p></div></dd><dt class=hdlist1>FreeBSD core team</dt><dd><p><em>FreeBSD コアチーム</em></p><div class=paragraph><p>これは、コアメンバが使う内部メーリングリストです。 FreeBSD に関連する深刻なやっかい事の裁定やハイレベルな綿密な調査を要求するときに、 このメーリングリストにメッセージを送る事が出来ます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT メーリングリスト</a></dt><dd><p><em>FreeBSD-CURRENT の使用に関する議論</em></p><div class=paragraph><p>これは FreeBSD-CURRENT のユーザのためのメーリングリストです。 メーリングリストでの話題は、-CURRENT で登場した新しい機能について、 その新機能によってユーザに影響することについての注意、 および -CURRENT のままでいるために必要な手順についての説明を含みます。 "CURRENT" を走らせている人はこのメーリングリストに登録しなくてはなりません。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-desktop>freebsd-desktop</a></dt><dd><p><em>デスクトップでの FreeBSD の利用や改良について</em></p><div class=paragraph><p>デスクトップでの FreeBSD について議論を行うためのフォーラムです。 主として、デスクトップの移植者やユーザが FreeBSD のデスクトップサポートに関する問題点や改良について議論する場です。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/dev-ci>dev-ci</a></dt><dd><p><em>ビルドおよび試験結果の継続的インテグレーションレポート</em></p><div class=paragraph><p>ビルドおよび試験結果に関するすべての継続的インテグレーションのレポート</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/dev-reviews>dev-reviews</a></dt><dd><p><em>FreeBSD レビューツールの進行中の作業の通知</em></p><div class=paragraph><p>パッチを含む FreeBSD レビューツールによる進行中のレビュー作業の自動通知</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-doc>freebsd-doc</a></dt><dd><p><em>ドキュメンテーションプロジェクト</em></p><div class=paragraph><p>このメーリングリストは FreeBSD 向けの文書の作成に関連する事柄やプロジェクトについて議論を行なうためのものです。 このメーリングリストに参加しているメンバは、 "FreeBSD ドキュメンテーションプロジェクト" に参加していることになります。 このメーリングリストは公開されているので、 参加や投稿は自由に行なうことができます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-drivers>freebsd-drivers</a></dt><dd><p><em>FreeBSD のデバイスドライバの書き方について</em></p><div class=paragraph><p>このメーリングリストは、FreeBSD のデバイスドライバに関連した技術的なフォーラムです。 主にデバイスドライバを書く人たちが、 FreeBSD カーネルの API を使ったデバイスドライバの書き方について質問を行う場です。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-dtrace>freebsd-dtrace</a></dt><dd><p><em>FreeBSD における Dtrace の利用と開発</em></p><div class=paragraph><p>DTrace は、 カーネルおよびユーザ空間のプログラムを実行時に解析するためのフレームワークを提供するもので、 FreeBSD に統合されています。 このメーリングリストは、 コードの開発者および利用者の議論のアーカイブです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-eclipse>freebsd-eclipse</a></dt><dd><p><em>Eclipse IDE, ツール、 リッチクライアントアプリケーションの FreeBSD ユーザおよび ports</em></p><div class=paragraph><p>このメーリングリストの目的は、FreeBSD プラットフォームでの Eclipse IDE、ツール、リッチクライアントアプリケーションについて、 選択、インストール、利用、 開発および管理に関係するすべての相互支援を提供すること、 そして Eclipse IDE およびプラグインの FreeBSD 環境への移植を手助けすることです。</p></div><div class=paragraph><p>このメーリングリストのもう一つの目的は、 Eclipse コミュニティと FreeBSD コミュニティが相互に利益になるような情報交換の場を提供することです。</p></div><div class=paragraph><p>このメーリングリストは、主に Eclipse ユーザのニーズに焦点が当てられていますが、 Eclipse フレームワークを用いた FreeBSD アプリケーションの開発に関わる方々のフォーラムにもなっています。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-embedded>freebsd-embedded</a></dt><dd><p><em>組み込みアプリケーションにおける FreeBSD の利用</em></p><div class=paragraph><p>このメーリングリストは、組み込みシステムにおける FreeBSD の利用に関するトピックを議論するためのものです。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。 このメーリングリストにおいて、 組み込みシステムは、 デスクトップや通常の一般的なコンピュータ環境ではなく、 単一の目的のために使われるコンピュータデバイスを意味します。 これらの例は、 携帯電話、ルータやスイッチおよび PBX といったネットワーク機器、 PDA, POS システムといったものです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-emulation>freebsd-emulation</a></dt><dd><p><em>Linux/MS-DOS®/Windows® 等の他のシステムのエミュレーション</em></p><div class=paragraph><p>他のオペレーティングシステムに書かれたプログラムを、 FreeBSD で走らせることに関連した技術的な議論のためのフォーラムです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-enlightenment>freebsd-enlightenment</a></dt><dd><p><em>Enlightenment</em></p><div class=paragraph><p>FreeBSD システムでの Enlightenment デスクトップ環境に関連した議論。 技術的なメーリングリストなので、 完全に技術的な内容が要求されます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-firewire>freebsd-firewire</a></dt><dd><p><em>FireWire® (iLink, IEEE 1394)</em></p><div class=paragraph><p>このメーリングリストは、FreeBSD における FireWire® (IEEE 1394, iLink) サブシステムの設計と実装について議論を行うためのものです。 標準化、バスデバイスとそのプロトコル、 アダプタボード/カード/チップセット、そして、 それらに適切に対応するためのアーキテクチャとコードの実装が特に関連するトピックです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-fs>freebsd-fs</a></dt><dd><p><em>ファイルシステム</em></p><div class=paragraph><p>FreeBSD のファイルシステムに関する議論。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-games>freebsd-games</a></dt><dd><p><em>FreeBSD のゲーム</em></p><div class=paragraph><p>FreeBSD にゲームを持ち込むことに関連した議論を行うメーリングリストです。 活発にゲームを FreeBSD に移植する作業を行っている方や、 問題を提起したり、 その他の解決方法を議論したりする方のためのものです。 技術的な議論に興味のある方の参加も歓迎されます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-gecko>freebsd-gecko</a></dt><dd><p><em>Gecko レンダリングエンジン</em></p><div class=paragraph><p>FreeBSD を使った Gecko アプリケーションについてのフォーラムです。</p></div><div class=paragraph><p>このメーリングリストでは、Gecko Ports アプリケーション、インストール、開発および FreeBSD でのサポートといった話題を中心に議論が行われます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-geom>freebsd-geom</a></dt><dd><p><em>GEOM</em></p><div class=paragraph><p>GEOM および関連した実装に関する議論。 これは技術的なメーリングリストなので、 完全に技術的な内容が要求されます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-git>freebsd-git</a></dt><dd><p><em>FreeBSD での git の使用</em></p><div class=paragraph><p>FreeBSD のプロジェクトコラボレーションおける github ミラーおよびその他の git の使用など、git インフラストラクチャをどのように使うかといった議論が行われます。 FreeBSD github ミラーから git を使用する方々が議論に参加しています。 ミラーの使用を考えている方や、git の一般的な FreeBSD での使用を考えている方はここで質問できます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-gnome>freebsd-gnome</a></dt><dd><p><em>GNOME</em></p><div class=paragraph><p>FreeBSD の GNOME Desktop Environment に関する議論。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-infiniband>freebsd-infiniband</a></dt><dd><p><em>FreeBSD での Infiniband の使用</em></p><div class=paragraph><p>FreeBSD における Infiniband, OFED および OpenSM に関する技術的なメーリングリストです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ipfw>freebsd-ipfw</a></dt><dd><p><em>IP Firewall</em></p><div class=paragraph><p>これは FreeBSD の IP firewall コードの再設計に関する技術的な議論のためのフォーラムです。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-isdn>freebsd-isdn</a></dt><dd><p><em>ISDN コミュニケーション</em></p><div class=paragraph><p>このメーリングリストは、 FreeBSD に対する ISDN サポートの開発の議論をおこなう人のためのものです．</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-java>freebsd-java</a></dt><dd><p><em>Java™ の開発</em></p><div class=paragraph><p>このメーリングリストは、FreeBSD 向けの重要な Java™ アプリケーションの開発や、JDK™ の移植やメンテナンスの議論をする人のためのものです．</p></div></dd></dl></div><div id=eresources-charters-jobs class=dlist><dl><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-jobs>freebsd-jobs</a></dt><dd><p><em>求人情報および就職希望情報</em></p><div class=paragraph><p>FreeBSD に関連した就職情報、および FreeBSD に関連した職業を探している方が履歴書を投稿するためのフォーラムです。 このメーリングリストは一般的な就職情報のためのものでは <em>ありません</em>。 一般的な就職情報については、 既に別な場所に適切なフォーラムがあるので、 そちらに投稿してください。</p></div><div class=paragraph><p>他の <code>FreeBSD.org</code> メーリングリスト同様に、 このメーリングリストは全世界に配信されます。 地域に関する情報や、 在宅勤務なのか移転のための支援を受けられるかどうかを明確にしてください。</p></div><div class=paragraph><p>メールでは、オープンフォーマットのみを使う必要があります。 - プレインテキストが好ましいのですが、 多くの読者は、 Portable Document Format (PDF), HTML および他にもいくつかのフォーマットを使用できるでしょう。 Microsoft® Word (<span class=filename>.doc</span>) のようなクローズドフォーマットは、 メーリングリストのサーバにより拒否されてしまいます。</p></div></dd><dt class=hdlist1><a href=https://mail.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></dt><dd><p><em>KDE</em></p><div class=paragraph><p>FreeBSD システムにおける KDE に関する議論。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>freebsd-hackers</a></dt><dd><p><em>技術的な議論</em></p><div class=paragraph><p>これは FreeBSD に関する技術的な議論のためのフォーラムです。 これは最もテクニカルなメーリングリストです。 このメーリングリストは、FreeBSD 上でアクティブに活動をしている人のためのもので、 問題を持ち出したり、代わりの解決法を議論します。 技術的な議論をフォローするのに興味がある人も歓迎します。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hardware>freebsd-hardware</a></dt><dd><p><em>FreeBSD のハードウェアの一般的な議論</em></p><div class=paragraph><p>FreeBSD が走っているハードウェアのタイプや、 何を買ったり避けたりするかに関する様々な問題や、 提案に関する議論。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-hubs>freebsd-hubs</a></dt><dd><p><em>ミラーサイト</em></p><div class=paragraph><p>FreeBSD ミラーサイトを運用している人達向けの、 アナウンスと議論を行なうメーリングリストです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-isp>freebsd-isp</a></dt><dd><p><em>インターネットサービスプロバイダのについての話題</em></p><div class=paragraph><p>このメーリングリストは、 FreeBSD を用いたインターネット サービスプロバイダ (ISP) に関する話題の議論のためのものです。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-mono>freebsd-mono</a></dt><dd><p><em>FreeBSD における Mono および C# アプリケーション</em></p><div class=paragraph><p>FreeBSD 上での Mono 開発フレームワークに関連した議論を行うためのメーリングリストです。 これは、技術的なメーリングリストです。 Mono または C# アプリケーションの FreeBSD への移植を活発に行っている方が、 問題を提起したり、他の解決方法について議論を行うためのものです。 技術的な議論に興味を持っている方の参加も歓迎されます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ocaml>freebsd-ocaml</a></dt><dd><p><em>FreeBSD 固有の OCaml に関する議論</em></p><div class=paragraph><p>このメーリングリストは、FreeBSD における OCaml に関する議論の場です。 このメーリングリストは技術的なメーリングリストです。 OCaml port、サードパーティ製ライブラリ、 およびフレームワークに関して作業を行っている個人のためのものです。 技術的な議論に興味を持っている個人の参加が歓迎されます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-office>freebsd-office</a></dt><dd><p><em>FreeBSD でのオフィスアプリケーション</em></p><div class=paragraph><p>FreeBSD におけるオフィスアプリケーションのインストール、 開発およびサポートについての議論の場です。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ops-announce>freebsd-ops-announce</a></dt><dd><p><em>プロジェクトのインフラストラクチャに関するアナウンス</em></p><div class=paragraph><p>FreeBSD.org プロジェクトのインフラストラクチャの変更や関連した問題について興味を持っている向けのメーリングリストです。</p></div><div class=paragraph><p>このモデレートメーリングリストは、 アナウンスに制限されています (返答や要求、議論、意見を述べる場ではありません)。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-performance>freebsd-performance</a></dt><dd><p><em>FreeBSD のチューニングや速度向上に関する議論</em></p><div class=paragraph><p>このメーリングリストは、ハッカー、 管理者および関連グループが、 FreeBSD のパフォーマンスに関するトピックを議論する場です。 このメーリングリストで議論されるべきトピックは、 高負荷における FreeBSD の導入において経験するパフォーマンスの問題や FreeBSD の限界に挑むような話題を含みます。 FreeBSD のパフォーマンスを改善したいと考えている方は、 このメーリングリストに登録してください。 このメーリングリストは、FreeBSD の高速化、 堅牢さ、拡張性に興味をもっている、経験のある FreeBSD ユーザ、ハッカー、管理者向けの高度な技術的メーリングです。 ドキュメントに目を通さずに質問して答えを求めるような Q and A タイプのメーリングリストではなく、 未解決で答えのないパフォーマンスに関連したトピックへの貢献や問い合わせの場です。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-pkg>freebsd-pkg</a></dt><dd><p><em>バイナリ package 管理および package ツールについての議論</em></p><div class=paragraph><p>ソフトウェアのインストールにバイナリ package を用いる FreeBSD システム管理のすべての側面に関する議論。 バイナリ package のツールキットとフォーマット、 それらの FreeBSD における開発とサポート、 package リポジトリ管理そしてサードパーティ製 package を含みます。</p></div><div class=paragraph><p>package の作成に失敗する ports に関する議論は ports の問題として考えるべきであり、 このメーリングリストで議論することは適切ではありません。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-pf>freebsd-pf</a></dt><dd><p><em>パケットフィルタファイアウォールシステムに関する議論および質問</em></p><div class=paragraph><p>FreeBSD のパケットフィルタ (pf) ファイアウォールシステムに関連した議論。 技術的な議論およびユーザによる質問の両方が歓迎されます。 このメーリングリストは、ALTQ QoS フレームワークについて議論する場でもあります。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-pkg-fallout>freebsd-pkg-fallout</a></dt><dd><p><em>package ビルドに失敗したログ</em></p><div class=paragraph><p>package ビルドクラスタにおいて package ビルドに失敗したすべてのログ</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-pkgbase>freebsd-pkgbase</a></dt><dd><p><em>FreeBSD ベースシステムの pkg 化</em></p><div class=paragraph><p>FreeBSD ベースシステムの pkg 化に関する実装および課題についての議論。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-platforms>freebsd-platforms</a></dt><dd><p><em>Intel® 以外のプラットフォームへの移植</em></p><div class=paragraph><p>クロスプラットフォームの FreeBSD の問題。Intel® 以外のプラットフォームへの FreeBSD の移植についての一般的な議論や提案。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ports>freebsd-ports</a></dt><dd><p><em>"ports" の議論</em></p><div class=paragraph><p>FreeBSD "Ports Collection" (<span class=filename>/usr/ports</span>) に関連する話題や、 Ports Collection の基盤および ports の一般的な構成の整備活動に関する議論。 これは技術的なメーリングリストなので、 厳密に技術的な内容のみが扱われます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-announce>freebsd-ports-announce</a></dt><dd><p><em>FreeBSD "Ports Collection" に関する重要なニュースと案内</em></p><div class=paragraph><p>"Ports Collection" (<span class=filename>/usr/ports</span>) の開発者、 ports 作成者およびユーザへの重要なニュース。 アーキテクチャ/インフラストラクチャの変更、新しい機能、 重要なアップグレードの案内、 そしてリリースエンジニアリング情報が扱われます。 このメーリングリストの流量は少なく、 アナウンスを目的としたものです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>freebsd-ports-bugs</a></dt><dd><p><em>"ports" のバグに関する議論</em></p><div class=paragraph><p>"Ports Collection" (<span class=filename>/usr/ports</span>) の障害報告や新たな ports や変更についての提案についての議論。 これは技術的なメーリングリストなので、 厳密に技術的な内容のみが扱われます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-proliant>freebsd-proliant</a></dt><dd><p><em>HP ProLiant サーバプラットフォーム上での FreeBSD に関する技術的な議論</em></p><div class=paragraph><p>このメーリングリストは、HP ProLiant サーバ上での FreeBSD の利用に関した技術的な議論に用いられます。 ProLiant に特有のドライバ、管理ソフトウェア、設定ツール、および BIOS アップデートなどが含まれます。 hpasmd, hpasmcli および hpacucli モジュールについて議論する主要な場です。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-python>freebsd-python</a></dt><dd><p><em>FreeBSD における Python</em></p><div class=paragraph><p>FreeBSD における Python サポートの改良に関連した議論を行うためのメーリングリストです。 これは技術的なメーリングリストです。 Python の移植に関する作業を行っている方や、 サードパーティ製モジュールおよび Zope を FreeBSD に移植している方を対象としたメーリングリストです。 技術的な議論に興味を持っている方の参加も歓迎されます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a></dt><dd><p><em>ユーザからの質問</em></p><div class=paragraph><p>FreeBSD に関する質問のためのメーリングリストです。 技術的なメーリングリストに対しては、 極めて技術的な質問でなければ、 "どのようにして" という質問を送るべきではありません。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-ruby>freebsd-ruby</a></dt><dd><p><em>FreeBSD 固有の Ruby に関する議論</em></p><div class=paragraph><p>FreeBSD での Ruby サポートに関連した議論を行うためのメーリングリストです。 これは技術的なメーリングリストです。Ruby ports, サードパーティライブラリおよびフレームワークについて作業を行っている人達を対象としています。</p></div><div class=paragraph><p>技術的な議論に興味を持つ方の参加も歓迎されます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-scsi>freebsd-scsi</a></dt><dd><p><em>SCSI サブシステム</em></p><div class=paragraph><p>これは FreeBSD のための SCSI サブシステムについて作業している人向けです。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-security>FreeBSD security メーリングリスト</a></dt><dd><p><em>セキュリティの関連の話題</em></p><div class=paragraph><p>FreeBSD コンピュータのセキュリティの話題 (DES, Kerberos, よく知られているセキュリティホールや、 それらのふさぎ方など) これは技術的なメーリングリストなので、 完全に技術的な議論を要求します。 これは、Q and A のメーリングリストではありません。 FAQ に対する Q and A (質問と答えの両方) の貢献は、歓迎されます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>FreeBSD security notifications メーリングリスト</a></dt><dd><p><em>セキュリティ関連の通知</em></p><div class=paragraph><p>FreeBSD のセキュリティ問題や、 修正に関する通知を行ないます。 このメーリングリストは議論を行なうためのメーリングリストではありません。 議論は FreeBSD-security で行ないます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-snapshots>freebsd-snapshots</a></dt><dd><p><em>FreeBSD 開発スナップショットのアナウンス</em></p><div class=paragraph><p>このメーリングリストは、head/ および stable/ ブランチからの新しい FreeBSD 開発スナップショットのアナウンスを行います。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-stable>FreeBSD-STABLE; メーリングリスト</a></dt><dd><p><em>FreeBSD-STABLE の使用に関する議論</em></p><div class=paragraph><p>これは FreeBSD-STABLE のユーザ用のメーリングリストです。 "STABLE" は、 RELEASE 後もバグフィックスおよび新しい機能の追加など、 開発が続いているブランチです。 バイナリ互換性のため、ABI は安定するように維持されます。 メーリングリストでの話題は、-STABLE で登場した新しい機能について、 その新機能によってユーザに影響することについての注意、 および -STABLE のままでいるために必要な手順についての説明を含みます。 "STABLE" を走らせている人はこのメーリングリストに登録すべきです。 これは技術的なメーリングリストなので、 完全に技術的な内容を要求します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-standards>freebsd-standards</a></dt><dd><p><em>C99 POSIX への適合</em></p><div class=paragraph><p>C99 および POSIX 標準への FreeBSD の適合に関連した技術的な議論を行うためのフォーラムです。
::
<em>FreeBSD による教育</em></p></div><div class=paragraph><p>FreeBSD による教育について議論を行うための技術的ではないメーリングリストです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-testing>freebsd-testing</a></dt><dd><p><em>FreeBSD における試験</em></p><div class=paragraph><p>ATF/Kyua、ビルド試験のインフラストラクチャ、 他のオペレーティングシステム (NetBSD, …​) から FreeBSD への移植に関する試験など、FreeBSD の試験に関して議論を行う技術的なメーリングリストです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-tex>freebsd-tex</a></dt><dd><p><em>TeX および関連アプリケーションの FreeBSD への移植</em></p><div class=paragraph><p>TeX および関連アプリケーションの FreeBSD への移植について議論する技術的なメーリングリストです。 TeX の FreeBSD への移植作業を活発に行っている個人が、 問題を提起したり、他の解決策について議論するためのものです。 技術的な議論に興味を持っている個人の参加も歓迎されます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-toolchain>freebsd-toolchain</a></dt><dd><p><em>FreeBSD の統合されたツールチェインのメンテナンス</em></p><div class=paragraph><p>FreeBSD のツールチェインのメンテナンスに関連した議論を行うためのメーリングリストです。 Clang および GCC の状況についての議論の他に、アセンブラ、 リンカおよびデバッガ等のソフトウェアの議論も行われます。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-transport>freebsd-transport</a></dt><dd><p><em>FreeBSD でのトランスポートレベルネットワークプロトコルに関する議論</em></p><div class=paragraph><p>The transport mailing list exists for the discussion of issues and designs around the transport level protocols in the FreeBSD network stack, including TCP, SCTP and UDP. TCP, SCTP および UDP などの FreeBSD ネットワークスタックのトランスポートレベルプロトコルに関する問題や設計についての議論を行うためのメーリングリストです。 ドライバ特有の話題であったりネットワークプロトコルなどの他のネットワークに関するトピックは、 で議論してください。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-translators>freebsd-translators</a></dt><dd><p><em>FreeBSD 文書およびプログラムの翻訳</em></p><div class=paragraph><p>FreeBSD 文書を英語から他の言語へと翻訳を行っている方々が、 翻訳方法やツールについて議論を行うメーリングリストです。 新しいメンバーは、自己紹介と、 興味のある翻訳言語をお知らせください。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-usb>freebsd-usb</a></dt><dd><p><em>FreeBSD の USB 対応に関する議論</em></p><div class=paragraph><p>これは、FreeBSD の USB 対応に関連した議論を行うメーリングリストです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-user-groups>freebsd-user-groups</a></dt><dd><p><em>ユーザグループの調整のメーリングリスト</em></p><div class=paragraph><p>これは、ローカルなユーザグループがお互いに、または、 コアチームが指定した個人と問題を議論する、 それぞれのローカルエリアのユーザグループからの調整人向けのメーリングリストです。 このメーリングリストはユーザグループ間のミーティングの概要やプロジェクトの調整に制限されるべきです。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-xfce>freebsd-xfce</a></dt><dd><p><em>XFCE</em></p><div class=paragraph><p>これは、XFCE 環境を FreeBSD へ移植することを議論する、技術的なメーリングリストです。 活発に XFCE を FreeBSD に移植する作業を行なっている人に向けたもので、 問題を提起したり、新しい解決法を議論することを目的としています。 技術的な議論に興味を持っている方の参加も歓迎します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-zope>freebsd-zope</a></dt><dd><p><em>Zope</em></p><div class=paragraph><p>これは、Zope 環境を FreeBSD へ移植することを議論する、技術的なメーリングリストです。 活発に Zope を FreeBSD に移植する作業を行なっている人に向けたもので、 問題を提起したり、新しい解決法を議論することを目的としています。 技術的な議論に興味を持っている方の参加も歓迎します。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-virtualization>freebsd-virtualization</a></dt><dd><p><em>FreeBSD によりサポートされているさまざまな仮想化技術についての議論</em></p><div class=paragraph><p>FreeBSD によりサポートされているさまざまな仮想化技術に関する議論。 新しい機能および基本的な機能の実装に焦点を当てる一方で、 仮想化技術の使用の際に問題が起きた場合の手助けや議論のフォーラムでもあります。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-wip-status>freebsd-wip-status</a></dt><dd><p><em>FreeBSD の進行中のプロジェクトの状況</em></p><div class=paragraph><p>このメーリングリストは、開発者が FreeBSD に関連したプロジェクトの立ち上げや進捗状況のアナウンスに利用するためのものです。 メールはモデレータ制です。 "To:" として最も適切な FreeBSD のメーリングリストを入れ、 このメーリングリストを "BCC:" に入れることが推奨されます。 このメーリングリスト上では、議論が許されていないため、 このように送信することで、 進捗状況の議論を別の適切なメーリングリストで議論できるようになります。</p></div><div class=paragraph><p>どのようなメールが適切かについては、 アーカイブで確認してください。</p></div><div class=paragraph><p>このメーリングリストへのメッセージの編集ダイジェスト版が、 進捗状況レポート として、数ヶ月おきに FreeBSD ウェブサイトに公開されます。 過去のレポートもアーカイブされています。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-wireless>freebsd-wireless</a></dt><dd><p><em>802.11 スタック、 ツールおよびデバイスドライバの開発に関する議論</em></p><div class=paragraph><p>FreeBSD のワイヤレスに関するメーリングリストです。 バグ、新しい機能およびメンテナンスについての議論を含む、 802.11 スタック (sys/net80211)、 デバイスドライバおよびツールの開発に焦点が当てられています。</p></div></dd><dt class=hdlist1><a href=https://lists.FreeBSD.org/subscription/freebsd-xen>freebsd-xen</a></dt><dd><p><em>FreeBSD の Xen™ への移植 - 実装および利用についての議論</em></p><div class=paragraph><p>このメーリングリストは、FreeBSD の Xen™ への移植に焦点が当てられています。 このメーリングリストのトラフィックは小さいので、 技術的な議論およびデザインの詳細と管理上の問題の両方についてのフォーラムとして期待されています。</p></div></dd></dl></div></div><div class=sect3><h4 id=eresources-mailfiltering>C.2.4. メーリングリストのフィルタリング<a class=anchor href=#eresources-mailfiltering></a></h4><div class=paragraph><p>FreeBSD のメーリングリストは、スパム、 ウィルスおよび他の不要なメールを配布してしまわないよう、 いくつかの方法でフィルタリングを行なっています。 この節で説明するフィルタリングは、 メーリングリストを守るために使われている方法のすべてというわけではありません。</p></div><div class=paragraph><p>メーリングリストでは、以下の添付ファイルを送ることができます。 以下の一覧以外の MIME content type の添付ファイルを含むファイルは、 メーリングリストに流れる前に取り除かれます。</p></div><div class=ulist><ul><li><p>application/octet-stream</p></li><li><p>application/pdf</p></li><li><p>application/pgp-signature</p></li><li><p>application/x-pkcs7-signature</p></li><li><p>message/rfc822</p></li><li><p>multipart/alternative</p></li><li><p>multipart/related</p></li><li><p>multipart/signed</p></li><li><p>text/html</p></li><li><p>text/plain</p></li><li><p>text/x-diff</p></li><li><p>text/x-patch</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>他の MIME content type の添付を許可するメーリングリストもありますが、 上の一覧に含まれるものであれば、 ほとんどのメーリングリストで適用できます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>HTML と plain テキストを両方含むメールでは、 HTML の部分が削除されます。 HTML のみを含むメールは、plain テキストに変換されます。</p></div></div></div><div class=sect2><h3 id=eresources-news>C.3. Usenet ニュースグループ<a class=anchor href=#eresources-news></a></h3><div class=paragraph><p>2 つの FreeBSD 用のニュースグループに加え、他にも FreeBSD の議論をしたり FreeBSD に関連するユーザがいるニュースグループがたくさんあります。</p></div><div class=sect3><h4 id=_bsd_用のニュースグループ>C.3.1. BSD 用のニュースグループ<a class=anchor href=#_bsd_用のニュースグループ></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix.bsd.freebsd.announce>comp.unix.bsd.freebsd.announce</a></p></li><li><p><a href=news:comp.unix.bsd.freebsd.misc>comp.unix.bsd.freebsd.misc</a></p></li><li><p><a href=news:de.comp.os.unix.bsd>de.comp.os.unix.bsd</a> (ドイツ)</p></li><li><p><a href=news:fr.comp.os.bsd>fr.comp.os.bsd</a> (フランス)</p></li></ul></div></div><div class=sect3><h4 id=_関連する他の_unix_のニュースグループ>C.3.2. 関連する他の UNIX® のニュースグループ<a class=anchor href=#_関連する他の_unix_のニュースグループ></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix>comp.unix</a></p></li><li><p><a href=news:comp.unix.questions>comp.unix.questions</a></p></li><li><p><a href=news:comp.unix.admin>comp.unix.admin</a></p></li><li><p><a href=news:comp.unix.programmer>comp.unix.programmer</a></p></li><li><p><a href=news:comp.unix.shell>comp.unix.shell</a></p></li><li><p><a href=news:comp.unix.misc>comp.unix.misc</a></p></li><li><p><a href=news:comp.unix.bsd>comp.unix.bsd</a></p></li></ul></div></div><div class=sect3><h4 id=_x_window_システム>C.3.3. X Window システム<a class=anchor href=#_x_window_システム></a></h4><div class=ulist><ul><li><p><a href=news:comp.windows.x>comp.windows.x</a></p></li></ul></div></div></div><div class=sect2><h3 id=eresources-web>C.4. オフィシャルミラー<a class=anchor href=#eresources-web></a></h3><div class=paragraph><p><a href=#central-mirrors>Central Servers</a>, <a href=#armenia-mirrors>Armenia</a>, <a href=#australia-mirrors>Australia</a>, <a href=#austria-mirrors>Austria</a>, <a href=#czech-republic-mirrors>Czech Republic</a>, <a href=#denmark-mirrors>Denmark</a>, <a href=#finland-mirrors>Finland</a>, <a href=#france-mirrors>France</a>, <a href=#germany-mirrors>Germany</a>, <a href=#hong-kong-mirrors>Hong Kong</a>, <a href=#ireland-mirrors>Ireland</a>, <a href=#japan-mirrors>Japan</a>, <a href=#latvia-mirrors>Latvia</a>, <a href=#lithuania-mirrors>Lithuania</a>, <a href=#netherlands-mirrors>Netherlands</a>, <a href=#norway-mirrors>Norway</a>, <a href=#russia-mirrors>Russia</a>, <a href=#slovenia-mirrors>Slovenia</a>, <a href=#south-africa-mirrors>South Africa</a>, <a href=#spain-mirrors>Spain</a>, <a href=#sweden-mirrors>Sweden</a>, <a href=#switzerland-mirrors>Switzerland</a>, <a href=#taiwan-mirrors>Taiwan</a>, <a href=#uk-mirrors>United Kingdom</a>, <a href=#usa-mirrors>United States of America</a>.</p></div><div id=central-mirrors class=paragraph><p><strong>Central Servers</strong></p></div><div class=ulist><ul><li><p><a href=https://www.FreeBSD.org/ class=bare>https://www.FreeBSD.org/</a></p></li></ul></div><div id=armenia-mirrors class=paragraph><p><strong>Armenia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.at.FreeBSD.org/ class=bare>http://www.at.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=australia-mirrors class=paragraph><p><strong>Australia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.au.FreeBSD.org/ class=bare>http://www.au.FreeBSD.org/</a></p></li><li><p><a href=http://www2.au.FreeBSD.org/ class=bare>http://www2.au.FreeBSD.org/</a></p></li></ul></div><div id=austria-mirrors class=paragraph><p><strong>Austria</strong></p></div><div class=ulist><ul><li><p><a href=http://www.at.FreeBSD.org/ class=bare>http://www.at.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=czech-republic-mirrors class=paragraph><p><strong>Czech Republic</strong></p></div><div class=ulist><ul><li><p><a href=http://www.cz.FreeBSD.org/ class=bare>http://www.cz.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=denmark-mirrors class=paragraph><p><strong>Denmark</strong></p></div><div class=ulist><ul><li><p><a href=http://www.dk.FreeBSD.org/ class=bare>http://www.dk.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=finland-mirrors class=paragraph><p><strong>Finland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.fi.FreeBSD.org/ class=bare>http://www.fi.FreeBSD.org/</a></p></li></ul></div><div id=france-mirrors class=paragraph><p><strong>France</strong></p></div><div class=ulist><ul><li><p><a href=http://www1.fr.FreeBSD.org/ class=bare>http://www1.fr.FreeBSD.org/</a></p></li></ul></div><div id=germany-mirrors class=paragraph><p><strong>Germany</strong></p></div><div class=ulist><ul><li><p><a href=http://www.de.FreeBSD.org/ class=bare>http://www.de.FreeBSD.org/</a></p></li></ul></div><div id=hong-kong-mirrors class=paragraph><p><strong>Hong Kong</strong></p></div><div class=ulist><ul><li><p><a href=http://www.hk.FreeBSD.org/ class=bare>http://www.hk.FreeBSD.org/</a></p></li></ul></div><div id=ireland-mirrors class=paragraph><p><strong>Ireland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ie.FreeBSD.org/ class=bare>http://www.ie.FreeBSD.org/</a></p></li></ul></div><div id=japan-mirrors class=paragraph><p><strong>Japan</strong></p></div><div class=ulist><ul><li><p><a href=http://www.jp.FreeBSD.org/www.FreeBSD.org/ class=bare>http://www.jp.FreeBSD.org/www.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=latvia-mirrors class=paragraph><p><strong>Latvia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.lv.FreeBSD.org/ class=bare>http://www.lv.FreeBSD.org/</a></p></li></ul></div><div id=lithuania-mirrors class=paragraph><p><strong>Lithuania</strong></p></div><div class=ulist><ul><li><p><a href=http://www.lt.FreeBSD.org/ class=bare>http://www.lt.FreeBSD.org/</a></p></li></ul></div><div id=netherlands-mirrors class=paragraph><p><strong>Netherlands</strong></p></div><div class=ulist><ul><li><p><a href=http://www.nl.FreeBSD.org/ class=bare>http://www.nl.FreeBSD.org/</a></p></li></ul></div><div id=norway-mirrors class=paragraph><p><strong>Norway</strong></p></div><div class=ulist><ul><li><p><a href=http://www.no.FreeBSD.org/ class=bare>http://www.no.FreeBSD.org/</a></p></li></ul></div><div id=russia-mirrors class=paragraph><p><strong>Russia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ru.FreeBSD.org/ class=bare>http://www.ru.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=slovenia-mirrors class=paragraph><p><strong>Slovenia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.si.FreeBSD.org/ class=bare>http://www.si.FreeBSD.org/</a></p></li></ul></div><div id=south-africa-mirrors class=paragraph><p><strong>South Africa</strong></p></div><div class=ulist><ul><li><p><a href=http://www.za.FreeBSD.org/ class=bare>http://www.za.FreeBSD.org/</a></p></li></ul></div><div id=spain-mirrors class=paragraph><p><strong>Spain</strong></p></div><div class=ulist><ul><li><p><a href=http://www.es.FreeBSD.org/ class=bare>http://www.es.FreeBSD.org/</a></p></li><li><p><a href=http://www2.es.FreeBSD.org/ class=bare>http://www2.es.FreeBSD.org/</a></p></li></ul></div><div id=sweden-mirrors class=paragraph><p><strong>Sweden</strong></p></div><div class=ulist><ul><li><p><a href=http://www.se.FreeBSD.org/ class=bare>http://www.se.FreeBSD.org/</a></p></li></ul></div><div id=switzerland-mirrors class=paragraph><p><strong>Switzerland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ch.FreeBSD.org/ class=bare>http://www.ch.FreeBSD.org/</a> (IPv6)</p></li><li><p><a href=http://www2.ch.FreeBSD.org/ class=bare>http://www2.ch.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=taiwan-mirrors class=paragraph><p><strong>Taiwan</strong></p></div><div class=ulist><ul><li><p><a href=http://www.tw.FreeBSD.org/ class=bare>http://www.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www2.tw.FreeBSD.org/ class=bare>http://www2.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www4.tw.FreeBSD.org/ class=bare>http://www4.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www5.tw.FreeBSD.org/ class=bare>http://www5.tw.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=uk-mirrors class=paragraph><p><strong>United Kingdom</strong></p></div><div class=ulist><ul><li><p><a href=http://www1.uk.FreeBSD.org class=bare>http://www1.uk.FreeBSD.org</a></p></li><li><p><a href=http://www3.uk.FreeBSD.org/ class=bare>http://www3.uk.FreeBSD.org/</a></p></li></ul></div><div id=usa-mirrors class=paragraph><p><strong>United States of America</strong></p></div><div class=ulist><ul><li><p><a href=http://www5.us.FreeBSD.org/ class=bare>http://www5.us.FreeBSD.org/</a> (IPv6)</p></li></ul></div></div></div></div><div class=sect1><h2 id=pgpkeys>付録 D: PGP 公開鍵<a class=anchor href=#pgpkeys></a></h2><div class=sectionbody><div class=paragraph><p><code>FreeBSD.org</code> オフィサの PGP 公開鍵を以下に示します。 これらの公開鍵は、署名を検証したり、 オフィサに暗号メールを送る必要がある場合に使用できます。 すべての FreeBSD 公開鍵の一覧は、 <a href=https://docs.freebsd.org/en/articles/pgpkeys/>PGP Keys</a> にあります。 また、完全なキーリングは <a href=https://docs.FreeBSD.org/pgpkeys/pgpkeys.txt>pgpkeyring.txt</a> からダウンロードできます。</p></div><div class=sect2><h3 id=pgpkeys-officers>D.1. オフィサ<a class=anchor href=#pgpkeys-officers></a></h3><div class=sect3><h4 id=_セキュリティオフィサチーム_security_officerfreebsd_org>D.1.1. セキュリティオフィサチーム <code>&lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>></code><a class=anchor href=#_セキュリティオフィサチーム_security_officerfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/D9AD2A18057474CB 2022-12-11 [C] [expires: 2026-01-24]
      Key fingerprint = 0BE3 3275 D74C 953C 79F8  1107 D9AD 2A18 0574 74CB
uid                            FreeBSD Security Officer &lt;security-officer@freebsd.org&gt;
sub   rsa4096/6E58DE901F001AEF 2022-12-11 [S] [expires: 2025-01-15]
sub   rsa4096/46DB26D62F6039B7 2022-12-11 [E] [expires: 2025-01-15]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGOVdeUBEADHF5VGg1iPbACB+7lomX6aDytUf0k2k2Yc/Kp6lfYv7JKU+1nr
TcNF7Gt1YkajPSeWRKNZw/X94g4w5TEOHbJ6QQWx9g+N7RjEq75actQ/r2N5zY4S
ujfFTepbvgR55mLTxlxGKFBmNrfNbpHRyh4GwFRgPlxf5Jy9SB+0m54yFS4QlSd0
pIzO0CLkjHUFy/8S93oSK2zUkgok5gLWruBXom+8VC3OtBElkWswPkE1pKZvMQCv
VyM+7BS+MCFXSdZczDZZoEzpQJGhUYFsdg0KqlLv6z1rP+HsgUYKTkRpcrumDQV0
MMuCE4ECU6nFDDTnbR8Wn3LF5oTt0GtwS0nWf+nZ1SFTDURcSPR4Lp/PKjuDAkOS
P8BaruCNx1ItHSwcnXw0gS4+h8FjtWNZpsawtzjjgApcl+m9KP6dkBcbN+i1DHm6
NG6YQVtVWyN8aOKmoC/FEm1CWh1bv+ri9XOkF2EqT/ktbjbT1hFoFGBkS9/35y1G
3KKyWtwKcyF4OXcArl6sQwGgiYnZEG3sUMaGrwQovRtMf7le3cAYsMkXyiAnEufa
deuabYLD8qp9L/eNo+9aZmhJqQg4EQb+ePH7bGPNDZ+M5oGUwReX857FoWaPhs4L
dAKQ1YwASxdKKh8wnaamjIeZSGP5TCjurH7pADAIaB3/D+ZNl2a7od+C1wARAQAB
tDdGcmVlQlNEIFNlY3VyaXR5IE9mZmljZXIgPHNlY3VyaXR5LW9mZmljZXJAZnJl
ZWJzZC5vcmc+iQJSBBMBCgA8AhsBBAsJCAcEFQoJCAUWAgMBAAIeBQIXgBYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJjlXeQBQkF3u+rAAoJENmtKhgFdHTLOVoQALS3
cj7rqYkHiV4zDYrgPEp9O1kAyGI8VdfGAMkDVTqr+wP4v/o7LIUrgwZl5qxesVFB
VknFr0Wp5g9h0iAjasoI5sDd6tH2SmumhBHXFVdftzDQhrugxH6fWRhHs0SaFYCk
Qt5nFbcpUfWgtQ35XTbsL8iENdYpjKXsSFQrJneGSwxIjWYTFn6ps/AI3gwR8+Bn
OffEFdYugJ049O6Vu6YBFJHrnMO7NbF4v95dVYuLtpMIaXWM+V9KITmhaBzFz5fM
Q7UOzcLlbxOYKNIWcp8QQk429mayKW5VUeUExUD1ZzBHn+P6ZG7QTMDu/RmBqiHo
ewCMVz4n9uXT5BiOngE4CvS0WQwHzK+k9MLpG2u/Bo9+LT0Ceh9Ou1rfU5+0tRwl
GyOFFjf3INS7I7gkcAwxQ7dzDItN/UQPZpg8y9mABU2x4enz0AvTnb61d/1dnTEr
tdNgU433he0ZnD1HurZCjBEWC656wv6iMdWcD8gjhMbmEpPmjvXcYlTO6zhEygSM
DiwdQCWK2W4++YJerA6ULBi3niNWBpofOFH8XylV56ruhjtHCo7+/3carcMoPOJv
lVZ1zCKxLro3TRBT15JTFBGqblRyTopFK3PuxW//GTnZOtpQEOV6yL4RAXcWeC1d
1hb5k/YxUmRF6XsDNEH4b08T8ZO8dV3dAV43Wh1oiQEzBBABCAAdFiEEuyjUCzYO
7pNq7RVv5fe8y6O93fgFAmObXVYACgkQ5fe8y6O93fiBlwf/W8y1XXJIx1ZA3n6u
f7aS70rbP9KFPr4U0dixwKE/gbtIQ9ckeNXrDDWz0v0NCz4qS+33IPiJg1WcY3vR
W90e7QgAueCo5TdZPImPbCs42vadpa5byMXS4Pw+xyT+d/yp2oLKYbj3En4bg1GM
w71DezIjvV+e01UR++u1t9yZ8LOWM5Kumz1zyQLZDZ8qIKt1bBfpa+E0cEqtNQWu
iGhQE3AHI8eWV+jBkg5y2zHRIevbWb1UPsj43lgkFtAGHk9rrM8Rmgr4AXr531iD
srBwauKZ/MElcF3MINuLH+gkPPaFHw/YIpLRLaZXZVsw3Xi1RNXI2n2ea29dvs/C
Lcf1vYkCMwQQAQgAHRYhBPwOh4rlr+eIAo1jVdOXkvSep+XCBQJjm14FAAoJENOX
kvSep+XC0DcP/1ZB7k9p1T+9QbbZZE1PJiHby3815ccH3XKexbNmmakHIn3L6Cet
F891Kqt9ssbhFRMNtyZ/k/8y8Hv5bKxVep5/HMyK+8aqfDFN0WMrqZh0/CiR6DJh
gnAmPNw/hAVHMHaYGII9kCrFfPFJ02FKoc81g9F08odb7TV+UlvRjkErhRxF+dGS
wQoO0RCbf0Z1cs7nd0Vb2z4IJh4XMxBjWc/uQ2Q9dH/0uRzwpAnR4YX+MG5YrX7Z
zBvDyR0r76iQwRSDKgioNgkr6R3rq1NZGdaj+8b0LzdOqtzKJ/eupDe3+H67e/EN
qymtreGjrubpiU9bKvYArisUqhE5KtguryvR6Qz9bj87nPg33DT3WWGVrwFRxBox
dbWzjQFv0wug8m4GAwVF7fPR5/eW7IHw8zvgn0vSPcZz7MZ4e6Y5jN4kA5/xWJYZ
Sps54qQWB+FA30unIXN68KqdIzONIbtaY3W4/JjJUCm4T+wEjKaH+wJX8w1DMjlg
mkTmGh/UrTyC1vXbPgk9Sy3cRTICR1T9z7W8UlmTtnKrUklrjlFR7SXzrEXzLGOX
Fm+NEHpHNXqzcm6c3QfzY/yQ9HSAQ/t7SUQ9caRePbDz3/msyPxtGFor9roQv6VN
wRXCyRgkH4Y5tPhJAQ8G/FxX+VXFb93QL0lfelb23/BBu6cUwW63SRn5uQINBGOV
dskBEADqo8z6TFAhrvHhJV5wHdj67guoYvpXP8gvdCqos8SLluqi0AWgJEwlqu7L
mKQ6qMoJ+2DN6y+dEtvOVgBAgF63LLf3FQKq9FB/3uqeIiQlCIl3H43f8KttEZzf
/lbry4Y6QhS2OXM31Ut9Q+1IfTGwvs1E8/J1U4jQrAGqNKknXyQyMweJ0jvvcSLJ
nv3S7COUJVOT3cTgVeh3RIQlFzqK2rSQmygDpS8bT8MjCsZr+KGezKpbddKXio4a
QW/e6nCMyYR8bo0GQ9DpsyAOsaENnkghncQhA7GdPZK9xLMNQMCp0OdcZlqRVjRZ
OutuzNW6PPoczs/NQq02YWK4BPtSV7+ldS9gPZTLIpnRNQRzcnA0vnQTqSAfasVw
sAGm+MpH7zcaMf2Tw1K08u7+5gyObgzUzQmGLCgo9VIncnDis0s4gfTmtrr5jCeV
7LYDQX+2fApMtXbVXeKJem1PS+Z6LPbW2HklxYuG5nFgewCYlQjKujfiwW1Clhi4
JQeE1Naobbaar99V/VeoHrOYAEWP0bkUyrFcocLJ+0g3KpjSkctIptgGGpMBKe4U
9O7pWoTki8Yz/uYQn/p0iZcG8SfKM8I4283jdsi5SUiNNJJZCBQTVA7d8MxUVv5+
qpX/v5XqYM3pHza2DLXzwfAE9O2dgN1OMZYIld+OnWcpm2PxIwARAQABiQRyBBgB
CgAmFiEEC+MydddMlTx5+BEH2a0qGAV0dMsFAmOVdskCGwIFCQICKQACQAkQ2a0q
GAV0dMvBdCAEGQEKAB0WIQS2FSd+gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBu
WN6QHwAa77gbEADpUBT14cesITuMsOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMP
Xih9G1tDo9ExIWT8jNjSSA+w0Viua/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJW
y944YegHF/5ytntwZ/L4BMYc3MztyZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37
bbUVw62xHQIn2zafSmMQ4oMXZTm9EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1
G9jqkwlaRYWjcLD0qxwc5m9LNrF6OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDC
lTTH+dAx3b6J1KFB0UiHP3FeTalFh8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2
RAo/o2X5r40qk/lhydQRZTSTFsiuH3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7r
e0jj8XMIO7G5yjQKQCnYuPdXbx++bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17
MEPIton1+NRfsU0peEVggQXlwdTcZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpK
a9qfIqBX/monjy7w5IHmhvLwAYI6IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69
PxMbOJbMpWSg8L7xW3LXKR1VwXggUC1+b3y67E5Ggi1hf0lfTnTMpL2ClO2QD/oC
hMIafhzxbjh2WzgYahVHZH3gpHc1/0Bnc07s9+Pa6EYYM9r0XzezLW7bswOjVloR
FreQ3FIF/2OSN0OGdm7dyYl0OliTIDDDlwK/l8bcckUcpHNR1dw0P3KvDlmLmzZy
G4HmzzSBa9jiFirEfcg2rnGc6Zi382jGVALuYVplPXyMOUiChp0AAQZzTIYpXw/g
pBE6em2k740yuK6WqG4yXXgk67FoH10TQvMd4Q73K4zw+9DMpThlUHcfBmAoViZw
il7C0xl+ysHX8ZI3JU8s1r3XAnpqdHi4Wpixm/ctXbVnTSA3FQr2SctJYqR1VHRW
GMW+Ii2SQDS+t9bZTzOgAPLDtfy+JqhBpwCB1a1EHftkJEojpfZipaYGkf3yc+vN
wUeUHp/csF9CT7Qbqaj1t7fVWzv7jcVKpRwngIT4vTSzqbo6WC34FuUAH0t7tJ5K
eZ625AqEFLmtqtDo+ydJhZrVrXBNXPfkx5hSVW/I9hvckMNwA3t0KfQC2sz+Z1Q1
a4vDWQYRytfyrgZkWGbXMn6l1JyqIolgJZuax2kYs7Vu3t8KptqCbv0ZBAGoMm7r
RLgVodhI9voA8YxCirSChrueJYn+JKk8MIyk3DdXpBoocMIAjFJAUgXjV5NQpZMy
xR8BEiQnBcHRIKVWEEyhbLtHpmCEsnKNyKVGoxs31IkEcgQYAQoAJgIbAhYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJlhctvBQkD8n2mAkDBdCAEGQEKAB0WIQS2FSd+
gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBuWN6QHwAa77gbEADpUBT14cesITuM
sOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMPXih9G1tDo9ExIWT8jNjSSA+w0Viu
a/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJWy944YegHF/5ytntwZ/L4BMYc3Mzt
yZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37bbUVw62xHQIn2zafSmMQ4oMXZTm9
EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1G9jqkwlaRYWjcLD0qxwc5m9LNrF6
OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDClTTH+dAx3b6J1KFB0UiHP3FeTalF
h8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2RAo/o2X5r40qk/lhydQRZTSTFsiu
H3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7re0jj8XMIO7G5yjQKQCnYuPdXbx++
bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17MEPIton1+NRfsU0peEVggQXlwdTc
ZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpKa9qfIqBX/monjy7w5IHmhvLwAYI6
IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69PxMbOJbMpWSg8L7xW3LXKR1VwXgg
UC1+b3y67E5Ggi1hf0lfTnTMpL2ClAkQ2a0qGAV0dMsjqhAAorQ725G342raJ+os
6+E/EFNsr4SR5H+AeinlQ2ymNSeO/ODsV6dmyYD3hed0mAXvIJt2B46fFC4eAP9f
VOIbMMhPMpnJuZyLPDi8gXcZLgWSRhJ88R98KIsmKlh+/fdZM4RI1JLjICi7kyNR
4jtKCzLj0DYVBzp1mn0lTwtFzv7SC9djpqFLnO5YoGPWfQHHhY02Trh2posRwAHO
oacXSFvsoQv6k6XNlStJ4lnrkH6t+Od4kU3/TJ0eQXs7Zd2WEVnMe1IhbihsGcAY
mzZzZlLOhskHCeVE2taHiXC6h4tC3/69I16N8ICauxGY41clPhiNmVaAzmkunOPz
ry5utl6HkpZ5/3UMVHI1JIvsfJW+vSMUhdcQILAv6DbRWWHeax3ZZ6iAVGCtJS7U
glwZM1Xor0okGtIS+aJ/Cw7tZ8Nm18lutcrf2MVW+BWpzMQKnWFQYTn1NEWjzYnx
9Na22+E8AvW02TdS0NSiP0sG/0q7lBNEck9vH4WEbbEXktj51Dg4ISUhQyW8BWwW
X+kSiNeqtcaikUb8SFj5vpTDotTSzikfT/jisvR5goTMNFCVHFZdXCdsbUZd8Iub
egAOh6Db/06y3mFYDEfcGJipab400OY03a2xw9Vz+YxrKfELCTBo2tZv+3K8kXgq
XFcbyJnkXmjnYM/sw5kKqtzuc7i5Ag0EY5V3BwEQAMpFVczZo9ZPNsgW791UW5o6
wnrnd1nIO+S4rc37q2TEz8KGHCuxo5NwffZ2t6Ln04BI54pbapg17b7a0hPka37H
FkL28n4VyMdx0CsAm3QEfUsdK6xwKV2SucYeVcrV1upcN4PdXD7su1I7/A4CWXFJ
G047zJ0Z89lJZiQEiAq7ghvEoinC0sm+0a6ao/ocqCgWCKM1yCPOyzJXleRrv29S
RnYziMR+q2U0x9xg9Xl6GMwUmFwbJc9nORVvLH7fbU6/du8EgoAYrglFOFZG/TSo
lSGWRSMiavz0JSD/i+rEN4aIT4WfBe+L9Wy1AmrNxiAO+zKmzHQu3JSxDncr+y+h
cd+W0gqw10FoI9jWLcL7kR+6a0iOjuJSXSopq2l3DafiPxtCFmr4CGQhzBHM6e4/
v/NNd3F0XpVbJ6RQph7lkfvfz8q2lvUlHhezJ0p1xXmhff9CHjdVMhmAmz5+imBA
Xk2mottNfKb0pFEen1xY3K/UPA4g+oPsSj495MsvIg9eIMCcC3/z0SEUMWH/styy
JzPqfpyfGwZeTcIj9vg2o+RnGvmcLVYA/EGToPk905kv/cK73oy8bZyOB0zMg7T9
PaWgLUO0sqjqo0Mw3knFySg3oRXlcilPQvfPdX0JvwLpc9DWlr1+1GkCXJ08lWug
Jc96CJQupKRb1IbC0oUXABEBAAGJAjwEGAEKACYWIQQL4zJ110yVPHn4EQfZrSoY
BXR0ywUCY5V3BwIbDAUJAgIpAAAKCRDZrSoYBXR0ywwtD/wIDmEcHdFlyFRTomUB
jbeK2uzcZIhkkgL58lc63UPle5iJ2FBvmYS+0rQS53sVEsccn5KfkOwTryKllvWb
l0IzuiqfawxALcfWpfZJHzTMSnDHfgXvOOyFMQruqRDAHAr7PNC0CnbT0sEF2ZFz
ad8M9fLqtkXUx4mgECNGJ4CVqg75KY8uUzv/BmRwEf587FT5/iAIed5MjFB2VFDX
9GABcvTTbHxCZIxnxl3cs15SxT0lAofZ2ueU6kWYWZSXFeaEM/4ymPJws2mmV0Ak
bJghLXCn9Mx3nX6NTZZ9Harbru+RzW3/Hg3DZd0J9vko8PafP0l1NWtgyX74CqvT
gjzTxXTnqrRXzcczK7fhcC2u4i0prPtXXcyyi7SwpoLikaZCLFFhUmOx+mS5Tjtg
FyFZBNxnO7iAwkzfcTcC9sPoWaFmiQf6q5EIYzG+WQpncj80mxl3HWOP6oFj/hZJ
RYseKeMkvJzLTo87rFdM6CsMrLwETR6e+aWM0btPFil1rXVACNOjsy0bxTV8OJEf
yxnYmyjvnBvB0kdiaVEDdVhxgSqzLAX4mgXa49/V6M/uzMr+n3/A1Jdk4V6fVm8S
5cFIXxoUat3cB4xGaT9OWD3o1NPr6eS9Vo0EsJlRl81SG68fS+Qtk2fX27T68YG4
Aa3zMfZxUsVuFLtTuQbRC+fJpIkCPAQYAQoAJgIbDBYhBAvjMnXXTJU8efgRB9mt
KhgFdHTLBQJlhcuqBQkD8n1oAAoJENmtKhgFdHTLoO0QAJsTE9fkleb7YzPEuP9G
J3jx8PGdWm7n+8UNdr24kS6gOXVUfPZrWa5So21hcIwZb4PZDqHSVSQnRciKhSnG
7gplYPNGZ4+FWbLr/mBRYarjkVFLUuCPexSIjxV1KSGJnWs9YTVAKZAz75GpCML6
jD6biCOQCQ86wqOdWvZIZR8YvurrxR64ABB0rjbsaG8cNOUX1cwAfdLwthf64dS+
2m3lqNGDHkP5eNL0RIxC5gXYEp0lvmlMH3ZuO5WrfH73PTDg89bxXeuhrFmSEwf4
xWm603oi8/2qQvR9/7jb0o+t71NQuWrWIFONZWWgZBUGso+uyT3XgY4YqKGR3z2Q
zKHYnJ6M7SvSYpqS7RtcxcCXF0HGNfES8cAgtKVpFtbtSwXXp8O8oLyjmVIO/NjU
pbLOGdFIsarsezLFV9f2fqZ63J34hyUSg8LrYVV1fA5DJUpebbX4hLpdk0MMtgG4
3BwKIGlJTpL5RkQ/uQU3YW2kairy7o+1imDD0TRzQxtdjVOI5vnlTNcfJZIIfLx4
drABA12OvpX3dfPV62R+8BAlJFT430CG6AISJIBqJRFvuikmnZGUvEHmOUs/FLbb
aXTPkKc7tR2WIwljRvMV+Qk84cWcX6YchMslMuiDM1mtlQZig34WHGSE+zCWnXAs
lIHlSwox7qfdO0Kz2XncSbIA
=QvUh
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_コアチーム書記_core_secretaryfreebsd_org>D.1.2. コアチーム書記 <code>&lt;<a href=mailto:core-secretary@FreeBSD.org>core-secretary@FreeBSD.org</a>></code><a class=anchor href=#_コアチーム書記_core_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/4D632518C3546B05 2024-02-17 [SC] [expires: 2025-02-16]
      Key fingerprint = 1A23 6A92 528D 00DD 7965  76FE 4D63 2518 C354 6B05
uid                            FreeBSD Core Team Secretary &lt;core-secretary@FreeBSD.org&gt;
sub   rsa4096/CABFDE12CA516ED2 2024-02-17 [E] [expires: 2025-02-16]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGXQ1o8BEAC+Rcg8cmVxuP17Vu+q5KgCx/XiulQuqKXAqqBlYCH2jqk6DINP
yFrREGBhzd/qNmlAYEahQ4Zgl0bUZNTrZVDyzicOvPP0jH+KSTQwRs7NOawEdlVO
cyHrwDCPEqf5ZzD4NhfTriEOw+j0pEH/onitUGvoQRtx15xWyaJQxDEBMTYMLewE
86D1bltwnTNczE3UZb7oQLJXkAX5hcLtou70XJGgZITvJkK+kp/xot2eFjnqRz/u
WeXnKhYAmC07EKwZ1uw047eHKwMMRBYqzApLwoQtfE430Kxf2q8de64x8zDbi6YM
1J4r8OAxOtHVyfJ0j7Q23DEZz0VVb4b1Tx5OG2Re/KSNvqI0awJO4TcRmOR88OyY
dzyXgnX6Sa7GVQY1FXvn7vtFuDAt7egZOzeomSHL9bdX07LTQ4UtM88EV9wm3q4q
smoatV9jsvPQ1zxCU3aQD/5eWTJH2/kz1LIuBL/Qi5XQpJn91lBtUWJrCgkHWPGu
f//rnnXmsG7DAChW+yZ7cFO8lfNa8sFhPqSxCYphWmJTrvadyQtDngB8JakWdnmK
pfGS6y5lel+181vw38ZZKt04AKM+nDY8051lBM7Q9Q6kTLI33UZeImndx5xYukVD
kV6aQ31HYfEark15c7iEz+OAcwFnM2ntXMt7kKGd40CqzusiPcQkPqPbAQARAQAB
tDhGcmVlQlNEIENvcmUgVGVhbSBTZWNyZXRhcnkgPGNvcmUtc2VjcmV0YXJ5QEZy
ZWVCU0Qub3JnPokCVwQTAQoAQRYhBBojapJSjQDdeWV2/k1jJRjDVGsFBQJl0NaP
AhsDBQkB4TOACAsJDQgMBwsDBRUKCQgLBRYDAgEAAh4FAheAAAoJEE1jJRjDVGsF
nacP/3PSg8JPmWoBfWrgT287NZ7OAU16/uGpDxlBUoVeEtkEDqZVW8yBFzrMhbwj
bJs3CZ+L85HMUDLZoxSwVnPM8PLVRzHTybYV7agYYzMox5C/jp2aeAgy9KYVd0Tk
07GMTYrSh4fhHWpxXz7IBOxk0RXvQxTHlg1u0DASkibYb2UTDcUNG5Q9kP/8jaIZ
kVDX8a5LDdOCgWaYdKPg4blv/UMjkegJz+Ayp7gXTcux6koW5F6ysSw9sgLBWb2D
b/KNIi4MBMe46xyXB/dqGAR4ibrUXTcQ4OAZNq1L6uWG1A49XuSgykdIwr00MzQw
wfVpKT31ww4ayVHLgj7NuqPlab9S5/fPfJ4MAvGE4GqWQFgsPKgKImUMgnnxTGpv
l7Dqk2MnWqn+wEi0bRES0PVBG96G+sZJQeaxBhoB+HwUSFqoZQg166AJIl//4t2w
bx0a1aWQSS0DZt3wsQW3NW9AE6L+FnFfIc2pQVoLjmvcGalDuvnemRmEOgotiZmt
32bi2aWxg0/Qio2rjLS2LpV+fhwDSN3Agvtnu53yUdD1TFFjTSMloM4SKhiXoPbI
XgfCLiBLNMsZL0AvO7wQfSePzPYxDLyEcwsfPJ8be+eGG1L62RUyad+MdfyXMH/S
m0sgqW/MW6Nv10RyPQOq3Jbgmp2laRMzKTOvQt5WwQf2FEl9uQINBGXQ1o8BEAC9
1cBYn6Z0QmM0OFWdXQI6fMOeNokaa6ngPgt7bzW5NjryqTdwyHOPZdm4DWf1SO/0
+fJRCqxbICyuMAFrb9fDle8bodALjm5ZquTL3D61HpZD4+RwOzOjYP6wLm7h38HT
/yIyK882Ovlw4Xz/TeSiL/VUSWE9twW7yz3oreCeLUBAfzacS9y+syO+aquEd0/x
JBz+mPQbrqfS64rCZXMZEivgsjkQoE6RM+n1rF4kw4Eu3E2kPevVwsoAaY+MEUM8
JAXaJMaNcLIhbeMy7dO/z6z2I3h5bUw5KxfVwzYSzSeRpYh53dNaB4NY+f5/vTrL
4dZmqBcLgcV0zZ02dj/u0SiwWlUFUpFGuSiW16DN7+2zG1zOWi7Nl44JawM62Tlf
mO8zruVGEHaV3e8fFwBLRKM0Sc7e3aLECISsfYeC5ZbRRbpQ1KX+VQr3FBKAMzG4
l9Go7vZ+UcLKpQx2rVPTJt1vDnRV49X6CF2Q/lV9iafQ4MTy6ACdAloT1yfH/lhU
iWQo1qDyRCSlmNBDsYl8gLrwMp4gGQAv3imZHxnJF5ru3nUYGG0U08D5mf2sWv5P
Wh7By8Jm8bmaP8cUF86lO9BJXh2d9QN5jqrAtXqYzenZ+ABSoL1XrD/yv3270rH7
H4gAUtgP+vJ3uMyRu9055OC+ie/b613NojCW5nYN2QARAQABiQI8BBgBCgAmFiEE
GiNqklKNAN15ZXb+TWMlGMNUawUFAmXQ1o8CGwwFCQHhM4AACgkQTWMlGMNUawXh
7w/+KjbEWTwAhjm2HJ3w4tXtPC5URg+A+BzYYVH/q0+956c1QeD0LYafHBw4LEMI
lhRvHQnmzwjtY8v/DgmLOVDMiMWVHo0Q2iQyMvOT1WyEPcgOTJLhvyVzDqRZx7AS
B4G8uNVkKAdBZ7OSXAP27lR/2SEoG05esw8b7Y39pVtucC3aeiua+19PLJWadBjj
XuvXuSCho0km+nk4IgadYmxIDyiMeyKZ8wCl7CJkzECm83q2OtNsMe3k8lgEXybt
KlQxnYApZmhqLMV5ob8WOk3AgAVsif1m332CiEIb1Sfx6wt3nXy/410CXdDDucuj
ndJVfJ6Un33tn0irZ5scPA2HmzK1PGMfgOGtkM8B3LE/x8kEKeWKb3l9boB32Unm
iTfKgEna+JISEab3bzOPWdCQFB8LyGXuWlhtvqmRoX8GtiMRy/F4mzh+l3lYHjj3
4EvPVyippO5zwU+S9HElJ2G37K6zrOmd5cGBrw4aBDoO70QVrMN4O86uvC9kChDb
qyFF5UgXg29QxJjiSCv98ksDMqpJ5AFYrmrsBtwU64OANrxxJ4AZLQ1apYmG9RWD
VHZgfeI60FNBLfKwix9UffFT7piQ/MLrjSde8gPH5S6ezBMrYpfGEopaI9A5qXe3
LnHz88gfdmaBM77YDZM/p23nmCrUxlE3kkbgjTY8NRjYyF8=
=MkAH
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_ports_管理チーム書記_portmgr_secretaryfreebsd_org>D.1.3. ports 管理チーム書記 <code>&lt;<a href=mailto:portmgr-secretary@FreeBSD.org>portmgr-secretary@FreeBSD.org</a>></code><a class=anchor href=#_ports_管理チーム書記_portmgr_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   ed25519/E3C401F60D709D59 2023-03-06 [SC] [expires: 2027-03-05]
      Key fingerprint = BED4 A1D3 6555 B681 2E9F  ABDA E3C4 01F6 0D70 9D59
uid                            FreeBSD Ports Management Team Secretary &lt;portmgr-secretary@FreeBSD.org&gt;
sub   cv25519/2C92B55E27A641C3 2023-03-06 [E] [expires: 2027-03-05]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZAXJvxYJKwYBBAHaRw8BAQdASFAC20WL3R1T6uNyGMZbfJCxDkcP4C5vi3Op
tcZ2fbq0R0ZyZWVCU0QgUG9ydHMgTWFuYWdlbWVudCBUZWFtIFNlY3JldGFyeSA8
cG9ydG1nci1zZWNyZXRhcnlARnJlZUJTRC5vcmc+iJYEExYKAD4WIQS+1KHTZVW2
gS6fq9rjxAH2DXCdWQUCZAXJvwIbAwUJB4TOAAULCQgHAwUVCgkICwUWAwIBAAIe
BQIXgAAKCRDjxAH2DXCdWYN1AP43TjyfZtZ3DLYT++g0+SuPsoO/3yWVybA+UmFL
zb8MngEA+LLNUfvEwCuXS/soh+ww5bpfmi3UUmeGiQEAXug3iA+JATMEEAEKAB0W
IQT7N0XIbxXo7ayBMvzYKU7Du8TX1QUCZAXLkwAKCRDYKU7Du8TX1XHMB/9R1MX4
6zMgpKqPPt76GOI+eGEdBK6bY8aJZjQGdqTh9f6VtXVoTGIG7cvhc9X8tDBoB0PT
2KZWheF51AV1+NHU4HwLAQ1BMebrFvWSfkw4xg4fBGwDhz9/GN85No+Js772V5ey
8lRiL6meRVWxMlLyWcxGd8JjcC5yX/iAUQ3SBGCLqW7unWjjg7CTd+AMBwcqPGrv
ax8q6eFVguJcHJAjMnKf6HAy4cpK3s+uMoUBCGnszSN12B3ysKfyC4pNO/pix5tA
Q5v8aRqTeFPh5zmNhWo0KGPzplTPqRQSHDl7GDQC8Ru3MhzFkeWzHsexjZVwS6W2
DPcYpuuAsA0XOZIZiQIzBBABCgAdFiEEEBpxaxYrAOVb7eoFrbv4YQo3ibcFAmQF
0u0ACgkQrbv4YQo3ibccwg/9F2Xuic3nhKxRbB3mJeDo6SYQETa/Gh1qQ34+8zlt
8UMazOx67gnYQfy+pXjro6eQ2up0a4eUYezcNOudqAQD21nRz3HA6EQVNcE/TzEA
xl5CJntTaLOt7S+EDXFW5BuQIvhhoMGgm8+WNVgA0EJ7tfL0OcYBSvr19fqwChEn
9c14cSk6mgHSsleP5NvskYN053pxHwy0LTSb8YBBv52th37t/CRFC1363rS5q+D7
JixFopd1O5pKpA5ipvE4gGgRjPtwjx0SjjepwK/3fuhEJQQyKzTIKlMfu2Dj/iR2
Li1Sfccau5LQXOj9fUITU3u1YG7yrm8VGzT7ao4d+KRwgMLjd2pLqiGIbbJwGBiP
FRmtilWQoeIlmSlFX4obAA517DOK0pW1mH8+eEn4EJd3SekT3yzFyKTASv0J48Z8
3F928xg+eZvHxVC0t1J+J5IG0gt3EEncuWKIPQGR7PiQbti6R3FQVTz6WfMWOebP
Qi0E9F/Aqakr6Vj2sKGrDq+ebpaF5G8Yw1YrUl2IDiPzkCegp3ZbI0wh11Xvzhi8
LXPQGK4jBQas4G8cegfitzmtdGRHYrbMv0R9I4mvaL+WlOuD2AvyVG28lguqVhnN
AZP+ohdquYyX2CNCVvbKWAtXo6Ur0vWG8BL8m6defAtEkIwVBALaOHQOSI3aNUz4
lwy4OARkBcm/EgorBgEEAZdVAQUBAQdAsefmSfxEOdOr02+K/6noYCuJ1FeAWVz6
jFYQ+9w6jggDAQgHiH4EGBYKACYWIQS+1KHTZVW2gS6fq9rjxAH2DXCdWQUCZAXJ
vwIbDAUJB4TOAAAKCRDjxAH2DXCdWRl4AP9h5ot212BK29S6ZcMBhHvmtF5PG1oD
c7LnZycSRmbFiwEAndCMpAGOhDW8iVgDd0wLQq/ZMPe+xccfG1b3zFH2EgE=
=iiAT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_doceng_secretaryfreebsd_org>D.1.4. <code>&lt;<a href=mailto:doceng-secretary@FreeBSD.org>doceng-secretary@FreeBSD.org</a>></code><a class=anchor href=#_doceng_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa2048/E1C03580AEB45E58 2019-10-31 [SC] [expires: 2022-10-30]
      Key fingerprint = F24D 7B32 B864 625E 5541  A0E4 E1C0 3580 AEB4 5E58
uid                            FreeBSD Doceng Team Secretary &lt;doceng-secretary@freebsd.org&gt;
sub   rsa2048/9EA8D713509472FC 2019-10-31 [E] [expires: 2022-10-30]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQENBF27FFcBCADeoSsIgyQUY8vREwkTikwFFlNg31MVy5s/Nq1cNK1PRfRMnprS
yfB62KqbYuz16bmQKaA9zHN4FGfiTvR6tl66LVHm1s/5HPiLv8sP14GsruLro9zN
v72dO7a9i68bMw+jarPOnu9dGiDFEI0dACOkdCGEYKEUapQeNpmWRrQ46BeXyFwF
JcNx76bJJUkwk6fWC0W63D762e6lCEX6ndoaPjjLBnFvtx13heNGUc8RukBwe2mA
U5pSGHj47J05bdWiRSwZaXa8PcW+20zTWaP755w7zWe4h60GANY7OsT9nuOqsioJ
QonxTrJuZweKRV8fNQ1EfDws3HZr7/7iXvO3ABEBAAG0PEZyZWVCU0QgRG9jZW5n
IFRlYW0gU2VjcmV0YXJ5IDxkb2Nlbmctc2VjcmV0YXJ5QGZyZWVic2Qub3JnPokB
VAQTAQoAPhYhBPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsDBQkFo5qABQsJ
CAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEOHANYCutF5YB2IIALw+EPYmOz9qlqIn
oTFmk/5MrcdzC5iLEfxubbF6TopDWsWPiOh5mAuvfEmROSGf6ctvdYe9UtQV3VNY
KeeyskeFrIBOFo2KG/dFqKPAWef6IfhbW3HWDWo5uOBg01jHzQ/pB1n6SMKiXfsM
idL9wN+UQKxF3Y7S/bVrZTV0isRUolO9+8kQeSYT/NMojVM0H2fWrTP/TaNEW4fY
JBDAl5hsktzdl8sdbNqdC0GiX3xb4GvgVzGGQELagsxjfuXk6PfOyn6Wx2d+yRcI
FrKojmhihBp5VGFQkntBIXQkaW0xhW+WBGxwXdaAl0drQlZ3W+edgdOl705x73kf
Uw3Fh2a5AQ0EXbsUVwEIANEPAsltM4vFj2pi5xEuHEcZIrIX/ZJhoaBtZkqvkB+H
4pu3/eQHK5hg0Dw12ugffPMz8mi57iGNI9TXd8ZYMJxAdvEZSDHCKZTX9G+FcxWa
/AzKNiG25uSISzz7rMB/lV1gofCdGtpHFRFTiNxFcoacugTdlYDiscgJZMJSg/hC
GXBdEKXR5WRAgAGandcL8llCToOt1lZEOkd5vJM861w6evgDhAZ2HGhRuG8/NDxG
r4UtlnYGUCFof/Q4oPNbDJzmZXF+8OQyTNcEpVD3leEOWG1Uv5XWS2XKVHcHZZ++
ISo/B5Q6Oi3SJFCVV9f+g09YF+PgfP/mVMBgif2fT20AEQEAAYkBPAQYAQoAJhYh
BPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsMBQkFo5qAAAoJEOHANYCutF5Y
kecIAMTh2VHQqjXHTszQMsy3NjiTVVITI3z+pzY0u2EYmLytXQ2pZMzLHMcklmub
5po0X4EvL6bZiJcLMI2mSrOs0Gp8P3hyMI40IkqoLMp7VA2LFlPgIJ7K5W4oVwf8
khY6lw7qg2l69APm/MM3xAyiL4p6MU8tpvWg5AncZ6lxyy27rxVflzEtCrKQuG/a
oVaOlMjH3uxvOK6IIxlhvWD0nKs/e2h2HIAZ+ILE6ytS5ZEg2GXuigoQZdEnv71L
xyvE9JANwGZLkDxnS5pgN2ikfkQYlFpJEkrNTQleCOHIIIp8vgJngEaP51xOIbQM
CiG/y3cmKQ/ZfH7BBvlZVtZKQsI=
=MQKT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div></div></div></div></div><hr><div class=last-modified><p><strong>最終更新日</strong>: 2022年9月16日 by <a href="https://cgit.freebsd.org/doc/commit/?id=b4933bde48" target=_blank>Ryusuke SUZUKI</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目次</h3><nav id=TableOfContents><ul><li><a href=#book-preface>前書き</a><ul><li><a href=#preface-audience>想定している読者</a></li><li><a href=#preface-changes-from3>第 3 版からの変更</a></li><li><a href=#preface-changes-from2>第 2 版 (2004) からの変更</a></li><li><a href=#preface-changes>第 1 版 (2001) からの変更</a></li><li><a href=#preface-overview>この文書の構成</a></li><li><a href=#preface-conv>この文書で用いられている表記法</a></li><li><a href=#preface-acknowledgements>謝辞</a></li></ul></li><li><a href=#getting-started>Part I: 導入</a><ul><li><a href=#introduction>Chapter 1. はじめに</a></li><li><a href=#bsdinstall>Chapter 2. FreeBSD のインストール</a></li><li><a href=#basics>Chapter 3. FreeBSD の基礎知識</a></li><li><a href=#ports>Chapter 4. アプリケーションのインストール - packages と ports</a></li><li><a href=#x11>Chapter 5. X Window System</a></li></ul></li><li><a href=#common-tasks>Part II: 日々の生活</a><ul><li><a href=#desktop>Chapter 6. デスクトップアプリケーション</a></li><li><a href=#multimedia>Chapter 7. マルチメディア</a></li><li><a href=#kernelconfig>Chapter 8. FreeBSD カーネルのコンフィグレーション</a></li><li><a href=#printing>Chapter 9. プリンタの利用</a></li><li><a href=#linuxemu>Chapter 10. Linux® バイナリ互換機能</a></li></ul></li><li><a href=#system-administration>Part III: システム管理</a><ul><li><a href=#config-tuning>Chapter 11. 設定とチューニング</a></li><li><a href=#boot>Chapter 12. FreeBSD の起動のプロセス</a></li><li><a href=#security>Chapter 13. セキュリティ</a></li><li><a href=#disks>Chapter 14. ストレージ</a></li><li><a href=#l10n>Chapter 15. 地域化 (localization) - i18n/L10n の利用と設定</a></li><li><a href=#updating-upgrading>Chapter 16. FreeBSD のアップデートとアップグレード</a></li></ul></li><li><a href=#network-communication>Part IV: ネットワーク通信</a><ul><li><a href=#serialcomms>Chapter 17. シリアル通信</a></li><li><a href=#ppp-and-slip>Chapter 18. PPP と SLIP</a></li><li><a href=#mail>Chapter 19. 電子メール</a></li><li><a href=#advanced-networking>Chapter 20. 高度なネットワーク</a></li></ul></li><li><a href=#appendices>Part V: 付録</a><ul><li><a href=#_freebsd_の入手方法>付録 A: FreeBSD の入手方法</a></li><li><a href=#bibliography>付録 B: 参考図書</a></li><li><a href=#eresources>付録 C: インターネット上のリソース</a></li><li><a href=#pgpkeys>付録 D: PGP 公開鍵</a></li></ul></li></ul></nav><hr><div class=resources><h3>リソース</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="PDF 版のダウンロード"></i><a href=https://download.freebsd.org/doc/ja/books/handbook/handbook_ja.pdf>PDF 版のダウンロード</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/ja/book target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/ja/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>日本語</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/ja class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/ja/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>